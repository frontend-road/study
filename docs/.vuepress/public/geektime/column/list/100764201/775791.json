{"id":775791,"title":"01｜用OpenAI Assistants的Function进行订单管理","content":"<p>你好，我是黄佳。</p><p>从今天开始，我们开始大模型应用开发实战的启程篇。最简单的大模型应用开发工具应该就是OpenAI Assistants。不过虽然简单，但是它的功能超级强大。所以，在启程篇中我们先把这个工具讲透。<span class=\"reference\">（注意，在2024年四月中旬，OpenAI 发布了Assistants的Beta v2版本，我们的课程基于v2版本。）</span></p><p>先说说本课的学习目标，主要有两个：</p><ol>\n<li>完全掌握到底什么是OpenAI Assistants，怎么使用它。</li>\n<li>通过 Assistants提供的Function，把自然语言问答自动地转换成函数调用的元数据，并能够动态地选择合适的函数进行调用。其中，什么是函数调用的元数据，什么是动态调用，也许有一点难理解，不怕，学完本课就会清晰。</li>\n</ol><p>另外，这节课我会带你完成一个<strong>订单管理功能</strong>，只根据用户的对话，给他计算购物篮里面订单商品的总金额。</p><h2>OpenAI 的 Assistants 工具其实是个不错的 Agent</h2><p>吴恩达老师在他最新的演讲中，大谈特谈AI Agent，而且给出了下面四种Agent设计模式。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/a5/c387871a9d18302e64a81c56924987a5.png?wh=2154x1135\" alt=\"图片\"></p><p>这四种Agent实现模式分别是：</p><ol>\n<li>反思（Reflection）：Agent通过交互学习和反思来优化决策。</li>\n<li>工具使用（Tool use）：Agent 在这个模式下能调用多种工具来完成任务。</li>\n<li>规划（Planning）：在规划模式中，Agent 需要规划出一系列行动步骤来达到目标。</li>\n<li>多Agent协作（Multiagent collaboration）：涉及多个Agent之间的协作。</li>\n</ol><!-- [[[read_end]]] --><p>这些模式描绘了AI Agent在不同情境下的行为和功能实现，反映了在AI系统设计时需要考虑的多样化策略，<strong>更重要的是对大模型的思维方式进行了指引，相当于武装上了“先进思想”</strong>。</p><p>说回Assistants。OpenAI的Assistants工具是一种基于GPT模型的语言理解和生成平台。它旨在通过提供信息、解答问题、生成文本和执行特定任务来协助我们的日常工作，成为我们的小助手、好助理。</p><p></p><p>嗯，听到这里你会不会觉得OpenAI公司的这个Assistants有点Agent的意思。的确如此，Assistants工具特意被设计得十分灵活且多功能，可以应用于各种场景和用例，从简单的日常对话到复杂的技术问题解答。</p><p>而且，吴恩达老师提出的4种Agent设计模式，Assistants至少实现了其中的两种，甚至是三种（前三种）；而第四种呢，也可以<strong>在程序中通过创建多个</strong> <strong>Assistants</strong> <strong>来实现</strong>。为什么这么说，相信我们启程篇学完之后，你就会同意我的观点。</p><p></p><p>Assistants工具的主要特点如下：</p><ul>\n<li>高级语言理解：能够理解和处理自然语言输入，识别用户的意图和需求。</li>\n<li>丰富的文本生成：可以根据用户的指令生成连贯、相关且有用的文本回应。</li>\n<li>适应性和定制化：可以根据特定的应用场景和需求定制，以提供更加个性化的服务。</li>\n<li>交互性：能够进行连贯的对话，理解上下文，记住对话历史，以提供更加深入和有连续性的交互体验。</li>\n<li>易于集成：可以被集成到各种平台和应用中，如网站、应用程序或其他数字服务。</li>\n</ul><p>所以呢，Assistants工具的应用可以是非常广泛的，例如客服自动化、个人助理、教育、内容创作、编程辅助等多个领域。而且，通过不断学习和适应，它也在进步，变得越来越高效、灵活且智能。</p><p>以我使用Assistants的直观感受来说，我觉得，这个工具的确做到了简单易用。智能程度也不错，听指挥，<strong>能够完成一系列的办公自动化任务</strong>。</p><p></p><p>我们甚至都不需要具有编程能力，就能使用强大的Assistants。当然，你得先拥有OpenAI API的账号和密钥，这是学习我们这个课程的基础。</p><p>这就带着你实操一下，感受这个工具的魅力。</p><h2>在 OpenAI 的 Playground 中试用 Assistants</h2><p>OpenAI 公司给我们提供了一个 <a href=\"https://platform.openai.com/playground\">Playground</a>，这个Playground&nbsp;是探索并学习在不编写任何代码的情况下构建自己的Assistants 的好方法。你可以通过这个平台运行指令和代码，使用 GPT-4， 甚至是最新的GPT-4o模型（GPT-4o模型的特点是又好又快）辅助完成 AI 应用、机器学习或数据科学相关的任务。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/be/dd3eb2bac3705a770e894f67773e23be.png?wh=2987x561\" alt=\"图片\" title=\"在 Playground 中用 Chat 功能比较 gpt-4o 和 gpt-4\"></p><p>Playground 里面的项目不少，有 Assistants，还有 Chat（对话）功能、Compare（对比不同模型对同一提示的响应）功能和 Completions（文本完成，是旧版的 Chat，已经过时了）等功能。</p><h3>新建一个 Assistant</h3><p>我们在右侧Playground下方选择 Assistants， 并把这个 Assistants 命名为“订单价格计算器”。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/0d/4cd2b8f058a824184a7874c288eec10d.png?wh=2133x1434\" alt=\"图片\"></p><p>指定我们要创建的Assistant的名称以及说明：“可以帮助客户计算当前购物车的商品总价”，并选择模型，之后保存，这个Assistant就创建好了，它拥有ChatGPT的全部功能，我们可以和它对话，输入你的Message后，单击屏幕右下方的Run，它就会根据自己拥有的知识进行回答。</p><p>在Playground中创建了这个Assistant之后，单击屏幕右方（Playground图标下方）的Assistants选项，你就会看到你所创建的所有Assistants列表。现在让我们记录下Agent的ID，以备后面程序中启用它。</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/f7/4baf9a20b0ae1b3c580eb5c347d963f7.png?wh=1046x680\" alt=\"图片\"></p><p>这个列表，包括你在Playground和程序中创建的所有Assistant。</p><h3>Assistant 中的可用工具</h3><p>此时，你肯定会问，如果这个Assistant和ChatGPT一样，那又有什么特别之处呢？为何不直接调用GPT模型的API来完成任务呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/4c/a09d8cc265059af89c724b543bbc9b4c.png?wh=853x405\" alt=\"图片\"></p><p>答案就是图中的这三种Tools，就是工具，其实就是你的Assistants 可以调用的功能。看到此处，你是否就直接联想到了吴恩达老师提出的第二种Agent模式：<strong>Tool use</strong>。</p><p>现在，OpenAI 不仅为我们的 Assistant 提供了强大的GPT模型，还提供了三种工具，它们分别是 File search、Code Interpreter 和 Functions。它们允许Assistant执行特定的任务、编写和运行代码、检索文档信息，<strong>大大扩展了</strong> <strong>Assistant</strong> <strong>的应用场景</strong>。</p><p>能够调用工具了！这就使OpenAI Assistant不再仅仅是一个聊天机器人，而是成为了一个功能强大、适应性强的AI助手。——它进化了！</p><p>具体来说：</p><ul>\n<li>Functions（函数）： Functions允许开发者定义自己的函数，并让Assistant在对话中动态调用这些函数。这使得Assistant能够执行特定的计算、数据处理、外部API调用等任务，并将结果返回给用户。例如，我们可以定义一个计算订单总价的函数，当用户询问订单价格时，Assistant可以调用这个函数，并将计算结果告诉用户。Functions使Assistant能够与外部系统和服务进行交互，能够执行代码，完成具体功能。</li>\n<li>Code Interpreter（代码解释器）：Code Interpreter非常强大，它允许Assistant编写、运行和解释代码。这使得Assistant能够完成数据分析、数据可视化、自动化任务等复杂的编程工作。例如，你可以上传一个包含销售数据的CSV文件，并请求Assistant生成一个销售报告，进行数据分析，生成可视化图表，并将报告返回给用户。</li>\n<li>File search（检索）：File search是文档检索工具，它允许Assistant从一组预先上传的文档中检索信息，并根据用户的询问提供相关的答案。使用这个工具，我们可以将产品手册、FAQ、知识库等各种文档上传到Assistant中，当用户提出问题时，Assistant可以自动在这些文档中搜索答案，并将最相关的信息返回给用户。</li>\n</ul><p>未来，Open AI 公司还计划发布更多的工具，并允许我们作为开发者，在 OpenAI 网站上提供开发者自己定义的工具，那么Assistant的能力将变得更加强大和灵活。</p><h3>在 Assistant 中添加 Function</h3><p>下面，我们在Assistant中添加Function，来完成一个购物车订单总价计算的功能。</p><p>第一步，是选择+Function图标，添加Function的定义。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/37/826576393d157705506c6bd6819fbe37.png?wh=477x127\" alt=\"图片\"></p><p>第二步，则是添加功能的调用说明，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/9b/3b058c956d523ee55d3f3511c9cbc79b.png?wh=955x1293\" alt=\"图片\"></p><p>文本如下：</p><pre><code class=\"language-plain\">{\n&nbsp; \"name\": \"calculate_order_total\",\n&nbsp; \"description\": \"根据多个商品类型和数量计算订单总价\",\n&nbsp; \"parameters\": {\n&nbsp; &nbsp; \"type\": \"object\",\n&nbsp; &nbsp; \"properties\": {\n&nbsp; &nbsp; &nbsp; \"items\": {\n&nbsp; &nbsp; &nbsp; &nbsp; \"type\": \"array\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"items\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"type\": \"object\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"properties\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"item_type\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"type\": \"string\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"description\": \"商品类型,例如:书籍,文具,电子产品\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"quantity\": {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"type\": \"integer\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"description\": \"商品数量\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"required\": [\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"item_type\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"quantity\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; },\n&nbsp; &nbsp; \"required\": [\n&nbsp; &nbsp; &nbsp; \"items\"\n&nbsp; &nbsp; ]\n&nbsp; }\n}\n</code></pre><p>此处的这个调用说明需要特别解释，<strong>因为</strong> <strong>Function</strong> <strong>的说明和实际的函数代码有着本质的区别</strong><strong>，</strong><strong>很容易混淆</strong>。让我来详细解释一下它们的不同之处。</p><p>Function的说明，如图中所示，是一个JSON格式的对象，用于向Assistant描述一个自定义函数，也叫做<strong>描述函数的元数据</strong>。这个JSON对象包含了函数的名称（name）、描述（description）、参数（parameters）等元数据信息。它的作用是让Assistant了解这个函数的功能、输入参数的类型和格式，以及哪些参数是必需的。但是，这个JSON对象本身并不包含函数的实现代码。</p><p>例如，图中的JSON对象描述了一个名为 “calculate_order_total” 的函数，它的作用是“根据多个商品类型和数量计算订单总价”，它接受一个名为 “items” 的参数，该参数是一个数组，数组中的每个元素都是一个包含 “item_type” 和 “quantity” 属性的对象。</p><p>而实际的函数代码，则是这个函数的具体实现，它定义了函数如何处理输入参数、执行计算、返回结果等细节。函数代码是用编程语言（如Python、JavaScript等）编写的，而不是JSON格式。</p><p>例如，对应于上述JSON描述的 “calculate_order_total” 函数，其实际的Python实现代码可能如下：</p><pre><code class=\"language-plain\">def calculate_order_total(items):\n    item_prices = {\n        \"书籍\": 10,\n        \"文具\": 5,\n        \"电子产品\": 100\n    }\n    total_price = 0\n    for item in items:\n        price_per_item = item_prices.get(item['item_type'], 0)\n        total_price += price_per_item * item['quantity']\n    return total_price\n</code></pre><p>这个Python函数接受一个 “items” 参数，遍历其中的每个商品，根据商品类型查找单价，累加计算总价，并返回结果。不过，这个函数的具体Python代码我们没必要让Assistants知道（它只需要知道函数的元数据，也就是调用格式和接口），具体Python代码是在下一步的应用程序中，我们才需要加入的内容。</p><p>因此，再次强调一次：<strong>刚才在</strong> <strong>Playground</strong> <strong>中添加的</strong> <strong>Function</strong> <strong>的说明</strong>（JSON对象）<strong>和实际的函数代码有着明确的区别</strong><strong>。</strong></p><ul>\n<li>Function的说明是一个JSON对象，用于向Assistant描述函数的元数据，如函数名称、参数类型等，但不包含函数的实现代码。</li>\n<li>实际的函数代码是用编程语言编写的，它定义了函数的具体实现细节，如何处理输入参数、执行计算、返回结果等。</li>\n</ul><p>在使用Function calling时，我们需要先提供函数的JSON描述，Assistant了解函数的接口定义。然后在代码中实现对应的函数。当Assistant在对话中决定调用该函数时，它会根据JSON描述生成一个包含具体参数值的JSON对象——这也就是<strong>函数调用的元数据</strong>，我们的代码需要解析这个JSON对象，提取参数值，调用相应的函数，并将结果返回给Assistant。</p><p>如果你还没有完全弄懂这个流程也不要紧，我们马上就实现这个流程。</p><h2>在程序中调用 Assistant</h2><p>下面，我就带着你在程序中调用这个刚刚创建的Assistant，来真真实实地完成一个购物篮订单金额的计算工具。</p><p>我们首先通过刚才记录下来的ID检索了之前创建的Assistant。</p><h3>检索到并获取 Assistant</h3><pre><code class=\"language-plain\"># 检索您之前创建的Assistant\nassistant_id = \"asst_FXoBJo1KlqfpCCKvNIoCyJHB\"&nbsp; # 你自己的助手ID\nassistant = client.beta.assistants.retrieve(assistant_id)\nprint(assistant)\n</code></pre><h3>创建 Thread，与 Assistant 对话</h3><p>然后创建一个新的Thread，并向Thread添加了用户的消息，请求Assistant计算订单总价。所谓Thread，就是你和GPT的一次会话Session，我们下一课还会细讲它。</p><pre><code class=\"language-plain\"># 创建一个线程并同时创建消息\nthread = client.beta.threads.create(\n&nbsp; messages=[\n&nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; \"role\": \"user\",\n&nbsp; &nbsp; &nbsp; \"content\": \"你好,我购买了一本书和一个电子产品,请帮我计算一下订单总价！\",\n&nbsp; &nbsp; }\n&nbsp; ]\n)\nprint(thread)\n</code></pre><h3>创建 Run，运行对话</h3><p>接下来，我们创建一个新的Run，让Assistant处理这个Thread。在Assistant处理Thread的过程中，需要轮询Run的状态，直到状态变为requires_action（需要调用函数）或completed（对话完成）。</p><p>为了方便轮询，OpenAI给出了一个create_and_poll函数。（关于Run的状态转换流程，我们下节课详细介绍）</p><pre><code class=\"language-plain\">run = client.beta.threads.runs.create_and_poll(\n&nbsp; thread_id=thread.id,\n&nbsp; assistant_id=assistant.id,\n&nbsp; # instructions=\"You are a personal math tutor. When asked a math question, write and run code to answer the question.\"\n)\nrun\n</code></pre><p>输出如下：</p><pre><code class=\"language-plain\">Run(id='run_fMy4vfnomLy0MCwvrpZ5t607', assistant_id='asst_FXoBJo1KlqfpCCKvNIoCyJHB', cancelled_at=None, completed_at=None, created_at=1713628399, expires_at=1713628999, failed_at=None, incomplete_details=None, instructions='通过Function帮我计算购物篮金额总额', last_error=None, max_completion_tokens=None, max_prompt_tokens=None, metadata={}, model='gpt-4-turbo', object='thread.run', required_action=RequiredAction(submit_tool_outputs=RequiredActionSubmitToolOutputs(tool_calls=[RequiredActionFunctionToolCall(id='call_q0pARrPzUwNVHkxGPJpOTsEv', function=Function(arguments='{\"items\":[{\"item_type\":\"书籍\",\"quantity\":1},{\"item_type\":\"电子产品\",\"quantity\":1}]}', name='calculate_order_total'), type='function')]), type='submit_tool_outputs'), response_format='auto', started_at=1713628399, status='requires_action', thread_id='thread_AJgbyuG0yJjFaHWP30pwfnzX', tool_choice='auto', tools=[FunctionTool(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')], truncation_strategy=TruncationStrategy(type='auto', last_messages=None), usage=None, temperature=1.0, top_p=1.0, tool_resources={})\n</code></pre><p>create_and_poll函数会不断检查Run的状态，并打印Run的详细信息。当Run的状态变为requires_action或completed时，函数返回最新的Run对象。</p><h3>读取 Run 返回的元数据</h3><p><strong>当Run的状态变为requires_action时，意味着Assistant需要调用一个函数来完成任务。</strong>我们需要从Run中提取函数调用的元数据信息，包括函数名、参数和ID。为此，我们定义了一个get_function_details函数。</p><pre><code class=\"language-plain\"># 读取function元数据信息\ndef get_function_details(run):\n    function_name = run.required_action.submit_tool_outputs.tool_calls[0].function.name\n    arguments = run.required_action.submit_tool_outputs.tool_calls[0].function.arguments\n    function_id = run.required_action.submit_tool_outputs.tool_calls[0].id\n    return function_name, arguments, function_id\n\n# 读取并打印元数据信息\nfunction_name, arguments, function_id = get_function_details(run)\nprint(\"function_name:\", function_name)\nprint(\"arguments:\", arguments)\nprint(\"function_id:\", function_id)\n</code></pre><p>输出如下：</p><pre><code class=\"language-plain\">function_name: calculate_order_total\narguments: {\"items\":[{\"item_type\":\"书籍\",\"quantity\":1},{\"item_type\":\"电子产品\",\"quantity\":1}]}\nfunction_id: call_UPLImNhob6s1XoQ9npdtT3Zh\n</code></pre><p>可以看到，此处get_function_details函数从Run的required_action中提取到了所有函数调用相关的元数据信息，包括函数名（calculate_order_total）、JSON格式的参数（{“item_type”:“书籍”,“quantity”:1},{“item_type”:“电子产品”,“quantity”:1}]}）和函数ID（call_UPLImNhob6s1XoQ9npdtT3Zh）。</p><p>这里就是Assitant非常聪明的地方。</p><p><span class=\"orange\">请注意，经过了Run中的Function处理，你的智能助理成功地把自然语言</span></p><pre><code> &quot;你好,我购买了一本书和一个电子产品，请帮我计算一下订单总价！&quot;\n</code></pre><p><span class=\"orange\">转换成了函数能够读懂的语言</span></p><pre><code>{&quot;item_type&quot;:&quot;书籍&quot;,&quot;quantity&quot;:1},{&quot;item_type&quot;:&quot;电子产品&quot;,&quot;quantity&quot;:1}\n</code></pre><p>还记得吧，这些就是我们在Playground的Function元数据中通过JSON格式定义的内容。这就是动态调用函数的基础！<strong>我们不需要硬性指定函数，Assitants会动态的帮咱们选择函数，同时确定每一个参数的传入数据值</strong>。</p><p>接下来，我们需要根据函数名和参数，动态调用相应的函数。此时，我们终于需要调用程序中的calculate_order_total函数来计算订单总价了。</p><pre><code class=\"language-plain\"># 定义计算订单总价函数\ndef calculate_order_total(items):\n    item_prices = {\n        \"书籍\": 10,\n        \"文具\": 5,\n        \"电子产品\": 100\n    }\n    total_price = 0\n    for item in items:\n        price_per_item = item_prices.get(item['item_type'], 0)\n        total_price += price_per_item * item['quantity']\n    return total_price\n\n# 根据Assistant返回的参数动态调用函数\nimport json\n\n# 将 JSON 字符串转换为字典\narguments_dict = json.loads(arguments)\n\n# 调用函数\norder_total = globals()[function_name](**arguments_dict)\n\n# 打印结果以进行验证\nprint(f\"订单总价为: {order_total} 元\")\n</code></pre><p>输出如下：</p><pre><code class=\"language-plain\">订单总价为: 110 元\n</code></pre><p>这里定义了calculate_order_total函数，用于根据商品类型和数量计算订单总价。然后使用 <code>json.loads</code> 将JSON格式的参数转换为Python字典并使用 <code>globals()[function_name](**arguments_dict)</code> 动态调用函数，并将结果存储在order_total变量中。打印订单总价以进行验证，结果无误。</p><p><strong>计算完订单总价后，还没有完，还需要将结果提交给Assistant，以便它继续处理Thread</strong>。为此，我们定义了一个submit_tool_outputs函数。</p><pre><code class=\"language-plain\"># 提交结果\nrun = client.beta.threads.runs.submit_tool_outputs(\n&nbsp; &nbsp; thread_id=thread.id,\n&nbsp; &nbsp; run_id=run.id,\n&nbsp; &nbsp; tool_outputs=[\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"tool_call_id\": function_id,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"output\": str(order_total),\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; ]\n)\nprint(\"提交结果之后Run的状态\", run)\n</code></pre><p>输出如下：</p><pre><code class=\"language-plain\">提交结果之后Run的状态 Run(id='run_uznnPaD3mtaJyuiBvX1UFN6a', assistant_id='asst_aT4hurwd35eSave7qrt2t6eJ', cancelled_at=None, completed_at=None, created_at=1711952239, expires_at=1711952839, failed_at=None, file_ids=[], instructions='可以帮助客户计算当前购物车的商品总价', last_error=None, metadata={}, model='gpt-4-1106-preview', object='thread.run', required_action=None, started_at=1711952240, status='completed', thread_id='thread_9ebLw6qbZCbB6uj9iabMVmSI', tools=[ToolAssistantToolsFunction(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')], usage=None, temperature=1.0)\n</code></pre><p>submit_tool_outputs函数将函数调用的结果提交给Assistant，包括函数ID和输出。<strong>提交结果后，Run的状态会变为completed，表示Assistant终于完成了任务。</strong></p><p>最后，我们再次轮询Run的状态，直到任务完全结束，然后获取Assistant在Thread中的最终回应。</p><pre><code class=\"language-plain\"># 再次轮询Run直至完成\nrun = client.beta.threads.runs.poll(thread_id=thread.id, run_id=run.id)\n\n# 获取Assistant在Thread中的回应\nmessages = client.beta.threads.messages.list(\n    thread_id=thread.id\n)\nprint(\"全部的message\", messages)\n\n# 输出Assistant的最终回应\nprint('下面打印最终的Assistant回应:')\nfor message in messages.data:\n    if message.role == \"assistant\":\n        print(f\"{message.content}\\n\")\n</code></pre><p>输出如下：</p><pre><code class=\"language-plain\">全部的message ThreadMessageList(data=[ThreadMessage(id='msg_mMvOUiL7Ibt0txNvSnXaxiUt', assistant_id=None, content=[MessageCon\n[MessageContentText(text=Text(annotations=[], value='您的订单总价为110元。'), type='text')]\n</code></pre><p>至此，整个程序就结束了。这个示例展示了如何在程序中调用OpenAI Assistant，以及使用Function calling功能完成一个简单的订单总价计算任务。你可以参考这个示例的结构和逻辑，设计并实现更加复杂的Assistant交互流程，以满足你所需要的、更实际的业务场景的需求。</p><h2>在程序中创建 Assistant</h2><p>好的，至此，今天的目标任务已经顺利完成。不过，最后，我还想补充一点内容，以便让你掌握全局。</p><p>刚才，我们的程序是调用了在Playground中创建的Assistant，然而在项目实战中，创建Assistant的工作当然是在程序中完成的。我将用client.beta.assistants.create方法创建一个新的Assistant，并将calculate_order_total这个函数的元数据（JSON格式）添加到Assistant的工具列表中。</p><p>以下是代码实现：</p><pre><code class=\"language-plain\">from openai import OpenAI\n\nclient = OpenAI()\n\nassistant = client.beta.assistants.create(\n    instructions=\"您是一个订单助手。请使用提供的函数来计算订单总价并回答问题。\",\n    model=\"gpt-4-1106-preview\",\n    tools=[{\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"calculate_order_total\",\n            \"description\": \"根据多个商品类型和数量计算订单总价\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"items\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"item_type\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"商品类型,例如:书籍,文具,电子产品\"\n                                },\n                                \"quantity\": {\n                                    \"type\": \"integer\",\n                                    \"description\": \"商品数量\"\n                                }\n                            },\n                            \"required\": [\n                                \"item_type\",\n                                \"quantity\"\n                            ]\n                        }\n                    }\n                },\n                \"required\": [\n                    \"items\"\n                ]\n            }\n        }\n    }]\n)\n\nprint(assistant)\n</code></pre><p>这里首先导入OpenAI类并创建一个客户端对象。然后创建一个新的Assistant。在创建Assistant时，我们提供了以下参数.</p><ul>\n<li>instructions：给Assistant的指令，告诉它作为一个订单助手，使用提供的函数计算订单总价并回答问题。</li>\n<li>model：使用的语言模型，这里使用 “gpt-4-1106-preview”。</li>\n<li>tools：一个包含函数定义的列表。在这个例子中，我们只提供了一个函数calculate_order_total，它的定义与我们在Playgound中指定的JSON格式的元数据信息完全一致。</li>\n</ul><p>创建Assistant后，我们将其打印出来，以便查看新创建的Assistant的详细信息。</p><p>输出如下：</p><pre><code class=\"language-plain\">\nAssistant(id='asst_123abc', created_at=1711126020, description=None, file_ids=[], \ninstructions='您是一个订单助手。请使用提供的函数来计算订单总价并回答问题。', metadata={}, model='gpt-4-1106-preview', \nname=None, object='assistant', tools=[ToolFunction(function=FunctionDefinition(name='calculate_order_total', \ndescription='根据多个商品类型和数量计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', \n'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, \n'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, \n'required': ['items']}), type='function')])\n</code></pre><p>这表明一个新的Assistant已经成功创建，并且包含了我们定义的calculate_order_total函数作为其工具。</p><p>现在，你就可以使用这个新的Assistant来处理用户的订单查询，它也将使用calculate_order_total函数计算订单总价，并提供相应的回答。这个Assistant与我们在Playground中创建的完全相同。</p><h2>总结时刻</h2><p>上面就是我们今天这节课的全部内容。你看见了Assistants中各种工具开始亮相并大显身手，其中 Functions 是自定义的函数，Code interpreter 是一个代码解释工具，而 File search则是文档检索工具。</p><p><strong>这些工具，使得</strong> <strong>Assistant</strong> <strong>跨越了仅仅是</strong> <strong>Chatbot</strong> <strong>的鸿沟，变身为一个能够实际执行任务、解决问题的智能助手，在各个领域都有广泛的应用前景</strong>。</p><p>我们通过Planground和API，分别创建了Assitant。之后，我在其中添加了一个名为 “calculate_order_total” 的Function，提供了详细的调用说明（Function calling），并特别强调了<strong>描述函数的元数据与实际函数代码的区别</strong>，避免混淆。</p><p>通过Assitant，我们把自然语言问答，自动地转换成了函数调用的参数，并能够动态地选择合适的函数进行调用<span class=\"orange\">（文章的红字部分）</span>。—— 这就是这节课的精髓。</p><p>之后，在Python程序中，通过调用OpenAI的API，我们用创建的Assistant来计算购物篮订单的总价。这个过程包括创建Thread、添加用户消息、创建Run、轮询Run状态、提取函数元数据、动态调用函数、提交函数结果等步骤，最终得到了以自然语言呈现的订单查询结果。</p><h2>思考题</h2><p>以下是几个思考题，可以帮助你进一步巩固和扩展今天学到的内容。</p><ol>\n<li>除了订单总价计算，你还能想到哪些场景可以运用Functions功能？尝试为这些场景设计合适的Function calling说明。</li>\n<li>在示例程序中，我们只实现了一个函数，也就是calculate_order_total，你能否根据自己思考到的业务场景，增加两个其它函数。然后，你的Assistant应该能够根据具体问题（用户的对话），来自动选择合适的函数进行调用。</li>\n<li>在示例程序中，我们使用了一个简单的商品价格字典来计算订单总价。在实际项目中，这些数据当然来自数据库或外部API。请尝试修改程序，从外部数据源获取商品价格信息。</li>\n<li>OpenAI给出的 <a href=\"https://platform.openai.com/docs/assistants/overview\">Assistants</a> 官方文档，质量其实也是非常不错的，我也建议你去阅读一下，作为学习过程中查漏补缺的基本指南。</li>\n</ol><p>期待你的思考，欢迎在评论区与我交流。如果今天的内容让你有所收获，也欢迎你把这节课转发给有需要的朋友！我们下节课再见！</p>","neighbors":{"left":{"article_title":"开篇词｜大模型应用开发时代，人人都是程序员","id":775779},"right":{"article_title":"02｜OpenAI Assistants中的线程和Run状态解析","id":776589}},"comments":[{"had_liked":false,"id":390965,"user_name":"Geek_9948a5","can_delete":false,"product_type":"c1","uid":1363593,"ip_address":"浙江","ucode":"7DDAF4A21EA1FC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLFvhaPbJ1sBZqr8GQRVDiaxsicukAETVzjqmBRba2WqibbmX3NmoPIkaNEnBvyaWobyCjGN0FJgGnKQ/132","comment_is_top":false,"comment_ctime":1716895846,"is_pvip":false,"replies":[{"id":142222,"content":"它就是一个Agent，而且是做的很不错的Agent。\n\n最主要的区别是封装程度：\n1. LangChain是开源框架，里面的ReAct等等逻辑我们看得到，可调试\n2. OpenAI Assistant是闭源产品，功能强大，我们拿来就用。\n\n万一我们对OpenAI Assistant的某个功能强烈不满，要么我们去论坛反馈，建议它们增加或改进，否则我们只好去拿LangChain这种开源框架，参考它的代码，自己搭建Agent，自己修改内部逻辑。——但是我们自己搭建的Agent也许比OpenAI Assistant Bug更多。—— 目前大概可以这样理解。\n","user_name":"作者回复","user_name_real":"作者","uid":1809833,"ctime":1717081313,"ip_address":"新加坡","comment_id":390965,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"这里的Assistant 本质是不是就是一个agent？\n就像老师之前的langchain课程中所讲，我们也可以基于langchain+react框架 搭建一个具备调用外部工具的agent。\n那么Assistant 和基于langchain搭建的agent的主要区别是什么呢？","like_count":2,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646000,"discussion_content":"它就是一个Agent，而且是做的很不错的Agent。\n\n最主要的区别是封装程度：\n1. LangChain是开源框架，里面的ReAct等等逻辑我们看得到，可调试\n2. OpenAI Assistant是闭源产品，功能强大，我们拿来就用。\n\n万一我们对OpenAI Assistant的某个功能强烈不满，要么我们去论坛反馈，建议它们增加或改进，否则我们只好去拿LangChain这种开源框架，参考它的代码，自己搭建Agent，自己修改内部逻辑。——但是我们自己搭建的Agent也许比OpenAI Assistant Bug更多。—— 目前大概可以这样理解。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717081313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390893,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":2029231,"ip_address":"广东","ucode":"00EA02C1F80DCD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f6/af/17886a09.jpg","comment_is_top":false,"comment_ctime":1716615391,"is_pvip":false,"replies":[{"id":142213,"content":"第03课中有提供链接：https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;777441\n可以在我的github找到：huangjia2019 - Repo: powerful_llm\n入群后也有这个代码的链接。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717079521,"ip_address":"新加坡","comment_id":390893,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"能提供完成的代码吗 ，，你提供的代码片段跑不起来","like_count":1,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645988,"discussion_content":"第03课中有提供链接：https://time.geekbang.org/column/article/777441\n可以在我的github找到：huangjia2019 - Repo: powerful_llm\n入群后也有这个代码的链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717079521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390798,"user_name":"陈东","can_delete":false,"product_type":"c1","uid":2213995,"ip_address":"广西","ucode":"FCDE6D237CC621","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ge7uhlEVxicQT73YuomDPrVKI8UmhqxKWrhtO5GMNlFjrHWfd3HAjgaSribR4Pzorw8yalYGYqJI4VPvUyPzicSKg/132","comment_is_top":false,"comment_ctime":1716303152,"is_pvip":true,"replies":[{"id":142137,"content":"很好的补充！就是这个意思，系统越来越复杂的时候，对Assistant的真正考验就来了。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1716453805,"ip_address":"新加坡","comment_id":390798,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"除了计算订单总额之外，还可以实现以下两个函数：\n\n1. `apply_discount(order_total, discount_percentage)`: 该函数用于计算订单总额中的折扣金额。用户可以提供订单总额和折扣百分比，函数会返回应用折扣后的订单总额。\n\n```python\ndef apply_discount(order_total, discount_percentage):\n    discount_amount = order_total * discount_percentage &#47; 100\n    discounted_total = order_total - discount_amount\n    return discounted_total\n```\n\n2. `calculate_shipping_cost(order_weight, shipping_rate)`: 这个函数用于计算订单的运输成本。用户可以提供订单的重量和每磅运输费用，函数将返回订单的运输总成本。\n\n```python\ndef calculate_shipping_cost(order_weight, shipping_rate):\n    shipping_cost = order_weight * shipping_rate\n    return shipping_cost\n```\n\n通过这两个新的函数，可以更全面地处理网上商店的订单相关功能。在具体对话中，根据用户的需求，我会自动选择调用合适的函数来满足用户的要求。","like_count":1,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645629,"discussion_content":"很好的补充！就是这个意思，系统越来越复杂的时候，对Assistant的真正考验就来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716453805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391222,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1402511,"ip_address":"广东","ucode":"6E31908EFE1107","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/8f/02be926d.jpg","comment_is_top":false,"comment_ctime":1717637851,"is_pvip":false,"replies":[{"id":142261,"content":"兄弟，你好。在最新的OpenAI文档中，指出了三个选项，可以帮助我们设置一下GPT在Function Call时候的行为模式\nhttps:&#47;&#47;platform.openai.com&#47;docs&#47;guides&#47;function-calling\n自动选择功能 (tool_choice: &quot;auto&quot;)：默认行为：模型会根据需要自行决定是否调用函数以及调用哪些函数。\n强制调用一个或多个函数 (tool_choice: &quot;required&quot;)：行为：模型会选择调用一个或多个函数，而不是生成直接面向用户的消息。用途：当希望模型总是执行某些操作而不是生成消息时使用。\n强制调用特定函数 (tool_choice: {&quot;type&quot;: &quot;function&quot;, &quot;function&quot;: {&quot;name&quot;: &quot;my_function&quot;}})：行为：模型只会调用指定的某个特定函数。用途：当希望模型调用特定功能，而不是其他任何功能或生成消息时使用。\n禁用函数调用 (tool_choice: &quot;none&quot;)：行为：模型只生成面向用户的消息，不会调用任何函数。\n用途：当您希望模型仅生成自然语言回复，而不调用任何函数时使用。\n\n这些选项可以帮助你灵活的根据场景来配置函数。但是怎么选？那么，要基于你具体业务场景定。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717646818,"ip_address":"新加坡","comment_id":391222,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"佳哥好，让大模型从一组函数中选择一个，并精确地指定每个参数，是否有适用的边界？什么时候该选择大模型模糊调用，什么时候该选择传统编程实现精确调用？如果大模型调用函数失败，除了给定一个默认函数，有什么方法能调优调用函数的手段吗，让不成功变得成功。","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646248,"discussion_content":"兄弟，你好。在最新的OpenAI文档中，指出了三个选项，可以帮助我们设置一下GPT在Function Call时候的行为模式\nhttps://platform.openai.com/docs/guides/function-calling\n自动选择功能 (tool_choice: &#34;auto&#34;)：默认行为：模型会根据需要自行决定是否调用函数以及调用哪些函数。\n强制调用一个或多个函数 (tool_choice: &#34;required&#34;)：行为：模型会选择调用一个或多个函数，而不是生成直接面向用户的消息。用途：当希望模型总是执行某些操作而不是生成消息时使用。\n强制调用特定函数 (tool_choice: {&#34;type&#34;: &#34;function&#34;, &#34;function&#34;: {&#34;name&#34;: &#34;my_function&#34;}})：行为：模型只会调用指定的某个特定函数。用途：当希望模型调用特定功能，而不是其他任何功能或生成消息时使用。\n禁用函数调用 (tool_choice: &#34;none&#34;)：行为：模型只生成面向用户的消息，不会调用任何函数。\n用途：当您希望模型仅生成自然语言回复，而不调用任何函数时使用。\n\n这些选项可以帮助你灵活的根据场景来配置函数。但是怎么选？那么，要基于你具体业务场景定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717646818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391072,"user_name":"良记","can_delete":false,"product_type":"c1","uid":1033503,"ip_address":"上海","ucode":"F78CC56BB32D8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/1f/8e9ee163.jpg","comment_is_top":false,"comment_ctime":1717229244,"is_pvip":false,"replies":[{"id":142250,"content":"这个function的服务位置是在Assistant之外配置的，在Function内部逻辑中实现的。对于Assistant，这相当于是黑盒。Assistant只需要知道调用Function，能解决这个任务即可。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717498847,"ip_address":"新加坡","comment_id":391072,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"Assistant 是怎么知道要调用服务的地址的？一开始的function就定义了函数的元数据，那么实现这个function的服务位置又应该在哪里配置？","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646178,"discussion_content":"这个function的服务位置是在Assistant之外配置的，在Function内部逻辑中实现的。对于Assistant，这相当于是黑盒。Assistant只需要知道调用Function，能解决这个任务即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717498848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391001,"user_name":"Geek_zbvt62","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"天津","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","comment_is_top":false,"comment_ctime":1716989566,"is_pvip":false,"replies":[{"id":142218,"content":"好的，同学我看到你自己回复问题已经解决。\n在第03课中有提供代码和数据集的链接：https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;777441\n也可以在我的github找到：huangjia2019 - Repo: powerful_llm\n入群后也有提供这个代码的链接。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717080614,"ip_address":"新加坡","comment_id":391001,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"1. 请问完整的代码在哪里？\n我在执行时，有一定几率出现异常：\n    function_name = run.required_action.submit_tool_outputs.tool_calls[0].function.name\n    AttributeError: &#39;NoneType&#39; object has no attribute &#39;submit_tool_outputs&#39;\n通过 print(run.status) 打印状态，发现是complete而不是required_action...\n这和api的limit有关系么(我没有调用很频繁)？亦或者和网络有关？在什么情况下会直接得到一个complete的状态？\n\n2. 想找python sdk的详细文档请问哪里有？官网上大篇幅的都是restful api的文档","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645996,"discussion_content":"好的，同学我看到你自己回复问题已经解决。\n在第03课中有提供代码和数据集的链接：https://time.geekbang.org/column/article/777441\n也可以在我的github找到：huangjia2019 - Repo: powerful_llm\n入群后也有提供这个代码的链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717080614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","nickname":"Geek_zbvt62","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645982,"discussion_content":"我知道了，出现异常是因为gpt4没能识别出function调用，直接回复了我一句话，需要提供更详细的信息。\n我丰富了Assistant的instruction，改成：\n“帮助客户计算购物车里商品的总价格，单位元。客户可以提供的商品类型：1. 书籍 2.文具 3.电子产品。不需要客户提供单价，可以通过function获取”\n效果会好很多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1717074282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"天津","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1347609,"avatar":"https://static001.geekbang.org/account/avatar/00/14/90/19/b3403815.jpg","nickname":"Juha","note":"","ucode":"5B9301CC960D84","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/d28174a9.jpg","nickname":"Geek_zbvt62","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646584,"discussion_content":"感谢Joshua，确实改了instruction之后run的状态会变成required_action","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718252937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645982,"ip_address":"北京","group_id":0},"score":646584,"extra":""}]}]},{"had_liked":false,"id":390950,"user_name":"熊出没","can_delete":false,"product_type":"c1","uid":1145377,"ip_address":"中国台湾","ucode":"6E39230CC87808","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","comment_is_top":false,"comment_ctime":1716826776,"is_pvip":false,"replies":[{"id":142220,"content":"是吗？界面和我的不一样？我想应该是只有付费用户才看得见高级一些的model。慢慢的，更新的model出来后，OpenAI会把这些“gpt-4”开放给免费用户。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717080822,"ip_address":"新加坡","comment_id":390950,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"创建Assistants时模型选择只有gpt-3.5-turbo-16k、gpt-3.5-turbo-0125、gpt-3.5-turbo、CHAT这几个选择 和老师的不一样 为什么\n","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645998,"discussion_content":"是吗？界面和我的不一样？我想应该是只有付费用户才看得见高级一些的model。慢慢的，更新的model出来后，OpenAI会把这些“gpt-4”开放给免费用户。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717080822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390817,"user_name":"yision97","can_delete":false,"product_type":"c1","uid":2477104,"ip_address":"四川","ucode":"F771F37CBC422D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICAILuSqtnARmMmomT7ic85ITviaiaJlowficJ4XH1pkh1syt1EFtOTvrMht2yOWxlW710AicaAf1EXEg/132","comment_is_top":false,"comment_ctime":1716369880,"is_pvip":false,"replies":[{"id":142138,"content":"可以入群问问大家的科学上网以及获得API Key的方法","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1716453844,"ip_address":"新加坡","comment_id":390817,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"各位使用的什么支付方案啊，我的卡被封了","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645630,"discussion_content":"可以入群问问大家的科学上网以及获得API Key的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716453844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645830,"discussion_content":"获取到了API key的方法了么 国内号码不可用啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716864265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390802,"user_name":"界元","can_delete":false,"product_type":"c1","uid":3732614,"ip_address":"广东","ucode":"6BE6C6497237DB","user_header":"https://static001.geekbang.org/account/avatar/00/38/f4/86/21ea3970.jpg","comment_is_top":false,"comment_ctime":1716339847,"is_pvip":false,"replies":[{"id":142217,"content":"这个设计很重要。正如另外一位同学‘Geek_9948a5’留言所说的： 在这段代码中，function_name 是从 Assistant 返回的数据中提取出来的。Assistant 会根据用户的请求动态地选择或生成一个函数来处理请求。—— 只有这样才实现了根据用户不同类型的问题，动态的调用不同的函数。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717080463,"ip_address":"新加坡","comment_id":390802,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"学习完了，对于order_total = globals()[function_name](**arguments_dict)的function_name怎么来的不太理解，为什么不是calculate_order_total？","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645994,"discussion_content":"这个设计很重要。正如另外一位同学‘Geek_9948a5’留言所说的： 在这段代码中，function_name 是从 Assistant 返回的数据中提取出来的。Assistant 会根据用户的请求动态地选择或生成一个函数来处理请求。—— 只有这样才实现了根据用户不同类型的问题，动态的调用不同的函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717080464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363593,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLFvhaPbJ1sBZqr8GQRVDiaxsicukAETVzjqmBRba2WqibbmX3NmoPIkaNEnBvyaWobyCjGN0FJgGnKQ/132","nickname":"Geek_9948a5","note":"","ucode":"7DDAF4A21EA1FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645853,"discussion_content":"因为工具可能有多个，globals()[function_name]指的是从Assistant的推理结果中获取到，需要调用的函数名.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716895945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645844,"discussion_content":"请问下 API Keys是获取的方法是什么 国内手机号码不能用于验证 \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716886274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645995,"discussion_content":"大家说可以试试AzureOpenAI，或者淘宝购买Key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717080518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645844,"ip_address":"新加坡","group_id":0},"score":645995,"extra":""}]}]},{"had_liked":false,"id":390767,"user_name":"Geek_7593a0","can_delete":false,"product_type":"c1","uid":3654637,"ip_address":"浙江","ucode":"731AD15B3CBDB7","user_header":"","comment_is_top":false,"comment_ctime":1716203701,"is_pvip":false,"replies":[{"id":142133,"content":"好问题呀！这么简单的场景，AI 没有什么优势。示例中，重要的是我们看到AI能够做什么，未来的Agent时代，由AI驱动的智能系统的雏形将是什么样的。——这就是OpenAI 给我们推出Assistants API，试图带给我们的东西。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1716453265,"ip_address":"新加坡","comment_id":390767,"utype":1}],"discussion_count":8,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"问，这样的场景用ai对比传统方案的优势在哪里","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645625,"discussion_content":"好问题呀！这么简单的场景，AI 没有什么优势。示例中，重要的是我们看到AI能够做什么，未来的Agent时代，由AI驱动的智能系统的雏形将是什么样的。——这就是OpenAI 给我们推出Assistants API，试图带给我们的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716453265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645473,"discussion_content":"AI当客服, 遇到用户要退款, 一边安抚用户, 一边根据知识库与用户确认退款相关政策, 用户始终要求退款的话通过function在外部系统中开工单请求人工介入, 甚至是直接创建退款单. 传统方案就是人工客服吧 😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716209346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":3654637,"avatar":"","nickname":"Geek_7593a0","note":"","ucode":"731AD15B3CBDB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":645496,"discussion_content":"传统不都七天无理由吗，同意协议后，点击退货退款完事，客服介入也是他那边可以一个请求完事，如果单纯是为了取代客服，应该划不来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716263307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645473,"ip_address":"浙江","group_id":0},"score":645496,"extra":""},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":3654637,"avatar":"","nickname":"Geek_7593a0","note":"","ucode":"731AD15B3CBDB7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645499,"discussion_content":"我，大学生，用了俩月了要退 🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716276493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645496,"ip_address":"上海","group_id":0},"score":645499,"extra":""},{"author":{"id":3654637,"avatar":"","nickname":"Geek_7593a0","note":"","ucode":"731AD15B3CBDB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":645505,"discussion_content":"这种场景，出于对商家的保护，ai已经没有意义了，必须要人工介入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716278790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645499,"ip_address":"浙江","group_id":0},"score":645505,"extra":""}]}]},{"had_liked":false,"id":390746,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"上海","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1716176835,"is_pvip":true,"replies":[{"id":142135,"content":"嗯，是这样的。但是我们也看到，从3.5到4，从4到4-Turbo，从4-Turbo到4o，模型的进展是非常快的，推理能力也越来越强的。当然兜底的设置也是必须。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1716453585,"ip_address":"新加坡","comment_id":390746,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100764201,"comment_content":"感觉提示不写清楚的话，chatgpt在选择是否调用tools、以及调用哪个tool上还有点随缘。所以才会有强制使用某个tool或function的选项来兜底","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645627,"discussion_content":"嗯，是这样的。但是我们也看到，从3.5到4，从4到4-Turbo，从4-Turbo到4o，模型的进展是非常快的，推理能力也越来越强的。当然兜底的设置也是必须。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716453585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3600600,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f0/d8/c344594a.jpg","nickname":"🇾.🇨.","note":"","ucode":"C033E961553EA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645549,"discussion_content":"哥们api是走虚拟服务商充值吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716348806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"英国","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3600600,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f0/d8/c344594a.jpg","nickname":"🇾.🇨.","note":"","ucode":"C033E961553EA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645504,"discussion_content":"是的，我也觉得，尤其使用国内模型时候，在和原生的tool功能重叠时候根本不知道去调","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716278304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392494,"user_name":"Sandy","can_delete":false,"product_type":"c1","uid":1029353,"ip_address":"上海","ucode":"471882A50FA2F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/e9/f43781b3.jpg","comment_is_top":false,"comment_ctime":1721098538,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100764201,"comment_content":"在run Cart_Price_Finally.py 脚本中 出现items的中文名称乱码 这样结果也就不正确。怎么解决？","like_count":0}]}