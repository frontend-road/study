{"id":169593,"title":"10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？","content":"<p>在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>为什么不推荐使用继承？</h2><p>继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。</p><p>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</p><p>我们知道，大部分鸟都会飞，那我们可不可以在AbstractBird抽象类中，定义一个fly()方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有fly()方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly()方法，让它抛出UnSupportedMethodException异常不就可以了吗？具体的代码实现如下所示：</p><!-- [[[read_end]]] --><pre><code>public class AbstractBird {\n  //...省略其他属性和方法...\n  public void fly() { //... }\n}\n\npublic class Ostrich extends AbstractBird { //鸵鸟\n  //...省略其他属性和方法...\n  public void fly() {\n    throw new UnSupportedMethodException(&quot;I can't fly.'&quot;);\n  }\n}\n</code></pre><p>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写fly()方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p><p>你可能又会说，那我们再通过AbstractBird类派生出两个更加细分的抽象类：会飞的鸟类AbstractFlyableBird和不会飞的鸟类AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承AbstractUnFlyableBird类，不就可以了吗？具体的继承关系如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/b7/1e27919f63ef615dba98bc00673914b7.jpg?wh=1703*923\" alt=\"\"></p><p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p><p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/c6/3f99fa541e7ec7656a1dd35cc4f28bc6.jpg?wh=3013*913\" alt=\"\"></p><p>如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p><p>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。</p><h2>组合相比继承有哪些优势？</h2><p>实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。</p><p>我们前面讲到接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个Flyable接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义Tweetable接口、EggLayable接口。我们将这个设计思路翻译成Java代码的话，就是下面这个样子：</p><pre><code>public interface Flyable {\n  void fly();\n}\npublic interface Tweetable {\n  void tweet();\n}\npublic interface EggLayable {\n  void layEgg();\n}\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\npublic class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀\n  //... 省略其他属性和方法...\n  @Override\n  public void fly() { //... }\n  @Override\n  public void tweet() { //... }\n  @Override\n  public void layEgg() { //... }\n}\n</code></pre><p>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p><p>我们可以针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</p><pre><code>public interface Flyable {\n  void fly()；\n}\npublic class FlyAbility implements Flyable {\n  @Override\n  public void fly() { //... }\n}\n//省略Tweetable/TweetAbility/EggLayable/EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟\n  private TweetAbility tweetAbility = new TweetAbility(); //组合\n  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合\n  //... 省略其他属性和方法...\n  @Override\n  public void tweet() {\n    tweetAbility.tweet(); // 委托\n  }\n  @Override\n  public void layEgg() {\n    eggLayAbility.layEgg(); // 委托\n  }\n}\n</code></pre><p>我们知道继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如is-a关系，我们可以通过组合和接口的has-a关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p><h2>如何判断该用组合还是继承？</h2><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p><p>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</p><p>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</p><p>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A类和B类并不一定具有继承关系。比如，Crawler类和PageAnalyzer类，它们都用到了URL拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现Crawler类和PageAnalyzer类继承同一个父类，而父类中定义的却只是URL相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</p><pre><code>public class Url {\n  //...省略属性和方法\n}\n\npublic class Crawler {\n  private Url url; // 组合\n  public Crawler() {\n    this.url = new Url();\n  }\n  //...\n}\n\npublic class PageAnalyzer {\n  private Url url; // 组合\n  public PageAnalyzer() {\n    this.url = new Url();\n  }\n  //..\n}\n</code></pre><p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中FeignClient是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的encode()函数。这个时候，我们只能采用继承来实现了。</p><pre><code>public class FeignClient { // Feign Client框架代码\n  //...省略其他代码...\n  public void encode(String url) { //... }\n}\n\npublic void demofunction(FeignClient feignClient) {\n  //...\n  feignClient.encode(url);\n  //...\n}\n\npublic class CustomizedFeignClient extends FeignClient {\n  @Override\n  public void encode(String url) { //...重写encode的实现...}\n}\n\n// 调用\nFeignClient client = new CustomizedFeignClient();\ndemofunction(client);\n</code></pre><p>尽管有些人说，要杜绝继承，100%用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p><h2>重点回顾</h2><p>到此，今天的内容就讲完了。我们一块儿来回顾一下，你需要重点掌握的知识点。</p><p><strong>1.为什么不推荐使用继承？</strong></p><p>继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p><p><strong>2.组合相比继承有哪些优势？</strong></p><p>继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p><p><strong>3.如何判断该用组合还是继承？</strong></p><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p><h2>课堂讨论</h2><p>我们在基于MVC架构开发Web应用的时候，经常会在数据库层定义Entity，在Service业务层定义BO（Business Object），在Controller接口层定义VO（View Object）。大部分情况下，Entity、BO、VO三者之间的代码有很大重复，但又不完全相同。我们该如何处理Entity、BO、VO代码重复的问题呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":155016,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574629797,"is_pvip":false,"discussion_count":28,"race_medal":0,"score":"1517698085285","product_id":100039001,"comment_content":"我的观点比较极端，用接口，组合和委托代替继承。原因如下：<br>1. 人无法预知未来，现在比较稳定的类继承关系将来未必稳定。<br>2.两种设计之间的选择耗费资源，每次都要为这个问题拿捏一下，甚至争论一下，不如把争论放在业务逻辑的实现上。<br>3.相对于接口+组合+委托增加的复杂度，代码统一成接口+组合+委托带来的好处更多，利于阅读和交流，毕竟读代码的次数大于写的次数，读一种类型的代码的难度远低于读两种类型。<br>4.新的编程语言让接口+组合+委托变得容易，例如Kotlin就有专门的语法糖支持，消除了很多模板代码。<br>5.接口+组合+委托符合矢量化思想，那就是将物体特征分成不同的维度，每个维度独立变化。继承则是将物体分类，抽取共性，处理共性，操作的灵活性大打折扣，毕竟现实中的物体特征多，共性少。","like_count":354,"discussions":[{"author":{"id":1070601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/56/09/4a9d4a35.jpg","nickname":"zj坚果","note":"","ucode":"D6E787FF032D7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263203,"discussion_content":"软件工程没有银弹。我不同意一刀切，正如你所说的“人类无法预知未来”，你又如何能知道未来不会有更好的解决方案，未来这个系统是否会采用采用其他技术重构甚至重做等等。如果未来是指几年后的话，个人觉得大可不必过早担心，毕竟我们的项目还要考虑各种其他因素，诸如人力资源，开发时间，队友是否跟你一样熟悉设计模式等。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1589187157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65645,"discussion_content":"作为一个职场老油条，还是赞同争哥观点的，毕竟还是要考虑到人力成本~~~","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1575018178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147925,"discussion_content":"就和贫血模型一样，人力成本在实际工作中也是很重要的考量维度","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1579681527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1032345,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","nickname":"Geeker","note":"","ucode":"9937127DE96D78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":223260,"discussion_content":"所以最重要的因素还是人，无论是需求分析阶段人与人的沟通，还是编码阶段的开发人力，还是测试阶段开发测试的沟通，还是上线后的运维。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586195746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":147925,"ip_address":""},"score":223260,"extra":""},{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1032345,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","nickname":"Geeker","note":"","ucode":"9937127DE96D78","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":297486,"discussion_content":"也因为人的多样性，最后还是需要流程和规范。有时遇到那种换个领导就一种搞法的，真实痛苦。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1596949011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223260,"ip_address":""},"score":297486,"extra":""}]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246810,"discussion_content":"文本的规范是没法做到最终的统一的，可以要求自己控制好度，一个工程是多人开发，所以没法要求别人也控制好度，这也就是为什么go语言和您说的kotlin放弃继承的原因，把握好度只是一种理想的状态，大部分人是把握不好的，特别在项目工期紧工作量大的情况下","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1587779669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59846,"discussion_content":"所以为什么会新起函数式编程，感觉接口，组合，委托的思路和函数式编程有点接近了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574694568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58171,"discussion_content":"矢量化思想，是你发明的名词么","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574656195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220277,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg","nickname":"Leo","note":"","ucode":"7A11B26AEA5510","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345650,"discussion_content":"还有一个就是不要过渡设计，拆分的很细后续维护也是一个痛点","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1611756054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018604,"avatar":"","nickname":"huxian","note":"","ucode":"60699B4C279E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70218,"discussion_content":"不完全赞同，继承还是有使用场景的，只是不能过度使用，我觉得和单例模式类似，尽量要少用，但有些场景还是必须要用的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575336971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025958,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a7/a6/120412b1.jpg","nickname":"姜中正","note":"","ucode":"D76875214401CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124855,"discussion_content":"这就是golang中经常用到的方法。golang中没有继承。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578454359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291391,"discussion_content":"请教一下，如果是按照功能分成多个基类，然后再按需继承。\n比如 Fly类，Tweet类，Egg类。\n鸵鸟就只继承Tweet类，Egg类\n这样也可以实现接口，组合，委托的效果啊，请问一下这样有什么坏处呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594802812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1071883,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epaibTssLXqSXryibVuFoMyicg64o3IqFaobS9J7TibqUpRQ45lVj2nbRQpfLQicW6W81zwYM19X1VIk8A/132","nickname":"ixonya","note":"","ucode":"1CE0897B39AD18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291643,"discussion_content":"本小白觉得你的方法也没啥不行的，和“接口，组合，委托”的思想是一致的，只是一些语言不支持多重继承。。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1594896372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291391,"ip_address":""},"score":291643,"extra":""},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071883,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epaibTssLXqSXryibVuFoMyicg64o3IqFaobS9J7TibqUpRQ45lVj2nbRQpfLQicW6W81zwYM19X1VIk8A/132","nickname":"ixonya","note":"","ucode":"1CE0897B39AD18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291726,"discussion_content":"可以直接组合呀😏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594920361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291643,"ip_address":""},"score":291726,"extra":""},{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294524,"discussion_content":"面向接口而非实现编程，接口是稳定的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595916852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291726,"ip_address":""},"score":294524,"extra":""}]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271417,"discussion_content":"第5点写的很好，其它的各有已见，没必要统一。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590134046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2829583,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/2d/0f/52e5dcff.jpg","nickname":"右手特别大","note":"","ucode":"9B9A4600B97D81","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576941,"discussion_content":"通过组合复用另外一个模块有一个限制条件，就是组合类必须定义实现对外的函数接口。 恰恰有一种场景，多个子类的功能与父类相似，但是就是有小部分不同。 用户希望这些子类都必须提供某套接口。除非你能忍受每一个子类都实现一遍这些接口，并且实现大多是代理调用某个成员变量模块的函数，显而易见的重复，只有继承才能解决，因为只有继承才支持函数实现的复用。至于重复代码有什么缺点，那是另外一个故事了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655860364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393478,"discussion_content":"你用组合实现一个模板方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631448857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377142,"discussion_content":"厉害👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622522979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2273754,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/da/5602cb4b.jpg","nickname":"king","note":"","ucode":"1E5BD0E2A789C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319070,"discussion_content":"可以想法不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603935871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1900967,"avatar":"","nickname":"ricepot100","note":"","ucode":"318CBC10964946","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218715,"discussion_content":"对于只利用继承进行分类的话，还是使用继承比较合适吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585670843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182984,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/08/2f825f69.jpg","nickname":"丁源(156*****518)","note":"","ucode":"BDBB8B7D0745FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185291,"discussion_content":"兄台结合实战的经验之谈着实值得点赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582613257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155007,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1574616175,"is_pvip":false,"replies":[{"id":"60028","content":"抽空集中答疑一下吧","user_name":"作者回复","comment_id":155007,"uid":"1190123","ip_address":"","utype":1,"ctime":1574853379,"user_name_real":"王争"}],"discussion_count":30,"race_medal":0,"score":"688769383535","product_id":100039001,"comment_content":"我个人感觉VO和BO都会采用组合entity的方式，老师是否可以在下一节课课聊聊上节课留下的思考题，您的处理方式？","like_count":160,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103974,"discussion_content":"一人血书求老师答疑","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1577408248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341023,"discussion_content":"找了全专栏，没有讨论题的答疑呀，","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1610264947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57880,"discussion_content":"为请老师讲解讨论题点赞","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574645438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338602,"discussion_content":"后来，老师答疑了吗","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1609321266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2343174,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c1/06/442b20a3.jpg","nickname":"小笨蛋","note":"","ucode":"159A8DCA371A35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338773,"discussion_content":"同问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609378914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338602,"ip_address":""},"score":338773,"extra":""}]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475635,"discussion_content":"抽空集中答疑一下吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574853379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1910698,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/27/aa/5e65bd19.jpg","nickname":"Eden","note":"","ucode":"1A03D9F9D5A17A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536446,"discussion_content":"老师突然想起来极客时间的账号了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638786413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475635,"ip_address":""},"score":536446,"extra":""},{"author":{"id":1246156,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/cc/fa33828b.jpg","nickname":"yuuki","note":"","ucode":"6C068781E03EA1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1910698,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/27/aa/5e65bd19.jpg","nickname":"Eden","note":"","ucode":"1A03D9F9D5A17A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":537603,"discussion_content":"老师这些课后思考题， 不讲解一下嘛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639114066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536446,"ip_address":""},"score":537603,"extra":""},{"author":{"id":1459863,"avatar":"https://static001.geekbang.org/account/avatar/00/16/46/97/ddd4b05f.jpg","nickname":"爱上我们的微笑","note":"","ucode":"40CDB7AB0991CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1910698,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/27/aa/5e65bd19.jpg","nickname":"Eden","note":"","ucode":"1A03D9F9D5A17A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":543814,"discussion_content":"哈哈哈\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641306783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536446,"ip_address":""},"score":543814,"extra":""}]},{"author":{"id":1335980,"avatar":"https://static001.geekbang.org/account/avatar/00/14/62/ac/1f3391dd.jpg","nickname":"张姗","note":"","ucode":"A075C34614FE4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136483,"discussion_content":"请老师讲解讨论题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579143376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111973,"avatar":"","nickname":"AdrianH","note":"","ucode":"1D5A7CB36BF57E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69059,"discussion_content":"+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575255833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1584787,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/93/029eee99.jpg","nickname":"阿维","note":"","ucode":"84CBFDBD016806","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60954,"discussion_content":"请老师加餐讲解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574766948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201342,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/be/9dada6f6.jpg","nickname":"Yannis","note":"","ucode":"9A59D61EDE1833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60209,"discussion_content":"请老师加餐讲解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574703204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529040,"avatar":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","nickname":"帆大肚子","note":"","ucode":"3DB11DB2FA1802","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59659,"discussion_content":"老师讲解讨论题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574692387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363054,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cc/6e/c3c9ea88.jpg","nickname":"别","note":"","ucode":"D806471DA0EDD9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58253,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574662572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261538,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/lNv6icIOUpEbUx4wBNLucxfH6SRNvpq6huvz0iaxtX1rSBticJvcxiaZVy6qIkpibPZ7axSDpnHAy0ZsHndczKbVxqA/132","nickname":"天堂up","note":"","ucode":"0881FCFA744147","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58250,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574662489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58248,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574662292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","nickname":"郑童文","note":"","ucode":"3D193715CB8549","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57947,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574647151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2065130,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/82/ea/c11d99f7.jpg","nickname":"Minghan","note":"","ucode":"8762CC489C3C6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587964,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663408002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1862316,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/6a/ac/b1738d6b.jpg","nickname":"杨振泽","note":"","ucode":"1666FEB0309BB7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576025,"discussion_content":"hu~ 2022年了，老师啥时候忙完？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655253428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023818,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/4a/f5b8c6b3.jpg","nickname":"Walker Jiang","note":"","ucode":"92AE855D428917","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549525,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644055738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393483,"discussion_content":"老师答疑没有?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631450356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691447,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","nickname":"Dunk","note":"","ucode":"A8F5AB98382719","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367710,"discussion_content":"请老师加餐答疑一波课后题吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618447544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361952,"discussion_content":"后来还是没有答疑？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616811853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242122,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","nickname":"YourSweetHeart","note":"","ucode":"38843F447B03F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85292,"discussion_content":"留言有点靠后了，在用委托代替继承修改之后，如果fly方法依赖鸵鸟类里某个属性，这该怎么办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576526125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1245904,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","nickname":"治慧","note":"","ucode":"47C331EF63EDC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242122,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","nickname":"YourSweetHeart","note":"","ucode":"38843F447B03F2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207869,"discussion_content":"fly方法是在上层对应的接口中,不应该去依赖下层类中的属性 这样就成环形了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1584519379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85292,"ip_address":""},"score":207869,"extra":""}]},{"author":{"id":1122412,"avatar":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","nickname":"NoAsk","note":"","ucode":"71CA29776B4F68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61973,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574809854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60768,"discussion_content":"臣附议...😄 最近也很头疼，有的时候感觉类爆炸了，但好像又不得不去创建一个字段差不多的类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574753331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60297,"discussion_content":"求老师加餐+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574726398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010957,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","nickname":"拓","note":"","ucode":"AC1940ECC25436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59721,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155242,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1574671181,"is_pvip":false,"discussion_count":18,"race_medal":0,"score":"581395256141","product_id":100039001,"comment_content":"课堂讨论answer:<br>Entity， Bo， Vo三者之间，显然并不存在 is-a关系，首先排除使用继承。<br><br>其次三者间也并非是严格的has-a关系，half measure之一是考虑使用组合（composition） + 委托（delegation）的方式解决代码重复的问题，但并不是我心中的最佳答案.<br><br>我的答案是不解决三者间的代码重复问题。Value Class就只是Value Class, 代码重复并不是业务上的代码重复,那就让它重复吧.<br><br>","like_count":136,"discussions":[{"author":{"id":2694117,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1b/e5/4f8612b0.jpg","nickname":"DougLea","note":"","ucode":"179F29D304519D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383407,"discussion_content":"非常同意楼主的观点，这三层确实必须要相互隔离，尽管代码重复，也不要滥用代码复用。如果一味的追求代码简洁，到最后遇到一点儿变动更加是得不偿失。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1626081853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1830814,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/ef/9e/fd29bdd8.jpg","nickname":"Bacchus","note":"","ucode":"A8AA7E4909B201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401891,"discussion_content":"同意，这三者其实就是三个领域的东西，不能因为属性的现实意义相同就混为一谈，海水里的鱼和鱼缸里的鱼虽然都是鱼，但是用法是不一样的，哈哈","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1633759605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257453,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","nickname":"此鱼不得水","note":"","ucode":"95268E823FB4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109448,"discussion_content":"不同领域的对象，属性重复没毛病。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577695431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286654,"discussion_content":"是的，这三者本身是三层结构的对象，分三层也是触偶\n如果存在复用则意味着一层的对象改变会影响到另一层","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593255003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446024,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/GA9AqKGEdib009iaPw3FSluiaeibCXmen7yFIKicZB8qqEtczZJF2WmwBJ738eExnxDmPREIGjqc4BFVXiamyhuCZASw/132","nickname":"一缕阳光","note":"","ucode":"CA89C1B7CB16C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585346,"discussion_content":"听君一席话，胜听一席话","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1661496128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297488,"discussion_content":"也是这种想法，有时适当重复也是一种模式，彼此之间没有依赖。最怕一些同事，见不得一点重复，总搞一些继承出来，看得都头大。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596949324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73233,"discussion_content":"我通常尽量只写一个类，然后用各层生效的注解来注释各个属性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575555925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384871,"discussion_content":"炫技，是不是，分开写纯粹点，没有鱼龙混杂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626777531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73233,"ip_address":""},"score":384871,"extra":""}]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72954,"discussion_content":"有道理！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575544874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59888,"discussion_content":"突然想到ddd里面的实体和值对象，或许从业务上来处理这个问题更好，根据业务来区分实体和值对象来建立entity，而不是死扣Entity、Bo、Vo做三层区分。个人思考的结果","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574694906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287634,"discussion_content":"那你这种就不是传统的MVC模式了，DDD讲究聚合根来聚合实体对象，那么就不存在细分的BO、VO、Entity了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593500137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":59888,"ip_address":""},"score":287634,"extra":""}]},{"author":{"id":1518793,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/c9/462afe28.jpg","nickname":"小白","note":"","ucode":"11FC209D9ED65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590854,"discussion_content":"确实，从业务角度来讲，这几个在上下文本来就不是同个东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666117659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394143,"avatar":"https://static001.geekbang.org/account/avatar/00/15/45/df/97a71dc8.jpg","nickname":"怀英","note":"","ucode":"E2838AF06FB300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587882,"discussion_content":"同意，有时VO不需要全部的entity的所有属性，如果要使用“接口+组合+委托”，那么这个“接口”就很难制定。此外，如果要实现如此的灵活性，在VO多变的情况下，最好的方法就是entity的每一个属性定义成一个接口，这样一来，工作量大，有点儿得不偿失","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663342009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005356,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","nickname":"ssala","note":"","ucode":"CCD82C81756FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554691,"discussion_content":"学到了，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646553234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213448,"discussion_content":"分开写没毛病，复用我觉得很重要看重业务趋同还是趋异，这里明显是趋异的，复用代码干嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585095010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87739,"discussion_content":"目前处理方式Entity， Bo， Vo三者之间，该重复还是重复吧，如果采用组合，虽然代码复用了，但是对于调用端/前端的数据获取增加了复杂性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576678061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73238,"discussion_content":"这个课后问题是常见的问题，可惜没有一个好方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575556023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393161,"discussion_content":"三层独立，用bean拷贝工具复制","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631272491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73238,"ip_address":""},"score":393161,"extra":""}]}]},{"had_liked":false,"id":155288,"user_name":"兔2🐰🍃","can_delete":false,"product_type":"c1","uid":1096984,"ip_address":"","ucode":"1FEDA044BB6CBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/18/2af6bf4b.jpg","comment_is_top":false,"comment_ctime":1574674973,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"486905979421","product_id":100039001,"comment_content":"看下来对组合跟委托两个概念表示不太明白，看了代码后才，以及网上查阅后才明白。<br>继承(Inheritance)：利用extends来扩展一个基类。is-a的关系。<br>组合(composition)：一个类的定义中使用其他对象。has-a的关系。<br>委托(delegation)：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。有uses-a, owns-a, has-a三种关系。","like_count":114,"discussions":[{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374743,"discussion_content":"组合其实就是依赖","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621332750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336634,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","nickname":"mqray","note":"","ucode":"15664507AD7033","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533056,"discussion_content":"这个组方就像spring boot中注入其他类一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637763577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2828609,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/29/41/371c3b77.jpg","nickname":"神经蛙vx qingtian01266","note":"","ucode":"83C047B851E23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532926,"discussion_content":"你的回复更像是看到类用了 extends ，说明他是 is-a 关系 。。。。。。作者想告诉我们的是什么时候用继续，什么时候用组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637734171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2034881,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0c/c1/1efe5b42.jpg","nickname":"小璇璇","note":"","ucode":"C574FDBA0F66D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378264,"discussion_content":"委托的最终目标是方法的委托，即方法的委托或方法的代理，比如调用obj.f()的时候转而去调用obj1.f()。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623134642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155565,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1574699639,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"349467050615","product_id":100039001,"comment_content":"VO,BO,DO表示什么前面都说过了，我觉得得换一个思路去看待这种模型转换的问题。 <br>这里我们将BO看做ddd里面的核心域中的实体。那么这个对象的变化应该对VO或者DO隐藏起来，VO是对外的模型，为什么需要感知到内部业务的变化，DO是具体的存储方式，这是由实现决定的，在业务逻辑中也不应该关心。重要的是隔离，让这三者独立变化。 <br>所以我的结论是，既不应该用继承，也不应该使用组合，使用防腐层，模型转换层隔离这种变化才是最好的。<br>但是实际上在很多业务中BO和DO是差不多的，于是就混用了，在业务不复杂的时候，也没太大关系。业务运行的很好，也不难理解。<br><br>追求完美，却不可能处处完美。","like_count":82,"discussions":[{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79923,"discussion_content":"赞同，但也期待更精彩更完美的解决方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576123697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730626,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","nickname":"小妖","note":"","ucode":"49C01DBFADF101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63803,"discussion_content":"和我的理解不谋而合，VO的作用本来就是为了和对外数据更灵活、不能也没必要和其他层有集成或者实现关系，划分三层最重要的是隔离，更容易拓展，如果把封装的定义泛化，这同样是另外一种封装","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574912377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1176980,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f5/94/67fabf8e.jpg","nickname":"Kevinlvlc","note":"","ucode":"90DFD58CED138C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60290,"discussion_content":"支持这种理解～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574725747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518793,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/c9/462afe28.jpg","nickname":"小白","note":"","ucode":"11FC209D9ED65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590855,"discussion_content":"最佳方案，DDD 就是这样设计的，重复就让他重复吧，从业务层面看，本就不是同个语义，随时有变化的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666117803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304087,"discussion_content":"防腐层还是第一次听说，他跟模型转换层有什么区别呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599464804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297493,"discussion_content":"目前我们项目也是部分混用，但需要开发人员理解好业务 model 以及 分层 model 的区别，要不为了兼容不同层，很容易把 model 搞成全家桶。而 model 是最容易导致各层耦合的点，用不好就容易导致高耦合造成混乱。因为在我看来，分层实现的还坏，决定于 model 的分层隔离有没有做好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596949890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438470,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","nickname":"Fredo","note":"","ucode":"681D6692617DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157898,"discussion_content":"关于DO VO等大家可以参考下 阿里巴巴JAVA开发手册","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580529496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042753,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p6kkT7nsViayxazIrxx7p0pklPRvet933nEGBupj1phL2zArLStC3MnHFFyBYZ9fDGbPWJxS6WOICkxCCLia7nhw/132","nickname":"Qfxl","note":"","ucode":"4554F28BB10F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96770,"discussion_content":"十分同意，相互隔离才是正确的抽象封装方法，业务不复杂亦可适度混用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577092239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83780,"discussion_content":"这里说的DO，是domain object 还是 data object?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576463031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87116,"discussion_content":"domain object 是你自己发明的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576644887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83780,"ip_address":""},"score":87116,"extra":""},{"author":{"id":1560281,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ce/d9/e3fc735c.jpg","nickname":"leo","note":"","ucode":"AAF0F90D8A2481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222589,"discussion_content":"domain object是DDD里面领域对象的意思。DDD将对象划分为DTO（Data Transfer Object）数据传输对象，DO（Domain Object）领域对象和PO（Persist Object）持久层对象。不过这三个概念和MVC中的VO，BO和DO不是对应的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586160273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87116,"ip_address":""},"score":222589,"extra":""},{"author":{"id":2791308,"avatar":"","nickname":"Geek3425","note":"","ucode":"C7292D0AF11F43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402748,"discussion_content":"domain\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633942351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83780,"ip_address":""},"score":402748,"extra":""}]},{"author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83777,"discussion_content":"“DO是具体的存储方式” -- 存储方式不是PO吗，这里为什么说是DO?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576462772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498641,"avatar":"https://static001.geekbang.org/account/avatar/00/16/de/11/72f96304.jpg","nickname":"M.O(∩_∩)O","note":"","ucode":"B245C2BA20DDA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78975,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576040864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237330,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1595781240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"216344146040","product_id":100039001,"comment_content":"继承和组合本质是一样的，都是委托。继承其实就是子类包含了父类的一个引用，然后把自己某些方法委托给父类。组合就是包含了多个其他类的引用，然后把自己的某些方法委托给这些类。<br>而只能委托给一个类和可以委托给多个类就是继承和组合的区别。只能委托给一个类，那么这个类一定要包含我要委托的全部能力；可以委托给多个类，那么这些能力就可以分散在这些委托的类中。将能力分散比将能力聚合更符合单一职责的原则。<br>如果将继承关系用树来描述，继承的弊处在于将继承路径上的那些扩展功能固化到了这条路径上的每个子类节点上了，一旦你想创建新的子类节点并想让它包含某个已存在的扩展功能，你就必须是那个扩展功能所在的节点的直系后代节点。那么问题来了，新的子类节点就顺带拥有了路径上其他节点的扩展功能，即使这些扩展功能并不是它想要的。当然，你可以重新开辟一条继承路径，使得这条路径上的扩展功能都是你想要的功能，这样一来，继承带来的的复杂性和功能的冗余性就体现了（两条路径存在功能相同的节点）。很自然地，你会想，把这些重复的功能抽成单独的类分离出去不就好了吗，一旦这样做了，就成了名为继承实为组合的设计了，因为它将功能委托给了多个类而不仅仅是它的父类。<br>可见，组合恰到好处地解决继承带来的问题，它将扩展功能成了一个个游离的单元，可根据需要自由组合，然后借助接口给自己打上标签，解决了 is-a 的问题。","like_count":50},{"had_liked":false,"id":155465,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1574691089,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"190553252113","product_id":100039001,"comment_content":"希望，评论区能增加一个&lt;b&gt;可选开关&lt;&#47;b&gt;，“只看作者回复”的评论「(*&#47;ω＼*)」","like_count":45,"discussions":[{"author":{"id":1620113,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b8/91/8a5c3ec6.jpg","nickname":"王一之","note":"","ucode":"7E13332BAEC2F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69861,"discussion_content":"可以有,不过有些评论(未回复的)还是很精彩的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575300131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60565,"discussion_content":"我也有","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574738388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1197722,"avatar":"https://static001.geekbang.org/account/avatar/00/12/46/9a/3b9062b5.jpg","nickname":"zxh","note":"","ucode":"8B4FEDA65B8187","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295165,"discussion_content":"你用 control+F 就可以实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596107486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016052,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/f4/d340dc44.jpg","nickname":"devin","note":"","ucode":"C9682026B6B1FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59871,"discussion_content":"赞，有同样的需求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574694791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155006,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1514882,"ip_address":"","ucode":"2F1FA3519FAB50","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyiafvkibXnTOpIJxlhndHpSDMsqja9AajKYtYgGEGtFWtBb2Mg8DRVjqlWyIxl1piaT4qpMkwerQUg/132","comment_is_top":false,"comment_ctime":1574615816,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"156193438472","product_id":100039001,"comment_content":"打卡✔<br>看完之后有种感觉，我们平常写的spring的依赖注入这种形式，是不是就是跟组合，委托这种模式啊","like_count":36,"discussions":[{"author":{"id":1609964,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","nickname":"拂尘","note":"","ucode":"9563C002E4B06A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57767,"discussion_content":"因为是面向抽象编程，如果不用工厂或者spring依赖注入的话，那么在new 对象的时候仍然会是面向实现，因为new肯定要new 实现类。组合应该就是使用类变量吧，然后委托就是将工作委托给类变量的对象方法实现，然后也是实现代码复用吧。所以spring依赖注入是帮助组合完全是面向接口抽象，脱离面向实现咯。以前是工厂现在在升级诶","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574642786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1609964,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","nickname":"拂尘","note":"","ucode":"9563C002E4B06A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58255,"discussion_content":"如果是类变量是组合的话， 那 容器变量属于组合吗，容器里面装的也是类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574662611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57767,"ip_address":""},"score":58255,"extra":""}]},{"author":{"id":1234314,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","nickname":"东征","note":"","ucode":"DC557A1631A493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58138,"discussion_content":"我认为是组合的一种体现","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574654072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2373458,"avatar":"https://static001.geekbang.org/account/avatar/00/24/37/52/fdfe66a1.jpg","nickname":"小熊","note":"","ucode":"7DDDC76895C1D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352254,"discussion_content":"我也是这么觉得的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614665774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249981,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/bd/54987d4b.jpg","nickname":"vince","note":"","ucode":"90DC7EA30D34B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72572,"discussion_content":"+1赞，一看就有这种感觉！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575506073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60308,"discussion_content":"的确，我想的一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574726680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173535,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1579591183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"126133642767","product_id":100039001,"comment_content":"万人血书，请老师讲解最优的方案，顶起来！！","like_count":30},{"had_liked":false,"id":155045,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1592092,"ip_address":"","ucode":"FF41E5D87BAD76","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/1c/5eb03a91.jpg","comment_is_top":false,"comment_ctime":1574640898,"is_pvip":false,"replies":[{"id":"60030","content":"可以的...","user_name":"作者回复","comment_id":155045,"uid":"1190123","ip_address":"","utype":1,"ctime":1574853463,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"96063921410","product_id":100039001,"comment_content":"希望作者能在课程末尾梳理下上一节课程的课后习题，或者集中点评下大家的留言。感谢","like_count":22,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475644,"discussion_content":"可以的...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574853463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586189,"discussion_content":"这个做了吗？在哪里可以找到答疑呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662026035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158697,"user_name":"kk","can_delete":false,"product_type":"c1","uid":1001181,"ip_address":"","ucode":"4C96F29C822E1D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/dd/8281f351.jpg","comment_is_top":false,"comment_ctime":1575435891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"83179814515","product_id":100039001,"comment_content":"希望老师，在每一节课能回答一下上一节课的问答","like_count":19},{"had_liked":false,"id":155042,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574640500,"is_pvip":false,"replies":[{"id":"60029","content":"理解的没问题！","user_name":"作者回复","comment_id":155042,"uid":"1190123","ip_address":"","utype":1,"ctime":1574853437,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"61704182644","product_id":100039001,"comment_content":"打卡✔<br>继承的层次过深带来的缺点看明白了，组合和委托不太理解，回头又好好看了看代码，视乎理解了，希望不要忘记了。也不知道是否理解对了？<br>记下自己的体会：<br>组合——类中包含其他实现类，感觉就是把大的功能分成多个类来实现，然后再根据需要组合进来使用。<br>委托——类中实现接口方法的时，把具体的实现方法调用其他类中的方法处理，也就是委托给别人（被委托者）帮他写好具体的实现。","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475642,"discussion_content":"理解的没问题！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574853437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271420,"discussion_content":"总结的挺经典的呀，哈哈。给个赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590134447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155135,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1574650031,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"57409224879","product_id":100039001,"comment_content":"GO完全摒弃了继承，在语法上只有组合，接口之间也可以组合(这也是官方鼓励的做法)。","like_count":13,"discussions":[{"author":{"id":1056127,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","nickname":"hetiu","note":"","ucode":"35D9338C3ABD20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101590,"discussion_content":"go的匿名组合颇有继承的味道","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577288470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2421338,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f2/5a/399ff23b.jpg","nickname":"越客","note":"","ucode":"2BF54F35774744","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1056127,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","nickname":"hetiu","note":"","ucode":"35D9338C3ABD20","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345434,"discussion_content":"还是多重继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611719866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":101590,"ip_address":""},"score":345434,"extra":""}]},{"author":{"id":1119851,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/6b/af7c7745.jpg","nickname":"tiny🌾","note":"","ucode":"7A4DE00381D1F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589826,"discussion_content":"go开发，还用看这专栏吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665328139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392924,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rRCSdTPyqWcW6U8DO9xL55ictNPlbQ38VAcaBNgibqaAhcH7mn1W9ddxIJLlMiaA5sngBicMX02w2HP5pAWpBAJsag/132","nickname":"butterfly","note":"","ucode":"1B724973303FB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285333,"discussion_content":"go是组合加接口，没了继承。那本节中提到的特殊场景，应该是没办法处理的\n“还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现“","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592810726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1763900,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ea/3c/24cb4bde.jpg","nickname":"疯狂的石头","note":"","ucode":"65CE6EB494FDCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1392924,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rRCSdTPyqWcW6U8DO9xL55ictNPlbQ38VAcaBNgibqaAhcH7mn1W9ddxIJLlMiaA5sngBicMX02w2HP5pAWpBAJsag/132","nickname":"butterfly","note":"","ucode":"1B724973303FB0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550540,"discussion_content":"go不会出现这种场景哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644581331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285333,"ip_address":""},"score":550540,"extra":""}]},{"author":{"id":1007670,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/60/36/1848c2b7.jpg","nickname":"dovefi","note":"","ucode":"9F8C59F095B187","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213367,"discussion_content":"喜欢go，干净利落","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585065386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156516,"user_name":"Brian","can_delete":false,"product_type":"c1","uid":1057945,"ip_address":"","ucode":"4C930BF5051EE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/99/694d5ee7.jpg","comment_is_top":false,"comment_ctime":1574904754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48819545010","product_id":100039001,"comment_content":"目前一项目中使用SpringBoot开发，其中对象定义为入参为DTO，数据库实现为Entity，业务返回结果为VO，三者对象完全独立，其中大部分属性相同，在 DTO对象 添加 convertToEntity 方法，Entity 添加 convertToVO 方法，实现对象属性拷贝。 同时在DTO和VO中使用组合方式，有很少数的继承。","like_count":11},{"had_liked":false,"id":155123,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1574649011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44524321971","product_id":100039001,"comment_content":"谈谈对下面一段话的理解：<br><br><br>“我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。”<br><br>理解或总结如下：<br><br>1、“比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代”，我的理解为：is-a意味着has-muilti-a&#39;s或者has-all-needed-a&#39;s。故而需要实现多个接口，而接口抽象的是操作或者方法而非数据（数据和方法的抽象由抽象类来完成），所以具体的操作要由被组合进来的类对象来完成，站在类间关系的角度来看，外部类和被组合类之间的关系被称为“委托”。<br><br>2、这里面，被组合类的代码被抽象到了接口中，或者反过来说接口的具体操作下沉到了被组合类中，这就是“代码复用我们可以通过组合和委托来实现”的含义，代码被不同的被组合类“分门（类）别类”的复用了。<br><br>3、“多态特性我们可以利用接口来实现”，因为接口代表了某种契约，而多态就是用子类代替父类。只要实现了某种接口，按照契约，自然就可以在某些方面或某种程度上代替父类。所以我觉得接口是“更细粒度更多控制的更有节制的继承”。<br><br>回到本课的问题。<br><br>之前的课说到VO，BO，Entity是典型的面向过程的编码，里面基本都是数据，没有方法。那么自然不可以用接口来减少代码的重复，只能用继承了。<br><br>但是MVC的结构，我理解它是一种分层客户端服务器架构，Layered Client-Server，每一层为其之上的层服务，并使用其之下的层所提供的服务。为了减少层之间的耦合，必要的重复是可以的。","like_count":10},{"had_liked":false,"id":237275,"user_name":"Hua100","can_delete":false,"product_type":"c1","uid":1723325,"ip_address":"","ucode":"4E7A749C343E90","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLeKVmTFdR2hQsCaNxxTK8wvnXXBayKLLoITqnbW9yjloAZWU99mOGaf1DkWqM6dol77aER9ickibA/132","comment_is_top":false,"comment_ctime":1595765160,"is_pvip":false,"replies":[{"id":"88025","content":"是的，你理解的没错。但是，并不是所有的语言中，接口都支持默认实现这个特性。","user_name":"作者回复","comment_id":237275,"uid":"1190123","ip_address":"","utype":1,"ctime":1596111664,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"40250470824","product_id":100039001,"comment_content":"请教一下，java8之后接口可以有default，那是不是就可以不需要使用组合+接口+委托了呢？是不是只需要接口+default方法就可以了？类似这样：<br>public interface Fly {<br>    default void fly(){<br>        &#47;&#47; 具体操作<br>    }<br>}<br>&#47;&#47; Tweetable, Eggable同理<br>public class Ostrich implements Tweetable, Eggable {<br>    public void egg(){<br>        Eggable.super.egg();<br>    }<br>    &#47;&#47; tweet同理<br>}<br>不知道我的理解对不对，我感觉这样就没必要用三个技术结合的方式。求大佬解答。","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502360,"discussion_content":"是的，你理解的没错。但是，并不是所有的语言中，接口都支持默认实现这个特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596111664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393482,"discussion_content":"dto,vo,entity，怎么弄?大部分字段都差不多，目前我实际都是用的继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631450313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155058,"user_name":"李湘河","can_delete":false,"product_type":"c1","uid":1349528,"ip_address":"","ucode":"DB078B5DAAE82E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","comment_is_top":false,"comment_ctime":1574642260,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40229347924","product_id":100039001,"comment_content":"现代军事武器中的开发都在追求模块化开发，这样装备之间通用性更强，战损时随时可以替换掉损坏的模块，这样又可以重新作战，当要增强坦克某一部分的性能时，仅改进对应的模块就行，感觉很像组合的思想。就像文中说的，对于结构稳定，层次浅的地方完全可以用继承，或者说可以局部用继承，比如VO层，对于用户检验，分页等都可以抽象出来","like_count":9,"discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292711,"discussion_content":"人类思考处理问题的本质还是都差不多的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595313687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217306,"avatar":"https://static001.geekbang.org/account/avatar/00/12/93/1a/5bb29be9.jpg","nickname":"曹玉磊","note":"","ucode":"BD46077D348F75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61444,"discussion_content":"觉得这个更像是面向接口编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574779472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155193,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1574659486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35934397854","product_id":100039001,"comment_content":"1.bo vo和entity三个命名在现在面向服务而非页面的后端编程，并不合适。<br>2.这里最好用组合。entity是最小的实体单元，bo可能面对多个entity聚合，vo可能面对多个bo聚合，这种场景下，显然组合更适合。虽然也存在entity和bo一对一的场景，或者bo中只有一个主entity的场景，这种场景用继承倒也不为过。但是，为了套路单一，减少阅读思考，统一组合便是，没必要再引入继承。<br><br>3.老项目里面，代码已经高度耦合，而且不是面相接口写的代码，那么整体改动成本会很大。这种情况下用继承实现多态我觉得挺合适。<br><br>4.java1.8提供接口的方法默认实现后，我觉得继承的处境真的挺尴尬，新项目反正能用继承实现的用组合也可以。所以除非父子关系特别明显（继承不深其实比组合直观），不然没什么必要用继承了。","like_count":8},{"had_liked":false,"id":155024,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574638524,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35934376892","product_id":100039001,"comment_content":"Entity，也称为DO （Data Object），与数据库表结构一一对应，到过DAO层向上传输对象，应独立为一个类。<br><br>BO，VO 可以采用继承或者组合的方式，复用DO的代码。<br><br>谨慎使用继承方式来进行扩展，不得已使用的话，必须符合里氏替换原则，父类能够出现的地方子类一定能够出现。","like_count":8},{"had_liked":false,"id":174684,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1580350941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27350154717","product_id":100039001,"comment_content":"vo， entity， bo只承载数据，不承载业务。虽然具有重复的代码，但却服务于不同的业务，采用任何一种方式都会耦合，不如就让代码重复着","like_count":6},{"had_liked":false,"id":155098,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574645752,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27344449528","product_id":100039001,"comment_content":"很多同学提出复用Entity（DO），我有不同意见：若修改DO，可能会影响到BO和VO。<br>我们都知道DO对应数据表，如PersonDO类有id，age，name。<br>若现在需求改变，age要从政府系统获取，原有的Person表要删除age字段，相应的DO类就要修改，UI仍然显示person.age。BO、VO有如果使用了DO就会受到影响。<br>为了降低影响，BO,VO考虑使用PersonDTO。<br>上面的例子中DTO中保留Person.age属性，在Service层中将DO转换为DTO，转换时PersonDTO.age从其他系统获取。<br>这样虽然增加了代码量，对DAO层的修改影响降到最低。","like_count":6},{"had_liked":false,"id":154999,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1574613914,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27344417690","product_id":100039001,"comment_content":"我的个人感觉,等待高手更好的回答&#47;&#47;<br>Entity在VO,BO中基本上都是一模一样的,使用组合把Entity引用进来,然后在BO,VO中创建各自独特的属性&#47;","like_count":6,"discussions":[{"author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87735,"discussion_content":"这样的话，其实对于前端数据的展现不是很友好，毕竟简单对象嵌套了两层+。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576677947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369757,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7WkTI1IicbKvsPJng5vQh5qlrf1smbfl2zb7icHZfzcAk1k4lr8w8IDEAdrqq1NHW5XZMPXiaa1h7Jn1LGOWOCkIA/132","nickname":"早起不吃虫","note":"","ucode":"13CD3B5E1F9435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538599,"discussion_content":"增加了解析层级，并且会徒增无意义字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639453758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154995,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1574612376,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"27344416152","product_id":100039001,"comment_content":"打卡✔<br>老师好，今天刚用继承优化了代码臃肿的问题，但是感觉好奇怪，请老师指导:<br>所有的消息都会先到一个A类中，在A类中，根据消息类型，比如类型1 2 3 4去处理不同的业务，每一类的业务都需要处理对应数据，原本随着消息类型的增加不断往这个A类中扩展代码，导致不好维护，所以我对每个业务模型建对应的类继承这个A类，在A类中将消息转给对应类去处理，其实new一个类 将所有参数传过去也可以，但是因为参数太多太多不美观，所以使用了继承，但回过头来想，我的继承只是被动使用的，好像和继承的原理相违背","like_count":6,"discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57663,"discussion_content":"A类里面加个工厂，通过工厂映射到处理类，每个类实现自己的业务，差不多是策略模式，参数构造一个参数类，每次都传类过去，这样可行吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574639952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1234314,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","nickname":"东征","note":"","ucode":"DC557A1631A493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58143,"discussion_content":"赞同，工厂加策略模式，将变化的部分抽作一个接口，工厂中维护接口的所有实现类（可以用spring注入list或map，比较方便动态发现），接口可以定义一个gettype方法，工厂中通过type寻找对应实现类做对应处理逻辑","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574654253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57663,"ip_address":""},"score":58143,"extra":""}]},{"author":{"id":1150755,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/23/bef3d8e9.jpg","nickname":"三省吾身","note":"","ucode":"7D68290C66CA68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70198,"discussion_content":"你应该使用组合加策略，实现分发类不用变更，只需要根据业务类型写具体实现类就可以。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575336089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57907,"discussion_content":"这个问题我理解不是出在A类，也不是出在对A类的继承，因为A类要接收消息，而子类需要依赖父类的资源。所以我认为问题出在对A类的调用上。当有新消息出现的时候，不要直接调用A的方法，也就是不要让A去区分应该给哪个子类处理。而是在调用方根据消息类型决定调用A的哪个子类。此处就跟失火🔥的夏天说的一样了，工厂模式或者策略模式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574646019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57937,"discussion_content":"感谢评论\n但是调用者是不知道的，一个控件显示若干数据，每条数据内部有个标记位，所有数据按照顺序显示","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574646831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57907,"ip_address":""},"score":57937,"extra":""},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58031,"discussion_content":"调用者调用一个工厂方法，工厂方法持有A的引用。这样呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574649745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57937,"ip_address":""},"score":58031,"extra":""},{"author":{"id":1584787,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/93/029eee99.jpg","nickname":"阿维","note":"","ucode":"84CBFDBD016806","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60967,"discussion_content":"我也有同样的问题，一个对象传过来几百项数据，我要把数据分类再分发到其他模块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574767691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57937,"ip_address":""},"score":60967,"extra":""}]},{"author":{"id":2358638,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","nickname":"Amber","note":"","ucode":"650FE5C46CCD1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334685,"discussion_content":"把A拆分为抽象类class Message{virtual void handle() = 0; };不同消息类型继承或实现Message中的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607936643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86657,"discussion_content":"把代码贴出来，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576598171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58067,"discussion_content":"感觉你的A类的设计是为了方便调用者，事物在A类处理，消息分类，我觉的这很符合策略模式的应用场景，不妨试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574650929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":58118,"discussion_content":"好的\n感谢指导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574652873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":58067,"ip_address":""},"score":58118,"extra":""}]}]},{"had_liked":false,"id":155760,"user_name":"废材姑娘","can_delete":false,"product_type":"c1","uid":1047537,"ip_address":"","ucode":"6AFB48B2A4939A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/f1/a2cde35e.jpg","comment_is_top":false,"comment_ctime":1574750181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23049586661","product_id":100039001,"comment_content":"很想知道老师对思考题的答案，困扰我很久了","like_count":5},{"had_liked":false,"id":155741,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1574747051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18754616235","product_id":100039001,"comment_content":"VO就是用来指定对外暴露的字段，跟DO不算是is-a关系，稳定性也不高，所以个人认为不需要处理和DO的重复代码","like_count":4},{"had_liked":false,"id":156225,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1574839411,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14459741299","product_id":100039001,"comment_content":"可以使用组合+继承来解决代码重复的问题，但实际项目中我更倾向于不同层次之间的冗余(前提是MVC框架)，因为我理解的优秀的代码是服务于优秀的设计架构的，也就是说不通层次之间的代码中肯定会有冗余，因为数据是在不同层次中流转的。不过在同一个层次中的代码冗余就有优化的必要了","like_count":3},{"had_liked":false,"id":155632,"user_name":"ANYI","can_delete":false,"product_type":"c1","uid":1084773,"ip_address":"","ucode":"B010B0FB10E0C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/65/633a7478.jpg","comment_is_top":false,"comment_ctime":1574730844,"is_pvip":false,"replies":[{"id":"60018","content":"恩恩，好的，抽空答疑一下","user_name":"作者回复","comment_id":155632,"uid":"1190123","ip_address":"","utype":1,"ctime":1574850954,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"14459632732","product_id":100039001,"comment_content":"这个课堂讨论，争哥啥时候可以给大家讲解下，这个貌似都是大家比较关注的点，😄","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475814,"discussion_content":"恩恩，好的，抽空答疑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574850954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1113307,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fc/db/56b0d13c.jpg","nickname":"豌豆","note":"","ucode":"0C35FD827F9BFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":554914,"discussion_content":"是呀，老师什么时候解答一下这个问题呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646659370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475814,"ip_address":""},"score":554914,"extra":""}]},{"author":{"id":1535005,"avatar":"https://static001.geekbang.org/account/avatar/00/17/6c/1d/203e2917.jpg","nickname":"zhao健枫的微信ID确实有点长啊","note":"","ucode":"46C5D8EBE40109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299069,"discussion_content":"快一年过去了，争哥这个空还没抽出来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597553886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155032,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1574639518,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14459541406","product_id":100039001,"comment_content":"这次的思考题正好也是困惑我很久的问题，看看大家有什么好的方式。<br>之前我的做法是用组合+委托的方式，但发现这种方式其实还是无法实现分层，即间接的将两个硬关联起来，增减属性的时候需要同时修改两个对象的代码；<br>如果是继承关系，那么相当于多出一个类，让三个对象同时继承该类，但这个新衍生出的对象又怎么理解它呢？它与其他三个对象是否有is-a的关系？不能单纯的为了复用而继承。<br>最后我极端的做法是将三者合为一体，抽象理解成“数据承载对象”…哈哈，但是这个对于VO对象，通常需要根据接口要求返回特定格式的数据，所以变成不伦不类的对象了。<br>😭","like_count":3,"discussions":[{"author":{"id":1038798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/ce/4528cb4b.jpg","nickname":"呼呼","note":"","ucode":"5D7B57C05B5D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84882,"discussion_content":"我基本也是这样处理，三者合一，但是在controller重新自定义了responsebody注解，在json转换的时候排除掉一些字段。现在唯一没解决的问题是在do里是uid，但在vo中应该是User对象，这种好像没啥好办法。不过有些数据层框架也支持直接用user属性的id关联数据库。这样就完全没必要考虑do bo vo之间的问题了，直接一个do解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576507899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298006,"user_name":"geek_666888","can_delete":false,"product_type":"c1","uid":2024635,"ip_address":"","ucode":"3E348CCE186ACF","user_header":"","comment_is_top":false,"comment_ctime":1623886896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10213821488","product_id":100039001,"comment_content":"很多人建议作者给出答案。我也很想知道答案，但又不想知道答案。<br>看作者《数据结构和算法之美》的时候，作者有句话我一直记着，大概“思考过程远比标准答案重要。”<br>我想这也是作者不向其他作者直接给答案的原因。<br>第二点，评论中也有很多大佬给出自己的见解，技术问题的处理从来都是思辨的过程，没有标准答案。","like_count":2},{"had_liked":false,"id":244409,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1598509394,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10188443986","product_id":100039001,"comment_content":"Entity、BO、VO 对于这三个，如果只考虑这节课说的，那么抽出共有的类，各个类将这个共有类作为自己的属性即可。<br>但是就整个代码体系来看，他们各自的职责完全不相同且各个model对应的处理层也不同。完全没有必要为了消除重复去特殊化处理。重复就让他们重复好啦。","like_count":2,"discussions":[{"author":{"id":1139367,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","nickname":"K战神","note":"","ucode":"527E6BB26BB766","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322024,"discussion_content":"同意，职责不一样，为了复用而进行聚合抽离，我觉得和你的想发一样，各自保持自己的独立性，一个类，只能有一个影响点，独立更好。\n\n不是所有的代码重复，就要消除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604664099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238896,"user_name":"旭塬","can_delete":false,"product_type":"c1","uid":1812849,"ip_address":"","ucode":"EF058DA2927A36","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/71/4f911305.jpg","comment_is_top":false,"comment_ctime":1596359913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10186294505","product_id":100039001,"comment_content":"用面向对象编程的思想来说，要保证最小功能粒度分开，VO.BO.Entity的功能场景不一样，就必须分开，不能因为一些代码重复就强行关联在一起，这也不利于解藕。<br>","like_count":2},{"had_liked":false,"id":155965,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1574785020,"is_pvip":false,"replies":[{"id":"60017","content":"你的意思是通过接口调用两个方法对吧，如果实在有这个需求，可以重新定义一个接口，extends另外两个接口。不过，你说的spring注入的情况，完全可以不依赖接口呀，直接依赖实现类也可以的。","user_name":"作者回复","comment_id":155965,"uid":"1190123","ip_address":"","utype":1,"ctime":1574850716,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164719612","product_id":100039001,"comment_content":"老师，针对你举鸟的例子：使用组合＋接口＋委托 代替继承的例子。如果在Spring中，怎么通过接口（自动注入）调用Ostrich鸵鸟的实现方法（下蛋和叫）？Tweetable和EggLayable接口各定义一个接口变量由鸵鸟初始化？这样感觉雍余了。<br>请解答一下？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475942,"discussion_content":"你的意思是通过接口调用两个方法对吧，如果实在有这个需求，可以重新定义一个接口，extends另外两个接口。不过，你说的spring注入的情况，完全可以不依赖接口呀，直接依赖实现类也可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574850716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155626,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1206726,"ip_address":"","ucode":"3B8DC780FE4EF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg","comment_is_top":false,"comment_ctime":1574730206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164664798","product_id":100039001,"comment_content":"结合DDD领域驱动设计，不是应该每层都做转换吗？例如dto，bo，po等。","like_count":2},{"had_liked":false,"id":155450,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1574690176,"is_pvip":false,"replies":[{"id":"60019","content":"也可以用组合的，组合也能解决复用的问题","user_name":"作者回复","comment_id":155450,"uid":"1190123","ip_address":"","utype":1,"ctime":1574851586,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164624768","product_id":100039001,"comment_content":"请问老师，好多类想要拥有相同的一个属性，考虑到代码复用性，是否只能继承啦","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475756,"discussion_content":"也可以用组合的，组合也能解决复用的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574851586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155410,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1574686500,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10164621092","product_id":100039001,"comment_content":"go语言对组合的支持更加纯粹，比java优雅。<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>type Flyable interface {<br>\tfly() error<br>}<br><br>type FlyAbility struct {<br>}<br><br>func (b *FlyAbility) fly() error {<br>\tfmt.Println(&quot;I can fly.&quot;)<br>\treturn nil<br>}<br><br>&#47;&#47;省略 Tweetable&#47;TweetAbility&#47;EggLayable&#47;EggLayAbility<br><br>type Ostrich struct {<br>\tFlyAbility<br>\t&#47;&#47; TweetAbility<br>\t&#47;&#47; EggLayAbility<br>}<br><br>func main() {<br>\tvar flyable Flyable = &amp;Ostrich{}<br>\tflyable.fly()<br>}","like_count":2,"discussions":[{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165370,"discussion_content":"接口也可以组合一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581266391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165369,"discussion_content":"乐高模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581266322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155192,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1574659278,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10164593870","product_id":100039001,"comment_content":"entity就不用动了，VO和BO都可以使用组合entity。我自己曾经抽取过VO和BO的共同属性，这个方法特别不好，只要父类要修改，子类也要跟着修改，子类调用的方法也要修改。<br><br>如果用组合的方式，那改动就会相对少很多。代码也会清晰很多。<br><br>要是很多entity有共同的属性，倒是可以抽出来作一个抽象类。","like_count":2,"discussions":[{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79930,"discussion_content":"考虑用组合是因为 默认了 VO和BO的内容都多于entity。如果页面需要展示的内容或逻辑处理的内容没有entity那么多字段，多出的字段也影响性能吧。花儿少年的答案感觉更好些。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576124488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155060,"user_name":"傲慢与偏执，","can_delete":false,"product_type":"c1","uid":1236496,"ip_address":"","ucode":"E9F81223DFAD24","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/10/9f15527d.jpg","comment_is_top":false,"comment_ctime":1574642608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164577200","product_id":100039001,"comment_content":"我只有在该类需要更细化详情信息的时候会组合详情类的list 看了这节课后 受益匪浅","like_count":2},{"had_liked":false,"id":155056,"user_name":"欠债太多","can_delete":false,"product_type":"c1","uid":1099238,"ip_address":"","ucode":"B0CC91FA6F3981","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/e6/50c5b805.jpg","comment_is_top":false,"comment_ctime":1574642112,"is_pvip":true,"replies":[{"id":"60025","content":"好像不合适，怎么通过vo和bo组合成entity呢？","user_name":"作者回复","comment_id":155056,"uid":"1190123","ip_address":"","utype":1,"ctime":1574853130,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164576704","product_id":100039001,"comment_content":"我们现在采用entity实现，VO和BO都去继承它，减少代码重复。看了专栏后，我认为可以通过讲VO和BO组合成Entity实现，不知道这样做，是不是合适","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475648,"discussion_content":"好像不合适，怎么通过vo和bo组合成entity呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574853130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318936,"user_name":"July 💫","can_delete":false,"product_type":"c1","uid":1761335,"ip_address":"","ucode":"0DC25F063E9E90","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e0/37/40b6711b.jpg","comment_is_top":false,"comment_ctime":1635486328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930453624","product_id":100039001,"comment_content":"笔记<br>&gt; **经典的设计原则之一：组合优于继承，多用组合少用继承。**<br><br>### 继承<br><br>1. 继承的缺点：<br><br>  - 继承层次过深<br><br>  - 过于复杂<br><br>  - 影响代码的可读性和可维护性<br><br>  - 父类和子类耦合度高<br><br>- 继承的优点：<br><br>  - 表示is-a关系<br><br>  - 支持多态特性<br><br>  - 代码复用<br><br>### 组合<br><br>  1. 组合的优点：<br><br>    - 包括组合，接口，委托三个技术点<br><br>    - 接口表示has-功能<br><br>    - 委托表示依赖驻入<br><br>    - 组合实现多个接口，既分离不同功能，还减少了耦合，提高代码复用<br><br>  1. 组合的缺点：<br><br>    - 更细粒度的类的拆分<br><br>    - 增加代码复杂程度<br><br>    - 提高维护成本<br><br>### 最少知识原则或者迪米特法则（Least Knowledge Principle）<br><br>  1. 暴露不该保留的接口给外部，增加了类使用过程中被误用的原则<br><br>  2. 封装，抽象类，接口，共同的特性是限制，限制才能避免误用。<br><br>### 总结<br><br>1. 为什么不推荐使用继承？<br><br>  继承是面向对象编程的四大特性之一，用来表示is-a的关系，可以解决代码复用的问题，虽然继承存在多种作用，但是继承层次过深，过于复杂，也会影响到代码的可读性和可维护性，所以针对这类场景，尽量少用继承，甚至不用。<br><br>1. 组合相比继承有哪些优势？<br><br>  继承的三大作用：表示is-a的关系，支持多态，解决代码复用，而这三个作用可以通过组合，接口，委托来实现，除此之外，组合还可以解决层次过深，过于复杂的继承关系影响代码可读性和可维护性的问题。<br><br>1. 如何判断什么时候该使用继承还是组合呢？<br><br>  在实际的项目开发中，要根据实际情况考虑选用哪一种，如果类的继承结构稳定，层次单一，关系不复杂，就可直接使用继承，反之则需要使用组合来替代继承。除此之外，一些特定的设计模式，特殊的应用场景会固定使用继承或者组合。","like_count":1},{"had_liked":false,"id":299769,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1624853172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5919820468","product_id":100039001,"comment_content":"能集中解答下课程中提出的问题吗？非常想知道最优做法。","like_count":1},{"had_liked":false,"id":191572,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584782736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879750032","product_id":100039001,"comment_content":"个人观点：我们变成是围绕着数据打桩的，BO、VO、Entity，核心是需要持久化的Entity，BO为了更好的进行业务处理在VO上进行扩展，VO则是为了展示在Entity上的扩展。当然VO、BO各自也有属于自己层面的属性，需要做到暴露“共有”属性，隐藏“特有”属性。BO、VO可以扩展(继承)Entity，又各自“特有”属性。可以借鉴组合的思路，BO、VO各自一些属于自己逻辑层的特有属性","like_count":1},{"had_liked":false,"id":175394,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1580704506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875671802","product_id":100039001,"comment_content":"C++有多继承，也可以使用虚继承来避免菱形继承存在的问题，这样是否也可以解决文章中提到的各种鸟的问题啊。","like_count":1},{"had_liked":false,"id":166834,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1577609222,"is_pvip":false,"replies":[{"id":"64826","content":"可以的 等后面有时间了吧 年底比较忙","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577666123,"ip_address":"","comment_id":166834,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5872576518","product_id":100039001,"comment_content":"老师能不能加餐集中解答一周的问题，有些老师提问的刚好我们在项目中也思考过，就是没找到很好的解决方案","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479647,"discussion_content":"可以的 等后面有时间了吧 年底比较忙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380984,"discussion_content":"好像没有找到答疑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624853267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166154,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1577409420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872376716","product_id":100039001,"comment_content":"<br>一、为什么不推荐使用继承？<br>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。<br><br>二、组合相比继承有哪些优势？<br>继承主要有三个作用：表示is-a关系，支持多态，代码复用。这三个作用可以使用其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。<br><br>三、如何判断该用组合还是继承？<br>1.继承改写成组合要做更细粒度的拆分，定义更多的类和接口，或多或少会增加代码的复杂程度和维护成本，实际的项目开发中，要根据具体的情况，来选择该用继承还是组合。<br>2.如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。<br>3.一些设计模式也会固定使用继承或组合。比如装饰者模式、策略模式、组合模式等使用了组合关系，模板模式使用了继承关系。<br><br>四、具体案例<br>1.如果A类和B类都用到了某个功能，但是用业务上来讲它们既不是父子关系，也不是兄弟关系。这时候为了代码复用，就不应该生硬的抽象出一个父类出来，会影响到代码的可读性，这时候使用组合更加合理。<br>2.如果不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。","like_count":1},{"had_liked":false,"id":155641,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1574731785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869699081","product_id":100039001,"comment_content":"Entity、BO、VO 这个重复代码问题也纠结过，BO，VO不需要 Entity 的所有属性，所以继承不大合适。用组合的话要套个其他实例单独写方法，麻烦。现在都是直接单独写，重复就重复了，而且一般也不会有复杂的逻辑，就重复属性和 getter&#47;setter。<br>特别想知道这个问题合适的做法。希望老师能在下节讲下上一节的问题，再布置下下节的问题，个人感觉这种方式比放到统一答疑章节要好很多。","like_count":1},{"had_liked":false,"id":155527,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1574695750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869663046","product_id":100039001,"comment_content":"1、我们现在的项目只有Entity与VO，而且两者之间互不相关，确实有太多的属性和方法重复了。<br>2、思考题：学习了今天内容，个人觉得可以使用委托和组合的方法，将Entity与VO共有属性抽象出来一个类，然后Entity与VO来组合此类。","like_count":1},{"had_liked":false,"id":155247,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1574671366,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5869638662","product_id":100039001,"comment_content":"&lt;?php<br>&#47;&#47;叫<br>interface jiaoable<br>{<br>    public function jiao();<br>}<br>&#47;&#47;飞<br>interface flyable<br>{<br>    public function fly();<br>}<br>&#47;&#47;下单<br>interface eggable<br>{<br>    public function egg();<br>}<br><br>&#47;&#47;叫的实现类<br>class jiaoablity implements jiaoable<br>{<br>    public function jiao()<br>    {<br>        echo &#39;jiao&#39;;<br>    }<br>}<br><br>&#47;&#47;鸵鸟类<br>class tuoniao implements jiaoable,eggable<br>{<br>    private $jiaoobj;<br><br>    public function __construct()<br>    {<br>        $this-&gt;jiaoobj = new jiaoablity();<br>    }<br><br>    public function jiao()<br>    {<br>        $this-&gt;jiaoobj-&gt;jiao();<br>    }<br><br>    public function egg()<br>    {<br>        echo &#39;我是鸵鸟我会下单&#39;;<br>    }<br>}<br><br>&#47;&#47;麻雀类<br>class maque implements jiaoable, flyable<br>{<br>    private $jiaoobj;<br><br>    public function __construct()<br>    {<br>        $this-&gt;jiaoobj = new jiaoablity();<br>    }<br><br>    public function jiao()<br>    {<br>        $this-&gt;jiaoobj-&gt;jiao();<br>    }<br><br>    public function fly()<br>    {<br>        echo &#39;我是麻雀我会飞&#39;;<br>    }<br>}<br>","like_count":1,"discussions":[{"author":{"id":2730834,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ab/52/7da45fc4.jpg","nickname":"Lancer","note":"","ucode":"6F0D2FBA72E69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394407,"discussion_content":"这个叫 “jiaoable”着实把我逗笑了~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631869972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297921,"discussion_content":"还有麻雀也会下蛋","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597111038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242122,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","nickname":"YourSweetHeart","note":"","ucode":"38843F447B03F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62540,"discussion_content":"😂😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574850482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155064,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1574642780,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"5869610076","product_id":100039001,"comment_content":"因为Entity， BO， VO都是描述对象的，只不过是用于不同目的的对象，这些对象之间会有很多重复的元素定义，针对这样的重复定义，我倒是感觉可以使用继承，将重复的那些元素都提取出来作为父类，然后entity，VO，BO去继承这个父类，在实现自己独有的元素。而接口主要是针对不同能能的复用，用在E，B，V身上并不合适。","like_count":1,"discussions":[{"author":{"id":1190085,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/c5/3a880251.jpg","nickname":"李鑫|MT","note":"","ucode":"D9985A7D2EC2FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57903,"discussion_content":"不太可行吧，Entity的代码多数都是根据表结构自动生成的，怎么抽取？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574645927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1132337,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","nickname":"小晏子","note":"","ucode":"3AAA6FB5ACB6AE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1190085,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/c5/3a880251.jpg","nickname":"李鑫|MT","note":"","ucode":"D9985A7D2EC2FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58551,"discussion_content":"VO BO里面应该有字段跟entity名字一样的吧 就把那些抽出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574680725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57903,"ip_address":""},"score":58551,"extra":""}]}]},{"had_liked":false,"id":155002,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574614426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869581722","product_id":100039001,"comment_content":"这种的我认为继承会好一点，将公用属性抽离到父类中，因为他的层次最多两层，而且用组合的话可能会带来某些不便，比如vo里面放个其他类，返回给客户端的时候属性分为两层，共有属性是在子json对象里的，感觉不妥。","like_count":1},{"had_liked":false,"id":155001,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1574614131,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869581427","product_id":100039001,"comment_content":"这篇文章，受益匪浅，激动的睡不着觉了。","like_count":1,"discussions":[{"author":{"id":1188524,"avatar":"https://static001.geekbang.org/account/avatar/00/12/22/ac/fc8e435a.jpg","nickname":"郭凯强","note":"","ucode":"002F58C3640560","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57645,"discussion_content":"……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574639129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359554,"user_name":"Will Zhang","can_delete":false,"product_type":"c1","uid":3197012,"ip_address":"上海","ucode":"294B06E7EFEB18","user_header":"https://static001.geekbang.org/account/avatar/00/30/c8/54/8d27cb56.jpg","comment_is_top":false,"comment_ctime":1665642782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665642782","product_id":100039001,"comment_content":"如果能像力扣一样能选择代码语言就好了，我对于那段组合委托就有点疑问，python没有接口的概念啊，如果用python语言改写应该怎么写呢？<br>直接在Ostrich类里面实例化TweetAbility和EggLayAbility这两个类然后调用对应的方法吗？<br>还是说和Java一样需要先用abc模块定义抽象接口，然后继承并通过组合委托实现抽象方法。","like_count":0},{"had_liked":false,"id":356478,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"广东","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662354929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662354929","product_id":100039001,"comment_content":"思考：<br>    Entity 类是直接与数据库操作的实体。 service类是聚合了与业务相关的信息，比如用户的订单信息会包含用户信息和订单信息。  VO 是具体请求返回的数据，可能 只包含了数BO的部分数据。<br><br>这章讲了为什么要多用组合少用继承。<br>    what<br>         继承的目的是为了代码的复用。如果继承的层次太深或者像例子的鸟类一样会导致代码不易维护，继承关系太复杂。比如阅读子类代码就要一直读到父类。父类代码修改影响子类，耦合。<br><br>  how <br>      可以用接口，组合，委托等来解决代码复用。<br>     比如鸟类会不会飞，会不会叫，替换成接口，来实现能力，如果有就实现该接口。如果功能一样，都要实现接口，也可以直接实现一个会飞的能力类。鸟类里使用组合即拥有该类的实列来解决这个问题。<br>不过这样也会造成要实现和维护的类很多。<br><br>设计模式中体现这个思想的有策略模式，装饰者模式。<br><br>如何判断时使用继承还是组合。<br>   1.继承关系确定，只有两层可以使用继承。<br>   2.设计模式、特殊的应用场景，会固定使用继承或者组合。<br>具体看业务场景吧。<br>","like_count":0},{"had_liked":false,"id":356165,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1662021043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662021043","product_id":100039001,"comment_content":"我们该如何处理 Entity、BO、VO 代码重复的问题呢？<br>我们现在的实现方式是提取出一个公共类，把能确定都会用到的字段放到这个公共类中，然后Entity,BO,VO都继承这个公共类，其他的个性化的就再自己当中定义。<br>学完本节之后，突然决定上面的方式其实效果很不好。因为肯定会有很多Entity和BO.VO三者之间互相交叉的情况，而且如果情况多了变成四个之间交叉的情况，会更加麻烦。如果只提取公共部分的那么可能都重合的字段会比较少。<br>这个地方我能想到方法来说细化共同点，多定义几个公共类，分别继承这样的。","like_count":0},{"had_liked":false,"id":351037,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657472747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657472747","product_id":100039001,"comment_content":"三者重复感觉是因为mvc架构模式开发把一次请求的处理分成了接口层处理，业务层处理，数据层处理三层，使得每一层可独立变化。消除重复问题能想到的解决方法：<br>1、三层合并为一层，会导致代码过于臃肿，可复用性极差<br>2、将重复代码封装函数，减少重复代码量（如果能通过语言提供的机制实现自动调用更好），但需要对不同的地方做特殊处理，需要衡量这样做利是否大于弊","like_count":0},{"had_liked":false,"id":347228,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1653831005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653831005","product_id":100039001,"comment_content":"课堂讨论: 没有必要为了复用代码而复用代码, 这个看起来结构挺清晰的, 大家都习惯了, 就让他重复就行.","like_count":0},{"had_liked":false,"id":345238,"user_name":"Geek_天涯tobe","can_delete":false,"product_type":"c1","uid":2354145,"ip_address":"","ucode":"8C95EE164CAB70","user_header":"https://static001.geekbang.org/account/avatar/00/23/eb/e1/71bb3704.jpg","comment_is_top":false,"comment_ctime":1652151764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652151764","product_id":100039001,"comment_content":"问下  怎么体现降低了父类和子类的高耦合的","like_count":0},{"had_liked":false,"id":345173,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652089899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652089899","product_id":100039001,"comment_content":"组合被用的少，是因为很多技术框架的组件必须要继承才能和框架一起工作。那么为何这些技术框架要用你使用继承呢，其实也是为了多态的便利性。","like_count":0},{"had_liked":false,"id":335388,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1645500354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645500354","product_id":100039001,"comment_content":"1.只要用到继承的类，将来需求是稳定的，不能随意更改的。<br>2.用组合的作用，是把相同的行为方法放到一个函数中，能提高复用性。<br>3.不用继承的原因，往往是因为复杂、难维护、嵌套过深等问题。<br>4.多用组合少用继承的原因是避免用那么多继承","like_count":0},{"had_liked":false,"id":329108,"user_name":"？","can_delete":false,"product_type":"c1","uid":2030035,"ip_address":"","ucode":"3043E00A056081","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f9/d3/2cb7516e.jpg","comment_is_top":false,"comment_ctime":1641125197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641125197","product_id":100039001,"comment_content":"但是单纯用组合处理有一个问题会不好处理，就是你暴露出去的vo其实大部分时候需要的字段都是没有entity多的，这种时候就会出现多余的对象的问题，其实很多时候都是一种取舍问题，只能根据你们的业务场景进行拆分才行。","like_count":0},{"had_liked":false,"id":317251,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1634721599,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1634721599","product_id":100039001,"comment_content":"组合跟继承都是必不可少的。组合强调的是面向接口编程，继承解决的是封装变化 &amp; 代码复用。可以说，整个设计模式讲的就是面向接口编程+用继承封装变化。关于Entity、BO、VO 三者的相似问题，我们的解决方案是独立发展，保证各层之间的隔离性，然后用mapstruct做转化避免无谓的转化代码。","like_count":0},{"had_liked":false,"id":316350,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1634281436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634281436","product_id":100039001,"comment_content":"什么时候用继承：<br>1.拥有is-a关系的时候。<br>2.继承关系稳定，层次浅，业务不复杂的时候<br>为什么尽量不用继承：<br>1.继承破坏父类的封装，将父类的成员暴露出来。<br>2.继承层次太深耦合性太强，可维护性降低。<br><br>替代继承：<br>用组合，接口，委托的方式替换继承关系。缺点是要写很多接口。<br><br>","like_count":0},{"had_liked":false,"id":316345,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1634279869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634279869","product_id":100039001,"comment_content":"上面那个把继承拆成接口，委托，组合的例子也可以这么写<br>public interface Flyable { <br>void fly()；<br>}<br><br>public class FlyAbility implements Flyable { <br>@Override <br>public void fly() {<br>\t&#47;&#47;... <br>\t}<br>}<br>&#47;&#47;省略Tweetable&#47;TweetAbility&#47;EggLayable&#47;EggLayAbility<br>public class Ostrich {&#47;&#47;鸵鸟 <br>\tprivate Tweetable twee &#47;&#47;组合 <br>\tprivate EggLayable eggLayable; &#47;&#47;组合 <br>\t<br>\tpublic Ostrich(Tweetable twee,EggLayable eggLayable){<br>\t\tthis.twee = twee;<br>\t\tthis.eggLayable = eggLayable;<br>\t\t<br>\t}<br>\t<br>\t&#47;&#47;... 省略其他属性和方法... <br>\tpublic void tweet() {<br>\t\ttwee.tweet(); &#47;&#47; 委托 <br>\t\t} <br>\tpublic void layEgg() {<br>\t\teggLayable.layEgg(); &#47;&#47; 委托 <br>\t\t}<br>\tpublic static void main(String[] args) {<br>\t\tTweetAbility tweetAbility = new TweetAbility(); &#47;&#47;组合 <br>\t\tEggLayAbility eggLayAbility = new EggLayAbility(); &#47;&#47;组合<br>\t\tOstrich o = new Ostrich(tweetAbility,eggLayAbility);<br>\t\t<br>\t\to.tweet();<br>\t\to.layEgg();<br>\t}<br>}","like_count":0},{"had_liked":false,"id":314584,"user_name":"振振","can_delete":false,"product_type":"c1","uid":1313365,"ip_address":"","ucode":"ECE08186230140","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/55/5e440425.jpg","comment_is_top":false,"comment_ctime":1633242839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633242839","product_id":100039001,"comment_content":"不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？<br><br>感觉这个例子讲的不太恰当，为啥“并且实现逻辑是一样的”？","like_count":0},{"had_liked":false,"id":312456,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1631806962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631806962","product_id":100039001,"comment_content":"继承与组合<br>\t关系浅时可用继承，复杂时组合代替，像装饰者模式、策略模式、组合、模板等设计模式<br>\t当没办法修改一个外部类代码时，可以通过继承形式进行重写函数代码<br>\t为什么不推荐用继承<br>\t\t继承层次过深，继承关系过于复杂影响可读性和可维护性<br>\t\t比如说粽子有甜的、咸的、辣的，AbstractSweet··· 同时还有方的三角形的，AbstractSweetTriangle··· 太过复杂<br>\t\t如果用接口实现<br>\t\t\t道滘粽子 implements Sweetable,Triangle <br>\t\t\t福建粽子 implements Slaty, Triangle<br>\t\t\t但每个粽子都要实现重复的三角形代码，造成代码重复<br>\t\t如果用组合实现<br>\t\t\t给接口定义实现类, TriangleAblity{ triangle(){ &#47;&#47;make triangle}<br>\t\t\t原本的实现地方通过委托，把实现代码交给Ablity<br>","like_count":0},{"had_liked":false,"id":301849,"user_name":"今夕是何年","can_delete":false,"product_type":"c1","uid":1111847,"ip_address":"","ucode":"2825454A7A1588","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7SOblVZ7dNJ88wkeYR0HklxdR9VuiaQ0GMscAnrlic6EjvRZS52m4n1VPypwZFsmabbJ4STZRbHFfVZE24Jjqr1w/132","comment_is_top":false,"comment_ctime":1625913611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625913611","product_id":100039001,"comment_content":"用继承，把公共的抽到父类里。<br>继承层次稳定，所以用继承比较合适。","like_count":0},{"had_liked":false,"id":301814,"user_name":"直走的螃蟹","can_delete":false,"product_type":"c1","uid":2683294,"ip_address":"","ucode":"8116812CF0A1F2","user_header":"","comment_is_top":false,"comment_ctime":1625895317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625895317","product_id":100039001,"comment_content":"我的理解是组合与委托都是为了使用其他类的方法。而不同在于其他类提供的方法是否一定要使用。组合是可用可不用;而委托是因为该类接口的关系必须使用。","like_count":0},{"had_liked":false,"id":294547,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1621995492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621995492","product_id":100039001,"comment_content":"三层的数据分析入下：<br>1.Entity 是直接面向数据库的，基本是一个Entity对应一个数据表<br>2.Bo 是通过业务逻辑对数据的组合，是一个Entity的全集或子集，也可能是多个Entity的全集或子集<br>3.Vo 是面向对外接口的数据<br>从这来看，三种数据有联系但大多数场景并无共性，分别面向不同使用场景。<br>结论：分别定义更方便每层的修改，没必要做统一。","like_count":0},{"had_liked":false,"id":294300,"user_name":"502819","can_delete":false,"product_type":"c1","uid":1787786,"ip_address":"","ucode":"9316B0001A18BD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/47/8a/a6ee3924.jpg","comment_is_top":false,"comment_ctime":1621867870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621867870","product_id":100039001,"comment_content":"个人感觉BO主要用于api暴露给调用方使用的，VO根据前端需要返回指定字段，两者都为了隐藏业务不需要的字段。。","like_count":0},{"had_liked":false,"id":294083,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1621753121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621753121","product_id":100039001,"comment_content":"把Entity、BO、VO这三者重复的代码单独抽取出来，组成一个新类，然后在这三个类的定义中，把新类组合进去，就能避免写重复的代码。","like_count":0},{"had_liked":false,"id":292319,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1620782193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620782193","product_id":100039001,"comment_content":"求这篇思考的回答。","like_count":0},{"had_liked":false,"id":290936,"user_name":"分神","can_delete":false,"product_type":"c1","uid":1093342,"ip_address":"","ucode":"173904DAE72B6F","user_header":"","comment_is_top":false,"comment_ctime":1619866167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619866167","product_id":100039001,"comment_content":"PHP的trait+interface用来替代继承会造成的问题时就很方便，很舒服","like_count":0},{"had_liked":false,"id":287033,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1617753981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617753981","product_id":100039001,"comment_content":"使用接口 组合 委托代替继承，解决类爆炸以及继承层次过深问题","like_count":0},{"had_liked":false,"id":282116,"user_name":"满目星河","can_delete":false,"product_type":"c1","uid":2455972,"ip_address":"","ucode":"6FE6EB6A58F080","user_header":"https://static001.geekbang.org/account/avatar/00/25/79/a4/353d4739.jpg","comment_is_top":false,"comment_ctime":1615095559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615095559","product_id":100039001,"comment_content":"思考题<br>虽然并不存在 is-a关系，但我觉得也可以使用继承。可以定义一个Base类，里面是共有的属性和方法。然后Entity、BO、VO继承这个Base。只有一层继承关系。","like_count":0},{"had_liked":false,"id":280004,"user_name":"没有心的人","can_delete":false,"product_type":"c1","uid":2449748,"ip_address":"","ucode":"F27D5894087B11","user_header":"https://static001.geekbang.org/account/avatar/00/25/61/54/5bf767e7.jpg","comment_is_top":false,"comment_ctime":1614051458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614051458","product_id":100039001,"comment_content":"第一次了解到委托这个概念，组合和委托这对组合拳感觉大有用处","like_count":0},{"had_liked":false,"id":275393,"user_name":"阿腾","can_delete":false,"product_type":"c1","uid":2263622,"ip_address":"","ucode":"FF1BEC88D98084","user_header":"https://static001.geekbang.org/account/avatar/00/22/8a/46/4f76078b.jpg","comment_is_top":false,"comment_ctime":1611500218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611500218","product_id":100039001,"comment_content":"如果系统设计得合理，类继承与对象组合可以相互配合。设计类时，通常倾向于考虑对象组合。然后寻找出冗余行为，进行设计细化。如果找到冗余行为，也许意味着此处应该使用类继承。—— 摘自《Objective-C 编程之道 —— iOS 设计模式解析》","like_count":0},{"had_liked":false,"id":274288,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610955824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610955824","product_id":100039001,"comment_content":"组合+接口+委托的模式，比较适合在业务框架比较清晰的情况下使用，所有业务都要拆分成“名称+动词”，就比较适合用这种模式。如果业务层次比较复杂，并且嵌套，这种模式就不再适用，比如，汽车在行驶过程中播着音乐，但遇到转弯打灯时，一边要停止音乐，一边要发出闪转弯灯时“啪啪”的提示音，等打灯完毕，要立即恢复音乐播放，这就是除了顺利成章的单一的“汽车有播放音乐”、“汽车有打转弯灯”这两个单体功能，还有条件触发的变化情况。这样的复杂情况，光接口、组合和委托还不够，还有流程设计在其中。","like_count":0},{"had_liked":false,"id":272191,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1609986038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609986038","product_id":100039001,"comment_content":"如果字段名都相同，且类型也相同，可以用反射做成通用的deep copy，其他的话可以手动deep copy","like_count":0},{"had_liked":false,"id":267722,"user_name":"刘建军","can_delete":false,"product_type":"c1","uid":2348590,"ip_address":"","ucode":"25210BF7BE6BA8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/We0naYhWttpJPDoO7TCndu5w1r4PSCdo57M61Zia8khXmM8GibicDzYdXiaJXZNok7274mSfB4aEMgxyiaDY1pRba0w/132","comment_is_top":false,"comment_ctime":1607905861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607905861","product_id":100039001,"comment_content":"我在做一个脚本语言的界面库，完全采用的继承，也是为了省代码，确实发现一下子类继承父类的方法有点莫名其妙","like_count":0},{"had_liked":false,"id":253641,"user_name":"小项91","can_delete":false,"product_type":"c1","uid":1251436,"ip_address":"","ucode":"EA3581C573B19C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/6c/afd17dd7.jpg","comment_is_top":false,"comment_ctime":1602818077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602818077","product_id":100039001,"comment_content":"组合相比于继承来说，将父概念的每一个属性细化成了一个组合（接口+实现）。如果这种属性非常多，而且基本上每个子类都需要这些属性，那么使用组合就没有必要了，直接使用抽象类继承更合适。<br><br>假如Father概念有a&#47;b&#47;c&#47;d&#47;e&#47;f五个属性，Son-1有a&#47;b&#47;c&#47;d&#47;e属性，Son-2有a&#47;b&#47;c&#47;e&#47;f属性，Son-3有a&#47;b&#47;c&#47;d&#47;f属性，且a&#47;b&#47;c&#47;d&#47;e&#47;f的实现是完全一样的。那么这么做是否合适？<br>先写一个抽象类AbstractFather，实现a&#47;b&#47;c方法。再分别写d&#47;e&#47;f的组合，让Son-1&#47;2&#47;3继承AbstractFather，分别实现d&#47;e&#47;f 接口。<br>（但是这样感觉又将d&#47;e&#47;f属性隔离在父概念之外了，有更好的办法吗？）","like_count":0},{"had_liked":false,"id":248573,"user_name":"Leon","can_delete":false,"product_type":"c1","uid":1051118,"ip_address":"","ucode":"782F7ECE08C0E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/ee/288d878c.jpg","comment_is_top":false,"comment_ctime":1600226409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600226409","product_id":100039001,"comment_content":"目前使用的是继承entity的方式，在多服务下，其实VO和Entity相差不多。个别敏感字在VO做处理，定制化的字段则在VO上加。","like_count":0},{"had_liked":false,"id":248203,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1600064266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600064266","product_id":100039001,"comment_content":"【要点】<br>1、不推荐使用继承的情况：如果继承层次过深、过复杂，会影响到代码的可维护性。这种情况下，我们应该少用甚至不用继承。<br>2、组合相比继承的优势：继承主要有三个作用，表示is-a关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。利用组合还可解决层次过深，过复杂的继承关系所带来的代码可维护性的问题。<br>3、用继承或组合的情况：如果类之间的继承结构稳定，层次比较浅，关系不复杂，就可以大胆地使用继承。反之，就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。<br>【思考】<br>Entity、VO、BO的重复不应该处理，VO、BO都是特定业务相关数据结构，他们内部其实并不涉及复杂的数据处理逻辑，很多时候就是数据的setter和getter，随着业务的变化而变化，VO和BO可能变化的比较多，Entity是数据表对应的，有最全的数据，相对稳定。应该让三者自己演化。","like_count":0},{"had_liked":false,"id":247276,"user_name":"Senior6623","can_delete":false,"product_type":"c1","uid":1517590,"ip_address":"","ucode":"D8ADAE5D037FC4","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/16/ca72addc.jpg","comment_is_top":false,"comment_ctime":1599645063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599645063","product_id":100039001,"comment_content":"如拨云见日,茅塞顿开","like_count":0},{"had_liked":false,"id":245772,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599045878,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599045878","product_id":100039001,"comment_content":"Entity、BO、VO之间数据重复的问题，不是很熟悉，mark下","like_count":0},{"had_liked":false,"id":243155,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1597978253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597978253","product_id":100039001,"comment_content":"继承是我用得最多也是最少的特性。因为客户端的模版模式必须要用到继承来创建视图控制器，所以用得多；几乎不主动设计用于继承的父类，所以用得少。<br>继承解决了代码复用的问题，但它近乎完美的违背了“高内聚，低耦合”的原则，所以在实际开发过程中，会优先使用“接口、组合、委托”等方式来代替继承。除非继承关系简单、继承逻辑明确、继承能明显减少代码量，否则都不会考虑继承。","like_count":0},{"had_liked":false,"id":240841,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1597100885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597100885","product_id":100039001,"comment_content":"Entity、BO、VO 三者之间的代码有很大重复，这种是不是可以使用组合方式来解决。","like_count":0},{"had_liked":false,"id":238917,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1596369355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596369355","product_id":100039001,"comment_content":"abstract BaseEntity，让子类继承，复用常用属性，id，deleted，createTime，updateTime。我之前的项目中，前人就是这么写的。","like_count":0},{"had_liked":false,"id":234814,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1594803145,"is_pvip":false,"replies":[{"id":"86783","content":"有些语言不支持多重继承，而且从语义上也不对，什么是Fly类啊，飞是行为，更适合用接口来表达，不适合作为类吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594903494,"ip_address":"","comment_id":234814,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594803145","product_id":100039001,"comment_content":"请教一下，如果是按照功能分成多个基类，然后再按需继承。<br>比如将大的基类分成，Fly类，Tweet类，Egg类三个类。<br>鸵鸟就只继承Tweet类，Egg类<br>这样也可以实现接口，组合，委托的效果啊，请问一下这样有什么坏处呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501516,"discussion_content":"有些语言不支持多重继承，而且从语义上也不对，什么是Fly类啊，飞是行为，更适合用接口来表达，不适合作为类吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594903494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229659,"user_name":"ujshenry","can_delete":false,"product_type":"c1","uid":1117410,"ip_address":"","ucode":"52840F95862014","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/e2/8a5e14b1.jpg","comment_is_top":false,"comment_ctime":1593090247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593090247","product_id":100039001,"comment_content":"讲解跟贴近实际，vo bo entity实际中也用到 基本就定义一个大而全的bean","like_count":0},{"had_liked":false,"id":227909,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1592525998,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592525998","product_id":100039001,"comment_content":"多用组合可以让我们，把精力和注意力集中在我们需要钱实现的对象身上，继承则需要我们在关注当前对象的同时，还有关注其继承的父类特性","like_count":0},{"had_liked":false,"id":224288,"user_name":"郭强","can_delete":false,"product_type":"c1","uid":1192928,"ip_address":"","ucode":"38F36F0F4CC775","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/e0/387ab6fd.jpg","comment_is_top":false,"comment_ctime":1591336981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591336981","product_id":100039001,"comment_content":"接口中的方法不是可以写默认方法吗，就不需要再额外写委托类了，方便很多。","like_count":0},{"had_liked":false,"id":222661,"user_name":"王瑞强","can_delete":false,"product_type":"c1","uid":1829090,"ip_address":"","ucode":"DEE4EB5E23433F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e8/e2/2bcaef68.jpg","comment_is_top":false,"comment_ctime":1590883122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590883122","product_id":100039001,"comment_content":"理解组合和委托的区别，组合是把一个类对象当做另一个类的成员变量；委托是使用组合的对象执行某个方法或者行为","like_count":0},{"had_liked":false,"id":221269,"user_name":"永远不要低估一颗冠军的心","can_delete":false,"product_type":"c1","uid":1339230,"ip_address":"","ucode":"FF0DD7382CD3CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/6f/5e/3f7e9ccd.jpg","comment_is_top":false,"comment_ctime":1590459580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590459580","product_id":100039001,"comment_content":"把实体之间相同的部分抽出来作为父类","like_count":0},{"had_liked":false,"id":220175,"user_name":"Zeng Shine","can_delete":false,"product_type":"c1","uid":1245334,"ip_address":"","ucode":"15D2618C92D662","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/96/6df95326.jpg","comment_is_top":false,"comment_ctime":1590196731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590196731","product_id":100039001,"comment_content":"组合是拼接共性，继承是包含共性。包含关系的耦合度更高。","like_count":0},{"had_liked":false,"id":217002,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589383610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589383610","product_id":100039001,"comment_content":"&#47;&#47;翱翔<br>class Soar implements FlyAble {<br>  @Override<br>  public void fly() { <br>  \t&#47;&#47;自由翱翔...<br>  }<br>}<br>&#47;&#47;狗刨<br>class DoggyPaddle implements SwimAble {<br>  @Override<br>  public void swim() { <br>  \t&#47;&#47;狗刨...<br>  }<br>}<br>&#47;&#47;天鹅<br>class Swan implements FlyAble, SwimAble {<br>  Soar soar = new Soar(); &#47;&#47;组合<br>  DoggyPaddle doggyPaddle = new DoggyPaddle();&#47;&#47;组合<br>  @Override<br>  public void fly() { <br>  \tsoar.fly();&#47;&#47; 委托<br>  }<br>  @Override<br>  public void swim() { <br>  \tdoggyPaddle.swim();&#47;&#47;委托<br>  }<br>}<br>&#47;&#47;老鹰<br>class Hawk implements FlyAble {<br>  Soar soar = new Soar(); &#47;&#47;组合<br>  @Override<br>  public void fly() { <br>  \tsoar.fly();&#47;&#47; 委托<br>  }<br>}<br>&#47;&#47;企鹅<br>class Penguin implements SwimAble {<br>  DoggyPaddle doggyPaddle = new DoggyPaddle();&#47;&#47;组合<br>  @Override<br>  public void swim() { <br>  \tdoggyPaddle.swim();&#47;&#47;委托<br>  }<br>}","like_count":0},{"had_liked":false,"id":216900,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589364674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589364674","product_id":100039001,"comment_content":"Entity、BO、VO   之间是通过继承来解决代码复用的，因为这种场景类稳定，继承层次浅。这是最初的想法不知道，看看以后有什么好的处理方式","like_count":0},{"had_liked":false,"id":211943,"user_name":"「@」","can_delete":false,"product_type":"c1","uid":1350503,"ip_address":"","ucode":"297B345E90C469","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/67/97c6bbf9.jpg","comment_is_top":false,"comment_ctime":1588039553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588039553","product_id":100039001,"comment_content":"VO大部分都是需要暴露给外部的，不能用来继承，我觉得BO继承entity，然后VO组合BO的方式比较稳妥","like_count":0},{"had_liked":false,"id":205697,"user_name":"gtp","can_delete":false,"product_type":"c1","uid":1372089,"ip_address":"","ucode":"12E21307343B3A","user_header":"https://static001.geekbang.org/account/avatar/00/14/ef/b9/c0c12bea.jpg","comment_is_top":false,"comment_ctime":1586704010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586704010","product_id":100039001,"comment_content":"终于明白为啥少多用组合少用继承了！！！","like_count":0},{"had_liked":false,"id":202460,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1585991936,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585991936","product_id":100039001,"comment_content":"组合+委托的方式会不会增加代码之间的耦合度，从而降低代码的可维护性？","like_count":0},{"had_liked":false,"id":200282,"user_name":"70","can_delete":false,"product_type":"c1","uid":1081899,"ip_address":"","ucode":"A5884B2BDDAB70","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/2b/cf93c499.jpg","comment_is_top":false,"comment_ctime":1585568404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585568404","product_id":100039001,"comment_content":"对于组合，php新增了关键字trait来处理，使用起来很方便。","like_count":0},{"had_liked":false,"id":197519,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585383377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585383377","product_id":100039001,"comment_content":"继承好像用的最多的也是entity&#47;BO之间的实体类继承。","like_count":0},{"had_liked":false,"id":194869,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585112724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585112724","product_id":100039001,"comment_content":"继承可以解决代码复用的问题，但是不推荐，主要原因是多度继承会导致代码难以维护。通过组合也可以实现继承的特性。<br><br>具体情况具体分析，如果非常确定继承的层次不多，可以使用继承。如果继承层次过多，还是使用组合为好。","like_count":0},{"had_liked":false,"id":194374,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585055490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585055490","product_id":100039001,"comment_content":"MVC其实已经在层与层之间很清晰了，只要在每一层的接口设计好就可以了。尽量减少重复代码","like_count":0},{"had_liked":false,"id":194221,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585038885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585038885","product_id":100039001,"comment_content":"针对老师留下的题目，我认为可以使用继承，把共有部分抽取出来","like_count":0},{"had_liked":false,"id":191857,"user_name":"Initiative Thinker","can_delete":false,"product_type":"c1","uid":1736297,"ip_address":"","ucode":"A884396A1581EF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","comment_is_top":false,"comment_ctime":1584800397,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584800397","product_id":100039001,"comment_content":"可以用抽象类代替接口吗","like_count":0},{"had_liked":false,"id":190293,"user_name":"索旭东","can_delete":false,"product_type":"c1","uid":1139039,"ip_address":"","ucode":"BFD07BCD8C8CAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/5f/b279daaf.jpg","comment_is_top":false,"comment_ctime":1584627520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584627520","product_id":100039001,"comment_content":"代码里的委托好像不是委托，只是个函数调用吧","like_count":0},{"had_liked":false,"id":189466,"user_name":"治慧","can_delete":false,"product_type":"c1","uid":1245904,"ip_address":"","ucode":"47C331EF63EDC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","comment_is_top":false,"comment_ctime":1584519593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584519593","product_id":100039001,"comment_content":"课后习题:entry bo vo 本质上没有任何继承关系可说的;从业务角度上虽然存在重复的字段,但是是不同的业务 也不适合 组合+委托的方式","like_count":0},{"had_liked":false,"id":188719,"user_name":"🌀Pick Monster 🌀","can_delete":false,"product_type":"c1","uid":1141196,"ip_address":"","ucode":"EE67F41B360460","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/cc/747c7629.jpg","comment_is_top":false,"comment_ctime":1584408084,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584408084","product_id":100039001,"comment_content":"继承的优点是可以提高代码的复用，但过渡复杂的继承会影响代码可读性和维护性。<br>组合的优点是提高代码的复用，降低业务结构的复杂度，但会增加分支结构导致需要更细粒度的设计。<br>继承类似于多线程的synchronized关键字，不能细粒度控制可能导致性能问题。组合类似于Lock锁，可以进行更细粒度的控制，但使用复杂度可能会提高。<br>所以我们应该根据具体的业务选择合适的方案。","like_count":0},{"had_liked":false,"id":187148,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1584026294,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584026294","product_id":100039001,"comment_content":"如果层级不多，有时候继承在语义上比较好吧。<br><br>组合和委托确实灵活很多。多个重复的逻辑，委托到另外一个独立的功能类里面去，然后在组合回来，很灵活。","like_count":0},{"had_liked":false,"id":186951,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1583978423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583978423","product_id":100039001,"comment_content":"继承的一个误区，为了代码复用，故意抽象公共一个父类出来。虽然解决了代码复用问题，但是影响了代码的可读性，可维护性。这样是得不偿失。应该用其他手段来实现代码复用","like_count":0},{"had_liked":false,"id":186671,"user_name":"赵云","can_delete":false,"product_type":"c1","uid":1376233,"ip_address":"","ucode":"FBECC7A2F4F70F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ff/e9/daebe1ea.jpg","comment_is_top":false,"comment_ctime":1583899672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583899672","product_id":100039001,"comment_content":"想问下老师有什么比较好的建议去实现这些重复的问题","like_count":0},{"had_liked":false,"id":184436,"user_name":"壹","can_delete":false,"product_type":"c1","uid":1023272,"ip_address":"","ucode":"335D34216066E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/28/bcaf070d.jpg","comment_is_top":false,"comment_ctime":1583314460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583314460","product_id":100039001,"comment_content":"看到鸟的这个例子我就想到swift的协议，解决这个问题比Java优雅太多了","like_count":0},{"had_liked":false,"id":180997,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582456271,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582456271","product_id":100039001,"comment_content":"今天主要讲组合和继承的使用，总结一下就是结构稳定继承层次浅（不超过两层）可以使用继承，否则使用组合+接口+委托单位方式。我的倾向是有共同结构或者业务上是同一类的优先使用继承，否则使用组合的方式。仍然回归定义，接口是行为的抽象，与行为相关的代码逻辑优先使用组合，在定义接口的时候要考虑得行为的通用性，也就是符合单一职责。下面说下思考题，entity、vo、bo本身就是不同层面的业务对象，entity是数据层对象，vo是展示层对象，bo是业务层对象，如果三者之间有通用的属性就各自定义好了，如果多种业务都有一些公共的属性则可以单独定义这么个bo、vo，然后使用组合的方式拿过来就好了。而且从业务看这不是重复代码，感觉问题可以更具体点","like_count":0},{"had_liked":false,"id":180665,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582360602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582360602","product_id":100039001,"comment_content":"还是不忘评价代码好坏的几条标准，可用，可维护，可扩展。。。。我们的目标是高质量的代码","like_count":0},{"had_liked":false,"id":180487,"user_name":"Ant","can_delete":false,"product_type":"c1","uid":1079563,"ip_address":"","ucode":"07E6374F91F61E","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0b/4346a253.jpg","comment_is_top":false,"comment_ctime":1582294331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582294331","product_id":100039001,"comment_content":"回顾了一下很受益，谢谢老师","like_count":0},{"had_liked":false,"id":179933,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582123324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582123324","product_id":100039001,"comment_content":"<br>对于这个问题，在实际开发中，我们经常使用Beans这个工具类其中的copproperties()方法去解决代码重复赋值问题，但是经过了这几天的学习，发现经常使用的mvc是一个面向过程的贫血模型，所以我给出的解决答案是使用接口 组合以及委托这种方式去替换它，这是我学完这节课的一个设想，但这三者之间并没有什么直接的关系，我认为这三者没必要去解决他们的代码重复问题，他们三个本身来说就应该是相对独立的，不然有这么多代码重复，我们为什么不将其放到一个对象里面了？在整个MVC三层之间都共用一个对象.","like_count":0},{"had_liked":false,"id":178248,"user_name":"wysobj","can_delete":false,"product_type":"c1","uid":1499936,"ip_address":"","ucode":"E4D0DEF1F330C5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/OwMy02RcVqOkKqmdQ8AAbblhrz5QM2B4PoPS4k6TLMDB4yzb25bocxKuF9vM1vicNcS0cLDzOlFfG61P7Pqdozw/132","comment_is_top":false,"comment_ctime":1581642044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581642044","product_id":100039001,"comment_content":"老师，我理解继承的核心目标是提供一种更符合人类思维模式的代码组织手段，除了代码复用也可以提高代码的可读性。只不过这个技术很难运用得恰当，容易造成过度设计或者结构腐化，所以需要慎重使用。您举的鸟的例子就能体现，其实鸟类概念的定义本身就没有飞翔的属性，所以不能提供fly方法。这种场景就像在代码开发中很多人最开始对一个类的边界理解有些许偏差导致设计问题，后续调整继承关系的成本很高。所以说与其说继承一无是处，不如说使用继承特性十分危险。","like_count":0},{"had_liked":false,"id":175066,"user_name":"Geek_7ead05","can_delete":false,"product_type":"c1","uid":1363830,"ip_address":"","ucode":"1FA18A1245200E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKHKe06oa6hIkIpIGib63GAU1M2q7HODOLwYZ1rJDOzDzmMlckQKgXzLaQJiaKSibJ0K2pCav8gLmLkg/132","comment_is_top":false,"comment_ctime":1580544736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580544736","product_id":100039001,"comment_content":"优先考虑用组合，接口和委托实现继承的功能。","like_count":0},{"had_liked":false,"id":170921,"user_name":"Citizen Z","can_delete":false,"product_type":"c1","uid":1125104,"ip_address":"","ucode":"9CA547640A8629","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","comment_is_top":false,"comment_ctime":1578759948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578759948","product_id":100039001,"comment_content":"个人认为，那些 xO 还是各自独立的好，因为属于不同层面的对象，从建模角度讲，他们之间不是相同领域的对象，只是恰好大部分字段相同，如果数据转换时有太多 target.setXxx(source.getXxx())，仅仅为了方便和减少代码量，可以考虑采用小工具的方式，如 copyProperties、字段 mapping 等手段来实现","like_count":0},{"had_liked":false,"id":170364,"user_name":"蓝领笑笑生","can_delete":false,"product_type":"c1","uid":1109147,"ip_address":"","ucode":"B9A42CD91CD5E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/9b/1c25e95f.jpg","comment_is_top":false,"comment_ctime":1578580272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578580272","product_id":100039001,"comment_content":"关于思考的问题，DO，VO，BO，DTO等，属于不同领域，各自的职责不一样，所以无所谓相同的属性。比如DTO做为参数的入参对象，会在属性上加一些校验注解或者在加一些swagger API接扣文档注解，而其他的O并不需要，尊从单一职责原则","like_count":0},{"had_liked":false,"id":169089,"user_name":"天空只能仰望？","can_delete":false,"product_type":"c1","uid":1102357,"ip_address":"","ucode":"D87BF6A57DAB42","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/15/4d43d05a.jpg","comment_is_top":false,"comment_ctime":1578272214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578272214","product_id":100039001,"comment_content":"继承便于代码复用，层次过深增加代码复杂程度和可读性，组合使用灵活便利，会增加类的复杂程度同时会增加部分代码冗余，屏蔽特性弊端正确使用才是王道！","like_count":0},{"had_liked":false,"id":168893,"user_name":"厉害了我的国","can_delete":false,"product_type":"c1","uid":1052191,"ip_address":"","ucode":"CD0A54A1B998AA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","comment_is_top":false,"comment_ctime":1578211526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578211526","product_id":100039001,"comment_content":"确实是这样，每个层都定义了相似的对象，很丑陋！","like_count":0},{"had_liked":false,"id":166882,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1577622975,"is_pvip":false,"replies":[{"id":"64821","content":"哪种更方便用那哪种 并不是说绝对杜绝继承。继承层次不深 结构不复杂的话 用继承没问题的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577665966,"ip_address":"","comment_id":166882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577622975","product_id":100039001,"comment_content":"接上一条，我的问题：<br>老师好，我是一名前端，就用React代码来阐述我的理解。<br>我理解的组合可能比较狭隘，具体如下：<br><br>页面上有元素ABC和D<br><br>status = 1的时候展示A B C<br><br>funciton Container1() {<br>  return &lt;&gt;<br>    &lt;A &#47;&gt;<br>    &lt;B &#47;&gt;<br>    &lt;C &#47;&gt;<br>  &lt;&#47;&gt;<br>}<br><br>status = 2的时候展示A B D<br><br>funciton Container2() {<br>  return &lt;&gt;<br>    &lt;A &#47;&gt;<br>    &lt;B &#47;&gt;<br>    &lt;D &#47;&gt;<br>  &lt;&#47;&gt;<br>}<br><br>status = 3的时候展示A B C D<br><br>funciton Container3() {<br>  return &lt;&gt;<br>    &lt;A &#47;&gt;<br>    &lt;B &#47;&gt;<br>    &lt;C &#47;&gt;<br>    &lt;D &#47;&gt;<br>  &lt;&#47;&gt;<br>}<br><br>function Home(status) {<br>  switch(status) {<br>    case 1:<br>      return &lt;Container1 &#47;&gt;<br>    case 2:<br>      return &lt;Container2 &#47;&gt;<br>    case 3:<br>      return &lt;Container3 &#47;&gt;<br>  }<br>  return &lt;Container1 &#47;&gt;<br>}<br><br>这里可以理解为ABCD的组合形成了Container，但是在不同status状态之间&lt;A &#47;&gt;&lt;B &#47;&gt;被重复了多次。<br>如果单独将AB这种组合抽取出来总觉得不对，因为抽取的理由仅仅是这几个状态的时候，他们是一起出现的。<br><br>我想如果使用模板方法，不同状态，重写基类的方法可能会减少这种重复，例如：<br><br>class Container {<br>  A() {<br>    return &lt;A &#47;&gt;<br>  }<br><br>  B() {<br>    return &lt;B &#47;&gt;<br>  }<br><br>  C() {<br>    return &lt;C &#47;&gt;<br>  }<br><br>  D() {<br>    return &lt;D &#47;&gt;<br>  }<br><br>  render() {<br>    return &lt;&gt;<br>      &lt;this.A &#47;&gt;<br>      &lt;this.B &#47;&gt;<br>      &lt;this.C &#47;&gt;<br>      &lt;this.D &#47;&gt;<br>    &lt;&#47;&gt;<br>  }<br>}<br><br>class Container1 extends Container {<br>  D() {<br>    return null<br>  }<br>}<br><br>class Container2 extends Container {<br>  C() {<br>    return null<br>  }<br>}<br><br><br>class Container3 extends Container {<br>}<br><br>以上。<br><br>开发中用的是组合的方式，发现有重复，所以才有此问。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479665,"discussion_content":"哪种更方便用那哪种 并不是说绝对杜绝继承。继承层次不深 结构不复杂的话 用继承没问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577665966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166861,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577617441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577617441","product_id":100039001,"comment_content":"1、继承是面向对象的四大特性之一。继承主要解决代码的复用问题。<br>2、继承层级太深，继承关系复杂，会影响代码的可维护性。这时候用组合、接口、委托的方式，替代继承的is-a、多态、复用。<br>3、继承并非一无是处，组合也不完美。如果继承关系稳定，层级浅选用继承关系；如果继承关系不稳定，关系复杂，用组合来替代。<br>4、继承相关设计模式：模板模式；组合相关设计模式：策略模式、组合模式、装饰者模式","like_count":0},{"had_liked":false,"id":166774,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1577591735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577591735","product_id":100039001,"comment_content":"针对下蛋会飞，完全相同的处理方式才可以用委托的方案解决，如果不同，还是需要每个不同种类自己去实现自己的处理方式，例如:麻雀下小蛋，鸵鸟下大蛋","like_count":0},{"had_liked":false,"id":166231,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1577419969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577419969","product_id":100039001,"comment_content":"按属性多少排序：bo&gt;entity&gt;vo，bo继承entity可以实现代码的复用。vo的属性较少，所以单独写属性会合理一些。","like_count":0},{"had_liked":false,"id":165430,"user_name":"Tracyliu","can_delete":false,"product_type":"c1","uid":1034513,"ip_address":"","ucode":"29F242C232B85B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c9/11/bb1a4368.jpg","comment_is_top":false,"comment_ctime":1577237075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577237075","product_id":100039001,"comment_content":"委托不就是代理模式么？","like_count":0},{"had_liked":false,"id":164800,"user_name":"OperaX","can_delete":false,"product_type":"c1","uid":1510551,"ip_address":"","ucode":"66947CD04E3B3E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8mFt5wSkia3yumk409E65JIlGoreva1Q25icTks0XB0EDC7WJ5V0z6zuvgGkI2Zrh5cBXGS5Hea8A/132","comment_is_top":false,"comment_ctime":1577092996,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577092996","product_id":100039001,"comment_content":"看完七个理论 感觉自己平时完完全全是在面向过程编程。","like_count":0},{"had_liked":false,"id":164547,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1577025583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577025583","product_id":100039001,"comment_content":"1.使用工具类解决重复性代码<br>2.抽象出一个接口和接口实现类，通过组合和代理方式优化","like_count":0},{"had_liked":false,"id":164450,"user_name":"峰回路转","can_delete":false,"product_type":"c1","uid":1773160,"ip_address":"","ucode":"A2874C7392C452","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0e/68/a41730c8.jpg","comment_is_top":false,"comment_ctime":1576994171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576994171","product_id":100039001,"comment_content":"飞的时候如果需要飞的方法内部的处理改变自己的多个属性值，怎么使用委托呐？","like_count":0},{"had_liked":false,"id":163894,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1576820647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576820647","product_id":100039001,"comment_content":"课堂讨论：<br>      Entity、BO、VO 没有关系，都是独立存在的，但是一般在会进行转换封装。在Service 层做。VO&lt;-&gt;BO 和  Entity&lt;-&gt;BO 的封装。 我一般会用BeanUtils.copyProperties 来处理。<br>","like_count":0},{"had_liked":false,"id":163571,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1576747349,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576747349","product_id":100039001,"comment_content":" 打卡《设计模式之美》之第10讲 《为何要多用组合少用继承？如何决定使用组合还是继承？》<br>设计原则：组合优于继承，多用组合少用继承<br>继承的优点：表示 is-a 关系，支持多态特性，代码复用<br>继承的不足：：继承层次过深、继承关系过于复杂会影响代码的可读性和可维护性<br>接口表示具有某种行为特性，但接口只能声明方法，不定义实现，所以会导致具有该功能（实现该接口）的类都要实现方法，导致代码重复。针对这种情况可以对接口再定义实现类，然后通过组合和委托技术来消除重复的代码。<br>继承的优点可以通过组合、接口、委托三个技术实现，并且还能解决继承的层次过深、过复杂的继承关系影响代码的可维护性的问题<br>即使鼓励使用组合，但并不是就拒绝使用继承，需要具体情况具体分析。如果类之间继承结构稳定，层次比较浅，关系不复杂，就可以使用继承。反之，就要尽量使用组合来替代继承","like_count":0},{"had_liked":false,"id":161828,"user_name":"小飞","can_delete":false,"product_type":"c1","uid":1050983,"ip_address":"","ucode":"CFFF2E7768EF9A","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/67/7de7988a.jpg","comment_is_top":false,"comment_ctime":1576366955,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576366955","product_id":100039001,"comment_content":"这个问题希望老师能够给出一个指导，开发过程中确实发生了对这个问题的争执。但是我还没有找到一个比较好的能够说服大家的办法。","like_count":0},{"had_liked":false,"id":161726,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1576308615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576308615","product_id":100039001,"comment_content":"组合就是把属性一个一个的明显的写出来，就像DTO！=VO !=entity<br>少用继承多用组合的原因：<br>1.继承会让程序变得更复杂。根据之前说的最小设计原则，不要在一个父类类定义子类不是通用的东西，这样如果类多的话会变得很多(当然如果只有一两层就没事了)。比如用户分为卖家和买家，买卖家又有绑卡和没绑卡的，这样就要设计四个父类（绑卡买&#47;卖家、没绑卡买卖家），这样下去会越来越多，定义的类也就越来越多。<br>2.明明可以直接看父类有什么东西的，但是如果有了继承簇，还要去看父类有什么，祖宗类有什么，你的猪队友骂不死你<br>3.对于方法，牵一发而动全身。父类变了，下面的都要变(因为用的基本都是super()指定用父类的)<br><br>用继承和组合的场景<br>类结构稳定，层次清晰，关系不复杂就用继承<br>否则就用组合","like_count":0},{"had_liked":false,"id":159855,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1575811853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575811853","product_id":100039001,"comment_content":"很想知道老师对思考题的答案，困扰我很久了","like_count":0},{"had_liked":false,"id":159747,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1575777780,"is_pvip":false,"replies":[{"id":"61127","content":"为啥是重复呢？能解释一下吗","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575896343,"ip_address":"","comment_id":159747,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575777780","product_id":100039001,"comment_content":"我觉得，相比较于继承，组合行为本身也是一种重复，咋解决呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477161,"discussion_content":"为啥是重复呢？能解释一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274328,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLicryBoLjDicckia0c5bkOoAlYoR2I9NMK8BiaD7HCGxhS1eM9YSfDuUJuZC90uwv9FvHIVSsBoxFgZw/132","nickname":"MwumLi","note":"","ucode":"9A8A72334ADF6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278746,"discussion_content":"重复实现了方法，虽然用了委托了具体实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591232133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159134,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1575545114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575545114","product_id":100039001,"comment_content":"适度就可以了……适当的代码重复可以忍受，业务的灵活性也得考虑进去","like_count":0},{"had_liked":false,"id":158968,"user_name":"1620","can_delete":false,"product_type":"c1","uid":1104310,"ip_address":"","ucode":"C9222A5CE4723C","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","comment_is_top":false,"comment_ctime":1575507949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575507949","product_id":100039001,"comment_content":"VO BO Entity 我最近在重写一个mvc web项目，（原有项目结构是 Bo extends Entity 在后台数据层mybatis 和 controller 共用了Bo） 我改的策略是废弃了 bo extends Bo 增加了Vo 以及复杂查询的Query ，query 与 Vo 不关心后续结构只关心定制化内容，前端小伙伴完全对照参数录入。 Bo层可能有一些特殊处理与定制。 我没有完全去想集成或者组合，我的目标只是想把他们职责更清晰一点，干净一点。 改完之后就是感觉许多出要transform比较多但可以借助一些copy技术的机制。 我也不知道有没有更好的办法来处理这些，设计模式没怎么学过，DDD只听说过...","like_count":0},{"had_liked":false,"id":158951,"user_name":"vince","can_delete":false,"product_type":"c1","uid":1249981,"ip_address":"","ucode":"90DC7EA30D34B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/bd/54987d4b.jpg","comment_is_top":false,"comment_ctime":1575506360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575506360","product_id":100039001,"comment_content":"讨论题：entity对应数据库层，不应该改动，而bo和vo可用组合的方式解决，具体落地可参考spring的group注解实现","like_count":0},{"had_liked":false,"id":157965,"user_name":"东东科","can_delete":false,"product_type":"c1","uid":1613041,"ip_address":"","ucode":"308F279C5BA37E","user_header":"https://static001.geekbang.org/account/avatar/00/18/9c/f1/a580562b.jpg","comment_is_top":false,"comment_ctime":1575290789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575290789","product_id":100039001,"comment_content":"大部分情况下Bo是Po（entity）的扩展，所以一般可以Bo继承Po或者是Bo组合Po。而现在的web开发很多是前后端分离，Vo需要携带状态和提示信息，所以一般用Vo组合Bo和Po","like_count":0},{"had_liked":false,"id":157788,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1575259164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575259164","product_id":100039001,"comment_content":"这个关于Entity，BO和VO，我是这么做的就是通常BO，VO要比entity多，所以干脆直接继承Entity就完了。当然涉及到一些敏感字段不想暴露出来，就有点麻烦了，可能要自己去除相关字段，或者只能弄一个一个大家通用的，上面都继承这个基础的。","like_count":0},{"had_liked":false,"id":157330,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1575111013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575111013","product_id":100039001,"comment_content":"三个，都有用，不需要组合，也不需要继承。  如果组合用得上就用，不必强求","like_count":0},{"had_liked":false,"id":156844,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1574987838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574987838","product_id":100039001,"comment_content":"业务开发常见问题，解决办法看具体场景而定。主要方式:<br>1 继承，适用在VO ，BO与ENTITY很接近，基本对应数据库字段，直接继承可以复用代码。但是需要能够容忍某些冗余的字段出现。<br><br>2 组合，使用ENTITY组合作为VO BO的成员属性，需要能容忍冗余字段<br><br>3 继承+组合，将VO 和 BO公共部分提取成为单独的类，再通过继承或组合完成复用。定义最为准确，业务和ENTITY分离，个人最推荐方式。","like_count":0},{"had_liked":false,"id":156770,"user_name":"刘岳","can_delete":false,"product_type":"c1","uid":1128385,"ip_address":"","ucode":"67C35B2518BF24","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/c1/481ddf9b.jpg","comment_is_top":false,"comment_ctime":1574952400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574952400","product_id":100039001,"comment_content":"里氏替换明确了继承的原则","like_count":0},{"had_liked":false,"id":156600,"user_name":"HF","can_delete":false,"product_type":"c1","uid":1112811,"ip_address":"","ucode":"0839195346C3CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/eb/84d4de33.jpg","comment_is_top":false,"comment_ctime":1574920732,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574920732","product_id":100039001,"comment_content":"<br>public interface Flyable {<br>  void fly()；<br>}<br>public class FlyAbility implements Flyable {<br>  @Override<br>  public void fly() { &#47;&#47;... }<br>}<br>&#47;&#47;省略Tweetable&#47;TweetAbility&#47;EggLayable&#47;EggLayAbility<br><br>public class Ostrich implements Tweetable, EggLayable {&#47;&#47;鸵鸟<br>  private TweetAbility tweetAbility = new TweetAbility(); &#47;&#47;组合<br>  private EggLayAbility eggLayAbility = new EggLayAbility(); &#47;&#47;组合<br>  &#47;&#47;... 省略其他属性和方法...<br>  @Override<br>  public void tweet() {<br>    tweetAbility.tweet(); &#47;&#47; 委托<br>  }<br>  @Override<br>  public void layEgg() {<br>    eggLayAbility.layEgg(); &#47;&#47; 委托<br>  }<br>}<br>这里都直接用组合了，为什么实现tweetable 和 egglayable接口，感觉有些设计的多此一举。","like_count":0},{"had_liked":false,"id":156482,"user_name":"古杨","can_delete":false,"product_type":"c1","uid":1744092,"ip_address":"","ucode":"8F52AA86B589C7","user_header":"","comment_is_top":false,"comment_ctime":1574901497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574901497","product_id":100039001,"comment_content":"我们项目没有什么Entity,BO,VO全用map😂","like_count":0},{"had_liked":false,"id":156353,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1574860949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574860949","product_id":100039001,"comment_content":"用组合比较合适，但是很多都是重复的，组合感觉又不一定合适，重复多了就单独写了","like_count":0},{"had_liked":false,"id":156336,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1574858291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574858291","product_id":100039001,"comment_content":"课后习题，目前是三者都各自独立去创建，怕后期的需求变化，期待老师的见解","like_count":0},{"had_liked":false,"id":156297,"user_name":"ljr_bird","can_delete":false,"product_type":"c1","uid":1618685,"ip_address":"","ucode":"13D2885BA6CDFF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2QR4YBpeXgVXGXIfnibt80oLbjibIdp1c5ty5wbBTHvgheZRcLWDZAVklOpG2yjlDS2N3rZH66pDOvsvvqI2ic7icw/132","comment_is_top":false,"comment_ctime":1574852001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574852001","product_id":100039001,"comment_content":"继承层次多，让人要花很多时间去理每一层的关系；这种情况下，类的功能&#47;能力可以以接口的方式赋予，想要什么功能就组装什么功能，好像也更自由优雅；但是如果接口的很多实现都是一样的，那么我们先封装一下实现再给需要的类去使用，那些类就不需要自己再实现一次了，从而提高复用性。","like_count":0},{"had_liked":false,"id":155986,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1574790040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574790040","product_id":100039001,"comment_content":"<br>数据库层的entity，在某些情况是和service层的bo的字段基本是一样的，我是一般如果感觉一样会用同一个实体，如果中间有部分字段是一样的，会把这部分的单独抽出来一个类，就是用到了组合，而且定义的时候会尽可能的有一定的通用性，至于controller层的vo的话，差距比较大的话就没办法了，也是能用组合就用组合，其实中间最长用到的是一个BeanUtils类中的一个copy方法，针对其中不同字段属性的赋值操作做了处理，其实就是utils的使用，个人觉得这这种框架下编程，用继承很容易出问题，还是组合、委托和接口用的最多","like_count":0},{"had_liked":false,"id":155946,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1574781292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574781292","product_id":100039001,"comment_content":"定义一个基类或抽象类，BO、VO和Entity继承它，或着创建Get方法，隐藏真实的类成员属性。","like_count":0},{"had_liked":false,"id":155846,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1574766357,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1574766357","product_id":100039001,"comment_content":"我觉得没必要分vo bo entity直接一个vo就好","like_count":0},{"had_liked":false,"id":155796,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1574757965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574757965","product_id":100039001,"comment_content":"目前项目Entity、BO、VO三个没有啥关系，只是部分属性相同。没用继承也没用组合。<br>","like_count":0},{"had_liked":false,"id":155730,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1574745679,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574745679","product_id":100039001,"comment_content":"课堂讨论：VO和Entity一个是针对展示界面，一个是针对数据存储，BO则是真正的业务实体，按照六边形架构来说—VO和Entity位于外层，BO位于内层，BO更加稳定；VO、Entity和BO并不是一一对应的关系，这三个的目标也不相同","like_count":0},{"had_liked":false,"id":155640,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1574731542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574731542","product_id":100039001,"comment_content":"设计模式_10<br>题目：<br>没做过后端的Web服务，根据题目内容，我认为可以用组合的方式，把重复的地方定义接口，给一个默认实现类，里面实现了三者代码相同的地方。<br><br>感想：<br>我们在讨论集成与组合的优劣时，我们在讨论什么？<br><br>个人认为，与组合相比，继承带来了更多的限制，这个问题的讨论变成了：<br>&gt; 限制带来的好处多还是坏处多？<br><br>- 坏处：<br>正如大家表达的一样，限制带来了明显的坏处，比如说，顶层的基类要增加一个抽象方法，所有的实现类都需要实现这个方法，这种变化带来了复杂度非线性的增加。<br>相同的问题，使用组合只需要新增一个接口，在需要的地方添加实现即可。<br><br>- 好处：<br>那么限制有没有好处呢？","like_count":0},{"had_liked":false,"id":155600,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574726209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574726209","product_id":100039001,"comment_content":"编程中is-a出现的机会比has-a低多了。所以在不确定是否是is-a时尽量使用has-a比较好","like_count":0},{"had_liked":false,"id":155599,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574726136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574726136","product_id":100039001,"comment_content":"我觉得继承对能力要求更高，需要有很好的抽象思维才能想清楚什么方法放在继承父类中合适","like_count":0},{"had_liked":false,"id":155593,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1574724958,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574724958","product_id":100039001,"comment_content":"组合对业务的扩展点分离的更彻底，灵活性相对继承会更好，但是极其稳定的业务关系用继承也没什么不好，也挺复合设计直觉的。相对而言，优先采用组合其实意味着对需求和设计的思考要更多更深入。<br>DO和BO，VO，DTO这些问题，基本原则应该是隔离DO和其它O，但是在项目中，DO本身已经把业务表达的太充分，导致DO和其它O太相似，从而觉得好像没必要隔离。","like_count":0},{"had_liked":false,"id":155581,"user_name":"Geek_8c5f9c","can_delete":false,"product_type":"c1","uid":1596047,"ip_address":"","ucode":"70CD441EAF490F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","comment_is_top":false,"comment_ctime":1574710924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574710924","product_id":100039001,"comment_content":"接口是为了表达能力，没有数据，在VO,BO,和Entity中只有数据，所以不用接口。<br>可以抽取它们的共同属性，用组合来引入。共同属性可以用于表达is-a的关系的情况下可以用继承。<br>还可以考虑不作处理，用mapper util来作不同类型间的转化。","like_count":0},{"had_liked":false,"id":155561,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1574698661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574698661","product_id":100039001,"comment_content":"打卡！<br>对于思考题，没想出什么好办法。<br>我认为VO、BO、entity 。可以在相同的字段上用相同的名字。这样就可以通过 Java 的浅拷贝去赋值。","like_count":0},{"had_liked":false,"id":155556,"user_name":"青阳魂","can_delete":false,"product_type":"c1","uid":1254875,"ip_address":"","ucode":"4F04ADAB6D870A","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/db/7c71ef4b.jpg","comment_is_top":false,"comment_ctime":1574697753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574697753","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":155549,"user_name":"wzp","can_delete":false,"product_type":"c1","uid":1120298,"ip_address":"","ucode":"2C511B2755A1E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/2a/9c18a3c4.jpg","comment_is_top":false,"comment_ctime":1574696999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574696999","product_id":100039001,"comment_content":"看了这篇文章，对GoF中的UML图有了一些理解，图中就使用了委托实现代码复用","like_count":0},{"had_liked":false,"id":155533,"user_name":"阿玛铭","can_delete":false,"product_type":"c1","uid":1100703,"ip_address":"","ucode":"DBF948D82ACBE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","comment_is_top":false,"comment_ctime":1574696021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574696021","product_id":100039001,"comment_content":"老师问那么多问题是为了消灭那么多问题，这就很哲学了。","like_count":0},{"had_liked":false,"id":155522,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574695343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574695343","product_id":100039001,"comment_content":"我们的项目中，entity完全是通过业务模型映射出来的，机器自动生成。<br><br>vo&#47;dto是根据实际的业务需求自定义的，数据的载体；<br><br>bo层完全是业务逻辑<br><br>controller则负责路由<br><br>三者并没有很多代码重复。","like_count":0},{"had_liked":false,"id":155510,"user_name":"拓","can_delete":false,"product_type":"c1","uid":1010957,"ip_address":"","ucode":"AC1940ECC25436","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","comment_is_top":false,"comment_ctime":1574693991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574693991","product_id":100039001,"comment_content":"orz. 没有Entity、BO、VO的概念咋整啊。只用过python做过web开发， 我可以理解python django框架里定义的model 对应Entity， 定义View对应VO。但是不知道BO对应django里面的哪部分？也没发现model和view里面有代码重复。另外，django里面的template是controller层面的东西吗？","like_count":0},{"had_liked":false,"id":155491,"user_name":"王振华 程序员","can_delete":false,"product_type":"c1","uid":1131957,"ip_address":"","ucode":"31BB337642B882","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","comment_is_top":false,"comment_ctime":1574692456,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574692456","product_id":100039001,"comment_content":"<br>public class FeignClient { &#47;&#47; feighn client框架代码<br>  &#47;&#47;...省略其他代码...<br>  public void encode(String url) { &#47;&#47;... }<br>}<br><br>public void demofunction(FeignClient feignClient) {<br>  &#47;&#47;...<br>  feignClient.encode(url);<br>  &#47;&#47;...<br>}<br><br>public class CustomizedFeignClient extends FeignClient {<br>  @Override<br>  public void encode(String url) { &#47;&#47;...重写encode的实现...}<br>}<br><br>&#47;&#47; 调用<br>FeignClient client = new CustomizedFeignClient();<br>demofunction(client);<br><br>老师你好，我之前没接触过Java，这段代码我实在是没看懂。<br>FeignClient 是父类， CustomizedFeignClient是子类。<br>FeignClient client = new CustomizedFeignClient();<br>这句代码中，定义的对象 client 到底是什么类型的？是FeignClient类型的，还是CustomizedFeignClient类型的？<br>按照文中的解释，既然这样写能达到 重写encode方法的目的，那应该是CustomizedFeignClient类型的了。 但生成client这个对象的时候，前面加个FeignClient，不会对它的类型有影响吗？<br><br>","like_count":0,"discussions":[{"author":{"id":1425252,"avatar":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","nickname":"塔兹米","note":"","ucode":"1A58C81EF9B0A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60170,"discussion_content":"是CustomizedFeignClient类型。\n引用指向的对象一直没有变。\n父类引用指向子类对象。这是多态。\n调用引用的方法时，如果子类重写了父类的方法的话。那么就会执行子类的方法实现，没有重写的话就依然是执行继承父类时的方法实现了。\n有一个弊端是，如果子类有它自己单独的方法那么父类的引用是无法调用到的。因为父类没有这个方法。想要调用的话就只能强转了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574698406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155461,"user_name":"2102","can_delete":false,"product_type":"c1","uid":1070298,"ip_address":"","ucode":"A67068F2A3157E","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/da/e2e5ddf7.jpg","comment_is_top":false,"comment_ctime":1574690891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574690891","product_id":100039001,"comment_content":"重复的可以用一个，或者用组合，继承","like_count":0},{"had_liked":false,"id":155435,"user_name":"瓶子霸哥","can_delete":false,"product_type":"c1","uid":1125806,"ip_address":"","ucode":"A7EEB459AB5550","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","comment_is_top":false,"comment_ctime":1574689050,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574689050","product_id":100039001,"comment_content":"学 Android 的并不觉得 MVC 里面的 V 和 C 有太多重复的地方啊. 做 Web 应用的同学能给我举个例子看看是哪里有重复吗","like_count":0,"discussions":[{"author":{"id":1425252,"avatar":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","nickname":"塔兹米","note":"","ucode":"1A58C81EF9B0A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60173,"discussion_content":"成员变量和get、set方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574698473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155425,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1574688159,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1574688159","product_id":100039001,"comment_content":"赞成不做处理，每一种对应都有各自的应用场景，强行的耦合在一起增加复杂度","like_count":0},{"had_liked":false,"id":155420,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1574687380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574687380","product_id":100039001,"comment_content":"打卡. entity作为基类，bo和vo继承，并增加自己需要的属性和方法","like_count":0},{"had_liked":false,"id":155409,"user_name":"Warn","can_delete":false,"product_type":"c1","uid":1465310,"ip_address":"","ucode":"F2F7FCDB0940D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/de/152f1c2c.jpg","comment_is_top":false,"comment_ctime":1574686435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574686435","product_id":100039001,"comment_content":"除了思考题，其他收获颇多","like_count":0},{"had_liked":false,"id":155408,"user_name":"陈迎春","can_delete":false,"product_type":"c1","uid":1443663,"ip_address":"","ucode":"2870BA6D6E5B1E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","comment_is_top":false,"comment_ctime":1574686066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574686066","product_id":100039001,"comment_content":"对于组合和委托的概念貌似没有特别讲，看着稍微有点吃力，自己还特地又上网查询了一番","like_count":0},{"had_liked":false,"id":155389,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1574684437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574684437","product_id":100039001,"comment_content":"打卡<br>1、当继承关系复杂、继承层次深的时候，尽量减少使用继承。这样会导致代码可读性和可维护性变差；<br>2、如果集成结构比较稳定，继承层次比较浅，关系不复杂，可以使用继承；<br>3、完全可以使用 接口、组合、委托的方式替换继承的使用；<br>4、继承是将物体分类，抽取共性，处理共性，相对于使用接口、组合和委托的方式灵活性较差，毕竟现实生活中的物体特征多（深度学习训练就是基于物体的特征来做），共性少。接口+组合+委托符合矢量化思想，它讲物体的特征分成不同的维度，每个维度可以独立的变化。","like_count":0},{"had_liked":false,"id":155379,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1574683701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574683701","product_id":100039001,"comment_content":"如果是我的话，应该不会处理这三者之间的代码重复，一般Entity和VO都是贫血模型。只是控制属性是否显示，BO可能存在类似领域对象的方法，但是我理解Entity、VO、BO一个是为了隔离层之间的依赖，一个是为了封装属性，从底到上，暴露的属性越来越少。<br><br>听了今天的课，我觉得设计模式的桥接模式，是不是就是利用接口替代抽象的场景?","like_count":0},{"had_liked":false,"id":155350,"user_name":"成葛格","can_delete":false,"product_type":"c1","uid":1030745,"ip_address":"","ucode":"A09A57D891FA50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/59/ffa298a2.jpg","comment_is_top":false,"comment_ctime":1574681105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574681105","product_id":100039001,"comment_content":"Entity，VO 结构层次简单，为了复用代码可以使用继承；BO 采用组合。","like_count":0},{"had_liked":false,"id":155259,"user_name":"爽了个爽","can_delete":false,"product_type":"c1","uid":1261326,"ip_address":"","ucode":"D5B10F75A02AB1","user_header":"https://static001.geekbang.org/account/avatar/00/13/3f/0e/3a2fb9ff.jpg","comment_is_top":false,"comment_ctime":1574672179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574672179","product_id":100039001,"comment_content":"<br>这个问题困扰我很久了。现在写代码的时候有时候会直接把Entity返回。除非有组合数据采用vo。🤣","like_count":0},{"had_liked":false,"id":155236,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1574669969,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574669969","product_id":100039001,"comment_content":"之前写Android的时候，对这些似懂非懂；现在接触到了Java Service，感觉对设计模式的要求越来越高了，就比如老师提出的这个思考题，尴尬，我现在的做法还是做封装，提取公共类更多一点。","like_count":0},{"had_liked":false,"id":155230,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1574669037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574669037","product_id":100039001,"comment_content":"目前项目中确实存在很多实体类都有同样的属性，至于怎么合理的应用还没有思考过。看了老师的文章之后，是不是要考虑用组合模式来优化。","like_count":0},{"had_liked":false,"id":155211,"user_name":"陀螺","can_delete":false,"product_type":"c1","uid":1058808,"ip_address":"","ucode":"5016747DD39102","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/f8/1388139d.jpg","comment_is_top":false,"comment_ctime":1574664237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574664237","product_id":100039001,"comment_content":"Entity、BO、VO 代码重复的问题从共性上使用继承不太合理，反而组合更加灵活些。更简单可以使用静态类来实现。","like_count":0},{"had_liked":false,"id":155206,"user_name":"真是艹0","can_delete":false,"product_type":"c1","uid":1234043,"ip_address":"","ucode":"0A082CE0D79C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/7b/74e59208.jpg","comment_is_top":false,"comment_ctime":1574663414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574663414","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":155197,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1574660816,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574660816","product_id":100039001,"comment_content":"打卡：组合和继承个有好处，不能滥用继承，组合方式更机灵活.","like_count":0},{"had_liked":false,"id":155196,"user_name":"崔礼堂","can_delete":false,"product_type":"c1","uid":1075312,"ip_address":"","ucode":"CB5F16A3774EF4","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/70/10e07705.jpg","comment_is_top":false,"comment_ctime":1574660473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574660473","product_id":100039001,"comment_content":"Vo接查询参数，dto反回列表对象，我是这么用的，其实有点懵","like_count":0},{"had_liked":false,"id":155179,"user_name":"阿崔cxr","can_delete":false,"product_type":"c1","uid":1177565,"ip_address":"","ucode":"26E2C7D96306A4","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/dd/c85f2065.jpg","comment_is_top":false,"comment_ctime":1574657195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574657195","product_id":100039001,"comment_content":"对于用组合还是继承来讲的话，我优先选择满足于当下业务场景下的最简单的实现方法。 不做过度的设计。 当未来有需求要变更的时候，通过重构来改变现有设计。 ","like_count":0},{"had_liked":false,"id":155177,"user_name":"路伴友行","can_delete":false,"product_type":"c1","uid":1506974,"ip_address":"","ucode":"96B54B7EEAEDAD","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/9e/8165b0a0.jpg","comment_is_top":false,"comment_ctime":1574656954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574656954","product_id":100039001,"comment_content":"VO, BO, Entity  还不如 map 字典来的方便🤣🤣🤣","like_count":0},{"had_liked":false,"id":155174,"user_name":"暝","can_delete":false,"product_type":"c1","uid":1608600,"ip_address":"","ucode":"20AE1FDFE6DD91","user_header":"https://static001.geekbang.org/account/avatar/00/18/8b/98/ddbdea57.jpg","comment_is_top":false,"comment_ctime":1574656630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574656630","product_id":100039001,"comment_content":"相对固定的组合，就是继承。组合更加灵活一点","like_count":0},{"had_liked":false,"id":155172,"user_name":"Zm","can_delete":false,"product_type":"c1","uid":1448893,"ip_address":"","ucode":"831FF80F07E965","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKj4w4lW7ibGEVxPv8wS1CrXKDeBz3RAaAdISxQSD23uUpV3wicsIMepaYZE8GzRcWmSpjet5NDN4MA/132","comment_is_top":false,"comment_ctime":1574656207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574656207","product_id":100039001,"comment_content":"Spring中beanfactory和beandefintion就是组合。  ","like_count":0},{"had_liked":false,"id":155171,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1574656021,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574656021","product_id":100039001,"comment_content":"这个课后思考题很实际。<br>如果组合entity，那entity里面不需要向外暴露的属性是不是要通过封装？<br>封装的话真正使用entity的时候又不支持直接获取entity对象了？<br>再扩展一点的话，在ddd中，各层对象可以是严格隔离的(每层之间都要转换)，可以是非严格的(可以使用一个对象)，这种情况又怎么更合理的使用组合还是继承呢？","like_count":0},{"had_liked":false,"id":155163,"user_name":"MaxHu","can_delete":false,"product_type":"c1","uid":1005070,"ip_address":"","ucode":"31E69EE0717B62","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/0e/43dbfb92.jpg","comment_is_top":false,"comment_ctime":1574654321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574654321","product_id":100039001,"comment_content":"课上老师提到:装饰模式，组合模式和和策略模式用了组合，而模版模式用的继承.上面说的组合其实是用到了继承和委托还有局部组成整体的组合. 上面说的继承是指对抽象类的继承，并且只用了继承。是这样理解吧？","like_count":0},{"had_liked":false,"id":155154,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1574652791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574652791","product_id":100039001,"comment_content":"用继承吧，可以将相同的部分抽出一个BaseEntity，然后不同的部分作为子类继承BaseEntity","like_count":0},{"had_liked":false,"id":155144,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1574651236,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574651236","product_id":100039001,"comment_content":"我认为这个要看 VO,BO,Entity的关系，如果 BO，VO,Entity存在包含关系 比如 VO 包含EntityA,EntityB那么就应该用组合，如果BO，VO,Entity只是用来存储字段数据，并且大部分字段名字都一样的话，为了消除重复代码，我首选继承。我非常赞同老师说这句话 ，“组合并不完美，继承也不是一无是处”！","like_count":0},{"had_liked":false,"id":155138,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1574650267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574650267","product_id":100039001,"comment_content":"把重复的代码抽出一个或多个接口并实现相应的类，然后在Entity，BO和VO中添加对应的属性（一个或多个），以此来实现代码复用，这就是一个典型的接口+组合实现代码复用并避免继承的例子","like_count":0},{"had_liked":false,"id":155116,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574647651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574647651","product_id":100039001,"comment_content":"他们没有继承关闭 所以应该用组合方式来解决重复性代码","like_count":0},{"had_liked":false,"id":155113,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1574647352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574647352","product_id":100039001,"comment_content":"got it~","like_count":0},{"had_liked":false,"id":155107,"user_name":"huahuaxiaoshao","can_delete":false,"product_type":"c1","uid":1600012,"ip_address":"","ucode":"3309034B2A8C65","user_header":"https://static001.geekbang.org/account/avatar/00/18/6a/0c/3740de12.jpg","comment_is_top":false,"comment_ctime":1574646556,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574646556","product_id":100039001,"comment_content":"一般来说，每个Entity都有增删改查的功能，何不设计一些增删改查的接口，并实现这些接口。通过组合构成一些通用类（当然封装的时候，会用到委托方式），本人就是一个小白菜，发表一下我的想法，不知道对不对，望批评指正。","like_count":0,"discussions":[{"author":{"id":1234314,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","nickname":"东征","note":"","ucode":"DC557A1631A493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57990,"discussion_content":"已经有了，了解下jpa","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574648470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155105,"user_name":"米 虫","can_delete":false,"product_type":"c1","uid":1073087,"ip_address":"","ucode":"6F35AA8BB8195B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/bf/4bd3eb4b.jpg","comment_is_top":false,"comment_ctime":1574646497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574646497","product_id":100039001,"comment_content":"我发现平时代码中，我也想不出多复杂的继承关系来，所以一般想到了的is a ，我都用上了继承，可能是多肽的魅力太诱惑。也可能是我原本就把继承当接口用了，c++。","like_count":0},{"had_liked":false,"id":155092,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1574644910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574644910","product_id":100039001,"comment_content":"实际中可能没有那么多entity,bo,vo，一般我们都是用一个","like_count":0},{"had_liked":false,"id":155088,"user_name":"Sheamus","can_delete":false,"product_type":"c1","uid":1248510,"ip_address":"","ucode":"F6EBDFF3575ADA","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","comment_is_top":false,"comment_ctime":1574644721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574644721","product_id":100039001,"comment_content":"课后思考题，使用组合比较好，有时候vo并不是要所有字段","like_count":0},{"had_liked":false,"id":155085,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1574644284,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1574644284","product_id":100039001,"comment_content":"老是你好，有个实现细节的问题。<br>实现 Flayable, Tweetable, EggLayable这些接口，如果需要访问 类的属性或方法的话，怎么使用 TweetAbility FlyAbility EggLayAbility 的委托方式实现呢？<br>如果实现时不需要访问 类的属性或方法的话，那不就和静态函数一样了吗？","like_count":0},{"had_liked":false,"id":155076,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1574643457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574643457","product_id":100039001,"comment_content":"## 继承的作用<br><br>1.  表示 is-a 关系<br>2. 支持多态<br>3. 代码复用<br><br>## 继承的缺点<br><br>类继承容易导致继承层次越来越深，层次变深会引起两个问题：<br>1. 代码可读性变差，从而导致可维护性变差。<br>2. 破坏类的封装性，子类依赖父类的实现，两者高度耦合。<br><br>## 如何解决继承的缺点<br><br>利用组合、接口、委托等三种技术手段。<br>（文中的例子依赖于其它类，因此需要实例化，Java 的抽象类可以包含实现，是不是用抽象类会更好？）<br><br>## 组合的优势<br><br>使用 has-a 关系解决继承 is-a 关系导致的问题，同时不丢失继承的优势。<br><br>## 组合的缺点<br><br>组合需要定义更多的类和接口，从而导致代码复杂度和维护成本增加。<br><br>## 如何选择继承和组合<br><br>1. 通常情况下，纵向比较深选择组合；横向比较广选择继承。<br>2. 只是接口功能相同，类之间没有继承关系时使用组合。<br>3. 对已有的类进行多态，只能使用继承。<br>","like_count":0},{"had_liked":false,"id":155072,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1574643293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574643293","product_id":100039001,"comment_content":"项目中大部分都是无脑继承，然后加自己的属性。。用组合的话，每次创建vo，bo对象，都要传一个entity进来，感觉也很麻烦","like_count":0},{"had_liked":false,"id":155067,"user_name":"tomcat","can_delete":false,"product_type":"c1","uid":1367381,"ip_address":"","ucode":"E56EDAA22D9287","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ1AM7bbBzJUQUC5qu7jebxd1pFYnibiaABbz0s7jNxOVpHBgNAtsPBFf504ib9ZjNdK4eDoiavjAZIYg/132","comment_is_top":false,"comment_ctime":1574642959,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574642959","product_id":100039001,"comment_content":"这种领域对象，只有getter,setter方法，将公共属性抽取到父类中，采用继承可以减少大量重复代码，实际项目中也是这么使用的。","like_count":0,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58066,"discussion_content":"赞同！而且如果项目在设计初命名不规范，会导致Entity（我一般与数据库字段名一一对应），VO,BO各字段名字都不一样，很头痛呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574650904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155049,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1574641491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574641491","product_id":100039001,"comment_content":"坐等大牛来优雅的解决思考题问题，这个问题困扰过，但是还是会复制粘贴，因为怕将来万一有变化。","like_count":0},{"had_liked":false,"id":155034,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1574639749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574639749","product_id":100039001,"comment_content":"这一节收获匪浅，感谢老师，对于思考题。我认为可以用组合，平时开发的时候，这三个类都是分开的。写了很多重复的代码，也一点都不优雅，期待老师的解答","like_count":0},{"had_liked":false,"id":155029,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1574639103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574639103","product_id":100039001,"comment_content":"老师 多继承中的mixin组合方式 是不是一种很好的方法呢","like_count":0},{"had_liked":false,"id":155025,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1574638719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574638719","product_id":100039001,"comment_content":"Mvc中各层的实体类有时候还要更加复杂一点，有时还要细分为入参和返回两种。比如controller的Request 和Response。<br><br>在业务简单的情况下，有时甚至可以三层都用同一个实体。<br><br>实体之间重复的部分可以考虑使用继承抽取。<br><br>而且还有一个问题，不同的实体在转换的时候，一大堆的get set方法，实在是不雅。","like_count":0},{"had_liked":false,"id":154996,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1574612419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574612419","product_id":100039001,"comment_content":"定义一个BaseBean包含着几个O的属性， <br>其他的O来继承.<br>","like_count":0},{"had_liked":false,"id":155016,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574629797,"is_pvip":false,"discussion_count":28,"race_medal":0,"score":"1517698085285","product_id":100039001,"comment_content":"我的观点比较极端，用接口，组合和委托代替继承。原因如下：<br>1. 人无法预知未来，现在比较稳定的类继承关系将来未必稳定。<br>2.两种设计之间的选择耗费资源，每次都要为这个问题拿捏一下，甚至争论一下，不如把争论放在业务逻辑的实现上。<br>3.相对于接口+组合+委托增加的复杂度，代码统一成接口+组合+委托带来的好处更多，利于阅读和交流，毕竟读代码的次数大于写的次数，读一种类型的代码的难度远低于读两种类型。<br>4.新的编程语言让接口+组合+委托变得容易，例如Kotlin就有专门的语法糖支持，消除了很多模板代码。<br>5.接口+组合+委托符合矢量化思想，那就是将物体特征分成不同的维度，每个维度独立变化。继承则是将物体分类，抽取共性，处理共性，操作的灵活性大打折扣，毕竟现实中的物体特征多，共性少。","like_count":354},{"had_liked":false,"id":155007,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1574616175,"is_pvip":false,"replies":[{"id":"60028","content":"抽空集中答疑一下吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574853379,"ip_address":"","comment_id":155007,"utype":1}],"discussion_count":30,"race_medal":0,"score":"688769383535","product_id":100039001,"comment_content":"我个人感觉VO和BO都会采用组合entity的方式，老师是否可以在下一节课课聊聊上节课留下的思考题，您的处理方式？","like_count":160,"discussions":[{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274965,"discussion_content":"我觉得知道不同模式的应用场景,能灵活运用就可以了,这种类型的比喻反而容易引起混淆","likes_number":23,"is_delete":false,"is_hidden":false,"ctime":1590637599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385252,"discussion_content":"课讲的越来越敷衍了\n","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1626955859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246610,"discussion_content":"不要随便拿点语言就生搬硬套","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1587743701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197379,"discussion_content":"装饰器模式：一定is-a关系，但是代理是吗？不一定是喔","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1583418965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186693,"discussion_content":"看老师的代码 我没看出代理模式和装饰者模式有什么不一样的地方， 不能因为使用场景的不同，就说是模式不同吧","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1582706044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188142,"discussion_content":"我也有相同的疑惑","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582800329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186693,"ip_address":""},"score":188142,"extra":""},{"author":{"id":1050642,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/12/3143f632.jpg","nickname":"冷冽","note":"","ucode":"4F952D4CFD5858","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193205,"discussion_content":"之前看《head first 设计模式》，里面写的，装饰器模式是拓展对象的行为，拓展内容都是对象的职责；代理模式是提供对象访问控制，是对象的一个替身。而且书里原文写了：代理在结构上类似装饰者，但是目的不同","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1583137925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186693,"ip_address":""},"score":193205,"extra":""},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050642,"avatar":"https://static001.geekbang.org/account/avatar/00/10/08/12/3143f632.jpg","nickname":"冷冽","note":"","ucode":"4F952D4CFD5858","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198188,"discussion_content":"不明白","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583485537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":193205,"ip_address":""},"score":198188,"extra":""}]},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246608,"discussion_content":"我总感觉你说的代理有问题，到底是谁帮谁代理，是经济人给明星代理，好像经济人也会唱歌一样，其实他不会，他间接利用明星会唱歌帮他代理，是利用了明星唱歌，然后自己跑业务，进行方法增强","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1587743667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292946,"discussion_content":"一拳一个杠精怪","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595391112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":246608,"ip_address":""},"score":292946,"extra":""},{"author":{"id":1206229,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","nickname":"Gopher","note":"","ucode":"3C1F9012BB486D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311080,"discussion_content":"说的例子并有啥问题，经纪人是明星的代理，那么可以把经纪人和歌手看作一个整体，这样看这就是个 能自己接活的歌手了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602214009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":246608,"ip_address":""},"score":311080,"extra":""}]},{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186694,"discussion_content":"\n// 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n  void f();\n}\npublic class A impelements IA {\n  public void f() { //... }\n}\npublic class AProxy impements IA {\n  private IA a;\n  public AProxy(IA a) {\n    this.a = a;\n  }\n  \n  public void f() {\n    // 新添加的代理逻辑\n    a.f();\n    // 新添加的代理逻辑\n  }\n}\n\n// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n  void f();\n}\npublic class A impelements IA {\n  public void f() { //... }\n}\npublic class ADecorator impements IA {\n  private IA a;\n  public ADecorator(IA a) {\n    this.a = a;\n  }\n  \n  public void f() {\n    // 功能增强代码\n    a.f();\n    // 功能增强代码\n  }\n}","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582706073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198187,"discussion_content":"就是说代码实现是一样的呗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583485497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186694,"ip_address":""},"score":198187,"extra":""},{"author":{"id":2041396,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","nickname":"宙斯","note":"","ucode":"80DF36BAD298AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387970,"discussion_content":"形式是一样的 写一遍又怎样呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628517606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186694,"ip_address":""},"score":387970,"extra":""}]},{"author":{"id":1903708,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0c/5c/b03b2cc1.jpg","nickname":"Geek_db6a4b","note":"","ucode":"E5992D1CF088C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375285,"discussion_content":"歌手本来就不负责搭台，所以代理模式不合适，而经纪人能帮歌手搞定一系列的事，所以适用中介模式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621562996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1775076,"avatar":"","nickname":"严","note":"","ucode":"9704161D1B317C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234706,"discussion_content":"设计模式来源于生活，更高于生活","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586995911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","nickname":"永旭","note":"","ucode":"C9C74BE32C8F46","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233595,"discussion_content":"你这个例子让我茅塞顿开, 谢谢~~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586933568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363929,"discussion_content":"人才啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617327697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1697810,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","nickname":"辉","note":"","ucode":"0D7B2C24BA8BD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351642,"discussion_content":"代理模式不是这样样子的吧，代理模式是我委托别人去代理我做一件和我想做的事。比喻是好事，但是别误导一些刚学习的没什么代码经验的人了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614353159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1206544,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","nickname":"懒猫","note":"","ucode":"B4B567A11B491D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1697810,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","nickname":"辉","note":"","ucode":"0D7B2C24BA8BD2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368393,"discussion_content":"这是出于实际实现角度考虑，经纪人是歌手的增强：向上增强。耳机也是歌手的增强，向下增强。答只是形象比喻下，希望别硬扛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618673730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351642,"ip_address":""},"score":368393,"extra":""},{"author":{"id":1248730,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0d/da/906dce6a.jpg","nickname":"sudo","note":"","ucode":"1936F782F914D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1697810,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","nickname":"辉","note":"","ucode":"0D7B2C24BA8BD2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398569,"discussion_content":"我觉得这比喻不咋样，误导人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632813986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351642,"ip_address":""},"score":398569,"extra":""},{"author":{"id":1145759,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/9f/da374651.jpg","nickname":"zero","note":"","ucode":"D8A22815D8987C","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":1697810,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e8/12/74f387c8.jpg","nickname":"辉","note":"","ucode":"0D7B2C24BA8BD2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569155,"discussion_content":"似乎是你自己理解错了，代理模式就是唱歌还是歌手自己唱，你这种理解方式变成经纪人唱歌了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651333860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351642,"ip_address":""},"score":569155,"extra":""}]},{"author":{"id":1071601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/59/f1/8909b9e0.jpg","nickname":"叉歪叉","note":"","ucode":"2C1AFC6335FF0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305918,"discussion_content":"一个类会有很多代理么，一个类可以有很多装饰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600129971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1109528,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","nickname":"王大喵","note":"","ucode":"C14AAE3ED964DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/59/f1/8909b9e0.jpg","nickname":"叉歪叉","note":"","ucode":"2C1AFC6335FF0E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308653,"discussion_content":"一个类可以有多个代理，也可以有多个装饰器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601020045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305918,"ip_address":""},"score":308653,"extra":""},{"author":{"id":1598564,"avatar":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","nickname":"劳码识途","note":"","ucode":"7AEF4D9407F097","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1109528,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","nickname":"王大喵","note":"","ucode":"C14AAE3ED964DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309745,"discussion_content":"对暗号：代理可以被代理吗/滑稽","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601430933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308653,"ip_address":""},"score":309745,"extra":""},{"author":{"id":2574819,"avatar":"https://static001.geekbang.org/account/avatar/00/27/49/e3/1e3320e9.jpg","nickname":"惊蛰","note":"","ucode":"E5A29CF79A24CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1598564,"avatar":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","nickname":"劳码识途","note":"","ucode":"7AEF4D9407F097","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374387,"discussion_content":"可以，只要不停的拓展子类，对上一个代理类进行增强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621160774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309745,"ip_address":""},"score":374387,"extra":""}]},{"author":{"id":1392556,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/ac/abd79156.jpg","nickname":"helloworld","note":"","ucode":"9DCFCF6835A8E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295963,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596415744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216643,"discussion_content":"是这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585472684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155242,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1574671181,"is_pvip":false,"discussion_count":18,"race_medal":0,"score":"581395256141","product_id":100039001,"comment_content":"课堂讨论answer:<br>Entity， Bo， Vo三者之间，显然并不存在 is-a关系，首先排除使用继承。<br><br>其次三者间也并非是严格的has-a关系，half measure之一是考虑使用组合（composition） + 委托（delegation）的方式解决代码重复的问题，但并不是我心中的最佳答案.<br><br>我的答案是不解决三者间的代码重复问题。Value Class就只是Value Class, 代码重复并不是业务上的代码重复,那就让它重复吧.<br><br>","like_count":136,"discussions":[{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288713,"discussion_content":"在各位大牛的评论里慢慢找感觉","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593847066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1037925,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d6/65/e6abeba2.jpg","nickname":"Persistfanāāā","note":"","ucode":"8C4EF892B7ED27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409768,"discussion_content":"感觉被人拆穿了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635507285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288713,"ip_address":""},"score":409768,"extra":""}]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288232,"discussion_content":"个人感觉，从业务考虑，最终映射到代码上，还是从被增强的方法说起，看被增强的方法，增加缓存，对原先方法的执行有没有影响，或者原先方法会不会依赖增加的逻辑，如果加不加这部分逻辑，原先的方法，执行结果一样，那就叫代理，否则叫装饰，同时从业务的角度出发，综合考虑缓存怎么设计，看这个设计会不会影响原先方法的执行，因业务场景缓存场景具体定","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593687697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875547,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/9b/21f6f607.jpg","nickname":"L","note":"","ucode":"46E1848E786751","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544297,"discussion_content":"说得真好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641460580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2404887,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","nickname":"达叔灬","note":"","ucode":"5CCBAF13548F02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388421,"discussion_content":"靠谱的总结啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628757785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/6a/80d9c545.jpg","nickname":"RD","note":"","ucode":"E3947B6E1681AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362929,"discussion_content":"好家伙，我直接好家伙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617074864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2170166,"avatar":"https://static001.geekbang.org/account/avatar/00/21/1d/36/2f22b1ba.jpg","nickname":"宝可梦","note":"","ucode":"A972D53C929626","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333034,"discussion_content":"这才是正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607419086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306651,"discussion_content":"真他妈牛！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600340799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201574,"discussion_content":"受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583810007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1152178,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/b2/6d587bb1.jpg","nickname":"久违的","note":"","ucode":"34F703D88A643D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198990,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583546698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1505950,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fa/9e/306a5ce7.jpg","nickname":"EdisonLi","note":"","ucode":"A85CBF3E2B5620","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192019,"discussion_content":"你的评论更容易理解！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583055490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186889,"discussion_content":"说的好，学习了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582719938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155288,"user_name":"兔2🐰🍃","can_delete":false,"product_type":"c1","uid":1096984,"ip_address":"","ucode":"1FEDA044BB6CBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/18/2af6bf4b.jpg","comment_is_top":false,"comment_ctime":1574674973,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"486905979421","product_id":100039001,"comment_content":"看下来对组合跟委托两个概念表示不太明白，看了代码后才，以及网上查阅后才明白。<br>继承(Inheritance)：利用extends来扩展一个基类。is-a的关系。<br>组合(composition)：一个类的定义中使用其他对象。has-a的关系。<br>委托(delegation)：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。有uses-a, owns-a, has-a三种关系。","like_count":114,"discussions":[{"author":{"id":1232468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/54/c13b1d63.jpg","nickname":"二十四桥仍在","note":"","ucode":"5498FE5949190F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224454,"discussion_content":"没说清楚啊，无需重写的方法，不去调用，那不是也没有影响吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586308434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1457872,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3e/d0/8044f633.jpg","nickname":"芝士就是力量","note":"","ucode":"C54D8954148C7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/54/c13b1d63.jpg","nickname":"二十四桥仍在","note":"","ucode":"5498FE5949190F","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":309880,"discussion_content":"其实说的很清楚了，BufferedInputStream本身不作为任何io通道的输入流，也就是说它本身不具备这个能力，所以才需要原始类去调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601476218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224454,"ip_address":""},"score":309880,"extra":""}]}]},{"had_liked":false,"id":155565,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1574699639,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"349467050615","product_id":100039001,"comment_content":"VO,BO,DO表示什么前面都说过了，我觉得得换一个思路去看待这种模型转换的问题。 <br>这里我们将BO看做ddd里面的核心域中的实体。那么这个对象的变化应该对VO或者DO隐藏起来，VO是对外的模型，为什么需要感知到内部业务的变化，DO是具体的存储方式，这是由实现决定的，在业务逻辑中也不应该关心。重要的是隔离，让这三者独立变化。 <br>所以我的结论是，既不应该用继承，也不应该使用组合，使用防腐层，模型转换层隔离这种变化才是最好的。<br>但是实际上在很多业务中BO和DO是差不多的，于是就混用了，在业务不复杂的时候，也没太大关系。业务运行的很好，也不难理解。<br><br>追求完美，却不可能处处完美。","like_count":82,"discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534194,"discussion_content":"装饰器模式也叫filter模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638115458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786752,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/43/80/b1ae32cd.jpg","nickname":"Kenneth。🌞","note":"","ucode":"299ADF236395CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383311,"discussion_content":"没有FilterInputStream 一样也是会调用实际传入的inputStream 的方法，因为不继承，BufferedInputStream 就必须持有inputStream 的方法引用， 并且在重写对应方法，委派给inputStream 执行，然后在需要方法增强。 \n会存在一个问题，不是所有方法都是BufferedInputStream 需要增强的，每个方法都重写就很繁琐， 再者，所有对InputStream 增加的类都需要重写，代码和功能上都有重复，所以就抽象一个FilterInputStream咯 ~  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626056556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073845,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","nickname":"zhanyd","note":"","ucode":"4C994EE512A3C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286548,"discussion_content":"此时调用is的没有重写方法(如read方法)时调用的是InputStream类中的read方法，而不是FileInputStream中的read方法-----这里说的不对吧？假如说BufferedInputStream类直接继承自InputStream类，其实调的是FileInputStream中的read方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593223909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1473448,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7b/a8/f9a2a7fd.jpg","nickname":"Feliz city","note":"","ucode":"8C4774234666CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073845,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","nickname":"zhanyd","note":"","ucode":"4C994EE512A3C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287680,"discussion_content":"不是吧，如果不在BufferedInputStream里包装一下，比如重写一下read()在里面调用in.read()，那真正bin.read()调用的其实是InputStream类中的默认方法（假设read()在InputStream中已经默认实现了）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593509025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286548,"ip_address":""},"score":287680,"extra":""}]}]},{"had_liked":false,"id":237330,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1595781240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"216344146040","product_id":100039001,"comment_content":"继承和组合本质是一样的，都是委托。继承其实就是子类包含了父类的一个引用，然后把自己某些方法委托给父类。组合就是包含了多个其他类的引用，然后把自己的某些方法委托给这些类。<br>而只能委托给一个类和可以委托给多个类就是继承和组合的区别。只能委托给一个类，那么这个类一定要包含我要委托的全部能力；可以委托给多个类，那么这些能力就可以分散在这些委托的类中。将能力分散比将能力聚合更符合单一职责的原则。<br>如果将继承关系用树来描述，继承的弊处在于将继承路径上的那些扩展功能固化到了这条路径上的每个子类节点上了，一旦你想创建新的子类节点并想让它包含某个已存在的扩展功能，你就必须是那个扩展功能所在的节点的直系后代节点。那么问题来了，新的子类节点就顺带拥有了路径上其他节点的扩展功能，即使这些扩展功能并不是它想要的。当然，你可以重新开辟一条继承路径，使得这条路径上的扩展功能都是你想要的功能，这样一来，继承带来的的复杂性和功能的冗余性就体现了（两条路径存在功能相同的节点）。很自然地，你会想，把这些重复的功能抽成单独的类分离出去不就好了吗，一旦这样做了，就成了名为继承实为组合的设计了，因为它将功能委托给了多个类而不仅仅是它的父类。<br>可见，组合恰到好处地解决继承带来的问题，它将扩展功能成了一个个游离的单元，可根据需要自由组合，然后借助接口给自己打上标签，解决了 is-a 的问题。","like_count":50},{"had_liked":false,"id":155465,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1574691089,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"190553252113","product_id":100039001,"comment_content":"希望，评论区能增加一个&lt;b&gt;可选开关&lt;&#47;b&gt;，“只看作者回复”的评论「(*&#47;ω＼*)」","like_count":45,"discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306684,"discussion_content":"主要区别还是在于场景，一个是增加和业务无关的功能，一个是增强功能，尤其是装饰者在概念上存在一个和原生类 存在继承同一个父类的关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600347581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300013,"discussion_content":"你这么说他跟代理完全没区别  本质是增强的代码是否与业务相关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597909546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155006,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1514882,"ip_address":"","ucode":"2F1FA3519FAB50","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyiafvkibXnTOpIJxlhndHpSDMsqja9AajKYtYgGEGtFWtBb2Mg8DRVjqlWyIxl1piaT4qpMkwerQUg/132","comment_is_top":false,"comment_ctime":1574615816,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"156193438472","product_id":100039001,"comment_content":"打卡✔<br>看完之后有种感觉，我们平常写的spring的依赖注入这种形式，是不是就是跟组合，委托这种模式啊","like_count":36,"discussions":[{"author":{"id":1875922,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/9f/d2/54578161.jpg","nickname":"菲茨杰拉德","note":"","ucode":"4EB29359F39862","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542168,"discussion_content":"讲讲啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640674123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740322,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/22/51f690e1.jpg","nickname":"big熊","note":"","ucode":"8D382BF137EF00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342532,"discussion_content":"阿哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610705285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173535,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1579591183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"126133642767","product_id":100039001,"comment_content":"万人血书，请老师讲解最优的方案，顶起来！！","like_count":30},{"had_liked":false,"id":155045,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1592092,"ip_address":"","ucode":"FF41E5D87BAD76","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/1c/5eb03a91.jpg","comment_is_top":false,"comment_ctime":1574640898,"is_pvip":false,"replies":[{"id":"60030","content":"可以的...","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574853463,"ip_address":"","comment_id":155045,"utype":1}],"discussion_count":2,"race_medal":0,"score":"96063921410","product_id":100039001,"comment_content":"希望作者能在课程末尾梳理下上一节课程的课后习题，或者集中点评下大家的留言。感谢","like_count":22,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475644,"discussion_content":"可以的...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574853463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586189,"discussion_content":"这个做了吗？在哪里可以找到答疑呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662026035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158697,"user_name":"kk","can_delete":false,"product_type":"c1","uid":1001181,"ip_address":"","ucode":"4C96F29C822E1D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/dd/8281f351.jpg","comment_is_top":false,"comment_ctime":1575435891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"83179814515","product_id":100039001,"comment_content":"希望老师，在每一节课能回答一下上一节课的问答","like_count":19},{"had_liked":false,"id":155042,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574640500,"is_pvip":false,"replies":[{"id":"60029","content":"理解的没问题！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574853437,"ip_address":"","comment_id":155042,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61704182644","product_id":100039001,"comment_content":"打卡✔<br>继承的层次过深带来的缺点看明白了，组合和委托不太理解，回头又好好看了看代码，视乎理解了，希望不要忘记了。也不知道是否理解对了？<br>记下自己的体会：<br>组合——类中包含其他实现类，感觉就是把大的功能分成多个类来实现，然后再根据需要组合进来使用。<br>委托——类中实现接口方法的时，把具体的实现方法调用其他类中的方法处理，也就是委托给别人（被委托者）帮他写好具体的实现。","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475642,"discussion_content":"理解的没问题！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574853437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271420,"discussion_content":"总结的挺经典的呀，哈哈。给个赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590134447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155135,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1574650031,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"57409224879","product_id":100039001,"comment_content":"GO完全摒弃了继承，在语法上只有组合，接口之间也可以组合(这也是官方鼓励的做法)。","like_count":13,"discussions":[{"author":{"id":1056127,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","nickname":"hetiu","note":"","ucode":"35D9338C3ABD20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101590,"discussion_content":"go的匿名组合颇有继承的味道","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577288470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2421338,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f2/5a/399ff23b.jpg","nickname":"越客","note":"","ucode":"2BF54F35774744","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1056127,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","nickname":"hetiu","note":"","ucode":"35D9338C3ABD20","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345434,"discussion_content":"还是多重继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611719866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":101590,"ip_address":""},"score":345434,"extra":""}]},{"author":{"id":1119851,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/6b/af7c7745.jpg","nickname":"tiny🌾","note":"","ucode":"7A4DE00381D1F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589826,"discussion_content":"go开发，还用看这专栏吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665328139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392924,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rRCSdTPyqWcW6U8DO9xL55ictNPlbQ38VAcaBNgibqaAhcH7mn1W9ddxIJLlMiaA5sngBicMX02w2HP5pAWpBAJsag/132","nickname":"butterfly","note":"","ucode":"1B724973303FB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285333,"discussion_content":"go是组合加接口，没了继承。那本节中提到的特殊场景，应该是没办法处理的\n“还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现“","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592810726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1763900,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ea/3c/24cb4bde.jpg","nickname":"疯狂的石头","note":"","ucode":"65CE6EB494FDCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1392924,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rRCSdTPyqWcW6U8DO9xL55ictNPlbQ38VAcaBNgibqaAhcH7mn1W9ddxIJLlMiaA5sngBicMX02w2HP5pAWpBAJsag/132","nickname":"butterfly","note":"","ucode":"1B724973303FB0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550540,"discussion_content":"go不会出现这种场景哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644581331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285333,"ip_address":""},"score":550540,"extra":""}]},{"author":{"id":1007670,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/60/36/1848c2b7.jpg","nickname":"dovefi","note":"","ucode":"9F8C59F095B187","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213367,"discussion_content":"喜欢go，干净利落","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585065386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156516,"user_name":"Brian","can_delete":false,"product_type":"c1","uid":1057945,"ip_address":"","ucode":"4C930BF5051EE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/99/694d5ee7.jpg","comment_is_top":false,"comment_ctime":1574904754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48819545010","product_id":100039001,"comment_content":"目前一项目中使用SpringBoot开发，其中对象定义为入参为DTO，数据库实现为Entity，业务返回结果为VO，三者对象完全独立，其中大部分属性相同，在 DTO对象 添加 convertToEntity 方法，Entity 添加 convertToVO 方法，实现对象属性拷贝。 同时在DTO和VO中使用组合方式，有很少数的继承。","like_count":11},{"had_liked":false,"id":155123,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1574649011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44524321971","product_id":100039001,"comment_content":"谈谈对下面一段话的理解：<br><br><br>“我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。”<br><br>理解或总结如下：<br><br>1、“比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代”，我的理解为：is-a意味着has-muilti-a&#39;s或者has-all-needed-a&#39;s。故而需要实现多个接口，而接口抽象的是操作或者方法而非数据（数据和方法的抽象由抽象类来完成），所以具体的操作要由被组合进来的类对象来完成，站在类间关系的角度来看，外部类和被组合类之间的关系被称为“委托”。<br><br>2、这里面，被组合类的代码被抽象到了接口中，或者反过来说接口的具体操作下沉到了被组合类中，这就是“代码复用我们可以通过组合和委托来实现”的含义，代码被不同的被组合类“分门（类）别类”的复用了。<br><br>3、“多态特性我们可以利用接口来实现”，因为接口代表了某种契约，而多态就是用子类代替父类。只要实现了某种接口，按照契约，自然就可以在某些方面或某种程度上代替父类。所以我觉得接口是“更细粒度更多控制的更有节制的继承”。<br><br>回到本课的问题。<br><br>之前的课说到VO，BO，Entity是典型的面向过程的编码，里面基本都是数据，没有方法。那么自然不可以用接口来减少代码的重复，只能用继承了。<br><br>但是MVC的结构，我理解它是一种分层客户端服务器架构，Layered Client-Server，每一层为其之上的层服务，并使用其之下的层所提供的服务。为了减少层之间的耦合，必要的重复是可以的。","like_count":10},{"had_liked":false,"id":237275,"user_name":"Hua100","can_delete":false,"product_type":"c1","uid":1723325,"ip_address":"","ucode":"4E7A749C343E90","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLLeKVmTFdR2hQsCaNxxTK8wvnXXBayKLLoITqnbW9yjloAZWU99mOGaf1DkWqM6dol77aER9ickibA/132","comment_is_top":false,"comment_ctime":1595765160,"is_pvip":false,"replies":[{"id":"88025","content":"是的，你理解的没错。但是，并不是所有的语言中，接口都支持默认实现这个特性。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1596111664,"ip_address":"","comment_id":237275,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40250470824","product_id":100039001,"comment_content":"请教一下，java8之后接口可以有default，那是不是就可以不需要使用组合+接口+委托了呢？是不是只需要接口+default方法就可以了？类似这样：<br>public interface Fly {<br>    default void fly(){<br>        &#47;&#47; 具体操作<br>    }<br>}<br>&#47;&#47; Tweetable, Eggable同理<br>public class Ostrich implements Tweetable, Eggable {<br>    public void egg(){<br>        Eggable.super.egg();<br>    }<br>    &#47;&#47; tweet同理<br>}<br>不知道我的理解对不对，我感觉这样就没必要用三个技术结合的方式。求大佬解答。","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502360,"discussion_content":"是的，你理解的没错。但是，并不是所有的语言中，接口都支持默认实现这个特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596111664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393482,"discussion_content":"dto,vo,entity，怎么弄?大部分字段都差不多，目前我实际都是用的继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631450313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155058,"user_name":"李湘河","can_delete":false,"product_type":"c1","uid":1349528,"ip_address":"","ucode":"DB078B5DAAE82E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","comment_is_top":false,"comment_ctime":1574642260,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40229347924","product_id":100039001,"comment_content":"现代军事武器中的开发都在追求模块化开发，这样装备之间通用性更强，战损时随时可以替换掉损坏的模块，这样又可以重新作战，当要增强坦克某一部分的性能时，仅改进对应的模块就行，感觉很像组合的思想。就像文中说的，对于结构稳定，层次浅的地方完全可以用继承，或者说可以局部用继承，比如VO层，对于用户检验，分页等都可以抽象出来","like_count":9,"discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292711,"discussion_content":"人类思考处理问题的本质还是都差不多的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595313687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217306,"avatar":"https://static001.geekbang.org/account/avatar/00/12/93/1a/5bb29be9.jpg","nickname":"曹玉磊","note":"","ucode":"BD46077D348F75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61444,"discussion_content":"觉得这个更像是面向接口编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574779472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155193,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1574659486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35934397854","product_id":100039001,"comment_content":"1.bo vo和entity三个命名在现在面向服务而非页面的后端编程，并不合适。<br>2.这里最好用组合。entity是最小的实体单元，bo可能面对多个entity聚合，vo可能面对多个bo聚合，这种场景下，显然组合更适合。虽然也存在entity和bo一对一的场景，或者bo中只有一个主entity的场景，这种场景用继承倒也不为过。但是，为了套路单一，减少阅读思考，统一组合便是，没必要再引入继承。<br><br>3.老项目里面，代码已经高度耦合，而且不是面相接口写的代码，那么整体改动成本会很大。这种情况下用继承实现多态我觉得挺合适。<br><br>4.java1.8提供接口的方法默认实现后，我觉得继承的处境真的挺尴尬，新项目反正能用继承实现的用组合也可以。所以除非父子关系特别明显（继承不深其实比组合直观），不然没什么必要用继承了。","like_count":8},{"had_liked":false,"id":155024,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574638524,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35934376892","product_id":100039001,"comment_content":"Entity，也称为DO （Data Object），与数据库表结构一一对应，到过DAO层向上传输对象，应独立为一个类。<br><br>BO，VO 可以采用继承或者组合的方式，复用DO的代码。<br><br>谨慎使用继承方式来进行扩展，不得已使用的话，必须符合里氏替换原则，父类能够出现的地方子类一定能够出现。","like_count":8},{"had_liked":false,"id":174684,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1580350941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27350154717","product_id":100039001,"comment_content":"vo， entity， bo只承载数据，不承载业务。虽然具有重复的代码，但却服务于不同的业务，采用任何一种方式都会耦合，不如就让代码重复着","like_count":6},{"had_liked":false,"id":155098,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574645752,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27344449528","product_id":100039001,"comment_content":"很多同学提出复用Entity（DO），我有不同意见：若修改DO，可能会影响到BO和VO。<br>我们都知道DO对应数据表，如PersonDO类有id，age，name。<br>若现在需求改变，age要从政府系统获取，原有的Person表要删除age字段，相应的DO类就要修改，UI仍然显示person.age。BO、VO有如果使用了DO就会受到影响。<br>为了降低影响，BO,VO考虑使用PersonDTO。<br>上面的例子中DTO中保留Person.age属性，在Service层中将DO转换为DTO，转换时PersonDTO.age从其他系统获取。<br>这样虽然增加了代码量，对DAO层的修改影响降到最低。","like_count":6},{"had_liked":false,"id":154999,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1574613914,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27344417690","product_id":100039001,"comment_content":"我的个人感觉,等待高手更好的回答&#47;&#47;<br>Entity在VO,BO中基本上都是一模一样的,使用组合把Entity引用进来,然后在BO,VO中创建各自独特的属性&#47;","like_count":6,"discussions":[{"author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87735,"discussion_content":"这样的话，其实对于前端数据的展现不是很友好，毕竟简单对象嵌套了两层+。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576677947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369757,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7WkTI1IicbKvsPJng5vQh5qlrf1smbfl2zb7icHZfzcAk1k4lr8w8IDEAdrqq1NHW5XZMPXiaa1h7Jn1LGOWOCkIA/132","nickname":"早起不吃虫","note":"","ucode":"13CD3B5E1F9435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538599,"discussion_content":"增加了解析层级，并且会徒增无意义字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639453758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154995,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1574612376,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"27344416152","product_id":100039001,"comment_content":"打卡✔<br>老师好，今天刚用继承优化了代码臃肿的问题，但是感觉好奇怪，请老师指导:<br>所有的消息都会先到一个A类中，在A类中，根据消息类型，比如类型1 2 3 4去处理不同的业务，每一类的业务都需要处理对应数据，原本随着消息类型的增加不断往这个A类中扩展代码，导致不好维护，所以我对每个业务模型建对应的类继承这个A类，在A类中将消息转给对应类去处理，其实new一个类 将所有参数传过去也可以，但是因为参数太多太多不美观，所以使用了继承，但回过头来想，我的继承只是被动使用的，好像和继承的原理相违背","like_count":6,"discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57663,"discussion_content":"A类里面加个工厂，通过工厂映射到处理类，每个类实现自己的业务，差不多是策略模式，参数构造一个参数类，每次都传类过去，这样可行吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574639952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1234314,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","nickname":"东征","note":"","ucode":"DC557A1631A493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58143,"discussion_content":"赞同，工厂加策略模式，将变化的部分抽作一个接口，工厂中维护接口的所有实现类（可以用spring注入list或map，比较方便动态发现），接口可以定义一个gettype方法，工厂中通过type寻找对应实现类做对应处理逻辑","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574654253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57663,"ip_address":""},"score":58143,"extra":""}]},{"author":{"id":1150755,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/23/bef3d8e9.jpg","nickname":"三省吾身","note":"","ucode":"7D68290C66CA68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70198,"discussion_content":"你应该使用组合加策略，实现分发类不用变更，只需要根据业务类型写具体实现类就可以。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575336089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57907,"discussion_content":"这个问题我理解不是出在A类，也不是出在对A类的继承，因为A类要接收消息，而子类需要依赖父类的资源。所以我认为问题出在对A类的调用上。当有新消息出现的时候，不要直接调用A的方法，也就是不要让A去区分应该给哪个子类处理。而是在调用方根据消息类型决定调用A的哪个子类。此处就跟失火🔥的夏天说的一样了，工厂模式或者策略模式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574646019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57937,"discussion_content":"感谢评论\n但是调用者是不知道的，一个控件显示若干数据，每条数据内部有个标记位，所有数据按照顺序显示","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574646831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57907,"ip_address":""},"score":57937,"extra":""},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58031,"discussion_content":"调用者调用一个工厂方法，工厂方法持有A的引用。这样呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574649745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57937,"ip_address":""},"score":58031,"extra":""},{"author":{"id":1584787,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/93/029eee99.jpg","nickname":"阿维","note":"","ucode":"84CBFDBD016806","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60967,"discussion_content":"我也有同样的问题，一个对象传过来几百项数据，我要把数据分类再分发到其他模块","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574767691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57937,"ip_address":""},"score":60967,"extra":""}]},{"author":{"id":2358638,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","nickname":"Amber","note":"","ucode":"650FE5C46CCD1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334685,"discussion_content":"把A拆分为抽象类class Message{virtual void handle() = 0; };不同消息类型继承或实现Message中的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607936643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86657,"discussion_content":"把代码贴出来，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576598171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58067,"discussion_content":"感觉你的A类的设计是为了方便调用者，事物在A类处理，消息分类，我觉的这很符合策略模式的应用场景，不妨试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574650929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":58118,"discussion_content":"好的\n感谢指导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574652873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":58067,"ip_address":""},"score":58118,"extra":""}]}]},{"had_liked":false,"id":155760,"user_name":"废材姑娘","can_delete":false,"product_type":"c1","uid":1047537,"ip_address":"","ucode":"6AFB48B2A4939A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/f1/a2cde35e.jpg","comment_is_top":false,"comment_ctime":1574750181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23049586661","product_id":100039001,"comment_content":"很想知道老师对思考题的答案，困扰我很久了","like_count":5},{"had_liked":false,"id":155741,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1574747051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18754616235","product_id":100039001,"comment_content":"VO就是用来指定对外暴露的字段，跟DO不算是is-a关系，稳定性也不高，所以个人认为不需要处理和DO的重复代码","like_count":4},{"had_liked":false,"id":156225,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1574839411,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14459741299","product_id":100039001,"comment_content":"可以使用组合+继承来解决代码重复的问题，但实际项目中我更倾向于不同层次之间的冗余(前提是MVC框架)，因为我理解的优秀的代码是服务于优秀的设计架构的，也就是说不通层次之间的代码中肯定会有冗余，因为数据是在不同层次中流转的。不过在同一个层次中的代码冗余就有优化的必要了","like_count":3},{"had_liked":false,"id":155632,"user_name":"ANYI","can_delete":false,"product_type":"c1","uid":1084773,"ip_address":"","ucode":"B010B0FB10E0C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/65/633a7478.jpg","comment_is_top":false,"comment_ctime":1574730844,"is_pvip":false,"replies":[{"id":"60018","content":"恩恩，好的，抽空答疑一下","user_name":"作者回复","comment_id":155632,"uid":"1190123","ip_address":"","utype":1,"ctime":1574850954,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"14459632732","product_id":100039001,"comment_content":"这个课堂讨论，争哥啥时候可以给大家讲解下，这个貌似都是大家比较关注的点，😄","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475814,"discussion_content":"恩恩，好的，抽空答疑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574850954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1113307,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fc/db/56b0d13c.jpg","nickname":"豌豆","note":"","ucode":"0C35FD827F9BFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":554914,"discussion_content":"是呀，老师什么时候解答一下这个问题呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646659370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475814,"ip_address":""},"score":554914,"extra":""}]},{"author":{"id":1535005,"avatar":"https://static001.geekbang.org/account/avatar/00/17/6c/1d/203e2917.jpg","nickname":"zhao健枫的微信ID确实有点长啊","note":"","ucode":"46C5D8EBE40109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299069,"discussion_content":"快一年过去了，争哥这个空还没抽出来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597553886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155032,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1574639518,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14459541406","product_id":100039001,"comment_content":"这次的思考题正好也是困惑我很久的问题，看看大家有什么好的方式。<br>之前我的做法是用组合+委托的方式，但发现这种方式其实还是无法实现分层，即间接的将两个硬关联起来，增减属性的时候需要同时修改两个对象的代码；<br>如果是继承关系，那么相当于多出一个类，让三个对象同时继承该类，但这个新衍生出的对象又怎么理解它呢？它与其他三个对象是否有is-a的关系？不能单纯的为了复用而继承。<br>最后我极端的做法是将三者合为一体，抽象理解成“数据承载对象”…哈哈，但是这个对于VO对象，通常需要根据接口要求返回特定格式的数据，所以变成不伦不类的对象了。<br>😭","like_count":3,"discussions":[{"author":{"id":1038798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/ce/4528cb4b.jpg","nickname":"呼呼","note":"","ucode":"5D7B57C05B5D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84882,"discussion_content":"我基本也是这样处理，三者合一，但是在controller重新自定义了responsebody注解，在json转换的时候排除掉一些字段。现在唯一没解决的问题是在do里是uid，但在vo中应该是User对象，这种好像没啥好办法。不过有些数据层框架也支持直接用user属性的id关联数据库。这样就完全没必要考虑do bo vo之间的问题了，直接一个do解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576507899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298006,"user_name":"geek_666888","can_delete":false,"product_type":"c1","uid":2024635,"ip_address":"","ucode":"3E348CCE186ACF","user_header":"","comment_is_top":false,"comment_ctime":1623886896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10213821488","product_id":100039001,"comment_content":"很多人建议作者给出答案。我也很想知道答案，但又不想知道答案。<br>看作者《数据结构和算法之美》的时候，作者有句话我一直记着，大概“思考过程远比标准答案重要。”<br>我想这也是作者不向其他作者直接给答案的原因。<br>第二点，评论中也有很多大佬给出自己的见解，技术问题的处理从来都是思辨的过程，没有标准答案。","like_count":2},{"had_liked":false,"id":244409,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1598509394,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10188443986","product_id":100039001,"comment_content":"Entity、BO、VO 对于这三个，如果只考虑这节课说的，那么抽出共有的类，各个类将这个共有类作为自己的属性即可。<br>但是就整个代码体系来看，他们各自的职责完全不相同且各个model对应的处理层也不同。完全没有必要为了消除重复去特殊化处理。重复就让他们重复好啦。","like_count":2},{"had_liked":false,"id":238896,"user_name":"旭塬","can_delete":false,"product_type":"c1","uid":1812849,"ip_address":"","ucode":"EF058DA2927A36","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/71/4f911305.jpg","comment_is_top":false,"comment_ctime":1596359913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10186294505","product_id":100039001,"comment_content":"用面向对象编程的思想来说，要保证最小功能粒度分开，VO.BO.Entity的功能场景不一样，就必须分开，不能因为一些代码重复就强行关联在一起，这也不利于解藕。<br>","like_count":2},{"had_liked":false,"id":155965,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1574785020,"is_pvip":false,"replies":[{"id":"60017","content":"你的意思是通过接口调用两个方法对吧，如果实在有这个需求，可以重新定义一个接口，extends另外两个接口。不过，你说的spring注入的情况，完全可以不依赖接口呀，直接依赖实现类也可以的。","user_name":"作者回复","comment_id":155965,"uid":"1190123","ip_address":"","utype":1,"ctime":1574850716,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164719612","product_id":100039001,"comment_content":"老师，针对你举鸟的例子：使用组合＋接口＋委托 代替继承的例子。如果在Spring中，怎么通过接口（自动注入）调用Ostrich鸵鸟的实现方法（下蛋和叫）？Tweetable和EggLayable接口各定义一个接口变量由鸵鸟初始化？这样感觉雍余了。<br>请解答一下？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475942,"discussion_content":"你的意思是通过接口调用两个方法对吧，如果实在有这个需求，可以重新定义一个接口，extends另外两个接口。不过，你说的spring注入的情况，完全可以不依赖接口呀，直接依赖实现类也可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574850716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155626,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1206726,"ip_address":"","ucode":"3B8DC780FE4EF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg","comment_is_top":false,"comment_ctime":1574730206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164664798","product_id":100039001,"comment_content":"结合DDD领域驱动设计，不是应该每层都做转换吗？例如dto，bo，po等。","like_count":2},{"had_liked":false,"id":155450,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1574690176,"is_pvip":false,"replies":[{"id":"60019","content":"也可以用组合的，组合也能解决复用的问题","user_name":"作者回复","comment_id":155450,"uid":"1190123","ip_address":"","utype":1,"ctime":1574851586,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164624768","product_id":100039001,"comment_content":"请问老师，好多类想要拥有相同的一个属性，考虑到代码复用性，是否只能继承啦","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475756,"discussion_content":"也可以用组合的，组合也能解决复用的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574851586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155410,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1004755,"ip_address":"","ucode":"9BB9A170023CD8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/d3/46fd4aa3.jpg","comment_is_top":false,"comment_ctime":1574686500,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10164621092","product_id":100039001,"comment_content":"go语言对组合的支持更加纯粹，比java优雅。<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>type Flyable interface {<br>\tfly() error<br>}<br><br>type FlyAbility struct {<br>}<br><br>func (b *FlyAbility) fly() error {<br>\tfmt.Println(&quot;I can fly.&quot;)<br>\treturn nil<br>}<br><br>&#47;&#47;省略 Tweetable&#47;TweetAbility&#47;EggLayable&#47;EggLayAbility<br><br>type Ostrich struct {<br>\tFlyAbility<br>\t&#47;&#47; TweetAbility<br>\t&#47;&#47; EggLayAbility<br>}<br><br>func main() {<br>\tvar flyable Flyable = &amp;Ostrich{}<br>\tflyable.fly()<br>}","like_count":2,"discussions":[{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165370,"discussion_content":"接口也可以组合一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581266391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165369,"discussion_content":"乐高模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581266322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155192,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1574659278,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10164593870","product_id":100039001,"comment_content":"entity就不用动了，VO和BO都可以使用组合entity。我自己曾经抽取过VO和BO的共同属性，这个方法特别不好，只要父类要修改，子类也要跟着修改，子类调用的方法也要修改。<br><br>如果用组合的方式，那改动就会相对少很多。代码也会清晰很多。<br><br>要是很多entity有共同的属性，倒是可以抽出来作一个抽象类。","like_count":2,"discussions":[{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79930,"discussion_content":"考虑用组合是因为 默认了 VO和BO的内容都多于entity。如果页面需要展示的内容或逻辑处理的内容没有entity那么多字段，多出的字段也影响性能吧。花儿少年的答案感觉更好些。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576124488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155060,"user_name":"傲慢与偏执，","can_delete":false,"product_type":"c1","uid":1236496,"ip_address":"","ucode":"E9F81223DFAD24","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/10/9f15527d.jpg","comment_is_top":false,"comment_ctime":1574642608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164577200","product_id":100039001,"comment_content":"我只有在该类需要更细化详情信息的时候会组合详情类的list 看了这节课后 受益匪浅","like_count":2},{"had_liked":false,"id":155056,"user_name":"欠债太多","can_delete":false,"product_type":"c1","uid":1099238,"ip_address":"","ucode":"B0CC91FA6F3981","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/e6/50c5b805.jpg","comment_is_top":false,"comment_ctime":1574642112,"is_pvip":true,"replies":[{"id":"60025","content":"好像不合适，怎么通过vo和bo组合成entity呢？","user_name":"作者回复","comment_id":155056,"uid":"1190123","ip_address":"","utype":1,"ctime":1574853130,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10164576704","product_id":100039001,"comment_content":"我们现在采用entity实现，VO和BO都去继承它，减少代码重复。看了专栏后，我认为可以通过讲VO和BO组合成Entity实现，不知道这样做，是不是合适","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475648,"discussion_content":"好像不合适，怎么通过vo和bo组合成entity呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574853130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318936,"user_name":"July 💫","can_delete":false,"product_type":"c1","uid":1761335,"ip_address":"","ucode":"0DC25F063E9E90","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e0/37/40b6711b.jpg","comment_is_top":false,"comment_ctime":1635486328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930453624","product_id":100039001,"comment_content":"笔记<br>&gt; **经典的设计原则之一：组合优于继承，多用组合少用继承。**<br><br>### 继承<br><br>1. 继承的缺点：<br><br>  - 继承层次过深<br><br>  - 过于复杂<br><br>  - 影响代码的可读性和可维护性<br><br>  - 父类和子类耦合度高<br><br>- 继承的优点：<br><br>  - 表示is-a关系<br><br>  - 支持多态特性<br><br>  - 代码复用<br><br>### 组合<br><br>  1. 组合的优点：<br><br>    - 包括组合，接口，委托三个技术点<br><br>    - 接口表示has-功能<br><br>    - 委托表示依赖驻入<br><br>    - 组合实现多个接口，既分离不同功能，还减少了耦合，提高代码复用<br><br>  1. 组合的缺点：<br><br>    - 更细粒度的类的拆分<br><br>    - 增加代码复杂程度<br><br>    - 提高维护成本<br><br>### 最少知识原则或者迪米特法则（Least Knowledge Principle）<br><br>  1. 暴露不该保留的接口给外部，增加了类使用过程中被误用的原则<br><br>  2. 封装，抽象类，接口，共同的特性是限制，限制才能避免误用。<br><br>### 总结<br><br>1. 为什么不推荐使用继承？<br><br>  继承是面向对象编程的四大特性之一，用来表示is-a的关系，可以解决代码复用的问题，虽然继承存在多种作用，但是继承层次过深，过于复杂，也会影响到代码的可读性和可维护性，所以针对这类场景，尽量少用继承，甚至不用。<br><br>1. 组合相比继承有哪些优势？<br><br>  继承的三大作用：表示is-a的关系，支持多态，解决代码复用，而这三个作用可以通过组合，接口，委托来实现，除此之外，组合还可以解决层次过深，过于复杂的继承关系影响代码可读性和可维护性的问题。<br><br>1. 如何判断什么时候该使用继承还是组合呢？<br><br>  在实际的项目开发中，要根据实际情况考虑选用哪一种，如果类的继承结构稳定，层次单一，关系不复杂，就可直接使用继承，反之则需要使用组合来替代继承。除此之外，一些特定的设计模式，特殊的应用场景会固定使用继承或者组合。","like_count":1},{"had_liked":false,"id":299769,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1624853172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5919820468","product_id":100039001,"comment_content":"能集中解答下课程中提出的问题吗？非常想知道最优做法。","like_count":1},{"had_liked":false,"id":191572,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584782736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879750032","product_id":100039001,"comment_content":"个人观点：我们变成是围绕着数据打桩的，BO、VO、Entity，核心是需要持久化的Entity，BO为了更好的进行业务处理在VO上进行扩展，VO则是为了展示在Entity上的扩展。当然VO、BO各自也有属于自己层面的属性，需要做到暴露“共有”属性，隐藏“特有”属性。BO、VO可以扩展(继承)Entity，又各自“特有”属性。可以借鉴组合的思路，BO、VO各自一些属于自己逻辑层的特有属性","like_count":1},{"had_liked":false,"id":175394,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1580704506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5875671802","product_id":100039001,"comment_content":"C++有多继承，也可以使用虚继承来避免菱形继承存在的问题，这样是否也可以解决文章中提到的各种鸟的问题啊。","like_count":1},{"had_liked":false,"id":166834,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1577609222,"is_pvip":false,"replies":[{"id":"64826","content":"可以的 等后面有时间了吧 年底比较忙","user_name":"作者回复","comment_id":166834,"uid":"1190123","ip_address":"","utype":1,"ctime":1577666123,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"5872576518","product_id":100039001,"comment_content":"老师能不能加餐集中解答一周的问题，有些老师提问的刚好我们在项目中也思考过，就是没找到很好的解决方案","like_count":1},{"had_liked":false,"id":166154,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1577409420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872376716","product_id":100039001,"comment_content":"<br>一、为什么不推荐使用继承？<br>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。<br><br>二、组合相比继承有哪些优势？<br>继承主要有三个作用：表示is-a关系，支持多态，代码复用。这三个作用可以使用其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。<br><br>三、如何判断该用组合还是继承？<br>1.继承改写成组合要做更细粒度的拆分，定义更多的类和接口，或多或少会增加代码的复杂程度和维护成本，实际的项目开发中，要根据具体的情况，来选择该用继承还是组合。<br>2.如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。<br>3.一些设计模式也会固定使用继承或组合。比如装饰者模式、策略模式、组合模式等使用了组合关系，模板模式使用了继承关系。<br><br>四、具体案例<br>1.如果A类和B类都用到了某个功能，但是用业务上来讲它们既不是父子关系，也不是兄弟关系。这时候为了代码复用，就不应该生硬的抽象出一个父类出来，会影响到代码的可读性，这时候使用组合更加合理。<br>2.如果不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。","like_count":1},{"had_liked":false,"id":155641,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1574731785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869699081","product_id":100039001,"comment_content":"Entity、BO、VO 这个重复代码问题也纠结过，BO，VO不需要 Entity 的所有属性，所以继承不大合适。用组合的话要套个其他实例单独写方法，麻烦。现在都是直接单独写，重复就重复了，而且一般也不会有复杂的逻辑，就重复属性和 getter&#47;setter。<br>特别想知道这个问题合适的做法。希望老师能在下节讲下上一节的问题，再布置下下节的问题，个人感觉这种方式比放到统一答疑章节要好很多。","like_count":1},{"had_liked":false,"id":155527,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1574695750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869663046","product_id":100039001,"comment_content":"1、我们现在的项目只有Entity与VO，而且两者之间互不相关，确实有太多的属性和方法重复了。<br>2、思考题：学习了今天内容，个人觉得可以使用委托和组合的方法，将Entity与VO共有属性抽象出来一个类，然后Entity与VO来组合此类。","like_count":1},{"had_liked":false,"id":155247,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1574671366,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5869638662","product_id":100039001,"comment_content":"&lt;?php<br>&#47;&#47;叫<br>interface jiaoable<br>{<br>    public function jiao();<br>}<br>&#47;&#47;飞<br>interface flyable<br>{<br>    public function fly();<br>}<br>&#47;&#47;下单<br>interface eggable<br>{<br>    public function egg();<br>}<br><br>&#47;&#47;叫的实现类<br>class jiaoablity implements jiaoable<br>{<br>    public function jiao()<br>    {<br>        echo &#39;jiao&#39;;<br>    }<br>}<br><br>&#47;&#47;鸵鸟类<br>class tuoniao implements jiaoable,eggable<br>{<br>    private $jiaoobj;<br><br>    public function __construct()<br>    {<br>        $this-&gt;jiaoobj = new jiaoablity();<br>    }<br><br>    public function jiao()<br>    {<br>        $this-&gt;jiaoobj-&gt;jiao();<br>    }<br><br>    public function egg()<br>    {<br>        echo &#39;我是鸵鸟我会下单&#39;;<br>    }<br>}<br><br>&#47;&#47;麻雀类<br>class maque implements jiaoable, flyable<br>{<br>    private $jiaoobj;<br><br>    public function __construct()<br>    {<br>        $this-&gt;jiaoobj = new jiaoablity();<br>    }<br><br>    public function jiao()<br>    {<br>        $this-&gt;jiaoobj-&gt;jiao();<br>    }<br><br>    public function fly()<br>    {<br>        echo &#39;我是麻雀我会飞&#39;;<br>    }<br>}<br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503372,"discussion_content":"主要看应用场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597453573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155064,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1574642780,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"5869610076","product_id":100039001,"comment_content":"因为Entity， BO， VO都是描述对象的，只不过是用于不同目的的对象，这些对象之间会有很多重复的元素定义，针对这样的重复定义，我倒是感觉可以使用继承，将重复的那些元素都提取出来作为父类，然后entity，VO，BO去继承这个父类，在实现自己独有的元素。而接口主要是针对不同能能的复用，用在E，B，V身上并不合适。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501164,"discussion_content":"你的意思是，定义很多不同的interface对吧。这样也可以，但用起来就没有现在的好用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594598958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290588,"discussion_content":"我指的是像rust的Iterator那样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594541227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155002,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574614426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869581722","product_id":100039001,"comment_content":"这种的我认为继承会好一点，将公用属性抽离到父类中，因为他的层次最多两层，而且用组合的话可能会带来某些不便，比如vo里面放个其他类，返回给客户端的时候属性分为两层，共有属性是在子json对象里的，感觉不妥。","like_count":1},{"had_liked":false,"id":155001,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1574614131,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869581427","product_id":100039001,"comment_content":"这篇文章，受益匪浅，激动的睡不着觉了。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496638,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359554,"user_name":"Will Zhang","can_delete":false,"product_type":"c1","uid":3197012,"ip_address":"上海","ucode":"294B06E7EFEB18","user_header":"https://static001.geekbang.org/account/avatar/00/30/c8/54/8d27cb56.jpg","comment_is_top":false,"comment_ctime":1665642782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665642782","product_id":100039001,"comment_content":"如果能像力扣一样能选择代码语言就好了，我对于那段组合委托就有点疑问，python没有接口的概念啊，如果用python语言改写应该怎么写呢？<br>直接在Ostrich类里面实例化TweetAbility和EggLayAbility这两个类然后调用对应的方法吗？<br>还是说和Java一样需要先用abc模块定义抽象接口，然后继承并通过组合委托实现抽象方法。","like_count":0},{"had_liked":false,"id":356478,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"广东","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662354929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662354929","product_id":100039001,"comment_content":"思考：<br>    Entity 类是直接与数据库操作的实体。 service类是聚合了与业务相关的信息，比如用户的订单信息会包含用户信息和订单信息。  VO 是具体请求返回的数据，可能 只包含了数BO的部分数据。<br><br>这章讲了为什么要多用组合少用继承。<br>    what<br>         继承的目的是为了代码的复用。如果继承的层次太深或者像例子的鸟类一样会导致代码不易维护，继承关系太复杂。比如阅读子类代码就要一直读到父类。父类代码修改影响子类，耦合。<br><br>  how <br>      可以用接口，组合，委托等来解决代码复用。<br>     比如鸟类会不会飞，会不会叫，替换成接口，来实现能力，如果有就实现该接口。如果功能一样，都要实现接口，也可以直接实现一个会飞的能力类。鸟类里使用组合即拥有该类的实列来解决这个问题。<br>不过这样也会造成要实现和维护的类很多。<br><br>设计模式中体现这个思想的有策略模式，装饰者模式。<br><br>如何判断时使用继承还是组合。<br>   1.继承关系确定，只有两层可以使用继承。<br>   2.设计模式、特殊的应用场景，会固定使用继承或者组合。<br>具体看业务场景吧。<br>","like_count":0},{"had_liked":false,"id":356165,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1662021043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662021043","product_id":100039001,"comment_content":"我们该如何处理 Entity、BO、VO 代码重复的问题呢？<br>我们现在的实现方式是提取出一个公共类，把能确定都会用到的字段放到这个公共类中，然后Entity,BO,VO都继承这个公共类，其他的个性化的就再自己当中定义。<br>学完本节之后，突然决定上面的方式其实效果很不好。因为肯定会有很多Entity和BO.VO三者之间互相交叉的情况，而且如果情况多了变成四个之间交叉的情况，会更加麻烦。如果只提取公共部分的那么可能都重合的字段会比较少。<br>这个地方我能想到方法来说细化共同点，多定义几个公共类，分别继承这样的。","like_count":0},{"had_liked":false,"id":351037,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657472747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657472747","product_id":100039001,"comment_content":"三者重复感觉是因为mvc架构模式开发把一次请求的处理分成了接口层处理，业务层处理，数据层处理三层，使得每一层可独立变化。消除重复问题能想到的解决方法：<br>1、三层合并为一层，会导致代码过于臃肿，可复用性极差<br>2、将重复代码封装函数，减少重复代码量（如果能通过语言提供的机制实现自动调用更好），但需要对不同的地方做特殊处理，需要衡量这样做利是否大于弊","like_count":0},{"had_liked":false,"id":347228,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1653831005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653831005","product_id":100039001,"comment_content":"课堂讨论: 没有必要为了复用代码而复用代码, 这个看起来结构挺清晰的, 大家都习惯了, 就让他重复就行.","like_count":0},{"had_liked":false,"id":345238,"user_name":"Geek_天涯tobe","can_delete":false,"product_type":"c1","uid":2354145,"ip_address":"","ucode":"8C95EE164CAB70","user_header":"https://static001.geekbang.org/account/avatar/00/23/eb/e1/71bb3704.jpg","comment_is_top":false,"comment_ctime":1652151764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652151764","product_id":100039001,"comment_content":"问下  怎么体现降低了父类和子类的高耦合的","like_count":0},{"had_liked":false,"id":345173,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652089899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652089899","product_id":100039001,"comment_content":"组合被用的少，是因为很多技术框架的组件必须要继承才能和框架一起工作。那么为何这些技术框架要用你使用继承呢，其实也是为了多态的便利性。","like_count":0},{"had_liked":false,"id":335388,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1645500354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645500354","product_id":100039001,"comment_content":"1.只要用到继承的类，将来需求是稳定的，不能随意更改的。<br>2.用组合的作用，是把相同的行为方法放到一个函数中，能提高复用性。<br>3.不用继承的原因，往往是因为复杂、难维护、嵌套过深等问题。<br>4.多用组合少用继承的原因是避免用那么多继承","like_count":0},{"had_liked":false,"id":329108,"user_name":"？","can_delete":false,"product_type":"c1","uid":2030035,"ip_address":"","ucode":"3043E00A056081","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f9/d3/2cb7516e.jpg","comment_is_top":false,"comment_ctime":1641125197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641125197","product_id":100039001,"comment_content":"但是单纯用组合处理有一个问题会不好处理，就是你暴露出去的vo其实大部分时候需要的字段都是没有entity多的，这种时候就会出现多余的对象的问题，其实很多时候都是一种取舍问题，只能根据你们的业务场景进行拆分才行。","like_count":0},{"had_liked":false,"id":317251,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1634721599,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1634721599","product_id":100039001,"comment_content":"组合跟继承都是必不可少的。组合强调的是面向接口编程，继承解决的是封装变化 &amp; 代码复用。可以说，整个设计模式讲的就是面向接口编程+用继承封装变化。关于Entity、BO、VO 三者的相似问题，我们的解决方案是独立发展，保证各层之间的隔离性，然后用mapstruct做转化避免无谓的转化代码。","like_count":0},{"had_liked":false,"id":316350,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1634281436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634281436","product_id":100039001,"comment_content":"什么时候用继承：<br>1.拥有is-a关系的时候。<br>2.继承关系稳定，层次浅，业务不复杂的时候<br>为什么尽量不用继承：<br>1.继承破坏父类的封装，将父类的成员暴露出来。<br>2.继承层次太深耦合性太强，可维护性降低。<br><br>替代继承：<br>用组合，接口，委托的方式替换继承关系。缺点是要写很多接口。<br><br>","like_count":0},{"had_liked":false,"id":316345,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1634279869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634279869","product_id":100039001,"comment_content":"上面那个把继承拆成接口，委托，组合的例子也可以这么写<br>public interface Flyable { <br>void fly()；<br>}<br><br>public class FlyAbility implements Flyable { <br>@Override <br>public void fly() {<br>\t&#47;&#47;... <br>\t}<br>}<br>&#47;&#47;省略Tweetable&#47;TweetAbility&#47;EggLayable&#47;EggLayAbility<br>public class Ostrich {&#47;&#47;鸵鸟 <br>\tprivate Tweetable twee &#47;&#47;组合 <br>\tprivate EggLayable eggLayable; &#47;&#47;组合 <br>\t<br>\tpublic Ostrich(Tweetable twee,EggLayable eggLayable){<br>\t\tthis.twee = twee;<br>\t\tthis.eggLayable = eggLayable;<br>\t\t<br>\t}<br>\t<br>\t&#47;&#47;... 省略其他属性和方法... <br>\tpublic void tweet() {<br>\t\ttwee.tweet(); &#47;&#47; 委托 <br>\t\t} <br>\tpublic void layEgg() {<br>\t\teggLayable.layEgg(); &#47;&#47; 委托 <br>\t\t}<br>\tpublic static void main(String[] args) {<br>\t\tTweetAbility tweetAbility = new TweetAbility(); &#47;&#47;组合 <br>\t\tEggLayAbility eggLayAbility = new EggLayAbility(); &#47;&#47;组合<br>\t\tOstrich o = new Ostrich(tweetAbility,eggLayAbility);<br>\t\t<br>\t\to.tweet();<br>\t\to.layEgg();<br>\t}<br>}","like_count":0},{"had_liked":false,"id":314584,"user_name":"振振","can_delete":false,"product_type":"c1","uid":1313365,"ip_address":"","ucode":"ECE08186230140","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/55/5e440425.jpg","comment_is_top":false,"comment_ctime":1633242839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633242839","product_id":100039001,"comment_content":"不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？<br><br>感觉这个例子讲的不太恰当，为啥“并且实现逻辑是一样的”？","like_count":0},{"had_liked":false,"id":312456,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1631806962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631806962","product_id":100039001,"comment_content":"继承与组合<br>\t关系浅时可用继承，复杂时组合代替，像装饰者模式、策略模式、组合、模板等设计模式<br>\t当没办法修改一个外部类代码时，可以通过继承形式进行重写函数代码<br>\t为什么不推荐用继承<br>\t\t继承层次过深，继承关系过于复杂影响可读性和可维护性<br>\t\t比如说粽子有甜的、咸的、辣的，AbstractSweet··· 同时还有方的三角形的，AbstractSweetTriangle··· 太过复杂<br>\t\t如果用接口实现<br>\t\t\t道滘粽子 implements Sweetable,Triangle <br>\t\t\t福建粽子 implements Slaty, Triangle<br>\t\t\t但每个粽子都要实现重复的三角形代码，造成代码重复<br>\t\t如果用组合实现<br>\t\t\t给接口定义实现类, TriangleAblity{ triangle(){ &#47;&#47;make triangle}<br>\t\t\t原本的实现地方通过委托，把实现代码交给Ablity<br>","like_count":0},{"had_liked":false,"id":301849,"user_name":"今夕是何年","can_delete":false,"product_type":"c1","uid":1111847,"ip_address":"","ucode":"2825454A7A1588","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7SOblVZ7dNJ88wkeYR0HklxdR9VuiaQ0GMscAnrlic6EjvRZS52m4n1VPypwZFsmabbJ4STZRbHFfVZE24Jjqr1w/132","comment_is_top":false,"comment_ctime":1625913611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625913611","product_id":100039001,"comment_content":"用继承，把公共的抽到父类里。<br>继承层次稳定，所以用继承比较合适。","like_count":0},{"had_liked":false,"id":301814,"user_name":"直走的螃蟹","can_delete":false,"product_type":"c1","uid":2683294,"ip_address":"","ucode":"8116812CF0A1F2","user_header":"","comment_is_top":false,"comment_ctime":1625895317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625895317","product_id":100039001,"comment_content":"我的理解是组合与委托都是为了使用其他类的方法。而不同在于其他类提供的方法是否一定要使用。组合是可用可不用;而委托是因为该类接口的关系必须使用。","like_count":0},{"had_liked":false,"id":294547,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1621995492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621995492","product_id":100039001,"comment_content":"三层的数据分析入下：<br>1.Entity 是直接面向数据库的，基本是一个Entity对应一个数据表<br>2.Bo 是通过业务逻辑对数据的组合，是一个Entity的全集或子集，也可能是多个Entity的全集或子集<br>3.Vo 是面向对外接口的数据<br>从这来看，三种数据有联系但大多数场景并无共性，分别面向不同使用场景。<br>结论：分别定义更方便每层的修改，没必要做统一。","like_count":0},{"had_liked":false,"id":294300,"user_name":"502819","can_delete":false,"product_type":"c1","uid":1787786,"ip_address":"","ucode":"9316B0001A18BD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/47/8a/a6ee3924.jpg","comment_is_top":false,"comment_ctime":1621867870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621867870","product_id":100039001,"comment_content":"个人感觉BO主要用于api暴露给调用方使用的，VO根据前端需要返回指定字段，两者都为了隐藏业务不需要的字段。。","like_count":0},{"had_liked":false,"id":294083,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1621753121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621753121","product_id":100039001,"comment_content":"把Entity、BO、VO这三者重复的代码单独抽取出来，组成一个新类，然后在这三个类的定义中，把新类组合进去，就能避免写重复的代码。","like_count":0},{"had_liked":false,"id":292319,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1620782193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620782193","product_id":100039001,"comment_content":"求这篇思考的回答。","like_count":0},{"had_liked":false,"id":290936,"user_name":"分神","can_delete":false,"product_type":"c1","uid":1093342,"ip_address":"","ucode":"173904DAE72B6F","user_header":"","comment_is_top":false,"comment_ctime":1619866167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619866167","product_id":100039001,"comment_content":"PHP的trait+interface用来替代继承会造成的问题时就很方便，很舒服","like_count":0},{"had_liked":false,"id":287033,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1617753981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617753981","product_id":100039001,"comment_content":"使用接口 组合 委托代替继承，解决类爆炸以及继承层次过深问题","like_count":0},{"had_liked":false,"id":282116,"user_name":"满目星河","can_delete":false,"product_type":"c1","uid":2455972,"ip_address":"","ucode":"6FE6EB6A58F080","user_header":"https://static001.geekbang.org/account/avatar/00/25/79/a4/353d4739.jpg","comment_is_top":false,"comment_ctime":1615095559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615095559","product_id":100039001,"comment_content":"思考题<br>虽然并不存在 is-a关系，但我觉得也可以使用继承。可以定义一个Base类，里面是共有的属性和方法。然后Entity、BO、VO继承这个Base。只有一层继承关系。","like_count":0},{"had_liked":false,"id":280004,"user_name":"没有心的人","can_delete":false,"product_type":"c1","uid":2449748,"ip_address":"","ucode":"F27D5894087B11","user_header":"https://static001.geekbang.org/account/avatar/00/25/61/54/5bf767e7.jpg","comment_is_top":false,"comment_ctime":1614051458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614051458","product_id":100039001,"comment_content":"第一次了解到委托这个概念，组合和委托这对组合拳感觉大有用处","like_count":0},{"had_liked":false,"id":275393,"user_name":"阿腾","can_delete":false,"product_type":"c1","uid":2263622,"ip_address":"","ucode":"FF1BEC88D98084","user_header":"https://static001.geekbang.org/account/avatar/00/22/8a/46/4f76078b.jpg","comment_is_top":false,"comment_ctime":1611500218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611500218","product_id":100039001,"comment_content":"如果系统设计得合理，类继承与对象组合可以相互配合。设计类时，通常倾向于考虑对象组合。然后寻找出冗余行为，进行设计细化。如果找到冗余行为，也许意味着此处应该使用类继承。—— 摘自《Objective-C 编程之道 —— iOS 设计模式解析》","like_count":0},{"had_liked":false,"id":274288,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610955824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610955824","product_id":100039001,"comment_content":"组合+接口+委托的模式，比较适合在业务框架比较清晰的情况下使用，所有业务都要拆分成“名称+动词”，就比较适合用这种模式。如果业务层次比较复杂，并且嵌套，这种模式就不再适用，比如，汽车在行驶过程中播着音乐，但遇到转弯打灯时，一边要停止音乐，一边要发出闪转弯灯时“啪啪”的提示音，等打灯完毕，要立即恢复音乐播放，这就是除了顺利成章的单一的“汽车有播放音乐”、“汽车有打转弯灯”这两个单体功能，还有条件触发的变化情况。这样的复杂情况，光接口、组合和委托还不够，还有流程设计在其中。","like_count":0},{"had_liked":false,"id":272191,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1609986038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609986038","product_id":100039001,"comment_content":"如果字段名都相同，且类型也相同，可以用反射做成通用的deep copy，其他的话可以手动deep copy","like_count":0},{"had_liked":false,"id":267722,"user_name":"刘建军","can_delete":false,"product_type":"c1","uid":2348590,"ip_address":"","ucode":"25210BF7BE6BA8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/We0naYhWttpJPDoO7TCndu5w1r4PSCdo57M61Zia8khXmM8GibicDzYdXiaJXZNok7274mSfB4aEMgxyiaDY1pRba0w/132","comment_is_top":false,"comment_ctime":1607905861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607905861","product_id":100039001,"comment_content":"我在做一个脚本语言的界面库，完全采用的继承，也是为了省代码，确实发现一下子类继承父类的方法有点莫名其妙","like_count":0},{"had_liked":false,"id":253641,"user_name":"小项91","can_delete":false,"product_type":"c1","uid":1251436,"ip_address":"","ucode":"EA3581C573B19C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/6c/afd17dd7.jpg","comment_is_top":false,"comment_ctime":1602818077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602818077","product_id":100039001,"comment_content":"组合相比于继承来说，将父概念的每一个属性细化成了一个组合（接口+实现）。如果这种属性非常多，而且基本上每个子类都需要这些属性，那么使用组合就没有必要了，直接使用抽象类继承更合适。<br><br>假如Father概念有a&#47;b&#47;c&#47;d&#47;e&#47;f五个属性，Son-1有a&#47;b&#47;c&#47;d&#47;e属性，Son-2有a&#47;b&#47;c&#47;e&#47;f属性，Son-3有a&#47;b&#47;c&#47;d&#47;f属性，且a&#47;b&#47;c&#47;d&#47;e&#47;f的实现是完全一样的。那么这么做是否合适？<br>先写一个抽象类AbstractFather，实现a&#47;b&#47;c方法。再分别写d&#47;e&#47;f的组合，让Son-1&#47;2&#47;3继承AbstractFather，分别实现d&#47;e&#47;f 接口。<br>（但是这样感觉又将d&#47;e&#47;f属性隔离在父概念之外了，有更好的办法吗？）","like_count":0},{"had_liked":false,"id":248573,"user_name":"Leon","can_delete":false,"product_type":"c1","uid":1051118,"ip_address":"","ucode":"782F7ECE08C0E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/ee/288d878c.jpg","comment_is_top":false,"comment_ctime":1600226409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600226409","product_id":100039001,"comment_content":"目前使用的是继承entity的方式，在多服务下，其实VO和Entity相差不多。个别敏感字在VO做处理，定制化的字段则在VO上加。","like_count":0},{"had_liked":false,"id":248203,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1600064266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600064266","product_id":100039001,"comment_content":"【要点】<br>1、不推荐使用继承的情况：如果继承层次过深、过复杂，会影响到代码的可维护性。这种情况下，我们应该少用甚至不用继承。<br>2、组合相比继承的优势：继承主要有三个作用，表示is-a关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。利用组合还可解决层次过深，过复杂的继承关系所带来的代码可维护性的问题。<br>3、用继承或组合的情况：如果类之间的继承结构稳定，层次比较浅，关系不复杂，就可以大胆地使用继承。反之，就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。<br>【思考】<br>Entity、VO、BO的重复不应该处理，VO、BO都是特定业务相关数据结构，他们内部其实并不涉及复杂的数据处理逻辑，很多时候就是数据的setter和getter，随着业务的变化而变化，VO和BO可能变化的比较多，Entity是数据表对应的，有最全的数据，相对稳定。应该让三者自己演化。","like_count":0},{"had_liked":false,"id":247276,"user_name":"Senior6623","can_delete":false,"product_type":"c1","uid":1517590,"ip_address":"","ucode":"D8ADAE5D037FC4","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/16/ca72addc.jpg","comment_is_top":false,"comment_ctime":1599645063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599645063","product_id":100039001,"comment_content":"如拨云见日,茅塞顿开","like_count":0},{"had_liked":false,"id":245772,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599045878,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599045878","product_id":100039001,"comment_content":"Entity、BO、VO之间数据重复的问题，不是很熟悉，mark下","like_count":0},{"had_liked":false,"id":243155,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1597978253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597978253","product_id":100039001,"comment_content":"继承是我用得最多也是最少的特性。因为客户端的模版模式必须要用到继承来创建视图控制器，所以用得多；几乎不主动设计用于继承的父类，所以用得少。<br>继承解决了代码复用的问题，但它近乎完美的违背了“高内聚，低耦合”的原则，所以在实际开发过程中，会优先使用“接口、组合、委托”等方式来代替继承。除非继承关系简单、继承逻辑明确、继承能明显减少代码量，否则都不会考虑继承。","like_count":0},{"had_liked":false,"id":240841,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1597100885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597100885","product_id":100039001,"comment_content":"Entity、BO、VO 三者之间的代码有很大重复，这种是不是可以使用组合方式来解决。","like_count":0},{"had_liked":false,"id":238917,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1596369355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596369355","product_id":100039001,"comment_content":"abstract BaseEntity，让子类继承，复用常用属性，id，deleted，createTime，updateTime。我之前的项目中，前人就是这么写的。","like_count":0},{"had_liked":false,"id":234814,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1594803145,"is_pvip":false,"replies":[{"id":"86783","content":"有些语言不支持多重继承，而且从语义上也不对，什么是Fly类啊，飞是行为，更适合用接口来表达，不适合作为类吧","user_name":"作者回复","comment_id":234814,"uid":"1190123","ip_address":"","utype":1,"ctime":1594903494,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1594803145","product_id":100039001,"comment_content":"请教一下，如果是按照功能分成多个基类，然后再按需继承。<br>比如将大的基类分成，Fly类，Tweet类，Egg类三个类。<br>鸵鸟就只继承Tweet类，Egg类<br>这样也可以实现接口，组合，委托的效果啊，请问一下这样有什么坏处呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501516,"discussion_content":"有些语言不支持多重继承，而且从语义上也不对，什么是Fly类啊，飞是行为，更适合用接口来表达，不适合作为类吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594903494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229659,"user_name":"ujshenry","can_delete":false,"product_type":"c1","uid":1117410,"ip_address":"","ucode":"52840F95862014","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/e2/8a5e14b1.jpg","comment_is_top":false,"comment_ctime":1593090247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593090247","product_id":100039001,"comment_content":"讲解跟贴近实际，vo bo entity实际中也用到 基本就定义一个大而全的bean","like_count":0},{"had_liked":false,"id":227909,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1592525998,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592525998","product_id":100039001,"comment_content":"多用组合可以让我们，把精力和注意力集中在我们需要钱实现的对象身上，继承则需要我们在关注当前对象的同时，还有关注其继承的父类特性","like_count":0},{"had_liked":false,"id":224288,"user_name":"郭强","can_delete":false,"product_type":"c1","uid":1192928,"ip_address":"","ucode":"38F36F0F4CC775","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/e0/387ab6fd.jpg","comment_is_top":false,"comment_ctime":1591336981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591336981","product_id":100039001,"comment_content":"接口中的方法不是可以写默认方法吗，就不需要再额外写委托类了，方便很多。","like_count":0},{"had_liked":false,"id":222661,"user_name":"王瑞强","can_delete":false,"product_type":"c1","uid":1829090,"ip_address":"","ucode":"DEE4EB5E23433F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e8/e2/2bcaef68.jpg","comment_is_top":false,"comment_ctime":1590883122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590883122","product_id":100039001,"comment_content":"理解组合和委托的区别，组合是把一个类对象当做另一个类的成员变量；委托是使用组合的对象执行某个方法或者行为","like_count":0},{"had_liked":false,"id":221269,"user_name":"永远不要低估一颗冠军的心","can_delete":false,"product_type":"c1","uid":1339230,"ip_address":"","ucode":"FF0DD7382CD3CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/6f/5e/3f7e9ccd.jpg","comment_is_top":false,"comment_ctime":1590459580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590459580","product_id":100039001,"comment_content":"把实体之间相同的部分抽出来作为父类","like_count":0},{"had_liked":false,"id":220175,"user_name":"Zeng Shine","can_delete":false,"product_type":"c1","uid":1245334,"ip_address":"","ucode":"15D2618C92D662","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/96/6df95326.jpg","comment_is_top":false,"comment_ctime":1590196731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590196731","product_id":100039001,"comment_content":"组合是拼接共性，继承是包含共性。包含关系的耦合度更高。","like_count":0},{"had_liked":false,"id":217002,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589383610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589383610","product_id":100039001,"comment_content":"&#47;&#47;翱翔<br>class Soar implements FlyAble {<br>  @Override<br>  public void fly() { <br>  \t&#47;&#47;自由翱翔...<br>  }<br>}<br>&#47;&#47;狗刨<br>class DoggyPaddle implements SwimAble {<br>  @Override<br>  public void swim() { <br>  \t&#47;&#47;狗刨...<br>  }<br>}<br>&#47;&#47;天鹅<br>class Swan implements FlyAble, SwimAble {<br>  Soar soar = new Soar(); &#47;&#47;组合<br>  DoggyPaddle doggyPaddle = new DoggyPaddle();&#47;&#47;组合<br>  @Override<br>  public void fly() { <br>  \tsoar.fly();&#47;&#47; 委托<br>  }<br>  @Override<br>  public void swim() { <br>  \tdoggyPaddle.swim();&#47;&#47;委托<br>  }<br>}<br>&#47;&#47;老鹰<br>class Hawk implements FlyAble {<br>  Soar soar = new Soar(); &#47;&#47;组合<br>  @Override<br>  public void fly() { <br>  \tsoar.fly();&#47;&#47; 委托<br>  }<br>}<br>&#47;&#47;企鹅<br>class Penguin implements SwimAble {<br>  DoggyPaddle doggyPaddle = new DoggyPaddle();&#47;&#47;组合<br>  @Override<br>  public void swim() { <br>  \tdoggyPaddle.swim();&#47;&#47;委托<br>  }<br>}","like_count":0},{"had_liked":false,"id":216900,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589364674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589364674","product_id":100039001,"comment_content":"Entity、BO、VO   之间是通过继承来解决代码复用的，因为这种场景类稳定，继承层次浅。这是最初的想法不知道，看看以后有什么好的处理方式","like_count":0},{"had_liked":false,"id":211943,"user_name":"「@」","can_delete":false,"product_type":"c1","uid":1350503,"ip_address":"","ucode":"297B345E90C469","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/67/97c6bbf9.jpg","comment_is_top":false,"comment_ctime":1588039553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588039553","product_id":100039001,"comment_content":"VO大部分都是需要暴露给外部的，不能用来继承，我觉得BO继承entity，然后VO组合BO的方式比较稳妥","like_count":0},{"had_liked":false,"id":205697,"user_name":"gtp","can_delete":false,"product_type":"c1","uid":1372089,"ip_address":"","ucode":"12E21307343B3A","user_header":"https://static001.geekbang.org/account/avatar/00/14/ef/b9/c0c12bea.jpg","comment_is_top":false,"comment_ctime":1586704010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586704010","product_id":100039001,"comment_content":"终于明白为啥少多用组合少用继承了！！！","like_count":0},{"had_liked":false,"id":202460,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1585991936,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585991936","product_id":100039001,"comment_content":"组合+委托的方式会不会增加代码之间的耦合度，从而降低代码的可维护性？","like_count":0},{"had_liked":false,"id":200282,"user_name":"70","can_delete":false,"product_type":"c1","uid":1081899,"ip_address":"","ucode":"A5884B2BDDAB70","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/2b/cf93c499.jpg","comment_is_top":false,"comment_ctime":1585568404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585568404","product_id":100039001,"comment_content":"对于组合，php新增了关键字trait来处理，使用起来很方便。","like_count":0},{"had_liked":false,"id":197519,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585383377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585383377","product_id":100039001,"comment_content":"继承好像用的最多的也是entity&#47;BO之间的实体类继承。","like_count":0},{"had_liked":false,"id":194869,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585112724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585112724","product_id":100039001,"comment_content":"继承可以解决代码复用的问题，但是不推荐，主要原因是多度继承会导致代码难以维护。通过组合也可以实现继承的特性。<br><br>具体情况具体分析，如果非常确定继承的层次不多，可以使用继承。如果继承层次过多，还是使用组合为好。","like_count":0},{"had_liked":false,"id":194374,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585055490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585055490","product_id":100039001,"comment_content":"MVC其实已经在层与层之间很清晰了，只要在每一层的接口设计好就可以了。尽量减少重复代码","like_count":0},{"had_liked":false,"id":194221,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585038885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585038885","product_id":100039001,"comment_content":"针对老师留下的题目，我认为可以使用继承，把共有部分抽取出来","like_count":0},{"had_liked":false,"id":191857,"user_name":"Initiative Thinker","can_delete":false,"product_type":"c1","uid":1736297,"ip_address":"","ucode":"A884396A1581EF","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","comment_is_top":false,"comment_ctime":1584800397,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584800397","product_id":100039001,"comment_content":"可以用抽象类代替接口吗","like_count":0},{"had_liked":false,"id":190293,"user_name":"索旭东","can_delete":false,"product_type":"c1","uid":1139039,"ip_address":"","ucode":"BFD07BCD8C8CAE","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/5f/b279daaf.jpg","comment_is_top":false,"comment_ctime":1584627520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584627520","product_id":100039001,"comment_content":"代码里的委托好像不是委托，只是个函数调用吧","like_count":0},{"had_liked":false,"id":189466,"user_name":"治慧","can_delete":false,"product_type":"c1","uid":1245904,"ip_address":"","ucode":"47C331EF63EDC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","comment_is_top":false,"comment_ctime":1584519593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584519593","product_id":100039001,"comment_content":"课后习题:entry bo vo 本质上没有任何继承关系可说的;从业务角度上虽然存在重复的字段,但是是不同的业务 也不适合 组合+委托的方式","like_count":0},{"had_liked":false,"id":188719,"user_name":"🌀Pick Monster 🌀","can_delete":false,"product_type":"c1","uid":1141196,"ip_address":"","ucode":"EE67F41B360460","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/cc/747c7629.jpg","comment_is_top":false,"comment_ctime":1584408084,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584408084","product_id":100039001,"comment_content":"继承的优点是可以提高代码的复用，但过渡复杂的继承会影响代码可读性和维护性。<br>组合的优点是提高代码的复用，降低业务结构的复杂度，但会增加分支结构导致需要更细粒度的设计。<br>继承类似于多线程的synchronized关键字，不能细粒度控制可能导致性能问题。组合类似于Lock锁，可以进行更细粒度的控制，但使用复杂度可能会提高。<br>所以我们应该根据具体的业务选择合适的方案。","like_count":0},{"had_liked":false,"id":187148,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1584026294,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584026294","product_id":100039001,"comment_content":"如果层级不多，有时候继承在语义上比较好吧。<br><br>组合和委托确实灵活很多。多个重复的逻辑，委托到另外一个独立的功能类里面去，然后在组合回来，很灵活。","like_count":0},{"had_liked":false,"id":186951,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1583978423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583978423","product_id":100039001,"comment_content":"继承的一个误区，为了代码复用，故意抽象公共一个父类出来。虽然解决了代码复用问题，但是影响了代码的可读性，可维护性。这样是得不偿失。应该用其他手段来实现代码复用","like_count":0},{"had_liked":false,"id":186671,"user_name":"赵云","can_delete":false,"product_type":"c1","uid":1376233,"ip_address":"","ucode":"FBECC7A2F4F70F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ff/e9/daebe1ea.jpg","comment_is_top":false,"comment_ctime":1583899672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583899672","product_id":100039001,"comment_content":"想问下老师有什么比较好的建议去实现这些重复的问题","like_count":0},{"had_liked":false,"id":184436,"user_name":"壹","can_delete":false,"product_type":"c1","uid":1023272,"ip_address":"","ucode":"335D34216066E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/28/bcaf070d.jpg","comment_is_top":false,"comment_ctime":1583314460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583314460","product_id":100039001,"comment_content":"看到鸟的这个例子我就想到swift的协议，解决这个问题比Java优雅太多了","like_count":0},{"had_liked":false,"id":180997,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582456271,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582456271","product_id":100039001,"comment_content":"今天主要讲组合和继承的使用，总结一下就是结构稳定继承层次浅（不超过两层）可以使用继承，否则使用组合+接口+委托单位方式。我的倾向是有共同结构或者业务上是同一类的优先使用继承，否则使用组合的方式。仍然回归定义，接口是行为的抽象，与行为相关的代码逻辑优先使用组合，在定义接口的时候要考虑得行为的通用性，也就是符合单一职责。下面说下思考题，entity、vo、bo本身就是不同层面的业务对象，entity是数据层对象，vo是展示层对象，bo是业务层对象，如果三者之间有通用的属性就各自定义好了，如果多种业务都有一些公共的属性则可以单独定义这么个bo、vo，然后使用组合的方式拿过来就好了。而且从业务看这不是重复代码，感觉问题可以更具体点","like_count":0},{"had_liked":false,"id":180665,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582360602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582360602","product_id":100039001,"comment_content":"还是不忘评价代码好坏的几条标准，可用，可维护，可扩展。。。。我们的目标是高质量的代码","like_count":0},{"had_liked":false,"id":180487,"user_name":"Ant","can_delete":false,"product_type":"c1","uid":1079563,"ip_address":"","ucode":"07E6374F91F61E","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0b/4346a253.jpg","comment_is_top":false,"comment_ctime":1582294331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582294331","product_id":100039001,"comment_content":"回顾了一下很受益，谢谢老师","like_count":0},{"had_liked":false,"id":179933,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582123324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582123324","product_id":100039001,"comment_content":"<br>对于这个问题，在实际开发中，我们经常使用Beans这个工具类其中的copproperties()方法去解决代码重复赋值问题，但是经过了这几天的学习，发现经常使用的mvc是一个面向过程的贫血模型，所以我给出的解决答案是使用接口 组合以及委托这种方式去替换它，这是我学完这节课的一个设想，但这三者之间并没有什么直接的关系，我认为这三者没必要去解决他们的代码重复问题，他们三个本身来说就应该是相对独立的，不然有这么多代码重复，我们为什么不将其放到一个对象里面了？在整个MVC三层之间都共用一个对象.","like_count":0},{"had_liked":false,"id":178248,"user_name":"wysobj","can_delete":false,"product_type":"c1","uid":1499936,"ip_address":"","ucode":"E4D0DEF1F330C5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/OwMy02RcVqOkKqmdQ8AAbblhrz5QM2B4PoPS4k6TLMDB4yzb25bocxKuF9vM1vicNcS0cLDzOlFfG61P7Pqdozw/132","comment_is_top":false,"comment_ctime":1581642044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581642044","product_id":100039001,"comment_content":"老师，我理解继承的核心目标是提供一种更符合人类思维模式的代码组织手段，除了代码复用也可以提高代码的可读性。只不过这个技术很难运用得恰当，容易造成过度设计或者结构腐化，所以需要慎重使用。您举的鸟的例子就能体现，其实鸟类概念的定义本身就没有飞翔的属性，所以不能提供fly方法。这种场景就像在代码开发中很多人最开始对一个类的边界理解有些许偏差导致设计问题，后续调整继承关系的成本很高。所以说与其说继承一无是处，不如说使用继承特性十分危险。","like_count":0},{"had_liked":false,"id":175066,"user_name":"Geek_7ead05","can_delete":false,"product_type":"c1","uid":1363830,"ip_address":"","ucode":"1FA18A1245200E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKHKe06oa6hIkIpIGib63GAU1M2q7HODOLwYZ1rJDOzDzmMlckQKgXzLaQJiaKSibJ0K2pCav8gLmLkg/132","comment_is_top":false,"comment_ctime":1580544736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580544736","product_id":100039001,"comment_content":"优先考虑用组合，接口和委托实现继承的功能。","like_count":0},{"had_liked":false,"id":170921,"user_name":"Citizen Z","can_delete":false,"product_type":"c1","uid":1125104,"ip_address":"","ucode":"9CA547640A8629","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","comment_is_top":false,"comment_ctime":1578759948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578759948","product_id":100039001,"comment_content":"个人认为，那些 xO 还是各自独立的好，因为属于不同层面的对象，从建模角度讲，他们之间不是相同领域的对象，只是恰好大部分字段相同，如果数据转换时有太多 target.setXxx(source.getXxx())，仅仅为了方便和减少代码量，可以考虑采用小工具的方式，如 copyProperties、字段 mapping 等手段来实现","like_count":0},{"had_liked":false,"id":170364,"user_name":"蓝领笑笑生","can_delete":false,"product_type":"c1","uid":1109147,"ip_address":"","ucode":"B9A42CD91CD5E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/9b/1c25e95f.jpg","comment_is_top":false,"comment_ctime":1578580272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578580272","product_id":100039001,"comment_content":"关于思考的问题，DO，VO，BO，DTO等，属于不同领域，各自的职责不一样，所以无所谓相同的属性。比如DTO做为参数的入参对象，会在属性上加一些校验注解或者在加一些swagger API接扣文档注解，而其他的O并不需要，尊从单一职责原则","like_count":0},{"had_liked":false,"id":169089,"user_name":"天空只能仰望？","can_delete":false,"product_type":"c1","uid":1102357,"ip_address":"","ucode":"D87BF6A57DAB42","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/15/4d43d05a.jpg","comment_is_top":false,"comment_ctime":1578272214,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578272214","product_id":100039001,"comment_content":"继承便于代码复用，层次过深增加代码复杂程度和可读性，组合使用灵活便利，会增加类的复杂程度同时会增加部分代码冗余，屏蔽特性弊端正确使用才是王道！","like_count":0},{"had_liked":false,"id":168893,"user_name":"厉害了我的国","can_delete":false,"product_type":"c1","uid":1052191,"ip_address":"","ucode":"CD0A54A1B998AA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","comment_is_top":false,"comment_ctime":1578211526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578211526","product_id":100039001,"comment_content":"确实是这样，每个层都定义了相似的对象，很丑陋！","like_count":0},{"had_liked":false,"id":166882,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1577622975,"is_pvip":false,"replies":[{"id":"64821","content":"哪种更方便用那哪种 并不是说绝对杜绝继承。继承层次不深 结构不复杂的话 用继承没问题的","user_name":"作者回复","comment_id":166882,"uid":"1190123","ip_address":"","utype":1,"ctime":1577665966,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1577622975","product_id":100039001,"comment_content":"接上一条，我的问题：<br>老师好，我是一名前端，就用React代码来阐述我的理解。<br>我理解的组合可能比较狭隘，具体如下：<br><br>页面上有元素ABC和D<br><br>status = 1的时候展示A B C<br><br>funciton Container1() {<br>  return &lt;&gt;<br>    &lt;A &#47;&gt;<br>    &lt;B &#47;&gt;<br>    &lt;C &#47;&gt;<br>  &lt;&#47;&gt;<br>}<br><br>status = 2的时候展示A B D<br><br>funciton Container2() {<br>  return &lt;&gt;<br>    &lt;A &#47;&gt;<br>    &lt;B &#47;&gt;<br>    &lt;D &#47;&gt;<br>  &lt;&#47;&gt;<br>}<br><br>status = 3的时候展示A B C D<br><br>funciton Container3() {<br>  return &lt;&gt;<br>    &lt;A &#47;&gt;<br>    &lt;B &#47;&gt;<br>    &lt;C &#47;&gt;<br>    &lt;D &#47;&gt;<br>  &lt;&#47;&gt;<br>}<br><br>function Home(status) {<br>  switch(status) {<br>    case 1:<br>      return &lt;Container1 &#47;&gt;<br>    case 2:<br>      return &lt;Container2 &#47;&gt;<br>    case 3:<br>      return &lt;Container3 &#47;&gt;<br>  }<br>  return &lt;Container1 &#47;&gt;<br>}<br><br>这里可以理解为ABCD的组合形成了Container，但是在不同status状态之间&lt;A &#47;&gt;&lt;B &#47;&gt;被重复了多次。<br>如果单独将AB这种组合抽取出来总觉得不对，因为抽取的理由仅仅是这几个状态的时候，他们是一起出现的。<br><br>我想如果使用模板方法，不同状态，重写基类的方法可能会减少这种重复，例如：<br><br>class Container {<br>  A() {<br>    return &lt;A &#47;&gt;<br>  }<br><br>  B() {<br>    return &lt;B &#47;&gt;<br>  }<br><br>  C() {<br>    return &lt;C &#47;&gt;<br>  }<br><br>  D() {<br>    return &lt;D &#47;&gt;<br>  }<br><br>  render() {<br>    return &lt;&gt;<br>      &lt;this.A &#47;&gt;<br>      &lt;this.B &#47;&gt;<br>      &lt;this.C &#47;&gt;<br>      &lt;this.D &#47;&gt;<br>    &lt;&#47;&gt;<br>  }<br>}<br><br>class Container1 extends Container {<br>  D() {<br>    return null<br>  }<br>}<br><br>class Container2 extends Container {<br>  C() {<br>    return null<br>  }<br>}<br><br><br>class Container3 extends Container {<br>}<br><br>以上。<br><br>开发中用的是组合的方式，发现有重复，所以才有此问。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479665,"discussion_content":"哪种更方便用那哪种 并不是说绝对杜绝继承。继承层次不深 结构不复杂的话 用继承没问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577665966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166861,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577617441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577617441","product_id":100039001,"comment_content":"1、继承是面向对象的四大特性之一。继承主要解决代码的复用问题。<br>2、继承层级太深，继承关系复杂，会影响代码的可维护性。这时候用组合、接口、委托的方式，替代继承的is-a、多态、复用。<br>3、继承并非一无是处，组合也不完美。如果继承关系稳定，层级浅选用继承关系；如果继承关系不稳定，关系复杂，用组合来替代。<br>4、继承相关设计模式：模板模式；组合相关设计模式：策略模式、组合模式、装饰者模式","like_count":0},{"had_liked":false,"id":166774,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1577591735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577591735","product_id":100039001,"comment_content":"针对下蛋会飞，完全相同的处理方式才可以用委托的方案解决，如果不同，还是需要每个不同种类自己去实现自己的处理方式，例如:麻雀下小蛋，鸵鸟下大蛋","like_count":0},{"had_liked":false,"id":166231,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1577419969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577419969","product_id":100039001,"comment_content":"按属性多少排序：bo&gt;entity&gt;vo，bo继承entity可以实现代码的复用。vo的属性较少，所以单独写属性会合理一些。","like_count":0},{"had_liked":false,"id":165430,"user_name":"Tracyliu","can_delete":false,"product_type":"c1","uid":1034513,"ip_address":"","ucode":"29F242C232B85B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c9/11/bb1a4368.jpg","comment_is_top":false,"comment_ctime":1577237075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577237075","product_id":100039001,"comment_content":"委托不就是代理模式么？","like_count":0},{"had_liked":false,"id":164800,"user_name":"OperaX","can_delete":false,"product_type":"c1","uid":1510551,"ip_address":"","ucode":"66947CD04E3B3E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8mFt5wSkia3yumk409E65JIlGoreva1Q25icTks0XB0EDC7WJ5V0z6zuvgGkI2Zrh5cBXGS5Hea8A/132","comment_is_top":false,"comment_ctime":1577092996,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577092996","product_id":100039001,"comment_content":"看完七个理论 感觉自己平时完完全全是在面向过程编程。","like_count":0},{"had_liked":false,"id":164547,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1577025583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577025583","product_id":100039001,"comment_content":"1.使用工具类解决重复性代码<br>2.抽象出一个接口和接口实现类，通过组合和代理方式优化","like_count":0},{"had_liked":false,"id":164450,"user_name":"峰回路转","can_delete":false,"product_type":"c1","uid":1773160,"ip_address":"","ucode":"A2874C7392C452","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0e/68/a41730c8.jpg","comment_is_top":false,"comment_ctime":1576994171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576994171","product_id":100039001,"comment_content":"飞的时候如果需要飞的方法内部的处理改变自己的多个属性值，怎么使用委托呐？","like_count":0},{"had_liked":false,"id":163894,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1576820647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576820647","product_id":100039001,"comment_content":"课堂讨论：<br>      Entity、BO、VO 没有关系，都是独立存在的，但是一般在会进行转换封装。在Service 层做。VO&lt;-&gt;BO 和  Entity&lt;-&gt;BO 的封装。 我一般会用BeanUtils.copyProperties 来处理。<br>","like_count":0},{"had_liked":false,"id":163571,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1576747349,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576747349","product_id":100039001,"comment_content":" 打卡《设计模式之美》之第10讲 《为何要多用组合少用继承？如何决定使用组合还是继承？》<br>设计原则：组合优于继承，多用组合少用继承<br>继承的优点：表示 is-a 关系，支持多态特性，代码复用<br>继承的不足：：继承层次过深、继承关系过于复杂会影响代码的可读性和可维护性<br>接口表示具有某种行为特性，但接口只能声明方法，不定义实现，所以会导致具有该功能（实现该接口）的类都要实现方法，导致代码重复。针对这种情况可以对接口再定义实现类，然后通过组合和委托技术来消除重复的代码。<br>继承的优点可以通过组合、接口、委托三个技术实现，并且还能解决继承的层次过深、过复杂的继承关系影响代码的可维护性的问题<br>即使鼓励使用组合，但并不是就拒绝使用继承，需要具体情况具体分析。如果类之间继承结构稳定，层次比较浅，关系不复杂，就可以使用继承。反之，就要尽量使用组合来替代继承","like_count":0},{"had_liked":false,"id":161828,"user_name":"小飞","can_delete":false,"product_type":"c1","uid":1050983,"ip_address":"","ucode":"CFFF2E7768EF9A","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/67/7de7988a.jpg","comment_is_top":false,"comment_ctime":1576366955,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576366955","product_id":100039001,"comment_content":"这个问题希望老师能够给出一个指导，开发过程中确实发生了对这个问题的争执。但是我还没有找到一个比较好的能够说服大家的办法。","like_count":0},{"had_liked":false,"id":161726,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1576308615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576308615","product_id":100039001,"comment_content":"组合就是把属性一个一个的明显的写出来，就像DTO！=VO !=entity<br>少用继承多用组合的原因：<br>1.继承会让程序变得更复杂。根据之前说的最小设计原则，不要在一个父类类定义子类不是通用的东西，这样如果类多的话会变得很多(当然如果只有一两层就没事了)。比如用户分为卖家和买家，买卖家又有绑卡和没绑卡的，这样就要设计四个父类（绑卡买&#47;卖家、没绑卡买卖家），这样下去会越来越多，定义的类也就越来越多。<br>2.明明可以直接看父类有什么东西的，但是如果有了继承簇，还要去看父类有什么，祖宗类有什么，你的猪队友骂不死你<br>3.对于方法，牵一发而动全身。父类变了，下面的都要变(因为用的基本都是super()指定用父类的)<br><br>用继承和组合的场景<br>类结构稳定，层次清晰，关系不复杂就用继承<br>否则就用组合","like_count":0},{"had_liked":false,"id":159855,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1575811853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575811853","product_id":100039001,"comment_content":"很想知道老师对思考题的答案，困扰我很久了","like_count":0},{"had_liked":false,"id":159747,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1575777780,"is_pvip":false,"replies":[{"id":"61127","content":"为啥是重复呢？能解释一下吗","user_name":"作者回复","comment_id":159747,"uid":"1190123","ip_address":"","utype":1,"ctime":1575896343,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1575777780","product_id":100039001,"comment_content":"我觉得，相比较于继承，组合行为本身也是一种重复，咋解决呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477161,"discussion_content":"为啥是重复呢？能解释一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274328,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLicryBoLjDicckia0c5bkOoAlYoR2I9NMK8BiaD7HCGxhS1eM9YSfDuUJuZC90uwv9FvHIVSsBoxFgZw/132","nickname":"MwumLi","note":"","ucode":"9A8A72334ADF6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278746,"discussion_content":"重复实现了方法，虽然用了委托了具体实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591232133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159134,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1575545114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575545114","product_id":100039001,"comment_content":"适度就可以了……适当的代码重复可以忍受，业务的灵活性也得考虑进去","like_count":0},{"had_liked":false,"id":158968,"user_name":"1620","can_delete":false,"product_type":"c1","uid":1104310,"ip_address":"","ucode":"C9222A5CE4723C","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","comment_is_top":false,"comment_ctime":1575507949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575507949","product_id":100039001,"comment_content":"VO BO Entity 我最近在重写一个mvc web项目，（原有项目结构是 Bo extends Entity 在后台数据层mybatis 和 controller 共用了Bo） 我改的策略是废弃了 bo extends Bo 增加了Vo 以及复杂查询的Query ，query 与 Vo 不关心后续结构只关心定制化内容，前端小伙伴完全对照参数录入。 Bo层可能有一些特殊处理与定制。 我没有完全去想集成或者组合，我的目标只是想把他们职责更清晰一点，干净一点。 改完之后就是感觉许多出要transform比较多但可以借助一些copy技术的机制。 我也不知道有没有更好的办法来处理这些，设计模式没怎么学过，DDD只听说过...","like_count":0},{"had_liked":false,"id":158951,"user_name":"vince","can_delete":false,"product_type":"c1","uid":1249981,"ip_address":"","ucode":"90DC7EA30D34B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/bd/54987d4b.jpg","comment_is_top":false,"comment_ctime":1575506360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575506360","product_id":100039001,"comment_content":"讨论题：entity对应数据库层，不应该改动，而bo和vo可用组合的方式解决，具体落地可参考spring的group注解实现","like_count":0},{"had_liked":false,"id":157965,"user_name":"东东科","can_delete":false,"product_type":"c1","uid":1613041,"ip_address":"","ucode":"308F279C5BA37E","user_header":"https://static001.geekbang.org/account/avatar/00/18/9c/f1/a580562b.jpg","comment_is_top":false,"comment_ctime":1575290789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575290789","product_id":100039001,"comment_content":"大部分情况下Bo是Po（entity）的扩展，所以一般可以Bo继承Po或者是Bo组合Po。而现在的web开发很多是前后端分离，Vo需要携带状态和提示信息，所以一般用Vo组合Bo和Po","like_count":0},{"had_liked":false,"id":157788,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1575259164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575259164","product_id":100039001,"comment_content":"这个关于Entity，BO和VO，我是这么做的就是通常BO，VO要比entity多，所以干脆直接继承Entity就完了。当然涉及到一些敏感字段不想暴露出来，就有点麻烦了，可能要自己去除相关字段，或者只能弄一个一个大家通用的，上面都继承这个基础的。","like_count":0},{"had_liked":false,"id":157330,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1575111013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575111013","product_id":100039001,"comment_content":"三个，都有用，不需要组合，也不需要继承。  如果组合用得上就用，不必强求","like_count":0},{"had_liked":false,"id":156844,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1428828,"ip_address":"","ucode":"1AEBD6F79941B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QFE00aXGzaS6ibbfJSJsDrpIkqs0OrIYjzZv6L9vZmMhOlut2j24iaeZb0MCQazToE6FRXN960nNiaTrsmw09YjGw/132","comment_is_top":false,"comment_ctime":1574987838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574987838","product_id":100039001,"comment_content":"业务开发常见问题，解决办法看具体场景而定。主要方式:<br>1 继承，适用在VO ，BO与ENTITY很接近，基本对应数据库字段，直接继承可以复用代码。但是需要能够容忍某些冗余的字段出现。<br><br>2 组合，使用ENTITY组合作为VO BO的成员属性，需要能容忍冗余字段<br><br>3 继承+组合，将VO 和 BO公共部分提取成为单独的类，再通过继承或组合完成复用。定义最为准确，业务和ENTITY分离，个人最推荐方式。","like_count":0},{"had_liked":false,"id":156770,"user_name":"刘岳","can_delete":false,"product_type":"c1","uid":1128385,"ip_address":"","ucode":"67C35B2518BF24","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/c1/481ddf9b.jpg","comment_is_top":false,"comment_ctime":1574952400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574952400","product_id":100039001,"comment_content":"里氏替换明确了继承的原则","like_count":0},{"had_liked":false,"id":156600,"user_name":"HF","can_delete":false,"product_type":"c1","uid":1112811,"ip_address":"","ucode":"0839195346C3CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/eb/84d4de33.jpg","comment_is_top":false,"comment_ctime":1574920732,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574920732","product_id":100039001,"comment_content":"<br>public interface Flyable {<br>  void fly()；<br>}<br>public class FlyAbility implements Flyable {<br>  @Override<br>  public void fly() { &#47;&#47;... }<br>}<br>&#47;&#47;省略Tweetable&#47;TweetAbility&#47;EggLayable&#47;EggLayAbility<br><br>public class Ostrich implements Tweetable, EggLayable {&#47;&#47;鸵鸟<br>  private TweetAbility tweetAbility = new TweetAbility(); &#47;&#47;组合<br>  private EggLayAbility eggLayAbility = new EggLayAbility(); &#47;&#47;组合<br>  &#47;&#47;... 省略其他属性和方法...<br>  @Override<br>  public void tweet() {<br>    tweetAbility.tweet(); &#47;&#47; 委托<br>  }<br>  @Override<br>  public void layEgg() {<br>    eggLayAbility.layEgg(); &#47;&#47; 委托<br>  }<br>}<br>这里都直接用组合了，为什么实现tweetable 和 egglayable接口，感觉有些设计的多此一举。","like_count":0},{"had_liked":false,"id":156482,"user_name":"古杨","can_delete":false,"product_type":"c1","uid":1744092,"ip_address":"","ucode":"8F52AA86B589C7","user_header":"","comment_is_top":false,"comment_ctime":1574901497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574901497","product_id":100039001,"comment_content":"我们项目没有什么Entity,BO,VO全用map😂","like_count":0},{"had_liked":false,"id":156353,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1574860949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574860949","product_id":100039001,"comment_content":"用组合比较合适，但是很多都是重复的，组合感觉又不一定合适，重复多了就单独写了","like_count":0},{"had_liked":false,"id":156336,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1574858291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574858291","product_id":100039001,"comment_content":"课后习题，目前是三者都各自独立去创建，怕后期的需求变化，期待老师的见解","like_count":0},{"had_liked":false,"id":156297,"user_name":"ljr_bird","can_delete":false,"product_type":"c1","uid":1618685,"ip_address":"","ucode":"13D2885BA6CDFF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2QR4YBpeXgVXGXIfnibt80oLbjibIdp1c5ty5wbBTHvgheZRcLWDZAVklOpG2yjlDS2N3rZH66pDOvsvvqI2ic7icw/132","comment_is_top":false,"comment_ctime":1574852001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574852001","product_id":100039001,"comment_content":"继承层次多，让人要花很多时间去理每一层的关系；这种情况下，类的功能&#47;能力可以以接口的方式赋予，想要什么功能就组装什么功能，好像也更自由优雅；但是如果接口的很多实现都是一样的，那么我们先封装一下实现再给需要的类去使用，那些类就不需要自己再实现一次了，从而提高复用性。","like_count":0},{"had_liked":false,"id":155986,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1574790040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574790040","product_id":100039001,"comment_content":"<br>数据库层的entity，在某些情况是和service层的bo的字段基本是一样的，我是一般如果感觉一样会用同一个实体，如果中间有部分字段是一样的，会把这部分的单独抽出来一个类，就是用到了组合，而且定义的时候会尽可能的有一定的通用性，至于controller层的vo的话，差距比较大的话就没办法了，也是能用组合就用组合，其实中间最长用到的是一个BeanUtils类中的一个copy方法，针对其中不同字段属性的赋值操作做了处理，其实就是utils的使用，个人觉得这这种框架下编程，用继承很容易出问题，还是组合、委托和接口用的最多","like_count":0},{"had_liked":false,"id":155946,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1574781292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574781292","product_id":100039001,"comment_content":"定义一个基类或抽象类，BO、VO和Entity继承它，或着创建Get方法，隐藏真实的类成员属性。","like_count":0},{"had_liked":false,"id":155846,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1574766357,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1574766357","product_id":100039001,"comment_content":"我觉得没必要分vo bo entity直接一个vo就好","like_count":0},{"had_liked":false,"id":155796,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1574757965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574757965","product_id":100039001,"comment_content":"目前项目Entity、BO、VO三个没有啥关系，只是部分属性相同。没用继承也没用组合。<br>","like_count":0},{"had_liked":false,"id":155730,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1574745679,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574745679","product_id":100039001,"comment_content":"课堂讨论：VO和Entity一个是针对展示界面，一个是针对数据存储，BO则是真正的业务实体，按照六边形架构来说—VO和Entity位于外层，BO位于内层，BO更加稳定；VO、Entity和BO并不是一一对应的关系，这三个的目标也不相同","like_count":0},{"had_liked":false,"id":155640,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1574731542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574731542","product_id":100039001,"comment_content":"设计模式_10<br>题目：<br>没做过后端的Web服务，根据题目内容，我认为可以用组合的方式，把重复的地方定义接口，给一个默认实现类，里面实现了三者代码相同的地方。<br><br>感想：<br>我们在讨论集成与组合的优劣时，我们在讨论什么？<br><br>个人认为，与组合相比，继承带来了更多的限制，这个问题的讨论变成了：<br>&gt; 限制带来的好处多还是坏处多？<br><br>- 坏处：<br>正如大家表达的一样，限制带来了明显的坏处，比如说，顶层的基类要增加一个抽象方法，所有的实现类都需要实现这个方法，这种变化带来了复杂度非线性的增加。<br>相同的问题，使用组合只需要新增一个接口，在需要的地方添加实现即可。<br><br>- 好处：<br>那么限制有没有好处呢？","like_count":0},{"had_liked":false,"id":155600,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574726209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574726209","product_id":100039001,"comment_content":"编程中is-a出现的机会比has-a低多了。所以在不确定是否是is-a时尽量使用has-a比较好","like_count":0},{"had_liked":false,"id":155599,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574726136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574726136","product_id":100039001,"comment_content":"我觉得继承对能力要求更高，需要有很好的抽象思维才能想清楚什么方法放在继承父类中合适","like_count":0},{"had_liked":false,"id":155593,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1574724958,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574724958","product_id":100039001,"comment_content":"组合对业务的扩展点分离的更彻底，灵活性相对继承会更好，但是极其稳定的业务关系用继承也没什么不好，也挺复合设计直觉的。相对而言，优先采用组合其实意味着对需求和设计的思考要更多更深入。<br>DO和BO，VO，DTO这些问题，基本原则应该是隔离DO和其它O，但是在项目中，DO本身已经把业务表达的太充分，导致DO和其它O太相似，从而觉得好像没必要隔离。","like_count":0},{"had_liked":false,"id":155581,"user_name":"Geek_8c5f9c","can_delete":false,"product_type":"c1","uid":1596047,"ip_address":"","ucode":"70CD441EAF490F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","comment_is_top":false,"comment_ctime":1574710924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574710924","product_id":100039001,"comment_content":"接口是为了表达能力，没有数据，在VO,BO,和Entity中只有数据，所以不用接口。<br>可以抽取它们的共同属性，用组合来引入。共同属性可以用于表达is-a的关系的情况下可以用继承。<br>还可以考虑不作处理，用mapper util来作不同类型间的转化。","like_count":0},{"had_liked":false,"id":155561,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1574698661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574698661","product_id":100039001,"comment_content":"打卡！<br>对于思考题，没想出什么好办法。<br>我认为VO、BO、entity 。可以在相同的字段上用相同的名字。这样就可以通过 Java 的浅拷贝去赋值。","like_count":0},{"had_liked":false,"id":155556,"user_name":"青阳魂","can_delete":false,"product_type":"c1","uid":1254875,"ip_address":"","ucode":"4F04ADAB6D870A","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/db/7c71ef4b.jpg","comment_is_top":false,"comment_ctime":1574697753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574697753","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":155549,"user_name":"wzp","can_delete":false,"product_type":"c1","uid":1120298,"ip_address":"","ucode":"2C511B2755A1E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/2a/9c18a3c4.jpg","comment_is_top":false,"comment_ctime":1574696999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574696999","product_id":100039001,"comment_content":"看了这篇文章，对GoF中的UML图有了一些理解，图中就使用了委托实现代码复用","like_count":0},{"had_liked":false,"id":155533,"user_name":"阿玛铭","can_delete":false,"product_type":"c1","uid":1100703,"ip_address":"","ucode":"DBF948D82ACBE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","comment_is_top":false,"comment_ctime":1574696021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574696021","product_id":100039001,"comment_content":"老师问那么多问题是为了消灭那么多问题，这就很哲学了。","like_count":0},{"had_liked":false,"id":155522,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574695343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574695343","product_id":100039001,"comment_content":"我们的项目中，entity完全是通过业务模型映射出来的，机器自动生成。<br><br>vo&#47;dto是根据实际的业务需求自定义的，数据的载体；<br><br>bo层完全是业务逻辑<br><br>controller则负责路由<br><br>三者并没有很多代码重复。","like_count":0},{"had_liked":false,"id":155510,"user_name":"拓","can_delete":false,"product_type":"c1","uid":1010957,"ip_address":"","ucode":"AC1940ECC25436","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","comment_is_top":false,"comment_ctime":1574693991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574693991","product_id":100039001,"comment_content":"orz. 没有Entity、BO、VO的概念咋整啊。只用过python做过web开发， 我可以理解python django框架里定义的model 对应Entity， 定义View对应VO。但是不知道BO对应django里面的哪部分？也没发现model和view里面有代码重复。另外，django里面的template是controller层面的东西吗？","like_count":0},{"had_liked":false,"id":155491,"user_name":"王振华 程序员","can_delete":false,"product_type":"c1","uid":1131957,"ip_address":"","ucode":"31BB337642B882","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","comment_is_top":false,"comment_ctime":1574692456,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574692456","product_id":100039001,"comment_content":"<br>public class FeignClient { &#47;&#47; feighn client框架代码<br>  &#47;&#47;...省略其他代码...<br>  public void encode(String url) { &#47;&#47;... }<br>}<br><br>public void demofunction(FeignClient feignClient) {<br>  &#47;&#47;...<br>  feignClient.encode(url);<br>  &#47;&#47;...<br>}<br><br>public class CustomizedFeignClient extends FeignClient {<br>  @Override<br>  public void encode(String url) { &#47;&#47;...重写encode的实现...}<br>}<br><br>&#47;&#47; 调用<br>FeignClient client = new CustomizedFeignClient();<br>demofunction(client);<br><br>老师你好，我之前没接触过Java，这段代码我实在是没看懂。<br>FeignClient 是父类， CustomizedFeignClient是子类。<br>FeignClient client = new CustomizedFeignClient();<br>这句代码中，定义的对象 client 到底是什么类型的？是FeignClient类型的，还是CustomizedFeignClient类型的？<br>按照文中的解释，既然这样写能达到 重写encode方法的目的，那应该是CustomizedFeignClient类型的了。 但生成client这个对象的时候，前面加个FeignClient，不会对它的类型有影响吗？<br><br>","like_count":0,"discussions":[{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338282,"discussion_content":"装饰器模式的意图是优化原始类的业务功能实现，没有避免继承结构爆炸的目的。桥接模式才可以说是基于组合避免类继承数量爆","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1609231983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/54/c13b1d63.jpg","nickname":"二十四桥仍在","note":"","ucode":"5498FE5949190F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226141,"discussion_content":"动态代理的两种实现，CgLib代理和jdk代理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586424690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402524,"discussion_content":"第一点同意，第二点，我觉得表述的不是很准确，装饰器模式中装饰类和原始类就是通过继承相同的父类，这样可以实现嵌套装饰，所以应该只支持继承的方式，不支持接口的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633913185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1651664,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/d0/962ebe2e.jpg","nickname":"Buring","note":"","ucode":"0AAEA64C63C2F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382233,"discussion_content":"那如果被装饰类不实现接口怎么办呢，装饰器类还不是需要通过继承来实现装饰功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625480448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073650,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","nickname":"Leon Wong","note":"","ucode":"B49B327367CF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290874,"discussion_content":"我不太理解怎么算是“基于继承代理”？难道指的是静态代理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594631655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073650,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","nickname":"Leon Wong","note":"","ucode":"B49B327367CF9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293231,"discussion_content":"不对哦，静态代理有两种实现方式，一种是基于接口，一种是基于继承。本质上就是不改变原始类的前提下，通过代理类来继承原始类，或者和原始类实现相同接口（通过组合）来对原始类的方法附加功能，符合开闭原则。\n  但静态代理有一个致命缺陷，就是要对每一个需要被代理的类都必须编写对应的代理类，而且每个代理类存在很多重复代码，会导致项目中类的成倍增长。动态代理通过反射来动态创建代理类，达到解决此问题的目的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595487973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290874,"ip_address":""},"score":293231,"extra":""}]}]},{"had_liked":false,"id":155461,"user_name":"2102","can_delete":false,"product_type":"c1","uid":1070298,"ip_address":"","ucode":"A67068F2A3157E","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/da/e2e5ddf7.jpg","comment_is_top":false,"comment_ctime":1574690891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574690891","product_id":100039001,"comment_content":"重复的可以用一个，或者用组合，继承","like_count":0},{"had_liked":false,"id":155435,"user_name":"瓶子霸哥","can_delete":false,"product_type":"c1","uid":1125806,"ip_address":"","ucode":"A7EEB459AB5550","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","comment_is_top":false,"comment_ctime":1574689050,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574689050","product_id":100039001,"comment_content":"学 Android 的并不觉得 MVC 里面的 V 和 C 有太多重复的地方啊. 做 Web 应用的同学能给我举个例子看看是哪里有重复吗","like_count":0,"discussions":[{"author":{"id":1425252,"avatar":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","nickname":"塔兹米","note":"","ucode":"1A58C81EF9B0A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60173,"discussion_content":"成员变量和get、set方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574698473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155425,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1574688159,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1574688159","product_id":100039001,"comment_content":"赞成不做处理，每一种对应都有各自的应用场景，强行的耦合在一起增加复杂度","like_count":0},{"had_liked":false,"id":155420,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":1541934,"ip_address":"","ucode":"F058640CF77A35","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/2e/ea54c240.jpg","comment_is_top":false,"comment_ctime":1574687380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574687380","product_id":100039001,"comment_content":"打卡. entity作为基类，bo和vo继承，并增加自己需要的属性和方法","like_count":0},{"had_liked":false,"id":155409,"user_name":"Warn","can_delete":false,"product_type":"c1","uid":1465310,"ip_address":"","ucode":"F2F7FCDB0940D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/de/152f1c2c.jpg","comment_is_top":false,"comment_ctime":1574686435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574686435","product_id":100039001,"comment_content":"除了思考题，其他收获颇多","like_count":0},{"had_liked":false,"id":155408,"user_name":"陈迎春","can_delete":false,"product_type":"c1","uid":1443663,"ip_address":"","ucode":"2870BA6D6E5B1E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","comment_is_top":false,"comment_ctime":1574686066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574686066","product_id":100039001,"comment_content":"对于组合和委托的概念貌似没有特别讲，看着稍微有点吃力，自己还特地又上网查询了一番","like_count":0},{"had_liked":false,"id":155389,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1574684437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574684437","product_id":100039001,"comment_content":"打卡<br>1、当继承关系复杂、继承层次深的时候，尽量减少使用继承。这样会导致代码可读性和可维护性变差；<br>2、如果集成结构比较稳定，继承层次比较浅，关系不复杂，可以使用继承；<br>3、完全可以使用 接口、组合、委托的方式替换继承的使用；<br>4、继承是将物体分类，抽取共性，处理共性，相对于使用接口、组合和委托的方式灵活性较差，毕竟现实生活中的物体特征多（深度学习训练就是基于物体的特征来做），共性少。接口+组合+委托符合矢量化思想，它讲物体的特征分成不同的维度，每个维度可以独立的变化。","like_count":0},{"had_liked":false,"id":155379,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1574683701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574683701","product_id":100039001,"comment_content":"如果是我的话，应该不会处理这三者之间的代码重复，一般Entity和VO都是贫血模型。只是控制属性是否显示，BO可能存在类似领域对象的方法，但是我理解Entity、VO、BO一个是为了隔离层之间的依赖，一个是为了封装属性，从底到上，暴露的属性越来越少。<br><br>听了今天的课，我觉得设计模式的桥接模式，是不是就是利用接口替代抽象的场景?","like_count":0},{"had_liked":false,"id":155350,"user_name":"成葛格","can_delete":false,"product_type":"c1","uid":1030745,"ip_address":"","ucode":"A09A57D891FA50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/59/ffa298a2.jpg","comment_is_top":false,"comment_ctime":1574681105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574681105","product_id":100039001,"comment_content":"Entity，VO 结构层次简单，为了复用代码可以使用继承；BO 采用组合。","like_count":0},{"had_liked":false,"id":155259,"user_name":"爽了个爽","can_delete":false,"product_type":"c1","uid":1261326,"ip_address":"","ucode":"D5B10F75A02AB1","user_header":"https://static001.geekbang.org/account/avatar/00/13/3f/0e/3a2fb9ff.jpg","comment_is_top":false,"comment_ctime":1574672179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574672179","product_id":100039001,"comment_content":"<br>这个问题困扰我很久了。现在写代码的时候有时候会直接把Entity返回。除非有组合数据采用vo。🤣","like_count":0},{"had_liked":false,"id":155236,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1574669969,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574669969","product_id":100039001,"comment_content":"之前写Android的时候，对这些似懂非懂；现在接触到了Java Service，感觉对设计模式的要求越来越高了，就比如老师提出的这个思考题，尴尬，我现在的做法还是做封装，提取公共类更多一点。","like_count":0},{"had_liked":false,"id":155230,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1574669037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574669037","product_id":100039001,"comment_content":"目前项目中确实存在很多实体类都有同样的属性，至于怎么合理的应用还没有思考过。看了老师的文章之后，是不是要考虑用组合模式来优化。","like_count":0},{"had_liked":false,"id":155211,"user_name":"陀螺","can_delete":false,"product_type":"c1","uid":1058808,"ip_address":"","ucode":"5016747DD39102","user_header":"https://static001.geekbang.org/account/avatar/00/10/27/f8/1388139d.jpg","comment_is_top":false,"comment_ctime":1574664237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574664237","product_id":100039001,"comment_content":"Entity、BO、VO 代码重复的问题从共性上使用继承不太合理，反而组合更加灵活些。更简单可以使用静态类来实现。","like_count":0},{"had_liked":false,"id":155206,"user_name":"真是艹0","can_delete":false,"product_type":"c1","uid":1234043,"ip_address":"","ucode":"0A082CE0D79C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/7b/74e59208.jpg","comment_is_top":false,"comment_ctime":1574663414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574663414","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":155197,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1574660816,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574660816","product_id":100039001,"comment_content":"打卡：组合和继承个有好处，不能滥用继承，组合方式更机灵活.","like_count":0,"discussions":[{"author":{"id":2063921,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/31/3aa06dd8.jpg","nickname":"张伟楠","note":"","ucode":"468A9BFF138C31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384725,"discussion_content":"大兄弟，装饰器哪里是用来解决继承关系过于复杂的问题啊。。。装饰器和代理实现方式都一样，代理能实现的凭什么装饰器实现不了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626713814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063921,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/31/3aa06dd8.jpg","nickname":"张伟楠","note":"","ucode":"468A9BFF138C31","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559793,"discussion_content":"上节课是这么说的，不是装饰器实现不了，就算类数量爆炸也是实现了，但这不是不优雅吗，代理只关注当前类，所以通过继承没影响的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648972592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384725,"ip_address":""},"score":559793,"extra":""}]}]},{"had_liked":false,"id":155196,"user_name":"崔礼堂","can_delete":false,"product_type":"c1","uid":1075312,"ip_address":"","ucode":"CB5F16A3774EF4","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/70/10e07705.jpg","comment_is_top":false,"comment_ctime":1574660473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574660473","product_id":100039001,"comment_content":"Vo接查询参数，dto反回列表对象，我是这么用的，其实有点懵","like_count":0},{"had_liked":false,"id":155179,"user_name":"阿崔cxr","can_delete":false,"product_type":"c1","uid":1177565,"ip_address":"","ucode":"26E2C7D96306A4","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/dd/c85f2065.jpg","comment_is_top":false,"comment_ctime":1574657195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574657195","product_id":100039001,"comment_content":"对于用组合还是继承来讲的话，我优先选择满足于当下业务场景下的最简单的实现方法。 不做过度的设计。 当未来有需求要变更的时候，通过重构来改变现有设计。 ","like_count":0},{"had_liked":false,"id":155177,"user_name":"路伴友行","can_delete":false,"product_type":"c1","uid":1506974,"ip_address":"","ucode":"96B54B7EEAEDAD","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/9e/8165b0a0.jpg","comment_is_top":false,"comment_ctime":1574656954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574656954","product_id":100039001,"comment_content":"VO, BO, Entity  还不如 map 字典来的方便🤣🤣🤣","like_count":0},{"had_liked":false,"id":155174,"user_name":"暝","can_delete":false,"product_type":"c1","uid":1608600,"ip_address":"","ucode":"20AE1FDFE6DD91","user_header":"https://static001.geekbang.org/account/avatar/00/18/8b/98/ddbdea57.jpg","comment_is_top":false,"comment_ctime":1574656630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574656630","product_id":100039001,"comment_content":"相对固定的组合，就是继承。组合更加灵活一点","like_count":0},{"had_liked":false,"id":155172,"user_name":"Zm","can_delete":false,"product_type":"c1","uid":1448893,"ip_address":"","ucode":"831FF80F07E965","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKj4w4lW7ibGEVxPv8wS1CrXKDeBz3RAaAdISxQSD23uUpV3wicsIMepaYZE8GzRcWmSpjet5NDN4MA/132","comment_is_top":false,"comment_ctime":1574656207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574656207","product_id":100039001,"comment_content":"Spring中beanfactory和beandefintion就是组合。  ","like_count":0},{"had_liked":false,"id":155171,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1574656021,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574656021","product_id":100039001,"comment_content":"这个课后思考题很实际。<br>如果组合entity，那entity里面不需要向外暴露的属性是不是要通过封装？<br>封装的话真正使用entity的时候又不支持直接获取entity对象了？<br>再扩展一点的话，在ddd中，各层对象可以是严格隔离的(每层之间都要转换)，可以是非严格的(可以使用一个对象)，这种情况又怎么更合理的使用组合还是继承呢？","like_count":0},{"had_liked":false,"id":155163,"user_name":"MaxHu","can_delete":false,"product_type":"c1","uid":1005070,"ip_address":"","ucode":"31E69EE0717B62","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/0e/43dbfb92.jpg","comment_is_top":false,"comment_ctime":1574654321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574654321","product_id":100039001,"comment_content":"课上老师提到:装饰模式，组合模式和和策略模式用了组合，而模版模式用的继承.上面说的组合其实是用到了继承和委托还有局部组成整体的组合. 上面说的继承是指对抽象类的继承，并且只用了继承。是这样理解吧？","like_count":0},{"had_liked":false,"id":155154,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1574652791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574652791","product_id":100039001,"comment_content":"用继承吧，可以将相同的部分抽出一个BaseEntity，然后不同的部分作为子类继承BaseEntity","like_count":0},{"had_liked":false,"id":155144,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1574651236,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574651236","product_id":100039001,"comment_content":"我认为这个要看 VO,BO,Entity的关系，如果 BO，VO,Entity存在包含关系 比如 VO 包含EntityA,EntityB那么就应该用组合，如果BO，VO,Entity只是用来存储字段数据，并且大部分字段名字都一样的话，为了消除重复代码，我首选继承。我非常赞同老师说这句话 ，“组合并不完美，继承也不是一无是处”！","like_count":0},{"had_liked":false,"id":155138,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1574650267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574650267","product_id":100039001,"comment_content":"把重复的代码抽出一个或多个接口并实现相应的类，然后在Entity，BO和VO中添加对应的属性（一个或多个），以此来实现代码复用，这就是一个典型的接口+组合实现代码复用并避免继承的例子","like_count":0},{"had_liked":false,"id":155116,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574647651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574647651","product_id":100039001,"comment_content":"他们没有继承关闭 所以应该用组合方式来解决重复性代码","like_count":0},{"had_liked":false,"id":155113,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1574647352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574647352","product_id":100039001,"comment_content":"got it~","like_count":0},{"had_liked":false,"id":155107,"user_name":"huahuaxiaoshao","can_delete":false,"product_type":"c1","uid":1600012,"ip_address":"","ucode":"3309034B2A8C65","user_header":"https://static001.geekbang.org/account/avatar/00/18/6a/0c/3740de12.jpg","comment_is_top":false,"comment_ctime":1574646556,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574646556","product_id":100039001,"comment_content":"一般来说，每个Entity都有增删改查的功能，何不设计一些增删改查的接口，并实现这些接口。通过组合构成一些通用类（当然封装的时候，会用到委托方式），本人就是一个小白菜，发表一下我的想法，不知道对不对，望批评指正。","like_count":0,"discussions":[{"author":{"id":1234314,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","nickname":"东征","note":"","ucode":"DC557A1631A493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57990,"discussion_content":"已经有了，了解下jpa","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574648470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155105,"user_name":"米 虫","can_delete":false,"product_type":"c1","uid":1073087,"ip_address":"","ucode":"6F35AA8BB8195B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/bf/4bd3eb4b.jpg","comment_is_top":false,"comment_ctime":1574646497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574646497","product_id":100039001,"comment_content":"我发现平时代码中，我也想不出多复杂的继承关系来，所以一般想到了的is a ，我都用上了继承，可能是多肽的魅力太诱惑。也可能是我原本就把继承当接口用了，c++。","like_count":0},{"had_liked":false,"id":155092,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1574644910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574644910","product_id":100039001,"comment_content":"实际中可能没有那么多entity,bo,vo，一般我们都是用一个","like_count":0},{"had_liked":false,"id":155088,"user_name":"Sheamus","can_delete":false,"product_type":"c1","uid":1248510,"ip_address":"","ucode":"F6EBDFF3575ADA","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","comment_is_top":false,"comment_ctime":1574644721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574644721","product_id":100039001,"comment_content":"课后思考题，使用组合比较好，有时候vo并不是要所有字段","like_count":0},{"had_liked":false,"id":155085,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1574644284,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1574644284","product_id":100039001,"comment_content":"老是你好，有个实现细节的问题。<br>实现 Flayable, Tweetable, EggLayable这些接口，如果需要访问 类的属性或方法的话，怎么使用 TweetAbility FlyAbility EggLayAbility 的委托方式实现呢？<br>如果实现时不需要访问 类的属性或方法的话，那不就和静态函数一样了吗？","like_count":0},{"had_liked":false,"id":155076,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1574643457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574643457","product_id":100039001,"comment_content":"## 继承的作用<br><br>1.  表示 is-a 关系<br>2. 支持多态<br>3. 代码复用<br><br>## 继承的缺点<br><br>类继承容易导致继承层次越来越深，层次变深会引起两个问题：<br>1. 代码可读性变差，从而导致可维护性变差。<br>2. 破坏类的封装性，子类依赖父类的实现，两者高度耦合。<br><br>## 如何解决继承的缺点<br><br>利用组合、接口、委托等三种技术手段。<br>（文中的例子依赖于其它类，因此需要实例化，Java 的抽象类可以包含实现，是不是用抽象类会更好？）<br><br>## 组合的优势<br><br>使用 has-a 关系解决继承 is-a 关系导致的问题，同时不丢失继承的优势。<br><br>## 组合的缺点<br><br>组合需要定义更多的类和接口，从而导致代码复杂度和维护成本增加。<br><br>## 如何选择继承和组合<br><br>1. 通常情况下，纵向比较深选择组合；横向比较广选择继承。<br>2. 只是接口功能相同，类之间没有继承关系时使用组合。<br>3. 对已有的类进行多态，只能使用继承。<br>","like_count":0},{"had_liked":false,"id":155072,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1574643293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574643293","product_id":100039001,"comment_content":"项目中大部分都是无脑继承，然后加自己的属性。。用组合的话，每次创建vo，bo对象，都要传一个entity进来，感觉也很麻烦","like_count":0},{"had_liked":false,"id":155067,"user_name":"tomcat","can_delete":false,"product_type":"c1","uid":1367381,"ip_address":"","ucode":"E56EDAA22D9287","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ1AM7bbBzJUQUC5qu7jebxd1pFYnibiaABbz0s7jNxOVpHBgNAtsPBFf504ib9ZjNdK4eDoiavjAZIYg/132","comment_is_top":false,"comment_ctime":1574642959,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574642959","product_id":100039001,"comment_content":"这种领域对象，只有getter,setter方法，将公共属性抽取到父类中，采用继承可以减少大量重复代码，实际项目中也是这么使用的。","like_count":0,"discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244341,"discussion_content":"总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587599135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155049,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1574641491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574641491","product_id":100039001,"comment_content":"坐等大牛来优雅的解决思考题问题，这个问题困扰过，但是还是会复制粘贴，因为怕将来万一有变化。","like_count":0},{"had_liked":false,"id":155034,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1574639749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574639749","product_id":100039001,"comment_content":"这一节收获匪浅，感谢老师，对于思考题。我认为可以用组合，平时开发的时候，这三个类都是分开的。写了很多重复的代码，也一点都不优雅，期待老师的解答","like_count":0},{"had_liked":false,"id":155029,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1574639103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574639103","product_id":100039001,"comment_content":"老师 多继承中的mixin组合方式 是不是一种很好的方法呢","like_count":0},{"had_liked":false,"id":155025,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1574638719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574638719","product_id":100039001,"comment_content":"Mvc中各层的实体类有时候还要更加复杂一点，有时还要细分为入参和返回两种。比如controller的Request 和Response。<br><br>在业务简单的情况下，有时甚至可以三层都用同一个实体。<br><br>实体之间重复的部分可以考虑使用继承抽取。<br><br>而且还有一个问题，不同的实体在转换的时候，一大堆的get set方法，实在是不雅。","like_count":0},{"had_liked":false,"id":154996,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1574612419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574612419","product_id":100039001,"comment_content":"定义一个BaseBean包含着几个O的属性， <br>其他的O来继承.<br>","like_count":0}]}