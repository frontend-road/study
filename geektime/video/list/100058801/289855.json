{"id":289855,"title":"27 | Window Trigger","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geektime-Flink\">https://gitee.com/geektime-geekbang/geektime-Flink</a></p>","comments":[{"had_liked":false,"id":253828,"user_name":"yang","can_delete":false,"product_type":"c3","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1602908222,"is_pvip":false,"replies":[{"id":93251,"content":"可以的 只要是能求取出Delta值即可，超过七天我觉得有点牵强，后面的场景非常适合，重点是和上一次数据对比。","user_name":"作者回复","user_name_real":"张利兵","uid":1119779,"ctime":1603528003,"ip_address":"","comment_id":253828,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"也就是说 ContiuousEventTimeTrigger 总是表现为 append 模式进行输出，这种模式对下游的算子的业务是不友好的，因为我们总是希望利用到上次计算的结果而不是每次用全量计算的结果去重新计算。\n所以  ContiuousEventTimeTrigger 单独使用的场景应该是比较少，还是看append模式的业务场景的需要。\n而 PuringTrigger 总是在触发计算计算之前，清空上一次windonw的计算结果，属于Update模式，对下游算子而言，可以有效利用上次计算结果，且这种方式可以减少 Triger 维护的状态。\n\nDeltaTrigger \n比如在购物app中 一个用户距离上次购物时间 超过7天 就可以使用这种触发器吧？\n或者，比如在温度传感器设备传来的数据中，和上次温度差超过5度，也可以使用这种触发器吧？\n\n\n","like_count":0,"discussions":[{"author":{"id":1119779,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/23/99c7ede5.jpg","nickname":"张利兵","note":"","ucode":"DBAE17970AB143","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507198,"discussion_content":"可以的 只要是能求取出Delta值即可，超过七天我觉得有点牵强，后面的场景非常适合，重点是和上一次数据对比。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603528003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352579,"user_name":"Hunter_Dark","can_delete":false,"product_type":"c3","uid":1342279,"ip_address":"","ucode":"3A07CCBC250B69","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/47/96dad3ff.jpg","comment_is_top":false,"comment_ctime":1658795226,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"老师，我是使用了proccessing Time trigger 。但是窗口没有数据进来，那么并不会触发计算对吗？","like_count":0},{"had_liked":false,"id":279483,"user_name":"正向成长","can_delete":false,"product_type":"c3","uid":1197344,"ip_address":"","ucode":"AC4B5E719BA5CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/20/24867e59.jpg","comment_is_top":false,"comment_ctime":1613800819,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"puring那个是update模式？课件里面是append模式","like_count":0},{"had_liked":false,"id":278148,"user_name":"Tobias","can_delete":false,"product_type":"c3","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1612775428,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"老师讲的很好，赞！","like_count":0},{"had_liked":false,"id":268005,"user_name":"高飞","can_delete":false,"product_type":"c3","uid":1315573,"ip_address":"","ucode":"EEF84DD4189B3D","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/f5/d9c23981.jpg","comment_is_top":false,"comment_ctime":1608027791,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"请问老师，关于ContiuousEventTimeTrigger的使用场景， 如果窗口时间是1小时， 而ContiuousEventTimeTrigger设定每隔1分钟计算一次， 计算的时候要把结果存储到mysql上以便业务上实时的展示。 就是例如求每个区域的每小时的商品销售额, 要求每隔1min能能够看到销售额变动情况这种需求。 那么在窗口的下游算子计算的时候， 每1分钟都要计算一次存入mysql(不管是append模式还是update模式)， 这样会不会还是计算重复了呢？ 因为都添加了mysql中的数据记录， 还是说要维护窗口和mysql的映射关系， 找到对应的mysql的条目进行更新？","like_count":0,"discussions":[{"author":{"id":2028957,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/9d/104bb8ea.jpg","nickname":"Geek2014","note":"","ucode":"9EB356D8DF287E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404701,"discussion_content":"MySQL里需要再做一次聚合吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634388382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260814,"user_name":"陈超","can_delete":false,"product_type":"c3","uid":1306148,"ip_address":"","ucode":"F61C5827BE1353","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/24/9b95e3cf.jpg","comment_is_top":false,"comment_ctime":1605112433,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100058801,"comment_content":"这么说来，对每类默认window 做 .trigger() 指定后，原有默认窗口的默认Trigger就作废了，完全以 .trigger()里指定的为准了吧？","like_count":0}]}