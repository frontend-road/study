{"id":94427,"title":"07 | 函数调用：为什么会发生stack overflow？","content":"<p>在开发软件的过程中我们经常会遇到错误，如果你用Google搜过出错信息，那你多少应该都访问过<a href=\"https://stackoverflow.com/\">Stack Overflow</a>这个网站。作为全球最大的程序员问答网站，Stack Overflow的名字来自于一个常见的报错，就是栈溢出（stack overflow）。</p><p>今天，我们就从程序的函数调用开始，讲讲函数间的相互调用，在计算机指令层面是怎么实现的，以及什么情况下会发生栈溢出这个错误。</p><h2>为什么我们需要程序栈？</h2><p>和前面几讲一样，我们还是从一个非常简单的C程序function_example.c看起。</p><pre><code>// function_example.c\n#include &lt;stdio.h&gt;\nint static add(int a, int b)\n{\n    return a+b;\n}\n\n\nint main()\n{\n    int x = 5;\n    int y = 10;\n    int u = add(x, y);\n}\n</code></pre><p>这个程序定义了一个简单的函数add，接受两个参数a和b，返回值就是a+b。而main函数里则定义了两个变量x和y，然后通过调用这个add函数，来计算u=x+y，最后把u的数值打印出来。</p><pre><code>$ gcc -g -c function_example.c\n$ objdump -d -M intel -S function_example.o\n</code></pre><p>我们把这个程序编译之后，objdump出来。我们来看一看对应的汇编代码。</p><pre><code>int static add(int a, int b)\n{\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi\n   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi\n    return a+b;\n   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]\n   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]\n  10:   01 d0                   add    eax,edx\n}\n  12:   5d                      pop    rbp\n  13:   c3                      ret    \n0000000000000014 &lt;main&gt;:\nint main()\n{\n  14:   55                      push   rbp\n  15:   48 89 e5                mov    rbp,rsp\n  18:   48 83 ec 10             sub    rsp,0x10\n    int x = 5;\n  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5\n    int y = 10;\n  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa\n    int u = add(x, y);\n  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]\n  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  30:   89 d6                   mov    esi,edx\n  32:   89 c7                   mov    edi,eax\n  34:   e8 c7 ff ff ff          call   0 &lt;add&gt;\n  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax\n  3c:   b8 00 00 00 00          mov    eax,0x0\n}\n  41:   c9                      leave  \n  42:   c3                      ret    \n</code></pre><p>可以看出来，在这段代码里，main函数和上一节我们讲的的程序执行区别并不大，它主要是把jump指令换成了函数调用的call指令。call指令后面跟着的，仍然是跳转后的程序地址。</p><p>这些你理解起来应该不成问题。我们下面来看一个有意思的部分。</p><!-- [[[read_end]]] --><p>我们来看add函数。可以看到，add函数编译之后，代码先执行了一条push指令和一条mov指令；在函数执行结束的时候，又执行了一条pop和一条ret指令。这四条指令的执行，其实就是在进行我们接下来要讲<strong>压栈</strong>（Push）和<strong>出栈</strong>（Pop）操作。</p><p>你有没有发现，函数调用和上一节我们讲的if…else和for/while循环有点像。它们两个都是在原来顺序执行的指令过程里，执行了一个内存地址的跳转指令，让指令从原来顺序执行的过程里跳开，从新的跳转后的位置开始执行。</p><p>但是，这两个跳转有个区别，if…else和for/while的跳转，是跳转走了就不再回来了，就在跳转后的新地址开始顺序地执行指令，就好像徐志摩在《再别康桥》里面写的：“我挥一挥衣袖，不带走一片云彩”，继续进行新的生活了。而函数调用的跳转，在对应函数的指令执行完了之后，还要再回到函数调用的地方，继续执行call之后的指令，就好像贺知章在《回乡偶书》里面写的那样：“少小离家老大回，乡音未改鬓毛衰”，不管走多远，最终还是要回来。</p><p>那我们有没有一个可以不跳转回到原来开始的地方，来实现函数的调用呢？直觉上似乎有这么一个解决办法。你可以把调用的函数指令，直接插入在调用函数的地方，替换掉对应的call指令，然后在编译器编译代码的时候，直接就把函数调用变成对应的指令替换掉。</p><p>不过，仔细琢磨一下，你会发现这个方法有些问题。如果函数A调用了函数B，然后函数B再调用函数A，我们就得面临在A里面插入B的指令，然后在B里面插入A的指令，这样就会产生无穷无尽地替换。就好像两面镜子面对面放在一块儿，任何一面镜子里面都会看到无穷多面镜子。</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/06/0b4d9f07a7d15e5e25908bbf1532e706.jpg?wh=1142*870\" alt=\"\"></p><center>Infinite Mirror Effect，如果函数A调用B，B再调用A，那么代码会无限展开，<a href=\"https://commons.wikimedia.org/w/index.php?curid=40716759\">图片来源</a></center><p>看来，把被调用函数的指令直接插入在调用处的方法行不通。那我们就换一个思路，能不能把后面要跳回来执行的指令地址给记录下来呢？就像前面讲PC寄存器一样，我们可以专门设立一个“程序调用寄存器”，来存储接下来要跳转回来执行的指令地址。等到函数调用结束，从这个寄存器里取出地址，再跳转到这个记录的地址，继续执行就好了。</p><p>但是在多层函数调用里，简单只记录一个地址也是不够的。我们在调用函数A之后，A还可以调用函数B，B还能调用函数C。这一层又一层的调用并没有数量上的限制。在所有函数调用返回之前，每一次调用的返回地址都要记录下来，但是我们CPU里的寄存器数量并不多。像我们一般使用的Intel i7 CPU只有16个64位寄存器，调用的层数一多就存不下了。</p><p>最终，计算机科学家们想到了一个比单独记录跳转回来的地址更完善的办法。我们在内存里面开辟一段空间，用栈这个<strong>后进先出</strong>（LIFO，Last In First Out）的数据结构。栈就像一个乒乓球桶，每次程序调用函数之前，我们都把调用返回后的地址写在一个乒乓球上，然后塞进这个球桶。这个操作其实就是我们常说的<strong>压栈</strong>。如果函数执行完了，我们就从球桶里取出最上面的那个乒乓球，很显然，这就是<strong>出栈</strong>。</p><p>拿到出栈的乒乓球，找到上面的地址，把程序跳转过去，就返回到了函数调用后的下一条指令了。如果函数A在执行完成之前又调用了函数B，那么在取出乒乓球之前，我们需要往球桶里塞一个乒乓球。而我们从球桶最上面拿乒乓球的时候，拿的也一定是最近一次的，也就是最下面一层的函数调用完成后的地址。乒乓球桶的底部，就是<strong>栈底</strong>，最上面的乒乓球所在的位置，就是<strong>栈顶</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/be/d0c75219d3a528c920c2a593daaf77be.jpeg?wh=2923*1975\" alt=\"\"></p><p>在真实的程序里，压栈的不只有函数调用完成后的返回地址。比如函数A在调用B的时候，需要传输一些参数数据，这些参数数据在寄存器不够用的时候也会被压入栈中。整个函数A所占用的所有内存空间，就是函数A的<strong>栈帧</strong>（Stack Frame）。Frame在中文里也有“相框”的意思，所以，每次到这里，我都有种感觉，整个函数A所需要的内存空间就像是被这么一个“相框”给框了起来，放在了栈里面。</p><p>而实际的程序栈布局，顶和底与我们的乒乓球桶相比是倒过来的。底在最上面，顶在最下面，这样的布局是因为栈底的内存地址是在一开始就固定的。而一层层压栈之后，栈顶的内存地址是在逐渐变小而不是变大。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/d1/2361ecf8cf08f07c83377376a31869d1.jpeg?wh=1655*1655\" alt=\"\"></p><p>图中，rbp是register base pointer 栈基址寄存器（栈帧指针），指向当前栈帧的栈底地址。rsp是register stack pointer 栈顶寄存器（栈指针），指向栈顶元素。</p><p>对应上面函数add的汇编代码，我们来仔细看看，main函数调用add函数时，add函数入口在0～1行，add函数结束之后在12～13行。</p><p>我们在调用第34行的call指令时，会把当前的PC寄存器里的下一条指令的地址压栈，保留函数调用结束后要执行的指令地址。而add函数的第0行，push rbp这个指令，就是在进行压栈。这里的rbp又叫栈帧指针（Frame Pointer），是一个存放了当前栈帧位置的寄存器。push rbp就把之前调用函数，也就是main函数的栈帧的栈底地址，压到栈顶。</p><p>接着，第1行的一条命令mov rbp, rsp里，则是把rsp这个栈指针（Stack Pointer）的值复制到rbp里，而rsp始终会指向栈顶。这个命令意味着，rbp这个栈帧指针指向的地址，变成当前最新的栈顶，也就是add函数的栈帧的栈底地址了。</p><p>而在函数add执行完成之后，又会分别调用第12行的pop rbp来将当前的栈顶出栈，这部分操作维护好了我们整个栈帧。然后，我们可以调用第13行的ret指令，这时候同时要把call调用的时候压入的PC寄存器里的下一条指令出栈，更新到PC寄存器中，将程序的控制权返回到出栈后的栈顶。</p><h2>如何构造一个stack  overflow？</h2><p>通过引入栈，我们可以看到，无论有多少层的函数调用，或者在函数A里调用函数B，再在函数B里调用A，这样的递归调用，我们都只需要通过维持rbp和rsp，这两个维护栈顶所在地址的寄存器，就能管理好不同函数之间的跳转。不过，栈的大小也是有限的。如果函数调用层数太多，我们往栈里压入它存不下的内容，程序在执行的过程中就会遇到栈溢出的错误，这就是大名鼎鼎的“stack  overflow”。</p><p>要构造一个栈溢出的错误并不困难，最简单的办法，就是我们上面说的Infiinite Mirror Effect的方式，让函数A调用自己，并且不设任何终止条件。这样一个无限递归的程序，在不断地压栈过程中，将整个栈空间填满，并最终遇上stack  overflow。</p><pre><code>int a()\n{\n  return a();\n}\n\n\nint main()\n{\n  a();\n  return 0;\n}\n</code></pre><p>除了无限递归，递归层数过深，在栈空间里面创建非常占内存的变量（比如一个巨大的数组），这些情况都很可能给你带来stack  overflow。相信你理解了栈在程序运行的过程里面是怎么回事，未来在遇到stackoverflow这个错误的时候，不会完全没有方向了。</p><h2>如何利用函数内联进行性能优化？</h2><p>上面我们提到一个方法，把一个实际调用的函数产生的指令，直接插入到的位置，来替换对应的函数调用指令。尽管这个通用的函数调用方案，被我们否决了，但是如果被调用的函数里，没有调用其他函数，这个方法还是可以行得通的。</p><p>事实上，这就是一个常见的编译器进行自动优化的场景，我们通常叫<strong>函数内联</strong>（Inline）。我们只要在GCC编译的时候，加上对应的一个让编译器自动优化的参数-O，编译器就会在可行的情况下，进行这样的指令替换。</p><p>我们来看一段代码。</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nint static add(int a, int b)\n{\n    return a+b;\n}\n\nint main()\n{\n    srand(time(NULL));\n    int x = rand() % 5\n    int y = rand() % 10;\n    int u = add(x, y)\n    printf(&quot;u = %d\\n&quot;, u)\n}\n</code></pre><p>为了避免编译器优化掉太多代码，我小小修改了一下function_example.c，让参数x和y都变成了，通过随机数生成，并在代码的最后加上将u通过printf打印出来的语句。</p><pre><code>$ gcc -g -c -O function_example_inline.c\n$ objdump -d -M intel -S function_example_inline.o\n</code></pre><p>上面的function_example_inline.c的编译出来的汇编代码，没有把add函数单独编译成一段指令顺序，而是在调用u = add(x, y)的时候，直接替换成了一个add指令。</p><pre><code>    return a+b;\n  4c:   01 de                   add    esi,ebx\n</code></pre><p>除了依靠编译器的自动优化，你还可以在定义函数的地方，加上inline的关键字，来提示编译器对函数进行内联。</p><p>内联带来的优化是，CPU需要执行的指令数变少了，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了。</p><p>不过内联并不是没有代价，内联意味着，我们把可以复用的程序指令在调用它的地方完全展开了。如果一个函数在很多地方都被调用了，那么就会展开很多次，整个程序占用的空间就会变大了。</p><p><img src=\"https://static001.geekbang.org/resource/image/dc/85/dca83475560147d4dd492ff283ae0c85.jpeg?wh=2035*1381\" alt=\"\"></p><p>这样没有调用其他函数，只会被调用的函数，我们一般称之为<strong>叶子函数（或叶子过程）</strong>。</p><h2>总结延伸</h2><p>这一节，我们讲了一个程序的函数间调用，在CPU指令层面是怎么执行的。其中一定需要你牢记的，就是<strong>程序栈</strong>这个新概念。</p><p>我们可以方便地通过压栈和出栈操作，使得程序在不同的函数调用过程中进行转移。而函数内联和栈溢出，一个是我们常常可以选择的优化方案，另一个则是我们会常遇到的程序Bug。</p><p>通过加入了程序栈，我们相当于在指令跳转的过程种，加入了一个“记忆”的功能，能在跳转去运行新的指令之后，再回到跳出去的位置，能够实现更加丰富和灵活的指令执行流程。这个也为我们在程序开发的过程中，提供了“函数”这样一个抽象，使得我们在软件开发的过程中，可以复用代码和指令，而不是只能简单粗暴地复制、粘贴代码和指令。</p><h2>推荐阅读</h2><p>如果你觉得还不过瘾，可以仔细读一下《深入理解计算机系统（第三版）》的3.7小节《过程》，进一步了解函数调用是怎么回事。</p><p>另外，我推荐你花一点时间，通过搜索引擎搞清楚function_example.c每一行汇编代码的含义，这个能够帮你进一步深入了解程序栈、栈帧、寄存器以及Intel CPU的指令集。</p><h2>课后思考</h2><p>在程序栈里面，除了我们跳转前的指令地址外，还需要保留哪些信息，才能在我们在函数调用完成之后，跳转回到指令地址的时候，继续执行完函数调用之后的指令呢？</p><p>你可以想一想，查一查，然后在留言区留下你的思考和答案，也欢迎你把今天的内容分享给你的朋友，和他一起思考和进步。</p>","neighbors":{"left":{"article_title":"06 | 指令跳转：原来if...else就是goto","id":94075},"right":{"article_title":"08 | ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？","id":94470}},"comments":[{"had_liked":false,"id":93215,"user_name":"CGer_AJ","can_delete":false,"product_type":"c1","uid":1109496,"ip_address":"","ucode":"8ADCD37282074B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/f8/b047d38a.jpg","comment_is_top":false,"comment_ctime":1557436247,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"349449787223","product_id":100026001,"comment_content":"这个很好 讲的很细 这两章我要反复看 并手动实践 感觉作者 把这个课讲的生动形象~这个绝对是最值的课程","like_count":80,"discussions":[{"author":{"id":2668983,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b9/b7/4e66a604.jpg","nickname":"lh_lh","note":"","ucode":"3B110D9E3A575C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380553,"discussion_content":"文字不懂的朋友可以去看一下B站宝藏博主的图解，建议暂停着看，理解每一步。https://www.bilibili.com/video/BV1WZ4y1p7JT","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1624552678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1641326,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDdmHm6txEVtEXEDibSdIsRLEpghOoMt2kfZHetY9QLWHygicKCfhVoYiaylAZJoXbcCMBhXqMF4icgw/132","nickname":"洗洗睡吧","note":"","ucode":"DE7F8B4CA512F6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2668983,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b9/b7/4e66a604.jpg","nickname":"lh_lh","note":"","ucode":"3B110D9E3A575C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576889,"discussion_content":"好东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655825208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380553,"ip_address":""},"score":576889,"extra":""}]}]},{"had_liked":false,"id":93243,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1557446496,"is_pvip":false,"replies":[{"id":"33382","content":"kdb_reboot，谢谢建议。这个建议不错，我麻烦编辑稍后加上。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557472262,"ip_address":"","comment_id":93243,"utype":1}],"discussion_count":7,"race_medal":0,"score":"237780647776","product_id":100026001,"comment_content":"倒数第二图比较好 <br>补充一下寄存器说明<br>rbp - register base pointer (start of stack)<br>rsp - register stack pointer (current location in stack, growing downwards)<br>建议将图编号这样评论的时候也能有所指代","like_count":56,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449543,"discussion_content":"kdb_reboot，谢谢建议。这个建议不错，我麻烦编辑稍后加上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557472262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1764854,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ed/f6/4a083c7e.jpg","nickname":"Geek_embeded","note":"","ucode":"1ABFAA34E983F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321183,"discussion_content":"老师忘记加了。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604545423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","nickname":"大马猴","note":"","ucode":"E3482CBDF43CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57183,"discussion_content":"然而现在也没加","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574579951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2231610,"avatar":"https://static001.geekbang.org/account/avatar/00/22/0d/3a/9315efcc.jpg","nickname":"single","note":"","ucode":"F1F990024D1DE2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550088,"discussion_content":"现在还是没加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644380783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253498,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/7a/edab929f.jpg","nickname":"唔是好青年","note":"","ucode":"A53457B9DF7D17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351027,"discussion_content":"现在也还没加","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614128725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318840,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1f/b8/9a142943.jpg","nickname":"小鲨鱼","note":"","ucode":"B0FFABB1F4343F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576268,"discussion_content":"加哪里呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655382944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2905523,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","nickname":"nuan","note":"","ucode":"55FF98EB85404D","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559137,"discussion_content":"现在还是没加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648622754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93314,"user_name":"chengzise","can_delete":false,"product_type":"c1","uid":1006070,"ip_address":"","ucode":"1C27D216359894","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/f6/ed66d1c1.jpg","comment_is_top":false,"comment_ctime":1557451853,"is_pvip":false,"replies":[{"id":"33410","content":"👍，谢谢 chengzise 同学，谢谢补充。call 在调用的时候会做push eip的操作，而在ret的时候会做pop eip的操作。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557478258,"ip_address":"","comment_id":93314,"utype":1}],"discussion_count":2,"race_medal":0,"score":"186241045581","product_id":100026001,"comment_content":"老师这里需要补冲一下，函数调用call指令时，（PC）指令地址寄存器会自动压栈，即返回地址压栈，函数返回ret指令时会自动弹栈，即返回地址赋值给PC寄存器，把之前。图片有显示压栈，没有文字说明，其他同学可以不太理解。","like_count":44,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449579,"discussion_content":"👍，谢谢 chengzise 同学，谢谢补充。call 在调用的时候会做push eip的操作，而在ret的时候会做pop eip的操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557478258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2837328,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4b/50/fae00aff.jpg","nickname":"HollyWong","note":"","ucode":"03A66A2BCC0A58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412336,"discussion_content":"老师说的是段内跳转，如果是段间跳转，还要将CS压栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636126059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217174,"user_name":"Geek_dark","can_delete":false,"product_type":"c1","uid":1736792,"ip_address":"","ucode":"84A751D785FD28","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2EOx1qgJEYIdmDQrcWBr2ByTKlwib4gKbjUK9qJ68cYTGXAJaepibo6wKFWjXMbwSUDiaw8RyU3QVg/132","comment_is_top":false,"comment_ctime":1589431551,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"151913286911","product_id":100026001,"comment_content":"https:&#47;&#47;manybutfinite.com&#47;post&#47;journey-to-the-stack&#47;<br>这篇文章将汇编指令操作栈的步骤一步步画出来了，大家可以看看，浅显易懂。","like_count":36,"discussions":[{"author":{"id":2445969,"avatar":"","nickname":"Geek_74d504","note":"","ucode":"86E607AF63C749","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350403,"discussion_content":"https://stackoverflow.com/questions/4024492/can-anyone-help-me-interpret-this-simple-disassembly-from-windbg\n这个也可以看看，对最简单的main前后的代码都有解释","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1613848206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133580,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","nickname":"憎爱不关心","note":"","ucode":"A868ACB200C798","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586318,"discussion_content":"感谢，让我的完美主义得到缓解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662103886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623117,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c4/4d/85014aab.jpg","nickname":"一叉树","note":"","ucode":"BFC984403ACD1F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578050,"discussion_content":"手动点赞！这篇文章真的超级详细。不知道后年马月才有 Part2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656487856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1133580,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","nickname":"憎爱不关心","note":"","ucode":"A868ACB200C798","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1623117,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c4/4d/85014aab.jpg","nickname":"一叉树","note":"","ucode":"BFC984403ACD1F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":586323,"discussion_content":"https://manybutfinite.com/post/epilogues-canaries-buffer-overflows/ 有啊，下一篇就是。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662106073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":578050,"ip_address":"广东"},"score":586323,"extra":""}]},{"author":{"id":2403865,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ae/19/5f2d96ce.jpg","nickname":"Bruce","note":"","ucode":"2EA3B9DBF5821C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340661,"discussion_content":"非常感谢，帮助我理解了整个过程，确实不错。一开始我以为只有地址的出栈入栈呢，哈哈， 没想到还有这么一堆东西，终于知道rbp, rsp, eax这些干啥的了，还有每个函数一开始的push rbp; mov rbp, rsp。还有最后的pop rbp, ret了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610090119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229111,"user_name":"杰杰","can_delete":false,"product_type":"c1","uid":1121620,"ip_address":"","ucode":"1E9C42DB1D8A7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/54/adb7bf82.jpg","comment_is_top":false,"comment_ctime":1592899205,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"108967081605","product_id":100026001,"comment_content":"查了一下，个人理解。<br><br>call 就相当于 push rip 和 jmp 的结合。rip 是指令地址寄存器，也就是会将返回地址入栈，并跳转到相应函数处执行。而 ret 就相当于 pop rip 和 jmp 的结合。<br><br>rbp 和 rsp 用于维护当前栈帧，rbp 指向栈帧的栈底地址，rsp 指向栈顶地址。<br>push rbp 和 mov rbp, rsp 主要是为了从 main 函数栈帧调整为 add 函数栈帧。<br>push rbp 是将之前 main 函数栈帧的栈底地址入栈，之后的 pop rbp 就可以将该栈底地址出栈，从而又调整为 main 函数栈帧。<br>rsp 指向 main 函数栈帧的栈顶地址，也就是当前 add 函数栈帧的栈底地址。mov rbp, rsp 就是把 rbp 从 main 函数栈帧的栈底地址 调整为 add 函数栈帧的栈底地址。<br>在 push 时 rsp 会减小，在 pop 时 rsp 会增大，从而 rsp 始终指向栈顶位置。<br>     ","like_count":25,"discussions":[{"author":{"id":2825312,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/1c/60/d84a9131.jpg","nickname":"白夜","note":"","ucode":"FE876ACB1B5210","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411382,"discussion_content":"好耶，感谢感谢，理解了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635913597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382090,"discussion_content":"不枉我一个一个的看评论，明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625409653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517457,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","nickname":"开心","note":"","ucode":"C8E08E8724C7CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334588,"discussion_content":"终于理解了，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607909796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98206,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1558930261,"is_pvip":true,"replies":[{"id":"35457","content":"秋天同学你好，<br><br>我们在这里先要分清楚 抽象概念 和 实际的硬件实现部分。<br><br>寄存器 和 内存，是在硬件层面就是放在不同的位置，使用不同的物理硬件来实现的。<br><br>而栈是一个抽象概念，实际是存放在内存里面的。栈是用来管理函数调用的“现场”的。确保函数调用完成后，还能回到调用者那里。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559121240,"ip_address":"","comment_id":98206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"108933112661","product_id":100026001,"comment_content":"现在有点模糊的是栈只是用来做函数调用，记录跳转地址的？它和寄存器的本质区别吗？这两者能给解释一下吗？谢谢！","like_count":26,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451598,"discussion_content":"秋天同学你好，\n\n我们在这里先要分清楚 抽象概念 和 实际的硬件实现部分。\n\n寄存器 和 内存，是在硬件层面就是放在不同的位置，使用不同的物理硬件来实现的。\n\n而栈是一个抽象概念，实际是存放在内存里面的。栈是用来管理函数调用的“现场”的。确保函数调用完成后，还能回到调用者那里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559121240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94873,"user_name":"董某人","can_delete":false,"product_type":"c1","uid":1237968,"ip_address":"","ucode":"62B249ADAC141F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep0ic1X2oYwJY4rUXdcTExmKnUvYLPqiazVmjA0QHOiaCcp5GEQZia8UKdya2TMq1CibwV4iaNe0hqZZ1eg/132","comment_is_top":false,"comment_ctime":1557914258,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"108932096658","product_id":100026001,"comment_content":"老师，既然push rbp 的作用是把&quot;main 函数栈帧的栈底地址，压到栈顶&quot;，那下一句mov rbp,rsp 又是把&quot;栈顶地址复制给栈帧&quot;。<br>原本rbp 中存储的不就是main 函数栈帧地址，压到栈顶后rsp 中存储的不也是main 函数栈帧地址，mov 这句的作用究竟是什么呢？","like_count":25,"discussions":[{"author":{"id":1043734,"avatar":"","nickname":"AKun","note":"","ucode":"BCF3FEDE06AB77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35651,"discussion_content":"rbp和rsp是两个寄存器，存放的分别是当前栈帧的栈底和栈顶地址。每一次的函数调用，会把上一个栈帧的栈底地址保存起来（结束后要恢复的），然后修改rbp的值到当前栈帧的栈底。新的函数调用刚开始时，rbp是和rsp指向相同的地址的。个人理解","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1571296127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043734,"avatar":"","nickname":"AKun","note":"","ucode":"BCF3FEDE06AB77","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362677,"discussion_content":"是的，调用前保存rbp的值的操作 应该是被打包在call指令中了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617007847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35651,"ip_address":""},"score":362677,"extra":""},{"author":{"id":1363822,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uktgj5R0p78c67oLib8EuRMRCgP8yjxnZ1ibVOuibhRZvjJpKSJNaTl0UlEfGyiaaiaGyPmqpGYpibTt0QopX1qtWfQQ/132","nickname":"杨大小最嗨皮","note":"","ucode":"7DFACF1414AE16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1043734,"avatar":"","nickname":"AKun","note":"","ucode":"BCF3FEDE06AB77","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375936,"discussion_content":"感觉就有点像这两个指针形成了一个滑动窗口 ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621874357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35651,"ip_address":""},"score":375936,"extra":""},{"author":{"id":1467309,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/ad/21f62e27.jpg","nickname":"wjyuian","note":"","ucode":"1DDDDBF869CFC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1363822,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uktgj5R0p78c67oLib8EuRMRCgP8yjxnZ1ibVOuibhRZvjJpKSJNaTl0UlEfGyiaaiaGyPmqpGYpibTt0QopX1qtWfQQ/132","nickname":"杨大小最嗨皮","note":"","ucode":"7DFACF1414AE16","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544640,"discussion_content":"应该就是滑动窗口的理解，很形象！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641613383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375936,"ip_address":""},"score":544640,"extra":""}]},{"author":{"id":1088673,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/a1/077139ed.jpg","nickname":"sa1kou","note":"","ucode":"4F68B6092D3C03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120626,"discussion_content":"move操作的是寄存器，push操作的是栈内存","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1578285715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","nickname":"Richard","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35363,"discussion_content":"个人理解，push和move操作是从main栈帧切换到add栈帧，rbp要指向当前栈帧（add栈帧）的底栈底，而rsp始终指向栈顶，这里move把rsp传入rbp就是把main的栈顶也即add的栈底压入rbp。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1571273287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105544,"user_name":"JStFs","can_delete":false,"product_type":"c1","uid":1241121,"ip_address":"","ucode":"636E85653555DD","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/21/7168f973.jpg","comment_is_top":false,"comment_ctime":1561026264,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"91755339480","product_id":100026001,"comment_content":"“push rbp 就把之前调用函数，也就是 main 函数的栈帧的栈底地址，压到栈顶。”<br><br>一直不明白为什么要把main的栈底压到栈顶？没有图很难理解","like_count":21,"discussions":[{"author":{"id":1305257,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ea/a9/0a917f2c.jpg","nickname":"Sunny","note":"","ucode":"BB7B274CE0672E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56916,"discussion_content":"同问，说实话，这一块感觉缺少上下文铺垫，感觉有点敷衍。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1574524692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1983034,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/42/3a/bca96a7f.jpg","nickname":"人什么人","note":"","ucode":"052538EFD0B1D6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335499,"discussion_content":"老师，你这个真的，不是太好理解， 还要百度","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1608208743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2099073,"avatar":"https://static001.geekbang.org/account/avatar/00/20/07/81/eec288f4.jpg","nickname":"tyt","note":"","ucode":"A1B4C026F54B00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295744,"discussion_content":"因为它进入了新的函数，不过新函数也要使用rbp来来对数据进行索引，所以把它入栈保存。等到该函数执行完成，再pop rbp。将栈内保存的上一个函数的rbp值，存入rbp。这么做是为了函数嵌套，当然你也可以选择用一个寄存器来保存这个值，但是寄存器是有限的，所以通过push和pop操作它。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596326966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1453187,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2c/83/f85ba9cd.jpg","nickname":"once","note":"","ucode":"033281FC1DAB37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6333,"discussion_content":"是的 我也不太理解 , 老师可以解答一下么","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1566834947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214582,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","nickname":"youngitachi","note":"","ucode":"88717CA8B8ED64","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415258,"discussion_content":"因为rbp需要保持一个栈帧的基准位置，也就是所谓的栈帧的栈底位置。\nmain函数调用其他函数的时候，会后两个连续的操作\n：\npush rbp\nmov rbp rsp（把rsp移到rbp）\n这样rbp的值就是其他函数的栈帧基准位置了。\n当函数调用完，进行ret的时候，rbp需要重新指向main函数的基准位置，这个时候就会有一个pop rbp的操作，也就是将之前压入到“那个时候的栈顶”的main函数栈底地址给pop到rbp","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1637040173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1992059,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/65/7b/058d17f3.jpg","nickname":"耶low","note":"","ucode":"4CCEB741583544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348928,"discussion_content":"我猜测跟Intel处理器采用小端法有关，详细可以看《深入理解计算机系统》2.1.3","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612778582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2285946,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/7a/b206cded.jpg","nickname":"人在江湖龙在江湖","note":"","ucode":"20850038573DAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323778,"discussion_content":"为了把局部变量放到栈中操作，如果没有这一步，汇编程序逻辑就要换一种方式写，完全是人实践总结出来的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604995095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624821,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ca/f5/3f95bf91.jpg","nickname":"tron","note":"","ucode":"F94DB2BE804998","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312563,"discussion_content":"顶到栈顶","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602733866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257283,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/43/e24212bb.jpg","nickname":"o_O","note":"","ucode":"7C469AE3DA323B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212946,"discussion_content":"我也觉得，希望画个图帮助理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585036777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206639,"discussion_content":"同问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584424213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235460,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/04/26fbd46a.jpg","nickname":"不会写诗的翩翩少年","note":"","ucode":"A2DB54A73080BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7601,"discussion_content":"同问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567582309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593345,"avatar":"https://static001.geekbang.org/account/avatar/00/18/50/01/128bdef2.jpg","nickname":"Black🐯","note":"","ucode":"9AD756BD5D1C4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348917,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612775034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108225,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e9/01/6e6d80d1.jpg","nickname":"Loy","note":"","ucode":"CD437EDA754EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341207,"discussion_content":"去看看程序员的自我修养这本书","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610350871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93486,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1557479667,"is_pvip":true,"replies":[{"id":"33427","content":"这两个是在维护函数调用的栈帧。<br><br>指令地址本身的压栈和出栈是在 call 和 ret 的部分进行的。<br>你可以认为 call 的同时进行了一次 push rip 把PC寄存器里面的内容压栈了，而在 ret 的时候 pop 把这部分数据出栈写回到PC寄存器里面了。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557506130,"ip_address":"","comment_id":93486,"utype":1}],"discussion_count":5,"race_medal":0,"score":"83161858291","product_id":100026001,"comment_content":"push rbp；<br>mov rbp rsp；<br>老师，想问这两句是如何控制函数调用的","like_count":19,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449653,"discussion_content":"这两个是在维护函数调用的栈帧。\n\n指令地址本身的压栈和出栈是在 call 和 ret 的部分进行的。\n你可以认为 call 的同时进行了一次 push rip 把PC寄存器里面的内容压栈了，而在 ret 的时候 pop 把这部分数据出栈写回到PC寄存器里面了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557506130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403865,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ae/19/5f2d96ce.jpg","nickname":"Bruce","note":"","ucode":"2EA3B9DBF5821C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340585,"discussion_content":"那什么叫做维护函数调用的栈帧呢？后面说的那些地址出栈入栈大家应该都很容易理解。只是这里额外的push rbp; mov rbp rsp;自己后面pop rbp. 很突然，不理解是干什么的。我看有人贴出来rbp rsp的意思，这不是我们的问题点。问的是作用，是怎么个过程，什么意义。就比如问这个cpu是干嘛的？有人贴出来cpu就是central processing unit中央处理器，你觉得别人能说“哦哦哦，那我明白了”吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610068024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1401319,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIAPIqAIJCHGyaGnR52b57BlegIRyQKu7QS8SNXDeKkYHmMbc9LoefHA6e1U6xRCNmfV37WIknTCA/132","nickname":"ConnorLee","note":"","ucode":"E3512D5AC50758","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2403865,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ae/19/5f2d96ce.jpg","nickname":"Bruce","note":"","ucode":"2EA3B9DBF5821C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530542,"discussion_content":"系统提示：你的问题已超出作者能力范围Max，被选择性无视。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637082617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340585,"ip_address":""},"score":530542,"extra":"{\"user_type\":1}"}]},{"author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206645,"discussion_content":"rip又是什么啊？是写错了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584424580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1245504,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/40/a203a3b9.jpg","nickname":"爱学习不害怕","note":"","ucode":"BE325C02E4C92F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286221,"discussion_content":"指令寄存器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593090030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206645,"ip_address":""},"score":286221,"extra":""}]}]},{"had_liked":false,"id":101365,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1559789525,"is_pvip":false,"replies":[{"id":"37118","content":"如果是函数作用域内的临时变量，就是分配在栈上的啊。<br><br>首先Java运行时候的JVM自己就是一个应用程序，和C编译出来的机器码就不一样。<br><br>Java通过New出来的对象是在堆上，但是函数作用域里面的临时变量，以及对应的引用都是放在栈上的。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1560262324,"ip_address":"","comment_id":101365,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74574233557","product_id":100026001,"comment_content":"老师 巨大数组为什么是分配在栈空间的呢？（java里面是分配到堆上的 c预约和java不同吗）","like_count":17,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452930,"discussion_content":"如果是函数作用域内的临时变量，就是分配在栈上的啊。\n\n首先Java运行时候的JVM自己就是一个应用程序，和C编译出来的机器码就不一样。\n\nJava通过New出来的对象是在堆上，但是函数作用域里面的临时变量，以及对应的引用都是放在栈上的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1560262324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1101182,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/7e/6fa52026.jpg","nickname":"qaz","note":"","ucode":"FE4455942A6465","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":561764,"discussion_content":"那也只是数组的引用在栈上吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649724569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":452930,"ip_address":""},"score":561764,"extra":""}]}]},{"had_liked":false,"id":95201,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1252639,"ip_address":"","ucode":"2F3959A717BE10","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/1f/6bc10297.jpg","comment_is_top":false,"comment_ctime":1557983415,"is_pvip":false,"replies":[{"id":"34189","content":"这个是在维护栈帧，因为后面有两个临时变量需要在调用其他函数之前保留到栈里面。0x18是16进制的24<br>两个int各需要8 bit,一共16bit，然后ebp本来就要8bit，一共只有24bit,考虑对齐到16bit的整数倍还要额外的8bit一共24bit","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1558099567,"ip_address":"","comment_id":95201,"utype":1}],"discussion_count":2,"race_medal":0,"score":"65982492855","product_id":100026001,"comment_content":"int main()<br>{<br>   d:   55                      push   ebp<br>   e:   89 e5                   mov    ebp,esp<br>  10:   83 ec 18                sub    esp,0x18<br>    int x = 5;<br>  13:   c7 45 f4 05 00 00 00    mov    DWORD PTR [ebp-0xc],0x5<br>    int y = 10;<br>  1a:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [ebp-0x8],0xa<br><br>老师，请教下：<br>   sub    esp,0x18  的目的是干什么？ 0x18 是怎么计算的？<br>","like_count":15,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450367,"discussion_content":"这个是在维护栈帧，因为后面有两个临时变量需要在调用其他函数之前保留到栈里面。0x18是16进制的24\n两个int各需要8 bit,一共16bit，然后ebp本来就要8bit，一共只有24bit,考虑对齐到16bit的整数倍还要额外的8bit一共24bit","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558099567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379345,"discussion_content":"这段哪里来的，按文中的不是0x10吗？ebp-4到0是x，ebp-8到ebp-4是y，对齐加8","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623836590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119050,"user_name":"DreamItPossible","can_delete":false,"product_type":"c1","uid":1254103,"ip_address":"","ucode":"232FCE2BB22012","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/d7/fed46140.jpg","comment_is_top":false,"comment_ctime":1564493899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57399068747","product_id":100026001,"comment_content":"首先，以函数P调用函数Q为例进行说明：<br>程序栈里需要保存的信息有：<br>- 函数P调用函数Q完成后的下一个指令的地址，即返回地址；<br>- 如果函数Q的参数个数超过6个，则剩余的参数值需要保存在栈上；<br>- 某些共用的寄存器值；<br>- 为指针类型参数生成的地址信息；<br>- 数组和结构体等复杂数据结构；<br>其次，需要保存的信息其实可以反过来解答文章开头的问题：为什么需要程序栈？<br>最后，总结一下：资源有限，即寄存器个数有限，需要结合栈来实现复杂的功能，比如函数调用等","like_count":13},{"had_liked":false,"id":128799,"user_name":"once","can_delete":false,"product_type":"c1","uid":1453187,"ip_address":"","ucode":"033281FC1DAB37","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/83/f85ba9cd.jpg","comment_is_top":false,"comment_ctime":1566964401,"is_pvip":false,"replies":[{"id":"51172","content":"这两个是在维护函数调用的栈帧。<br><br>指令地址本身的压栈和出栈是在 call 和 ret 的部分进行的。<br>你可以认为 call 的同时进行了一次 push rip 把PC寄存器里面的内容压栈了，而在 ret 的时候 pop 把这部分数据出栈写回到PC寄存器里面了。<br><br>这一部分的确是有不少同学表示写得不够清楚，我晚点看单独会在FAQ里面更详细地写一下这个过程。也再修订一下这一讲希望能讲解地更清楚一些。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568551529,"ip_address":"","comment_id":128799,"utype":1}],"discussion_count":3,"race_medal":0,"score":"53106571953","product_id":100026001,"comment_content":"老师 call指令已经将pc寄存器里的下一个指令（add函数执行完的跳转地址）压栈了 那 add函数里面的 push rbp压的又是什么栈 还有把main函数从栈底压到栈顶这个是什么意思 没有图看了好几遍也懵懵的 help老师","like_count":12,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465108,"discussion_content":"这两个是在维护函数调用的栈帧。\n\n指令地址本身的压栈和出栈是在 call 和 ret 的部分进行的。\n你可以认为 call 的同时进行了一次 push rip 把PC寄存器里面的内容压栈了，而在 ret 的时候 pop 把这部分数据出栈写回到PC寄存器里面了。\n\n这一部分的确是有不少同学表示写得不够清楚，我晚点看单独会在FAQ里面更详细地写一下这个过程。也再修订一下这一讲希望能讲解地更清楚一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568551529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378915,"discussion_content":"态度倒是挺好的，就是老师可能太忙了，从来不去做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623508590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1084817,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epBvSR0csPOllNNO4Y9atB4ibrkTkFjw08MgHbOCJbnJQnDHVPQiba6KhAyWGbn2pj7WLBZib1iaUJ8icg/132","nickname":"过河拆桥","note":"","ucode":"39348D80CBBDD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402217,"discussion_content":"哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633834191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378915,"ip_address":""},"score":402217,"extra":""}]}]},{"had_liked":false,"id":96689,"user_name":"小猪","can_delete":false,"product_type":"c1","uid":1519206,"ip_address":"","ucode":"01712EFFD641A6","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/66/3f49793e.jpg","comment_is_top":false,"comment_ctime":1558488616,"is_pvip":false,"replies":[{"id":"35472","content":"小猪同学你好，<br><br>那么被调用的函数运行完之后，怎么知道要跳回到哪一个地址呢？","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559122799,"ip_address":"","comment_id":96689,"utype":1}],"discussion_count":7,"race_medal":0,"score":"40213194280","product_id":100026001,"comment_content":"老师，我觉得用goto就可以实现函数调用，起先跳转到函数，运行完，在用goto跳回来就行了","like_count":9,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450972,"discussion_content":"小猪同学你好，\n\n那么被调用的函数运行完之后，怎么知道要跳回到哪一个地址呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559122799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306076,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8FcyGXsZ9RtGZ18o9pPjTiab2FbYPdnBs1fibWJtiaUlD8ySjwStcAicAOUoDu1Fb49NiblmKCtqKgtw/132","nickname":"转过","note":"","ucode":"EDB2FD2D6D7AEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7043,"discussion_content":"那for循环为什么知道要跳回哪个地址呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567318878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1074310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","nickname":"多襄丸","note":"","ucode":"1AA1497C5A293C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1306076,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8FcyGXsZ9RtGZ18o9pPjTiab2FbYPdnBs1fibWJtiaUlD8ySjwStcAicAOUoDu1Fb49NiblmKCtqKgtw/132","nickname":"转过","note":"","ucode":"EDB2FD2D6D7AEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96578,"discussion_content":"你搞清楚了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577076915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7043,"ip_address":""},"score":96578,"extra":""},{"author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1306076,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8FcyGXsZ9RtGZ18o9pPjTiab2FbYPdnBs1fibWJtiaUlD8ySjwStcAicAOUoDu1Fb49NiblmKCtqKgtw/132","nickname":"转过","note":"","ucode":"EDB2FD2D6D7AEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122965,"discussion_content":"for、dowhile循环最终都是满足dowhile循环的机器码：举例在do的第一行地址为L2，指令顺序执行，到while的时候判断条件后goto到L2（继续循环）或者往下执行（循环完毕）。整个跳转都是在一个函数内完成，而函数跳转不一样，main跳转到add，add执行完cpu懵逼了，不知道该继续往哪里走了，这时候就要告诉cpu，add函数你执行完之后再去main里面某个地址位置继续执行。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578382820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7043,"ip_address":""},"score":122965,"extra":""},{"author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1306076,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8FcyGXsZ9RtGZ18o9pPjTiab2FbYPdnBs1fibWJtiaUlD8ySjwStcAicAOUoDu1Fb49NiblmKCtqKgtw/132","nickname":"转过","note":"","ucode":"EDB2FD2D6D7AEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122975,"discussion_content":"那谁来告诉cpu后面执行完要去main里某个位置继续执行呢，文章也说了，一开始想法是函数内联，函数内联即把被调用的函数add直接代替call写在main中，使它们变成一个函数，一个函数内肯定就顺序执行即可，也不用goto了，但是直接用函数内联的方式在有相互调用的情况下是不适用的，那么就要找一套能适用于所有情况的策略。于是就选择了栈。main先压栈，此时栈顶栈底都是main，然后add进来，此时栈底是main，栈顶是add，add执行完后出栈，栈顶变成main继续执行。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1578383261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7043,"ip_address":""},"score":122975,"extra":""}]}]},{"had_liked":false,"id":93872,"user_name":"Akizuki","can_delete":false,"product_type":"c1","uid":1517311,"ip_address":"","ucode":"2B48169ED18AC7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEbZZ65d5ibzjadyKq6Odjs5eeSJGwxnfBAv7gKjp6vG5GUdz9YrXq54KZeAEsS1OfahWVZurXODg/132","comment_is_top":false,"comment_ctime":1557646400,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40212352064","product_id":100026001,"comment_content":"function_example.c 反汇编结果：<br><br>    int u = add(x, y);<br>  2a:   8b 55 f8                mov    edx, DWORD PTR [rbp-0x8]<br>  2d:   8b 45 fc                mov    eax, DWORD PTR [rbp-0x4]<br>  30:   89 d6                   mov    esi, edx<br>  32:   89 c7                   mov    edi, eax<br><br>老师，这里为什么没有编译成：<br><br>mov    esi, DWORD PTR [rbp-0x8]<br>mov    edi, DWORD PTR [rbp-0x4]<br><br>谢谢～","like_count":9,"discussions":[{"author":{"id":1274118,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/06/e17159a9.jpg","nickname":"peterkalven","note":"","ucode":"74AF1D2A01E563","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629,"discussion_content":"我也没想明白。 增加了函数的参数到5个，发现可以直接把内存stack中的内容直接存到esi和edi中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561823021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98211,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1558931470,"is_pvip":true,"replies":[{"id":"35456","content":"java虚拟机其实是一个应用层的程序，java虚拟机的内部内存分配其实是在虚拟内存地址层面的分配。的确不涉及到操作系统和硬件层面的分页问题。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559121094,"ip_address":"","comment_id":98211,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35918669838","product_id":100026001,"comment_content":"java程序应该不是那种分页的形式，在虚机起动的时候我们根据配置或者是起动参数指定需要的内存大小，应该是预先分配好一大段连续的内存供程序使用，所以在程序运行过程中如果超出啦，预分配大小的内存就会出现内存溢出的错误","like_count":8,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451600,"discussion_content":"java虚拟机其实是一个应用层的程序，java虚拟机的内部内存分配其实是在虚拟内存地址层面的分配。的确不涉及到操作系统和硬件层面的分页问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559121094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94827,"user_name":"Alphalin","can_delete":false,"product_type":"c1","uid":1034134,"ip_address":"","ucode":"7F6D9A5BD6DB2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/96/19149e9e.jpg","comment_is_top":false,"comment_ctime":1557905683,"is_pvip":false,"replies":[{"id":"34164","content":"34的整个指令有长度啊，你数一数这条指令对应的机器码需要多少空间呢？","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1558093647,"ip_address":"","comment_id":94827,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31622676755","product_id":100026001,"comment_content":"请问地址34后面的地址怎么直接到39了？ 35地址在哪呢","like_count":7,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450225,"discussion_content":"34的整个指令有长度啊，你数一数这条指令对应的机器码需要多少空间呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558093647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378919,"discussion_content":"汇编代码和机器码之间是一一对应的，但是一条指令可能对应着一条或者多条机器码，是一对多的一个关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623509204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179108,"user_name":"曾立涵","can_delete":false,"product_type":"c1","uid":1242498,"ip_address":"","ucode":"C8E9019A44FB9B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/82/75f71508.jpg","comment_is_top":false,"comment_ctime":1581918380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27351722156","product_id":100026001,"comment_content":"大家可以结合这篇文章看一下，带图的好理解一些https:&#47;&#47;blog.csdn.net&#47;fistraiser&#47;article&#47;details&#47;80270473","like_count":6},{"had_liked":false,"id":113888,"user_name":"楼外楼","can_delete":false,"product_type":"c1","uid":1243180,"ip_address":"","ucode":"791F2CA15B8F1F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sgEfkeMSIIibeH4l0HS8uwM6PGY3DSHoW5tV9l1hDQ06tr3OnI7F545Wdxsh59rqOKnzjLUpCcEqic3P9zZbKzPQ/132","comment_is_top":false,"comment_ctime":1563179934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23038016414","product_id":100026001,"comment_content":"ESP&#47;RSP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。（64位机器变为RSP）<br>EBP&#47;RBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。（64位机器变为RBP）","like_count":5},{"had_liked":false,"id":93588,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1557505850,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23032342330","product_id":100026001,"comment_content":"老师，有两个问题还是没有理解：<br>1.为什么栈底到栈顶地址是从大到小？<br>2.内联时把可重用的程序指令在调用的地方展开，指的是什么展开？","like_count":5,"discussions":[{"author":{"id":1883431,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/bd/27/e653a220.jpg","nickname":"Xiaosong","note":"","ucode":"28A03027343F9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557058,"discussion_content":"1.c的数组是由低向高分配内存地址的，栈由高向低可以让栈顶的指针指向数组的第一个元素，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647638169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93233,"user_name":"小李同学","can_delete":false,"product_type":"c1","uid":1187427,"ip_address":"","ucode":"90B50B7D408AC8","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/63/d5909105.jpg","comment_is_top":false,"comment_ctime":1557444837,"is_pvip":false,"replies":[{"id":"33405","content":"每个线程都有一个自己的栈。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557476853,"ip_address":"","comment_id":93233,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23032281317","product_id":100026001,"comment_content":"老师，栈是按照线程进行区分的吗？那个线程都有各自对应的栈吗？","like_count":5,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449538,"discussion_content":"每个线程都有一个自己的栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557476853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94547,"user_name":"大给给","can_delete":false,"product_type":"c1","uid":1238618,"ip_address":"","ucode":"69B6FBE9E81467","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/5a/377dc4bf.jpg","comment_is_top":false,"comment_ctime":1557838716,"is_pvip":false,"replies":[{"id":"34167","content":"可以的，其实内存操作是很慢的相对于cpu，如果不能加载到高速缓存里面，反复直接操作主内存是很慢的","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1558094019,"ip_address":"","comment_id":94547,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18737707900","product_id":100026001,"comment_content":"买了好多课之后感觉最值的课程，深入浅出；另外问老师个问题，inline会提升程序的性能，根本原因是直接替换不需要让栈帧入栈出栈对门？那可不可以理解为这里比较耗性能的地方是入栈出栈操作？","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450102,"discussion_content":"可以的，其实内存操作是很慢的相对于cpu，如果不能加载到高速缓存里面，反复直接操作主内存是很慢的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558094019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93600,"user_name":"喜欢吃鱼","can_delete":false,"product_type":"c1","uid":1250205,"ip_address":"","ucode":"02F41572F53E3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","comment_is_top":false,"comment_ctime":1557529790,"is_pvip":false,"replies":[{"id":"34169","content":"的确是，一个是每100次猜错一次，一个是10次猜错一次，性能上会有差别，你可以自己写个程序统计一下时间试试","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1558095242,"ip_address":"","comment_id":93600,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18737398974","product_id":100026001,"comment_content":"谢谢老师的回复，我忘了贴代码了，需要优化的代码如下.网上说把大的for循环写里面是为了提高CPU流水线的分支预测的准确率，但是我对这个不是很清楚。<br>for（i=0;i&lt;1000;i++）{<br>        for（j=0;j&lt;100;j++）{<br>                for（k=0;k&lt;10;k++）{<br>                       printf(“%d”,i+j+k);<br>                }<br>        }<br>}","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449695,"discussion_content":"的确是，一个是每100次猜错一次，一个是10次猜错一次，性能上会有差别，你可以自己写个程序统计一下时间试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558095242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93551,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1557493560,"is_pvip":false,"replies":[{"id":"33433","content":"6个还是8个以内的调用参数会放在寄存器内而不是stack frame里面。<br>X64 下 stack 需要按 16 bytes 做 alignment 可能是导致你需要的空间变成 24 bytes 的原因。这里的 24 bytes 加上你的 8 bytes 的 rbp 正好是 32 bytes 能是16的倍数。<br>可以看看这个 stackoverflow 的问题 https:&#47;&#47;stackoverflow.com&#47;questions&#47;40580914&#47;why-more-space-on-the-stack-frame-is-reserved-than-is-needed-in-x86","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557509618,"ip_address":"","comment_id":93551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18737362744","product_id":100026001,"comment_content":"0x0000000000400508 &lt;+0&gt;:     push   %rbp<br>0x0000000000400509 &lt;+1&gt;:     mov    %rsp,%rbp<br>0x000000000040050c &lt;+4&gt;:     sub    $0x18,%rsp<br>0x0000000000400510 &lt;+8&gt;:     movl   $0x1,-0x4(%rbp)<br>0x0000000000400517 &lt;+15&gt;:    movl   $0x2,-0x8(%rbp)<br>0x000000000040051e &lt;+22&gt;:    mov    -0x8(%rbp),%esi<br>0x0000000000400521 &lt;+25&gt;:    mov    -0x4(%rbp),%eax<br>0x0000000000400524 &lt;+28&gt;:    movl   $0x7,(%rsp)<br>=&gt; 0x000000000040052b &lt;+35&gt;:    mov    $0x6,%r9d<br> 0x0000000000400531 &lt;+41&gt;:    mov    $0x5,%r8d<br> 0x0000000000400537 &lt;+47&gt;:    mov    $0x4,%ecx<br> 0x000000000040053c &lt;+52&gt;:    mov    $0x3,%edx<br> 0x0000000000400541 &lt;+57&gt;:    mov    %eax,%edi<br> 0x0000000000400543 &lt;+59&gt;:    callq  0x4004cd &lt;add&gt;<br> 0x0000000000400548 &lt;+64&gt;:    mov    %eax,-0xc(%rbp)<br> 0x000000000040054b &lt;+67&gt;:    mov    $0x0,%eax<br> 0x0000000000400550 &lt;+72&gt;:    leaveq<br> 0x0000000000400551 &lt;+73&gt;:    retq<br>(gdb) i r<br>rcx            0x400560 4195680<br>rdx            0x7fffffffe4e8   140737488348392<br>rbp            0x7fffffffe3f0   0x7fffffffe3f0<br>rsp            0x7fffffffe3d8   0x7fffffffe3d8<br>r12            0x4003e0 4195296<br>r13            0x7fffffffe4d0   140737488348368<br>r14            0x0      0<br>r15            0x0      0<br>rip            0x40052b 0x40052b &lt;main+35&gt;<br>eflags         0x216    [ PF AF IF ]<br>cs             0x33     51<br>ss             0x2b     43<br>ds             0x0      0<br>es             0x0      0<br>fs             0x0      0<br>gs             0x0      0<br>(gdb) x&#47;24x $rbp<br>0x7fffffffe3f0: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x7fffffffe3f8: 0xd5    0x03    0xa3    0xf7    0xff    0x7f    0x00    0x00<br>0x7fffffffe400: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>(gdb) x&#47;24x ($rbp-24)<br>0x7fffffffe3d8: 0x07    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0x7fffffffe3e0: 0xd0    0xe4    0xff    0xff    0xff    0x7f    0x00    0x00<br>0x7fffffffe3e8: 0x02    0x00    0x00    0x00    0x01    0x00    0x00    0x00<br>从gdb的结果来看，保存了局部变量 调用函数的参数，但是这里不理解的是我的main方法里面只定义了三个局部变量，为什么要分配24字节呢？ 加上传参的4字节应该16字节也够了","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449676,"discussion_content":"6个还是8个以内的调用参数会放在寄存器内而不是stack frame里面。\nX64 下 stack 需要按 16 bytes 做 alignment 可能是导致你需要的空间变成 24 bytes 的原因。这里的 24 bytes 加上你的 8 bytes 的 rbp 正好是 32 bytes 能是16的倍数。\n可以看看这个 stackoverflow 的问题 https://stackoverflow.com/questions/40580914/why-more-space-on-the-stack-frame-is-reserved-than-is-needed-in-x86","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557509618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93482,"user_name":"不系之舟","can_delete":false,"product_type":"c1","uid":1005689,"ip_address":"","ucode":"EC10937D9C031A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/79/e7bbd28e.jpg","comment_is_top":false,"comment_ctime":1557479182,"is_pvip":true,"replies":[{"id":"33425","content":"我这里文字上的确描述有点问题。push rbp压入的之前调用函数的栈帧地址，称为返回地址不太好，叫做调用者栈帧地址？<br><br>call压入的eip&#47;rip或者说PC寄存器里的内容，是下一条指令的地址名叫作返回地址似乎也不太合适？<br>","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557505765,"ip_address":"","comment_id":93482,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18737348366","product_id":100026001,"comment_content":"文章中的&quot;push rbp 就把之前调用函数的返回地址，压到栈顶。&quot;<br><br>感觉这句话有问题，函数的返回地址压到栈顶，应该是call指令做的。","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449650,"discussion_content":"我这里文字上的确描述有点问题。push rbp压入的之前调用函数的栈帧地址，称为返回地址不太好，叫做调用者栈帧地址？\n\ncall压入的eip/rip或者说PC寄存器里的内容，是下一条指令的地址名叫作返回地址似乎也不太合适？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557505765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93393,"user_name":"Spring","can_delete":false,"product_type":"c1","uid":1222211,"ip_address":"","ucode":"8175463FB4705B","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/43/cb6ab349.jpg","comment_is_top":false,"comment_ctime":1557463195,"is_pvip":false,"replies":[{"id":"33412","content":"还需要考虑函数的调用参数传递哦。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557478451,"ip_address":"","comment_id":93393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18737332379","product_id":100026001,"comment_content":"call之后，原函数的bp就会赋值为sp，因此只要把bp压栈就好了，call之后再把之前压栈的bp出栈赋值给sp就好了。<br>函数返回后会把返回值放到ax寄存器，如果有多个返回值的话就将返回值的内存地址放到ax中。<br>因此call之后恢复回原函数还要保存bp和返回值。","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449611,"discussion_content":"还需要考虑函数的调用参数传递哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557478451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93258,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1557448341,"is_pvip":false,"replies":[{"id":"33348","content":"组成是一门牵涉到操作系统、编译、数字电路等很多核心课程的内容。程序加载和链接部分的确和操作系统和编译原理脱不开关系，但是想要深入理解操作系统，还是要专门上一门操作系统的课。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557468490,"ip_address":"","comment_id":93258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18737317525","product_id":100026001,"comment_content":"看了前面这几篇文章，感觉专栏有点倾向操作系统原理更多一些","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449548,"discussion_content":"组成是一门牵涉到操作系统、编译、数字电路等很多核心课程的内容。程序加载和链接部分的确和操作系统和编译原理脱不开关系，但是想要深入理解操作系统，还是要专门上一门操作系统的课。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557468490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146991,"user_name":"tlseek","can_delete":false,"product_type":"c1","uid":1273813,"ip_address":"","ucode":"39956BA395AADF","user_header":"https://static001.geekbang.org/account/avatar/00/13/6f/d5/3e284a71.jpg","comment_is_top":false,"comment_ctime":1572752239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14457654127","product_id":100026001,"comment_content":"说一下个人理解，函数调用的栈是以栈帧单位，调用一个函数就会出现一个栈帧。但汇编指令的push和pop的操作对象并不是栈帧，而是rsp(栈顶指针)。要记住任何对栈操作的指令都会使rsp移动。<br>push rbp是指将rbp的内容（前一个函数的栈基地址）压入栈中，rsp向前移一位。<br>此时rsp指向的当前函数调用的栈基地址，而栈基地址所存放的内容是前一个函数调用的栈基地址。<br>mov rbp, rsp 是将当前函数调用栈基地址设置到rbp中，便于当前函数后续的指令使用。<br>pop rbp 指将rbp所指向的内存的内容（前一个函数栈基地址）移出栈（rsp向后移一位），并将此内容存入rbp中。这时rbp就指向前一个函数的栈基了。","like_count":3},{"had_liked":false,"id":93498,"user_name":"喜欢吃鱼","can_delete":false,"product_type":"c1","uid":1250205,"ip_address":"","ucode":"02F41572F53E3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","comment_is_top":false,"comment_ctime":1557482024,"is_pvip":false,"replies":[{"id":"33426","content":"我猜你遇到的问题是多维数组存储结构带来的Cache Line的性能差异问题？如果是这种情况是因为cache line，CPU从内存加载数据会一个一个Cache Line加载到高速缓存里面。如果是这个问题，我会在后面的高速缓存部分专门讲解这个问题。<br><br>能直接举一段具体的代码吗？<br>","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557505959,"ip_address":"","comment_id":93498,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442383912","product_id":100026001,"comment_content":"徐老师，问您一个和这节内容不是很相关的一个问题可以吗？<br>为什么在写多重for循环的时候，循环次数多的大循环要写里面，小循环写外面？<br>希望老师解答下，非常感谢！！！","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449662,"discussion_content":"我猜你遇到的问题是多维数组存储结构带来的Cache Line的性能差异问题？如果是这种情况是因为cache line，CPU从内存加载数据会一个一个Cache Line加载到高速缓存里面。如果是这个问题，我会在后面的高速缓存部分专门讲解这个问题。\n\n能直接举一段具体的代码吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557505959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93470,"user_name":"上五楼的快活","can_delete":false,"product_type":"c1","uid":1219564,"ip_address":"","ucode":"99E4477B4BA595","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/ec/f16470a0.jpg","comment_is_top":false,"comment_ctime":1557476371,"is_pvip":false,"replies":[{"id":"33403","content":"留言区就是大家的学习小组。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557476627,"ip_address":"","comment_id":93470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442378259","product_id":100026001,"comment_content":"老师您好，刚订阅，在哪儿加学习小组","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449644,"discussion_content":"留言区就是大家的学习小组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557476627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93318,"user_name":"吴宇晨","can_delete":false,"product_type":"c1","uid":1199968,"ip_address":"","ucode":"F8F45B7067DF6D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg","comment_is_top":false,"comment_ctime":1557452047,"is_pvip":false,"replies":[{"id":"33409","content":"吴宇晨同学你好，调用方的栈地址是在他自己被调用的时候已经压栈了呀，可以再回头去看一下csapp。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557477951,"ip_address":"","comment_id":93318,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442353935","product_id":100026001,"comment_content":"我记得应该还要保存调用方的栈地址，调用结束才能还原栈，csapp之前看了，但是平常接触不到这些知识，都忘的差不多了😅😅","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449581,"discussion_content":"吴宇晨同学你好，调用方的栈地址是在他自己被调用的时候已经压栈了呀，可以再回头去看一下csapp。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557477951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93306,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1557451449,"is_pvip":false,"replies":[{"id":"33355","content":"👍","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557469074,"ip_address":"","comment_id":93306,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442353337","product_id":100026001,"comment_content":"Push rbp, move rpb rsp,以前一直不知道这两句的含义，现在清楚了","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449574,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557469074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93286,"user_name":"@我","can_delete":false,"product_type":"c1","uid":1239383,"ip_address":"","ucode":"91B91000195513","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/57/68e414ba.jpg","comment_is_top":false,"comment_ctime":1557450172,"is_pvip":false,"replies":[{"id":"33404","content":"是存到寄存器或者栈里面的，如果寄存器里面存不下，就会放到栈帧里面去。<br><br>多线程情况下，每个线程有自己的栈。但是线程切换是context switch，这个和函数调用并不相同。context switch通常要解决的是把当前现场中的其他信息保留下来，比如寄存器里面的内容等等，而不是做一次压栈。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557476833,"ip_address":"","comment_id":93286,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442352060","product_id":100026001,"comment_content":"还要保护现场，保护现场的变量值也是存到系统栈里面的？多线程切换的话，是不是也要存到自己线程对应的栈里面？","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449563,"discussion_content":"是存到寄存器或者栈里面的，如果寄存器里面存不下，就会放到栈帧里面去。\n\n多线程情况下，每个线程有自己的栈。但是线程切换是context switch，这个和函数调用并不相同。context switch通常要解决的是把当前现场中的其他信息保留下来，比如寄存器里面的内容等等，而不是做一次压栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557476833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93263,"user_name":"matter","can_delete":false,"product_type":"c1","uid":1517718,"ip_address":"","ucode":"260BAE6D7F7870","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/96/a49c7264.jpg","comment_is_top":false,"comment_ctime":1557448715,"is_pvip":false,"replies":[{"id":"33354","content":"matter同学你好，你的理解是对的，真实的栈的增长和分配地址是由大地址到小地址，所以其实和桶相比是倒过来的。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557469052,"ip_address":"","comment_id":93263,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14442350603","product_id":100026001,"comment_content":"实际的程序栈，顶和底跟乒乓球桶是相反的这个点我读了两遍，还没有太清楚含义。是不是指的分配栈地址的时候，分配的是一定大小的内存空间，比如从1a到3f，而第一次压栈操作存储的地址是3f而不是1a，是这样吗老师","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449552,"discussion_content":"matter同学你好，你的理解是对的，真实的栈的增长和分配地址是由大地址到小地址，所以其实和桶相比是倒过来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557469052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621946,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bf/ba/b6eda99b.jpg","nickname":"崎玉せんせい","note":"","ucode":"834285B99E3EDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374360,"discussion_content":"其实可以补充说明一下，不同的CPU架构下，栈的设计可能是不一样的，x86的栈是向下增长，arm可以向下增长也可以向上增长，这样大家可能会清晰一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621150761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180556,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1582336175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172270767","product_id":100026001,"comment_content":"第一个问题：什么是栈，栈就是一种数据结构，先入后出，后入先出。比如食堂里装菜的盘子，买菜的时候师傅一定是先拿最上面，但是这一些盘子里，一定是最下边的先摆上的，这个就是一个非常典型的栈结构。 第二个问题：程序中函数是怎么调用函数的，最简单的理解就是被调用的函数先将调用者的入口地址压栈，等函数执行完成完成再出栈，这样可以理解成从哪里来的再回到哪里去。 第三个问题：栈溢出是怎么发生的，无限调用函数，或者让一个函数无限调用自己，由于不断的压栈，内存CPU都是有限的，当达到容量的边界后，再压栈自然就溢出了。","like_count":2},{"had_liked":false,"id":178753,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1581817239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171751831","product_id":100026001,"comment_content":"函数调用和跳转的不同在于，是否保存当前执行地址。<br>函数调用是要保存当前执行地址，而且函数调用可以有嵌套结构，嵌套的顺序是后进先出，这种结构天然适合栈这种数据结构。照理说栈只需要一个寄存器指向栈顶即可。这里用了rsp和rbp两个寄存器，我猜测的原因在于需要一个寄存器存储跳转的地址，rbp就是栈顶保存的地址，rsp则是新的跳转地址。新来一个函数调用，只要将rbp压入内存栈（类似于拷贝，但是比起拷贝来，这里可以按照栈的顺序拷贝多份，将来出栈,按照后进先出的顺序回到rbp寄存器），再将rsp拷贝到rbp，这样栈顶就指向新的跳转地址，所有的偏移量都是以这个地址为基础。函数调用完毕，pop指令将上一层函数暂停执行的地址从内存栈中copy到rbp寄存器，同时清除内存栈中对应的项，这样程序就可以在上一次函数暂停的地方继续执行。内存栈维护着从最外层函数到这个函数每一层暂停点的地址，把整个线性的结构有序的分成多个部分，每一部分处理一层函数。<br>普通跳转指令没用到寄存器，跳转地址是作为参数传递的。","like_count":2},{"had_liked":false,"id":156574,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1574916262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10164850854","product_id":100026001,"comment_content":"1.程序栈的概念其实很简单，但是要放在组成里学习，总是说不出哪里怪怪的<br>2.关于指令的内容，讲了这三节，总结下来也就是跳转，数据，运算，逻辑这些指令类别。其中跳转是作者着重讲解的内容，也是最有意思的地方，跳转是实现复杂逻辑的根本，万变不离本<br>3. 除了无限递归，递归层数过深，在栈空间里面创建非常占内存的变量（比如一个巨大的数组），这些情况都很可能给你带来 stack  overflow。","like_count":2},{"had_liked":false,"id":144077,"user_name":"杨涛","can_delete":false,"product_type":"c1","uid":1082978,"ip_address":"","ucode":"2B6B6AEFFB54A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/86/62/22e9aeb0.jpg","comment_is_top":false,"comment_ctime":1571840274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10161774866","product_id":100026001,"comment_content":"栈帧可以看看这个https:&#47;&#47;www.cnblogs.com&#47;ysocean&#47;p&#47;7625917.html","like_count":2},{"had_liked":false,"id":96401,"user_name":"愤怒的虾干","can_delete":false,"product_type":"c1","uid":1266043,"ip_address":"","ucode":"CEBD1B2BE7BCEE","user_header":"https://static001.geekbang.org/account/avatar/00/13/51/7b/191a2112.jpg","comment_is_top":false,"comment_ctime":1558409259,"is_pvip":false,"replies":[{"id":"35505","content":"愤怒的虾干同学你好，<br><br>中断不是函数调用啊。不过中断的确会对cs,ip进行压栈，以及保存flags寄存器。但是函数调用虽然对于ip会进行压栈，但是并不需要取清理条件码寄存器，也就是flags寄存器的状态，也不需要对于cs进行压栈。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559128314,"ip_address":"","comment_id":96401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10148343851","product_id":100026001,"comment_content":"我记得在中断处理时，需要保护现场，将cs、ip寄存器压栈，保存Flags寄存器，清除中断标识，然后跳转到中断处理命令；推广开来方法调用也需要将cs、ip寄存器压栈，保存调用前Flags寄存器状态，清除Flags寄存器的标识。老师，是这样吗？","like_count":2,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450867,"discussion_content":"愤怒的虾干同学你好，\n\n中断不是函数调用啊。不过中断的确会对cs,ip进行压栈，以及保存flags寄存器。但是函数调用虽然对于ip会进行压栈，但是并不需要取清理条件码寄存器，也就是flags寄存器的状态，也不需要对于cs进行压栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559128314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332626,"user_name":"侠女马姑娘","can_delete":false,"product_type":"c1","uid":1139886,"ip_address":"","ucode":"4F25009CCFBF71","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/ae/6a4cb64c.jpg","comment_is_top":false,"comment_ctime":1643419026,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5938386322","product_id":100026001,"comment_content":"mark 一下，2022年1月29日，组成原理的学习进入懵逼状态。咬牙继续听。","like_count":1},{"had_liked":false,"id":291265,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1620175585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5915142881","product_id":100026001,"comment_content":"说下个人理解：<br>当main函数调用add函数的时候 在汇编代码中  push rbp 就是保留了 调用者的栈帧信息（main）然后接下来的 mov rbp  rsp ，因为此时rbp还是main的 刚刚只是做了一次压栈的操作保存了信息，所以rsp会后移一位 这里说明一下，对于每一次push操作，rsp储存的地址会-1）。那么这样一来的话，相当于调用者栈帧的栈顶现在作为了新的栈帧的栈底（并且该栈底保存的是调用者栈帧的栈底地址，请记住这一点）而此时新的栈帧的栈底和栈底位于同一个位置。 接下来rbp就是独立的栈帧了 和main隔离开了 就可以访问自己的独立变量 以及做一些操作 保持了隔离性","like_count":1},{"had_liked":false,"id":250626,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1601176832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5896144128","product_id":100026001,"comment_content":"这课程太值了，好实在啊。从汇编语言角度，理解了程序如何执行，从顺序执行，到分支执行，循环执行，到这一节的函数调用，从根本上理解了底层机制。第一次对底层原理产生兴趣，从害怕转变成了欲罢不能。","like_count":1},{"had_liked":false,"id":237852,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1595986884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890954180","product_id":100026001,"comment_content":"chrome V8里也有函数内联的概念，没想到是和寄存器函数内联一样。","like_count":1},{"had_liked":false,"id":94133,"user_name":"passenger","can_delete":false,"product_type":"c1","uid":1528419,"ip_address":"","ucode":"E45D739EA6A8AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/63/9dd2c265.jpg","comment_is_top":false,"comment_ctime":1557728819,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5852696115","product_id":100026001,"comment_content":"main函数调用add函数的时候，栈里面顺序是不是<br>从底到顶：<br>main函数的rbp<br> 一些大变量<br>下一条指令地址<br>add函数的rbp<br>？<br>rbp是不是告诉我们这个函数从这开始，之后要压入栈的变量都是从这个地址开始的。","like_count":1,"discussions":[{"author":{"id":1310995,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/eyKgpIVFSDQBia7SJRVUKFh5qgwc3ohzEPSKvchLf9ZvwIO9CrS470ER7OhNzWTs0svECHCBiarQTa41BO3Hf0DA/132","nickname":"Temme","note":"","ucode":"BCBA3A5570216A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149751,"discussion_content":"在pop rbp发生之前从底到顶\nmain函数栈帧栈底\n算上栈底后四字节存第一个变量\n再四字节第二个变量\n空8字节(因为sub改了栈顶，之后还有变量用到，保存add函数返回结果)\n存函数调用结束之后下一个指令的地址\n存main函数栈帧栈底的地址\nadd函数栈帧栈底(当前的栈顶)\n算上add栈底后四字节存变量，函数当中的局部变量\n然后再四个字节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579777418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93616,"user_name":"不系之舟","can_delete":false,"product_type":"c1","uid":1005689,"ip_address":"","ucode":"EC10937D9C031A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/79/e7bbd28e.jpg","comment_is_top":false,"comment_ctime":1557536646,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5852503942","product_id":100026001,"comment_content":"老师可以考虑讲述下callee和caller的关系，这样描述返回地址和ebp应该会清晰点。","like_count":1},{"had_liked":false,"id":93582,"user_name":"run","can_delete":false,"product_type":"c1","uid":1510539,"ip_address":"","ucode":"67F4B1542C322C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYPpOWCGE1M4IDya3raE3KDDLFmGNMIlhbOLtibmy6KIKtnoYPcg4W195zicfb1f2k5TGNxRULgmNQ/132","comment_is_top":false,"comment_ctime":1557505058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852472354","product_id":100026001,"comment_content":"既然call做了保存返回地址的事情那push rbp, mov rpb rsp这两条指令还做什么呢？文中对这两句话的讲解看不太懂","like_count":1},{"had_liked":false,"id":93552,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1557494183,"is_pvip":false,"replies":[{"id":"33434","content":"寄存器里面的数据并不一定要放到stack frame里面。stack frame里面必须放的一般包括调用函数里的临时&#47;本地变量。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557509678,"ip_address":"","comment_id":93552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852461479","product_id":100026001,"comment_content":"在程序栈里面，除了我们跳转前的指令地址外，还需要保留CPU通用寄存器的中的数据","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449677,"discussion_content":"寄存器里面的数据并不一定要放到stack frame里面。stack frame里面必须放的一般包括调用函数里的临时/本地变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557509678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93490,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1557480037,"is_pvip":false,"replies":[{"id":"33431","content":"https:&#47;&#47;linux.die.net&#47;man&#47;1&#47;objdump<br><br>-M 代表选反汇编之后指令的表示形式，一般linux下可以选intel或者att，默认好像是att。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557508622,"ip_address":"","comment_id":93490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852447333","product_id":100026001,"comment_content":"问一个问题，我看老师objdump -M intel 这里-M的参数 intel是根据什么规则去选的呢？ 我看过man objdump还是不知道怎么指定","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449655,"discussion_content":"https://linux.die.net/man/1/objdump\n\n-M 代表选反汇编之后指令的表示形式，一般linux下可以选intel或者att，默认好像是att。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557508622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93380,"user_name":"喜欢吃鱼","can_delete":false,"product_type":"c1","uid":1250205,"ip_address":"","ucode":"02F41572F53E3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/9d/d91dc762.jpg","comment_is_top":false,"comment_ctime":1557460285,"is_pvip":false,"replies":[{"id":"33352","content":"我推测是不是你在调用gcc的时候，没有开启 -O 参数来开启编译器优化？<br>gcc -g -c -O function_example_inline.c","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557468744,"ip_address":"","comment_id":93380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852427581","product_id":100026001,"comment_content":"老师，为什么我把add函数变为inline函数之后，objdump出来的调用add处的汇编指令还是：call   25 &lt;main+0x25&gt;<br>","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449606,"discussion_content":"我推测是不是你在调用gcc的时候，没有开启 -O 参数来开启编译器优化？\ngcc -g -c -O function_example_inline.c","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557468744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93365,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1557456814,"is_pvip":true,"replies":[{"id":"33411","content":"Better me，抱歉，我没太理解，这是一个提问么？","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557478304,"ip_address":"","comment_id":93365,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852424110","product_id":100026001,"comment_content":"rbp、rsp是如何管理函数之间的调用的","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449598,"discussion_content":"Better me，抱歉，我没太理解，这是一个提问么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557478304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93347,"user_name":"免费的人","can_delete":false,"product_type":"c1","uid":1032106,"ip_address":"","ucode":"2B12D8ED63C564","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/aa/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1557454938,"is_pvip":false,"replies":[{"id":"33408","content":"答案不太对哦，除了返回地址之外，这些都是不用在调用前单独压栈的，可以再搜索看看其他资料再来回答这个问题。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557477117,"ip_address":"","comment_id":93347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852422234","product_id":100026001,"comment_content":"思考题：函数返回值、返回地址、sp bp","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449592,"discussion_content":"答案不太对哦，除了返回地址之外，这些都是不用在调用前单独压栈的，可以再搜索看看其他资料再来回答这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557477117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93256,"user_name":"ezra.xu","can_delete":false,"product_type":"c1","uid":1014005,"ip_address":"","ucode":"6C3E11889BC6AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/f5/ae200a94.jpg","comment_is_top":false,"comment_ctime":1557448294,"is_pvip":false,"replies":[{"id":"33347","content":"👍可以谈谈执行状态里面包含了哪些信息呢？","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1557468406,"ip_address":"","comment_id":93256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852415590","product_id":100026001,"comment_content":"除了函数调用的返回地址，应该还有当前函数的执行状态需要保存。","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449547,"discussion_content":"👍可以谈谈执行状态里面包含了哪些信息呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557468406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358067,"user_name":"Rock_yan","can_delete":false,"product_type":"c1","uid":3074990,"ip_address":"天津","ucode":"86206B4A04B702","user_header":"","comment_is_top":false,"comment_ctime":1663890517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663890517","product_id":100026001,"comment_content":"rdp变成了最新的栈顶，rsp始终会指向栈顶。这个描述的怎么有两个栈顶。rdp应该是最新的栈低吧，也就是add函数的栈低。","like_count":0},{"had_liked":false,"id":356982,"user_name":"Nuvole Bianche","can_delete":false,"product_type":"c1","uid":2100301,"ip_address":"上海","ucode":"3C059A454C16C7","user_header":"https://static001.geekbang.org/account/avatar/00/20/0c/4d/90ab20d8.jpg","comment_is_top":false,"comment_ctime":1662788577,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662788577","product_id":100026001,"comment_content":"“把一个实际调用的函数产生的指令，直接插入到的位置，来替换对应的函数调用指令。”   个人感觉更明确的说法是：“把一个实际调用的函数产生的指令（主）替换掉（谓）原来的34行call指令对应的（定）代码（宾）”  这个插入又替换的描述有些累赘甚至影响理解了。","like_count":0},{"had_liked":false,"id":355741,"user_name":"Geek_d07ee1","can_delete":false,"product_type":"c1","uid":3165831,"ip_address":"河南","ucode":"D0EA6988EE0FCB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjbPAydn9KYzGqea5grOXibIF72GcicoyYcwqS1XRosZV0Ov0KB6MtgsRf3YuI4iaXT27gwQXXgQxqQ/132","comment_is_top":false,"comment_ctime":1661708316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661708316","product_id":100026001,"comment_content":"老师你好，想问一下文章里只提到了当调用函数的时候会将返回地址和参数压入栈中，那么局部变量存在哪里呢？和地址存在一起吗？","like_count":0},{"had_liked":false,"id":354815,"user_name":"蜘蛛侠","can_delete":false,"product_type":"c1","uid":3053481,"ip_address":"河南","ucode":"B59D7255BAD55B","user_header":"https://static001.geekbang.org/account/avatar/00/2e/97/a9/e3b097f1.jpg","comment_is_top":false,"comment_ctime":1660803425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660803425","product_id":100026001,"comment_content":"mov：数据传输指令，push： 把字压入堆栈，pop：把字弹出堆栈","like_count":0},{"had_liked":false,"id":346678,"user_name":"致远","can_delete":false,"product_type":"c1","uid":1107201,"ip_address":"","ucode":"ABB939F557D708","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/01/617de42c.jpg","comment_is_top":false,"comment_ctime":1653357592,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653357592","product_id":100026001,"comment_content":"看得懵逼，倒数第二个图，表格上面是栈顶还是栈底？","like_count":0},{"had_liked":false,"id":342997,"user_name":"Geek_080ce7","can_delete":false,"product_type":"c1","uid":2924187,"ip_address":"","ucode":"C74D97C84983B9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/SluScDGqnhBNwmOQ774QEzuXiazk8Ab7ng8xCT81gunl9Hls9oibwB4AibCDxDtZwTe4mEib5QiaLXUqMv8iceXicXSYg/132","comment_is_top":false,"comment_ctime":1650588644,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650588644","product_id":100026001,"comment_content":"有一个问题想问一下，就是函数在进行跳转的时候，pc是怎么知道下一个跳转地址的？因为跳转不是顺序执行的，不能依靠自增，那这个偏移量是什么时候算好的？","like_count":0},{"had_liked":false,"id":342760,"user_name":"三株树","can_delete":false,"product_type":"c1","uid":2854832,"ip_address":"","ucode":"C1AF11387E7CD8","user_header":"https://static001.geekbang.org/account/avatar/00/2b/8f/b0/cfeced1d.jpg","comment_is_top":false,"comment_ctime":1650449657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650449657","product_id":100026001,"comment_content":"传入的参数，定义的局部变量","like_count":0},{"had_liked":false,"id":335665,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1645617708,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645617708","product_id":100026001,"comment_content":"思考题：需要存PC地址（用于返回原函数）、增加的rsp大小（用于计算需要删除的栈帧大小）","like_count":0},{"had_liked":false,"id":335662,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1645617134,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645617134","product_id":100026001,"comment_content":"徐老师，function_example_inline.c中的代码，13 15 16行最后需要加下分号","like_count":0},{"had_liked":false,"id":335001,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1640556,"ip_address":"","ucode":"C8CB775680F0AF","user_header":"","comment_is_top":false,"comment_ctime":1645249705,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645249705","product_id":100026001,"comment_content":"每种编程语言都会编译成机器码，那不同的语言的主要区别是什么?","like_count":0},{"had_liked":false,"id":335000,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1640556,"ip_address":"","ucode":"C8CB775680F0AF","user_header":"","comment_is_top":false,"comment_ctime":1645249573,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645249573","product_id":100026001,"comment_content":"v8与jvm的区别?","like_count":0},{"had_liked":false,"id":334993,"user_name":"张翔","can_delete":false,"product_type":"c1","uid":1814438,"ip_address":"","ucode":"2EB1282C526A02","user_header":"https://static001.geekbang.org/account/avatar/00/1b/af/a6/cbc4bf59.jpg","comment_is_top":false,"comment_ctime":1645244894,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645244894","product_id":100026001,"comment_content":"可以配合阮一峰老师这篇汇编语言入门教程：https:&#47;&#47;www.ruanyifeng.com&#47;blog&#47;2018&#47;01&#47;assembly-language-primer.html","like_count":0},{"had_liked":false,"id":333971,"user_name":"何同一","can_delete":false,"product_type":"c1","uid":2637195,"ip_address":"","ucode":"3270B66A34F29A","user_header":"https://static001.geekbang.org/account/avatar/00/28/3d/8b/47bcc851.jpg","comment_is_top":false,"comment_ctime":1644645187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644645187","product_id":100026001,"comment_content":"根据二进制 abi, 调用者在调用函数前需要保存 rax, rcx, rdx 寄存器，而被调用的函数如果用到了 rbx, rsi, rdi, rbp 寄存器也需要先进行保存","like_count":0},{"had_liked":false,"id":327229,"user_name":"KimZing","can_delete":false,"product_type":"c1","uid":1126442,"ip_address":"","ucode":"2E6854614BD92C","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2a/30354f00.jpg","comment_is_top":false,"comment_ctime":1639991923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639991923","product_id":100026001,"comment_content":"这节对于没有基础的同学不是太友好(我)，可以参考这篇文章进行辅助阅读https:&#47;&#47;blog.csdn.net&#47;ABo_Zhang&#47;article&#47;details&#47;89668046。里面解释了栈的形象化结构，以及为什么最后一个函数为什么没有扩展esp。如果还是看不懂，可以再辅助以下几篇文章进行阅读理解：<br>https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;446344416<br>https:&#47;&#47;my.oschina.net&#47;tsh&#47;blog&#47;1475209。","like_count":0},{"had_liked":false,"id":324480,"user_name":"one_piece","can_delete":false,"product_type":"c1","uid":1549113,"ip_address":"","ucode":"9CF2835BDE864C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibYibX2VeJicH7FxNmrz94cxYFE4y3NrZBiamlZ4icqVfhMAXgZAHlb97UXfUWqvnQtzpEQYSkIPem8G86ANur6aVOQ/132","comment_is_top":false,"comment_ctime":1638452995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638452995","product_id":100026001,"comment_content":"我想问下老师，我们在调用第 34 行的 call 指令时，会把当前的 PC 寄存器里的下一条指令的地址压栈，这里的下一条指令是指哪条指令？","like_count":0},{"had_liked":false,"id":317361,"user_name":"希言自然","can_delete":false,"product_type":"c1","uid":1736720,"ip_address":"","ucode":"8D99A82B05636B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/80/10/2406a662.jpg","comment_is_top":false,"comment_ctime":1634773199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634773199","product_id":100026001,"comment_content":"好难啊，第一遍过了还是懵逼状态，看来要反复看了。。。","like_count":0},{"had_liked":false,"id":313251,"user_name":"Geek_ee3685","can_delete":false,"product_type":"c1","uid":2750366,"ip_address":"","ucode":"2E0D5A064F5619","user_header":"","comment_is_top":false,"comment_ctime":1632330471,"is_pvip":false,"replies":[{"id":"113910","content":"call本身就会压栈，你可以把call看成一个原子化了的push+jmp","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1633162734,"ip_address":"","comment_id":313251,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632330471","product_id":100026001,"comment_content":"老师 您说在调用call的时候 需要把pc寄存器的指令压栈  这是在哪段代码体现的 push rbp 吗？","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527292,"discussion_content":"call本身就会压栈，你可以把call看成一个原子化了的push+jmp","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633162734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305772,"user_name":"Geek_337e21","can_delete":false,"product_type":"c1","uid":2274627,"ip_address":"","ucode":"D51F99290C30C8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyNezT33TyZdPI8DtRe7LzV9geutjMkaNNByOkyMXhNQVia5CJE54lWrBpicftq7jdo8bCcXhokjUQ/132","comment_is_top":false,"comment_ctime":1628154498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628154498","product_id":100026001,"comment_content":"前一个函数的局部变量值，打开的文件句柄，错误变量的设置（error）。","like_count":0},{"had_liked":false,"id":305375,"user_name":"Geek_8a0a23","can_delete":false,"product_type":"c1","uid":1140565,"ip_address":"","ucode":"605C1750C59918","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKkfZpMx6JDjRiaa51DWRtncfQOy8Lblia1XkeIsXiccTG1nIKyaSic01H0IXgHM3KPSYJ1x51avblJAg/132","comment_is_top":false,"comment_ctime":1627952100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627952100","product_id":100026001,"comment_content":"😀","like_count":0},{"had_liked":false,"id":297587,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1623655412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623655412","product_id":100026001,"comment_content":"这里的 rbp 又叫栈帧指针（Frame Pointer），是一个存放了当前栈帧位置的寄存器。push rbp 就把之前调用函数，也就是 main 函数的栈帧的栈底地址，压到栈顶<br><br>这里的栈底地址是什么？","like_count":0},{"had_liked":false,"id":296315,"user_name":"杰良","can_delete":false,"product_type":"c1","uid":2567349,"ip_address":"","ucode":"5DC1D1C58A4731","user_header":"https://static001.geekbang.org/account/avatar/00/27/2c/b5/10141329.jpg","comment_is_top":false,"comment_ctime":1622895886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622895886","product_id":100026001,"comment_content":"为了实现函数的调用与返回功能，需要在内存空间开辟一个栈空间，用于记录调用前、调用参数，以及调用执行时的临时变量等信息。调用与返回使用的指令分别是 call，ret。","like_count":0},{"had_liked":false,"id":291801,"user_name":"昨日火冷啊","can_delete":false,"product_type":"c1","uid":1215103,"ip_address":"","ucode":"126A583CCF9E91","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/7f/fcb659b7.jpg","comment_is_top":false,"comment_ctime":1620494912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620494912","product_id":100026001,"comment_content":"老师，c++中使用lambda函数与一般方法调用函数有什么区别调用？在参数捕获的时候是什么原理？哪里能找到相关资料？","like_count":0},{"had_liked":false,"id":287243,"user_name":"巴洛克先生","can_delete":false,"product_type":"c1","uid":1221305,"ip_address":"","ucode":"FFE5FB80147E02","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/b9/2b9e419e.jpg","comment_is_top":false,"comment_ctime":1617852381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617852381","product_id":100026001,"comment_content":"(__TEXT,__text) section<br>_main:<br>0000000000000000\tpushq\t%rbp<br>0000000000000001\tmovq\t%rsp, %rbp<br>0000000000000004\tsubq\t$0x10, %rsp<br>0000000000000008\tmovl\t$0x5, -0x4(%rbp)<br>000000000000000f\tmovl\t$0xa, -0x8(%rbp)<br>0000000000000016\tmovl\t-0x4(%rbp), %edi<br>0000000000000019\tmovl\t-0x8(%rbp), %esi<br>000000000000001c\tcallq\t0x21<br>0000000000000021\txorl\t%ecx, %ecx<br>0000000000000023\tmovl\t%eax, -0xc(%rbp)<br>0000000000000026\tmovl\t%ecx, %eax<br>0000000000000028\taddq\t$0x10, %rsp<br>000000000000002c\tpopq\t%rbp<br>000000000000002d\tretq<br>000000000000002e\tnop<br>_add:<br>0000000000000030\tpushq\t%rbp<br>0000000000000031\tmovq\t%rsp, %rbp<br>0000000000000034\tmovl\t%edi, -0x4(%rbp)<br>0000000000000037\tmovl\t%esi, -0x8(%rbp)<br>000000000000003a\tmovl\t-0x4(%rbp), %eax<br>000000000000003d\taddl\t-0x8(%rbp), %eax<br>0000000000000040\tpopq\t%rbp<br>0000000000000041\tretq<br><br>不明白为什么callq是0x21 不应该是0030吗","like_count":0},{"had_liked":false,"id":284661,"user_name":"ysh","can_delete":false,"product_type":"c1","uid":1113305,"ip_address":"","ucode":"17D1994A7D5DA6","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/d9/8483510b.jpg","comment_is_top":false,"comment_ctime":1616407773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616407773","product_id":100026001,"comment_content":"push rbp<br>move rbp，rsp<br>许多同学不明白这里的意思，每个函数开头都有，其实在call，ret的指令执行时会同时压栈和出栈调用地址了，上面这两个指令其实是为了维护当前函数的栈帧高低两个地址，因为寄存器是有限的，cpu内只能维护当前的高低地址，而每个函数的栈帧开头都有rbp这个地址，弹出栈的时候就能知道下一个栈帧的起始地址","like_count":0},{"had_liked":false,"id":284431,"user_name":"S","can_delete":false,"product_type":"c1","uid":2436407,"ip_address":"","ucode":"E88F6A338F34A6","user_header":"https://static001.geekbang.org/account/avatar/00/25/2d/37/f8733b67.jpg","comment_is_top":false,"comment_ctime":1616246593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616246593","product_id":100026001,"comment_content":"老师，最近遇到两个问题希望老师能从用一章的知识解答一下（本人想不通，网上也没有详细的解释）。<br>问题1.<br>std::string func1()<br>{<br><br>}<br><br>std::string func2(std::string &amp; str)<br>{<br><br>}<br><br>int main()<br>{<br>\tstd::string s = func1();<br>\tfunc2(s);<br>}<br>定义一个返回类型为string的函数，但没有return返回值，有的编译器上面的程序是能编译过的。为什么func1函数运行后程序会挂掉？<br><br>问题2：<br>void func()<br>{<br>\tchar buf[3] = {0};<br>\trecv(buf, 6);\t&#47;&#47;从网络接收32字节数据<br><br>\tstd::string s = buf;<br>\tcout &lt;&lt; s &lt;&lt; endl;<br>}<br><br>int main()<br>{<br>\tfunc();<br><br>\treturn 0;<br>}<br>当buf长度为16字节，却从网络接收到32字节数据（假如接收到的数据为&quot;123456&quot;）。并赋值给s，s能正常打印出&quot;123456&quot;来。但fun函数运行完后也会挂掉。为什么打印s的时候程序不挂？而等到func函数运行完后才会挂掉？","like_count":0},{"had_liked":false,"id":280776,"user_name":"NULL","can_delete":false,"product_type":"c1","uid":2445698,"ip_address":"","ucode":"E5F7807C3642A8","user_header":"https://static001.geekbang.org/account/avatar/00/25/51/82/017b9ff4.jpg","comment_is_top":false,"comment_ctime":1614363410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614363410","product_id":100026001,"comment_content":"请问在 main() 函数调用时，push rbp 这时的 rbp 中保存的是什么呢？希望作者能够回答以下，感谢","like_count":0},{"had_liked":false,"id":280683,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1132157,"ip_address":"","ucode":"318D052B7C329A","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/7d/f4715d46.jpg","comment_is_top":false,"comment_ctime":1614317033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614317033","product_id":100026001,"comment_content":"老师，请问下“而一层层压栈之后，栈顶的内存地址是在逐渐变小而不是变大。”这个内存地址为啥会逐渐变小？","like_count":0},{"had_liked":false,"id":272443,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":2403865,"ip_address":"","ucode":"2EA3B9DBF5821C","user_header":"https://static001.geekbang.org/account/avatar/00/24/ae/19/5f2d96ce.jpg","comment_is_top":false,"comment_ctime":1610091860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610091860","product_id":100026001,"comment_content":"经过搜索和学习，我大概理清了整个程序栈的调用过程，总结一下我的理解。<br>比如这个程序<br>int add(int a, int b)<br>{<br>    int result = a + b;<br>    return result;<br>}<br><br>int main(int argc)<br>{<br>    int answer;<br>    answer = add(40, 2);<br>}<br><br>首先，运行该程序的第一段代码是运行C runtime library， 然后才会调用main函数，然后调用add函数。那么一开始rbp指向的是NULL，对于main函数这个栈帧(stack frame)，首先被压入栈中的是它的形参argc = 1（假设我们在command line没有传入参数）。然后call main，会把lib start_main函数的返回地址压入栈中。然后是main函数的prologue：push rbp; mov rbp rsp;把rbp=NULL压入栈中。然后rbp和rsp指向同一位置，即栈顶，记住，这个位置就是main函数的栈帧的栈底位置了，接下来直到遇到新的rbp的位置前的这一段都算是main函数的栈帧内容。然后执行sub rsp, 0x18，挪动栈顶指针，为了给main函数里的local variables分配空间。接下的是一些赋值。然后到了call 0 &lt;add&gt;。此时，同样的，第一步操作是把要返回的main函数中的地址先入栈，然后进入add函数。执行add函数的prologue: push rbp; move rbp, rsp。进行计算，最后返回值一定要mov给eax这个寄存器，因为eax就是用来保存函数返回值的。最后add函数里会执行它的epilogues: pop rbp; ret。这两句，其实此时rsp的位置并不是真的就是栈顶，它的位置是和rpb一致。比它更小的地址还有我们刚才用于计算分配的地址，但是我们并没有在add函数里调用过sub rsp, 0x18这类移动栈顶指针的指令，这是一个细节。有人以为rsp无时无刻不在栈顶，其实不然。那么此时rsp, rbp都指向saved rbp位置。pop rbp会让rbp指向main函数的栈帧的栈底位置。同时既然pop了，rsp移动一个单位，指向ret address: main: 34。然后ret会继续pop该返回地址给PC寄存器(rip)。然后就返回到main函数里了。同样的操作。进行main函数的epilogues。<br><br>其实，这段内容需要自己去搜索学习一下，栈帧是什么？是包括了3个寄存器,rbp, rsp, eax，还有local variables, saved rbp, return address, params等等，不仅仅是一个返回地址。然后理清流程。","like_count":0},{"had_liked":false,"id":269361,"user_name":"木有昵称","can_delete":false,"product_type":"c1","uid":1002120,"ip_address":"","ucode":"AE358BD65DC33A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/88/93b31e00.jpg","comment_is_top":false,"comment_ctime":1608623686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608623686","product_id":100026001,"comment_content":"但是如果被调用的函数里，没有调用其他函数，这个方法还是可以行得通的。<br><br>老师，这句话怎么理解？如果被调用函数里面还有对其他函数的调用，会有问题么？","like_count":0},{"had_liked":false,"id":264925,"user_name":"IDo","can_delete":false,"product_type":"c1","uid":1026204,"ip_address":"","ucode":"BCF7BFBE35E390","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/9c/91dc7fc4.jpg","comment_is_top":false,"comment_ctime":1606707877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606707877","product_id":100026001,"comment_content":"不熟悉x86，我直接用aarch64的编译器编译作者的代码看的。","like_count":0},{"had_liked":false,"id":255054,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1603259657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603259657","product_id":100026001,"comment_content":"以前只是想到在调用函数的时候，需要在栈中开辟一段内存，入栈一个“调用”，但从没想过函数内联可以优化性能。<br>这样对 Java 虚拟机中函数内联的 JIT 优化有了更深一层的理解了。","like_count":0},{"had_liked":false,"id":253647,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1602818743,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602818743","product_id":100026001,"comment_content":"“在栈空间里面创建非常占内存的变量（比如一个巨大的数组），这些情况都很可能给你带来 stack overflow”，这句话，老师，数据可不会占用栈空间哈，数组是可以根据下标获取值的，这是堆的功能哈","like_count":0,"discussions":[{"author":{"id":1132542,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/fe/f2ce12cd.jpg","nickname":"Leosocy","note":"","ucode":"5E076D6B981F84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331032,"discussion_content":"不是new出来的局部变量应该都存在栈空间吧？楼主是不是想说java啊。另外数组可以根据下标获取是因为存储在连续的内存空间，跟在堆上还是栈上无关哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606748990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253597,"user_name":"Geek_ca540c","can_delete":false,"product_type":"c1","uid":1903258,"ip_address":"","ucode":"DA56EE2C0CD480","user_header":"","comment_is_top":false,"comment_ctime":1602809441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602809441","product_id":100026001,"comment_content":"文中 提到的&quot;在所有函数调用返回之前，每一次调用的返回地址都要记录下来，但是我们 CPU 里的寄存器数量并不多。&quot; 和 栈存储的方法，两者的共同点: 都会存储每次调用的返回地址，不同点是:栈会在使用完该地址之后及时删除，但是之前的方法是，等所有程序运行完之后才会删除。 不知道我的理解对不对？","like_count":0},{"had_liked":false,"id":244184,"user_name":"magina","can_delete":false,"product_type":"c1","uid":1138499,"ip_address":"","ucode":"9546701896A09F","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/43/3799a0f3.jpg","comment_is_top":false,"comment_ctime":1598421711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598421711","product_id":100026001,"comment_content":"&quot;这时候同时要把 call 调用的时候压入的 PC 寄存器里的下一条指令出栈，更新到 PC 寄存器中，将程序的控制权返回到出栈后的栈顶。&quot;返回地址应该也是被压制栈里面的吧？","like_count":0},{"had_liked":false,"id":235655,"user_name":"Don Wang","can_delete":false,"product_type":"c1","uid":1319529,"ip_address":"","ucode":"1853365FA279F2","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/69/09f7a8a2.jpg","comment_is_top":false,"comment_ctime":1595138922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595138922","product_id":100026001,"comment_content":"另外这段代码有些问题， 没有添加符号；<br><br><br>#include &lt;stdio.h&gt;<br>#include &lt;time.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>int static add(int a, int b)<br>{<br>    return a+b;<br>}<br><br>int main()<br>{<br>    srand(time(NULL));<br>    int x = rand() % 5<br>    int y = rand() % 10;<br>    int u = add(x, y)<br>    printf(&quot;u = %d\\n&quot;, u)<br>}<br><br><br>","like_count":0},{"had_liked":false,"id":235654,"user_name":"Don Wang","can_delete":false,"product_type":"c1","uid":1319529,"ip_address":"","ucode":"1853365FA279F2","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/69/09f7a8a2.jpg","comment_is_top":false,"comment_ctime":1595138914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595138914","product_id":100026001,"comment_content":"[root@master ~]# objdump -d -M intel -S function_example_inline.o<br><br>function_example_inline.o：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;main&gt;:<br>{<br>    return a+b;<br>}<br><br>int main()<br>{<br>   0:\t53                   \tpush   rbx<br>    srand(time(NULL));<br>   1:\tbf 00 00 00 00       \tmov    edi,0x0<br>   6:\te8 00 00 00 00       \tcall   b &lt;main+0xb&gt;<br>   b:\t89 c7                \tmov    edi,eax<br>   d:\te8 00 00 00 00       \tcall   12 &lt;main+0x12&gt;<br>    int x = rand() % 5;<br>  12:\te8 00 00 00 00       \tcall   17 &lt;main+0x17&gt;<br>  17:\t89 c3                \tmov    ebx,eax<br>    int y = rand() % 10;<br>  19:\te8 00 00 00 00       \tcall   1e &lt;main+0x1e&gt;<br>  1e:\t89 c1                \tmov    ecx,eax<br>    int x = rand() % 5;<br>  20:\tbf 67 66 66 66       \tmov    edi,0x66666667<br>  25:\t89 d8                \tmov    eax,ebx<br>  27:\tf7 ef                \timul   edi<br>  29:\td1 fa                \tsar    edx,1<br>  2b:\t89 d8                \tmov    eax,ebx<br>  2d:\tc1 f8 1f             \tsar    eax,0x1f<br>  30:\t29 c2                \tsub    edx,eax<br>  32:\t8d 04 92             \tlea    eax,[rdx+rdx*4]<br>  35:\t29 c3                \tsub    ebx,eax<br>    int y = rand() % 10;<br>  37:\t89 c8                \tmov    eax,ecx<br>  39:\tf7 ef                \timul   edi<br>  3b:\tc1 fa 02             \tsar    edx,0x2<br>  3e:\t89 d7                \tmov    edi,edx<br>  40:\t89 c8                \tmov    eax,ecx<br>  42:\tc1 f8 1f             \tsar    eax,0x1f<br>  45:\t29 c7                \tsub    edi,eax<br>  47:\t8d 04 bf             \tlea    eax,[rdi+rdi*4]<br>  4a:\t01 c0                \tadd    eax,eax<br>  4c:\t29 c1                \tsub    ecx,eax<br>    return a+b;<br>  4e:\t8d 34 0b             \tlea    esi,[rbx+rcx*1]<br>    int u = add(x, y);<br>    printf(&quot;u = %d\\n&quot;, u);<br>  51:\tbf 00 00 00 00       \tmov    edi,0x0<br>  56:\tb8 00 00 00 00       \tmov    eax,0x0<br>  5b:\te8 00 00 00 00       \tcall   60 &lt;main+0x60&gt;<br>}<br>  60:\t5b                   \tpop    rbx<br>  61:\tc3                   \tret    <br>[root@master ~]# <br>————————————————————————<br>没找到图中所谓的  “add指令”？？？<br>","like_count":0},{"had_liked":false,"id":227955,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1592529926,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592529926","product_id":100026001,"comment_content":"函数的第0条指令是将栈帧寄存器压栈，栈帧寄存器存放的是上一个栈帧的栈顶地址，再将栈帧寄存器指向当前的栈顶，接着拨动sp栈顶指针到相应位置，然后开始执行代码主体，最后在退出前，先把栈顶寄存器拨到栈帧寄存器指向的地方，把上一个栈帧的栈帧寄存器出栈，再恢复PC寄存器、控制寄存器等。","like_count":0},{"had_liked":false,"id":227785,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1592479063,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592479063","product_id":100026001,"comment_content":"需要恢复控制寄存器的信息，比如各种flag。","like_count":0},{"had_liked":false,"id":226875,"user_name":"肖梦连","can_delete":false,"product_type":"c1","uid":1854320,"ip_address":"","ucode":"98EB833870D666","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4b/70/fb4f6a55.jpg","comment_is_top":false,"comment_ctime":1592221201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592221201","product_id":100026001,"comment_content":"“我们在内存里面开辟一段空间，用栈这个后进先出（LIFO，Last In First Out）的数据结构。”<br>这个导致堆栈溢出的内存有无大小之说","like_count":0},{"had_liked":false,"id":223590,"user_name":"夕林语","can_delete":false,"product_type":"c1","uid":1264180,"ip_address":"","ucode":"B57681D0C73E1B","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/34/1faac99b.jpg","comment_is_top":false,"comment_ctime":1591141049,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1591141049","product_id":100026001,"comment_content":"思考题：<br>还会保留参数和局部变量","like_count":0},{"had_liked":false,"id":221227,"user_name":"taodao100","can_delete":false,"product_type":"c1","uid":2015939,"ip_address":"","ucode":"44BB22D03998EF","user_header":"","comment_is_top":false,"comment_ctime":1590452527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590452527","product_id":100026001,"comment_content":"老师,寄存器EAX等是集成在CPU内部, 本文说的栈,物理上是存放在哪里呢,  是存放在物理内存条, 然后划分为逻辑栈空间来处理么,  如果是这样,物理内存是非常大的, 为什么栈的大小有限呢, 谢谢!","like_count":0},{"had_liked":false,"id":214068,"user_name":"顾海","can_delete":false,"product_type":"c1","uid":1103602,"ip_address":"","ucode":"13F4E0A21975CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","comment_is_top":false,"comment_ctime":1588649347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588649347","product_id":100026001,"comment_content":"<br><br>老师，context switch的时候是将当前线程或者进程的现场比如寄存器里面的内容等保存到哪里呢","like_count":0},{"had_liked":false,"id":200507,"user_name":"WENMURAN","can_delete":false,"product_type":"c1","uid":1915404,"ip_address":"","ucode":"5D1CE8B41937C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXNhbTULKiakib8lYXrvGF2zPwfedooBzC2EtSv1nt1MwV1KUvTkcJrvCBFvcdwJicnr3OEXnk9GUCg/132","comment_is_top":false,"comment_ctime":1585613903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585613903","product_id":100026001,"comment_content":"函数调用：<br>两个函数相互调用，会陷入无穷无尽的循环。<br>引入栈的概念：直接插入指令不行，那就把之后要执行的指令的地址记录下来，等到调用结束，直接跳转到这个地址，继续执行。栈就是在内存里开辟一块新的空间，就像一个竖状的球桶，每次调用一个函数，就往同里放一个球，调用完了把球拿出去，因为一个地方可能会调用很多层函数，那就按顺序来，最先进去的一定是最后出来。栈帧其实就是相当于函数的临时工作场所，你本身有你的办公室，需要用你的时候，临时给你一间房子，如果你内部还要调用其他函数，那你就在这个临时的房子里再分出一个小房子给那个函数，如果他内部还要调用其他函数，那就让他在自己那个小房子里再分一个小空间给别人，以此类推。等到函数结束的时候，一定是最后进来的那个人先走，然后次之，直到最初的那个人离开，这个栈帧也就可以消除了。","like_count":0},{"had_liked":false,"id":198372,"user_name":"王楷程","can_delete":false,"product_type":"c1","uid":1938215,"ip_address":"","ucode":"C53850ECCFC42E","user_header":"https://static001.geekbang.org/account/avatar/00/1d/93/27/7d2ad04c.jpg","comment_is_top":false,"comment_ctime":1585448288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585448288","product_id":100026001,"comment_content":"现在就去Stack overflow上看一下","like_count":0},{"had_liked":false,"id":192026,"user_name":"邹友","can_delete":false,"product_type":"c1","uid":1919425,"ip_address":"","ucode":"3ACEE22DBFEE86","user_header":"https://static001.geekbang.org/account/avatar/00/1d/49/c1/5a77c210.jpg","comment_is_top":false,"comment_ctime":1584815855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584815855","product_id":100026001,"comment_content":"关于push rdp 和 mov rdp rsp还是需要老师讲解一下<br>如果说push rdp是维护当前函数的栈帧，那是不每个函数最开始rdp都相当于初始化为自己的栈帧栈底指针，mov rdp rsp 更新压栈后的栈顶指针到rdp，然后pop再弹出自己此栈顶，以此实现了自己整个栈帧的维护。<br>还是说add的push rdp是压入main的栈帧栈底，那之前main执行的push rdp是在压入的什么","like_count":0},{"had_liked":false,"id":192021,"user_name":"邹友","can_delete":false,"product_type":"c1","uid":1919425,"ip_address":"","ucode":"3ACEE22DBFEE86","user_header":"https://static001.geekbang.org/account/avatar/00/1d/49/c1/5a77c210.jpg","comment_is_top":false,"comment_ctime":1584813160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584813160","product_id":100026001,"comment_content":"函数调用回转地址这块感觉讲的没太明白，既然给了和if&#47;else的对比，且提出了内联的假设，感觉可以基于前因后果或者说演进优化的方式串起来。<br>比如说如果if&#47;else总要自己jump指定地址，而函数的call没有，这里编译后的代码是不是已经就是基于栈的了。现在课程的讲解思路像是在说第一步编译代码先没有栈，提出优化替换代码，再继续思考引入栈概念。但看看后又觉得替换的想法是退一步作假设若不如此会怎样，然后再补充说明编译代码中的实现。<br>这一点没太清楚老师的讲解思路","like_count":0},{"had_liked":false,"id":187267,"user_name":"Zeal","can_delete":false,"product_type":"c1","uid":1898857,"ip_address":"","ucode":"327D516A1D0F0E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f9/69/384e33e6.jpg","comment_is_top":false,"comment_ctime":1584070631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584070631","product_id":100026001,"comment_content":"乒乓球的比喻并不好。<br>栈，不管其生长方向如何，其本质是不变的：后进先出；程序如果需要栈的配合来执行，那么执行的顺序是和进栈时反过来的；栈的大小不够了，那就入不了栈，也就自然不会有先前假设的“后进先出”。","like_count":0},{"had_liked":false,"id":187197,"user_name":"永远的草莓地","can_delete":false,"product_type":"c1","uid":1034001,"ip_address":"","ucode":"D4BD8DD42350CC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/11/89ba9915.jpg","comment_is_top":false,"comment_ctime":1584058492,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584058492","product_id":100026001,"comment_content":"有个疑问: “比如函数 A 在调用 B 的时候，需要传输一些参数数据，这些参数数据在寄存器不够用的时候也会被压入栈中。”    这个判断逻辑在哪里实现？编译器编译出来的机器码就有这样的判断吗？还是说 push 这个指令会优先在寄存器存放？","like_count":0},{"had_liked":false,"id":178910,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1581853030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581853030","product_id":100026001,"comment_content":"按照说的理解栈帧是不是大小都是不固定的？？？","like_count":0},{"had_liked":false,"id":175683,"user_name":"fcb的鱼","can_delete":false,"product_type":"c1","uid":1243901,"ip_address":"","ucode":"88667EBF09CEC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","comment_is_top":false,"comment_ctime":1580798399,"is_pvip":false,"replies":[{"id":"68649","content":"fcb的鱼同学，<br><br>你好，我们不只是有指令寄存器这一种寄存器的呀。还有用来存储下一条指令地址的PC寄存器，有存储用来做计算数据的数据寄存器。<br><br>另外，“一个64位的寄存器能保证的指令数为2^64次方吧”，对于指令，除了指令本身，还有指令的操作数哦。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581232907,"ip_address":"","comment_id":175683,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580798399","product_id":100026001,"comment_content":"一个64位的寄存器能保证的指令数为2^64次方吧，所以一个寄存器理论上能存所有的指令了吧？为什么还需要那么多的寄存器。","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482854,"discussion_content":"fcb的鱼同学，\n\n你好，我们不只是有指令寄存器这一种寄存器的呀。还有用来存储下一条指令地址的PC寄存器，有存储用来做计算数据的数据寄存器。\n\n另外，“一个64位的寄存器能保证的指令数为2^64次方吧”，对于指令，除了指令本身，还有指令的操作数哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581232907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174209,"user_name":"Joe Black","can_delete":false,"product_type":"c1","uid":1052528,"ip_address":"","ucode":"21FE222A286445","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/70/c8680841.jpg","comment_is_top":false,"comment_ctime":1580089470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580089470","product_id":100026001,"comment_content":"2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]  <br>2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]  <br>30:   89 d6                   mov    esi,edx  <br>32:   89 c7                   mov    edi,eax<br>请问下这里为什么要先把参数在eax和edx中存一下呢？最终我看似乎是为了通过esi和edi进行参数传递，直接把值给这两个寄存器不行吗？","like_count":0},{"had_liked":false,"id":173910,"user_name":"Temme","can_delete":false,"product_type":"c1","uid":1310995,"ip_address":"","ucode":"BCBA3A5570216A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/eyKgpIVFSDQBia7SJRVUKFh5qgwc3ohzEPSKvchLf9ZvwIO9CrS470ER7OhNzWTs0svECHCBiarQTa41BO3Hf0DA/132","comment_is_top":false,"comment_ctime":1579775294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579775294","product_id":100026001,"comment_content":"不知道我的理解对不<br><br>1.真正意义上的栈只有程序栈，能够压栈和出栈<br><br>2.整个过程的目的是让rbp一直是当前函数栈帧的栈底地址(这个栈底地址的说法好像让不少同学以为函数也有个栈。。)<br><br>3.push rbp是为了压栈来保存rsp中的值，mov   rbp rsp是在更新rbp，因为调用新的函数了，最后pop rbp是把之前压栈保存的值出栈还原了，这样做对应了2所说的<br><br>4.rsp在整个压栈出栈的机制是一直会自动指向栈顶，这个栈顶指的是下一次如果要压栈，所要赋值的栈内存的地址","like_count":0},{"had_liked":false,"id":171714,"user_name":"Mr.埃克斯","can_delete":false,"product_type":"c1","uid":1400806,"ip_address":"","ucode":"855BE5DFD2BB0B","user_header":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","comment_is_top":false,"comment_ctime":1578996066,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578996066","product_id":100026001,"comment_content":"作者你好，将%rsp寄存器的值复制给%rbp寄存是: mov %rsp %rbp吧？","like_count":0},{"had_liked":false,"id":169604,"user_name":"许先森","can_delete":false,"product_type":"c1","uid":1795371,"ip_address":"","ucode":"1F42D4A6B5C6AF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","comment_is_top":false,"comment_ctime":1578387328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578387328","product_id":100026001,"comment_content":"理论：“每一个帧栈都建立在调用者下方，即地址递减的方向。”<br>可以想象一个乐事薯片桶倒着放，开口向下，这个桶也不是无限容量的，是有限制的，比如这是一个20厘米的桶，开口位置是0，底部是20，这时候往桶里放一个1厘米高的薯片A，（别和我说这违反万有引力定律）它占用的内存为19（栈指针，抽象可以叫顶部）至20（帧指针，抽象叫底部），再来一个1厘米高的薯片B，它占用的内存为18（顶部）至19（底部）。新来的这个薯片B我觉得它味道不够，给它加点别的料导致它变成了5厘米高，所以它现在在内存中的位置为14至19，可以看到底部位置没变，顶部位置变小了，也就是说把栈指针减去一定的值就相当于给这个帧栈分配了更多的内存空间，相反，把顶部数字（栈指针）增大，就相当于压缩了帧栈长度，也就是内存被释放了。","like_count":0},{"had_liked":false,"id":167558,"user_name":"胖胖虎","can_delete":false,"product_type":"c1","uid":1139121,"ip_address":"","ucode":"9CA8F99CC82944","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","comment_is_top":false,"comment_ctime":1577859287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577859287","product_id":100026001,"comment_content":"老师，我一直有一个疑问，Linux内核中的栈的处理是否和用户态有不同？用gdb分析core dump的时候，可以用切换栈帧的方式切到对应的调用栈上去进行分析。但是在内核态，使用crash进行分析内核转储就无法进行这样的操作，这就给分析内核的一些问题带来了很多麻烦。","like_count":0},{"had_liked":false,"id":164991,"user_name":"日光下的魔术师","can_delete":false,"product_type":"c1","uid":1518599,"ip_address":"","ucode":"120192E75FBE9B","user_header":"https://static001.geekbang.org/account/avatar/00/17/2c/07/27740a4c.jpg","comment_is_top":false,"comment_ctime":1577143706,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577143706","product_id":100026001,"comment_content":"请问，一层一层压栈之后，为什么栈顶的内存地址是在不断变小的，这一块没搞懂","like_count":0,"discussions":[{"author":{"id":1400806,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/e6/19778e70.jpg","nickname":"Mr.埃克斯","note":"","ucode":"855BE5DFD2BB0B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133803,"discussion_content":"每个进程都会划分一段内存（内存地址从下到上递增的），其中有堆区，代码区，栈区等；堆区是向上增长的，地址也是变大的，栈是向下增长的，地址就是减小的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578990761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163656,"user_name":"lcp","can_delete":false,"product_type":"c1","uid":1147461,"ip_address":"","ucode":"3C9975BFF7654E","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/45/981ac8ab.jpg","comment_is_top":false,"comment_ctime":1576761806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576761806","product_id":100026001,"comment_content":"push rbp；<br>mov rbp rsp；<br>这2个是对栈帧的压栈出栈，并不是执行指令的压栈出栈；栈帧是用来标识一个函数的调用上下文，结合 @chengzise 的回复这样理解应该就能贯通了。","like_count":0},{"had_liked":false,"id":163518,"user_name":"大王叫我来巡山","can_delete":false,"product_type":"c1","uid":1099513,"ip_address":"","ucode":"1B8D0C701BC95E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","comment_is_top":false,"comment_ctime":1576736337,"is_pvip":false,"replies":[{"id":"68133","content":"👍加油","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580650788,"ip_address":"","comment_id":163518,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576736337","product_id":100026001,"comment_content":"反复看了很多遍，每一遍都有收获，一定要练，多练，多看","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478428,"discussion_content":"👍加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580650788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154723,"user_name":"Sunny","can_delete":false,"product_type":"c1","uid":1305257,"ip_address":"","ucode":"BB7B274CE0672E","user_header":"https://static001.geekbang.org/account/avatar/00/13/ea/a9/0a917f2c.jpg","comment_is_top":false,"comment_ctime":1574521415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574521415","product_id":100026001,"comment_content":"“push rbp 就把之前调用函数，也就是 main 函数的栈帧的栈底地址，压到栈顶。老师，这句话能再深入解释一下么？“栈低地址，压到栈顶”我实在是看不懂这句。","like_count":0},{"had_liked":false,"id":152744,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1574074356,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574074356","product_id":100026001,"comment_content":"老师，整个专栏学起来很枯燥无聊，理解起来有些困难，有什么好的建议么？","like_count":0,"discussions":[{"author":{"id":1235120,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d8/b0/28e69b49.jpg","nickname":"D-fly","note":"","ucode":"0E6A50E59BB1F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96436,"discussion_content":"一遍看不了，就看两遍，两遍看不了，就看三遍，以此类推，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577065097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149793,"user_name":"Presley","can_delete":false,"product_type":"c1","uid":1215219,"ip_address":"","ucode":"D8F125835F4903","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/f3/7c89d00e.jpg","comment_is_top":false,"comment_ctime":1573379215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573379215","product_id":100026001,"comment_content":"还需要保存传入的参数，以及计算的结果。<br>传入的参数通过栈来传递<br>计算结果通过寄存器来传递","like_count":0},{"had_liked":false,"id":142827,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1571544944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571544944","product_id":100026001,"comment_content":"---总结---<br>由于寄存器的数量限制，单纯依赖于寄存器的存储功能无法实现复杂的函数调用功能，因此引入了栈这种数据结构。<br>栈可以记录历史信息和执行路径信息，在函数调用中也可以体现出作用域的变化，和函数调用过程不谋而合。<br><br>---问题---<br>请问下老师，栈这个概念在机器码层面是如何感知的，按我之前的理解，栈的概念是在操作系统层面抽象产生的，即压栈和出栈的操作经编译汇编后应该仅变成了内存的存取操作。但似乎之前的理解是有问题的，那么像push rbp这样的指令是如何定位到栈顶在内存中的位置并进行push的呢？","like_count":0},{"had_liked":false,"id":142609,"user_name":"心浮天空","can_delete":false,"product_type":"c1","uid":1051609,"ip_address":"","ucode":"3B2D0E6CC51EE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","comment_is_top":false,"comment_ctime":1571411829,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571411829","product_id":100026001,"comment_content":"有个问题: 不清楚C语言是否支持尾递归优化, 如果支持又是如何做到的呢？","like_count":0},{"had_liked":false,"id":131187,"user_name":"不会写诗的翩翩少年","can_delete":false,"product_type":"c1","uid":1235460,"ip_address":"","ucode":"A2DB54A73080BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/04/26fbd46a.jpg","comment_is_top":false,"comment_ctime":1567666353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567666353","product_id":100026001,"comment_content":"1、阅读本篇文章时关于栈帧部分内容，可参考此篇文章https:&#47;&#47;www.cnblogs.com&#47;ysocean&#47;p&#47;7625917.html<br>2、pop rbp之前，不需要先执行movl rbp, rsp么，让栈指针指向栈帧么，@老师","like_count":0},{"had_liked":false,"id":129678,"user_name":"不再冲动的函数","can_delete":false,"product_type":"c1","uid":1440695,"ip_address":"","ucode":"821BE5E22085F9","user_header":"https://static001.geekbang.org/account/avatar/00/15/fb/b7/3681866d.jpg","comment_is_top":false,"comment_ctime":1567216628,"is_pvip":false,"replies":[{"id":"51165","content":"栈帧都是运行时动态分配的，根据程序实际执行的过程中大小发生变化，并没有固定的大小。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568551001,"ip_address":"","comment_id":129678,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567216628","product_id":100026001,"comment_content":"每个线程的栈帧是什么时候分配的？编译程序的时候？还有一般每个程序的栈帧大小是多少？","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465598,"discussion_content":"栈帧都是运行时动态分配的，根据程序实际执行的过程中大小发生变化，并没有固定的大小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568551001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112428,"user_name":"赵小通","can_delete":false,"product_type":"c1","uid":1047266,"ip_address":"","ucode":"C19D395C2E8BA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/e2/178bc954.jpg","comment_is_top":false,"comment_ctime":1562731268,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562731268","product_id":100026001,"comment_content":"为啥咱们编出来的汇编语言不一样啊？老师是什么环境？我的环境是centos 6.9，gcc版本是6.5.0，linux内核版本是2.6.32, x86_64<br>#include&lt;stdio.h&gt;<br>int add_a_and_b(int a, int b) {<br>   0:\t55                   \tpush   %rbp<br>   1:\t48 89 e5             \tmov    %rsp,%rbp<br>   4:\t89 7d fc             \tmov    %edi,-0x4(%rbp)<br>   7:\t89 75 f8             \tmov    %esi,-0x8(%rbp)<br>    return a + b;<br>   a:\t8b 55 fc             \tmov    -0x4(%rbp),%edx<br>   d:\t8b 45 f8             \tmov    -0x8(%rbp),%eax<br>  10:\t01 d0                \tadd    %edx,%eax<br>}<br>  12:\t5d                   \tpop    %rbp<br>  13:\tc3                   \tretq<br><br>0000000000000014 &lt;main&gt;:<br>int main() {<br>  14:\t55                   \tpush   %rbp<br>  15:\t48 89 e5             \tmov    %rsp,%rbp<br>  18:\t48 83 ec 10          \tsub    $0x10,%rsp<br>    int a, b, c;<br>    a = 2;<br>  1c:\tc7 45 fc 02 00 00 00 \tmovl   $0x2,-0x4(%rbp)<br>    b = 3;<br>  23:\tc7 45 f8 03 00 00 00 \tmovl   $0x3,-0x8(%rbp)<br>    c = add_a_and_b(a, b);<br>  2a:\t8b 55 f8             \tmov    -0x8(%rbp),%edx<br>  2d:\t8b 45 fc             \tmov    -0x4(%rbp),%eax<br>  30:\t89 d6                \tmov    %edx,%esi<br>  32:\t89 c7                \tmov    %eax,%edi<br>  34:\te8 00 00 00 00       \tcallq  39 &lt;main+0x25&gt;<br>  39:\t89 45 f4             \tmov    %eax,-0xc(%rbp)<br>    return c;<br>  3c:\t8b 45 f4             \tmov    -0xc(%rbp),%eax<br>}<br>  3f:\tc9                   \tleaveq<br>  40:\tc3                   \tretq","like_count":0,"discussions":[{"author":{"id":1180493,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/4d/20cb06d0.jpg","nickname":"anderson","note":"","ucode":"F5400691D50E24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22003,"discussion_content":"你这个是att的汇编语法，需要指定 -M intel 来选择intel的汇编语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569559515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106268,"user_name":"hehorange","can_delete":false,"product_type":"c1","uid":1520030,"ip_address":"","ucode":"9257AAFB674025","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTITKv1C7HrokGrJFURexzzGEuCUibcKnPLp5rD7LFicqO8E3elKBmPGESX02qxzwv4zAk96A66ajGxw/132","comment_is_top":false,"comment_ctime":1561239666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561239666","product_id":100026001,"comment_content":"这一讲主要思想是理解了，但在具体的栈帧操作上光凭文字还是很难理解，希望能加上配图来讲解。我看前面也有评论也提到了","like_count":0},{"had_liked":false,"id":103961,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1560574652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560574652","product_id":100026001,"comment_content":"老师用的什么电脑，什么系统。Mac下，我也反编译出来了，感觉和老师的有很大的出入。<br>","like_count":0},{"had_liked":false,"id":103431,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1560434230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560434230","product_id":100026001,"comment_content":"还需要保存局部&#47;临时变量，被调函数的参数列表","like_count":0},{"had_liked":false,"id":101023,"user_name":"开心","can_delete":false,"product_type":"c1","uid":1517457,"ip_address":"","ucode":"C8E08E8724C7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","comment_is_top":false,"comment_ctime":1559702357,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559702357","product_id":100026001,"comment_content":"代码执行的时候，是每个方法都有一个栈，还是所有方法公用一个栈呀~ ","like_count":0},{"had_liked":false,"id":99798,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1559304259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559304259","product_id":100026001,"comment_content":"还需要有函数参数、临时变量和函数调用前后需要保存不变的寄存器值","like_count":0},{"had_liked":false,"id":99289,"user_name":"拓山","can_delete":false,"product_type":"c1","uid":1545647,"ip_address":"","ucode":"11FE9CF3821898","user_header":"https://static001.geekbang.org/account/avatar/00/17/95/af/b7f8dc43.jpg","comment_is_top":false,"comment_ctime":1559186717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559186717","product_id":100026001,"comment_content":"【push rbp 就把之前调用函数，也就是 main 函数的栈帧的栈底地址，压到栈顶】这句话有隐含的信息没有说清楚：<br>1、压到栈顶是谁的栈顶，是add函数的栈顶吗？<br>2、为什么是把main的栈底又压到栈顶？这个时候main函数的栈顶就是add函数的栈底呀，<br><br>","like_count":0},{"had_liked":false,"id":99286,"user_name":"拓山","can_delete":false,"product_type":"c1","uid":1545647,"ip_address":"","ucode":"11FE9CF3821898","user_header":"https://static001.geekbang.org/account/avatar/00/17/95/af/b7f8dc43.jpg","comment_is_top":false,"comment_ctime":1559186347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559186347","product_id":100026001,"comment_content":"【push rbp 就把之前调用函数，也就是 main 函数的栈帧的栈底地址，压到栈顶】有两个隐含信息没解释清楚：","like_count":0},{"had_liked":false,"id":99198,"user_name":"子云","can_delete":false,"product_type":"c1","uid":1516554,"ip_address":"","ucode":"4462F725F1251B","user_header":"https://static001.geekbang.org/account/avatar/00/17/24/0a/4e00e9df.jpg","comment_is_top":false,"comment_ctime":1559177289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559177289","product_id":100026001,"comment_content":"老师啊，这个我看了还是有点蒙逼的那种，以前都没学过，零基础的，怎么办呢<br>","like_count":0},{"had_liked":false,"id":98174,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1558924778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558924778","product_id":100026001,"comment_content":"1、老师好!压栈出栈，寄存器地址变动那还是不太理解。问题一：网上查了下rsp：栈指针寄存器永远指向系统栈最上面一个栈帧的栈顶。rbp：基址指针寄存器指向系统栈最上面一个栈帧的底部。网上的解释对吗？rsp寄存器存的内存地址是什么时候改变的？是push的时候从pc寄存器复制过来么，pop的时候和rbp一起变为新栈顶？。问题二：pop rbp出栈时rbp指向新栈顶原栈顶内存会置空吗？问题三：ret操作是把pop后新的rbp复制到PC寄存器吗？","like_count":0},{"had_liked":false,"id":95602,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1558096519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558096519","product_id":100026001,"comment_content":"我是一名运维工程师，今年的目标是深挖计算机专业基础课程 day07<br>https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;10876051.html","like_count":0},{"had_liked":false,"id":93740,"user_name":"萝卜祥子","can_delete":false,"product_type":"c1","uid":1476139,"ip_address":"","ucode":"367F4E644D4656","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9z4VJwCSPPI0Zng5OmbC0EX7TYvqiconRv4GolDKxWLK97GLvvoroqTgkHlIlLyZZTVlRRiaZkCeTlthNDYauhA/132","comment_is_top":false,"comment_ctime":1557576979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557576979","product_id":100026001,"comment_content":"这里有个疑问，在调用子函数之前，会将调用者寄存器进行保护，这是编译器自行处理的吗？由于64位操作系统增加了一些寄存器，因此很多情况下参数已经不通过栈调用，而是通过寄存器传递参数，这个应该也是ABI规范规定的吧，在深入理解计算机系统中有涉及这部分","like_count":0},{"had_liked":false,"id":93646,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1557543943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557543943","product_id":100026001,"comment_content":"看了下深入理解计算机系统的3.7章，测试了下程序<br>int swap_add(int* xp, int* yp) {<br>  int x = *xp;<br>  int y = *xp;<br>  *xp = y;<br>  *yp = x;<br>  return x + y;<br>}<br><br>int caller() {<br>  int arg1 = 534;<br>  int arg2 = 1057;<br>  int sum = swap_add(&amp;arg1, &amp;arg2);<br>  int diff = arg1 - arg2;<br>  return sum * diff;<br>}<br>有两个疑问 <br>1 发现书中的指令比我生成的多了一个l后缀 <br>2 调用者计算传指针的参数时候，书中使用的是栈帧指针加字节偏移leal -4(%ebp), %eax，而我用centos7 编译的是直接存入rdx,rax,edx,DWORD PTR [rbp-0xc]   eax,DWORD PTR [rbp-0x10]<br>这个差异是怎么回事，老师帮忙解释下","like_count":0},{"had_liked":false,"id":93645,"user_name":"鱼的老大","can_delete":false,"product_type":"c1","uid":1140671,"ip_address":"","ucode":"DCFBF6E937E4D4","user_header":"https://static001.geekbang.org/account/avatar/00/11/67/bf/9888df21.jpg","comment_is_top":false,"comment_ctime":1557543925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557543925","product_id":100026001,"comment_content":"“栈底的内存地址是在一开始就固定的。”这句话中的“内存地址”是由每个线程自己分配的么？","like_count":0},{"had_liked":false,"id":93489,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1557479997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557479997","product_id":100026001,"comment_content":"讲得很好很生动  基本都懂了 还需要反复阅读 加深印象  在读一读书   加深印象","like_count":0}]}