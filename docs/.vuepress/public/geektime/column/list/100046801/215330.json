{"id":215330,"title":"12 | MySQL如何应对高并发（二）：读写分离","content":"<p>你好，我是李玥。</p><p>上节课我和你讲了，使用Redis作为MySQL的前置缓存，可以帮助MySQL挡住绝大部分的查询请求。这种方法对于像电商中的商品系统、搜索系统这类与用户关联不大的系统，效果特别的好。因为在这些系统中，每个人看到的内容都是一样的，也就是说，对后端服务来说，每个人的查询请求和返回的数据都是一样的。这种情况下，Redis缓存的命中率非常高，近乎于全部的请求都可以命中缓存，相对的，几乎没有多少请求能穿透到MySQL。</p><p>但是，和用户相关的系统，使用缓存的效果就没那么好了，比如说，订单系统、账户系统、购物车系统等等。在这些系统里面，每个用户需要查询的信息都是和用户相关的，即使是同一个功能界面，那每个人看到的数据都是不一样的。</p><p>比如说，“我的订单”这个功能，用户在这里看到的都是自己的订单数据，我打开我的订单缓存的数据，是不能给你打开你的订单来使用的，因为我们两个人的订单是不一样的。这种情况下，缓存的命中率就没有那么高，还是有相当一部分查询请求因为命中不了缓存，打到MySQL上。</p><p>那随着系统用户数量越来越多，打到MySQL上的读写请求也越来越多，当单台MySQL支撑不了这么多的并发请求时，我们该怎么办？</p><!-- [[[read_end]]] --><h2>读写分离是提升MySQL并发的首选方案</h2><p>当单台MySQL无法满足要求的时候，只能用多个MySQL实例来承担大量的读写请求。MySQL和大部分常用的关系型数据库一样，都是典型的单机数据库，不支持分布式部署。用一个单机数据库的多个实例来组成一个集群，提供分布式数据库服务，是一个非常困难的事儿。</p><p>在部署集群的时候，需要做很多额外的工作，而且很难做到对应用透明，那你的应用程序也要为此做较大的架构调整。所以，除非系统规模真的大到只有这一条路可以走，不建议你对数据进行分片，自行构建MySQL集群，代价非常大。</p><p>一个简单而且非常有效的方案是，我们不对数据分片，而是使用多个具有相同数据的MySQL实例来分担大量的查询请求，这种方法通常称为“读写分离”。读写分离之所以能够解决问题，它实际上是基于一个对我们非常有利的客观情况，那就是，很多系统，特别是面对公众用户的互联网系统，对数据的读写比例是严重不均衡的。读写比一般都在几十左右，平均每发生几十次查询请求，才有一次更新请求。换句话来说，数据库需要应对的绝大部分请求都是只读查询请求。</p><p>一个分布式的存储系统，想要做分布式写是非常非常困难的，因为很难解决好数据一致性的问题。但实现分布式读就相对简单很多，我只需要增加一些只读的实例，只要能够把数据实时的同步到这些只读实例上，保证这这些只读实例上的数据都随时一样，这些只读的实例就可以分担大量的查询请求。</p><p>读写分离的另外一个好处是，它实施起来相对比较简单。把使用单机MySQL的系统升级为读写分离的多实例架构非常容易，一般不需要修改系统的业务逻辑，只需要简单修改DAO代码，把对数据库的读写请求分开，请求不同的MySQL实例就可以了。</p><p>通过读写分离这样一个简单的存储架构升级，就可以让数据库支持的并发数量增加几倍到十几倍。所以，当你的系统用户数越来越多，读写分离应该是你首先要考虑的扩容方案。</p><p>下图是一个典型的读写分离架构：</p><p><img src=\"https://static001.geekbang.org/resource/image/40/db/40e195c130d45dcdf25a273cb8835ddb.jpg?wh=1142*799\" alt=\"\"></p><p>主库负责执行应用程序发来的所有数据更新请求，然后异步将数据变更实时同步到所有的从库中去，这样，主库和所有从库中的数据是完全一样的。多个从库共同分担应用的查询请求。</p><p>然后我们简单说一下，如何来实施MySQL的读写分离方案。你需要做两件事儿：</p><ol>\n<li>部署一主多从多个MySQL实例，并让它们之间保持数据实时同步。</li>\n<li>分离应用程序对数据库的读写请求，分别发送给从库和主库。</li>\n</ol><p>MySQL自带主从同步的功能，经过简单的配置就可以实现一个主库和几个从库之间的数据同步，部署和配置的方法，你看<a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication.html\">MySQL的官方文档</a>照着做就可以。分离应用程序的读写请求方法有下面这三种：</p><ol>\n<li>纯手工方式：修改应用程序的DAO层代码，定义读写两个数据源，指定每一个数据库请求的数据源。</li>\n<li>组件方式：也可以使用像Sharding-JDBC这种集成在应用中的第三方组件来实现，这些组件集成在你的应用程序内，代理应用程序的所有数据库请求，自动把请求路由到对应数据库实例上。</li>\n<li>代理方式：在应用程序和数据库实例之间部署一组数据库代理实例，比如说Atlas或者MaxScale。对应用程序来说，数据库代理把自己伪装成一个单节点的MySQL实例，应用程序的所有数据库请求被发送给代理，代理分离读写请求，然后转发给对应的数据库实例。</li>\n</ol><p>这三种方式，我最推荐的是第二种，使用读写分离组件。这种方式代码侵入非常少，并且兼顾了性能和稳定性。如果你的应用程序是一个逻辑非常简单的微服务，简单到只有几个SQL，或者是，你的应用程序使用的编程语言没有合适的读写分离组件，那你也可以考虑使用第一种纯手工的方式来实现读写分离。</p><p>一般情况下，不推荐使用第三种代理的方式，原因是，使用代理加长了你的系统运行时数据库请求的调用链路，有一定的性能损失，并且代理服务本身也可能出现故障和性能瓶颈等问题。但是，代理方式有一个好处是，它对应用程序是完全透明的。<strong>所以，只有在不方便修改应用程序代码这一种情况下，你才需要采用代理方式。</strong></p><p>另外，如果你配置了多个从库，推荐你使用“HAProxy+Keepalived”这对儿经典的组合，来给所有的从节点做一个高可用负载均衡方案，既可以避免某个从节点宕机导致业务可用率降低，也方便你后续随时扩容从库的实例数量。因为HAProxy可以做L4层代理，也就是说它转发的是TCP请求，所以用“HAProxy+Keepalived”代理MySQL请求，在部署和配置上也没什么特殊的地方，正常配置和部署就可以了。</p><h2>注意读写分离带来的数据不一致问题</h2><p>读写分离的一个副作用是，可能会存在数据不一致的情况。原因是，数据库中的数据在主库完成更新后，是异步同步到每个从库上的，这个过程有一个微小的时间差，这个时间差叫<strong>主从同步延迟</strong>。正常情况下，主从延迟非常小，不超过1ms。但即使这个非常小的延迟，也会导致在某一个时刻，主库和从库上的数据是不一致的。应用程序需要能接受并克服这种主从不一致的情况，否则就会引发一些由于主从延迟导致的数据错误。</p><p>还是拿订单系统来举例，我们自然的设计思路是，用户从购物车里发起结算创建订单，进入订单页，打开支付页面进行支付，支付完成后，按道理应该再返回支付之前的订单页。但如果这个时候马上自动返回订单页，就很可能会出现订单状态还是显示“未支付”。因为，支付完成后，订单库的主库中，订单状态已经被更新了，而订单页查询的从库中，这条订单记录的状态有可能还没更新。怎么解决？</p><p>这种问题其实没什么好的技术手段来解决，所以你看大的电商，它支付完成后是不会自动跳回到订单页的，它增加了一个无关紧要的“支付完成”页面，其实这个页面没有任何有效的信息，就是告诉你支付成功，然后再放一些广告什么的。你如果想再看刚刚支付完成的订单，需要手动点一下，这样就很好地规避了主从同步延迟的问题。</p><p>上面这个例子还只是订单状态显示错误，刷新一下就好了。我们需要特别注意的，是那些数据更新后，立刻需要查询更新后的数据，然后再更新其他数据这种情况。比如说在购物车页面，如果用户修改了某个商品的数量，需要重新计算优惠和总价。更新了购物车的数据后，需要立即调用计价服务，这个时候如果计价服务去读购物车的从库，非常可能读到旧数据而导致计算的总价错误。</p><p>对于这个例子，你可以把“更新购物车、重新计算总价”这两个步骤合并成一个微服务，然后放在一个数据库事务中去，同一个事务中的查询操作也会被路由到主库，这样来规避主从不一致的问题。</p><p>对于这种主从延迟带来的数据不一致的问题，没有什么简单方便而且通用的技术方案可以解决，我们需要重新设计业务逻辑，尽量规避更新数据后立即去从库查询刚刚更新的数据。</p><h2>小结</h2><p>随着系统的用户增长，当单个MySQL实例快要扛不住大量并发的时候，读写分离是首选的数据库扩容方案。读写分离的方案不需要对系统做太大的改动，就可以让系统支撑的并发提升几倍到十几倍。</p><p>推荐你使用集成在应用内的读写分离组件方式来分离数据库读写请求，如果很难修改应用程序，也可以使用代理的方式来分离数据库读写请求。如果你的方案中部署了多个从库，推荐你用“HAProxy+Keepalived”来做这些从库的负载均衡和高可用，这个方案的好处是简单稳定而且足够灵活，不需要增加额外的服务器部署，便于维护并且不增加故障点。</p><p>主从同步延迟会导致主库和从库之间出现数据不一致的情况，我们的应用程序应该能兼容主从延迟，避免因为主从延迟而导致的数据错误。规避这个问题最关键的一点是，我们在设计系统的业务流程时，尽量不要在更新数据之后立即去查询更新后的数据。</p><h2>思考题</h2><p>课后请你对照你现在负责开发或者维护的系统来分享一下，你的系统实施读写分离的具体方案是什么样的？比如，如何分离读写数据库请求？如何解决主从延迟带来的数据一致性问题？欢迎你在留言区与我讨论。</p><p>如果你觉得今天的内容对你有帮助，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"11 | MySQL如何应对高并发（一）：使用缓存保护MySQL","id":213230},"right":{"article_title":"13 | MySQL主从数据库同步是如何实现的？","id":215383}},"comments":[{"had_liked":false,"id":194080,"user_name":"李玥","can_delete":false,"product_type":"c1","uid":1501046,"ip_address":"","ucode":"B19E91EE248591","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","comment_is_top":true,"comment_ctime":1585022846,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"9.2233721501088993e+18","product_id":100046801,"comment_content":"Hi，我是李玥。<br><br>这里回顾一下上节课的思考题：<br><br>课后请你想一下，具体什么情况下，使用Cache Aside模式更新缓存会产生脏数据？欢迎你在评论区留言，通过一个例子来说明情况。<br><br>说一种可能产生脏数据的情况：<br><br>使用Cache Aside模式来更新缓存，是不是就完全可以避免产生脏数据呢？也不是，如果一个写线程在更新订单数据的时候，恰好赶上这条订单数据缓存过期，又恰好赶上一个读线程正在读这条订单数据，还是有可能会产生读线程将缓存更新成脏数据。但是，这个可能性相比Read&#47;Write Through模式要低很多，并且发生的概率并不会随着并发数量增多而显著增加，所以即使是高并发的场景，这种情况实际发生的概率仍然非常低。<br><br>既然不能百分之百的避免缓存的脏数据，那我们可以使用一些方式来进行补偿。比如说，把缓存的过期时间设置的相对短一些，一般在几十秒左右，这样即使产生了脏数据，几十秒之后就会自动恢复了。更复杂一点儿的，可以在请求中带上一个刷新标志位，如果用户在查看订单的时候，手动点击刷新，那就不走缓存直接去读数据库，也可以解决一部分问题。","like_count":26,"discussions":[{"author":{"id":1209170,"avatar":"https://static001.geekbang.org/account/avatar/00/12/73/52/a5a0c0c6.jpg","nickname":"animabear","note":"","ucode":"60E27F9F57DD06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224340,"discussion_content":"还可以采用延迟删除 隔几秒后再执行一次删除 可以由业务或者 redis proxy 实现","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586279844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094478,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/4e/5f22b09d.jpg","nickname":"marker","note":"","ucode":"DDBF1CD83665C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295990,"discussion_content":"可以做一个内部队列保持修改数据库和刷新缓存串行化，查询请求的时候处理一下即可。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596422225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247124,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUicDf5vnWPib22sugRBcES8lR3LibI3LfZrKqiabiczqeBVOhlCan8VNpVjK57gibmb58lYL68FY7nvFQ/132","nickname":"zhsoft","note":"","ucode":"573BF7C3676531","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226913,"discussion_content":"老师请问下\n1.如果cache aside模式下，缓存中的数据不设置过期时间，还会有脏数据吗\n2.还有操作缓存的时候会存在失败的情况，这个情况是要重试，还是引用mq，失败就放到mq","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586444624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1319264,"avatar":"https://static001.geekbang.org/account/avatar/00/14/21/60/b21da12a.jpg","nickname":"渐渐迷失","note":"","ucode":"9CEB5D11B4B5CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219970,"discussion_content":"没事说的是 和cache aside 情况一样不是没有脏数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585829013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1319264,"avatar":"https://static001.geekbang.org/account/avatar/00/14/21/60/b21da12a.jpg","nickname":"渐渐迷失","note":"","ucode":"9CEB5D11B4B5CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219968,"discussion_content":"问一句 read write through 脏数据 是因为修改数据用的乐观锁吗 如果开启悲观锁在事务里是不是就没事了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585828911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194019,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1585015370,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"121844099658","product_id":100046801,"comment_content":"在上家公司，我记得我写订单支付成功之后需要送优惠券的业务，也导致赠送优惠券不成功。<br>测试环境怎么都不出问题，后来才想到的是主从的问题，之后就修改成功了，从主库查询并增加优惠券。忙到半夜。这个课程真是太好了。","like_count":29,"discussions":[{"author":{"id":1074897,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/d1/8664c464.jpg","nickname":"flyCoder","note":"","ucode":"82FB7B60775978","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349157,"discussion_content":"没理解你的问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612939279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366311,"discussion_content":"如何区分到主库和从库查询优惠券的时机？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618025642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2791739,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/99/3b/acbc0986.jpg","nickname":"记忆不寒凉","note":"","ucode":"AC1D0AA0740803","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402028,"discussion_content":"一般这种主流程的查询可以强制走主库","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633785360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366311,"ip_address":""},"score":402028,"extra":""}]}]},{"had_liked":false,"id":226653,"user_name":"王佳山","can_delete":false,"product_type":"c1","uid":1786944,"ip_address":"","ucode":"771D318F150F8C","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoxUFAanq6rz2MqHXtn7vAvyIe0ljoqCtX3gnqZujLk7x90llHedHqCpHCnbYJeZmPX06Y6OFlibpQ/132","comment_is_top":false,"comment_ctime":1592180123,"is_pvip":false,"replies":[{"id":"84541","content":"比如先后执行一条更新语句，和一条查询语句。<br><br>默认读写分离的情况下，更新语句会走主库，查询语句会走从库。<br><br>如果把这两条语句放到同一个事务里面，因为事务的原子性，那查询语句也会走主库。<br>","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1592918562,"ip_address":"","comment_id":226653,"utype":1}],"discussion_count":2,"race_medal":0,"score":"83196558747","product_id":100046801,"comment_content":"这篇文章中提到的同一个事务会路由到主库是什么意思？","like_count":20,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498318,"discussion_content":"比如先后执行一条更新语句，和一条查询语句。\n\n默认读写分离的情况下，更新语句会走主库，查询语句会走从库。\n\n如果把这两条语句放到同一个事务里面，因为事务的原子性，那查询语句也会走主库。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592918562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1856445,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/53/bd/c394ecb7.jpg","nickname":"Jack-bai","note":"","ucode":"CF223B05C01610","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555840,"discussion_content":"如果通过组件方式实现读写分离，我理解走主库或是从库是与语句的关键字有关的吧。难道和事务是相关的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647078667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196408,"user_name":"Mongo","can_delete":false,"product_type":"c1","uid":1012100,"ip_address":"","ucode":"3EED4257A8F8C3","user_header":"","comment_is_top":false,"comment_ctime":1585278821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70304755557","product_id":100046801,"comment_content":"- Redis作为 MySQL前置<br>  针对类似电商类看到的结果是一样的效果很好<br>  针对看到的内容各不相同的时候，效果一般<br>- MySQL 针对高并发方案<br>  - 分布式存储系统难点<br>      写难以保证数据一致性<br>      分布式读相对简单<br>  - 构建分布式集群<br>    不建议构建分布式集群，代价大<br>  - 读写分离方案<br>    读写分离，可有效分担大量的查询请求<br>    读写分离，实施比较方便<br>    - 读写分离方案<br>      部署一主多从多个 MySQL 实例，并让他们之间保持数据实时同步<br>      分离应用程序对数据库的读写请求，分别发送到从库和主库<br>      - 分离读写的方法(推荐第二种)<br>        1.纯手工方式：修改应用程序 DAO 层代码，定义读写两个数据源，指定每一个数据库请求的数据源<br>        2.组件方式：也可以使用像 Sharding-JDBC这种集成在应用中的第三方组件来实现，这些组件集成在你的应用程序内，代理应用程序的所有数据库请求，自动把请求路由到对应数据库实例上<br>        3.代理方式：在应用程序和数据库实例之间部署一组数据库代理实例， 比如 Atlas 或者 MaxScale。对应用程序来说，数据库代理把自己伪装成一个单节点的 MySQL 实例，应用程序的诉讼有数据库请求被发送到给代理，代理分离读写请求，然后转发给对应的数据库实例。<br>      - 配置多个从库<br>        推荐使用&quot;HAProxy + Keeplived&quot;组合<br>    - 读写分离弊端<br>      可能导致数据不一致的问题，正常不超过1ms<br>      - 解决方法<br>        将同步的一些操作放到一个数据库事务中来做，写与读在一个库<br>        增加一些步骤操作，让 1ms 的同步自然的消耗掉","like_count":17},{"had_liked":false,"id":194547,"user_name":"kyll","can_delete":false,"product_type":"c1","uid":1103329,"ip_address":"","ucode":"2425DCF5753786","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/e1/a05a9e22.jpg","comment_is_top":false,"comment_ctime":1585065893,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"53124673445","product_id":100046801,"comment_content":"原来用mycat，现在我们使用sharding-jdbc，配置简单，对开发透明。而且看官网上未来发展前景不错。sharding可以做到同一个线程内更新后的查询在主库进行，其他的情况也是在交互上做改进了","like_count":12},{"had_liked":false,"id":193982,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1585010292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40239715956","product_id":100046801,"comment_content":"电商直接提示，订单稍后查询😄","like_count":9},{"had_liked":false,"id":193959,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1585007632,"is_pvip":false,"replies":[{"id":"73924","content":"部署在一起。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1585025790,"ip_address":"","comment_id":193959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27354811408","product_id":100046801,"comment_content":"HAproxy keepalived是和mysql部署在同一台机器上的吗？还是部署在单独的机器上的？","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488714,"discussion_content":"部署在一起。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585025790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202629,"user_name":"上山砍柴","can_delete":false,"product_type":"c1","uid":1059766,"ip_address":"","ucode":"F85D250C11ED70","user_header":"https://wx.qlogo.cn/mmopen/vi_32/4pFDynicvRnrTTRavia64UAknQjyX3KFfm67W4AZG52wm2TgwL1FWNX1zhIlIVgicPw2jzPqKASAib5nI1QfY6pc2Q/132","comment_is_top":false,"comment_ctime":1586018530,"is_pvip":false,"replies":[{"id":"76054","content":"即使做了读写分离，一般也不会用MySQL直接抗秒杀请求，还是需要前置保护机制，避免大量的请求打到MySQL上。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1586223258,"ip_address":"","comment_id":202629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23060855010","product_id":100046801,"comment_content":"老师您好！读写分离后，是否可以满足高并发写呢，比如秒杀系统，能够满足瞬间大量订单创建写数据库吗？","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490637,"discussion_content":"即使做了读写分离，一般也不会用MySQL直接抗秒杀请求，还是需要前置保护机制，避免大量的请求打到MySQL上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586223258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194907,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1585119264,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23059955744","product_id":100046801,"comment_content":"HAProxy+Keepalived这套架构：挺好挺稳定，业界使用率很高。<br>偷懒点可以直接用云厂商，不过读写分离的能力确实不敢恭维。","like_count":5,"discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366313,"discussion_content":"读写分离，不是建议使用组件方式：Sharding-JDBC嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618026655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1794060,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/60/0c/e1f012cb.jpg","nickname":"frankie","note":"","ucode":"813D1352B68A21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287507,"discussion_content":"只能做到负载均衡和高可用吧？真的读写分离需要其他中间件了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593459850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194041,"user_name":"怀朔","can_delete":false,"product_type":"c1","uid":1006865,"ip_address":"","ucode":"52FAC1C2FD37B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/11/e1f36640.jpg","comment_is_top":false,"comment_ctime":1585017701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764886885","product_id":100046801,"comment_content":"现在主流的都是用proxy的<br><br>主备延迟怎么解决呢？ <br>1、开启半同步方案<br>2、尽量在主库里面减少大事务、使用不均匀的话开启写后考虑主库读<br>3、有能力的话 分库分表<br>4、增加从库性能<br>5、如果实在无法追平 从新做从库吧","like_count":4},{"had_liked":false,"id":193962,"user_name":"Mq","can_delete":false,"product_type":"c1","uid":1178359,"ip_address":"","ucode":"041F572AFAB275","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","comment_is_top":false,"comment_ctime":1585008401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764877585","product_id":100046801,"comment_content":"        我们系统现在从库没有ha的配置，在检测到主从延迟大于几秒后或故障后，把数据源自动切换切换到主库，如果检测一段时间延长减少又把数据源切换到从库，这种方式目前还行，如果并发真上来了，然后主从同步延迟加大导致切换到主库，可能把主库也搞挂。<br>         缓存有2层，一层是渠道端，策略是我们有更新了发mq消息通知他们删除，一层是我们系统在有导致数据变更的接口调用后会刷缓存，策略是查主库把数据弄到缓存，另外就是设置缓存失效时间，在回到看数据的页面也要几秒，这种针对活跃的数据有较好的效果，不活跃的数据也没有数据延迟的问题","like_count":4},{"had_liked":false,"id":243853,"user_name":"灿烂明天","can_delete":false,"product_type":"c1","uid":1322455,"ip_address":"","ucode":"07DA56B0680D0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/d7/74fc8f38.jpg","comment_is_top":false,"comment_ctime":1598312643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893279939","product_id":100046801,"comment_content":"老师，HAProxy+Keepalived这个方案具体是怎么做的，谢谢","like_count":1},{"had_liked":false,"id":206660,"user_name":"闫冬","can_delete":false,"product_type":"c1","uid":1109691,"ip_address":"","ucode":"1725E869D5A3D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/bb/7afd6824.jpg","comment_is_top":false,"comment_ctime":1586914473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881881769","product_id":100046801,"comment_content":"李老师 主从延迟时间比较短的情况 可以在设计上解决 如果延迟时间比较长呢","like_count":1},{"had_liked":false,"id":198605,"user_name":"木头发芽","can_delete":false,"product_type":"c1","uid":1419723,"ip_address":"","ucode":"657B381C5DA963","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","comment_is_top":false,"comment_ctime":1585459198,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5880426494","product_id":100046801,"comment_content":"阿里云的rds自带读写分离功能，连接数据库是一个url，它通过分析sql语句来决定，更新和事务路由到主库，读写到只读从库，对开发来说无感知，运维只要根据压力情况增加或减少主从节点就好。<br>但老师是不是没有说当单表量太大的时候，读写分离并不能解决压力问题，还得分库","like_count":1,"discussions":[{"author":{"id":2297346,"avatar":"https://static001.geekbang.org/account/avatar/00/23/0e/02/41099234.jpg","nickname":"Django...","note":"","ucode":"56693F8A886FF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379853,"discussion_content":"单表量大时，确实需要考虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624192152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195556,"user_name":"Regis","can_delete":false,"product_type":"c1","uid":1435632,"ip_address":"","ucode":"3911E4EDE27F4E","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/f0/d0bf3a5f.jpg","comment_is_top":false,"comment_ctime":1585196935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880164231","product_id":100046801,"comment_content":"我们公司web开发才刚刚起步，主要公司内部使用，还用不到读写分离，不过老师讲的很透彻，终于知道为什么有些网站支付后会有几秒等待才会返回结果了","like_count":2},{"had_liked":false,"id":194139,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1585029918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879997214","product_id":100046801,"comment_content":"主从同步的问题经常遇到,虽然采用公有云,但是很多时候都不能保证毫秒级响应,我这里的方案是,如果存在DML,并且业务方对实时性要求很高的话,那业务上把数据放到Redis这种高性能的Cache中去,如果要求不高就直接读从库,至于啥时候用读库、啥时候用主库,这个跟老师说的一样,我们在框架层面就给保证了,唯一缺憾就是,如何降低延迟,一直在摸索中...","like_count":1},{"had_liked":false,"id":194113,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1585026450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879993746","product_id":100046801,"comment_content":"京东那么大数据量，数据应该还是要分片的，没法避免","like_count":1},{"had_liked":false,"id":193991,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1585011235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879978531","product_id":100046801,"comment_content":"对于可能存在主从延迟的地方可以采取强制读主库的措施。","like_count":1},{"had_liked":false,"id":193968,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1585008832,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879976128","product_id":100046801,"comment_content":"写后读，走主库","like_count":1},{"had_liked":false,"id":193941,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1585002892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879970188","product_id":100046801,"comment_content":"我们公司用的代理的方式，主从延迟，更新完即读的场景不多，强制读主库解决的，","like_count":1},{"had_liked":false,"id":351656,"user_name":"多学多看多记","can_delete":false,"product_type":"c1","uid":2276155,"ip_address":"","ucode":"0670C833007510","user_header":"https://static001.geekbang.org/account/avatar/00/22/bb/3b/6e020a32.jpg","comment_is_top":false,"comment_ctime":1658055924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658055924","product_id":100046801,"comment_content":"go后端，从组件层面，gorm老框架需要手动区分reader和writer，新框架就不需要区分了，在框架内不做了分离，业务不感知。在系统层面，mysql又做了一层代理，写请求路由到代理的3306端口，读请求路由到3307端口。虽然增加了一层代理，但是分库分表是无感知的，且可以更好地接入k8s集群","like_count":0},{"had_liked":false,"id":299256,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1624536131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624536131","product_id":100046801,"comment_content":"数据库的查询，是不是默认不带事物的？","like_count":0},{"had_liked":false,"id":279512,"user_name":"ezekiel","can_delete":false,"product_type":"c1","uid":1158795,"ip_address":"","ucode":"AB4AB6FA8612D8","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/8b/43ce01ca.jpg","comment_is_top":false,"comment_ctime":1613810356,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1613810356","product_id":100046801,"comment_content":"Cache Aside模式，如果在缓存和数据库里都加上数据的版本号，是否可以避免更新的时候产生脏数据的问题？或者这样的模式会不会有什么问题？","like_count":0,"discussions":[{"author":{"id":2040025,"avatar":"","nickname":"沈璐","note":"","ucode":"923B574059D77F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376502,"discussion_content":"并发情况下用版本号判断也会有问题，要不得引入分布式锁，复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622166851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217116,"user_name":"seg-上海","can_delete":false,"product_type":"c1","uid":1760320,"ip_address":"","ucode":"46BA8DCB06ED5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBllicLBj61g1ibmCeWzLYpQYEteTOtAAAypoIg6CD19ibXQBbM09VsME9Ta1G8ubwk0ibjiacItavibaeg/132","comment_is_top":false,"comment_ctime":1589422132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589422132","product_id":100046801,"comment_content":"业务qps一般到什么水平就要读写分离了，上来就设计成读写分离可以吗","like_count":0},{"had_liked":false,"id":211005,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1587880246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587880246","product_id":100046801,"comment_content":"公司的业务量不是很大，采用了两个数据源，用aop的方式动态切换数据源","like_count":0},{"had_liked":false,"id":207824,"user_name":"王杰","can_delete":false,"product_type":"c1","uid":1944186,"ip_address":"","ucode":"53CC01032E4A25","user_header":"","comment_is_top":false,"comment_ctime":1587191151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587191151","product_id":100046801,"comment_content":"一般是数据分片，加读写分离，对于那些实时要用的放到同一个数据库事务中去，相当于部分的读也是用的主库","like_count":0},{"had_liked":false,"id":194074,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1464199,"ip_address":"","ucode":"854500026E2187","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhuGLVRYZibOTfMumk53Wn8Q0Rkg0o6DzTicbibCq42lWQoZ8lFeQvicaXuZa7dYsr9URMrtpXMVDDww/132","comment_is_top":false,"comment_ctime":1585021244,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1585021244","product_id":100046801,"comment_content":"通过中间件实现读写分离，事务内的强致走主库（中间件方式遇到的问题有：增加运维成本，多了一次网络请求，同时在考虑故障隔离时没想到好的方案）。目前因系统在重构，想将中间件的实现方式改成组件方式，同时想将关系库的数据实时同步至MongoDB中（同步时会调整数据模型便于查询），当做从库供查询使用。","like_count":0,"discussions":[{"author":{"id":1006865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/11/e1f36640.jpg","nickname":"怀朔","note":"","ucode":"52FAC1C2FD37B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212872,"discussion_content":"可以考虑 es 或者 云化搜索内存型数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585026631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1464199,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhuGLVRYZibOTfMumk53Wn8Q0Rkg0o6DzTicbibCq42lWQoZ8lFeQvicaXuZa7dYsr9URMrtpXMVDDww/132","nickname":"hello","note":"","ucode":"854500026E2187","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/11/e1f36640.jpg","nickname":"怀朔","note":"","ucode":"52FAC1C2FD37B6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213486,"discussion_content":"多谢建议，我们业务数据需要复杂sql和存储的横向扩展能力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585098758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212872,"ip_address":""},"score":213486,"extra":""},{"author":{"id":1006865,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/11/e1f36640.jpg","nickname":"怀朔","note":"","ucode":"52FAC1C2FD37B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1464199,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhuGLVRYZibOTfMumk53Wn8Q0Rkg0o6DzTicbibCq42lWQoZ8lFeQvicaXuZa7dYsr9URMrtpXMVDDww/132","nickname":"hello","note":"","ucode":"854500026E2187","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213540,"discussion_content":"第二个产品可以解决复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585103401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213486,"ip_address":""},"score":213540,"extra":""}]}]},{"had_liked":false,"id":194016,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1585015118,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585015118","product_id":100046801,"comment_content":"根源解决不了就绕过去。或者是想办法规避，目标就是业务无影响。<br>对主从延迟敏感的场景强制走主库，用组件的方式+hint很容易切换是从主还是从读数据<br>还有比较关键的是规避导致主从延迟增大","like_count":0},{"had_liked":false,"id":193950,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1585006399,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1585006399","product_id":100046801,"comment_content":"对于数据量大，但是查询量小，或者查询历史数据查询量大的场景，达到最终状态的记录双写一份到ES中，查询时近期数据查DB，远期数据查询ES","like_count":0,"discussions":[{"author":{"id":1975581,"avatar":"http://thirdwx.qlogo.cn/mmopen/2kpMNDYsSfCnhAYmvAsNcYKyNLUJG5iax9BKgXAJzxypEJGRVwhibjZ53S5icgEDibn8uqrqwsKcxzEXfRRUXTdqjA/132","nickname":"岳宜波","note":"","ucode":"5043CA250FDCB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250522,"discussion_content":"双写如何保证数据一致呢？ES和DB数据不一致怎么办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588006328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1975581,"avatar":"http://thirdwx.qlogo.cn/mmopen/2kpMNDYsSfCnhAYmvAsNcYKyNLUJG5iax9BKgXAJzxypEJGRVwhibjZ53S5icgEDibn8uqrqwsKcxzEXfRRUXTdqjA/132","nickname":"岳宜波","note":"","ucode":"5043CA250FDCB1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268246,"discussion_content":"最终状态的数据被再次修改的可能性不大，并且适合归档存储。实现数据的冷热分离，提高查询效率和存储性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589736873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250522,"ip_address":""},"score":268246,"extra":""}]}]}]}