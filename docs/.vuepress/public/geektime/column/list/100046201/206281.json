{"id":206281,"title":"06 | RPC实战：剖析gRPC源码，动手实现一个完整的RPC","content":"<p>你好，我是何小锋。上一讲我分享了动态代理，其作用总结起来就是一句话：“我们可以通过动态代理技术，屏蔽 RPC 调用的细节，从而让使用者能够面向接口编程。”</p><p>到今天为止，我们已经把 RPC 通信过程中要用到的所有基础知识都讲了一遍，但这些内容多属于理论。<strong>这一讲我们就来实战一下，看看具体落实到代码上，我们应该怎么实现一个 RPC 框架？</strong></p><p>为了能让咱们快速达成共识，我选择剖析 gRPC 源码（源码地址：<a href=\"https://github.com/grpc/grpc-java\">https://github.com/grpc/grpc-java</a>）。通过分析 gRPC 的通信过程，我们可以清楚地知道在 gRPC 里面这些知识点是怎么落地到具体代码上的。</p><p>gRPC 是由 Google 开发并且开源的一款高性能、跨语言的 RPC 框架，当前支持 C、Java 和 Go 等语言，当前 Java 版本最新 Release 版为 1.27.0。gRPC 有很多特点，比如跨语言，通信协议是基于标准的 HTTP/2 设计的，序列化支持 PB（Protocol Buffer）和 JSON，整个调用示例如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/86/0d/8671942cd89feea3a2544d3530da450d.jpg?wh=3183*1769\" alt=\"\" title=\"gRPC调用示例图\"></p><p>如果你想快速地了解一个全新框架的工作原理，我个人认为最快的方式就是从使用示例开始，所以现在我们就以最简单的 HelloWord 为例开始了解。</p><p>在这个例子里面，我们会定义一个 say 方法，调用方通过 gRPC 调用服务提供方，然后服务提供方会返回一个字符串给调用方。</p><!-- [[[read_end]]] --><p>为了保证调用方和服务提供方能够正常通信，我们需要先约定一个通信过程中的契约，也就是我们在 Java  里面说的定义一个接口，这个接口里面只会包含一个 say 方法。在 gRPC 里面定义接口是通过写 Protocol Buffer 代码，从而把接口的定义信息通过 Protocol Buffer 语义表达出来。HelloWord 的 Protocol Buffer 代码如下所示：</p><pre><code>syntax = &quot;proto3&quot;;\n\noption java_multiple_files = true;\noption java_package = &quot;io.grpc.hello&quot;;\noption java_outer_classname = &quot;HelloProto&quot;;\noption objc_class_prefix = &quot;HLW&quot;;\n\npackage hello;\n\nservice HelloService{\nrpc Say(HelloRequest) returns (HelloReply) {}\n}\n\nmessage HelloRequest {\nstring name = 1;\n}\n\nmessage HelloReply {\nstring message = 1;\n}\n</code></pre><p>有了这段代码，我们就可以为客户端和服务器端生成消息对象和 RPC 基础代码。我们可以利用 Protocol Buffer 的编译器 protoc，再配合 gRPC Java 插件（protoc-gen-grpc-java），通过命令行 protoc3 加上 plugin 和 proto 目录地址参数，我们就可以生成消息对象和 gRPC 通信所需要的基础代码。如果你的项目是 Maven 工程的话，你还可以直接选择使用 Maven  插件来生成同样的代码。</p><h2>发送原理</h2><p>生成完基础代码以后，我们就可以基于生成的代码写下调用端代码，具体如下：</p><pre><code>package io.grpc.hello;\n\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\n\n\nimport java.util.concurrent.TimeUnit;\n\npublic class HelloWorldClient {\n\n    private final ManagedChannel channel;\n    private final HelloServiceGrpc.HelloServiceBlockingStub blockingStub;\n    /**\n    * 构建Channel连接\n    **/\n    public HelloWorldClient(String host, int port) {\n        this(ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build());\n    }\n\n    /**\n    * 构建Stub用于发请求\n    **/\n    HelloWorldClient(ManagedChannel channel) {\n        this.channel = channel;\n        blockingStub = HelloServiceGrpc.newBlockingStub(channel);\n    }\n    \n    /**\n    * 调用完手动关闭\n    **/\n    public void shutdown() throws InterruptedException {\n        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n\n \n    /**\n    * 发送rpc请求\n    **/\n    public void say(String name) {\n        // 构建入参对象\n        HelloRequest request = HelloRequest.newBuilder().setName(name).build();\n        HelloReply response;\n        try {\n            // 发送请求\n            response = blockingStub.say(request);\n        } catch (StatusRuntimeException e) {\n            return;\n        }\n        System.out.println(response);\n    }\n\n    public static void main(String[] args) throws Exception {\n            HelloWorldClient client = new HelloWorldClient(&quot;127.0.0.1&quot;, 50051);\n            try {\n                client.say(&quot;world&quot;);\n            } finally {\n                client.shutdown();\n            }\n    }\n}\n</code></pre><p><strong>调用端代码大致分成三个步骤：</strong></p><ul>\n<li>首先用 host 和 port 生成 channel 连接；</li>\n<li>然后用前面生成的 HelloService gRPC 创建 Stub 类；</li>\n<li>最后我们可以用生成的这个 Stub 调用 say 方法发起真正的 RPC 调用，后续其它的 RPC 通信细节就对我们使用者透明了。</li>\n</ul><p>为了能看清楚里面具体发生了什么，我们需要进入到 ClientCalls.blockingUnaryCall 方法里面看下逻辑细节。但是为了避免太多的细节影响你理解整体流程，我在下面这张图中只画下了最重要的部分。</p><p><img src=\"https://static001.geekbang.org/resource/image/57/5d/57c7d1c005c1d426ccee48a84e286b5d.jpg?wh=5429*1517\" alt=\"\" title=\"整体流程图\"></p><p>我们可以看到，在调用端代码里面，我们只需要一行（第48行）代码就可以发起一个 RPC 调用，而具体这个请求是怎么发送到服务提供者那端的呢？这对于我们 gRPC 使用者来说是完全透明的，我们只要关注是怎么创建出 stub 对象的就可以了。</p><p>比如入参是一个字符对象，gRPC 是怎么把这个对象传输到服务提供方的呢？因为在<a href=\"https://time.geekbang.org/column/article/202779\">[第 03 讲]</a> 中我们说过，只有二进制才能在网络中传输，但是目前调用端代码的入参是一个字符对象，那在 gRPC 里面我们是怎么把对象转成二进制数据的呢？</p><p>回到上面流程图的第3步，在 writePayload 之前，ClientCallImpl 里面有一行代码就是 method.streamRequest(message)，看方法签名我们大概就知道它是用来把对象转成一个 InputStream，有了 InputStream 我们就很容易获得入参对象的二进制数据。这个方法返回值很有意思，就是为啥不直接返回我们想要的二进制数组，而是返回一个 InputStream 对象呢？你可以先停下来想下原因，我们会在最后继续讨论这个问题。</p><p>我们接着看 streamRequest 方法的拥有者 method 是个什么对象？我们可以看到 method 是 MethodDescriptor 对象关联的一个实例，而 MethodDescriptor 是用来存放要调用 RPC 服务的接口名、方法名、服务调用的方式以及请求和响应的序列化和反序列化实现类。</p><p>大白话说就是，MethodDescriptor 是用来存储一些 RPC 调用过程中的元数据，而在 MethodDescriptor 里面 requestMarshaller 是在绑定请求的时候用来序列化方式对象的，所以当我们调用 method.streamRequest(message) 的时候，实际是调用 requestMarshaller.stream(requestMessage) 方法，而 requestMarshaller 里面会绑定一个 Parser，这个 Parser 才真正地把对象转成了 InputStream 对象。</p><p>讲完序列化在 gRPC 里面的应用后，我们再来看下在 gRPC 里面是怎么完成请求数据“断句”的，就是我们在<a href=\"https://time.geekbang.org/column/article/199651\">[第 02 讲]</a> 中说的那个问题——二进制流经过网络传输后，怎么正确地还原请求前语义？</p><p>我们在 gRPC 文档中可以看到，gRPC 的通信协议是基于标准的 HTTP/2 设计的，而 HTTP/2 相对于常用的 HTTP/1.X 来说，它最大的特点就是多路复用、双向流，该怎么理解这个特点呢？这就好比我们生活中的单行道和双行道，HTTP/1.X 就是单行道，HTTP/2 就是双行道。</p><p>那既然在请求收到后需要进行请求“断句”，那肯定就需要在发送的时候把断句的符号加上，我们看下在 gRPC 里面是怎么加的？</p><p>因为 gRPC 是基于 HTTP/2 协议，而 HTTP/2 传输基本单位是 Frame，Frame 格式是以固定 9 字节长度的 header，后面加上不定长的 payload 组成，协议格式如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/75/d5554644aefe5aaab42718d75a47de75.jpg?wh=3796*1143\" alt=\"\"></p><p>那在 gRPC 里面就变成怎么构造一个 HTTP/2 的 Frame 了。</p><p>现在回看我们上面那个流程图的第 4 步，在 write 到 Netty 里面之前，我们看到在 MessageFramer.writePayload 方法里面会间接调用 writeKnownLengthUncompressed 方法，该方法要做的两件事情就是构造 Frame Header 和 Frame Body，然后再把构造的 Frame 发送到 NettyClientHandler，最后将 Frame 写入到 HTTP/2 Stream 中，完成请求消息的发送。</p><h2>接收原理</h2><p>讲完 gRPC 的请求发送原理，我们再来看下服务提供方收到请求后会怎么处理？我们还是接着前面的那个例子，先看下服务提供方代码，具体如下：</p><pre><code>static class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase {\n\n  @Override\n  public void say(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver) {\n    HelloReply reply = HelloReply.newBuilder().setMessage(&quot;Hello &quot; + req.getName()).build();\n    responseObserver.onNext(reply);\n    responseObserver.onCompleted();\n  }\n}\n</code></pre><p>上面 HelloServiceImpl 类是按照 gRPC 使用方式实现了 HelloService 接口逻辑，但是对于调用者来说并不能把它调用过来，因为我们没有把这个接口对外暴露，在 gRPC 里面我们是采用 Build 模式对底层服务进行绑定，具体代码如下：</p><pre><code>package io.grpc.hello;\n\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.stub.StreamObserver;\n\nimport java.io.IOException;\n\n\npublic class HelloWorldServer {\n\n  private Server server;\n\n  /**\n  * 对外暴露服务\n  **/\n  private void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port)\n        .addService(new HelloServiceImpl())\n        .build()\n        .start();\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        HelloWorldServer.this.stop();\n      }\n    });\n  }\n\n  /**\n  * 关闭端口\n  **/\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  /**\n  * 优雅关闭\n  **/\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final HelloWorldServer server = new HelloWorldServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n  \n}\n</code></pre><p>服务对外暴露的目的是让过来的请求在被还原成信息后，能找到对应接口的实现。在这之前，我们需要先保证能正常接收请求，通俗地讲就是要先开启一个 TCP 端口，让调用方可以建立连接，并把二进制数据发送到这个连接通道里面，这里依然只展示最重要的部分。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/cd/b43a3fb6d6929bb862893aebd7cd40cd.jpg?wh=4614*1541\" alt=\"\"></p><p>这四个步骤是用来开启一个 Netty Server，并绑定编解码逻辑的，如果你暂时看不懂，没关系的，我们可以先忽略细节。我们重点看下 NettyServerHandler 就行了，在这个 Handler  里面会绑定一个 FrameListener，gRPC 会在这个 Listener 里面处理收到数据请求的 Header 和 Body，并且也会处理 Ping、RST 命令等，具体流程如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/f5/98d0ecec8e2c9b75159e86253c6c3cf5.jpg?wh=4606*1527\" alt=\"\"></p><p>在收到 Header 或者 Body 二进制数据后，NettyServerHandler 上绑定的FrameListener 会把这些二进制数据转到 MessageDeframer 里面，从而实现 gRPC 协议消息的解析 。</p><p>那你可能会问，这些 Header 和 Body 数据是怎么分离出来的呢？按照我们前面说的，调用方发过来的是一串二进制数据，这就是我们前面开启 Netty Server 的时候绑定 Default HTTP/2FrameReader 的作用，它能帮助我们按照 HTTP/2 协议的格式自动切分出 Header 和 Body 数据来，而对我们上层应用 gRPC  来说，它可以直接拿拆分后的数据来用。</p><h2>总结</h2><p>这是我们基础篇的最后一讲，我们采用剖析 gRPC 源码的方式来学习如何实现一个完整的 RPC。当然整个 gRPC 的代码量可比这多得多，但今天的主要目就是想让你把前面所学的序列化、协议等方面的知识落实到具体代码上，所以我们这儿只分析了 gRPC 收发请求两个过程。</p><p>实现了这两个过程，我们就可以完成一个点对点的 RPC 功能，但在实际使用的时候，我们的服务提供方通常都是以一个集群的方式对外提供服务的，所以在 gRPC 里面你还可以看到负载均衡、服务发现等功能。而且 gRPC 采用的是 HTTP/2 协议，我们还可以通过 Stream 方式来调用服务，以提升调用性能。</p><p>总的来说，其实我们可以简单地认为<strong>gRPC 就是采用 HTTP/2 协议，并且默认采用 PB 序列化方式的一种 RPC</strong>，它充分利用了 HTTP/2 的多路复用特性，使得我们可以在同一条链路上双向发送不同的 Stream 数据，以解决 HTTP/1.X 存在的性能问题。</p><h2>课后思考</h2><p>我们讲到，在 gRPC 调用的时候，我们有一个关键步骤就是把对象转成可传输的二进制，但是在 gRPC 里面，我们并没有直接转成二进制数组，而是返回一个 InputStream，你知道这样做的好处是什么吗？</p><p>欢迎留言和我分享你的答案，也欢迎你把文章分享给你的朋友，邀请他加入学习。我们下节课再见！</p>","neighbors":{"left":{"article_title":"05 | 动态代理：面向接口编程，屏蔽RPC处理流程","id":205910},"right":{"article_title":"07 | 架构设计：设计一个灵活的RPC框架","id":207137}},"comments":[{"had_liked":false,"id":183982,"user_name":"雨霖铃声声慢","can_delete":false,"product_type":"c1","uid":1052607,"ip_address":"","ucode":"656D98310C6DA3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/bf/ee93c4cf.jpg","comment_is_top":false,"comment_ctime":1583196662,"is_pvip":false,"replies":[{"id":"71620","content":"没错，避免二次拷贝","user_name":"作者回复","comment_id":183982,"uid":"1541007","ip_address":"","utype":1,"ctime":1583621635,"user_name_real":"何小锋"}],"discussion_count":4,"race_medal":0,"score":"280756070902","product_id":100046201,"comment_content":"InputStream封装了底层传输的字节缓冲区实现，它通常是一组通过指针连接起来的内存块的集合，这些内存块由网络的零拷贝获取的。由于不能保证能够从内存块中获取一个byte[]，我们不能传递一个简单的byte[]或byte[][]，并且可能需要一个目标byte[]来从缓冲区中获取数据。<br>另外byte[]的缺点是需要从缓冲区中复制一个大的、连续的数据，而实际上没有什么方法可以使它执行得更好。当使用压缩时，我们也不知道消息未压缩的长度，它是动态解压缩的。","like_count":66,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485839,"discussion_content":"没错，避免二次拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583621635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2524569,"avatar":"https://static001.geekbang.org/account/avatar/00/26/85/99/171b34d2.jpg","nickname":"Zmha_","note":"","ucode":"6DCF245FF797F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375315,"discussion_content":"应该是英文翻译的……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621572731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347101,"discussion_content":"什么是没有办法使它执行的更好。。。没看懂这是英文翻译过来的吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612151738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401400,"discussion_content":"类似于传指针和传值的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633658820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199272,"user_name":"tulip","can_delete":false,"product_type":"c1","uid":1739012,"ip_address":"","ucode":"44BB22410A848D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/89/04/c1474869.jpg","comment_is_top":false,"comment_ctime":1585485499,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"117549602491","product_id":100046201,"comment_content":"老师可以出一期go 的嘛","like_count":27,"discussions":[{"author":{"id":1739012,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/89/04/c1474869.jpg","nickname":"tulip","note":"","ucode":"44BB22410A848D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333843,"discussion_content":"自己用golang实现了一个简单版的https://github.com/Mrliu8023/easyrpc","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607649485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1187577,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/f9/bfb54326.jpg","nickname":"狮锅艺","note":"","ucode":"1B4AD130F9D0CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266434,"discussion_content":"golang版本，推荐参考一下https://promacanthus.netlify.app/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/grpc/07-golang%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/  ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589513234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183733,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1583121323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57417696171","product_id":100046201,"comment_content":"老师能否把代码提交到github上，我们可以下载下来跑一跑，看一看","like_count":13},{"had_liked":false,"id":184919,"user_name":"楼下小黑哥","can_delete":false,"product_type":"c1","uid":1014680,"ip_address":"","ucode":"453B099B0EE52E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg","comment_is_top":false,"comment_ctime":1583453220,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40238158884","product_id":100046201,"comment_content":"网上搜索资料查到，分享一下：<br>A stream also has the advantage that you don&#39;t have to have all bytes in memory at the same time, which is convenient if the size of the data is large and can easily be handled in small chunks.","like_count":9,"discussions":[{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360308,"discussion_content":"翻译：流的另一个优点是，您不必同时将所有字节都存储在内存中，如果数据的大小很大，并且可以很容易地以小块的形式处理，这是很方便的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616416335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183771,"user_name":"超威丶","can_delete":false,"product_type":"c1","uid":1180753,"ip_address":"","ucode":"1A18DE885D3C44","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/51/da465a93.jpg","comment_is_top":false,"comment_ctime":1583132175,"is_pvip":false,"replies":[{"id":"71623","content":"stream传输是建立在多路复用的基础上","user_name":"作者回复","comment_id":183771,"uid":"1541007","ip_address":"","utype":1,"ctime":1583621898,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"35942870543","product_id":100046201,"comment_content":"难道http2的核心实现不就是基于流实现？","like_count":8,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485774,"discussion_content":"stream传输是建立在多路复用的基础上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583621898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333571,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1644409144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27414212920","product_id":100046201,"comment_content":"这里说一下对inpustream的理解。首先要理解，当网卡接收到数据之后是存放到缓冲区的，这里其实已经分配过空间了。而上层应用想拿到这些数据，可以再次分配一段空间，然后把数据从缓冲区复制到这里，但是这样就多了一次复制了。而为了解决这个问题，inputstream本质上就是一段指针，指向了缓冲区的数据，那样可以直接使用这段地址的数据。不管用什么语言实现，本质思想都是类似的。","like_count":6},{"had_liked":false,"id":186391,"user_name":"四喜","can_delete":false,"product_type":"c1","uid":1071389,"ip_address":"","ucode":"C5EBED19C0F332","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/1d/c89abcd8.jpg","comment_is_top":false,"comment_ctime":1583834075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27353637851","product_id":100046201,"comment_content":"分享一下Python的Tutorial：<br><br>gRPC Basics - Python：https:&#47;&#47;grpc.io&#47;docs&#47;tutorials&#47;basic&#47;python&#47;<br><br>gRPC Python Quick Start：https:&#47;&#47;grpc.io&#47;docs&#47;quickstart&#47;python&#47;","like_count":6},{"had_liked":false,"id":183844,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1583144668,"is_pvip":false,"replies":[{"id":"71625","content":"是的，例子里面的需要在客户端等待","user_name":"作者回复","comment_id":183844,"uid":"1541007","ip_address":"","utype":1,"ctime":1583622117,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"27352948444","product_id":100046201,"comment_content":"老师，有个疑问。按道理客户端发起一次rpc调用，通过序列化、网络传输、服务端处理再响应，这期间有时间差的。上面客户端代码除非是阻塞的，否则不可能立马得到结果吧。","like_count":6,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485798,"discussion_content":"是的，例子里面的需要在客户端等待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583622117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184363,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1583298669,"is_pvip":true,"replies":[{"id":"71618","content":"内部应用之间通信更强调性能","user_name":"作者回复","comment_id":184363,"uid":"1541007","ip_address":"","utype":1,"ctime":1583621330,"user_name_real":"何小锋"}],"discussion_count":5,"race_medal":0,"score":"10173233261","product_id":100046201,"comment_content":"老师 有说法是内部调用用rpc 外部用http 这是为什么呀","like_count":2,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485988,"discussion_content":"内部应用之间通信更强调性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583621330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438037,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/55/8ac4f169.jpg","nickname":"陈国林","note":"","ucode":"83D12F3E79F197","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196044,"discussion_content":"大胆来回答下，一起学习。\n1. 目前互联网产品面向用户的形态大部分是APP+网页的形式，这种情况下APP或网页我们称之为客户端。这种场景下客户端跟服务端交互大部分是采用 HTTP 协议，目前用的最多的是 HTTP 1.1 版本，这就是所谓的【外部】。为什么用 HTTP 呢？最主要的原因是 HTTP 协议已经很成熟了，而且协议无状态、明文传输，对于客户端来说非常优好。\n2. 知道了外部的定义后，【内部】的定义就很好理解，所谓内部就是指服务端内部之间服务调用，常用于微服务之间服务调用。为什么服务之间用RPC，其实本质问题就是为什么内部调用不用HTTP协议？我们知道服务内部调用对性能要求是比较高的，通常服务内部调用QPS比外部高可能不止一个量级。为了提高性能，我们就需要尽量减少服务调用之间的数据传输，并且能够自定义协议。 显然 HTTP 协议不太符合这个需求，当然如果调用量不大用 HTTP 是最方便的，如果量大一般都是选择 RPC 协议。目前RPC协议没有明确的公认标准，所以一般大厂都会自己实现","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1583328525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2826205,"avatar":"","nickname":"hillwater","note":"","ucode":"FB16D5FCE8C7E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589810,"discussion_content":"外部我们也用私有协议的rpc，主要也是用于大流量。小流量rest够了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665319913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215542,"discussion_content":"网络问题，机房内网稳定，所以，性能越快越好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585351814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318915,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2SjCeylLv0P3Glle5277kA4b8cAuxr1NrC0njPKEqzSpB8IEicHB29GicFFwG1qiaxs4hxRiaBmoibVw/132","nickname":"阳仔","note":"","ucode":"4907A3750CEAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197779,"discussion_content":"外部你想用rpc也可以的hhh，但是rpc是基于tcpip，现在国内公网ip那么少，问题是客户端不会有公网ip的吧，这个只是个猜想，希望有缘人能解答一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583436757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347039,"user_name":"Hzº","can_delete":false,"product_type":"c1","uid":2407065,"ip_address":"","ucode":"8EC62B8F7F2163","user_header":"https://static001.geekbang.org/account/avatar/00/24/ba/99/da85915f.jpg","comment_is_top":false,"comment_ctime":1653637144,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948604440","product_id":100046201,"comment_content":"感觉对Java不熟悉的同学，不太友好","like_count":1},{"had_liked":false,"id":198663,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1585462859,"is_pvip":false,"replies":[{"id":"74949","content":"可以看下grpc官网或者搜索一下","user_name":"作者回复","comment_id":198663,"uid":"1541007","ip_address":"","utype":1,"ctime":1585570861,"user_name_real":"何小锋"}],"discussion_count":2,"race_medal":0,"score":"5880430155","product_id":100046201,"comment_content":"老师好，可以把 为客户端和服务器端生成消息对象和 RPC 基础代码 的命令提供出来吗？谢谢。","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489737,"discussion_content":"可以看下grpc官网或者搜索一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585570861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217566,"discussion_content":"谢谢老师，我昨天憋了很久，憋出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585570907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183654,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1583108146,"is_pvip":false,"replies":[{"id":"71638","content":"在传输层也需要用stream，避免二次拷贝","user_name":"作者回复","comment_id":183654,"uid":"1541007","ip_address":"","utype":1,"ctime":1583626445,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"5878075442","product_id":100046201,"comment_content":"以流的方式处理请求数据，适合请求数据数据量大情况。好比Sax和Dom区别。","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485742,"discussion_content":"在传输层也需要用stream，避免二次拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583626445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359672,"user_name":"Geek_757cbc","can_delete":false,"product_type":"c1","uid":2943897,"ip_address":"上海","ucode":"ECE10235F88FEA","user_header":"","comment_is_top":false,"comment_ctime":1665740152,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1665740152","product_id":100046201,"comment_content":"static class HelloServiceImpl 报错，去掉static调试成功","like_count":0},{"had_liked":false,"id":316773,"user_name":"墨白","can_delete":false,"product_type":"c1","uid":2259490,"ip_address":"","ucode":"D884B9C0056C80","user_header":"https://static001.geekbang.org/account/avatar/00/22/7a/22/45307c91.jpg","comment_is_top":false,"comment_ctime":1634548268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634548268","product_id":100046201,"comment_content":"老师httpclient底层也是基于socket封装，为什么没有基于FileChannelimp零拷贝的实现","like_count":0},{"had_liked":false,"id":239683,"user_name":"Di Yu","can_delete":false,"product_type":"c1","uid":1248429,"ip_address":"","ucode":"9AC55943F7D5D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/ad/d1ab1995.jpg","comment_is_top":false,"comment_ctime":1596615281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596615281","product_id":100046201,"comment_content":"gRPC看起来没有用到动态代理吗？在调用端代码里边我们手动的建立了channel，然后手动的call blockingStub.say(request)。这是为了更好的性能吧？如果要用动态代理，那我们会把建立channel等事情放到代理类里边，这样调用端代码就简化一些了，这样理解对吗？","like_count":0},{"had_liked":false,"id":216733,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1589333904,"is_pvip":false,"replies":[{"id":"80445","content":"👍","user_name":"作者回复","comment_id":216733,"uid":"1541007","ip_address":"","utype":1,"ctime":1589500679,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"1589333904","product_id":100046201,"comment_content":"我们讲到，在 gRPC 调用的时候，我们有一个关键步骤就是把对象转成可传输的二进制，但是在 gRPC 里面，我们并没有直接转成二进制数组，而是返回一个 InputStream，你知道这样做的好处是什么吗？<br><br>这个不知道哎😂<br>猜测是为性能故，看评论区的讨论，猜测是正确的，不过细节还是不太清楚，需要后补一下。<br><br>Inputstream——避免二次拷贝（序列化＋encode）——更高的性能。","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494927,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589500679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211679,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1587995289,"is_pvip":false,"replies":[{"id":"79140","content":"序列化和encode","user_name":"作者回复","comment_id":211679,"uid":"1541007","ip_address":"","utype":1,"ctime":1588407425,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"1587995289","product_id":100046201,"comment_content":"为什么能避免二次拷贝？","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493332,"discussion_content":"序列化和encode","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588407425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184934,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1583455323,"is_pvip":false,"replies":[{"id":"71617","content":"grpc是用http2来传输的","user_name":"作者回复","comment_id":184934,"uid":"1541007","ip_address":"","utype":1,"ctime":1583621139,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"1583455323","product_id":100046201,"comment_content":"这样跟HTTP2有什么区别呢","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486177,"discussion_content":"grpc是用http2来传输的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583621139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183931,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1583163701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583163701","product_id":100046201,"comment_content":"精彩","like_count":0},{"had_liked":false,"id":183640,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1583102838,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583102838","product_id":100046201,"comment_content":"我猜的是网络字节序问题吧😊","like_count":0,"discussions":[{"author":{"id":2062475,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bxaaILnBnJSZFCicMjePPueyEWzQfQBPETvW0l8rX7fPgT7o0ojVrtuoqDiaa2ibAk28USKia4CDzYu1HzjoIUZ8Gw/132","nickname":"追求","note":"","ucode":"2E3F5A57F89FA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292758,"discussion_content":"老师，gRPC支持微信小程端吗？ 还有thrift支持微信小程序端吗？ 谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595322036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}