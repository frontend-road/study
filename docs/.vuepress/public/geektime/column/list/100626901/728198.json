{"id":728198,"title":"17｜tokio编程： Rust异步编程还有哪些需要注意的点？","content":"<p>你好，我是Mike。前面几节课，我们学习了Rust异步编程和tokio的基础知识，我们先来简单回顾下。</p><ol>\n<li><code>async/.await</code> 语法</li>\n<li>tokio基本概念和组件</li>\n<li>使用tokio编写一个网络并发应用</li>\n<li>使用Arc和Mutex在多个task之间共享数据</li>\n<li>在并发task之间使用Channel传递数据</li>\n</ol><p>通过学习这些内容，你应该已经能使用tokio开发Rust异步并发应用了。这节课，我们对Rust异步并发相关的知识点来做一点补遗。</p><h2>async其他知识点</h2><p>Rust代码中的async函数，其实和Rust的普通函数是不相容的。async Rust就好像是Rust语言里的一个独立王国。</p><h3>async代码的传染性</h3><p>Rust async代码具有传染性。前面我们给出了使用 <code>async/.await</code> 的两条规则。</p><ol>\n<li>async函数或block只有被 <code>.await</code> 后才被驱动。</li>\n<li><code>.await</code> 只能在async函数或block中使用。</li>\n</ol><p>这就导致在业务代码中（非tokio那个顶层Runtime代码），如果你需要调用一个async函数，那么你也需要让你现在这个调用者函数也是async的，你可以看我给出的这个例子。</p><pre><code class=\"language-plain\">// 我们定义foo1为一个异步函数\nasync fn foo1() -&gt; u32 {\n  100u32\n}\n// 我需要在foo2函数中调用foo1，那么这个foo2也必需要是async函数\nasync fn foo2() -&gt; u32 {\n  foo1().await\n}\n// 我需要在foo3函数中调用foo2，那么这个foo3也必需要是async函数\nasync fn foo3() -&gt; u32 {\n  foo2().await\n}\n\n#[tokio::main]\nasync main() {\n  let num = foo3().await;\n  println!(\"{}\", num);\n}\n</code></pre><!-- [[[read_end]]] --><p>这就叫作async代码的传染性。这种传染性是由Rust的async语法带来的。</p><blockquote>\n<p><span class=\"reference\">注：Rust中还有一个语法具有传染性——类型参数T。</span></p>\n</blockquote><p>但是实际工作中，我们经常会遇到异步代码与同步代码混合使用的情况。这类情况应该怎么处理呢？下面我们分情况来分析。</p><h3>async代码环境中的同步代码</h3><p>常见的同步代码分两类，一类是直接在内存里的简单操作，比如 <code>vec.push()</code> 这种API接口的调用。这类操作在std Rust里怎么使用在async Rust里就怎么使用，一样的。</p><pre><code class=\"language-plain\">async fn foo1() -&gt; u32 {\n  let mut vec = Vec::new();\n  vec.push(10);\n}\n</code></pre><p>另外有一类操作，要么是需要执行长时间的计算，要么是需要调用第三方已经写好的同步库的代码，你没有办法去修改它。对于这类函数的调用，你当然也可以直接调用：</p><pre><code class=\"language-plain\">async fn foo1() -&gt; u32 {\n  let result = a_heavy_work();\n}\n</code></pre><p>这样写当然是可以运行的，但会有性能上的问题：它会阻塞当前正在跑这个异步代码的系统线程（OS Thread，由tokio来管理维护），所以当前的这个系统线程就会被卡住，而不能再跑其他异步代码了。</p><p>好消息是，tokio专门给我们提供了另外的设施来处理这种情况，就是 <code>task::spawn_blocking()</code> 函数。你可以看一下它的使用方法。</p><pre><code class=\"language-plain\">#[tokio::main]\nasync fn main() {\n    // 此任务跑在一个单独的线程中\n    let blocking_task = tokio::task::spawn_blocking(|| {\n        // 在这里面可以执行阻塞线程的代码\n    });\n    // 像下面这样用同样的方式等待这种阻塞式任务的完成\n    blocking_task.await.unwrap();\n}\n</code></pre><p>只需要把CPU计算密集型任务放到 <code>task::spawn_blocking()</code> 里就可以了，tokio会帮我们单独开一个新的系统线程，来专门跑这个CPU计算密集型的task。然后和普通的tokio task一样，可以通过await来获取它的结果，当然，也可以用Oneshot channel把结果返回回来。</p><p>给这种CPU计算密集型任务单独开一个系统线程运行，就能保证我们当前跑异步任务的系统线程不会被这个CPU计算密集型任务占据，导致异步并发能力下降，因此我们得到了一个比较好的方案。</p><p>一般来讲，主体是async代码，只有一些小部分是同步代码的时候，使用 <code>task::spawn_blocking()</code> 比较合适。</p><h3>同步代码环境中的async代码</h3><p>那如果主体代码是同步代码（或者叫 std Rust 代码），但是局部想调用一些async接口，比如db driver只提供了async封装，像这种情况下该怎么办呢？</p><p>回想一下我们前面讲到的，展开 <code>#[tokio::main]</code>。</p><pre><code class=\"language-plain\">#[tokio::main]\nasync fn main() {\n    println!(\"Hello world\");\n}\n</code></pre><p>展开后，其实是下面这个样子：</p><pre><code class=\"language-plain\">fn main() {\n    tokio::runtime::Builder::new_multi_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            println!(\"Hello world\");\n        })\n}\n</code></pre><p>类似地，我们要在同步风格的代码中执行async代码，只需要手动 block_on 这段异步代码就可以了。除了默认的系统多线程Runtime之外，tokio专门为这种临时的（以及测试的）场景提供了另一种单系统线程的runtime，就是 <code>new_current_thread()</code>。它的意思是就在当前程序执行的线程中建立tokio Runtime，异步任务就跑在当前这个线程中。比如：</p><pre><code class=\"language-plain\">async fn foo1() -&gt; u32 {\n&nbsp;   10\n}\n\nfn foo() {\n  &nbsp; let rt = tokio::runtime::Builder::new_current_thread()\n  &nbsp; &nbsp; &nbsp; &nbsp; .enable_all()\n  &nbsp; &nbsp; &nbsp; &nbsp; .build().unwrap();\n  \n  &nbsp; let num = rt.block_on(foo1());  // 注意这一句的 foo1()，调用了此异步函数\n    // 或者像下面这样写\n    //let num = rt.block_on(async {\n&nbsp; &nbsp; //&nbsp; &nbsp; foo1().await\n&nbsp; &nbsp; //});\n  &nbsp; println!(\"{}\", num);\n}\n\nfn main() {\n&nbsp;   foo();\n}\n// 输出 \n10\n</code></pre><p>就通过这种方式，我们在主体为std Rust的代码中，成功地调用了局部的async Rust代码，并得到了这段局部异步代码的返回值。</p><h2>Rust async实现原理</h2><p>Rust 的async实现实际采用的是一种无栈协程（Stackless Coroutine）方案。它的实现是非常高效的，性能在所有支持异步语法的语言中属于最高的那一级，非常厉害。</p><h3>Rust async的背后原理</h3><p>Rust语言实际会把 async 语法编译成 std Rust 中的状态机，然后通过运行时底层的 poll 机制来轮询这个状态机的状态。所以本质上来讲，<code>async/.await</code> 语法只是语法糖。</p><p>简单来说，Rust会把一个async函数转换成另一种东西，你可以看一下我给出的转换示例。</p><p>async函数：</p><pre><code class=\"language-plain\">async fn foo1() -&gt; u32 {\n  10\n}\n</code></pre><p>转换后：</p><pre><code class=\"language-plain\">struct FutureA {\n    ...\n}\nimpl Future for FutureA {\n    ...\n}\n</code></pre><p>具体的转换和实现细节我们现在不需要掌握，只需要知道，Rust的这种实现并不是像Go或Java那样，在系统级线程的基础上，单独实现了一层结合GC内存管理且具有完整屏蔽性的轻量级线程，它没有选择在OS应用之间引入一个层（layer），而是在结构体之上构建一个状态机，以零成本抽象（zero cost abstract）为原则，尽量少地引入额外的消耗，配合 <code>async/.await</code> 语法糖，来达到简化程序员开发难度的效果。</p><p>这种方案成功地让Rust的异步并发能力达到业界顶尖水平。Rust异步语法从提案到稳定推出，前后经历了大量的讨论和修改，花了将近5年的时间，非常不容易，是整个Rust社区共同努力的结果，期间的故事称得上是全世界开源协作的典范。</p><h3>其他一些要注意的问题</h3><p>Rust async编程也一直处于不断地发展过程中，比如目前在 trait 里，就不能定义async 方法，比如：</p><pre><code class=\"language-plain\">trait MyTrait {\n    async fn f() {}\n}\n// 编译错误\nerror[E0706]: trait fns cannot be declared `async`\n --&gt; src/main.rs:4:5\n  |\n4 |     async fn f() {}\n  |     \n</code></pre><p>为了解决这个问题，我们可以引入 <code>async_trait crate</code> 的 <code>async_trait</code> 宏来暂时过渡。</p><pre><code class=\"language-plain\">use async_trait::async_trait;\n\n#[async_trait]    // 定义时加\ntrait MyTrait {\n    async fn f() {}\n}\n\nstruct Modal;\n\n#[async_trait]    // impl 时也要加\nimpl MyTrait for Modal {}\n</code></pre><p>请注意上述代码中，在定义trait和impl trait的时候，都需要添加 <code>#[async_trait]</code> 属性宏来标注。添加了这个宏标注后，trait里的 async fn 就可以像普通的async fn 那样在异步代码中被调用了。</p><p>目前使用这个宏会有一点性能上的开销，好在trait中的async fn这个特性Rust官方也快稳定下来了，估计在1.75版本正式推出，到时候就可以去掉这个宏标注了。</p><h2>小结</h2><p>这节课我补充了Rust异步并发编程中剩下的一些需要注意的知识点。</p><p>我们一共花了5节课的时间来讲解async Rust和tokio的使用，这是因为异步并发编程对于一个场景，也就是高性能高并发服务来说，至关重要。在后面的Web后端服务开发实战部分，我们还会继续基于tokio进行讲解。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/aa/a005e69a5cfdacd5a93ae841a32c07aa.jpg?wh=1920x1172\" alt=\"图片\"></p><h2>思考题</h2><p>你是如何理解 “async Rust是一个独立王国”这种说法的？欢迎你分享自己的见解，我们一起讨论，如果你觉得这节课的内容对你有帮助的话，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p><p>参考链接：<a href=\"https://tokio.rs/tokio/topics/bridging\">https://tokio.rs/tokio/topics/bridging</a></p>","neighbors":{"left":{"article_title":"16｜tokio编程：使用channel在不同任务间通信？","id":728107},"right":{"article_title":"18｜错误处理系统：错误的构建、传递和处理","id":729009}},"comments":[{"had_liked":false,"id":386079,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"浙江","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1704006047,"is_pvip":false,"replies":[{"id":140719,"content":"对的，已经支持了","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704162161,"ip_address":"重庆","comment_id":386079,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师，新的1.75是不是支持asnyc trait了","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634867,"discussion_content":"对的，已经支持了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704162162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384579,"user_name":"Geek_e72251","can_delete":false,"product_type":"c1","uid":3733050,"ip_address":"广东","ucode":"894904DE2E6AC0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/VF71Gcf2C2bjYPFCRv0TPfwhkJmT5WhtusltuaXQM0KMDibdallNFypqWV6v2FJ4bqNwzujiaF5LEDeia7JMZTTtw/132","comment_is_top":false,"comment_ctime":1701179815,"is_pvip":false,"replies":[{"id":140283,"content":"好讷","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701220094,"ip_address":"重庆","comment_id":384579,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"期待axum的实战","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632690,"discussion_content":"好讷","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701220094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384491,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"中国香港","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1701056640,"is_pvip":false,"replies":[{"id":140271,"content":"这个课程定位问题，对于很多业务语言过来的同学，暂时不需要了解那些东西的。另外一方面，网上已经有很多资料讲解那些了，可以去搜搜看。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701067728,"ip_address":"重庆","comment_id":384491,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"等了一个周末就7分钟的课程，而且最近几节将tokio的内容相对有点不充实，既然是进阶篇，异步这一块把 Future、Executor 的实现原理带着分析下。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632606,"discussion_content":"这个课程定位问题，对于很多业务语言过来的同学，暂时不需要了解那些东西的。另外一方面，网上已经有很多资料讲解那些了，可以去搜搜看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701067728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1287406,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a4/ee/b960a322.jpg","nickname":"mihello","note":"","ucode":"4B1E7B7A141606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635361,"discussion_content":"老师有无可能搞个体系课，训练营之类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704766681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384482,"user_name":"不忘初心","can_delete":false,"product_type":"c1","uid":3737491,"ip_address":"四川","ucode":"8262D42405F4E2","user_header":"https://static001.geekbang.org/account/avatar/00/39/07/93/710c7ee2.jpg","comment_is_top":false,"comment_ctime":1701042368,"is_pvip":false,"replies":[{"id":140269,"content":"哈哈，压力山大","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701052040,"ip_address":"重庆","comment_id":384482,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"每天能更新一节就好了, 隔天更新拖的时间太长了","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632595,"discussion_content":"哈哈，压力山大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701052040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384480,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1701039384,"is_pvip":false,"replies":[{"id":140268,"content":"好的好的。正在✍️","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701052031,"ip_address":"重庆","comment_id":384480,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"期待老师的实战课程","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632594,"discussion_content":"好的好的。正在✍️","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701052031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395239,"user_name":"青云","can_delete":false,"product_type":"c1","uid":1185038,"ip_address":"美国","ucode":"6B059CEE8B3300","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/0e/a0a26779.jpg","comment_is_top":false,"comment_ctime":1729834556,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"这几个RUST专栏里面最适合入门的","like_count":0}]}