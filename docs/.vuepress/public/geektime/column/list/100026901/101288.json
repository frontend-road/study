{"id":101288,"title":"18 | metaclass，是潘多拉魔盒还是阿拉丁神灯？","content":"<p>你好，我是蔡元楠，极客时间《大规模数据处理实战》专栏的作者。今天我想和你分享的主题是：metaclass，是潘多拉魔盒还是阿拉丁神灯？</p><p>Python中有很多黑魔法，比如今天我将分享的metaclass。我认识许多人，对于这些语言特性有两种极端的观点。</p><ul>\n<li>一种人觉得这些语言特性太牛逼了，简直是无所不能的阿拉丁神灯，必须找机会用上才能显示自己的Python实力。</li>\n<li>另一种观点则是认为这些语言特性太危险了，会蛊惑人心去滥用，一旦打开就会释放“恶魔”，让整个代码库变得难以维护。</li>\n</ul><p>其实这两种看法都有道理，却又都浅尝辄止。今天，我就带你来看看，metaclass到底是潘多拉魔盒还是阿拉丁神灯？</p><p>市面上的很多中文书，都把metaclass译为“元类”。我一直认为这个翻译很糟糕，所以也不想在这里称metaclass为元类。因为如果仅从字面理解，“元”是“本源”“基本”的意思，“元类”会让人以为是“基本类”。难道Python的metaclass，指的是Python 2的Object吗？这就让人一头雾水了。</p><p>事实上，meta-class的meta这个词根，起源于希腊语词汇meta，包含下面两种意思：</p><ol>\n<li>“Beyond”，例如技术词汇metadata，意思是描述数据的超越数据；</li>\n<li>“Change”，例如技术词汇metamorphosis，意思是改变的形态。</li>\n</ol><!-- [[[read_end]]] --><p>metaclass，一如其名，实际上同时包含了“超越类”和“变形类”的含义，完全不是“基本类”的意思。所以，要深入理解metaclass，我们就要围绕它的<strong>超越变形</strong>特性。接下来，我将为你展开metaclass的超越变形能力，讲清楚metaclass究竟有什么用？怎么应用？Python语言设计层面是如何实现metaclass的 ？以及使用metaclass的风险。</p><h2>metaclass的超越变形特性有什么用？</h2><p><a href=\"https://pyyaml.org/wiki/PyYAMLDocumentation\">YAML</a>是一个家喻户晓的Python工具，可以方便地序列化/逆序列化结构数据。YAMLObject的一个<strong>超越变形能力</strong>，就是它的任意子类支持序列化和反序列化（serialization &amp; deserialization）。比如说下面这段代码：</p><pre><code>class Monster(yaml.YAMLObject):\n  yaml_tag = u'!Monster'\n  def __init__(self, name, hp, ac, attacks):\n    self.name = name\n    self.hp = hp\n    self.ac = ac\n    self.attacks = attacks\n  def __repr__(self):\n    return &quot;%s(name=%r, hp=%r, ac=%r, attacks=%r)&quot; % (\n       self.__class__.__name__, self.name, self.hp, self.ac,      \n       self.attacks)\n\nyaml.load(&quot;&quot;&quot;\n--- !Monster\nname: Cave spider\nhp: [2,6]    # 2d6\nac: 16\nattacks: [BITE, HURT]\n&quot;&quot;&quot;)\n\nMonster(name='Cave spider', hp=[2, 6], ac=16, attacks=['BITE', 'HURT'])\n\nprint yaml.dump(Monster(\n    name='Cave lizard', hp=[3,6], ac=16, attacks=['BITE','HURT']))\n\n# 输出\n!Monster\nac: 16\nattacks: [BITE, HURT]\nhp: [3, 6]\nname: Cave lizard\n</code></pre><p>这里YAMLObject的特异功能体现在哪里呢？</p><p>你看，调用统一的yaml.load()，就能把任意一个yaml序列载入成一个Python Object；而调用统一的yaml.dump()，就能把一个YAMLObject子类序列化。对于load()和dump()的使用者来说，他们完全不需要提前知道任何类型信息，这让超动态配置编程成了可能。在我的实战经验中，许多大型项目都需要应用这种超动态配置的理念。</p><p>比方说，在一个智能语音助手的大型项目中，我们有1万个语音对话场景，每一个场景都是不同团队开发的。作为智能语音助手的核心团队成员，我不可能去了解每个子场景的实现细节。</p><p>在动态配置实验不同场景时，经常是今天我要实验场景A和B的配置，明天实验B和C的配置，光配置文件就有几万行量级，工作量真是不小。而应用这样的动态配置理念，我就可以让引擎根据我的文本配置文件，动态加载所需要的Python类。</p><p>对于YAML的使用者，这一点也很方便，你只要简单地继承yaml.YAMLObject，就能让你的Python Object具有序列化和逆序列化能力。是不是相比普通Python类，有一点“变态”，有一点“超越”？</p><p>事实上，我在Google见过很多Python开发者，发现能深入解释YAML这种设计模式优点的人，大概只有10%。而能知道类似YAML的这种动态序列化/逆序列化功能正是用metaclass实现的人，更是凤毛麟角，可能只有1%了。</p><h2>metaclass的超越变形特性怎么用？</h2><p>刚刚提到，估计只有1%的Python开发者，知道YAML的动态序列化/逆序列化是由metaclass实现的。如果你追问，YAML怎样用metaclass实现动态序列化/逆序列化功能，可能只有0.1%的人能说得出一二了。</p><p>因为篇幅原因，我们这里只看YAMLObject的load()功能。简单来说，我们需要一个全局的注册器，让YAML知道，序列化文本中的 <code>!Monster</code> 需要载入成 Monster这个Python类型。</p><p>一个很自然的想法就是，那我们建立一个全局变量叫 registry，把所有需要逆序列化的YAMLObject，都注册进去。比如下面这样：</p><pre><code>registry = {}\n\ndef add_constructor(target_class):\n    registry[target_class.yaml_tag] = target_class\n</code></pre><p>然后，在Monster 类定义后面加上下面这行代码：</p><pre><code>add_constructor(Monster)\n</code></pre><p>但这样的缺点也很明显，对于YAML的使用者来说，每一个YAML的可逆序列化的类Foo定义后，都需要加上一句话，<code>add_constructor(Foo)</code>。这无疑给开发者增加了麻烦，也更容易出错，毕竟开发者很容易忘了这一点。</p><p>那么，更优的实现方式是什么样呢？如果你看过YAML的源码，就会发现，正是metaclass解决了这个问题。</p><pre><code># Python 2/3 相同部分\nclass YAMLObjectMetaclass(type):\n  def __init__(cls, name, bases, kwds):\n    super(YAMLObjectMetaclass, cls).__init__(name, bases, kwds)\n    if 'yaml_tag' in kwds and kwds['yaml_tag'] is not None:\n      cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml)\n  # 省略其余定义\n\n# Python 3\nclass YAMLObject(metaclass=YAMLObjectMetaclass):\n  yaml_loader = Loader\n  # 省略其余定义\n\n# Python 2\nclass YAMLObject(object):\n  __metaclass__ = YAMLObjectMetaclass\n  yaml_loader = Loader\n  # 省略其余定义\n</code></pre><p>你可以发现，YAMLObject把metaclass都声明成了YAMLObjectMetaclass，尽管声明方式在Python 2 和3中略有不同。在YAMLObjectMetaclass中， 下面这行代码就是魔法发生的地方：</p><pre><code>cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml) \n</code></pre><p>YAML应用metaclass，拦截了所有YAMLObject子类的定义。也就说说，在你定义任何YAMLObject子类时，Python会强行插入运行下面这段代码，把我们之前想要的<code>add_constructor(Foo)</code>给自动加上。</p><pre><code>cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml)\n</code></pre><p>所以YAML的使用者，无需自己去手写<code>add_constructor(Foo)</code> 。怎么样，是不是其实并不复杂？</p><p>看到这里，我们已经掌握了metaclass的使用方法，超越了世界上99.9%的Python开发者。更进一步，如果你能够深入理解，Python的语言设计层面是怎样实现metaclass的，你就是世间罕见的“Python大师”了。</p><h2><strong>Python底层语言设计层面是如何实现metaclass的？</strong></h2><p>刚才我们提到，metaclass能够拦截Python类的定义。它是怎么做到的？</p><p>要理解metaclass的底层原理，你需要深入理解Python类型模型。下面，我将分三点来说明。</p><h3>第一，所有的Python的用户定义类，都是type这个类的实例。</h3><p>可能会让你惊讶，事实上，类本身不过是一个名为 type 类的实例。在Python的类型世界里，type这个类就是造物的上帝。这可以在代码中验证：</p><pre><code># Python 3和Python 2类似\nclass MyClass:\n  pass\n\ninstance = MyClass()\n\ntype(instance)\n# 输出\n&lt;class '__main__.C'&gt;\n\ntype(MyClass)\n# 输出\n&lt;class 'type'&gt;\n</code></pre><p>你可以看到，instance是MyClass的实例，而MyClass不过是“上帝”type的实例。</p><h3>第二，用户自定义类，只不过是type类的<code>__call__</code>运算符重载。</h3><p>当我们定义一个类的语句结束时，真正发生的情况，是Python调用type的<code>__call__</code>运算符。简单来说，当你定义一个类时，写成下面这样时：</p><pre><code>class MyClass:\n  data = 1\n</code></pre><p>Python真正执行的是下面这段代码：</p><pre><code>class = type(classname, superclasses, attributedict)\n</code></pre><p>这里等号右边的<code>type(classname, superclasses, attributedict)</code>，就是type的<code>__call__</code>运算符重载，它会进一步调用：</p><pre><code>type.__new__(typeclass, classname, superclasses, attributedict)\ntype.__init__(class, classname, superclasses, attributedict)\n</code></pre><p>当然，这一切都可以通过代码验证，比如下面这段代码示例：</p><pre><code>class MyClass:\n  data = 1\n  \ninstance = MyClass()\nMyClass, instance\n# 输出\n(__main__.MyClass, &lt;__main__.MyClass instance at 0x7fe4f0b00ab8&gt;)\ninstance.data\n# 输出\n1\n\nMyClass = type('MyClass', (), {'data': 1})\ninstance = MyClass()\nMyClass, instance\n# 输出\n(__main__.MyClass, &lt;__main__.MyClass at 0x7fe4f0aea5d0&gt;)\n\ninstance.data\n# 输出\n1\n</code></pre><p>由此可见，正常的MyClass定义，和你手工去调用type运算符的结果是完全一样的。</p><h3>第三，metaclass是type的子类，通过替换type的<code>__call__</code>运算符重载机制，“超越变形”正常的类。</h3><p>其实，理解了以上几点，我们就会明白，正是Python的类创建机制，给了metaclass大展身手的机会。</p><p>一旦你把一个类型MyClass的metaclass设置成MyMeta，MyClass就不再由原生的type创建，而是会调用MyMeta的<code>__call__</code>运算符重载。</p><pre><code>class = type(classname, superclasses, attributedict) \n# 变为了\nclass = MyMeta(classname, superclasses, attributedict)\n</code></pre><p>所以，我们才能在上面YAML的例子中，利用YAMLObjectMetaclass的<code>__init__</code>方法，为所有YAMLObject子类偷偷执行<code>add_constructor()</code>。</p><h2><strong>使用metaclass的风险</strong></h2><p>前面的篇幅，我都是在讲metaclass的原理和优点。的的确确，只有深入理解metaclass的本质，你才能用好metaclass。而不幸的是，正如我开头所说，深入理解metaclass的Python开发者，只占了0.1%不到。</p><p>不过，凡事有利必有弊，尤其是metaclass这样“逆天”的存在。正如你所看到的那样，metaclass会\"扭曲变形\"正常的Python类型模型。所以，如果使用不慎，对于整个代码库造成的风险是不可估量的。</p><p>换句话说，metaclass仅仅是给小部分Python开发者，在开发框架层面的Python库时使用的。而在应用层，metaclass往往不是很好的选择。</p><p>也正因为这样，据我所知，在很多硅谷一线大厂，使用Python metaclass需要特例特批。</p><h2>总结</h2><p>这节课，我们通过解读YAML的源码，围绕metaclass的设计本意“超越变形”，解析了metaclass的使用场景和使用方法。接着，我们又进一步深入到Python语言设计层面，搞明白了metaclass的实现机制。</p><p>正如我取的标题那样，metaclass是Python黑魔法级别的语言特性。天堂和地狱只有一步之遥，你使用好metaclass，可以实现像YAML那样神奇的特性；而使用不好，可能就会打开潘多拉魔盒了。</p><p>所以，今天的内容，一方面是帮助有需要的同学，深入理解metaclass，更好地掌握和应用；另一方面，也是对初学者的科普和警告：不要轻易尝试metaclass。</p><h2>思考题</h2><p>学完了上节课的Python装饰器和这节课的metaclass，你知道了，它们都能干预正常的Python类型机制。那么，你觉得装饰器和metaclass有什么区别呢？欢迎留言和我讨论。</p>","comments":[{"had_liked":false,"id":105137,"user_name":"奔跑的蜗牛","can_delete":false,"product_type":"c1","uid":1394019,"ip_address":"","ucode":"88D855ED42F134","user_header":"https://static001.geekbang.org/account/avatar/00/15/45/63/d3319b80.jpg","comment_is_top":false,"comment_ctime":1560927564,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"504072101196","product_id":100026901,"comment_content":"看不懂了 😄","like_count":118,"discussions":[{"author":{"id":1219179,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9a/6b/e8ef2989.jpg","nickname":"云蝈蝈","note":"","ucode":"19B1597DB49819","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294561,"discussion_content":"我都以为我看错书了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595928402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1922298,"avatar":"","nickname":"patience","note":"","ucode":"46BEA083F550A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288125,"discussion_content":"还没看完，也看不懂了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593655474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021741,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/97/2d/8e4836f3.jpg","nickname":"Bonaparte","note":"","ucode":"27E9CEE38A30C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369077,"discussion_content":"我以为要导入 YAML","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618922470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2660939,"avatar":"","nickname":"Geek_76801d","note":"","ucode":"1E85D8A5475E54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1021741,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/97/2d/8e4836f3.jpg","nickname":"Bonaparte","note":"","ucode":"27E9CEE38A30C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568582,"discussion_content":"哈哈哈哈哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651162252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369077,"ip_address":""},"score":568582,"extra":""}]},{"author":{"id":1324970,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/aa/177d46f2.jpg","nickname":"阿法","note":"","ucode":"EC1928BEA0DA8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569879,"discussion_content":"完全看不懂了哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651584868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105440,"user_name":"尘墨","can_delete":false,"product_type":"c1","uid":1239472,"ip_address":"","ucode":"2B46B4E5ECDF83","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/b0/7be55531.jpg","comment_is_top":false,"comment_ctime":1561000567,"is_pvip":false,"replies":[{"id":"38221","content":"棒","user_name":"作者回复","comment_id":105440,"uid":"1257426","ip_address":"","utype":1,"ctime":1561046560,"user_name_real":"Yuannan蔡元楠"}],"discussion_count":9,"race_medal":0,"score":"375223155319","product_id":100026901,"comment_content":"我尝试着自己写了一个例子，发现好像清晰多了，没有看懂的大家可以看一下<br>class Mymeta(type):<br>    def __init__(self, name, bases, dic):<br>        super().__init__(name, bases, dic)<br>        print(&#39;===&gt;Mymeta.__init__&#39;)<br>        print(self.__name__)<br>        print(dic)<br>        print(self.yaml_tag)<br><br>    def __new__(cls, *args, **kwargs):<br>        print(&#39;===&gt;Mymeta.__new__&#39;)<br>        print(cls.__name__)<br>        return type.__new__(cls, *args, **kwargs)<br><br>    def __call__(cls, *args, **kwargs):<br>        print(&#39;===&gt;Mymeta.__call__&#39;)<br>        obj = cls.__new__(cls)<br>        cls.__init__(cls, *args, **kwargs)<br>        return obj<br>    <br>class Foo(metaclass=Mymeta):<br>    yaml_tag = &#39;!Foo&#39;<br><br>    def __init__(self, name):<br>        print(&#39;Foo.__init__&#39;)<br>        self.name = name<br><br>    def __new__(cls, *args, **kwargs):<br>        print(&#39;Foo.__new__&#39;)<br>        return object.__new__(cls)<br><br>foo = Foo(&#39;foo&#39;)<br>把上面的例子运行完之后就会明白很多了，正常情况下我们在父类中是不能对子类的属性进行操作，但是元类可以。换种方式理解：元类、装饰器、类装饰器都可以归为元编程(引用自 python-cook-book 中的一句话)。","like_count":88,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454685,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561046560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2313563,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4d/5b/a435ee83.jpg","nickname":"variance","note":"","ucode":"EADB5E1697BC51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334703,"discussion_content":"class MyMeta(type):\n    def __init__(cls, name, bases, dict):\n        super().__init__(name, bases, dict)\n        print(&#39;===>MyMeta.__init__&#39;)\n        print(cls.__name__)\n        print(bases)\n        print(dict)\n        print(cls.yaml_tag)\n\n    def __new__(mcs, *args, **kwargs):\n        print(&#39;===>MyMeta.__new__&#39;)\n        print(mcs.__name__)\n        return type.__new__(mcs, *args, **kwargs)\n\n    def __call__(cls, *args, **kwargs):\n        print(&#39;===>MyMeta.__call__&#39;)\n        obj = cls.__new__(cls)\n        cls.__init__(cls, *args, **kwargs)\n        return obj\n\n\nclass Foo(metaclass=MyMeta):\n    yaml_tag = &#39;!Foo&#39;\n\n    def __init__(self, name):\n        print(&#39;Foo.__init__&#39;)\n        self.name = name\n\n    def __new__(cls, *args, **kwargs):\n        print(&#39;Foo.__new__&#39;)\n        return object.__new__(cls)\n\n\nif __name__ == &#39;__main__&#39;:\n    foo = Foo(&#39;foo&#39;)\n\n=======输出结果=======\n/usr/bin/python3.8 /home/lm/spider/search_engine/metaclass/MyMeta.py\n===>MyMeta.__new__\nMyMeta\n===>MyMeta.__init__\nFoo\n()\n{&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;Foo&#39;, &#39;yaml_tag&#39;: &#39;!Foo&#39;, &#39;__init__&#39;: <function Foo.__init__ at 0x7f88f5becca0>, &#39;__new__&#39;: <function Foo.__new__ at 0x7f88f5becdc0>}\n!Foo\n===>MyMeta.__call__\nFoo.__new__\nFoo.__init__\n\nProcess finished with exit code 0\n\nmetaclass相当于装饰器，当实例化Foo的实例的时候，会从自定义的type类的__new__方法先生成类似于&#39;type&#39;这个祖先的&#39;抽象类&#39;的具体子类MyMeta这个类的实例, 但MyMeta类重写了__new__方法，故从MyMeta类的__new__方法开始执行，返回一个新生成的对象，就同样调用MyMeta的构造方法__init__方法。而在MyMeta构造方法中，实际传进来的就是Foo的对象。因此我们可以通过cls拿到新生成的Foo对象，以及Foo的成员变量。我猜测：这时候MyMeta.__init__中的cls这个对象实例就是Foo的一个虚拟的，不是真正发在内存里的，那是因为我们定义class Foo(metaclass=MyMeta),就相当于将Foo的相关信息传递给MyMeta中去，故我们执行cls.__name__和cls.yaml_tag是得到Foo及其相关信息，只有在调用MyMeta.__call__的时候，Foo类的new方法和构造方法才顺序执行，也就说只有这售后foo这个实例才真正在内存真实存在。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1607945853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1915554,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3a/a2/d9f736c6.jpg","nickname":"海晏","note":"","ucode":"38E998D2036115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290247,"discussion_content":"1、python中所有的类都是type的子类\n2、cls就是metaclass，cls是父类的一个实例，也即当前这个类本身\n3、self是当前类的一个实例\n4、python中每调用一次类的实例，__call__就会被执行一次\n5、__new__()：先调用__new__(),后__init__()初始化\n（1）静态方法，至少要传递一个参数cls，cls表示需要实例化的类\n（2）必须要有返回值，返回实例化出来的实例，也可以返回父类和object的__new__()出来的实例\n（3）__init__()的参数self,就是__new__()出来的实例返回，因此__init__()初始化之前，会先调用__new__()\n6、把Mymeta.__call__()中的cls全部替换成self，不影响Eight, Nine的输出","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594389182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3020434,"avatar":"","nickname":"Geek_d4ab3d","note":"","ucode":"B57E178ABFBB80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1915554,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/3a/a2/d9f736c6.jpg","nickname":"海晏","note":"","ucode":"38E998D2036115","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575689,"discussion_content":"牛皮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655027362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290247,"ip_address":""},"score":575689,"extra":""}]},{"author":{"id":1922298,"avatar":"","nickname":"patience","note":"","ucode":"46BEA083F550A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288185,"discussion_content":"还是没看太懂，运行了一下，输出了结果。不太理解的是：\n1、最后一句foo = Foo(&#39;foo&#39;)，是在实例化Foo类，并且给入了一个参数‘foo’，初始化的时候，不是应该先输出print(&#39;Foo.__init__&#39;)嘛，即输出父类Mymeta中的print(&#39;===>Mymeta.__init__&#39;)嘛？为什么实际运行先得到的结果是===>Mymeta.__new__？不太理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593672741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1502093,"avatar":"https://static001.geekbang.org/account/avatar/00/16/eb/8d/8ee78d3d.jpg","nickname":"瑞哲","note":"","ucode":"9F170728A055AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237787,"discussion_content":"===>Mymeta.__new__\nMymeta\n===>Mymeta.__init__\nFoo\n\n这里定义Foo这个类的时候，指定metaclass是Mymeta，为什么Mymeta的__call__方法没有被调用呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587184543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/e8/abd99392.jpg","nickname":"ashen-one","note":"","ucode":"F80F924DB220A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159662,"discussion_content":"MyMeta的__call__函数中cls.__init__(cls, *args, **kwargs)，第一个输入参数是不是应该是上一语句返回的obj？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580721880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/49/71/fc2b5cf2.jpg","nickname":"隔壁家老鲍","note":"","ucode":"560030862CC24A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83861,"discussion_content":"问个问题，这里的Foo.new好像没被调用，这是为什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576470524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6b/c1/331b91c4.jpg","nickname":"郑文捷","note":"","ucode":"98C08BB54F0974","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70457,"discussion_content":"执行代码报错\nMymeta __init__方法中，self.name 这个name提示不存在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575359136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105196,"user_name":"你曾是少年","can_delete":false,"product_type":"c1","uid":1326701,"ip_address":"","ucode":"83BBA0754EA1C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/6d/323995f4.jpg","comment_is_top":false,"comment_ctime":1560937197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"164769694445","product_id":100026901,"comment_content":"基础不够，之前没接触过metaclass，这一讲读起来太费劲了","like_count":38},{"had_liked":false,"id":105127,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1560925351,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"134704911527","product_id":100026901,"comment_content":"装饰器像AOP，metaclass像反射机制","like_count":32,"discussions":[{"author":{"id":1099513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","nickname":"大王叫我来巡山","note":"","ucode":"1B8D0C701BC95E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2527,"discussion_content":"我感觉我也是这么理解的，好像语言设计的本身也有问题啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563760610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105028,"user_name":"Hoo-Ah","can_delete":false,"product_type":"c1","uid":1306913,"ip_address":"","ucode":"823093A6C7DEE7","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/21/52e8267b.jpg","comment_is_top":false,"comment_ctime":1560906701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"113230056397","product_id":100026901,"comment_content":"之前讲装饰器的时候讲到函数装饰器和类装饰器，而类装饰器就是在雷里面定义了__call__方法，之后在函数执行的时候会调用类的__call__方法。<br>在metaclass中重载了__call__方法，在使用metaclass实例化生成类的时候也是调用了__call__方法，从这方面来讲是很像。<br>要说不一样的话，一个是在执行层面，一个是在生成层面。<br>可以讲讲type和object的区别吗以及可以用一篇专栏讲讲python的魔术方法。","like_count":26},{"had_liked":false,"id":136226,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1569390845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70288867581","product_id":100026901,"comment_content":"1.metaclass拦截了类的构造，类似于黑客，改变了类的行为，在某些场合可简化程序设计。<br>2.python装饰器：不会去改变类的行为，但通过装饰类，可以加强类的功能，通过不同的装饰器使类的功能更加丰富。","like_count":17},{"had_liked":false,"id":105055,"user_name":"你看起来很好吃","can_delete":false,"product_type":"c1","uid":1188854,"ip_address":"","ucode":"F9079138EC3D7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/f6/1ef70cab.jpg","comment_is_top":false,"comment_ctime":1560909067,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"40215614731","product_id":100026901,"comment_content":"‘用户自定义类，只不过是 type 类的__call__运算符’<br>景老师，这里这段是不是有点问题，我做了以下实验：<br><br>class MyMeta(type):<br>    def __init__(cls, name, bases, dict):<br>        print(&#39;MyMeta __init__&#39;)<br><br>    def __new__(cls, name, bases, dict):<br>        print(&#39;MyMeta __new__&#39;)<br>        return type.__new__(cls, name, bases, dict)<br><br>    def __call__(cls):<br>        print(&#39;MyMeta __call__&#39;)<br>        return type.__call__(cls)<br><br>class Test(metaclass=MyMeta):<br>    a = 10<br><br>    def __init__(self):<br>        pass<br><br>    def __new__(cls):<br>        return super(Test, cls).__new__(cls)<br><br>test = Test()<br>我发现在使用class Test()定义类时，会依次调用MyMeta的__new__和__init__方法构建Test类，然后在使用test = Test()创建类对象时，才会调用MyMeta的__call__方法来调用Test类的__new__和__init__方法。好像和您说的不一样？<br>我看您说的意思是，在使用class定义类的时候，先调用metaclass的__call__,然后再调用metaclass的__new__和__init__？","like_count":9,"discussions":[{"author":{"id":1263561,"avatar":"https://static001.geekbang.org/account/avatar/00/13/47/c9/0ff8bc5f.jpg","nickname":"程运来","note":"","ucode":"8A09A42770C31D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1023,"discussion_content":"这小节，专栏写错了。metaclass 跟__call__ 一点关系都没有。只有当实例化类时，才会调用metaclass的__call__方法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562244374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1502093,"avatar":"https://static001.geekbang.org/account/avatar/00/16/eb/8d/8ee78d3d.jpg","nickname":"瑞哲","note":"","ucode":"9F170728A055AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263561,"avatar":"https://static001.geekbang.org/account/avatar/00/13/47/c9/0ff8bc5f.jpg","nickname":"程运来","note":"","ucode":"8A09A42770C31D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237795,"discussion_content":"重载了Foo的__call__方法，发现在foo=Foo(&#39;foo&#39;)的时候使用的还是Mymeta的__call__方法，这是为什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587185138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1023,"ip_address":""},"score":237795,"extra":""},{"author":{"id":1502093,"avatar":"https://static001.geekbang.org/account/avatar/00/16/eb/8d/8ee78d3d.jpg","nickname":"瑞哲","note":"","ucode":"9F170728A055AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263561,"avatar":"https://static001.geekbang.org/account/avatar/00/13/47/c9/0ff8bc5f.jpg","nickname":"程运来","note":"","ucode":"8A09A42770C31D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237799,"discussion_content":"明白了，__call__方法是实例在像函数一样调用时使用的方法，foo=Foo(&#39;foo&#39;)；foo()，这时会使用Foo的__call__方法。而foo=Foo(&#39;foo&#39;)时，执行的是Mymeta(classname, superclasses, attributedict)，Mymeta是type的实例。这里发现，Mymeta的__call__, __new__, __init__都是特殊方法，可以像类方法一样使用，相当于这里就是Mymeta.__call__(classname, superclasses, attributedict)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587186313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1023,"ip_address":""},"score":237799,"extra":""},{"author":{"id":1000076,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","nickname":"龍蝦","note":"","ucode":"BE1D500833F070","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1502093,"avatar":"https://static001.geekbang.org/account/avatar/00/16/eb/8d/8ee78d3d.jpg","nickname":"瑞哲","note":"","ucode":"9F170728A055AD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301688,"discussion_content":"```\nclass MyMetaclass(type):\n    def __new__(mcs, name, bases, dict, **kwargs):\n        return type.__new__(mcs, name, bases, dict)\n\n    def __call__(cls, *args, **kwargs):\n        print(&#34;MyMetaclass.__call__():&#34;, args, kwargs)\n        return type.__call__(cls, *args, **kwargs)\n\n\nif __name__ == &#34;__main__&#34;:\n    print(MyMetaclass(&#34;MyClass&#34;, (), {}))\n```\n\n上面的代码，你会发现 `Mymeta(classname, superclasses, attributedict)` 不是 `Mymeta.__call__(classname, superclasses, attributedict)`\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598607588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237799,"ip_address":""},"score":301688,"extra":""}]},{"author":{"id":1837149,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/08/5d/8e720217.jpg","nickname":"Sugushu","note":"","ucode":"CAE52AF3DF2B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214570,"discussion_content":"class name为可执行语句，根据metaclass的指示，去寻找__new__和__init__方法\n__new__方法创建了Foo类，__init__方法创建了Foo类对象\ninstance = Class()，实例化过程中，调用metaclass指示的类内的__call__方法，如果未重载，则去调用类对象内的__new__方法以及__init__方法完成实例创建","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585208875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1837149,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/08/5d/8e720217.jpg","nickname":"Sugushu","note":"","ucode":"CAE52AF3DF2B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214564,"discussion_content":"class MyMeta与def 语法类似，都是可执行的语句，所以没有test=Test()实例化之前，打印的结果可以看出，__new__和__init__方法已经执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585208585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4367,"discussion_content":"call就是调用的时候执行的语句，定义的时候是不执行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565339007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106111,"user_name":"Wing·三金","can_delete":false,"product_type":"c1","uid":1341402,"ip_address":"","ucode":"6B9F5822C3717F","user_header":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","comment_is_top":false,"comment_ctime":1561177225,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31625948297","product_id":100026901,"comment_content":"个人粗浅的理解是：metaclass 与 类装饰器相似，大多数情况下本质上都是重载了 __call__ 函数，但有一个明显的区别是前者对【继承了 metaclass 的子类本身】的属性造成了影响，而类装饰器是对【作为装饰器本身的类】造成影响而已，对【被装饰的类】的属性没有直接影响（间接影响就看被装饰的函数怎么操作了）。","like_count":7,"discussions":[{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9696,"discussion_content":"我觉得说的很对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568206073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105486,"user_name":"Jon徐","can_delete":false,"product_type":"c1","uid":1206774,"ip_address":"","ucode":"D203B6848C1D9C","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/f6/40c497a3.jpg","comment_is_top":false,"comment_ctime":1561013889,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"31625784961","product_id":100026901,"comment_content":"之前没有接触过 metaclass，感觉用metaclass的作用就是超动态生成类。这节课感觉确实比较魔术，跟上一节装饰器还要再细想一下。<br><br>pyyaml 5.1以上，这段代码会报错，要把 yaml.load() 改成 yaml.load_all()<br>yaml.load(&quot;&quot;&quot;<br>--- !Monster<br>name: Cave spider<br>hp: [2,6]    # 2d6<br>ac: 16<br>attacks: [BITE, HURT]<br>&quot;&quot;&quot;)<br><br><br>","like_count":7,"discussions":[{"author":{"id":2369413,"avatar":"https://static001.geekbang.org/account/avatar/00/24/27/85/ddeeaf30.jpg","nickname":"dived","note":"","ucode":"141916A3BAF5A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374399,"discussion_content":"win10 5.4.1没报错，不过不妨碍这节课没听懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621164882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4372,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565339854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596386,"avatar":"","nickname":"瞳梦","note":"","ucode":"A86FC44F6321BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1694,"discussion_content":"成功work, thanks","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562818400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185783,"user_name":"向南","can_delete":false,"product_type":"c1","uid":1325700,"ip_address":"","ucode":"E6072AD7CA6798","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/84/70340e87.jpg","comment_is_top":false,"comment_ctime":1583678567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23058515047","product_id":100026901,"comment_content":"metaclass的应用：单例模式、ORM模式","like_count":5},{"had_liked":false,"id":180625,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1253774,"ip_address":"","ucode":"A7059C7D505AA0","user_header":"","comment_is_top":false,"comment_ctime":1582354397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23057190877","product_id":100026901,"comment_content":"我的感觉装饰器是通过正常的函数的调用、闭包等方法实现附加的功能。metaclass直接就是一种hack的方法。另外，在前面type类的说明代码中：<br>type(instance)# 输出 &lt;class &#39;__main__.C&#39;&gt;  --&gt; 应该是&lt;class &#39;__main__.MyClass&#39;&gt;？","like_count":5},{"had_liked":false,"id":105868,"user_name":"图·美克尔","can_delete":false,"product_type":"c1","uid":1076720,"ip_address":"","ucode":"021FB5AE110066","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eppQqDE6TNibvr3DNdxG323AruicIgWo5DpVr6U7yZVNkbF2rKluyDfhdpgAEcYEOZTAnbrMdTzFkUw/0","comment_is_top":false,"comment_ctime":1561096757,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"23035933237","product_id":100026901,"comment_content":"装饰器和metaclass都是给对象增加一些额外的公共配件，但装饰器不影响对象本身，而metaclass是将对象本身进行改造。是设计模式层面的东西。","like_count":5},{"had_liked":false,"id":105185,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1560934623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23035771103","product_id":100026901,"comment_content":"哎，对metaclass的机制真是一知半解啊，是90%那坨的！<br>metaclass和类装饰器都可以动态定制或修改类，类装饰器比metaclass以更简单的方式做到创建类时定制类，但它只能定制被装饰的这个类，而对继承这个类的类失效。metaclass的功能则是要强大的多，它可以定制类的继承关系。","like_count":5},{"had_liked":false,"id":105181,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1560934150,"is_pvip":false,"replies":[{"id":"38222","content":"很好","user_name":"作者回复","comment_id":105181,"uid":"1257426","ip_address":"","utype":1,"ctime":1561046630,"user_name_real":"Yuannan蔡元楠"}],"discussion_count":3,"race_medal":0,"score":"23035770630","product_id":100026901,"comment_content":"yaml.load(&quot;&quot;&quot;<br>--- !Monster<br>name: Cave spider<br>hp: [2,6]    # 2d6<br>ac: 16<br>attacks: [BITE, HURT]<br>&quot;&quot;&quot;)<br>运行时报错，pyyaml版本PyYAML-5.1，将语句改成<br>yaml.load(&quot;&quot;&quot;<br>--- !Monster<br>name: Cave spider<br>hp: [2,6]    # 2d6<br>ac: 16<br>attacks: [BITE, HURT]<br>&quot;&quot;&quot;，Loader=yaml.Loader)即可，参见&quot;https:&#47;&#47;github.com&#47;yaml&#47;pyyaml&#47;issues&#47;266&quot;","like_count":5,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454586,"discussion_content":"很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561046630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159983,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/2f/d08a1363.jpg","nickname":"聪少 Jeff","note":"","ucode":"C791ACA9B47679","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536990,"discussion_content":"Thanks！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638929647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2317044,"avatar":"https://static001.geekbang.org/account/avatar/00/23/5a/f4/077903da.jpg","nickname":"Aaron","note":"","ucode":"232FB93BDC5C93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381644,"discussion_content":"Just warning~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625151012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165977,"user_name":"起个啥名字呢","can_delete":false,"product_type":"c1","uid":1168839,"ip_address":"","ucode":"C71AA544A79834","user_header":"https://static001.geekbang.org/account/avatar/00/11/d5/c7/5a78596a.jpg","comment_is_top":false,"comment_ctime":1577354829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18757224013","product_id":100026901,"comment_content":"一点没懂","like_count":4},{"had_liked":false,"id":322072,"user_name":"仲薛蒲","can_delete":false,"product_type":"c1","uid":2807170,"ip_address":"","ucode":"C98EC9D6179B93","user_header":"https://static001.geekbang.org/account/avatar/00/2a/d5/82/fc50e63a.jpg","comment_is_top":false,"comment_ctime":1637155764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14522057652","product_id":100026901,"comment_content":"推荐知乎上一篇文章辅助理解 https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;65214982 ","like_count":3},{"had_liked":false,"id":166798,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1536078,"ip_address":"","ucode":"9619A9C79538D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/70/4e/2808a1af.jpg","comment_is_top":false,"comment_ctime":1577600468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462502356","product_id":100026901,"comment_content":"再补充一段，忘记说“装饰器”和“metaclass”的区别了，装饰器就没有基因编辑那么神奇了，它是用来装饰用的，相当于一个外在的辅助功能，而且只对被装饰的函数有效果，好比美颜相机的功能，每一张要被装饰的面孔都需要用美颜相机进行一次装饰（@装饰函数），而且，你被装饰之后，你的子女不会被装饰，就不存在代代继承的效果了，使用起来也更加灵活，你可以选择美颜后再发圈，也可以选择不美颜直接发圈。","like_count":3},{"had_liked":false,"id":105037,"user_name":"TKbook","can_delete":false,"product_type":"c1","uid":1073829,"ip_address":"","ucode":"F6E0E99CC79059","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/a5/43aa0c27.jpg","comment_is_top":false,"comment_ctime":1560907855,"is_pvip":false,"replies":[{"id":"38223","content":"谢谢","user_name":"作者回复","comment_id":105037,"uid":"1257426","ip_address":"","utype":1,"ctime":1561046796,"user_name_real":"Yuannan蔡元楠"}],"discussion_count":2,"race_medal":0,"score":"14445809743","product_id":100026901,"comment_content":"一开始还以为我打开错专栏了。   目前看了好多解释metaclass的文章，感觉这一篇看起来最明了。","like_count":3,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454532,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561046796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9664,"discussion_content":"哈哈，“你好，我是蔡元楠”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568201667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110724,"user_name":"吴月月鸟","can_delete":false,"product_type":"c1","uid":1115064,"ip_address":"","ucode":"2F068EDD166B49","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/b8/961a5342.jpg","comment_is_top":false,"comment_ctime":1562319686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10152254278","product_id":100026901,"comment_content":"这篇蛮好玩的，天堂和地狱只有一步之遥。","like_count":2},{"had_liked":false,"id":162196,"user_name":"隔壁家老鲍","can_delete":false,"product_type":"c1","uid":1591665,"ip_address":"","ucode":"560030862CC24A","user_header":"https://static001.geekbang.org/account/avatar/00/18/49/71/fc2b5cf2.jpg","comment_is_top":false,"comment_ctime":1576475463,"is_pvip":false,"replies":[{"id":"63091","content":"问题很好，修饰器的确和metaclass有很多相似之处","user_name":"作者回复","comment_id":162196,"uid":"1257426","ip_address":"","utype":1,"ctime":1577248083,"user_name_real":"Yuannan蔡元楠"}],"discussion_count":1,"race_medal":0,"score":"5871442759","product_id":100026901,"comment_content":"感觉入门了，不过还是有一些问题<br>@修饰符是在python里是怎么实现的呢<br>老师如果看到了可以给点意见么","like_count":1,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477979,"discussion_content":"问题很好，修饰器的确和metaclass有很多相似之处","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577248083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132860,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1568254352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863221648","product_id":100026901,"comment_content":"# Python 3 和 Python 2 类似<br>class MyClass:<br>  pass<br><br>instance = MyClass()<br><br>type(instance)<br># 输出<br>&lt;class &#39;__main__.C&#39;&gt;  ##这里写错了，应该是&lt;class &#39;__main__.MyClass&#39;&gt;<br><br>type(MyClass)<br># 输出<br>&lt;class &#39;type&#39;&gt;<br>","like_count":1},{"had_liked":false,"id":110064,"user_name":"俊伟","can_delete":false,"product_type":"c1","uid":1111175,"ip_address":"","ucode":"7905B4F25637F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","comment_is_top":false,"comment_ctime":1562164039,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5857131335","product_id":100026901,"comment_content":"我还有一个问题，好多框架的源码比如django的metaclass都重写了new方法而不是重写init方法，这有什么区别吗？重新这两个方法任意一个都可以吧，为什么总重写new方法呢？","like_count":1,"discussions":[{"author":{"id":1579113,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGTgnCUZbXpDCeia2RdXVmP5aQdxTPNR5iaGUhhUfyEMHL9wnOHIsTmt4FJicceB0DBQZlUYTcqkLkw/132","nickname":"jumpingwa","note":"","ucode":"78005B31EFF335","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379478,"discussion_content":"__new__方法才是类的构造方法，而__init__只是初始化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623921553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109723,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1562082525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857049821","product_id":100026901,"comment_content":"class TestMetaClass(type):<br><br>    def __new__(mcs, *args, **kwargs):<br>        print(&#39;TestMetaClass.__new__&#39;, mcs)<br>        return type.__new__(mcs, *args, **kwargs)<br><br>    def __init__(cls, name, bases, kwds):<br>        print(&#39;TestMetaClass.__init__&#39;, cls)<br>        super(TestMetaClass, cls).__init__(name, bases, kwds)<br><br>    def __call__(cls, *args, **kwargs):<br>        print(&#39;TestMetaClass.__call__&#39;)<br>        return super(TestMetaClass, cls).__call__(*args, **kwargs)<br><br><br>class A(metaclass=TestMetaClass):<br><br>    def __new__(cls, *args, **kwargs):<br>        print(&#39;A.__new__&#39;)<br>        return super(A, cls).__new__(cls)<br><br>    def __init__(self, name=None):<br>        self.name = name<br>        print(&#39;A.__init__&#39;)<br><br><br>A(&#39;hello&#39;)","like_count":1},{"had_liked":false,"id":109322,"user_name":"吴林辉","can_delete":false,"product_type":"c1","uid":1222971,"ip_address":"","ucode":"56F117300FF33D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/3b/f4ca20d8.jpg","comment_is_top":false,"comment_ctime":1561999171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856966467","product_id":100026901,"comment_content":"有个疑问请教下老师，例子里YAMLObject 把 metaclass 声明成了 YAMLObjectMetaclass，换成YAMLObject 继承 YAMLObjectMetaclass ，单纯的做YAMLObjectMetaclass的子类，然后super父类的__init__ 方法，不是也能实现一样的功能么<br>","like_count":1},{"had_liked":false,"id":106317,"user_name":"Geek_Wison","can_delete":false,"product_type":"c1","uid":1504371,"ip_address":"","ucode":"2CD880F07FDD57","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4HlmmWfWicNmo3x3HKaOwz3ibcicDFlV5xILbILKGFCXbnaLf2fZRARfBdVBC5NhIPmXxaxA0T9Jhg/132","comment_is_top":false,"comment_ctime":1561263257,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5856230553","product_id":100026901,"comment_content":"老师你好，为什么我执行示例代码会一个constructor错误，查了好久资料都解决不了。<br>import yaml<br>class Monster(yaml.YAMLObject):<br>  yaml_tag = u&#39;!Monster&#39;<br>  def __init__(self, name, hp, ac, attacks):<br>    self.name = name<br>    self.hp = hp<br>    self.ac = ac<br>    self.attacks = attacks<br>  def __repr__(self):<br>    return &quot;%s(name=%r, hp=%r, ac=%r, attacks=%r)&quot; % (<br>       self.__class__.__name__, self.name, self.hp, self.ac,      <br>       self.attacks)<br><br>yaml.load(&quot;&quot;&quot;<br>--- !Monster<br>name: Cave spider<br>hp: [2,6]    # 2d6<br>ac: 16<br>attacks: [BITE, HURT]<br>&quot;&quot;&quot;)<br><br>错误信息：<br>ConstructorError: could not determine a constructor for the tag &#39;!Monster&#39;<br>  in &quot;&lt;unicode string&gt;&quot;, line 2, column 5:<br>    --- !Monster<br>        ^","like_count":1,"discussions":[{"author":{"id":1319215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/21/2f/b29e8af8.jpg","nickname":"轻风悠扬","note":"","ucode":"F2276CE113BED1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343581,"discussion_content":"yaml.load需要添加一个参数，Loader=yaml.Loader","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611103377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4368,"discussion_content":"我也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565339129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596386,"avatar":"","nickname":"瞳梦","note":"","ucode":"A86FC44F6321BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1693,"discussion_content":"我也遇到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562818308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105163,"user_name":"hlz-123","can_delete":false,"product_type":"c1","uid":1433586,"ip_address":"","ucode":"B7E5EF0C260BD2","user_header":"","comment_is_top":false,"comment_ctime":1560931927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855899223","product_id":100026901,"comment_content":"关于类装饰器和metaclass，我的理解如下：<br>1、类装饰器实现功能<br>     class A:<br>            def __init__:<br>            ......<br>            def __call__:<br>      @class A<br>       def my_func():<br>       每次执行函数my_fund()时，首先执行A类中__call__函数，再执行my_func()。<br>2、metaclass实现功能<br>     class A:<br>     class B(metaclass=A) <br>     B类的基类就改变到了A类，不是原来以前缺省的基类，比如object,<br>     在python中，生成类时，最终的基类应该是type，但metaclass可以改变基类，所以翻译成元类也有 <br>     几分道理。<br>3、相同点和区别<br>     相同点：类装饰器和metaclass都指定了一个类<br>     区别：类装饰器是去执行其指定类中的__call__函数，而meataclass是指定基类，基类的构成函数和 <br>     属性 能够被子类继承。 ","like_count":1},{"had_liked":false,"id":356160,"user_name":"雕刻时光","can_delete":false,"product_type":"c1","uid":2737073,"ip_address":"广东","ucode":"F69EB721AC706A","user_header":"https://static001.geekbang.org/account/avatar/00/29/c3/b1/e2e846d0.jpg","comment_is_top":false,"comment_ctime":1662019173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662019173","product_id":100026901,"comment_content":"装饰器像AOP，metaclass像反射机制","like_count":0},{"had_liked":false,"id":342873,"user_name":"simple_孙","can_delete":false,"product_type":"c1","uid":1873629,"ip_address":"","ucode":"A77203E242D652","user_header":"https://static001.geekbang.org/account/avatar/00/1c/96/dd/1620a744.jpg","comment_is_top":false,"comment_ctime":1650513492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650513492","product_id":100026901,"comment_content":"把add_constructor放到YAMLObject的__new__方法里可以吗，也会每次都执行的","like_count":0},{"had_liked":false,"id":338748,"user_name":"徐先生","can_delete":false,"product_type":"c1","uid":1233506,"ip_address":"","ucode":"F1749C79FB1F8E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/62/d223b5e9.jpg","comment_is_top":false,"comment_ctime":1647699573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647699573","product_id":100026901,"comment_content":"Meta class是运行时编程的基础，常用的方法hook,热更新等技术都是通过 runtime机制完成","like_count":0},{"had_liked":false,"id":329937,"user_name":"twigle","can_delete":false,"product_type":"c1","uid":1228894,"ip_address":"","ucode":"9D2439BFF8B99F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRLfnpj6j5SNVFyH4bQxxKibqIDEIsYQZYmGqcEbQdxfDWMvCQFtnI9sKIa8C7sl4aYbuWZr2tK3w/132","comment_is_top":false,"comment_ctime":1641657979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641657979","product_id":100026901,"comment_content":"创建类就是调用type或者继承type的元类的__call__方法，元类继承type，重载其__call__，指定metaclass，相应元类代替type创建类，虚拟机负责调用__call__, 元类没有重载的话用type的__call__<br><br>type的__call__方法底层是<br>type.__new__(typeclass, classname, superclasses, attributedict)<br>type.__init__(class, classname, superclasses, attributedict)<br>执行子类的__new__方法返回一个对象，相当于构造器，第一个参数是类<br>执行子类__init__方法，相当于初始化代码块，第一个参数是实例<br>至于类加载虚拟机的时机和类对象初始化，应该在调用__call__之前，python虚拟机保证<br>","like_count":0},{"had_liked":false,"id":329928,"user_name":"twigle","can_delete":false,"product_type":"c1","uid":1228894,"ip_address":"","ucode":"9D2439BFF8B99F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRLfnpj6j5SNVFyH4bQxxKibqIDEIsYQZYmGqcEbQdxfDWMvCQFtnI9sKIa8C7sl4aYbuWZr2tK3w/132","comment_is_top":false,"comment_ctime":1641653736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641653736","product_id":100026901,"comment_content":"生产中遇到元类的问题后再来看的，非常棒的一节课！","like_count":0},{"had_liked":false,"id":319874,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1635994214,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1635994214","product_id":100026901,"comment_content":"看到这，装饰器、metaclass、继承，现在有点一团浆糊，感觉又能感觉到它们的区别，但是又说不上来。","like_count":0},{"had_liked":false,"id":315734,"user_name":"Clany","can_delete":false,"product_type":"c1","uid":1238495,"ip_address":"","ucode":"1C4B6321172D87","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/df/ae7f8e00.jpg","comment_is_top":false,"comment_ctime":1633956290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633956290","product_id":100026901,"comment_content":"__new__方法的第一个参数是这个类，而其余的参数会在调用成功后全部传递给__init__方法初始化，这一下子就看出了谁是老子谁是小子的关系。<br>所以，__new__方法（第一个执行）先于__init__方法执行：<br>class A: \tpass  class B(A): \tdef __new__(cls): \t\tprint(&quot;__new__方法被执行&quot;) \t\treturn super().__new__(cls)<br> \tdef __init__(self): \t\tprint(&quot;__init__方法被执行&quot;)<br> b = B() <br>执行结果为：<br>__new__方法被执行 __init__方法被执行<br>我比较两个方法的参数，发现__new__方法是传入类(cls)，而__init__方法传入类的实例化对象(self)，而有意思的是，__new__方法返回的值就是一个实例化对象（ps:如果__new__方法返回None，则__init__方法不会被执行，并且返回值只能调用父类中的__new__方法，而不能调用毫无关系的类的__new__方法）。我们可以这么理解它们之间的关系，__new__是开辟疆域的大将军，而__init__是在这片疆域上辛勤劳作的小老百姓，只有__new__执行完后，开辟好疆域后，__init__才能工作，结合到代码，也就是__new__的返回值正是__init__中self。<br>我们可以看下面这个例子： class CapStr(str):     def __new__(cls, string):         self_in_init = super().__new__(cls, string)         print(id(self_in_init))         return self_in_init      def __init__(self,string):         print(id(self))  a = CapStr(&quot;I love China!&quot;) print(id(a)) <br>执行结果为：<br>2691640428616 2691640428616 2691640428616<br>上面这段代码的内容很简单，在__new__中打印一下返回值的id，在__init__中打印一下self的id值，最后再打印一下创建的这个类的id值（所谓的id值也就是内存地址），我们可以看到最后的输出结果是一致的，这也就说明，整个类的地盘是由__new__函数&quot;开辟出来的&quot;，而到了__init__内部就只能在这片地盘上&quot;修修补补&quot;了。<br>小结：__new__和__init__相配合才是python中真正的类构造器。","like_count":0},{"had_liked":false,"id":298158,"user_name":"Fullmetal Alchemist","can_delete":false,"product_type":"c1","uid":1528865,"ip_address":"","ucode":"4D260084DBC2B2","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/21/aaf74594.jpg","comment_is_top":false,"comment_ctime":1623928600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623928600","product_id":100026901,"comment_content":"Json的dumps和loads也是用metaclass来实现的吗","like_count":0},{"had_liked":false,"id":297235,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":2538092,"ip_address":"","ucode":"094F30C802C0F6","user_header":"","comment_is_top":false,"comment_ctime":1623387742,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623387742","product_id":100026901,"comment_content":"思考题有大佬来回答一下吗？我觉得metaclass就是类的装饰器","like_count":0},{"had_liked":false,"id":289691,"user_name":"喵(๑•́ωก̀๑)","can_delete":false,"product_type":"c1","uid":1241361,"ip_address":"","ucode":"66CCF45ACA61BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/11/2f2819bd.jpg","comment_is_top":false,"comment_ctime":1619145159,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619145159","product_id":100026901,"comment_content":"没看懂，再去查查metaclass其它资料辅助理解下","like_count":0},{"had_liked":false,"id":275468,"user_name":"海朋森","can_delete":false,"product_type":"c1","uid":1165084,"ip_address":"","ucode":"212BADF1F9E962","user_header":"https://static001.geekbang.org/account/avatar/00/11/c7/1c/e59a699b.jpg","comment_is_top":false,"comment_ctime":1611554138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611554138","product_id":100026901,"comment_content":"在接口自动化测试的方面，会有人把接口配置写在yaml来，进行转来转去","like_count":0},{"had_liked":false,"id":258988,"user_name":"茫农","can_delete":false,"product_type":"c1","uid":1206365,"ip_address":"","ucode":"71F7143644C9CB","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/5d/1ccee378.jpg","comment_is_top":false,"comment_ctime":1604590671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604590671","product_id":100026901,"comment_content":"装饰器像动态代理，metaclass像javaagent","like_count":0},{"had_liked":false,"id":233907,"user_name":"Robert小七","can_delete":false,"product_type":"c1","uid":1165254,"ip_address":"","ucode":"6BBF4674673AF5","user_header":"https://static001.geekbang.org/account/avatar/00/11/c7/c6/35cc7c7c.jpg","comment_is_top":false,"comment_ctime":1594515076,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1594515076","product_id":100026901,"comment_content":"时过一年，再来看这篇文章，简直封神","like_count":0,"discussions":[{"author":{"id":1000076,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","nickname":"龍蝦","note":"","ucode":"BE1D500833F070","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301671,"discussion_content":"__call__运算符重载的描述，你确定看懂了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598604118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1165254,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c7/c6/35cc7c7c.jpg","nickname":"Robert小七","note":"","ucode":"6BBF4674673AF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000076,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/8c/373d4027.jpg","nickname":"龍蝦","note":"","ucode":"BE1D500833F070","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":301834,"discussion_content":"你有什么疑问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598675216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301671,"ip_address":""},"score":301834,"extra":""}]}]},{"had_liked":false,"id":221001,"user_name":"lcqbug","can_delete":false,"product_type":"c1","uid":1268609,"ip_address":"","ucode":"08FA17F21BCEC5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbyHPGNLu9sDQOs1V6brMcDwia55pyIlP9n62oO6IYS6kIFDnOSON4ugSeBSy6WhDUnYyJC6vtnHQ/132","comment_is_top":false,"comment_ctime":1590376536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590376536","product_id":100026901,"comment_content":"装饰器和和metaclass都可以改变代码运行结果，一个是按着正常规则有的，一个是从底层改变的。2，我的理解，type翻译为元类，metaclass是控制元类的行为的，有☞超越改变的意思。object翻译为基类。基类为众神之父，元类为造物主。","like_count":0},{"had_liked":false,"id":217160,"user_name":"我是学🤓","can_delete":false,"product_type":"c1","uid":1524623,"ip_address":"","ucode":"4407BDA2278E9F","user_header":"https://static001.geekbang.org/account/avatar/00/17/43/8f/78d29569.jpg","comment_is_top":false,"comment_ctime":1589428600,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1589428600","product_id":100026901,"comment_content":"第三遍阅读，终于懂了 metaclass","like_count":0,"discussions":[{"author":{"id":1695261,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/9doFL0ZzcWf5gkQ10cHsOziamhHicjq1k2KHvJibkicBjHsKyvf9jMepvdgLFiadiaI8PScf73Pl7QK3ibp6MYicWn9BuQ/132","nickname":"Geek_6df977","note":"","ucode":"4F26A42C9BD901","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375143,"discussion_content":"大佬能讲一下吗？我看的云里雾里的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621495209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206158,"user_name":"kaizen","can_delete":false,"product_type":"c1","uid":1675966,"ip_address":"","ucode":"313EEA97AEC7C3","user_header":"https://static001.geekbang.org/account/avatar/00/19/92/be/8de4e1fe.jpg","comment_is_top":false,"comment_ctime":1586796615,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586796615","product_id":100026901,"comment_content":"老师，看完老师这篇完全是懵的，试图在评论中找到更通俗的理解，如果说装饰器是为了在不改变被装饰者的前提下进行额外的处理，那么metaclass是为了让很多不同的class，在实例化时能够做一件统一的事吧<br>老师这篇文章，开篇门槛就不低~，yaml，序列与反序列等等","like_count":0},{"had_liked":false,"id":177344,"user_name":"辰星","can_delete":false,"product_type":"c1","uid":1037406,"ip_address":"","ucode":"C05AF875B85718","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d4/5e/b8bfa75d.jpg","comment_is_top":false,"comment_ctime":1581350383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581350383","product_id":100026901,"comment_content":"看不懂（＃－.－）","like_count":0},{"had_liked":false,"id":171021,"user_name":"jackstraw","can_delete":false,"product_type":"c1","uid":1137207,"ip_address":"","ucode":"C967D2D6158F99","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/37/8775d714.jpg","comment_is_top":false,"comment_ctime":1578823491,"is_pvip":false,"replies":[{"id":"66800","content":"遇到什么问题？这些代码我都校验过","user_name":"作者回复","user_name_real":"Yuannan蔡元楠","uid":"1257426","ctime":1579136372,"ip_address":"","comment_id":171021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578823491","product_id":100026901,"comment_content":"这代码跑都跑不通","like_count":0,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481202,"discussion_content":"遇到什么问题？这些代码我都校验过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579136372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166796,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1536078,"ip_address":"","ucode":"9619A9C79538D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/70/4e/2808a1af.jpg","comment_is_top":false,"comment_ctime":1577599962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577599962","product_id":100026901,"comment_content":"每次学完后，都会看一遍大家的留言，很多留言都很精彩，本章内容特别有意思，也领略到了Python的神奇之处，我也留言一次吧，哈哈哈哈。<br>个人对于metaclass认知，首先它包含了“超越类”和“变形类”含义。<br>超越类：是因为继承了自定义metaclass的类，都会受到影响。<br>变形类：类的运行机制跟普通类的机制不同，会增加某种功能。<br>出现两种特性的根本原因就是因为Python本身的运行机制，每一个定义的类都涉及到继承、重载，中途修改了父类的特性，子类自然受影响，之前说Python里面，处处皆对象，看来可以修改为“Python中处处皆对象，处处皆对象的继承、重载”。举个例子，使用metaclass有点类似于基因编辑，对某一位孕妇采用了基因编辑的技术，如果编辑后可以提高母亲的智商，自然她的子子辈辈的智商都能提高（阿拉丁神灯的效果）；如果编辑后会导致母亲的免疫力下降，自然她的子子辈辈的免疫力都会下降（潘多拉魔盒带来的灾难），所以，基因编辑也要慎重，当然，目前来说是明令禁止。","like_count":0},{"had_liked":false,"id":152728,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574070809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574070809","product_id":100026901,"comment_content":"Python ：创建普通类型对象，调用的是系统定义的type(classname, superclasses, attributedict)<br>创建metaclass，调用的是自定义的MyMeta(classname, superclasses, attributedict)，这个时候可以做很多手脚。<br>但是这些手脚明显违背封装的特性，不是特别必要还是不要用。","like_count":0},{"had_liked":false,"id":147200,"user_name":"沢民","can_delete":false,"product_type":"c1","uid":1142644,"ip_address":"","ucode":"426A76C0DC00A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/74/90097b9d.jpg","comment_is_top":false,"comment_ctime":1572837175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572837175","product_id":100026901,"comment_content":"老师，这段代码有Python3的版本的吗？运行不通呢。","like_count":0},{"had_liked":false,"id":138575,"user_name":"自由民","can_delete":false,"product_type":"c1","uid":1346236,"ip_address":"","ucode":"435C67531697F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","comment_is_top":false,"comment_ctime":1570344556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570344556","product_id":100026901,"comment_content":"思考题：装饰器是不改变函数，而为函数增加新的功能，在函数和类上都能用。metaclass是改变自定义类型的metaclass，使其不再重载默认的type的__call__而是转而重载自定义的metaclass的__call__。<br>总结：慎用metaclass。","like_count":0},{"had_liked":false,"id":133108,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1568362496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568362496","product_id":100026901,"comment_content":"个人感觉，metaclass通过重载__call__来修改类的行为，而装饰器是通过将原函数进行包装来修改原函数的功能，两者都对原有的功能进行了扩展，但是实现思路不一样，metaclass是从类型机制这个角度，而装饰器主要从函数的角度，个人感觉装饰器更加轻量级（因此更加适合业务应用层面），而metaclass更加重量级一些（可以看成是“大招”，也因此更加适合框架层面）","like_count":0},{"had_liked":false,"id":131592,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1567820937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567820937","product_id":100026901,"comment_content":"讲的很棒，终于明白了，👍","like_count":0},{"had_liked":false,"id":121179,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1565071295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565071295","product_id":100026901,"comment_content":"关于文中的代码段：<br><br># Python 3 和 Python 2 类似<br>class MyClass:<br>  pass<br><br>instance = MyClass()<br><br>type(instance)<br># 输出<br>&lt;class &#39;__main__.C&#39;&gt;<br><br>type(MyClass)<br># 输出<br>&lt;class &#39;type&#39;&gt;<br><br><br>经验证，MyClass是旧式类写法，命令行输出为&lt;type &#39;classobj&#39;&gt;<br>如果将MyClass改成新式类写法: MyClass(object)，则输出为&lt;type&#39;type&#39;&gt;<br><br>如果以上验证正确，请修改下文中内容。<br>","like_count":0},{"had_liked":false,"id":108865,"user_name":"magician","can_delete":false,"product_type":"c1","uid":1483968,"ip_address":"","ucode":"1BD1125C7C907A","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/c0/c6880c07.jpg","comment_is_top":false,"comment_ctime":1561905127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561905127","product_id":100026901,"comment_content":"可以讲讲type和object的区别吗？","like_count":0},{"had_liked":false,"id":108512,"user_name":"俊伟","can_delete":false,"product_type":"c1","uid":1111175,"ip_address":"","ucode":"7905B4F25637F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","comment_is_top":false,"comment_ctime":1561789673,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561789673","product_id":100026901,"comment_content":"装饰器子类无法继承，而metaclass不用担心无法继承的问题。这篇文章写的真的好，以前对metaclass的了解，只是把它当成一个比装饰器高级一点的工具。创建类的时候，就是重载了type的__call__方法，而type的call方法不过是调用了new和init方法。这里我有一个问题，new是创建一个对象的方法，那么重写了new方法，那么我就能根据条件返回不同的类型。而init方法，是初始化对象属性的方法，在这里我可以根据条件给类添加一些属性。不知道我上面关于元类的理解对不对。","like_count":0},{"had_liked":false,"id":106342,"user_name":"lllong33","can_delete":false,"product_type":"c1","uid":1528751,"ip_address":"","ucode":"5D012385994C3D","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","comment_is_top":false,"comment_ctime":1561274372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561274372","product_id":100026901,"comment_content":"metaclass 开发框架层面的 Python 库时使用，应用层不适用。唯一看到过就是看别人写的简易爬虫框架源码见过。yaml模块也没有用，json用的最多，路很长啊，","like_count":0},{"had_liked":false,"id":106182,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1561197192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561197192","product_id":100026901,"comment_content":"我默认安装最新的pyyaml5.1版本上面的案例没运行通过，需要pip install PyYAML==3.10安装这个版本才行。<br>请教老师，继承于yaml.YAMLObject的类能否重写__call__()使之变成类装饰器，这样使用序列化和反序列化会不会更简便呢？","like_count":0},{"had_liked":false,"id":105609,"user_name":"Geek_974cd5","can_delete":false,"product_type":"c1","uid":1528654,"ip_address":"","ucode":"5A6BC28919AD4D","user_header":"","comment_is_top":false,"comment_ctime":1561041108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561041108","product_id":100026901,"comment_content":"装饰器在不影响代码整体业务逻辑的基础上，方便代码的调试，跟踪，日志记录等；<br>metaclass更多的强调动态性，需要有安全性，完整性校验的代码做保障，容易造成反序列化漏洞；","like_count":0},{"had_liked":false,"id":105415,"user_name":"yshan","can_delete":false,"product_type":"c1","uid":1136788,"ip_address":"","ucode":"A2ECDCDA52B8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/94/c8bc2b59.jpg","comment_is_top":false,"comment_ctime":1560995205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560995205","product_id":100026901,"comment_content":"另一方面，也是对初学者的科普和警告：不要轻易尝试 mateclass。","like_count":0},{"had_liked":false,"id":105292,"user_name":"zengyunda","can_delete":false,"product_type":"c1","uid":1359389,"ip_address":"","ucode":"3F08F16FB92C8E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ic76sMTwXTJYJQglBTHVian3OHibEuvGXuRH5QibvwqVIsUNa8pzRYkmsbXjLp1eacN1vC77EVKe4k5u7RRVFb3dOg/132","comment_is_top":false,"comment_ctime":1560956110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560956110","product_id":100026901,"comment_content":"注定成为不了1%的人，这一讲似懂非懂的","like_count":0},{"had_liked":false,"id":105164,"user_name":"John Si","can_delete":false,"product_type":"c1","uid":1526611,"ip_address":"","ucode":"705B90724A4BD4","user_header":"https://static001.geekbang.org/account/avatar/00/17/4b/53/67c08006.jpg","comment_is_top":false,"comment_ctime":1560931963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560931963","product_id":100026901,"comment_content":"装饰器跟metaclass这两节课内容都很复杂，不知老师能否再详细说明一下，谢谢老师","like_count":0},{"had_liked":false,"id":105009,"user_name":"enjoylearning","can_delete":false,"product_type":"c1","uid":1000237,"ip_address":"","ucode":"DCAF8538DEA277","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","comment_is_top":false,"comment_ctime":1560905165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560905165","product_id":100026901,"comment_content":"觉得metaclass更像c#等类型编译语言的反射","like_count":0},{"had_liked":false,"id":104992,"user_name":"code2","can_delete":false,"product_type":"c1","uid":1281792,"ip_address":"","ucode":"BBA5748FB6A01C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8OPzdpDraQMvCNWAicicDt54sDaIYJZicBLfMyibXVs4V0ZibEdkZlbzxxL7aGpRoeyvibag5LaAaaGKSdwYQMY2hUrQ/132","comment_is_top":false,"comment_ctime":1560903681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560903681","product_id":100026901,"comment_content":"metaclass译为 变异类 如何？","like_count":0},{"had_liked":false,"id":104942,"user_name":"夜路破晓","can_delete":false,"product_type":"c1","uid":1353577,"ip_address":"","ucode":"9B875F94B759B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3hZfficKPGCq2kjFBu9SgaMjibJTEl7iaW1ta6pZNyiaWP8XEsNpunlnsiaOtBpWTXfT5BvRP3qNByml6p9rtBvqewg/132","comment_is_top":false,"comment_ctime":1560876290,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1560876290","product_id":100026901,"comment_content":"请通俗地解释下，object和type之间的关系？","like_count":0,"discussions":[{"author":{"id":1051873,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","nickname":"拾掇拾掇","note":"","ucode":"D775F374C2A1D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":170561,"discussion_content":"object是type的实例，type又是object的子类，type是自己的实例。list、str、dict、tuple是object的子类，也是type的实例。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581679499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}