{"id":91258,"title":"49 | 别让性能被锁住","content":"<h1>课件及源代码地址</h1><p><a href=\"https://gitee.com/geektime-geekbang/go_learning\">https://gitee.com/geektime-geekbang/go_learning</a></p><h2>书目推荐</h2><p><a href=\"time://mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F1ycmk3uob0ryw\">《计算机程序的构造和解释》</a></p>","comments":[{"had_liked":false,"id":183787,"user_name":"CcczzZ","can_delete":false,"product_type":"c3","uid":1019568,"ip_address":"","ucode":"5F46DA5053D2BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","comment_is_top":false,"comment_ctime":1583134430,"is_pvip":false,"replies":[{"id":75403,"content":"线程在等待锁被挂起时，是释放CPU资源的。","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1585831166,"ip_address":"","comment_id":183787,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师，我按照第一个示例：读锁的 lockAccess 和 无锁的 lockFreeAccess 方法分析 cpu.prof 文件的时候，top命令返回的结果，为什么有时候使用率会没有 lockAccess ，而是 lockFreeAccess 方法占用CPU比较高。代码是和文档一致的\n\n(pprof) top\nShowing nodes accounting for 11.25s, 98.94% of 11.37s total\nDropped 13 nodes (cum &lt;= 0.06s)\nShowing top 10 nodes out of 29\n      flat  flat%   sum%        cum   cum%\n     2.40s 21.11% 21.11%      2.40s 21.11%  sync.(*RWMutex).RLock\n     2.29s 20.14% 41.25%      2.99s 26.30%  runtime.mapaccess2_faststr\n     2.21s 19.44% 60.69%      2.21s 19.44%  sync.(*RWMutex).RUnlock\n     1.90s 16.71% 77.40%      1.90s 16.71%  runtime.findnull\n     0.87s  7.65% 85.05%      0.87s  7.65%  runtime.pthread_cond_wait\n     0.55s  4.84% 89.89%      3.19s 28.06%  go_learning&#47;ch48&#47;lock_test.lockFreeAccess.func1\n     0.47s  4.13% 94.02%      0.47s  4.13%  runtime.add\n     0.34s  2.99% 97.01%      0.34s  2.99%  runtime.pthread_cond_signal\n     0.12s  1.06% 98.07%      0.12s  1.06%  runtime.newstack\n     0.10s  0.88% 98.94%      0.15s  1.32%  runtime.(*bmap).keys","like_count":2,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485779,"discussion_content":"线程在等待锁被挂起时，是释放CPU资源的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585831166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208893,"user_name":"贾敏","can_delete":false,"product_type":"c3","uid":1946456,"ip_address":"","ucode":"6C5B5EABA4C811","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b3/58/14e407e8.jpg","comment_is_top":false,"comment_ctime":1587459172,"is_pvip":false,"replies":[{"id":80207,"content":"你可以尝试 读写比例 1:1\n\nconst (\n\tNumOfReader = 100\n\tNumOfWriter = 100\n)\n\n我得到如下：\nBenchmarkSyncmap&#47;map_with_RWLock-4         \t     132\t   8604360 ns&#47;op\nBenchmarkSyncmap&#47;sync.map-4                \t     141\t   8440450 ns&#47;op\nBenchmarkSyncmap&#47;concurrent_map-4          \t     270\t   4297897 ns&#47;op","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1589361651,"ip_address":"","comment_id":208893,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"按老师的代码实例测试，变化 读写的比例  我得到的结果总是 sync.Map 花的时间最少， 问题可能出在哪里呢？","like_count":1,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492662,"discussion_content":"你可以尝试 读写比例 1:1\n\nconst (\n\tNumOfReader = 100\n\tNumOfWriter = 100\n)\n\n我得到如下：\nBenchmarkSyncmap/map_with_RWLock-4         \t     132\t   8604360 ns/op\nBenchmarkSyncmap/sync.map-4                \t     141\t   8440450 ns/op\nBenchmarkSyncmap/concurrent_map-4          \t     270\t   4297897 ns/op","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589361651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288678,"user_name":"escray","can_delete":false,"product_type":"c3","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1618623261,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"很多程序的性能问题，都和锁有关，数据库或者编程语言的。\n\nGo 语言中有读写锁，互斥的写锁比较容易理解，而互斥的读锁容易造成“误解”。\n\nLockFree 和 LockAccess 在我的笔记本上性能差距大概是 1:30\n\nConcurrent Map 利用 parition 的原理，把一个大的 Map 变成很多小的 Map，这样就可以避免因为一个大的 Map 整个被锁定（锁冲突）的情况\n\n读多写少的时候，使用 sync.map\n读写都很频繁的时候使用 Concurrent Map\n\n但是从我本地测试的情况来看，直到读写比 50:1 的时候，sync.Map 在性能上才超过了 Concurrent Map。\n\n按照留言中的线索，读写比例在 10:1 的时候，sync.map 和 concurrent_map 的性能差距大概是 1:2；如果将读写比例设定为 1:1 的时候，性能比上升为 1:5，concurrent_map 的优势更为明显。","like_count":7},{"had_liked":false,"id":160622,"user_name":"木头发芽","can_delete":false,"product_type":"c3","uid":1419723,"ip_address":"","ucode":"657B381C5DA963","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","comment_is_top":false,"comment_ctime":1575987840,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"我的理解从锁功能上来说:\nmap with lock类似表锁，每次加锁都锁整个map\nsync map类似行锁，只锁要写的那块map内存\nconcurrent map类似区间锁，\n但是跟mysql中不一样，mysql里行锁好于区间锁好于表锁","like_count":2},{"had_liked":false,"id":299794,"user_name":"FR","can_delete":false,"product_type":"c3","uid":1226754,"ip_address":"","ucode":"E111881ED789C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/b8/02/7bcba09e.jpg","comment_is_top":false,"comment_ctime":1624863192,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师，为什么我的go test -bench打印不出来课程里面的那些参数啊\n","like_count":0,"discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383244,"discussion_content":"你是 windows 吗？我在 windows 的“.”要加双引号，即：go test -bench=&#34;.&#34;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626010257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224691,"user_name":"张三说","can_delete":false,"product_type":"c3","uid":1065988,"ip_address":"","ucode":"F1BE933F314D6C","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/04/7904829d.jpg","comment_is_top":false,"comment_ctime":1591508887,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"concurrent_map 看了下源码，应该只是增加了并行度，跟Java老的cm实现不一样的是，第一层槽数组的每个元素用读写锁处理并发，挺有意思的","like_count":0},{"had_liked":false,"id":160620,"user_name":"木头发芽","can_delete":false,"product_type":"c3","uid":1419723,"ip_address":"","ucode":"657B381C5DA963","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","comment_is_top":false,"comment_ctime":1575987741,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"我的理解从锁功能上来说:\nmap with lock类似表锁，每次加锁都锁整个map\nsync map类似行锁，只锁要写的那块map内存\nconcurrent map类似区间锁，\n但是跟mysql中不一样，mysql里行锁好于区间锁好于表锁，这里不一样","like_count":0}]}