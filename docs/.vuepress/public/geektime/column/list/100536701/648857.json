{"id":648857,"title":"16｜再回首：JdbcTemplate章节小结","content":"<p>你好，我是郭屹。</p><p>恭喜你学完了MiniSpring的第三部分——JdbcTemplate了。JdbcTemplate在Spring 框架里，扮演着非常重要的角色。通过它，我们可以更加便捷地进行数据库操作，缩短了开发周期和开发成本，同时也降低了出错的风险。</p><p>它对Spring应用程序的稳定性和性能表现有着至关重要的影响，已经成为开发高效、高质量应用程序的不可或缺的一部分。</p><p>为了让你更好地掌握这部分内容，下面我们对这一整章做一个重点回顾。</p><h3>JdbcTemplate重点回顾</h3><p>JdbcTemplate是Spring框架中的一部分，是Spring对数据访问的一个实现，在Spring应用程序中被广泛采用。它这个实现特别好地体现了Rod Johnson对简洁实用的原则的把握。JdbcTemplate封装了JDBC的 API，并提供了更为便捷的访问方式，使得开发人员在不需要编写大量代码的情况下，能够高效、灵活地进行数据库操作。</p><p>我们知道，JDBC的程序都是类似的，所以这个部分我们提取出一个JDBC访问的模板，同时引入DataSource概念，屏蔽具体的数据库，就便利了上层应用业务程序员。然后，我们再进行SQL参数的处理，SQL请求带有参数，实现把数据转换成SQL语句所需要的参数格式，对SQL语句执行后的返回结果，又要自动绑定为业务对象。</p><!-- [[[read_end]]] --><p>之后，为了支持大量的数据访问，我们实现了数据库连接池提高性能，并且把连接池构造变成一个Bean注入到IoC容器里，还可以让用户自行配置连接池的参数。最后，进一步把程序里的SQL语句也抽取出来，配置到外部文件中，实现一个简单的MyBatis。</p><p>这就是这一章实现JdbcTemplate的过程，你可以再回顾一下。另外我们每一节课后面都给了一道思考题，让你在我们实现的这个极简框架上进行扩展，如果你认真学习了这一章的内容，相信你是可以举一反三的，自己提出解决方案。</p><p>方法可能不同，但目标是一样的。我把参考答案写在文稿中了，你可以看一下，如果你有更好的思路和想法，也欢迎和我分享。下节课我们马上要进入AOP的环节了，一起期待一下吧！</p><h3>13｜JDBC访问框架：如何抽取JDBC模板并隔离数据库？</h3><h4>思考题</h4><p>我们现在只实现了query，想一想如果想要实现update应该如何做呢？</p><h4>参考答案</h4><p>我们现在JdbcTemplate类的结构，对于query()和update()是并列设计的，只要在类中对应的提供一个方法，形如：int update(String sql, Object[] args, int[] argTypes)。这个方法内部是一个PreparedStatement，SQL是要执行的SQL语句，args是SQL参数，argTypes是数据类型，返回值是受影响的行数。</p><h3>14｜增强模板：如何抽取专门的部件完成专门的任务？</h3><h4>思考题</h4><p>你想一想我们应该怎么改造数据库连接池，保证多线程安全？</p><h4>参考答案</h4><p>这个问题有不同的方案，下面是一种思路供参考。</p><p>提供两个队列，一个用于忙的连接，一个用于空闲连接：</p><pre><code class=\"language-plain\">&nbsp; &nbsp; private BlockingQueue&lt;PooledConnection&gt; busy;\n&nbsp; &nbsp; private BlockingQueue&lt;PooledConnection&gt; idle;\n</code></pre><p>获取数据库连接就从idle队列中获取，程序大体如下：</p><pre><code class=\"language-plain\">while (true) {\nconn = idle.poll();\n}\n</code></pre><p>就是死等一个空闲连接。然后加入忙队列。<br>\n当然，进一步考虑，还应当判断连接数是否到了最大，如果没有，则要先创建一个新的连接。创建的时候要小心了，因为是多线程的，所以要再次校验是否超过最大连接数，如使用CAS技术：</p><pre><code class=\"language-plain\">if (size.get() &lt; getPoolProperties().getMaxActive()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (size.addAndGet(1) &gt; getPoolProperties().getMaxActive()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size.decrementAndGet();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return createConnection(now, con, username, password);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n</code></pre><p>而且还应当设置一个timeout，如果在规定的时间内还没有拿到一个连接，就要抛出一个异常。</p><pre><code class=\"language-plain\">if ((System.currentTimeMillis() - now) &gt;= maxWait) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new PoolExhaustedException(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"Timeout: Unable to fetch a connection in \" + (maxWait / 1000) +\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" seconds.\");\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n</code></pre><p>关闭连接，也就是从busy队列移除，然后加入到idle队列中。</p><h3>15｜mBatis : 如何将SQL语句配置化？</h3><h4>思考题</h4><p>我们只是简单地实现了select语句的配置，如何扩展到update语句？进一步，如何实现读写分离？</p><h4>参考答案</h4><p>我们可以在sql节点类MapperNode中增加一个属性sqltype，表示sql语句的类型，比如0表示select，1表示update，2表示insert，3表示delete。这样我们就知道了一个sql语句是read还是write。</p><p>然后datasource变成两个，一个是readDatasource，一个是writeDatasource，可以配置在外部文件中。JdbcTemplate也提供一个setDatasource()允许动态设置数据源。</p><p>DefaultSqlSession类中配置两个data source，形如：</p><pre><code class=\"language-plain\">\tprivate DataSource readDataSource;\t\n\tprivate DataSource writeDataSource;\t\n</code></pre><p>然后在selectOne()中这么判断：</p><pre><code class=\"language-plain\">\tpublic Object selectOne(String sqlid, Object[] args, PreparedStatementCallback pstmtcallback) {\n\t\tint sqltype = this.sqlSessionFactory.getMapperNode(sqlid).getSqlType();\n if (sqltype==0)  {//read\njdbcTemplate.setDatasource(readDataSource);\n\t\t}\n\t\treturn jdbcTemplate.query(sql, args, pstmtcallback);\n\t}\n</code></pre><p>也就是说，每一次用SqlSession执行SQL语句的时候，都判断一下SQL类型，如果是read，则设置readDatasource，否则设置writeDatasource.</p>","neighbors":{"left":{"article_title":"15｜mBatis：如何将SQL语句配置化？","id":648473},"right":{"article_title":"17｜动态代理：如何在运行时插入逻辑？","id":649839}},"comments":[{"had_liked":false,"id":374907,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1684635842,"is_pvip":false,"replies":[{"id":136804,"content":"赞一个！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684723905,"ip_address":"澳大利亚","comment_id":374907,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"读写分离的实现，按照老师的思路，实现了一下。\n1、增加sqlType参数。\n首先改造MapperNode，增加sqlType参数.\n\n2、注入双数据源。\n因为我们配置到applicationContext.xml中的是SqlSessionFactory，所以数据源的注入要在这个类中。\npublic class DefaultSqlSessionFactory implements SqlSessionFactory {\n    ........\n\n    @Autowired\n    private DataSource readDataSource;\n    @Autowired\n    private DataSource writeDataSource;\n\n    @Override\n    public SqlSession openSession() {\n        .......\n        defaultSqlSession.setReadDataSource(readDataSource);\n        defaultSqlSession.setWriteDataSource(writeDataSource);\n        return defaultSqlSession;\n        .......\n    }\n    ........\n}\n\n3、根据sqlType将不同的数据源注入jdbcTemplate中\n之后在openSession的时候，塞给SqlSession对象。当用户执行操作的时候，根据操作类型的不同，给JdbcTemplate注入不同的数据源\npublic class DefaultSqlSession implements SqlSession{\n    \n    .........\n\n    private DataSource readDataSource;\n    private DataSource writeDataSource;\n\n    ....省略readDataSource和writeDataSource的set方法....\n\n    @Override\n    public Object selectOne(String sqlId, Object[] args, PrepareStatementCallBack pstmtcallback) throws Exception {\n        MapperNode mapperNode = this.sqlSessionFactory.getMapperNode(sqlId);\n        if (mapperNode.getSqlType().equals(&quot;3&quot;)) {\n            jdbcTemplate.setDataSource(readDataSource);\n        }\n        return jdbcTemplate.queryObject(mapperNode.getSql(), args, pstmtcallback);\n    }\n\n    @Override\n    public Integer delete(String sqlId, Object[] args) throws Exception {\n        MapperNode mapperNode = this.sqlSessionFactory.getMapperNode(sqlId);\n        if (mapperNode.getSqlType().equals(&quot;1&quot;)) {\n            jdbcTemplate.setDataSource(writeDataSource);\n        }\n        return jdbcTemplate.delete(mapperNode.getSql(), args);\n    }\n    .........\n}","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618944,"discussion_content":"赞一个！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684723905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372878,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1681740543,"is_pvip":false,"replies":[{"id":136275,"content":"会跟平台商量是不是要出MiniTomcat。\n并发问题需要系统级的解决(web server, servlet 容器，缓存，连接池等等)，不是单一servlet这一点可以决定的，servlet本身也是单实例多线程的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681818423,"ip_address":"澳大利亚","comment_id":372878,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：会讲解MiniTomcat吗？\n很期望针对Tomcat也出一个类似的专栏。\n\nQ2：MVC会导致低并发吗？\nMVC用一个单一的 Servlet 拦截所有请求，这个设计会降低系统的并发吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614540,"discussion_content":"会跟平台商量是不是要出MiniTomcat。\n并发问题需要系统级的解决(web server, servlet 容器，缓存，连接池等等)，不是单一servlet这一点可以决定的，servlet本身也是单实例多线程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681818423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}