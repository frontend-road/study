{"id":104521,"title":"19 | 如何用协程来优化多线程业务？","content":"<p>你好，我是刘超。</p><p>近一两年，国内很多互联网公司开始使用或转型Go语言，其中一个很重要的原因就是Go语言优越的性能表现，而这个优势与Go实现的轻量级线程Goroutines（协程Coroutine）不无关系。那么Go协程的实现与Java线程的实现有什么区别呢？</p><h2>线程实现模型</h2><p>了解协程和线程的区别之前，我们不妨先来了解下底层实现线程几种方式，为后面的学习打个基础。</p><p>实现线程主要有三种方式：轻量级进程和内核线程一对一相互映射实现的1:1线程模型、用户线程和内核线程实现的N:1线程模型以及用户线程和轻量级进程混合实现的N:M线程模型。</p><h3>1:1线程模型</h3><p>以上我提到的内核线程（Kernel-Level Thread, KLT）是由操作系统内核支持的线程，内核通过调度器对线程进行调度，并负责完成线程的切换。</p><p>我们知道在Linux操作系统编程中，往往都是通过fork()函数创建一个子进程来代表一个内核中的线程。一个进程调用fork()函数后，系统会先给新的进程分配资源，例如，存储数据和代码的空间。然后把原来进程的所有值都复制到新的进程中，只有少数值与原来进程的值（比如PID）不同，这相当于复制了一个主进程。</p><p>采用fork()创建子进程的方式来实现并行运行，会产生大量冗余数据，即占用大量内存空间，又消耗大量CPU时间用来初始化内存空间以及复制数据。</p><!-- [[[read_end]]] --><p>如果是一份一样的数据，为什么不共享主进程的这一份数据呢？这时候轻量级进程（Light Weight Process，即LWP）出现了。</p><p>相对于fork()系统调用创建的线程来说，LWP使用clone()系统调用创建线程，该函数是将部分父进程的资源的数据结构进行复制，复制内容可选，且没有被复制的资源可以通过指针共享给子进程。因此，轻量级进程的运行单元更小，运行速度更快。LWP是跟内核线程一对一映射的，每个LWP都是由一个内核线程支持。</p><h3>N:1线程模型</h3><p>1:1线程模型由于跟内核是一对一映射，所以在线程创建、切换上都存在用户态和内核态的切换，性能开销比较大。除此之外，它还存在局限性，主要就是指系统的资源有限，不能支持创建大量的LWP。</p><p>N:1线程模型就可以很好地解决1:1线程模型的这两个问题。</p><p>该线程模型是在用户空间完成了线程的创建、同步、销毁和调度，已经不需要内核的帮助了，也就是说在线程创建、同步、销毁的过程中不会产生用户态和内核态的空间切换，因此线程的操作非常快速且低消耗。</p><h3>N:M线程模型</h3><p>N:1线程模型的缺点在于操作系统不能感知用户态的线程，因此容易造成某一个线程进行系统调用内核线程时被阻塞，从而导致整个进程被阻塞。</p><p>N:M线程模型是基于上述两种线程模型实现的一种混合线程管理模型，即支持用户态线程通过LWP与内核线程连接，用户态的线程数量和内核态的LWP数量是N:M的映射关系。</p><p><strong>了解完这三个线程模型，你就可以清楚地了解到Go协程的实现与Java线程的实现有什么区别了。</strong></p><p>JDK 1.8 Thread.java  中  Thread#start  方法的实现，实际上是通过Native调用start0方法实现的；在Linux下， JVM Thread的实现是基于pthread_create实现的，而pthread_create实际上是调用了clone()完成系统调用创建线程的。</p><p>所以，目前Java在Linux操作系统下采用的是用户线程加轻量级线程，一个用户线程映射到一个内核线程，即1:1线程模型。由于线程是通过内核调度，从一个线程切换到另一个线程就涉及到了上下文切换。</p><p>而Go语言是使用了N:M线程模型实现了自己的调度器，它在N个内核线程上多路复用（或调度）M个协程，协程的上下文切换是在用户态由协程调度器完成的，因此不需要陷入内核，相比之下，这个代价就很小了。</p><h2>协程的实现原理</h2><p>协程不只在Go语言中实现了，其实目前大部分语言都实现了自己的一套协程，包括C#、erlang、python、lua、javascript、ruby等。</p><p>相对于协程，你可能对进程和线程更为熟悉。进程一般代表一个应用服务，在一个应用服务中可以创建多个线程，而协程与进程、线程的概念不一样，<span class=\"orange\">我们可以将协程看作是一个类函数或者一块函数中的代码，</span>我们可以在一个主线程里面轻松创建多个协程。</p><p>程序调用协程与调用函数不一样的是，协程可以通过暂停或者阻塞的方式将协程的执行挂起，而其它协程可以继续执行。这里的挂起只是在程序中（用户态）的挂起，同时将代码执行权转让给其它协程使用，待获取执行权的协程执行完成之后，将从挂起点唤醒挂起的协程。 协程的挂起和唤醒是通过一个调度器来完成的。</p><p>结合下图，你可以更清楚地了解到基于N:M线程模型实现的协程是如何工作的。</p><p>假设程序中默认创建两个线程为协程使用，在主线程中创建协程ABCD…，分别存储在就绪队列中，调度器首先会分配一个工作线程A执行协程A，另外一个工作线程B执行协程B，其它创建的协程将会放在队列中进行排队等待。</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/72/9b0a301337fa868eab1b9d32e6fcbd72.jpg?wh=666*870\" alt=\"\"></p><p>当协程A调用暂停方法或被阻塞时，协程A会进入到挂起队列，调度器会调用等待队列中的其它协程抢占线程A执行。当协程A被唤醒时，它需要重新进入到就绪队列中，通过调度器抢占线程，如果抢占成功，就继续执行协程A，失败则继续等待抢占线程。</p><p><img src=\"https://static001.geekbang.org/resource/image/be/94/bebdfb057a9243e640515900eec4ed94.jpg?wh=656*874\" alt=\"\"></p><p>相比线程，协程少了由于同步资源竞争带来的CPU上下文切换，I/O密集型的应用比较适合使用，特别是在网络请求中，有较多的时间在等待后端响应，协程可以保证线程不会阻塞在等待网络响应中，充分利用了多核多线程的能力。而对于CPU密集型的应用，由于在多数情况下CPU都比较繁忙，协程的优势就不是特别明显了。</p><h2>Kilim协程框架</h2><p>虽然这么多的语言都实现了协程，但目前Java原生语言暂时还不支持协程。不过你也不用泄气，我们可以通过协程框架在Java中使用协程。</p><p>目前Kilim协程框架在Java中应用得比较多，通过这个框架，开发人员就可以低成本地在Java中使用协程了。</p><p>在Java中引入 <a href=\"https://github.com/kilim/kilim\">Kilim</a> ，和我们平时引入第三方组件不太一样，除了引入jar包之外，还需要通过Kilim提供的织入（Weaver）工具对Java代码编译生成的字节码进行增强处理，比如，识别哪些方式是可暂停的，对相关的方法添加上下文处理。通常有以下四种方式可以实现这种织入操作：</p><ul>\n<li>在编译时使用maven插件；</li>\n<li>在运行时调用kilim.tools.Weaver工具；</li>\n<li>在运行时使用kilim.tools.Kilim invoking调用Kilim的类文件；</li>\n<li>在main函数添加 if (kilim.tools.Kilim.trampoline(false,args)) return。</li>\n</ul><p>Kilim框架包含了四个核心组件，分别为：任务载体（Task）、任务上下文（Fiber）、任务调度器（Scheduler）以及通信载体（Mailbox）。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/13/20e81165d99c5fc1a55424156e15ff13.jpg?wh=880*690\" alt=\"\"></p><p>Task对象主要用来执行业务逻辑，我们可以把这个比作多线程的Thread，与Thread类似，Task中也有一个run方法，不过在Task中方法名为execute，我们可以将协程里面要做的业务逻辑操作写在execute方法中。</p><p>与Thread实现的线程一样，Task实现的协程也有状态，包括：Ready、Running、Pausing、Paused以及Done总共五种。Task对象被创建后，处于Ready状态，在调用execute()方法后，协程处于Running状态，在运行期间，协程可以被暂停，暂停中的状态为Pausing，暂停后的状态为Paused，暂停后的协程可以被再次唤醒。协程正常结束后的状态为Done。</p><p>Fiber对象与Java的线程栈类似，主要用来维护Task的执行堆栈，Fiber是实现N:M线程映射的关键。</p><p>Scheduler是Kilim实现协程的核心调度器，Scheduler负责分派Task给指定的工作者线程WorkerThread执行，工作者线程WorkerThread默认初始化个数为机器的CPU个数。</p><p>Mailbox对象类似一个邮箱，协程之间可以依靠邮箱来进行通信和数据共享。协程与线程最大的不同就是，线程是通过共享内存来实现数据共享，而协程是使用了通信的方式来实现了数据共享，主要就是为了避免内存共享数据而带来的线程安全问题。</p><h2>协程与线程的性能比较</h2><p>接下来，我们通过一个简单的生产者和消费者的案例，来对比下协程和线程的性能。可通过 <a href=\"https://github.com/nickliuchao/coroutine\">Github</a> 下载本地运行代码。</p><p>Java多线程实现源码：</p><pre><code>public class MyThread {\n\tprivate static Integer count = 0;//\n\tprivate static final Integer FULL = 10; //最大生产数量\n\tprivate static String LOCK = &quot;lock&quot;; //资源锁\n\n\tpublic static void main(String[] args) {\n\t\tMyThread test1 = new MyThread();\n\n\t\tlong start = System.currentTimeMillis();\n\n\t\tList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();\n\t\tfor (int i = 0; i &lt; 1000; i++) {//创建五个生产者线程\n\t\t\tThread thread = new Thread(test1.new Producer());\n\t\t\tthread.start();\n\t\t\tlist.add(thread);\n\t\t}\n\n\t\tfor (int i = 0; i &lt; 1000; i++) {//创建五个消费者线程\n\t\t\tThread thread = new Thread(test1.new Consumer());\n\t\t\tthread.start();\n\t\t\tlist.add(thread);\n\t\t}\n\n\t\ttry {\n\t\t\tfor (Thread thread : list) {\n\t\t\t\tthread.join();//等待所有线程执行完\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(&quot;子线程执行时长：&quot; + (end - start));\n\t}\n    //生产者\n\tclass Producer implements Runnable {\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 10; i++) {\n\t\t\t\tsynchronized (LOCK) {\n\t\t\t\t\twhile (count == FULL) {//当数量满了时\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tLOCK.wait();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;生产者生产，目前总共有&quot; + count);\n\t\t\t\t\tLOCK.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    //消费者\n\tclass Consumer implements Runnable {\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 10; i++) {\n\t\t\t\tsynchronized (LOCK) {\n\t\t\t\t\twhile (count == 0) {//当数量为零时   \n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tLOCK.wait();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;消费者消费，目前总共有&quot; + count);\n\t\t\t\t\tLOCK.notifyAll();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre><p>Kilim协程框架实现源码：</p><pre><code>public class Coroutine  {\n\n\t\tstatic Map&lt;Integer, Mailbox&lt;Integer&gt;&gt; mailMap = new HashMap&lt;Integer, Mailbox&lt;Integer&gt;&gt;();//为每个协程创建一个信箱，由于协程中不能多个消费者共用一个信箱，需要为每个消费者提供一个信箱，这也是协程通过通信来保证共享变量的线程安全的一种方式\n\n\tpublic static void main(String[] args) {\n\n\t\tif (kilim.tools.Kilim.trampoline(false,args)) return;\n\t\tProperties propes = new Properties();\n\t\tpropes.setProperty(&quot;kilim.Scheduler.numThreads&quot;, &quot;1&quot;);//设置一个线程\n\t\tSystem.setProperties(propes);\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i &lt; 1000; i++) {//创建一千生产者\n\t\t\tMailbox&lt;Integer&gt; mb = new Mailbox&lt;Integer&gt;(1, 10);\n\t\t\tnew Producer(i, mb).start();\n\t\t\tmailMap.put(i, mb);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &lt; 1000; i++) {//创建一千个消费者\n\t\t\tnew Consumer(mailMap.get(i)).start();\n\t\t}\n\t\t\n\t\tTask.idledown();//开始运行\n\t\t\n\t\t long endTime = System.currentTimeMillis();\n\t        \n\t     System.out.println( Thread.currentThread().getName()  + &quot;总计花费时长：&quot; + (endTime- startTime));\n\t}\n\t\n}\n</code></pre><pre><code>//生产者\npublic class Producer extends Task&lt;Object&gt; {\n\n\tInteger count = null;\n\tMailbox&lt;Integer&gt; mb = null;\n\n\tpublic Producer(Integer count, Mailbox&lt;Integer&gt; mb) {\n\t\tthis.count = count;\n\t\tthis.mb = mb;\n\t}\n\n\tpublic void execute() throws Pausable {\n\t\tcount = count*10;\n\t\tfor (int i = 0; i &lt; 10; i++) {\n\t\t\tmb.put(count);//当空间不足时，阻塞协程线程\n\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;生产者生产，目前总共有&quot; + mb.size() + &quot;生产了：&quot; + count);\n\t\t\tcount++;\n\t\t}\n\t}\n}\n</code></pre><pre><code>//消费者\npublic class Consumer extends Task&lt;Object&gt; {\n\n\tMailbox&lt;Integer&gt; mb = null;\n\n\tpublic Consumer(Mailbox&lt;Integer&gt; mb) {\n\t\tthis.mb = mb;\n\t}\n\n\t/**\n\t * 执行\n\t */\n\tpublic void execute() throws Pausable {\n\t\tInteger c = null;\n\t\tfor (int i = 0; i &lt; 10000; i++)  {\n\t\t\tc = mb.get();//获取消息，阻塞协程线程\n\t\t\t\n\t\t\tif (c == null) {\n\t\t\t\tSystem.out.println(&quot;计数&quot;);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;消费者消费，目前总共有&quot; + mb.size() + &quot;消费了：&quot; + c);\n\t\t\t\tc = null;\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre><p>在这个案例中，我创建了1000个生产者和1000个消费者，每个生产者生产10个产品，1000个消费者同时消费产品。我们可以看到两个例子运行的结果如下：</p><pre><code>多线程执行时长：2761\n</code></pre><pre><code>协程执行时长：1050\n</code></pre><p>通过上述性能对比，我们可以发现：在有严重阻塞的场景下，协程的性能更胜一筹。其实，<span class=\"orange\">I/O阻塞型场景也就是协程在Java中的主要应用。</span></p><h2>总结</h2><p>协程和线程密切相关，协程可以认为是运行在线程上的代码块，协程提供的挂起操作会使协程暂停执行，而不会导致线程阻塞。</p><p>协程又是一种轻量级资源，即使创建了上千个协程，对于系统来说也不是很大的负担，但如果在程序中创建上千个线程，那系统可真就压力山大了。可以说，<span class=\"orange\">协程的设计方式极大地提高了线程的使用率。</span></p><p>通过今天的学习，当其他人侃侃而谈Go语言在网络编程中的优势时，相信你不会一头雾水。学习Java的我们也不要觉得，协程离我们很遥远了。协程是一种设计思想，不仅仅局限于某一门语言，况且Java已经可以借助协程框架实现协程了。</p><p>但话说回来，协程还是在Go语言中的应用较为成熟，在Java中的协程目前还不是很稳定，重点是缺乏大型项目的验证，可以说Java的协程设计还有很长的路要走。</p><h2>思考题</h2><p>在Java中，除了Kilim框架，你知道还有其它协程框架也可以帮助Java实现协程吗？你使用过吗？</p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","comments":[{"had_liked":false,"id":124662,"user_name":"帽子丨影","can_delete":false,"product_type":"c1","uid":1225395,"ip_address":"","ucode":"2B34892A2DE83E","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","comment_is_top":false,"comment_ctime":1565939304,"is_pvip":false,"replies":[{"id":"51148","content":"对的，这样理解很清晰","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568541636,"ip_address":"","comment_id":124662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61695481448","product_id":100028001,"comment_content":"文中提到协程有个队列，最终还是需要主线程来调度执行。那是不是有点类似线程池。主线程是Worker线程，每一个协程就是一个Task。只不过主线程执行到的某个Task阻塞时会去执行下一个Task。","like_count":14,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463266,"discussion_content":"对的，这样理解很清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568541636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110719,"user_name":"小橙橙","can_delete":false,"product_type":"c1","uid":1054923,"ip_address":"","ucode":"4F467210A15F66","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/cb/edb5a0a0.jpg","comment_is_top":false,"comment_ctime":1562318939,"is_pvip":false,"replies":[{"id":"40391","content":"是的，Java未来的三个主要项目之一Loom项目 引入了被称为 fibers 的新型轻量级用户线程，甲骨文公司 Loom 项目技术负责人 Ron Pressler 在 QCon 伦敦 2019 大会上指出：“利用 fibers，如果我们确保其轻量化程度高于内核提供的线程，那么问题就得到了解决。大家将能够尽可能多地使用这些用户模式下的轻量级线程，且基本不会出现任何阻塞问题”。<br><br>具体的可以阅读以下openjdk官网链接：<br>https:&#47;&#47;cr.openjdk.java.net&#47;~rpressler&#47;loom&#47;Loom-Proposal.html","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562465619,"ip_address":"","comment_id":110719,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61691861083","product_id":100028001,"comment_content":"老师，以后的JAVA版本是不是也会自带协程功能？","like_count":14,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457025,"discussion_content":"是的，Java未来的三个主要项目之一Loom项目 引入了被称为 fibers 的新型轻量级用户线程，甲骨文公司 Loom 项目技术负责人 Ron Pressler 在 QCon 伦敦 2019 大会上指出：“利用 fibers，如果我们确保其轻量化程度高于内核提供的线程，那么问题就得到了解决。大家将能够尽可能多地使用这些用户模式下的轻量级线程，且基本不会出现任何阻塞问题”。\n\n具体的可以阅读以下openjdk官网链接：\nhttps://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562465619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579086,"discussion_content":"2022年已经在JDK19中已经有了预览版本：https://openjdk.org/jeps/425","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657170456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116855,"user_name":"~Wade","can_delete":false,"product_type":"c1","uid":1253445,"ip_address":"","ucode":"74F5478B704681","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/45/3c5548bb.jpg","comment_is_top":false,"comment_ctime":1563931969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44513604929","product_id":100028001,"comment_content":"有一个java库叫Quasar Fiber ，通过javaagent技术可以实现轻量级线程 <br>官网：http:&#47;&#47;www.paralleluniverse.co&#47;quasar&#47;","like_count":10},{"had_liked":false,"id":109492,"user_name":"欧星星","can_delete":false,"product_type":"c1","uid":1014347,"ip_address":"","ucode":"56365442E231A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg","comment_is_top":false,"comment_ctime":1562043666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18741912850","product_id":100028001,"comment_content":"老师有几个疑问<br>1. 协程必须手动调用等待或阻塞才能被安排到等待队列去吗？还是说协程也可以跟线程一样会被随机丢到等待队列去每个协程也有个运行时间片？如果可以随机一般是如何实现的？<br>2. 协程之间的争抢基于什么实现的？我想的话可以使用CAS来实现没有抢到的再次被丢到等待队列不知道对不对。<br>3. 我看例子上邮箱里面没有数据时消费者协程没有类似线程的等待机制，这个要如何写呢？","like_count":4},{"had_liked":false,"id":132427,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568119483,"is_pvip":false,"replies":[{"id":"50648","content":"1、这里说的通信方式是指协程间的通信方式，是通过数据共享来实现的，不存在线程安全问题；<br>2、需要CPU，协程可以更充分的利用好CPU，不会来回切换资源。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568124470,"ip_address":"","comment_id":132427,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14453021371","product_id":100028001,"comment_content":"课前思考及问题<br>1：协程是啥？<br>2：协程更轻量怎么体现，它轻量在哪里？<br>3：为什么多协程没有高并发的问题？<br>4：协程真这么优秀，为啥没有全面支持或使用？换言之实现协程需要什么代价？<br>昨晚休息的太晚了，今天脑袋晕晕的，状态不佳感觉学完还是回答不好，课前的思考题。先跳过，回头再看一下。<br><br>课后思考及问题<br>1：协程与线程最大的不同就是，线程是通过共享内存来实现数据共享，而协程是使用了通信的方式来实现了数据共享，主要就是为了避免内存共享数据而带来的线程安全问题。<br>这里的通信方式具体指什么？它比共享内存通信的方式还要快嘛？每个协程间都需要建立这种通信方式不耗资源不影响性能嘛？<br><br>2：而 Go 语言是使用了 N:M 线程模型实现了自己的调度器，它在 N 个内核线程上多路复用（或调度）M 个协程，协程的上下文切换是在用户态由协程调度器完成的，因此不需要陷入内核，相比之下，这个代价就很小了。<br>协程的执行不需要CPU？若需要，就会存在切入切出，协程的上下文切换怎么能在用户态全部完成，这个没有理解？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466932,"discussion_content":"1、这里说的通信方式是指协程间的通信方式，是通过数据共享来实现的，不存在线程安全问题；\n2、需要CPU，协程可以更充分的利用好CPU，不会来回切换资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568124470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9336,"discussion_content":"老师，我的问题，没回答全，一般我第一个问题是问是什么？第二个就是问为什么了？如果还接着问，就是想延伸。\n上面的问题，协程也通过共享数据来通信，那他们的共享数据应该在内存中，如果有多个协程有写操作应该也是有协程读数据不一致性的问题吧？\n另外，就是协程使用CPU的切入切出，我的理解是有切入切出的，他们的切入切出全在内核态嘛？\n学完这篇后，我回答不出课前的思考题，我感觉还是没有完全理解协程这个东西是啥？轻在哪里？快在哪里？怎么快的？\n我先记一笔，有个印象，继续看下去，还是要系统的看书。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568154668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109409,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1562030390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446932278","product_id":100028001,"comment_content":"老师讲协程讲的最深最易懂的一个，赞赞赞","like_count":3},{"had_liked":false,"id":109383,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1562028714,"is_pvip":false,"replies":[{"id":"39623","content":"1、对的<br>2、属于用户线程，与内核线程一对一映射","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562035621,"ip_address":"","comment_id":109383,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14446930602","product_id":100028001,"comment_content":"老师，读了今天的内容，我理解的意思是：<br>1.因为每个轻量级线程都有一个内核线程支持，而java中，每个用户线程对应一个轻量级线程，可以看作用户线程和支持轻量级线程的内核线程是一对一的，所以就说java线程模型是用户线程和内核线程一对一。<br>2.那这里轻量级线程属于内核线程吗，我看文中说的是由内核线程clone而来的，那它算内核线程吗？<br>请老师解答一下！","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456387,"discussion_content":"1、对的\n2、属于用户线程，与内核线程一对一映射","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562035621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151078,"user_name":"晓晨同学","can_delete":false,"product_type":"c1","uid":1413041,"ip_address":"","ucode":"236AEEB786E2CE","user_header":"https://static001.geekbang.org/account/avatar/00/15/8f/b1/7b697ed4.jpg","comment_is_top":false,"comment_ctime":1573651128,"is_pvip":false,"replies":[{"id":"72192","content":"可以，只是实现成本的问题","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584016871,"ip_address":"","comment_id":151078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163585720","product_id":100028001,"comment_content":"请问老师，上面说N:1这种线程模型是当某个用户线程使用内核线程阻塞的时候会使整个进程下的所有用户线程阻塞，那我想为什么不能像N:M线程模型一样当某个用户线程阻塞时就挂起来从而去调度其他的用户线程呢","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474357,"discussion_content":"可以，只是实现成本的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140105,"user_name":"Ericens","can_delete":false,"product_type":"c1","uid":1607328,"ip_address":"","ucode":"95AB0416F8EF7B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/fy6KTCIk6JPGdOYbvsXJ4h1zq8a6P6sHiau0t2hBxxZfSeE2ymJmWsnb7YzxUO3byr1n30UoYD2XrXDwlrQa6lQ/132","comment_is_top":false,"comment_ctime":1570809045,"is_pvip":false,"replies":[{"id":"54268","content":"协程更轻量级，协程是线程的子集，所以不会存在线程间的上下文切换，而仅仅是通过调度器来完成调度的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570953030,"ip_address":"","comment_id":140105,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10160743637","product_id":100028001,"comment_content":"老师，请教个关于协程与线程的疑问。比如，a协程调用socket. read(),此时数据没有准备好，则继续调度b协程。<br><br>把协程换成线程，上面这个过程哪个更加轻量？协程还是线程？<br>我理解这个过程涉及的过程如下，都一样。<br>1.都有系统调用read()，从用户态切换到了内核态，<br>2.都有上下文切换。(不同协程的寄存器，和不同线程的寄存器)<br>3. 都要执行任务调度。协程调度或者线程调度。<br><br>那协程到底轻量在哪？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470247,"discussion_content":"协程更轻量级，协程是线程的子集，所以不会存在线程间的上下文切换，而仅仅是通过调度器来完成调度的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570953030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607328,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/fy6KTCIk6JPGdOYbvsXJ4h1zq8a6P6sHiau0t2hBxxZfSeE2ymJmWsnb7YzxUO3byr1n30UoYD2XrXDwlrQa6lQ/132","nickname":"Ericens","note":"","ucode":"95AB0416F8EF7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33633,"discussion_content":"1.如果因为时间片到了，线程要被切换，确实是线程更重。又有一个疑问，难道go要实现时间片的协程调度？\n\n2. go在什么场景下是不需要陷入内核，而发生协程调度的呢？\n\n3. 当场景是调用socket. read的时候，此时线程已经进去内核态。然后资源不可用，才切换其他线程执行。这个过程协程也要走一遍啊\n\n还请老师指点迷津","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571138528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211517,"user_name":"葛阳","can_delete":false,"product_type":"c1","uid":1129902,"ip_address":"","ucode":"DDC6D5CF151C23","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/ae/5eede757.jpg","comment_is_top":false,"comment_ctime":1587976066,"is_pvip":true,"replies":[{"id":"78604","content":"这里的进程应该理解为线程，因为在unix编程中，通常以进程来代表线程的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1587986415,"ip_address":"","comment_id":211517,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882943362","product_id":100028001,"comment_content":"&quot;相对于 fork() 系统调用创建的线程来说，LWP 使用 clone() 系统调用创建线程，该函数是将部分父进程的资源的数据结构进行复制，复制内容可选，且没有被复制的资源可以通过指针共享给子进程。因此，轻量级进程的运行单元更小，运行速度更快。LWP 是跟内核线程一对一映射的，每个 LWP 都是由一个内核线程支持。&quot;  -- 这句话是不是有毛病，一会儿&quot;进程&quot;一会儿&quot;线程&quot;","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493282,"discussion_content":"这里的进程应该理解为线程，因为在unix编程中，通常以进程来代表线程的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587986415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158525,"user_name":"慎独","can_delete":false,"product_type":"c1","uid":1137160,"ip_address":"","ucode":"7EA6FB3C7CFE4C","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/08/2bef230f.jpg","comment_is_top":false,"comment_ctime":1575396663,"is_pvip":false,"replies":[{"id":"60851","content":"协程可以胜任高并发场景，不过目前没有在线上的Java项目使用过协程","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1575537525,"ip_address":"","comment_id":158525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870363959","product_id":100028001,"comment_content":"老师，协程在高并发系统中使用过吗？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476756,"discussion_content":"协程可以胜任高并发场景，不过目前没有在线上的Java项目使用过协程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575537525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154293,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1574405202,"is_pvip":true,"replies":[{"id":"59450","content":"netty在处理同步业务场景下，特别是业务处理比较耗时的场景下，并发处理能力有限。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1574581073,"ip_address":"","comment_id":154293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869372498","product_id":100028001,"comment_content":"1. Java框架的话，Kilim有一段时间没有更新了，最近Quasar好像流行一些。<br>2. JVM里，可以混用Kotlin；或者是混用Scala+akka。<br>3. 未来版本的JDK也会逐步支持协程，但现在的实验版本好像只是在Linux下支持的比较好。<br>4 .不过说实话，现在的netty框架，在一定意义上工作原理和协程也有一些相似之处。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475426,"discussion_content":"netty在处理同步业务场景下，特别是业务处理比较耗时的场景下，并发处理能力有限。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574581073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109498,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1562045017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857012313","product_id":100028001,"comment_content":"老师好!1:1,N:1，N:M的线程模型。总感觉上学的时候有讲可是又想不起来。谢谢老师的讲解。不过还是有些不明白的地方。<br>Java是采用1:1的映射方式。一个Java线程就对应一个内核线程。用户态和内核态的切换和这个映射模型有关系么(用户态和内核态，和用户线程内核线程是否有关系)?<br>从用户态切换为内核态的时候具体做了哪些操作?之前讲IO模型时老师讲了，用户空间和内核空间，多次数据拷贝。和用户线程内核线程有什么联系么?后面会讲么?","like_count":1},{"had_liked":false,"id":109397,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1562029788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856997084","product_id":100028001,"comment_content":"终于弄懂协程和线程的区别了，协程基于N：M的线程模型实现，M个协程被调度器调度，实际上也是被内核线程执行，不过由于需要的内核线程少，一个内核线程可以执行多个协程，占用资源少，而且上下文切换也更加少，而基于线程的1：1模型只有有阻塞就会有上下文切换","like_count":1},{"had_liked":false,"id":352907,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"陕西","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1659003610,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659003610","product_id":100028001,"comment_content":"协程其实还是要利用线程来实现多路复用的，因为操作系统只认线程。其实跟netty的多线程模型有些类似，只是协程干了阻塞IO的事，少了上下文切换。","like_count":0},{"had_liked":false,"id":311587,"user_name":"190coder","can_delete":false,"product_type":"c1","uid":1202881,"ip_address":"","ucode":"68111F5B32CCF7","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/c1/6df65e0a.jpg","comment_is_top":false,"comment_ctime":1631325892,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631325892","product_id":100028001,"comment_content":"java 里的协程就是玩具，在线程资源足够多的时候，性能和效率根本比不过线程","like_count":0},{"had_liked":false,"id":300998,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1625479859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625479859","product_id":100028001,"comment_content":"每个协程都有自己的mailbox，为啥还能共享变量？如果不能共享变量，这两个测试程序根本体现不出啥。","like_count":0},{"had_liked":false,"id":282320,"user_name":"Eco","can_delete":false,"product_type":"c1","uid":1373230,"ip_address":"","ucode":"5459B494753183","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/x86UN2kFbJGGwiaw7yeVtyaf05y5eZmdOciaAF09WEBRVicbPGsej1b62UAH3icjeJqvibVc6aqB0EuFwDicicKKcF47w/132","comment_is_top":false,"comment_ctime":1615196342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615196342","product_id":100028001,"comment_content":"好像有个叫akka的框架不知道是不是协程的思想。还有老师在上面讲协程调度哪里，感觉有点像线程池呢。就指定数量的线程去执行远远大于线程数的Task，只不过这里的Task有状态还能阻塞。","like_count":0},{"had_liked":false,"id":270655,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609208180,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1609208180","product_id":100028001,"comment_content":"而 Go 语言是使用了 N:M 线程模型实现了自己的调度器，它在 N 个内核线程上多路复用（或调度）M 个协程.<br>老师这里的多路复用是什么意思啊?复用的是协程还是内核线程.","like_count":0,"discussions":[{"author":{"id":2532285,"avatar":"","nickname":"Geek_926921","note":"","ucode":"51C3B0178D77E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379332,"discussion_content":"看第二张图，线程数并没有新增，而是重复利用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623832116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243480,"user_name":"Geek_be0aff","can_delete":false,"product_type":"c1","uid":1902223,"ip_address":"","ucode":"C14ABF4146A2CF","user_header":"","comment_is_top":false,"comment_ctime":1598150769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598150769","product_id":100028001,"comment_content":"请老师指教，fork使用的写时复制机制不就是为了解决创建子进程开销太大问题吗？为何还需要LWP，那如果LWP机制父子进程共享内存，对同一块内存写不同的值，如何避免冲突呢?","like_count":0},{"had_liked":false,"id":243369,"user_name":"Geek_79c48f","can_delete":false,"product_type":"c1","uid":2110766,"ip_address":"","ucode":"27ABED62E38762","user_header":"","comment_is_top":false,"comment_ctime":1598076507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598076507","product_id":100028001,"comment_content":"共享内存机制和消息机制，实现不一样`~","like_count":0},{"had_liked":false,"id":227066,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592274051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592274051","product_id":100028001,"comment_content":"从图中看出，协程是要通过抢占线程执行的，没有上下文切换，都在用户空间执行，那是不是可以通过适当增加线程数增加并发量呢","like_count":0},{"had_liked":false,"id":181235,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1582523353,"is_pvip":true,"replies":[{"id":"70508","content":"对的，有个任务调度器。如果是IO密集型的场景，协程会更又优势。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1582719586,"ip_address":"","comment_id":181235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582523353","product_id":100028001,"comment_content":"协程被暂停,那下次再执行怎么知道执行到哪里了呢？是程序计数器记录了吗？<br><br>追求高吞吐量的系统，协程是不是就不能帮上忙了？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484969,"discussion_content":"对的，有个任务调度器。如果是IO密集型的场景，协程会更又优势。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582719586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115111,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1563497180,"is_pvip":false,"replies":[{"id":"42359","content":"对的，减少阻塞，充分利用CPU。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563760769,"ip_address":"","comment_id":115111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563497180","product_id":100028001,"comment_content":"从前，操作系统调度线程运行；现在，有了协程，进程自己调度协程如何运行，避免不必要的上下文切换，且协程相比线程占用内存空间更少。<br>协程主要来解决网络IO问题。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458971,"discussion_content":"对的，减少阻塞，充分利用CPU。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563760769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110934,"user_name":"玉哥","can_delete":false,"product_type":"c1","uid":1275710,"ip_address":"","ucode":"FC88E11D3A340B","user_header":"https://static001.geekbang.org/account/avatar/00/13/77/3e/702c8782.jpg","comment_is_top":false,"comment_ctime":1562398860,"is_pvip":false,"replies":[{"id":"40385","content":"在socket通信中，可以使用协程优化IO读写这块。例如，可以尝试用协程写个非阻塞Socket通信，或用协程简单改造下Netty。具体的实现自己可以尝试，如果遇到问题欢迎沟通。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562464048,"ip_address":"","comment_id":110934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562398860","product_id":100028001,"comment_content":"有没有具体场景的实战优化呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457131,"discussion_content":"在socket通信中，可以使用协程优化IO读写这块。例如，可以尝试用协程写个非阻塞Socket通信，或用协程简单改造下Netty。具体的实现自己可以尝试，如果遇到问题欢迎沟通。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562464048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109801,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1562115745,"is_pvip":false,"replies":[{"id":"39939","content":"会的，在mailbox为空时，消费者get会被阻塞；在mailbox满了，生产者put会阻塞。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562207599,"ip_address":"","comment_id":109801,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562115745","product_id":100028001,"comment_content":"消费者从mailbox拿数据为空时，或生产者往mailbox写数据没有可用空间时，不会阻塞吗？类似于队列","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456578,"discussion_content":"会的，在mailbox为空时，消费者get会被阻塞；在mailbox满了，生产者put会阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562207599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109559,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1562057332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562057332","product_id":100028001,"comment_content":"AKKA Framework算得上一个，另外还有Vert.X","like_count":0},{"had_liked":false,"id":109490,"user_name":"欧星星","can_delete":false,"product_type":"c1","uid":1014347,"ip_address":"","ucode":"56365442E231A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg","comment_is_top":false,"comment_ctime":1562042908,"is_pvip":false,"replies":[{"id":"39936","content":"由调度器保证","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562207373,"ip_address":"","comment_id":109490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562042908","product_id":100028001,"comment_content":"有个疑问，线程的切换是由系统来保证的，那协程之间的切换也能跟线程那样由调度器保证，还是说协程必须要手动调用或io","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456438,"discussion_content":"由调度器保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562207373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109484,"user_name":"六维","can_delete":false,"product_type":"c1","uid":1022887,"ip_address":"","ucode":"EB1C15AC06A8DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/a7/440aff07.jpg","comment_is_top":false,"comment_ctime":1562040693,"is_pvip":false,"replies":[{"id":"39935","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562207347,"ip_address":"","comment_id":109484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562040693","product_id":100028001,"comment_content":"一核的CPU是否有使用协程的必要？ 按目前cpu的调度是采用时间片的方式，一核的CPU也存在上下文切换。一核的CPU也可以应用到协程带来的好处。 不知道这个理解是否正确？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456433,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562207347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109431,"user_name":"crazypokerk","can_delete":false,"product_type":"c1","uid":1158383,"ip_address":"","ucode":"9AAD5D9726E503","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/ef/494f56c3.jpg","comment_is_top":false,"comment_ctime":1562031810,"is_pvip":false,"replies":[{"id":"39934","content":"没有其他成员变量引用&quot;lock&quot;，这里使用没有问题，具体场景具体分析。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562207140,"ip_address":"","comment_id":109431,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1562031810","product_id":100028001,"comment_content":"老师，不是建议不要使用String对象作为锁对象吗？为什么上面的代码private static String LOCK = &quot;lock&quot;，要这么写呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456408,"discussion_content":"没有其他成员变量引用&amp;quot;lock&amp;quot;，这里使用没有问题，具体场景具体分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562207140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382173,"discussion_content":"这个建议是基于什么场景的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625460880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109425,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1562031367,"is_pvip":false,"replies":[{"id":"39630","content":"对的，一些技术框架还是需要经受大公司或者一些大型项目的验证，不过我们也可以先在一些小型项目中先行使用。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562037434,"ip_address":"","comment_id":109425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562031367","product_id":100028001,"comment_content":"loom项目也可以让javaer玩玩协程，不过仅限于玩玩。总归没有大项目验证，而且都非官方版本，而是以框架的形式引用。不建议在真实项目中去使用。另外erland的并发编程并不弱于go。就目前来看，感觉还是java比较适合写web项目。虽然go写并发编程很爽，但web开发组件不健全，很多东西得自己实现，而自己实现意味着成本和风险。能有现有，经过大项目和时间验证的组件终是比较让人舒心的。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456406,"discussion_content":"对的，一些技术框架还是需要经受大公司或者一些大型项目的验证，不过我们也可以先在一些小型项目中先行使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562037434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109411,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1562030518,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562030518","product_id":100028001,"comment_content":"听过quasar，好像这个早就有了，但不知道为啥没火起来","like_count":0,"discussions":[{"author":{"id":1202881,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/c1/6df65e0a.jpg","nickname":"190coder","note":"","ucode":"68111F5B32CCF7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534093,"discussion_content":"我理解目前在java开发的大部门web项目中大多是分布式场景中，很少有高阻塞+高IO场景，大部门都是RPC请求带来的网络IO并发场景。协程减少的线程上下文切换开销远小于 网络IO带来的开销。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638093468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109405,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1562030180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562030180","product_id":100028001,"comment_content":"除了内存模型还有线程模型，这种有虚拟机的语言是不是都有这种对应关系啊。协程用的不多，以前想用kilim但是有点麻烦，就没用了","like_count":0},{"had_liked":false,"id":109375,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1562027834,"is_pvip":false,"replies":[{"id":"39622","content":"mailbox不会阻塞，这是一个信箱，协程之间通过mailbox来分享共享变量","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562035568,"ip_address":"","comment_id":109375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562027834","product_id":100028001,"comment_content":"请问mailbox是如何实现阻塞的呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456384,"discussion_content":"mailbox不会阻塞，这是一个信箱，协程之间通过mailbox来分享共享变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562035568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109361,"user_name":"沧颜","can_delete":false,"product_type":"c1","uid":1517966,"ip_address":"","ucode":"143CF912BC7247","user_header":"https://static001.geekbang.org/account/avatar/00/17/29/8e/bdd22627.jpg","comment_is_top":false,"comment_ctime":1562026454,"is_pvip":false,"replies":[{"id":"39621","content":"kotlin也很多人使用","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562035476,"ip_address":"","comment_id":109361,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1562026454","product_id":100028001,"comment_content":"kotlin的协程设计应该和这个框架差不多吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456379,"discussion_content":"kotlin也很多人使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562035476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096630,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/b6/55f6beba.jpg","nickname":"zhongjinming","note":"","ucode":"068B0DB0A74D2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3914,"discussion_content":"请问老师，例子中协程A和协程B如果存在资源竞争的时候 是不是就不能放在不同的线程A和线程B里执行；","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564975490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}