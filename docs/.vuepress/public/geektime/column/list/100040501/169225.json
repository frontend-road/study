{"id":169225,"title":"01 | 堆、栈、RAII：C++里该如何管理资源？","content":"<p>你好，我是吴咏炜。</p><p>今天我们就正式开启了C++的学习之旅，作为第一讲，我想先带你把地基打牢。我们来学习一下内存管理的基本概念，大致的学习路径是：先讲堆和栈，然后讨论 C++ 的特色功能  RAII。掌握这些概念，是能够熟练运用 C++ 的基础。</p><h2>基本概念</h2><p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p><p>C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 <code>new</code> 和 <code>delete</code> 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p><ul>\n<li><code>new</code> 和 <code>delete</code> 操作的区域是 free store</li>\n<li><code>malloc</code> 和 <code>free</code> 操作的区域是 heap</li>\n</ul><p>但 <code>new</code> 和 <code>delete</code> 通常底层使用 <code>malloc</code> 和 <code>free</code> 来实现，所以 free store 也是 heap。鉴于对其区分的实际意义并不大，在本专栏里，除非另有特殊说明，我会只使用堆这一术语。</p><p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p><!-- [[[read_end]]] --><p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p><p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。</p><p>接下来，我将会对堆、栈和 RAII 进行深入的探讨。</p><h2>堆</h2><p>从现代编程的角度来看，使用堆，或者说使用动态内存分配，是一件再自然不过的事情了。下面这样的代码，都会导致在堆上分配内存（并构造对象）。</p><pre><code class=\"language-c++\">// C++\nauto ptr = new std::vector&lt;int&gt;();\n</code></pre><pre><code class=\"language-java\">// Java\nArrayList&lt;int&gt; list = new ArrayList&lt;int&gt;();\n</code></pre><pre><code class=\"language-python\"># Python\nlst = list()\n</code></pre><p>从历史的角度，动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性——内存分配耗时需要多久？失败了怎么办？等等——至今仍有很多场合会禁用动态内存，尤其在实时性要求比较高的场合，如飞行控制器和电信设备。不过，由于大家多半对这种用法比较熟悉，特别是从 C 和 C++ 以外的其他语言开始学习编程的程序员，所以提到内存管理，我们还是先讨论一下使用堆的编程方式。</p><p>在堆上分配内存，有些语言可能使用 <code>new</code> 这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作：</p><ol>\n<li>让内存管理器分配一个某个大小的内存块</li>\n<li>让内存管理器释放一个之前分配的内存块</li>\n<li>让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</li>\n</ol><p>C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。</p><p><strong>需要略加说明的是，上面的三个操作都不简单，并且彼此之间是相关的。</strong></p><p>第一，分配内存要考虑程序当前已经有多少未分配的内存。内存不足时要从操作系统申请新的内存。内存充足时，要从可用的内存里取出一块合适大小的内存，做簿记工作将其标记为已用，然后将其返回给要求内存的代码。</p><p>需要注意到，绝大部分情况下，可用内存都会比要求分配的内存大，所以代码只被允许使用其被分配的内存区域，而剩余的内存区域仍属于未分配状态，可以在后面的分配过程中使用。另外，如果内存管理器支持垃圾收集的话，分配内存的操作还可能会触发垃圾收集。</p><p>第二，释放内存不只是简单地把内存标记为未使用。对于连续未使用的内存块，通常内存管理器需要将其合并成一块，以便可以满足后续的较大内存分配要求。毕竟，目前的编程模式都要求申请的内存块是连续的。</p><p>第三，垃圾收集操作有很多不同的策略和实现方式，以实现性能、实时性、额外开销等各方面的平衡。由于 C++ 里通常都不使用垃圾收集，所以就不是我们专栏的重点，不再展开讲解。</p><p>下面这张图展示了一个简单的分配过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/5a/1814fb6093744c64ac9d3861fb4d3a5a.png?wh=1042*744\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/a7/3b/a7b72d6062c5cd798a2de991bffd713b.png?wh=1042*744\" alt=\"\"></p><p>注意在图 1e 的状态下，内存管理器是满足不了长度大于 4 的内存分配要求的；而在图 1f 的状态，则长度小于等于 7 的单个内存要求都可以得到满足。</p><p>当然，这只是一个简单的示意，只是为了让你能够对这个过程有一个大概的感性认识。在不考虑垃圾收集的情况下，内存需要手工释放；在此过程中，内存可能有碎片化的情况。比如，在图 1d 的情况下，虽然总共剩余内存为 6，但却满足不了长度大于 4 的内存分配要求。</p><p>幸运的是，大部分软件开发人员都不需要担心这个问题。内存分配和释放的管理，是内存管理器的任务，一般情况下我们不需要介入。我们只需要正确地使用 <code>new</code> 和 <code>delete</code>。每个 <code>new</code> 出来的对象都应该用 <code>delete</code> 来释放，就是这么简单。</p><p>但真的很简单、可以高枕无忧了吗？</p><p>事实说明，漏掉 <code>delete</code> 是一种常见的情况，这叫“内存泄漏”——相信你一定听到过这个说法。为什么呢？</p><p>我们还是看一些代码例子。</p><pre><code class=\"language-c++\">void foo()\n{\n  bar* ptr = new bar();\n  …\n  delete ptr;\n}\n</code></pre><p>这个很简单吧，但是却存在两个问题：</p><ol>\n<li>中间省略的代码部分也许会抛出异常，导致最后的 <code>delete ptr</code> 得不到执行。</li>\n<li>更重要的，这个代码不符合 C++ 的惯用法。在 C++ 里，这种情况下有 99% 的可能性不应该使用堆内存分配，而应使用栈内存分配。这样写代码的，估计可能是从 Java 转过来的🤭——但我真见过这样的代码。</li>\n</ol><p>而更常见、也更合理的情况，是分配和释放不在一个函数里。比如下面这段示例代码：</p><pre><code class=\"language-c++\">bar* make_bar(…)\n{\n  bar* ptr = nullptr;\n  try {\n    ptr = new bar();\n    …\n  }\n  catch (...) {\n    delete ptr;\n    throw;\n  }\n  return ptr;\n}\n\nvoid foo()\n{\n  …\n  bar* ptr = make_bar(…)\n  …\n  delete ptr;\n}\n</code></pre><p>这样的话，会漏 <code>delete</code> 的可能性是不是大多了？有关这个问题的解决方法，我们在下一讲还会提到。</p><p>好，堆我们暂时就讨论到这儿。下面，我们看看更符合 C++ 特性的栈内存分配。</p><h2>栈</h2><p>我们先来看一段示例代码，来说明 C++ 里函数调用、本地变量是如何使用栈的。当然，这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。</p><pre><code class=\"language-c++\">void foo(int n)\n{\n  …\n}\n\nvoid bar(int n)\n{\n  int a = n + 1;\n  foo(a);\n}\n\nint main()\n{\n  …\n  bar(42);\n  …\n}\n</code></pre><p>这段代码执行过程中的栈变化，我画了下面这张图来表示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/3b/6ef3d653af7fa6c9728ea4bea348093b.png?wh=1446*710\" alt=\"\"></p><p>在我们的示例中，栈是向上增长的。在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，<strong>分配出本地变量所需的空间</strong>，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。</p><p>注意到了没有，本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。我们可以看到：</p><ul>\n<li>栈上的分配极为简单，移动一下栈指针而已。</li>\n<li>栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。</li>\n<li>由于后进先出的执行过程，不可能出现内存碎片。</li>\n</ul><p>顺便说一句，图 2 中每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧（stack frame）。GCC 和 Clang 的命令行参数中提到 frame 的，如 <code>-fomit-frame-pointer</code>，一般就是指栈帧。</p><p>前面例子的本地变量是简单类型，C++ 里称之为 POD 类型（Plain Old Data）。对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效，只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用。</p><p>这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。事实上，如果你用 MSVC 编译含异常的 C++ 代码，但没有使用上一讲说过的 <code>/EHsc</code> 参数，编译器就会报告：</p><blockquote>\n<p>warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc</p>\n</blockquote><p>下面是一段简短的代码，可以演示栈展开：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nclass Obj {\npublic:\n  Obj() { puts(\"Obj()\"); }\n  ~Obj() { puts(\"~Obj()\"); }\n};\n\nvoid foo(int n)\n{\n  Obj obj;\n  if (n == 42)\n    throw \"life, the universe and everything\";\n}\n\nint main()\n{\n  try {\n    foo(41);\n    foo(42);\n  }\n  catch (const char* s) {\n    puts(s);\n  }\n}\n</code></pre><p>执行代码的结果是：</p><blockquote>\n<p><code>Obj()</code><br>\n<code>~Obj()</code><br>\n<code>Obj()</code><br>\n<code>~Obj()</code><br>\n<code>life, the universe and everything</code></p>\n</blockquote><p>也就是说，不管是否发生了异常，<code>obj</code> 的析构函数都会得到执行。</p><p>在 C++ 里，所有的变量缺省都是值语义——如果不使用 <code>*</code> 和 <code>&amp;</code> 的话，变量不会像 Java 或 Python 一样引用一个堆上的对象。对于像智能指针这样的类型，你写 <code>ptr-&gt;call()</code> 和 <code>ptr.get()</code>，语法上都是对的，并且 <code>-&gt;</code> 和 <code>.</code> 有着不同的语法作用。而在大部分其他语言里，访问成员只用 <code>.</code>，但在作用上实际等价于 C++ 的 <code>-&gt;</code>。这种值语义和引用语义的区别，是 C++ 的特点，也是它的复杂性的一个来源。要用好 C++，就需要理解它的值语义的特点。</p><p>对堆和栈有了基本了解之后，我们继续往下，聊一聊 C++ 的重要特性 RAII。</p><h2>RAII</h2><p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：</p><ul>\n<li>对象很大；</li>\n<li>对象的大小在编译时不能确定；</li>\n<li>对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</li>\n</ul><p>常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。下面的例子，是对工厂方法的简单演示：</p><pre><code class=\"language-c++\">enum class shape_type {\n  circle,\n  triangle,\n  rectangle,\n  …\n};\n\nclass shape { … };\nclass circle : public shape { … };\nclass triangle : public shape { … };\nclass rectangle : public shape { … };\n\nshape* create_shape(shape_type type)\n{\n  …\n  switch (type) {\n  case shape_type::circle:\n    return new circle(…);\n  case shape_type::triangle:\n    return new triangle(…);\n  case shape_type::rectangle:\n    return new rectangle(…);\n  …\n  }\n}\n</code></pre><p>这个 <code>create_shape</code> 方法会返回一个 <code>shape</code> 对象，对象的实际类型是某个 <code>shape</code> 的子类，圆啊，三角形啊，矩形啊，等等。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是 <code>shape</code>，实际却返回一个 <code>circle</code>，编译器不会报错，但结果多半是错的。这种现象叫对象切片（object slicing），是 C++ 特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是 C++ 的一个陷阱了，大家需要小心这个问题。</p><p>那么，我们怎样才能确保，在使用 <code>create_shape</code> 的返回值时不会发生内存泄漏呢？</p><p>答案就在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。一个简单的实现如下所示：</p><pre><code class=\"language-c++\">class shape_wrapper {\npublic:\n  explicit shape_wrapper(\n    shape* ptr = nullptr)\n    : ptr_(ptr) {}\n  ~shape_wrapper()\n  {\n    delete ptr_;\n  }\n  shape* get() const { return ptr_; }\nprivate:\n  shape* ptr_;\n};\n\nvoid foo()\n{\n  …\n  shape_wrapper ptr_wrapper(\n    create_shape(…));\n  …\n}\n</code></pre><p>如果你好奇 <code>delete</code> 空指针会发生什么的话，那答案是，这是一个合法的空操作。在 <code>new</code> 一个对象和 <code>delete</code> 一个指针时编译器需要干不少活的，它们大致可以如下翻译：</p><pre><code class=\"language-c++\">// new circle(…)\n{\n  void* temp = operator new(sizeof(circle));\n  try {\n    circle* ptr =\n      static_cast&lt;circle*&gt;(temp);\n    ptr-&gt;circle(…);\n    return ptr;\n  }\n  catch (...) {\n    operator delete(ptr);\n    throw;\n  }\n}\n</code></pre><pre><code class=\"language-c++\">if (ptr != nullptr) {\n  ptr-&gt;~shape();\n  operator delete(ptr);\n}\n</code></pre><p>也就是说，<code>new</code> 的时候先分配内存（失败时整个操作失败并向外抛出异常，通常是 <code>bad_alloc</code>），然后在这个结果指针上构造对象（注意上面示意中的调用构造函数并不是合法的 C++ 代码）；构造成功则 <code>new</code> 操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。<code>delete</code> 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。</p><p>回到 <code>shape_wrapper</code> 和它的析构行为。在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：</p><ul>\n<li>关闭文件（<code>fstream</code> 的析构就会这么做）</li>\n<li>释放同步锁</li>\n<li>释放其他重要的系统资源</li>\n</ul><p>例如，我们应该使用：</p><pre><code class=\"language-c++\">std::mutex mtx;\n\nvoid some_func()\n{\n  std::lock_guard&lt;std::mutex&gt; guard(mtx);\n  // 做需要同步的工作\n}\n</code></pre><p>而不是：</p><pre><code class=\"language-c++\">std::mutex mtx;\n\nvoid some_func()\n{\n  mtx.lock();\n  // 做需要同步的工作……\n  // 如果发生异常或提前返回，\n  // 下面这句不会自动执行。\n  mtx.unlock();\n}\n</code></pre><p>顺便说一句，上面的 <code>shape_wrapper</code> 差不多就是个最简单的智能指针了。至于完整的智能指针，我们留到下一讲继续学习。</p><h2>内容小结</h2><p>本讲我们讨论了 C++ 里内存管理的一些基本概念，强调栈是 C++ 里最“自然”的内存使用方式，并且，使用基于栈和析构函数的 RAII，可以有效地对包括堆内存在内的系统资源进行统一管理。</p><h2>课后思考</h2><p>最后留给你一道思考题。<code>shape_wrapper</code> 和智能指针比起来，还缺了哪些功能？欢迎留言和我分享你的观点。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Memory management”. <a href=\"https://en.wikipedia.org/wiki/Memory_management\">https://en.wikipedia.org/wiki/Memory_management</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Stack-based memory allocation”. <a href=\"https://en.wikipedia.org/wiki/Stack-based_memory_allocation\">https://en.wikipedia.org/wiki/Stack-based_memory_allocation</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Resource acquisition is initialization”. <a href=\"https://en.wikipedia.org/wiki/RAII\">https://en.wikipedia.org/wiki/RAII</a> </span></p><p><span class=\"reference\">[3a] 维基百科, “RAII”. <a href=\"https://zh.wikipedia.org/zh-cn/RAII\">https://zh.wikipedia.org/zh-cn/RAII</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Call stack”. <a href=\"https://en.wikipedia.org/wiki/Call_stack\">https://en.wikipedia.org/wiki/Call_stack</a> </span></p><p><span class=\"reference\">[5] Wikipedia, “Object slicing”. <a href=\"https://en.wikipedia.org/wiki/Object_slicing\">https://en.wikipedia.org/wiki/Object_slicing</a> </span></p><p><span class=\"reference\">[6] Stack Overflow, “Why does the stack address grow towards decreasing memory addresses?” <a href=\"https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses\">https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses</a> </span></p><p><span class=\"reference\">注意：有些条目虽然有中文版，但内容太少；此处单独标出中文版条目的，则是内容比较全面、能够补充本专栏内容的情况。 </span></p>","neighbors":{"left":{"article_title":"课前必读 | 有关术语发音及环境要求","id":169198},"right":{"article_title":"02 | 自己动手，实现C++的智能指针","id":169263}},"comments":[{"had_liked":false,"id":155594,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1574725224,"is_pvip":true,"replies":[{"id":"59703","content":"其他都对，不过，自定义delete似乎目前没这个必要？<br><br>1. 好问题。静态存储区既不是堆也不是栈，而是……静态的。意思是，它们是在程序编译、链接时完全确定下来的，具有固定的存储位置（暂不考虑某些系统的地址扰乱机制）。堆和栈上的变量则都是动态的，地址无法确定。<br><br>2. thread_local和静态存储区类似，只不过不是整个程序统一一块，而是每个线程单独一块。用法上还是当成全局&#47;静态变量来用，但不共享也就不需要同步了。<br><br>3. 非静态数据成员加上动态类型所需的空间。注意后者不一定是4，而一般是指针的大小，在64位系统上是8字节。还有，要考虑字节对齐的影响。静态数据成员和成员函数都不占个别对象的空间。","user_name":"作者回复","comment_id":155594,"uid":"1645639","ip_address":"","utype":1,"ctime":1574733455,"user_name_real":"吴咏炜"}],"discussion_count":22,"race_medal":0,"score":"392416749160","product_id":100040501,"comment_content":"没有引用计数，没有拷贝和移动，没有线程安全，没有自定义delete函数，另外想请教老师一些问题.<br>1. 全局静态和局部静态的变量是存储在哪个区域？看很多书是静态存储区，但静态存储区又是什么区？堆？<br>2. thread local的变量存储在哪个区？因为线程是动态创建的，理解这个变量内存也应该动态分配的，线程结束内存自动释放？难道也是堆？<br>3. 类的大小是怎么定的呢？一般都是看类的成员变量占用字节数再根据是否虚类看是否加4字节，但是类里面有很多成员函数，这些成员函数不占空间吗，如果有静态成员变量或者静态成员函数呢？<br>谢谢老师!","like_count":91,"discussions":[{"author":{"id":1362403,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","nickname":"三味","note":"","ucode":"A580F715D1CC96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70327,"discussion_content":"关于最后一点类的成员函数, 记得曾经有个人举过这样一个例子:\nstruct A{ void func() { cout<<&#34;hello world&#34; << endl; } };\nint main() {\n    A* pa = nullptr;\n    pa->func();\n    return 0;\n}\n然后就很容易就能明白了.","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575345628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60338,"discussion_content":"推荐可以看程序员的自我修养这本书，好多问题就会清晰","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574728099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1141994,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","nickname":"泰伦卢","note":"","ucode":"FEA6B43C8D4FF9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":60512,"discussion_content":"谢谢，这本书几年前看了一部分发现当时的水平根本看不懂，最近我再看一看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574735206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60338,"ip_address":""},"score":60512,"extra":""},{"author":{"id":1151971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/e3/da819340.jpg","nickname":"马仔","note":"","ucode":"75760150602EA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1141994,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","nickname":"泰伦卢","note":"","ucode":"FEA6B43C8D4FF9","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":100514,"discussion_content":"我也想看一看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577266094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60512,"ip_address":""},"score":100514,"extra":""}]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475800,"discussion_content":"其他都对，不过，自定义delete似乎目前没这个必要？\n\n1. 好问题。静态存储区既不是堆也不是栈，而是……静态的。意思是，它们是在程序编译、链接时完全确定下来的，具有固定的存储位置（暂不考虑某些系统的地址扰乱机制）。堆和栈上的变量则都是动态的，地址无法确定。\n\n2. thread_local和静态存储区类似，只不过不是整个程序统一一块，而是每个线程单独一块。用法上还是当成全局/静态变量来用，但不共享也就不需要同步了。\n\n3. 非静态数据成员加上动态类型所需的空间。注意后者不一定是4，而一般是指针的大小，在64位系统上是8字节。还有，要考虑字节对齐的影响。静态数据成员和成员函数都不占个别对象的空间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574733455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3100089,"avatar":"https://static001.geekbang.org/account/avatar/00/2f/4d/b9/7e4659c5.jpg","nickname":"runzeUnchained","note":"","ucode":"63A86E52AF05DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583771,"discussion_content":"智能指针本身就不是线程安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660364655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792714,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","nickname":"Im me","note":"","ucode":"FF7DEED4BB4C37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569549,"discussion_content":"受益匪浅,感谢提问和老师的回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651477101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2726937,"avatar":"https://static001.geekbang.org/account/avatar/00/29/9c/19/59fce6fa.jpg","nickname":"神经蛙","note":"","ucode":"62D8578997B564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394200,"discussion_content":"编个简单的东西，看一眼反汇编就都明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631780887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260213,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/b5/22d74b60.jpg","nickname":"许思维","note":"","ucode":"3A470CAC0ADAC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355972,"discussion_content":"这几个问题可以看 侯捷老师翻译的《深入理解C++对象模型》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615513517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1835765,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/02/f5/7d262c57.jpg","nickname":"落鲸与鱼","note":"","ucode":"50C41DFC06C773","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1260213,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/b5/22d74b60.jpg","nickname":"许思维","note":"","ucode":"3A470CAC0ADAC4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543528,"discussion_content":"是的，讲的很清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641196127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":355972,"ip_address":""},"score":543528,"extra":""}]},{"author":{"id":2361409,"avatar":"https://static001.geekbang.org/account/avatar/00/24/08/41/63d4d7f3.jpg","nickname":"WonBean","note":"","ucode":"94C5E87F4F77D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337160,"discussion_content":"第三点这里还可以引出一个新问题，C++中一个空类的大小是多少 class A {};","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608808875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1135701,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","nickname":"Edison","note":"","ucode":"734A561F363720","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2361409,"avatar":"https://static001.geekbang.org/account/avatar/00/24/08/41/63d4d7f3.jpg","nickname":"WonBean","note":"","ucode":"94C5E87F4F77D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366516,"discussion_content":"一个字节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618104719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337160,"ip_address":""},"score":366516,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1135701,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","nickname":"Edison","note":"","ucode":"734A561F363720","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366754,"discussion_content":"还有个空类优化的。如果一个空类被继承，它在子类里不占任何字节。从这个意义上说，在C++里私有继承比组合更加经济。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618186208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366516,"ip_address":""},"score":366754,"extra":""},{"author":{"id":1835765,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/02/f5/7d262c57.jpg","nickname":"落鲸与鱼","note":"","ucode":"50C41DFC06C773","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543530,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641196154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366754,"ip_address":""},"score":543530,"extra":""}]},{"author":{"id":1565950,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0hbe9w5kuAvf6d17suDPB6W1j2hlYPJ43eRogABUic5pUV7ia5rPHjXLWEfDZLHiafMUiaQ/132","nickname":"marsly","note":"","ucode":"1F61DE32D99426","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278874,"discussion_content":"最后一个问题推荐 深度探索C++对象模型一书，讲的非常详细，好像侯捷老师翻译的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591249069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526311,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/27/2702206d.jpg","nickname":"百年","note":"","ucode":"6D41E3D3282255","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67804,"discussion_content":"我记得这个是存在内存四区里的一个位置！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575178328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757384,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL41RCmZy6An5SLXPmXU6ea5yvweBGPicedqQ0xjuaYp1PY1CSlUuNwgV3BNpbWzdJwXlWZAVicrtPg/132","nickname":"啦啦啦","note":"","ucode":"76BBA994C40F23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60703,"discussion_content":"静态和非静态成员函数都是在类对象之外的，静态变量也在类对象之外","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574747475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141994,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","nickname":"泰伦卢","note":"","ucode":"FEA6B43C8D4FF9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60511,"discussion_content":"感谢老师，个人认为自定义delete可以用于控制sharedptr指针数组的释放，uniqueptr当然没这个问题，而且有时候也可以用智能指针来控制文件的自动关闭，个人拙见，不知道对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574735170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1141994,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","nickname":"泰伦卢","note":"","ucode":"FEA6B43C8D4FF9","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":61770,"discussion_content":"啊，当时没理解你的意思：我把自定义delete函数字面理解成在类里定义`operator delete`了。你如果写deleter或删除器我大概就会理解了😅。另外，删除器一般是个函数对象，而不是函数。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574783321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60511,"ip_address":""},"score":61770,"extra":""},{"author":{"id":1135701,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","nickname":"Edison","note":"","ucode":"734A561F363720","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":366519,"discussion_content":"老师，针对helloworld的问题一，我想再追问一下，如果一个类中定义太多的static类型的成员变量和函数成员，会有什么问题，我看到我们公司内部代码里面，一个类的成员函数几乎都是static类型。直接通过类名来调用这些函数成员","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618104963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61770,"ip_address":""},"score":366519,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1135701,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","nickname":"Edison","note":"","ucode":"734A561F363720","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366755,"discussion_content":"没啥技术问题，但多半不能算一个好的封装，不是好的设计。静态成员跟某个名空间下的自由成员区别就不大了，除了如果有些私有、有些公有的话，这样做提供了一些对私有成员的访问控制。但你也可以把这些私有的静态成员放到 .cpp 文件的匿名名空间里去，效果我没想出有啥区别。\n\n有可能这种做法是以前Java开发者带过来的？毕竟Java里一切都需要放类里……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618186553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366519,"ip_address":""},"score":366755,"extra":""}]}]},{"had_liked":false,"id":155608,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1574728384,"is_pvip":true,"replies":[{"id":"59864","content":"谢谢。这个专栏是要求之前学过、用过C++的。没学过的不合适。","user_name":"作者回复","comment_id":155608,"uid":"1645639","ip_address":"","utype":1,"ctime":1574763030,"user_name_real":"吴咏炜"}],"discussion_count":3,"race_medal":0,"score":"181963354816","product_id":100040501,"comment_content":"说实话，这个专栏对于我这个经常使用C++来做项目的人来讲，我认为不适合初学者，上车需要有过C++开发经验的。一般的小伙伴可能会有压力哒，但是如果想学，克服心里畏惧，从这个专栏出发可以迅速的深入。很好的专栏。","like_count":42,"discussions":[{"author":{"id":1347123,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8e/33/0769f7c7.jpg","nickname":"Chang","note":"","ucode":"9FBB91A8E0CE3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70822,"discussion_content":"实际上，给初学者的入门资料太多了，而这门课的价值在于其稍稍进阶的讲解。大家共同进步。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575381519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475806,"discussion_content":"谢谢。这个专栏是要求之前学过、用过C++的。没学过的不合适。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574763030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1686397,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","nickname":"黄振宇","note":"","ucode":"976BC7B46DA419","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60753,"discussion_content":"确实有难度。。初学者看起来有点吃力了\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574751891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155665,"user_name":"bo","can_delete":false,"product_type":"c1","uid":1368074,"ip_address":"","ucode":"B1D7177830DE07","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/0a/bf7ece06.jpg","comment_is_top":false,"comment_ctime":1574734641,"is_pvip":false,"replies":[{"id":"59859","content":"凡生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。","user_name":"作者回复","comment_id":155665,"uid":"1645639","ip_address":"","utype":1,"ctime":1574762585,"user_name_real":"吴咏炜"}],"discussion_count":8,"race_medal":0,"score":"173373426481","product_id":100040501,"comment_content":"老师您好！工程的时候，具体怎么考虑在栈上分配还是在堆上分配，更合理些？","like_count":40,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475822,"discussion_content":"凡生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574762585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1340589,"avatar":"https://static001.geekbang.org/account/avatar/00/14/74/ad/771d2646.jpg","nickname":"赵奇彬","note":"","ucode":"74B0FF5C558F89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299013,"discussion_content":"用智能指针就完了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597510507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1010819,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","nickname":"Luke","note":"","ucode":"8368A63185356D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1340589,"avatar":"https://static001.geekbang.org/account/avatar/00/14/74/ad/771d2646.jpg","nickname":"赵奇彬","note":"","ucode":"74B0FF5C558F89","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300577,"discussion_content":"不符合C++惯用法，局部使用的变量或对象没必要在堆上分配（非得new出来后再构造智能指针，智能指针有额外开销，包括编码和程序运行两个层面），分配在栈上，可以在出栈时自动释放内存，不会发生内存泄露。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598178875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299013,"ip_address":""},"score":300577,"extra":""},{"author":{"id":2361409,"avatar":"https://static001.geekbang.org/account/avatar/00/24/08/41/63d4d7f3.jpg","nickname":"WonBean","note":"","ucode":"94C5E87F4F77D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1010819,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","nickname":"Luke","note":"","ucode":"8368A63185356D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337161,"discussion_content":"另外有一点需要注意，极端情况万一对象太大超出栈空间大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608809011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300577,"ip_address":""},"score":337161,"extra":""},{"author":{"id":1607117,"avatar":"https://static001.geekbang.org/account/avatar/00/18/85/cd/63a10fbe.jpg","nickname":"简之","note":"","ucode":"6C96513778BA68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1340589,"avatar":"https://static001.geekbang.org/account/avatar/00/14/74/ad/771d2646.jpg","nickname":"赵奇彬","note":"","ucode":"74B0FF5C558F89","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568155,"discussion_content":"堆内存分配释放很慢的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651071939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299013,"ip_address":""},"score":568155,"extra":""}]},{"author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82675,"discussion_content":"对象大小在编译时候不确定，或者返回值是对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576344738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000070,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/86/d05de870.jpg","nickname":"Xiang","note":"","ucode":"374744FF627C00","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64571,"discussion_content":"对象移动，有rust的味道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574950819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1759958,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/da/d6/88822f85.jpg","nickname":"羽砂","note":"","ucode":"028C043C5FDB0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63821,"discussion_content":"还要考虑栈的大小吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574914169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155940,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574780513,"is_pvip":false,"replies":[{"id":"59929","content":"认真记笔记非常好。<br><br>不过，建议笔记还是记关键字和要点，解释文字不用多。否则篇幅跟原文接近就意义不大了。","user_name":"作者回复","comment_id":155940,"uid":"1645639","ip_address":"","utype":1,"ctime":1574813561,"user_name_real":"吴咏炜"}],"discussion_count":3,"race_medal":0,"score":"130423799393","product_id":100040501,"comment_content":"学习笔记：<br><br>1、概念<br>堆（heap）：在内存管理中，指的是动态分配内存的区域。当被分配之后需要手工释放，否则，就会造成内存泄漏。<br>C++ 标准里一个相关概念是自由存储区（free store），特指使用 new 和 delete 来分配和释放内存的区域。<br>这是堆的一个子集：new 和 delete 操作的区域是 free store，而 malloc 和 free 操作的区域是 heap 。<br>但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。<br><br>栈（stack）：在内存管理中，指的是函数调用过程中产生的本地变量和调用数据的区域。<br><br>RAII（Resource Acquisition Is Initialization）：C++ 所特有的资源管理方式。<br>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。<br>对 RAII 的使用，使得 C++ 不需要垃圾收集方法，也能有效地对内存进行管理。<br><br>2、堆<br>C++程序需要牵涉到两个的内存管理器的操作：<br><br>1). 让内存管理器分配一个某个大小的内存块<br>分配内存要考虑程序当前已经有多少未分配的内存。<br>内存不足时要从操作系统申请新的内存。<br>内存充足时，要从可用的内存里取出一块合适大小的内存，并将其标记为已用，然后将其返回给要求内存的代码。<br><br>2). 让内存管理器释放一个之前分配的内存块<br>释放内存不只是简单地把内存标记为未使用。<br>对于连续未使用的内存块，通常内存管理器需要将其合并成一块，以便可以满足后续的较大内存分配要求。<br>目前的编程模式都要求申请的内存块是连续的。<br><br>从堆上申请的内存需要手工释放，但在此过程中，内存可能有碎片化的情况。<br>一般情况下不需要开发人员介入。因为内存分配和释放的管理，是内存管理器的任务。<br>开发人员只需要正确地使用 new 和 delete，即每个 new 出来的对象都应该用 delete 来释放。<br><br>3、栈<br>大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。<br>任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。<br>当函数调用另外一个函数时，会把参数也压入栈里，然后把下一行汇编指令的地址压入栈，并跳转到新的函数。<br>新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，分配出本地变量所需的空间，随后执行函数中的代码。<br>在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。<br><br>本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。<br>当函数执行完成之后，这些内存也就自然而然释放掉了。<br>栈上的内存分配，是移动一下栈指针。<br>栈上的内存释放，是函数执行结束时移动一下栈指针。<br>由于后进先出的执行过程，不可能出现内存碎片。<br><br>每个函数占用的栈空间有个特定的术语，叫做栈帧（stack frame）。<br>GCC 和 Clang 的命令行参数中提到 frame 的，如 -fomit-frame-pointer，一般就是指栈帧。<br><br>如果本地变量是简单类型，C++ 里称之为 POD 类型（Plain Old Data）。<br>对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效。<br>只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用。<br>编译器会自动调用析构函数，包括在函数执行发生异常的情况。<br>在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。<br><br>在 C++ 里，所有的变量缺省都是值语义。<br>引用一个堆上的对象需要使用 * 和 &amp; 。<br>对于像智能指针这样的类型，使用 ptr-&gt;call() 和 ptr.get()，语法上都是对的，并且 -&gt; 和 . 有着不同的语法作用。<br>这种值语义和引用语义的区别，是 C++ 的特点，也是它的复杂性的一个来源。<br>","like_count":30,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475932,"discussion_content":"认真记笔记非常好。\n\n不过，建议笔记还是记关键字和要点，解释文字不用多。否则篇幅跟原文接近就意义不大了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318528,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","nickname":"Sochooligan","note":"","ucode":"B66F78B6B86476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102284,"discussion_content":"我建议进一步总结一下，你自己的理解和有疑问的地方！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577336094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62051,"discussion_content":"了解，我后面会精简整理成自己容易掌握的知识点，而不是照搬老师的文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574815132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157115,"user_name":"史鹏飞","can_delete":false,"product_type":"c1","uid":1497528,"ip_address":"","ucode":"39D9A28082C0BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/d9/b8/2d8900d5.jpg","comment_is_top":false,"comment_ctime":1575033896,"is_pvip":false,"replies":[{"id":"60298","content":"这就是面向对象里的基本用法了。在面向对象的继承体系了，shape需要有一个虚析构函数。这样如果有一个shape*实际指向circle，在delete这个指针时，调用的是circle的析构函数（当然析构过程中，最后也会再调用shape的析构函数）。<br><br>下面的代码可以展示这个过程：<br><br>#include &lt;stdio.h&gt;<br><br>class shape {<br>public:<br>  virtual ~shape()<br>  {<br>    puts(&quot;~shape&quot;);<br>  }<br>};<br><br>class circle : public shape {<br>public:<br>  ~circle()<br>  {<br>    puts(&quot;~circle&quot;);<br>  }<br>};<br><br>int main()<br>{<br>  shape* ptr = new circle();<br>  delete ptr;<br>}<br><br>结果是：<br><br>~circle<br>~shape","user_name":"作者回复","comment_id":157115,"uid":"1645639","ip_address":"","utype":1,"ctime":1575079360,"user_name_real":"吴咏炜"}],"discussion_count":6,"race_medal":0,"score":"121834118184","product_id":100040501,"comment_content":"老师在shape_wrapper类下边的foo函数调用完后，会把shape析构掉，但如何析构circle呢？","like_count":28,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476331,"discussion_content":"这就是面向对象里的基本用法了。在面向对象的继承体系了，shape需要有一个虚析构函数。这样如果有一个shape*实际指向circle，在delete这个指针时，调用的是circle的析构函数（当然析构过程中，最后也会再调用shape的析构函数）。\n\n下面的代码可以展示这个过程：\n\n#include &amp;lt;stdio.h&amp;gt;\n\nclass shape {\npublic:\n  virtual ~shape()\n  {\n    puts(&amp;quot;~shape&amp;quot;);\n  }\n};\n\nclass circle : public shape {\npublic:\n  ~circle()\n  {\n    puts(&amp;quot;~circle&amp;quot;);\n  }\n};\n\nint main()\n{\n  shape* ptr = new circle();\n  delete ptr;\n}\n\n结果是：\n\n~circle\n~shape","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575079360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1088453,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9b/c5/3ef64571.jpg","nickname":"Nofissure","note":"","ucode":"877943E169CFE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":534183,"discussion_content":"老师你好，为什么会调用基类的虚析构方法呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638114579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":476331,"ip_address":""},"score":534183,"extra":""}]},{"author":{"id":1441214,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fd/be/232ffedf.jpg","nickname":"大李","note":"","ucode":"45538A3E6DF9A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314626,"discussion_content":"析构函数要是虚函数，面试考点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603179590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1835765,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/02/f5/7d262c57.jpg","nickname":"落鲸与鱼","note":"","ucode":"50C41DFC06C773","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543531,"discussion_content":"这个问题对应的就是为什么父类的析构函数一般设置为虚析构函数，建议看深入探索C++对象模型，侯捷老师翻译的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641196502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/06/895a122b.jpg","nickname":"ghost","note":"","ucode":"1D5A11D65B82F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285002,"discussion_content":"老师还举例子，真实诚意满满","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592710512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284513,"discussion_content":"先析构自己，再析构父类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592545578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157616,"user_name":"Geek_3f3bcb","can_delete":false,"product_type":"c1","uid":1244557,"ip_address":"","ucode":"F8FF302BCE43FC","user_header":"","comment_is_top":false,"comment_ctime":1575213381,"is_pvip":false,"replies":[{"id":"60441","content":"哈，你是第一个用这个形容词的。😁","user_name":"作者回复","comment_id":157616,"uid":"1645639","ip_address":"","utype":1,"ctime":1575245041,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"83179592005","product_id":100040501,"comment_content":"看的有点爽","like_count":20,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476484,"discussion_content":"哈，你是第一个用这个形容词的。😁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575245041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163651,"user_name":"LiKui","can_delete":false,"product_type":"c1","uid":1498186,"ip_address":"","ucode":"7089F7F38D26A3","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/4a/0f56e0ad.jpg","comment_is_top":false,"comment_ctime":1576761301,"is_pvip":false,"replies":[{"id":"62273","content":"是的。","user_name":"作者回复","comment_id":163651,"uid":"1645639","ip_address":"","utype":1,"ctime":1576799779,"user_name_real":"吴咏炜"}],"discussion_count":2,"race_medal":0,"score":"74591205333","product_id":100040501,"comment_content":"内存泄漏的原因之二：<br>1. 异常或分支导致delete未得到执行<br>2.分配和释放不在一个函数里导致的遗漏delete","like_count":17,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478490,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576799779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2217470,"avatar":"https://static001.geekbang.org/account/avatar/00/21/d5/fe/6b817edf.jpg","nickname":"喏豆","note":"","ucode":"35C73B88D3129F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383059,"discussion_content":"第二点我很想知道 怎么解决最好 c语言也会碰到这个问题！比较困惑，有时候不知道应该在什么地方 free它最好，不知道有没有free过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625867458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155596,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1574725300,"is_pvip":true,"replies":[{"id":"59860","content":"如果这个变量下面还有用到的地方，这是个好习惯。不过，这个习惯主要还是从C来的。现代C++不推荐一般代码里再使用裸指针和new&#47;delete的。","user_name":"作者回复","comment_id":155596,"uid":"1645639","ip_address":"","utype":1,"ctime":1574762718,"user_name_real":"吴咏炜"}],"discussion_count":8,"race_medal":0,"score":"61704267444","product_id":100040501,"comment_content":"话说一般delete.后需要把这个变量置成nullptr吗，我有时候这样写，不知道有没有必要","like_count":14,"discussions":[{"author":{"id":1216016,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8e/10/10092bb1.jpg","nickname":"Luke","note":"","ucode":"C34D4C44DBCE03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60504,"discussion_content":"有必要，因为别的地方有可能有使用这个指针。\n初始化和删除后重置为确定值都是良好的习惯","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574734730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475801,"discussion_content":"如果这个变量下面还有用到的地方，这是个好习惯。不过，这个习惯主要还是从C来的。现代C++不推荐一般代码里再使用裸指针和new/delete的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574762718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267832,"avatar":"https://static001.geekbang.org/account/avatar/00/13/58/78/fe19274b.jpg","nickname":"睡在床板下","note":"","ucode":"69BF52FF9C8A0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84570,"discussion_content":"华为编程规范，已经习惯了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576501353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/06/895a122b.jpg","nickname":"ghost","note":"","ucode":"1D5A11D65B82F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285003,"discussion_content":"这个问题感觉是两种情况： 1. 如果在 C++ 中写 c like 的代码，感觉有必要；2. 如果纯现代的 C++ 代码，这些几乎都是在智能指针中处理了，感觉就没必要了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592710691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1939197,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vNIpqHwbiafuaMoDf4JgmX3lgj8oSTyMibiaZytM7zfKDaOFeSBR7CJ3sX6UmOTKOMfwu6ImR9LiarZbQY4Za46ribw/132","nickname":"银行","note":"","ucode":"D3A2A4C64A5496","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270850,"discussion_content":"个人感觉意义不大，尤其在多线程情况下这个操作基本没啥用，还是智能指针保险一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590064423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1362403,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","nickname":"三味","note":"","ucode":"A580F715D1CC96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70331,"discussion_content":"即使是在析构函数里面, 我都会加上一句ptr = nullptr;\n感觉这就是强迫自己养成一种习惯. \n好比 if (nullptr == ptr) 这么写一样. 虽然我没养成这样的习惯, 但是这么写绝对是更有益处...\n因为我真的曾经脑子一抽写下了 if (ptr = nullptr) 这样混蛋的代码... 而且调试了一晚上...头昏脑涨的, 发现问题之后, 都恨不得抽自己俩耳光... 那会儿都已经不是新手了, 都犯下过这样错误...\n不过这个问题编译器可以检查出来, 重视warning的重要性...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575345984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1362403,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","nickname":"三味","note":"","ucode":"A580F715D1CC96","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70843,"discussion_content":"我一直不喜欢 nullptr == ptr 这样的写法，就是感觉别扭，虽然我也曾经漏过等号。好在用 GCC/Clang，对这个问题一直是有明确警告的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575382008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70331,"ip_address":""},"score":70843,"extra":""}]},{"author":{"id":1422582,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","nickname":"W.jyao","note":"","ucode":"C57B3A78B6A795","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60569,"discussion_content":"必须有必要。不然成了未定义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574738647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173845,"user_name":"super-ck","can_delete":false,"product_type":"c1","uid":1307067,"ip_address":"","ucode":"02F036E53E1130","user_header":"","comment_is_top":false,"comment_ctime":1579736159,"is_pvip":false,"replies":[{"id":"67408","content":"是这个顺序。但异常抛出后，如果有相应的catch的话，析构完了才会执行到catch。","user_name":"作者回复","comment_id":173845,"uid":"1645639","ip_address":"","utype":1,"ctime":1579744418,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"48824376415","product_id":100040501,"comment_content":"您好，有一点不是很清楚，在n为42时为何不是构造函数-throw-析构函数这个顺序，根据上下文，为42时，按一般逻辑应该进判断执行才对","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482219,"discussion_content":"是这个顺序。但异常抛出后，如果有相应的catch的话，析构完了才会执行到catch。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579744418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157054,"user_name":"楚小奕","can_delete":false,"product_type":"c1","uid":1011022,"ip_address":"","ucode":"AB808A42C2535E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/4e/347c3e8f.jpg","comment_is_top":false,"comment_ctime":1575019651,"is_pvip":false,"replies":[{"id":"60270","content":"Meyers的书对提升C++能力到下一个台阶是非常重要的。我也从中学了很多。","user_name":"作者回复","comment_id":157054,"uid":"1645639","ip_address":"","utype":1,"ctime":1575027902,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"40229725315","product_id":100040501,"comment_content":"这个专栏配合 《modern effect c++》效果很好","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476315,"discussion_content":"Meyers的书对提升C++能力到下一个台阶是非常重要的。我也从中学了很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575027902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165857,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1249512,"ip_address":"","ucode":"E0AFA940BEAC1C","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/e8/172b5915.jpg","comment_is_top":false,"comment_ctime":1577334555,"is_pvip":false,"replies":[{"id":"63267","content":"不是。返回shape*是没有问题的。返回shape才会造成对象切片。<br><br>可以通过delete一个shape*来删除一个circle对象的。这个是正常的面向对象行为。要求是shape有虚析构函数。","user_name":"作者回复","comment_id":165857,"uid":"1645639","ip_address":"","utype":1,"ctime":1577355569,"user_name_real":"吴咏炜"}],"discussion_count":2,"race_medal":0,"score":"35937072923","product_id":100040501,"comment_content":"老师您好，我说一下我对内存切片那里的理解，不知道对不对：<br>返回的是个基类指针shape*，但其实指向的是个继承类circle对象。那么在用户程序里，就算用户记得delete这个指针shape*，也会造成circle部分永久残留在内存，从而造成内存泄漏，我理解的对吗？","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479295,"discussion_content":"不是。返回shape*是没有问题的。返回shape才会造成对象切片。\n\n可以通过delete一个shape*来删除一个circle对象的。这个是正常的面向对象行为。要求是shape有虚析构函数。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577355569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2466389,"avatar":"https://static001.geekbang.org/account/avatar/00/25/a2/55/ec6b990a.jpg","nickname":"JC","note":"","ucode":"0FB3C53427DF98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410525,"discussion_content":"这种语意的切片意思是\n大内存对象到小内存对象的拷贝丢失\n因为shape类是其他图形对象的基类，如果通过对象而非指针方式就存在这种切片问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635724865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202050,"user_name":"莫珣","can_delete":false,"product_type":"c1","uid":1117933,"ip_address":"","ucode":"CAFE6F2AC5C177","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","comment_is_top":false,"comment_ctime":1585893811,"is_pvip":false,"replies":[{"id":"75572","content":"是这样。不过RAII这个名字很差劲，看名字完全看不到最关键的点——析构。","user_name":"作者回复","comment_id":202050,"uid":"1645639","ip_address":"","utype":1,"ctime":1585960438,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"31650664883","product_id":100040501,"comment_content":"C++对象在销毁的时候会自动调用析构函数，所谓RAII机制其实就是在对象构造的时候初始化它所需要的资源，在析构的时候自动释放它持有的资源。","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490494,"discussion_content":"是这样。不过RAII这个名字很差劲，看名字完全看不到最关键的点——析构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585960438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155478,"user_name":"吴军旗^_^","can_delete":false,"product_type":"c1","uid":1507640,"ip_address":"","ucode":"5760CE31AE3FA5","user_header":"https://static001.geekbang.org/account/avatar/00/17/01/38/5daf2cfb.jpg","comment_is_top":false,"comment_ctime":1574691782,"is_pvip":false,"replies":[{"id":"59662","content":"如果刚开始学的话，这个专栏可能会有点挑战。可以先看一下 C++ 之父的 A Tour of C++，国内出版叫《C++语言导学》(谢谢小猪钱钱同学告知)。<br><br>另外，《C++ Primer》名声很响，但 848 页初学有点厚了。注意不是《C++ Primer Plus》，这本跟前者完全无关，不推荐。","user_name":"作者回复","comment_id":155478,"uid":"1645639","ip_address":"","utype":1,"ctime":1574693106,"user_name_real":"吴咏炜"}],"discussion_count":3,"race_medal":0,"score":"31639462854","product_id":100040501,"comment_content":"老师可推荐一下教程吗？ 从php转过来的，感觉有点难。","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475767,"discussion_content":"如果刚开始学的话，这个专栏可能会有点挑战。可以先看一下 C++ 之父的 A Tour of C++，国内出版叫《C++语言导学》(谢谢小猪钱钱同学告知)。\n\n另外，《C++ Primer》名声很响，但 848 页初学有点厚了。注意不是《C++ Primer Plus》，这本跟前者完全无关，不推荐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1367705,"avatar":"https://static001.geekbang.org/account/avatar/00/14/de/99/067ed9c6.jpg","nickname":"matheecs","note":"","ucode":"00719CDB6B80C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60456,"discussion_content":"中文版叫《C++语言导学》，第一版和第二版都有翻译出版了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574732130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364645,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/a5/7acbd63a.jpg","nickname":"eddy","note":"","ucode":"E71EE2FAD96000","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213404,"discussion_content":"我个人觉得<c++大学教程>(c++how to program)很好，很全面，另外最近翻看了下<c++ primer plus>但从知识点讲没毛病啊，为什么不推荐？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585068295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156094,"user_name":"Gerry","can_delete":false,"product_type":"c1","uid":1172429,"ip_address":"","ucode":"C3A8BC33F2A25A","user_header":"https://static001.geekbang.org/account/avatar/00/11/e3/cd/82829bf9.jpg","comment_is_top":false,"comment_ctime":1574819009,"is_pvip":false,"replies":[{"id":"60043","content":"因你这句话，我特地又去查了一下，目前看到的图，开口永远是上方。中英文资料都是如此。<br><br>这个词的来源实际上可能是堆盘子。显然，你只能从上面取放盘子……","user_name":"作者回复","comment_id":156094,"uid":"1645639","ip_address":"","utype":1,"ctime":1574857379,"user_name_real":"吴咏炜"}],"discussion_count":5,"race_medal":0,"score":"27344622785","product_id":100040501,"comment_content":"栈通常说是向下增长，从高地址到低地址。文中表述是向上增长感觉欠妥。","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475982,"discussion_content":"因你这句话，我特地又去查了一下，目前看到的图，开口永远是上方。中英文资料都是如此。\n\n这个词的来源实际上可能是堆盘子。显然，你只能从上面取放盘子……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574857379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346028,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f08a3JZjZd4Dpf2IL0g4mkQ9WtcAM3zcCZsA8r9GMpcUmsXGueVMibtJBxXDNGKx75rA/132","nickname":"dasheyuan","note":"","ucode":"AD61112AB070DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62642,"discussion_content":"“向上增长”应该与文章中栈的示意图有关吧，如果栈底是高地址的话，我认为表述没问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574856523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1346028,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f08a3JZjZd4Dpf2IL0g4mkQ9WtcAM3zcCZsA8r9GMpcUmsXGueVMibtJBxXDNGKx75rA/132","nickname":"dasheyuan","note":"","ucode":"AD61112AB070DC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62814,"discussion_content":"文中是明确这样写的：「在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。」","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574862089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":62642,"ip_address":""},"score":62814,"extra":""}]},{"author":{"id":2818265,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/00/d9/f7c658cf.jpg","nickname":"Lionel","note":"","ucode":"A6AD53F2F92EE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587059,"discussion_content":"stack开口向上，queue开口向左，几乎所有的数据结构类书籍里都是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662722816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258402,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","nickname":"皮皮侠","note":"","ucode":"04205990C1DE1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317112,"discussion_content":"IBM等大型机可能是从低地址向高地址增长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603506831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155886,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1574774005,"is_pvip":false,"replies":[{"id":"59912","content":"这里主要牵涉到“栈帧”是如何定义的。虽然“参数属于调用者而非被调用者，一般也是由调用者来释放”概念上没有错，但我当时对“栈帧”的定义想当然了。我后来又查了一下定义（用词要以大家接受的用法为准），发现参数和局部变量应该算作一个栈帧里。也就是说，你们这儿的质疑是有道理的。所以，目前我已经把图修改了，这样应该就都没有疑问了。","user_name":"作者回复","comment_id":155886,"uid":"1645639","ip_address":"","utype":1,"ctime":1574782230,"user_name_real":"吴咏炜"}],"discussion_count":3,"race_medal":0,"score":"27344577781","product_id":100040501,"comment_content":"怕评论中您看不到，在此再问一下，麻烦您啦～<br>上个问题回顾：<br>对于图2d有疑惑，希望该图绘制中可以标明main函数占用的栈空间范围及其对应的栈帧，同理，对bar和foo也一样。如果将图2d从下到上每行编号为0，1，2，...，7，那么main、bar和foo对应的栈空间占用、栈帧分别是那几行呢？<br>您的回答：嗯，问得有道理。我的颜色选取不够好，回头改一下。按一般的栈帧定义，只有 0 属于 main，1–4 属于 bar。5 以上属于 foo。<br><br>首先，非常感谢您的回复～<br><br>然而，看到有人这样问您：“参数42”和“a=43”分别是函数调用的参数和函数局部变量，应该属于同一个栈帧，为什么这里不同？<br>您的回答是：同样，实际实现通常就是这个样子的。参数属于调用者而非被调用者，一般也是由调用者来释放——至少一般 x86 的实现是这个样子。<br><br>那么和您这里回答我的就不一致的呢。您这里回答我1-4属于bar，因此，那个人问的问题（“参数42”和“a=43”应该属于同一个栈帧）这句就是对的。另外您说“参数属于调用者而非被调用者”，这里1-4既然属于bar了，那么参数42不就属于了被调用者bar了吗？我理解的是main是调用者，main调用了bar，则bar是被调用者。","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475910,"discussion_content":"这里主要牵涉到“栈帧”是如何定义的。虽然“参数属于调用者而非被调用者，一般也是由调用者来释放”概念上没有错，但我当时对“栈帧”的定义想当然了。我后来又查了一下定义（用词要以大家接受的用法为准），发现参数和局部变量应该算作一个栈帧里。也就是说，你们这儿的质疑是有道理的。所以，目前我已经把图修改了，这样应该就都没有疑问了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574782230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2623098,"avatar":"https://static001.geekbang.org/account/avatar/00/28/06/7a/9a60b72f.jpg","nickname":"haha","note":"","ucode":"E8F99449B78882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539495,"discussion_content":"好细致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639729415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2038525,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/1a/fd/41337d1e.jpg","nickname":"Albert Stack","note":"","ucode":"BBC3F3F457985A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340136,"discussion_content":"请问这个栈上的变量由调用者还是被调用者释放是否就是类似于__stdcall、__cedcl这种调用约定指定的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609914988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226608,"user_name":"Home","can_delete":false,"product_type":"c1","uid":2038373,"ip_address":"","ucode":"038156875D664A","user_header":"https://static001.geekbang.org/account/avatar/00/1f/1a/65/bcf45f14.jpg","comment_is_top":false,"comment_ctime":1592150824,"is_pvip":false,"replies":[{"id":"83428","content":"所有的指针、引用变量（以 &amp;、* 结尾的）都算引用语义，其他的就是值语义了。","user_name":"作者回复","comment_id":226608,"uid":"1645639","ip_address":"","utype":1,"ctime":1592180600,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"18772020008","product_id":100040501,"comment_content":"老师好，关于值语义和引用语义可以分别举几个例子么？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498301,"discussion_content":"所有的指针、引用变量（以 &amp;amp;、* 结尾的）都算引用语义，其他的就是值语义了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592180600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207081,"user_name":"陈嘉伟","can_delete":false,"product_type":"c1","uid":1967541,"ip_address":"","ucode":"E4C3CBC101ACBE","user_header":"","comment_is_top":false,"comment_ctime":1587003735,"is_pvip":false,"replies":[{"id":"77528","content":"空值是个单一数值，编译器会产生检查的代码，简单得很。编译器可没有简单方法来帮你检查你删除的指针是否是之前已经删除的。<br><br>反过来，删除指针后立即清空可以部分防止这种问题，虽然这种用法在C++里的必要性要低一点。我们推荐**不**使用裸指针，尽量用高层抽象来帮我们自动解决这些问题。","user_name":"作者回复","comment_id":207081,"uid":"1645639","ip_address":"","utype":1,"ctime":1587119864,"user_name_real":"吴咏炜"}],"discussion_count":3,"race_medal":0,"score":"18766872919","product_id":100040501,"comment_content":"请教一个问题，既然delete空指针是合法的，那多次delete同一个指针为什么会报错呢？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492003,"discussion_content":"空值是个单一数值，编译器会产生检查的代码，简单得很。编译器可没有简单方法来帮你检查你删除的指针是否是之前已经删除的。\n\n反过来，删除指针后立即清空可以部分防止这种问题，虽然这种用法在C++里的必要性要低一点。我们推荐**不**使用裸指针，尽量用高层抽象来帮我们自动解决这些问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587119864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001222,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/06/895a122b.jpg","nickname":"ghost","note":"","ucode":"1D5A11D65B82F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285004,"discussion_content":"如果重复delete一个指针，正好这个指针所指的内存没有被占用，那是不是程序就不会出现问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592711426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1664917,"avatar":"https://static001.geekbang.org/account/avatar/00/19/67/95/49e7d8fa.jpg","nickname":"勇攀高峰","note":"","ucode":"4DC9AD387A042C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255061,"discussion_content":"指针代表内存地址，你再次删除时，指向的可能是另外一个数据，不可预知的结果发生。#空悬的野指针#","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588356042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157046,"user_name":"xm2018","can_delete":false,"product_type":"c1","uid":1153105,"ip_address":"","ucode":"570A41E62C46A8","user_header":"https://static001.geekbang.org/account/avatar/00/11/98/51/27c46724.jpg","comment_is_top":false,"comment_ctime":1575018081,"is_pvip":false,"replies":[{"id":"60275","content":"一般不这么看。异常安全性对系统有很多约定，违反了约定，通常 terminate 会被调用。这种情况下就是不做清理工作的。<br><br>在Windows上，你甚至可以用 catch(...) 捕获指针越界访问（需要 &#47;EHa 编译参数），但前提条件一样是你需要去 catch。<br><br>从另一个角度，程序崩溃时，大部分资源都会被操作系统回收，不会对系统造成问题。我们说泄漏，关注的主要是程序（长时间）运行过程中应该释放而没有释放掉的东西，如内存、文件句柄、锁等等。","user_name":"作者回复","comment_id":157046,"uid":"1645639","ip_address":"","utype":1,"ctime":1575031939,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"18754887265","product_id":100040501,"comment_content":"关于演示栈展开的那段程序，如果main函数里面不try catch的话，第二个foo(42) obj的析构函数不会被调用，程序非法退出。这种情况算不算泄漏?","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476314,"discussion_content":"一般不这么看。异常安全性对系统有很多约定，违反了约定，通常 terminate 会被调用。这种情况下就是不做清理工作的。\n\n在Windows上，你甚至可以用 catch(...) 捕获指针越界访问（需要 /EHa 编译参数），但前提条件一样是你需要去 catch。\n\n从另一个角度，程序崩溃时，大部分资源都会被操作系统回收，不会对系统造成问题。我们说泄漏，关注的主要是程序（长时间）运行过程中应该释放而没有释放掉的东西，如内存、文件句柄、锁等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575031939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212270,"user_name":"Interesting","can_delete":false,"product_type":"c1","uid":1666691,"ip_address":"","ucode":"5795B2D14BD37D","user_header":"https://static001.geekbang.org/account/avatar/00/19/6e/83/f429164e.jpg","comment_is_top":false,"comment_ctime":1588082178,"is_pvip":false,"replies":[{"id":"78973","content":"是的。<br><br>另外，对象内部可能额外申请堆内存，并在对象析构时自动释放。容器对象基本都会这么做。从实际的角度，真正的应用代码里完全可以没有new和delete（底层库代码一般仍然会需要）。","user_name":"作者回复","comment_id":212270,"uid":"1645639","ip_address":"","utype":1,"ctime":1588157225,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"14472984066","product_id":100040501,"comment_content":"C++是只有使用new关键字出来的对象才分配到堆上吗？<br>Obj obj();<br>Obj obj* = new Obj();<br>只有后者是在堆上吗？ 堆栈的却别就是 栈的销毁是随着局部变量失效和函数调用完自动销毁  而 堆是需要申请和手动销毁吗？<br>抱歉从别的语言转过来的可能表述不是很准确 ","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493467,"discussion_content":"是的。\n\n另外，对象内部可能额外申请堆内存，并在对象析构时自动释放。容器对象基本都会这么做。从实际的角度，真正的应用代码里完全可以没有new和delete（底层库代码一般仍然会需要）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588157225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160448,"user_name":"Anita","can_delete":false,"product_type":"c1","uid":1640077,"ip_address":"","ucode":"0D4BE5C64479B9","user_header":"https://static001.geekbang.org/account/avatar/00/19/06/8d/704e2596.jpg","comment_is_top":false,"comment_ctime":1575952863,"is_pvip":false,"replies":[{"id":"61239","content":"这么说吧，Java里的一个对象变量相当于C++的指针变量，. 相当于 C++ 的 -&gt;。其他就再多读两遍体会一下吧。","user_name":"作者回复","comment_id":160448,"uid":"1645639","ip_address":"","utype":1,"ctime":1575957481,"user_name_real":"吴咏炜"}],"discussion_count":1,"race_medal":0,"score":"14460854751","product_id":100040501,"comment_content":"在 C++ 里，所有的变量缺省都是值语义——如果不使用 * 和 &amp; 的话，变量不会像 Java 或 Python 一样引用一个堆上的对象。对于像智能指针这样的类型，你写 ptr-&gt;call() 和 ptr.get()，语法上都是对的，并且 -&gt; 和 . 有着不同的语法作用。而在大部分其他语言里，访问成员只用 .，但在作用上实际等价于 C++ 的 -&gt;。这种值语义和引用语义的区别，是 C++ 的特点，也是它的复杂性的一个来源。要用好 C++，就需要理解它的值语义的特点。<br><br>这段有些不理解，老师能再解释一下吗？谢谢","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477378,"discussion_content":"这么说吧，Java里的一个对象变量相当于C++的指针变量，. 相当于 C++ 的 -&amp;gt;。其他就再多读两遍体会一下吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575957481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159677,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1575726125,"is_pvip":false,"replies":[{"id":"61021","content":"嗯，有点道理。但需要学习能力很强，因为我假设你是懂C++的基本语法的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575779053,"ip_address":"","comment_id":159677,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14460628013","product_id":100040501,"comment_content":"老师反复提到，没有学过、用过c++的人不适合学；我的观点稍微有点不同：计算机基础知识扎实，熟悉Java和c，这门课还是蛮适合的。<br><br>计算机基础知识深厚，深入理解堆和栈的区别，知道什么时候用堆内存，什么时候用栈内存，那么，剩下的就是语法了。 ","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477141,"discussion_content":"嗯，有点道理。但需要学习能力很强，因为我假设你是懂C++的基本语法的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575779053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75787,"discussion_content":"谢谢🙏老师点评","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575779131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267154,"user_name":"怎么追摩羯座","can_delete":false,"product_type":"c1","uid":2005457,"ip_address":"","ucode":"C3A72F52FA125C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/99/d1/88127ae2.jpg","comment_is_top":false,"comment_ctime":1607610486,"is_pvip":false,"replies":[{"id":"97137","content":"RAII，不是RALL。<br><br>RAII是一种惯用法，把资源的有效期跟持有资源的对象的生命周期绑定到一起。它靠构造函数来完成资源的分配，并利用析构函数来完成资源的释放。<br><br>RAII跟析构函数关系非常紧密，但概念上并不等同。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1607785172,"ip_address":"","comment_id":267154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10197545078","product_id":100040501,"comment_content":"RALL可以理解为是析构函数吗","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511528,"discussion_content":"RAII，不是RALL。\n\nRAII是一种惯用法，把资源的有效期跟持有资源的对象的生命周期绑定到一起。它靠构造函数来完成资源的分配，并利用析构函数来完成资源的释放。\n\nRAII跟析构函数关系非常紧密，但概念上并不等同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607785172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158192,"user_name":"流浪在寂寞古城","can_delete":false,"product_type":"c1","uid":1105678,"ip_address":"","ucode":"FE90DCD5DC3A20","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/0e/4e2b06d5.jpg","comment_is_top":false,"comment_ctime":1575344716,"is_pvip":false,"replies":[{"id":"60638","content":"加油！跟Java区别还是很大的，要注意。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575377009,"ip_address":"","comment_id":158192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10165279308","product_id":100040501,"comment_content":"作为一个用c++做过一些项目，但是没有深入学习过c++的我（看到java很亲切呀，哈哈），感觉有些压力，RAII里面的这个语法就没怎么接触过。不过我会坚持看完，认真理解。勉励自己吧。这算一个flag了吧，所有小伙伴一起加油，跟大佬学习。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476662,"discussion_content":"加油！跟Java区别还是很大的，要注意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575377009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157701,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575248639,"is_pvip":false,"replies":[{"id":"60455","content":"在 C++ 里，用 Obj obj; 这种方式定义的对象，在函数里就是栈上分配，在函数外就是静态分配。不会堆上分配。C++ 不是“有些语言”里的后者；Python 属于这类。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575249932,"ip_address":"","comment_id":157701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10165183231","product_id":100040501,"comment_content":"前面讲堆的时候，说到“在堆上分配内存，有些语言可能使用 new 这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字”；后面讲栈的时候，又说到“对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效，只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用”。这里有个疑问，当定义一个类对象时，是从栈还是堆中分配的内存空间","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476502,"discussion_content":"在 C++ 里，用 Obj obj; 这种方式定义的对象，在函数里就是栈上分配，在函数外就是静态分配。不会堆上分配。C++ 不是“有些语言”里的后者；Python 属于这类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575249932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155482,"user_name":"大大","can_delete":false,"product_type":"c1","uid":1340730,"ip_address":"","ucode":"3A3DC9AC382651","user_header":"https://static001.geekbang.org/account/avatar/00/14/75/3a/a7596c06.jpg","comment_is_top":false,"comment_ctime":1574692056,"is_pvip":false,"replies":[{"id":"59661","content":"Go也有它的优点。写网络应用Go还是不错的。好的语言多了，也是C++用得少了些的原因。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574692945,"ip_address":"","comment_id":155482,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10164626648","product_id":100040501,"comment_content":"虽然现在写go了，但是相信以后还会用到c++。c++,近两年确实受到很大的冲击。云原生很不容易有个envoy，但是由于c++的复杂性，导致项目没有那么活跃。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475768,"discussion_content":"Go也有它的优点。写网络应用Go还是不错的。好的语言多了，也是C++用得少了些的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574692945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1340730,"avatar":"https://static001.geekbang.org/account/avatar/00/14/75/3a/a7596c06.jpg","nickname":"大大","note":"","ucode":"3A3DC9AC382651","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59736,"discussion_content":"老师，我C++14  17都还没看过，不知道跟下来会不会很吃力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1340730,"avatar":"https://static001.geekbang.org/account/avatar/00/14/75/3a/a7596c06.jpg","nickname":"大大","note":"","ucode":"3A3DC9AC382651","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61781,"discussion_content":"11 看过？那很好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574783440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":59736,"ip_address":""},"score":61781,"extra":""}]}]},{"had_liked":false,"id":359563,"user_name":"DDRH","can_delete":false,"product_type":"c1","uid":3044278,"ip_address":"广东","ucode":"047BF2A1D1A27A","user_header":"https://static001.geekbang.org/account/avatar/00/2e/73/b6/73f85077.jpg","comment_is_top":false,"comment_ctime":1665646738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5960614034","product_id":100040501,"comment_content":"思考：<br>没有引用计数、没有考虑线程安全、没有自定义拷贝和移动、没有重载*和-&gt;运算符、没有release和reset资源主动释放和重置操作等","like_count":1},{"had_liked":false,"id":344755,"user_name":"小骆驼🐪","can_delete":false,"product_type":"c1","uid":1782139,"ip_address":"","ucode":"C62F685903F2F0","user_header":"https://static001.geekbang.org/account/avatar/00/1b/31/7b/5914f8eb.jpg","comment_is_top":false,"comment_ctime":1651751775,"is_pvip":false,"replies":[{"id":"125911","content":"你这个回答混合了两个不同的东西。前三个是代码二进制文件里的分段，后两个是内存区域。这倒不能说是C专有的。<br><br>从内存的角度，变量可以放在全局静态区域、线程本地存储区域和栈上。变量本身不会在堆（自由存储区域）上，但变量可以指向堆上的对象。这就是四种不同的内存区域了。在大部分系统上，代码是需要加载到内存来执行的，所以代码区域也是一种内存区域。","user_name":"作者回复","user_name_real":"作者","uid":"1645639","ctime":1651933212,"ip_address":"","comment_id":344755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5946719071","product_id":100040501,"comment_content":"今天面试被问到，变量存储在哪些区域，以及c++内存区域。我回答内存区域有text,bss,data,堆，栈(这好像是c的划分)🤦","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570833,"discussion_content":"你这个回答混合了两个不同的东西。前三个是代码二进制文件里的分段，后两个是内存区域。这倒不能说是C专有的。\n\n从内存的角度，变量可以放在全局静态区域、线程本地存储区域和栈上。变量本身不会在堆（自由存储区域）上，但变量可以指向堆上的对象。这就是四种不同的内存区域了。在大部分系统上，代码是需要加载到内存来执行的，所以代码区域也是一种内存区域。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651933212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329611,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1658014,"ip_address":"","ucode":"BAAA75EE713CA6","user_header":"https://static001.geekbang.org/account/avatar/00/19/4c/9e/908c04fe.jpg","comment_is_top":false,"comment_ctime":1641445511,"is_pvip":false,"replies":[{"id":"120139","content":"嗯。RAII太重要了，一定要一开始就讲。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1641551363,"ip_address":"","comment_id":329611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936412807","product_id":100040501,"comment_content":"工作几年后，觉得有必要学习C++，就开始找各种资料开始自学。到现在只是自己做过一些小项目，对于C++始终感觉理解不够。特别是内存管理，喜欢指针的灵活。又总是很害怕遇到各种bug。原来还有RAII这么好的方式，看来之前智能指针完全没有get到要点。看到这里，有一种终于找到组织了的感觉。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544534,"discussion_content":"嗯。RAII太重要了，一定要一开始就讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641551363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300226,"user_name":"peter","can_delete":false,"product_type":"c1","uid":2654135,"ip_address":"","ucode":"C3500F334D2996","user_header":"https://static001.geekbang.org/account/avatar/00/28/7f/b7/68977ad8.jpg","comment_is_top":false,"comment_ctime":1625054588,"is_pvip":false,"replies":[{"id":"108842","content":"正好刚在知乎上写了个回答，可以看看：<br><br>https:&#47;&#47;www.zhihu.com&#47;question&#47;468514838&#47;answer&#47;1967696567","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1625098108,"ip_address":"","comment_id":300226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5920021884","product_id":100040501,"comment_content":"想问一下static_cast这一类的类型转换到底有什么好处呢？平时开发的时候并不太习惯用这种方式，感觉直接指针强转就可以，两者没什么实质的区别，反正能就是能，不能就是不能，static_cast只是好看一些，如果出问题的话让你死的体面点。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522683,"discussion_content":"正好刚在知乎上写了个回答，可以看看：\n\nhttps://www.zhihu.com/question/468514838/answer/1967696567","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625098108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268803,"user_name":"西二旗老实人","can_delete":false,"product_type":"c1","uid":1221340,"ip_address":"","ucode":"9200589B422CDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/dc/cd53031f.jpg","comment_is_top":false,"comment_ctime":1608355200,"is_pvip":false,"replies":[{"id":"97583","content":"人外有人，天外有天。强中自有强中手。学完了自然会看到一个更新更强的世界。<br><br>提醒一下，你现在还只在第一讲呢……后面有更难得多的内容。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1608509412,"ip_address":"","comment_id":268803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903322496","product_id":100040501,"comment_content":"老师你的水平好高啊，看完这些感觉自己变强了很多","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512044,"discussion_content":"人外有人，天外有天。强中自有强中手。学完了自然会看到一个更新更强的世界。\n\n提醒一下，你现在还只在第一讲呢……后面有更难得多的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608509412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217878,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1512432,"ip_address":"","ucode":"0665F3AD23890F","user_header":"https://static001.geekbang.org/account/avatar/00/17/13/f0/ce1a26be.jpg","comment_is_top":false,"comment_ctime":1589636568,"is_pvip":false,"replies":[{"id":"80756","content":"说栈大小固定还是不太对。现代系统上，栈有个最大大小（因为栈一般要求是连续的），但操作系统不会一次性分配所有的内存。栈的内存占用可以在使用中增长。<br><br>这个因为所以也不对吧。栈大小是否固定跟增长方向没有因果关系。大部分平台上栈向低地址增长，但也不是所有。这事实上只是历史限制造成的实现细节。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1589801884,"ip_address":"","comment_id":217878,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884603864","product_id":100040501,"comment_content":"每一个线程的栈空间大小是固定的, 所以增长方向是 往低地址空间, 直达耗尽.","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495280,"discussion_content":"说栈大小固定还是不太对。现代系统上，栈有个最大大小（因为栈一般要求是连续的），但操作系统不会一次性分配所有的内存。栈的内存占用可以在使用中增长。\n\n这个因为所以也不对吧。栈大小是否固定跟增长方向没有因果关系。大部分平台上栈向低地址增长，但也不是所有。这事实上只是历史限制造成的实现细节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589801884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186823,"user_name":"宋强","can_delete":false,"product_type":"c1","uid":1564605,"ip_address":"","ucode":"119A0B00ABDA7B","user_header":"","comment_is_top":false,"comment_ctime":1583934426,"is_pvip":false,"replies":[{"id":"72122","content":"对，大部分情况是这样的。<br><br>还有些不完全是这样的情况，但原则依然是相通的：<br><br>for (int i = 0; i &lt; 10; i++) {<br>  &#47;&#47; i 在块内有效<br>}<br><br>以及（C++17）：<br><br>if (FILE* fp = fopen(…); fp != nullptr) {<br>  &#47;&#47; fp 在此有效<br>} else {<br>  &#47;&#47; fp 在此也有效<br>}<br>&#47;&#47; fp 在此已失效","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1583981375,"ip_address":"","comment_id":186823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878901722","product_id":100040501,"comment_content":"请问老师，局部变量的作用域是{}界定的吗？比如我想使用std::lock_guard对函数体内部分的程序块加锁，是这样吗？<br>func A() {<br>  {<br>  std::lock_guard<br>  ...<br>  }<br>...<br>}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486885,"discussion_content":"对，大部分情况是这样的。\n\n还有些不完全是这样的情况，但原则依然是相通的：\n\nfor (int i = 0; i &amp;lt; 10; i++) {\n  // i 在块内有效\n}\n\n以及（C++17）：\n\nif (FILE* fp = fopen(…); fp != nullptr) {\n  // fp 在此有效\n} else {\n  // fp 在此也有效\n}\n// fp 在此已失效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583981375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174748,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1580369170,"is_pvip":false,"replies":[{"id":"67937","content":"嗯，写“返回值类型是基类（的指针或引用）”会更清楚点。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1580397764,"ip_address":"","comment_id":174748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5875336466","product_id":100040501,"comment_content":"“常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类”<br>这句话的意思应该是：“返回值类型是基类指针”吧","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482509,"discussion_content":"嗯，写“返回值类型是基类（的指针或引用）”会更清楚点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580397764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171078,"user_name":"Puck","can_delete":false,"product_type":"c1","uid":1298144,"ip_address":"","ucode":"B156FAEC056E37","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/e0/af675567.jpg","comment_is_top":false,"comment_ctime":1578840663,"is_pvip":false,"replies":[{"id":"66360","content":"看对象多大了。如果对象很大（大数组吗？），那可以把它放堆上；或把里面的大成员放堆上，把对象做成 RAII 管理对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578880412,"ip_address":"","comment_id":171078,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5873807959","product_id":100040501,"comment_content":"初学C++时，也喜欢尽量使用栈对象，但后来知道还有“爆栈”一说。为了避免爆栈，开始大量使用智能指针写代码。即“对象一般使用堆内存”。<br>且当指针作为类数据成员时，多了一种空指针表示未配置该项的作用，故亦多有使用。如接口 setA(const A&amp;)，exec()(调用前必须已经setA)，在其数据成员实现上，我就喜欢用智能指针去hold一个A对象而不是直接的A对象。这点不知道大家是怎么做的","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481233,"discussion_content":"看对象多大了。如果对象很大（大数组吗？），那可以把它放堆上；或把里面的大成员放堆上，把对象做成 RAII 管理对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578880412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6e/7d/0485232b.jpg","nickname":"瓜农","note":"","ucode":"CF6B8E5B74BCA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574237,"discussion_content":"所以老师还是建议尽量在栈上分配对象？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653918535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165872,"user_name":"Sochooligan","can_delete":false,"product_type":"c1","uid":1318528,"ip_address":"","ucode":"B66F78B6B86476","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","comment_is_top":false,"comment_ctime":1577337138,"is_pvip":false,"replies":[{"id":"63268","content":"我那是示意，构造是不允许这样调用的。<br><br>析构的语法则可用，但你这个错误似乎是没把 ptr 当成参数传进去。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577355837,"ip_address":"","comment_id":165872,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5872304434","product_id":100040501,"comment_content":"请教老师两个问题。<br>我的环境是macOS+eclipse+gcc9.2：<br>编译选项是：-std=c++17<br>问题1：ptr-&gt;circle(); 报 invalid use of &quot;circle::circle&quot;<br>问题2：后面catch (…)里的 operator delete(ptr)报 &#39;ptr&#39; was not declared in this scope<br>说明：我是把那段代码放到一个函数中了。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479299,"discussion_content":"我那是示意，构造是不允许这样调用的。\n\n析构的语法则可用，但你这个错误似乎是没把 ptr 当成参数传进去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577355837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318528,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","nickname":"Sochooligan","note":"","ucode":"B66F78B6B86476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102634,"discussion_content":"谢谢！我再试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577357738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161415,"user_name":"执假以为真","can_delete":false,"product_type":"c1","uid":1145738,"ip_address":"","ucode":"A02D82C5CCDA07","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/8a/c411a123.jpg","comment_is_top":false,"comment_ctime":1576202913,"is_pvip":false,"replies":[{"id":"61553","content":"没有。大部分的开发不会遇到自己要写内存管理器的情况。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576275300,"ip_address":"","comment_id":161415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871170209","product_id":100040501,"comment_content":"会不会讲内存管理器呢，不是内核中的内存管理，是库级别的。好像Google自己做了一个","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477712,"discussion_content":"没有。大部分的开发不会遇到自己要写内存管理器的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576275300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161056,"user_name":"Sochooligan","can_delete":false,"product_type":"c1","uid":1318528,"ip_address":"","ucode":"B66F78B6B86476","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","comment_is_top":false,"comment_ctime":1576110790,"is_pvip":false,"replies":[{"id":"61455","content":"1. 恰恰相反，大部分语言里都有像指针的东西，只是不叫指针，不能随意转换和做加减法，也就不那么危险。很多语言都没有值语义——传递对象，而不是对象的指针&#47;引用。<br><br>2. 得到一个指针，当然是引用语义。<br><br>3. 不是完整表达式，问题没有意义。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1576140651,"ip_address":"","comment_id":161056,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5871078086","product_id":100040501,"comment_content":"请课堂疑问：<br>1. “值语义”这个概念是想说明，C++有指针，很多其他语言没有？<br>2. ptr.get() 是什么语义？<br>3. ptr-&gt;是什么语义？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477588,"discussion_content":"1. 恰恰相反，大部分语言里都有像指针的东西，只是不叫指针，不能随意转换和做加减法，也就不那么危险。很多语言都没有值语义——传递对象，而不是对象的指针/引用。\n\n2. 得到一个指针，当然是引用语义。\n\n3. 不是完整表达式，问题没有意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576140651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318528,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","nickname":"Sochooligan","note":"","ucode":"B66F78B6B86476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80119,"discussion_content":"搜索了一下，简单说理解：1. 值语义是指根据原物再复制出一个，共有两个，互相不影响。是两片内存区域。2. 引用语义是指两者引用的是同一个东西。同一片内存区域。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576148553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318528,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","nickname":"Sochooligan","note":"","ucode":"B66F78B6B86476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80058,"discussion_content":"谢谢！我体会一下。 2. 的表达式获取对象的指针，所以是一个引用语义? 问题3. 换成ptr->call(), 表示是什么意思呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576142476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158808,"user_name":"陈英桂","can_delete":false,"product_type":"c1","uid":1100348,"ip_address":"","ucode":"06E8DEE42DA82E","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/3c/f6e7ebf1.jpg","comment_is_top":false,"comment_ctime":1575455766,"is_pvip":false,"replies":[{"id":"60755","content":"是问题之一。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575464023,"ip_address":"","comment_id":158808,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870423062","product_id":100040501,"comment_content":"类成员函数中缺少了拷贝构造函数、赋值操作符重载。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476855,"discussion_content":"是问题之一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157972,"user_name":"浑浑噩噩cium","can_delete":false,"product_type":"c1","uid":1617939,"ip_address":"","ucode":"358C0BCFF62B40","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","comment_is_top":false,"comment_ctime":1575291594,"is_pvip":false,"replies":[{"id":"60533","content":"「std::terminate() 为 C++ 运行时在异常处理因下列原因失败时调用：<br>1) 抛出的异常未被捕捉（此情况下是否进行任何栈回溯是实现定义的）<br>…」<br><br>https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;error&#47;terminate","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575295890,"ip_address":"","comment_id":157972,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5870258890","product_id":100040501,"comment_content":"<br>void foo(int n)<br>{<br>  Obj obj;<br>  if (n == 42)<br>    throw &quot;life, the universe and everything&quot;;<br>}<br>变量释放，析构函数调用是函数返回的时候调用的。<br>我测试了下如果没有捕获异常的话第二个obj的析构函数没有被调用程序结束，说明:<br>1.析构是在foo函数返回的时候调用的<br>2.抛异常的函数没有返回，不会自动释放变量<br>3.如果捕获了异常，就在catch里面释放异常函数foo里面的变量。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476601,"discussion_content":"「std::terminate() 为 C++ 运行时在异常处理因下列原因失败时调用：\n1) 抛出的异常未被捕捉（此情况下是否进行任何栈回溯是实现定义的）\n…」\n\nhttps://zh.cppreference.com/w/cpp/error/terminate","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575295890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547048,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9b/28/9d89de4d.jpg","nickname":"暒","note":"","ucode":"9C956F418C66BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85540,"discussion_content":"我没有看懂作者大大的回答是什么意思。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576553190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1617939,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","nickname":"浑浑噩噩cium","note":"","ucode":"358C0BCFF62B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1547048,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9b/28/9d89de4d.jpg","nickname":"暒","note":"","ucode":"9C956F418C66BB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85967,"discussion_content":"意思是异常捕获处理在terminate里面实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576584870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85540,"ip_address":""},"score":85967,"extra":""},{"author":{"id":1010819,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","nickname":"Luke","note":"","ucode":"8368A63185356D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1617939,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","nickname":"浑浑噩噩cium","note":"","ucode":"358C0BCFF62B40","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300595,"discussion_content":"在你测试时，terminate()在异常未被捕捉时被调用，程序结束，第二个obj的析构函数没有被调用。这里obj析构是否会被调用，根据编译器的实现会有所不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598186889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85967,"ip_address":""},"score":300595,"extra":""}]}]},{"had_liked":false,"id":156468,"user_name":"嵇斌","can_delete":false,"product_type":"c1","uid":1047812,"ip_address":"","ucode":"C9422C3F8A7B23","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/04/89cc31ab.jpg","comment_is_top":false,"comment_ctime":1574898858,"is_pvip":false,"replies":[{"id":"60075","content":"😄","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574900077,"ip_address":"","comment_id":156468,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869866154","product_id":100040501,"comment_content":"「如果你好奇 delete 空指针会发生什么的话，那答案是，这是一个合法的空操作。」如然想起了JavaScript里的delete 0；原来编程语言真的是相通的...","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476122,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574900077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352928,"user_name":"拓荒","can_delete":false,"product_type":"c1","uid":2638789,"ip_address":"广东","ucode":"A55075A0B8486F","user_header":"https://static001.geekbang.org/account/avatar/00/28/43/c5/2b53972b.jpg","comment_is_top":false,"comment_ctime":1659019637,"is_pvip":false,"replies":[{"id":"128418","content":"从进程内的角度，没有人释放它。从操作系统的角度，进程结束时，进程相关的资源，包括内存、文件等，都会被操作系统回收。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1659312178,"ip_address":"广东","comment_id":352928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659019637","product_id":100040501,"comment_content":"如果用new申请了一段动态内存，但是在程序中没有用delete进行释放，那么当程序执行结束时，这段动态内存是否会被释放呢？如果会的话，是由谁释放的呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582196,"discussion_content":"从进程内的角度，没有人释放它。从操作系统的角度，进程结束时，进程相关的资源，包括内存、文件等，都会被操作系统回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659312178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347232,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1653831512,"is_pvip":false,"replies":[{"id":"126753","content":"嗯，是这样。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1654312115,"ip_address":"","comment_id":347232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653831512","product_id":100040501,"comment_content":"“本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了”----更准确的说，不是在函数执行完吧，是在这个变量生命周期终结？ ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574745,"discussion_content":"嗯，是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654312115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344248,"user_name":"newzai","can_delete":false,"product_type":"c1","uid":1102367,"ip_address":"","ucode":"D5E34D427D65FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/1f/2ef2514b.jpg","comment_is_top":false,"comment_ctime":1651395446,"is_pvip":false,"replies":[{"id":"125693","content":"单纯内存分配失败倒不是一种常见的需要 catch 的场合，因为它通常发生得最早，一旦失败直接往外抛就行了——最外层有个地方捕捉就够。对于一般写代码，需要 catch 的通常是当有多个地方可能失败：比如，先分配内存，再调用构造函数。这样，我们就需要在第二步（构造函数）失败时去释放内存……如果第一步就失败，至少当前函数里就可能不需要处理了。","user_name":"作者回复","user_name_real":"作者","uid":"1645639","ctime":1651470763,"ip_address":"","comment_id":344248,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1651395446","product_id":100040501,"comment_content":"内存分配失败这种try的代码真恶心。。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569531,"discussion_content":"单纯内存分配失败倒不是一种常见的需要 catch 的场合，因为它通常发生得最早，一旦失败直接往外抛就行了——最外层有个地方捕捉就够。对于一般写代码，需要 catch 的通常是当有多个地方可能失败：比如，先分配内存，再调用构造函数。这样，我们就需要在第二步（构造函数）失败时去释放内存……如果第一步就失败，至少当前函数里就可能不需要处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651470764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344123,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1651286417,"is_pvip":true,"replies":[{"id":"125692","content":"如果是“终止运行”的情况的话，析构函数倒不一定会被调用了。如果有地方 catch 了的话，那析构函数调用就一定会发生（除非析构函数中又抛了异常）。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1651470568,"ip_address":"","comment_id":344123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651286417","product_id":100040501,"comment_content":"函数抛出异常而提前终止运行，在此之前只要有对象被创建，这些对象的析构函数都会被调用。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569530,"discussion_content":"如果是“终止运行”的情况的话，析构函数倒不一定会被调用了。如果有地方 catch 了的话，那析构函数调用就一定会发生（除非析构函数中又抛了异常）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651470568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342794,"user_name":"Amos","can_delete":false,"product_type":"c1","uid":2154175,"ip_address":"","ucode":"185CDBBCB4D70E","user_header":"https://static001.geekbang.org/account/avatar/00/20/de/bf/259d4570.jpg","comment_is_top":false,"comment_ctime":1650464617,"is_pvip":false,"replies":[{"id":"125260","content":"入栈返回地址是 call 指令做的事情。显然，你不可能先 call 再传参数。<br><br>纯理论探讨，反过来也是可能的，但那就不是 x86 指令集的做法了。","user_name":"作者回复","user_name_real":"作者","uid":"1645639","ctime":1650547606,"ip_address":"","comment_id":342794,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650464617","product_id":100040501,"comment_content":"老师您好，我想请教一下：为什么被调函数入栈的时候，先入栈被调函数的参数，再入栈返回地址？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565828,"discussion_content":"入栈返回地址是 call 指令做的事情。显然，你不可能先 call 再传参数。\n\n纯理论探讨，反过来也是可能的，但那就不是 x86 指令集的做法了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650547607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326864,"user_name":"haha","can_delete":false,"product_type":"c1","uid":2623098,"ip_address":"","ucode":"E8F99449B78882","user_header":"https://static001.geekbang.org/account/avatar/00/28/06/7a/9a60b72f.jpg","comment_is_top":false,"comment_ctime":1639725599,"is_pvip":false,"replies":[{"id":"118851","content":"字符串在 C++ 里是常量，不能跟 char* 匹配成功。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1639843949,"ip_address":"","comment_id":326864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639725599","product_id":100040501,"comment_content":"<br>#include &lt;stdio.h&gt;<br><br>class Obj {<br>public:<br>  Obj() { puts(&quot;Obj()&quot;); }<br>  ~Obj() { puts(&quot;~Obj()&quot;); }<br>};<br><br>void foo(int n)<br>{<br>  Obj obj;<br>  if (n == 42)<br>    throw &quot;life, the universe and everything&quot;;<br>}<br><br>int main()<br>{<br>  try {<br>    foo(41);<br>    foo(42);<br>  }<br>  catch (const char* s) {<br>    puts(s);<br>  }<br>}<br>在测试中catch(const char* s) 输入成了catch(char* s)，可以编译成功，但执行时析构函数没有被调用，是为什么？<br>输出如下：<br>Obj()<br>~Obj()<br>Obj()<br>terminate called after throwing an instance of  &#39;char const*&#39;<br>zsh: abort        .&#47;exam1<br><br>改为const char*，可以正常执行析构函数。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539809,"discussion_content":"字符串在 C++ 里是常量，不能跟 char* 匹配成功。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639843949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326811,"user_name":"🐾mc🐾","can_delete":false,"product_type":"c1","uid":1030759,"ip_address":"","ucode":"CE47F9316D6E14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/67/c764be06.jpg","comment_is_top":false,"comment_ctime":1639707649,"is_pvip":false,"replies":[{"id":"118850","content":"没有错。再读一下。意思是new和delete在不同的地方很容易出差错。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1639843827,"ip_address":"","comment_id":326811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639707649","product_id":100040501,"comment_content":"这样的话，会漏 delete 的可能性是不是大多了  ---&gt;  这样的话，会漏 delete 的可能性是不是小多了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539808,"discussion_content":"没有错。再读一下。意思是new和delete在不同的地方很容易出差错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639843827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323528,"user_name":"zhmacn","can_delete":false,"product_type":"c1","uid":2561868,"ip_address":"","ucode":"91FA8535808CA0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJrZ9ic5vHOVfzqcA3Y454gicI2z7L1Ujp5hzFr9CbfTu6goHE7fUlbl3QjpEvXJj5qlvRAVcGRomw/132","comment_is_top":false,"comment_ctime":1637966448,"is_pvip":false,"replies":[{"id":"117537","content":"确实是哦。谢谢。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1638231735,"ip_address":"","comment_id":323528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637966448","product_id":100040501,"comment_content":"java的list代码是不是写错了ArrayList&lt;Integer&gt;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534557,"discussion_content":"确实是哦。谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638231735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318391,"user_name":"严海波","can_delete":false,"product_type":"c1","uid":1264573,"ip_address":"","ucode":"8D4E230FD95383","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/bd/fe8c68b3.jpg","comment_is_top":false,"comment_ctime":1635274046,"is_pvip":true,"replies":[{"id":"115670","content":"这不是我这个现代C++专栏的主题。抱歉了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1635606610,"ip_address":"","comment_id":318391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635274046","product_id":100040501,"comment_content":"你在这里应该追加解释一下glibc中alloc的实现，每一块分配的堆对象都有一个指针长度在堆对象的前面，一些黑客会利用修改这个长度做一些攻击。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529221,"discussion_content":"这不是我这个现代C++专栏的主题。抱歉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635606610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308396,"user_name":"树天先森","can_delete":false,"product_type":"c1","uid":2739991,"ip_address":"","ucode":"29334054D991CE","user_header":"https://static001.geekbang.org/account/avatar/00/29/cf/17/f6eacf3f.jpg","comment_is_top":false,"comment_ctime":1629599516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629599516","product_id":100040501,"comment_content":"第二次看才看懂，写得真好！","like_count":0},{"had_liked":false,"id":304411,"user_name":"Mari","can_delete":false,"product_type":"c1","uid":2271867,"ip_address":"","ucode":"5260C80C8B6AD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/E73UicmpgFiaZW4SOTGaxoIk9PWue54neNcfsicz7HOxJUucep4jSMyeMMruLNcIlxsE330qOFMacaEQ9Vz4zXJyg/132","comment_is_top":false,"comment_ctime":1627393688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627393688","product_id":100040501,"comment_content":"shape_wrapper 和智能指针比起来，还缺了哪些功能？<br>1,  使用模版实现 operator -&gt;  操作符<br>&lt;typelate T&gt;<br>T *operator-&gt;(){<br>    return ptr_；<br>}","like_count":0},{"had_liked":false,"id":298918,"user_name":"Geek_e7c5f3","can_delete":false,"product_type":"c1","uid":2122979,"ip_address":"","ucode":"C1CBCC3655F465","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/YrTewgZu6SicWJkepbTSuhVHfBBCyEkc0VH6TOVnaCtpp7FxMdN98j6D42TLiaYjsZBiaic2GLr32JE00Tlibap95aw/132","comment_is_top":false,"comment_ctime":1624373123,"is_pvip":false,"replies":[{"id":"108454","content":"对于桌面开发，这是一种可行的策略。因为虚拟内存会导致绝大部分内存分配都会成功，即使内存已经不足。<br><br>异常捕获一般也不在new的现场，这样就失去异常的优势了。异常捕获一般是在一个集中的地方统一处理。<br><br>另外，手工new和delete是不推荐的。在同一个函数里new和delete更是通常可以被栈上自动对象所取代。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1624439504,"ip_address":"","comment_id":298918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624373123","product_id":100040501,"comment_content":"以前接触过有经验的c++程序员(老师傅，10几年c++开发经验的)，很多都是直接new，然后用完就delete，并不会去在new中进行try异常捕获；我猜，他们觉得都new失败整个系统就存在问题了吧！这个原因我也是猜测一下，所以想请教一下老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522276,"discussion_content":"对于桌面开发，这是一种可行的策略。因为虚拟内存会导致绝大部分内存分配都会成功，即使内存已经不足。\n\n异常捕获一般也不在new的现场，这样就失去异常的优势了。异常捕获一般是在一个集中的地方统一处理。\n\n另外，手工new和delete是不推荐的。在同一个函数里new和delete更是通常可以被栈上自动对象所取代。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624439504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296716,"user_name":"Geek_dddde9","can_delete":false,"product_type":"c1","uid":2652522,"ip_address":"","ucode":"D14EF94033662A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIowerMFjqhnvMUkicDpc8jKfia2sUJgUcR1ceicqoNANib79D8e5pHv2fRiblXm8zkia4MPmp5k0ByiaUbg/132","comment_is_top":false,"comment_ctime":1623128440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623128440","product_id":100040501,"comment_content":"实际的智能指针应该是个模板把。。不会单独确定存放哪类的指针","like_count":0},{"had_liked":false,"id":287675,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1135701,"ip_address":"","ucode":"734A561F363720","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","comment_is_top":false,"comment_ctime":1618105231,"is_pvip":false,"replies":[{"id":"104515","content":"谢谢😊","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1618186767,"ip_address":"","comment_id":287675,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618105231","product_id":100040501,"comment_content":"这课程很好，周末看您的课程真是一种享受","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518382,"discussion_content":"谢谢😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618186767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285467,"user_name":"Best of me","can_delete":false,"product_type":"c1","uid":2181712,"ip_address":"","ucode":"924F8C506F52CE","user_header":"https://static001.geekbang.org/account/avatar/00/21/4a/50/df3108fd.jpg","comment_is_top":false,"comment_ctime":1616829262,"is_pvip":false,"replies":[{"id":"103606","content":"本地（local）变量具有决定性的生命周期。到了对象定义所在的 }，对象就被析构，所在的内存就被释放。在析构函数里执行的代码，就决定了进一步的复杂生命期管理。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1616852463,"ip_address":"","comment_id":285467,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616829262","product_id":100040501,"comment_content":"没怎么清楚RAII怎样依托栈的。这个函数的调用和压入参数那块儿我懂了他压入栈的顺序以及调用，但这个没看出来类，类里new一个不是在堆上吗？我的理解，在栈里调用，在堆上分配，然后delete，但怎么就是依托栈这个过程不怎么清楚呀老师。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517684,"discussion_content":"本地（local）变量具有决定性的生命周期。到了对象定义所在的 }，对象就被析构，所在的内存就被释放。在析构函数里执行的代码，就决定了进一步的复杂生命期管理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616852463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285464,"user_name":"Best of me","can_delete":false,"product_type":"c1","uid":2181712,"ip_address":"","ucode":"924F8C506F52CE","user_header":"https://static001.geekbang.org/account/avatar/00/21/4a/50/df3108fd.jpg","comment_is_top":false,"comment_ctime":1616828607,"is_pvip":false,"replies":[{"id":"103605","content":"RAII 的核心是可以帮你管理（释放）资源。如果你构造时是 new，析构里就可以是 delete。如果你构造时是 lock，析构里就可以是 unlock。如果构造时是 open，析构里就可以是 close。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1616852360,"ip_address":"","comment_id":285464,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616828607","product_id":100040501,"comment_content":"老师，你看我对RAII理解对不对。我对RAII的理解：就是一个对象内存分配以后再使用完成后保证能够delete成功，将空间回收成功；而且还也可以是：关闭文件（fstream 的析构就会这么做）、释放同步锁、释放其他重要的系统资源。综合上面来看主要就是负责回收空间，这么说对吗？但我还是没怎么感觉到使用RAII的感觉，就是简单的析构函数里delete相应的指针。是我的理解有错吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517682,"discussion_content":"RAII 的核心是可以帮你管理（释放）资源。如果你构造时是 new，析构里就可以是 delete。如果你构造时是 lock，析构里就可以是 unlock。如果构造时是 open，析构里就可以是 close。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616852360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284762,"user_name":"力战者","can_delete":false,"product_type":"c1","uid":2379384,"ip_address":"","ucode":"19C164A6B5035D","user_header":"https://static001.geekbang.org/account/avatar/00/24/4e/78/02bd7123.jpg","comment_is_top":false,"comment_ctime":1616463607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616463607","product_id":100040501,"comment_content":"share智能指针里面有两个累，一个存放指针，一个存放引用计数，缺这两个","like_count":0},{"had_liked":false,"id":273955,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1610765956,"is_pvip":false,"replies":[{"id":"99508","content":"编译器会自动生成在异常抛出时调用析构函数的代码，也许这样说你觉得更严格一点？","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1610885310,"ip_address":"","comment_id":273955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610765956","product_id":100040501,"comment_content":"这里是不是有一些没讲对？编译器会调用析构函数。可是编译器不是只在编译时才起作用吗？但是异常是发生在程序运行时的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513874,"discussion_content":"编译器会自动生成在异常抛出时调用析构函数的代码，也许这样说你觉得更严格一点？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610885310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272302,"user_name":"Geek_af30d1","can_delete":false,"product_type":"c1","uid":2368431,"ip_address":"","ucode":"EA0786A33EC32B","user_header":"","comment_is_top":false,"comment_ctime":1610023593,"is_pvip":false,"replies":[{"id":"98778","content":"说“对象被复制后……”感觉怪怪的。换成“变量”就基本没问题了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1610102333,"ip_address":"","comment_id":272302,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610023593","product_id":100040501,"comment_content":"所谓值语义是一个对象被系统标准的复制方式复制后，与被复制的对象之间毫无关系，可以彼此独立改变互不影响<br><br>指针语义，引用语义：通常是指一个对象被系统标准的复制方式复制后，与被复制的对象之间依然共享底层资源，对任何一个的改变都将改变另一个<br>老师， 这样解释对吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513229,"discussion_content":"说“对象被复制后……”感觉怪怪的。换成“变量”就基本没问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610102333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267794,"user_name":"Geek_af30d1","can_delete":false,"product_type":"c1","uid":2368431,"ip_address":"","ucode":"EA0786A33EC32B","user_header":"","comment_is_top":false,"comment_ctime":1607933728,"is_pvip":false,"replies":[{"id":"97315","content":"与值语义相对的是引用语义，即引用或指针。<br><br>在Python里，所有的变量都是引用语义，指向堆上面的对象。而在C++里，引用的对象可以在堆上，也可以在栈上。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1608028600,"ip_address":"","comment_id":267794,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607933728","product_id":100040501,"comment_content":"值语义：一般值栈上的分配的<br>对象语义：一般值使用 堆上的数据，取他的地址或者引用等<br>这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511746,"discussion_content":"与值语义相对的是引用语义，即引用或指针。\n\n在Python里，所有的变量都是引用语义，指向堆上面的对象。而在C++里，引用的对象可以在堆上，也可以在栈上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608028600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264326,"user_name":"luke","can_delete":false,"product_type":"c1","uid":1057643,"ip_address":"","ucode":"1D26F3F31CC435","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pCVwNYT22UX6XAXJ5XLmbSHRmuPIncaJkS7S6kUKe0C8qWURib8zOhHTPwR36FeZZ4BcnKuDia4nrekqDnAkxdJQ/132","comment_is_top":false,"comment_ctime":1606439809,"is_pvip":false,"replies":[{"id":"95903","content":"用额外的大括号括起 lock_guard 和需要同步的代码。是问这个么？","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1606534310,"ip_address":"","comment_id":264326,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606439809","product_id":100040501,"comment_content":"RAII这种写法如何减少同步段的操作？例如在一个函数里，我只希望lock变量赋值这个语句，而不是整段。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510524,"discussion_content":"用额外的大括号括起 lock_guard 和需要同步的代码。是问这个么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606534310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057643,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/pCVwNYT22UX6XAXJ5XLmbSHRmuPIncaJkS7S6kUKe0C8qWURib8zOhHTPwR36FeZZ4BcnKuDia4nrekqDnAkxdJQ/132","nickname":"luke","note":"","ucode":"1D26F3F31CC435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336327,"discussion_content":"是，合理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608551091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258232,"user_name":"201201594","can_delete":false,"product_type":"c1","uid":2248268,"ip_address":"","ucode":"95E095CD281167","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/iaLkyMR0uWonRrLtV7QwVDeXu13tL1skAwKPJYricxKhDiasickILYVVujHIw6DcZsL4XecxBHQYIA2A9wcfpvxQEw/132","comment_is_top":false,"comment_ctime":1604332274,"is_pvip":false,"replies":[{"id":"94103","content":"对，这是原则。对于简单的你代码中的情况，可以直接使用C++里的智能指针。<br><br>另外，注意拼写，是wrapper。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1604413757,"ip_address":"","comment_id":258232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604332274","product_id":100040501,"comment_content":"void fun() {<br>    A a;<br>}<br>将a对象分配到栈上，当对象的作用域结束以后，会自动调用A类的析构函数释放内存。所以在这里不需要new,也不需要delete。<br><br>但是遇到对象比较大或某些情况，需要将其分配到堆上时，可以将这部分作为一个Warpper类的成员变量，那么只需在Warpper类中做好该成员变量的初始化和析构即可。<br><br>class Warpper {<br>   explicit Warpper() {<br>       a = new A();<br>    }<br>    ~Warpper() {<br>       delete A;<br>    }<br><br>   A* a;<br>}<br><br>如上定义了Warpper类，则在fun中依然可以通过值语义将其分配到栈上，而此时内部成员变量A是分配在堆上的。<br><br>void fun() {<br>    Warpper warpper;<br>}<br><br>所以通过值语义在栈上分配 + 自动调用析构函数 的RAII机制，可以在代码中不出现new delete。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508588,"discussion_content":"对，这是原则。对于简单的你代码中的情况，可以直接使用C++里的智能指针。\n\n另外，注意拼写，是wrapper。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604413757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253387,"user_name":"Lloyd Liu","can_delete":false,"product_type":"c1","uid":1619354,"ip_address":"","ucode":"82DF4CE95ECB74","user_header":"https://static001.geekbang.org/account/avatar/00/18/b5/9a/0161f563.jpg","comment_is_top":false,"comment_ctime":1602725062,"is_pvip":false,"replies":[{"id":"92589","content":"是说代码不在一起，人更容易出错，漏掉相关的 delete 操作，造成内存泄漏。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1602779642,"ip_address":"","comment_id":253387,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602725062","product_id":100040501,"comment_content":"“而更常见、也更合理的情况，是分配和释放不在一个函数里。比如下面这段示例代码：<br><br>这样的话，会漏 delete 的可能性是不是大多了？有关这个问题的解决方法，我们在下一讲还会提到。”<br><br>这里有点不明白，“会漏delete的可能性是不是大多了？”，说明上面的代码是有问题的吗？<br>那“分配和释放不在一个函数里”，是应该做的还是不该做的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507059,"discussion_content":"是说代码不在一起，人更容易出错，漏掉相关的 delete 操作，造成内存泄漏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602779642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245707,"user_name":"whiplash","can_delete":false,"product_type":"c1","uid":2111173,"ip_address":"","ucode":"FE90D0E1D74D9F","user_header":"https://static001.geekbang.org/account/avatar/00/20/36/c5/0940c513.jpg","comment_is_top":false,"comment_ctime":1599031560,"is_pvip":false,"replies":[{"id":"90413","content":"实参一般是函数调用返回之后再由调用者弹出的，不存在你说的问题。<br><br>实际上，有些调用规范也有由被调用函数负责清理栈的。这种情况下，返回时使用 ret 4 这样的汇编指令一样可以。<br><br>这些你自己分析一下编译器产生的汇编代码就明白了。MSVC 用 &#47;Fa 选项，GCC 和 Clang 用 -S 选项。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1599112524,"ip_address":"","comment_id":245707,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599031560","product_id":100040501,"comment_content":"您好，您在讲栈的时候，调用bar函数时，先把bar的实参值入栈，然后把main函数的返回地址入栈。这个地方实在超出我的理解范围。如果bar的实参被main函数的返回地址压住弹不出栈，函数就没办法执行啊。望得到您的回答。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504966,"discussion_content":"实参一般是函数调用返回之后再由调用者弹出的，不存在你说的问题。\n\n实际上，有些调用规范也有由被调用函数负责清理栈的。这种情况下，返回时使用 ret 4 这样的汇编指令一样可以。\n\n这些你自己分析一下编译器产生的汇编代码就明白了。MSVC 用 /Fa 选项，GCC 和 Clang 用 -S 选项。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599112524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241175,"user_name":"::error","can_delete":false,"product_type":"c1","uid":2014834,"ip_address":"","ucode":"75B4317A3B9070","user_header":"https://static001.geekbang.org/account/avatar/00/1e/be/72/6060d4a6.jpg","comment_is_top":false,"comment_ctime":1597208181,"is_pvip":false,"replies":[{"id":"89141","content":"那是默认参数。构造时不提供指针的话，就用nullptr。如果用户提供了其他值，就用其他值。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1597238938,"ip_address":"","comment_id":241175,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597208181","product_id":100040501,"comment_content":"老师那个shape_warpper类的构造函数，怎么那个参数一开始是shape* ptr=nullpty，不应该是shape *ptr吗。要是这样的话那不永远ptr就是个nullpty了吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503666,"discussion_content":"那是默认参数。构造时不提供指针的话，就用nullptr。如果用户提供了其他值，就用其他值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597238938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232038,"user_name":"Mingjie","can_delete":false,"product_type":"c1","uid":1356943,"ip_address":"","ucode":"0B83CD820E5F61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwVgXx5UCmXuUJIibytjfxlfia7XJBX6ricaVuGpAREA9fm8mK7WwKXEzictLQRIicvrIgRCGtrwfsS9g/132","comment_is_top":false,"comment_ctime":1593839560,"is_pvip":false,"replies":[{"id":"85791","content":"对，能不用new，就不用new。事实上，在某些环境里，会完全禁用堆内存。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1594004235,"ip_address":"","comment_id":232038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593839560","product_id":100040501,"comment_content":"我想起来了，应该是像值类型一样定义就可以分配在栈上了<br>foo()<br>{<br>...<br>   Bar mbar；<br>...<br>}<br>","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500485,"discussion_content":"对，能不用new，就不用new。事实上，在某些环境里，会完全禁用堆内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594004235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232036,"user_name":"Mingjie","can_delete":false,"product_type":"c1","uid":1356943,"ip_address":"","ucode":"0B83CD820E5F61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwVgXx5UCmXuUJIibytjfxlfia7XJBX6ricaVuGpAREA9fm8mK7WwKXEzictLQRIicvrIgRCGtrwfsS9g/132","comment_is_top":false,"comment_ctime":1593839086,"is_pvip":false,"replies":[{"id":"85792","content":"对，基本就是你另一个评论的意思，别用new。<br><br>此外，new也可以分配到指定的地方的，不过，那是C++98就有高级用法，我这个专栏里没有讨论。而且，虽然技术上允许，但实际上也不会分配在栈上，而是多用于内存池这样的批量分配场景。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1594004502,"ip_address":"","comment_id":232036,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593839086","product_id":100040501,"comment_content":"void foo()<br>{<br>  bar* ptr = new bar();<br>  …<br>  delete ptr;<br>}<br>上面的代码存在两个问题：<br><br>1 中间省略的代码部分也许会抛出异常，导致最后的delete ptr 得不到执行。<br><br>2 更重要的，这个代码不符合C++ 的惯用法。在C++ 里，这种情况下有99% 的可能性不应该使用堆内存分配，而应该使用栈内存分配。<br><br>我的问题，像上面的代码在函数中使用new 分配对象在堆空间上，C++ 如何让它分配在栈上呢？不是说使用new 就是在堆上分配内存吗？<br>我觉的正确的使用堆上的对象应该是把变量定义在 .h 文件中，或者定义在类中，是类的一个属性。但如果就是在函数执行期间使用堆对象，也可以像上面的方法中使用吧，用老师下面说的改良方法就好了。<br>但我不知道  使用new 分配对象在堆空间上，C++ 如何让它分配在栈上呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500483,"discussion_content":"对，基本就是你另一个评论的意思，别用new。\n\n此外，new也可以分配到指定的地方的，不过，那是C++98就有高级用法，我这个专栏里没有讨论。而且，虽然技术上允许，但实际上也不会分配在栈上，而是多用于内存池这样的批量分配场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594004502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229640,"user_name":"流连留念","can_delete":false,"product_type":"c1","uid":1229953,"ip_address":"","ucode":"DCFF4CC415D22D","user_header":"https://static001.geekbang.org/account/avatar/00/12/c4/81/974ecd8b.jpg","comment_is_top":false,"comment_ctime":1593082340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593082340","product_id":100040501,"comment_content":"有一直困扰我的问题，但是有点长，例子略少，得多看几遍，总体不错👍","like_count":0},{"had_liked":false,"id":227983,"user_name":"Ryan24G","can_delete":false,"product_type":"c1","uid":1631292,"ip_address":"","ucode":"EA1E134C18DA80","user_header":"https://static001.geekbang.org/account/avatar/00/18/e4/3c/dfcb86df.jpg","comment_is_top":false,"comment_ctime":1592532210,"is_pvip":true,"replies":[{"id":"84066","content":"都是合法的内容，而且我也不知道有更好且公开的资料。如何访问，各人自己想办法了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1592543704,"ip_address":"","comment_id":227983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592532210","product_id":100040501,"comment_content":"参考资料 都要翻墙 T_T","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498873,"discussion_content":"都是合法的内容，而且我也不知道有更好且公开的资料。如何访问，各人自己想办法了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592543704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225828,"user_name":"Geek_6d3429","can_delete":false,"product_type":"c1","uid":1898698,"ip_address":"","ucode":"F112DBF8375B7F","user_header":"","comment_is_top":false,"comment_ctime":1591868069,"is_pvip":false,"replies":[{"id":"83262","content":"对返回指针没有切割问题。但需要很小心，不造成内存泄漏。智能指针解决这一问题，而且智能指针也属于我说的指针变体。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1591940390,"ip_address":"","comment_id":225828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591868069","product_id":100040501,"comment_content":"您好 这个不太明白<br><br>“”这个 create_shape 方法会返回一个 shape 对象，对象的实际类型是某个 shape 的子类，圆啊，三角形啊，矩形啊，等等。这种情况下，函数的返回值只能是指针或其变体形式。”这段话是说返回指针是没问题的，只有返回对象才有问题吗？如果返回指针没有问题，如何引出的后文智能指针的论述？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498008,"discussion_content":"对返回指针没有切割问题。但需要很小心，不造成内存泄漏。智能指针解决这一问题，而且智能指针也属于我说的指针变体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591940390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210156,"user_name":"问天","can_delete":false,"product_type":"c1","uid":1450670,"ip_address":"","ucode":"A3695FAA4F6A77","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/ae/a7dba9ac.jpg","comment_is_top":false,"comment_ctime":1587692315,"is_pvip":false,"replies":[{"id":"78361","content":"不懂你的意思。RAII名字起得不太好，核心是自动析构。C里可没有。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1587704426,"ip_address":"","comment_id":210156,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1587692315","product_id":100040501,"comment_content":"c不是也raii吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492958,"discussion_content":"不懂你的意思。RAII名字起得不太好，核心是自动析构。C里可没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587704426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2922136,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/96/98/89b96cda.jpg","nickname":"三年二班邱小东","note":"","ucode":"909B49C63C8EC6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":559699,"discussion_content":"他的意思是C里的变量生命周期结束是也会自动销毁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648886616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":492958,"ip_address":""},"score":559699,"extra":""}]}]},{"had_liked":false,"id":195603,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1585203549,"is_pvip":true,"replies":[{"id":"74462","content":"你感到有价值，我就高兴了。😆","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1585316288,"ip_address":"","comment_id":195603,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585203549","product_id":100040501,"comment_content":"老师讲的真棒，评论区的讨论也非常的有价值，让我对编程语言有了更加透彻的理解呢。 这篇已经读了5遍了，果然需要写过一段时间的代码才能读懂呢。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489125,"discussion_content":"你感到有价值，我就高兴了。😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585316288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195294,"user_name":"howard霍华德","can_delete":false,"product_type":"c1","uid":1784046,"ip_address":"","ucode":"0C84B2C77E5766","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELPygdIicTKCkLPksiaiaT9ibcZWUPZrgaicfEtRqUnDiayT1vgYB1tTf04tuwdS322QUEtPt2NuBNqbDUA/132","comment_is_top":false,"comment_ctime":1585154865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585154865","product_id":100040501,"comment_content":"这篇文章要不断反刍 方能体会其中精妙","like_count":0},{"had_liked":false,"id":184562,"user_name":"浓茶水","can_delete":false,"product_type":"c1","uid":1080521,"ip_address":"","ucode":"1821A4FCB7B408","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/c9/3db4187e.jpg","comment_is_top":false,"comment_ctime":1583338260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583338260","product_id":100040501,"comment_content":"仔细看完所有评论，疑问，和老师的回复，有收益！","like_count":0},{"had_liked":false,"id":181628,"user_name":"JDY","can_delete":false,"product_type":"c1","uid":1848474,"ip_address":"","ucode":"4B6F55332BE6DC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg","comment_is_top":false,"comment_ctime":1582600135,"is_pvip":false,"replies":[{"id":"70360","content":"学完了 C++ Primer，来看这个专栏差不多正好。😆","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1582611037,"ip_address":"","comment_id":181628,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582600135","product_id":100040501,"comment_content":"看完了《c++primer》这本书，朋友推荐这个课程，看了第一讲感觉读完后在根据留言问题的解答，确实有点干货，比自己闷头学习好多了，果断订阅~","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485056,"discussion_content":"学完了 C++ Primer，来看这个专栏差不多正好。😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582611037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173842,"user_name":"super-ck","can_delete":false,"product_type":"c1","uid":1307067,"ip_address":"","ucode":"02F036E53E1130","user_header":"","comment_is_top":false,"comment_ctime":1579735497,"is_pvip":false,"replies":[{"id":"67402","content":"我说的是类似于 malloc&#47;free 的函数的内部逻辑，跟语言无关。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1579743243,"ip_address":"","comment_id":173842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579735497","product_id":100040501,"comment_content":"我觉得在c++ 中，应该没有内存合并这种，通常情况下，小于128比特每八比特一组，用时从八对齐位置找，如果找不到就再分配，而大于128则用malloc，所以内存合并存疑","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482218,"discussion_content":"我说的是类似于 malloc/free 的函数的内部逻辑，跟语言无关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579743243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168024,"user_name":"Geek_4472ab","can_delete":false,"product_type":"c1","uid":1264720,"ip_address":"","ucode":"63DB215130ADF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRicvicty8DRWAwMGcicdUdKJjjo7f1V63WUbHuJu6YX44ojlXVLE4Bf3l6qXxOvkBaJNyA/132","comment_is_top":false,"comment_ctime":1577979087,"is_pvip":false,"replies":[{"id":"65271","content":"😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578015715,"ip_address":"","comment_id":168024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577979087","product_id":100040501,"comment_content":"老师讲的真好，表白老师～","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480105,"discussion_content":"😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578015715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159724,"user_name":"panqing","can_delete":false,"product_type":"c1","uid":1563877,"ip_address":"","ucode":"6A1E50905AD2E7","user_header":"https://static001.geekbang.org/account/avatar/00/17/dc/e5/d07c38fa.jpg","comment_is_top":false,"comment_ctime":1575761342,"is_pvip":false,"replies":[{"id":"61015","content":"智能指针也可以不是引用计数的。🤓<br><br>不过不管那种，下一讲都会讨论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575776067,"ip_address":"","comment_id":159724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575761342","product_id":100040501,"comment_content":"shape_wraper 缺一个 ref counter","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477152,"discussion_content":"智能指针也可以不是引用计数的。🤓\n\n不过不管那种，下一讲都会讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575776067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159714,"user_name":"licong","can_delete":false,"product_type":"c1","uid":1502601,"ip_address":"","ucode":"02478E64E9D223","user_header":"https://static001.geekbang.org/account/avatar/00/16/ed/89/86340059.jpg","comment_is_top":false,"comment_ctime":1575735231,"is_pvip":true,"replies":[{"id":"61017","content":"常用语言里只有C++区分这两种标记（就是文中的例子）。你不能写ptr.call()。一般其他语言里都这样写。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575776279,"ip_address":"","comment_id":159714,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575735231","product_id":100040501,"comment_content":"“你写 ptr-&gt;call() 和 ptr.get()，语法上都是对的，并且 -&gt; 和 . 有着不同的语法作用”，这句话不太明白","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477149,"discussion_content":"常用语言里只有C++区分这两种标记（就是文中的例子）。你不能写ptr.call()。一般其他语言里都这样写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575776279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159622,"user_name":"panqing","can_delete":false,"product_type":"c1","uid":1563877,"ip_address":"","ucode":"6A1E50905AD2E7","user_header":"https://static001.geekbang.org/account/avatar/00/17/dc/e5/d07c38fa.jpg","comment_is_top":false,"comment_ctime":1575708198,"is_pvip":false,"replies":[{"id":"60991","content":"辫子抓得很好。不能执行的代码，写的时候，有时一改就容易出bug。<br><br>这儿的意图主要是文中这句话：「更常见、也更合理的情况是分配和释放不在一个函数里。」会出问题的点不是 make_bar，而是第 18 行的位置。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575721674,"ip_address":"","comment_id":159622,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575708198","product_id":100040501,"comment_content":"文稿中的第一个程序 编译不会通过。line 9 看不到 ptr 的声明。而且我不懂这个代码为啥内存泄漏可能性大。catch 里面做了保护，有异常会delete ptr.<br><br>1 bar* make_bar(…)<br>2 {<br>3  …<br>4  try {<br>5    bar* ptr = new bar();<br>6   …<br>7 }<br>8 catch (...) {<br>9  delete ptr;<br>10  throw;<br> 11 }<br>12  return ptr;<br>13}<br>14 void foo()<br>15{<br>16  …<br>17  bar* ptr = make_bar(…)<br>18  …<br>19  delete ptr;<br>20}<br>","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477121,"discussion_content":"辫子抓得很好。不能执行的代码，写的时候，有时一改就容易出bug。\n\n这儿的意图主要是文中这句话：「更常见、也更合理的情况是分配和释放不在一个函数里。」会出问题的点不是 make_bar，而是第 18 行的位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575721674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159027,"user_name":"刘光裕","can_delete":false,"product_type":"c1","uid":1757814,"ip_address":"","ucode":"D45460DAB10982","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d2/76/78368371.jpg","comment_is_top":false,"comment_ctime":1575517307,"is_pvip":false,"replies":[{"id":"60856","content":"shape就需要定义虚析构函数的。这和内存泄漏是两件无关的事。虚析构函数不能防止内存泄漏。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575539735,"ip_address":"","comment_id":159027,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575517307","product_id":100040501,"comment_content":"老师，shape工厂函数那部分，如果shape自身定义了虚析构函数，还会造成内存泄漏么？是不是就不需要定义shape_wraper了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476920,"discussion_content":"shape就需要定义虚析构函数的。这和内存泄漏是两件无关的事。虚析构函数不能防止内存泄漏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575539735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158455,"user_name":"wl.luke","can_delete":false,"product_type":"c1","uid":1639991,"ip_address":"","ucode":"59174AD0DC9633","user_header":"https://static001.geekbang.org/account/avatar/00/19/06/37/f1f66429.jpg","comment_is_top":false,"comment_ctime":1575376332,"is_pvip":false,"replies":[{"id":"60648","content":"下面列的都是不能或不应存储在栈上的情况。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575380686,"ip_address":"","comment_id":158455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575376332","product_id":100040501,"comment_content":"C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：<br>后面的例子到底哪些可以存储，哪些不可以啊，表示没看特别懂，能解释解释吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476732,"discussion_content":"下面列的都是不能或不应存储在栈上的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575380686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157644,"user_name":"熊出没","can_delete":false,"product_type":"c1","uid":1145377,"ip_address":"","ucode":"6E39230CC87808","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","comment_is_top":false,"comment_ctime":1575218112,"is_pvip":true,"replies":[{"id":"60444","content":"这个似乎没必要……标准的智能指针类似乎也没做这个限制吧……","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575245388,"ip_address":"","comment_id":157644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575218112","product_id":100040501,"comment_content":"shape_wrapper还需要限制使用者对shape_wrapper类使用new的方式进行资源申请","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476490,"discussion_content":"这个似乎没必要……标准的智能指针类似乎也没做这个限制吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575245388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157639,"user_name":"熊出没","can_delete":false,"product_type":"c1","uid":1145377,"ip_address":"","ucode":"6E39230CC87808","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","comment_is_top":false,"comment_ctime":1575217277,"is_pvip":true,"replies":[{"id":"60442","content":"切片是说把返回值类型从shape*改成shape会发生的错误……","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575245199,"ip_address":"","comment_id":157639,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1575217277","product_id":100040501,"comment_content":"请教下老师：RAII中对于对象切片的问题有些疑惑，create_shape的返回值是一个指针，而不是对象，为什么还会有内存泄漏呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476489,"discussion_content":"切片是说把返回值类型从shape*改成shape会发生的错误……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575245199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2573392,"avatar":"https://static001.geekbang.org/account/avatar/00/27/44/50/302d5b30.jpg","nickname":"天涯游子","note":"","ucode":"E6C8E638362318","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382070,"discussion_content":"所以有没有内存泄漏呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625400070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70246,"discussion_content":"谢谢 看来理解没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575338062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157499,"user_name":"盛艳明","can_delete":false,"product_type":"c1","uid":1132347,"ip_address":"","ucode":"E4C1C699572C44","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/3b/15e4490f.jpg","comment_is_top":false,"comment_ctime":1575180065,"is_pvip":false,"replies":[{"id":"60383","content":"😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575188983,"ip_address":"","comment_id":157499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575180065","product_id":100040501,"comment_content":"感谢老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476448,"discussion_content":"😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575188983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156946,"user_name":"Mark@ZEGO","can_delete":false,"product_type":"c1","uid":1030946,"ip_address":"","ucode":"A5C8F6DBEE2C61","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/22/1cbb4aa0.jpg","comment_is_top":false,"comment_ctime":1574999665,"is_pvip":true,"replies":[{"id":"60267","content":"发生异常，在函数外面捕获，程序不就没崩溃么？但上面的代码里，内存就会泄漏。<br><br>函数内catch之后你怎么办？已经不能继续执行了，手工记住该清理啥吗？……不过也不用急，下面专门有一讲谈异常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575027383,"ip_address":"","comment_id":156946,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574999665","product_id":100040501,"comment_content":"<br>void foo()<br>{<br>  bar* ptr = new bar();<br>  …<br>  delete ptr;<br>}<br><br>这里没太明白，请老师解惑：<br>1. 如何省略号中的代码发生了异常，那程序应该崩溃了，这时候内存是否释放，有关系吗？<br>2. 如果用 try-catch 保护省略号部分的代码，就算程序发生了异常，后面的 delete ptr; 还是会被执行，不会泄漏内存。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476279,"discussion_content":"发生异常，在函数外面捕获，程序不就没崩溃么？但上面的代码里，内存就会泄漏。\n\n函数内catch之后你怎么办？已经不能继续执行了，手工记住该清理啥吗？……不过也不用急，下面专门有一讲谈异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575027383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030946,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bb/22/1cbb4aa0.jpg","nickname":"Mark@ZEGO","note":"","ucode":"A5C8F6DBEE2C61","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69043,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575253708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156841,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1574987734,"is_pvip":false,"replies":[{"id":"60265","content":"呃，有两个问题。一、Meyers讲得是相当清楚的，我没把握认为我能讲得比他好，大家感到有困难的地方也非常可能是很个人化的。二、讲别人的内容，在法律上是很成问题的，没特别的授权就该算作是侵权了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1575027082,"ip_address":"","comment_id":156841,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574987734","product_id":100040501,"comment_content":"能开个专栏讲讲Scott Mayers, Effective C++吗？自己看，很多东西看不透彻。谢谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476250,"discussion_content":"呃，有两个问题。一、Meyers讲得是相当清楚的，我没把握认为我能讲得比他好，大家感到有困难的地方也非常可能是很个人化的。二、讲别人的内容，在法律上是很成问题的，没特别的授权就该算作是侵权了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575027082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1090051,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/ywSuwVNMKNjRLPMjZmpQOQHWW2usAu8RwRIOlBHaVVU6J3xHdtibgO6FVzYkRIkV50vCr62ia4OwJp07giabiazUGA/132","nickname":"ripple","note":"","ucode":"99008FD0533F68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300721,"discussion_content":"哈哈，老师，那樊登岂不天天侵权","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598247902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66770,"discussion_content":"谢谢。明白了，主要是我道行太浅。如果有平台能提供类似的读书交流就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575106011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156563,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574912330,"is_pvip":false,"replies":[{"id":"60109","content":"是的。用 C++ 不用 RAII，是对 C++ 功能的一大浪费啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574913853,"ip_address":"","comment_id":156563,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574912330","product_id":100040501,"comment_content":"刚刚我去维基百科中文版 搜了RAII 尤其是看到lock_guard时才发现利用栈调用析构函数释放锁 真的太牛逼了 这样就可以避免我们漏掉释放锁 从而造成的死锁 同样也可以用来释放内存 避免内存泄漏 很优雅 而且代码也很安全 大写的赞","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476153,"discussion_content":"是的。用 C++ 不用 RAII，是对 C++ 功能的一大浪费啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574913853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156400,"user_name":"%;","can_delete":false,"product_type":"c1","uid":1650351,"ip_address":"","ucode":"5B63F764708D3E","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/af/72a3f782.jpg","comment_is_top":false,"comment_ctime":1574866899,"is_pvip":false,"replies":[{"id":"60070","content":"是的，Meyers讲得很好的。他的书大家应该看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574899046,"ip_address":"","comment_id":156400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574866899","product_id":100040501,"comment_content":"学习了effective c++条款13:RAII<br>其中提到两个关键点：1.获得资源后立即放进管理对象 2.管理对象通过析构函数确保资源被释放。<br>对我来说这个专栏挺费劲的，一点一点看。😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476097,"discussion_content":"是的，Meyers讲得很好的。他的书大家应该看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574899046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156232,"user_name":" 🐌 ","can_delete":false,"product_type":"c1","uid":1041850,"ip_address":"","ucode":"BB5D7FFEE8F371","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/ba/e1790822.jpg","comment_is_top":false,"comment_ctime":1574840185,"is_pvip":false,"replies":[{"id":"60048","content":"谢谢。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574857860,"ip_address":"","comment_id":156232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574840185","product_id":100040501,"comment_content":"nice，讲的很清楚","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476042,"discussion_content":"谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574857860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156163,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1574827059,"is_pvip":false,"replies":[{"id":"60047","content":"我感觉目前的结果是对的（也是从实际运行结果粘贴过来的）。你再看看、试验一下？","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574857849,"ip_address":"","comment_id":156163,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574827059","product_id":100040501,"comment_content":"<br>栈展开那块的输出是下面这样吧？<br><br>Obj()<br>Obj()<br>~Obj(）<br>~Obj()<br>life, the universe and everything","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476014,"discussion_content":"我感觉目前的结果是对的（也是从实际运行结果粘贴过来的）。你再看看、试验一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574857849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346028,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f08a3JZjZd4Dpf2IL0g4mkQ9WtcAM3zcCZsA8r9GMpcUmsXGueVMibtJBxXDNGKx75rA/132","nickname":"dasheyuan","note":"","ucode":"AD61112AB070DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62679,"discussion_content":"估计这些实例老师都有代码调试过的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574857814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346028,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f08a3JZjZd4Dpf2IL0g4mkQ9WtcAM3zcCZsA8r9GMpcUmsXGueVMibtJBxXDNGKx75rA/132","nickname":"dasheyuan","note":"","ucode":"AD61112AB070DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62634,"discussion_content":"我调试的输出和老师的输出一致，编译器gcc 5.4","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574856301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156152,"user_name":"虫 二","can_delete":false,"product_type":"c1","uid":1434808,"ip_address":"","ucode":"4416C9BFD62F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","comment_is_top":false,"comment_ctime":1574825329,"is_pvip":false,"replies":[{"id":"60046","content":"对象超出作用域时被释放——一个shape_wrapper本地变量离开定义此变量的结束大括号时。当前的定义没有引用计数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574857688,"ip_address":"","comment_id":156152,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574825329","product_id":100040501,"comment_content":"当使用shape_wrapper，内存是什么时候被释放的呢？也有用到引用计数吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476010,"discussion_content":"对象超出作用域时被释放——一个shape_wrapper本地变量离开定义此变量的结束大括号时。当前的定义没有引用计数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574857688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156045,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1574815390,"is_pvip":false,"replies":[{"id":"60042","content":"嗯，是的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574856992,"ip_address":"","comment_id":156045,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574815390","product_id":100040501,"comment_content":"老师，”编译器调用析构函数”是不是指编译器在二进制文件中插入析构函数的代码？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475968,"discussion_content":"嗯，是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574856992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155956,"user_name":"小学生","can_delete":false,"product_type":"c1","uid":1021673,"ip_address":"","ucode":"64CDFA5A55D6F0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/e9/7a6433d3.jpg","comment_is_top":false,"comment_ctime":1574782741,"is_pvip":true,"replies":[{"id":"59931","content":"对，继承情况下，基类一般只用指针或引用，基本没例外。<br><br>跟局部变量对应的一般是全局&#47;静态变量。C++ 里没有类变量的说法。要延长生命期，一般也不是用你说的方法，而是返回对象（指针）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574813913,"ip_address":"","comment_id":155956,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574782741","product_id":100040501,"comment_content":"关于对象切片的那个问题，因为使用到了继承，应该不会考虑返回普通对象吧？因为可能要需要基类或子类。<br>可以给出一些，使用了继承又返回普通对象（即非指针）的场景吗🤔经验真的少<br>create_sharp 里面如果new 了一块内存且用于保存该内存的对象在超过其作用范围内，对象被销毁，可是指向的内容没有手动delete，而后再也找不到该对象（也就是没有显式指针引用），这样就内存泄漏了，因为再也引用不到那块内存了。这是栈变量或者局部变量的作用域带来的，所以用类变量可以将其作用域延长至整个类的生命周期中","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475938,"discussion_content":"对，继承情况下，基类一般只用指针或引用，基本没例外。\n\n跟局部变量对应的一般是全局/静态变量。C++ 里没有类变量的说法。要延长生命期，一般也不是用你说的方法，而是返回对象（指针）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155918,"user_name":"Egos","can_delete":false,"product_type":"c1","uid":1071143,"ip_address":"","ucode":"9F0055B140E935","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/27/1188e017.jpg","comment_is_top":false,"comment_ctime":1574778507,"is_pvip":false,"replies":[{"id":"59926","content":"代码风格有很多种，不同的项目都不一样。我现在做 Unix&#47;Linux 项目比较多，一般全小写居多。<br><br>这个跟项目走，不用自己有很强的意见。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574813429,"ip_address":"","comment_id":155918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574778507","product_id":100040501,"comment_content":"老师的代码是标准的cpp code style 吗？看着class 第一个字母小写不习惯","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475926,"discussion_content":"代码风格有很多种，不同的项目都不一样。我现在做 Unix/Linux 项目比较多，一般全小写居多。\n\n这个跟项目走，不用自己有很强的意见。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155855,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1574768602,"is_pvip":false,"replies":[{"id":"59891","content":"嗯，问得有道理。我的颜色选取不够好，回头改一下。按一般的栈帧定义，只有 0 属于 main，1–4 属于 bar。5 以上属于 foo。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574773073,"ip_address":"","comment_id":155855,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574768602","product_id":100040501,"comment_content":"对于图2d有疑惑，希望该图绘制中可以标明main函数占用的栈空间范围及其对应的栈帧，同理，对bar和foo也一样。如果将图2d从下到上每行编号为0，1，2，...，7，那么main、bar和foo对应的栈空间占用、栈帧分别是那几行呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475899,"discussion_content":"嗯，问得有道理。我的颜色选取不够好，回头改一下。按一般的栈帧定义，只有 0 属于 main，1–4 属于 bar。5 以上属于 foo。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574773073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61127,"discussion_content":"然而，看到有人这样问您：“参数42”和“a=43”分别是函数调用的参数和函数局部变量，应该属于同一个栈帧，为什么这里不同？\n您的回答是：同样，实际实现通常就是这个样子的。参数属于调用者而非被调用者，一般也是由调用者来释放——至少一般 x86 的实现是这个样子。\n\n那么和您这里回答我的就不一致的呢。您这里回答我1-4属于bar，因此，那个人问的问题（“参数42”和“a=43”应该属于同一个栈帧）这句就是对的。另外您说“参数属于调用者而非被调用者”，这里1-4既然属于bar了，那么参数42不就属于了被调用者bar了吗？我理解的是main是调用者，main调用了bar，则bar是被调用者。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574773678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155781,"user_name":"%;","can_delete":false,"product_type":"c1","uid":1650351,"ip_address":"","ucode":"5B63F764708D3E","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/af/72a3f782.jpg","comment_is_top":false,"comment_ctime":1574755483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574755483","product_id":100040501,"comment_content":"找到了a tour of c++ 学习先","like_count":0},{"had_liked":false,"id":155712,"user_name":"xjtu_ss_70309","can_delete":false,"product_type":"c1","uid":1757887,"ip_address":"","ucode":"BC4A523789C55E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d2/bf/7431e82e.jpg","comment_is_top":false,"comment_ctime":1574741568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574741568","product_id":100040501,"comment_content":"缺了引用计数","like_count":0},{"had_liked":false,"id":155691,"user_name":"frazer","can_delete":false,"product_type":"c1","uid":1194427,"ip_address":"","ucode":"36869573D98495","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/bb/3dd9ef18.jpg","comment_is_top":false,"comment_ctime":1574737213,"is_pvip":false,"replies":[{"id":"59865","content":"那就多读几遍😁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574763256,"ip_address":"","comment_id":155691,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574737213","product_id":100040501,"comment_content":"有点看不懂了，还得回去恶补CPP的语法知识","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475837,"discussion_content":"那就多读几遍😁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574763256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155679,"user_name":"流浪地球","can_delete":false,"product_type":"c1","uid":1498137,"ip_address":"","ucode":"25210DCD353F97","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg","comment_is_top":false,"comment_ctime":1574735636,"is_pvip":false,"replies":[{"id":"59857","content":"没有重载。全局的delete（和free）都可以接受空指针的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574762348,"ip_address":"","comment_id":155679,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574735636","product_id":100040501,"comment_content":"老师您好，请问 “如果你好奇 delete 空指针会发生什么的话，那答案是，这是一个合法的空操作。在 new 一个对象和 delete 一个指针时编译器需要干不少活的” 这段讲述中的delete是重载过的吗？全局的::operator delete是做判空操作吗？<br>谢谢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475830,"discussion_content":"没有重载。全局的delete（和free）都可以接受空指针的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574762348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498137,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg","nickname":"流浪地球","note":"","ucode":"25210DCD353F97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60897,"discussion_content":"delete 和 free 空指针不是会引发崩溃吗，求解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574763624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1498137,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg","nickname":"流浪地球","note":"","ucode":"25210DCD353F97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61778,"discussion_content":"你试一下不就知道了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574783401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60897,"ip_address":""},"score":61778,"extra":""}]}]},{"had_liked":false,"id":155559,"user_name":"净莲妖火","can_delete":false,"product_type":"c1","uid":1089372,"ip_address":"","ucode":"2AFE1021696E53","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/5c/f7425225.jpg","comment_is_top":false,"comment_ctime":1574698352,"is_pvip":false,"replies":[{"id":"59696","content":"嗯，是的。这个也是目前这个类缺失的地方。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574732180,"ip_address":"","comment_id":155559,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574698352","product_id":100040501,"comment_content":"智能指针还少了对*和-&gt;符号的支持，为支持所有指针，需要用类模版。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475793,"discussion_content":"嗯，是的。这个也是目前这个类缺失的地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574732180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155514,"user_name":"小林coding","can_delete":false,"product_type":"c1","uid":1303210,"ip_address":"","ucode":"D57D7DBF260216","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/aa/9ddc6469.jpg","comment_is_top":false,"comment_ctime":1574694580,"is_pvip":true,"replies":[{"id":"59668","content":"是的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574697855,"ip_address":"","comment_id":155514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574694580","product_id":100040501,"comment_content":"老师，文稿中的这句话：<br>[ 如果返回类型是 shape，实际却返回一个 circle，编译器不会报错，但结果多半是错的。这种现象叫对象切片（object slicing），是 C++ 特有的一种编码错误 ]<br><br>这里想说明的是返回类型是普通 shape ，而不是 shape* 或 shape&amp;  是吗？<br>","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475781,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574697855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155496,"user_name":"Para","can_delete":false,"product_type":"c1","uid":1079651,"ip_address":"","ucode":"C257F5F58DADDD","user_header":"https://thirdqq.qlogo.cn/qqapp/101423631/68B06747A0E7D52A26CEC926D06CEE03/100","comment_is_top":false,"comment_ctime":1574692983,"is_pvip":false,"replies":[{"id":"59670","content":"对，这是其中的一个问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574697959,"ip_address":"","comment_id":155496,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574692983","product_id":100040501,"comment_content":"区别是赋值构造浅拷贝有可能导致double free吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475775,"discussion_content":"对，这是其中的一个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574697959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155494,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1574692707,"is_pvip":false,"replies":[{"id":"59671","content":"1. 看汇编会比较明白。一般进入一个函数之后，最先执行的语句就是保存一些基础的寄存器。<br>2. 你说的对，图已改。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574698236,"ip_address":"","comment_id":155494,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574692707","product_id":100040501,"comment_content":"关于图2c和图2d，有两个疑问：<br>1， 寄存器保留空间指的是什么，有什么作用？<br>2，“参数42”和“a=43”分别是函数调用的参数和函数局部变量，应该属于同一个栈帧，为什么这里不同？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475774,"discussion_content":"1. 看汇编会比较明白。一般进入一个函数之后，最先执行的语句就是保存一些基础的寄存器。\n2. 你说的对，图已改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574698236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61701,"discussion_content":"另，我原先作图时没有查定义，有点想当然了。目前图已经修改，应该就不会产生疑问了。抱歉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574782558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59896,"discussion_content":"我对这里也有点疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574694985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155476,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1574691382,"is_pvip":false,"replies":[{"id":"59664","content":"能拷贝和赋值的，就是结果不对。🤣","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574693173,"ip_address":"","comment_id":155476,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1574691382","product_id":100040501,"comment_content":"拷贝和赋值的功能也是相对完整智能指针差的内容","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475765,"discussion_content":"能拷贝和赋值的，就是结果不对。🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1674919,"avatar":"","nickname":"Geek_3812e8","note":"","ucode":"049FA88FCCDD10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61078,"discussion_content":"编译器合成的拷贝和赋值是浅拷贝，因此会造成double free","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574771706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155472,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1574691260,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1574691260","product_id":100040501,"comment_content":"没有引用计数的功能","like_count":0},{"had_liked":false,"id":155453,"user_name":"言念君子","can_delete":false,"product_type":"c1","uid":1241665,"ip_address":"","ucode":"58772F508AC7DC","user_header":"https://wx.qlogo.cn/mmopen/vi_32/icultORy1BkmIuq9oDFgyolLibfOlsJxj69es4QiashdXEtPicxPsZGNQF0WOrZHDs1JvLeec7icn1DAVD1oNjO7mvg/132","comment_is_top":false,"comment_ctime":1574690351,"is_pvip":false,"replies":[{"id":"59654","content":"我检查了一下，代码似乎没问题，但在我的手机上宽度略超了点。你是不是也是这个问题？试试左右拖动一下。（代码要在手机屏幕上能适配还是很有挑战的……）<br><br>没有引用计数是一个问题。不过，不是所有的智能指针都是引用计数的哦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574692226,"ip_address":"","comment_id":155453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574690351","product_id":100040501,"comment_content":"工厂方法那里的代码显示好像有问题。<br><br>相比于智能指针最明显的区别是没有实现引用计数的功能。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475757,"discussion_content":"我检查了一下，代码似乎没问题，但在我的手机上宽度略超了点。你是不是也是这个问题？试试左右拖动一下。（代码要在手机屏幕上能适配还是很有挑战的……）\n\n没有引用计数是一个问题。不过，不是所有的智能指针都是引用计数的哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574692226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155402,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1574685605,"is_pvip":false,"replies":[{"id":"59635","content":"是不是漏看了下面这段话？<br><br>「如果你好奇 delete 空指针会发生什么的话，那答案是，这是一个合法的空操作。」","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574687953,"ip_address":"","comment_id":155402,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1574685605","product_id":100040501,"comment_content":"老师看到一个优化点，ptr_ 需要判断空，如果prt_已经创建了，才使用delete","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475740,"discussion_content":"是不是漏看了下面这段话？\n\n「如果你好奇 delete 空指针会发生什么的话，那答案是，这是一个合法的空操作。」","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574687953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","nickname":"曾轼麟","note":"","ucode":"D418371AC11270","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59507,"discussion_content":"嗯嗯是的，但是老师也说了delete会做出很多其它的操作，如果delete 空指针好不好导致一些不需要的性能开销呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574689867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1451391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","nickname":"曾轼麟","note":"","ucode":"D418371AC11270","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61806,"discussion_content":"别人做检查和你做检查没区别啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574783639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":59507,"ip_address":""},"score":61806,"extra":""}]},{"author":{"id":1232666,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cf/1a/858ed742.jpg","nickname":"ly","note":"","ucode":"E3DD8176AE8AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59433,"discussion_content":"delete nullptr是可以的啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574688622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155387,"user_name":"叶筱","can_delete":false,"product_type":"c1","uid":1388844,"ip_address":"","ucode":"A613A652E39ADA","user_header":"https://static001.geekbang.org/account/avatar/00/15/31/2c/b91ce98e.jpg","comment_is_top":false,"comment_ctime":1574684260,"is_pvip":true,"replies":[{"id":"59629","content":"看来我的讲述还是不够完整啊……能说说哪些地方你觉得特别有困难不？<br><br>不过，边看边查这种学习方式要得。参考资料就是让你们扩展阅读的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1574687563,"ip_address":"","comment_id":155387,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1574684260","product_id":100040501,"comment_content":"边看边查，好多定义都不甚了解","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475737,"discussion_content":"看来我的讲述还是不够完整啊……能说说哪些地方你觉得特别有困难不？\n\n不过，边看边查这种学习方式要得。参考资料就是让你们扩展阅读的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574687563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59630,"discussion_content":"比如：当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，这句话里，括号中寄存器传递参数的情况不是很理解。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574691831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":60915,"discussion_content":"括号里可以不用管，不这么写怕有人说我不严密。哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574764599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":59630,"ip_address":""},"score":60915,"extra":""}]},{"author":{"id":1388844,"avatar":"https://static001.geekbang.org/account/avatar/00/15/31/2c/b91ce98e.jpg","nickname":"叶筱","note":"","ucode":"A613A652E39ADA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59627,"discussion_content":"c++基础差点（基本有些语法的格式和变量头文件），基本上查查都能理解了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574691805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}