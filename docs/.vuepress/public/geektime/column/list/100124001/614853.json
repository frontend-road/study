{"id":614853,"title":"31｜规则引擎：自定义爬虫处理规则","content":"<p>你好，我是郑建勋。</p><p>这一节课，我们重点来看看如何更合理地设置爬虫任务规则。之前，我们在查找租房信息时，已经实现了有一定扩展性的程序。通过在每一个请求中加入 <code>ParseFunc</code> 函数，可以实现灵活的请求规则。</p><pre><code class=\"language-plain\">// 单个请求\ntype Request struct {\n\tunique    string\n\tTask      *Task\n\tUrl       string\n\tMethod    string\n\tDepth     int\n\tPriority  int\n\tParseFunc func([]byte, *Request) ParseResult\n}\n</code></pre><p>但我们现在仍然面临几个问题：</p><ul>\n<li>一个爬虫任务会针对不同的网站有不同的处理规则，但现在的处理方式导致多个规则之间是割裂的，不便于统一管理。</li>\n<li>我们在添加初始爬虫网站URL时，这些种子任务是在main函数中注入进去的，与任务的规则之间是割裂的。但是我们需要将初始爬虫URL与处理规则进行统一的管理。</li>\n<li>当前的爬虫任务还是需要手动初始化才能运行，可配置化程度比较低。我们希望这些写好的静态任务在程序初始化时能够自动加载。而通过外部接口，或者只要在配置文件中指定一个任务名就能将任务调度起来。</li>\n<li>更进一步，我们当前的任务和规则都是静态的，静态指的是代码需要提前写好，重新编译运行才能够在运行中被调用。我们能否动态地增加任务和任务的规则，让程序能够动态地解析我们的规则呢？</li>\n</ul><!-- [[[read_end]]] --><p>为了解决上面这些问题，我们需要有专门负责规则管理的模块，并完成静态规则与动态规则的解析。</p><h2>静态规则引擎</h2><p>静态规则处理的确定性强，它适合对性能要求高的爬虫任务。我们可以把一个任务的规则抽象如下：</p><pre><code class=\"language-plain\">type RuleTree struct {\n\tRoot  func() []*Request // 根节点(执行入口)\n\tTrunk map[string]*Rule  // 规则哈希表\n}\n\n// 采集规则节点\ntype Rule struct {\n\tParseFunc func(*Context) ParseResult // 内容解析函数\n}\n\ntype Context struct {\n\tBody []byte\n\tReq  *Request\n}\n</code></pre><p>其实规则引擎就像一棵树。RuleTree.Root 是一个函数，用于生成爬虫的种子网站，而RuleTree.Trunk是一个规则哈希表，用于存储当前任务所有的规则，哈希表的Key为规则名，Value为具体的规则。每一个规则就是一个ParseFunc解析函数。参数Context为自定义结构体，用于传递上下文信息，也就是当前的请求参数以及要解析的内容字节数组。后续还会添加请求中的临时数据等上下文数据。</p><p>下面我们沿用之前爬取租房信息的例子，将处理规则替换为使用新的静态规则引擎。</p><p><strong>第一步，定义任务与规则。</strong></p><p>我们在Task中加入了Name字段，将其作为一个任务唯一的标识。Task里除了之前具有的最大深度、等待时间等属性，我们还加入了规则条件， 规则条件中Root生成了初始化的爬虫任务。Trunk为爬虫任务中的所有规则。</p><pre><code class=\"language-plain\">type Task struct {\n   ...\n   Rule        RuleTree\n}\n\nvar DoubangroupTask = &amp;collect.Task{\n\tName:     \"find_douban_sun_room\",\n\tWaitTime: 1 * time.Second,\n\tMaxDepth: 5,\n\tCookie:  \"xxx\",\n\tRule: collect.RuleTree{\n\t\tRoot: func() []*collect.Request {\n\t\t\tvar roots []*collect.Request\n\t\t\tfor i := 0; i &lt; 25; i += 25 {\n\t\t\t\tstr := fmt.Sprintf(\"&lt;https://www.douban.com/group/szsh/discussion?start=%d&gt;\", i)\n\t\t\t\troots = append(roots, &amp;collect.Request{\n\t\t\t\t\tPriority: 1,\n\t\t\t\t\tUrl:      str,\n\t\t\t\t\tMethod:   \"GET\",\n\t\t\t\t\tRuleName: \"解析网站URL\",\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn roots\n\t\t},\n\t\tTrunk: map[string]*collect.Rule{\n\t\t\t\"解析网站URL\": &amp;collect.Rule{ParseURL},\n\t\t\t\"解析阳台房\":   &amp;collect.Rule{GetSunRoom},\n\t\t},\n\t},\n}\n</code></pre><p>当前任务规则包括了“解析网站URL” 和“解析阳台房” 这两个规则，分别对应了处理函数ParseURL和GetSunRoom，如下所示。</p><pre><code class=\"language-plain\">const urlListRe = `(&lt;https://www.douban.com/group/topic/[0-9a-z]+/&gt;)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`\nconst ContentRe = `&lt;div class=\"topic-content\"&gt;[\\s\\S]*?阳台[\\s\\S]*?&lt;div class=\"aside\"&gt;`\n\nfunc ParseURL(ctx *collect.Context) collect.ParseResult {\n\tre := regexp.MustCompile(urlListRe)\n\n\tmatches := re.FindAllSubmatch(ctx.Body, -1)\n\tresult := collect.ParseResult{}\n\n\tfor _, m := range matches {\n\t\tu := string(m[1])\n\t\tresult.Requesrts = append(\n\t\t\tresult.Requesrts, &amp;collect.Request{\n\t\t\t\tMethod:   \"GET\",\n\t\t\t\tTask:     ctx.Req.Task,\n\t\t\t\tUrl:      u,\n\t\t\t\tDepth:    ctx.Req.Depth + 1,\n\t\t\t\tRuleName: \"解析阳台房\",\n\t\t\t})\n\t}\n\treturn result\n}\n\nfunc GetSunRoom(ctx *collect.Context) collect.ParseResult {\n\tre := regexp.MustCompile(ContentRe)\n\n\tok := re.Match(ctx.Body)\n\tif !ok {\n\t\treturn collect.ParseResult{\n\t\t\tItems: []interface{}{},\n\t\t}\n\t}\n\tresult := collect.ParseResult{\n\t\tItems: []interface{}{ctx.Req.Url},\n\t}\n\treturn result\n}\n</code></pre><p><strong>第二步，初始化任务与规则。</strong></p><p>在engine/schedule.go文件中，init函数中的Store.Add函数将任务加载到全局的任务队列中。在Go中，init函数是一个特殊的函数，它会在main函数之前自动执行。注意，当添加的任务越来越多之后，代码会变得臃肿，这不是一种优雅的写法。后面我们还会优化它。</p><pre><code class=\"language-plain\">// engine/schedule.go\nfunc init() {\n\tStore.Add(doubangroup.DoubangroupTask)\n}\n\nfunc (c *CrawlerStore) Add(task *collect.Task) {\n\tc.hash[task.Name] = task\n\tc.list = append(c.list, task)\n}\n\n// 全局爬虫任务实例\nvar Store = &amp;CrawlerStore{\n\tlist: []*collect.Task{},\n\thash: map[string]*collect.Task{},\n}\n\ntype CrawlerStore struct {\n\tlist []*collect.Task\n\thash map[string]*collect.Task\n}\n</code></pre><p><strong>第三步，启动任务。</strong></p><p>启动爬虫任务的方式可以分为两种，一种是加载配置文件，另一种是在调用用户接口时，传递任务名称和参数。不过在这里我们先用硬编码的形式来实现。而通过配置文件和用户接口来操作任务的方式我们会有专门的课程来实现。</p><pre><code class=\"language-plain\">func main(){\n\t...\n\tseeds = append(seeds, &amp;collect.Task{\n\t\t\tName:    \"find_douban_sun_room\",\n\t\t\tFetcher: f,\n\t\t})\n\ts := engine.NewEngine(\n\t\t\tengine.WithFetcher(f),\n\t\t\tengine.WithLogger(logger),\n\t\t\tengine.WithWorkCount(5),\n\t\t\tengine.WithSeeds(seeds),\n\t\t\tengine.WithScheduler(engine.NewSchedule()),\n\t\t)\n\t\ts.Run()\n}\n</code></pre><p><strong>第四步，加载任务。</strong><br>\n在调度器启动时，通过task.Rule.Root()获取初始化任务，并加入到任务队列中。</p><pre><code class=\"language-plain\">func (e *Crawler) Schedule() {\n\tvar reqs []*collect.Request\n\tfor _, seed := range e.Seeds {\n\t\ttask := Store.hash[seed.Name]\n\t\t// 获取初始化任务\n\t\trootreqs := task.Rule.Root()\n\t\treqs = append(reqs, rootreqs...)\n\t}\n\tgo e.scheduler.Schedule()\n\tgo e.scheduler.Push(reqs...)\n}\n</code></pre><p>在Worker处理请求时，需要从Rule.Trunk中获取当前请求的解析规则，并将内容和请求包装到Context中，调用ParseFunc对内容进行解析。</p><pre><code class=\"language-plain\">func (s *Crawler) CreateWork() {\n\tfor {\n     ...\n     //获取当前任务对应的规则\n    rule := req.Task.Rule.Trunk[req.RuleName]\n    // 内容解析\n    result := rule.ParseFunc(&amp;collect.Context{\n    \tbody,\n    \treq,\n    })\n\t// 新的任务加入队列中\n    if len(result.Requesrts) &gt; 0 {\n\t\t\tgo s.scheduler.Push(result.Requesrts...)\n\t\t}\n\t}\n}\n</code></pre><p>完整的代码位于<a href=\"https://github.com/dreamerjackson/crawler\">v0.2.4</a>。</p><h2>动态规则引擎</h2><p>对Go语言这样的静态语言来说，我们需要在编译前就明确规则。这保证了程序的安全性与高性能，但是也失去了一些灵活性。像Javascript、Python、Lua这样的动态语言与Go有显著不同，它们不需要提前进行编译，能够比较灵活地书写并执行动态的规则。这一功能依赖于一种语言解释器，这种解释器一般是静态的语言编写的，例如C/C++，解释器会解析这些动态语言的语法，然后执行相应规则。</p><p>和你分享一个实际企业中的例子。一家人工智能企业的核心产品之一是对视频流进行人脸识别。完成视频中人脸的解析涉及到视频的解码、 人脸的识别、人脸的矫正、特征的提取等多个阶段。这整个过程被称为一个pipeline。pipeline中的每一个阶段可能是串行的也可能是并行的。在过去，人脸、人群、物体的识别都需要单独来开发，这样开发的周期比较长，也缺乏灵活性。</p><p>为了应对未来灵活多变的检测需求，例如监测人是否摔倒，工人是否佩戴安全帽等，我们需要更短的开发周期，需要用更灵活的方式把这些阶段串联起来。这时这家公司就在Go中使用了Lua虚拟机。开发者遇到一个新的长尾需求时，通过书写Lua脚本来定义新的规则。在Go程序中通过动态加载Lua脚本来实现灵活性。</p><p>我们现在的爬虫项目其实也面邻着一样的问题。网站和规则是多种多样的，我们无法穷尽所有的规则，如果每次遇到新网站都要重新写代码，写爬取规则然后重启程序，这会比较繁琐，所以我们希望能够动态地在程序运行过程中加载规则。</p><p>动态规则带来的另一个好处是，降低了书写代码规则的门槛，它甚至可以让业务人员也能书写简单的规则。<strong>说到在爬虫项目中实现动态规则的引擎，我们首先想到的就是使用Javascript虚拟机了。因为使用JS操作网页有天然的优势。</strong></p><p>自己要在短时间内实现一个工业级的虚拟机可能比较困难，我们可以使用一些开源的项目，例如<a href=\"https://github.com/robertkrimen/otto\">otto</a>。otto 是用 Go 编写的 JavaScript 虚拟机，用于在Go中执行Javascript语法。</p><p>下面是用otto编写的一个简单的例子。在这个例子中，script字符串即为要执行的Javascript语法，console.log是JS中的函数，用于打印变量。</p><pre><code class=\"language-plain\">package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/robertkrimen/otto\"\n)\n\nfunc main() {\n\tvm := otto.New()\n\tscript := `\n\t\tvar n = 100;\n\t\tconsole.log(\"hello-\" + n);   \n    n;\n\t`\n\tvalue, _ := vm.Run(script)\n\tfmt.Println(\"value:\", value.String()) \n}\n</code></pre><p>最终结果为：</p><pre><code class=\"language-plain\">hello-100\nvalue: 100\n</code></pre><p>这样，我们就实现了在Go语言中执行JS脚本的目的。实际上，otto内部解析了这一串字符串，并按照JS语法中对应的规则进行了相应的处理，例如脚本中的console.log函数最终其实也调用了Go中的fmt函数，实现将文本打印到控制台。不过我们要注意的是，不一定JS的所有语法JS虚拟机都是支持的，是否支持取决于当前虚拟机的实现。例如当前otto支持JS5语法，但是不支持JS6语法。</p><p>下面我们我们仍然以爬取租房信息为例，借助otto库实现的JS虚拟机来实现动态的规则引擎。</p><p><strong>第一步，构建动态规则模型TaskModle。</strong></p><pre><code class=\"language-plain\">type (\n\tTaskModle struct {\n\t\tName     string        `json:\"name\"` // 任务名称，应保证唯一性\n\t\tUrl      string        `json:\"url\"`\n\t\tCookie   string        `json:\"cookie\"`\n\t\tWaitTime time.Duration `json:\"wait_time\"`\n\t\tReload   bool          `json:\"reload\"` // 网站是否可以重复爬取\n\t\tMaxDepth int64         `json:\"max_depth\"`\n\t\tRoot  string           `json:\"root_script\"`\n\t\tRules []RuleModle      `json:\"rule\"`\n\t}\n\tRuleModle struct {\n\t\tName      string `json:\"name\"`\n\t\tParseFunc string `json:\"parse_script\"`\n\t}\n)\n</code></pre><p>为什么这里要单独构建一个任务的结构体呢？主要原因在于，现在我们的规则都是字符串了，这和之前的静态规则引擎有本质的不同。其中，TaskModle.Root为初始化种子节点的JS脚本，TaskModle.Rules为具体爬虫任务的规则树。</p><p><strong>第二步，书写动态爬虫规则。</strong></p><p>示例代码如下。其中，Root脚本就是我们要生成的种子网站URL。在这里我们构建了一个JS数组arr，将生成的请求数组添加到arr之后，又调用了AddJsReq函数。AddJsReq函数其实是一个Go函数，用于最终生成Go中的请求数组。在这里我们可以看到，在Go的JS虚拟机中，还可以灵活地调用原生的Go函数。</p><pre><code class=\"language-plain\">var DoubangroupJSTask = &amp;collect.TaskModle{\n\tProperty: collect.Property{\n\t\tName:     \"js_find_douban_sun_room\",\n\t\tWaitTime: 1 * time.Second,\n\t\tMaxDepth: 5,\n\t\tCookie:   \"xxx\",\n\t},\n\tRoot: `\n\t\tvar arr = new Array();\n \t\tfor (var i = 25; i &lt;= 25; i+=25) {\n\t\t\tvar obj = {\n\t\t\t   Url: \"&lt;https://www.douban.com/group/szsh/discussion?start=&gt;\" + i,\n\t\t\t   Priority: 1,\n\t\t\t   RuleName: \"解析网站URL\",\n\t\t\t   Method: \"GET\",\n\t\t   };\n\t\t\tarr.push(obj);\n\t\t};\n\t\tconsole.log(arr[0].Url);\n\t\tAddJsReq(arr);\n\t\t\t`,\n\tRules: []collect.RuleModle{\n\t\t{\n\t\t\tName: \"解析网站URL\",\n\t\t\tParseFunc: `\n\t\t\tctx.ParseJSReg(\"解析阳台房\",\"(&lt;https://www.douban.com/group/topic/[0-9a-z]+/&gt;)\\\\\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;\");\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tName: \"解析阳台房\",\n\t\t\tParseFunc: `\n\t\t\t//console.log(\"parse output\");\n\t\t\tctx.OutputJS(\"&lt;div class=\\\\\"topic-content\\\\\"&gt;[\\\\\\\\s\\\\\\\\S]*?阳台[\\\\\\\\s\\\\\\\\S]*?&lt;div class=\\\\\"aside\\\\\"&gt;\");\n\t\t\t`,\n\t\t},\n\t},\n}\n</code></pre><p>而在Rules脚本中，我们加入了两个爬虫规则，分别是“解析网站URL”和 “解析阳台房”，他们都可以使用非常简单的规则来实现。在这里我们调用了 ctx.ParseJSReg 来解析请求，调用了 ctx.OutputJS 来解析并输出找到的内容，注意这里的ctx.ParseJSReg与ctx.OutputJS也是Go原生的函数，下面我们会看到他们的实现。</p><p><strong>第三步，书写动态规则中的Go函数。</strong></p><p>AddJsReqs函数将在JS脚本中的请求数据变为Go结构中的数组[]*collect.Request，而ctx.ParseJSReg方法则会动态解析JS中传递的正则表达式并生成新的请求, ctx.OutputJS负责解析传递过来的正则表达式并完成结果的输出。注意JS虚拟机会自动将JS脚本中的参数转换为函数参数中对应的结构。</p><pre><code class=\"language-plain\">// 用于动态规则添加请求。\nfunc AddJsReqs(jreqs []map[string]interface{}) []*collect.Request {\n\treqs := make([]*collect.Request, 0)\n\n\tfor _, jreq := range jreqs {\n\t\treq := &amp;collect.Request{}\n\t\tu, ok := jreq[\"Url\"].(string)\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\t\treq.Url = u\n\t\treq.RuleName, _ = jreq[\"RuleName\"].(string)\n\t\treq.Method, _ = jreq[\"Method\"].(string)\n\t\treq.Priority, _ = jreq[\"Priority\"].(int64)\n\t\treqs = append(reqs, req)\n\t}\n\treturn reqs\n}\n\n// 动态解析JS中的正则表达式\nfunc (c *Context) ParseJSReg(name string, reg string) ParseResult {\n\tre := regexp.MustCompile(reg)\n\n\tmatches := re.FindAllSubmatch(c.Body, -1)\n\tresult := ParseResult{}\n\n\tfor _, m := range matches {\n\t\tu := string(m[1])\n\t\tresult.Requesrts = append(\n\t\t\tresult.Requesrts, &amp;Request{\n\t\t\t\tMethod:   \"GET\",\n\t\t\t\tTask:     c.Req.Task,\n\t\t\t\tUrl:      u,\n\t\t\t\tDepth:    c.Req.Depth + 1,\n\t\t\t\tRuleName: name,\n\t\t\t})\n\t}\n\treturn result\n}\n\n// 解析内容并输出结果\nfunc (c *Context) OutputJS(reg string) ParseResult {\n\tre := regexp.MustCompile(reg)\n\tok := re.Match(c.Body)\n\tif !ok {\n\t\treturn ParseResult{\n\t\t\tItems: []interface{}{},\n\t\t}\n\t}\n\tresult := ParseResult{\n\t\tItems: []interface{}{c.Req.Url},\n\t}\n\treturn result\n}\n</code></pre><p><strong>第四步，初始化任务与规则。</strong></p><p>初始化动态规则这一步更复杂一些，因为我们需要将JS脚本放入paesrFunc函数中，供otto库解析，代码如下所示。</p><pre><code class=\"language-plain\">func init() {\n    ...\n\tStore.AddJSTask(doubangroup.DoubangroupJSTask)\n}\n\nfunc (c *CrawlerStore) AddJSTask(m *collect.TaskModle) {\n\ttask := &amp;collect.Task{\n\t\tProperty: m.Property,\n\t}\n\n\ttask.Rule.Root = func() ([]*collect.Request, error) {\n\t\tvm := otto.New()\n\t\tvm.Set(\"AddJsReq\", AddJsReqs)\n\t\tv, err := vm.Eval(m.Root)\n\t\te, err := v.Export()\n\t\treturn e.([]*collect.Request), nil\n\t}\n\n\tfor _, r := range m.Rules {\n\t\tpaesrFunc := func(parse string) func(ctx *collect.Context) (collect.ParseResult, error) {\n\t\t\treturn func(ctx *collect.Context) (collect.ParseResult, error) {\n\t\t\t\tvm := otto.New()\n\t\t\t\tvm.Set(\"ctx\", ctx)\n\t\t\t\tv, err := vm.Eval(parse)\n\t\t\t\te, err := v.Export()\n\t\t\t\treturn e.(collect.ParseResult), err\n\t\t\t}\n\t\t}(r.ParseFunc)\n\t\tif task.Rule.Trunk == nil {\n\t\t\ttask.Rule.Trunk = make(map[string]*collect.Rule, 0)\n\t\t}\n\t\ttask.Rule.Trunk[r.Name] = &amp;collect.Rule{\n\t\t\tpaesrFunc,\n\t\t}\n\t}\n\n\tc.hash[task.Name] = task\n\tc.list = append(c.list, task)\n}\n</code></pre><p>在这里，用于生成种子网站的Root函数中的 vm.Eval(m.Root) 执行了配置中的root脚本，然后返回了生成的请求数组。vm.Set(“AddJsReq”, AddJsReqs) 可以将Go原生函数注册到 JS 虚拟机中，这样我们才能在JS脚本中调用Go函数。paesrFunc函数也是一样，在这里我们使用了闭包，方便后续执行parse脚本并最后返回解析后的collect.ParseResult结果。</p><p><strong>第五步，启动并加载任务。</strong></p><p>启动任务和加载任务与静态规则引擎代码完全一致，完全复用就可以了。到这里，我们只需要指定一个任务名js_find_douban_sun_room就可以利用动态规则引擎将爬虫任务跑起来了。</p><pre><code class=\"language-plain\">func main(){\n\t...\n\tseeds = append(seeds, &amp;collect.Task{\n\t\t\tProperty: collect.Property{\n\t\t\t\tName: \"js_find_douban_sun_room\",\n\t\t\t},\n\t\t\tFetcher: f,\n\t\t})\n\t\n\t\ts := engine.NewEngine(\n\t\t\tengine.WithFetcher(f),\n\t\t\tengine.WithLogger(logger),\n\t\t\tengine.WithWorkCount(5),\n\t\t\tengine.WithSeeds(seeds),\n\t\t\tengine.WithScheduler(engine.NewSchedule()),\n\t\t)\n\t\n\t\ts.Run()\n}\n</code></pre><p>完整的代码位于<a href=\"https://github.com/dreamerjackson/crawler\">v0.2.5</a>。</p><h2>总结</h2><p>在本节课程中，为了更好地对爬虫任务进行管理，我们构建了规则引擎模块来管理静态和动态的规则。</p><p>静态的规则指的是需要在Go代码中提前写好的解析规则，这些规则固定、性能更高。但是由于我们无法穷尽所有的网站和规则，所以每加入一个网站都需要修改代码，还要重新启动程序，过程比较繁琐。动态的规则构建了Javascript的虚拟机，它会动态解析JS的语法规则。</p><p>其实从我们现在的实现来看，用这些简单的规则就可以支持许多简单的爬取规则。在JS语法中，我们实现了调用Go函数的能力，这让书写JS脚本变得更加简单。我们甚至可以想象这样一个场景，用户只要在页面中选择自己希望爬取的内容，就足够我们生成动态的规则满足客户的爬取需求了。这种商业模式是成立的，用我们现在的技术完全可以实现。</p><p>不过，动态的规则当前的性能确实比不上静态的规则，因为它内部有大量运算、内存分配还有反射的使用。但是在爬虫项目中，很多时候真正的瓶颈是来自于网络I/O。因此通常动态规则带来的灵活性收益要大于其性能的损耗。</p><h2>课后题</h2><p>你认为下面这个最基本的JS脚本，在JS虚拟机内部是如何实现的？</p><pre><code class=\"language-plain\">\tscript := `\n\t\tvar n = 1+2;\n\t\tconsole.log(\"hello-\" + n);   \n    n;\n</code></pre><p>欢迎你在留言区与我交流讨论，我们下节课再见！</p>","neighbors":{"left":{"article_title":"30｜辅助任务管理：任务优先级、去重与失败处理","id":614287},"right":{"article_title":"32｜存储引擎：数据清洗与存储","id":615675}},"comments":[{"had_liked":false,"id":364812,"user_name":"Realm","can_delete":false,"product_type":"c1","uid":1081299,"ip_address":"浙江","ucode":"30CBEBE619D1A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","comment_is_top":false,"comment_ctime":1671529384,"is_pvip":true,"replies":[{"id":134140,"content":"之前写代码时，考虑可以用于任务的优先级排序等功能","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676215380,"ip_address":"北京","comment_id":364812,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"课程渐入佳境了，知识越来越有趣味了。老师，有时间可以把每节课的思考题答疑下，那就更好了。\n\n思考题：\n猜测是用AST抽象语法树+反射，解析js，转成Golang语法。\n\n疑问：\n```\ntype CrawlerStore struct {\n\tlist []*collect.Task\n\thash map[string]*collect.Task\n}\n```\n这个list的设计是用于做什么？好像程序中没有提到。","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603461,"discussion_content":"之前写代码时，考虑可以用于任务的优先级排序等功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676215380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364778,"user_name":"翡翠虎","can_delete":false,"product_type":"c1","uid":1448015,"ip_address":"广西","ucode":"2572E93C4C57A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/4f/9e4d5591.jpg","comment_is_top":false,"comment_ctime":1671479395,"is_pvip":false,"replies":[{"id":134139,"content":"每一个具体的任务的过程都可能有很多个阶段，是比较复杂的，每个阶段还有联系。不能简单的用文本放在数据库中","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676215328,"ip_address":"北京","comment_id":364778,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"设计一个这样的引擎有什么好处？如果把xpath规则或者正则放到数据库，运行的时候随着任务传递给程序，程序按几个预设配置处理，会不会更好？","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603460,"discussion_content":"每一个具体的任务的过程都可能有很多个阶段，是比较复杂的，每个阶段还有联系。不能简单的用文本放在数据库中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676215328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386446,"user_name":"一打七","can_delete":false,"product_type":"c1","uid":1241197,"ip_address":"北京","ucode":"D242C5EF70C176","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/6d/3e570bb8.jpg","comment_is_top":false,"comment_ctime":1704849221,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"不明白为什么是动态的？看着还是写死的代码","like_count":1}]}