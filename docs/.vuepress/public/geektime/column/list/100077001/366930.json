{"id":366930,"title":"03｜Spring Bean 依赖注入常见错误（下）","content":"<p>你好，我是傅健，这节课我们接着聊Spring的自动注入。</p><p>上一讲我们介绍了3个Spring编程中关于依赖注入的错误案例，这些错误都是比较常见的。如果你仔细分析的话，你会发现它们大多都是围绕着@Autowired、@Qualifier的使用而发生，而且自动注入的类型也都是普通对象类型。</p><p>那在实际应用中，我们也会使用@Value等不太常见的注解来完成自动注入，同时也存在注入到集合、数组等复杂类型的场景。这些情况下，我们也会遇到一些问题。所以这一讲我们不妨来梳理下。</p><h2>案例1：@Value没有注入预期的值</h2><p>在装配对象成员属性时，我们常常会使用@Autowired来装配。但是，有时候我们也使用@Value进行装配。不过这两种注解使用风格不同，使用@Autowired一般都不会设置属性值，而@Value必须指定一个字符串值，因为其定义做了要求，定义代码如下：</p><pre><code>public @interface Value {\n\n   /**\n    * The actual value expression &amp;mdash; for example, &lt;code&gt;#{systemProperties.myProp}&lt;/code&gt;.\n    */\n   String value();\n\n}\n</code></pre><p>另外在比较这两者的区别时，<strong>我们一般都会因为@Value常用于String类型的装配而误以为@Value不能用于非内置对象的装配，实际上这是一个常见的误区</strong>。例如，我们可以使用下面这种方式来Autowired一个属性成员：</p><pre><code>@Value(&quot;#{student}&quot;)\nprivate Student student;\n</code></pre><!-- [[[read_end]]] --><p>其中student这个Bean定义如下：</p><pre><code>@Bean\npublic Student student(){\n    Student student = createStudent(1, &quot;xie&quot;);\n    return student;\n}\n</code></pre><p>当然，正如前面提及，我们使用@Value更多是用来装配String，而且它支持多种强大的装配方式，典型的方式参考下面的示例：</p><pre><code>//注册正常字符串\n@Value(&quot;我是字符串&quot;)\nprivate String text; \n\n//注入系统参数、环境变量或者配置文件中的值\n@Value(&quot;${ip}&quot;)\nprivate String ip\n\n//注入其他Bean属性，其中student为bean的ID，name为其属性\n@Value(&quot;#{student.name}&quot;)\nprivate String name;\n</code></pre><p>上面我给你简单介绍了@Value的强大功能，以及它和@Autowired的区别。那么在使用@Value时可能会遇到那些错误呢？这里分享一个最为典型的错误，即使用@Value可能会注入一个不是预期的值。</p><p>我们可以模拟一个场景，我们在配置文件application.properties配置了这样一个属性：</p><pre><code>username=admin\npassword=pass\n</code></pre><p>然后我们在一个Bean中，分别定义两个属性来引用它们：</p><pre><code>@RestController\n@Slf4j\npublic class ValueTestController {\n    @Value(&quot;${username}&quot;)\n    private String username;\n    @Value(&quot;${password}&quot;)\n    private String password;\n \n    @RequestMapping(path = &quot;user&quot;, method = RequestMethod.GET)\n    public String getUser(){\n       return username + &quot;:&quot; + password;\n    };\n}\n</code></pre><p>当我们去打印上述代码中的username和password时，我们会发现password正确返回了，但是username返回的并不是配置文件中指明的admin，而是运行这段程序的计算机用户名。很明显，使用@Value装配的值没有完全符合我们的预期。</p><h3>案例解析</h3><p>通过分析运行结果，我们可以知道@Value的使用方式应该是没有错的，毕竟password这个字段装配上了，但是为什么username没有生效成正确的值？接下来我们就来具体解析下。</p><p>我们首先了解下对于@Value，Spring是如何根据@Value来查询“值”的。我们可以先通过方法DefaultListableBeanFactory#doResolveDependency来了解@Value的核心工作流程，代码如下：</p><pre><code>@Nullable\npublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n    //省略其他非关键代码\n    Class&lt;?&gt; type = descriptor.getDependencyType();\n      //寻找@Value\n      Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n      if (value != null) {\n         if (value instanceof String) {\n            //解析Value值\n            String strVal = resolveEmbeddedValue((String) value);\n            BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ?\n                  getMergedBeanDefinition(beanName) : null);\n            value = evaluateBeanDefinitionString(strVal, bd);\n         }\n         \n         //转化Value解析的结果到装配的类型\n         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n         try {\n            return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());\n         }\n         catch (UnsupportedOperationException ex) {\n            //异常处理\n         }\n      }\n    //省略其他非关键代码\n  }\n</code></pre><p>​可以看到，@Value的工作大体分为以下三个核心步骤。</p><p><strong>1.  寻找@Value</strong></p><p>在这步中，主要是判断这个属性字段是否标记为@Value，依据的方法参考QualifierAnnotationAutowireCandidateResolver#findValue：</p><pre><code>@Nullable\nprotected Object findValue(Annotation[] annotationsToSearch) {\n   if (annotationsToSearch.length &gt; 0) {  \n      AnnotationAttributes attr = AnnotatedElementUtils.getMergedAnnotationAttributes(\n            AnnotatedElementUtils.forAnnotations(annotationsToSearch), this.valueAnnotationType);\n      //valueAnnotationType即为@Value\n      if (attr != null) {\n         return extractValue(attr);\n      }\n   }\n   return null;\n}\n</code></pre><p><strong>2.  解析@Value的字符串值</strong></p><p>如果一个字段标记了@Value，则可以拿到对应的字符串值，然后就可以根据字符串值去做解析，最终解析的结果可能是一个字符串，也可能是一个对象，这取决于字符串怎么写。</p><p><strong>3.  将解析结果转化为要装配的对象的类型</strong></p><p>当拿到第二步生成的结果后，我们会发现可能和我们要装配的类型不匹配。假设我们定义的是UUID，而我们获取的结果是一个字符串，那么这个时候就会根据目标类型来寻找转化器执行转化，字符串到UUID的转化实际上发生在UUIDEditor中：</p><pre><code>public class UUIDEditor extends PropertyEditorSupport {\n\n   @Override\n   public void setAsText(String text) throws IllegalArgumentException          {\n      if (StringUtils.hasText(text)) {\n         //转化操作\n         setValue(UUID.fromString(text.trim()));\n      }\n      else {\n         setValue(null);\n      }\n   }\n   //省略其他非关代码\n  \n}\n</code></pre><p>通过对上面几个关键步骤的解析，我们大体了解了@Value的工作流程。结合我们的案例，很明显问题应该发生在第二步，即解析Value指定字符串过程，执行过程参考下面的关键代码行：</p><pre><code>String strVal = resolveEmbeddedValue((String) value);\n</code></pre><p>这里其实是在解析嵌入的值，实际上就是“替换占位符”工作。具体而言，它采用的是PropertySourcesPlaceholderConfigurer根据PropertySources来替换。不过当使用 ${username} 来获取替换值时，其最终执行的查找并不是局限在application.property文件中的。通过调试，我们可以看到下面的这些“源”都是替换依据：</p><p><img src=\"https://static001.geekbang.org/resource/image/25/40/25d4242bc0dae8fa730663b9122b7840.png?wh=1683*269\" alt=\"\"></p><pre><code>[ConfigurationPropertySourcesPropertySource {name='configurationProperties'}, \nStubPropertySource {name='servletConfigInitParams'}, ServletContextPropertySource {name='servletContextInitParams'}, PropertiesPropertySource {name='systemProperties'}, OriginAwareSystemEnvironmentPropertySource {name='systemEnvironment'}, RandomValuePropertySource {name='random'},\nOriginTrackedMapPropertySource {name='applicationConfig: classpath:/application.properties]'},\nMapPropertySource {name='devtools'}]\n</code></pre><p>而具体的查找执行，我们可以通过下面的代码（PropertySourcesPropertyResolver#getProperty）来获取它的执行方式：</p><pre><code>@Nullable\nprotected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) {\n   if (this.propertySources != null) {\n      for (PropertySource&lt;?&gt; propertySource : this.propertySources) {\n         Object value = propertySource.getProperty(key);\n         if (value != null) {\n         //查到value即退出  \n         return convertValueIfNecessary(value, targetValueType);\n         }\n      }\n   }\n \n   return null;\n}\n</code></pre><p>从这可以看出，在解析Value字符串时，其实是有顺序的（查找的源是存在CopyOnWriteArrayList中，在启动时就被有序固定下来），一个一个“源”执行查找，在其中一个源找到后，就可以直接返回了。</p><p>如果我们查看systemEnvironment这个源，会发现刚好有一个username和我们是重合的，且值不是pass。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/28/eb48b0d27dc7d0dyy32a548934edc728.png?wh=708*381\" alt=\"\"></p><p>所以，讲到这里，你应该知道问题所在了吧？这是一个误打误撞的例子，刚好系统环境变量（systemEnvironment）中含有同名的配置。实际上，对于系统参数（systemProperties）也是一样的，这些参数或者变量都有很多，如果我们没有意识到它的存在，起了一个同名的字符串作为@Value的值，则很容易引发这类问题。</p><h3>问题修正</h3><p>针对这个案例，有了源码的剖析，我们就可以很快地找到解决方案了。例如我们可以避免使用同一个名称，具体修改如下：</p><pre><code>user.name=admin\nuser.password=pass\n</code></pre><p>但是如果我们这么改的话，其实还是不行的。实际上，通过之前的调试方法，我们可以找到类似的原因，在systemProperties这个PropertiesPropertySource源中刚好存在user.name，真是无巧不成书。所以命名时，我们一定要注意<strong>不仅要避免和环境变量冲突，也要注意避免和系统变量等其他变量冲突</strong>，这样才能从根本上解决这个问题。</p><p>通过这个案例，我们可以知道：Spring给我们提供了很多好用的功能，但是这些功能交织到一起后，就有可能让我们误入一些坑，只有了解它的运行方式，我们才能迅速定位问题、解决问题。</p><h2>案例2：错乱的注入集合</h2><p>前面我们介绍了很多自动注入的错误案例，但是这些案例都局限在单个类型的注入，对于集合类型的注入并无提及。实际上，<strong>集合类型的自动注入是Spring提供的另外一个强大功能。</strong></p><p>假设我们存在这样一个需求：存在多个学生Bean，我们需要找出来，并存储到一个List里面去。多个学生Bean的定义如下：</p><pre><code>@Bean\npublic Student student1(){\n    return createStudent(1, &quot;xie&quot;);\n}\n\n@Bean\npublic Student student2(){\n    return createStudent(2, &quot;fang&quot;);\n}\n\nprivate Student createStudent(int id, String name) {\n    Student student = new Student();\n    student.setId(id);\n    student.setName(name);\n    return student;\n}\n</code></pre><p>有了集合类型的自动注入后，我们就可以把零散的学生Bean收集起来了，代码示例如下：</p><pre><code>@RestController\n@Slf4j\npublic class StudentController {\n\n    private List&lt;Student&gt; students;\n\n    public StudentController(List&lt;Student&gt; students){\n        this.students = students;\n    }\n\n    @RequestMapping(path = &quot;students&quot;, method = RequestMethod.GET)\n    public String listStudents(){\n       return students.toString();\n    };\n\n}\n</code></pre><p>通过上述代码，我们就可以完成集合类型的注入工作，输出结果如下：</p><blockquote>\n<p>[Student(id=1, name=xie), Student(id=2, name=fang)]</p>\n</blockquote><p>然而，业务总是复杂的，需求也是一直变动的。当我们持续增加一些student时，可能就不喜欢用这种方式来注入集合类型了，而是倾向于用下面的方式去完成注入工作：</p><pre><code>@Bean\npublic List&lt;Student&gt; students(){\n    Student student3 = createStudent(3, &quot;liu&quot;);\n    Student student4 = createStudent(4, &quot;fu&quot;);\n    return Arrays.asList(student3, student4);\n} \n</code></pre><p>为了好记，这里我们不妨将上面这种方式命名为“直接装配方式”，而将之前的那种命名为“收集方式”。</p><p>实际上，如果这两种方式是非此即彼的存在，自然没有任何问题，都能玩转。但是如果我们不小心让这2种方式同时存在了，结果会怎样？</p><p>这时候很多人都会觉得Spring很强大，肯定会合并上面的结果，或者认为肯定是以直接装配结果为准。然而，当我们运行起程序，就会发现后面的注入方式根本没有生效。即依然返回的是前面定义的2个学生。为什么会出现这样的错误呢？</p><h3>案例解析</h3><p>要了解这个错误的根本原因，你就得先清楚这两种注入风格在Spring中是如何实现的。对于收集装配风格，Spring使用的是DefaultListableBeanFactory#resolveMultipleBeans来完成装配工作，针对本案例关键的核心代码如下：</p><pre><code>private Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName,\n      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n   final Class&lt;?&gt; type = descriptor.getDependencyType();\n   if (descriptor instanceof StreamDependencyDescriptor) {\n      //装配stream\n      return stream;\n   }\n   else if (type.isArray()) {\n      //装配数组\n      return result;\n   }\n   else if (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) {\n      //装配集合\n      //获取集合的元素类型\n      Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();\n      if (elementType == null) {\n         return null;\n      }\n      //根据元素类型查找所有的bean\n      Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,\n            new MultiElementDescriptor(descriptor));\n      if (matchingBeans.isEmpty()) {\n         return null;\n      }\n      if (autowiredBeanNames != null) {\n         autowiredBeanNames.addAll(matchingBeans.keySet());\n      }\n      //转化查到的所有bean放置到集合并返回\n      TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n      Object result = converter.convertIfNecessary(matchingBeans.values(), type);\n      //省略非关键代码\n      return result;\n   }\n   else if (Map.class == type) {\n      //解析map\n      return matchingBeans;\n   }\n   else {\n      return null;\n   }\n}\n</code></pre><p>到这，我们就不难概括出这种收集式集合装配方式的大体过程了。</p><p><strong>1.  获取集合类型的元素类型</strong></p><p>针对本案例，目标类型定义为List&lt;Student&gt; students，所以元素类型为Student，获取的具体方法参考代码行：</p><blockquote>\n<p>Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</p>\n</blockquote><p><strong>2.  根据元素类型，找出所有的Bean</strong></p><p>有了上面的元素类型，即可根据元素类型来找出所有的Bean，关键代码行如下：</p><blockquote>\n<p>Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType, new MultiElementDescriptor(descriptor));</p>\n</blockquote><p><strong>3.  将匹配的所有的Bean按目标类型进行转化</strong></p><p>经过步骤2，我们获取的所有的Bean都是以java.util.LinkedHashMap.LinkedValues形式存储的，和我们的目标类型大概率不同，所以最后一步需要做的是<strong>按需转化</strong>。在本案例中，我们就需要把它转化为List，转化的关键代码如下：</p><blockquote>\n<p>Object result = converter.convertIfNecessary(matchingBeans.values(), type);</p>\n</blockquote><p>如果我们继续深究执行细节，就可以知道最终是转化器CollectionToCollectionConverter来完成这个转化过程。</p><p>学习完收集方式的装配原理，我们再来看下直接装配方式的执行过程，实际上这步在前面的课程中我们就提到过（即DefaultListableBeanFactory#findAutowireCandidates方法执行），具体的执行过程这里就不多说了。</p><p>知道了执行过程，接下来无非就是根据目标类型直接寻找匹配的Bean。在本案例中，就是将Bean名称为students的List&lt;Student&gt;装配给StudentController#students属性。</p><p>了解了这两种方式，我们再来思考这两种方式的关系：当同时满足这两种装配方式时，Spring是如何处理的？这里我们可以参考方法DefaultListableBeanFactory#doResolveDependency的几行关键代码，代码如下：</p><pre><code>Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\nif (multipleBeans != null) {\n   return multipleBeans;\n}\nMap&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n</code></pre><p>很明显，这两种装配集合的方式是<strong>不能同存</strong>的，结合本案例，当使用收集装配方式来装配时，能找到任何一个对应的Bean，则返回，如果一个都没有找到，才会采用直接装配的方式。说到这里，你大概能理解为什么后期以List方式直接添加的Student Bean都不生效了吧。</p><h3>问题修正</h3><p>现在如何纠正这个问题就变得简单多了，就是你一定要下意识地避免这2种方式共存去装配集合，只用一个这个问题就迎刃而解了。例如，在这里，我们可以使用直接装配的方式去修正问题，代码如下：</p><pre><code>@Bean\npublic List&lt;Student&gt; students(){\n    Student student1 = createStudent(1, &quot;xie&quot;);\n    Student student2 = createStudent(2, &quot;fang&quot;);\n    Student student3 = createStudent(3, &quot;liu&quot;);\n    Student student4 = createStudent(4, &quot;fu&quot;);\n    return Arrays.asList(student1，student2，student3, student4);\n}\n</code></pre><p>也可以使用收集方式来修正问题时，代码如下：</p><pre><code>    @Bean\n    public Student student1(){\n        return createStudent(1, &quot;xie&quot;);\n    }\n    @Bean\n    public Student student2(){\n        return createStudent(2, &quot;fang&quot;);\n    }\n    @Bean\n    public Student student3(){\n        return createStudent(3, &quot;liu&quot;);\n    }\n    @Bean\n    public Student student4(){\n        return createStudent(4, &quot;fu&quot;);\n    }\n</code></pre><p>总之，都是可以的。还有一点要注意：<strong>在对于同一个集合对象的注入上，混合多种注入方式是不可取的，这样除了错乱，别无所得。</strong></p><h2>重点回顾</h2><p>今天我们又学习了关于Spring自动注入的两个典型案例。</p><p>通过案例1的学习，我们了解到@Value不仅可以用来注入String类型，也可以注入自定义对象类型。同时在注入String时，你一定要意识到它不仅仅可以用来引用配置文件里配置的值，也可能引用到环境变量、系统参数等。</p><p>而通过案例2的学习，我们了解到集合类型的注入支持两种常见的方式，即上文中我们命名的收集装配式和直接装配式。这两种方式共同装配一个属性时，后者就会失效。</p><p>综合上一讲的内容，我们一共分析了5个问题以及背后的原理，通过这些案例的分析，我们不难看出Spring的自动注入非常强大，围绕@Autowired、@Qualifier、@Value等内置注解，我们可以完成不同的注入目标和需求。不过这种强大，正如我在<a href=\"https://time.geekbang.org/column/article/364661\">开篇词</a>中提及的，它建立在很多隐性的规则之上。只有你把这些规则都烂熟于心了，才能很好地去规避问题。</p><h2>思考题</h2><p>在案例2中，我们初次运行程序获取的结果如下：</p><blockquote>\n<p>[Student(id=1, name=xie), Student(id=2, name=fang)]</p>\n</blockquote><p>那么如何做到让学生2优先输出呢？</p><p>我们留言区见！</p>","neighbors":{"left":{"article_title":"02｜Spring Bean 依赖注入常见错误（上）","id":366170},"right":{"article_title":"04｜Spring Bean 生命周期常见错误","id":367876}},"comments":[{"had_liked":false,"id":297957,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1623854264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"164832611512","product_id":100077001,"comment_content":"思考题：<br>方法一：添加@Order(number)注解，number越小优先级越高，越靠前<br>方法二：声明Student这些Bean时将id=2的Student提到id=1之前<br><br>","like_count":39},{"had_liked":false,"id":290505,"user_name":"笨鱼","can_delete":false,"product_type":"c1","uid":1080625,"ip_address":"","ucode":"FF99952DBD448C","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/31/fd301a35.jpg","comment_is_top":false,"comment_ctime":1619593836,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"27389397612","product_id":100077001,"comment_content":"StudentController构造函数上不需要加@Autowired注解吗？","like_count":6,"discussions":[{"author":{"id":2594123,"avatar":"https://static001.geekbang.org/account/avatar/00/27/95/4b/9b50efe3.jpg","nickname":"安眠","note":"","ucode":"94AC6BE1FFD257","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384199,"discussion_content":"显示声明构造器的时候，bean创建，就是走声明的构造器创建，参数的bean对象，会在Spring容器中查找","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626421951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1375256,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","nickname":"TANMIYOO","note":"","ucode":"BC3556131D4D61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371416,"discussion_content":"spring bean定义常见错误你是咋学的?","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1619764245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168960,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/40/e1a51ac1.jpg","nickname":"Washington","note":"","ucode":"00F5F36416147D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371317,"discussion_content":"通过构造函数注入不需要加@Autowired","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1619725418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290278,"user_name":"Ball","can_delete":false,"product_type":"c1","uid":1521451,"ip_address":"","ucode":"1EE949E68D84CA","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/2b/b32f1d66.jpg","comment_is_top":false,"comment_ctime":1619483297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27389287073","product_id":100077001,"comment_content":"今天的课程给出的问题直击业务痛点！我们非常方便的使用依赖注入的特性时，必须要思考🤔对象从哪里注入、怎么创建、为什么是注入这一个对象的。虽然编写框架的目的是让开发人员无需关心太多底层细节，能专心业务逻辑的开发，但是作为开发人员不能真的无脑去使用框架。<br>另外，我还得学会注入集合等高级用法，之前业务上都是用的注入单个对象的简单用法，必须有所提升。","like_count":6},{"had_liked":false,"id":319312,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1635738925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10225673517","product_id":100077001,"comment_content":"不错，学习了","like_count":2},{"had_liked":false,"id":292472,"user_name":"暖色浮余生","can_delete":false,"product_type":"c1","uid":1593126,"ip_address":"","ucode":"ED943F2DF88896","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/26/f21afb83.jpg","comment_is_top":false,"comment_ctime":1620833218,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10210767810","product_id":100077001,"comment_content":"发现一个问题。通过收集模式获取。比如我得 StudentController 类中通过 @Bean 的方式声明一个 bean 的时候，收集模式并不会收集到当前声明的这个 Student bean。当我的 @Bean 标注的方法为 static 的时候，收集模式此时收集到的是 3 个 bean. 感觉大概是当我的 bean 实例化完成之后才会调用 @Bean 标注的非静态方法，因为实例化未完成无法调用。 而静态方法并不依赖 bean 实例化。没找到具体的代码","like_count":2,"discussions":[{"author":{"id":2227949,"avatar":"https://static001.geekbang.org/account/avatar/00/21/fe/ed/a37ce1e3.jpg","nickname":"C","note":"","ucode":"E7743DB82C5B55","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405787,"discussion_content":"对，你的想法是对的。@Bean标注的方法声明在类内部时，会通过ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod加载，如果方法不是static修饰的将会设置@Bean所属AbstractBeanDefinition的factoryBeanName属性，BeanFactory在实例化@Bean所属的实例时(AbstractAutowireCapableBeanFactory#createBeanInstance)，发现AbstractBeanDefinition的factoryBeanName不为空时，会调用AbstractAutowireCapableBeanFactory#instantiateUsingFactoryMethod，该方法会将factoryBeanName所指向的Bean创建出来，然后通过反射调用该Bean标记为@Bean的方法获取执行结果(也就是要创建的Bean)，然后放入BeanFactory中。当然，这一切还需要你去求证，我看的Spring版本是5.3.5。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634646387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382393,"discussion_content":"ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod 会处理static 和非静态的bean","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625555326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382392,"discussion_content":"ConfigurationClassParser#retrieveBeanMethodMetadata","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625554911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290241,"user_name":"qlmmys","can_delete":false,"product_type":"c1","uid":1558222,"ip_address":"","ucode":"B9C6B37FF80F06","user_header":"https://static001.geekbang.org/account/avatar/00/17/c6/ce/c1376d80.jpg","comment_is_top":false,"comment_ctime":1619445524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10209380116","product_id":100077001,"comment_content":"思考题<br>spring按照bean声明的顺序加载bean，并顺序保存。所以想让学生2优先输出，主需要优先声明学生2即可","like_count":2},{"had_liked":false,"id":290227,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1619441587,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10209376179","product_id":100077001,"comment_content":"思考题：<br>收集装配风格：只能通过实体类实现Ordered接口 getOrder方法中指定一个顺序<br>直接装配方式：除了上述方式，还可以@Order 、@Priority注解指定顺序。","like_count":2,"discussions":[{"author":{"id":1122971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/9b/e948d5c3.jpg","nickname":"Nightwish","note":"","ucode":"29CC83987C6134","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374349,"discussion_content":"这些注解或者接口是怎么确定顺序的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621148498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326262,"user_name":"Geek7319","can_delete":false,"product_type":"c1","uid":2854210,"ip_address":"","ucode":"47B5934C973BD6","user_header":"","comment_is_top":false,"comment_ctime":1639452077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5934419373","product_id":100077001,"comment_content":"针对问题1，是否可以可以使用@PropertySource配置文件路径呢。 从固定配置文件路径抽取value值，就无需考虑多个配置文件命名冲突问题","like_count":1},{"had_liked":false,"id":292847,"user_name":"虹炎","can_delete":false,"product_type":"c1","uid":1600615,"ip_address":"","ucode":"9E28ACEBFB26D5","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/67/07bcc58f.jpg","comment_is_top":false,"comment_ctime":1621007998,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5915975294","product_id":100077001,"comment_content":"控制spring bean加载顺序：<br>1，Bean上使用@Order注解，如@Order(2)。数值越小表示优先级越高。默认优先级最低。<br>2，@DependsOn    使用它，可使得依赖的Bean如果未被初始化会被优先初始化。","like_count":1,"discussions":[{"author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582683,"discussion_content":"@DependsOn不行，是不是因为初始化的顺序和注入的顺序无关 ？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659596309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331611,"avatar":"https://static001.geekbang.org/account/avatar/00/14/51/9b/ccea47d9.jpg","nickname":"安迪密恩","note":"","ucode":"A6F3F67CF8E6F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555011,"discussion_content":"@DependsOn 不好用啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646721803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354933,"user_name":"陌兮","can_delete":false,"product_type":"c1","uid":1415619,"ip_address":"广东","ucode":"00CE47CAECD5CD","user_header":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","comment_is_top":false,"comment_ctime":1660894113,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660894113","product_id":100077001,"comment_content":"@Value这个点是之前从来没有考虑到的","like_count":0},{"had_liked":false,"id":332210,"user_name":"子夜枯灯","can_delete":false,"product_type":"c1","uid":1359678,"ip_address":"","ucode":"5D84BFE7832038","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/3e/cdc36608.jpg","comment_is_top":false,"comment_ctime":1643097236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643097236","product_id":100077001,"comment_content":"添加@Order(number)注解，number越小优先级越高，越靠前","like_count":0},{"had_liked":false,"id":291159,"user_name":"arch","can_delete":false,"product_type":"c1","uid":1078931,"ip_address":"","ucode":"A69EBFE0520B85","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/93/64ed7385.jpg","comment_is_top":false,"comment_ctime":1620060460,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"1620060460","product_id":100077001,"comment_content":"StudentController构造函数上应该需要加@Autowired注解","like_count":0,"discussions":[{"author":{"id":1366631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/67/73a0c754.jpg","nickname":"gallifrey","note":"","ucode":"A4E5E0E7E2DEF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569553,"discussion_content":"详见01 | Spring Bean 定义常见错误 案例2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651477573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331611,"avatar":"https://static001.geekbang.org/account/avatar/00/14/51/9b/ccea47d9.jpg","nickname":"安迪密恩","note":"","ucode":"A6F3F67CF8E6F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555013,"discussion_content":"不需要的。自己试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646721962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2450893,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/L8EpqHoAnmvkzCIsdOkv5QvhIzu5tMaF2FDusXShqukv5ZBkS8DbicWaErjnYydibiaqBrs70wQ8P6axvC2FbWpbQ/132","nickname":"Geek_d3928c","note":"","ucode":"7CB09FD1F7CB23","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553597,"discussion_content":"构造函数注入了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645975214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290200,"user_name":"陈越","can_delete":false,"product_type":"c1","uid":1007632,"ip_address":"","ucode":"C27ED9BE19913E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/10/2c533d89.jpg","comment_is_top":false,"comment_ctime":1619427259,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619427259","product_id":100077001,"comment_content":"order注解<br>实现ordered接口","like_count":0}]}