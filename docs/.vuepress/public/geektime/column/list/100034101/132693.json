{"id":132693,"title":"11 | 语义分析（上）：如何建立一个完善的类型系统？","content":"<p>在做语法分析时我们可以得到一棵语法树，而基于这棵树能做什么，是语义的事情。比如，+号的含义是让两个数值相加，并且通常还能进行缺省的类型转换。所以，如果要区分不同语言的差异，不能光看语言的语法。比如Java语言和JavaScript在代码块的语法上是一样的，都是用花括号，但在语义上是不同的，一个有块作用域，一个没有。</p><p>这样看来，相比词法和语法的设计与处理，语义设计和分析似乎要复杂很多。虽然我们借作用域、生存期、函数等特性的实现涉猎了很多语义分析的场景，但离系统地掌握语义分析，还差一点儿火候。所以，为了帮你攻破语义分析这个阶段，我会用两节课的时间，再梳理一下语义分析中的重要知识，让你更好地建立起相关的知识脉络。</p><p>今天这节课，我们把注意力集中在<strong>类型系统</strong>这个话题上。</p><p>围绕类型系统产生过一些争论，有的程序员会拥护动态类型语言，有的会觉得静态类型语言好。要想探究这个问题，我们需要对类型系统有个清晰的了解，最直接的方式，就是建立一个完善的类型系统。</p><p>那么什么是类型系统？我们又该怎样建立一个完善的类型系统呢？</p><p>其实，类型系统是一门语言所有的类型的集合，操作这些类型的规则，以及类型之间怎么相互作用的（比如一个类型能否转换成另一个类型）。如果要建立一个完善的类型系统，形成对类型系统比较完整的认知，需要从两个方面出发：</p><!-- [[[read_end]]] --><ul>\n<li>根据领域的需求，设计自己的类型系统的特征。</li>\n<li>在编译器中支持类型检查、类型推导和类型转换。</li>\n</ul><p>先从第一个方面出发看一下。</p><h2>设计类型系统的特征</h2><p>在进入这个话题之前，我想先问你一个有意义的问题：类型到底是什么？我们说一个类型的时候，究竟在说什么？</p><p>要知道，在机器代码这个层面，其实是分不出什么数据类型的。在机器指令眼里，那就是0101，它并不对类型做任何要求，不需要知道哪儿是一个整数，哪儿代表着一个字符，哪儿又是内存地址。你让它做什么操作都可以，即使这个操作没有意义，比如把一个指针值跟一个字符相加。</p><p>那么高级语言为什么要增加类型这种机制呢？</p><p>对类型做定义很难，但大家公认的有一个说法：类型是针对一组数值，以及在这组数值之上的一组操作。比如，对于数字类型，你可以对它进行加减乘除算术运算，对于字符串就不行。</p><p>所以，类型是高级语言赋予的一种语义，有了类型这种机制，就相当于定了规矩，可以检查施加在数据上的操作是否合法。因此类型系统最大的好处，就是可以通过类型检查降低计算出错的概率。所以，现代计算机语言都会精心设计一个类型系统，而不是像汇编语言那样完全不区分类型。</p><p>不过，类型系统的设计有很多需要取舍和权衡的方面，比如：</p><ul>\n<li>面向对象的拥护者希望所有的类型都是对象，而重视数据计算性能的人认为应该支持非对象化的基础数据类型；</li>\n<li>你想把字符串作为原生数据类型，还是像Java那样只是一个普通的类？</li>\n<li>是静态类型语言好还是动态类型语言好？</li>\n<li>……</li>\n</ul><p>虽然类型系统的设计有很多需要取舍和权衡的方面，但它最需要考虑的是，是否符合这门语言想解决的问题，我们用静态类型语言和动态类型语言分析一下。</p><p>根据类型检查是在编译期还是在运行期进行的，我们可以把计算机语言分为两类：</p><ul>\n<li>静态类型语言（全部或者几乎全部的类型检查是在编译期进行的）。</li>\n<li>动态类型语言（类型的检查是在运行期进行的）。</li>\n</ul><p>静态类型语言的拥护者说：</p><blockquote>\n<p>因为编译期做了类型检查，所以程序错误较少，运行期不用再检查类型，性能更高。像C、Java和Go语言，在编译时就对类型做很多处理，包括检查类型是否匹配，以及进行缺省的类型转换，大大降低了程序出错的可能性，还能让程序运行效率更高，因为不需要在运行时再去做类型检查和转换。</p>\n</blockquote><p>而动态类型语言的拥护者说：</p><blockquote>\n<p>静态语言太严格，还要一遍遍编译，编程效率低，用动态类型语言方便进行快速开发。JavaScript、Python、PHP等都是动态类型的。</p>\n</blockquote><p>客观地讲，这些说法都有道理。目前的趋势是，某些动态类型语言在想办法增加一些机制，在编译期就能做类型检查，比如用TypeScript代替JavaScript编写程序，做完检查后再输出成JavaScript。而某些静态语言呢，却又发明出一些办法，部分地绕过类型检查，从而提供动态类型语言的灵活性。</p><p>再延伸一下，跟静态类型和动态类型概念相关联的，还有强类型和弱类型。强类型语言中，变量的类型一旦声明就不能改变，弱类型语言中，变量类型在运行期时可以改变。二者的本质区别是，强类型语言不允许违法操作，因为能够被检查出来，弱类型语言则从机制上就无法禁止违法操作，所以是不安全的。比如你写了一个表达式a*b。如果a和b这两个变量是数值，这个操作就没有问题，但如果a或b不是数值，那就没有意义了，弱类型语言可能就检查不出这类问题。</p><p>也就是，静态类型和动态类型说的是什么时候检查的问题，强类型和弱类型说的是就算检查，也检查不出来，或者没法检查的问题，<strong>这两组概念经常会被搞混，所以我在这里带你了解一下。</strong></p><p>接着说回来。关于类型特征的取舍，是根据领域问题而定的。举例来说，很多人可能都觉得强类型更好，但对于儿童编程启蒙来说，他们最好尽可能地做各种尝试，如果必须遵守与类型有关的规则，程序总是跑不起来，可能会打击到他们。</p><p>对于playscript而言，因为目前是用来做教学演示的，所以我们尽可能地多涉及与类型处理有关的情况，供大家体会算法，或者在自己的工作中借鉴。</p><p>首先，playscript是静态类型和强类型的，所以几乎要做各种类型检查，你可以参考看看这些都是怎么做的。</p><p>第二，我们既支持对象，也支持原生的基础数据类型。这两种类型的处理特点不一样，你也可以借鉴一下。后面面向对象的一讲，我会再讲与之相关的子类型（Subtyping）和运行时类型信息（Run Time Type Information, RTTI）的概念，这里就不展开了。</p><p>第三，我们还支持函数作为一等公民，也就是支持函数的类型。函数的类型是它的原型，包括返回值和参数，原型一样的函数，就看做是同样类型的，可以进行赋值。这样，你也就可以了解实现函数式编程特性时，要处理哪些额外的类型问题。</p><p>接下来，我们来说一说如何做类型检查、类型推导和类型转换。</p><h2>如何做类型检查、类型推导和类型转换</h2><p>先来看一看，如果编写一个编译器，我们在做类型分析时会遇到哪些问题。以下面这个最简单的表达式为例，这个表达式在不同的情况下会有不同的运行结果：</p><pre><code>a = b + 10 \n</code></pre><ul>\n<li>如果b是一个浮点型，b+10的结果也是浮点型。如果b是字符串型的，有些语言也是允许执行+号运算的，实际的结果是字符串的连接。这个分析过程，就是<strong>类型推导（Type Inference）。</strong></li>\n<li>当右边的值计算完，赋值给a的时候，要检查左右两边的类型是否匹配。这个过程，就是<strong>类型检查（Type Checking）。</strong></li>\n<li>如果a的类型是浮点型，而右边传过来的是整型，那么一般就要进行缺省的<strong>类型转换（Type Conversion）。</strong></li>\n</ul><p>类型的检查、推导和转换是三个工作，可是采用的技术手段差不多，所以我们放在一起讲，<strong>先来看看类型的推导。</strong></p><p>在早期的playscript的实现中，是假设运算符两边的类型都是整型的，并做了强制转换。</p><p>这在实际应用中，当然不够用，因为我们还需要用到其他的数据类型。那怎么办呢？在运行时再去判断和转换吗？当然可以，但我们还有更好的选择，就是在编译期先判断出表达式的类型来。比如下面这段代码，是在RefResolve.java中，推导表达式的类型：</p><pre><code>case PlayScriptParser.ADD:\n    if (type1 == PrimitiveType.String || \n        type2 == PrimitiveType.String){\n        type = PrimitiveType.String;\n    }\n    else if (type1 instanceof PrimitiveType &amp;&amp; \n             type2 instanceof PrimitiveType){\n        //类型“向上”对齐，比如一个int和一个float，取float\n        type = PrimitiveType.getUpperType(type1,type2);\n    }else{\n        at.log(&quot;operand should be PrimitiveType for additive operation&quot;, ctx);\n    }\n    break;\n</code></pre><p>这段代码提到，如果操作符号两边有一边数据类型是String类型的，那整个表达式就是String类型的。如果是其他基础类型的，就要按照一定的规则进行类型的转换，并确定运算结果的类型。比如，+号一边是double类型的，另一边是int类型的，那就要把int型的转换成double型的，最后计算结果也是double类型的。</p><p>做了类型的推导以后，我们就可以简化运行期的计算，不需要在运行期做类型判断了：</p><pre><code>private Object add(Object obj1, Object obj2, Type targetType) {\n    Object rtn = null;\n    if (targetType == PrimitiveType.String) {\n        rtn = String.valueOf(obj1) + \n              String.valueOf(obj2);\n    } else if (targetType == PrimitiveType.Integer) {\n        rtn = ((Number)obj1).intValue() + \n              ((Number)obj2).intValue();\n    } else if (targetType == PrimitiveType.Float) {\n        rtn = ((Number)obj1).floatValue()+\n              ((Number)obj2).floatValue(); \n    } \n    ...\n    return rtn;\n}\n</code></pre><p>通过这个类型推导的例子，我们又可以引出<strong>S属性（Synthesized Attribute）</strong>的知识点。如果一种属性能够从下级节点推导出来，那么这种属性就叫做S属性，字面意思是综合属性，就是在AST中从下级的属性归纳、综合出本级的属性。更准确地说，是通过下级节点和自身来确定的。</p><p><img src=\"https://static001.geekbang.org/resource/image/52/0c/52b4dfe5eb96dfeacd6a018c4e97720c.jpg?wh=1142*472\" alt=\"\"></p><p>与S属性相对应的是<strong>I属性（Inherited Attribute），</strong>也就是继承属性，即AST中某个节点的属性是由上级节点、兄弟节点和它自身来决定的，比如：</p><pre><code>int a;\n</code></pre><p>变量a的类型是int，这个很直观，因为变量声明语句中已经指出了a的类型，但这个类型可不是从下级节点推导出来的，而是从兄弟节点推导出来的。</p><p>在PlayScript.g4中，变量声明的相关语法如下：</p><pre><code>variableDeclarators\n    : typeType variableDeclarator (',' variableDeclarator)*\n    ;\n\nvariableDeclarator\n    : variableDeclaratorId ('=' variableInitializer)?\n    ;\n\nvariableDeclaratorId\n    : IDENTIFIER ('[' ']')*\n    ;\n\ntypeType\n    : (classOrInterfaceType| functionType | primitiveType) ('[' ']')*\n    ;\n</code></pre><p>把int a;这样一个简单的变量声明语句解析成AST，就形成了一棵有两个分枝的树：</p><p><img src=\"https://static001.geekbang.org/resource/image/25/14/2561a3dd309ba662c82a0bc985c2b614.jpg?wh=1142*683\" alt=\"\"></p><p>这棵树的左枝，可以从下向上推导类型，所以类型属性也就是S属性。而右枝则必须从根节点（也就是variableDeclarators）往下继承类型属性，所以对于a这个节点来说，它的类型属性是I属性。</p><p>这里插一句，RefResolver.java实现了PlayScriptListener接口。这样，我们可以用标准的方法遍历AST。代码中的enterXXX()方法表示刚进入这个节点，exitXXX()方法表示退出这个节点，这时所有的子节点都已经遍历过了。在计算S属性时，我一定是在exitXXX()方法中，因为可以利用下级节点的类型推导出自身节点的类型。</p><p>很多现代语言会支持自动类型推导，例如Go语言就有两种声明变量的方式：</p><pre><code>var a int = 10  //第一种\na := 10         //第二种 \n</code></pre><p>第一种方式，a的类型是显式声明的；第二种方式，a的类型是由右边的表达式推导出来<br>\n的。从生成的AST中，你能看到它们都是经历了从下到上的综合，再从上到下的继承的过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/32/39/3229353c78b54db03afaa2a9318b9d39.jpg?wh=1142*401\" alt=\"\"></p><p><strong>说完了类型推导，我们再看看类型检查。</strong></p><p>类型检查主要出现在几个场景中：</p><ul>\n<li>赋值语句（检查赋值操作左边和右边的类型是否匹配）。</li>\n<li>变量声明语句（因为变量声明语句中也会有初始化部分，所以也需要类型匹配）。</li>\n<li>函数传参（调用函数的时候，传入的参数要符合形参的要求）。</li>\n<li>函数返回值（从函数中返回一个值的时候，要符合函数返回值的规定）。</li>\n</ul><p>类型检查还有一个特点：以赋值语句为例，左边的类型，是I属性，是从声明中得到的；右边的类型是S属性，是自下而上综合出来的。当左右两边的类型相遇之后，就要检查二者是否匹配，被赋值的变量要满足左边的类型要求。</p><p>如果匹配，自然没有问题，如果不完全匹配，也不一定马上报错，<strong>而是要看看是否能进行类型转换。</strong>比如，一般的语言在处理整型和浮点型的混合运算时，都能进行自动的转换。像JavaScript和SQL，甚至能够在算术运算时，自动将字符串转换成数字。在MySQL里，运行下面的语句，会得到3，它自动将’2’转换成了数字：</p><pre><code>select 1 + '2';\n</code></pre><p>这个过程其实是有风险的，这就像在强类型的语言中开了一个后门，绕过或部分绕过了编译器的类型检查功能。把父类转成子类的场景中，编译器顶多能检查这两个类之间是否有继承关系，如果连继承关系都没有，这当然能检查出错误，制止这种转换。但一个基类的子类可能是很多的，具体这个转换对不对，只有到运行期才能检查出错误来。C语言因为可以强制做各种转换，这个后门开的就更大了。不过这也是C语言要达到它的设计目的，必须具备的特性。</p><p>关于类型的处理，大家可以参考playscript的示例代码，里面有三个类可以看一看：</p><ul>\n<li>TypeResolver.java（做了自上而下的类型推导，也就是I属性的计算，包括变量- 声明、类的继承声明、函数声明）。</li>\n<li>RefResolver.java（有自下而上的类型推导的逻辑）。</li>\n<li>TypeChecker.java（类型检查）。</li>\n</ul><h2>课程小结</h2><p>本节课我们重点探讨了语义分析和语言设计中的一个重要话题：类型系统。</p><p>理解类型系统，了解它的本质对我们学习语言会有很大的帮助。我希望在这个过程中，你不会再被静态类型和动态类型，强类型和弱类型这样的概念难倒，甚至可以质疑已有的一些观念。比如，如果你仔细研究，会发现静态类型和动态类型不是绝对的，静态类型的语言如Java，也会在运行期去处理一些类型检查。强类型和弱类型可能也不是绝对的，就像C语言，你如果不允许做任何强制类型转换，不允许指针越界，那它也就完全变成强类型的了。</p><p>掌握对计算机语言更深一点儿的理解能力，将会是你学习编译原理的额外回报！</p><h2>一课一思</h2><p>针对今天讲的类型系统的知识，你所熟悉的语言是静态类型的，还是动态类型的？是强类型的，还是弱类型的？它的类型系统中有哪些你觉得有意思或者引起你困扰的设计？欢迎在留言区分享你的发现。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>本节课相关的示例代码放在文末，供你参考。</p><ul>\n<li>playscript-java（项目目录）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/playscript-java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/playscript-java\">GitHub</a></li>\n<li>PlayScript.g4（语法规则）：     <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4\">GitHub</a></li>\n<li>TypeAndScopeScanner.java（类型和作用域扫描）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeAndScopeScanner.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeAndScopeScanner.java\">GitHub</a></li>\n<li>TypeResolver.java（自上而下的类型推导）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeResolver.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeResolver.java\">GitHub</a></li>\n<li>RefResolver.java（自下而上的类型推导）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/RefResolver.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/RefResolver.java\">GitHub</a></li>\n<li>TypeChecker.java（类型检查）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeChecker.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeChecker.java\">GitHub</a></li>\n</ul><p></p>","neighbors":{"left":{"article_title":"10 | 闭包： 理解了原理，它就不反直觉了","id":131317},"right":{"article_title":"12 | 语义分析（下）：如何做上下文相关情况的处理？","id":133737}},"comments":[{"had_liked":false,"id":139713,"user_name":"智晨","can_delete":false,"product_type":"c1","uid":1122801,"ip_address":"","ucode":"630AAA1548660C","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/f1/e5d6cfe1.jpg","comment_is_top":false,"comment_ctime":1570710378,"is_pvip":false,"replies":[{"id":"54372","content":"我认为，如果想从根本上理解编程语言的类型系统，以及其他学科如社会学、生物学中的分类系统，应该都要理解类型论。因为数学是最最底层的形式体系了。<br>对子类型的严格定义，也最好用数学方式表达。<br>如果有对理论追根究底的兴趣，还是可以研究一下类型论。对于想设计一套类型系统的人来说，本着严谨的态度，也有必要了解类型论。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1571030422,"ip_address":"","comment_id":139713,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35930448746","product_id":100034101,"comment_content":"想请教一下老师，类型论是干什么用的？跟类型系统有什么关系？","like_count":8,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470070,"discussion_content":"我认为，如果想从根本上理解编程语言的类型系统，以及其他学科如社会学、生物学中的分类系统，应该都要理解类型论。因为数学是最最底层的形式体系了。\n对子类型的严格定义，也最好用数学方式表达。\n如果有对理论追根究底的兴趣，还是可以研究一下类型论。对于想设计一套类型系统的人来说，本着严谨的态度，也有必要了解类型论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571030422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132456,"user_name":"janey","can_delete":false,"product_type":"c1","uid":1619748,"ip_address":"","ucode":"B2160B363F23EB","user_header":"https://static001.geekbang.org/account/avatar/00/18/b7/24/17f6c240.jpg","comment_is_top":false,"comment_ctime":1568126176,"is_pvip":false,"replies":[{"id":"50725","content":"同意你的分析:-)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568181166,"ip_address":"","comment_id":132456,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31632897248","product_id":100034101,"comment_content":"C语言是静态类型语言，大部分变量是强类型，但指针是弱类型吧，查不出错啊。Go语言是静态类型语言，但interface 实现接口到运行时才报错又有动态的成份。请老师指正。","like_count":7,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466947,"discussion_content":"同意你的分析:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568181166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400340,"discussion_content":"C语言的char和int类型又是随时代替","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633240183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131868,"user_name":"VVK","can_delete":false,"product_type":"c1","uid":1025748,"ip_address":"","ucode":"6C07E1548DEABA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/d4/84ce26cb.jpg","comment_is_top":false,"comment_ctime":1567945098,"is_pvip":false,"replies":[{"id":"50744","content":"谢谢肯定:-)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568182894,"ip_address":"","comment_id":131868,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27337748874","product_id":100034101,"comment_content":"老师讲的太好了，十几年没搞懂的概念终于理整明白了。","like_count":6,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466654,"discussion_content":"谢谢肯定:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568182894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248166,"user_name":"墨灵","can_delete":false,"product_type":"c1","uid":1409700,"ip_address":"","ucode":"185D70CA20BEEE","user_header":"https://static001.geekbang.org/account/avatar/00/15/82/a4/a92c6eca.jpg","comment_is_top":false,"comment_ctime":1600047761,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10189982353","product_id":100034101,"comment_content":"a = 1 # 变量初始化，假设类型推导成功<br>a + 1 # 两个数值相加，正常执行<br>a = &#39;1&#39; # 如果允许在运行期改变a的类型，则是动态类型，否则是静态类型<br>a + 1 # 如果定义char + int是没意义的，报错的是强类型，不报错是弱类型<br><br>JavaScript是动态类型，也是弱类型；python是动态类型，却是强类型。<br>","like_count":2,"discussions":[{"author":{"id":1114878,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/fe/d539b96b.jpg","nickname":"曹翔","note":"","ucode":"B4D8B42DFB535C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404673,"discussion_content":"Python是弱类型吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634379869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400343,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633240301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151176,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1573660864,"is_pvip":true,"replies":[{"id":"59568","content":"研究技术到最后，一定会研究历史，以及推动历史发展的那些人。我在结束语中提了一些关键的人物。我们仔细研究语言的特性的话，会发现它们传承、发展的脉络，很有意思。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1574667080,"ip_address":"","comment_id":151176,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10163595456","product_id":100034101,"comment_content":"以类型系统实现的原理看已使用了良久的编程语言，有种莫名的亲切感。很好奇编程语言的发展史，以及特定的编程语言是为什么而诞生的，相互间又有什么异同之处。","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474392,"discussion_content":"研究技术到最后，一定会研究历史，以及推动历史发展的那些人。我在结束语中提了一些关键的人物。我们仔细研究语言的特性的话，会发现它们传承、发展的脉络，很有意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574667080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158962,"discussion_content":"历史是个好东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580644673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132125,"user_name":"D","can_delete":false,"product_type":"c1","uid":1027596,"ip_address":"","ucode":"5BB4D16FE39BFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","comment_is_top":false,"comment_ctime":1568027048,"is_pvip":false,"replies":[{"id":"50731","content":"是的:-)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568181984,"ip_address":"","comment_id":132125,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157961640","product_id":100034101,"comment_content":"Java中的封装类，提供了类型系统，好处就是方便使用，符合类型系统规范，坏处是性能损失。","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466779,"discussion_content":"是的:-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568181984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347874,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1654527805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654527805","product_id":100034101,"comment_content":"我是学Rust的，Rust中特别强调生命周期，可变引用，不可变引用这些概念，一开始觉得好像和其他语言差不多，但是学着写了一些代码之后才发现，其实差异会很大，Rust是无gc的，但是又没有C&#47;C++那种高度自由，所以做了很多折中和规矩，因此像Rust的编译原理，后面有机会也想深入了解一下。","like_count":0},{"had_liked":false,"id":335877,"user_name":"hilltsui","can_delete":false,"product_type":"c1","uid":1725302,"ip_address":"","ucode":"D59A02AA45A52F","user_header":"","comment_is_top":false,"comment_ctime":1645751919,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1645751919","product_id":100034101,"comment_content":"老师你好，请问老师你文中说运行程序时机机械码不区分数据类型，但为什么cpu 存在整型运算和浮点运算单元的区别？常说的fpu 。","like_count":0,"discussions":[{"author":{"id":2862304,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/ac/e0/791d0f5e.jpg","nickname":"Geek_ffff","note":"","ucode":"64F06EBE327F57","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583256,"discussion_content":"计算机指令由操作码和操作数组成；操作数没有区分数据类型；但是操作码是有区分类型的，比如在因特尔x86架构下，整数的加法运算的操作码是 ADDL，单精度浮点数的加法运算的操作码是 ADDSS；所以CPU是根据操作数来区分数据类型的。可以看一下汇编语法😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659986220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322569,"user_name":"爱笑的布谷鸟","can_delete":false,"product_type":"c1","uid":2842894,"ip_address":"","ucode":"75E9DDB93E5D24","user_header":"","comment_is_top":false,"comment_ctime":1637484943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637484943","product_id":100034101,"comment_content":"宫老师，类型系统的目的，就是为了做类型检查，这样理解对吗？","like_count":0},{"had_liked":false,"id":316094,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1634131079,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1634131079","product_id":100034101,"comment_content":"不错，对语言有了新的认识","like_count":0},{"had_liked":false,"id":210969,"user_name":"放不下筷子的程序员","can_delete":false,"product_type":"c1","uid":1477966,"ip_address":"","ucode":"A15DBF21BAAF75","user_header":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKzjyzkV7eCLBrTZAsficJHR5iamYpiapqKHiaicuZVzZsPf3uX8gg93XloLDYfNCXwuGsA0zjmIGpfOqg/132","comment_is_top":false,"comment_ctime":1587871853,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587871853","product_id":100034101,"comment_content":"老师您好，我对您第一遍扫描的代码存在一些疑问，就是您的代码中不再为函数创建一个额外的scope，那么类是不是也需要做相同的处理呢？还有就是您为for创建了一个scope，那么while是否也需要创建一个scope呢？","like_count":0,"discussions":[{"author":{"id":1444483,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","nickname":"风","note":"","ucode":"E1CE0825AAF805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401167,"discussion_content":"函数有创建scope，只是不是BlockScope，叫做Function，它继承了Scope，也是一种scope。\nfor的scope是为了像是 for(int i=0; ...) 里的int i 准备的，while不存在这种需求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633587730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201410,"user_name":"dra","can_delete":false,"product_type":"c1","uid":1800186,"ip_address":"","ucode":"5A6B3508851C5F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/77/fa/5fe29602.jpg","comment_is_top":false,"comment_ctime":1585782770,"is_pvip":false,"replies":[{"id":"76609","content":"肯定要回复。最近时间宽裕了些，希望可以回复更及时:)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586513684,"ip_address":"","comment_id":201410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585782770","product_id":100034101,"comment_content":"老师竟然回复了上一位留言。还在维护👍🏼期待老师下一个专栏","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490325,"discussion_content":"肯定要回复。最近时间宽裕了些，希望可以回复更及时:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586513684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}