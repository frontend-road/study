{"id":416722,"title":"09｜所有权：一个值可以有多个所有者么？","content":"<p>你好，我是陈天。</p><p>之前介绍的单一所有权规则，能满足我们大部分场景中分配和使用内存的需求，而且在编译时，通过 Rust 借用检查器就能完成静态检查，不会影响运行时效率。</p><p>但是，规则总会有例外，在日常工作中有些特殊情况该怎么处理呢？</p><ul>\n<li>一个有向无环图（DAG）中，某个节点可能有两个以上的节点指向它，这个按照所有权模型怎么表述？</li>\n<li>多个线程要访问同一块共享内存，怎么办？</li>\n</ul><p>我们知道，这些问题在程序运行过程中才会遇到，在编译期，所有权的静态检查无法处理它们，所以为了更好的灵活性，Rust 提供了<strong>运行时的动态检查</strong>，来满足特殊场景下的需求。</p><p>这也是 Rust 处理很多问题的思路：编译时，处理大部分使用场景，保证安全性和效率；运行时，处理无法在编译时处理的场景，会牺牲一部分效率，提高灵活性。后续讲到静态分发和动态分发也会有体现，这个思路很值得我们借鉴。</p><p>那具体如何在运行时做动态检查呢？运行时的动态检查又如何与编译时的静态检查自洽呢？</p><p>Rust 的答案是使用引用计数的智能指针：<strong>Rc（Reference counter） 和 Arc（Atomic reference counter）</strong>。这里要特别说明一下，Arc 和 ObjC/Swift 里的 ARC（Automatic Reference Counting）不是一个意思，不过它们解决问题的手段类似，都是通过引用计数完成的。</p><!-- [[[read_end]]] --><h2>Rc</h2><p>我们先看 Rc。对某个数据结构 T，我们可以创建引用计数 Rc，使其有多个所有者。Rc 会把对应的数据结构创建在堆上，我们在第二讲谈到过，堆是唯一可以让动态创建的数据被到处使用的内存。</p><pre><code class=\"language-rust\">use std::rc::Rc;\nfn main() {    \n  let a = Rc::new(1);\n}\n</code></pre><p>之后，如果想对数据创建更多的所有者，我们可以通过 clone() 来完成。</p><p><strong>对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数</strong>。而当一个 Rc 结构离开作用域被 drop() 时，也只会减少其引用计数，直到引用计数为零，才会真正清除对应的内存。</p><pre><code class=\"language-rust\">use std::rc::Rc;\nfn main() {\n    let a = Rc::new(1);\n    let b = a.clone();\n    let c = a.clone();\n}\n</code></pre><p>上面的代码我们创建了三个 Rc，分别是 a、b 和 c。它们共同指向堆上相同的数据，也就是说，堆上的数据有了三个共享的所有者。在这段代码结束时，c 先 drop，引用计数变成 2，然后 b drop、a drop，引用计数归零，堆上内存被释放。<img src=\"https://static001.geekbang.org/resource/image/a3/8c/a3510f9b565577bc74bc0dcda0b3e78c.jpg?wh=1920x1300\" alt=\"图片\"></p><p>你也许会有疑问：为什么我们生成了对同一块内存的多个所有者，但是，编译器不抱怨所有权冲突呢？</p><p>仔细看这段代码：首先 a 是 Rc::new(1) 的所有者，这毋庸置疑；然后 b 和 c 都调用了 a.clone()，分别得到了一个新的 Rc，所以从编译器的角度，abc 都各自拥有一个 Rc。如果文字你觉得稍微有点绕，看看 Rc 的 clone() 函数的实现，就很清楚了（<a href=\"https://doc.rust-lang.org/src/alloc/rc.rs.html#1433-1453\">源代码</a>）：</p><pre><code class=\"language-rust\">fn clone(&amp;self) -&gt; Rc&lt;T&gt; {\n    // 增加引用计数\n    self.inner().inc_strong();\n    // 通过 self.ptr 生成一个新的 Rc 结构\n    Self::from_inner(self.ptr)\n}\n</code></pre><p>所以，Rc 的 clone() 正如我们刚才说的，不复制实际的数据，只是一个引用计数的增加。</p><p>你可能继续会疑惑：Rc 是怎么产生在堆上的？并且为什么这段堆内存不受栈内存生命周期的控制呢？</p><h3>Box::leak()机制</h3><p>上一讲我们讲到，在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致。所以 Rc 的实现似乎与此格格不入。的确，如果完全按照上一讲的单一所有权模型，Rust 是无法处理 Rc 这样的引用计数的。</p><p>Rust必须提供一种机制，让代码可以像 C/C++ 那样，<strong>创建不受栈内存控制的堆内存</strong>，从而绕过编译时的所有权规则。Rust 提供的方式是 Box::leak()。</p><p>Box 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致。我们后续讲到智能指针时会详细介绍 Box。</p><p>Box::leak()，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。<img src=\"https://static001.geekbang.org/resource/image/9f/cd/9f1a17dea75f9cae596a56f51d007ccd.jpg?wh=1920x881\" alt=\"图片\"></p><p>所以我们相当于主动撕开了一个口子，允许内存泄漏。注意，在 C/C++ 下，其实你通过 malloc 分配的每一片堆内存，都类似 Rust 下的 Box::leak()。我很喜欢 Rust 这样的设计，它符合最小权限原则（<a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\">Principle of least privilege</a>），最大程度帮助开发者撰写安全的代码。</p><p><strong>有了 Box::leak()，我们就可以跳出 Rust 编译器的静态检查</strong>，保证 Rc 指向的堆内存，有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期。如果你对此感兴趣，可以看 <a href=\"https://doc.rust-lang.org/src/alloc/rc.rs.html#342-350\">Rc::new() 的源码</a>。</p><p>插一句，在学习语言的过程中，不要因为觉得自己是个初学者，就不敢翻阅标准库的源码，相反，遇到不懂的地方，如果你去看对应的源码，得到的是第一手的知识，一旦搞明白，就会学得非常扎实，受益无穷。</p><p>搞明白了 Rc，我们就进一步理解 Rust 是如何进行所有权的静态检查和动态检查了：</p><ul>\n<li>静态检查，靠编译器保证代码符合所有权规则；</li>\n<li>动态检查，通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。</li>\n</ul><h3>实现 DAG</h3><p>现在我们用 Rc 来实现之前无法实现的 DAG。</p><p>假设 Node 就只包含 id 和指向下游（downstream）的指针，因为 DAG 中的一个节点可能被多个其它节点指向，所以我们使用  <code>Rc&lt;Node&gt;</code> 来表述它；一个节点可能没有下游节点，所以我们用  <code>Option&lt;Rc&lt;Node&gt;&gt;</code> 来表述它。<img src=\"https://static001.geekbang.org/resource/image/0c/ab/0c5b0ff12963792a55baa43d3b3054ab.jpg?wh=1920x982\" alt=\"图片\"></p><p>要建立这样一个 DAG，我们需要为 Node 提供以下方法：</p><ul>\n<li>new()：建立一个新的 Node。</li>\n<li>update_downstream()：设置 Node 的 downstream。</li>\n<li>get_downstream()：clone 一份 Node 里的 downstream。</li>\n</ul><p>有了这些方法，我们就可以创建出拥有上图关系的 DAG 了（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=455a14b85949d11a3368019aec7b238b\">代码1</a>）：</p><pre><code class=\"language-rust\">use std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    id: usize,\n    downstream: Option&lt;Rc&lt;Node&gt;&gt;,\n}\n\nimpl Node {\n    pub fn new(id: usize) -&gt; Self {\n        Self {\n            id,\n            downstream: None,\n        }\n    }\n\n    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;Node&gt;) {\n        self.downstream = Some(downstream);\n    }\n\n    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;Node&gt;&gt; {\n        self.downstream.as_ref().map(|v| v.clone())\n    }\n}\n\nfn main() {\n    let mut node1 = Node::new(1);\n    let mut node2 = Node::new(2);\n    let mut node3 = Node::new(3);\n    let node4 = Node::new(4);\n    node3.update_downstream(Rc::new(node4));\n\n    node1.update_downstream(Rc::new(node3));\n    node2.update_downstream(node1.get_downstream().unwrap());\n    println!(\"node1: {:?}, node2: {:?}\", node1, node2);\n}\n</code></pre><h2>RefCell</h2><p>在运行上述代码时，细心的你也许会疑惑：整个 DAG 在创建完成后还能修改么？</p><p>按最简单的写法，我们可以在上面的代码1的  <code>main()</code> 函数后，加入这段代码（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5fc82318fefff9f736391aaac84fbf52\">代码2</a>），来修改 Node3 使其指向一个新的节点 Node5：</p><pre><code class=\"language-rust\">let node5 = Node::new(5);\nlet node3 = node1.get_downstream().unwrap();\nnode3.update_downstream(Rc::new(node5));\n\nprintln!(\"node1: {:?}, node2: {:?}\", node1, node2);\n</code></pre><p>然而，它无法编译通过，编译器会告诉你“node3 cannot borrow as mutable”。</p><p>这是因为<strong>Rc 是一个只读的引用计数器</strong>，你无法拿到 Rc 结构内部数据的可变引用，来修改这个数据。这可怎么办？</p><p>这里，我们需要使用 RefCell。</p><p>和 Rc 类似，RefCell 也绕过了 Rust 编译器的静态检查，允许我们在运行时，对某个只读数据进行可变借用。这就涉及 Rust 另一个比较独特且有点难懂的概念：<a href=\"https://doc.rust-lang.org/book/ch15-05-interior-mutability.html\">内部可变性（interior mutability）</a>。</p><h3>内部可变性</h3><p>有内部可变性，自然能联想到外部可变性，所以我们先看这个更简单的定义，对比着学。</p><p>当我们用  <code>let mut</code> 显式地声明一个可变的值，或者，用  <code>&amp;mut</code> 声明一个可变引用时，编译器可以在编译时进行严格地检查，保证只有可变的值或者可变的引用，才能修改值内部的数据，这被称作外部可变性（exterior mutability），外部可变性通过 <code>mut</code> 关键字声明。</p><p>然而，这样不够灵活，有时候我们希望能够绕开这个编译时的检查，对并未声明成  <code>mut</code> 的值或者引用，也想进行修改。也就是说，<strong>在编译器的眼里，值是只读的，但是在运行时，这个值可以得到可变借用，从而修改内部的数据</strong>，这就是  <code>RefCell</code> 的用武之地。</p><p>我们看一个简单的例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=99c4faa2e3f3a976d3c61c3f82764e28\">代码2</a>）：</p><pre><code class=\"language-rust\">use std::cell::RefCell;\n\nfn main() {\n    let data = RefCell::new(1);\n    {\n        // 获得 RefCell 内部数据的可变借用\n        let mut v = data.borrow_mut();\n        *v += 1;\n    }\n    println!(\"data: {:?}\", data.borrow());\n}\n</code></pre><p>在这个例子里，data 是一个 RefCell，其初始值为 1。可以看到，我们并未将 data 声明为可变变量。之后我们可以通过使用 RefCell 的 <code>borrow_mut()</code> 方法，来获得一个可变的内部引用，然后对它做加 1 的操作。最后，我们可以通过 RefCell 的  <code>borrow()</code> 方法，获得一个不可变的内部引用，因为加了 1，此时它的值为 2。</p><p>你也许奇怪，这里为什么要把获取和操作可变借用的两句代码，用花括号分装到一个作用域下？</p><p>因为根据所有权规则，在同一个作用域下，我们<strong>不能同时有活跃的可变借用和不可变借用</strong>。通过这对花括号，我们明确地缩小了可变借用的生命周期，不至于和后续的不可变借用冲突。</p><p>这里再想一步，如果没有这对花括号，这段代码是无法编译通过？还是运行时会出错（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0af48f1237504aaadbe7da1f1853a838\">代码3</a>）？</p><pre><code class=\"language-rust\">use std::cell::RefCell;\n\nfn main() {\n&nbsp; &nbsp; let data = RefCell::new(1);\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; let mut v = data.borrow_mut();\n&nbsp; &nbsp; *v += 1;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"data: {:?}\", data.borrow());\n}\n</code></pre><p>如果你运行代码3，编译没有任何问题，但在运行到第 9 行时，会得到：“already mutably borrowed: BorrowError” 这样的错误。可以看到，所有权的借用规则在此依旧有效，只不过它在运行时检测。</p><p>这就是外部可变性和内部可变性的重要区别，我们用下表来总结一下：<img src=\"https://static001.geekbang.org/resource/image/94/3c/94bd27a93210ea829482663c9138de3c.jpg?wh=3402x1017\" alt=\"\"></p><h3>实现可修改DAG</h3><p>好，现在我们对 RefCell 有一个直观的印象，看看如何使用它和 Rc 来让之前的 DAG 变得可修改。</p><p>首先数据结构的 downstream 需要 Rc 内部嵌套一个 RefCell，这样，就可以利用 RefCell 的内部可变性，来获得数据的可变借用了，同时 Rc 还允许值有多个所有者。<img src=\"https://static001.geekbang.org/resource/image/62/46/6264d51da5c5e9025abf28d7c0dd2e46.jpg?wh=1920x1324\" alt=\"图片\"></p><p>完整的代码我放到这里了（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=abbb6881ed94a9881ed96ace779d3734\">代码4</a>）：</p><pre><code class=\"language-rust\">use std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    id: usize,\n    // 使用 Rc&lt;RefCell&lt;T&gt;&gt; 让节点可以被修改\n    downstream: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,\n}\n\nimpl Node {\n    pub fn new(id: usize) -&gt; Self {\n        Self {\n            id,\n            downstream: None,\n        }\n    }\n\n    pub fn update_downstream(&amp;mut self, downstream: Rc&lt;RefCell&lt;Node&gt;&gt;) {\n        self.downstream = Some(downstream);\n    }\n\n    pub fn get_downstream(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt; {\n        self.downstream.as_ref().map(|v| v.clone())\n    }\n}\n\nfn main() {\n    let mut node1 = Node::new(1);\n    let mut node2 = Node::new(2);\n    let mut node3 = Node::new(3);\n    let node4 = Node::new(4);\n\n    node3.update_downstream(Rc::new(RefCell::new(node4)));\n    node1.update_downstream(Rc::new(RefCell::new(node3)));\n    node2.update_downstream(node1.get_downstream().unwrap());\n    println!(\"node1: {:?}, node2: {:?}\", node1, node2);\n\n    let node5 = Node::new(5);\n    let node3 = node1.get_downstream().unwrap();\n    // 获得可变引用，来修改 downstream\n    node3.borrow_mut().downstream = Some(Rc::new(RefCell::new(node5)));\n\n    println!(\"node1: {:?}, node2: {:?}\", node1, node2);\n}\n\n</code></pre><p>可以看到，通过使用  <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 这样的嵌套结构，我们的 DAG 也可以正常修改了。</p><h2>Arc 和 Mutex/RwLock</h2><p>我们用 Rc 和 RefCell 解决了 DAG 的问题，那么，开头提到的多个线程访问同一块内存的问题，是否也可以使用 Rc 来处理呢？</p><p>不行。因为 Rc 为了性能，使用的不是线程安全的引用计数器。因此，我们需要另一个引用计数的智能指针：Arc，它实现了线程安全的引用计数器。</p><p>Arc 内部的引用计数使用了 <a href=\"https://doc.rust-lang.org/src/alloc/sync.rs.html#303-312\">Atomic Usize</a> ，而非普通的 usize。从名称上也可以感觉出来，Atomic Usize 是 usize 的原子类型，它使用了 CPU 的特殊指令，来保证多线程下的安全。如果你对原子类型感兴趣，可以看 <a href=\"https://doc.rust-lang.org/std/sync/atomic/index.html\">std::sync::atomic 的文档</a>。</p><p>Rust 实现两套不同的引用计数数据结构，完全是为了性能考虑，从这里我们也可以感受到 Rust 对性能的极致渴求。<strong>如果不用跨线程访问，可以用效率非常高的 Rc；如果要跨线程访问，那么必须用 Arc</strong>。</p><p>同样的，RefCell 也不是线程安全的，如果我们要在多线程中，使用内部可变性，Rust 提供了 Mutex 和 RwLock。</p><p>这两个数据结构你应该都不陌生，Mutex是互斥量，获得互斥量的线程对数据独占访问，RwLock是读写锁，获得写锁的线程对数据独占访问，但当没有写锁的时候，允许有多个读锁。读写锁的规则和 Rust 的借用规则非常类似，我们可以类比着学。</p><p>Mutex 和 RwLock 都用在多线程环境下，对共享数据访问的保护上。刚才中我们构建的 DAG 如果要用在多线程环境下，需要把  <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 替换为  <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或者  <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>。更多有关 Arc/Mutex/RwLock 的知识，我们会在并发篇详细介绍。</p><h2>小结</h2><p>我们对所有权有了更深入的了解，掌握了 Rc / Arc、RefCell / Mutex / RwLock 这些数据结构的用法。</p><p>如果想绕过“一个值只有一个所有者”的限制，我们可以使用 <strong>Rc / Arc 这样带引用计数的智能指针</strong>。其中，Rc 效率很高，但只能使用在单线程环境下；Arc 使用了原子结构，效率略低，但可以安全使用在多线程环境下。</p><p>然而，Rc / Arc 是不可变的，如果想要修改内部的数据，<strong>需要引入内部可变性</strong>，在单线程环境下，可以在 Rc 内部使用 RefCell；在多线程环境下，可以使用 Arc 嵌套 Mutex 或者 RwLock 的方法。</p><p>你可以看这张表快速回顾：<img src=\"https://static001.geekbang.org/resource/image/fc/86/fc524d667fabeec0a8a22d0e10531086.jpg?wh=3387x1982\" alt=\"\"></p><h3>思考题</h3><ol>\n<li>运行下面的代码，查看错误，并阅读 <a href=\"https://doc.rust-lang.org/std/thread/fn.spawn.html\">std::thread::spawn</a> 的文档，找到问题的原因后，修改代码使其编译通过。</li>\n</ol><pre><code class=\"language-rust\">fn main() {\n&nbsp; let arr = vec![1];\n\n&nbsp; std::thread::spawn(|| {\n&nbsp; &nbsp; println!(\"{:?}\", arr);\n&nbsp; });\n}\n</code></pre><ol start=\"2\">\n<li>\n<p>你可以写一段代码，在 main() 函数里生成一个字符串，然后通过  <code>std::thread::spawn</code> 创建一个线程，让 main() 函数所在的主线程和新的线程共享这个字符串么？提示：使用 <a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\">std::sync::Arc</a>。</p>\n</li>\n<li>\n<p>我们看到了 Rc 的 clone() 方法的实现：</p>\n</li>\n</ol><pre><code class=\"language-rust\">fn clone(&amp;self) -&gt; Rc&lt;T&gt; {\n    // 增加引用计数\n    self.inner().inc_strong();\n    // 通过 self.ptr 生成一个新的 Rc 结构\n    Self::from_inner(self.ptr)\n}\n</code></pre><p>你有没有注意到，这个方法传入的参数是  <code>&amp;self</code> ，是个不可变引用，然而它调用了  <code>self.inner().inc_strong()</code> ，光看函数名字，它用来增加 self 的引用计数，可是，为什么这里对 self 的不可变引用可以改变 self 的内部数据呢？</p><p>欢迎在留言区分享你的思考。恭喜你完成了 Rust 学习的第九次打卡，如果你觉得有收获，也欢迎分享给你身边的朋友，邀TA一起讨论。</p><h2>参考资料</h2><ol>\n<li>clone() 函数的<a href=\"https://doc.rust-lang.org/src/alloc/rc.rs.html#1433-1453\">实现源码</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\">最小权限原则</a></li>\n<li>Rc::new() 的<a href=\"https://doc.rust-lang.org/src/alloc/rc.rs.html#342-350\">源码</a></li>\n<li>Arc 内部的引用计数使用了 <a href=\"https://doc.rust-lang.org/src/alloc/sync.rs.html#303-312\">Atomic Usize</a></li>\n<li>Atomic Usize 是 usize 的原子类型： <a href=\"https://doc.rust-lang.org/std/sync/atomic/index.html\">std::sync::atomic 的文档</a></li>\n<li>内部可变性：除了 RefCell  之外，Rust 还提供了 Cell。如果你想对 RefCell 和 Cell 进一步了解，可以看 Rust 标准库里<a href=\"https://doc.rust-lang.org/std/cell/index.html\">cell 的文档</a>。</li>\n</ol>","neighbors":{"left":{"article_title":"08｜所有权：值的借用是如何工作的？","id":415988},"right":{"article_title":"10｜生命周期：你创建的值究竟能活多久？","id":417384}},"comments":[{"had_liked":false,"id":311592,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":true,"comment_ctime":1631328099,"is_pvip":false,"replies":[{"id":"112999","content":"这个世界本就不纯粹，没有绝对的完美。所有的语言都会撕开一道口子，Haskell 也需要 IO Monad 和外界打交道，Erlang VM 也得忍着可能 crash VM 的风险引入 NIF (native function) 等等。不光语言如此，框架也如此，给你解决 80% 问题的利器，也保留让你解决剩下 20% 问题的灵活度。这还只是一个 Box:leak&#47;Box::into_raw&#47;ManuallyDrop，Rust 还有 unsafe 呢...别着急下结论，让子弹飞一会。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516186,"ip_address":"","comment_id":311592,"utype":1}],"discussion_count":5,"race_medal":0,"score":"9.2233722661193994e+18","product_id":100085301,"comment_content":"今天这章我看完以后感觉有一股非常遗憾的情绪：<br>我原本以为rust真的用编译时检查解决了当年C++面临的那些问题。结果最后还是妥协撕开了一道口子开了后门，而且这个后门开的很复杂，我的感觉，这个特性，将来要么就是没什么人用，要么就是被人滥用。这个东西对人的自控要求太高了","like_count":54,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526672,"discussion_content":"这个世界本就不纯粹，没有绝对的完美。所有的语言都会撕开一道口子，Haskell 也需要 IO Monad 和外界打交道，Erlang VM 也得忍着可能 crash VM 的风险引入 NIF (native function) 等等。不光语言如此，框架也如此，给你解决 80% 问题的利器，也保留让你解决剩下 20% 问题的灵活度。这还只是一个 Box:leak/Box::into_raw/ManuallyDrop，Rust 还有 unsafe 呢...别着急下结论，让子弹飞一会。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1631516186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1642586,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/5a/3411221e.jpg","nickname":"Heidi","note":"","ucode":"2751FD284068AA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":590213,"discussion_content":"确实没吹的那么完美，而且开发效率也并不高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665624688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":526672,"ip_address":"上海"},"score":590213,"extra":""},{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":1642586,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/5a/3411221e.jpg","nickname":"Heidi","note":"","ucode":"2751FD284068AA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":590217,"discussion_content":"恩任何语言都有优劣势，根据实际开发需要，理性选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665625768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":590213,"ip_address":"北京"},"score":590217,"extra":""},{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"discussion":{"id":591553,"discussion_content":"存在这种可能吗？只要能用java的，不是java梭哈？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666658681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":590217,"ip_address":"广东"},"score":591553,"extra":""}]},{"author":{"id":1050018,"avatar":"https://static001.geekbang.org/account/avatar/00/10/05/a2/721ae4c6.jpg","nickname":"Jervis","note":"","ucode":"86C02C483449CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591554,"discussion_content":"看到这里同感，确实生产力不友好。不知道有没有优化的计划。  @Tyr","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666658809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338602,"user_name":"清风徐来","can_delete":false,"product_type":"c1","uid":1202697,"ip_address":"","ucode":"2AAA5B8DE30DF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/09/afa3e112.jpg","comment_is_top":true,"comment_ctime":1647590878,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"9.2233720900419994e+18","product_id":100085301,"comment_content":"老师问一个额外的问题<br>以anyhow、clap库为例，通篇看rust技术文档有一种很蒙蔽的感觉，感觉文档只是把技术点拆的很零碎进行说明（如：有哪些struct、trait等），外加一个没有实质性帮助的为例文档代码，感觉和其他语言的技术文档很不一样；一句话来说明：文档描述拆的很零碎，并没有一个清晰地整体的统一使用说明，致使无从下手；这个问题如何解决？？？","like_count":13,"discussions":[{"author":{"id":1200299,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/ab/6584e520.jpg","nickname":"陈顺吉","note":"","ucode":"315732AEA35CD1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565357,"discussion_content":"文档只是生成出来的，这个完全就是库作者偷懒，不愿意写文档","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650447951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2412264,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ce/e8/8b3126d0.jpg","nickname":"小奶精","note":"","ucode":"EB264B3ADC20AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557591,"discussion_content":"同样有这样的感受，在第一次翻看某个库文档时，往往很难找到一个整体的抓手。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647873836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2126729,"avatar":"https://static001.geekbang.org/account/avatar/00/20/73/89/3082c8a1.jpg","nickname":"Jin Se","note":"","ucode":"B731A09BA1BC16","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2412264,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ce/e8/8b3126d0.jpg","nickname":"小奶精","note":"","ucode":"EB264B3ADC20AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578495,"discussion_content":"抓手 你是阿里的吗🐶","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1656832813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":557591,"ip_address":""},"score":578495,"extra":""}]}]},{"had_liked":false,"id":311405,"user_name":"千回百转无劫山","can_delete":false,"product_type":"c1","uid":1456256,"ip_address":"","ucode":"2C249889C00929","user_header":"","comment_is_top":false,"comment_ctime":1631209153,"is_pvip":true,"replies":[{"id":"112849","content":"赞！非常棒的回答。第 3 题其实不用看代码也可以尝试猜一下：当一个只读引用可以修改内部数据时，它一定是用了内部可变性。:)<br><br>一个实际使用的系统一定是符合二八定律的：可以用少量规则来满足 80%的应用场景。但总还有例外需要处理。所以编译期尽管能解决绝大多数的应用场景，但是解决不了的时候，还是需要运行期的检查来弥补。<br><br>这就涉及到如何权衡了。Rust 的选择是最小权限原则，你只有显式地要求（比如数据结构用 Arc&lt;T&gt; 封装），才会进行额外的处理（维护引用计数）。其实这也是我们撰写软件系统时应该遵循的原则。<br><br>谈到滥用，最小权限原则恰恰是为了防止滥用。比如 mut，当你实际不需要的时候，编译器会报警。Rc&#47;Arc 不必要的 clone，clippy（Rust 的 linting 工具） 会提示。<br><br>如果「滥用」智能指针，并不会导致内存安全无法保证，比如你在不需要的时候使用 Arc，损失的是 atomic compare_and_swap 时的性能，但不会带来安全问题。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631237370,"ip_address":"","comment_id":311405,"utype":1}],"discussion_count":3,"race_medal":0,"score":"130480228033","product_id":100085301,"comment_content":"1. 错误为线程借用的arr生命周期可能会长于main函数中的arr，简单处理的话把main中arr的所有权move到线程里即可，编译器对此有详尽的提示：<br>```rust<br>fn main() {<br>    let arr = vec![1];<br><br>    std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    });<br>}<br>```<br>2. 这个问题其实是第1个问题的延续，如果将main中变量的所有权move到线程中，那么在main中将无法访问，所以使用Arc这个智能指针即可实现共享所有权：<br>```rust<br>use std::sync::Arc;<br>fn main() {<br>    let s = Arc::new(&quot;rust rocks!&quot;);<br>    let s1 = s.clone();<br><br>    let handler = std::thread::spawn(move || {<br>        println!(&quot;thread: {:?}&quot;, s1);<br>    });<br>    println!(&quot;main: {:?}&quot;, s);<br>    handler.join().unwrap();<br>}<br>```<br>3. 不太确定，查文档看调用链是inner方法返回了RcBox，RcBox调用的inc_strong是RcInnerPtr这个trait的方法，它会通过调用该trait的strong_ref方法返回cell，而cell是一个可变的共享容器，即最终通过cell共享内存来改变内部数据。<br><br>看完这一小节产生一个疑问，本小节介绍的智能指针都是为了突破rust编译期的所有权规则限制。那为什么要先做限制再提供突破限制的方法呢？这样做的意义是否可以理解为就像unsafe或者最小权限原则一样，大部分情况下，遵循所有权规则，仅在必要的时候使用智能指针来突破限制？如果用户滥用了智能指针，那么是否就像滥用了unsafe一样，rust内存安全等特性就无法保证了？","like_count":30,"discussions":[{"author":{"id":1456256,"avatar":"","nickname":"千回百转无劫山","note":"","ucode":"2C249889C00929","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393071,"discussion_content":"明白了，使用智能指针和使用unsafe还是不同的，感谢老师的回复和lisiur的评论！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1631240500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393062,"discussion_content":"我个人觉得，如果不涉及unsafe，即使滥用智能指针也不会导致内存安全问题（内存泄漏在rust里不算内存安全问题），内部可变性在静态语法上没有突破所有权规则，在运行时其实也还是有动态的所有权规则约束，一旦出现问题就会报错。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1631238867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526588,"discussion_content":"赞！非常棒的回答。第 3 题其实不用看代码也可以尝试猜一下：当一个只读引用可以修改内部数据时，它一定是用了内部可变性。:)\n\n一个实际使用的系统一定是符合二八定律的：可以用少量规则来满足 80%的应用场景。但总还有例外需要处理。所以编译期尽管能解决绝大多数的应用场景，但是解决不了的时候，还是需要运行期的检查来弥补。\n\n这就涉及到如何权衡了。Rust 的选择是最小权限原则，你只有显式地要求（比如数据结构用 Arc&amp;lt;T&amp;gt; 封装），才会进行额外的处理（维护引用计数）。其实这也是我们撰写软件系统时应该遵循的原则。\n\n谈到滥用，最小权限原则恰恰是为了防止滥用。比如 mut，当你实际不需要的时候，编译器会报警。Rc/Arc 不必要的 clone，clippy（Rust 的 linting 工具） 会提示。\n\n如果「滥用」智能指针，并不会导致内存安全无法保证，比如你在不需要的时候使用 Arc，损失的是 atomic compare_and_swap 时的性能，但不会带来安全问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631237370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311441,"user_name":"lisiur","can_delete":false,"product_type":"c1","uid":1201350,"ip_address":"","ucode":"CEB2DBCE29CAA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","comment_is_top":false,"comment_ctime":1631238553,"is_pvip":false,"replies":[{"id":"112855","content":"谢谢你这么有深度的思考！<br><br>编译器是一个不断进化的过程，在基本的规则下，它可以尽可能多地把常见的，并且合法的情况处理掉，不给开发者太多的负担。所以可以引用引入了是否活跃的概念，以及 NLL（https:&#47;&#47;rust-lang.github.io&#47;rfcs&#47;2094-nll.html）。<br><br>对于文中的内部可变性的例子，检查完全有赖正在执行的函数来确保。的确，对于这个例子，在编译期完全有可能把原本在作用域结束时 drop 的 v 提前到 v 使用完的地方：<br><br>```rust<br><br>use std::cell::RefCell;<br><br>fn main() {<br>    let data = RefCell::new(1);<br>    <br>    &#47;&#47; 获得 RefCell 内部数据的可变借用<br>    let mut v = data.borrow_mut();<br>    *v += 1;<br>    &#47;&#47; 提前 drop 可变引用<br>    drop(v);<br>    <br>    println!(&quot;data: {:?}&quot;, data.borrow());<br>    <br>    &#47;&#47; 隐含的 drop<br>    &#47;&#47; 原本 drop(v) 发生在这里<br>    drop(data);<br>}<br>```<br><br>这样可以避免额外的作用域。<br><br>但是，如果这样做，编译器就是在为某个特定的数据结构 RefCell，而非 Rust 的语法单元 &amp;mut 来做优化了。从系统设计的角度，除非能找到一种很通用的方法（比如设计一个新的像 Send&#47;Sync&#47;Unpin 这样的 auto trait 对所有实现了这个 auto trait 的数据结构进行优化），否则，编译器需要知道哪个数据结构在做哪个操作的时候需要特殊处理。这就会让编译器本身的设计变得复杂。<br><br>个人意见，不代表编译器团队的思路 :)<br><br><br>","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631242018,"ip_address":"","comment_id":311441,"utype":1}],"discussion_count":3,"race_medal":0,"score":"117595355545","product_id":100085301,"comment_content":"老师您好，在代码3里，把内部作用域去掉会导致运行时错误，但是如果使用普通的借用方式像这样：<br><br>```rust<br>fn main() {<br>    let mut data = 1;<br>    let v = &amp;mut data;<br>    *v += 1;<br>    println!(&quot;data: {:?}&quot;, &amp;data);<br>}<br>```<br><br>却不需要使用多余的作用域。<br><br>我的理解是普通的借用方式走的是编译期检查，编译器标记借用的生命期的粒度比作用域要小，比如上述代码的 mut 借用，正常的生命期应该是到main函数结束，但是编译器应该是把它缩小到了 println 代码之前的位置，所以 println 的不可变借用并不和上面的可变借用冲突。但是运行时的&quot;生命期检查&quot;应该就是作用域粒度的，所以需要使用额外的作用域来达到手动 drop 可变借用的效果。<br><br>我的想法是，既然编译期能够做到尽可能小的缩小借用的生命周期，那编译器能不能自动对这种特殊的内部可变性的借用在合适的位置插入drop代码，使得不使用额外的作用域也能满足运行时检查呢？","like_count":27,"discussions":[{"author":{"id":2709342,"avatar":"https://static001.geekbang.org/account/avatar/00/29/57/5e/2565df70.jpg","nickname":"揽余月","note":"","ucode":"D75ABAA841C23A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549584,"discussion_content":"可以简化一下代码，让它在当前生命周期没有所有者：\n*data.borrow_mut() += 1;","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1644115154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526605,"discussion_content":"谢谢你这么有深度的思考！\n\n编译器是一个不断进化的过程，在基本的规则下，它可以尽可能多地把常见的，并且合法的情况处理掉，不给开发者太多的负担。所以可以引用引入了是否活跃的概念，以及 NLL（https://rust-lang.github.io/rfcs/2094-nll.html）。\n\n对于文中的内部可变性的例子，检查完全有赖正在执行的函数来确保。的确，对于这个例子，在编译期完全有可能把原本在作用域结束时 drop 的 v 提前到 v 使用完的地方：\n\n```rust\n\nuse std::cell::RefCell;\n\nfn main() {\n    let data = RefCell::new(1);\n    \n    // 获得 RefCell 内部数据的可变借用\n    let mut v = data.borrow_mut();\n    *v += 1;\n    // 提前 drop 可变引用\n    drop(v);\n    \n    println!(&amp;quot;data: {:?}&amp;quot;, data.borrow());\n    \n    // 隐含的 drop\n    // 原本 drop(v) 发生在这里\n    drop(data);\n}\n```\n\n这样可以避免额外的作用域。\n\n但是，如果这样做，编译器就是在为某个特定的数据结构 RefCell，而非 Rust 的语法单元 &amp;amp;mut 来做优化了。从系统设计的角度，除非能找到一种很通用的方法（比如设计一个新的像 Send/Sync/Unpin 这样的 auto trait 对所有实现了这个 auto trait 的数据结构进行优化），否则，编译器需要知道哪个数据结构在做哪个操作的时候需要特殊处理。这就会让编译器本身的设计变得复杂。\n\n个人意见，不代表编译器团队的思路 :)\n\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631242018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069346,"avatar":"https://static001.geekbang.org/account/avatar/00/10/51/22/d12f7a72.jpg","nickname":"TheLudlows","note":"","ucode":"64895727505014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413104,"discussion_content":"这里找到答案了 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636382373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315922,"user_name":"dotfiles","can_delete":false,"product_type":"c1","uid":1217723,"ip_address":"","ucode":"F915599EC2F6E5","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/bb/1c8384a0.jpg","comment_is_top":false,"comment_ctime":1634046776,"is_pvip":false,"replies":[{"id":"115285","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132489,"ip_address":"","comment_id":315922,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53173654328","product_id":100085301,"comment_content":"1. rust由于所有权以及默认不可变等限制,导致最常见的数据结构---链表的实现变得相当复杂,常见的实现使用了3层结构体.<br>Option&lt;&gt;提供空和非空,相关: Some&#47;None<br>Rc&lt;T&gt;提供引用计数,相关: New&#47;clone; 如果为了避免循环引用,还要考虑downgrade&#47;upgrade; 这块和cpp的shared_ptr&#47;weak_ptr类似.<br>RefCell&lt;T&gt;提供内部可变性,基于unsafe机制,提供运行时检查. 相关: borrow&#47;borrow_mut<br><br>2. 内部可变性<br>Rc的引用计数器和RefCell中的数据可变,都是基于unsafe实现的.<br>我们以Rc引用计数器的更新为例:<br>```<br>impl&lt;T&gt; Cell&lt;T&gt; {<br>    pub fn replace(&amp;self, val: T) -&gt; T {<br>        mem::replace(unsafe { &amp;mut *self.value.get() }, val)<br>    }<br>}<br>```<br>如上可以看到,即使replace的参数self是不可变的,也可以通过unsafe去改变其中的值.也就是说rust通过unsafe具有完全的c&#47;c++类似的能力.<br>同理,可以看到Refcell获取可变引用,也是通过unsafe将指针直接转成可变引用.可以想象的是,在RefCell中,还需要通过额外的代码来处理可读不可写,可写不可读的类似读写锁的问题.<br>```<br>impl&lt;T: ?Sized&gt; RefCell&lt;T&gt; {<br>    pub fn try_borrow_mut(&amp;self) -&gt; Result&lt;RefMut&lt;&#39;_, T&gt;, BorrowMutError&gt; {<br>                ...<br>                Ok(RefMut { value: unsafe { &amp;mut *self.value.get() }, borrow: b })<br>                ...<br>}<br>```<br>在rust的设计中,明显推崇将问题尽量在静态编译期解决.实在搞不定的,就是通过unsafe和额外的处理推迟到运行期解决.","like_count":12,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528203,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635132489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311447,"user_name":"noisyes","can_delete":false,"product_type":"c1","uid":2538540,"ip_address":"","ucode":"94EC310B284AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg","comment_is_top":false,"comment_ctime":1631239992,"is_pvip":false,"replies":[{"id":"112858","content":"这就是运行期检查和编译期检查的区别。data.borrow_mut() 产生的 v 会一直活跃到作用域结束，而对于 &amp;mut 编译器可以检查它是否活跃从而让我们撰写代码时不需要额外的作用域。你可以看看我和另一个同学关于这个问题的详细讨论。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631242637,"ip_address":"","comment_id":311447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40285945656","product_id":100085301,"comment_content":"fn main() {<br>    &#47;*let data = RefCell::new(1);<br><br>    let mut v = data.borrow_mut();<br>    *v += 1;<br><br>    println!(&quot;data: {:?}&quot;, data.borrow());<br>    *&#47;<br>    let mut v = vec![1, 2, 3];<br>    let data1 = &amp;mut v[1];<br>    *data1 = 2;<br>    let data2 = &amp;v[1];<br>    println!(&quot;{}&quot;, data2);<br>}<br><br>老师这段代码注释的部分，运行时不能通过，可变借用和不可变借用并没有冲突呀（v并没在borrow之后使用，同一时刻并没有同时有可变借用和不可变借用），我自己写的这部分就是可以编译运行的。","like_count":9,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526607,"discussion_content":"这就是运行期检查和编译期检查的区别。data.borrow_mut() 产生的 v 会一直活跃到作用域结束，而对于 &amp;amp;mut 编译器可以检查它是否活跃从而让我们撰写代码时不需要额外的作用域。你可以看看我和另一个同学关于这个问题的详细讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631242637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311680,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1631386297,"is_pvip":false,"replies":[{"id":"113008","content":"好问题。strong 为 0 时，ptr::drop_in_place 已经把大部分内存释放。但此时可以还有孤悬的 weak reference，它们还是可用的，但无法 upgrade。可以看这个代码：<br><br>```rust<br>use std::rc::{Rc, Weak};<br><br>#[derive(Debug)]<br>struct Foo {<br>    bar: &amp;&#39;static str,<br>}<br><br>impl Drop for Foo {<br>    fn drop(&amp;mut self) {<br>        println!(&quot;dropped!&quot;);<br>    }<br>}<br><br>fn main() {<br>    let foo = Rc::new(Foo { bar: &quot;hello&quot; });<br>    let weak_foo = Rc::downgrade(&amp;foo);<br>    let other_weak_foo = Weak::clone(&amp;weak_foo);<br>    <br>    drop(weak_foo); &#47;&#47; 不会 drop<br>    drop(foo);      &#47;&#47; 打印 dropped!<br>    <br>    &#47;&#47; 此时还有 weak ref 存在<br>    println!(&quot;other weak foo: {:?}&quot;, other_weak_foo);<br>    <br>    &#47;&#47; 无法 upgrade<br>    assert!(other_weak_foo.upgrade().is_none());    <br>}<br>```<br><br>playground: https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ffd75a38877cfd78b6c66d0b13dc1d90","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631517441,"ip_address":"","comment_id":311680,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27401190073","product_id":100085301,"comment_content":"为啥要week == 0的时候才deallocate所有内存呢? 这样是不是不太高效?<br><br>```<br>fn drop(&amp;mut self) {<br>    unsafe {<br>        self.inner().dec_strong();<br>        if self.inner().strong() == 0 {<br>            &#47;&#47; destroy the contained object<br>            ptr::drop_in_place(Self::get_mut_unchecked(self));<br><br>            &#47;&#47; remove the implicit &quot;strong weak&quot; pointer now that we&#39;ve<br>            &#47;&#47; destroyed the contents.<br>            self.inner().dec_weak();<br><br>            if self.inner().weak() == 0 {<br>                Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));<br>            }<br>        }<br>    }<br>}<br>```","like_count":6,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526702,"discussion_content":"好问题。strong 为 0 时，ptr::drop_in_place 已经把大部分内存释放。但此时可以还有孤悬的 weak reference，它们还是可用的，但无法 upgrade。可以看这个代码：\n\n```rust\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Foo {\n    bar: &amp;amp;&amp;#39;static str,\n}\n\nimpl Drop for Foo {\n    fn drop(&amp;amp;mut self) {\n        println!(&amp;quot;dropped!&amp;quot;);\n    }\n}\n\nfn main() {\n    let foo = Rc::new(Foo { bar: &amp;quot;hello&amp;quot; });\n    let weak_foo = Rc::downgrade(&amp;amp;foo);\n    let other_weak_foo = Weak::clone(&amp;amp;weak_foo);\n    \n    drop(weak_foo); // 不会 drop\n    drop(foo);      // 打印 dropped!\n    \n    // 此时还有 weak ref 存在\n    println!(&amp;quot;other weak foo: {:?}&amp;quot;, other_weak_foo);\n    \n    // 无法 upgrade\n    assert!(other_weak_foo.upgrade().is_none());    \n}\n```\n\nplayground: https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=ffd75a38877cfd78b6c66d0b13dc1d90","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631517441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408789,"discussion_content":"进一步解释一下：\ndrop_in_place 那一步应该是调用 T 的 Drop::drop 方法，如果 T 是 Vec，那堆上的内存就被释放了，可如果 T 是 [usize; 10000]，它没有实现 Drop trait（我猜哈），只能在 Global.deallocate 这一步才能释放内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635324782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397361,"discussion_content":"感谢老师! 看了下源码, 如果 `Rc<T>` 中, T的size很大, 而且值都在struct内部, 没有被释放, 比如T是`[usize; 10_000]`; 如果T是Vec类型, 数据就会被提前释放, since data is stored indirectly in another location.\n\n```\npub unsafe fn get_mut_unchecked(this: &amp;mut Self) -> &amp;mut T {\n    // We are careful to *not* create a reference covering the &#34;count&#34; fields, as\n    // this would conflict with accesses to the reference counts (e.g. by `Weak`).\n    unsafe { &amp;mut (*this.ptr.as_ptr()).value }\n}\n\nfn drop(&amp;mut self) {\n    unsafe {\n        self.inner().dec_strong();\n        if self.inner().strong() == 0 {\n            // destroy the contained object\n            ptr::drop_in_place(Self::get_mut_unchecked(self));\n            // remove the implicit &#34;strong weak&#34; pointer now that we&#39;ve\n            // destroyed the contents.\n            self.inner().dec_weak();\n            if self.inner().weak() == 0 {\n                Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n            }\n        }\n    }\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632596967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315333,"user_name":"枸杞红茶","can_delete":false,"product_type":"c1","uid":2738941,"ip_address":"","ucode":"03D80953AF984E","user_header":"https://static001.geekbang.org/account/avatar/00/29/ca/fd/4e6dd31c.jpg","comment_is_top":false,"comment_ctime":1633840081,"is_pvip":false,"replies":[{"id":"115299","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635133450,"ip_address":"","comment_id":315333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18813709265","product_id":100085301,"comment_content":"1. 线程的运行时间可能会比当前函数还要长，而闭包中又借用了arr，使用move将当前函数的arr所有权转移给线程。<br>```<br>use std::thread;<br><br>fn main() {<br>    let arr = vec![1];<br><br>    let handler = thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    });<br>    handler.join().unwrap();<br>}<br>```<br>2. <br>```<br>use std::thread;<br>use std::sync::Arc;<br><br>fn main() {<br>    let five = Arc::new(&quot;hello Tyr&quot;);<br><br>    {<br>        let give_me_five = five.clone();<br>        let handler = thread::spawn(move || {<br>            println!(&quot;thread greeting: {:?}&quot;, give_me_five);<br>        });<br>        handler.join().unwrap();<br>    }<br>    println!(&quot;main greeting: {:?}&quot;, five);<br>}<br>```<br>3. Rc源码中有这么一段，<br>```<br>#[doc(hidden)]<br>trait RcInnerPtr {<br>    fn weak_ref(&amp;self) -&gt; &amp;Cell&lt;usize&gt;;<br>    fn strong_ref(&amp;self) -&gt; &amp;Cell&lt;usize&gt;;<br><br>    #[inline]<br>    fn strong(&amp;self) -&gt; usize {<br>        self.strong_ref().get()<br>    }<br><br>    #[inline]<br>    fn inc_strong(&amp;self) {<br>        let strong = self.strong();<br><br>        &#47;&#47; We want to abort on overflow instead of dropping the value.<br>        &#47;&#47; The reference count will never be zero when this is called;<br>        &#47;&#47; nevertheless, we insert an abort here to hint LLVM at<br>        &#47;&#47; an otherwise missed optimization.<br>        if strong == 0 || strong == usize::MAX {<br>            abort();<br>        }<br>        self.strong_ref().set(strong + 1);<br>    }<br>    ...<br>}<br>```<br>增加计数器```self.inner().inc_strong();```调用的```inc_strong```函数修改的是```strong_ref()```，属于Cell类型，Shareable mutable containers，可共享可修改的容器。","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527937,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635133450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311756,"user_name":"Kerry","can_delete":false,"product_type":"c1","uid":2061524,"ip_address":"","ucode":"92F809EC998FC6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","comment_is_top":false,"comment_ctime":1631446439,"is_pvip":false,"replies":[{"id":"112992","content":"1、2 正确！3 跟 unsafe 关系不大，跟 strong 是 Cell&lt;usize&gt; 实现了内部可变性有关。（当然，内部可变性底层的实现是 unsafe）","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631515163,"ip_address":"","comment_id":311756,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18811315623","product_id":100085301,"comment_content":"课后思考题：<br><br>1. 生命周期问题，主线程可能比派生线程更早结束，导致派生线程引用了过期的值。<br><br>你也许会想到加上join强制派生线程先于主线程结束，以此解决编译问题。然而这是行不通的。这里的问题是语法层面的，而不是语义层面的。<br><br>解决方法有两种：一是move，二是用ARC。方法一的代码如下：<br><br>fn main() {<br>    let arr = vec![1];<br><br>    std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    }).join().unwrap();<br>}<br><br>方法二参考思考题2即可。<br><br>2. 如下所示，用ARC包一下要共享的资源：<br><br>use std::sync::{Arc, RwLock};<br>use std::rc::Rc;<br><br>fn main() {<br>    let s = Arc::new(RwLock::new(&quot;Hello&quot;));<br><br>    let r = s.clone();<br>    std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, r.as_ref().read().unwrap());<br>    }).join().unwrap();<br><br>    println!(&quot;{:?}&quot;, s.as_ref().read().unwrap());<br>}<br><br>3. 是时候步入unsafe的世界了~编译器终究只是帮我们干活，规则再严格，那都是死的。为了提供一定灵活性，会像RefCell这样提供一些机制给我们做一些不安全的操作。通过阅读self.inner().inc_strong()的源码，可以知道底层是通过unsafe实现不可变转可变引用的：<br><br>unsafe { &amp;mut *self.value.get() }<br><br><br>","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526730,"discussion_content":"1、2 正确！3 跟 unsafe 关系不大，跟 strong 是 Cell&amp;lt;usize&amp;gt; 实现了内部可变性有关。（当然，内部可变性底层的实现是 unsafe）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631515163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2061524,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","nickname":"Kerry","note":"","ucode":"92F809EC998FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393644,"discussion_content":"这样看来Rust的内部可见性，跟C++的的“const结构体可以有mutable的成员”是类似的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631531679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311453,"user_name":"夏洛克Moriaty","can_delete":false,"product_type":"c1","uid":2754785,"ip_address":"","ucode":"49BA020F04AB16","user_header":"https://static001.geekbang.org/account/avatar/00/2a/08/e1/b4748943.jpg","comment_is_top":false,"comment_ctime":1631241152,"is_pvip":false,"replies":[{"id":"112875","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631284174,"ip_address":"","comment_id":311453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18811110336","product_id":100085301,"comment_content":"终于理解了Rc的本质了，以前只是知道实现二叉树这种数据结构必须用Rc，因为他允许有多个所有者。但是不理解或者说不知道为什么要有内部可变性和运行时检查这个东西，今天看了Box::leak() 机制的解释终于明白了。","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526610,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631284174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311663,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1784009,"ip_address":"","ucode":"1C064405490769","user_header":"https://static001.geekbang.org/account/avatar/00/1b/38/c9/63ea8fe6.jpg","comment_is_top":false,"comment_ctime":1631371995,"is_pvip":true,"replies":[{"id":"112995","content":"在你用花括号括起 v 的那句，v 的所有权被转移给了 {} 作用域内部，并且由于没有人使用这个花括号的返回值，所以 v 被 drop 了。之后再用 v 就会报错：<br>```rust<br>fn main() {<br>    let mut v = vec![1, 2, 3];<br>    {<br>        v            &#47;&#47; 编译不通过<br>    };<br>    v.push(4);<br>}<br>```<br><br>而使用 v.push()，这里使用了 v 的可变引用，没有问题。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631515596,"ip_address":"","comment_id":311663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14516273883","product_id":100085301,"comment_content":"老师好，关于使用花括号提前结束生命周期这点有一点不明白<br>```rust<br>fn main() {<br>    let mut v = vec![1, 2, 3];<br>    {<br>        v            &#47;&#47; 编译不通过<br>        v.push(3); &#47;&#47;编译通过<br>    };<br>    v.push(4);<br>}<br>```<br>花括号中的两种写法，一种不通过，报错error[E0382]: borrow of moved value: `v`；一种又可以通过，是为什么呢？使用一个花括号增加了一个作用域以后，对于作用域内使用的外部变量的所有权到底产生了怎样的影响呢？","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526695,"discussion_content":"在你用花括号括起 v 的那句，v 的所有权被转移给了 {} 作用域内部，并且由于没有人使用这个花括号的返回值，所以 v 被 drop 了。之后再用 v 就会报错：\n```rust\nfn main() {\n    let mut v = vec![1, 2, 3];\n    {\n        v            // 编译不通过\n    };\n    v.push(4);\n}\n```\n\n而使用 v.push()，这里使用了 v 的可变引用，没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631515596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311452,"user_name":"noisyes","can_delete":false,"product_type":"c1","uid":2538540,"ip_address":"","ucode":"94EC310B284AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg","comment_is_top":false,"comment_ctime":1631241085,"is_pvip":false,"replies":[{"id":"112874","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631284143,"ip_address":"","comment_id":311452,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10221175677","product_id":100085301,"comment_content":"思考题：<br>1. fn main() {<br>    let arr = vec![1];<br>    let handler = std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    });<br>    handler.join().unwrap();<br>}<br><br>2. fn main() {<br>    let ss = Arc::new(String::from(&quot;hello world&quot;));<br>    let ss1 = ss.clone();<br>    let handler = std::thread::spawn(move || {<br>        println!(&quot;{}&quot;, ss1);<br>    });<br>    println!(&quot;{}&quot;, ss);<br>    handler.join().unwrap();<br>}<br><br>3. 还没看源码 应该就是内部可变性吧","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526609,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631284143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311440,"user_name":"葡萄","can_delete":false,"product_type":"c1","uid":1018673,"ip_address":"","ucode":"6E8597D1B09807","user_header":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLDoDeeNST87MZEdfT8n7yEWp06KsFCTs2ssFh2tbHu413nibrRObOia1Zn9pqiaHgIicVkSHRZM3LHOEA/132","comment_is_top":false,"comment_ctime":1631238429,"is_pvip":false,"replies":[{"id":"112856","content":"非常正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631242079,"ip_address":"","comment_id":311440,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10221173021","product_id":100085301,"comment_content":"3. Rc类创建<br>Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value })<br>self.inner().inc_strong()<br>获得了Rc里 strong, 也就是Cell对象，Cell是内部可变的，使用set方法进行修改。<br>fn inc_strong(&amp;self) {<br>        let strong = self.strong();<br>        self.strong_ref().set(strong + 1);<br>    }","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526604,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631242079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330566,"user_name":"chyuwei","can_delete":false,"product_type":"c1","uid":1361377,"ip_address":"","ucode":"19687765E6DE5D","user_header":"","comment_is_top":false,"comment_ctime":1642045168,"is_pvip":false,"replies":[{"id":"120686","content":"对","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642292650,"ip_address":"","comment_id":330566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937012464","product_id":100085301,"comment_content":"个人感觉就是 所有权导致不能出现多个可变引用， <br>借鉴了多线程里面的mutex，所以有了这个所谓的内部可变性。<br>对于mutex，操作系统可以保证独占性，<br>对于refcell应该就是库代码去保证。<br><br>至于有些同学说撕口子这个事， safe rust可以写绝大多数程序了。<br>当你不得不去撕口子，写unsafe时，其实和c++就没什么区别了","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546295,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642292650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323617,"user_name":"dch666","can_delete":false,"product_type":"c1","uid":1318336,"ip_address":"","ucode":"21E3890CD66485","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/c0/978fc470.jpg","comment_is_top":false,"comment_ctime":1638024716,"is_pvip":true,"replies":[{"id":"118882","content":"没区别","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639850054,"ip_address":"","comment_id":323617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5932992012","product_id":100085301,"comment_content":"在代码1中，我把 self.downstream.as_ref().map(|v| v.clone()) 改成了 self.downstream.clone() 看到 print 输出结果是一样的，想问下这两种写法有区别吗？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539843,"discussion_content":"没区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639850054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320568,"user_name":"TheLudlows","can_delete":false,"product_type":"c1","uid":1069346,"ip_address":"","ucode":"64895727505014","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/22/d12f7a72.jpg","comment_is_top":false,"comment_ctime":1636382232,"is_pvip":false,"replies":[{"id":"116304","content":"第一段代码编译器可以检查出 p 在做完 *p += 2 之后就不活跃了，所以不存在活跃的可变引用和不可变引用并存的情况。这是一种编译器的优化；第二种无法优化。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636478640,"ip_address":"","comment_id":320568,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5931349528","product_id":100085301,"comment_content":"陈天老师麻烦问下为什么下面这段可以编译<br>```rust<br>fn main() {<br>    let mut data = 1;<br>    let p = &amp;mut data;<br>    *p += 2;<br>    println!(&quot;data: {:?}&quot;, &amp;data);<br>}<br>```<br>而例子中的这段不能编译呢<br>use std::cell::RefCell;<br><br>fn main() {<br>    let data = RefCell::new(1);<br>    <br>    let mut v = data.borrow_mut();<br>    *v += 1;<br>    <br>    println!(&quot;data: {:?}&quot;, data.borrow());<br>}","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530052,"discussion_content":"第一段代码编译器可以检查出 p 在做完 *p += 2 之后就不活跃了，所以不存在活跃的可变引用和不可变引用并存的情况。这是一种编译器的优化；第二种无法优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636478640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312447,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1631805487,"is_pvip":false,"replies":[{"id":"113221","content":"downstream  是一个 Option&lt;Node&gt;，as_ref() 后变成 Option&lt;&amp;Nonde&gt;，Option 有 map 方法，可以对里面的 Some(v) 的 v 进行 map 处理。可以看：https:&#47;&#47;doc.rust-lang.org&#47;std&#47;option&#47;enum.Option.html#method.map","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631844703,"ip_address":"","comment_id":312447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5926772783","product_id":100085301,"comment_content":"代码1和4中留意一下struct 和impl都是Node，这样的写法看起来比较简洁。<br>另外代码中有一句<br>self.downstream.as_ref().map(|v| v.clone())<br>这里的map语法是什么意思？没太看懂，多谢了","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526969,"discussion_content":"downstream  是一个 Option&amp;lt;Node&amp;gt;，as_ref() 后变成 Option&amp;lt;&amp;amp;Nonde&amp;gt;，Option 有 map 方法，可以对里面的 Some(v) 的 v 进行 map 处理。可以看：https://doc.rust-lang.org/std/option/enum.Option.html#method.map","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631844703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311407,"user_name":"Geek_364411","can_delete":false,"product_type":"c1","uid":1441429,"ip_address":"","ucode":"64BB3CF51166B3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AqCAY0eAVuCLIiafWWUv871EsRhEnhYT1cy1g7CGBtYJgLxiajw68l2fff4Lu7FMmjKXuchlhcCKOqd2ghibcJgHA/132","comment_is_top":false,"comment_ctime":1631226641,"is_pvip":false,"replies":[{"id":"112850","content":"1&#47;2 正确！<br><br>3. 其实是想帮助我们回顾内部可变性。当一个不可变的引用可以修改内部状态时，它一定使用了某种内部可变性的方法。你的代码并没有解决 clone() 面临的问题，因为从接口看，你要修改的 dst 是一个 &amp;mut T。clone() 第一个参数是 &amp;self，不是 &amp;mut self。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631237637,"ip_address":"","comment_id":311407,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5926193937","product_id":100085301,"comment_content":"1.<br>fn main() {<br>  let arr = vec![1];<br><br>  std::thread::spawn(move || {<br>    println!(&quot;{:?}&quot;, arr);<br>  });<br>}<br>2.<br>fn main() {<br>    let name = &quot;Hello&quot;;<br>    let m_name = Arc::new(name);<br>    let clone_name = m_name.clone();<br>    std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, clone_name);<br>    });<br>    println!(&quot;{:?}&quot;, m_name);<br>}<br>3.使用了裸指针来修改<br>pub fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T {<br>    unsafe {<br>        let result = ptr::read(dest);<br>        ptr::write(dest, src);<br>        result<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526589,"discussion_content":"1/2 正确！\n\n3. 其实是想帮助我们回顾内部可变性。当一个不可变的引用可以修改内部状态时，它一定使用了某种内部可变性的方法。你的代码并没有解决 clone() 面临的问题，因为从接口看，你要修改的 dst 是一个 &amp;amp;mut T。clone() 第一个参数是 &amp;amp;self，不是 &amp;amp;mut self。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631237637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359875,"user_name":"Neo","can_delete":false,"product_type":"c1","uid":1070189,"ip_address":"浙江","ucode":"A2B2E2F8780557","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/6d/c947ef55.jpg","comment_is_top":false,"comment_ctime":1666003585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666003585","product_id":100085301,"comment_content":"问题1: 新线程生命周期可能比主线程长，新线程借用了arr会超出主线程的生命周期<br>    let arr =vec![1];<br><br>    std::thread::spawn(move || {<br>        println!(&quot;arr1: {:?}&quot;, arr);<br>    }).join().unwrap();<br><br>问题2:<br>    let arr =Arc::new(vec![1]);<br>    let arr1 = arr.clone();<br>    std::thread::spawn(move || {<br>        println!(&quot;arr1: {:?}&quot;, arr1);<br>    }).join().unwrap();<br><br>    println!(&quot;arr: {:?}&quot;, arr);","like_count":0},{"had_liked":false,"id":353577,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"广东","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1659579352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659579352","product_id":100085301,"comment_content":"思考题<br><br>1. https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7ae64f30bcc966e0bdd6d4e57bb4c0e4<br>```<br>fn main() {<br>    let arr = vec![1];<br><br>    std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    });<br><br>}<br>```<br>2. https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=99716788245b49b5c94d975c94b39380<br>```<br>use std::{cell::RefCell, sync::Arc};<br><br>fn main() {<br>    let hello = &quot;hello&quot;.to_owned();<br>    let arc = Arc::new(hello);<br><br>    {<br>        let arc_copy = arc.clone();<br>        std::thread::spawn(move || {<br>            println!(&quot;In thread, arc copy value: {:?}&quot;, arc_copy);<br>        });<br>    }<br><br>    println!(&quot;arc value: {}&quot;, arc);<br>}<br>```<br>3. 强引用计数的值，存储在 RcBox 结构体中的 strong:Cell&lt;usize&gt; 字段中，而 Cell&lt;usize&gt; 可做简单的 get和set方法，引用计数 +1 操作在 RcInnerPtr trait 的 inc_strong()默认实现中完成。","like_count":0},{"had_liked":false,"id":348729,"user_name":"NorthWind","can_delete":false,"product_type":"c1","uid":1037669,"ip_address":"","ucode":"459ADF3B0945E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/65/1c9f1530.jpg","comment_is_top":false,"comment_ctime":1655353940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655353940","product_id":100085301,"comment_content":"java 里一堆的强弱引用也是实现类似的这个功能的么","like_count":0},{"had_liked":false,"id":346250,"user_name":"ONLY","can_delete":false,"product_type":"c1","uid":1049147,"ip_address":"","ucode":"180990E586D060","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/3b/b4a47f63.jpg","comment_is_top":false,"comment_ctime":1652945924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652945924","product_id":100085301,"comment_content":"感觉rust的借用检查不智能，虽然在同一个作用域，但是可变借用已经完成了不会对数据有副作用了，后面再使用不可变借用应该是允许的，不然这个会有很多无意义的代码就是为了规避编译器的这个借用检查","like_count":0},{"had_liked":false,"id":342854,"user_name":"◑▂◐","can_delete":false,"product_type":"c1","uid":1338732,"ip_address":"","ucode":"42E6C1191FF63B","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/6c/81fa79a2.jpg","comment_is_top":false,"comment_ctime":1650508473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650508473","product_id":100085301,"comment_content":"老师有一个初级问题请教下：self.downstream.as_ref().map(|v| v.clone())  中的 |v| 是代表什么语法；我找了很多rust相关的语法知识都没有找到。或者老师这一块有什么书籍可以推荐的 ","like_count":0},{"had_liked":false,"id":342237,"user_name":"习惯","can_delete":false,"product_type":"c1","uid":2183344,"ip_address":"","ucode":"2E61B2C235B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/21/50/b0/9e80e838.jpg","comment_is_top":false,"comment_ctime":1650121752,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650121752","product_id":100085301,"comment_content":"这种是在同一个作用域既有可变引用和不可变引用吗<br>    let mut s = String::from(&quot;hello&quot;);<br>    let s1 = &amp;mut s;<br>    s1.push_str(&quot; world&quot;);<br>    println!(&quot;{}&quot;, s);<br>    let s2 = &amp;s;<br>    println!(&quot;{}&quot;, s2);<br><br>看了RefCell的borrow()的和borrow_mut()的代码，在同一作用域分别执行borrow_mut()和borrow()时，在内部调用时都会执行一个try_的方法，当首次执行borrow_mut()时,会将常量UnUsed减1赋值给RefCell中的属性borrow，即为-1，然后再同一作用域再调用RefCell的borrow()时会通过is_reading()判断这个RefCell的borrow和常量UnUsed的大小，按以上流程走时会返回错误，导致运行时panic，之所以再不同作用域进行读写，是因为RefMut中的borrow属性的BorrowRefMut类型实现了Drop,在其实现的drop内部中将borrow属性又置为了初始值，所以内部作用域结束后，自动调用drop(),在外部的作用域就可以正常访问RefCell的borrow()方法了，RefCell通过代码控制实现了在同一作用域只能存在一个borrow_mut()方法或者多个borrow()方法，但是像上面的代码String在同一作用域可以存在一个可变引用也可以同时存在多个不可变引用，这是不是有点不一样啊，就感觉有点矛盾，这里老师说是根据所有权规则，同一作用域不能同时存在活跃的可变和不可变引用啊，但是String又可以，一个头两个大啊，新手分析，希望老师指正","like_count":0},{"had_liked":false,"id":340581,"user_name":"登高","can_delete":false,"product_type":"c1","uid":1068600,"ip_address":"","ucode":"CD40046238BA18","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/38/3faa8377.jpg","comment_is_top":false,"comment_ctime":1648951579,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648951579","product_id":100085301,"comment_content":"将rust遇到的问题分成编译期和运行期，编译器完全遵循一个值有且只有一个ower的原则，但是在运行期有需要突破这个限制的时候，于是提供了Rc智能智能指针，Rc智能指针是只读的引用，为了实现可以修改的功能引入了RefCell。<br><br>这一节看下来，rust在编译期遵循规则，在运行时牺牲一定的性能来打破规则，运行时虽然打破了规则，但有一套运行时的规则替代编译规则来保证安全。<br><br>实际使用需要多练习才能自如的用起来","like_count":0},{"had_liked":false,"id":337081,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1646613985,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646613985","product_id":100085301,"comment_content":"第三题：self.inner().inc_strong() 调用了 self.strong_ref().set(strong + 1)，strong_ref是一个Cell类型， 是可变的。<br><br>fn strong_ref(&amp;self) -&gt; &amp;Cell&lt;usize&gt;;<br>rc.rs文档的开头有这么一段话：<br>&#47;&#47;! Shared references in Rust disallow mutation by default, and [`Rc`]<br>&#47;&#47;! is no exception: you cannot generally obtain a mutable reference to<br>&#47;&#47;! something inside an [`Rc`]. If you need mutability, put a [`Cell`]<br>&#47;&#47;! or [`RefCell`] inside the [`Rc`]; see [an example of mutability<br>&#47;&#47;! inside an `Rc`][mutability].<br><br>    fn inc_strong(&amp;self) {<br>        let strong = self.strong();<br><br>        &#47;&#47; We want to abort on overflow instead of dropping the value.<br>        &#47;&#47; The reference count will never be zero when this is called;<br>        &#47;&#47; nevertheless, we insert an abort here to hint LLVM at<br>        &#47;&#47; an otherwise missed optimization.<br>        if strong == 0 || strong == usize::MAX {<br>            abort();<br>        }<br>        self.strong_ref().set(strong + 1);<br>    }<br>","like_count":0},{"had_liked":false,"id":334194,"user_name":"adgjl丶","can_delete":false,"product_type":"c1","uid":2889982,"ip_address":"","ucode":"A26A0C0F894F96","user_header":"https://static001.geekbang.org/account/avatar/00/2c/18/fe/1100a1f5.jpg","comment_is_top":false,"comment_ctime":1644806544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644806544","product_id":100085301,"comment_content":"老师好，rust引用计数可以处理循环引用吗？","like_count":0},{"had_liked":false,"id":333228,"user_name":"Zero","can_delete":false,"product_type":"c1","uid":1077442,"ip_address":"","ucode":"A94F43EF1BF3A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/c2/2031a595.jpg","comment_is_top":false,"comment_ctime":1644222386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644222386","product_id":100085301,"comment_content":"```<br>fn main() {<br>    let arr = vec![1, 2, 2, 3, 3, 4, 4, 5, 5];<br><br>    let handler = std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    });<br>    handler.join().unwrap();<br>}<br>```<br>如果不使用move，闭包不能够拥有arr的所有权，需要将arr的所有权转交给闭包。这里也就是涉及到arr的生命周期问题。不能通过编译，说明编译器并不能判断出闭包和arr的生命周期谁更长。","like_count":0},{"had_liked":false,"id":333125,"user_name":"揽余月","can_delete":false,"product_type":"c1","uid":2709342,"ip_address":"","ucode":"D75ABAA841C23A","user_header":"https://static001.geekbang.org/account/avatar/00/29/57/5e/2565df70.jpg","comment_is_top":false,"comment_ctime":1644115544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644115544","product_id":100085301,"comment_content":"老师，我想请问一下<br>`self.downstream.as_ref.map(|v| v.clone())`<br>这一句代码是干嘛的？Clippy提示我可以简化为`self.downstream.as_ref.cloned()`，我直接`self.downstream.clone()`也可以","like_count":0},{"had_liked":false,"id":332133,"user_name":"Curricane","can_delete":false,"product_type":"c1","uid":1243961,"ip_address":"","ucode":"3778B96444874E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VLB1WPGVDnicKaMGUcFZdtDQOXSib3LhFv6YqCZA16qfy2KHUAGL0ichSEE6rSu8HXSibGdg8vzIQ7qWlk9BZOeJjQ/132","comment_is_top":false,"comment_ctime":1643033803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643033803","product_id":100085301,"comment_content":"use std::cell::RefCell;fn main() {    let data = RefCell::new(1);        let mut v = data.borrow_mut();    *v += 1;        println!(&quot;data: {:?}&quot;, data.borrow());}<br>运行时报错<br>不知 是RefCell 有些似乎有些特殊，还是编译器对 普通的 借用做了优化，如下代码是可以通过编译且正常运行的<br><br>fn main() {<br>    let mut data = [1, 2];<br>    let data1 = &amp;mut data;<br>    data1[0] = -1;<br>    let data2 = &amp;data;<br>    println!(&quot;data2 {:?}&quot;, data2);<br><br>}<br><br>这是为什么呢？ ","like_count":0},{"had_liked":false,"id":331580,"user_name":"腾达","can_delete":false,"product_type":"c1","uid":1079876,"ip_address":"","ucode":"72F9CFBA44FDEE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","comment_is_top":false,"comment_ctime":1642662001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642662001","product_id":100085301,"comment_content":"对一个 Rc 结构进行 clone(), 用：Rc::clone(..) 还是 a.clone() ?","like_count":0},{"had_liked":false,"id":331575,"user_name":"腾达","can_delete":false,"product_type":"c1","uid":1079876,"ip_address":"","ucode":"72F9CFBA44FDEE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","comment_is_top":false,"comment_ctime":1642660844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642660844","product_id":100085301,"comment_content":"```rust<br>node3.borrow_mut().downstream  &#47;&#47; 这里为什么必须一气呵成？不能 let mut aa =node3.borrow_mut();  aa.downstream=.....<br>```","like_count":0},{"had_liked":false,"id":321248,"user_name":"Ignis","can_delete":false,"product_type":"c1","uid":2837051,"ip_address":"","ucode":"94A55C81E2F86C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEL7ibAFViaJqhTRquzLKhS0SebmHON4RKeaL9I9R9wKHWt6ehcu0QtN8icvmPicU8wvDYIZiaaxqGWSxlw/132","comment_is_top":false,"comment_ctime":1636725264,"is_pvip":false,"replies":[{"id":"118934","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639853824,"ip_address":"","comment_id":321248,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636725264","product_id":100085301,"comment_content":"1. 将arr移动到子线程：<br>```rust<br>fn main() {<br>    let arr = vec![1];<br>    std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    });<br>}<br>```<br><br>2. 使用Arc包一下String：<br>```rust<br>use std::sync::Arc;<br><br>fn main() {<br>    let s1 = Arc::new(String::from(&quot;arc&quot;));<br>    let s2 = s1.clone();<br>    let h = std::thread::spawn(move || {<br>        println!(&quot;child thread: {:?}&quot;, s2);<br>    });<br>    println!(&quot;main thread: {:?}&quot;, s1);<br>    h.join().unwrap();<br>}<br>```<br><br>3. 感觉这个类似C语言里面的const指针，指针本身的值不能更改，但是其指向的内容是可以更改的。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539895,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313784,"user_name":"泡沫的快乐","can_delete":false,"product_type":"c1","uid":1165936,"ip_address":"","ucode":"44B2014D815DAE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ5MUYIZAaFTyrvLgNptib49zGW5SvqUxYmSC7qib4ibQF6GUiafsoHRqGQQvGicial7q5Bg9n11rLTNicHw/132","comment_is_top":false,"comment_ctime":1632664986,"is_pvip":false,"replies":[{"id":"113721","content":"主要是因为这样方便生成在栈上操作的指令。比如你传给函数一个不确定长度的数据，在生成新的栈帧时，参数究竟要占多大的区域，该用什么指令来操作这个数据，这些都很麻烦。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632796446,"ip_address":"","comment_id":313784,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632664986","product_id":100085301,"comment_content":"老师您好。 我不太明白，为什么栈只能存放 确定占用多少内存 的类型？  ","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527470,"discussion_content":"主要是因为这样方便生成在栈上操作的指令。比如你传给函数一个不确定长度的数据，在生成新的栈帧时，参数究竟要占多大的区域，该用什么指令来操作这个数据，这些都很麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632796446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313273,"user_name":".nil?","can_delete":false,"product_type":"c1","uid":1070750,"ip_address":"","ucode":"33459B799640BF","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/9e/020797cd.jpg","comment_is_top":false,"comment_ctime":1632361577,"is_pvip":false,"replies":[{"id":"113528","content":"非常正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632464601,"ip_address":"","comment_id":313273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632361577","product_id":100085301,"comment_content":"第1题. 根据错误提示可以看出，闭包中借用的arr生命周期大于main函数中arr的生命周期，根据提示添加move就可以<br>```<br>fn main() {<br>  let arr = vec![1];<br><br>  std::thread::spawn(move || {<br>    println!(&quot;{:?}&quot;, arr);<br>  });<br>}<br>```<br><br>第2题<br>```<br>use std::sync::Arc;<br>fn main() {<br>  let s1 = Arc::new(&quot;test str&quot;);<br>  let s2 = s1.clone();<br><br>  let hander = std::thread::spawn(move || {<br>    println!(&quot;thread s is {:?}&quot;, s2);<br>  });<br>  println!(&quot;s1 is {:?}&quot;, s1);<br>  hander.join().unwrap();<br>}<br>```<br><br>第3题，翻看源代码，对于 inc_strong() 函数中调用的 strong_ref()，它的返回类型是 Cell，而 Cell 是内部可变<br>```<br>    fn strong_ref(&amp;self) -&gt; &amp;Cell&lt;usize&gt;;<br><br>    #[inline]<br>    fn strong(&amp;self) -&gt; usize {<br>        self.strong_ref().get()<br>    }<br><br>    #[inline]<br>    fn inc_strong(&amp;self) {<br>        let strong = self.strong();<br><br>        &#47;&#47; We want to abort on overflow instead of dropping the value.<br>        &#47;&#47; The reference count will never be zero when this is called;<br>        &#47;&#47; nevertheless, we insert an abort here to hint LLVM at<br>        &#47;&#47; an otherwise missed optimization.<br>        if strong == 0 || strong == usize::MAX {<br>            abort();<br>        }<br>        self.strong_ref().set(strong + 1);<br>    }<br>```","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527299,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632464601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312277,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1631713861,"is_pvip":false,"replies":[{"id":"113162","content":"文中讲过了，&amp;mut x 编译时编译器可以检查是否违背所有权规则，borrow_mut() 是个函数，只有运行到这一刻，才知道是否违背所有权规则。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631758481,"ip_address":"","comment_id":312277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631713861","product_id":100085301,"comment_content":" x.borrow_mut() 和 &amp;mut x 好像结果一样他们之间有什么区别吗？<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526923,"discussion_content":"文中讲过了，&amp;amp;mut x 编译时编译器可以检查是否违背所有权规则，borrow_mut() 是个函数，只有运行到这一刻，才知道是否违背所有权规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631758481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311776,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1631457094,"is_pvip":false,"replies":[{"id":"112990","content":"标准库里很多 unsafe 都是为了性能所做的妥协。读代码，首先看数据结构和接口，然后再看实现细节，很多标准库下的unsafe，实现细节并不复杂，如果看不懂，弄明白接口在干嘛也就可以。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631515008,"ip_address":"","comment_id":311776,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1631457094","product_id":100085301,"comment_content":"听取老师建议，读源码，看到 cell.rs 里面有很多的 unsafe，代码仔细阅读也没有那么难。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526737,"discussion_content":"标准库里很多 unsafe 都是为了性能所做的妥协。读代码，首先看数据结构和接口，然后再看实现细节，很多标准库下的unsafe，实现细节并不复杂，如果看不懂，弄明白接口在干嘛也就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631515008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311710,"user_name":"0@1","can_delete":false,"product_type":"c1","uid":1549191,"ip_address":"","ucode":"932A4139DB8169","user_header":"https://static001.geekbang.org/account/avatar/00/17/a3/87/eb923eb3.jpg","comment_is_top":false,"comment_ctime":1631419209,"is_pvip":false,"replies":[{"id":"112949","content":"课程所有的目录？有啊，在课程首页就有一张目录长图。<br><br>最近留言区提的一些问题都要在后面才会学到。<br>一部分是因为Rust的设计是环环相扣的，所以之前的问题涉及后面的知识；一部分也是因为有些同学非常棒，一步步追问思考，学习进度也很不错，所以会问到目前的超纲内容。问了的，老师看到也都认真补充了。","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1631440067,"ip_address":"","comment_id":311710,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1631419209","product_id":100085301,"comment_content":"老师，能不能提前列出所有的课程目录，这样也好方便问问题， 有些问题可能需要在特定课程目录下问比较合适。","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526712,"discussion_content":"课程所有的目录？有啊，在课程首页就有一张目录长图。\n\n最近留言区提的一些问题都要在后面才会学到。\n一部分是因为Rust的设计是环环相扣的，所以之前的问题涉及后面的知识；一部分也是因为有些同学非常棒，一步步追问思考，学习进度也很不错，所以会问到目前的超纲内容。问了的，老师看到也都认真补充了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631440067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311552,"user_name":"Tyler","can_delete":false,"product_type":"c1","uid":1209108,"ip_address":"","ucode":"6C94C462D69EC6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL8Rzicd8f8GlIiaLQ6bYKPdhFJ3tvXw96rMicPv4s2rXEanYKjKdEewjCUAnwfJiaN53WyexhYLu1bbQ/132","comment_is_top":false,"comment_ctime":1631281468,"is_pvip":false,"replies":[{"id":"112880","content":"对！第 3 题和 unsafe 关系不大，和内部可变性有关。一个只读引用（&amp;self）修改某个内部数据，那么这个内部数据一定使用了内部可变性。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631284662,"ip_address":"","comment_id":311552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631281468","product_id":100085301,"comment_content":"1、在闭包前加move关键字。  编译器在编译时有错误提示并提供了一个解决的方法。<br>2、<br>use std::sync::Arc;<br><br>fn main() {<br>  let s = Arc::new(String::from(&quot;Hello World&quot;));<br>  let s1 = s.clone();<br>  let h = std::thread::spawn(move || {<br>    println!(&quot;thread: {:?}&quot;, s1);<br>  });<br>  <br>  println!(&quot;{:?}&quot;, s);<br>  h.join().unwrap();<br>}<br>```<br>3、查看源码inner()的实现使用了unsafe <br><br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526659,"discussion_content":"对！第 3 题和 unsafe 关系不大，和内部可变性有关。一个只读引用（&amp;amp;self）修改某个内部数据，那么这个内部数据一定使用了内部可变性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631284662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311551,"user_name":"Custer","can_delete":false,"product_type":"c1","uid":1020822,"ip_address":"","ucode":"8AEA5544C94D57","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/96/575d42c3.jpg","comment_is_top":false,"comment_ctime":1631280712,"is_pvip":true,"replies":[{"id":"113001","content":"非常正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516291,"ip_address":"","comment_id":311551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631280712","product_id":100085301,"comment_content":"1.<br>fn main() {<br>  let arr = vec![1];<br><br>  std::thread::spawn(move || {<br>    println!(&quot;{:?}&quot;, arr);<br>  });<br>}<br>2.<br>   1 │ use std::sync::Arc;<br>   2 │<br>   3 │ fn main() {<br>   4 │ let str = Arc::new(String::from(&quot;共享字符串&quot;));<br>   5 │ let a = str.clone();<br>   6 │ let b = Arc::clone(&amp;str);<br>   7 │<br>   8 │ std::thread::spawn(move || {<br>   9 │ println!(&quot;线程: {:?}&quot;, b);<br>  10 │ });<br>  11 │ println!(&quot;main: {:?}&quot;, a);<br>  12 │ }<br>3.<br>查看源代码<br>```rust<br>impl&lt;T: ?Sized&gt; Clone for Rc&lt;T&gt; {<br>    #[inline]<br>    fn clone(&amp;self) -&gt; Rc&lt;T&gt; {<br>        self.inner().inc_strong();<br>        Self::from_inner(self.ptr)<br>    }<br>}<br>```<br><br>```rust<br>impl&lt;T: ?Sized&gt; Rc&lt;T&gt; {<br>    #[inline(always)]<br>    fn inner(&amp;self) -&gt; &amp;RcBox&lt;T&gt; {<br>        &#47;&#47; This unsafety is ok because while this Rc is alive we&#39;re guaranteed<br>        &#47;&#47; that the inner pointer is valid.<br>        unsafe { self.ptr.as_ref() }<br>    }<br>...<br>```<br><br>```rust<br>#[doc(hidden)]<br>trait RcInnerPtr {<br>    fn weak_ref(&amp;self) -&gt; &amp;Cell&lt;usize&gt;;<br>    fn strong_ref(&amp;self) -&gt; &amp;Cell&lt;usize&gt;;<br><br>    #[inline]<br>    fn strong(&amp;self) -&gt; usize { self.strong_ref().get() }<br><br>    #[inline]<br>    fn inc_strong(&amp;self) {<br>        let strong = self.strong();<br><br>        if strong == 0 || strong == usize::MAX {<br>            abort();<br>        }<br>        self.strong_ref().set(strong + 1);<br>    }<br>```<br><br>看源代码猜测“这里对 self 的不可变引用可以改变 self 的内部数据”是因为：<br>在 unsafe 代码块中获取了 self 的指针，返回了 `RcBox&lt;T&gt;` 的引用类型，然后在 `inc_strong()` 函数中，通过 `self.strong_ref()` 使用 `Cell＜T＞` 内部可变容器，通过对外暴露的 `set` 方法实现了对内部值的修改，而其本身却是不可变的。所以，实际上 `Cell＜T＞` 包裹的T本身合法地避开了借用检查。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526658,"discussion_content":"非常正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631516291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311459,"user_name":"jin","can_delete":false,"product_type":"c1","uid":1202896,"ip_address":"","ucode":"DCA0E9C1F7838F","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/d0/5be738e0.jpg","comment_is_top":false,"comment_ctime":1631242661,"is_pvip":false,"replies":[{"id":"113003","content":"这是这个例子的写法问题，它只是为了展示 Rc &#47; RefCell。如果要真写一个 DAG，可以看 daggy 这个项目，这是它的用法：https:&#47;&#47;github.com&#47;mitchmindtree&#47;daggy&#47;blob&#47;master&#47;tests&#47;add_edges.rs","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631516495,"ip_address":"","comment_id":311459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631242661","product_id":100085301,"comment_content":"老师好，文章构造DAG时，是先构建了Node1，3，4的关系，再把2加进去。但让我直觉上难以接受的是，加进去的时候却用到了Node1，因为需要调用Rc.clone()增加引用计数。在实际的图论问题中，假设我们要插入点2，找到了点3，难道还要O(n)遍历所有点，从而找到点2的reference吗？感觉这个确实有点限制灵活性了，请问您怎么看呢？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526614,"discussion_content":"这是这个例子的写法问题，它只是为了展示 Rc / RefCell。如果要真写一个 DAG，可以看 daggy 这个项目，这是它的用法：https://github.com/mitchmindtree/daggy/blob/master/tests/add_edges.rs","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631516495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311458,"user_name":"Christian","can_delete":false,"product_type":"c1","uid":1089000,"ip_address":"","ucode":"D84F866015BA07","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/e8/39433235.jpg","comment_is_top":false,"comment_ctime":1631242659,"is_pvip":false,"replies":[{"id":"112876","content":"正确！不过第 2 题在线程里的闭包没有必要。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631284257,"ip_address":"","comment_id":311458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631242659","product_id":100085301,"comment_content":"1. spawn 要求闭包具有静态生命周期。但传入的闭包捕获了 arr 的引用，生命周期不会超出 main 函数。修复：<br>```rust<br>fn main() {<br>    let arr = vec![1];<br>    std::thread::spawn(move || {<br>        println!(&quot;{:?}&quot;, arr);<br>    });<br>}<br>```<br><br>2. <br>```rust<br>use std::sync::Arc;<br><br>fn main() {<br>    let s = Arc::new(&quot;foo&quot;.to_string());<br><br>    let handle = std::thread::spawn({<br>        let s = s.clone();<br><br>        move || {<br>            println!(&quot;{:?}&quot;, s);<br>        }<br>    });<br><br>    println!(&quot;{:?}&quot;, s);<br><br>    handle.join().unwrap();<br>}<br>```<br><br>3. inner() 的返回类型具有内部可变行。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526613,"discussion_content":"正确！不过第 2 题在线程里的闭包没有必要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631284257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}