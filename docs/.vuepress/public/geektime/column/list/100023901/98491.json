{"id":98491,"title":"41 | 案例分析（四）：高性能数据库连接池HiKariCP","content":"<p>实际工作中，我们总会难免和数据库打交道；只要和数据库打交道，就免不了使用数据库连接池。业界知名的数据库连接池有不少，例如c3p0、DBCP、Tomcat JDBC Connection Pool、Druid等，不过最近最火的是HiKariCP。</p><p><strong>HiKariCP号称是业界跑得最快的数据库连接池</strong>，这两年发展得顺风顺水，尤其是Springboot 2.0将其作为<strong>默认数据库连接池</strong>后，江湖一哥的地位已是毋庸置疑了。那它为什么那么快呢？今天咱们就重点聊聊这个话题。</p><h2>什么是数据库连接池</h2><p>在详细分析HiKariCP高性能之前，我们有必要先简单介绍一下什么是数据库连接池。本质上，数据库连接池和线程池一样，都属于池化资源，作用都是避免重量级资源的频繁创建和销毁，对于数据库连接池来说，也就是避免数据库连接频繁创建和销毁。如下图所示，服务端会在运行期持有一定数量的数据库连接，当需要执行SQL时，并不是直接创建一个数据库连接，而是从连接池中获取一个；当SQL执行完，也并不是将数据库连接真的关掉，而是将其归还到连接池中。</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/19/0b106876824e43d11750334e86556519.png?wh=1142*511\" alt=\"\"></p><center><span class=\"reference\">数据库连接池示意图</span></center><p>在实际工作中，我们都是使用各种持久化框架来完成数据库的增删改查，基本上不会直接和数据库连接池打交道，为了能让你更好地理解数据库连接池的工作原理，下面的示例代码并没有使用任何框架，而是原生地使用HiKariCP。执行数据库操作基本上是一系列规范化的步骤：</p><!-- [[[read_end]]] --><ol>\n<li>通过数据源获取一个数据库连接；</li>\n<li>创建Statement；</li>\n<li>执行SQL；</li>\n<li>通过ResultSet获取SQL执行结果；</li>\n<li>释放ResultSet；</li>\n<li>释放Statement；</li>\n<li>释放数据库连接。</li>\n</ol><p>下面的示例代码，通过 <code>ds.getConnection()</code> 获取一个数据库连接时，其实是向数据库连接池申请一个数据库连接，而不是创建一个新的数据库连接。同样，通过 <code>conn.close()</code> 释放一个数据库连接时，也不是直接将连接关闭，而是将连接归还给数据库连接池。</p><pre><code>//数据库连接池配置\nHikariConfig config = new HikariConfig();\nconfig.setMinimumIdle(1);\nconfig.setMaximumPoolSize(2);\nconfig.setConnectionTestQuery(&quot;SELECT 1&quot;);\nconfig.setDataSourceClassName(&quot;org.h2.jdbcx.JdbcDataSource&quot;);\nconfig.addDataSourceProperty(&quot;url&quot;, &quot;jdbc:h2:mem:test&quot;);\n// 创建数据源\nDataSource ds = new HikariDataSource(config);\nConnection conn = null;\nStatement stmt = null;\nResultSet rs = null;\ntry {\n  // 获取数据库连接\n  conn = ds.getConnection();\n  // 创建Statement \n  stmt = conn.createStatement();\n  // 执行SQL\n  rs = stmt.executeQuery(&quot;select * from abc&quot;);\n  // 获取结果\n  while (rs.next()) {\n    int id = rs.getInt(1);\n    ......\n  }\n} catch(Exception e) {\n   e.printStackTrace();\n} finally {\n  //关闭ResultSet\n  close(rs);\n  //关闭Statement \n  close(stmt);\n  //关闭Connection\n  close(conn);\n}\n//关闭资源\nvoid close(AutoCloseable rs) {\n  if (rs != null) {\n    try {\n      rs.close();\n    } catch (SQLException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><p><a href=\"https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole\">HiKariCP官方网站</a>解释了其性能之所以如此之高的秘密。微观上HiKariCP程序编译出的字节码执行效率更高，站在字节码的角度去优化Java代码，HiKariCP的作者对性能的执着可见一斑，不过遗憾的是他并没有详细解释都做了哪些优化。而宏观上主要是和两个数据结构有关，一个是FastList，另一个是ConcurrentBag。下面我们来看看它们是如何提升HiKariCP的性能的。</p><h2>FastList解决了哪些性能问题</h2><p>按照规范步骤，执行完数据库操作之后，需要依次关闭ResultSet、Statement、Connection，但是总有粗心的同学只是关闭了Connection，而忘了关闭ResultSet和Statement。为了解决这种问题，最好的办法是当关闭Connection时，能够自动关闭Statement。为了达到这个目标，Connection就需要跟踪创建的Statement，最简单的办法就是将创建的Statement保存在数组ArrayList里，这样当关闭Connection的时候，就可以依次将数组中的所有Statement关闭。</p><p>HiKariCP觉得用ArrayList还是太慢，当通过 <code>conn.createStatement()</code> 创建一个Statement时，需要调用ArrayList的add()方法加入到ArrayList中，这个是没有问题的；但是当通过 <code>stmt.close()</code> 关闭Statement的时候，需要调用 ArrayList的remove()方法来将其从ArrayList中删除，这里是有优化余地的。</p><p>假设一个Connection依次创建6个Statement，分别是S1、S2、S3、S4、S5、S6，按照正常的编码习惯，关闭Statement的顺序一般是逆序的，关闭的顺序是：S6、S5、S4、S3、S2、S1，而ArrayList的remove(Object o)方法是顺序遍历查找，逆序删除而顺序查找，这样的查找效率就太慢了。如何优化呢？很简单，优化成逆序查找就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/a6/4b5e2ef70e46b087b139b331578a82a6.png?wh=1142*389\" alt=\"\"></p><center><span class=\"reference\">逆序删除示意图</span></center><p>HiKariCP中的FastList相对于ArrayList的一个优化点就是将 <code>remove(Object element)</code> 方法的<strong>查找顺序变成了逆序查找</strong>。除此之外，FastList还有另一个优化点，是 <code>get(int index)</code> 方法没有对index参数进行越界检查，HiKariCP能保证不会越界，所以不用每次都进行越界检查。</p><p>整体来看，FastList的优化点还是很简单的。下面我们再来聊聊HiKariCP中的另外一个数据结构ConcurrentBag，看看它又是如何提升性能的。</p><h2>ConcurrentBag解决了哪些性能问题</h2><p>如果让我们自己来实现一个数据库连接池，最简单的办法就是用两个阻塞队列来实现，一个用于保存空闲数据库连接的队列idle，另一个用于保存忙碌数据库连接的队列busy；获取连接时将空闲的数据库连接从idle队列移动到busy队列，而关闭连接时将数据库连接从busy移动到idle。这种方案将并发问题委托给了阻塞队列，实现简单，但是性能并不是很理想。因为Java SDK中的阻塞队列是用锁实现的，而高并发场景下锁的争用对性能影响很大。</p><pre><code>//忙碌队列\nBlockingQueue&lt;Connection&gt; busy;\n//空闲队列\nBlockingQueue&lt;Connection&gt; idle;\n</code></pre><p>HiKariCP并没有使用Java SDK中的阻塞队列，而是自己实现了一个叫做ConcurrentBag的并发容器。ConcurrentBag的设计最初源自C#，它的一个核心设计是使用ThreadLocal避免部分并发问题，不过HiKariCP中的ConcurrentBag并没有完全参考C#的实现，下面我们来看看它是如何实现的。</p><p>ConcurrentBag中最关键的属性有4个，分别是：用于存储所有的数据库连接的共享队列sharedList、线程本地存储threadList、等待数据库连接的线程数waiters以及分配数据库连接的工具handoffQueue。其中，handoffQueue用的是Java SDK提供的SynchronousQueue，SynchronousQueue主要用于线程之间传递数据。</p><pre><code>//用于存储所有的数据库连接\nCopyOnWriteArrayList&lt;T&gt; sharedList;\n//线程本地存储中的数据库连接\nThreadLocal&lt;List&lt;Object&gt;&gt; threadList;\n//等待数据库连接的线程数\nAtomicInteger waiters;\n//分配数据库连接的工具\nSynchronousQueue&lt;T&gt; handoffQueue;\n</code></pre><p>当线程池创建了一个数据库连接时，通过调用ConcurrentBag的add()方法加入到ConcurrentBag中，下面是add()方法的具体实现，逻辑很简单，就是将这个连接加入到共享队列sharedList中，如果此时有线程在等待数据库连接，那么就通过handoffQueue将这个连接分配给等待的线程。</p><pre><code>//将空闲连接添加到队列\nvoid add(final T bagEntry){\n  //加入共享队列\n  sharedList.add(bagEntry);\n  //如果有等待连接的线程，\n  //则通过handoffQueue直接分配给等待的线程\n  while (waiters.get() &gt; 0 \n    &amp;&amp; bagEntry.getState() == STATE_NOT_IN_USE \n    &amp;&amp; !handoffQueue.offer(bagEntry)) {\n      yield();\n  }\n}\n</code></pre><p>通过ConcurrentBag提供的borrow()方法，可以获取一个空闲的数据库连接，borrow()的主要逻辑是：</p><ol>\n<li>首先查看线程本地存储是否有空闲连接，如果有，则返回一个空闲的连接；</li>\n<li>如果线程本地存储中无空闲连接，则从共享队列中获取。</li>\n<li>如果共享队列中也没有空闲的连接，则请求线程需要等待。</li>\n</ol><p>需要注意的是，线程本地存储中的连接是可以被其他线程窃取的，所以需要用CAS方法防止重复分配。在共享队列中获取空闲连接，也采用了CAS方法防止重复分配。</p><pre><code>T borrow(long timeout, final TimeUnit timeUnit){\n  // 先查看线程本地存储是否有空闲连接\n  final List&lt;Object&gt; list = threadList.get();\n  for (int i = list.size() - 1; i &gt;= 0; i--) {\n    final Object entry = list.remove(i);\n    final T bagEntry = weakThreadLocals \n      ? ((WeakReference&lt;T&gt;) entry).get() \n      : (T) entry;\n    //线程本地存储中的连接也可以被窃取，\n    //所以需要用CAS方法防止重复分配\n    if (bagEntry != null \n      &amp;&amp; bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\n      return bagEntry;\n    }\n  }\n\n  // 线程本地存储中无空闲连接，则从共享队列中获取\n  final int waiting = waiters.incrementAndGet();\n  try {\n    for (T bagEntry : sharedList) {\n      //如果共享队列中有空闲连接，则返回\n      if (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\n        return bagEntry;\n      }\n    }\n    //共享队列中没有连接，则需要等待\n    timeout = timeUnit.toNanos(timeout);\n    do {\n      final long start = currentTime();\n      final T bagEntry = handoffQueue.poll(timeout, NANOSECONDS);\n      if (bagEntry == null \n        || bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\n          return bagEntry;\n      }\n      //重新计算等待时间\n      timeout -= elapsedNanos(start);\n    } while (timeout &gt; 10_000);\n    //超时没有获取到连接，返回null\n    return null;\n  } finally {\n    waiters.decrementAndGet();\n  }\n}\n</code></pre><p>释放连接需要调用ConcurrentBag提供的requite()方法，该方法的逻辑很简单，首先将数据库连接状态更改为STATE_NOT_IN_USE，之后查看是否存在等待线程，如果有，则分配给等待线程；如果没有，则将该数据库连接保存到线程本地存储里。</p><pre><code>//释放连接\nvoid requite(final T bagEntry){\n  //更新连接状态\n  bagEntry.setState(STATE_NOT_IN_USE);\n  //如果有等待的线程，则直接分配给线程，无需进入任何队列\n  for (int i = 0; waiters.get() &gt; 0; i++) {\n    if (bagEntry.getState() != STATE_NOT_IN_USE \n      || handoffQueue.offer(bagEntry)) {\n        return;\n    } else if ((i &amp; 0xff) == 0xff) {\n      parkNanos(MICROSECONDS.toNanos(10));\n    } else {\n      yield();\n    }\n  }\n  //如果没有等待的线程，则进入线程本地存储\n  final List&lt;Object&gt; threadLocalList = threadList.get();\n  if (threadLocalList.size() &lt; 50) {\n    threadLocalList.add(weakThreadLocals \n      ? new WeakReference&lt;&gt;(bagEntry) \n      : bagEntry);\n  }\n}\n</code></pre><h2>总结</h2><p>HiKariCP中的FastList和ConcurrentBag这两个数据结构使用得非常巧妙，虽然实现起来并不复杂，但是对于性能的提升非常明显，根本原因在于这两个数据结构适用于数据库连接池这个特定的场景。FastList适用于逆序删除场景；而ConcurrentBag通过ThreadLocal做一次预分配，避免直接竞争共享资源，非常适合池化资源的分配。</p><p>在实际工作中，我们遇到的并发问题千差万别，这时选择合适的并发数据结构就非常重要了。当然能选对的前提是对特定场景的并发特性有深入的了解，只有了解到无谓的性能消耗在哪里，才能对症下药。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"40 | 案例分析（三）：高性能队列Disruptor","id":98134},"right":{"article_title":"42 | Actor模型：面向对象原生的并发模型","id":98903}},"comments":[{"had_liked":false,"id":100200,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1559479037,"is_pvip":false,"replies":[{"id":"36135","content":"厉害","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559541730,"ip_address":"","comment_id":100200,"utype":1}],"discussion_count":3,"race_medal":0,"score":"263552484093","product_id":100023901,"comment_content":"线程本地的连接会被窃取   <br>这个我觉得是因为 如果 Tl里面没有空闲的 会去 sharedList查找处于 Not_In_Use的连接 这个连接可能已经在其他TL里面存在了 所以就会出现线程T2从sharedList获取到了 T1存在TL里面存放的没有使用的连接这种情况","like_count":61,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452447,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559541730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1185424,"avatar":"https://static001.geekbang.org/account/avatar/00/12/16/90/21f4035c.jpg","nickname":"聪","note":"","ucode":"EBF8A23383D59F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538735,"discussion_content":"sharedList中连接体现了是否在使用中，但是未体现是否在其他TL中，所以即使从本线程TL中获取连接也要检查是否可用；这样的好处是更充分利用未被使用的连接，提高连接的使用率","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639495043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897671,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","nickname":"kimoti","note":"","ucode":"0A78077408C2B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275957,"discussion_content":"这个解释好难理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590790313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122535,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1565419743,"is_pvip":false,"replies":[{"id":"50600","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568085584,"ip_address":"","comment_id":122535,"utype":1}],"discussion_count":1,"race_medal":0,"score":"233493653727","product_id":100023901,"comment_content":"支持高性能并发的软件通常首先会关注整体的并发设计模式，并发设计模式将影响整个软件的设计架构，比如RateLimiter并非采用较为复杂的生产者消费者模式，而是用细粒度的互斥锁来实现令牌桶算法；Netty采用了Reactor模式而非阻塞的等待-通知机制的一些实现。对设计模式的考量应当根据实际需求先考虑线程分工，再从避免共享的模式考虑到一些无锁的模式，再到细粒度的锁控制，再到复杂的同步和互斥模式。<br>从高性能队列和高性能数据连接池中，可以看到，性能的提高通常会从几方面着手（实际场景中应当测试优于猜测，再根据阿姆达尔定律从性能瓶颈处先着手）：并发设计模式；内存分配算法；缓存利用率；GC情况（有GC的语言）；数据结构与算法的效率等。<br>","like_count":55,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462297,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568085584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100203,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1559480360,"is_pvip":false,"replies":[{"id":"36134","content":"sharedlist和其他线程的threadlocal里有可能都有同一个连接，从前者取到连接，就相当于窃取了后者","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559541708,"ip_address":"","comment_id":100203,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74573924392","product_id":100023901,"comment_content":"同问为什么线程本地的会被其他线程窃取，麻烦老师解释一下","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452449,"discussion_content":"sharedlist和其他线程的threadlocal里有可能都有同一个连接，从前者取到连接，就相当于窃取了后者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559541708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100047,"user_name":"阿健","can_delete":false,"product_type":"c1","uid":1024066,"ip_address":"","ucode":"7475C02BABF3B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/42/88e70d61.jpg","comment_is_top":false,"comment_ctime":1559400943,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44509073903","product_id":100023901,"comment_content":"同问，为什么说线程本地的连接会被窃取呢？","like_count":10,"discussions":[{"author":{"id":1019351,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/d7/886e9563.jpg","nickname":"张高","note":"","ucode":"9E5EB8675E4956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95342,"discussion_content":"线程的threadList中的空闲线程的引用同时也被sharedList保存了；别的线程会优先从自己的threadList中找空闲线程，找不到就从所有线程共享的sharedList中找。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577020540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100067,"user_name":"沙漠里的骆驼","can_delete":false,"product_type":"c1","uid":1012559,"ip_address":"","ucode":"5EC18A71B3A594","user_header":"https://static001.geekbang.org/account/avatar/00/0f/73/4f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1559433904,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23034270384","product_id":100023901,"comment_content":"窃取是在获取本地链接失败时，遍历sharelist实现的","like_count":5},{"had_liked":false,"id":99994,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1559381623,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23034218103","product_id":100023901,"comment_content":"想了半天感觉ConcurrentBag应该是池化的一种通用性优化，但好像会有饥饿问题，如果某些线程总是占用连接，那么某些不经常占用连接的就可能一直拿不到连接，硬想的一个缺点，哈哈哈。","like_count":5},{"had_liked":false,"id":224961,"user_name":"Just","can_delete":false,"product_type":"c1","uid":2022626,"ip_address":"","ucode":"35FA6917DE1D04","user_header":"https://static001.geekbang.org/account/avatar/00/1e/dc/e2/a3abd320.jpg","comment_is_top":false,"comment_ctime":1591602311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14476504199","product_id":100023901,"comment_content":"这个ThreadLocal和JVM内存分配的TLAB（Thread local allocation buffer）还是有点像，先从本地获取，没有的话再去申请","like_count":3},{"had_liked":false,"id":242495,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1597742171,"is_pvip":false,"replies":[{"id":"90227","content":"多次请求之间是不共享任何数据都没有，性能提高只是一次请求范围之内<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1598926687,"ip_address":"","comment_id":242495,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10187676763","product_id":100023901,"comment_content":"看了第二遍，有个疑问，在一半WEB项目中，每次请求SPRING都新建一个线程服务，所以ThreadLocal中的线程并不能重用，这块性能提升就无效了，都去COW中CAS获取可用线程了，CAS在高并发环境中表现并不好","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504021,"discussion_content":"多次请求之间是不共享任何数据都没有，性能提高只是一次请求范围之内\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598926687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100088,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1559441115,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10149375707","product_id":100023901,"comment_content":"可以用栈stack来代替list实现逆序关闭S6~S1吗？","like_count":2,"discussions":[{"author":{"id":1156592,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","nickname":"Joker","note":"","ucode":"126AF848001A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52588,"discussion_content":"那个逆序查找应该不是必须的吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574070559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48808,"discussion_content":"栈里的方法都是同步的，而且弹出操作会有校验参数，感觉结果上可以，性能上没有FastList好吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573529423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293945,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1621643421,"is_pvip":false,"replies":[{"id":"106596","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1621669310,"ip_address":"","comment_id":293945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5916610717","product_id":100023901,"comment_content":"又来打一次卡，配合代码和debug","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520439,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621669310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272781,"user_name":"poordickey","can_delete":false,"product_type":"c1","uid":1810156,"ip_address":"","ucode":"2A436EC813AF97","user_header":"","comment_is_top":false,"comment_ctime":1610279295,"is_pvip":false,"replies":[{"id":"98928","content":"并没有真的close，你调用了一个被hack的方法","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1610366181,"ip_address":"","comment_id":272781,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905246591","product_id":100023901,"comment_content":"这里讲的是连接池  但是很想知道一个数据库连接从拿到到归还的整个过程细节，从一个连接池拿到一个连接，connect之后，执行了SQL，并close了，归还到线程池之后又是怎么一直和数据库保持连接的呢","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513383,"discussion_content":"并没有真的close，你调用了一个被hack的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610366181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220393,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1008071,"ip_address":"","ucode":"9FE5F43055D3AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","comment_is_top":false,"comment_ctime":1590233383,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5885200679","product_id":100023901,"comment_content":"for (int i = list.size() - 1; i &gt;= 0; i--) { final Object entry = list.remove(i);<br><br>遍历的同时删除 会报 currentModityException吧<br><br>另外没看懂为啥需要handoffQueue, 直接从share 里拿 和 threadLocal 里拿不行么","like_count":1,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373296,"discussion_content":"同不明白handOffQueue的作用是啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620693216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1197455,"avatar":"https://static001.geekbang.org/account/avatar/00/12/45/8f/a56b2214.jpg","nickname":"innocent","note":"","ucode":"368659A0DDE7E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388111,"discussion_content":"如果一个线程使用完连接要归还，此时正好有另一个线程需要获取连接，刚好就可以通过手递手的方式把连接给到另一个线程，减少归还线程的操作","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628598167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373296,"ip_address":""},"score":388111,"extra":""}]}]},{"had_liked":false,"id":103299,"user_name":"Geek_89bbab","can_delete":false,"product_type":"c1","uid":1156607,"ip_address":"","ucode":"B3110D5B3C9500","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/ff/6201122c.jpg","comment_is_top":false,"comment_ctime":1560410686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855377982","product_id":100023901,"comment_content":"threadList里面的连接可能也会存在于多个threadList,但是概率相对较小；threadList的连接的remove操作都由本线程来执行，窃取的线程只会把标识设置为已使用，而不会将其从对应的那个threadList移除。可能是为了避免多线程操作同一个队列,而影响性能。所以把移除threadList里的连接的任务交给对应的那个线程。","like_count":1},{"had_liked":false,"id":100227,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1559487467,"is_pvip":false,"replies":[{"id":"36133","content":"只有requite的时候会放到threatlocal里","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559541480,"ip_address":"","comment_id":100227,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854454763","product_id":100023901,"comment_content":"老师， 我看文中提到的是调用requite()释放链接的时候将这个链接添加到本地存储中。<br>那我想问，如果不是调用requite()方法释放连接的情况下，这个连接第一次被放入threadlocal是什么时候啊？ 是第一次获取连接的时候吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452464,"discussion_content":"只有requite的时候会放到threatlocal里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559541480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100164,"user_name":"银时空de梦","can_delete":false,"product_type":"c1","uid":1179017,"ip_address":"","ucode":"EC707B6CF7F287","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/89/cbca1b8e.jpg","comment_is_top":false,"comment_ctime":1559465318,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5854432614","product_id":100023901,"comment_content":"最后数据库连接都到线程本地池中了","like_count":1,"discussions":[{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48807,"discussion_content":"我感觉也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573529126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100112,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1559446754,"is_pvip":false,"replies":[{"id":"36141","content":"呵呵😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559542449,"ip_address":"","comment_id":100112,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854414050","product_id":100023901,"comment_content":"强烈建议老师再讲一期  ","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452415,"discussion_content":"呵呵😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559542449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350461,"user_name":"码小呆","can_delete":false,"product_type":"c1","uid":2055809,"ip_address":"","ucode":"44532D6ABF9340","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","comment_is_top":false,"comment_ctime":1656924677,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656924677","product_id":100023901,"comment_content":"请问是如何 保证数组不会越界的呢？","like_count":0},{"had_liked":false,"id":348993,"user_name":"王应发","can_delete":false,"product_type":"c1","uid":2768731,"ip_address":"","ucode":"EF597BADCC526B","user_header":"","comment_is_top":false,"comment_ctime":1655628649,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655628649","product_id":100023901,"comment_content":"删除statement时，为什么不直接调用clear方法清空？","like_count":0},{"had_liked":false,"id":346249,"user_name":"yellow","can_delete":false,"product_type":"c1","uid":2249111,"ip_address":"","ucode":"C359D1E7BACE3A","user_header":"https://static001.geekbang.org/account/avatar/00/22/51/97/936944e6.jpg","comment_is_top":false,"comment_ctime":1652944246,"is_pvip":false,"replies":[{"id":"126349","content":"所有的连接，不论是否被使用，都在sharedList中","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1652968400,"ip_address":"","comment_id":346249,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652944246","product_id":100023901,"comment_content":"老师你好，请问释放的连接，如果没有，仅仅被保存到线程本地存储中，为什么不需要同时被重新保存到sharedList中呢？<br>不重新保存到sharedList中，别的线程还怎么有机会拿得到这个连接呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572807,"discussion_content":"所有的连接，不论是否被使用，都在sharedList中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652968400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308478,"user_name":"study的程序员","can_delete":false,"product_type":"c1","uid":1023101,"ip_address":"","ucode":"E5AE9037D24429","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","comment_is_top":false,"comment_ctime":1629639301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629639301","product_id":100023901,"comment_content":"如果会被窃取，requite方法中如果没有等待线程为什么不把连接放入sharedList？","like_count":0},{"had_liked":false,"id":294142,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1621784022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621784022","product_id":100023901,"comment_content":"1、老师贴出来的是什么版本的hikariCP，我的版本（com.zaxxer:HikariCP:2.5.1）ConcurrentBag没有handoffQueue属性。<br>2、另外我想监控hikariCP把执行超时（比如6s）的连接释放掉。已经做出的尝试：<br>1）通过Mybatis的设置执行超时(defaultStatementTimeout)无效，生产上30个连接全部被耗尽，再有新请求会一直报错“ Connection is not available, request timed out after 30000ms”。<br><br>现在正在尝试的做法：<br>定时任务循环所有数据库连接，判断执行超过6S的连接，将其底层的Connection 关闭。本地测试能关闭，即能释放连接池中已经Hang住的连接，但是“执行超过6s”这个不好判断。<br><br>另外附上我的应用边库信息：<br>1)应用-&gt;Postgresql_120--&gt;MySQL_FDW--&gt;MySQL_5.7<br>2)上面讲的第1点的失效原因:Postgresql通过MySQL_FDW取MySQL这种场景才设置执行超时失效(直接应用连Postgresql是可以生效的)","like_count":0},{"had_liked":false,"id":159750,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1575778688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575778688","product_id":100023901,"comment_content":"  bagEntry.setState(STATE_NOT_IN_USE);requilte方法里面写的有点问题吧，这个之前已经设置状态，后面for循环里面判断不等于未使用状态，这个多此一举","like_count":0},{"had_liked":false,"id":141577,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1571194198,"is_pvip":true,"replies":[{"id":"54747","content":"先了解实现原理，然后写一个最简单的程序，调试跟代码。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571227543,"ip_address":"","comment_id":141577,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571194198","product_id":100023901,"comment_content":"注意到了requite()的一个细节优化，自己使用完了线程后并不是直接交还给线程池，而是先问下有没有其他线程等待，如果有，那么直接分配就好，这里就减少了一个线程上下文切换带来的损失。不过这里的threadList应该只是会使用线程池的连接，不可以在这个连接上做一些自己数据的存储，因为如果这样就会给每次连接的归还时执行一次清洗工作，想来也会是一次性能的浪费吧。老师，关于连接池源码怎么看啊，像实践下今天课堂上学到的内容，但是不只如何下手","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470804,"discussion_content":"先了解实现原理，然后写一个最简单的程序，调试跟代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571227543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125263,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1566133974,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566133974","product_id":100023901,"comment_content":"老师，您好，下面这一段没有看懂：<br>else if ((i &amp; 0xff) == 0xff) {<br>      parkNanos(MICROSECONDS.toNanos(10));<br> }<br>为什么需要这样一段呢？","like_count":0,"discussions":[{"author":{"id":1561805,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qOYxfAJhznzg3ibHQmOOh2IRTficpPDtNmZwb0MR77cg35vt60VtcX89w4lvnRg4aIDE1ZIpib2rcQpbNicQg1Vicgg/132","nickname":"黄曙光","note":"","ucode":"FEBF44C4230B57","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577046,"discussion_content":"0xff是16进制，表示255。意思是自选到255次就休眠10毫秒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655900090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118230,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1564298500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564298500","product_id":100023901,"comment_content":"看不上眼的优化，居然带来了巨大的性能提升。","like_count":0},{"had_liked":false,"id":103499,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1560468909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560468909","product_id":100023901,"comment_content":"faststatementlist","like_count":0},{"had_liked":false,"id":100294,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1559523733,"is_pvip":false,"replies":[{"id":"36131","content":"我觉得可以开心地笑一下，然后，就没然后了😂😂😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1559541225,"ip_address":"","comment_id":100294,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559523733","product_id":100023901,"comment_content":"根本看不够，强烈建议老师再来一篇","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452489,"discussion_content":"我觉得可以开心地笑一下，然后，就没然后了😂😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559541225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100187,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1559473364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559473364","product_id":100023901,"comment_content":"打卡！","like_count":0},{"had_liked":false,"id":100058,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1559406882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559406882","product_id":100023901,"comment_content":"需要多看几遍","like_count":0},{"had_liked":false,"id":99983,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1559378212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559378212","product_id":100023901,"comment_content":"这样会不会导致每个线程持有50个以下链接，而且每个链接可能在多个线程共存","like_count":0},{"had_liked":false,"id":99971,"user_name":"槑·先生","can_delete":false,"product_type":"c1","uid":1445744,"ip_address":"","ucode":"897F0475592E3A","user_header":"https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg","comment_is_top":false,"comment_ctime":1559374065,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1559374065","product_id":100023901,"comment_content":"面向业务设计数据结构，赞👍","like_count":0},{"had_liked":false,"id":99891,"user_name":"东方奇骥","can_delete":false,"product_type":"c1","uid":1354850,"ip_address":"","ucode":"DEE7085F7E55A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","comment_is_top":false,"comment_ctime":1559353948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559353948","product_id":100023901,"comment_content":"以前只知道ArrayList删除效率低，这优化思想结合了业务场景，看起来简单不说却不知道。项目还在springboot1.x用的阿里巴巴Druid，后面新项目2.x用HaKriCP性能应该会更好。","like_count":0},{"had_liked":false,"id":99873,"user_name":"冯传博","can_delete":false,"product_type":"c1","uid":1177787,"ip_address":"","ucode":"91B9A1EF0FF042","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/bb/8b2ba45d.jpg","comment_is_top":false,"comment_ctime":1559350147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559350147","product_id":100023901,"comment_content":"线程本地的链接是如何被窃取的呢？","like_count":0}]}