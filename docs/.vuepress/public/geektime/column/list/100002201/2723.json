{"id":2723,"title":"34 | 编程范式游记（5）- 修饰器模式","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p>\n<p>在上一讲中，我们领略了函数式编程的趣味和魅力，主要讲了函数式编程的主要技术。还记得有哪些吗？递归、Map、Reduce、Filter等，并利用Python的Decorator和Generator功能，将多个函数组合成了管道。</p>\n<p>此时，你心中可能会有个疑问，这个decorator又是怎样工作的呢？这就是本文中要讲述的内容，“Decorator模式”，又叫“修饰器模式”，或是“装饰器模式”。</p>\n<h1>Python的Decorator</h1>\n<p>Python的Decorator在使用上和Java的Annotation（以及C#的Attribute）很相似，就是在方法名前面加一个@XXX注解来为这个方法装饰一些东西。但是，Java/C#的Annotation也很让人望而却步，太过于复杂了。你要玩它，需要先了解一堆Annotation的类库文档，感觉几乎就是在学另外一门语言。</p>\n<p>而Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法，这种方法不需要你去掌握什么复杂的OO模型或是Annotation的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。</p>\n<p>这是我最喜欢的一个模式了，也是一个挺好玩儿的东西，这个模式动用了函数式编程的一个技术——用一个函数来构造另一个函数。</p>\n<!-- [[[read_end]]] -->\n<p>好了，我们先来点感性认识，看一个Python修饰器的Hello World代码。</p>\n<pre><code>def hello(fn):\n    def wrapper():\n        print &quot;hello, %s&quot; % fn.__name__\n        fn()\n        print &quot;goodbye, %s&quot; % fn.__name__\n    return wrapper\n \n@hello\ndef Hao():\n    print &quot;i am Hao Chen&quot;\n \nHao()\n</code></pre>\n<p>代码的执行结果如下：</p>\n<pre><code>$ python hello.py\nhello, Hao\ni am Hao Chen\ngoodbye, Hao\n</code></pre>\n<p>你可以看到如下的东西：</p>\n<ol>\n<li>\n<p>函数 <code>Hao</code> 前面有个@hello的“注解”，<code>hello</code> 就是我们前面定义的函数 <code>hello</code>；</p>\n</li>\n<li>\n<p>在 <code>hello</code> 函数中，其需要一个 <code>fn</code> 的参数（这就是用来做回调的函数）；</p>\n</li>\n<li>\n<p>hello函数中返回了一个inner函数 <code>wrapper</code>，这个 <code>wrapper</code>函数回调了传进来的 <code>fn</code>，并在回调前后加了两条语句。</p>\n</li>\n</ol>\n<p>对于Python的这个@注解语法糖（Syntactic sugar）来说，当你在用某个@decorator来修饰某个函数 <code>func</code> 时，如下所示:</p>\n<pre><code>@decorator\ndef func():\n    pass\n</code></pre>\n<p>其解释器会解释成下面这样的语句：</p>\n<pre><code>func = decorator(func)\n</code></pre>\n<p>嘿！这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的。但是，我们需要注意，那里还有一个赋值语句，把decorator这个函数的返回值赋值回了原来的 <code>func</code>。</p>\n<p>我们再来看一个带参数的玩法：</p>\n<pre><code>def makeHtmlTag(tag, *args, **kwds):\n    def real_decorator(fn):\n        css_class = &quot; class='{0}'&quot;.format(kwds[&quot;css_class&quot;]) \\\n                                     if &quot;css_class&quot; in kwds else &quot;&quot;\n        def wrapped(*args, **kwds):\n            return &quot;&lt;&quot;+tag+css_class+&quot;&gt;&quot; + fn(*args, **kwds) + &quot;&lt;/&quot;+tag+&quot;&gt;&quot;\n        return wrapped\n    return real_decorator\n \n@makeHtmlTag(tag=&quot;b&quot;, css_class=&quot;bold_css&quot;)\n@makeHtmlTag(tag=&quot;i&quot;, css_class=&quot;italic_css&quot;)\ndef hello():\n    return &quot;hello world&quot;\n \nprint hello()\n \n# 输出：\n# &lt;b class='bold_css'&gt;&lt;i class='italic_css'&gt;hello world&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<p>在上面这个例子中，我们可以看到：<code>makeHtmlTag</code>有两个参数。所以，为了让 <code>hello = makeHtmlTag(arg1, arg2)(hello)</code> 成功， <code>makeHtmlTag</code> 必需返回一个decorator（这就是为什么我们在 <code>makeHtmlTag</code> 中加入了 <code>real_decorator()</code>）。</p>\n<p>这样一来，我们就可以进入到decorator的逻辑中去了——decorator得返回一个wrapper，wrapper里回调 <code>hello</code>。看似那个 <code>makeHtmlTag()</code> 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然。</p>\n<p>我们再来看一个为其它函数加缓存的示例：</p>\n<pre><code>from functools import wraps\ndef memoization(fn):\n    cache = {}\n    miss = object()\n \n    @wraps(fn)\n    def wrapper(*args):\n        result = cache.get(args, miss)\n        if result is miss:\n            result = fn(*args)\n            cache[args] = result\n        return result\n \n    return wrapper\n \n@memoization\ndef fib(n):\n    if n &lt; 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n</code></pre>\n<p>上面这个例子中，是一个斐波那契数列的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成 <code>fib(4) + fib(3)</code>，而 <code>fib(4)</code> 分解成 <code>fib(3) + fib(2)</code>，<code>fib(3)</code> 又分解成<code>fib(2) + fib(1)</code>……你可以看到，基本上来说，<code>fib(3)</code>、<code>fib(2)</code>、<code>fib(1)</code>在整个递归过程中被调用了至少两次。</p>\n<p>而我们用decorator，在调用函数前查询一下缓存，如果没有才调用，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。<code>wraps</code> 的作用是保证 <code>fib</code> 的函数名不被 <code>wrapper</code> 所取代。</p>\n<p>除此之外，Python还支持类方式的decorator。</p>\n<pre><code>class myDecorator(object):\n    def __init__(self, fn):\n        print &quot;inside myDecorator.__init__()&quot;\n        self.fn = fn\n \n    def __call__(self):\n        self.fn()\n        print &quot;inside myDecorator.__call__()&quot;\n \n@myDecorator\ndef aFunction():\n    print &quot;inside aFunction()&quot;\n \nprint &quot;Finished decorating aFunction()&quot;\n \naFunction()\n \n# 输出：\n# inside myDecorator.__init__()\n# Finished decorating aFunction()\n# inside aFunction()\n# inside myDecorator.__call__()\n</code></pre>\n<p>上面这个示例展示了，用类的方式声明一个decorator。我们可以看到这个类中有两个成员：</p>\n<ol>\n<li>一个是<code>__init__()</code>，这个方法是在我们给某个函数decorate时被调用，所以，需要有一个 <code>fn</code> 的参数，也就是被decorate的函数。</li>\n<li>一个是<code>__call__()</code>，这个方法是在我们调用被decorate的函数时被调用的。</li>\n</ol>\n<p>从上面的输出中，可以看到整个程序的执行顺序，这看上去要比“函数式”的方式更易读一些。</p>\n<p>我们来看一个实际点的例子，下面这个示例展示了通过URL的路由来调用相关注册的函数示例：</p>\n<pre><code>class MyApp():\n    def __init__(self):\n        self.func_map = {}\n \n    def register(self, name):\n        def func_wrapper(func):\n            self.func_map[name] = func\n            return func\n        return func_wrapper\n \n    def call_method(self, name=None):\n        func = self.func_map.get(name, None)\n        if func is None:\n            raise Exception(&quot;No function registered against - &quot; + str(name))\n        return func()\n \napp = MyApp()\n \n@app.register('/')\ndef main_page_func():\n    return &quot;This is the main page.&quot;\n \n@app.register('/next_page')\ndef next_page_func():\n    return &quot;This is the next page.&quot;\n \nprint app.call_method('/')\nprint app.call_method('/next_page')\n</code></pre>\n<p>注意：上面这个示例中decorator类不是真正的decorator，其中也没有<code>__call__()</code>，并且，wrapper返回了原函数。所以，原函数没有发生任何变化。</p>\n<h1>Go语言的Decorator</h1>\n<p>Python有语法糖，所以写出来的代码比较酷。但是对于没有修饰器语法糖这类语言，写出来的代码会是怎么样的？我们来看一下Go语言的代码。</p>\n<p>还是从一个Hello World开始。</p>\n<pre><code>package main\n\nimport &quot;fmt&quot;\n\nfunc decorator(f func(s string)) func(s string) {\n    return func(s string) {\n        fmt.Println(&quot;Started&quot;)\n        f(s)\n        fmt.Println(&quot;Done&quot;)\n    }\n}\n\nfunc Hello(s string) {\n    fmt.Println(s)\n}\n\nfunc main() {\n    decorator(Hello)(&quot;Hello, World!&quot;)\n}\n</code></pre>\n<p>可以看到，我们动用了一个高阶函数 <code>decorator()</code>，在调用的时候，先把 <code>Hello()</code> 函数传进去，然后其返回一个匿名函数。这个匿名函数中除了运行了自己的代码，也调用了被传入的 <code>Hello()</code> 函数。</p>\n<p>这个玩法和Python的异曲同工，只不过，Go并不支持像Python那样的@decorator语法糖。所以，在调用上有些难看。当然，如果要想让代码容易读一些，你可以这样：</p>\n<pre><code>hello := decorator(Hello)\nhello(&quot;Hello&quot;)\n</code></pre>\n<p>我们再来看一个为函数log消耗时间的例子：</p>\n<pre><code>type SumFunc func(int64, int64) int64\n\nfunc getFunctionName(i interface{}) string {\n    return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()\n}\n\nfunc timedSumFunc(f SumFunc) SumFunc {\n    return func(start, end int64) int64 {\n        defer func(t time.Time) {\n            fmt.Printf(&quot;--- Time Elapsed (%s): %v ---\\n&quot;, \n                getFunctionName(f), time.Since(t))\n        }(time.Now())\n        return f(start, end)\n    }\n}\n\nfunc Sum1(start, end int64) int64 {\n    var sum int64\n    sum = 0\n    if start &gt; end {\n        start, end = end, start\n    }\n    for i := start; i &lt;= end; i++ {\n        sum += i\n    }\n    return sum\n}\n\nfunc Sum2(start, end int64) int64 {\n    if start &gt; end {\n        start, end = end, start\n    }\n    return (end - start + 1) * (end + start) / 2\n}\n\nfunc main() {\n\n    sum1 := timedSumFunc(Sum1)\n    sum2 := timedSumFunc(Sum2)\n\n    fmt.Printf(&quot;%d, %d\\n&quot;, sum1(-10000, 10000000), sum2(-10000, 10000000))\n}\n</code></pre>\n<p>关于上面的代码：</p>\n<ul>\n<li>\n<p>有两个 Sum 函数，<code>Sum1()</code> 函数就是简单地做个循环，<code>Sum2()</code> 函数动用了数据公式。（注意：<code>start</code> 和 <code>end</code> 有可能有负数的情况。）</p>\n</li>\n<li>\n<p>代码中使用了Go语言的反射机制来获取函数名。</p>\n</li>\n<li>\n<p>修饰器函数是 <code>timedSumFunc()</code>。</p>\n</li>\n</ul>\n<p>再来看一个 HTTP 路由的例子：</p>\n<pre><code>func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(&quot;---&gt;WithServerHeader()&quot;)\n        w.Header().Set(&quot;Server&quot;, &quot;HelloServer v0.0.1&quot;)\n        h(w, r)\n    }\n}\n \nfunc WithAuthCookie(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(&quot;---&gt;WithAuthCookie()&quot;)\n        cookie := &amp;http.Cookie{Name: &quot;Auth&quot;, Value: &quot;Pass&quot;, Path: &quot;/&quot;}\n        http.SetCookie(w, cookie)\n        h(w, r)\n    }\n}\n \nfunc WithBasicAuth(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(&quot;---&gt;WithBasicAuth()&quot;)\n        cookie, err := r.Cookie(&quot;Auth&quot;)\n        if err != nil || cookie.Value != &quot;Pass&quot; {\n            w.WriteHeader(http.StatusForbidden)\n            return\n        }\n        h(w, r)\n    }\n}\n \nfunc WithDebugLog(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(&quot;---&gt;WithDebugLog&quot;)\n        r.ParseForm()\n        log.Println(r.Form)\n        log.Println(&quot;path&quot;, r.URL.Path)\n        log.Println(&quot;scheme&quot;, r.URL.Scheme)\n        log.Println(r.Form[&quot;url_long&quot;])\n        for k, v := range r.Form {\n            log.Println(&quot;key:&quot;, k)\n            log.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))\n        }\n        h(w, r)\n    }\n}\nfunc hello(w http.ResponseWriter, r *http.Request) {\n    log.Printf(&quot;Received Request %s from %s\\n&quot;, r.URL.Path, r.RemoteAddr)\n    fmt.Fprintf(w, &quot;Hello, World! &quot;+r.URL.Path)\n}\n</code></pre>\n<p>上面的代码中，我们写了多个函数。有写HTTP响应头的，有写认证Cookie的，有检查认证Cookie的，有打日志的……在使用过程中，我们可以把其嵌套起来使用，在修饰过的函数上继续修饰，这样就可以拼装出更复杂的功能。</p>\n<pre><code>func main() {\n    http.HandleFunc(&quot;/v1/hello&quot;, WithServerHeader(WithAuthCookie(hello)))\n    http.HandleFunc(&quot;/v2/hello&quot;, WithServerHeader(WithBasicAuth(hello)))\n    http.HandleFunc(&quot;/v3/hello&quot;, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))\n    err := http.ListenAndServe(&quot;:8080&quot;, nil)\n    if err != nil {\n        log.Fatal(&quot;ListenAndServe: &quot;, err)\n    }\n}\n</code></pre>\n<p>当然，如果一层套一层不好看的话，我们可以使用pipeline的玩法，需要先写一个工具函数——用来遍历并调用各个decorator：</p>\n<pre><code>type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc\n \nfunc Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {\n    for i := range decors {\n        d := decors[len(decors)-1-i] // iterate in reverse\n        h = d(h)\n    }\n    return h\n}\n</code></pre>\n<p>然后，我们就可以像下面这样使用了。</p>\n<pre><code>http.HandleFunc(&quot;/v4/hello&quot;, Handler(hello,\n                WithServerHeader, WithBasicAuth, WithDebugLog))\n</code></pre>\n<p>这样的代码是不是更易读了一些？pipeline的功能也就出来了。</p>\n<p>不过，对于Go的修饰器模式，还有一个小问题——好像无法做到泛型，就像上面那个计算时间的函数一样，它的代码耦合了需要被修饰的函数的接口类型，无法做到非常通用。如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。</p>\n<p>因为Go语言不像Python和Java，Python是动态语言，而Java有语言虚拟机，所以它们可以干许多比较变态的事儿，然而Go语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go语言支持的最大的泛型是interface{}，还有比较简单的Reflection机制，在上面做做文章，应该还是可以搞定的。</p>\n<p>废话不说，下面是我用Reflection机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）。</p>\n<pre><code>func Decorator(decoPtr, fn interface{}) (err error) {\n    var decoratedFunc, targetFunc reflect.Value\n \n    decoratedFunc = reflect.ValueOf(decoPtr).Elem()\n    targetFunc = reflect.ValueOf(fn)\n \n    v := reflect.MakeFunc(targetFunc.Type(),\n        func(in []reflect.Value) (out []reflect.Value) {\n            fmt.Println(&quot;before&quot;)\n            out = targetFunc.Call(in)\n            fmt.Println(&quot;after&quot;)\n            return\n        })\n \n    decoratedFunc.Set(v)\n    return\n}\n</code></pre>\n<p>上面的代码动用了 <code>reflect.MakeFunc()</code> 函数制作出了一个新的函数，其中的 <code>targetFunc.Call(in)</code> 调用了被修饰的函数。关于Go语言的反射机制，推荐官方文章——《<a href=\"https://blog.golang.org/laws-of-reflection\">The Laws of Reflection</a>》，在这里我不多说了。</p>\n<p>上面这个 <code>Decorator()</code> 需要两个参数：</p>\n<ul>\n<li>第一个是出参 <code>decoPtr</code> ，就是完成修饰后的函数。</li>\n<li>第二个是入参 <code>fn</code> ，就是需要修饰的函数。</li>\n</ul>\n<p>这样写是不是有些二？的确是的。不过，这是我个人在Go语言里所能写出来的最好的代码了。如果你知道更优雅的写法，请你一定告诉我！</p>\n<p>好的，让我们来看一下使用效果。首先，假设我们有两个需要修饰的函数：</p>\n<pre><code>func foo(a, b, c int) int {\n    fmt.Printf(&quot;%d, %d, %d \\n&quot;, a, b, c)\n    return a + b + c\n}\n \nfunc bar(a, b string) string {\n    fmt.Printf(&quot;%s, %s \\n&quot;, a, b)\n    return a + b\n}\n</code></pre>\n<p>然后，我们可以这样做：</p>\n<pre><code>type MyFoo func(int, int, int) int\nvar myfoo MyFoo\nDecorator(&amp;myfoo, foo)\nmyfoo(1, 2, 3)\n</code></pre>\n<p>你会发现，使用 <code>Decorator()</code> 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？谁叫这是有类型的静态编译的语言呢？</p>\n<p>嗯。如果你不想声明函数签名，那么也可以这样：</p>\n<pre><code>mybar := bar\nDecorator(&amp;mybar, bar)\nmybar(&quot;hello,&quot;, &quot;world!&quot;)\n</code></pre>\n<p>好吧，看上去不是那么得漂亮，但是it does work。看样子Go语言目前本身的特性无法做成像Java或Python那样，对此，我们只能多求Go语言多放糖了！</p>\n<h1>小结</h1>\n<p>好了，讲了那么多的例子，看了那么多的代码，我估计你可能有点晕，让我们来做个小结吧。</p>\n<p>通过上面Python和Go修饰器的例子，我们可以看到，所谓的修饰器模式其实是在做下面的几件事。</p>\n<ul>\n<li>\n<p>表面上看，修饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事，或是在现有的函数功能上再附加上一些别的功能。</p>\n</li>\n<li>\n<p>除了我们可以感受到<strong>函数式编程</strong>下的代码扩展能力，我们还能感受到函数的互相和随意拼装带来的好处。</p>\n</li>\n<li>\n<p>但是深入看一下，我们不难发现，Decorator这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）。</p>\n</li>\n</ul>\n<p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。</p>\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/301\">01 | 编程范式游记：起源</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/303\">02 | 编程范式游记：泛型编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2017\">03 | 编程范式游记：类型系统和泛型的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2711\">04 | 编程范式游记：函数式编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2723\">05 | 编程范式游记：修饰器模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2729\">06 | 编程范式游记：面向对象编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2741\">07 | 编程范式游记：基于原型的编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2748\">08 | 编程范式游记：Go 语言的委托模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2751\">09 | 编程范式游记：编程的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2752\">10 | 编程范式游记：逻辑编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2754\">11 | 编程范式游记：程序世界里的编程范式</a></li>\n</ul>\n","comments":[{"had_liked":false,"id":2518,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1517553795,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"173316245635","product_id":100002201,"comment_content":"越看越觉得装饰器模式是属于AOP思想的一种实现🤔。","like_count":40,"discussions":[{"author":{"id":1763208,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e7/88/c8b4ad9c.jpg","nickname":"没有昵称","note":"","ucode":"565783BDD01CE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276038,"discussion_content":"设计模式中分成了装饰器和代理两种模式","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590805185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123103,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/1f/6452b2e8.jpg","nickname":"刘清斌","note":"","ucode":"775B053AF87B53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246878,"discussion_content":"用途和AOP一样，都是用在非业务的场景","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587783762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375693,"discussion_content":"Aop就是装饰者模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621818815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2002555,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8e/7b/701c741f.jpg","nickname":"难得自然萌","note":"","ucode":"73C86B48236104","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301811,"discussion_content":"思想是一致的实现不同吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598668543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1598564,"avatar":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","nickname":"劳码识途","note":"","ucode":"7AEF4D9407F097","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298604,"discussion_content":"这就是一种动态织入，是一种动态代理的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597340395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105548,"user_name":"陈华","can_delete":false,"product_type":"c1","uid":1082730,"ip_address":"","ucode":"3AF9E8EB39E507","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132","comment_is_top":false,"comment_ctime":1561026860,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87460372780","product_id":100002201,"comment_content":"...感觉还是转行算了....，","like_count":20,"discussions":[{"author":{"id":2110272,"avatar":"https://static001.geekbang.org/account/avatar/00/20/33/40/69c65edc.jpg","nickname":"ITCamel","note":"","ucode":"FB260BF4A9DD46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394598,"discussion_content":"哈哈，有些东西写起业务代码来不深究是确实用不到的，不过真去看框架代码了，就会发现到处都是这东西。浩哥是比较牛的，所以各个语言的特性都能把握住本质。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631952465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3156,"user_name":"minghu6","can_delete":false,"product_type":"c1","uid":1050269,"ip_address":"","ucode":"F44058E21B14C9","user_header":"","comment_is_top":false,"comment_ctime":1518591393,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53058198945","product_id":100002201,"comment_content":"其实Java装饰器和Python装饰器还是差别挺大的，Python装饰器是一个高阶函数，Java的则真的是&quot;注解&quot;，只是起到一个打标签的作用，还要另外的类来检查特定标签进行特定处理。","like_count":13,"discussions":[{"author":{"id":1598564,"avatar":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","nickname":"劳码识途","note":"","ucode":"7AEF4D9407F097","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298606,"discussion_content":"Java中的注解可以理解为数据接口，因为Java 中传统的接口只针对行为，而不针对属性，同时Java中的注解也是一种元编程的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597340481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2347,"user_name":"麻花快跑","can_delete":false,"product_type":"c1","uid":1042579,"ip_address":"","ucode":"835D2234751AF6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/93/bc8166d2.jpg","comment_is_top":false,"comment_ctime":1516847317,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44466520277","product_id":100002201,"comment_content":"耗子叔，我看你博客和文章很久了，从coolshell就开始了，现在也快30了，但是越来越焦虑，他们都说是30岁程序员的普遍情况，希望耗子叔能以过来人的身份写下这方面的文章，为我们指点下迷路","like_count":10,"discussions":[{"author":{"id":1085152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","nickname":"爱学习的大叔","note":"","ucode":"91F9ABF1EC98D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319844,"discussion_content":"我35了都不怕，你怕啥。。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1604139361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1000417,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/e1/b7be5560.jpg","nickname":"sam","note":"","ucode":"8D48F4B9045947","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1085152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","nickname":"爱学习的大叔","note":"","ucode":"91F9ABF1EC98D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361383,"discussion_content":"学习不断👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616657005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319844,"ip_address":""},"score":361383,"extra":""}]}]},{"had_liked":false,"id":2339,"user_name":"浩子","can_delete":false,"product_type":"c1","uid":1027495,"ip_address":"","ucode":"91473789B31BA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ad/a7/14246c67.jpg","comment_is_top":false,"comment_ctime":1516844619,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31581615691","product_id":100002201,"comment_content":"耗子哥，文章写的很有意思。最近也在相继学习Go语言。 <br>不过我很纠结，我是一名.net的技术主管，最近想开拓其他语言的方向。可是却不知道从何下手，比较感兴趣的有Go，Java，Python。可是时间总是有限的。 不知道从哪面方面进行深入研究。","like_count":7,"discussions":[{"author":{"id":1085152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","nickname":"爱学习的大叔","note":"","ucode":"91F9ABF1EC98D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319845,"discussion_content":"我也是搞.net的，业余时间都学点前端。哈哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604139493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1660330,"avatar":"https://static001.geekbang.org/account/avatar/00/19/55/aa/c79c292c.jpg","nickname":"Erebus","note":"","ucode":"81CC93A6D7A4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363277,"discussion_content":"深入浅出golang rust","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617160630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50036,"user_name":"少盐","can_delete":false,"product_type":"c1","uid":1305743,"ip_address":"","ucode":"BCC7E264B75702","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/8f/8299495a.jpg","comment_is_top":false,"comment_ctime":1544846128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27314649904","product_id":100002201,"comment_content":"基本没看懂，后面的总结基本知道装饰器是干嘛的","like_count":6},{"had_liked":false,"id":316956,"user_name":"seedjyh","can_delete":false,"product_type":"c1","uid":2309641,"ip_address":"","ucode":"D590E526A9A1D7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4IPqj4H3jQHq4C1lgKh6ZroK3CVmGLiadic7S1rxbuy09JM9x8Aib6VkozPkO4lrUTHAhicX1z9Cg2w/132","comment_is_top":false,"comment_ctime":1634627921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18814497105","product_id":100002201,"comment_content":"理解python的函数型装饰器，关键就是分清3个函数。<br>- 被装饰的函数 raw_fn<br>- 装饰后的函数 new_fn<br>- 执行装饰的函数 decoractor_fn<br>其中，raw_fn 和 new_fn 的函数签名（参数和返回值）是相同的，就是一连串@之后真正手写def的那个函数。<br>decoractor_fn 的参数是 raw_fn，在内部定义new_fn并返回之。<br><br>至于带参数的装饰器，其实就是产生装饰器的工厂，本身并不是装饰器。<br>decoractor_factory的参数可以随便写，其内部定义一个decoractor_fn并返回。<br><br>类模式的装饰器有点像C++的仿函数。<br><br>Golang的装饰器，在框架echo的middleware这里体现得淋漓尽致。","like_count":5},{"had_liked":false,"id":105714,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1561078148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14445980036","product_id":100002201,"comment_content":"通过装饰器，我们很容易的给代码添加一些功能，附加执行一些操作。然后深入之后发现装饰器可以修饰任何函数，加不同函数随意组合和拼装往往会带来一些神奇的效果，恰如linux的编码哲学，一个工具只做一件事并把这件事做到极致。<br>通过装饰器的封装，我们可以把很多业务逻辑，重复代码给消除，从而优化代码","like_count":3},{"had_liked":false,"id":25529,"user_name":"恒","can_delete":false,"product_type":"c1","uid":1105216,"ip_address":"","ucode":"5B0BD0F12AE23E","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/40/b2183a47.jpg","comment_is_top":false,"comment_ctime":1537353868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14422255756","product_id":100002201,"comment_content":"go语言的第一个例子让我联想到java的静态代理，后面反射的例子让我联想到java的动态代理","like_count":3},{"had_liked":false,"id":98196,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1558928791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10148863383","product_id":100002201,"comment_content":"这一章的内容真带劲","like_count":2},{"had_liked":false,"id":39776,"user_name":"杨智晓 ✟","can_delete":false,"product_type":"c1","uid":1024263,"ip_address":"","ucode":"E3B56F4A38F63D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/07/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1542354699,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10132289291","product_id":100002201,"comment_content":"哎，Go语言的语法真是看着别扭，虽然知道Go强劲","like_count":2,"discussions":[{"author":{"id":1319157,"avatar":"https://static001.geekbang.org/account/avatar/00/14/20/f5/6cdbfa90.jpg","nickname":"刘匿名","note":"","ucode":"CB4C1DC8C1BB31","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332399,"discussion_content":"两年过去了，语法上还是没有太多改善……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607180063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1350286,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/8e/69856382.jpg","nickname":"蓝舵手","note":"","ucode":"4F6DA4D8CB13E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1319157,"avatar":"https://static001.geekbang.org/account/avatar/00/14/20/f5/6cdbfa90.jpg","nickname":"刘匿名","note":"","ucode":"CB4C1DC8C1BB31","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":565888,"discussion_content":"一年半过去了，泛型出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650552893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332399,"ip_address":""},"score":565888,"extra":""}]}]},{"had_liked":false,"id":17306,"user_name":"亮出","can_delete":false,"product_type":"c1","uid":1014289,"ip_address":"","ucode":"A7673283D03656","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/11/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1532564137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10122498729","product_id":100002201,"comment_content":"编程的例子，有github么","like_count":2},{"had_liked":false,"id":6463,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1524748116,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10114682708","product_id":100002201,"comment_content":"python和go基本语法要看看上面有的函数例子，没看懂。","like_count":2},{"had_liked":false,"id":288249,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1618380597,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5913347893","product_id":100002201,"comment_content":"第一个python装饰器代码，python 3.X版本，写法有点不同可能，可以试试我的，看看可不可以直接运行：<br><br>def hello(fn):<br>    def wrapper():<br>        print(&quot;hello, %s&quot; % fn.__name__)<br>        fn()<br>        print(&quot;goodbye, %s&quot; % fn.__name__)<br><br>    return wrapper<br><br><br>@hello<br>def Hao():<br>    print(&quot;i am Hao Chen&quot;)<br><br><br>Hao()","like_count":1,"discussions":[{"author":{"id":1583747,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/83/23a56f7b.jpg","nickname":"风大苏","note":"","ucode":"6444B5B5FCF333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585816,"discussion_content":"主要就是 py2 和 py3 在 pirnt 函数上的使用差别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661841956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233717,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1594406790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889374086","product_id":100002201,"comment_content":"感觉本质还是函数式编程里面的closure...函数式里面都是immutable的，所以closure是很安全的...但是python和go这类的语言是有状态的，debug closure的时候就很痛苦...比如你传了一个python dict或者go的pointer...wrapped function很可能就会产生让人头痛的side effect...大家用的时候又喜欢滥用...总体感觉，感觉decorator就是动态语言的generics...","like_count":1},{"had_liked":false,"id":212872,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1588230018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883197314","product_id":100002201,"comment_content":"函数式编程中的 Decorator 用法，我在很多程序代码或脚本中看到过，原来这种写法有个名字叫 Decorator，像 Pipeline 一样连接所有的函数。有一种贯通已有编程认知的感觉，就像零碎的知识被串联在一起。","like_count":1},{"had_liked":false,"id":288269,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1618387915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618387915","product_id":100002201,"comment_content":"装饰模式突然讲几个语言的实现串在一起对比，感觉明白了点，之前只关注细节没有考虑到后面的设计模式。","like_count":0},{"had_liked":false,"id":257817,"user_name":"爱学习的大叔","can_delete":false,"product_type":"c1","uid":1085152,"ip_address":"","ucode":"91F9ABF1EC98D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/e0/847348b1.jpg","comment_is_top":false,"comment_ctime":1604139753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604139753","product_id":100002201,"comment_content":"感觉有点像.net 里边的面向切面(AOP),给流程上节外生枝，做点别的事情。","like_count":0},{"had_liked":false,"id":256600,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1603689762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603689762","product_id":100002201,"comment_content":"关于 Go 的修饰器后半部分(正文最后四分之一)，我还没完全看懂，可能是因为缺少 Go 的语言基础。但 Python 比较熟悉，修饰器部分也能够明白。<br><br>自己同事使用 Python 的修饰器，成功做了一些 动态加载函数 的功能，可谓是让后期我们的某个环节的工作效率提高了数倍。从十多分钟的操作，改写为10s的工作。","like_count":0},{"had_liked":false,"id":246271,"user_name":"你为啥那么牛","can_delete":false,"product_type":"c1","uid":1503506,"ip_address":"","ucode":"1ABC604A54A8F6","user_header":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","comment_is_top":false,"comment_ctime":1599235489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599235489","product_id":100002201,"comment_content":"从来没学过python，通过这篇文章，我学会了。而且，全部看懂了。","like_count":0},{"had_liked":false,"id":244674,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1598609447,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1598609447","product_id":100002201,"comment_content":"Go语言的Decrorator太造作了，与其这样，还不如，直接声明一个新的函数对原有函数包装一下那么直接明了。","like_count":0},{"had_liked":false,"id":223397,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1591081060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591081060","product_id":100002201,"comment_content":"我咋感觉Python的Decorator看着很像代理模式你呢","like_count":0},{"had_liked":false,"id":211796,"user_name":"BeginYan","can_delete":false,"product_type":"c1","uid":1082843,"ip_address":"","ucode":"BB06C4712E6383","user_header":"https://static001.geekbang.org/account/avatar/00/10/85/db/f978ddcd.jpg","comment_is_top":false,"comment_ctime":1588007696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588007696","product_id":100002201,"comment_content":"最喜欢的python中的装饰器","like_count":0},{"had_liked":false,"id":169430,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1578355986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578355986","product_id":100002201,"comment_content":"修饰器模式，用来做什么，粗看了几个例子只记得是可以在函数前后自动调用。但确实就像java注解一般，它用注入的方式实现了函数功能的添加，在日志，缓存等场景把功能性，通用性能力抽象出来。而抽象，也就是范型的意义之一。<br>附作者的说明：<br>但是深入看一下，我们不难发现，Decorator 这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像 for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）。","like_count":0},{"had_liked":false,"id":135951,"user_name":"磉盘","can_delete":false,"product_type":"c1","uid":1055624,"ip_address":"","ucode":"1C245991F30A73","user_header":"https://static001.geekbang.org/account/avatar/00/10/1b/88/ac69f57a.jpg","comment_is_top":false,"comment_ctime":1569313725,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1569313725","product_id":100002201,"comment_content":"可以用“触类旁通”这词来形容，面向对象有修饰器模式，python和go有修饰器语法，Java有注释解。了这些概念可以更好地理解语言。就像总结里说的，他们都实现了相同的几点功能。","like_count":0},{"had_liked":false,"id":133132,"user_name":"nil","can_delete":false,"product_type":"c1","uid":1507193,"ip_address":"","ucode":"0F5D298C1CBB74","user_header":"https://static001.geekbang.org/account/avatar/00/16/ff/79/3b38c9e1.jpg","comment_is_top":false,"comment_ctime":1568374920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568374920","product_id":100002201,"comment_content":"函数是一等公民，使得装饰者模式变得想当精简，使用oop实现装饰者模式就没有fp这么beautiful了，python的注解语法糖看起来想当优雅","like_count":0},{"had_liked":false,"id":121108,"user_name":"Geek_0be289","can_delete":false,"product_type":"c1","uid":1589753,"ip_address":"","ucode":"E11A6530B31512","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq9mcgmFDsACbcmMBKK6IoNMgg8ZFsriaXzEsu4iam3kf9Yk7z0lPNwyG5rRulGwbmAjdaHVxmm6bFQ/132","comment_is_top":false,"comment_ctime":1565059796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565059796","product_id":100002201,"comment_content":"可惜的是如果高频使用反射，性能会损耗很厉害","like_count":0}]}