{"id":9266,"title":"第18讲 | 什么情况下Java程序会产生死锁？如何定位、修复？","content":"<p>今天，我会介绍一些日常开发中类似线程死锁等问题的排查经验，并选择一两个我自己修复过或者诊断过的核心类库死锁问题作为例子，希望不仅能在面试时，包括在日常工作中也能对你有所帮助。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">什么情况下Java程序会产生死锁？如何定位、修复？</span></p>\n<h2>典型回答</h2>\n<p>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p>\n<p>你可以利用下面的示例图理解基本的死锁问题：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ea/6c/ea88719ec112dead21334034c9ef8a6c.png?wh=551*356\" alt=\"\" /></p>\n<p>定位死锁最常见的方式就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往jstack等就能直接定位，类似JConsole甚至可以在图形界面进行有限的死锁检测。</p>\n<p>如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。</p>\n<h2>考点分析</h2>\n<p>今天的问题偏向于实用场景，大部分死锁本身并不难定位，掌握基本思路和工具使用，理解线程相关的基本概念，比如各种线程状态和同步、锁、Latch等并发工具，就已经足够解决大多数问题了。</p><!-- [[[read_end]]] -->\n<p>针对死锁，面试官可以深入考察：</p>\n<ul>\n<li>\n<p>抛开字面上的概念，让面试者写一个可能死锁的程序，顺便也考察下基本的线程编程。</p>\n</li>\n<li>\n<p>诊断死锁有哪些工具，如果是分布式环境，可能更关心能否用API实现吗？</p>\n</li>\n<li>\n<p>后期诊断死锁还是挺痛苦的，经常加班，如何在编程中尽量避免一些典型场景的死锁，有其他工具辅助吗？</p>\n</li>\n</ul>\n<h2>知识扩展</h2>\n<p>在分析开始之前，先以一个基本的死锁程序为例，我在这里只用了两个嵌套的synchronized去获取锁，具体如下：</p>\n<pre><code>public class DeadLockSample extends Thread {\n\tprivate String first;\n\tprivate String second;\n\tpublic DeadLockSample(String name, String first, String second) {\n    \tsuper(name);\n    \tthis.first = first;\n    \tthis.second = second;\n\t}\n\n\tpublic  void run() {\n    \tsynchronized (first) {\n        \tSystem.out.println(this.getName() + &quot; obtained: &quot; + first);\n        \ttry {\n            \tThread.sleep(1000L);\n            \tsynchronized (second) {\n                \tSystem.out.println(this.getName() + &quot; obtained: &quot; + second);\n            \t}\n        \t} catch (InterruptedException e) {\n            \t// Do nothing\n        \t}\n    \t}\n\t}\n\tpublic static void main(String[] args) throws InterruptedException {\n    \tString lockA = &quot;lockA&quot;;\n    \tString lockB = &quot;lockB&quot;;\n    \tDeadLockSample t1 = new DeadLockSample(&quot;Thread1&quot;, lockA, lockB);\n    \tDeadLockSample t2 = new DeadLockSample(&quot;Thread2&quot;, lockB, lockA);\n    \tt1.start();\n    \tt2.start();\n    \tt1.join();\n    \tt2.join();\n\t}\n}\n</code></pre>\n<p>这个程序编译执行后，几乎每次都可以重现死锁，请看下面截取的输出。另外，这里有个比较有意思的地方，为什么我先调用Thread1的start，但是Thread2却先打印出来了呢？这就是因为线程调度依赖于（操作系统）调度器，虽然你可以通过优先级之类进行影响，但是具体情况是不确定的。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/86/0e/869f3a3d7b759fbfb794f8c81047f30e.png?wh=328*57\" alt=\"\" /></p>\n<p>下面来模拟问题定位，我就选取最常见的jstack，其他一些类似JConsole等图形化的工具，请自行查找。</p>\n<p>首先，可以使用jps或者系统的ps命令、任务管理器等工具，确定进程ID。</p>\n<p>其次，调用jstack获取线程栈：</p>\n<pre><code>${JAVA_HOME}\\bin\\jstack your_pid\n</code></pre>\n<p>然后，分析得到的输出，具体片段如下：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/1f/8b/1fcc1a521b801a5f7428d5229525a38b.png?wh=605*308\" alt=\"\" /></p>\n<p>最后，结合代码分析线程栈信息。上面这个输出非常明显，找到处于BLOCKED状态的线程，按照试图获取（waiting）的锁ID（请看我标记为相同颜色的数字）查找，很快就定位问题。 jstack本身也会把类似的简单死锁抽取出来，直接打印出来。</p>\n<p>在实际应用中，类死锁情况未必有如此清晰的输出，但是总体上可以理解为：</p>\n<p><strong>区分线程状态 -&gt; 查看等待目标 -&gt; 对比Monitor等持有状态</strong></p>\n<p>所以，理解线程基本状态和并发相关元素是定位问题的关键，然后配合程序调用栈结构，基本就可以定位到具体的问题代码。</p>\n<p>如果我们是开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用Java提供的标准管理API，<a href=\"https://docs.oracle.com/javase/9/docs/api/java/lang/management/ThreadMXBean.html#findDeadlockedThreads--\">ThreadMXBean</a>，其直接就提供了findDeadlockedThreads​()方法用于定位。为方便说明，我修改了DeadLockSample，请看下面的代码片段。</p>\n<pre><code>public static void main(String[] args) throws InterruptedException {\n\n\tThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n\tRunnable dlCheck = new Runnable() {\n\n    \t@Override\n    \tpublic void run() {\n        \tlong[] threadIds = mbean.findDeadlockedThreads();\n        \tif (threadIds != null) {\n                     ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);\n                     System.out.println(&quot;Detected deadlock threads:&quot;);\n            \tfor (ThreadInfo threadInfo : threadInfos) {\n                \tSystem.out.println(threadInfo.getThreadName());\n            \t}\n          }\n       }\n    };\n\n       ScheduledExecutorService scheduler =Executors.newScheduledThreadPool(1);\n       // 稍等5秒，然后每10秒进行一次死锁扫描\n        scheduler.scheduleAtFixedRate(dlCheck, 5L, 10L, TimeUnit.SECONDS);\n// 死锁样例代码…\n}\n</code></pre>\n<p>重新编译执行，你就能看到死锁被定位到的输出。在实际应用中，就可以据此收集进一步的信息，然后进行预警等后续处理。但是要注意的是，对线程进行快照本身是一个相对重量级的操作，还是要慎重选择频度和时机。</p>\n<p><strong>如何在编程中尽量预防死锁呢？</strong></p>\n<p>首先，我们来总结一下前面例子中死锁的产生包含哪些基本元素。基本上死锁的发生是因为：</p>\n<ul>\n<li>\n<p>互斥条件，类似Java中Monitor都是独占的，要么是我用，要么是你用。</p>\n</li>\n<li>\n<p>互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。</p>\n</li>\n<li>\n<p>循环依赖关系，两个或者多个个体之间出现了锁的链条环。</p>\n</li>\n</ul>\n<p>所以，我们可以据此分析可能的避免死锁的思路和方法。</p>\n<p><strong>第一种方法</strong></p>\n<p>如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁。否则，即使是非常精通并发编程的工程师，也难免会掉进坑里，嵌套的synchronized或者lock非常容易出问题。</p>\n<p>我举个<a href=\"https://bugs.openjdk.java.net/browse/JDK-8198928\">例子</a>， Java NIO的实现代码向来以锁多著称，一个原因是，其本身模型就非常复杂，某种程度上是不得不如此；另外是在设计时，考虑到既要支持阻塞模式，又要支持非阻塞模式。直接结果就是，一些基本操作如connect，需要操作三个锁以上，在最近的一个JDK改进中，就发生了死锁现象。</p>\n<p>我将其简化为下面的伪代码，问题是暴露在HTTP/2客户端中，这是个非常现代的反应式风格的API，非常推荐学习使用。</p>\n<pre><code>/// Thread HttpClient-6-SelectorManager:\nreadLock.lock();\nwriteLock.lock();\n// 持有readLock/writeLock，调用close（）需要获得closeLock\nclose();\n// Thread HttpClient-6-Worker-2 持有closeLock\nimplCloseSelectableChannel (); //想获得readLock\n\n</code></pre>\n<p>在close发生时， HttpClient-6-SelectorManager线程持有readLock/writeLock，试图获得closeLock；与此同时，另一个HttpClient-6-Worker-2线程，持有closeLock，试图获得readLock，这就不可避免地进入了死锁。</p>\n<p>这里比较难懂的地方在于，closeLock的持有状态（就是我标记为绿色的部分）<strong>并没有在线程栈中显示出来</strong>，请参考我在下图中标记的部分。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/b7/24/b7961a84838b5429a8f59826b91ed724.png?wh=1457*686\" alt=\"\" /><br />\n﻿<br />\n更加具体来说，请查看<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/ce06058197a4/src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java\">SocketChannelImpl</a>的663行，对比implCloseSelectableChannel()方法实现和<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/ce06058197a4/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java\">AbstractInterruptibleChannel.close()</a>在109行的代码，这里就不展示代码了。</p>\n<p>所以，从程序设计的角度反思，如果我们赋予一段程序太多的职责，出现“既要…又要…”的情况时，可能就需要我们审视下设计思路或目的是否合理了。对于类库，因为其基础、共享的定位，比应用开发往往更加令人苦恼，需要仔细斟酌之间的平衡。</p>\n<p><strong>第二种方法</strong></p>\n<p>如果必须使用多个锁，尽量设计好锁的获取顺序，这个说起来简单，做起来可不容易，你可以参看著名的<a href=\"https://en.wikipedia.org/wiki/Banker%27s_algorithm\">银行家算法</a>。</p>\n<p>一般的情况，我建议可以采取些简单的辅助手段，比如：</p>\n<ul>\n<li>将对象（方法）和锁之间的关系，用图形化的方式表示分别抽取出来，以今天最初讲的死锁为例，因为是调用了同一个线程所以更加简单。</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/1e/59/1e23562b6ff34206b11c5ec07608fb59.png?wh=241*448\" alt=\"\" /></p>\n<ul>\n<li>然后根据对象之间组合、调用的关系对比和组合，考虑可能调用时序。</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/ee/75/ee413b86e8775c63e7947955646db975.png?wh=444*604\" alt=\"\" /></p>\n<ul>\n<li>按照可能时序合并，发现可能死锁的场景。</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/9b/e7/9bbad67e205e54e8f7ec8ad37872a9e7.png?wh=368*440\" alt=\"\" /><br />\n﻿<br />\n<strong>第三种方法</strong></p>\n<p>使用带超时的方法，为程序带来更多可控性。</p>\n<p>类似Object.wait(…)或者CountDownLatch.await(…)，都支持所谓的timed_wait，我们完全可以就不假定该锁一定会获得，指定超时时间，并为无法得到锁时准备退出逻辑。</p>\n<p>并发Lock实现，如ReentrantLock还支持非阻塞式的获取锁操作tryLock()，这是一个插队行为（barging），并不在乎等待的公平性，如果执行时对象恰好没有被独占，则直接获取锁。有时，我们希望条件允许就尝试插队，不然就按照现有公平性规则等待，一般采用下面的方法：</p>\n<pre><code>if (lock.tryLock() || lock.tryLock(timeout, unit)) {\n  \t// ...\n   }\n\n</code></pre>\n<p><strong>第四种方法</strong></p>\n<p>业界也有一些其他方面的尝试，比如通过静态代码分析（如FindBugs）去查找固定的模式，进而定位可能的死锁或者竞争情况。实践证明这种方法也有一定作用，请参考<a href=\"https://plugins.jetbrains.com/plugin/3847-findbugs-idea\">相关文档</a>。</p>\n<p>除了典型应用中的死锁场景，其实还有一些更令人头疼的死锁，比如类加载过程发生的死锁，尤其是在框架大量使用自定义类加载时，因为往往不是在应用本身的代码库中，jstack等工具也不见得能够显示全部锁信息，所以处理起来比较棘手。对此，Java有<a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/lang/cl-mt.html\">官方文档</a>进行了详细解释，并针对特定情况提供了相应JVM参数和基本原则。</p>\n<p>今天，我从样例程序出发，介绍了死锁产生原因，并帮你熟悉了排查死锁基本工具的使用和典型思路，最后结合实例介绍了实际场景中的死锁分析方法与预防措施，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，有时候并不是阻塞导致的死锁，只是某个线程进入了死循环，导致其他线程一直等待，这种问题如何诊断呢？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","comments":[{"had_liked":false,"id":12871,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1529106719,"is_pvip":false,"replies":[{"id":"4298","content":"很好的总结","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529160345,"ip_address":"","comment_id":12871,"utype":1}],"discussion_count":1,"race_medal":0,"score":"705903743263","product_id":100006701,"comment_content":"1. 死锁的另一个好朋友就是饥饿。死锁和饥饿都是线程活跃性问题。<br>实践中死锁可以使用 jvm 自带的工具进行排查。<br>2. 课后题提出的死循环死锁可以认为是自旋锁死锁的一种，其他线程因为等待不到具体的信号提示。导致线程一直饥饿。<br>这种情况下可以查看线程 cpu 使用情况，排查出使用 cpu 时间片最高的线程，再打出该线程的堆栈信息，排查代码。<br>3. 基于互斥量的锁如果发生死锁往往 cpu 使用率较低，实践中也可以从这一方面进行排查。","like_count":165,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419440,"discussion_content":"很好的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529160345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12882,"user_name":"I am a psycho","can_delete":false,"product_type":"c1","uid":1103501,"ip_address":"","ucode":"0B65ECADB378C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/8d/7db04ad3.jpg","comment_is_top":false,"comment_ctime":1529111924,"is_pvip":false,"replies":[{"id":"4304","content":"对，比如Linux上，可以使用top命令配合grep Java之类，找到忙的pid；然后，转换成16进制，就是jstack输出中的格式；再定位代码","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529169598,"ip_address":"","comment_id":12882,"utype":1}],"discussion_count":2,"race_medal":0,"score":"246342247796","product_id":100006701,"comment_content":"当是死循环引起的其他线程阻塞，会导致cpu飙升，可以先看下cpu的使用率。","like_count":58,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419443,"discussion_content":"对，比如Linux上，可以使用top命令配合grep Java之类，找到忙的pid；然后，转换成16进制，就是jstack输出中的格式；再定位代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529169598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070581,"avatar":"https://static001.geekbang.org/account/avatar/00/10/55/f5/8d1588bd.jpg","nickname":"xfun","note":"","ucode":"A9A08E9EA6E13B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293939,"discussion_content":"CPU飙升不一定就是死锁造成的 定位方法老师已经讲了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595734595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13722,"user_name":"curlev3","can_delete":false,"product_type":"c1","uid":1108241,"ip_address":"","ucode":"BA76924E0F3A0E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/11/e435e996.jpg","comment_is_top":false,"comment_ctime":1529971761,"is_pvip":false,"replies":[{"id":"4651","content":"非常不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530117835,"ip_address":"","comment_id":13722,"utype":1}],"discussion_count":2,"race_medal":0,"score":"207688401969","product_id":100006701,"comment_content":"回答老师的问题<br>可以通过linux下top命令查看cpu使用率较高的java进程，进而用top -Hp ➕pid查看该java进程下cpu使用率较高的线程。再用jstack命令查看线程具体调用情况，排查问题。","like_count":49,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419732,"discussion_content":"非常不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530117835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138369,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5e/c1/cd721d46.jpg","nickname":"_yiunia##远","note":"","ucode":"AF508C3D0EB954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301095,"discussion_content":"那么问题来了，死锁为什么导致cpu升高？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598406107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15473,"user_name":"西鄉十六夜","can_delete":false,"product_type":"c1","uid":1119187,"ip_address":"","ucode":"D6215321F6AE3E","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/d3/8f880956.jpg","comment_is_top":false,"comment_ctime":1531205924,"is_pvip":false,"replies":[{"id":"5310","content":"不知道有什么好办法，也许用我例子哪个API去找到死锁线程，想办法把死锁条件打开；但我觉得这东西不靠谱，假设真的解除死锁，你还能保证程序正确性吗，这不会是个通用解决方案<br><br>另外，即使以前有stop方法，blocked状态的线程也是关不了的吧，它不响应你的请求的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1531320622,"ip_address":"","comment_id":15473,"utype":1}],"discussion_count":1,"race_medal":0,"score":"121790290212","product_id":100006701,"comment_content":"老师，面试遇到过一个很刁钻的问题。如何在jvm不重启的情况下杀死一个线程，在stop被移除后，如果线程存在死锁那是否意味着必须要修复代码再重启虚拟机呢？","like_count":29,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420399,"discussion_content":"不知道有什么好办法，也许用我例子哪个API去找到死锁线程，想办法把死锁条件打开；但我觉得这东西不靠谱，假设真的解除死锁，你还能保证程序正确性吗，这不会是个通用解决方案\n\n另外，即使以前有stop方法，blocked状态的线程也是关不了的吧，它不响应你的请求的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531320622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13957,"user_name":"tracer","can_delete":false,"product_type":"c1","uid":1124766,"ip_address":"","ucode":"AE2BC047DB7D7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg","comment_is_top":false,"comment_ctime":1530083933,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"104609299037","product_id":100006701,"comment_content":"看了下jconsole检测死锁功能的源码，果然也是用ThreadMXBean获取死锁线程并分组，然后打印相关线程信息的。","like_count":25},{"had_liked":false,"id":12955,"user_name":"残阳","can_delete":false,"product_type":"c1","uid":1046498,"ip_address":"","ucode":"8049541C6F7DB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/e2/0c13b4fc.jpg","comment_is_top":false,"comment_ctime":1529205752,"is_pvip":false,"replies":[{"id":"4425","content":"谢谢，地址也很重要","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529423994,"ip_address":"","comment_id":12955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44478878712","product_id":100006701,"comment_content":"以前做排查的时候看thread dump, 一般都会直接按一些关键字搜索。比如wait，lock之类，然后再找重复的内存地址。看完这遍文章之后感觉对死锁的理解更深刻。","like_count":11,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419477,"discussion_content":"谢谢，地址也很重要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529423994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12901,"user_name":"陈一嘉","can_delete":false,"product_type":"c1","uid":1087070,"ip_address":"","ucode":"B189852AB2F168","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/5e/8bba3a8a.jpg","comment_is_top":false,"comment_ctime":1529119891,"is_pvip":false,"replies":[{"id":"4309","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529171037,"ip_address":"","comment_id":12901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35888858259","product_id":100006701,"comment_content":"任务线程规范命名，详细记录逻辑运行日志。jstack查看线程状态。","like_count":9,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419451,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529171037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12909,"user_name":"肖一林","can_delete":false,"product_type":"c1","uid":1113317,"ip_address":"","ucode":"1DE45D906EB836","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/e5/605f423f.jpg","comment_is_top":false,"comment_ctime":1529126769,"is_pvip":false,"replies":[{"id":"4303","content":"nio确实教程少，书籍也不好找 Java IO，NIO，NIO2好像也没引进；如果想系统学习，我建议买本 《netty实战》，Java自己的nio定位偏重于基础性API，与终端应用需求有点鸿沟","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529169292,"ip_address":"","comment_id":12909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27298930545","product_id":100006701,"comment_content":"初学nio的时候确实动不动就发生死锁。现在好像也没有特别好的教程，都是一些java.io的教程。很多教程跟不上技术的迭代。也可能是因为直接io编程在项目实践中偏少。<br><br>另外，这个小程序的图片不能放大看，不知道是微信的原因还是小程序的原因。老师看到了帮忙反馈一下。","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419454,"discussion_content":"nio确实教程少，书籍也不好找 Java IO，NIO，NIO2好像也没引进；如果想系统学习，我建议买本 《netty实战》，Java自己的nio定位偏重于基础性API，与终端应用需求有点鸿沟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529169292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12912,"user_name":"肖一林","can_delete":false,"product_type":"c1","uid":1113317,"ip_address":"","ucode":"1DE45D906EB836","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/e5/605f423f.jpg","comment_is_top":false,"comment_ctime":1529127419,"is_pvip":false,"replies":[{"id":"4301","content":"不错，selected key 和 cancelled key的集合不是线程安全的，我记得标准文档就建议","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529168358,"ip_address":"","comment_id":12912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23003963899","product_id":100006701,"comment_content":"一课一练：<br>最典型的场景是nio的Selector类，这个类内部有三个集合，并且对这些集合做了同步。如果多个线程同时操作一个Selector，就很容易发生死锁。它的select方法会一直拿着锁，并且循环等待事件发生。如果有其他线程在修改它内部的集合数据，就死锁了。<br><br>同样用jstack可以发现问题，找出被阻塞的线程，看它等待哪个锁，再找到持有这把锁的线程，这个线程一搬处于运行状态","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419456,"discussion_content":"不错，selected key 和 cancelled key的集合不是线程安全的，我记得标准文档就建议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529168358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140247,"user_name":"格非","can_delete":false,"product_type":"c1","uid":1004569,"ip_address":"","ucode":"89FABFFC377131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/19/95ff4cbd.jpg","comment_is_top":false,"comment_ctime":1570862418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14455764306","product_id":100006701,"comment_content":"操作系统中学过进程死锁发成的四个必要条件：1、互斥条件，2、占有和等待条件，3、不可抢占条件，4、循环等待条件；破环这四个必要条件中的一个就可以避免发生死锁","like_count":4},{"had_liked":false,"id":134284,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1568793899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14453695787","product_id":100006701,"comment_content":"一：死锁的主要原因：<br>不同线程获取锁的顺序不一致导致。<br>二：解决方法：<br>1.确保按照一定顺序获取锁，比如两个类似lockA, lockB的hash值比较，如果相等（概率很低），再添加一把另外的锁tieLock ，具体示例 参加 JCIP 10-3<br>2.开放调用 不要同时获取多把锁 具体示例 参见JCIP 10-6<br>3.使用定时的锁 ，tryLock() 或者tryLock(timeout) <br><br>三：死锁检测：<br>3.1 jstack pid &gt; app.dump 然后在文件中查找线程状态（比如搜索Blocking) -&gt; 查看等待目标 -&gt; 对比 Monitor...<br>3.2 ThreadMXBean   <br><br><br><br>","like_count":3},{"had_liked":false,"id":13428,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1529625708,"is_pvip":false,"replies":[{"id":"4505","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529629555,"ip_address":"","comment_id":13428,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14414527596","product_id":100006701,"comment_content":"尽然可以用ThreadMXBean来抓线程死锁信息，受教了。<br>循环死锁，会导致cpu某线程的cpu时间片占用率相当高，可以结合操作系统工具分析出线程号，然后用jstack分析线程","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419645,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529629555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285993,"user_name":"林毅鑫","can_delete":false,"product_type":"c1","uid":1917916,"ip_address":"","ucode":"1BB3D186E90D96","user_header":"https://static001.geekbang.org/account/avatar/00/1d/43/dc/95d4f2c5.jpg","comment_is_top":false,"comment_ctime":1617096230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912063526","product_id":100006701,"comment_content":"一、死锁发生的原因<br>两个进场之间发生互斥，你不让我，我不让你。<br>二、处理死锁的方法<br>1、避免使用多个锁，不要赋予一段程序太多功能；<br>2、用图形化方式设计好锁的获取方式，参考银行家算法；<br>3、使用带超时（timed_wait）的方法，指定超时时间，并为无法得到锁时准备退出逻辑；<br>4、通过静态代码分析（如 FindBugs）去查找固定的模式，进而定位可能的死锁或者竞争情况；<br>三、解决办法<br>1、使用jps或ps命令定位死锁进程<br>2、开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用 Java 提供的标准管理 API，ThreadMXBean，其直接就提供了 findDeadlockedThreads​() 方法用于定位。<br>","like_count":2},{"had_liked":false,"id":236841,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1595561256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890528552","product_id":100006701,"comment_content":"死锁一般的表现是CPU占用很高，内存占用不高。当检测到这种情况的时候，就需要考虑是否发生了死锁，然后找到对应的进程，使用jstack、jconsole和visualVm等工具查看栈调用栈信息，根绝业务定位问题","like_count":2},{"had_liked":false,"id":165013,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1577147959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872115255","product_id":100006701,"comment_content":"18 死锁产生的原因，死锁检测工具的使用，以及在实际编码的时候如何注意 1 死锁是一种程序的状态，在实体之间由于循环依赖导致彼此都处于等待之中，没有任何个体可以继续进行，死锁存在于线程与线程之间，也存在与资源独占的进程之间，比较常见的场景是多线程并发环境中的死锁，两个或者多个线程互相持有对方需要的锁，而永久处于阻塞状态。2 检测死锁可以用jstack等工具获取线程栈，然后定位相互之间的关系，找到死锁。2.1 死锁产生的demo，定义两个对象，两个线程，线程一synchronized先锁对象a再锁对象b，线程二先锁对象b，再锁a，两个线程启动，就会产生死锁 2.2 用jstack找死锁步骤 首先确定进程ID，然后用jstack pid，可以打印出具体的死锁信息 2.3 可以用java提供的标准管理api ThreadMxBean 提供了findDeadLockedThreads方法用于定位 3 如何在预防死锁 死锁产生有几个条件 互斥条件，且互斥条件是长期持有，使用结束之前，只能自己持有，别的线程用不了，循环依赖关系，两个或者多个个体之间出现了锁的链条环，实际使用注意步骤 尽量避免使用多个锁，并且只有在需要时才持有锁，如果必须使用多个锁，设计好锁的使用顺序，再者使用带超时的方法，无法获取到锁，超时执行退出逻辑，再者，通过通过静态代码分析，去查找固定的模式，进而定位可能的死锁或者竞争情况 ","like_count":2},{"had_liked":false,"id":147680,"user_name":"vaccywen","can_delete":false,"product_type":"c1","uid":1115128,"ip_address":"","ucode":"077FDB50831921","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/f8/f98df0a7.jpg","comment_is_top":false,"comment_ctime":1572878909,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5867846205","product_id":100006701,"comment_content":"多执行几次jstack，如果同一个线程id多次结果都是running，而其他线程一直都是BLOCKED状态，是不是就可以判断某个持锁线程进入死循环？","like_count":1,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336812,"discussion_content":"不靠谱 , 比如文中说的threadPoolExcetor的core线程一直就是存活状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608708010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122204,"user_name":"道法自然","can_delete":false,"product_type":"c1","uid":1182509,"ip_address":"","ucode":"F88FBFB34EE764","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/2d/4a6d7d41.jpg","comment_is_top":false,"comment_ctime":1565315840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860283136","product_id":100006701,"comment_content":"请教老师，线程饥饿的情况，有没有什么好的诊断办法？","like_count":1},{"had_liked":false,"id":114608,"user_name":"JSON","can_delete":false,"product_type":"c1","uid":1128581,"ip_address":"","ucode":"9C9DA6C58AFA57","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/85/105667e6.jpg","comment_is_top":false,"comment_ctime":1563348766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858316062","product_id":100006701,"comment_content":"如果是生产环境出现了死锁状态，该怎么排查问题","like_count":1},{"had_liked":false,"id":68142,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1550448412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5845415708","product_id":100006701,"comment_content":"平常工作发生的死锁都发生在数据库层面，多线程并发修改同一条记录","like_count":1},{"had_liked":false,"id":13478,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1529665453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5824632749","product_id":100006701,"comment_content":"杨老师，Sorry。接着上了问题，是我的进程PID搞错了，应该用Javax，我用成eclipse的PID了。","like_count":2},{"had_liked":false,"id":248523,"user_name":"蒙奇君杰","can_delete":false,"product_type":"c1","uid":1117302,"ip_address":"","ucode":"2DBCECD149730F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/76/0c07376d.jpg","comment_is_top":false,"comment_ctime":1600211633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600211633","product_id":100006701,"comment_content":"循环死锁，会导致cpu某线程的cpu时间片占用率相当高，可以结合操作系统工具分析出线程号，然后用jstack分析线程。<br>from jacy<br>","like_count":0},{"had_liked":false,"id":229390,"user_name":"大成尊者","can_delete":false,"product_type":"c1","uid":1783367,"ip_address":"","ucode":"42473322052B11","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/47/8e80082c.jpg","comment_is_top":false,"comment_ctime":1592983023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592983023","product_id":100006701,"comment_content":"有时候并不是阻塞导致的死锁，只是某个线程进入了死循环，导致其他线程一直等待，这种问题如何诊断呢？<br>答：这种依然可以通过jstack来看线程的状态，如果是阻塞，那么可以去看这个线程的实现，如果是死循环，那么很容易debug出来","like_count":0},{"had_liked":false,"id":150285,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573504866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573504866","product_id":100006701,"comment_content":"死锁是两个线程相互试图获取对方独占的资源的情况。如果随机使用锁，这种情况不可避免。","like_count":0},{"had_liked":false,"id":102224,"user_name":"Geek_7eb30c","can_delete":false,"product_type":"c1","uid":1394299,"ip_address":"","ucode":"9C570910CBAA38","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gCN0rqmg3cDYQYfddTuWCXMIaPfbeR3kDVdCtzlmvp3r4l132Hju86TzRn3382ic52icylZuryUgGvA8fib1icIib7A/132","comment_is_top":false,"comment_ctime":1560163988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560163988","product_id":100006701,"comment_content":"老师有个问题咨询下，我在跑一个大批量数据导入数据库的程序，用线程池一批1000导入数据库，头尾用了分布式redis锁防止并发，但在倒入中还是出现锁表的情况，不知道是不是我的分布式锁放错位置，是否应该放在异步线程开启前加锁","like_count":0},{"had_liked":false,"id":82097,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1554119439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554119439","product_id":100006701,"comment_content":"还有一种锁叫做活锁，可能两个线程一直在释放锁，抢占锁，互不相让，这种也是一种并发问题","like_count":0},{"had_liked":false,"id":71430,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1551341380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551341380","product_id":100006701,"comment_content":"java8环境，连着多运行几次那个死锁实例代码才会出现blocked状态，前几次都是RUNNABLE状态，而且用线程组打印的才是blocked，直接用线程的getState方法打印的都是RUNNABLE。","like_count":0},{"had_liked":false,"id":36813,"user_name":"leleba","can_delete":false,"product_type":"c1","uid":1281735,"ip_address":"","ucode":"C868F6ABF509B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/c7/f05f9fd0.jpg","comment_is_top":false,"comment_ctime":1541345358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541345358","product_id":100006701,"comment_content":"杨老师，mac电脑上，jdk1.8.0运行你的第一个例子怎么也不死锁","like_count":0},{"had_liked":false,"id":17693,"user_name":"、","can_delete":false,"product_type":"c1","uid":1162040,"ip_address":"","ucode":"9BA80F04C1D5E2","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/38/2fb5c4ce.jpg","comment_is_top":false,"comment_ctime":1532879795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532879795","product_id":100006701,"comment_content":"因为Synchrinized 而BLOCKED的线程会消耗CPU吗。   多个线程争取锁是会消耗的吧","like_count":0},{"had_liked":false,"id":16795,"user_name":"洗头用酱油","can_delete":false,"product_type":"c1","uid":1181339,"ip_address":"","ucode":"BDD6B32C55858F","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/9b/ade9c3bd.jpg","comment_is_top":false,"comment_ctime":1532194342,"is_pvip":false,"replies":[{"id":"5891","content":"不是一个概念，biased其实用这种方式避免了锁，和线程调度是两件事","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1532357213,"ip_address":"","comment_id":16795,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532194342","product_id":100006701,"comment_content":"杨老师，有点迷糊，所以说一个对象偏向一个线程后，这个线程就有工作了优先权吗？ 问题我记得不特殊设置的话，JVM是随机执行线程的呀？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420931,"discussion_content":"不是一个概念，biased其实用这种方式避免了锁，和线程调度是两件事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532357213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13678,"user_name":"coolboy","can_delete":false,"product_type":"c1","uid":1160559,"ip_address":"","ucode":"248918FCC9E65D","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/6f/7c964414.jpg","comment_is_top":false,"comment_ctime":1529924617,"is_pvip":false,"replies":[{"id":"4585","content":"是","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529944811,"ip_address":"","comment_id":13678,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529924617","product_id":100006701,"comment_content":"杨老师，问个小白问题，java的线程状态有BLOCK、WAITING状态，使用java的内置关键字sychronized时，会出现BLOCK状态。但如果用java的reentrantLock时，也会出现BLOCK状态的吗，不应该只有WAITING状态的？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419722,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529944811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13380,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1529570168,"is_pvip":false,"replies":[{"id":"4507","content":"我不能重现，你是jdk8update多少？synchronized正常理解就是Blocked","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529630937,"ip_address":"","comment_id":13380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529570168","product_id":100006701,"comment_content":"杨老师，我Win7系统，Java 8上运行Dead Lock Simple例子，通过Jstack获取的Thread 1和Thread 2的线程状态，都是Runnable,但是Waiting on Condition[0x 000000000]。<br>但是，我通过Thread Group打印出来，两个线程状态都是Block。<br>晕乎了。。。。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419634,"discussion_content":"我不能重现，你是jdk8update多少？synchronized正常理解就是Blocked","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529630937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}