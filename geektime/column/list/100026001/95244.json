{"id":95244,"title":"10 | 动态链接：程序内部的“共享单车”","content":"<p>我们之前讲过，程序的链接，是把对应的不同文件内的代码段，合并到一起，成为最后的可执行文件。这个链接的方式，让我们在写代码的时候做到了“复用”。同样的功能代码只要写一次，然后提供给很多不同的程序进行链接就行了。</p><p>这么说来，“链接”其实有点儿像我们日常生活中的<strong>标准化、模块化</strong>生产。我们有一个可以生产标准螺帽的生产线，就可以生产很多个不同的螺帽。只要需要螺帽，我们都可以通过<strong>链接</strong>的方式，去<strong>复制</strong>一个出来，放到需要的地方去，大到汽车，小到信箱。</p><p>但是，如果我们有很多个程序都要通过装载器装载到内存里面，那里面链接好的同样的功能代码，也都需要再装载一遍，再占一遍内存空间。这就好比，假设每个人都有骑自行车的需要，那我们给每个人都生产一辆自行车带在身边，固然大家都有自行车用了，但是马路上肯定会特别拥挤。</p><p><img src=\"https://static001.geekbang.org/resource/image/09/51/092dfd81e3cc45ea237bb85557bbfa51.jpg?wh=2416*2121\" alt=\"\"></p><h2>链接可以分动、静，共享运行省内存</h2><p>我们上一节解决程序装载到内存的时候，讲了很多方法。说起来，最根本的问题其实就是<strong>内存空间不够用</strong>。如果我们能够让同样功能的代码，在不同的程序里面，不需要各占一份内存空间，那该有多好啊！就好比，现在马路上的共享单车，我们并不需要给每个人都造一辆自行车，只要马路上有这些单车，谁需要的时候，直接通过手机扫码，都可以解锁骑行。</p><!-- [[[read_end]]] --><p>这个思路就引入一种新的链接方法，叫作<strong>动态链接</strong>（Dynamic Link）。相应的，我们之前说的合并代码段的方法，就是<strong>静态链接</strong>（Static Link）。</p><p>在动态链接的过程中，我们想要“链接”的，不是存储在硬盘上的目标文件代码，而是加载到内存中的<strong>共享库</strong>（Shared Libraries）。顾名思义，这里的共享库重在“共享“这两个字。</p><p>这个加载到内存中的共享库会被很多个程序的指令调用到。在Windows下，这些共享库文件就是.dll文件，也就是Dynamic-Link Libary（DLL，动态链接库）。在Linux下，这些共享库文件就是.so文件，也就是Shared Object（一般我们也称之为动态链接库）。这两大操作系统下的文件名后缀，一个用了“动态链接”的意思，另一个用了“共享”的意思，正好覆盖了两方面的含义。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/60/2980d241d3c7cbfa3724cb79b801d160.jpg?wh=2311*2009\" alt=\"\"></p><h2>地址无关很重要，相对地址解烦恼</h2><p>不过，要想要在程序运行的时候共享代码，也有一定的要求，就是这些机器码必须是“<strong>地址无关</strong>”的。也就是说，我们编译出来的共享库文件的指令代码，是地址无关码（Position-Independent Code）。换句话说就是，这段代码，无论加载在哪个内存地址，都能够正常执行。如果不是这样的代码，就是地址相关的代码。</p><p>如果还不明白，我给你举一个生活中的例子。如果我们有一个骑自行车的程序，要“前进500米，左转进入天安门广场，再前进500米”。它在500米之后要到天安门广场了，这就是地址相关的。如果程序是“前进500米，左转，再前进500米”，无论你在哪里都可以骑车走这1000米，没有具体地点的限制，这就是地址无关的。</p><p>你可以想想，大部分函数库其实都可以做到地址无关，因为它们都接受特定的输入，进行确定的操作，然后给出返回结果就好了。无论是实现一个向量加法，还是实现一个打印的函数，这些代码逻辑和输入的数据在内存里面的位置并不重要。</p><p>而常见的地址相关的代码，比如绝对地址代码（Absolute Code）、利用重定位表的代码等等，都是地址相关的代码。你回想一下我们之前讲过的重定位表。在程序链接的时候，我们就把函数调用后要跳转访问的地址确定下来了，这意味着，如果这个函数加载到一个不同的内存地址，跳转就会失败。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/4a/8cab516a92fd3d7e951887808597094a.jpg?wh=2671*1555\" alt=\"\"></p><p>对于所有动态链接共享库的程序来讲，虽然我们的共享库用的都是同一段物理内存地址，但是在不同的应用程序里，它所在的虚拟内存地址是不同的。我们没办法、也不应该要求动态链接同一个共享库的不同程序，必须把这个共享库所使用的虚拟内存地址变成一致。如果这样的话，我们写的程序就必须明确地知道内部的内存地址分配。</p><p>那么问题来了，我们要怎么样才能做到，动态共享库编译出来的代码指令，都是地址无关码呢？</p><p>动态代码库内部的变量和函数调用都很容易解决，我们只需要使用<strong>相对地址</strong>（Relative Address）就好了。各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在一段连续的虚拟内存地址中的，无论装载到哪一段地址，不同指令之间的相对地址都是不变的。</p><h2>PLT和GOT，动态链接的解决方案</h2><p>要实现动态链接共享库，也并不困难，和前面的静态链接里的符号表和重定向表类似，还是和前面一样，我们还是拿出一小段代码来看一看。</p><p>首先，lib.h 定义了动态链接库的一个函数 show_me_the_money。</p><pre><code>// lib.h\n#ifndef LIB_H\n#define LIB_H\n\nvoid show_me_the_money(int money);\n\n#endif\n</code></pre><p>lib.c包含了lib.h的实际实现。</p><pre><code>// lib.c\n#include &lt;stdio.h&gt;\n\n\nvoid show_me_the_money(int money)\n{\n    printf(&quot;Show me USD %d from lib.c \\n&quot;, money);\n}\n</code></pre><p>然后，show_me_poor.c 调用了 lib 里面的函数。</p><pre><code>// show_me_poor.c\n#include &quot;lib.h&quot;\nint main()\n{\n    int money = 5;\n    show_me_the_money(money);\n}\n</code></pre><p>最后，我们把 lib.c 编译成了一个动态链接库，也就是 .so 文件。</p><pre><code>$ gcc lib.c -fPIC -shared -o lib.so\n$ gcc -o show_me_poor show_me_poor.c ./lib.so\n</code></pre><p>你可以看到，在编译的过程中，我们指定了一个 <strong>-fPIC</strong> 的参数。这个参数其实就是Position Independent Code的意思，也就是我们要把这个编译成一个地址无关代码。</p><p>然后，我们再通过gcc编译show_me_poor 动态链接了lib.so的可执行文件。在这些操作都完成了之后，我们把show_me_poor这个文件通过objdump出来看一下。</p><pre><code>$ objdump -d -M intel -S show_me_poor\n</code></pre><pre><code>……\n0000000000400540 &lt;show_me_the_money@plt-0x10&gt;:\n  400540:       ff 35 12 05 20 00       push   QWORD PTR [rip+0x200512]        # 600a58 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;\n  400546:       ff 25 14 05 20 00       jmp    QWORD PTR [rip+0x200514]        # 600a60 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;\n  40054c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]\n\n0000000000400550 &lt;show_me_the_money@plt&gt;:\n  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;\n  400556:       68 00 00 00 00          push   0x0\n  40055b:       e9 e0 ff ff ff          jmp    400540 &lt;_init+0x28&gt;\n……\n0000000000400676 &lt;main&gt;:\n  400676:       55                      push   rbp\n  400677:       48 89 e5                mov    rbp,rsp\n  40067a:       48 83 ec 10             sub    rsp,0x10\n  40067e:       c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5\n  400685:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  400688:       89 c7                   mov    edi,eax\n  40068a:       e8 c1 fe ff ff          call   400550 &lt;show_me_the_money@plt&gt;\n  40068f:       c9                      leave  \n  400690:       c3                      ret    \n  400691:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]\n  400698:       00 00 00 \n  40069b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]\n……\n</code></pre><p>我们还是只关心整个可执行文件中的一小部分内容。你应该可以看到，在main函数调用show_me_the_money的函数的时候，对应的代码是这样的：</p><pre><code>call   400550 &lt;show_me_the_money@plt&gt;\n</code></pre><p>这里后面有一个@plt的关键字，代表了我们需要从PLT，也就是<strong>程序链接表</strong>（Procedure Link Table）里面找要调用的函数。对应的地址呢，则是400550这个地址。</p><p>那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。</p><pre><code>  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 &lt;_GLOBAL_OFFSET_TABLE_+0x18&gt;\n</code></pre><p>在动态链接对应的共享库，我们在共享库的data section里面，保存了一张<strong>全局偏移表</strong>（GOT，Global Offset Table）。<strong>虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。</strong>所有需要引用当前共享库外部的地址的指令，都会查询GOT，来找到当前运行程序的虚拟内存里的对应位置。而GOT表里的数据，则是在我们加载一个个共享库的时候写进去的。</p><p>不同的进程，调用同样的lib.so，各自GOT里面指向最终加载的动态链接库里面的虚拟内存地址是不同的。</p><p>这样，虽然不同的程序调用的同样的动态库，各自的内存地址是独立的，调用的又都是同一个动态库，但是不需要去修改动态库里面的代码所使用的地址，而是各个程序各自维护好自己的GOT，能够找到对应的动态库就好了。</p><p><img src=\"https://static001.geekbang.org/resource/image/11/c8/1144d3a2d4f3f4f87c349a93429805c8.jpg?wh=2846*876\" alt=\"\"></p><p>我们的GOT表位于共享库自己的数据段里。GOT表在内存里和对应的代码段位置之间的偏移量，始终是确定的。这样，我们的共享库就是地址无关的代码，对应的各个程序只需要在物理内存里面加载同一份代码。而我们又要通过各个可执行程序在加载时，生成的各不相同的GOT表，来找到它需要调用到的外部变量和函数的地址。</p><p>这是一个典型的、不修改代码，而是通过修改“<strong>地址数据</strong>”来进行关联的办法。它有点像我们在C语言里面用函数指针来调用对应的函数，并不是通过预先已经确定好的函数名称来调用，而是利用当时它在内存里面的动态地址来调用。</p><h2>总结延伸</h2><p>这一讲，我们终于在静态链接和程序装载之后，利用动态链接把我们的内存利用到了极致。同样功能的代码生成的共享库，我们只要在内存里面保留一份就好了。这样，我们不仅能够做到代码在开发阶段的复用，也能做到代码在运行阶段的复用。</p><p>实际上，在进行Linux下的程序开发的时候，我们一直会用到各种各样的动态链接库。C语言的标准库就在1MB以上。我们撰写任何一个程序可能都需要用到这个库，常见的Linux服务器里，/usr/bin下面就有上千个可执行文件。如果每一个都把标准库静态链接进来的，几GB乃至几十GB的磁盘空间一下子就用出去了。如果我们服务端的多进程应用要开上千个进程，几GB的内存空间也会一下子就用出去了。这个问题在过去计算机的内存较少的时候更加显著。</p><p>通过动态链接这个方式，可以说彻底解决了这个问题。就像共享单车一样，如果仔细经营，是一个很有社会价值的事情，但是如果粗暴地把它变成无限制地复制生产，给每个人造一辆，只会在系统内制造大量无用的垃圾。</p><p>过去的05～09这五讲里，我们已经把程序怎么从源代码变成指令、数据，并装载到内存里面，由CPU一条条执行下去的过程讲完了。希望你能有所收获，对于一个程序是怎么跑起来的，有了一个初步的认识。</p><h2>推荐阅读</h2><p>想要更加深入地了解动态链接，我推荐你可以读一读《程序员的自我修养：链接、装载和库》的第7章，里面深入地讲解了，动态链接里程序内的数据布局和对应数据的加载关系。</p><h2>课后思考</h2><p>像动态链接这样通过修改“地址数据”来进行间接跳转，去调用一开始不能确定位置代码的思路，你在应用开发中使用过吗？</p><p>欢迎你在留言区写下你的思考和疑问，和大家一起探讨。你也可以把今天的文章分享给你朋友，和他一起学习和进步。</p><p></p>","comments":[{"had_liked":false,"id":134862,"user_name":"fatme","can_delete":false,"product_type":"c1","uid":1034451,"ip_address":"","ucode":"75A805D2BB2AD1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","comment_is_top":false,"comment_ctime":1568943849,"is_pvip":false,"replies":[{"id":"52638","content":"PLT是为了做延迟绑定，如果函数没有实际被调用到，就不需要更新GOT里面的数值。因为很多动态装载的函数库都是不会被实际调用到的。<br><br>这个如果要深入细节可以看一下《程序员的自我修养》的7.4小结。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1569658916,"ip_address":"","comment_id":134862,"utype":1}],"discussion_count":3,"race_medal":0,"score":"186252537577","product_id":100026001,"comment_content":"老师，为什么要采用 PLT 和 GOT 两级跳转，直接用 GOT 有问题吗？","like_count":44,"discussions":[{"author":{"id":1178888,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","nickname":"小鳄鱼","note":"","ucode":"9C30CAFB41A263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551812,"discussion_content":"你可以看老师的图，GOT不是编译时确定的。这意味着共享库并不是全部加载的，是需要的时候才加载的。因此只有运行时，加载了才能确定目标共享库所在的内存地址。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645146276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467933,"discussion_content":"PLT是为了做延迟绑定，如果函数没有实际被调用到，就不需要更新GOT里面的数值。因为很多动态装载的函数库都是不会被实际调用到的。\n\n这个如果要深入细节可以看一下《程序员的自我修养》的7.4小结。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569658916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2008852,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a7/14/b18ac990.jpg","nickname":"jokerPENG","note":"","ucode":"9D9EB64517221E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589396,"discussion_content":"这样设计其实都是为节省资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664815851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95480,"user_name":"齐","can_delete":false,"product_type":"c1","uid":1486566,"ip_address":"","ucode":"378B273955095D","user_header":"https://static001.geekbang.org/account/avatar/00/16/ae/e6/58f30bb3.jpg","comment_is_top":false,"comment_ctime":1558061482,"is_pvip":true,"replies":[{"id":"35525","content":"👍不错的例子","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559130335,"ip_address":"","comment_id":95480,"utype":1}],"discussion_count":5,"race_medal":0,"score":"164766818730","product_id":100026001,"comment_content":"Java语言多态的实现","like_count":39,"discussions":[{"author":{"id":1473251,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","nickname":"不一样的烟火","note":"","ucode":"6E305F0EE90E8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23428,"discussion_content":"我觉得更像是类的实现，不同实例之间函数都是一样的，数据部分各个实例自己维护；同时又像是栈帧的实现，共享库相当于可重入函数，局部变量在变化，但是代码是同一份","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1569816500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3003067,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/d2/bb/8f647aef.jpg","nickname":"程杰","note":"","ucode":"6580E4B8091E76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1473251,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","nickname":"不一样的烟火","note":"","ucode":"6E305F0EE90E8B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573766,"discussion_content":"主要是这个是调用的时候（动态）才去加载的，不调用不执行 不加载的 节省磁盘，节省内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653634233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":23428,"ip_address":""},"score":573766,"extra":""}]},{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450473,"discussion_content":"👍不错的例子","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1559130335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289172,"discussion_content":"多态是编译期就确定具体执行哪个之类的方法，是静态链接的过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594015081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1055248,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/10/2a1e7e2a.jpg","nickname":"掀翻大海","note":"","ucode":"1EDEA92B939C7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313774,"discussion_content":"调用接口函数，运行时才能确定是哪个实现类的方法，应该是动态链接","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603089370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289172,"ip_address":""},"score":313774,"extra":""}]}]},{"had_liked":false,"id":95479,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1558061441,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"164766818689","product_id":100026001,"comment_content":"所以说plt 里面实际上是存放了 GOT[ i ] 的地址 , 而  GOT[ i ] 中存放了 要调用函数在虚拟内存中的地址，而该地址实际上是共享函数代码段的真实物理地址的一个映射。但有一些疑问，PLT 的 机制是什么，感觉没太介绍PLT ，不知道他怎么来的。对PLT 很模糊，他如何利用了相对地址的方法。希望老师能解答一下","like_count":38,"discussions":[{"author":{"id":1656719,"avatar":"https://static001.geekbang.org/account/avatar/00/19/47/8f/85f73373.jpg","nickname":"ADC不能C","note":"","ucode":"BD64C5DBC24AF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39937,"discussion_content":"细节程序员的自我修养里面有讲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572019211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547315,"discussion_content":"plt是为了延迟绑定\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642609639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1285612,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKy9XSxDLRibViazIs1wzhEmIQqMlhcoKhTXNvxXkaPGIveib8B9ibvpdkZxABKFIc4iaSMrkTh7EfWjtg/132","nickname":"likejjj","note":"","ucode":"005BF873B32EA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306806,"discussion_content":"PLT是一个跳转表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600395191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240126,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","nickname":"宋不肥","note":"","ucode":"32B34AF579C91C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40105,"discussion_content":"知道的，6月份看完了。谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572080298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97366,"user_name":"Calix","can_delete":false,"product_type":"c1","uid":1212966,"ip_address":"","ucode":"6166FD5B2EDC54","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/26/395798ae.jpg","comment_is_top":false,"comment_ctime":1558660636,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"83163039260","product_id":100026001,"comment_content":"1. GOT 保存在共享库自己的数据段里<br>2. 每个程序维护自己的GOT<br><br>所以，GOT 到底保存在哪里？？共享库里面还是各个程序里？","like_count":19,"discussions":[{"author":{"id":1310995,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/eyKgpIVFSDQBia7SJRVUKFh5qgwc3ohzEPSKvchLf9ZvwIO9CrS470ER7OhNzWTs0svECHCBiarQTa41BO3Hf0DA/132","nickname":"Temme","note":"","ucode":"BCBA3A5570216A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290827,"discussion_content":"后来又看过许多的我明确告诉你，got，plt是每个可执行文件都会有的，\n调用某个共享库的函数时，got用来存储经计算后的函数地址，plt存的是另外的指令，意思就是:got表里没有该函数地址就发起地址计算，并存好，如果有了，就直接操纵指令跳转","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1594614673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253603,"discussion_content":"我觉得应该这么理解，多个程序调用同一个函数，对于这个函数的实现本身来说，谁调用它它并不关心，只是调用者根据传入不同的参数获得不同的结果。于是对于这个公有的函数而言，他的代码部分只需要存一份，但是数据部分需要每个程序各自存一份，GOT存在共享库的数据段，而其它每个进程都需要加载一份数据段，于是每个进程就都有一个GOT","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1588246993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1433862,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/qGEe1b4PLBkqJop7bDjkFt4gzQm9I8mr7XkMDicKlxJLs6sTGPslmh56ricsFIy4n8h5gbVvXTwe38znLvFIib8Fg/132","nickname":"芋头15","note":"","ucode":"9263F90B660AF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385644,"discussion_content":"找到个解释比较清晰的\n\n\n函数和数据的使用实际上可分为以下4类，下面分别讨论：\n1，模块内部的数据访问\n2，模块内部的函数调用\n对于以上两种情况，实际上可以做一类处理，因为一个模块内部的.data和.text结构固定，一遍都是前面几页.text后几页.data，所以不管是从.text到.text，还是从.text到.data偏移量都是固定的，基于当前的地址和相对之间的偏移量，就可以完成内部数据的访问，或者函数的调用。\n3，模块间的数据访问\n4，模块间的函数调用\n对于以上两种情况，实际上也可以做一类处理，ELF的做法是在.data中建立一个指向这些外部变量和函数的指针数组，即全局偏移表（Global Offset Table），即本文标题中的GOT了，实际上对于变量和函数符号，具体保存的表分别是.got和.got.plt。\n装载器在装载时会查找每个变量所在的地址，然后填充GOT中的各项，当需要访问相关变量时，通过GOT访问即可。\n这中间有个比较特殊的情况，假如全局变量定义在.so模块内部，现在可执行文件需要访问这个变量，因为可执行文件在链接时就需要这个全局的线性地址，为了使链接过程可以正常进行，链接器会在可执行文件的.bss段创建一个全局变量的副本，这就导致一个一份全局同时存在于内存的两个位置，解决这个问题的办法就是.so会假装这个定义在自己内部的全局定义在外部，将其添加到GOT表中，然后通过GOT表来访问，.so装载时，链接器会将GOT表中这个全局的指针指向可执行文件的.bss段的全局变量副本中，这样的话，所有对于这个全局的使用都使用这个副本，变量就唯一了。 \n\n摘自：【动态链接机制详解及GOT和fPIC_yejing&#39;s utopia-CSDN博客】https://blog.csdn.net/yejing_utopia/article/details/41521889","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1627192426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1433862,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/qGEe1b4PLBkqJop7bDjkFt4gzQm9I8mr7XkMDicKlxJLs6sTGPslmh56ricsFIy4n8h5gbVvXTwe38znLvFIib8Fg/132","nickname":"芋头15","note":"","ucode":"9263F90B660AF9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547316,"discussion_content":"这还要找吗，就是老师推荐的那本书里的内容。程序员的自我修养","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642609796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385644,"ip_address":""},"score":547316,"extra":""}]},{"author":{"id":1634044,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ee/fc/8717c26b.jpg","nickname":"柠檬","note":"","ucode":"AF73A8B705CE76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267243,"discussion_content":"这段我也看得有点懵","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589619248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","nickname":"1024","note":"","ucode":"DCC31F6EC54F43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":971,"discussion_content":"首先可以确定的是每个程序(进程）都会有自己的虚拟内存空间，所以GOT一定是在每个进程中都有保存，并且独立；其次每个进程的虚拟内存空间都有自己的数据段，程序段，堆，栈；GOT存储在该进程虚拟空间的数据段里\n非科班，自学，不知道理解的对不对，希望老师及各位同学点播指正","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562211879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1086407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","nickname":"1024","note":"","ucode":"DCC31F6EC54F43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547317,"discussion_content":"不对，不是数据段。got在so共享库的数据段，最后加载到的位置是在进程堆和栈之间的共享区。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642609946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":971,"ip_address":""},"score":547317,"extra":""}]},{"author":{"id":1285612,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKy9XSxDLRibViazIs1wzhEmIQqMlhcoKhTXNvxXkaPGIveib8B9ibvpdkZxABKFIc4iaSMrkTh7EfWjtg/132","nickname":"likejjj","note":"","ucode":"005BF873B32EA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306805,"discussion_content":"GOT保存在数据段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600395164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077573,"avatar":"https://static001.geekbang.org/account/avatar/00/10/71/45/126cd913.jpg","nickname":"袭","note":"","ucode":"D5B8609CDFB145","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5412,"discussion_content":"是不是保留在堆上面？gp寄存器指向的区域？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566233109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97154,"user_name":"阿锋","can_delete":false,"product_type":"c1","uid":1127761,"ip_address":"","ucode":"7AF449ABA89242","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/51/c616f95a.jpg","comment_is_top":false,"comment_ctime":1558598658,"is_pvip":false,"replies":[{"id":"35516","content":"是的，虚拟内存既然叫做“虚拟”它就是一个抽象概念。要么是已经实际加载到物理内存里了，要么还没有加载或者交换出去在硬盘上。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559129931,"ip_address":"","comment_id":97154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83162977282","product_id":100026001,"comment_content":"有一个点不明白，虚拟内存中的内容究竟放在哪里，它的内容也应该是放在物理内存里的或者是硬盘里的？是这样吗？","like_count":19,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451158,"discussion_content":"是的，虚拟内存既然叫做“虚拟”它就是一个抽象概念。要么是已经实际加载到物理内存里了，要么还没有加载或者交换出去在硬盘上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559129931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97180,"user_name":"半斤八两","can_delete":false,"product_type":"c1","uid":1067622,"ip_address":"","ucode":"973F074F0E899E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/66/d3d19642.jpg","comment_is_top":false,"comment_ctime":1558603002,"is_pvip":false,"replies":[{"id":"35481","content":"每个程序自己维护一张","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559123736,"ip_address":"","comment_id":97180,"utype":1}],"discussion_count":4,"race_medal":0,"score":"78868014330","product_id":100026001,"comment_content":"所以老师请问下GOT是每个程序都维护一张所以有多张还是每个程序共同维护一张GOT","like_count":18,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451167,"discussion_content":"每个程序自己维护一张","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1559123736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099379,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","nickname":"疯琴","note":"","ucode":"82ACAA4A27753D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322407,"discussion_content":"那和文中“我们的 GOT 表位于共享库自己的数据段里”是不是矛盾的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604739249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1099379,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","nickname":"疯琴","note":"","ucode":"82ACAA4A27753D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363355,"discussion_content":"不矛盾，共享库只是共享程序段，数据段是不共享的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617177543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":322407,"ip_address":""},"score":363355,"extra":""},{"author":{"id":2354332,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ec/9c/b4acd768.jpg","nickname":"Sarah","note":"","ucode":"FDC8A0D30EAE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581296,"discussion_content":"不太明白你表达的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658715694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363355,"ip_address":""},"score":581296,"extra":""}]}]},{"had_liked":false,"id":95349,"user_name":"许山山","can_delete":false,"product_type":"c1","uid":1241643,"ip_address":"","ucode":"2A5168DEB58F19","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/2b/7d9751bb.jpg","comment_is_top":false,"comment_ctime":1558025863,"is_pvip":false,"replies":[{"id":"34148","content":"谢谢支持","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1558090257,"ip_address":"","comment_id":95349,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74572469895","product_id":100026001,"comment_content":"真的写的好棒啊，和操作系统配合食用简直不要太爽","like_count":18,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450419,"discussion_content":"谢谢支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558090257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96365,"user_name":"焰火","can_delete":false,"product_type":"c1","uid":1244606,"ip_address":"","ucode":"D3353B386DE3B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","comment_is_top":false,"comment_ctime":1558404172,"is_pvip":true,"replies":[{"id":"35536","content":"焰火同学你好<br><br>这是个好问题，共享库在内存中也是采用分页机制的。<br>同时调用共享库只要对应的指令代码是PIC的也就是地址无关的，并不会有什么问题。但是两个进程的数据段是不共享的而已。<br><br>","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559132512,"ip_address":"","comment_id":96365,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57392979020","product_id":100026001,"comment_content":"浩哥您好，有个问题想请教一下您。<br>共享库在内存中也是采用分页机制么？  如果是的话，那么怎么解决多进程同时调用共享库的问题呢？<br>如果不是的话，那么这共享库在内存里就是全加载？","like_count":13,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450848,"discussion_content":"焰火同学你好\n\n这是个好问题，共享库在内存中也是采用分页机制的。\n同时调用共享库只要对应的指令代码是PIC的也就是地址无关的，并不会有什么问题。但是两个进程的数据段是不共享的而已。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559132512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124987,"discussion_content":"他想问的应该是如果是分页的话，某些程序想用某几页，另一些程序又想用其他页，极端情况是不是会导致共享库全加载到内存中了？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578465444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95552,"user_name":"冯华琴也可叫做冯琴华","can_delete":false,"product_type":"c1","uid":1211345,"ip_address":"","ucode":"D436A8EF05E547","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/d1/132019c7.jpg","comment_is_top":false,"comment_ctime":1558079796,"is_pvip":false,"replies":[{"id":"34146","content":"👍动态代理是个不错的例子","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1558090007,"ip_address":"","comment_id":95552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53097687348","product_id":100026001,"comment_content":"动态代理？上层应用只和代理类交互，具体实现是透明的。","like_count":12,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450510,"discussion_content":"👍动态代理是个不错的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558090007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95926,"user_name":"cbing","can_delete":false,"product_type":"c1","uid":1010179,"ip_address":"","ucode":"61399122B2E62D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/03/a3b0d635.jpg","comment_is_top":false,"comment_ctime":1558258070,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"44507931030","product_id":100026001,"comment_content":"在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。<br>-------------------<br>老师可不可以重新解释下这一段啊，特别是“所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置”这一句，好懵","like_count":10,"discussions":[{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308360,"discussion_content":"就是都有，举个不太好的例子。比如一栋大楼，它有一个表，通过这个表可以找到每个房间，因为房间是相对于这栋大楼固定的。现在，你需要从你家去到这栋大楼的某个房间，这时候，你就需要复制一份这个表。但是这个表跟原来的那个表不完全一样，需要在原表的基础上加上你家到这这栋大楼的偏移。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1600929537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2425841,"avatar":"https://static001.geekbang.org/account/avatar/00/25/03/f1/69e111f0.jpg","nickname":"walter","note":"","ucode":"C45C93E3DFFAF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357017,"discussion_content":"在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享（1）的，但是数据部分是各个动态链接它的应用程序里面各加载一份（2）的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置（共享库在映射到虚拟内存里面的地址）。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的（是在加载时写入的，这个不是共享的，而是每隔进程一份）（3）。\n我的理解：读者（外部地址指令）去图书馆（共享库）借书因为不知道书的具体位置，所以需要用借阅电脑（GOT）查找出书的位置（虚拟内存的地址），这个过程就行GOT发挥作用的过程。\n（1）图书馆里面的书是共享的，\n（2）但被每个读者借出去以后又是特别的。\n（3）这个过程就好像读者借书时录入自己的信息\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615726573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1285612,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKy9XSxDLRibViazIs1wzhEmIQqMlhcoKhTXNvxXkaPGIveib8B9ibvpdkZxABKFIc4iaSMrkTh7EfWjtg/132","nickname":"likejjj","note":"","ucode":"005BF873B32EA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306807,"discussion_content":"共享库里面的GOT表再数据段，每个进程会copy一份共享库的数据段，同时因为GOT表与代码段之间的偏移量是确定的，从而可以计算出具体的代码地址","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600395367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242498,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/82/75f71508.jpg","nickname":"曾立涵","note":"","ucode":"C8E9019A44FB9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177670,"discussion_content":"我的理解是：无论是共享库还是要调用它的程序，本身都有data section，在链接的时候都会合并起来（ELF和静态链接里那个ELF的图里有画），在链接动态库，动态库载入程序的虚拟内存时，会把动态库data section里GOT表也合到程序的data section里，也就是每个程序都有自己的一份GOT表，而GOT表的数据，就是在链接动态库时生成的。而动态库在程序虚拟内存里的位置，都要靠程序里自己的GOT表来找到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582118317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242498,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/82/75f71508.jpg","nickname":"曾立涵","note":"","ucode":"C8E9019A44FB9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253595,"discussion_content":"按老师的说法，应该是共享库的代码段是共享的，只加载一份，但是数据段是每个进程各自加载的，另外GOT生成比较绕，他一开始是不知道自己的位置的，当PLT查找对应的GOT，第一次的时候GOT也不知道共享库的函数的位置，于是它回调PLT[0]，PLT[0]又调用GOT[2]，GOT[2]会调用lib.so找到实际函数的位置，完成地址重映射，并且把地址填到对应GOT，这样下次再找的时候就直接可以获得了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588246654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177670,"ip_address":""},"score":253595,"extra":""},{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1242498,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/82/75f71508.jpg","nickname":"曾立涵","note":"","ucode":"C8E9019A44FB9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547318,"discussion_content":"不会合并。。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642610044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177670,"ip_address":""},"score":547318,"extra":""}]}]},{"had_liked":false,"id":95869,"user_name":"cbing","can_delete":false,"product_type":"c1","uid":1010179,"ip_address":"","ucode":"61399122B2E62D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/03/a3b0d635.jpg","comment_is_top":false,"comment_ctime":1558237985,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35917976353","product_id":100026001,"comment_content":"在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。<br>--------------<br>这段完全看不懂QAQ","like_count":8,"discussions":[{"author":{"id":1643181,"avatar":"https://static001.geekbang.org/account/avatar/00/19/12/ad/8a149930.jpg","nickname":"青城","note":"","ucode":"9C255FF808D4EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360311,"discussion_content":"一样，哈哈。看到后面有点懵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616416792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95599,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1558096343,"is_pvip":false,"replies":[{"id":"35524","content":"👍坚持到底就是胜利","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559130318,"ip_address":"","comment_id":95599,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31622867415","product_id":100026001,"comment_content":"这一周紧赶慢赶，总算是赶上了更新的进度。day10天学习笔记<br>https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;10880416.html","like_count":7,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450532,"discussion_content":"👍坚持到底就是胜利","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559130318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2119325,"avatar":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","nickname":"ryanxw","note":"","ucode":"0B91EAC8D06EED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396802,"discussion_content":"笑死，抄了一遍也叫学习笔记","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1632494609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95909,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1558253340,"is_pvip":true,"replies":[{"id":"35541","content":"不使用动态链接的话就不需要啊","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559132691,"ip_address":"","comment_id":95909,"utype":1}],"discussion_count":1,"race_medal":1,"score":"27328057116","product_id":100026001,"comment_content":"每个应用程序都会生成自己的GOT表吗？","like_count":6,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450636,"discussion_content":"不使用动态链接的话就不需要啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559132691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334813,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1645146723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14530048611","product_id":100026001,"comment_content":"链接其实就是寻找目标代码段的过程。静态链接是把代码直接复制一份写到目标文件里了。而动态链接则是记下目标代码段的所在地址进行映射跳转。PLT和GLT两级跳转寻址，是为了延迟加载共享库，节约内存。","like_count":3},{"had_liked":false,"id":168404,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1578061852,"is_pvip":false,"replies":[{"id":"68650","content":"gogo同学，<br><br>你好，是的，动态绑定其实和动态链接本质上就是同一个思路。<br><br>要看对应的汇编代码，可以找一台云主机装一下Linux，Mac下连readelf这样可以读取elf格式的命令也没有。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581233316,"ip_address":"","comment_id":168404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14462963740","product_id":100026001,"comment_content":"在mac上面好像看不出来 PLT 和 GOT 的存在<br><br>objdump -source show_me_poor<br><br>show_me_poor:   file format Mach-O 64-bit x86-64<br><br>Disassembly of section __TEXT,__text:<br>__text:<br>100000f70:      55      pushq   %rbp<br>100000f71:      48 89 e5        movq    %rsp, %rbp<br>100000f74:      48 83 ec 10     subq    $16, %rsp<br>100000f78:      c7 45 fc 05 00 00 00    movl    $5, -4(%rbp)<br>100000f7f:      8b 7d fc        movl    -4(%rbp), %edi<br>100000f82:      e8 09 00 00 00  callq   9 &lt;dyld_stub_binder+0x100000f90&gt;<br>100000f87:      31 c0   xorl    %eax, %eax<br>100000f89:      48 83 c4 10     addq    $16, %rsp<br>100000f8d:      5d      popq    %rbp<br>100000f8e:      c3      retq<br><br>_main:<br>100000f70:      55      pushq   %rbp<br>100000f71:      48 89 e5        movq    %rsp, %rbp<br>100000f74:      48 83 ec 10     subq    $16, %rsp<br>100000f78:      c7 45 fc 05 00 00 00    movl    $5, -4(%rbp)<br>100000f7f:      8b 7d fc        movl    -4(%rbp), %edi<br>100000f82:      e8 09 00 00 00  callq   9 &lt;dyld_stub_binder+0x100000f90&gt;<br>100000f87:      31 c0   xorl    %eax, %eax<br>100000f89:      48 83 c4 10     addq    $16, %rsp<br>100000f8d:      5d      popq    %rbp<br>100000f8e:      c3      retq<br>Disassembly of section __TEXT,__stubs:<br>__stubs:<br>100000f90:      ff 25 7a 00 00 00       jmpq    *122(%rip)<br>Disassembly of section __TEXT,__stub_helper:<br>__stub_helper:<br>100000f98:      4c 8d 1d 69 00 00 00    leaq    105(%rip), %r11<br>100000f9f:      41 53   pushq   %r11<br>100000fa1:      ff 25 59 00 00 00       jmpq    *89(%rip)<br>100000fa7:      90      nop<br>100000fa8:      68 00 00 00 00  pushq   $0<br>100000fad:      e9 e6 ff ff ff  jmp     -26 &lt;__stub_helper&gt;<br><br><br>mac 下好像是 100000f82:      e8 09 00 00 00  callq   9 &lt;dyld_stub_binder+0x100000f90&gt;  <br>dyld_stub_binder<br><br>不过，算是知道或者说了解了共享库是通过动态链接 动态生成共享代码的地址，而这个地址一方面是在运行的时候生成，另一方面取决于当前指令的相对地址。这里面有两个重要的表叫PLT(程序链接表)和 GOT(全局位移表)。<br><br>额，忽然想起来了一个词语，叫动态绑定，就是运行时才知道是哪个实现。<br>而静态绑定，就是在编译的时候就已经确定了是哪个实现。<br><br>要更好的理解这一讲，需要结合老师推荐的书和linux 环境。","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480211,"discussion_content":"gogo同学，\n\n你好，是的，动态绑定其实和动态链接本质上就是同一个思路。\n\n要看对应的汇编代码，可以找一台云主机装一下Linux，Mac下连readelf这样可以读取elf格式的命令也没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581233316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96756,"user_name":"栋能","can_delete":false,"product_type":"c1","uid":1006849,"ip_address":"","ucode":"8BD9C939D3E8E1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/01/9cd84003.jpg","comment_is_top":false,"comment_ctime":1558497714,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14443399602","product_id":100026001,"comment_content":"看了GOT表之后的那个图（动态链接过程图）我有个疑问，我们的程序在虚拟内存中还是像静态链接那样，把需要的库都加载（拼接）进来的，故调用的共享库在程序的虚拟内存空间中其实还是多份的？还有就是如果GOT在共享库的data section，那不同程序调用的时候，如何区分当前GOT属于那个程序呢？","like_count":3,"discussions":[{"author":{"id":1040236,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg","nickname":"Dylan","note":"","ucode":"58064D0C9F9F5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182590,"discussion_content":"进程对应的虚拟地址空间中的data段里会有相应的GOT位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582438835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131165,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/9d/c36b7ef7.jpg","nickname":"顾骨","note":"","ucode":"3F6BA592AB7723","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260,"discussion_content":"去看看虚拟内存和物理内存的映射，应该就懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561365460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95757,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1252639,"ip_address":"","ucode":"2F3959A717BE10","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/1f/6bc10297.jpg","comment_is_top":false,"comment_ctime":1558166829,"is_pvip":false,"replies":[{"id":"35558","content":"Allen同学你好，<br><br>这个需要的前置知识有点多，而且不太方便用文章的形式体现。先要教会大家用gbd，然后一步一步调试，也不太适合录音。<br><br>我想想是否有可能在专栏结束之后用加餐的形式提供一些对应的内容。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559133547,"ip_address":"","comment_id":95757,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443068717","product_id":100026001,"comment_content":"老师可以加一节课，讲解一下如何利用栈信息，来解栈调用关系吗？<br><br>比如：C程序发生段错误，利用黑匣子日志，如何分析 段错误时，函数的堆栈信息吗？","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450587,"discussion_content":"Allen同学你好，\n\n这个需要的前置知识有点多，而且不太方便用文章的形式体现。先要教会大家用gbd，然后一步一步调试，也不太适合录音。\n\n我想想是否有可能在专栏结束之后用加餐的形式提供一些对应的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559133547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179295,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1581953860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171888452","product_id":100026001,"comment_content":"感觉看到这节，要掉队了。指令和运算08~09一节一些不懂，直接会影响到本节的学习。每个字都认识，串在一起一大段就不认识了。","like_count":2},{"had_liked":false,"id":133631,"user_name":"w 🍍","can_delete":false,"product_type":"c1","uid":1228290,"ip_address":"","ucode":"F2386C971EC58B","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/02/43202976.jpg","comment_is_top":false,"comment_ctime":1568624794,"is_pvip":false,"replies":[{"id":"52639","content":"我想了一下，如果共享库动态链接调用主进程里面定义的函数，也是可以让共享库去调用主进程的。但是这是一种循环依赖设计，意味着你的代码结构设计很可能出了问题。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1569659069,"ip_address":"","comment_id":133631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158559386","product_id":100026001,"comment_content":"进程调用共享库时，用GOT来找到共享库地址，那共享库会用到GOT来获取主进程的数据吗？","like_count":2,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467455,"discussion_content":"我想了一下，如果共享库动态链接调用主进程里面定义的函数，也是可以让共享库去调用主进程的。但是这是一种循环依赖设计，意味着你的代码结构设计很可能出了问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569659069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95513,"user_name":"ezra.xu","can_delete":false,"product_type":"c1","uid":1014005,"ip_address":"","ucode":"6C3E11889BC6AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/f5/ae200a94.jpg","comment_is_top":false,"comment_ctime":1558071630,"is_pvip":false,"replies":[{"id":"35527","content":"抱歉手头没有mac，我看看稍后抽空研究一下，不过不使用-M一样可以看到对应的指令信息，只是可能格式稍有不同，应该不影响理解指令含义。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1559130457,"ip_address":"","comment_id":95513,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10148006222","product_id":100026001,"comment_content":"mac机器上objdump命令-M选项有问题，请老师确认下该如何处理，谢谢。","like_count":2,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450489,"discussion_content":"抱歉手头没有mac，我看看稍后抽空研究一下，不过不使用-M一样可以看到对应的指令信息，只是可能格式稍有不同，应该不影响理解指令含义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559130457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112913,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fb/51/870a6fcb.jpg","nickname":"Trust me ҉҉҉҉҉҉҉❀","note":"","ucode":"B576CBDE262A40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531120,"discussion_content":"mac 不是linux，文件格式叫 Mach-O 你要用 otools -s 去看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637236187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a2/df/924756fe.jpg","nickname":"Durian_","note":"","ucode":"D07FD85A81C6D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200544,"discussion_content":"你有解决吗\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583682820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95394,"user_name":"青莲","can_delete":false,"product_type":"c1","uid":1181787,"ip_address":"","ucode":"6BA5D5D47DE38E","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/5b/2a342424.jpg","comment_is_top":false,"comment_ctime":1558052420,"is_pvip":true,"replies":[{"id":"34192","content":"如果算的话，你认为是为什么呢？","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1558099782,"ip_address":"","comment_id":95394,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147987012","product_id":100026001,"comment_content":"多态算吗","like_count":2,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450440,"discussion_content":"如果算的话，你认为是为什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558099782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353427,"user_name":"X","can_delete":false,"product_type":"c1","uid":1581509,"ip_address":"上海","ucode":"BE05C1D25CE313","user_header":"https://static001.geekbang.org/account/avatar/00/18/21/c5/024e1ef1.jpg","comment_is_top":false,"comment_ctime":1659431302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5954398598","product_id":100026001,"comment_content":"看了一遍，懵懵懂懂，大概明白共享库的意思就是不要每次通过静态链接将一些底层的函数库给链接进来，这样程序一多的话，每个程序都有一份底层函数库，太占用内存了，所以得想办法将底层共用的函数库给提取出来，弄成共用的函数库。<br>然后共用的函数库就和plt和got有关。<br>plt是存在公共函数库里的，got是每个程序自己维护的一份偏移表。<br>还需细细品尝。","like_count":1},{"had_liked":false,"id":170944,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1578795495,"is_pvip":false,"replies":[{"id":"68108","content":"-_-_aaa同学，<br><br>你好，并不会这样，可以回头去看一下第7讲讲Stack的相关内容再思考一下。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580636669,"ip_address":"","comment_id":170944,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5873762791","product_id":100026001,"comment_content":"文中”大部分函数库其实都可以做到地址无关，因为它们都接受特定的输入，进行确定的操作，然后给出返回结果就好了。无论是实现一个向量加法，还是实现一个打印的函数，这些代码逻辑和输入的数据在内存里面的位置并不重要。”如果返回的结果不知道地址，或者没有地址那调用它的函数就拿不到它的值，那岂不是很尴尬。","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481177,"discussion_content":"-_-_aaa同学，\n\n你好，并不会这样，可以回头去看一下第7讲讲Stack的相关内容再思考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580636669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142856,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1571563689,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5866530985","product_id":100026001,"comment_content":"<br>---总结---<br>为了减少静态链接中的内存消耗问题，引入了动态链接<br>实现动态链接的要点：地址无关（相对地址）<br><br>---问题---<br>1. 请问下老师，“共享库的数据部分”指的是什么？<br>2. 对于PLT和GOT表，是否PLT是位于应用代码的数据段而GOT位于共享库的数据段，而PLT中的数据项会指向GOT中的数据项？","like_count":1,"discussions":[{"author":{"id":1270780,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8AdNibZHbZriaqLQZrNPcX8hVOpY91o0ELl7eOq7qy3aTibjia10ymIsKUKW6Ucs9SuXBDWlg6sjahw/132","nickname":"逆舟","note":"","ucode":"B303B4B8E10E0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272604,"discussion_content":"我也有同样的疑问，希望老师抽空解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590328239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118567,"user_name":"Lrwin","can_delete":false,"product_type":"c1","uid":1180503,"ip_address":"","ucode":"5E394E36419C56","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/57/31595f22.jpg","comment_is_top":false,"comment_ctime":1564390476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859357772","product_id":100026001,"comment_content":"http状态码30x","like_count":1},{"had_liked":false,"id":95792,"user_name":"Geek_648105","can_delete":false,"product_type":"c1","uid":1487690,"ip_address":"","ucode":"92AF101EED2BCB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nNU5h24KDv8cP8zTcWjKBhc5gmMnmWDEM0QF2F6mdItYk1sz6GPic59bR1xicwO8HATXX2q2G8iamSVNExQ5KEYiag/132","comment_is_top":false,"comment_ctime":1558178021,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5853145317","product_id":100026001,"comment_content":"多个应用程序同时调用同一个库，不是有重入的问题吗？库应该是用可重入的方式写吗？我反复看了几遍，对于库是不太理解。","like_count":1,"discussions":[{"author":{"id":2617636,"avatar":"https://static001.geekbang.org/account/avatar/00/27/f1/24/07ce02a0.jpg","nickname":"熊光红","note":"","ucode":"2216C008FAD248","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378026,"discussion_content":"函数的局部变量存储在栈中，每个线程栈不一样，不会充入，全局变量就会出问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623023160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363359,"discussion_content":"是的，只共享程序段，不会有重入问题的；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617178235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1285612,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKy9XSxDLRibViazIs1wzhEmIQqMlhcoKhTXNvxXkaPGIveib8B9ibvpdkZxABKFIc4iaSMrkTh7EfWjtg/132","nickname":"likejjj","note":"","ucode":"005BF873B32EA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306808,"discussion_content":"数据段每个进程拷贝一份，应该是可以避免重入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600395536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95507,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1558069253,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5853036549","product_id":100026001,"comment_content":"plt应该是在链接动态库时候生成的。<br>不知道理解是否正确","like_count":1},{"had_liked":false,"id":95444,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1558057027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853024323","product_id":100026001,"comment_content":"go语言的闭包","like_count":1},{"had_liked":false,"id":358546,"user_name":"张无忌","can_delete":false,"product_type":"c1","uid":1222000,"ip_address":"浙江","ucode":"87E5FC2F415774","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/70/d7b70282.jpg","comment_is_top":false,"comment_ctime":1664421116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664421116","product_id":100026001,"comment_content":"老师好，看到这句：“你回想一下我们之前讲过的重定位表。在程序链接的时候，我们就把函数调用后要跳转访问的地址确定下来了”。<br>请问，重定向表里面记录的是虚拟地址还是物理地址？逻辑上分析，应该是虚拟地址，如果是物理地址，那限制就太大了。如果是虚拟地址，为什么说“要跳转的地址确定下来了”？不是很理解","like_count":0},{"had_liked":false,"id":351670,"user_name":"Geek_f34ff0","can_delete":false,"product_type":"c1","uid":3050175,"ip_address":"","ucode":"EEFA753D53AF60","user_header":"","comment_is_top":false,"comment_ctime":1658072374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658072374","product_id":100026001,"comment_content":"shenandoah垃圾收集器用来解决和用户程序并发跟新引用的转发指针技术","like_count":0},{"had_liked":false,"id":349173,"user_name":"Timothy","can_delete":false,"product_type":"c1","uid":1143015,"ip_address":"","ucode":"A3E94236DD7A82","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/e7/82cd831d.jpg","comment_is_top":false,"comment_ctime":1655781183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655781183","product_id":100026001,"comment_content":"老师您好，请问想编译输出show_me_poor.c的结果看下，应该怎么编译呢？（我尝试gcc编译报错：show_me_poor.c:(.text+0x15): undefined reference to `show_me_the_money&#39;）","like_count":0},{"had_liked":false,"id":348976,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1655617938,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655617938","product_id":100026001,"comment_content":"动态链接好是好，版本管理很痛苦","like_count":0},{"had_liked":false,"id":348771,"user_name":"Geek_0ba253","can_delete":false,"product_type":"c1","uid":2612720,"ip_address":"","ucode":"55D6DDECC9AF60","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QvyPibAqLH5uEr7GNL6Lg9jT9sUs9jtub4LvO575nHuT3viagzmvKLCwGQRicsiadic3n9lM62qQ6n5shHfXUYib8Ktg/132","comment_is_top":false,"comment_ctime":1655376986,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1655376986","product_id":100026001,"comment_content":"在一个输入需要不同处理的时候，用一个变量来接收外部所需处理的函数名，实际执行通过变量值动态调用函数。","like_count":0},{"had_liked":false,"id":342950,"user_name":"Geek_d68bf9","can_delete":false,"product_type":"c1","uid":2173090,"ip_address":"","ucode":"D88E117B6A18B3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIstR9CfEytdeJyicODHOe6cYGt4icg8cNVam9mE0s7picUsInZvwvia1hEtKsyHETfic0jrAddjt0wXdA/132","comment_is_top":false,"comment_ctime":1650545748,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650545748","product_id":100026001,"comment_content":"看了一遍，竟然没看懂。。。","like_count":0},{"had_liked":false,"id":340036,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1648548937,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648548937","product_id":100026001,"comment_content":"前提是程序不会装载的时候就把所有动态库的调用执行并形成plt和got表，而是运行时加载进来的，那么久需要一步步的建立物理内存和虚拟内存的表格，就是plt和got表。而plt和got表是写在动态库的数据段，代码段是不允许修改的。<br><br>如果这里不清楚，那么可能没办法更好的理解got表的作用和原理了。","like_count":0},{"had_liked":false,"id":340035,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1648548899,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648548899","product_id":100026001,"comment_content":"前提是程序不会装载的时候就把所有动态库的调用执行并形成plt和got表，而是运行时加载进来的，那么久需要一步步的建立物理内存和虚拟内存的表格，就是plt和got表。而plt和got表是写在动态库的数据段，代码段是不允许修改的。","like_count":0},{"had_liked":false,"id":327613,"user_name":"Geek_53ae34","can_delete":false,"product_type":"c1","uid":2873876,"ip_address":"","ucode":"051A1A5C1B9621","user_header":"","comment_is_top":false,"comment_ctime":1640188866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640188866","product_id":100026001,"comment_content":"动态链接相比静态链接，程序运行效率要影响多少？","like_count":0},{"had_liked":false,"id":305431,"user_name":"陈柏林","can_delete":false,"product_type":"c1","uid":1282562,"ip_address":"","ucode":"2636649821FAB9","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/02/288a6b8c.jpg","comment_is_top":false,"comment_ctime":1627971643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627971643","product_id":100026001,"comment_content":"老师,程序在动态链接了共享库之后是否是根据自身的内存地址加上GOT中记录的偏移量计算出共享库的物理地址,然后调用函数?还有另外一个问题,如果两个程序都定义了一个同名的函数动态加载到动态库的,是否会引起错误,望回复!","like_count":0},{"had_liked":false,"id":292493,"user_name":"Geek_c5ffc5","can_delete":false,"product_type":"c1","uid":1625628,"ip_address":"","ucode":"282EBC6E355D50","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLjiaBdicic93IOs2GlnT54iarib6qHZga5x58yyseVMUoQY2VBIHfq6ea3I510qQ3813bFFwmG5oTDGiaQ/132","comment_is_top":false,"comment_ctime":1620842564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620842564","product_id":100026001,"comment_content":"那当我们把目光挪到上面的 400550 这个地址，你又会看到里面进行了一次跳转，这个跳转指定的跳转地址，你可以在后面的注释里面可以看到，GLOBAL_OFFSET_TABLE+0x18。这里的 GLOBAL_OFFSET_TABLE，就是我接下来要说的全局偏移表。<br>——-没看太明白 0x18这里是怎么来的","like_count":0},{"had_liked":false,"id":292427,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1620816349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620816349","product_id":100026001,"comment_content":"面向抽象编程，实现类与类之间解耦的意思。<br>类之间关联是通过接口，而不是具体实现类。","like_count":0},{"had_liked":false,"id":291680,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1620429798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620429798","product_id":100026001,"comment_content":"动态库应该也有对应的虚拟地址 映射到不连续的物理地址 是不是 ","like_count":0},{"had_liked":false,"id":291679,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1620429280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620429280","product_id":100026001,"comment_content":"这个 so 共享库是一次性加载到内存的 还是像之前那样分页加载到内存的 比如我调用一个printf函数他才会加载到内存吗 不然也是虚拟内存 加入这个函数需要的内存大于4k 是不是会占用2个页  是不是页的尾部会指向下个页头","like_count":0},{"had_liked":false,"id":286377,"user_name":"张勇生","can_delete":false,"product_type":"c1","uid":2188352,"ip_address":"","ucode":"C4A136DA8D7ABF","user_header":"","comment_is_top":false,"comment_ctime":1617273121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617273121","product_id":100026001,"comment_content":"老师  有了解过go吗   go这方面都是静态链接的  按你这说的原理  似乎每个程序都会占用很大内存喝磁盘空间","like_count":0},{"had_liked":false,"id":284170,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1616110192,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616110192","product_id":100026001,"comment_content":"如何高效使用有限内存设计，值得我们好好学习借鉴。","like_count":0},{"had_liked":false,"id":269459,"user_name":"小径交叉的汤圆","can_delete":false,"product_type":"c1","uid":2370863,"ip_address":"","ucode":"C53AAB22568AA2","user_header":"https://static001.geekbang.org/account/avatar/00/24/2d/2f/f6602f63.jpg","comment_is_top":false,"comment_ctime":1608660338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608660338","product_id":100026001,"comment_content":"请教一下徐老师，C&#47;C++在链接标准库的时候是用动态链接还是静态链接的方式呢，比如类似#include&lt;iostream&gt;&#47;#include&lt;stdio&gt;&#47;#include&lt;cmath&gt;&#47;#include&lt;vector&gt;等等的时候","like_count":0},{"had_liked":false,"id":268708,"user_name":"schwarzeni","can_delete":false,"product_type":"c1","uid":1112540,"ip_address":"","ucode":"C1969191F334BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/dc/0a1eeb4c.jpg","comment_is_top":false,"comment_ctime":1608300184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608300184","product_id":100026001,"comment_content":"记得以前在vps上编译c语言版的ss server（梯子）的时候报了缺少某个 .so  的错误 hhh","like_count":0},{"had_liked":false,"id":267130,"user_name":"ripple","can_delete":false,"product_type":"c1","uid":1090051,"ip_address":"","ucode":"99008FD0533F68","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ywSuwVNMKNjRLPMjZmpQOQHWW2usAu8RwRIOlBHaVVU6J3xHdtibgO6FVzYkRIkV50vCr62ia4OwJp07giabiazUGA/132","comment_is_top":false,"comment_ctime":1607605071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607605071","product_id":100026001,"comment_content":"我们之所以在linux或者android上使用动态库，如果这个动态库没有用到系统的库函数，那么理论上，动态库和静态库相比，也没有节约磁盘空间对吧，如果库中用到了系统相关的库函数，那么这些库函数所在的库是没有包含进程序的，只有运行的时候，动态去加载","like_count":0},{"had_liked":false,"id":257613,"user_name":"余巍","can_delete":false,"product_type":"c1","uid":1995082,"ip_address":"","ucode":"B0819C42A82371","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0eGJygV4lh6PJuotKrz1jsZcOdNiaHnUC3y5A2O3yudUQLkzOE8758icDoXlvgpytQ50ibSIc9nJmg/132","comment_is_top":false,"comment_ctime":1604043757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604043757","product_id":100026001,"comment_content":"假设so共享库a已经被加载，在物理地址00aaH，你自己程序的代码（使用了共享库a）加载时，操作系统会给这个进程创建一个页表，页表是虚拟内存空间和物理内存空间的映射，因为进程内部要使用共享库a，为了共享就假装加载了共享库a，把共享库a的真实物理地址放到页表中某一项中去了，而GOT存储的值应该是共享库a在页表中虚拟地址。老师这样理解有问题没？","like_count":0},{"had_liked":false,"id":245020,"user_name":"zxk","can_delete":false,"product_type":"c1","uid":1221195,"ip_address":"","ucode":"4BB2BD9D2BCD04","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/4b/b72f724f.jpg","comment_is_top":false,"comment_ctime":1598784552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598784552","product_id":100026001,"comment_content":"这样，我们的共享库就是地址无关的代码，对应的各个程序只需要在物理内存里面加载同一份代码。而我们又要通过各个可执行程序在加载时，生成的各不相同的 GOT 表，来找到它需要调用到的外部变量和函数的地址。<br>老师，这句话可不可以理解为，当各个可执行程序需要访问共享库的变量及函数时，查询自己的GOT表即可？","like_count":0},{"had_liked":false,"id":228039,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1592541587,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592541587","product_id":100026001,"comment_content":"show me the money，暴露年龄了😎","like_count":0},{"had_liked":false,"id":227848,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1810189,"ip_address":"","ucode":"75F613D58909DB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZHw73tgCqGKhvticUWGRz4icgicu4hFWfKtacoFJeItH7maNuNUmjnEgDTJvOibwUWgGV0p6guNPibMVWDV4BUmEmlA/132","comment_is_top":false,"comment_ctime":1592493590,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1592493590","product_id":100026001,"comment_content":"徐老师你好，整一篇文章就这句话还不是很懂；“所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。”假设，我的一个程序已经加载了一个共享库然后启动运行了，然后另一个程序刚刚启动，那这个共享库怎么加载到我刚刚启动的程序的GOT里面呢？<br>还望老师解答！！要不然后面的课程可能会听不太明白","like_count":0,"discussions":[{"author":{"id":2924187,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/SluScDGqnhBNwmOQ774QEzuXiazk8Ab7ng8xCT81gunl9Hls9oibwB4AibCDxDtZwTe4mEib5QiaLXUqMv8iceXicXSYg/132","nickname":"Geek_080ce7","note":"","ucode":"C74D97C84983B9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566892,"discussion_content":"应该是每个进程都有自己的plt和got,共享库已经再内存中存在，而新进程去第一次调用的时候会经过一个地址的计算，也就是调用函数地址解析函数（_dl_runtime_resolve），获取到实际内存地址之后回写到新进程的got里面，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650791597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1285612,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKy9XSxDLRibViazIs1wzhEmIQqMlhcoKhTXNvxXkaPGIveib8B9ibvpdkZxABKFIc4iaSMrkTh7EfWjtg/132","nickname":"likejjj","note":"","ucode":"005BF873B32EA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306813,"discussion_content":"共享库，共享的是代码段。每个进程有自己的进程空间，不会影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600395741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211004,"user_name":"陈诚","can_delete":false,"product_type":"c1","uid":1338751,"ip_address":"","ucode":"138DD00D245FEE","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/7f/e1c189c7.jpg","comment_is_top":false,"comment_ctime":1587880194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587880194","product_id":100026001,"comment_content":"个人觉得理解动态链接的一句要诀：将对label的解析推迟到不能再推迟，即推迟到第一次使用该label时","like_count":0},{"had_liked":false,"id":202149,"user_name":"WENMURAN","can_delete":false,"product_type":"c1","uid":1915404,"ip_address":"","ucode":"5D1CE8B41937C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXNhbTULKiakib8lYXrvGF2zPwfedooBzC2EtSv1nt1MwV1KUvTkcJrvCBFvcdwJicnr3OEXnk9GUCg/132","comment_is_top":false,"comment_ctime":1585910764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585910764","product_id":100026001,"comment_content":"动态链接<br>链接是把对应的不同文件内的代码段合并到一起成为最后可执行的文件。<br>装载器在加载程序指令时，有很多时候指令是重复的，如果重复调用的话，占用大量内存，效率不高，于是引入动态链接。<br>动态链接的对象，是加载到内存中的共享库，共享就是大家都可以用，但是，这些代码必须“地址无关”。<br>在动态链接的共享库里，保存了一张全局偏移表（GOT），所有需要引用当前共享库外部的地址的指令，都会查询GOT，来找到当前运行程序的虚拟内存里的对应位置。","like_count":0},{"had_liked":false,"id":199457,"user_name":"Arthur.Li","can_delete":false,"product_type":"c1","uid":1005824,"ip_address":"","ucode":"EC2436A5136C13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","comment_is_top":false,"comment_ctime":1585489564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585489564","product_id":100026001,"comment_content":"c语言几乎开头都会引用的stdio.h，是不是动态链接库","like_count":0},{"had_liked":false,"id":192039,"user_name":"大头爸爸","can_delete":false,"product_type":"c1","uid":1276613,"ip_address":"","ucode":"131E25DB04D222","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","comment_is_top":false,"comment_ctime":1584826148,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584826148","product_id":100026001,"comment_content":"对汇编不熟，请问rip和PC是什么关系呢？好像都是指向CPU将要执行的指令的位置?","like_count":0,"discussions":[{"author":{"id":1645302,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1a/f6/19e67bea.jpg","nickname":"モブ","note":"","ucode":"01BE64E20DEF7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253557,"discussion_content":"rip是64位intel指令指针寄存器，对应32位eip和x86的ip，PC是非Intel厂商对指令指针寄存器的叫法，其实是一个东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588243729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189188,"user_name":"Ht","can_delete":false,"product_type":"c1","uid":1620981,"ip_address":"","ucode":"91E3A107280519","user_header":"https://static001.geekbang.org/account/avatar/00/18/bb/f5/f60a479f.jpg","comment_is_top":false,"comment_ctime":1584470896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584470896","product_id":100026001,"comment_content":"在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。<br>------------------------<br>这里的GOT表是指的各个程序里data段里的（合并了共享库的GOT表内容），它记录了当前程序加载到的各个共享库与当前程序的代码段的相对位置，这样在执行进入到共享库后，当需要跳出共享库时，就查询该GOT表中该共享库的相对位置，使用共享库栈顶+相对位置跳回到程序中对应的虚拟内存地址，继续获取虚拟内存地址-&gt;物理内存地址中的指令到指令寄存器中执行。请问老师这样理解对吗","like_count":0},{"had_liked":false,"id":160372,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1575942540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575942540","product_id":100026001,"comment_content":"动态链接就是来解决静态链接缺陷的一种方式！","like_count":0},{"had_liked":false,"id":152758,"user_name":"好饿早知道送外卖了","can_delete":false,"product_type":"c1","uid":1132304,"ip_address":"","ucode":"AED22DB5BF8FC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","comment_is_top":false,"comment_ctime":1574076110,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1574076110","product_id":100026001,"comment_content":"没太看懂~所以相对地址在执行的时候可以看做是对不同程序内存中的动态库的虚拟地址进行了一次重定向、定向到指定位置的偏移量？","like_count":0},{"had_liked":false,"id":139022,"user_name":"小冰","can_delete":false,"product_type":"c1","uid":1012854,"ip_address":"","ucode":"B78FA8960F7417","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/76/50c8b033.jpg","comment_is_top":false,"comment_ctime":1570528263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570528263","product_id":100026001,"comment_content":"虽然没搞懂很细节的东西，但是我感觉这些解决问题的思想方法有所领会，对于程序是怎么跑起来的，有一个大体的认识了。感谢！<br>现在还处于不求甚解的阶段，还需要通过时常回顾，不断温故知新加深理解","like_count":0},{"had_liked":false,"id":138623,"user_name":"........","can_delete":false,"product_type":"c1","uid":1236198,"ip_address":"","ucode":"D54E7F428E7F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/e6/ea4b2c10.jpg","comment_is_top":false,"comment_ctime":1570375829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570375829","product_id":100026001,"comment_content":"老师, 请问一下, 每个共享库的data section部分都有一张GOT表，其中存放着数据段和代码段的相对位置。其他程序引用共享库的时候，需要加载数据段，同时根据现有的GOT表重新计算，相对位置，不知道这样理解对不对?","like_count":0},{"had_liked":false,"id":125728,"user_name":"袭","can_delete":false,"product_type":"c1","uid":1077573,"ip_address":"","ucode":"D5B8609CDFB145","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/45/126cd913.jpg","comment_is_top":false,"comment_ctime":1566233925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566233925","product_id":100026001,"comment_content":"这样总结对吗？ 共享代码库使用相对地址，got根据相对地址计算出在进程虚拟内存中的绝对地址，然后主程序调用时就可以查表通过绝对地址找到函数入口。","like_count":0},{"had_liked":false,"id":125727,"user_name":"袭","can_delete":false,"product_type":"c1","uid":1077573,"ip_address":"","ucode":"D5B8609CDFB145","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/45/126cd913.jpg","comment_is_top":false,"comment_ctime":1566233747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566233747","product_id":100026001,"comment_content":"总结：共享代码库里面的地址都使用相对地址，全局偏移表计算出在程序虚拟内存中的绝对地址，","like_count":0},{"had_liked":false,"id":117149,"user_name":"一尾","can_delete":false,"product_type":"c1","uid":1517556,"ip_address":"","ucode":"67D404036231D1","user_header":"https://static001.geekbang.org/account/avatar/00/17/27/f4/a1ce6248.jpg","comment_is_top":false,"comment_ctime":1563977231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563977231","product_id":100026001,"comment_content":"谢谢！","like_count":0},{"had_liked":false,"id":107177,"user_name":"FutureEye","can_delete":false,"product_type":"c1","uid":1040569,"ip_address":"","ucode":"D5D50CD25B6BD2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/b9/ce3380ae.jpg","comment_is_top":false,"comment_ctime":1561473696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561473696","product_id":100026001,"comment_content":"老师是不是可以理解为：OC 中的类对象和对象是这个的吗？<br>也就是说说类对象永远只有一个，类对象中不包含变量的数据，每个变量的信息都是在创建的新对象中。对吗？","like_count":0},{"had_liked":false,"id":103968,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1560577237,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1560577237","product_id":100026001,"comment_content":"比如c++的“多态”，到底调用的是哪个对象，是通过一个映射表动态确定的；还比如用函数指针来调用不同的函数，也是动态确定到底调用哪个函数","like_count":0,"discussions":[{"author":{"id":1473251,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","nickname":"不一样的烟火","note":"","ucode":"6E305F0EE90E8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23431,"discussion_content":"感觉多态比喻不太贴切，多态会绑定不一样的函数实现，而共享库代码实现是一样的，只是地址不同 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569816786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101147,"user_name":"开心","can_delete":false,"product_type":"c1","uid":1517457,"ip_address":"","ucode":"C8E08E8724C7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","comment_is_top":false,"comment_ctime":1559727160,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1559727160","product_id":100026001,"comment_content":"在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。<br>这一段怎么看都理不通额","like_count":0,"discussions":[{"author":{"id":1040236,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg","nickname":"Dylan","note":"","ucode":"58064D0C9F9F5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182612,"discussion_content":"模块内的数据访问采用以当前PC指针+偏移的方式进行寻址；模块外的处理方式就是GOT啦，那如果是代码跳转就引入PLT","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582441421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100177,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1559468010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559468010","product_id":100026001,"comment_content":"老师好，Java里面方法只有一份，在方法区，这个和动态链接有关系么?","like_count":0},{"had_liked":false,"id":99208,"user_name":"YI🎐","can_delete":false,"product_type":"c1","uid":1004429,"ip_address":"","ucode":"EC473E92A07373","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/8d/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1559178000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559178000","product_id":100026001,"comment_content":"我有个问题，是怎么确定一个.so是同一个的？","like_count":0},{"had_liked":false,"id":98754,"user_name":"A🔱栋杰✨","can_delete":false,"product_type":"c1","uid":1046580,"ip_address":"","ucode":"C975704B321C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/34/9d8a2a6b.jpg","comment_is_top":false,"comment_ctime":1559090948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559090948","product_id":100026001,"comment_content":"1. 系统对共享库的判断标准是什么，仅仅是*.so类型文件加文件名？如果复制lib.so为lib1.so，同时两者被两个应用程序使用，装载时两者被视为同一个共享库，使用同一段物理内存吗？<br><br>2. 但凡引用了*.so文件的应用程序在装载时都遵循共享库加载机制(即动态链接)吗？若lib.so被多个程序引用，但一段时间内只有一个程序被编译、链接、装载、执行，此时对lib.so的引用是釆用静态链接还是动态链接？<br><br>3. 静态链接可以实现虚拟内存地址与物理内存地址的映射，因两处地址都是连续的，此处的映射本质上是否也是相对地址的体现(两种地址数学值上的偏移量固定)？在动态链接中是否也可以叫映射，若存在GOT，就让不同应用(引用的共享库对应)的虚拟内存地址映射至相同的物理内存地址？","like_count":0},{"had_liked":false,"id":97410,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1558665805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558665805","product_id":100026001,"comment_content":"看的懵懵懂懂  基本了解 一会再多看几遍 加深印象  搞懂所有问题","like_count":0},{"had_liked":false,"id":95758,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1252639,"ip_address":"","ucode":"2F3959A717BE10","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/1f/6bc10297.jpg","comment_is_top":false,"comment_ctime":1558166858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558166858","product_id":100026001,"comment_content":"<br>这样的话，汇编、plt等，都可以串起来了","like_count":0},{"had_liked":false,"id":95698,"user_name":"D","can_delete":false,"product_type":"c1","uid":1027596,"ip_address":"","ucode":"5BB4D16FE39BFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","comment_is_top":false,"comment_ctime":1558144810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558144810","product_id":100026001,"comment_content":"每个使用动态库的APP需要so同样大小的虚拟地址空间","like_count":0},{"had_liked":false,"id":95604,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1476388,"ip_address":"","ucode":"AB5828AAC90748","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/24/4fc7c548.jpg","comment_is_top":false,"comment_ctime":1558097175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558097175","product_id":100026001,"comment_content":"这篇写得挺好的。希望 运行时重定位的过程可以写的更详细些。","like_count":0},{"had_liked":false,"id":95587,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1558091944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558091944","product_id":100026001,"comment_content":"java的多态、重载差不多也是这个样的。","like_count":0},{"had_liked":false,"id":95508,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1558069991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558069991","product_id":100026001,"comment_content":"@胖胖胖 同求plt解答。不过我先去翻翻程序员的自我修养吧","like_count":0},{"had_liked":false,"id":95493,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1558064095,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1558064095","product_id":100026001,"comment_content":"不同的进程，调用同样的 lib.so，各自 GOT 里面指向最终加载的动态链接库里面的虚拟内存地址是不同的。<br>我们的 GOT 表位于共享库自己的数据段里。GOT 表在内存里和对应的代码段位置之间的偏移量，始终是确定的。<br><br>GOT里面的偏移量就是指的上面说的动态链接库的虚拟内存地址吧？那这样看起来这两句话是矛盾的呀，不同的进程中同一个动态链接库的GOT表里的虚拟内存地址应该是相同的吧？因为同一个库的同一个函数的相对于GOT的偏移量是相同的。","like_count":0,"discussions":[{"author":{"id":1561842,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d4/f2/98201045.jpg","nickname":"Jason","note":"","ucode":"63A89D36BE72E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3599,"discussion_content":"第三张图片，可以看出来GOT表里面的虚拟内存地址应该是不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564628499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95475,"user_name":"林三杠","can_delete":false,"product_type":"c1","uid":1012832,"ip_address":"","ucode":"E667F986D07DC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/60/0403b575.jpg","comment_is_top":false,"comment_ctime":1558061054,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1558061054","product_id":100026001,"comment_content":"程序运行时怎么找到共享库的位置？是默认从某个路径下获取吗？或者通过参数指定？","like_count":0,"discussions":[{"author":{"id":1561842,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d4/f2/98201045.jpg","nickname":"Jason","note":"","ucode":"63A89D36BE72E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3600,"discussion_content":"运行时需要指定共享库路径的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564628555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95446,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1558057165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558057165","product_id":100026001,"comment_content":"虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。老师，应用程序使用动态库数据是是写时复制吧，修改的时候才拷贝","like_count":0}]}