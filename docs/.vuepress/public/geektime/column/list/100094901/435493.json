{"id":435493,"title":"05 | 栈的魔法：从栈切换的角度理解进程和协程","content":"<p>你好，我是海纳。</p><p>上一节课，我们了解到函数在执行的时候，就会在栈上创建栈帧，那么函数执行的上下文都将保存在栈帧里。今天，我们就再来进一步分析，栈切换在计算机系统设计中所发挥的重要作用。</p><p>几乎所有的程序员都会遇到并发程序。因为多进程或者多线程程序可以并发执行，充分利用多CPU多核的计算资源来完成任务，会大大提升应用程序的性能。</p><p>所以，我相信你在工作中也遇到过多线程程序，但不知道你是否考虑过进程和线程是如何切换的呢？很多文章都介绍了，操作系统为了避免频繁进入内核态，会把很多工作都尽量放在用户态。那么你有没有仔细思考过内核态、用户态到底意味着什么呢？</p><p>要回答上面的问题，我们就要理解这些概念背后最重要的一个步骤：对执行单元的上下文环境进行切换。它就是由栈这个核心数据结构支撑的，这也是我们今天学习的重点内容。</p><p>通过今天的学习，你将掌握协程的基本知识，这样，你在C++中使用各种协程库，或者在Lua、Go等语言中使用原生协程的时候，就能理解它们背后发生了什么，也可以帮你写出正确的IO程序。你还将深入理解操作系统用户态和内核态，这样，你在做架构的时候，就能正确评估操作系统进入内核态的开销是多少。</p><p>在讲解执行单元的切换与栈的关系之前，我们先来给出它的准确定义。</p><!-- [[[read_end]]] --><h3>什么是执行单元</h3><p>执行单元是指CPU调度和分派的基本单位，它是一个CPU能正常运行的基本单元。执行单元是可以停下来的，只要能把CPU状态（其实就是寄存器的值）全部保存起来，等到这个执行单元再被调度的时候，就把状态恢复过来就行了。我们把这种保存状态，挂起，恢复执行，恢复状态的完整过程，称为执行单元的调度(Scheduling)。</p><p>具体来说，常见的执行单元有进程，线程和协程三种，接下来，我们详细说明这三种执行单元的区别和联系。我们先来比较进程和线程。</p><h4>理解进程和线程</h4><p>当运行一个可执行程序的时候，操作系统就会启动一个进程。进程会被操作系统管理和调度，被调度到的进程就可以独占CPU了。</p><p>CPU就像是一个可以轮流使用的工作台，多个进程可以在工作台上工作，时间到了就会带着自己的工作离开工作台，换下一个进程上来工作。</p><p>进程有自己独立的内存空间和页表，以及文件表等等各种私有资源，如果使用多进程系统，让多个任务并发执行，那么它所占用的资源就会比较多。线程的出现解决了这个问题。</p><p>同一个进程中的线程则共享该进程的内存空间，文件表，文件描述符等资源，它与同一个进程的其他线程共享资源分配。除了共享的资源，每个线程也有自己的私有空间，这就是线程的栈。线程在执行函数调用的时候，会在自己的线程栈里创建函数栈帧。</p><p>根据上面所说的特点，人们常把进程看做是资源分配的单位，把线程才看成一个具体的执行实体。</p><p>由于线程的切换过程和进程的切换过程十分相似，我们这节课就只以进程的切换为重点进行讲解，请你一定要自己查找相关资料，对照进程切换的过程，去理解线程的切换过程。</p><h4>理解协程</h4><p>协程是比线程更轻量的执行单元。进程和线程的调度是由操作系统负责的，而协程则是由执行单元相互协商进行调度的，所以它的切换发生在用户态。只有前一个协程主动地执行yield函数，让出CPU的使用权，下一个协程才能得到调度。</p><p>因为程序自己负责协程的调度，所以大多数时候，我们可以让不那么忙的协程少参与调度，从而提升整个程序的吞吐量，而不是像进程那样，没有繁重任务的进程，也有可能被换进来执行。</p><p>协程的切换和调度所耗费的资源是最少的，Go语言把协程和IO多路复用结合在一起，提供了非常便捷的IO接口，使得协程的概念深入人心。</p><p>从操作系统和Web Server演进的历史来看，先是多进程系统的出现，然后出现了多线程系统，最后才是协程被大规模使用，这个演进历程背后的逻辑就是执行单元需要越来越轻量，以支持更大的并发总数。</p><p>但我们这节课却要先讲协程，这是因为从实现层面来说，协程是最简单的，当你理解了协程的实现原理，再回头学习进程就比较容易了，所以我们先来学习协程的原理。</p><h3>协程是怎么调度和切换的？</h3><p>在讲解协程的理论之前，我们先通过一个最简单的协程的例子，来观察协程的运作机制：</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define STACK_SIZE 1024\n\ntypedef void(*coro_start)();\n\nclass coroutine {\npublic:\n    long* stack_pointer;\n    char* stack;\n\n    coroutine(coro_start entry) {\n        if (entry == NULL) {\n            stack = NULL;\n            stack_pointer = NULL;\n            return;\n        }\n\n        stack = (char*)malloc(STACK_SIZE);\n        char* base = stack + STACK_SIZE;\n        stack_pointer = (long*) base;\n        stack_pointer -= 1;\n        *stack_pointer = (long) entry;\n        stack_pointer -= 1;\n        *stack_pointer = (long) base;\n    }\n\n    ~coroutine() {\n        if (!stack)\n            return;\n        free(stack);\n        stack = NULL;\n    }\n};\n\ncoroutine* co_a, * co_b;\n\nvoid yield_to(coroutine* old_co, coroutine* co) {\n    __asm__ (\n        &quot;movq %%rsp, %0\\n\\t&quot;\n        &quot;movq %%rax, %%rsp\\n\\t&quot;\n        :&quot;=m&quot;(old_co-&gt;stack_pointer):&quot;a&quot;(co-&gt;stack_pointer):);\n}\n\nvoid start_b() {\n    printf(&quot;B&quot;);\n    yield_to(co_b, co_a);\n    printf(&quot;D&quot;);\n    yield_to(co_b, co_a);\n}\n\nint main() {\n    printf(&quot;A&quot;);\n    co_b = new coroutine(start_b);\n    co_a = new coroutine(NULL);\n    yield_to(co_a, co_b);\n    printf(&quot;C&quot;);\n    yield_to(co_a, co_b);\n    printf(&quot;E\\n&quot;);\n    delete co_a;\n    delete co_b;\n    return 0;\n}\n</code></pre><p>我们使用g++对这段代码进行编译，注意要使用O0进行编译，不能使用更高的优化级别，这是因为更高级别的优化会内联yield_to方法，这就使得栈的布局和程序中期望的不相符了。我们先来看看这段代码的运行的结果，如下所示：</p><pre><code># g++ -g -o co -O0 coroutine.cpp\n# ./co\nABCDE\n</code></pre><p>这段代码的神奇之处在于，main函数在执行到一半的时候，可以停下来去执行start_b函数，这和我们通常遇到的函数调用是很不一样的。而这种效果是通过协程达到的。</p><p>你可以看到，在main函数的执行过程中（即代码的57行），CPU通过执行yield_to方法转到另外一个协程。新的协程的入口函数是start_b，所以，CPU就转而去执行start_b，在start_b执行到48行的时候，还能再通过yield_to，再回到main函数中继续执行。</p><p>下面我们来看协程是怎么实现这一点的。</p><p>我们调用构造函数coroutine创建了两个协程co_a和co_b（即代码的55、56行）。其中，co_b的入口地址是函数start_b，co_a没有入口地址。</p><p>我们具体来看在coroutine里发生了什么。其实在创建这两个协程之前，coroutine已经申请了一段大小为1K的内存作为协程栈，然后让栈底指针base指向栈的底部（第21行）。因为栈是由上向下增长的，所以，我们又在协程栈上放入了base地址和起始地址（第23~27行），此时，协程栈内的数据是这样的，如图1所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/55/b12a4941be1f61d5132500c3d1b8ec55.jpg?wh=2284x1151\" alt=\"\"></p><p>在准备好协程栈以后，就可以调用yield_to方法进行协程的切换。在上一节中，我们提到过协程要主动调用yield方法将CPU的占有权让出来，后面的协程才能执行。所以，协程切换的关键机制就肯定隐藏在yield_to方法里。</p><p>yield_to方法具体做了什么事情呢？我们需要通过机器码来进行说明。这里我们使用\"objdump -d\"命令查看yield_to方法经过编译以后的机器码：</p><pre><code>000000000040076d &lt;_Z8yield_toP9coroutineS0_&gt;:\n  40076d:       55                      push   %rbp\n  40076e:       48 89 e5                mov    %rsp,%rbp\n  400771:       48 89 7d f8             mov    %rdi,-0x8(%rbp)\n  400775:       48 89 75 f0             mov    %rsi,-0x10(%rbp)\n  400779:       48 8b 45 f0             mov    -0x10(%rbp),%rax\n  40077d:       48 8b 00                mov    (%rax),%rax\n  400780:       48 8b 55 f8             mov    -0x8(%rbp),%rdx\n  400784:       48 89 22                mov    %rsp,(%rdx)\n  400787:       48 89 c4                mov    %rax,%rsp\n  40078a:       5d                      pop    %rbp\n  40078b:       c3                      retq\n</code></pre><p>yield_to中，参数old_co指向老协程，co则指向新的协程，也就是我们要切换过去执行的目标协程。</p><p>这段代码的作用是，首先，把当前rsp寄存器的值存储到old_co的stack_pointer属性（第9行），并且把新的协程的stack_pointer属性更新到rsp寄存器（第10行），然后，retq指令将会从栈上取出调用者的地址，并跳转回调用者继续执行（第12行，这是上一节课的内容，如果你不熟悉，可以再自行复习一下）。</p><p>结合以上分析，我们可以想象在协程示例代码的第57行，当调用这一次yield_to时，rsp寄存器刚好就会指向新的协程co的栈，接着就会执行\"pop rbp\"和\"retq\"这两条指令。这里你需要注意一下，栈的切换，并没有改变指令的执行顺序，因为栈指针存储在rsp寄存器中，当前执行到的指令存储在IP寄存器中，rsp的切换并不会导致IP寄存器发生变化。</p><p>而显然，如图1所示，我们刚才精心准备的base地址正好就是为了\"pop rbp\"准备的，而start_b则是为了retq准备的。执行这次retq，CPU就会跳转到start_b函数中去运行了。</p><p>经过这种切换，系统中会出现两个栈，如图2所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/63/31/63ffc7601254bb2460d65c43f57a7931.jpg?wh=2284x1249\" alt=\"\"></p><p>当程序继续执行时，在start_b中调用了yield_to，CPU又会转移回协程a的栈上，这样在执行retq时，就会返回到main函数里继续运行了。</p><p>在这个过程中，我们并没有使用任何操作系统的系统调用，就实现了控制流的转移。也就是说，在同一个线程中，我们真正实现了两个执行单元。这两个执行单元并不像线程那样是抢占式地运行，而是相互主动协作式执行，所以，这样的执行单元就是协程。我们可以看到，协程的切换全靠本执行单元主动调用yield_to来把执行权让渡给其他协程。</p><p>每个协程都拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方（上述例子中，保存在coroutine对象中），在切回来的时候，恢复先前保存的寄存器上下文和栈。</p><p>分析到这里，这个程序对我们而言，已经没有太多秘密了，它所有看上去神奇的地方，不过就是切换了程序运行的栈指针而已。</p><p>分析到这里，我们就可以准确地定义协程了。协程是一种轻量级的，用户态的执行单元。相比线程，它占用的内存非常少，在很多实现中（比如Go语言）甚至可以做到按需分配栈空间。</p><p>它主要有三个特点：</p><ol>\n<li>占用的资源更少;</li>\n<li>所有的切换和调度都发生在用户态。</li>\n<li>它的调度是协商式的，而不是抢占式的。</li>\n</ol><p>前两个特点容易理解，我来给你重点解释一下第三个特点。</p><p>目前主流语言基本上都选择了多线程作为并发设施，与线程相关的概念是抢占式多任务（Preemptive multitasking），而与协程相关的是协作式多任务。不管是进程还是线程，每次阻塞、切换都需要陷入系统调用(system call)，先让CPU执行操作系统的调度程序，然后再由调度程序决定该哪一个进程(线程)继续执行。</p><p>由于抢占式调度执行顺序无法确定，我们使用线程时需要非常小心地处理同步问题，而协程完全不存在这个问题。因为协作式的任务调度，是要用户自己来负责任务的让出的。如果一个任务不主动让出，其他任务就不会得到调度。这是协程的一个弱点，但是如果使用得当，这其实是一个可以变得很强大的优点。</p><p>你可以尝试将编译优化等级设为O1，观察yield_to函数的机器码的变化，然后就可以理解当栈基址寄存器的保存和恢复如果被优化掉以后，我们准备的那个数据就不再起作用了。也请你尝试对上述代码进行修改，以适应O1优化。</p><p>在理解了协程以后，我们再回过头来看进程。</p><h3>进程是怎么调度和切换的？</h3><p>进程切换的原理其实与协程切换的原理大致相同，都是将上下文保存在特定的位置，切换到新的进程去执行。所不同的是，操作系统为我们提供了进程的创建、销毁、信号通信等基础设施，这使得程序员可以很方便地创建进程。如果一个进程a创建了另外一个进程b，则称a为父进程，b为子进程。</p><p>我先带你通过下面这个例子，直观地感受多进程运行的情况：</p><pre><code>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    pid_t pid;\n    if (!(pid = fork())) {\n        printf(&quot;I am child process\\n&quot;);\n        exit(0);\n    }\n    else {\n        printf(&quot;I am father process\\n&quot;);\n        wait(pid);\n    }\n\n    return 0;\n}\n</code></pre><p>编译执行这段代码的结果如下所示：</p><pre><code># gcc -o p process.c\n# ./p\nI am father process\nI am child process\n</code></pre><p>在这个结果里，我们可以看到，在if分支和else分支中的代码都被运行了。曾经有个笑话说，这个世界上最远的距离，不是你在天涯，我在海角，而是你在if里，我在else里。由此可见，这个笑话也并不正确，还是要看if条件里填的是什么。</p><p>在上面的代码中，fork是一个系统调用，用于创建进程，如果其返回值为0，则代表当前进程是子进程，如果其返回值不为0，则代表当前进程是父进程，而这个返回值就是子进程的进程ID。</p><p>我们看到，子进程在打印完一行语句后就调用exit退出执行了。父进程在打印完以后，并没有立即退出，而是调用wait函数等待子进程退出。由于进程的调度执行是操作系统负责的，具有很大的随机性，所以父进程和子进程谁先退出，我们并不能确定。为了避免子进程变成孤儿进程，我们采用了让父进程等待子进程退出的办法，就是对两个进程进行同步。</p><p>其实，这段程序最难理解的是第6行，为什么一次fork后，会有两种不同的返回值？这是因为fork方法本质上在系统里创建了两个栈，这两个栈一个是父进程的，一个是子进程的。创建的时候，子进程完全“继承”了父进程的所有数据，包括栈上的数据。父子进程栈的情况如图3所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/05/bb/05f522cfcaa8ef2d79fa7221cc1bb8bb.jpg?wh=2284x1445\" alt=\"\"></p><p>在图3里，只要有一个进程对栈进行修改，栈就会复制一份，然后父子进程各自持有一份。图中的黄色部分也是进程共用的，如果有一个进程修改它，也会复制一份副本，这种机制叫做写时复制。</p><p>接着，操作系统就会接管两个进程的调度。当父进程得到调度时，父进程的栈上是fork函数的frame，当CPU执行fork的ret语句时，返回值就是子进程的ID。</p><p>而当子进程得到调度时，rsp这个栈指针就将会指向子进程的栈，子进程的栈上也同样是fork函数的frame，它也会执行一次fork的ret语句，其返回值是0。</p><p>所以第6行虽然是同一个变量pid，但实际上，它在子进程的main函数的栈帧里有一个副本，在父进程的栈帧里也有一个副本。从fork开始，父进程和子进程就已经分道扬镳了。你可以将进程栈的切换与协程栈的切换对比着进行学习。</p><p>我们通过一个例子展示了进程是如何创建的，并且分析了进程创建背后栈的变化过程。你可以看到，进程做为一种执行单元，它的切换还是要依赖于栈切换这个核心机制。</p><p>关于fork的更多的细节，我们将在第10课再加以分析。在这节课，将进程的栈类比于协程栈已经足够了。</p><h3>用户态和内核态是怎么切换的？</h3><p>在第二节课里，我们讲解了中断描述符表，并且用系统调用write这个例子，来展示如何通过软中断进入内核态。实际上，内核态和用户态的切换也依赖栈的切换。因为在第二节课里，我们还没有讲到栈，所以在讲到用户态切换内核态的时候，并没有涉及到栈的切换，现在，我们补上用户态和内核态切换的最后一块拼图。</p><p>操作系统内核在运行的时候，肯定也是需要栈的，这个栈称为内核栈，它与用户应用程序使用的用户态栈是不同的。只有高权限的内核代码才能访问它。而内核态与用户态的相互切换，其中最重要的一个步骤就是两个栈的切换。</p><p>中断发生时，CPU根据需要跳转的特权级，去一个特定的结构中（不同的CPU会有所不同，比如i386就存在TSS中，但不管是什么CPU，一定会有一个类似的结构），取得目标特权级所对应的stack段选择子和栈顶指针，并分别送入ss寄存器和rsp寄存器，这就完成了一次栈的切换。</p><p>然后，IP寄存器跳入中断服务程序开始执行，中断服务程序会把当前CPU中的所有寄存器，也就是程序的上下文都保存到栈上，这就意味着用户态的CPU状态其实是由中断服务程序在系统栈上进行维护的。如图4所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/65/e015b6a3b4d93431194614e065078e65.jpg?wh=2284x2101\" alt=\"\"></p><p>一般来说，当程序因为call指令或者int指令进行跳转的时候，只需要把下一条指令的地址放到栈上，供被调用者执行ret指令使用，这样可以便于返回到调用函数中继续执行。但图4中的内核态栈里有一点特殊之处，就是CPU自动地将用户态栈的段选择子ss3，和栈顶指针rsp3都放到内核态栈里了。这里的数字3代表了CPU特权级，内核态是0，用户态是3。</p><p>当中断结束时，中断服务程序会从内核栈里将CPU寄存器的值全部恢复，最后再执行\"iret\"指令（注意不是ret，而是iret，这表示是从中断服务程序中返回）。而iret指令就会将ss3/rsp3都弹出栈，并且将这个值分别送到ss和rsp寄存器中。这样就完成了从内核栈到用户栈的一次切换。同时，内核栈的ss0和rsp0也会被保存到前文所说的一个特定的结构中，以供下次切换时使用。</p><h3>总结</h3><p>这节课我们举例说明了进程，线程和协程的基本概念，并对它们的调度做了简单的说明。然后介绍了服务端编程模型从多进程向协程演进的历程。</p><p>接着，我们重点介绍了栈切换的整个过程。<strong>栈切换的核心就是栈指针rsp寄存器的切换，只要我们想办法把rsp切换了就相当于换了执行单元的上下文环境</strong>。这一节课所有的讲解都可以归到这条线索上。</p><p>我们又用了协程切换，进程栈的写时复制和切换，以及用户态和内核态的切换这三个例子来说明举例说明栈的切换所发挥的重要作用。</p><p>通过两节课的学习，我们对进程中的栈空间相关的知识进行一次比较深入的梳理。从中我们可以得到一个结论：栈往往和执行单元是一对一的关系，栈的活跃就代表着它所对应的执行单元的活跃。栈上的数据非常敏感，一旦被攻击，往往会造成巨大的破坏。</p><p>在第三节课里，我们学习了堆空间的管理方式，这两节课又学习了栈空间的运行机制，这两部分内容都是程序运行时所要操作的内存。在这之后，我们将目光转移到程序的汇编代码，研究一下程序的静态数据是如何组织和划分的。</p><h3>思考题</h3><p>我们这节课讲到了协程和进程的栈切换，但没有讲线程的栈切换。请你思考，线程的栈切换是更类似协程那种提前创建好的方式，还是更类似于进程那种按需写时复制？为什么？欢迎你在留言区和我交流你的想法，我在留言区等你。</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/e9/c481a2a217c906ed118770a91f17c4e9.jpg?wh=2284x1355\" alt=\"\"></p><p>欢迎你在留言区分享你的想法和收获，我在留言区等你。如果这节课帮到了你，也欢迎你把这节课分享给自己的朋友。我们下一讲再见！</p>","comments":[{"had_liked":false,"id":319781,"user_name":"鵼","can_delete":false,"product_type":"c1","uid":1101766,"ip_address":"","ucode":"F6561743835F7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg","comment_is_top":false,"comment_ctime":1635937766,"is_pvip":false,"replies":[{"id":"116149","content":"Good","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636279305,"ip_address":"","comment_id":319781,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27405741542","product_id":100094901,"comment_content":"补充一下：关于coroutine,在优化O1下，因为没有基地址的入栈出栈操作，所以 代码只用删除coroutine下的基地值入栈操作：stack_pointer -= 1; *stack_pointer = (long) base; 就可以了","like_count":6,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529768,"discussion_content":"Good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636279305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2304123,"avatar":"","nickname":"Geek_ed84ef","note":"","ucode":"D64973A23FCAA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587427,"discussion_content":"为什么在优化O1下没有基地址的入栈出战操作了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663050930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319733,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1635924876,"is_pvip":false,"replies":[{"id":"115895","content":"回答正确！写时复制只能发生在进程之间。同一个进程的线程因为共享资源，只能提前分配。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635932413,"ip_address":"","comment_id":319733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23110761356","product_id":100094901,"comment_content":"思考题：线程的用户栈是pthread函数提前创建的吗？","like_count":5,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529747,"discussion_content":"回答正确！写时复制只能发生在进程之间。同一个进程的线程因为共享资源，只能提前分配。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635932413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319669,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1635906024,"is_pvip":false,"replies":[{"id":"115863","content":"赞！很准确了。我们在第10节课会讲页中断，那时候就会更加深一层理解。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635923811,"ip_address":"","comment_id":319669,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18815775208","product_id":100094901,"comment_content":"fork 系统调用，只会新建一个子进程调用栈，并向其拷贝父进程调用栈数据，所以父子进程保存了同样的寄存器数据，因此造成了 fork 调用一次，而返回两次的现象。<br><br>由于 fork 本质会将父进程拷贝一份，作为子进程，这样就会有大量的拷贝工作，fork 会很慢，同时子进程可能不需要这么多的资源，会造成资源浪费，因此主流操作系统，比如 linux 都实现 COW 机制，即写时复制，fork 时对栈以外的资源都先映射到地址空间中，文件、socket 等句柄资源引用计数+1，待子进程访问这些地址时会触发缺页中断，此时内核再来为其分配真正的物理页，这样就节省了时间和空间。","like_count":5,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529716,"discussion_content":"赞！很准确了。我们在第10节课会讲页中断，那时候就会更加深一层理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635923811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321350,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1636807362,"is_pvip":false,"replies":[{"id":"116725","content":"你后面的理解在linux上大致是对的。虽然确实每个进程有自己的内核态栈，但你要牢记，在内核态运行时，内核代码段有能力访问任何一个进程的核心结构。这是用户态和内核态最大的不同。还有，你前边的理解也没错，微内核的操作系统就是这么设计的。windows和minix都是由内核进程提供服务。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636902348,"ip_address":"","comment_id":321350,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14521709250","product_id":100094901,"comment_content":"进程有两种栈，用户态栈和内核态栈。之前以为一直有一个内核进程在运行，发起系统调用相当于用户进程和内核进程在通信。是不是可以这样理解，进程执行的代码是包含内核代码和用户代码，当执行内核代码时需要进入内核态，当执行用户代码时在用户态。所以各进程的虚拟内存中就包含两部分，内核空间和用户空间，分别存放内核代码和用户代码。感觉理解的很零碎，老师帮看看哪块理解的不对。","like_count":3,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530275,"discussion_content":"你后面的理解在linux上大致是对的。虽然确实每个进程有自己的内核态栈，但你要牢记，在内核态运行时，内核代码段有能力访问任何一个进程的核心结构。这是用户态和内核态最大的不同。还有，你前边的理解也没错，微内核的操作系统就是这么设计的。windows和minix都是由内核进程提供服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322893,"user_name":"陈狄","can_delete":false,"product_type":"c1","uid":2011954,"ip_address":"","ucode":"456F00EB2EB43D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg","comment_is_top":false,"comment_ctime":1637648739,"is_pvip":false,"replies":[{"id":"117248","content":"编译器的优化没做好，开O1优化就不会了","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637716610,"ip_address":"","comment_id":322893,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10227583331","product_id":100094901,"comment_content":"mov    %rdi,-0x8(%rbp)<br>mov    %rsi,-0x10(%rbp)<br>mov    -0x10(%rbp),%rax<br>mov    (%rax),%rax<br>mov    -0x8(%rbp),%rdx<br>mov    %rsp,(%rdx)<br>请问老师，这段汇编，明明rdi和rsi可以直接拿来用，为什么要先存到栈里面，然后再从栈里面取出来访问，要绕一道？","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532827,"discussion_content":"编译器的优化没做好，开O1优化就不会了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637716610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321420,"user_name":"Geek_27eb54","can_delete":false,"product_type":"c1","uid":2715118,"ip_address":"","ucode":"7D1EE10A61C7C0","user_header":"","comment_is_top":false,"comment_ctime":1636863540,"is_pvip":false,"replies":[{"id":"117073","content":"不是规则不一致哦。规则是永远都一样的，都是MMU根据页表进行三级映射，从虚拟地址映射为物理地址。不一样的是页表里面的内容。两个进程可以把自己的虚拟地址映射到相同的物理地址。这就是共享内存。一个进程里的多个线程共享同一个页表，所以线程的私有内存是肯定不会有相同的地址的。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637375414,"ip_address":"","comment_id":321420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10226798132","product_id":100094901,"comment_content":"海纳，老师，根据之前学的物理地址和虚拟地址，共享内存实际上可不可以理解成虚拟地址到物理地址的转换规则是一致的，私有地址中转换规则不一致？那么在一个进程中的多个线程中的私有内存，会不会有相同的地址呢？或者说我这样理解有问题呢？希望老师可以解答一下","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531653,"discussion_content":"不是规则不一致哦。规则是永远都一样的，都是MMU根据页表进行三级映射，从虚拟地址映射为物理地址。不一样的是页表里面的内容。两个进程可以把自己的虚拟地址映射到相同的物理地址。这就是共享内存。一个进程里的多个线程共享同一个页表，所以线程的私有内存是肯定不会有相同的地址的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637375414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331069,"user_name":"石天兰爱学习","can_delete":false,"product_type":"c1","uid":1451826,"ip_address":"","ucode":"0D95CDA7463516","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4C2AgnHBt1qmRSiaqPQfEPicCdEJp6IgLC1wsVJPa1zQoRztNaZcqiaRXIblkRc1sgn7dUdPmrE011uFbibEQtia3bg/132","comment_is_top":false,"comment_ctime":1642407524,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5937374820","product_id":100094901,"comment_content":"老师的文章又干又硬，啃的我牙疼&#47;(ㄒoㄒ)&#47;~~","like_count":1},{"had_liked":false,"id":320501,"user_name":"流浪地球","can_delete":false,"product_type":"c1","uid":1498137,"ip_address":"","ucode":"25210DCD353F97","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg","comment_is_top":false,"comment_ctime":1636355531,"is_pvip":false,"replies":[{"id":"116227","content":"是的，我们是把堆上的一块内存区域当成了栈来用。这个例子也说明了，内存区域划分是我们根据人的理解去做的划分，而不是说就此固定了的。你可以了解一下js或者python中的generator，他们是stackless的，我们这节课的协程是stackful的。对比一下自己就清楚了。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636384630,"ip_address":"","comment_id":320501,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5931322827","product_id":100094901,"comment_content":"用户态的协程栈是分配在堆空间的吗？看代码是使用了malloc函数。协程的stackful和非stackful是什么却区别呢？","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530016,"discussion_content":"是的，我们是把堆上的一块内存区域当成了栈来用。这个例子也说明了，内存区域划分是我们根据人的理解去做的划分，而不是说就此固定了的。你可以了解一下js或者python中的generator，他们是stackless的，我们这节课的协程是stackful的。对比一下自己就清楚了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636384630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319770,"user_name":"鵼","can_delete":false,"product_type":"c1","uid":1101766,"ip_address":"","ucode":"F6561743835F7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg","comment_is_top":false,"comment_ctime":1635935705,"is_pvip":false,"replies":[{"id":"115920","content":"哈哈哈，说得很有趣也很正确","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635939470,"ip_address":"","comment_id":319770,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5930903001","product_id":100094901,"comment_content":"对于学java的我看懂这段c++代码真不容易啊，好歹看懂了 。最难懂的应该是 协程a了，一开始一直觉得参数NULL，那个stack_pointer就是个null，后来查查资料，指针变量在声明的时候已经分配内存地址了，所以a的stack_pointer就是内存中的一块地址，只是它指向 的是NULL，本身还是一个内存地址。它的作用其实就是为了保存mian函数的rsp，所以才不用赋值（或者说给指定的地址）。<br>关于思考题：我觉得应该类似于进程那种按需写时复制。原因我认为的比较浅显，也比较尴尬，因为fork和pthread_create都是调用的clone（😅😅），其次线程的资源都是 共享的父亲 ，页表、虚拟地址 、文件描述符啥的应该都是同一个。不对 ，pthread_create的时候是有 参数的，fork没有。那应该是类似协程那种提前创建好的方式，用于保存参数数据。","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529764,"discussion_content":"哈哈哈，说得很有趣也很正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635939470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319735,"user_name":"张贺","can_delete":false,"product_type":"c1","uid":1283181,"ip_address":"","ucode":"0254E40FB3EB5F","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/6d/5cd6e8c7.jpg","comment_is_top":false,"comment_ctime":1635924962,"is_pvip":true,"replies":[{"id":"116151","content":"没有。当前线程的用户态的状态还会保存在内核态栈上。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636279455,"ip_address":"","comment_id":319735,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5930892258","product_id":100094901,"comment_content":"用户态内核态切换的时候，线程切换了吗？","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529749,"discussion_content":"没有。当前线程的用户态的状态还会保存在内核态栈上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636279455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352413,"user_name":"Geek_a5edac","can_delete":false,"product_type":"c1","uid":1954784,"ip_address":"","ucode":"A47341B4DB9C8E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132","comment_is_top":false,"comment_ctime":1658651113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658651113","product_id":100094901,"comment_content":"作为后端开发，日常工作更多偏向设计模式、领域模型、上层架构的设计。但也一直对底层原理感兴趣，我认为在“设计”上很多思想是想通的，互相借鉴并融会贯通方可游刃有余，本章节深入了底层细节我总算是啃透了，现在如果让我讲一下进程、线程、协程的调度过程，脑子里已经能自行构建出对应的核心流程来了，感谢老师。","like_count":1},{"had_liked":false,"id":348973,"user_name":"程序员班吉","can_delete":false,"product_type":"c1","uid":1478098,"ip_address":"","ucode":"BD48CF7649609A","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/d2/8a6be8d8.jpg","comment_is_top":false,"comment_ctime":1655614555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655614555","product_id":100094901,"comment_content":"golang的内存管理很大程度上依赖堆，但是为了利用CPU的多核特性要将协程调度到不同的核上，这里我一直有几个疑问。<br>1.golang是单进程的吗？因为不同的协程可以访问同一块堆上的内存。<br>2.如果是单进程的，那么如何能让golang发挥cpu多核的优势呢？难道同一个进程里的不同线程M可以被调度到不同的CPU核心上吗？<br>","like_count":0},{"had_liked":false,"id":326145,"user_name":"Jerry_Yuan","can_delete":false,"product_type":"c1","uid":1387096,"ip_address":"","ucode":"525A52D7369DBC","user_header":"https://static001.geekbang.org/account/avatar/00/15/2a/58/fabdfe69.jpg","comment_is_top":false,"comment_ctime":1639393421,"is_pvip":false,"replies":[{"id":"118505","content":"正确。只有一点小瑕疵，就是最后那一点，一般来说使用的是pop指令，而不是mov指令，因为要从栈上弹出数据。当然，使用mov，最后再一次性调整栈指针也是可以的（而且在某些CPU上，可能效率更高）。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1639488432,"ip_address":"","comment_id":326145,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1639393421","product_id":100094901,"comment_content":"请问老师一下，在最后讲用户态内核态切换的时候，内核为了切换进程，保存用户进程的寄存器现场以及pc寄存器值，然后执行调度相关的系统调用。是不是可以理解成 每一个用户进程都有一个kernel stack（内核地址空间栈的一部分），存放用户进程的寄存器上下文以及返回地址。等到系统调用结束之后，再将之前保存到内核栈上的用户进程的状态通过mov指令重新放到寄存器上？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538696,"discussion_content":"正确。只有一点小瑕疵，就是最后那一点，一般来说使用的是pop指令，而不是mov指令，因为要从栈上弹出数据。当然，使用mov，最后再一次性调整栈指针也是可以的（而且在某些CPU上，可能效率更高）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639488433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1387096,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2a/58/fabdfe69.jpg","nickname":"Jerry_Yuan","note":"","ucode":"525A52D7369DBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":538740,"discussion_content":"谢谢老师！感觉听了老师讲解之后，补充一点x86汇编知识，自己写一个协程coroutine的.so文件也绝非不可能。只要抽象一个协程结构体存放CPU的通用寄存器和pc，再模拟协程的上下文切换，维护每一个协程的栈帧，用汇编恢复被调度的协程的%rsp, %rbp,以及pc寄存器的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639495437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":538696,"ip_address":""},"score":538740,"extra":""}]}]},{"had_liked":false,"id":324934,"user_name":"Geek_d797a2","can_delete":false,"product_type":"c1","uid":2821112,"ip_address":"","ucode":"80027DA49D41BA","user_header":"","comment_is_top":false,"comment_ctime":1638725297,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1638725297","product_id":100094901,"comment_content":"老师好，想问下 yield to 方法的汇编码中，为什么最后恢复栈的语句中好象缺少了 mov %rbp, %rsp，函数调用的最后三行汇编不是都有这句吗？","like_count":0,"discussions":[{"author":{"id":1338751,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/7f/e1c189c7.jpg","nickname":"陈诚","note":"","ucode":"138DD00D245FEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556403,"discussion_content":"因为在yield_to函数中，没有修改rsp的值，所以不需要mov %rbp, %rsp的操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647342755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537506,"discussion_content":"&#34;pop %rbp&#34;等价于&#34;mov (%rsp), %rbp \\n\\t add $0x8, %rsp \\n\\t&#34;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639080381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323722,"user_name":"Geek_a5edac","can_delete":false,"product_type":"c1","uid":1954784,"ip_address":"","ucode":"A47341B4DB9C8E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132","comment_is_top":false,"comment_ctime":1638119803,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1638119803","product_id":100094901,"comment_content":"老师，文中 co_a = new coroutine(NULL); 这段代码没看懂，我看入参是Null，按构造函数的写法：<br>if (entry == NULL) { stack = NULL; stack_pointer = NULL; return; } 所以我看co_a并没有初始化栈空间啊，那后面co_a的栈怎么能存储rsp相关的上下文信息的","like_count":0,"discussions":[{"author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537507,"discussion_content":"yield_to函数里那段汇编，就相当于co_a-&gt;stack_pointer = (当前%rsp的值); %rsp = co_b-&gt;stack_pointer","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639080805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338751,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/7f/e1c189c7.jpg","nickname":"陈诚","note":"","ucode":"138DD00D245FEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556404,"discussion_content":"因为最终是用当前的主线程作为co_a协程来工作的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647342794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321399,"user_name":"余生","can_delete":false,"product_type":"c1","uid":2421369,"ip_address":"","ucode":"AEF6C96738F03B","user_header":"https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg","comment_is_top":false,"comment_ctime":1636847899,"is_pvip":true,"replies":[{"id":"117074","content":"TSS是CPU规定的。pt_regs是软件定义的。但其实结构都差不多，就是保存CPU的寄存器的值而已。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637375467,"ip_address":"","comment_id":321399,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636847899","product_id":100094901,"comment_content":"老师，这里提到的TSS，跟linux里面的pt_reg那个结构体是同一个东西吗？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531654,"discussion_content":"TSS是CPU规定的。pt_regs是软件定义的。但其实结构都差不多，就是保存CPU的寄存器的值而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637375467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321351,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1636807542,"is_pvip":false,"replies":[{"id":"116723","content":"这个专栏不会哦。我倒是曾经在直播中讲过一次io，你可以去b站的极客时间账号里查看","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636902032,"ip_address":"","comment_id":321351,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636807542","product_id":100094901,"comment_content":"之前听说goroutine既实现了协程，也对用户态的IO进行了完整的实现，其他语言的协程实现都是缺失的，说明了golang的强大。老师后面会讲这块IO这块吗？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530276,"discussion_content":"这个专栏不会哦。我倒是曾经在直播中讲过一次io，你可以去b站的极客时间账号里查看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320272,"user_name":"Geek_fd760d","can_delete":false,"product_type":"c1","uid":1453388,"ip_address":"","ucode":"03382EF49D900F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eorbckvhLliahdDbuorLB5E1NhQddskOybChBic2Kf9FmF3Vr0aQnrmCT2JwVADWY3iapkRbXDmKI6gQ/132","comment_is_top":false,"comment_ctime":1636191973,"is_pvip":false,"replies":[{"id":"116144","content":"不能，在执行startb的ret指令的时候，就会发现rbp和rip寄存器的值都不正确了。大概率会出现SIGSEGV或者SIGBUS错误。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636278981,"ip_address":"","comment_id":320272,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636191973","product_id":100094901,"comment_content":"对于协程的案例中，如果start_b函数中并没有切换回协程a的代码，那么这个函数执行完后还能进入主函数吗？具体会发生什么？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529936,"discussion_content":"不能，在执行startb的ret指令的时候，就会发现rbp和rip寄存器的值都不正确了。大概率会出现SIGSEGV或者SIGBUS错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636278981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319737,"user_name":"张贺","can_delete":false,"product_type":"c1","uid":1283181,"ip_address":"","ucode":"0254E40FB3EB5F","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/6d/5cd6e8c7.jpg","comment_is_top":false,"comment_ctime":1635925298,"is_pvip":true,"replies":[{"id":"116150","content":"Linux系统是这样的。这是因为Linux系统没有很好地支持线程，而是直接利用了进程的结构。当然，Linux的多线程支持也在不断地完善中，未来会是怎么样，我们拭目以待。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636279417,"ip_address":"","comment_id":319737,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635925298","product_id":100094901,"comment_content":"每个线程都可以分配一个内核栈吗？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529751,"discussion_content":"Linux系统是这样的。这是因为Linux系统没有很好地支持线程，而是直接利用了进程的结构。当然，Linux的多线程支持也在不断地完善中，未来会是怎么样，我们拭目以待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636279417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319714,"user_name":"独孤","can_delete":false,"product_type":"c1","uid":1294873,"ip_address":"","ucode":"301D08665822E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/19/16863a09.jpg","comment_is_top":false,"comment_ctime":1635920676,"is_pvip":true,"replies":[{"id":"115861","content":"因为我们用了&quot;a&quot;(co-&gt;stack_pointer)来约束它只能送到rax寄存器里。&quot;a&quot;代表了rax寄存器。关于内嵌汇编，我们在导学的第三节课里有讲，可供参考。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635923654,"ip_address":"","comment_id":319714,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635920676","product_id":100094901,"comment_content":"下面这段代码中co-&gt;stack_pointer的值为什么会存到寄存器%rax中？这是约定的吗？<br>void yield_to(coroutine* old_co, coroutine* co) <br>{    __asm__ (        &quot;movq %%rsp, %0\\n\\t&quot;        <br>                           &quot;movq %%rax, %%rsp\\n\\t&quot;       <br>                            :&quot;=m&quot;(old_co-&gt;stack_pointer):&quot;a&quot;(co-&gt;stack_pointer):);<br>}","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529735,"discussion_content":"因为我们用了&amp;quot;a&amp;quot;(co-&amp;gt;stack_pointer)来约束它只能送到rax寄存器里。&amp;quot;a&amp;quot;代表了rax寄存器。关于内嵌汇编，我们在导学的第三节课里有讲，可供参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635923654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319631,"user_name":"费城的二鹏","can_delete":false,"product_type":"c1","uid":1101293,"ip_address":"","ucode":"DE768A0CC3053D","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ed/825d84ee.jpg","comment_is_top":false,"comment_ctime":1635896664,"is_pvip":false,"replies":[{"id":"115864","content":"写时复制是按页进行复制的。在创建子进程的时候呢，子进程只是把页表复制一份，所以子进程和父进程的虚拟地址一开始是指向相同的物理地址的。只有当有一个进程在写的时候才会复制一页出来。你要结合第一课想一下，虚拟空间是连续的，但物理空间不必是连续的，所以我在背后悄悄地把映射到的物理地址替换掉，你其实是不知道的。再想一下？","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635924327,"ip_address":"","comment_id":319631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635896664","product_id":100094901,"comment_content":"“其实，这段程序最难理解的是第 6 行，为什么一次 fork 后，会有两种不同的返回值？这是因为 fork 方法本质上在系统里创建了两个栈，这两个栈一个是父进程的，一个是子进程的。”<br><br>fork 后，父进程与子进程会有单独的栈与公用栈，我想了解下这个地方的数据结构是怎样的？栈空间一般是连续的，如果有公用部分的栈，那部分栈在内存中如何存储？如何能同时在父子进程延伸出独立的栈？如何实现写时复制？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529696,"discussion_content":"写时复制是按页进行复制的。在创建子进程的时候呢，子进程只是把页表复制一份，所以子进程和父进程的虚拟地址一开始是指向相同的物理地址的。只有当有一个进程在写的时候才会复制一页出来。你要结合第一课想一下，虚拟空间是连续的，但物理空间不必是连续的，所以我在背后悄悄地把映射到的物理地址替换掉，你其实是不知道的。再想一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635924327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}