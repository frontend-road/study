{"id":150881,"title":"13 | 缓存的使用姿势（一）：如何选择缓存的读写策略？","content":"<p>上节课，我带你了解了缓存的定义、分类以及不足，你现在应该对缓存有了初步的认知。从今天开始，我将带你了解一下使用缓存的正确姿势，比如缓存的读写策略是什么样的，如何做到缓存的高可用以及如何应对缓存穿透。通过了解这些内容，你会对缓存的使用有深刻的认识，这样在实际工作中就可以在缓存使用上游刃有余了。</p><p>今天，我们先讲讲缓存的读写策略。你可能觉得缓存的读写很简单，只需要优先读缓存，缓存不命中就从数据库查询，查询到了就回种缓存。实际上，针对不同的业务场景，缓存的读写策略也是不同的。</p><p>而我们在选择策略时也需要考虑诸多的因素，比如说，缓存中是否有可能被写入脏数据，策略的读写性能如何，是否存在缓存命中率下降的情况等等。接下来，我就以标准的“缓存+数据库”的场景为例，带你剖析经典的缓存读写策略以及它们适用的场景。这样一来，你就可以在日常的工作中根据不同的场景选择不同的读写策略。</p><h2>Cache Aside（旁路缓存）策略</h2><p>我们来考虑一种最简单的业务场景，比方说在你的电商系统中有一个用户表，表中只有ID和年龄两个字段，缓存中我们以ID为Key存储用户的年龄信息。那么当我们要把ID为1的用户的年龄从19变更为20，要如何做呢？</p><!-- [[[read_end]]] --><p><strong>你可能会产生这样的思路：</strong>先更新数据库中ID为1的记录，再更新缓存中Key为1的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/65/d3389ef91de21e90dec2a9854e26e965.jpg?wh=1142*451\" alt=\"\"></p><p><strong>这个思路会造成缓存和数据库中的数据不一致。</strong>比如，A请求将数据库中ID为1的用户年龄从19变更为20，与此同时，请求B也开始更新ID为1的用户数据，它把数据库中记录的年龄变更为21，然后变更缓存中的用户年龄为21。紧接着，A请求开始更新缓存数据，它会把缓存中的年龄变更为20。此时，数据库中用户年龄是21，而缓存中的用户年龄却是20。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/35/7fbf80fb7949939dd5543a8da8181635.jpg?wh=1142*615\" alt=\"\"></p><p><strong>为什么产生这个问题呢？</strong>因为变更数据库和变更缓存是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据的不一致。</p><p>另外，直接更新缓存还存在另外一个问题就是丢失更新。还是以我们的电商系统为例，假如电商系统中的账户表有三个字段：ID、户名和金额，这个时候缓存中存储的就不只是金额信息，而是完整的账户信息了。当更新缓存中账户金额时，你需要从缓存中查询完整的账户数据，把金额变更后再写入到缓存中。</p><p>这个过程中也会有并发的问题，比如说原有金额是20，A请求从缓存中读到数据，并且把金额加1，变更成21，在未写入缓存之前又有请求B也读到缓存的数据后把金额也加1，也变更成21，两个请求同时把金额写回缓存，这时缓存里面的金额是21，但是我们实际上预期是金额数加2，这也是一个比较大的问题。</p><p><strong>那我们要如何解决这个问题呢？</strong>其实，我们可以在更新数据时不更新缓存，而是删除缓存中的数据，在读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。</p><p><img src=\"https://static001.geekbang.org/resource/image/66/c4/661da5a2b55b7d6e1575a3241247eec4.jpg?wh=1142*649\" alt=\"\"></p><p>这个策略就是我们使用缓存最常见的策略，Cache Aside策略（也叫旁路缓存策略），这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的。它可以分为读策略和写策略，<strong>其中读策略的步骤是：</strong></p><ul>\n<li>从缓存中读取数据；</li>\n<li>如果缓存命中，则直接返回数据；</li>\n<li>如果缓存不命中，则从数据库中查询数据；</li>\n<li>查询到数据后，将数据写入到缓存中，并且返回给用户。</li>\n</ul><p><strong>写策略的步骤是：</strong></p><ul>\n<li>更新数据库中的记录；</li>\n<li>删除缓存记录。</li>\n</ul><p>你也许会问了，在写策略中，能否先删除缓存，后更新数据库呢？<strong>答案是不行的，</strong>因为这样也有可能出现缓存数据不一致的问题，我以用户表的场景为例解释一下。</p><p>假设某个用户的年龄是20，请求A要更新用户年龄为21，所以它会删除缓存中的内容。这时，另一个请求B要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为20，并且写入到缓存中，然后请求A继续更改数据库，将用户的年龄更新为21，这就造成了缓存和数据库的不一致。</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/3b/b725cc2c93f31a5d477b6b72fc5add3b.jpg?wh=1142*540\" alt=\"\"></p><p>那么像Cache Aside策略这样先更新数据库，后删除缓存就没有问题了吗？其实在理论上还是有缺陷的。假如某个用户数据在缓存中不存在，请求A读取数据时从数据库中查询到年龄为20，在未写入缓存中时另一个请求B更新数据。它更新数据库中的年龄为21，并且清空缓存。这时请求A把从数据库中读到的年龄为20的数据写入到缓存中，造成缓存和数据库数据不一致。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/d9/f24f728919216b90e374e33a82ccd5d9.jpg?wh=1142*543\" alt=\"\"></p><p>不过这种问题出现的几率并不高，原因是缓存的写入通常远远快于数据库的写入，所以在实际中很难出现请求B已经更新了数据库并且清空了缓存，请求A才更新完缓存的情况。而一旦请求A早于请求B清空缓存之前更新了缓存，那么接下来的请求就会因为缓存为空而从数据库中重新加载数据，所以不会出现这种不一致的情况。</p><p><strong>Cache Aside策略是我们日常开发中最经常使用的缓存策略，不过我们在使用时也要学会依情况而变。</strong>比如说当新注册一个用户，按照这个更新策略，你要写数据库，然后清理缓存（当然缓存中没有数据给你清理）。可当我注册用户后立即读取用户信息，并且数据库主从分离时，会出现因为主从延迟所以读不到用户信息的情况。</p><p><strong>而解决这个问题的办法</strong>恰恰是在插入新数据到数据库之后写入缓存，这样后续的读请求就会从缓存中读到数据了。并且因为是新注册的用户，所以不会出现并发更新用户信息的情况。</p><p>Cache Aside存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。<strong>如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</strong></p><p>1.一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</p><p>2.另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</p><p>当然了，除了这个策略，在计算机领域还有其他几种经典的缓存策略，它们也有各自适用的使用场景。</p><h2>Read/Write Through（读穿/写穿）策略</h2><p>这个策略的核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。这就好比你在汇报工作的时候只对你的直接上级汇报，再由你的直接上级汇报给他的上级，你是不能越级汇报的。</p><p>Write Through的策略是这样的：先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做“Write Miss（写失效）”。</p><p>一般来说，我们可以选择两种“Write Miss”方式：一个是“Write Allocate（按写分配）”，做法是写入缓存相应位置，再由缓存组件同步更新到数据库中；另一个是“No-write allocate（不按写分配）”，做法是不写入缓存中，而是直接更新到数据库中。</p><p>在Write Through策略中，我们一般选择“No-write allocate”方式，原因是无论采用哪种“Write Miss”方式，我们都需要同步将数据更新到数据库中，而“No-write allocate”方式相比“Write Allocate”还减少了一次缓存的写入，能够提升写入的性能。</p><p>Read Through策略就简单一些，它的步骤是这样的：先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库中同步加载数据。</p><p>下面是Read Through/Write Through策略的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/90/d1/90dc599d4d2604cd5943584c4d755bd1.jpg?wh=1142*888\" alt=\"\"></p><p>Read Through/Write Through策略的特点是由缓存节点而非用户来和数据库打交道，在我们开发过程中相比Cache Aside策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是Memcached还是Redis都不提供写入数据库，或者自动加载数据库中的数据的功能。而我们在使用本地缓存的时候可以考虑使用这种策略，比如说在上一节中提到的本地缓存Guava Cache中的Loading Cache就有Read Through策略的影子。</p><p>我们看到Write Through策略中写数据库是同步的，这对于性能来说会有比较大的影响，因为相比于写缓存，同步写数据库的延迟就要高很多了。那么我们可否异步地更新数据库？这就是我们接下来要提到的“Write Back”策略。</p><h2>Write Back（写回）策略</h2><p>这个策略的核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。</p><p><strong>需要注意的是，</strong>在“Write Miss”的情况下，我们采用的是“Write Allocate”的方式，也就是在写入后端存储的同时要写入缓存，这样我们在之后的写请求中都只需要更新缓存即可，而无需更新后端存储了，我将Write back策略的示意图放在了下面：</p><p><img src=\"https://static001.geekbang.org/resource/image/59/9f/59f3c4caafd4c3274ddb7e0ac37f429f.jpg?wh=1142*997\" alt=\"\"></p><p><strong>如果使用Write Back策略的话，读的策略也有一些变化了。</strong>我们在读取缓存时如果发现缓存命中则直接返回缓存数据。如果缓存不命中则寻找一个可用的缓存块儿，如果这个缓存块儿是“脏”的，就把缓存块儿中之前的数据写入到后端存储中，并且从后端存储加载数据到缓存块儿，如果不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据就好了。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/59/a01bbf953088eef6695ffb1dc182b559.jpg?wh=1142*1036\" alt=\"\"></p><p><strong>发现了吗？</strong>其实这种策略不能被应用到我们常用的数据库和缓存的场景中，它是计算机体系结构中的设计，比如我们在向磁盘中写数据时采用的就是这种策略。无论是操作系统层面的Page Cache，还是日志的异步刷盘，亦或是消息队列中消息的异步写入磁盘，大多采用了这种策略。因为这个策略在性能上的优势毋庸置疑，它避免了直接写磁盘造成的随机写问题，毕竟写内存和写磁盘的随机I/O的延迟相差了几个数量级呢。</p><p>但因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为Page Cache还没有来得及刷盘造成的。</p><p><strong>当然，你依然可以在一些场景下使用这个策略，在使用时，我想给你的落地建议是：</strong>你在向低速设备写入数据的时候，可以在内存里先暂存一段时间的数据，甚至做一些统计汇总，然后定时地刷新到低速设备上。比如说，你在统计你的接口响应时间的时候，需要将每次请求的响应时间打印到日志中，然后监控系统收集日志后再做统计。但是如果每次请求都打印日志无疑会增加磁盘I/O，那么不如把一段时间的响应时间暂存起来，经过简单的统计平均耗时，每个耗时区间的请求数量等等，然后定时地，批量地打印到日志中。</p><h2>课程小结</h2><p>本节课，我主要带你了解了缓存使用的几种策略，以及每种策略适用的使用场景是怎样的。我想让你掌握的重点是：</p><p>1.Cache Aside是我们在使用分布式缓存时最常用的策略，你可以在实际工作中直接拿来使用。</p><p>2.Read/Write Through和Write Back策略需要缓存组件的支持，所以比较适合你在实现本地缓存组件的时候使用；</p><p>3.Write Back策略是计算机体系结构中的策略，不过写入策略中的只写缓存，异步写入后端存储的策略倒是有很多的应用场景。</p><p>而且，你还需要了解，我们今天提到的策略都是标准的使用姿势，在实际开发过程中需要结合实际的业务特点灵活使用甚至加以改造。这些业务特点包括但不仅限于：整体的数据量级情况，访问的读写比例的情况，对于数据的不一致时间的容忍度，对于缓存命中率的要求等等。理论结合实践，具体情况具体分析，你才能得到更好的解决方案。</p><h2>一课一思</h2><p>结合今天课程中的内容，你可以思考一下在日常工作中使用缓存时都使用了哪些缓存的读写策略呢？欢迎在留言区和我一起讨论。</p><p>最后，感谢你的阅读，如果这篇文章对你有收获，欢迎你将它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"12 | 缓存：数据库成为瓶颈后，动态数据的查询要如何加速？","id":149899},"right":{"article_title":"14 | 缓存的使用姿势（二）：缓存如何做到高可用？","id":151949}},"comments":[{"had_liked":false,"id":141551,"user_name":"小可","can_delete":false,"product_type":"c1","uid":1006735,"ip_address":"","ucode":"8834AF621FA67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","comment_is_top":true,"comment_ctime":1571189903,"is_pvip":false,"replies":[{"id":"54679","content":"👍","user_name":"作者回复","comment_id":141551,"uid":"1448977","ip_address":"","utype":1,"ctime":1571193771,"user_name_real":"唐扬"}],"discussion_count":9,"race_medal":0,"score":"9.2233721887497994e+18","product_id":100035801,"comment_content":"工作中老师说的这几种缓存策略基本都用到了，特别是统计接口响应时间那个例子和我们的场景一样。管理平台统计一百多个节点的上报到队列中的数据，原来是按消费一批统计完直接批量入库，数据量太大(每秒两三千)，压力全在数据库，系统也比较卡，并且如果入库不及时就会数据积压，后续都跟不上。现在是消费统计和入库分开，消费统计先放缓存，每分钟再将缓存同步到数据库，同步成功再提交消费offset，目前看还算稳定。","like_count":36,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470795,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571193771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34669,"discussion_content":"“现在是消费统计和入库分开，消费统计先放缓存，每分钟再将缓存同步到数据库，同步成功再提交消费offset，目前看还算稳定。”消费统计和入库分开，其实就是业务解耦，可以用消息队列来完美解决。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571213288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":35483,"discussion_content":"嗯，可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571284448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":34669,"ip_address":""},"score":35483,"extra":""},{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":46899,"discussion_content":"每个请求写入缓存算消费成功吗？如果是这样，感觉还是有@杨骥提到的缓存丢数据问题。如果是写入数据库算消费成功，为什么还要多写一次缓存呢，最终的瓶颈还是在数据库哇。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573223805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":34669,"ip_address":""},"score":46899,"extra":""}]},{"author":{"id":1679880,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a2/08/9db00d06.jpg","nickname":"Y","note":"","ucode":"0CED0858B534E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41383,"discussion_content":"每分钟积累的请求量有多大，一次性同步数据库能消费的过来吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572415732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1679880,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a2/08/9db00d06.jpg","nickname":"Y","note":"","ucode":"0CED0858B534E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41470,"discussion_content":"因为本身是数据统计，量不是很大，每分钟小几千条吧，虽然也不少，但相对于每秒上千条操作数据库好了很多，实际上数据的操作也就是累价值更新，没必要每来个数据就更新统计值，一般业务上对统计值的实时性要求没那么高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572435308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41383,"ip_address":""},"score":41470,"extra":""}]},{"author":{"id":1239757,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/cd/179ee11c.jpg","nickname":"杨骥","note":"","ucode":"9A54E09212B660","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35394,"discussion_content":"不怕缓存挂了,丢失数据么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571275694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1239757,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/cd/179ee11c.jpg","nickname":"杨骥","note":"","ucode":"9A54E09212B660","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35484,"discussion_content":"原始数据在消息队列，缓存挂了，重消费统计","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571284491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35394,"ip_address":""},"score":35484,"extra":""},{"author":{"id":1121588,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/34/8201baab.jpg","nickname":"端贺","note":"","ucode":"80F1400B138055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37947,"discussion_content":"那么什么时候才算得上是消息的真正消费呢？是写入数据库之后吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571704941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35484,"ip_address":""},"score":37947,"extra":""}]}]},{"had_liked":false,"id":141516,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1571187380,"is_pvip":false,"replies":[{"id":"54656","content":"好滴，我关注一下~","user_name":"作者回复","comment_id":141516,"uid":"1448977","ip_address":"","utype":1,"ctime":1571189078,"user_name_real":"唐扬"}],"discussion_count":6,"race_medal":0,"score":"186254781108","product_id":100035801,"comment_content":"读到这里突然想到一个开源项目https:&#47;&#47;github.com&#47;apache&#47;ignite，内存数据库，结合了关系型数据库和缓存的优点，如果只当缓存使用的话，可以自动加载和写入关系型数据库中的数据。完美解决一致性问题。但是好像国内使用的人不多。","like_count":44,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470781,"discussion_content":"好滴，我关注一下~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571189078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2756576,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/0f/e0/b53a7701.jpg","nickname":"骑车上天空","note":"","ucode":"364365E2721122","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582484,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659445029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1255794,"avatar":"https://static001.geekbang.org/account/avatar/00/13/29/72/515e8867.jpg","nickname":"王厂长","note":"","ucode":"FF41279DA5A860","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576585,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655687156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/18/0d1447db.jpg","nickname":"Mars","note":"","ucode":"65DF3E2EC194FA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562270,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649809448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259156,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/94/0b969588.jpg","nickname":"青年祭司","note":"","ucode":"C88EDAE3FF09AE","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406429,"discussion_content":"看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634773511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2291843,"avatar":"https://static001.geekbang.org/account/avatar/00/22/f8/83/60e2e754.jpg","nickname":"LSH","note":"","ucode":"65F5A9F819F1B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375239,"discussion_content":"等看一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621523941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141729,"user_name":"岁寒","can_delete":false,"product_type":"c1","uid":1066921,"ip_address":"","ucode":"D062733384F4BF","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/a9/3ace68b6.jpg","comment_is_top":false,"comment_ctime":1571215667,"is_pvip":false,"replies":[{"id":"54787","content":"是的 所以解决的办法需要权衡一致性和性能","user_name":"作者回复","comment_id":141729,"uid":"1448977","ip_address":"","utype":1,"ctime":1571271832,"user_name_real":"唐扬"}],"discussion_count":1,"race_medal":0,"score":"126125267251","product_id":100035801,"comment_content":"缓存一定会引入不一致的。。","like_count":30,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470862,"discussion_content":"是的 所以解决的办法需要权衡一致性和性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571271832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147196,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1572835798,"is_pvip":true,"replies":[{"id":"56861","content":"这样确实是一个比较好的方式，只是会稍微复杂","user_name":"作者回复","comment_id":147196,"uid":"1448977","ip_address":"","utype":1,"ctime":1572836125,"user_name_real":"唐扬"}],"discussion_count":14,"race_medal":0,"score":"83177214422","product_id":100035801,"comment_content":"文中提到的第一个第一个缓存和数据不一致的问题，我认为这个问题的原因是，多个客户端更新缓存和数据库之间是无序的、并发的操作，这样必然导致数据不一致的问题，因此我们采用了监听binlog的方式，把Binlog扔到消息队列中，由一个leader来消费，负责更新缓存，保证了写缓存操作之间的顺序性，保证了缓存的准确性，避免了频繁读库。","like_count":20,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473193,"discussion_content":"这样确实是一个比较好的方式，只是会稍微复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572836125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583740,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/7c/0d6a87c4.jpg","nickname":"dandy","note":"","ucode":"5EE976FCBD9215","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338226,"discussion_content":"不用监听binlog也一样，只需要代码里头自身处理，需要更新的数据放队列里头，之后队列在异步消费，更新缓存，这样就不会有你说的binlog的问题了。思路都是一样的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609217340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1583740,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/7c/0d6a87c4.jpg","nickname":"dandy","note":"","ucode":"5EE976FCBD9215","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338402,"discussion_content":"是个好办法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609255998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338226,"ip_address":""},"score":338402,"extra":""}]},{"author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262904,"discussion_content":"binlog是全量的，缓存只是部分数据，binlog信息过来还需要查询是否需要刷寻缓存数据吧？确实这个量和复杂度还是蛮大的，我觉得通过消息队列后台一个程序消费（顺序消费指？单线程的话吃不消）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589156151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55930,"discussion_content":"这种方案数据延迟会比较高吧，需求不一样，方案也应该有所取舍\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574413464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1329995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","nickname":"Luciano李鑫","note":"","ucode":"5FBE5F86FD5B2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219197,"discussion_content":"在binlog数据量比较大的情况下确实有这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585743073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55930,"ip_address":""},"score":219197,"extra":""}]},{"author":{"id":1092603,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ab/fb/e1e0dbe2.jpg","nickname":"发条☞橙子","note":"","ucode":"D3875C267EC08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554399,"discussion_content":"不论异步/同步更新，都需要考虑ACID的，异步仅仅是解决了阻塞问题。比如用户需要写入后立马得到更新的值，实现却更复杂了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646364865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1271918,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/6e/eb079ed7.jpg","nickname":"永健_何","note":"","ucode":"7746F1B2A7542A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302980,"discussion_content":"你好，这种方案就是操作写入到消息队列中，就返回执行结果吗，最后的入库时由leader来完成的吗，算一个异步更新的方案吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599102772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196234,"avatar":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","nickname":"退役的球童","note":"","ucode":"CD5157830D9606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230699,"discussion_content":"确保数据库和缓存中数据的强一致性方案。楼主说的监听binlong，可以使用阿里开源 Canal的，接下来就跟楼主说的差不多了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586764328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1196234,"avatar":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","nickname":"退役的球童","note":"","ucode":"CD5157830D9606","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230701,"discussion_content":"这样其实有个问题，下面的评论里也提到了，就是在binlog非常大时候，同步会有延迟，这点需要注意下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586764494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230699,"ip_address":""},"score":230701,"extra":""}]},{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552214,"discussion_content":"放在队列问题是一样的，只是问题转移了，同样要保证队列里的消息跟db的改动顺序是一致的，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645349434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364409,"discussion_content":"但还是存在更新丢失的问题，因为异步更新缓存，更新数据时可能读到旧缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617463201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52170,"discussion_content":"大神，可以讲解地更加具体些嘛？怎样保证写缓存操作的顺序性呢？不胜感激！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574000892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52322,"discussion_content":"扔到消息队里，由一个程序来消费，收到的消息是顺序的，消费自然也是顺序的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574039007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52170,"ip_address":""},"score":52322,"extra":""}]}]},{"had_liked":false,"id":144452,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1571925877,"is_pvip":false,"replies":[{"id":"55690","content":"是的","user_name":"作者回复","comment_id":144452,"uid":"1448977","ip_address":"","utype":1,"ctime":1571960060,"user_name_real":"唐扬"}],"discussion_count":1,"race_medal":0,"score":"61701468021","product_id":100035801,"comment_content":"老师，我理解WriteBack策略相当于缓存和缓冲区合二为一了，对吧。据我所知，MySQL的buffer pool使用了WriteBack策略，但为了防止系统崩溃后数据丢失，MySQL使用了WAL（Write-Ahead Logging）机制，写先日志。好像WAL在HBase等系统也在用","like_count":15,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471947,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571960060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142126,"user_name":"yc","can_delete":false,"product_type":"c1","uid":1670122,"ip_address":"","ucode":"2E01505284DC4E","user_header":"https://static001.geekbang.org/account/avatar/00/19/7b/ea/a64f7822.jpg","comment_is_top":false,"comment_ctime":1571297594,"is_pvip":false,"replies":[{"id":"54930","content":"write back策略其实不算数据库和mc之间的策略，而是计算机体系结构中的策略，比如磁盘文件的缓存。它的完整读策略是这样的：如果缓存命中，则直接返回；如果缓存不命中，则重新找一个缓存块儿，如果这个缓存块儿是脏的，那么写入后端存储，并且把后端存储中的数据加载到缓存中；如果不是脏的，那么就把后端存储中的数据加载到缓存，然后标记缓存非脏。<br>是我的讲述不太清晰，感谢你的提问","user_name":"作者回复","comment_id":142126,"uid":"1448977","ip_address":"","utype":1,"ctime":1571364645,"user_name_real":"唐扬"}],"discussion_count":1,"race_medal":0,"score":"53110905146","product_id":100035801,"comment_content":"write back策略读请求时“如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中”，是不是写错了，如果缓存不是脏的，直接从缓存返回即可，为什么还要从后端记载数据到缓存然后返回？我看留言很多人都有同样的疑问，请老师解释一下，谢谢。","like_count":13,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470994,"discussion_content":"write back策略其实不算数据库和mc之间的策略，而是计算机体系结构中的策略，比如磁盘文件的缓存。它的完整读策略是这样的：如果缓存命中，则直接返回；如果缓存不命中，则重新找一个缓存块儿，如果这个缓存块儿是脏的，那么写入后端存储，并且把后端存储中的数据加载到缓存中；如果不是脏的，那么就把后端存储中的数据加载到缓存，然后标记缓存非脏。\n是我的讲述不太清晰，感谢你的提问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571364645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141809,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1571229867,"is_pvip":false,"replies":[{"id":"54785","content":"1. 是在更新数据库前加锁，锁的粒度是大了一些<br>2. 确实是更偏重底层开发","user_name":"作者回复","comment_id":141809,"uid":"1448977","ip_address":"","utype":1,"ctime":1571271762,"user_name_real":"唐扬"}],"discussion_count":3,"race_medal":0,"score":"53110837419","product_id":100035801,"comment_content":"Cache Aside对缓存命中率两种解决方案中的1,可能是我没看懂，感觉没解决问题啊？<br>这里说在“更新数据时也更新缓存”，我理解就是先更新DB再更新缓存，这样除非在更新DB之前加分布式锁，否则在更新DB之后加分布式锁，再更新缓存，依然较高可能出现不一致的情况。<br>实际中我们确实用在更新缓存时用分布式锁或本地锁，只不过是发现缓存为空而去读DB时，为了解决穿透问题。<br>纯个人见解，除了cache aside，另外两种更贴近底层系统开发而不是商业应用开发。因为我们大多数人做的系统，都是低速存储都是数据库，是有复杂的业务逻辑约束的，比如唯一性等，不是那种简单的page&#47;cpu cahce。我们经常的写操作一般都要借助数据库来检验这些约束并且在出错之后返回给用户。而如果直接与缓存打交道，且不论有些缓存的实现并不保证数据可靠性，也不能依靠缓存检验这些约束。<br>其实现在很多系统用的一种缓存模式是类似CQRS，写直接修改DB，异步更新到缓存，读只从缓存读数据。适合对数据不一致窗口可以容忍的场景。","like_count":13,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470894,"discussion_content":"1. 是在更新数据库前加锁，锁的粒度是大了一些\n2. 确实是更偏重底层开发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571271762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1755152,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","nickname":"Info_E","note":"","ucode":"97207B2CC4C776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380519,"discussion_content":"第一种也很有疑惑，在更新DB后再加锁感觉毫无意义，依然有可能会有先更新DB的反而后更新Cache的情况。只有在更新DB前加锁、更新Cache后解锁才能保证一致性。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624541196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2169775,"avatar":"https://static001.geekbang.org/account/avatar/00/21/1b/af/f766fef7.jpg","nickname":"赵文帅","note":"","ucode":"B36E8BD8136B02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577094,"discussion_content":"楼主说的对，如果先更新数据库然后加锁，那么仍然可能另外一个 线程先更新了数据且先获取到了锁然后更新缓存，那么此时数据库的值是后者，而缓存的值确实前者，这样还是不一致，只能 更新db前就加锁，但这样相当于只能写数据库只能有一个并发，效率会很低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655912088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231863,"user_name":"老菜","can_delete":false,"product_type":"c1","uid":1044452,"ip_address":"","ucode":"79521914D27320","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ef/e4/72d41488.jpg","comment_is_top":false,"comment_ctime":1593791098,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"40248496762","product_id":100035801,"comment_content":"老师讲到的缓存策略在工作中都或多或少用到过或者见到过。不过除了老师讲的的策略之外，我们项目中用到了另外的缓存读写策略。<br>背景是这样的：”商品中心“维护了商品基础信息包括价格信息，作为微服务对外提供统一 API 访问入口，在前端比如购物车里需要调用“商品中心”提供的 API 获取价格信息渲染到页面，但是每次获取价格信息都涉及到网络调用，并且商品价格等信息一单写入修改频率是非常低的。基于以上原因在前端增加一层关于商品价格等信息的缓存。<br>写入策略是这样的：首先全量拷贝“商品中心”的所有商品价格信息到前端的缓存中，当然这个是一个非常耗时的操作并且这个操作只有在最开始初始缓存时执行且仅执行一次。然后订阅“商品中心”的改价操作的binlog，在发生商品信息修改时，更新前端缓存的价格信息，还有一个兜底策略就是定时任务轮询商品中心发生改价的商品信息，然后更新前端缓存的价格信息。<br>读缓存策略是这样的：在前端查询商品价格信息时，只会与缓存交互。<br>这样做的目的就是将购物车里商品查询性能做到极致，因为在活动期特别是双 11 时候购物车或商品详情访问可达亿级 PV ；另外就是商品变价都是运营人员提前 1-2 天配置好的，比如商品 A 原价是 10 元，双  11 期间改价为 8.9 元，价格生效期是在双 11 期间，这种缓存读取策略既提高了查询性能，又不会受数据短暂时间延迟的影响。<br>","like_count":9,"discussions":[{"author":{"id":1518310,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2a/e6/c788257f.jpg","nickname":"geek_arong2048","note":"","ucode":"AB575BE100E4A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576547,"discussion_content":"缓存预热的一种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655644238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194245,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtYGLkKnh188BsN41yXQV41uwk1lYTQBtDIJ6fl24biaicWql4GtyLqPuUoZwSWdvGBJemTV8xIplw/132","nickname":"wanghang886","note":"","ucode":"4EDA390D87425E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404218,"discussion_content":"想请教一下，前端是怎么获取到价格的变化信息的呢，是直接封装缓存的接口吗？还是类似于长链接的机智直接推送啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634261911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2034632,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0b/c8/15f055d3.jpg","nickname":"图灵机","note":"","ucode":"EB02DB653AD591","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289295,"discussion_content":"羡慕可以做这种高并发，大流量的项目","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594047449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1018928,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/30/d642e01a.jpg","nickname":"zhengnachuan","note":"","ucode":"FC6CD65906BE6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2034632,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0b/c8/15f055d3.jpg","nickname":"图灵机","note":"","ucode":"EB02DB653AD591","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":327919,"discussion_content":"其实这种方案不一定只在高并发中使用，所有需要优化频繁请求性能（相对自身业务而言）的操作，都可以采用缓存\n\n像我们做的b端产品，服务启动时会初始化一些业务元数据至缓存中。同时对读请求做区分：\n1、可以容忍数据不一致的直接走缓存；\n2、需要强一致性的则先调用接口获取元数据再刷缓存；\n3、定时任务定期刷缓存；\n当然和上述方案的区别在于是主动调用依赖方，也可以加上消息订阅的流程，就更完善了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606017171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289295,"ip_address":""},"score":327919,"extra":""},{"author":{"id":2134178,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGab0pU6otFrXbzaHzLGvJTleveANhr48ALAJqZGWZ75sxJ5NHEJFWmg1mHurEZYCPg/132","nickname":"InfoQ_86bc07609fbd","note":"","ucode":"000CAFAD2DE0B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018928,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/30/d642e01a.jpg","nickname":"zhengnachuan","note":"","ucode":"FC6CD65906BE6B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402381,"discussion_content":"提前准备缓存数据，分摊了每次写缓存消耗，空间换时间的好办法。但缓存数据太大，读端太多，可能有网络开销。不知有没有好办法解决？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633873822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327919,"ip_address":""},"score":402381,"extra":""}]}]},{"had_liked":false,"id":143412,"user_name":"程序水果宝","can_delete":false,"product_type":"c1","uid":1371633,"ip_address":"","ucode":"1700DDFE073A56","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","comment_is_top":false,"comment_ctime":1571706702,"is_pvip":false,"replies":[{"id":"55496","content":"是有这个问题，比如pagecache在机器掉电之后就都是数据了。一个办法是将写入缓存的操作写入log里，类似lsm树的write ahead log","user_name":"作者回复","comment_id":143412,"uid":"1448977","ip_address":"","utype":1,"ctime":1571792781,"user_name_real":"唐扬"}],"discussion_count":2,"race_medal":0,"score":"27341510478","product_id":100035801,"comment_content":"使用写回策略，如果在缓存更新到数据库之前设备掉电了，那这样数据岂不是丢失了，请问这是怎么解决的呢，通过主备机制吗，缓存数据写两份？","like_count":6,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471524,"discussion_content":"是有这个问题，比如pagecache在机器掉电之后就都是数据了。一个办法是将写入缓存的操作写入log里，类似lsm树的write ahead log","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571792781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559598,"discussion_content":"是的，这种大部分业务是不能用写回的\n缓存不能当存储","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648827475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141757,"user_name":"七号叽","can_delete":false,"product_type":"c1","uid":1235812,"ip_address":"","ucode":"0CB7E5C3297511","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/64/f9628492.jpg","comment_is_top":false,"comment_ctime":1571218545,"is_pvip":false,"replies":[{"id":"54786","content":"否则缓存块就可能永远是脏的了","user_name":"作者回复","comment_id":141757,"uid":"1448977","ip_address":"","utype":1,"ctime":1571271809,"user_name_real":"唐扬"}],"discussion_count":10,"race_medal":0,"score":"27341022321","product_id":100035801,"comment_content":"老师你好，请问一下write back策略为什么读请求时是“如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中”，而不是直接返回？谢谢","like_count":6,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470875,"discussion_content":"否则缓存块就可能永远是脏的了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571271809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1417113,"avatar":"https://static001.geekbang.org/account/avatar/00/15/9f/99/46ebc741.jpg","nickname":"Richie","note":"","ucode":"2530B54C8860BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37943,"discussion_content":"这个前提是缓存不命中，建议返回原文细读前后几句话","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1571704311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1235812,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/64/f9628492.jpg","nickname":"七号叽","note":"","ucode":"0CB7E5C3297511","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1417113,"avatar":"https://static001.geekbang.org/account/avatar/00/15/9f/99/46ebc741.jpg","nickname":"Richie","note":"","ucode":"2530B54C8860BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39414,"discussion_content":"好的，感谢  不知道为什么忽略了🌚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571923023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37943,"ip_address":""},"score":39414,"extra":""}]},{"author":{"id":1000439,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/f7/abb7bfe3.jpg","nickname":"刘冲","note":"","ucode":"0C4F66921AE76C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35342,"discussion_content":"没懂，既然不是脏数据，直接返回就可以了，为啥还说可能永远都是脏数据呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571272128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1000439,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/f7/abb7bfe3.jpg","nickname":"刘冲","note":"","ucode":"0C4F66921AE76C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306033,"discussion_content":"脏数据指的是发现之前有数据没有落盘，触发落盘，然后又因为本次需要的数据在缓存中未命中，所以准备从库里拿新数据到缓存中，那么刚拿到的数据由于和库里一致，所以自然就是非“脏”的了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1600152161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35342,"ip_address":""},"score":306033,"extra":""},{"author":{"id":1997465,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/7a/99/4ac1d891.jpg","nickname":"猴子胖胖","note":"","ucode":"EFFE195C126E00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556811,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647521862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306033,"ip_address":""},"score":556811,"extra":""}]},{"author":{"id":1590038,"avatar":"https://static001.geekbang.org/account/avatar/00/18/43/16/d18be4c5.jpg","nickname":"...？","note":"","ucode":"8CB8669180F9D8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372099,"discussion_content":"缓存未命中，选择一个缓存块，这个缓存块的数据不是要找的数据，是其他的缓存，需要判断触发别的缓存是否落盘，这个缓存块脏不脏，都要从数据库读新数据返回，对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620186934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3031867,"avatar":"","nickname":"Geek_1ca1a6","note":"","ucode":"F00B9A60D32A3E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1590038,"avatar":"https://static001.geekbang.org/account/avatar/00/18/43/16/d18be4c5.jpg","nickname":"...？","note":"","ucode":"8CB8669180F9D8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":584842,"discussion_content":"缓存未命中，咋滴都得加载到内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661154918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372099,"ip_address":"上海"},"score":584842,"extra":""}]},{"author":{"id":1006864,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/10/0acf7cbc.jpg","nickname":"Ryan-Hou","note":"","ucode":"5B703C1E1596A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106236,"discussion_content":"可以直接返回，但是后续读该数据那不是依然不命中继续查库？缓存的意义就没了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577524791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35099,"discussion_content":"同问，如果缓存中有数据，只是判断是否为脏的，不管是否为脏，都直接返回不就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571235701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141565,"user_name":"王大伟","can_delete":false,"product_type":"c1","uid":1180955,"ip_address":"","ucode":"A3BDC4D7B94B0F","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/1b/fc1aa0ac.jpg","comment_is_top":false,"comment_ctime":1571192091,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"27340995867","product_id":100035801,"comment_content":"Read&#47;Write Through策略与MySQL的Buffer Pool的机制很相似啊","like_count":6,"discussions":[{"author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38649,"discussion_content":"这点我的理解不太一样，与之相似的是write back策略。这个属于系统级的用法，挺多地方都用","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571813384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39451,"discussion_content":"赞同！我跟你理解一样，另外MySQL使用了WAL，系统崩溃后数据不会丢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571926171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":38649,"ip_address":""},"score":39451,"extra":""}]},{"author":{"id":1246178,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","nickname":"inrtyx","note":"","ucode":"81CD18FF34ABAB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184323,"discussion_content":"应该是write back策略和mysql一样","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582552730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143918,"user_name":"fdconan","can_delete":false,"product_type":"c1","uid":1244596,"ip_address":"","ucode":"01C71C6E9FD1E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLv9HJIW4OACkjlwOQJ9cU7HzvaDFYkACWCib2lzOMef9ZiaGDTVFqjPicpVK5KDRbBRVGGHrMHQO1Rw/132","comment_is_top":false,"comment_ctime":1571806928,"is_pvip":false,"replies":[{"id":"55608","content":"会的，这就是狗桩效应嘛~","user_name":"作者回复","comment_id":143918,"uid":"1448977","ip_address":"","utype":1,"ctime":1571854956,"user_name_real":"唐扬"}],"discussion_count":1,"race_medal":0,"score":"23046643408","product_id":100035801,"comment_content":"Cache Aside（旁路缓存）策略，对于读多写少场景，当一个写操作更新db后同时删除缓存。然后多个读就会回源，这不会造成db压力么？","like_count":5,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471746,"discussion_content":"会的，这就是狗桩效应嘛~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571854956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142384,"user_name":"Geek_49305e","can_delete":false,"product_type":"c1","uid":1667478,"ip_address":"","ucode":"DC435E892631C2","user_header":"","comment_is_top":false,"comment_ctime":1571361567,"is_pvip":false,"replies":[{"id":"55100","content":"这种情况下，在更新数据库之前就要加锁","user_name":"作者回复","comment_id":142384,"uid":"1448977","ip_address":"","utype":1,"ctime":1571454056,"user_name_real":"唐扬"}],"discussion_count":4,"race_medal":0,"score":"23046198047","product_id":100035801,"comment_content":"老师，1. 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。   这个解决方案应该有些不严谨的地方，如有A，B两个线程，A先更新数据库的值为20，而后A获取到更新缓存的分布式的锁，但未释放锁，此时B更新数据库的值为21，更新后尝试获取锁，此时获取锁一定会失败，抛出异常，终止更新缓存。 最后缓存中的数据为A更新的的值20","like_count":5,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471099,"discussion_content":"这种情况下，在更新数据库之前就要加锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571454056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1666557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eovz9xiauibkkJ2wyu8P1TTliacnk0FaVkfxsK95VITwtHRnmGeD4IdEOLLwkKEedeM2mr8XjE8TVXZQ/132","nickname":"Geek_kenny","note":"","ucode":"9E241E4C67E555","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48504,"discussion_content":"B尝试获取锁失败可以不断重试，redisson有提供公平锁的api","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573483842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364419,"discussion_content":"1.悲观锁，被阻塞\n2.乐观锁，不断尝试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617464156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1961553,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKndUALz6eOevGElBRewhmYZWhJiaplDdpBh5cy26ZIvLrxc8To6gooEzE8G5r3IxoyrINPz8qFZaQ/132","nickname":"Geek_27508f","note":"","ucode":"09E517267AEED9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297245,"discussion_content":"比如AB读取的值都为20时，如果A线程更新完数据库获取锁时卡住了，B线程先获取到了锁，而且B线程发生在A之后，这种情况加锁是不是也不太合适了？要结合乐观锁么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596844418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141633,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1571204073,"is_pvip":false,"replies":[{"id":"54699","content":"是的 这样只能更新缓存，然后使用分布式锁来控制","user_name":"作者回复","comment_id":141633,"uid":"1448977","ip_address":"","utype":1,"ctime":1571206030,"user_name_real":"唐扬"}],"discussion_count":4,"race_medal":0,"score":"18751073257","product_id":100035801,"comment_content":"老师问您一个问题！其实如果是使用.Cache Aside方式的话。在写的时候时候因为更新数据后，删除了缓存。在高并发情况下。那么可能会出现以下情况：<br>主从同步的情况下，从库没来得及同步。大量的读请求返回的是从库的旧数据。而这个时候读的数据会被动写入缓存。那就存在很大的问题！这种应该怎么处理！如果是这样的话？是不是只能依靠分布式锁来实现了！<br>","like_count":4,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470827,"discussion_content":"是的 这样只能更新缓存，然后使用分布式锁来控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571206030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34725,"discussion_content":"如“jc9090kkk”所说，你说的是同步延迟造成的数据不一致，跟缓存策略没有直接关系。处理你说的问题，我所接触到的有2个办法：1.如果这个数据是核心数据（不一致会造成核心业务逻辑错误），这种情况就是读主库，不是从库，这样就解决你说的主从不一致问题，读后写入缓存，这种情况即使不加缓存，也是读主库；2.如果这个数据非核心数据，允许短暂不一致的情况，就用老师说的那种给缓存设置一个较短（这个业务实际情况定）的过期时间，降低对业务的影响。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1571216754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100149,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","nickname":"猿人谷","note":"","ucode":"85106C7FB14C43","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":34738,"discussion_content":"嗯，是的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571218722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":34725,"ip_address":""},"score":34738,"extra":""}]},{"author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34553,"discussion_content":"你这是数据库主从同步延迟导致的，跟缓存有啥关系？ 数据库主从延迟导致的过期读的问题，应该是优先解决主从同步延迟，否则数据的不一致你用什么缓存策略都是有问题的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571205787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141563,"user_name":"MoonGod","can_delete":false,"product_type":"c1","uid":1254337,"ip_address":"","ucode":"CB39976963F37A","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/c1/54ef6885.jpg","comment_is_top":false,"comment_ctime":1571191522,"is_pvip":false,"replies":[{"id":"54677","content":"如果更新不频繁的话，其实还OK<br>如果更新频繁，可以加分布式锁，让单一线程可以更新这条数据；或者设置短的过期时间，让可能出现的不一致数据尽快过期","user_name":"作者回复","comment_id":141563,"uid":"1448977","ip_address":"","utype":1,"ctime":1571193753,"user_name_real":"唐扬"}],"discussion_count":3,"race_medal":0,"score":"14456093410","product_id":100035801,"comment_content":"老师请问一个问题，在cache aside策略中，如果先更新数据库，再删除缓存。这样如果读请求访问量很大，会短时间出现大量请求穿透到数据库，这里有好的办法优化吗？","like_count":3,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470800,"discussion_content":"如果更新不频繁的话，其实还OK\n如果更新频繁，可以加分布式锁，让单一线程可以更新这条数据；或者设置短的过期时间，让可能出现的不一致数据尽快过期","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571193753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2586341,"avatar":"","nickname":"石头","note":"","ucode":"EB3C9A277C7B0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369932,"discussion_content":"1这个怎么防止缓存穿透的问题，加锁确实可以解决。\n2但是设置短的过期时间又相当于允许数据短时间不一致，未采用aside策略了，这个策略其实也非常常用。\n1和2并不是在回答同一个问题。缓存穿透只要是缓存不是永不过期就一定会存在的，和是不是cache aside没啥关系。\n对于更新不频繁的数据，也不一定要加锁，更新数据库时立即更新缓存，设置个很长的时间戳，然后消费binlog再确保数据一致性就可以。既防止缓存穿透，也解决了一致性问题。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619217328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014806,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/16/4d1e5cc1.jpg","nickname":"mgxian","note":"","ucode":"7B7E77E6A83B87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34331,"discussion_content":"给缓存加锁 同一个缓存 key 只允许一个线程更新缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571193302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235913,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1595241456,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10185176048","product_id":100035801,"comment_content":"原文：Write Back 策略的核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。<br><br>问题一：<br>再次使用时，这里的“使用”是指 read 或 write 操作，还是仅是 write 操作？<br><br>-----<br><br>原文：在“Write Miss”的情况下，我们采用的是“Write Allocate”的方式，也就是在写入后端存储的同时要写入缓存，这样我们在之后的写请求中都只需要更新缓存即可，而无需更新后端存储了，我将 Write back 策略的示意图放在了下面。<br><br>问题二：<br>Write Back 策略，当数据不在缓存时，需要要写入后端存储和缓存。为什么后续的写请求，只需要更新缓存（并且把缓存标记为“脏”），不需要更新后端存储呀？<br>我的理解是：这好像回到了问题一的场景了，再次使用时（后续的写请求），把被标记为“脏”的数据写回后端存储。<br><br>问题三：<br>下方的示意图，如果为脏，写后端存储。之后又写缓存，并标记为脏。<br>这里应该是将上一次的脏数据（本次写请求之前的脏数据）刷到存储。而本次写请求的修改，是体现在写后端存储之后的写缓存操作。本次的写修改，需要等待下一次使用时，才会写入到后端存储。是这样么？<br><br>-----<br><br>原文：Write Back 策略的读的策略也有一些变化了。我们在读取缓存时如果缓存不命中则寻找一个可用的缓存块儿，<br>如果这个缓存块儿是“脏”的，就把缓存块儿中之前的数据写入到后端存储中，并且从后端存储加载数据到缓存块儿，<br>如果不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据就好了。<br><br>问题四：<br>读的时候，如果不命中缓存，为啥要寻找一个可用的缓存块？这个缓存块是本次读请求业务相关的么？如果相关，那不是缓存不命中了么？如果不相关，那咋知道该如何刷回后端存储呀？<br><br>问题五：<br>还是没能理解，当读操作时，既然缓存不命中了，何来缓存块“脏”与“不脏”这一说呢？<br><br>问题六：<br>假设我理解了缓存不命中，并且缓存块是“脏”的场景。<br>此时将缓存块的数据写入后端存储，为什么还需要从后端存储加载数据到缓存块？此时后端存储的数据，不应该和缓存块里的数据是一致的么？<br><br>问题七：<br>假设我理解了缓存不命中，并且缓存块是不“脏”的场景。<br>为什么还需要从后端存储加载数据到缓存，数据不是不脏么，不脏就是没有被修改过，那应该也是和后端存储的数据是一致的吧？<br><br>-----<br><br>谢谢老师，期待您的回复！！","like_count":2,"discussions":[{"author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306044,"discussion_content":"试着回答一下：\n答一：读或写都可能触发落库。\n\n答二：未命中时，双写即缓存和库，当前缓存和库数据一致，所以非&#34;脏&#34;。后续只写缓存，避免了频繁落库io消耗，但因和库中不一致了（库中是旧的），所以标记&#34;脏&#34;，等待落库时机。\n\n答三：是的，二次触发写，先将旧数据落库，再更新缓存，等待下一次落库。\n\n答四：读，未命中，申请一块缓存空间，用于从库中加载数据后存放。如果发现之前有脏数据未落库，则触发落库，然后继续加载自己需要的数据到缓存中。如果没有旧的脏数据，则直接读取自己要的新数据。无论哪种，本次未命中导致的加载数据，缓存和库都是一致的，所以非&#34;脏&#34;。\n\n答五：读，未命中，所谓的脏数据，非本次想要的数据，而指的是之前是否存在未落库的数据。\n\n答六：&#34;脏&#34;的数据，即之前的与本次无关的数据，触发了落库。而从后端存储加载数据，才是本次未命中下，要读取的，否则缓存就没有这数据了。\n\n答七：不&#34;脏&#34;，指的是没有要落库的其他旧数据，与本次想要的无关。本次想要的，因为未命中，所以必然要从库中加载。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600154444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2134178,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGab0pU6otFrXbzaHzLGvJTleveANhr48ALAJqZGWZ75sxJ5NHEJFWmg1mHurEZYCPg/132","nickname":"InfoQ_86bc07609fbd","note":"","ucode":"000CAFAD2DE0B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402410,"discussion_content":"简单的说，当缓存空间有限时，踢出旧缓存，加载新缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633875880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306044,"ip_address":""},"score":402410,"extra":""}]}]},{"had_liked":false,"id":162843,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1576610940,"is_pvip":false,"replies":[{"id":"62142","content":"是的，可以加分布式锁","user_name":"作者回复","comment_id":162843,"uid":"1448977","ip_address":"","utype":1,"ctime":1576735701,"user_name_real":"唐扬"}],"discussion_count":1,"race_medal":0,"score":"10166545532","product_id":100035801,"comment_content":"老师，写穿策略中先写缓存再同步DB，此过程若是多线程，需要加锁吧，如果不加，也存在写覆盖问题","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478163,"discussion_content":"是的，可以加分布式锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576735701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162784,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1576589119,"is_pvip":false,"replies":[{"id":"62144","content":"是的","user_name":"作者回复","comment_id":162784,"uid":"1448977","ip_address":"","utype":1,"ctime":1576735803,"user_name_real":"唐扬"}],"discussion_count":2,"race_medal":0,"score":"10166523711","product_id":100035801,"comment_content":"Cache Aside在更新频繁时的两种解决策略应该是很经典的CAP问题吧，要保证C就要一定程度上牺牲A，反之亦然。看哪个更重要","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478149,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576735803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1755152,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","nickname":"Info_E","note":"","ucode":"97207B2CC4C776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550666,"discussion_content":"是我理解的有问题吗 cap不是描述的是集群系统间 各个节点间的数据一致性 和 系统可用性之前要有取舍，咱这个是数据库和缓存间的一致性问题啊 ，跟cap有啥关系？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644662233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145568,"user_name":"你净瞎说～","can_delete":false,"product_type":"c1","uid":1255437,"ip_address":"","ucode":"A4EE0154034D22","user_header":"https://static001.geekbang.org/account/avatar/00/13/28/0d/558f6141.jpg","comment_is_top":false,"comment_ctime":1572317237,"is_pvip":false,"replies":[{"id":"56283","content":"指的是缓存使用的那块内存有未被刷新到后端存储中的数据，就认为是脏的","user_name":"作者回复","comment_id":145568,"uid":"1448977","ip_address":"","utype":1,"ctime":1572392860,"user_name_real":"唐扬"}],"discussion_count":3,"race_medal":0,"score":"10162251829","product_id":100035801,"comment_content":"脏是针对缓存块来说的吧？缓存也有脏不脏吗？","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472469,"discussion_content":"指的是缓存使用的那块内存有未被刷新到后端存储中的数据，就认为是脏的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572392860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/4c/108db3b5.jpg","nickname":"红袖添香","note":"","ucode":"0E62FA9C4F4E09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47698,"discussion_content":"这个类似于MySQL的PURGE过程","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573393244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208835,"avatar":"https://static001.geekbang.org/account/avatar/00/12/72/03/da1fcc81.jpg","nickname":"overland","note":"","ucode":"609A463519E5F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62332,"discussion_content":"有是脏还是没有是脏呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574834462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142006,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1571278423,"is_pvip":false,"replies":[{"id":"54931","content":"write back策略其实不算数据库和mc之间的策略，而是计算机体系结构中的策略，比如磁盘文件的缓存。它的完整读策略是这样的：如果缓存命中，则直接返回；如果缓存不命中，则重新找一个缓存块儿，如果这个缓存块儿是脏的，那么写入后端存储，并且把后端存储中的数据加载到缓存中；如果不是脏的，那么就把后端存储中的数据加载到缓存，然后标记缓存非脏。<br>是我的讲述不太清晰，感谢你的提问","user_name":"作者回复","comment_id":142006,"uid":"1448977","ip_address":"","utype":1,"ctime":1571364648,"user_name_real":"唐扬"}],"discussion_count":1,"race_medal":0,"score":"10161213015","product_id":100035801,"comment_content":"老师你好，请问一下write back策略为什么读请求时是“如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中”，而不是直接返回？，这里您说： 否则缓存块就可能永远是脏的了。<br>对此表示疑惑，既然不是脏数据，难道不是直接返回就好了？","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470952,"discussion_content":"write back策略其实不算数据库和mc之间的策略，而是计算机体系结构中的策略，比如磁盘文件的缓存。它的完整读策略是这样的：如果缓存命中，则直接返回；如果缓存不命中，则重新找一个缓存块儿，如果这个缓存块儿是脏的，那么写入后端存储，并且把后端存储中的数据加载到缓存中；如果不是脏的，那么就把后端存储中的数据加载到缓存，然后标记缓存非脏。\n是我的讲述不太清晰，感谢你的提问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571364648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297376,"user_name":"כן אני אמריקאי","can_delete":false,"product_type":"c1","uid":1527429,"ip_address":"","ucode":"56C5C2B369121B","user_header":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","comment_is_top":false,"comment_ctime":1623490545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5918457841","product_id":100035801,"comment_content":"用个人的语言总结一下 Write Back 策略：<br><br>假设缓存中存放的是 key-value 数据，我们即将写入(&quot;usr:101&quot;:&quot;hresh&quot;)的数据。<br><br>**数据写入时**<br><br>- 如果缓存中不存在 key=&quot;usr:101&quot;的数据，即Write Miss情况下，<br>  - 选择一个可用的缓存块（用来缓存数据），如果它是脏的，则将缓存块里之前的数据和新数据(&quot;usr:101&quot;:&quot;hresh&quot;)一起落盘到数据库中，再将新数据写入到缓存块中；（按照文章的说法需要将该缓存块标记为脏的，但是按照我上述的理解应该不需要。）<br>  - 如果选择的缓存块不是脏的，则直接写入到缓存即可，最后该缓存块标记为脏的。<br>- 如果缓存中存在 key=&quot;usr:101&quot;的旧数据，只需要更新缓存，最后该缓存块标记为脏的。<br><br>数据读取 key=&quot;usr:101&quot; 的数据时<br><br>- 如果缓存命中则直接返回缓存数据。<br>- 如果缓存不命中则寻找一个可用的缓存块儿（不存在 key=&quot;usr:101&quot;），<br>  - 如果这个缓存块儿是“脏”的，就把缓存块儿中之前的数据写入到数据库中，并且从数据库中加载 (&quot;usr:101&quot;:&quot;hresh&quot;)到缓存块儿；<br>  - 如果不是脏的，则由缓存组件从数据库中将 (&quot;usr:101&quot;:&quot;hresh&quot;)加载到缓存中；<br>  - 最后我们将缓存块设置为不是脏的，返回数据就好了。","like_count":1},{"had_liked":false,"id":209192,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1587518335,"is_pvip":false,"replies":[{"id":"78269","content":"👍","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1587623993,"ip_address":"","comment_id":209192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882485631","product_id":100035801,"comment_content":"小结一下：<br>1：用缓存目的是为了提速，之所以能提速关键在于使用内存来存储，不过内存的特点是掉电后时会丢数据，所以，一份数据会放在DB和缓存两个地方，那么对于变化频繁的数据就会存在数据不一致的问题，缓存最适合的是静态资源或变化低频的资源<br>2：后面这个那个策略，都是为了解决变化频繁的数据的数据一致性问题的，在解决缓存一致性问题时会引入别的问题，比如：性能问题，复杂度问题。<br>3：具体怎么权衡看业务场景，不过数据一致性问题在分布式环境中是很经典和头疼的问题，因为缓存数据会引入，别的情况也会引入，比如：主从延迟","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492733,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587623993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175715,"user_name":"小洛","can_delete":false,"product_type":"c1","uid":1005062,"ip_address":"","ucode":"227EC21891012B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/06/ea49b29d.jpg","comment_is_top":false,"comment_ctime":1580805614,"is_pvip":false,"replies":[{"id":"68350","content":"：）","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1580872377,"ip_address":"","comment_id":175715,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5875772910","product_id":100035801,"comment_content":"Cache Aside 写策略  先更新数据库后删除缓存，假设缓存不空为20    A线程去更新数据库为21，还没有及时删除缓存，这时候B线程去读取缓存就读到旧的数据20了，如果B线程读取到旧的数据后去做核心业务操作，例如金额操作就会出问题了，但是如果对A线程的整个操作“先更新数据库，再删除缓存”进行加锁，保证B线程读取到一定是A线程设置的新值，但是写多读少的场景下又对写入性能有影响，看来还是要结合业务场景来选择合适的技术解决方案。一句话缓存不简单。谢谢老师的分享！","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482867,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580872377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2002210,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","nickname":"tongzi","note":"","ucode":"7349A6E42EDF17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340147,"discussion_content":"hi，有个问题，对A线程的整个操作加锁，也不能解决保证，B线程一定是A线程设置的新值；B线程还是可能先读取数据库旧值，A线程加锁操作完整执行完毕，然后B线程将旧值存到缓存中去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609916226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1755152,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","nickname":"Info_E","note":"","ucode":"97207B2CC4C776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2002210,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","nickname":"tongzi","note":"","ucode":"7349A6E42EDF17","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550667,"discussion_content":"你那个概率就太小了吧，A线程都更新数据库和删缓存都执行完了，B线程还没更新数据到缓存。不过确实存在其他问题， 对更新加锁只是保证更新缓存和更新数据库的操作的原子性，并不能锁住那行缓存数据，B线程在A线程删除缓存操作之前读取时 读到的还是旧数据，依旧会有问题。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644662785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340147,"ip_address":""},"score":550667,"extra":""}]}]},{"had_liked":false,"id":148818,"user_name":"Fourty Seven","can_delete":false,"product_type":"c1","uid":1323868,"ip_address":"","ucode":"DD213225842F68","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/5c/8c0a372a.jpg","comment_is_top":false,"comment_ctime":1573090615,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5868057911","product_id":100035801,"comment_content":"老师，写回策略中，读请求未命中，为啥要找可用缓存块，可用是指什么？有数据？没数据？这块没太理解","like_count":1,"discussions":[{"author":{"id":1023475,"avatar":"","nickname":"Scott","note":"","ucode":"7FC3B7B326C56C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325230,"discussion_content":"读请求缓存未命中，则要把数据加载到缓存中，保证下次读请求的命中，所以要寻找可用的缓存块，然后判断该缓存数据是否脏数据，是的话需要写到磁盘中，最后在从磁盘上加载数据到缓存快中。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605254171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442497,"avatar":"https://static001.geekbang.org/account/avatar/00/16/02/c1/80e68043.jpg","nickname":"停三秒","note":"","ucode":"C9D8F39F24672E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196786,"discussion_content":"同文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583372716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52172,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574000969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142870,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571570037,"is_pvip":false,"replies":[{"id":"55193","content":"这个读缓存想表达的意思是由缓存将数据加载到缓存中的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571577717,"ip_address":"","comment_id":142870,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866537333","product_id":100035801,"comment_content":"Read Through&#47;Write Through...策略的示意图是不是画错了？<br>缓存命中？否----------&gt;读缓存--------------&gt;数据库加载数据到缓存<br>缓存都没有命中，再去读缓存也无法命中啊。中间步骤（读缓存）是不是多余的呢？","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471302,"discussion_content":"这个读缓存想表达的意思是由缓存将数据加载到缓存中的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571577717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141891,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1571245876,"is_pvip":false,"replies":[{"id":"54784","content":"1. 后面有写明<br>2. 是的 但是读后会将缓存标记为不脏，在读多些少的场景下，不会增加很多","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571271667,"ip_address":"","comment_id":141891,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5866213172","product_id":100035801,"comment_content":"你好, 关于Write Back策略:<br>1. Write Back只是说明写的策略, 没有说明读的策略吧?<br>2. 关于&quot;我们在读到缓存数据后,...,如果缓存不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据就好了。&quot;, 如果遇到连续的读操作, 缓存中的数据一直都是&quot;不是脏的&quot;, 并且每次读操作都要&quot;由缓存组件将后端存储中的数据加载到缓存中&quot;, 这样不是增加了缓存与存储之间的读次数吗? ","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470927,"discussion_content":"1. 后面有写明\n2. 是的 但是读后会将缓存标记为不脏，在读多些少的场景下，不会增加很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571271667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193337,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","nickname":"Keith","note":"","ucode":"B40774090714D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35431,"discussion_content":"按上文所述, 一次读请求=1次缓存读操作+1次后端存储读操作+1次缓存写操作, 这在读多写少的情况下为什么&#34;不是增加很多&#34;呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571279310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193337,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","nickname":"Keith","note":"","ucode":"B40774090714D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38655,"discussion_content":"我从两个角度来理解，当然前提还是读多写少。第一个是数据的热点程度，假设你读的东西永远是连续而且不重复那缓存就没有意义了，所有的数据都是一次性使用后就淘汰。第二个是从数据的局部性，像mysql数据在存储和内存之间交换都是按照块（block）为基础单元，连续（范围）读有比较高的概率会命中缓存。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571814131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35431,"ip_address":""},"score":38655,"extra":""},{"author":{"id":1042503,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/47/3e4a03ac.jpg","nickname":"renwotao","note":"","ucode":"8054CA7EC0C8AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90813,"discussion_content":"你说的意思就是命中肯定就不去更新缓存了，只有没有命中才去加载数据到缓存，所以读多写少，命中多时就不会出现太多的加载缓存的事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576797223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":38655,"ip_address":""},"score":90813,"extra":""}]}]},{"had_liked":false,"id":141574,"user_name":"良记","can_delete":false,"product_type":"c1","uid":1033503,"ip_address":"","ucode":"F78CC56BB32D8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/1f/485fcff9.jpg","comment_is_top":false,"comment_ctime":1571193148,"is_pvip":true,"replies":[{"id":"54682","content":"1. 不一样，read&#47;write through是由缓存来写入后端存储，cache aside则都是有应用来负责<br>2. 后面有合适的机会我写一下伪代码","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571196272,"ip_address":"","comment_id":141574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866160444","product_id":100035801,"comment_content":"今天的文章想请教老师2个问题：<br>1、Read &#47; Write Through里边如果用了No-write allocate策略，是不是就是和Cache Aside一样了？<br>2、类似今天这种例子后期会用代码写出来吗？","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470803,"discussion_content":"1. 不一样，read/write through是由缓存来写入后端存储，cache aside则都是有应用来负责\n2. 后面有合适的机会我写一下伪代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571196272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350059,"user_name":"数禾学员5","can_delete":false,"product_type":"c1","uid":2961298,"ip_address":"","ucode":"BA459C465CF577","user_header":"https://static001.geekbang.org/account/avatar/00/2d/2f/92/6b2479a0.jpg","comment_is_top":false,"comment_ctime":1656550678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656550678","product_id":100035801,"comment_content":"Write Back 那一段写的没有看懂，只有我感觉前后矛盾的么？","like_count":0},{"had_liked":false,"id":340467,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1648827260,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648827260","product_id":100035801,"comment_content":"cache aside还是小概率会有并发更新问题<br>这个最终要看使用场景，可以加失效时间<br>如果还不能接受就只能加锁，读写锁","like_count":0},{"had_liked":false,"id":340391,"user_name":"温旭升","can_delete":false,"product_type":"c1","uid":2605923,"ip_address":"","ucode":"12AC469FEB563D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/quaAPZib2arYia7XhUQAd83ribCJlM4CNwCMVicwZqyJL8SCrrKxNf84aXe7GF07rib4TOicTgicw2GjO1lSVMich5Japw/132","comment_is_top":false,"comment_ctime":1648796223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648796223","product_id":100035801,"comment_content":"老师好！另一种方案：在对关系数据库和缓存写操作之前，增加分布式锁控制，确保数据库与缓存的写操作，在一个原子事务下完成。这样保障了数据在关系数据库与缓存中的数据一致性。  这种方案是否常用、可行？又会有什么其它影响？","like_count":0},{"had_liked":false,"id":322630,"user_name":"18610296143","can_delete":false,"product_type":"c1","uid":1067994,"ip_address":"","ucode":"1D4C68E468C871","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/da/c93eaab5.jpg","comment_is_top":false,"comment_ctime":1637505976,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637505976","product_id":100035801,"comment_content":"比如，A 请求将数据库中 ID 为 1 的用户年龄从 19 变更为 20，与此同时，请求 B 也开始更新 ID 为 1 的用户数据，它把数据库中记录的年龄变更为 21，然后变更缓存中的用户年龄为 21。紧接着，A 请求开始更新缓存数据，它会把缓存中的年龄变更为 20。此时，数据库中用户年龄是 21，而缓存中的用户年龄却是 20。<br><br>public void updateSomething(Integer id ){<br>      updateDB(id);<br>      updateCache(id);<br>}<br><br>我的问题是：两个线程并发去修改表中的同一行数据，db会上行锁，谁先获取到锁谁先执行，只有在事务提交之后另外一个线程才能更新数据。那么我理解的应该是一个串行的过程（基于spring开发针对service上的方法开启事务控制），为什么发发生上面的现象呢？","like_count":0},{"had_liked":false,"id":322628,"user_name":"18610296143","can_delete":false,"product_type":"c1","uid":1067994,"ip_address":"","ucode":"1D4C68E468C871","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/da/c93eaab5.jpg","comment_is_top":false,"comment_ctime":1637505293,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1637505293","product_id":100035801,"comment_content":"比如，A 请求将数据库中 ID 为 1 的用户年龄从 19 变更为 20，与此同时，请求 B 也开始更新 ID 为 1 的用户数据，它把数据库中记录的年龄变更为 21，然后变更缓存中的用户年龄为 21。紧接着，A 请求开始更新缓存数据，它会把缓存中的年龄变更为 20。此时，数据库中用户年龄是 21，而缓存中的用户年龄却是 20。<br><br>不知道现在留言，老师还会回复不？","like_count":0,"discussions":[{"author":{"id":1755152,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","nickname":"Info_E","note":"","ucode":"97207B2CC4C776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550672,"discussion_content":"这种情况发生概率很低 你B请求都更新数据库都执行完了，A请求更新缓存还没执行完，这A不行啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644663693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322381,"user_name":"mojo","can_delete":false,"product_type":"c1","uid":1206808,"ip_address":"","ucode":"60F69DF1A9AE3E","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/18/322cf00f.jpg","comment_is_top":false,"comment_ctime":1637333251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637333251","product_id":100035801,"comment_content":"write back策略中，再次使用才会写入后端存储，如果一直不使用难道就不存入后端存储了？那其他例如一些etl后台数据同步工具不是一直拿不到最新数据了？","like_count":0},{"had_liked":false,"id":322092,"user_name":"James","can_delete":false,"product_type":"c1","uid":1036309,"ip_address":"","ucode":"7A0DC75746CB3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/15/c5dc2b0d.jpg","comment_is_top":false,"comment_ctime":1637162157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637162157","product_id":100035801,"comment_content":"你好老师，想问下在Cache Aside模式下，对于A B线程并发引起的缓存不一致怎么解决？加分布式锁吗？我理解如果加分布式锁的话那读线程A在开始请求缓存的时候就需要进行加锁一直要加到读数据后设置缓存成功才释放，这时候B才能获取锁去更改数据库的值，那么这样的话每个读缓存的操作之前都需要获取锁是不是效率就很慢了？","like_count":0},{"had_liked":false,"id":318227,"user_name":"jason","can_delete":false,"product_type":"c1","uid":2680235,"ip_address":"","ucode":"0886E1D88BB7CC","user_header":"https://static001.geekbang.org/account/avatar/00/28/e5/ab/cece3199.jpg","comment_is_top":false,"comment_ctime":1635211012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635211012","product_id":100035801,"comment_content":"老师你好，如果write back策略数据还没落盘，缓存就失效了会咋样","like_count":0},{"had_liked":false,"id":311703,"user_name":"Sic Pavis","can_delete":false,"product_type":"c1","uid":1106088,"ip_address":"","ucode":"48B5F0118347C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","comment_is_top":false,"comment_ctime":1631415779,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1631415779","product_id":100035801,"comment_content":"缓存一致性常规的办法是先DB后删缓存，但除了文中说的并发问题外，还有个问题就是删除缓存的时候失败了。<br>这里列一下我知道的几种处理方案：<br>1. 不处理。 因为缓存一般是有过期时间，相当于在一个过期时间内缓存里的是脏数据，在极少量出现的情况下很多业务是可以容忍的，毕竟成本最低，方案最简单。<br>2. 延时双删。 操作路径是：删缓存-操作数据库-等待一定时间-删缓存。 个人不是很推荐，因为这个方案略复杂，而且还要“等待”这种很僵硬的机制，最关键的是极端场景下也没法解决并发问题。<br>3. 用分布式事务的思想。 可以通过记录本地消息表、消息队列事务消息、或其他分布式事务的解决办法处理，机制很重。不是非常注重缓存一致性的场景，不建议上这么复杂的策略。","like_count":0,"discussions":[{"author":{"id":1108306,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e9/52/aa3be800.jpg","nickname":"Loubobooo","note":"","ucode":"7B2543A80EBDEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557686,"discussion_content":"我也想到了会有删除缓存失败，可以通过重试机制来删除缓存，然后限定重试机制次数，达到缓存过期时间内删除，否则删除不成功也会过期失效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647931532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309577,"user_name":"小写丶H","can_delete":false,"product_type":"c1","uid":1721694,"ip_address":"","ucode":"30DF5C21E23425","user_header":"","comment_is_top":false,"comment_ctime":1630237825,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1630237825","product_id":100035801,"comment_content":"cache aside这种写模式，如果更新数据库成功，删除缓存失败怎么办？","like_count":0,"discussions":[{"author":{"id":2892193,"avatar":"","nickname":"Geek_150bc1","note":"","ucode":"DE5B282AEC4CE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545653,"discussion_content":"是不是需要2 phase commit?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642022074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293575,"user_name":"hello zero","can_delete":false,"product_type":"c1","uid":1028052,"ip_address":"","ucode":"D1F4B2A7D4635B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/d4/59e2bfd4.jpg","comment_is_top":false,"comment_ctime":1621434608,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621434608","product_id":100035801,"comment_content":"老师，cache aside策略，如果更新数据库后，删除缓存失败了，那不是数据也不一致了？","like_count":0},{"had_liked":false,"id":290502,"user_name":"骆驼、","can_delete":false,"product_type":"c1","uid":1443660,"ip_address":"","ucode":"252ECDB1524867","user_header":"https://static001.geekbang.org/account/avatar/00/16/07/4c/f9852f8f.jpg","comment_is_top":false,"comment_ctime":1619593429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619593429","product_id":100035801,"comment_content":"老师，读缓存时，如果缓存不命中，则寻找一个可用的缓存块儿，这个可用是不是指没有数据的缓存块和标记为脏的数据块？如果是“脏”的缓存块，则先将这个 “脏” 数据写入到后端数据库中，然后从后端数据库中获取要读取的数据，并覆盖这个&quot;脏&quot;缓存块中的数据。如果不是“脏”的缓存块，表示这个缓存块中没有数据，直接从后端数据库中读取并写入到这个缓存块。<br>不知道我上面的理解对不对。","like_count":0},{"had_liked":false,"id":290275,"user_name":"大爱无疆","can_delete":false,"product_type":"c1","uid":1064966,"ip_address":"","ucode":"7E219CE450BF47","user_header":"https://static001.geekbang.org/account/avatar/00/10/40/06/bb31933b.jpg","comment_is_top":false,"comment_ctime":1619482854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619482854","product_id":100035801,"comment_content":"如何保证缓存和下层存储一致这个问题，如果保证一致性，应该参考cpu L1级cache一致性解决方案的思路","like_count":0},{"had_liked":false,"id":289835,"user_name":"石头","can_delete":false,"product_type":"c1","uid":2586341,"ip_address":"","ucode":"EB3C9A277C7B0C","user_header":"","comment_is_top":false,"comment_ctime":1619217593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619217593","product_id":100035801,"comment_content":"感觉若干次缓存拿不到回源db没啥影响，可怕的是缓存故障了，所以db要限流，缓存要做高可用，或者有备用的缓存方案。","like_count":0},{"had_liked":false,"id":289233,"user_name":"₯㎕、AmberLavigne","can_delete":false,"product_type":"c1","uid":1699576,"ip_address":"","ucode":"6246705BE0BD87","user_header":"https://static001.geekbang.org/account/avatar/00/19/ee/f8/5222d593.jpg","comment_is_top":false,"comment_ctime":1618927285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618927285","product_id":100035801,"comment_content":"文中说，如果不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据就好了。     不是脏的是指缓存和数据库中值是一致的，怎么会出现后面的说法？","like_count":0},{"had_liked":false,"id":282180,"user_name":"torres","can_delete":false,"product_type":"c1","uid":1108761,"ip_address":"","ucode":"34DABCFC7B74EA","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","comment_is_top":false,"comment_ctime":1615122835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615122835","product_id":100035801,"comment_content":"老师，我想请问一下， Read&#47;Write Through模式是否也像Cache Aside模式一样，会出现数据库和缓存数据不一致的情况？","like_count":0},{"had_liked":false,"id":234192,"user_name":"道","can_delete":false,"product_type":"c1","uid":1324160,"ip_address":"","ucode":"851A0AD751D317","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/80/30e9ae41.jpg","comment_is_top":false,"comment_ctime":1594616761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594616761","product_id":100035801,"comment_content":"文中说到旁路缓存，写比较多的场景可能对缓存命中率影响大，解决方法之一是在更新缓存前加分布式锁。我的疑问是，假如流程是A请求更新数据库，然后B请求也更新数据库统一记录，然后B请求更新缓存，最后A请求更新缓存。分布式锁加载更新缓存前并没有解决并发问题。和旁路策略一样，理论上存在不一致，尽管概率低，缓存读写速度远大于数据库。。。作者的意思是想表达分布式锁家在写数据库前吗，这样更新数据库和缓存才是原子操作","like_count":0},{"had_liked":false,"id":213474,"user_name":"蓝猫","can_delete":false,"product_type":"c1","uid":1128676,"ip_address":"","ucode":"A2E11FF854013C","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/e4/17ffa30b.jpg","comment_is_top":false,"comment_ctime":1588427248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588427248","product_id":100035801,"comment_content":"CacheAside的读写策略出现不一致的概率很低，文中的解释是写缓存的效率比写数据库快很多，我觉得这个理由不太有利，CacheAside策略只是将更新缓存换成了删除缓存而已，怎么就能降低不一致概率，此处不太明白","like_count":0},{"had_liked":false,"id":213241,"user_name":"林腾","can_delete":false,"product_type":"c1","uid":1963793,"ip_address":"","ucode":"8E2438E56BF677","user_header":"","comment_is_top":false,"comment_ctime":1588339399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588339399","product_id":100035801,"comment_content":"老师好，hibernate得一级缓存策略是不是就是读穿&#47;写穿策略？","like_count":0},{"had_liked":false,"id":201573,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1585806487,"is_pvip":false,"replies":[{"id":"75826","content":"一般写write ahead log保证数据一致","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1586087648,"ip_address":"","comment_id":201573,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585806487","product_id":100035801,"comment_content":"对&quot;Write Back&quot;策略，我的理解是，这个策略应对的是写多的场景，但是这个策略会有丢数据的风险；<br>有什么可以落地可以解决丢数据的风险呢？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490366,"discussion_content":"一般写write ahead log保证数据一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586087648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200713,"user_name":"Wiggins","can_delete":false,"product_type":"c1","uid":1078222,"ip_address":"","ucode":"021EE98CF0E4EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/73/ce/23bd3997.jpg","comment_is_top":false,"comment_ctime":1585642520,"is_pvip":false,"replies":[{"id":"75175","content":"没有太关注过，应该实现起来也不难","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1585700463,"ip_address":"","comment_id":200713,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1585642520","product_id":100035801,"comment_content":"老师你好 看了文章很久以后 其实发现write through策略其实更是让业务无感知 那想请问下 有什么好的write through的中间件么","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490112,"discussion_content":"没有太关注过，应该实现起来也不难","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585700463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198502,"user_name":"高科","can_delete":false,"product_type":"c1","uid":1107568,"ip_address":"","ucode":"81A4DDF41D3C1C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/70/b9907b0e.jpg","comment_is_top":false,"comment_ctime":1585454178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585454178","product_id":100035801,"comment_content":"请问Write Back（写回）策略里面提到的缓存块如何实现？","like_count":0},{"had_liked":false,"id":196606,"user_name":"lofaith","can_delete":false,"product_type":"c1","uid":1322553,"ip_address":"","ucode":"5DF6922BBF1AD5","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/39/7682b49e.jpg","comment_is_top":false,"comment_ctime":1585296987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585296987","product_id":100035801,"comment_content":"老师，WriteBack策略中，读的时候，如果没有命中缓存，那么找一个可用的缓存块，这个可用的是怎么找的呢，是找到一个空的缓存块吗，那空的缓存块怎么会有脏不脏呢<br>我的理解是脏的缓存块是有缓存的缓存块，然后把里面的缓存写入数据库，再把这次要查询的数据缓存到这个缓存块里，然后返回数据。<br>不是脏的缓存块就是说这个缓存块是空的，则直接把要查询的数据缓存到这个缓存块里，然后返回数据。<br>但是这样脏的缓存块里面原先的缓存就会失效啊，这个策略还是不太清楚是怎么工作的。","like_count":0},{"had_liked":false,"id":195273,"user_name":"与狼共舞","can_delete":false,"product_type":"c1","uid":1391144,"ip_address":"","ucode":"02AC04B43F0194","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/28/cf707831.jpg","comment_is_top":false,"comment_ctime":1585152451,"is_pvip":false,"replies":[{"id":"75181","content":"用的比较多的还是cache aside","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1585700659,"ip_address":"","comment_id":195273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585152451","product_id":100035801,"comment_content":"第一种比较常见，Write Back（写回）策略这个MySQL应该是用的这个思路，Read&#47;Write Through（读穿 &#47; 写穿）策略这个暂时没用到。","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489012,"discussion_content":"用的比较多的还是cache aside","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585700659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179735,"user_name":"Asha","can_delete":false,"product_type":"c1","uid":1796527,"ip_address":"","ucode":"69F227707A9EDD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/af/ceb4450c.jpg","comment_is_top":false,"comment_ctime":1582085226,"is_pvip":false,"replies":[{"id":"70261","content":"其实很难保证，尤其是客户端做双写的情况。一般是手工删除，或者设置比较小的过期时间","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1582514010,"ip_address":"","comment_id":179735,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582085226","product_id":100035801,"comment_content":"老师你好 这个文章很好的解释了缓存和数据库的一致性问题 那缓存一般都是主从结构的 怎么保证从库和主库的一致性呢","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484373,"discussion_content":"其实很难保证，尤其是客户端做双写的情况。一般是手工删除，或者设置比较小的过期时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582514010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171335,"user_name":"ezekiel","can_delete":false,"product_type":"c1","uid":1158795,"ip_address":"","ucode":"AB4AB6FA8612D8","user_header":"https://static001.geekbang.org/account/avatar/00/11/ae/8b/43ce01ca.jpg","comment_is_top":false,"comment_ctime":1578904072,"is_pvip":false,"replies":[{"id":"67359","content":"缓存时间一般要结合你的业务场景，比如是否频繁更新，缓存容量是怎样的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1579694852,"ip_address":"","comment_id":171335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578904072","product_id":100035801,"comment_content":"老师您好！<br><br>缓存的过期时间，这个一般怎么把握？<br><br>主要考虑哪些方面？能否举个例子？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481300,"discussion_content":"缓存时间一般要结合你的业务场景，比如是否频繁更新，缓存容量是怎样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579694852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171213,"user_name":"吴冬","can_delete":false,"product_type":"c1","uid":1144916,"ip_address":"","ucode":"0ED4314231C536","user_header":"https://static001.geekbang.org/account/avatar/00/11/78/54/eee87a6b.jpg","comment_is_top":false,"comment_ctime":1578882342,"is_pvip":false,"replies":[{"id":"66910","content":"好的，我努力~","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1579228539,"ip_address":"","comment_id":171213,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578882342","product_id":100035801,"comment_content":"老师应该实战和理论很厉害，但好像没能很好的表达出来。从头看到这个位置，给我的感觉有点平淡，亮点不多。希望老师能更好的将实力展现出来","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481263,"discussion_content":"好的，我努力~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579228539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018928,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/30/d642e01a.jpg","nickname":"zhengnachuan","note":"","ucode":"FC6CD65906BE6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327923,"discussion_content":"我觉得从实战开始已经写得很棒了，能学到很多东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606017551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170604,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1578643449,"is_pvip":false,"replies":[{"id":"66142","content":"write back在写入时只标记","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1578668095,"ip_address":"","comment_id":170604,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578643449","product_id":100035801,"comment_content":"write back回写入脏数据时候也是随机同步写入的,只有触发写入 且之前标记为脏才去写一条数据,性能不会比 write through快多少啊","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481037,"discussion_content":"write back在写入时只标记","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578668095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166026,"user_name":"Geek_b617bf","can_delete":false,"product_type":"c1","uid":1220552,"ip_address":"","ucode":"9BAFC3B184B1D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","comment_is_top":false,"comment_ctime":1577366001,"is_pvip":false,"replies":[{"id":"63336","content":"数据有限的情况下可以","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1577417910,"ip_address":"","comment_id":166026,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577366001","product_id":100035801,"comment_content":"我们是直接读缓存，缓存不过期，后台定时任务异步刷新mysql的数据到缓存中。前端不写只读，最大限度的提高qps","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479357,"discussion_content":"数据有限的情况下可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577417910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161604,"user_name":"Cassie","can_delete":false,"product_type":"c1","uid":1309529,"ip_address":"","ucode":"C2426CF07A2AE1","user_header":"https://static001.geekbang.org/account/avatar/00/13/fb/59/20bc2a6d.jpg","comment_is_top":false,"comment_ctime":1576245156,"is_pvip":false,"replies":[{"id":"62234","content":"同时只有一个客户端在更新，不会不一致的吧","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1576756378,"ip_address":"","comment_id":161604,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576245156","product_id":100035801,"comment_content":"1. 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；这个感觉存在数据不一致呀","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477779,"discussion_content":"同时只有一个客户端在更新，不会不一致的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576756378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180963,"discussion_content":"个人觉得，锁是要包含数据库查询+缓存更新操作。@Cassie 是不是理解成了，只有更新缓存的操作才在锁范围内","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582328972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160123,"user_name":"面向加薪学习","can_delete":false,"product_type":"c1","uid":1108117,"ip_address":"","ucode":"5164A1DF058AC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/95/13b88119.jpg","comment_is_top":false,"comment_ctime":1575874948,"is_pvip":false,"replies":[{"id":"61409","content":"会的，不过要看具体的命中率，是否可以接受","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1576117010,"ip_address":"","comment_id":160123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575874948","product_id":100035801,"comment_content":"2. 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。<br><br>老师请教一下，如果时间短，不会不缓存很快过期，反复读数据库？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477264,"discussion_content":"会的，不过要看具体的命中率，是否可以接受","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576117010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159792,"user_name":"退役的球童","can_delete":false,"product_type":"c1","uid":1196234,"ip_address":"","ucode":"CD5157830D9606","user_header":"https://static001.geekbang.org/account/avatar/00/12/40/ca/1313a90b.jpg","comment_is_top":false,"comment_ctime":1575790133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575790133","product_id":100035801,"comment_content":"老师，你好。cache aside策略理论上来说可以有效避免缓存跟数据库的数据不一致问题。但是还是存在客户端读取到的数据与数据库中数据不一致的情况啊。万一客户端会依赖读到的数据做二次运算，这种情况咋处理？","like_count":0},{"had_liked":false,"id":159162,"user_name":"code","can_delete":false,"product_type":"c1","uid":1081312,"ip_address":"","ucode":"4E9776712684F5","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/e0/8eae4cd6.jpg","comment_is_top":false,"comment_ctime":1575550261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575550261","product_id":100035801,"comment_content":"降到最低write back的策略时、针对于一个脏的缓存块，假如有一个读之后，将脏的缓存块标记为不脏，并且将数据存储到数据库内，之后有个新的更新将该缓存块标记为脏块，再次读的情况下是不是又会将之前更新的数据块（之前标记为不脏的）再次更新到数据库，这个数据块的模型麻烦解释一下","like_count":0},{"had_liked":false,"id":158965,"user_name":"刘鹏","can_delete":false,"product_type":"c1","uid":1230417,"ip_address":"","ucode":"44F3D4DB3F5678","user_header":"https://static001.geekbang.org/account/avatar/00/12/c6/51/e39b5828.jpg","comment_is_top":false,"comment_ctime":1575507800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575507800","product_id":100035801,"comment_content":"老师我觉得，缓存策略主要是解决在缓存层的并发问题，导致缓存出现脏数据。数据库的修改操作一定要在缓存前还有一个原因是保证数据库的成功执行","like_count":0},{"had_liked":false,"id":156202,"user_name":"overland","can_delete":false,"product_type":"c1","uid":1208835,"ip_address":"","ucode":"609A463519E5F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/03/da1fcc81.jpg","comment_is_top":false,"comment_ctime":1574835126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574835126","product_id":100035801,"comment_content":"write back 中缓存没数据了，那缓存块还是为脏的吗？断电了缓存数据丢失那块还是保持脏的状态吗，不太明白","like_count":0},{"had_liked":false,"id":154356,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1574413933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574413933","product_id":100035801,"comment_content":"Read Through&#47;Write Through 的流程图中读请求没有命中缓存之后的流程为什么读缓存？<br><br>按照缓存组件代理写数据源的思想，应该都是先去读缓存吧？<br>读缓存-》命中-》返回数据<br>读缓存-》不命中-》加载数据到缓存-》返回数据<br>这样的流程吧？","like_count":0},{"had_liked":false,"id":154278,"user_name":"Luciano李鑫","can_delete":false,"product_type":"c1","uid":1329995,"ip_address":"","ucode":"5FBE5F86FD5B2C","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/4b/97926cba.jpg","comment_is_top":false,"comment_ctime":1574403149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574403149","product_id":100035801,"comment_content":"请问：这里与上面的场景是两种更新策略导致的数据不一致。<br>1. 直接update   amount = 21 <br>2. update amount = amount +1<br>第一种情况会出现 :<br><br>---------------------数据库更新为20<br>         ---------------数据库更新为21<br>         ---------------缓存更新为21<br>---------------------缓存更新为20<br><br>完成一个目标需要两个原子操作，就容易在高并发情况下夹入其他请求完整阶段这种三明治结构。<br><br>第二中情况种情况会出现 :<br>数据库值为20<br>----------------------更新数据库+1 （21）<br>-----------------更新数据库+1 （22）<br>-----------------更新缓存+1 （21）<br>---------------------更新缓存+1 （22）<br><br>请问这种用update amount = amount+1 的方式更新，可以解决数据不一致的情况吗<br>","like_count":0},{"had_liked":false,"id":152390,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1573989521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573989521","product_id":100035801,"comment_content":"Read Through&#47;White Through 策略中。图示左边部分。如果缓存未命中，“读缓存”是否应该改为“读数据库”？因为已知未命中，肯定不需要再去读缓存了。","like_count":0},{"had_liked":false,"id":151290,"user_name":"夏风","can_delete":false,"product_type":"c1","uid":1496195,"ip_address":"","ucode":"EEF37E75FBBA8A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrgpv3Kia5Iw2kmg2rV4PSReiaic8d0Dj93XPlJaNpPRPC2xAIS22PQerSxb0cgjChSGAEOyX4tJBCQ/132","comment_is_top":false,"comment_ctime":1573696185,"is_pvip":false,"replies":[{"id":"58451","content":"你说的事务是数据库事务，其实没有办法协调缓存。这个问题主要是我们无法控制缓存和数据库哪一个先更新","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1573867310,"ip_address":"","comment_id":151290,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573696185","product_id":100035801,"comment_content":"老师，您好，有个问题想确认下哈。关于旁路缓存中的场景问题，是不是要区分下是否支持事务啊，“比方说在你的电商系统中有一个用户表，表中只有 ID 和年龄两个字段，缓存中我们以 ID 为 Key 存储用户的年龄信息。那么当我们要把 ID 为 1 的用户的年龄从 19 变更为 20，要如何做呢？”如果在支持事务的操作中，InnoDB更新一条记录会进行锁行，后面的更新操作需要在事务结束后才会进行更新，如果是同一个执行体，不会存在此问题啊？如果是在非事务，也只有在不同执行体下，更新数据库到更新缓存中间的执行时间不一致才会出现吧？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474426,"discussion_content":"你说的事务是数据库事务，其实没有办法协调缓存。这个问题主要是我们无法控制缓存和数据库哪一个先更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573867310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148804,"user_name":"Fourty Seven","can_delete":false,"product_type":"c1","uid":1323868,"ip_address":"","ucode":"DD213225842F68","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/5c/8c0a372a.jpg","comment_is_top":false,"comment_ctime":1573088989,"is_pvip":false,"replies":[{"id":"57330","content":"是的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1573169889,"ip_address":"","comment_id":148804,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573088989","product_id":100035801,"comment_content":"write back策略，只要数据写到缓存而没有写入数据库就是脏的吧？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473618,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573169889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148165,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1572953477,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1572953477","product_id":100035801,"comment_content":"在write back策略中从左边的流程上来看，这是个死循环吧？！","like_count":0,"discussions":[{"author":{"id":1762252,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e3/cc/0947ff0b.jpg","nickname":"nestle","note":"","ucode":"469800BED81B54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184849,"discussion_content":"不会。如果是脏数据，说明是上一次写的脏数据，把他写回存储，然后再把当前要写的数据写到缓存，并标记为脏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582562833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147609,"user_name":"XD","can_delete":false,"product_type":"c1","uid":1079293,"ip_address":"","ucode":"DC9DCFB3841A4E","user_header":"https://static001.geekbang.org/account/avatar/00/10/77/fd/c6619535.jpg","comment_is_top":false,"comment_ctime":1572872943,"is_pvip":false,"replies":[{"id":"57035","content":"有将缓存数据写入后端存储的操作","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1572938953,"ip_address":"","comment_id":147609,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572872943","product_id":100035801,"comment_content":"关于write back，没有定时刷脏页的机制吗？还是设置一个脏页比例，一旦超过就刷？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473274,"discussion_content":"有将缓存数据写入后端存储的操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572938953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144461,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1571928326,"is_pvip":false,"replies":[{"id":"55689","content":"是可以的呀 可以做成一个组件，不过wal不是很复杂 不知道是否值得","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571960043,"ip_address":"","comment_id":144461,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571928326","product_id":100035801,"comment_content":"老师，WriteBack最大问题是系统崩溃后数据会丢失，一般使用WAL解决。MySQL&#47;HBase等都在用WAL。我在想，既然WAL这么有用，那可不可以做成单独的组件或服务呢？这样，就不用每个用WAL的系统都自己实现了。","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471952,"discussion_content":"是可以的呀 可以做成一个组件，不过wal不是很复杂 不知道是否值得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571960043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143685,"user_name":"hetiu","can_delete":false,"product_type":"c1","uid":1056127,"ip_address":"","ucode":"35D9338C3ABD20","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","comment_is_top":false,"comment_ctime":1571756153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571756153","product_id":100035801,"comment_content":"请问老师用的什么画图工具","like_count":0},{"had_liked":false,"id":142222,"user_name":"jiangjing","can_delete":false,"product_type":"c1","uid":1295268,"ip_address":"","ucode":"D45001E5FB4D6F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibcRNslcyp7dwIR3TIwvloCibMd7Ew2TB3MU0wISFXEolyuHRtfIriagm6PMX5zQHicmc78BrBcxA6vQ5qnTPCev9A/132","comment_is_top":false,"comment_ctime":1571314484,"is_pvip":false,"replies":[{"id":"54921","content":"可以用锁来解决","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571361996,"ip_address":"","comment_id":142222,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571314484","product_id":100035801,"comment_content":"Read&#47;Write Through（读穿 &#47; 写穿）策略，也会产生数据不一致的问题吧？ 如果没有这个问题，解决的思路是锁还是单线程操作呢，比如提到的guava","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471034,"discussion_content":"可以用锁来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571361996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142192,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1571307486,"is_pvip":false,"replies":[{"id":"54918","content":"是可以的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571361795,"ip_address":"","comment_id":142192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571307486","product_id":100035801,"comment_content":"我想问一下，有没有可能类似于加锁的方式解决？<br>假设要更新id1的用户，先把数据锁住，数据库和缓存都更新结束后再允许后续的进程操作。<br>虽然会影响性能，但是自我感觉，如果锁的粒度更细的话，我觉得应该也还好。<br><br>不知道有没有类似的实现。<br>","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471025,"discussion_content":"是可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571361795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141585,"user_name":"Wiggins","can_delete":false,"product_type":"c1","uid":1078222,"ip_address":"","ucode":"021EE98CF0E4EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/73/ce/23bd3997.jpg","comment_is_top":false,"comment_ctime":1571195350,"is_pvip":false,"replies":[{"id":"54788","content":"这里的分布式锁指的是引用层加锁，你想如果两个线程更新数据库和缓存的顺序不同，会产生数据不一致；redis本身的操作是原子的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571271906,"ip_address":"","comment_id":141585,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1571195350","product_id":100035801,"comment_content":"老师你好，请问下Redis不是一个单线程模型么，那么在其中他的分布式锁有什么含义么，不是不会产生锁竞争么？还是只有在集群中Redis的分布式锁有用，如果是单节点的Redis是否就不需要，对这一块一直有疑问。谢谢老师","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470809,"discussion_content":"这里的分布式锁指的是引用层加锁，你想如果两个线程更新数据库和缓存的顺序不同，会产生数据不一致；redis本身的操作是原子的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571271906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34566,"discussion_content":" redis对于需要依赖多个redis操作的实例（多个redis，可以引申为分布式缓存系统）来说，依然需要锁的介入来保证资源访问的正确性，对于单机redis来讲，你用单独的key实现锁机制非常容易，比如setnx，但是对于分布式系统对于某个资源集中访问，就需要通过全局的一个锁来保证，也就是分布式锁，一般redis的分布式锁实现可以用setnx和getset来模拟，也可以用set命令来实现分布式锁，redis中 set key 时的NX 参数可以保证在这个 key 不存在的情况下写入成功。并且再加上 EX 参数可以让该 key 在超时之后自动删除，不清楚的话可以去了解下，但是分布式锁的引入会产生新的问题，比如锁状态获取失败，超时问题等等，你可以把问题这样理解，单机的redis随着业务发展慢慢会变成分布式系统，参与进来的redis成员越多，多个成员如果都想用某个资源，就必要要有特定的介质来维护资源访问，这个介质就是锁，在分布式系统中就是分布式锁。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571206542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141500,"user_name":"Stalary","can_delete":false,"product_type":"c1","uid":1101749,"ip_address":"","ucode":"F69AFF7C958D31","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/b5/d1ec6a7d.jpg","comment_is_top":false,"comment_ctime":1571185750,"is_pvip":false,"replies":[{"id":"54659","content":"可能我没有表述清楚。因为Cache aside会清空缓存，所以会对命中率有影响。<br>那么如果不清空缓存，还要保证一致性，可以在更新数据之前先加分布式锁，同时只有一个线程更新数据，当然这样对写入性能有影响","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571189255,"ip_address":"","comment_id":141500,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1571185750","product_id":100035801,"comment_content":"老师，我没有明白Cache Aside为什么使用分布式锁就解决了问题，这样多个写入同时到达时只有一个能成功写入，也不一定是最后一次的写入成功吧","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470772,"discussion_content":"可能我没有表述清楚。因为Cache aside会清空缓存，所以会对命中率有影响。\n那么如果不清空缓存，还要保证一致性，可以在更新数据之前先加分布式锁，同时只有一个线程更新数据，当然这样对写入性能有影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571189255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282648,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/58/b4f6365d.jpg","nickname":"小北","note":"","ucode":"3A23079E4AA92E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34246,"discussion_content":"其他的请求可以拒绝或者重试","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571187317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34261,"discussion_content":"没获取到锁的请求重试就行了，所有更新缓存的操作都会串行执行，所以会影响更新的性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571188736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141492,"user_name":"stg609","can_delete":false,"product_type":"c1","uid":1073025,"ip_address":"","ucode":"FB70A75A891BB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg","comment_is_top":false,"comment_ctime":1571185279,"is_pvip":false,"replies":[{"id":"54660","content":"我目前还没有看到~","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571189334,"ip_address":"","comment_id":141492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571185279","product_id":100035801,"comment_content":"还想问下老师，既然write back 需要缓存组件的支持能否推荐几个支持该功能的缓存组件？(除了提到的Guava Cache)","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470769,"discussion_content":"我目前还没有看到~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571189334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141491,"user_name":"stg609","can_delete":false,"product_type":"c1","uid":1073025,"ip_address":"","ucode":"FB70A75A891BB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg","comment_is_top":false,"comment_ctime":1571185109,"is_pvip":false,"replies":[{"id":"54655","content":"写的流程是没有问题的，不过没有讲到读的流程，在读流程中会将脏缓存写入持久化存储，我补充一下，谢谢~","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571189067,"ip_address":"","comment_id":141491,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571185109","product_id":100035801,"comment_content":"Write back 策略的图是不是有点问题？如果请求发现是脏的，则最终还是要写缓存，还是标记脏的，那不是一直都是脏的了？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470768,"discussion_content":"写的流程是没有问题的，不过没有讲到读的流程，在读流程中会将脏缓存写入持久化存储，我补充一下，谢谢~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571189067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166476,"discussion_content":"如果请求发现是脏的，则最终还是要写缓存，写缓存后是不需要标记脏的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581399750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}