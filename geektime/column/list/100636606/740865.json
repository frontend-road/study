{"id":740865,"title":"第 4 章 从 Spring Framework 到 Spring Boot(2)","content":"<h2 id=\"nav_point_65\">4.3　自动配置</h2>\n<p>Spring Boot 可以根据 CLASSPATH、配置项等条件自动进行常规配置，省去了我们自己动手把一模一样的配置复制来复制去的麻烦。既然框架能猜到你想这么配，那它自己就能帮你搞定，如果它的配置不是我们想要的，再做些手动配置就好了。</p>\n<p>我们已经在代码示例 1-1 中看到过 <code>@SpringBootApplication</code> 注解了，查看这个注解，可以发现它上面添加了 <code>@EnableAutoConfiguration</code>，它可以开启自动配置功能。这两个注解上都有 <code>exclude</code> 属性，我们可以在其中排除一些不想启用的自动配置类。如果不想启用自动配置功能，也可以在配置文件中配置 <code>spring.boot.enableautoconfiguration=false</code>，关闭该功能。</p>\n<h3 id=\"nav_point_66\">4.3.1　自动配置的实现原理</h3>\n<p>自动配置类其实就是添加了 <code>@Configuration</code> 的普通 Java 配置类，它利用 Spring Framework 4.0 加入的条件注解 <code>@Conditional</code> 来实现“根据特定条件启用相关配置类”，注解中传入的 <code>Condition</code> 类就是不同条件的判断逻辑。Spring Boot 内置了很多条件注解，表 4-2 中列举了 <code>org.springframework.boot.autoconfigure.condition</code> 包中的条件注解。</p>\n<p><strong>表 4-2　Spring Boot 内置的条件注解</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>条件注解</p></th>\n<th><p>生效条件</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>@ConditionalOnBean</code></p></td>\n<td><p>存在特定名称、特定类型、特定泛型参数或带有特定注解的 Bean</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnMissingBean</code></p></td>\n<td><p>与前者相反，不存在特定 Bean</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnClass</code></p></td>\n<td><p>存在特定的类</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnMissingClass</code></p></td>\n<td><p>与前者相反，不存在特定类</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnCloudPlatform</code></p></td>\n<td><p>运行在特定的云平台上，截至 2.6.3 版本，代表云平台的枚举类支持无云平台、CloudFoundry、Heroku、SAP、Kubernetes 和 Azure，可以通过 <code>spring.main.cloud-platform</code> 配置强制使用的云平台</p><!-- [[[read_end]]] --></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnExpression</code></p></td>\n<td><p>指定的 SpEL 表达式为真</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnJava</code></p></td>\n<td><p>运行在满足条件的 Java 上，可以比指定版本新，也可以比指定版本旧</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnJndi</code></p></td>\n<td><p>指定的 JNDI 位置必须存在一个，如没有指定，则需要存在 <code>InitialContext</code></p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnProperty</code></p></td>\n<td><p>属性值满足特定条件，比如给定的属性值都不能为 <code>false</code></p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnResource</code></p></td>\n<td><p>存在特定资源</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnSingleCandidate</code></p></td>\n<td><p>当前上下文中，特定类型的 Bean 有且仅有一个</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnWarDeployment</code></p></td>\n<td><p>应用程序是通过传统的 War 方式部署的，而非内嵌容器</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnWebApplication</code></p></td>\n<td><p>应用程序是一个 Web 应用程序</p></td>\n</tr>\n<tr>\n<td><p><code>@ConditionalOnNotWebApplication</code></p></td>\n<td><p>与前者相反，应用程序不是一个 Web 应用程序</p></td>\n</tr>\n</tbody>\n</table>\n<p>以 <code>@ConditionalOnClass</code> 注解为例，它的定义如下所示，<code>@Target</code> 指明该注解可用于类型和方法定义，<code>@Rentention</code> 指明注解的信息在运行时也能获取到，而其中最关键的就是 <code>OnClassCondition</code> 条件类，里面是具体的条件计算逻辑：</p>\n<pre class=\"code-rows\"><code>@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnClassCondition.class)\npublic @interface ConditionalOnClass {\n    Class&lt;?&gt;[] value() default {};\n    String[] name() default {};\n}</code></pre>\n<p>了解了条件注解后，再来看看它们是如何与配置类结合使用的。以后续章节中会用到的 <code>JdbcTemplateAutoConfiguration</code> 为例，它的完整类定义代码如下所示：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })\n@ConditionalOnSingleCandidate(DataSource.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n@EnableConfigurationProperties(JdbcProperties.class)\n@Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })\npublic class JdbcTemplateAutoConfiguration {}</code></pre>\n<p>可以看到这个配置类的生效条件是存在 <code>DataSource</code> 和 <code>JdbcTemplate</code> 类，且在上下文中只能有一个 <code>DataSource</code>。此外，这个自动配置需要在 <code>DataSourceAutoConfiguration</code> 之后再配置（可以用 <code>@AutoConfigureBefore</code>、<code>@AutoConfigureAfter</code> 和 <code>@AutoConfigureOrder</code> 来控制自动配置的顺序）。这个配置类还会同时导入 <code>JdbcTemplateConfiguration</code> 和 <code>NamedParameterJdbcTemplateConfiguration</code> 里的配置。</p>\n<blockquote>\n<p><strong>茶歇时间：通过 <code>ImportSelector</code> 选择性导入配置</strong></p>\n<p>普通的配置类需要被扫描到才能生效，可是自动配置类并不在我们项目的扫描路径中，它们又是怎么被加载上来的呢？</p>\n<p>秘密在于 <code>@EnableAutoConfiguration</code> 上的 <code>@Import(AutoConfigurationImportSelector.class)</code>，其中的 <code>AutoConfigurationImportSelector</code> 类是 <code>ImportSelector</code> 的实现，这个接口的作用就是根据特定条件决定可以导入哪些配置类，接口中的 <code>selectImports()</code> 方法返回的就是可以导入的配置类名。</p>\n<p><code>AutoConfigurationImportSelector</code> 通过 <code>SpringFactoriesLoader</code> 来加载 <code>/META-INF/spring.factories</code> 里配置的自动配置类列表 <span class=\"comment-number\">14</span>，所用的键是 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>，值是以逗号分隔的自动配置类全限定类名（包含了完整包名与类名）清单。</p>\n<p>所以，只要在我们的类上增加 <code>@SpringBootApplication</code> 或者 <code>@EnableAutoConfiguration</code> 后，Spring Boot 就会自动替我们加载所有的自动配置类。</p>\n</blockquote>\n\n<p>自动配置固然帮我们做了很多事，降低了配置的复杂度，但总有些情况我们会想要强制禁用某些自动配置，这时就需要做以下处理：</p>\n<ul>\n<li>在配置文件中使用 <code>spring.autoconfigure.exclude</code> 配置项，它的值是要排除的自动配置类的全限定类名；</li>\n<li>在 <code>@SpringBootApplication</code> 注解中添加 <code>exclude</code> 配置，它的值是要排除的自动配置类。</li>\n</ul>\n<h3 id=\"nav_point_67\">4.3.2　配置项加载机制详解</h3>\n<p>如果自动配置的东西不满足我们的需要，我们可以自己动手进行配置，但在动手之前，可以先了解下 Spring Boot 的自动配置是否有给我们留下什么“开关参数”，用来定制配置内容。以 AOP 的配置为例，它就可以通过 <code>spring.aop.proxy-target-class</code> 属性来做微调：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@EnableAspectJAutoProxy(proxyTargetClass = false)\n@ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"false\",\n                       matchIfMissing = false)\nstatic class JdkDynamicAutoProxyConfiguration {}\n\n@Configuration(proxyBeanMethods = false)\n@EnableAspectJAutoProxy(proxyTargetClass = true)\n@ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"true\",\n                       matchIfMissing = true)\nstatic class CglibAutoProxyConfiguration {}</code></pre>\n<p>在 2.3.1 节中，我们了解过了 Spring Framework 的 <code>PropertySource</code> 抽象机制，Spring Boot 将它又向前推进了一大步。</p>\n<ol>\n<li><p><strong>Spring Boot 的属性加载优先级</strong></p>\n<p>Spring Boot 有 18 种方式来加载属性 <span class=\"comment-number\">15</span>，且存在覆盖关系，本节根据优先级列出其中的一部分：</p>\n<p>(1) 测试类上的 <code>@TestPropertySource</code> 注解；</p>\n<p>(2) 测试类上的 <code>@SpringBootTest</code> 注解中的 <code>properties</code> 属性，还有些其他 <code>@...Test</code> 注解也有该属性；</p>\n<p>(3) 命令行参数（在 5.3 节中会讨论如何获取命令行参数）；</p>\n<p>(4) <code>java:comp/env</code> 中的 JNDI 属性；</p>\n<p>(5) <code>System.getProperties()</code> 中获取到的系统属性；</p>\n<p>(6) 操作系统环境变量；</p>\n<p>(7) <code>RandomValuePropertySource</code> 提供的 <code>random.*</code> 属性（比如 <code>$</code>、<code>$</code>、<code>$</code> 和 <code>$</code>）；</p>\n<p>(8) 应用配置文件（有好几个地方可以配置，下面会详细说明）；</p>\n<p>(9) 配置类上的 <code>@PropertySource</code> 注解。</p>\n<p>如果存在同名的属性，越往前的位置优先级越高，例如 <code>my.prop</code> 出现在命令行上，又出现在配置文件里，那最终会使用命令行里的值。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Spring Boot 的配置文件</strong></p>\n<p>Spring Boot 还为我们提供了一套配置文件，默认以 <code>application</code> 作为主文件名，支持 Properties 格式（文件以 <code>.properties</code> 结尾）和 YAML<span class=\"comment-number\">16</span> 格式（文件以 <code>.yml</code> 结尾）。Spring Boot 会按如下优先级加载属性（以 <code>.properties</code> 文件为例，<code>.yml</code> 文件的顺序是一样的）：</p>\n<p>(1) 打包后的 Jar 包以外的 <code>application-.properties</code>；</p>\n<p>(2) 打包后的 Jar 包以外的 <code>application.properties</code>；</p>\n<p>(3) Jar 包内部的 <code>application-.properties</code>；</p>\n<p>(4) Jar 包内部的 <code>application.properties</code>。</p>\n<p>可以看到 Jar 包外部的文件比内部的优先级高，特定 Profile 的文件比公共的文件优先级高。</p>\n<p>在 Spring Boot 2.4.0 之前，上述第 2 和第 3 个文件的优先级顺序是反的，所有 application-.properties 文件的顺序都要高于 application.properties，无论是否在 Jar 包外。从 2.4.0 开始，调整为 Jar 包外部的文件优先级更高。可以设置 <code>spring.config.use-legacy-processing=true</code> 来开启兼容逻辑，Spring Boot 3.0 里会移除这个开关。</p>\n<p>Spring Boot 会在如下几处位置寻找 <code>application.properties</code> 文件，并将其中的内容添加到 Spring 的 <code>Environment</code> 中：</p>\n<ul>\n<li>当前目录的 <code>/config</code> 子目录；</li>\n<li>当前目录；</li>\n<li>CLASSPATH 中的 <code>/config</code> 目录；</li>\n<li>CLASSPATH 根目录。</li>\n</ul>\n<p>如果我们不想用 <code>application</code> 来做主文件名，可以通过 <code>spring.config.name</code><span class=\"comment-number\">17</span> 来改变默认值。通过下面的方式可以将 <code>application.properties</code> 改为 <code>spring.properties</code>：</p>\n<pre class=\"code-rows\"><code>▸ java -jar foo.jar --spring.config.name=spring</code></pre>\n<p>还可以通过 <code>spring.config.location</code> 来修改查找配置文件的路径，默认是下面这样的，用逗号分隔，越靠后的优先级越高：</p>\n<pre class=\"code-rows\"><code>classpath:/,classpath:/config/,file:./,file:./config/*/,file:./config/</code></pre>\n<p>如果同时存在 <code>.propertries</code> 文件和 <code>.yml</code> 文件，那么后者中配置的属性优先级更高。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>类型安全的配置属性</strong></p>\n<p>通常，我们会在类中用 <code>@Value(\"${}\")</code> 注解来访问属性，或者在 XML 文件中使用 <code>${}</code> 占位符。在配置中，可能会有大量的属性需要一一对应到类的成员变量上，Spring Boot 提供了一种结构化且类型安全的方式来处理配置属性（configuration properties）——使用 <code>@ConfigurationProperties</code> 注解。</p>\n<p>下面的代码是 <code>DataSourceProperties</code> 类的一部分，这是一个典型的配置属性类（当然，它也是一个 POJO），Spring Boot 会把环境中以 <code>spring.datasource</code> 打头的属性都绑定到类的成员变量上，并且完成对应的类型转换。例如，<code>spring.datasource.url</code> 就会绑定到 <code>url</code> 上。</p>\n<pre class=\"code-rows\"><code>@ConfigurationProperties(prefix = \"spring.datasource\")\npublic class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {\n    private ClassLoader classLoader;\n    private String name;\n    private boolean generateUniqueName = true;\n    private Class&lt;? extends DataSource&gt; type;\n    private String driverClassName;\n    private String url;\n    // 以下省略\n}</code></pre>\n<p>如果为类加上 <code>@ConstructorBinding</code> 注解，还可以通过构造方法完成绑定，不过这种做法相对而言并不常用。</p>\n<p><code>ConfigurationPropertiesAutoConfiguration</code> 自动配置类添加了 <code>@EnableConfigurationProperties</code> 注解，开启了对 <code>@ConfigurationProperties</code> 的支持。我们可以通过添加 <code>@EnableConfigurationProperties (DataSourceProperties.class)</code> 注解这样的方式将绑定后的 <code>DataSourceProperties</code> 注册为 Bean，此时的 Bean 名称为“属性前缀 - 配置类的全限定类名”，例如 <code>spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties</code>；也可以直接用 <code>@Component</code> 注解或其他标准 Bean 配置方式将其注册为 Bean，以供其他 Bean 注入使用。</p>\n<p>除了添加到类上，<code>@ConfigurationProperties</code> 注解也可以被加到带有 <code>@Bean</code> 注解的方法上，这样就能为方法返回的 Bean 对象绑定上下文中的属性了。</p>\n<p>Spring Boot 在绑定属性时非常灵活，几乎可以说怎么写都能绑上，它一共支持四种属性命名形式：</p>\n<ul>\n<li>短横线分隔，推荐的写法，比如 <code>spring.datasource.driver-class-name</code>；</li>\n<li>驼峰式，比如 <code>spring.datasource.driverClassName</code>；</li>\n<li>下划线分隔，比如 <code>spring.datasource.driver_class_name</code>；</li>\n<li>全大写且用下划线分隔，比如 <code>SPRING_DATASOURCE_DRIVERCLASSNAME</code>。</li>\n</ul>\n<p>前三种形式多用于 <code>.properties</code> 文件、<code>.yml</code> 文件和 Java 系统属性的配置方式，第四种则更多出现在系统的环境变量中 <span class=\"comment-number\">18</span>。而 <code>@ConfigurationProperties</code> 中的 <code>prefix</code> 属性只能使用第一种形式。</p>\n</li>\n</ol>\n\n\n\n\n<h2 id=\"nav_point_68\">4.4　编写我们自己的自动配置与起步依赖</h2>\n<p>既然 Spring Boot 为我们提供了这么灵活强大的自动配置与起步依赖功能，那我们是否也可以参考其实现原理，实现专属于自己的自动配置与起步依赖呢？答案是肯定的。不仅如此，我们还可以对实现稍作修改，让它适用于非 Spring Boot 环境，甚至是低版本的 Spring Framework 环境。</p>\n<h3 id=\"nav_point_69\">4.4.1　编写自己的自动配置</h3>\n<p>根据 4.3.1 节的描述，我们很容易就能想到，要编写自己的自动配置，只需要以下三个步骤：</p>\n<p>(1) 编写常规的配置类；</p>\n<p>(2) 为配置类增加生效条件与顺序；</p>\n<p>(3) 在 <code>/META-INF/spring.factories</code> 文件中添加自动配置类。</p>\n<p>从第 4 章的例子开始，我们将正式开始开发二进制奶茶店的代码。作为贯穿全书的案例，它几乎会串联起全书所有的重要知识点，方便大家理解并加深印象。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店新店开张，有很多准备工作要做，因此在尚未做好对外营业的准备时，不能开门迎客。现在，我们需要将具体的准备情况和每天的营业时间信息找个地方统一管理起来，以便合理安排门店的营业工作。</p>\n</blockquote>\n<p>在 Spring Initializr 中，选择新建一个 Spring Boot 2.6.3 版本的 Maven 工程，具体信息如表 4-3 所示。点击生成按钮后，就能获得一个 <code>binarytea.zip</code> 压缩文件，这个文件被解压后即是原始工程。我们将这个工程放在 ch4/binarytea 目录中。</p>\n<p><strong>表 4-3　BinaryTea 的项目信息</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>条目</p></th>\n<th><p>内容</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>项目</p></td>\n<td><p>Maven Project</p></td>\n</tr>\n<tr>\n<td><p>语言</p></td>\n<td><p>Java</p></td>\n</tr>\n<tr>\n<td><p>Spring Boot 版本</p></td>\n<td><p>2.6.3</p></td>\n</tr>\n<tr>\n<td><p>Group</p></td>\n<td><p><code>learning.spring</code></p></td>\n</tr>\n<tr>\n<td><p>Artifact</p></td>\n<td><p><code>binarytea</code></p></td>\n</tr>\n<tr>\n<td><p>名称</p></td>\n<td><p>BinaryTea</p></td>\n</tr>\n<tr>\n<td><p>Java 包名</p></td>\n<td><p><code>learning.spring.binarytea</code></p></td>\n</tr>\n<tr>\n<td><p>打包方式</p></td>\n<td><p>Jar</p></td>\n</tr>\n<tr>\n<td><p>Java 版本</p></td>\n<td><p>11</p></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p><strong>编写配置类并指定条件</strong></p>\n<p>考虑到在 Spring Boot 项目里可以很方便地从配置文件里加载配置，我们可以把具体的准备情况和每天的营业时间都放在配置文件里，通过对应配置项来控制程序的运行逻辑。</p>\n<p>编写一个简单的 <code>ShopConfiguration</code> 类，上面增加了 <code>@Cofiguration</code> 注解，表示这是一个配置类。这个配置类生效的条件是 <code>binarytea.ready</code> 属性的值为 <code>true</code>，也就是店铺已经准备就绪了，除此之外的值或者不存在该属性时 <code>ShopConfiguration</code> 都不会生效。<code>ShopConfiguration</code> 类的代码大致如代码示例 4-2 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-2</strong>　<code>ShopConfiguration</code> 自动配置类定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.config;\n\n// 省略import部分\n\n@Configuration\n@EnableConfigurationProperties(BinaryTeaProperties.class)\n@ConditionalOnProperty(name = \"binarytea.ready\", havingValue = \"true\")\npublic class ShopConfiguration {\n}</code></pre>\n<p>它的作用是创建一个 <code>BinaryTeaProperties</code> 的 Bean，并将就绪状态和营业时间绑定到 Bean 的成员上。<code>BinaryTeaProperties</code> 的代码大致如代码示例 4-3 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-3</strong>　<code>BinaryTeaProperties</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@ConfigurationProperties(\"binarytea\")\npublic class BinaryTeaProperties {\n    private boolean ready;\n    private String openHours;\n    // 省略Getter和Setter\n}</code></pre>\n<p>以 <code>binarytea</code> 打头的属性值会被绑定到 <code>BinaryTeaProperties</code> 的 <code>ready</code> 和 <code>openHours</code> 成员上。例如，<code>application.properties</code> 文件包含如下内容，它们就会被绑定上去：</p>\n<pre class=\"code-rows\"><code>binarytea.ready=true\nbinarytea.open-hours=8:30-22:00</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置 spring.factories 文件</strong></p>\n<p>为了让 Spring Boot 能找到我们写的这个配置类，我们需要在工程的 <code>src/resources</code> 目录中创建 <code>META-INF/spring.factories</code> 文件，其内容如下：</p>\n<pre class=\"code-rows\"><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=learning.spring.config.ShopConfiguration</code></pre>\n<p>由于工程生成的包名是 <code>learning.spring.binarytea</code>，所以默认会扫描这个包下的类。出于演示的目的，我们不希望 Spring Boot 工程自动扫描到 <code>ShopConfiguration</code> 类，所以特意将它放在 <code>learning.spring.config</code> 包中。Spring Boot 的自动配置机制会通过 <code>spring.factories</code> 文件里的配置，找到我们的 <code>ShopConfiguration</code> 类。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>测试</strong></p>\n<p>要测试我们的自动配置是否生效，只要看 Spring 上下文中是否存在 <code>BinaryTeaProperties</code> 类型的 Bean。<code>@SpringBootTest</code> 注解提供了基本的 Spring Boot 工程测试能力，<code>classes</code> 属性的值是该测试类依赖的配置类，<code>properties</code> 属性中以键值对的形式提供了属性配置，代替了在测试文件夹中提供的 <code>application.properties</code>，我们还可以根据测试需要调整属性值。</p>\n<p>如果店铺已经准备好开门营业了，规定每天的营业时间是早 8 点 30 分至晚 10 点，检查整个自动配置功能是否符合预期的测试代码应该如代码示例 4-4 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-4</strong>　<code>ShopConfigurationEnableTest</code> 测试类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.config;\n\n// 省略import部分\n\n@SpringBootTest(classes = BinaryTeaApplication.class, properties = {\n     \"binarytea.ready=true\",\n     \"binarytea.open-hours=8:30-22:00\"\n})\npublic class ShopConfigurationEnableTest {\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Test\n    void testPropertiesBeanAvailable() {\n        assertNotNull(applicationContext.getBean(BinaryTeaProperties.class));\n        assertTrue(applicationContext\n                .containsBean(\"binarytea-learning.spring.binarytea.BinaryTeaProperties\"));\n    }\n\n    @Test\n    void testPropertyValues() {\n        BinaryTeaProperties properties = applicationContext.getBean(BinaryTeaProperties.class);\n        assertTrue(properties.isReady());\n        assertEquals(\"8:30-22:00\", properties.getOpenHours());\n    }\n}</code></pre>\n<p>其中，<code>testPropertiesBeanAvailable()</code> 方法的作用是检查 Spring 上下文中是否存在 <code>BinaryTeaProperties</code> 类型的 Bean，Bean 的名字是否如 4.3.2 节所描述的那样；<code>testPropertyValues()</code> 方法的作用是检查属性内容是否被正确绑定到成员变量中。</p>\n<p>如果店铺还没准备好，那么自动配置类不应该生效。我们可以通过 <code>ShopConfigurationDisableTest</code> 类来测试，其中会检查 <code>binarytea.ready</code> 属性值，并确认上下文中不存在 <code>BinaryTeaProperties</code> 类型的 Bean，具体代码如代码示例 4-5 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-5</strong>　<code>ShopConfigurationDisableTest</code> 测试类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest(classes = BinaryTeaApplication.class, properties = {\n    \"binarytea.ready=false\"\n})\npublic class ShopConfigurationDisableTest {\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Test\n    void testPropertiesBeanUnavailable() {\n        assertEquals(\"false\", applicationContext.getEnvironment().getProperty(\"binarytea.ready\"));\n        assertFalse(applicationContext.containsBean(\"binarytea-learning.spring.binarytea.BinaryTeaProperties\"));\n    }\n}</code></pre>\n<p>算上生成工程时自动生成的 <code>BinaryTeaApplicationTests</code> 类中的 <code>contextLoads()</code> 测试方法，通过 <code>mvn test</code> 命令执行测试后，如果测试全部成功，我们可以看到类似下面的结果：</p>\n<pre class=\"code-rows\"><code>[INFO] Results:\n[INFO]\n[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------</code></pre>\n</li>\n</ol>\n<h3 id=\"nav_point_70\">4.4.2　脱离 Spring Boot 实现自动配置</h3>\n<p>上一节中，我们依赖 Spring Boot 提供的一些能力，实现了一个自动配置类。可是，如果没有 Spring Boot，又该怎么办？甚至出于某些原因，我们要在 Spring Framework 4.<em>x</em> 或者更低的版本上也做些自动配置，又该怎么办呢？</p>\n<p>这里需要解决两个问题：</p>\n<ul>\n<li>如何找到配置类；</li>\n<li>如何实现配置类上的条件。</li>\n</ul>\n<p>第一个问题相对容易解决，只需要根据当前工程的情况进行调整，让我们的配置类位于工程会扫描的包里（比如 <code>@ComponentScan</code> 配置的扫描目标里），或者把我们的配置类追加到工程的扫描范围里。第二个问题则要复杂一些，如果我们用的是 4.<em>x</em> 版本的 Spring Framework，那么它本身就有 <code>@Conditional</code> 注解，我们完全可以按照 Spring Boot 中那些条件注解的实现，按需复制过来；如果用的是 3.<em>x</em> 版本的 Spring Framework，就只能通过自定义 <code>BeanFactoryPostProcessor</code>，根据一定的条件，再决定是否用编程的方式注册 Bean。</p>\n<p>假设我们根据配置来决定 <code>HelloWorld</code> 程序输出的语言种类 <span class=\"comment-number\">19</span>，如代码示例 4-6，在 <code>learning.spring.speaker</code> 包中定义接口与类。</p>\n\n<blockquote>\n<p><strong>代码示例 4-6</strong>　<code>Speaker</code> 接口及其实现代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface Speaker {\n    String speak();\n}\n\npublic class ChineseSpeaker implements Speaker {\n    @Override\n    public String speak() {\n        return \"你好，我爱Spring。\";\n    }\n}\npublic class EnglishSpeaker implements Speaker {\n    @Override\n    public String speak() {\n        return \"Hello, I love Spring.\";\n    }\n}</code></pre>\n<ol>\n<li><p><strong>定义配置类并实现条件判断</strong></p>\n<p>如果工程的 Spring Bean 扫描路径是 <code>learning.spring.helloworld</code>，那就在这个包下放一个配置类，具体如代码示例 4-7 所示，其中创建了 <code>SpeakerBeanFactoryPostProcessor</code>，同时也让容器加载了 <code>application.properties</code> 文件 <span class=\"comment-number\">20</span>。</p>\n<blockquote>\n<p><strong>代码示例 4-7</strong>　用于添加 <code>BeanFactoryPostProcessor</code> 的配置类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@PropertySource(\"classpath:/application.properties\")\npublic class AutoConfiguration {\n    @Bean\n    public static SpeakerBeanFactoryPostProcessor speakerBeanFactoryPostProcessor() {\n        return new SpeakerBeanFactoryPostProcessor();\n    }\n}</code></pre>\n<p><code>SpeakerBeanFactoryPostProcessor</code> 的工作比较多，有如下几种。</p>\n<ul>\n<li>根据 <code>spring.speaker.enable</code> 开关确定是否自动配置 <code>speaker</code> Bean。</li>\n<li>根据 <code>spring.speaker.language</code> 动态确定使用哪个 <code>Speaker</code> 接口的实现。</li>\n<li>将确定的 <code>Speaker</code> 实现注册到 Spring 上下文中。</li>\n</ul>\n<p>具体获取属性进行判断和注册的代码如代码示例 4-8 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-8</strong>　<code>SpeakerBeanFactoryPostProcessor</code> 处理逻辑</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class SpeakerBeanFactoryPostProcessor implements BeanFactoryPostProcessor, EnvironmentAware {\n    private static final Log log = LogFactory.getLog(SpeakerBeanFactoryPostProcessor.class);\n    // 为了获得配置属性，注入Environment\n    private Environment environment;\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        // 获取属性值\n        String enable = environment.getProperty(\"spring.speaker.enable\");\n        String language = environment.getProperty(\"spring.speaker.language\", \"English\");\n        String clazz = \"learning.spring.speaker.\" + language + \"Speaker\";\n\n        // 开关为true则注册Bean，否则结束\n        if (!\"true\".equalsIgnoreCase(enable)) {\n            return;\n        }\n        // 如果目标类不存在，结束处理\n        if (!ClassUtils.isPresent(clazz, SpeakerBeanFactoryPostProcessor.class.getClassLoader())) {\n            return;\n        }\n\n        if (beanFactory instanceof BeanDefinitionRegistry) {\n            registerBeanDefinition((BeanDefinitionRegistry) beanFactory, clazz);\n        } else {\n            registerBean(beanFactory, clazz);\n        }\n    }\n        // 省略其他代码\n}</code></pre>\n<p>代码示例 4-8 的 <code>postProcessBeanFactory()</code> 方法最后，根据 <code>BeanFactory</code> 的类型选择了不同的 Bean 注册方式，实际情况中会更倾向于使用 <code>BeanDefinitionRegistry</code> 来注册 Bean 定义。两种不同的注册方法如代码示例 4-9 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-9</strong>　<code>SpeakerBeanFactoryPostProcessor</code> 中的 Bean 注册逻辑</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class SpeakerBeanFactoryPostProcessor implements BeanFactoryPostProcessor, EnvironmentAware {\n    // 如果是BeanDefinitionRegistry，可以注册BeanDefinition\n    private void registerBeanDefinition(BeanDefinitionRegistry beanFactory, String clazz) {\n        GenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n        beanDefinition.setBeanClassName(clazz);\n        beanFactory.registerBeanDefinition(\"speaker\", beanDefinition);\n    }\n\n    // 如果只能识别成ConfigurableListableBeanFactory，直接注册一个Bean实例\n    private void registerBean(ConfigurableListableBeanFactory beanFactory, String clazz) {\n        try {\n            Speaker speaker = (Speaker) ClassUtils.forName(clazz, SpeakerBeanFactoryPostProcessor.class.\n                                  getClassLoader()).getDeclaredConstructor().newInstance();\n            beanFactory.registerSingleton(\"speaker\", speaker);\n        } catch (Exception e) {\n            log.error(\"Can not create Speaker.\", e);\n        }\n    }\n        // 省略其他代码\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>运行与测试</strong></p>\n<p>为了简化演示工程，假设 <code>learning.spring.helloworld</code> 中是需要运行的代码，我们可以直接在 <code>main()</code> 方法中创建 Spring 上下文，具体如代码示例 4-10 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-10</strong>　<code>Application</code> 类定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@ComponentScan(\"learning.spring.helloworld\")\n    public class Application {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext =\n                new AnnotationConfigApplicationContext(Application.class);\n        Speaker speaker = applicationContext.getBean(\"speaker\", Speaker.class);\n        System.out.println(speaker.speak());\n    }\n}</code></pre>\n<p>配套的 <code>application.properties</code> 文件仅包含两个配置，具体如下：</p>\n<pre class=\"code-rows\"><code>spring.speaker.enable=true\nspring.speaker.language=Chinese</code></pre>\n<p>程序的运行效果就是输出一句中文：</p>\n<pre class=\"code-rows\"><code>你好，我爱Spring。</code></pre>\n<p>如果将 <code>spring.speaker.language</code> 删除，或者改为 <code>English</code>，输出则为英文：</p>\n<pre class=\"code-rows\"><code>Hello, I love Spring.</code></pre>\n<p>与之前一样，我们也提供了基本的测试代码。由于配置内容不同，不同的组合需要我们编写不同的测试类，比如，和上述的运行一样，要求正常输出中文，可以使用代码示例 4-11 的测试代码。</p>\n<blockquote>\n<p><strong>代码示例 4-11</strong>　<code>ChineseAutoConfigurationTest</code> 中文测试类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringJUnitConfig(AutoConfiguration.class)\n@TestPropertySource(properties = {\n    \"spring.speaker.enable=true\",\n    \"spring.speaker.language=Chinese\"\n})\npublic class ChineseAutoConfigurationTest {\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Test\n    void testHasChineseSpeaker() {\n        assertTrue(applicationContext.containsBean(\"speaker\"));\n        Speaker speaker = applicationContext.getBean(\"speaker\", Speaker.class);\n        assertEquals(ChineseSpeaker.class, speaker.getClass());\n    }\n}</code></pre>\n<p><code>@SpringJUnitConfig</code> 注解是 Spring 的测试框架提供的组合注解，可以代替之前看到过的 <code>@ExtendWith(SpringExtension.class)</code>，同时配置一些 Spring 相关的内容。<code>@TestPropertySource</code> 注解可以指定属性文件的位置，也可以直接提供属性键值对。</p>\n<p>如果要关闭开关，则可以像代码示例 4-12 那样。</p>\n<blockquote>\n<p><strong>代码示例 4-12</strong>　<code>DisableAutoConfigurationTest</code> 关闭开关的测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringJUnitConfig(AutoConfiguration.class)\n@TestPropertySource(properties = {\"spring.speaker.enable=false\"})\npublic class DisableAutoConfigurationTest {\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Test\n    void testHasNoSpeaker() {\n        assertFalse(applicationContext.containsBean(\"speaker\"));\n    }\n}</code></pre>\n<p>如果 <code>spring.speaker.language</code> 的值我们不支持，那只需要调整 <code>@TestPropertySource</code> 中提供的属性值，其他测试代码和断言逻辑与 <code>DisableAutoConfigurationTest</code> 完全一样，具体如代码示例 4-13 所示。</p>\n<blockquote>\n<p><strong>代码示例 4-13</strong>　<code>WrongAutoConfigurationTest</code> 错误语言的测试</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringJUnitConfig(AutoConfiguration.class)\n@TestPropertySource(properties = {\n    \"spring.speaker.enable=true\",\n    \"spring.speaker.language=Japanese\"\n})\npublic class WrongAutoConfigurationTest {\n    // 具体代码省略，同DisableAutoConfigurationTest\n}</code></pre>\n<p>在 IDEA 中运行所有这些测试类的效果如图 4-1 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00760.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4-1　IDEA 中的测试运行效果</strong></p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_71\">4.4.3　编写自己的起步依赖</h3>\n<p>在通常情况下，起步依赖主要由两部分内容组成：</p>\n<p>(1) 所需要管理的依赖项；</p>\n<p>(2) 对应功能的自动配置。</p>\n<ol>\n<li><p><strong>依赖项该如何管理</strong></p>\n<p>如 4.2.2 节所述，Spring Boot 的起步依赖本身就是一个 Maven 模块，所以将要管理的依赖项直接放在它的 pom.xml 中即可，即放在 <code>&lt;dependencies/&gt;</code> 中。对于自动配置，我们一般都会单独编写一个模块，把相关自动配置类和 <code>spring.factories</code> 等文件放在一起。前者就是起步依赖自身，即 <code>starter</code> 模块，后者就是 <code>autoconfigure</code> 模块。</p>\n<p>由于 Spring Boot 官方的起步依赖都使用 <code>spring-boot</code> 开头，因而我们的自定义起步依赖需要<strong>避免</strong>使用这个前缀。大家可以根据要实现的功能，或者要引入的内容来设计前缀，后缀使用 <code>-spring-boot-starter</code>，例如 <code>binarytea-spring-boot-starter</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>自动配置模块该如何定义</strong></p>\n<p>在 <code>autoconfigure</code> 模块中一般还会包含所需的属性配置，通常是带有 <code>@ConfigurationProperties</code> 的类，这些属性的前缀最好和 <code>starter</code> 中的保持一致，不要和 Spring Boot 内置的自动配置使用的 <code>spring</code>、<code>server</code> 等前缀混在一起。而 <code>autoconfigure</code> 模块的命名后缀可以使用 <code>-spring-boot-autoconfigure</code>，例如 <code>binarytea-spring-boot-autoconfigure</code>。</p>\n<p>在准备完自动配置模块 <code>binarytea-spring-boot-autoconfigure</code> 后，务必将它也放到 <code>binaryteaspring-boot-starter</code> 的 <code>&lt;dependencies/&gt;</code> 中去，这样就能和其他起步依赖一样，在使用时只需引入 <code>starter</code> 模块就可以了。当然，如果两者的内容都十分简单，也可以将它们合并到一起，直接放到 <code>starter</code> 中。</p>\n<p>顺便再强调一下，起步依赖本身就是一个普通的 Maven 模块，因此无论是否用在 Spring Boot 工程里，它的实现和功能都不会有太大差异。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_72\">4.5　小结</h2>\n<p>本章我们了解了为何在 Spring Framework 已经成为事实行业标准的情况下，Spring 团队仍然孕育出了 Spring Boot 这么一个炙手可热的项目，大有“不用 Spring Boot 就不算开发 Spring 项目”的意思。我们也一同学习了 Spring Boot 中使用最广泛的两个功能——起步依赖与自动配置，了解了它们的基本使用和二者背后的实现原理。在此过程之中，对于 Spring Boot 是如何加载配置项的，它的加载位置与优先级顺序等一系列问题，我们都做了简单的说明。</p>\n<p>章节的最后，大家一起动手解决了几个问题，即如何编写自己的起步依赖与自动配置，还把问题延展了一下：如果没有 Spring Boot 又该如何实现呢？</p>\n<p>下一章，我们会进一步展开说明 Spring Boot 中与生产运行相关的功能，并学习 Spring Boot Actuator、监控与部署相关的一些话题。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>本章我们正式开始搭建二进制奶茶店的示例工程，主要做了两件事：</p>\n<p>(1) 通过 Spring Initializr 初始化了二进制奶茶店的 BinaryTea 工程，完成了项目骨架的搭建；</p>\n<p>(2) 编写了一个读取是否开门营业和营业时间配置的自动配置类。</p>\n<p>这只是整个示例的“第一步”，后续章节中的演示都会基于本章的工程展开。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","comments":[]}