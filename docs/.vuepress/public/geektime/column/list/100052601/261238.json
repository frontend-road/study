{"id":261238,"title":"21 | 开放封闭原则：不改代码怎么写新功能？","content":"<p>你好！我是郑晔。</p><p>上一讲，我们讲了一个最基础的设计原则：单一职责原则，从这个原则中，你知道了一个模块只应该包含来自同一个变化来源的内容。这一讲，我们来看下一个设计原则：开放封闭原则。</p><p>作为一名程序员，来了一个需求就要改一次代码，这种方式我们已经见怪不怪了，甚至已经变成了一种下意识的反应。修改也很容易，只要我们按照之前的惯例如法炮制就好了。</p><p>这是一种不费脑子的做法，却伴随着长期的伤害。每人每次都只改了一点点，但是，经过长期积累，再来一个新的需求，改动量就要很大了。而在这个过程中，每个人都很无辜，因为每个人都只是遵照惯例在修改。但结果是，所有人都受到了伤害，代码越来越难以维护。</p><p>既然“修改”会带来这么多问题，那我们可以不修改吗？开放封闭原则就提供了这样的一个新方向。</p><h2>不修改代码</h2><p>开放封闭原则是这样表述的：</p><blockquote>\n<p>软件实体（类、模块、函数）应该对扩展开放，对修改封闭。</p>\n</blockquote><p>这个说法是Bertrand Meyer在其著作《面向对象软件构造》（Object-Oriented Software Construction）中提出来的，它给软件设计提出了一个极高的要求：不修改代码。</p><p>或许你想问，不修改代码，那我怎么实现新的需求呢？答案就是<strong>靠扩展</strong>。用更通俗的话来解释，就是新需求应该用新代码实现。</p><!-- [[[read_end]]] --><p>开放封闭原则向我们描述的是一个结果，就是我们可以不修改代码而仅凭扩展就完成新功能。但是，这个结果的前提是要在软件内部留好扩展点，而这正是需要我们去设计的地方。因为<strong>每一个扩展点都是一个需要设计的模型。</strong></p><p>举个例子，假如我们正在开发一个酒店预订系统，针对不同的用户，我们需要计算出不同的房价。比如，普通用户是全价，金卡是8折，银卡是9折，代码写出来可能是这样的：</p><pre><code>class HotelService {\n  public double getRoomPrice(final User user, final Room room) {\n    double price = room.getPrice();\n    if (user.getLevel() == Level.GOLD) {\n      return price * 0.8;\n    }\n    \n    if (user.getLevel() == Level.SILVER) {\n      return price * 0.9;\n    }\n    \n    return price;\n  }\n}\n</code></pre><p>这时，新的需求来了，要增加白金卡会员，给出75折的优惠，如法炮制的写法应该是这样的：</p><pre><code>class HotelService {\n  public double getRoomPrice(final User user, final Room room) {\n    double price = room.getPrice();\n    if (user.getLevel() == UserLevel.GOLD) {\n      return price * 0.8;\n    }\n    \n    if (user.getLevel() == UserLevel.SILVER) {\n      return price * 0.9;\n    }\n    \n    if (user.getLevel() == UserLevel.PLATINUM) {\n      return price * 0.75;\n    }\n    \n    return price;\n  }\n}\n</code></pre><p>显然，这种做法就是修改代码的做法，每增加一个新的类型就要修改一次代码。但是，一个有各种级别用户的酒店系统肯定不只是房价有区别，提供的服务也可能有区别。可想而知，每增加一个用户级别，我们要改的代码就漫山遍野。</p><p>那应该怎么办呢？我们应该考虑如何把它设计成一个可以扩展的模型。在这个例子里面，既然每次要增加的是用户级别，而且各种服务的差异都体现在用户级别上，我们就需要一个用户级别的模型。在前面的代码里，用户级别只是一个简单的枚举，我们可以给它丰富一下：</p><pre><code>interface UserLevel {\n  double getRoomPrice(Room room);\n}\n\nclass GoldUserLevel implements UserLevel {\n  public double getRoomPrice(final Room room) {\n    return room.getPrice() * 0.8;\n  }\n}\n\nclass SilverUserLevel implements UserLevel {\n  public double getRoomPrice(final Room room) {\n    return room.getPrice() * 0.9;\n  }\n}\n</code></pre><p>我们原来的代码就可以变成这样：</p><pre><code>class HotelService {\n  public double getRoomPrice(final User user, final Room room) {\n    return user.getRoomPrice(room);\n  }\n}\n\nclass User {\n  private UserLevel level;\n  ...\n  \n  public double getRoomPrice(final Room room) {\n    return level.getRoomPrice(room);\n  }\n}\n</code></pre><p>这样一来，再增加白金用户，我们只要写一个新的类就好了：</p><pre><code>class PlatinumUserLevel implements UserLevel {\n  public double getRoomPrice(final Room room) {\n    return room.getPrice() * 0.75;\n  }\n</code></pre><p>之所以我们可以这么做，是因为我们在代码里留好了扩展点：UserLevel。在这里，我们把原来的只支持枚举值的UserLevel升级成了一个有行为的UserLevel。</p><p>经过这番改造，HotelService的getRoomPrice这个方法就稳定了下来，我们就不需要根据用户级别不断地调整这个方法了。至此，我们就拥有了一个稳定的构造块，可以在后期的工作中把它当做一个稳定的模块来使用。</p><p>当然，在这个例子里，这个方法是比较简单的。而在实际的项目中，业务方法都会比较复杂。</p><h2>构建扩展点</h2><p>好，现在我们已经对开放封闭原则有了一个基本的认识。其实，我们都知道修改是不好的，道理我们都懂，就是在<strong>代码层面</strong>，有人就糊涂了。我做个类比你就知道了，比如说，如果我问你，你正在开发的系统有问题吗？相信大部人的答案都是有。</p><p>那我又问你，那你会经常性主动调整它吗？大部人都不会。为什么呢？因为它在线上运行得好好的，万一我调整它，调整坏了怎么办。是啊！你看，道理就是这么个道理，放在系统层面人人都懂，而在代码层面，却总是习惯性被忽视。</p><p>所以，我们写软件就应该提供一个又一个稳定的小模块，然后，将它们组合起来。一个经常变动的模块必然是不稳定的，用它去构造更大的模块，就是将隐患深埋其中。</p><p>你可能会说，嗯，我懂了，可我还是做不好啊！为什么我们懂了道理后，依旧过不好“这一关”呢？因为<strong>阻碍程序员们构造出稳定模块的障碍，其实是构建模型的能力</strong>。你可以回顾一下前面那段代码，看看让这段代码产生变化的UserLevel是如何升级成一个有行为的UserLevel的。</p><p>在讲封装的时候，我说过，封装的要点是行为，数据只是实现细节，而很多人习惯性的写法是面向数据的，这也是导致很多人在设计上缺乏扩展性思考的一个重要原因。</p><p><strong>构建模型的难点，首先在于分离关注点，这个我们之前说过很多次了，不再赘述，其次在于找到共性</strong>。</p><p>在多态那一讲，我们说过，要构建起抽象就要找到事物的共同点，有了这个理解，我们看前面的例子应该还算容易理解。而在一个业务处理的过程中，发现共性这件事对很多人来说就已经开始有难度了。</p><p>我们再来看个例子，下面是一个常见的报表服务，首先我们取出当天的订单，然后生成订单的统计报表，还要把统计结果发送给相关的人等：</p><pre><code>class ReportService {\n  public void process() {\n    // 获取当天的订单\n    List&lt;Order&gt; orders = fetchDailyOrders();\n    // 生成统计信息\n    OrderStatistics statistics = generateOrderStatistics(orders);\n    // 生成统计报表\n    generateStatisticsReport(statistics);\n    // 发送统计邮件\n    sendStatisticsByMail(statistics);\n  }\n}\n</code></pre><p>很多人在日常工作中写出的代码都是与此类似的，但这个流程肯定是比较僵化的。出现一个新需求就需要调整这段代码。我们这就有一个新需求，把统计信息发给另外一个内部系统，这个内部系统可以把统计信息展示出来，供外部合作伙伴查阅。该怎么做呢？</p><p>我们先分析一下，发送给另一个系统的内容是统计信息，在原有的代码里，前面两步分别是获取源数据和生成统计信息，后面两步分别是，生成报表和将统计信息通过邮件发送出去。</p><p>也就是说，后两步和即将添加的步骤有一个共同点，都使用了统计信息，这样我们就找到了它们的共性，所以，我们就可以用一个共同的模型去涵盖它们，比如，OrderStatisticsConsumer：</p><pre><code>interface OrderStatisticsConsumer {\n  void consume(OrderStatistics statistics);\n}\n\nclass StatisticsReporter implements OrderStatisticsConsumer {\n  public void consume(OrderStatistics statistics) {\n    generateStatisticsReport(statistics);\n  }\n}\n\nclass StatisticsByMailer implements OrderStatisticsConsumer {\n  public void consume(OrderStatistics statistics) {\n    sendStatisticsByMail(statistics);\n  }\n}\n\nclass ReportService {\n  private List&lt;OrderStatisticsConsumer&gt; consumers;\n  \n  void process() {\n    // 获取当天的订单\n    List&lt;Order&gt; orders = fetchDailyOrders();\n    // 生成统计信息\n    OrderStatistics statistics = generateOrderStatistics(orders);\n    \n    for (OrderStatisticsConsumer consumer: consumers) {\n        consumer.consume(statistics);\n    }\n  }\n}\n</code></pre><p>如此一来，我们的新需求也只要添加一个新的类就可以实现了：</p><pre><code>class StatisticsSender implements OrderStatisticsConsumer {\n  public void consume(final OrderStatistics statistics) {\n    sendStatisticsToOtherSystem(statistics);\n  }\n}\n</code></pre><p>你能看出来，在这个例子里，我们第一步做的事情还是分解，就是把一个一个的步骤分开，然后找出步骤之间相似的地方，由此构建出一个新的模型。</p><p>真实项目里的代码可能比这个代码要复杂，但其实，并不一定是业务逻辑复杂，而是代码本身写得复杂了。所以，我们要先根据上一讲的单一职责原则，将不同需求来源引起的变动拆分到不同的方法里，形成一个又一个的小单元，再来做我们这里的分析。</p><p>通过这个例子你也可以看出，在真实的项目中，想要达到开放封闭原则的要求并不是一蹴而就的。这里我们只是因为有了需求的变动，才提取出一个OrderStatisticsConsumer。</p><p>未来可能还会有其他的变动，比如，生成报表的逻辑。到那时，也许我们还会提取出一个新的OrderStatisticsGenerator的接口。但总的来说，我们每做一次这种模型构建，最核心的类就会朝着稳定的方向迈进一步。</p><p>所以，好的设计都会提供足够的扩展点给新功能去扩展。在《Unix 编程艺术》一书中，Unix编程就提倡“提供机制，而不是策略”，这就是开放封闭原则的一种体现。</p><p>同样的，我们知道很多系统是有插件机制的，比如，很多人使用的VIM和Emacs，离我们比较近的还有Eclipse和Visual Studio Code，它们都体现着开放封闭原则。去了解它们的接口，我们就可以看到这个软件给我们提供的各种能力，这也是一种很好的学习方式。</p><p>开放封闭原则还可以帮助我们改进自己的系统，我们可以通过查看自己的源码控制系统，找出那些最经常变动的文件，它们通常都是没有满足开放封闭原则的，而这可以成为我们改进系统的起点。</p><h2>总结时刻</h2><p>今天，我们讲了开放封闭原则，软件实体应该对扩展开放，对修改封闭。简单地说，就是不要修改代码，新的功能要用新的代码实现。</p><p>其实，道理大家都懂，但对很多人来说，做到是有难度的，尤其是在代码里留下扩展点，往往是需要有一定设计能力的。而构建模型的难点，首先就在于分离关注点，其次是找到共性。今天我们也讲了在一个真实项目中，怎样逐步地去构建扩展点，让系统稳定下来。</p><p>很多优秀的软件在设计上都给我们提供了足够的扩展能力，向这些软件的接口学习，我们可以学到更多的东西。</p><p>如果说单一职责原则主要看的还是封装，开放封闭原则就必须有多态参与其中了。显然，要想提供扩展点，就需要面向接口编程。但是，是不是有了接口，就是好的设计了呢？下一讲，我们来看设计一个接口还需要满足什么样的原则。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>设计扩展点，迈向开放封闭原则</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/4a/611dd0fbcf3c87a3de84b457ac6bf44a.jpg?wh=2284*1210\" alt=\"\"></p><h2>思考题</h2><p>最后，我想请你找一个提供了扩展点的开源项目，分析一下它是如何设计这个扩展点的。欢迎在留言区写下你的想法。</p><p>感谢阅读，如果你觉得这一讲的内容对你有帮助的话，也欢迎把它分享给你的朋友。</p>","comments":[{"had_liked":false,"id":234677,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1594772635,"is_pvip":false,"replies":[{"id":"86723","content":"去看看《Unix 编程艺术》，非常值得读的一本好书。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1594864363,"ip_address":"","comment_id":234677,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35954511003","product_id":100052601,"comment_content":"第一个案例感觉就是把user类改成了充血模型，这样确实合理一些，因为价格生成策略因用户不同而不同，同时又加入userlevel类，这样就更职责单一了。<br><br><br>第二个案例从方法命名上就可以看出职责不单一了，连原作者都不知道这个方法干了什么，只好叫“process”这么泛泛的名字。<br><br>Unix那个，是“提供策略，而不是机制”吧，可能记错了，一直搞不清机制和策略是什么意思。<br>","like_count":8,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501462,"discussion_content":"去看看《Unix 编程艺术》，非常值得读的一本好书。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594864363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061005,"avatar":"https://static001.geekbang.org/account/avatar/00/10/30/8d/a2a4e97e.jpg","nickname":"Atong","note":"","ucode":"7E9D4B8D108E4E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305534,"discussion_content":"从字面理解“机制”更像是：告知我有什么样的流程，最终可以完成什么结果。其中有一些环节或内容需要外部参与（当然也可能没有）。  而策略更像是详细的描述事情执行的步骤和方法。\n\n生活点的例子：比如公司的升职晋升机制。(告知外部有表面述职环节，述职通过即加薪。) 这就是机制。机制可以有自己的规范和限定。\n而策略就是具体的述职内容，要由外部来参与。（就如述职人需要具体演讲的内容，不在机制提供的内容。）\n\n\n换成软件范畴应该就更像是:机制是面向接口，提供接口。而策略就是具体的执行类。而机制的限定和规范就是接口的定义。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1599987722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291561,"discussion_content":"看来之前没读懂，得再读一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594867253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237583,"user_name":"桃子-夏勇杰","can_delete":false,"product_type":"c1","uid":1158436,"ip_address":"","ucode":"5D5F38AABA980F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/24/c6b763b4.jpg","comment_is_top":false,"comment_ctime":1595890000,"is_pvip":true,"replies":[{"id":"87768","content":"写出了一种诗意。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595893703,"ip_address":"","comment_id":237583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31660661072","product_id":100052601,"comment_content":"软件系统是变与不变的交融艺术，变化带来发展，不变的是本质，是共性。没有不变的变化只是绚丽的海市蜃楼，透过变化抓住不变，才是抓住了核心与要义。","like_count":8,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502469,"discussion_content":"写出了一种诗意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595893703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235603,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1595123161,"is_pvip":false,"replies":[{"id":"87053","content":"DDD只能帮助你把骨架建起来，其中的细节，还是需要遵循着设计原则进行调整。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595201886,"ip_address":"","comment_id":235603,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31659894233","product_id":100052601,"comment_content":"DDD的思路我觉得比较适合做，难就难到领域建模","like_count":7,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501785,"discussion_content":"DDD只能帮助你把骨架建起来，其中的细节，还是需要遵循着设计原则进行调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595201886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235174,"user_name":"Being","can_delete":false,"product_type":"c1","uid":1152227,"ip_address":"","ucode":"80A8783927B650","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/e3/ed118550.jpg","comment_is_top":false,"comment_ctime":1594913929,"is_pvip":false,"replies":[{"id":"87017","content":"很好的分享！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1595120587,"ip_address":"","comment_id":235174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27364717705","product_id":100052601,"comment_content":"可以简单说下我们公司GIS平台的框架，也是插件的扩展机制。比如对于不同文件的格式解析和保存，抽象出DataSource模型和Saver模型，作为一类数据源注册进插件模块来扩展，而框架则提供类似驱动的能力，由用户组合需要的数据源放入驱动，然后通过驱动，来获得按流程处理后的文件导出。","like_count":7,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501624,"discussion_content":"很好的分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595120587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234702,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1594776166,"is_pvip":false,"replies":[{"id":"86628","content":"非常好的总结！","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1594784117,"ip_address":"","comment_id":234702,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18774645350","product_id":100052601,"comment_content":"1、识别修改点，构建模型，将原来静态的逻辑转为动态的逻辑<br>2、构建模型的难点在于分离关注点，其次就是<br>找到共性<br>","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501476,"discussion_content":"非常好的总结！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594784117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061005,"avatar":"https://static001.geekbang.org/account/avatar/00/10/30/8d/a2a4e97e.jpg","nickname":"Atong","note":"","ucode":"7E9D4B8D108E4E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305535,"discussion_content":"赞，其实再构建完成模型的时候，就可以针对构建出的模型列表，事先评估和假设会存在哪些可能的需求点。面对需求点，现有的模型需要在哪些地方做修改。如果改动大，那表明模型构建的粒度还可以进一步拆分。\n模型的构建也不是一版就成型，总要有一些评估方法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599988045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257896,"user_name":"明","can_delete":false,"product_type":"c1","uid":1607502,"ip_address":"","ucode":"34FF545704EA8A","user_header":"https://static001.geekbang.org/account/avatar/00/18/87/4e/98173974.jpg","comment_is_top":false,"comment_ctime":1604198388,"is_pvip":false,"replies":[{"id":"93905","content":"别说，在不改动这件事上，还真的是异曲同工。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1604241497,"ip_address":"","comment_id":257896,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14489100276","product_id":100052601,"comment_content":"看了两遍 觉得这个开闭原则和函数式编程很搭啊😂😂","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508493,"discussion_content":"别说，在不改动这件事上，还真的是异曲同工。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604241497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240157,"user_name":"PM2","can_delete":false,"product_type":"c1","uid":1276515,"ip_address":"","ucode":"BE80B76C1CA3F1","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/63/487f537e.jpg","comment_is_top":false,"comment_ctime":1596772480,"is_pvip":false,"replies":[{"id":"88725","content":"很好的分享","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1596849106,"ip_address":"","comment_id":240157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14481674368","product_id":100052601,"comment_content":"java的SPI给开发者提供了不错的扩展机制，像spring boot 和dubbo就在此基础上做了改进，各自提供了扩展点，spring boot允许用户自定义starter,dubbo可以自定义协议等","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503357,"discussion_content":"很好的分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596849106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277240,"user_name":"Y丶z","can_delete":false,"product_type":"c1","uid":1195151,"ip_address":"","ucode":"ABACBDD8880AD2","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/8f/acd032f2.jpg","comment_is_top":false,"comment_ctime":1612327928,"is_pvip":false,"replies":[{"id":"100598","content":"工厂模式","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1612340445,"ip_address":"","comment_id":277240,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10202262520","product_id":100052601,"comment_content":"那么用户等级和不同级别的类如何对应起来，用if else吗？","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514970,"discussion_content":"工厂模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612340445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292131,"user_name":"阿姐的阿杰","can_delete":false,"product_type":"c1","uid":1001156,"ip_address":"","ucode":"89F5CF4D1E0C2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c4/128338f8.jpg","comment_is_top":false,"comment_ctime":1620698384,"is_pvip":false,"replies":[{"id":"105805","content":"找到关键点了","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1620778524,"ip_address":"","comment_id":292131,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5915665680","product_id":100052601,"comment_content":"开闭原则之前一直没理解，就在于这个名字翻译过来一点也不直观。今天才意识到应该这么说：“就是不要修改代码，新的功能要用新的代码实现。”。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519694,"discussion_content":"找到关键点了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620778524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250565,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601132915,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5896100211","product_id":100052601,"comment_content":"相对于“对扩展开放，对修改封闭”，我觉的“新需求应该用新代码实现”更容易理解一些。<br><br>在酒店预订系统的例子里面，如果采用枚举方式的 UserLevel 是否可行？又或者采用配置文件的方式，应该也算是对于“扩展开放”。<br><br>如果 UserLevel 只和房价的折扣有关的话，那么应该没问题，如果还有其他的相关选项，可能会麻烦一些。<br><br>文中说“很多人习惯性的写法是面向数据的”，这个估计也是面向数据库编程的由来。<br><br>在第二个例子中，有一个小细节，StatisticsSender 类里面，consume 的参数带了 final 修饰，而之前定义的时候并没有，我觉的应该是前面的代码里面漏掉了吧，毕竟这里的不希望对 statistics 进行任何修改。<br><br>看到留言里面有人说 process 的函数名不好，有同感，但是也想不出什么更好的名字来，reportProcess 也许好一点？<br><br>在代码里留扩展点，可能需要对于业务比较熟悉，知道哪里有可能变化或者扩展；如果缺乏相关知识的话，就只能等需求出来以后再考虑了。比较极端的情况，到处留扩展点，但是最终却没有用到，可能也算过度设计。<br><br>看到 Uncle Bob 的一篇文章，从开闭原则中可以推导出一些 OOD 的其他习惯用法，比如：所有的成员变量都是私有的（private），不使用全局变量，运行时类型识别 RTTI 有风险<br>","like_count":2},{"had_liked":false,"id":246133,"user_name":"hph","can_delete":false,"product_type":"c1","uid":2027011,"ip_address":"","ucode":"83EF84001C3BA9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/ee/03/50b5e0d5.jpg","comment_is_top":false,"comment_ctime":1599186938,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5894154234","product_id":100052601,"comment_content":"在开发一个产品，在基于OPCUA数据采集的基础上，实现数据记录和输出，从功能上看比较简单，但是写代码的时候就有很多的扩展点需要构建模型（比如目标数据库，有sqlserver，oracle等， 条件的配置有时间触发，订阅变量的脚本触发等），由于只有一个人搞，时间就比较长，就经常被催，，，之前我总是说有代码很多，很多模块需要设计，其实就是设计扩展点（之前总是表达不出这个意思），因为一个扩展点的设计不光是接口的设计、每个实现类的编写和加载哪些扩展的定义，在完整的系统中还要有买个扩展的配置界面，以及在配置界面上也是通过扩展的方式将其配置的UI呈现，还有这些扩展的配置结果的工程文件的定义等，催的蛋疼。。。","like_count":2,"discussions":[{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579948,"discussion_content":"扩展点可以延迟到新需求到来在重构，提取出扩展点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657783142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239525,"user_name":"石马","can_delete":false,"product_type":"c1","uid":1128089,"ip_address":"","ucode":"2BB8D16DEE6001","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/99/b4341376.jpg","comment_is_top":false,"comment_ctime":1596554541,"is_pvip":false,"replies":[{"id":"88515","content":"机制应该是引擎吧？","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1596620530,"ip_address":"","comment_id":239525,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5891521837","product_id":100052601,"comment_content":"机制与策略的关系，在我的理解来看，机制就像是车的离合和油门，而策略则是不同的驾驶方式，配合就起来可以完成不同的飘移效果","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503127,"discussion_content":"机制应该是引擎吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596620530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061005,"avatar":"https://static001.geekbang.org/account/avatar/00/10/30/8d/a2a4e97e.jpg","nickname":"Atong","note":"","ucode":"7E9D4B8D108E4E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305536,"discussion_content":"嗯，机制更像是汽车的驱动模型系统。比如需要有引擎子系统，动力控制子系统。策略就是具体的实现方式，比如有(引擎)前驱全驱，(动力控制)手动挡还是自动之类的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599988389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128089,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/99/b4341376.jpg","nickname":"石马","note":"","ucode":"2BB8D16DEE6001","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296706,"discussion_content":"举的例子说得有些片面，应该是整个动力系统会贴切些，有这样的动力系统（不变的机制），配合上多样化的驾驶方式（变化的策略），从而产生不同的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596627848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236701,"user_name":"giteebravo","can_delete":false,"product_type":"c1","uid":1005290,"ip_address":"","ucode":"C087E8D6B5A98B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","comment_is_top":false,"comment_ctime":1595505666,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5890472962","product_id":100052601,"comment_content":"<br>第一个例子不太好理解，<br>第二个就相对容易多了<br>","like_count":1},{"had_liked":false,"id":344642,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1582420,"ip_address":"","ucode":"349FD35822DC8A","user_header":"https://static001.geekbang.org/account/avatar/00/18/25/54/ef2ca14f.jpg","comment_is_top":false,"comment_ctime":1651700538,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651700538","product_id":100052601,"comment_content":"比如说spring boot的自动配置机制: 只需要在spring.factories文件中配置好配置类, 就可以在模块被引入时做好自动配置. ","like_count":0},{"had_liked":false,"id":343548,"user_name":"小凯","can_delete":false,"product_type":"c1","uid":2160395,"ip_address":"","ucode":"4467791346C3ED","user_header":"https://static001.geekbang.org/account/avatar/00/20/f7/0b/403fbeba.jpg","comment_is_top":false,"comment_ctime":1650901280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650901280","product_id":100052601,"comment_content":"第二个例子引入接口后的client代码能够实现和旧代码一样的功能吗？<br>client直接调用consume方法会执行 每一个实现类中的consume方法吗？🤔","like_count":0},{"had_liked":false,"id":340438,"user_name":"laolinshi","can_delete":false,"product_type":"c1","uid":1024994,"ip_address":"","ucode":"269B879389D7D5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/e2/5cb4f43f.jpg","comment_is_top":false,"comment_ctime":1648813591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648813591","product_id":100052601,"comment_content":"java中提供的SPI机制很好的符合了这个设计原则。一个接口对应着多种实现，当有可能以后还需要扩展其他实现的时候，可以把实现类配置在以接口类的完整名称命名的配置文件中，然后在代码中通过JDK提供的ServiceLoader加载配置文件获得所有的实现类，通过逐一调用实现类的方法来执行不同的业务逻辑。系统采用这样的方式实现之后，以后需要添加新的处理逻辑时，只要把新的实现类配置在合适的配置文件中就可以了，调用端的代码不需要做任何的修改。","like_count":0},{"had_liked":false,"id":319031,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1635518622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635518622","product_id":100052601,"comment_content":"面对一堆让人崩溃的代码怎么修改？<br>1. 再苦再累也要为要修改的代码加上自动化测试，这样就不用担心自己把原有功能改坏了<br>2. 应用已掌握的设计模式重构代码<br>3. 自动化测试验证<br><br>能不能好好过年，就看自动化测试 + 重构了","like_count":0},{"had_liked":false,"id":313791,"user_name":"cz","can_delete":false,"product_type":"c1","uid":1008468,"ip_address":"","ucode":"96385190176F78","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/54/c9475cd0.jpg","comment_is_top":false,"comment_ctime":1632667119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632667119","product_id":100052601,"comment_content":"第二个例子不错","like_count":0},{"had_liked":false,"id":303202,"user_name":"呆呆狗的兽","can_delete":false,"product_type":"c1","uid":2404924,"ip_address":"","ucode":"B7D445F3BE2E4C","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/3c/22028324.jpg","comment_is_top":false,"comment_ctime":1626662846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626662846","product_id":100052601,"comment_content":"上面例子中UserLevel那个例子，可以用枚举呀，枚举里写抽象方法，各自等级再去实现，不然新建类太浪费了，比如用户等级有上十个左右，什么公候伯子男爵等，等那天每个等级特定的相关逻辑多起来的时候 比如大于3个功能（方法）的时候，可以考虑重构为接口和实现类，那时候因为功能多起来了逻辑也更丰富（复杂）了，是值得的 否则直接枚举写方法搞定，而且很重要的一点是userLevel使用的时候还是要创建对象的，而枚举自身在项目启动时已经每一项都是对象了（当然枚举对象的大括号里要是写成员变量啥的，得考虑并发情况）","like_count":1},{"had_liked":false,"id":269690,"user_name":"vplus","can_delete":false,"product_type":"c1","uid":1474072,"ip_address":"","ucode":"19A014336C1E40","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/18/9b9c373b.jpg","comment_is_top":false,"comment_ctime":1608737604,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1608737604","product_id":100052601,"comment_content":"两个例子都是将处理动作抽象出来形成一个接口，需要进行这个处理动作的类实现这个接口，每个类用不同的处理方法完成这个处理动作。","like_count":0,"discussions":[{"author":{"id":1474072,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/18/9b9c373b.jpg","nickname":"vplus","note":"","ucode":"19A014336C1E40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337037,"discussion_content":"所以每次增加修改功能，增加修改的都是独立的类，而不是一个包含所有动作的巨型方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608777778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268022,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1608032353,"is_pvip":false,"replies":[{"id":"97476","content":"改能改得好，才是有价值的。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1608251893,"ip_address":"","comment_id":268022,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608032353","product_id":100052601,"comment_content":"不是不让改代码，是不建议无设计的一团麻if else改代码，类内部膨胀，可读性，可维护性都不高。绝不再在类内部写硬代码，常量都抽取到配置文件去读取，拒绝硬代码！","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511818,"discussion_content":"改能改得好，才是有价值的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608251893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255825,"user_name":"Janenesome","can_delete":false,"product_type":"c1","uid":1276572,"ip_address":"","ucode":"15D2673CC31D9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/9c/a4bc748d.jpg","comment_is_top":false,"comment_ctime":1603439726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603439726","product_id":100052601,"comment_content":"找出变与不变、变的部分抽象出共性。<br><br>我之前使用多态优化，最好找的就是各种 if-else 条件这个优化点。文章第二个案例的确很实用，因为我现在的代码就是这样的哈哈，以后看到同样的入参就的想下是不是能抽象出来。","like_count":1}]}