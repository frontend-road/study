{"id":737438,"title":"07｜对内的保护：引入门面模式封装内部实现类","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>在前面的学习内容中，我们为了符合Servlet规范，新增了HttpRequest与HttpResponse类，但截止到现在我们只对Request请求相关的代码进行了实现，所以这节课我们就来改造Response返回代码。</p><p>另外，我们也注意到，在HttpProcessor类里，我们直接使用的是HttpRequest与HttpResponse，这两个对象要传入Servlet里，但在这两个类中我们也定义了许多内部的方法，一旦被用户知晓我们的实现类，那么这些内部方法就暴露在用户面前了，这是我们不愿看到的，也是我们需要规避的。因此这节课我们计划用门面（Facade）设计模式来解决这个问题。</p><p>下面就让我们一起来动手实现。</p><h2>项目结构</h2><p>这节课的项目结构主要新增了HttpRequestFacade.java与HttpResponseFacade.java两个类，如下所示：</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpHeader.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpRequest.java\n│  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  ├─ HttpResponse.java\n│  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><h2>Response返回信息解析</h2><p>上一节课我们完成了Request请求信息解析，有了前文铺垫，接下来针对Response的改造就容易很多了。</p><p>我们在前面提到过，HTTP协议中规定Response返回格式由以下几部分组成：状态行、响应头、空行、响应体。我们常用的状态码一般为200、401、404、500、503、504等，我们在HttpResponse里用switch条件语句先关联常用的状态码与状态信息。</p><pre><code class=\"language-java\">package server;\npublic class HttpResponse implements HttpServletResponse {\n  protected String getStatusMessage(int status) {\n    switch (status) {\n        case SC_OK:\n            return (\"OK\");\n        case SC_ACCEPTED:\n            return (\"Accepted\");\n        case SC_BAD_GATEWAY:\n            return (\"Bad Gateway\");\n        case SC_BAD_REQUEST:\n            return (\"Bad Request\");\n        case SC_CONTINUE:\n            return (\"Continue\");\n        case SC_FORBIDDEN:\n            return (\"Forbidden\");\n        case SC_INTERNAL_SERVER_ERROR:\n            return (\"Internal Server Error\");\n        case SC_METHOD_NOT_ALLOWED:\n            return (\"Method Not Allowed\");\n        case SC_NOT_FOUND:\n            return (\"Not Found\");\n        case SC_NOT_IMPLEMENTED:\n            return (\"Not Implemented\");\n        case SC_REQUEST_URI_TOO_LONG:\n            return (\"Request URI Too Long\");\n        case SC_SERVICE_UNAVAILABLE:\n            return (\"Service Unavailable\");\n        case SC_UNAUTHORIZED:\n            return (\"Unauthorized\");\n        default:\n            return (\"HTTP Response Status \" + status);\n    }\n}\n</code></pre><p>其中定义的状态常量都来自HttpServletResponse里的定义。<br>\n接下来我们关注头部信息的操作，使用headers这样一个concurrentHashMap存储头部的键值信息，里面是content-length和content-type的时候，我们还会设置相关属性。代码如下：</p><pre><code class=\"language-java\">public class HttpResponse implements HttpServletResponse {\n    Map&lt;String, String&gt; headers = new ConcurrentHashMap&lt;&gt;();\n    @Override\n    public void addHeader(String name, String value) {\n        headers.put(name, value);\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_LENGTH_NAME) {\n            setContentLength(Integer.parseInt(value));\n        }\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_TYPE_NAME) {\n            setContentType(value);\n        }\n    }\n    \n    @Override\n    public void setHeader(String name, String value) {\n        headers.put(name, value);\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_LENGTH_NAME) {\n            setContentLength(Integer.parseInt(value));\n        }\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_TYPE_NAME) {\n            setContentType(value);\n        }\n    }\n}\n</code></pre><p>有了内部的头部信息，我们还会提供一个sendHeaders方法，按照HTTP协议的规定拼接，包含状态行、头信息和空行，将Header打印出来，如下所示：</p><pre><code class=\"language-java\">public void sendHeaders() throws IOException {\n    PrintWriter outputWriter = getWriter();\n    //下面这一端是输出状态行\n    outputWriter.print(this.getProtocol());\n    outputWriter.print(\" \");\n    outputWriter.print(status);\n    if (message != null) {\n        outputWriter.print(\" \");\n        outputWriter.print(message);\n    }\n    outputWriter.print(\"\\r\\n\");\n    \n    if (getContentType() != null) {\n        outputWriter.print(\"Content-Type: \" + getContentType() + \"\\r\\n\");\n    }\n    if (getContentLength() &gt;= 0) {\n        outputWriter.print(\"Content-Length: \" + getContentLength() + \"\\r\\n\");\n    }\n    \n    //输出头信息\n    Iterator&lt;String&gt; names = headers.keySet().iterator();\n    while (names.hasNext()) {\n        String name = names.next();\n        String value = headers.get(name);\n        outputWriter.print(name);\n        outputWriter.print(\": \");\n        outputWriter.print(value);\n        outputWriter.print(\"\\r\\n\");\n    }\n    \n    //最后输出空行\n    outputWriter.print(\"\\r\\n\");\n    outputWriter.flush();\n}\n</code></pre><p>完整的HttpResponse改造如下，由于代码太长，其中非关键的实现方法就不列在这里了。</p><pre><code class=\"language-java\">package server;\npublic class HttpResponse implements HttpServletResponse {\n    HttpRequest request;\n    OutputStream output;\n    PrintWriter writer;\n    String contentType = null;\n    long contentLength = -1;\n    String charset = null;\n    String characterEncoding = null;\n    String protocol = \"HTTP/1.1\";\n    //headers是一个保存头信息的map\n    Map&lt;String, String&gt; headers = new ConcurrentHashMap&lt;&gt;();\n    //默认返回OK\n    String message = getStatusMessage(HttpServletResponse.SC_OK);\n    int status = HttpServletResponse.SC_OK;\n    \n    public HttpResponse(OutputStream output) {\n        this.output = output;\n    }\n    public void setRequest(HttpRequest request) {\n        this.request = request;\n    }\n    //状态码以及消息文本，没有考虑国际化\n    protected String getStatusMessage(int status) {\n        switch (status) {\n            case SC_OK:\n                return (\"OK\");\n            case SC_ACCEPTED:\n                return (\"Accepted\");\n            case SC_BAD_GATEWAY:\n                return (\"Bad Gateway\");\n            case SC_BAD_REQUEST:\n                return (\"Bad Request\");\n            case SC_CONTINUE:\n                return (\"Continue\");\n            case SC_FORBIDDEN:\n                return (\"Forbidden\");\n            case SC_INTERNAL_SERVER_ERROR:\n                return (\"Internal Server Error\");\n            case SC_METHOD_NOT_ALLOWED:\n                return (\"Method Not Allowed\");\n            case SC_NOT_FOUND:\n                return (\"Not Found\");\n            case SC_NOT_IMPLEMENTED:\n                return (\"Not Implemented\");\n            case SC_REQUEST_URI_TOO_LONG:\n                return (\"Request URI Too Long\");\n            case SC_SERVICE_UNAVAILABLE:\n                return (\"Service Unavailable\");\n            case SC_UNAUTHORIZED:\n                return (\"Unauthorized\");\n            default:\n                return (\"HTTP Response Status \" + status);\n        }\n    }\n    public void sendHeaders() throws IOException {\n        PrintWriter outputWriter = getWriter();\n        //下面这一端是输出状态行\n        outputWriter.print(this.getProtocol());\n        outputWriter.print(\" \");\n        outputWriter.print(status);\n        if (message != null) {\n            outputWriter.print(\" \");\n            outputWriter.print(message);\n        }\n        outputWriter.print(\"\\r\\n\");\n        if (getContentType() != null) {\n            outputWriter.print(\"Content-Type: \" + getContentType() + \"\\r\\n\");\n        }\n        if (getContentLength() &gt;= 0) {\n            outputWriter.print(\"Content-Length: \" + getContentLength() + \"\\r\\n\");\n        }\n        //输出头信息\n        Iterator&lt;String&gt; names = headers.keySet().iterator();\n        while (names.hasNext()) {\n            String name = names.next();\n            String value = headers.get(name);\n            outputWriter.print(name);\n            outputWriter.print(\": \");\n            outputWriter.print(value);\n            outputWriter.print(\"\\r\\n\");\n        }\n        //最后输出空行\n        outputWriter.print(\"\\r\\n\");\n        outputWriter.flush();\n    }\n    @Override\n    public String getCharacterEncoding() {\n        return this.characterEncoding;\n    }\n    @Override\n    public String getContentType() {\n        return this.contentType;\n    }\n    @Override\n    public PrintWriter getWriter() throws IOException {\n        writer = new PrintWriter(new OutputStreamWriter(output, getCharacterEncoding()), true);\n        return writer;\n    }\n    @Override\n    public void setCharacterEncoding(String arg0) {\n        this.characterEncoding = arg0;\n    }\n    @Override\n    public void setContentType(String arg0) {\n        this.contentType = arg0;\n    }\n    @Override\n    public void addHeader(String name, String value) {\n        headers.put(name, value);\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_LENGTH_NAME) {\n            setContentLength(Integer.parseInt(value));\n        }\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_TYPE_NAME) {\n            setContentType(value);\n        }\n    }\n    @Override\n    public String getHeader(String name) {\n        return headers.get(name);\n    }\n    @Override\n    public Collection&lt;String&gt; getHeaderNames() {\n        return headers.keySet();\n    }\n    public void setHeader(String name, String value) {\n        headers.put(name, value);\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_LENGTH_NAME) {\n            setContentLength(Integer.parseInt(value));\n        }\n        if (name.toLowerCase() == DefaultHeaders.CONTENT_TYPE_NAME) {\n            setContentType(value);\n        }\n    }\n\n</code></pre><h2>Processor中的改造</h2><p>修改完response之后，自然地，我们在HttpProcessor中，将原来引用或初始化Response类的地方，全部用HttpResponse替代。</p><pre><code class=\"language-java\">HttpProcessor.java\n&nbsp; // create Response object\n&nbsp; HttpResponse response = new HttpResponse(output);\n&nbsp; response.setRequest(request);\n</code></pre><p>ServletProcessor类process代码如下：</p><pre><code class=\"language-java\">public class ServletProcessor {\n    public void process(HttpRequest request, HttpResponse response) {\n        String uri = request.getUri();\n        String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n        URLClassLoader loader = null;\n        try {\n            // create a URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            //这个URLClassloader的工作目录设置在HttpServer.WEB_ROOT\n            File classPath = new File(HttpServer.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        }\n        catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n        //response默认为UTF-8编码\n        response.setCharacterEncoding(\"UTF-8\");\n        Class&lt;?&gt; servletClass = null;\n        try {\n            servletClass = loader.loadClass(servletName);\n        }\n        catch (ClassNotFoundException e) {\n            System.out.println(e.toString());\n        }\n        //回写头信息\n        try {\n            response.sendHeaders();\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        }\n        //创建servlet新实例，调用service()\n        Servlet servlet = null;\n        try {\n            servlet = (Servlet) servletClass.newInstance();\n            servlet.service(request, response);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n    }\n}\n</code></pre><p>在此我们完成了HttpRequest与HttpResponse的替换。</p><h2>Facade模式的应用</h2><p>现在有一个问题需要我们解决：我们直接使用的是HttpRequest与HttpResponse，这两个对象要传入Servlet中，但在这两个类中我们也定义了许多内部的方法，一旦被用户知晓我们的实现类，则这些内部方法就暴露在用户面前了。</p><p>这样其实是不好的。面向对象编程的思想，是将内部实现的结构和复杂性包装在一层壳里面，能不对外暴露就不要对外暴露。作为客户程序，最好只知道最小知识集。另外，这个Request和Response类是要传给外部的Servlet程序的，跳出了Tomcat本身，如果这个写Servlet的程序员他知道传的这个类里面有一些额外的方法，原理上他可以进行强制转换之后调用，这样也不是很安全。</p><p>接下来我们看看如何使用门面设计模式，规避上述问题。</p><p>先解释一下Facade模式，Facade这个词来自于建筑学，字面意思是“立面”，就是我们在大街上看到的门面。门面把建筑的内部结构包装起来给人们展示了一个新的友好的有特色的外观。软件中用同样的手法，将软件的内部结构进行包装，对外用简单的API供人使用。</p><p>下面是Facade的结构图：</p><p><img src=\"https://static001.geekbang.org/resource/image/80/45/807b51e8b4d226b68e01aca29f121545.png?wh=1920x1229\" alt=\"图片\"></p><p>看上图，本来一个软件中有几个类，一个类里面有一堆方法，给外面的client程序直接用会增添很多复杂性而且不安全，于是中间加了一层Facade，提供一个简单的doSomething()方法。这样对使用者来说很简单方便，也便于内部结构的调整，未来需要改动内部实现的时候，因为有这个Facade存在，所以并不需要改动对外的接口。</p><p>Facade类是一个新类，外部使用者没法根据它来强制转换获得内部的结构和方法，这样将实际实现的几个类保护起来了，提高了安全性。这正是我们现在在处理Request和Response的时候所希望看到的。我们按照这个思路写自己的Facade。</p><p>首先定义HttpRequestFacade与HttpResponseFacade，分别实现HttpServletRequest与HttpServletResponse。你可以看一下我给出的代码主体部分，大部分都是直接转到request和response里面的相应调用，完整代码就不一一展示了，你可以看最后的Gitee链接。</p><p>HttpRequestFacade.java：</p><pre><code class=\"language-java\">package server;\npublic class HttpRequestFacade implements HttpServletRequest {\n    private HttpServletRequest request;\n    public HttpRequestFacade(HttpRequest request) {\n        this.request = request;\n    }\n    /* implementation of the HttpServletRequest*/\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n    public Enumeration getAttributeNames() {\n        return request.getAttributeNames();\n    }\n    public String getCharacterEncoding() {\n        return request.getCharacterEncoding();\n    }\n    public int getContentLength() {\n        return request.getContentLength();\n    }\n    public String getContentType() {\n        return request.getContentType();\n    }\n    public Cookie[] getCookies() {\n        return request.getCookies();\n    }\n    public Enumeration getHeaderNames() {\n        return request.getHeaderNames();\n    }\n    public String getHeader(String name) {\n        return request.getHeader(name);\n    }\n    public Enumeration getHeaders(String name) {\n        return request.getHeaders(name);\n    }\n    public ServletInputStream getInputStream() throws IOException {\n        return request.getInputStream();\n    }\n    public int getIntHeader(String name) {\n        return request.getIntHeader(name);\n    }\n    public String getMethod() {\n        return request.getMethod();\n    }\n    public String getParameter(String name) {\n        return request.getParameter(name);\n    }\n    public Map getParameterMap() {\n        return request.getParameterMap();\n    }\n    public Enumeration getParameterNames() {\n        return request.getParameterNames();\n    }\n    public String[] getParameterValues(String name) {\n        return request.getParameterValues(name);\n    }\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n    public BufferedReader getReader() throws IOException {\n        return request.getReader();\n    }\n    public String getRequestURI() {\n        return request.getRequestURI();\n    }\n    public StringBuffer getRequestURL() {\n        return request.getRequestURL();\n    }\n    public HttpSession getSession() {\n        return request.getSession();\n    }\n    public HttpSession getSession(boolean create) {\n        return request.getSession(create);\n    }\n    public void removeAttribute(String attribute) {\n        request.removeAttribute(attribute);\n    }\n    public void setAttribute(String key, Object value) {\n        request.setAttribute(key, value);\n    }\n    public void setCharacterEncoding(String encoding) throws UnsupportedEncodingException {\n        request.setCharacterEncoding(encoding);\n    }\n}\n</code></pre><p>HttpResponseFacade.java类主体定义如下：</p><pre><code class=\"language-java\">package server;\n\npublic class HttpResponseFacade implements HttpServletResponse {\n    private HttpServletResponse response;\n    public HttpResponseFacade(HttpResponse response) {\n        this.response = response;\n    }\n    public void addDateHeader(String name, long value) {\n        response.addDateHeader(name, value);\n    }\n    public void addHeader(String name, String value) {\n        response.addHeader(name, value);\n    }\n    public boolean containsHeader(String name) {\n        return response.containsHeader(name);\n    }\n    public String encodeUrl(String url) {\n        return response.encodeUrl(url);\n    }\n    public String encodeURL(String url) {\n        return response.encodeURL(url);\n    }\n    public void flushBuffer() throws IOException {\n        response.flushBuffer();\n    }\n    public String getCharacterEncoding() {\n        return response.getCharacterEncoding();\n    }\n    @Override\n    public String getContentType() {\n        return null;\n    }\n    @Override\n    public void setCharacterEncoding(String s) {\n    }\n    public void setContentLength(int length) {\n        response.setContentLength(length);\n    }\n    public void setContentType(String type) {\n        response.setContentType(type);\n    }\n    public void setHeader(String name, String value) {\n        response.setHeader(name, value);\n    }\n    public ServletOutputStream getOutputStream() throws IOException {\n        return response.getOutputStream();\n    }\n    @Override\n    public PrintWriter getWriter() throws IOException {\n        return response.getWriter();\n    }\n    @Override\n    public void addCookie(Cookie arg0) {\n        response.addCookie(arg0);\n    }\n    @Override\n    public String getHeader(String arg0) {\n        return response.getHeader(arg0);\n    }\n    @Override\n    public Collection&lt;String&gt; getHeaderNames() {\n        return response.getHeaderNames();\n    }\n    @Override\n    public Collection&lt;String&gt; getHeaders(String arg0) {\n        return response.getHeaders(arg0);\n    }\n}\n</code></pre><p>在此两个Facade就定义完毕了，前面我们也说过，我们要做的是向Servlet传入参数时规避内部方法，而Facade的作用就是封装不希望暴露的方法，更深层的内部方法不予展示。因而在ServletProcessor中，Servlet调用service时我们传入HttpRequestFacade与HttpResponseFacade，你可以看一下需要调整的部分代码。</p><pre><code class=\"language-java\">ServletProcessor.java\n\nServlet servlet = null;\n//调用servlet的service()方法时传入的是Facade对象\ntry {\n    servlet = (Servlet) servletClass.newInstance();\n    HttpRequestFacade requestFacade = new HttpRequestFacade(request);\n    HttpResponseFacade responseFacade = new HttpResponseFacade(response);\n    servlet.service(requestFacade, responseFacade);\n}\n\n</code></pre><p>这样在Servlet中，我们看到的只是Facade，看不见内部方法，应用程序员想进行强制转化也不行，这样既简单又安全。</p><p>还有，按照Servlet的规范，客户自定义的Servlet是要继承HttpServlet的，在调用的service方法内，它的实际行为是通过method判断调用的是哪一个方法，如果是Get方法就调用doGet()，如果是Post方法调用的就是doPost()，其他的方法也是一样的道理。</p><p>所以在我们自定义的HttpRequest里，一定要实现getMethod方法，我们来调整一下。</p><pre><code class=\"language-java\">package server;\npublic class HttpRequest implements HttpServletRequest{\n    @Override\n    public String getMethod() {\n      return new String(this.requestLine.method, 0, this.requestLine.methodEnd);\n    }\n}\n</code></pre><p>这样做可以简化客户程序，让业务程序员写Servlet的时候只需要重载doGet()或doPost()方法即可。</p><p>这样我们这个阶段的改造就完成了。</p><h2>测试</h2><p>我们这节课的实现只是内部程序结构的变动，并不影响用户的Servlet和客户端的访问。所以还是可以沿用以前的测试办法进行验证。</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/02/b2/02f040768f67d31ba4bc8bab64d757b2.jpg?wh=3321x1536\" alt=\"\"></p><p>这节课我们主要做了两件事：一是解析Response的返回信息，存储Header信息，可以让我们更好地处理服务器响应；二是采用Facade门面模式，新增HttpRequestFacade与HttpResponseFacade，封装我们不希望暴露的方法体，避免被业务程序员直接调用实现类的内部方法。</p><p>通过这两件事情，我们既符合了Servlet的规范，又让MiniTomcat本身在面对Servlet应用程序员的时候更加安全。这个Facade的设计是Tomcat中被人称赞的优点，我们自己尝试设计框架的时候可以借鉴。</p><p>本节课完整代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter07\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter07</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：如果我们不引入Facade，那么一个Servlet程序员有可能做些什么我们不希望他们做的事情？</p><p>欢迎你把你思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"06｜规范化：引入HttpRequest与HttpResponse","id":735122},"right":{"article_title":"08｜解析参数：通过引入Cookie和Session避免反复登录","id":737743}},"comments":[{"had_liked":false,"id":385776,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1703338881,"is_pvip":false,"replies":[{"id":140647,"content":"Q1，实现代码一样的，但是对外是两个语义。\nQ2，是先后输出的，一次交互中完成\nQ3，替代方法是用constructor来新建实例\nQ4，没用到，只是定义在这里了，大家知道原理。\nQ5，Oerride是编译注解，加上是好习惯\nQ6，不知道多少行，整个源代码大约是18M，我觉得有30-50万行吧。我直接用IDE看的源代码。\nQ7，URLClassLoader是Java自己提供的，就是“传统”的啊。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703668392,"ip_address":"湖南","comment_id":385776,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：addHeader与setHeader代码相同，不就重复了吗？\nHttpResponse中的这两个类，代码完全相同，重复啊。\n\nQ2：sendHeaders方法和servlet.service是分别输出到浏览器吗？\nServletProcessor类的process方法中，先是调用response.sendHeaders(); 这个方法是把头部信息输出到浏览器吗？紧接着又调用servlet.service，这个方法是输出内容到浏览器。这两次输出是顺序完成的吗？感觉应该是一起输出到浏览器才对，不过用了两个方法，感觉是分别输出到浏览器。\n\nQ3：newInstance过时了，替代方法是什么？\n我用Idea2019，对于“servlet = (Servlet) servletClass.newInstance();\n”这行代码，Idea提示此方法已经过时了。如果过时了，替代方法是什么？\n\nQ4：getMethod并没有被使用，对吗？\nHttpRequest中虽然实现了getMethod方法，但程序运行并没有使用此方法，对吗？（也许用了，但我没有看到）\n\nQ5：HttpRequestFacade类中的方法，为什么没有加override注解？\n我这里Idea2019有红线提示，提示缺少override注解，但是能运行。\n\nQ6：Tomcat源码大约多少行？老师一般用什么看Tomcat源码？\n用SourceInsight?还是直接用Idea看？\n\nQ7：对URL为什么要用URLClassLoader？传统的几个ClassLoader难道不能加载吗？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634570,"discussion_content":"Q1，实现代码一样的，但是对外是两个语义。\nQ2，是先后输出的，一次交互中完成\nQ3，替代方法是用constructor来新建实例\nQ4，没用到，只是定义在这里了，大家知道原理。\nQ5，Oerride是编译注解，加上是好习惯\nQ6，不知道多少行，整个源代码大约是18M，我觉得有30-50万行吧。我直接用IDE看的源代码。\nQ7，URLClassLoader是Java自己提供的，就是“传统”的啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703668392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1126661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/31/05/9028e9ac.jpg","nickname":"ctt","note":"","ucode":"FA87B9E86FD308","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634550,"discussion_content":"Q1:当使用 put 方法时，有两种情况：\n键不存在于映射中：键和值作为新的键值对插入。\n键已存在于映射中：映射中该键的当前值被新值替换，put 方法返回被替换的旧值。所以看上去调用的都是put方法，但是实际的执行逻辑是不一样的。可以去看concurrentHashMap的put方法 \nQ2:\n首先发送头部信息，只有在这些头部信息完全写入输出流之后，才会发送实际的内容数据。这是因为 HTTP 协议规定了响应应该首先包含头部信息，随后是响应体。如果顺序颠倒或混合，客户端可能无法正确解析响应。\nQ4：getMethod并没有被使用，对吗？\n应该没被使用，我把getMethod返回null不影响程序运行\nQ7:\nURLClassLoader 是 java.net.URLClassLoader 类的一个实例，它扩展了 ClassLoader 类，并提供了额外的功能来从 URL 指定的位置加载类。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703648821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388789,"user_name":"小四","can_delete":false,"product_type":"c1","uid":1103002,"ip_address":"北京","ucode":"41BAE89BCCF047","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/9a/11134ccc.jpg","comment_is_top":false,"comment_ctime":1710897967,"is_pvip":false,"replies":[{"id":141528,"content":"模仿Tomcat","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1711068736,"ip_address":"澳大利亚","comment_id":388789,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"这个facade感觉用wrapper更合理一些吧？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640011,"discussion_content":"模仿Tomcat","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711068737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386363,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"广东","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1704684279,"is_pvip":false,"replies":[{"id":140895,"content":"但是可以强制转化后获取，Facade就是让这种强制转化失效","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705024144,"ip_address":"澳大利亚","comment_id":386363,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"不希望外部修改的把方法设置为私有，只开放出必要的方法，设置为public\n","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635651,"discussion_content":"但是可以强制转化后获取，Facade就是让这种强制转化失效","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1705024144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385811,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1703426846,"is_pvip":false,"replies":[{"id":140645,"content":"举个例子：如果没有Facade，而是直接传入了实现类ConcreteRequest，则写servlet的那个程序员，他在doGet(request,response)中可以这么写：(ConcreteRequest)request进行强制转换，这样就可以调用ConcreteRequest实现类里面的方法了，造成隐患。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703665575,"ip_address":"湖南","comment_id":385811,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"目前想到有两点\n1，直接操作请求参数， 会有数据篡改嫌疑\n2，影响正常流程， 比如已经调用 response.sendHeaders 方法， 开发人员不熟悉整个复杂流程步骤，有可能会重复调用。\n\n请老师指点","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634566,"discussion_content":"举个例子：如果没有Facade，而是直接传入了实现类ConcreteRequest，则写servlet的那个程序员，他在doGet(request,response)中可以这么写：(ConcreteRequest)request进行强制转换，这样就可以调用ConcreteRequest实现类里面的方法了，造成隐患。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703665575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394183,"user_name":"码哥字节","can_delete":false,"product_type":"c1","uid":1572356,"ip_address":"广东","ucode":"362103AD52C8E0","user_header":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","comment_is_top":false,"comment_ctime":1726054863,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师一个问题，响应给浏览器的页面变成了html文本，浏览器f12 响应头为空。","like_count":0}]}