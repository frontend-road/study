{"id":523170,"title":"38 | 折叠表达式：高效的编译期展开","content":"<p>你好，我是吴咏炜。</p><p>当我在写<a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a>“应用可变模板和 tuple 的编译期技巧”时，有朋友就建议可以讨论一下折叠表达式 <span class=\"orange\">[1]</span>。不过，在那时候我对折叠表达式并没有什么实际应用经验，觉得它用处不大，于是就略过了。幸好我只是没有写，而没有乱加评论，否则就图欧图森破（too old, too simple）了。很多功能，只有在你真正需要到它、又掌握如何使用的时候，你才会觉得真正有用。很多 C++ 里看似用处不大的特性，都是这种情况（当然也不是所有，否则就不会有对特性的废弃和删除了）。</p><p>跟之前一样，我们还是通过具体的例子来看一下折叠表达式的作用和表达能力。</p><h2>基本用法</h2><h3>一元折叠</h3><p>在<a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a>我举过这样一个编译期递归的例子：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nconstexpr auto sum(T x)\n{\n  return x;\n}\n\ntemplate &lt;typename T1, typename T2,\n          typename... Targ&gt;\nconstexpr auto sum(T1 x, T2 y,\n                   Targ... args)\n{\n  return sum(x + y, args...);\n}\n</code></pre><p>而使用折叠表达式的话，我们可以把代码简化成下面这个样子：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nconstexpr auto sum(Args... args)\n{\n  return (... + args);\n}\n</code></pre><!-- [[[read_end]]] --><p>你应该可以看到，这个改进有多大了吧？</p><p>虽然猜这个代码是什么意思不难，但要精确理解这样的代码的语义，以及自己写出正确的折叠表达式，我们还是需要讲一点点语法。</p><p>首先，折叠表达式应用在可变模板的情况下，所以，我们需要有 <code>typename... Args</code> 这样的模板参数，及 <code>Args... args</code>、<code>const Args&amp;... args</code>、<code>Args&amp;&amp;... args</code> 之类的函数参数包 <span class=\"orange\">[2]</span>。</p><p>其次，我们在折叠表达式里使用参数包有一种特殊的形式。我们一定会用到圆括号（漏括号是初学时的常见错误）、参数包名称、运算符和 <code>...</code>。上面的代码用的是“一元左折叠”，形式是“<code>(... 运算符 参数包名称)</code>”。</p><p>最后，我们看一下折叠表达式是如何展开的。如果参数包只有一项（<code>args0</code>），那结果就是这个参数自身（<code>args0</code>）；如果参数包有两项（<code>args0, args1</code>），那结果就是这两项用运算符拼接起来（<code>args0 + args1</code>）；如果参数包有三项（<code>args0, args1, args2</code>），那结果就是这三项用运算符拼接起来（<code>args0 + args1 + args2</code>）；以此类推。</p><p>如果你初步理解了，那我得声明一下，我上面做了简化。对于超过两项的折叠表达式展开，我们有时候需要关注一下运算符的结合问题，即我们需要的是 <code>(args0 + args1) + args2</code>，还是 <code>args0 + (args1 + args2)</code>。显而易见，对于加法，以及其他满足结合律的运算符，这两者的区别并不重要。但是，即使对于加法，实际上这两种顺序都不是完全没有区别的（如浮点数），而对于减法、除法之类的运算，那就更不用说了。所以，我们需要区分一元左折叠和一元右折叠两种不同的方式，它们分别对应于 <code>(args0 + args1) + args2</code> 和 <code>args0 + (args1 + args2)</code>。写折叠表达式时的区别是，一元左折叠的 <code>...</code> 在左边，而一元右折叠的 <code>...</code> 在右边：<code>(... + args)</code> 和 <code>(args + ...)</code>。</p><p>下面用符号描述一下。令 $E$ 代表参数包，$N$ 代表参数包里的参数数量，则：</p><ul>\n<li>一元左折叠是 $(\\ldots\\ \\mathrm{op}\\ E)$，展开后成为 $(((E_1\\ \\mathrm{op}\\ E_2) \\ \\mathrm{op}\\ \\ldots)\\ \\mathrm{op}\\ E_N)$</li>\n<li>一元右折叠是 $(E \\ \\mathrm{op}\\ \\ldots)$，展开后成为$(E_1\\ \\mathrm{op}\\ (\\ldots\\ \\mathrm{op}\\ (E_{N-1}\\ \\mathrm{op}\\ E_N)))$</li>\n</ul><h3>与和或的折叠</h3><p>在大部分折叠表达式的展开过程中，参数包为空是一个错误。不过，为了方便实际使用的场景，C++ 对于使用 <code>&amp;&amp;</code> 和 <code>||</code> 的折叠表达式有特殊处理，允许参数包为空。这种情况下，<code>&amp;&amp;</code> 得到 <code>true</code>，<code>||</code> 得到 <code>false</code>——也就是说，相当于折叠表达式默认填充了一项不影响正常运算结果的数据：<code>true &amp;&amp; args0 &amp;&amp; ...</code> 和 <code>false || args0 || ...</code>。</p><p>C++ 里的“与”和“或”有短路求值行为 <span class=\"orange\">[3]</span>。当你写下 <code>a &amp;&amp; b</code> 时，如果 <code>a</code> 算出的结果是 <code>false</code>，编译器就不会对 <code>b</code> 进行求值，因为求值没有意义，不会影响结果。这是一个明确定义了的行为。类似地，如果 <code>a || b</code> 里 <code>a</code> 的结果是 <code>true</code>，编译器也不会对 <code>b</code> 进行求值。</p><p>如果我们看 <code>a &amp;&amp; b &amp;&amp; c</code> 这样的表达式的话，我们会发现情况也完全一样。按照运算符的结合规则，上面的表达式等同于 <code>(a &amp;&amp; b) &amp;&amp; c</code>；如果 <code>a</code> 结果为 <code>false</code>，无需对 <code>b</code> 求值就得到 <code>a &amp;&amp; b</code> 为 <code>false</code>，所以 <code>c</code> 也无需求值即得到最终结果 <code>false</code>。如果 <code>a</code> 为 <code>true</code>，编译器才会对 <code>b</code> 求值，并在结果为 <code>true</code> 时才对 <code>c</code> 求值……</p><p>再进一步，对于 <code>a &amp;&amp; (b &amp;&amp; c)</code> 进行分析，我们会发现，求值的顺序和结果仍将完全相同：</p><ul>\n<li>若 <code>a</code> 求值为 <code>false</code>，则 <code>b &amp;&amp; c</code> 不求值，结果为 <code>false</code></li>\n<li>若 <code>a</code> 求值为 <code>true</code>，然后 <code>b</code> 求值为 <code>false</code>，则 <code>c</code> 不求值，结果为 <code>false</code></li>\n<li>若 <code>a</code> 求值为 <code>true</code>，然后 <code>b</code> 求值为 <code>true</code>，则结果为 <code>c</code> 求值的结果</li>\n</ul><p>这样的分析对于 <code>||</code> 也同样适用。因此，一元左折叠和右折叠的等价性不仅对于普通满足结合律的运算符是成立的，而且对于有短路规则的运算符也同样是成立的。</p><h3>逗号的折叠</h3><p>很多人可能没注意到，逗号“<code>,</code>”也是一个运算符 <span class=\"orange\">[4]</span>，表达式 <code>a, b</code> 的意思是（当然，不是在能被当作函数参数的地方；如果可能被编译器误解，多加一重括号就行），对 <code>a</code> 和 <code>b</code> 依次进行求值，返回后一个表达式 <code>b</code> 的结果。在使用逗号的折叠表达式里，参数包也允许为空，此时表达式的结果相当于 <code>void()</code>，即没有数值。</p><p>我们后面会展示逗号折叠表达式的用法。</p><h3>二元折叠</h3><p>在参数包里提供了运算所需的所有参数时，一元折叠表达式就很好了。但还有很大的一类展开场景，我们没法用一元折叠表达式，因为我们需要在函数里提供某个参数。一种典型的情况就是，我们需要把一堆参数输出到某个流里：</p><pre><code class=\"language-cpp\">cout &lt;&lt; args0 &lt;&lt; args1 &lt;&lt; ... &lt;&lt; argsN;\n</code></pre><p>这里我们就需要用到所谓的“二元左折叠”了。如果待输出的参数组成了我们的参数包 <code>args</code>，我们用下面的代码就能输出：</p><pre><code class=\"language-cpp\">(cout &lt;&lt; ... &lt;&lt; args);\n</code></pre><p>类似地，我们有“二元右折叠”，道理相同，我就不展开了。</p><p>二元折叠相当于提供了一个“初值”，所以参数包允许为空。对于空参数包，<code>(... + args)</code> 是不合法代码，而 <code>(0 + ... + args)</code> 就是合法的了。</p><p>下面用符号描述一下。令 $E$ 代表参数包，$N$ 代表参数包里的参数数量，$I$ 代表“初值参数”，则：</p><ul>\n<li>二元左折叠是 $(I\\ \\mathrm{op}\\ \\ldots\\ \\mathrm{op}\\ E)$，展开后成为 $((((I\\ \\mathrm{op}\\ E_1)\\ \\mathrm{op}\\ E_2) \\ \\mathrm{op}\\ \\ldots)\\ \\mathrm{op}\\ E_N)$</li>\n<li>二元右折叠是 $(E \\ \\mathrm{op}\\ \\ldots\\ \\mathrm{op}\\ I)$，展开后成为$(E_1\\ \\mathrm{op}\\ (\\ldots\\ \\mathrm{op}\\ (E_{N-1}\\ \\mathrm{op}\\ (E_N\\ \\mathrm{op}\\ I))))$</li>\n</ul><h2>折叠表达式的应用场景</h2><p>在对折叠表达式有了一些初步的了解之后，我们来看一下实际应用折叠表达式的一些场景。</p><h3>空指针检查</h3><p>作为一种编译期展开的功能，折叠表达式能够达到跟手写展开完全相同的效果，但表达上要精炼得多。比如，我们有代码需要检查给定的指针（有可能有智能指针）是否有为空的情况，我们就可以写：</p><pre><code class=\"language-cpp\">if (ptr1 == nullptr ||\n    ptr2 == nullptr ||\n    …\n    ptrN == nullptr) {\n  // 记录日志，出错返回，等等\n}\n</code></pre><p>这当然不算糟糕，但下面这样的写法是不是好上一点点？</p><pre><code class=\"language-cpp\">if (is_any_null(ptr1, ptr2, …, ptrN)) {\n  // 记录日志，出错返回，等等\n}\n</code></pre><p>而 <code>is_any_null</code> 的实现非常简单：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nconstexpr bool\nis_any_null(const Args&amp;... args)\n{\n  return (... || (args == nullptr));\n}\n</code></pre><h3>返回值检查</h3><p>比上面这种更复杂一点的，是调用多个函数，检查返回值，并在返回值表示不成功时终止代码执行。示意代码如下：</p><pre><code class=\"language-cpp\">error_t result{};\nresult = check1(…);\nif (result != error_t::ok) {\n  return result;\n}\nresult = check2(…);\nif (result != error_t::ok) {\n  return result;\n}\nresult = check3(…);\nif (result != error_t::ok) {\n  return result;\n}\nresult = check4(…);\nif (result != error_t::ok) {\n  return result;\n}\nreturn error_t::ok;\n</code></pre><p>利用折叠表达式，我们也可以这样简化代码：</p><pre><code class=\"language-cpp\">return checked_exec(\n  error_t::ok,\n  [&amp;] { return check1(…); },\n  [&amp;] { return check2(…); },\n  [&amp;] { return check3(…); },\n  [&amp;] { return check4(…); });\n</code></pre><p>当然，我们需要提供 <code>checked_exec</code> 的定义：</p><pre><code class=\"language-cpp\">template &lt;typename R,\n          typename... Fn&gt;\nR checked_exec(const R&amp; expected,\n               Fn&amp;&amp;... fn)\n{\n  R result = expected;\n  (void)(((result = forward&lt;Fn&gt;(\n             fn)()) == expected) &amp;&amp;\n         ...);\n  return result;\n}\n</code></pre><p>在参数展开和内联后，我们上面对 <code>checked_exec</code> 的调用就大致相当于下面的代码：</p><pre><code class=\"language-cpp\">error_t result = error_t::ok;\n(void)(((result = check1(…)) == error_t::ok) &amp;&amp;\n       (((result = check2(…)) == error_t::ok) &amp;&amp;\n        (((result = check3(…)) == error_t::ok) &amp;&amp;\n         ((result = check4(…)) == error_t::ok))));\nreturn result;\n</code></pre><p>这里我严格按一元右折叠的形式进行了展开，但就如上面讨论过的，这里左折叠和右折叠是等价的。此时，去掉一些括号，代码会更加清晰：</p><pre><code class=\"language-cpp\">(void)((result = check1(…)) == error_t::ok &amp;&amp;\n       (result = check2(…)) == error_t::ok &amp;&amp;\n       (result = check3(…)) == error_t::ok &amp;&amp;\n       (result = check4(…)) == error_t::ok);\n</code></pre><p>所以，我们看到了，利用折叠表达式和短路规则，我们可以实现 <code>checked_exec</code> 或类似的函数，来简化一些重复的检查，让代码更加清晰，并避免低级错误。</p><h3>编译期遍历</h3><p>利用逗号折叠表达式，我们可以实现一些编译期的遍历操作。最基本的，当然就是直接遍历所有的参数了。利用这种方式，我们可以来实现带分隔符的打印操作：</p><pre><code class=\"language-cpp\">template &lt;typename T,\n          typename First,\n          typename... Rest&gt;\nvoid print_with_separator(\n  const T&amp; sep,\n  const First&amp; first,\n  const Rest&amp;... rest)\n{\n  cout &lt;&lt; first;\n  ((cout &lt;&lt; sep &lt;&lt; rest), ...);\n  cout &lt;&lt; endl;\n}\n</code></pre><p>这个代码很简单，可以内联，因此我也没有必要像<a href=\"https://time.geekbang.org/column/article/517514\">第 37 讲</a>里描述的那样进一步进行传参优化了。这里的编译期展开就利用了逗号折叠表达式。比如，当我们以 <code>print_with_separator(\", \", \"one\", \"two\", \"three\")</code> 来调用时，函数体展开成大致这个样子（去掉了不必要的括号）：</p><pre><code class=\"language-cpp\">cout &lt;&lt; \"one\";\n((cout &lt;&lt; \", \" &lt;&lt; \"two\"),\n (cout &lt;&lt; \", \" &lt;&lt; \"three\"));\ncout &lt;&lt; endl;\n</code></pre><p>逗号前的那个表达式就成了我们希望在参数包 <code>args</code> 上反复执行的内容。</p><p>使用类似的方式，我们可以打印一个 <code>tuple</code>。这时，代码就稍微复杂一些了：我们需要根据需要遍历的项数预先生成编译期的整数序列，也就是<a href=\"https://time.geekbang.org/column/article/185899\">第 18 讲</a>讨论过的 <code>make_index_sequence</code>，然后利用折叠表达式来逐项遍历。</p><p>不过呢，我们这次会使用标准库里的一个对 <code>make_index_sequence</code> 的小小封装 <span class=\"orange\">[5]</span>：</p><pre><code class=\"language-cpp\">template &lt;class... T&gt;\nusing index_sequence_for =\n  make_index_sequence&lt;sizeof...(T)&gt;;\n</code></pre><p>这个类模板会根据模板参数的项数来生成一个合适的序列。比如，如果传给 <code>index_sequence_for</code> 的模板参数有三项的话，那结果类型就会是 <code>index_sequence&lt;0, 1, 2&gt;</code>。</p><p>然后，<code>print_tuple</code> 就可以这样实现：</p><pre><code class=\"language-cpp\">template &lt;typename Tup,\n          size_t... Is&gt;\nvoid output_tuple_members(\n  ostream&amp; os,\n  const Tup&amp; tup,\n  index_sequence&lt;Is...&gt;)\n{\n  ((os &lt;&lt; (Is != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;Is&gt;(tup)),\n   ...);\n}\n\ntemplate &lt;typename... Args&gt;\nvoid print_tuple(const tuple&lt;Args...&gt;&amp; args)\n{\n  cout &lt;&lt; '(';\n  output_tuple_members(\n    cout, args,\n    index_sequence_for&lt;Args...&gt;{});\n  cout &lt;&lt; ')';\n}\n</code></pre><p>对于一个三项的 <code>tuple</code>，最后展开出来的代码就差不多是这个样子：</p><pre><code class=\"language-cpp\">cout &lt;&lt; '(';\n((cout &lt;&lt; (0 != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;0&gt;(args)),\n (cout &lt;&lt; (1 != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;1&gt;(args)),\n (cout &lt;&lt; (2 != 0 ? \", \" : \"\")\n       &lt;&lt; get&lt;2&gt;(args)));\ncout &lt;&lt; ')';\n</code></pre><p>显然，它确实能够完成我们需要的打印任务。如果我们传它一个 <code>make_tuple(1, \"two\", 3.14159)</code>，打印结果就会是：</p><blockquote>\n<p><code>(1, two, 3.14159)</code></p>\n</blockquote><h2>内容小结</h2><p>本讲我讨论了 C++17 提供的折叠表达式，并通过提供具体的例子，向你展示了如何使用这一特性来进行编译期展开，从而简化重复的代码。</p><h2>课后思考</h2><p>尝试一下不用折叠表达式去实现 <code>checked_exec</code>（或其他使用了折叠表达式的函数模板），体会一下折叠表达式带来的简化。</p><p>期待你的动手实践，有任何疑问我们留言区见！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “fold expression”. <a href=\"https://en.cppreference.com/w/cpp/language/fold\">https://en.cppreference.com/w/cpp/language/fold</a></span></p><p><span class=\"reference\">[1a] cppreference.com, “折叠表达式”. <a href=\"https://zh.cppreference.com/w/cpp/language/fold\">https://zh.cppreference.com/w/cpp/language/fold</a></span></p><p><span class=\"reference\">[2] cppreference.com, “Parameter pack”. <a href=\"https://en.cppreference.com/w/cpp/language/parameter_pack\">https://en.cppreference.com/w/cpp/language/parameter_pack</a></span></p><p><span class=\"reference\">[2a] cppreference.com, “形参包”. <a href=\"https://zh.cppreference.com/w/cpp/language/parameter_pack\">https://zh.cppreference.com/w/cpp/language/parameter_pack</a></span></p><p><span class=\"reference\">[3] cppreference.com, “Logical operators”. <a href=\"https://en.cppreference.com/w/cpp/language/operator_logical\">https://en.cppreference.com/w/cpp/language/operator_logical</a></span></p><p><span class=\"reference\">[3a] cppreference.com, “逻辑运算符”. <a href=\"https://zh.cppreference.com/w/cpp/language/operator_logical\">https://zh.cppreference.com/w/cpp/language/operator_logical</a></span></p><p><span class=\"reference\">[4] cppreference.com, “Other operators”. <a href=\"https://en.cppreference.com/w/cpp/language/operator_other\">https://en.cppreference.com/w/cpp/language/operator_other</a></span></p><p><span class=\"reference\">[4a] cppreference.com, “其他运算符”. <a href=\"https://zh.cppreference.com/w/cpp/language/operator_other\">https://zh.cppreference.com/w/cpp/language/operator_other</a></span></p><p><span class=\"reference\">[5] cppreference.com, “std::integer_sequence”. <a href=\"https://en.cppreference.com/w/cpp/utility/integer_sequence\">https://en.cppreference.com/w/cpp/utility/integer_sequence</a></span></p><p><span class=\"reference\">[5a] cppreference.com, “std::integer_sequence”. <a href=\"https://zh.cppreference.com/w/cpp/utility/integer_sequence\">https://zh.cppreference.com/w/cpp/utility/integer_sequence</a></span></p>","neighbors":{"left":{"article_title":"37｜参数传递的正确方法和模板的二进制膨胀","id":517514},"right":{"article_title":"39 | 如何在编译期玩转字符串？","id":527423}},"comments":[{"had_liked":false,"id":348414,"user_name":"孙新","can_delete":false,"product_type":"c1","uid":2875594,"ip_address":"","ucode":"A80038A479B943","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","comment_is_top":false,"comment_ctime":1655089859,"is_pvip":true,"replies":[{"id":"126946","content":"课程里我也展示了不少代码了。还是看看如何在项目里真正用起来吧。用起来才会有感觉。<br><br>标准库本身就是一个不错的参考。我觉得 Clang 的标准库 libc++ 可读性最好。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1655130680,"ip_address":"","comment_id":348414,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5950057155","product_id":100040501,"comment_content":"最近刷了两三遍的课，也逐渐了解了一些语法细节。但是因为现有的项目基本没有模板编程的部分，所以比较困惑。就是好的模板编程代码结构设计是什么样的，有什么优秀开源项目推荐的吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575834,"discussion_content":"课程里我也展示了不少代码了。还是看看如何在项目里真正用起来吧。用起来才会有感觉。\n\n标准库本身就是一个不错的参考。我觉得 Clang 的标准库 libc++ 可读性最好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1655130680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":575947,"discussion_content":"感谢老师，那就动手了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655203737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":575834,"ip_address":""},"score":575947,"extra":""}]}]},{"had_liked":false,"id":347741,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1654388406,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654388406","product_id":100040501,"comment_content":"赞一个","like_count":0}]}