{"id":597664,"title":"03｜Token：如何降低用户身份鉴权的流量压力？","content":"<p>你好，我是徐长龙，这节课我们来看看如何用token算法降低用户中心的身份鉴权流量压力。</p><p>很多网站初期通常会用Session方式实现登录用户的用户鉴权，也就是在用户登录成功后，将这个用户的具体信息写在服务端的Session缓存中，并分配一个session_id保存在用户的Cookie中。该用户的每次请求时候都会带上这个ID，通过ID可以获取到登录时写入服务端Session缓存中的记录。</p><p>流程图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/58/72/589d13f1d758a44a1af37efaf9dbdc72.jpg?wh=3330x2141\" alt=\"\" title=\"Session Cache实现的用户鉴权\"></p><p>这种方式的好处在于信息都在服务端储存，对客户端不暴露任何用户敏感的数据信息，并且每个登录用户都有共享的缓存空间（Session Cache）。</p><p>但是随着流量的增长，这个设计也暴露出很大的问题——用户中心的身份鉴权在大流量下很不稳定。因为用户中心需要维护的Session Cache空间很大，并且被各个业务频繁访问，那么缓存一旦出现故障，就会导致所有的子系统无法确认用户身份，进而无法正常对外服务。</p><p>这主要是由于Session Cache和各个子系统的耦合极高，<strong>全站的请求都会对这个缓存至少访问一次</strong>，这就导致缓存的内容长度和响应速度，直接决定了全站的QPS上限，让整个系统的隔离性很差，各子系统间极易相互影响。</p><p>那么，如何降低用户中心与各个子系统间的耦合度，提高系统的性能呢？我们一起来看看。</p><!-- [[[read_end]]] --><h2>JWT登陆和token校验</h2><p>常见方式是采用签名加密的token，这是登录的一个行业标准，即JWT（JSON Web Token）：<img src=\"https://static001.geekbang.org/resource/image/02/bf/02f2f3aff0f5db68ef952065da2721bf.jpg?wh=3330x2141\" alt=\"\" title=\"token流程\"></p><p>上图就是JWT的登陆流程，用户登录后会将用户信息放到一个加密签名的token中，每次请求都把这个串放到header或cookie内带到服务端，服务端直接将这个token解开即可直接获取到用户的信息，无需和用户中心做任何交互请求。</p><p>token生成代码如下：</p><pre><code class=\"language-go\">import \"github.com/dgrijalva/jwt-go\"\n\n//签名所需混淆密钥 不要太简单 容易被破解\n//也可以使用非对称加密，这样可以在客户端用公钥验签\nvar secretString = []byte(\"jwt secret string 137 rick\") \n\ntype TokenPayLoad struct {\n    UserId   uint64 `json:\"userId\"` //用户id\n    NickName string `json:\"nickname\"` //昵称\n    jwt.StandardClaims //私有部分\n}\n\n// 生成JWT token\nfunc GenToken(userId uint64, nickname string) (string, error) {\n    c := TokenPayLoad{\n        UserId: userId, //uid\n        NickName: nickname, //昵称\n        //这里可以追加一些其他加密的数据进来\n        //不要明文放敏感信息，如果需要放，必须再加密\n        \n        //私有部分\n        StandardClaims: jwt.StandardClaims{\n            //两小时后失效\n            ExpiresAt: time.Now().Add(2 * time.Hour).Unix(),\n            //颁发者\n            Issuer:    \"geekbang\",\n        },\n    }\n    //创建签名 使用hs256\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, c)\n    // 签名，获取token结果\n    return token.SignedString(secretString)\n}\n</code></pre><p>可以看到，这个token内部包含过期时间，快过期的token会在客户端自动和服务端通讯更换，这种方式可以大幅提高截取客户端token并伪造用户身份的难度。</p><p>同时，服务端也可以和用户中心解耦，业务服务端直接解析请求带来的token即可获取用户信息，无需每次请求都去用户中心获取。而token的刷新可以完全由App客户端主动请求用户中心来完成，而不再需要业务服务端业务请求用户中心去更换。</p><p>JWT是如何保证数据不会被篡改，并且保证数据的完整性呢，我们先看看它的组成。</p><p><img src=\"https://static001.geekbang.org/resource/image/24/f6/240a6a36f0fbcd177e990411abbb8df6.jpg?wh=1920x501\" alt=\"图片\"></p><p>如上图所示，加密签名的token分为三个部分，彼此之间用点来分割，其中，Header用来保存加密算法类型；PayLoad是我们自定义的内容；Signature是防篡改签名。</p><p>JWT token解密后的数据结构如下图所示：</p><pre><code class=\"language-json\">//header\n//加密头\n{\n&nbsp; \"alg\": \"HS256\", // 加密算法，注意检测个别攻击会在这里设置为none绕过签名\n&nbsp; \"typ\": \"JWT\" //协议类型\n}\n\n//PAYLOAD\n//负载部分，存在JWT标准字段及我们自定义的数据字段\n{\n&nbsp; \"userid\": \"9527\", //我们放的一些明文信息，如果涉及敏感信息，建议再次加密\n&nbsp; \"nickname\": \"Rick.Xu\", // 我们放的一些明文信息，如果涉及隐私，建议再次加密\n  \"iss\": \"geekbang\",\n&nbsp; \"iat\": 1516239022, //token发放时间\n  \"exp\": 1516246222, //token过期时间\n}\n\n//签名\n//签名用于鉴定上两段内容是否被篡改，如果篡改那么签名会发生变化\n//校验时会对不上\n</code></pre><p>JWT如何验证token是否有效，还有token是否过期、是否合法，具体方法如下：</p><pre><code class=\"language-go\">func DecodeToken(token string) (*TokenPayLoad, error) {\n    token, err := jwt.ParseWithClaims(token, &amp;TokenPayLoad{}, func(tk *jwt.Token) (interface{}, error) {\n        return secret, nil\n    })\n    if err != nil {\n        return nil, err\n    }\n    if decodeToken, ok := token.Claims.(*TokenPayLoad); ok &amp;&amp; token.Valid {\n        return decodeToken, nil\n    }\n    return nil, errors.New(\"token wrong\")\n}\n</code></pre><p>JWT的token解密很简单，第一段和第二段都是通过base64编码的。直接解开这两段数据就可以拿到payload中所有的数据，其中包括用户昵称、uid、用户权限和token过期时间。要验证token是否过期，只需将其中的过期时间和本地时间对比一下，就能确认当前token是不是有效。</p><p>而验证token是否合法则是通过签名验证完成的，任何信息修改都会无法通过签名验证。要是通过了签名验证，就表明token没有被篡改过，是一个合法的token，可以直接使用。</p><p>这个过程如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/19/8a/19b6179e1ff8ef5a13f0cbf4527ce88a.jpg?wh=3330x2141\" alt=\"\"></p><p>我们可以看到，通过token方式，用户中心压力最大的接口可以下线了，每个业务的服务端只要解开token验证其合法性，就可以拿到用户信息。不过这种方式也有缺点，就是用户如果被拉黑，客户端最快也要在token过期后才能退出登陆，这让我们的管理存在一定的延迟。</p><p>如果我们希望对用户进行实时管理，可以把新生成的token在服务端暂存一份，每次用户请求就和缓存中的token对比一下，但这样很影响性能，极少数公司会这么做。同时，为了提高JWT系统的安全性，token一般会设置较短的过期时间，通常是十五分钟左右，过期后客户端会自动更换token。</p><h2>token的更换和离线</h2><p>那么如何对JWT的token进行更换和离线验签呢？</p><p>具体的服务端换签很简单，只要客户端检测到当前的token快过期了，就主动请求用户中心更换token接口，重新生成一个离当前还有十五分钟超时的token。</p><p>但是期间如果超过十五分钟还没换到，就会导致客户端登录失败。为了减少这类问题，同时保证客户端长时间离线仍能正常工作，行业内普遍使用双token方式，具体你可以看看后面的流程图：</p><p><img src=\"https://static001.geekbang.org/resource/image/de/7c/de29bd40ac360cb06ca6d3e75ac87a7c.jpg?wh=3330x2141\" alt=\"\"></p><p>可以看到，这个方案里有两种token：<strong>一种是refresh_token，用于更换access_token，有效期是30天；另一种是access_token，用于保存当前用户信息和权限信息，每隔15分钟更换一次</strong>。如果请求用户中心失败，并且App处于离线状态，只要检测到本地refresh_token没有过期，系统仍可以继续工作，直到refresh_token过期为止，然后提示用户重新登陆。这样即使用户中心坏掉了，业务也能正常运转一段时间。</p><p>用户中心检测更换token的实现如下：</p><pre><code class=\"language-go\">//如果还有五分钟token要过期，那么换token\nif decodeToken.StandardClaims.ExpiresAt &lt; TimestampNow() - 300 {\n  //请求下用户中心，问问这个人禁登陆没\n  //....略具体\n  \n  //重新发放token\n  token, err := GenToken(.....)\n  if err != nil {\n        return nil, err\n  }\n  //更新返回cookie中token\n  resp.setCookie(\"xxxx\", token)\n}\n</code></pre><p>这段代码只是对当前的token做了超时更换。JWT对离线App端十分友好，因为App可以将它保存在本地，在使用用户信息时直接从本地解析出来即可。</p><h2>安全建议</h2><p>最后我再啰嗦几句，除了上述代码中的注释外，在使用JWT方案的时候还有一些关键的注意事项，这里分享给你。</p><p>第一，通讯过程必须使用HTTPS协议，这样才可以降低被拦截的可能。</p><p>第二，要注意限制token的更换次数，并定期刷新token，比如用户的access_token每天只能更换50次，超过了就要求用户重新登陆，同时token每隔15分钟更换一次。这样可以降低token被盗取后给用户带来的影响。</p><p>第三，Web用户的token保存在cookie中时，建议加上httponly、SameSite=Strict限制，以防止cookie被一些特殊脚本偷走。</p><h2>总结</h2><p>传统的Session方式是把用户的登录信息通过SessionID统一缓存到服务端中，客户端和子系统每次请求都需要到用户中心去“提取”，这就会导致用户中心的流量很大，所有业务都很依赖用户中心。</p><p>为了降低用户中心的流量压力，同时让各个子系统与用户中心脱耦，我们采用信任“签名”的token，把用户信息加密发放到客户端，让客户端本地拥有这些信息。而子系统只需通过签名算法对token进行验证，就能获取到用户信息。</p><p>这种方式的核心是<strong>把用户信息放在服务端外做传递和维护，以此解决用户中心的流量性能瓶颈</strong>。此外，通过定期更换token，用户中心还拥有一定的用户控制能力，也加大了破解难度，可谓一举多得。</p><p>其实，还有很多类似的设计简化系统压力，比如文件crc32校验签名可以帮我们确认文件在传输过程中是否损坏；通过Bloom Filter可以确认某个key是否存在于某个数据集合文件中等等，这些都可以大大提高系统的工作效率，减少系统的交互压力。这些技巧在硬件能力腾飞的阶段，仍旧适用。</p><h2>思考题</h2><p>用户如果更换了昵称，如何快速更换token中保存的用户昵称呢？</p><p>欢迎你在留言区与我交流讨论，我们下节课见！</p>","neighbors":{"left":{"article_title":"02｜缓存一致：读多写少时，如何解决数据更新缓存不同步？","id":596644},"right":{"article_title":"04｜同城双活：如何实现机房之间的数据同步？","id":598570}},"comments":[{"had_liked":false,"id":360874,"user_name":"徐曙辉","can_delete":false,"product_type":"c1","uid":1035885,"ip_address":"北京","ucode":"D8FA8A64FB7E33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/6d/0c15c18a.jpg","comment_is_top":true,"comment_ctime":1666929490,"is_pvip":true,"replies":[{"id":"131282","content":"你好，徐曙辉，很高兴收到你的再次留言<br>对于session 方式来说，由于用户每次请求都会读取session cache，客户端本地是不会保存token，所以不存在token内用户头像更新不及时问题。可以说后台系统用session管理用户很方便，因为这个可以做到用户实时管理，当我们禁用用户的时候把session的缓存登陆标志删掉即可。不过这个方式适合少量用户，对于QPS超过10w QPS请求的API则不太适合。<br><br>所以使用token方式来签名发给客户端，客户端请求其他子系统的时候，会带上它，子系统只要验证这个token的签名就不需要再去用户中心问一句。所以token使用后，用户中心不会被其他子系统频繁请求，但是也导致token发出去没法再次更改，即使我们用户中心给他拉黑了，其他子系统只认印章，不会过来问问。<br><br>同时为了方便token内会保存当前用户一些基础信息，减少其他系统过来询问的次数，这导致，用户更新头像，token没更换，是不会同步更新的<br>第一个很暴力，但是很有趣～<br>第二个方式也很有趣，同时补一个技巧我们可以通过 设定 固定网址 user&#47;用户uid&#47;heaer.jpg方式直接获取用户头像，这样也不用考虑更新问题了<br><br>","user_name":"作者回复","comment_id":360874,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1666940850,"user_name_real":"作者"}],"discussion_count":9,"race_medal":0,"score":"9.2233720385217004e+18","product_id":100309001,"comment_content":"Q1：在token过期很短的时候，通过refresh_token频繁更新token，怎么实现对用户实时管理？是不是还是跟用户人数相关，一般这种场景是后台系统，删除一个用户后该用户账号立刻不能登录，后台人数比C端人数少很多，所以管理起来代价比较小，更看重权限安全，放在缓存中进行管理。<br>A: 如果我来做快速更换昵称的功能，两种方式，<br>a.在用户修改昵称后，内存中加入个用户标识，解析token后读取该标识，有则返回特定code，让客户端重新拿token。甚至可以不用客户端参与，返回301重定向到获取新token的路由。<br>b. token里面不存用户信息，只存用户ID，需要用户信息的时候从缓存读。<br>","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591932,"discussion_content":"你好，徐曙辉，很高兴收到你的再次留言\n对于session 方式来说，由于用户每次请求都会读取session cache，客户端本地是不会保存token，所以不存在token内用户头像更新不及时问题。可以说后台系统用session管理用户很方便，因为这个可以做到用户实时管理，当我们禁用用户的时候把session的缓存登陆标志删掉即可。不过这个方式适合少量用户，对于QPS超过10w QPS请求的API则不太适合。\n\n所以使用token方式来签名发给客户端，客户端请求其他子系统的时候，会带上它，子系统只要验证这个token的签名就不需要再去用户中心问一句。所以token使用后，用户中心不会被其他子系统频繁请求，但是也导致token发出去没法再次更改，即使我们用户中心给他拉黑了，其他子系统只认印章，不会过来问问。\n\n同时为了方便token内会保存当前用户一些基础信息，减少其他系统过来询问的次数，这导致，用户更新头像，token没更换，是不会同步更新的\n第一个很暴力，但是很有趣～\n第二个方式也很有趣，同时补一个技巧我们可以通过 设定 固定网址 user/用户uid/heaer.jpg方式直接获取用户头像，这样也不用考虑更新问题了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666940850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":5,"child_discussions":[{"author":{"id":2269341,"avatar":"","nickname":"不吃包子","note":"","ucode":"5E0661EC355ED9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591949,"discussion_content":"你的意思是,针对你的提问,JWT不保存用户信息,只保存用户ID,用户信息存储是到缓存中,单独读取的?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666951037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":591932,"ip_address":"广东"},"score":591949,"extra":""},{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2269341,"avatar":"","nickname":"不吃包子","note":"","ucode":"5E0661EC355ED9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591953,"discussion_content":"第二种是指，将容易改变的内容，通过其他方式获取，比如用户头像，用固定网址来获取，即使改了网址不会变，只是改变了网址里面的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666953490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":591949,"ip_address":"北京"},"score":591953,"extra":""},{"author":{"id":1035885,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ce/6d/0c15c18a.jpg","nickname":"徐曙辉","note":"","ucode":"D8FA8A64FB7E33","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591972,"discussion_content":"学到了，之前没往这方面想过，按这样做，头像可以http://xx.com/user/用户ID/header.jpg，静态文件可以，因为反正都是远程http渲染，但是昵称和其他信息都这样处理，每一项都放到远程地址性能不是很好，是不是可以http://xxx.com/user/用户ID/info.json，再反序列化，这样确定是占了额外的存储空间，优点是不用查DB和缓存，减少她们的压力，在web应用中，用户信息读取挺频繁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1666968192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":591953,"ip_address":"湖南"},"score":591972,"extra":""}]},{"author":{"id":1392585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","nickname":"Sky","note":"","ucode":"4C5A5AB73E8B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591999,"discussion_content":"同时补一个技巧我们可以通过 设定 固定网址 user/用户uid/heaer.jpg方式直接获取用户头像，这样也不用考虑更新问题了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1667023590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3183263,"avatar":"https://static001.geekbang.org/account/avatar/00/30/92/9f/d5255fe8.jpg","nickname":"snake","note":"","ucode":"0C7398D3A68119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592216,"discussion_content":"没想到还有这样的方式，学到了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667209809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","nickname":"Sky","note":"","ucode":"4C5A5AB73E8B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592000,"discussion_content":"这个技巧学到了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667023600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360866,"user_name":"7S","can_delete":false,"product_type":"c1","uid":1199397,"ip_address":"北京","ucode":"A08EEF49BFB076","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/25/0920057c.jpg","comment_is_top":false,"comment_ctime":1666925335,"is_pvip":false,"replies":[{"id":"131273","content":"你好，7S，很高兴收到你的思考，关于这里有一些特殊的小技巧，如请求时带上一些客户端特征，如：请求更换access_token时，带上的refresh_token的请求 同时 需要特殊的签名，存储在本地的token不用明文保存，与服务端通讯时用特殊协议加密等～","user_name":"作者回复","comment_id":360866,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1666927494,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"18846794519","product_id":100309001,"comment_content":"access_token由于安全问题设置过期的时间非常短，但是refresh_token有效时间非常长，如果refresh_token被泄漏掉，是不是能一直刷新access_token呢。。","like_count":4,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591908,"discussion_content":"你好，7S，很高兴收到你的思考，关于这里有一些特殊的小技巧，如请求时带上一些客户端特征，如：请求更换access_token时，带上的refresh_token的请求 同时 需要特殊的签名，存储在本地的token不用明文保存，与服务端通讯时用特殊协议加密等～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666927494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360895,"user_name":"极客","can_delete":false,"product_type":"c1","uid":1114999,"ip_address":"北京","ucode":"A4AAA6B4F40E66","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/77/3f6a76a9.jpg","comment_is_top":false,"comment_ctime":1666948549,"is_pvip":false,"replies":[{"id":"131287","content":"你好，极客，感谢你的留言，这个思路很有意思，是个方法，印象里这个技巧对于读多写多的服务的客户端也会做类似的事情","user_name":"作者回复","comment_id":360895,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1666954168,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14551850437","product_id":100309001,"comment_content":"客户端可以缓存修改后的昵称，直到更换了access token再清除缓存，类似弹幕本地先发送让用户自己认为发送成功了","like_count":4,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591957,"discussion_content":"你好，极客，感谢你的留言，这个思路很有意思，是个方法，印象里这个技巧对于读多写多的服务的客户端也会做类似的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666954168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361197,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1667314169,"is_pvip":true,"replies":[{"id":"131372","content":"你好，peter，这里更换是客户端写代码来实现自动更换的，子业务系统无需关注token的更换。","user_name":"作者回复","comment_id":361197,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667318267,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1667314169","product_id":100309001,"comment_content":"请问：Token的自动更新是系统自动完成的吗？<br>文中有“过期后客户端会自动更换 token。”，那么，token的更新需要开发人员写代码吗？（如果是框架自动完成，或者是TCP&#47;UDP协议栈完成，就不需要用户写代码了）<br>","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592347,"discussion_content":"你好，peter，这里更换是客户端写代码来实现自动更换的，子业务系统无需关注token的更换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667318267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361162,"user_name":"frag007","can_delete":false,"product_type":"c1","uid":1215185,"ip_address":"北京","ucode":"94D7368F091908","user_header":"","comment_is_top":false,"comment_ctime":1667290274,"is_pvip":true,"replies":[{"id":"131363","content":"你好，frag007，很高兴收到你的留言，这是个最简单的实现方式～唯一缺点就是多客户端的情况下同步有些问题～","user_name":"作者回复","comment_id":361162,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667297237,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1667290274","product_id":100309001,"comment_content":"更新昵称一般是用户自己发起的，更新昵称的同时，业务后台重新生成token就可以了。","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592309,"discussion_content":"你好，frag007，很高兴收到你的留言，这是个最简单的实现方式～唯一缺点就是多客户端的情况下同步有些问题～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667297237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361082,"user_name":"吴晨辉","can_delete":false,"product_type":"c1","uid":2312639,"ip_address":"北京","ucode":"757E98E93AF6A3","user_header":"https://static001.geekbang.org/account/avatar/00/23/49/bf/4936c58b.jpg","comment_is_top":false,"comment_ctime":1667193240,"is_pvip":true,"replies":[{"id":"131352","content":"最后一句很棒，支持，笑","user_name":"作者回复","comment_id":361082,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667266703,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1667193240","product_id":100309001,"comment_content":"很高兴第二次回答问题<br>传统sessoion会导致用户中心缓存大，耦合度高，但实时性强<br>jwt加密策略耦合度低，但是实时性不高<br>那么可以结合两个方式，优先读取token 加密字段，然后利用用户id关联session cache覆盖<br>考虑到session缓存成本，可以只缓存实时性强的字段，或者用vip制度，用户充钱越多，缓存的东西越多<br>核心思想就是成本增效","like_count":1,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592261,"discussion_content":"最后一句很棒，支持，笑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667266703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361014,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"北京","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1667115555,"is_pvip":true,"replies":[{"id":"131318","content":"你好，张申傲，感谢你的留言～","user_name":"作者回复","comment_id":361014,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667142945,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1667115555","product_id":100309001,"comment_content":"老师对于 JWT 的原理和最佳实践讲得很清楚👍🏻","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592138,"discussion_content":"你好，张申傲，感谢你的留言～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667142945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360949,"user_name":"Sky","can_delete":false,"product_type":"c1","uid":1392585,"ip_address":"北京","ucode":"4C5A5AB73E8B90","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","comment_is_top":false,"comment_ctime":1667023544,"is_pvip":false,"replies":[{"id":"131314","content":"你好，sky，很高兴收到你的留言，踢下线可以用网关黑名单方式，每个业务网关会解开token，发现redis中有这个uid以及低于指定版本，就会要求更换","user_name":"作者回复","comment_id":360949,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667043890,"user_name_real":"编辑"}],"discussion_count":4,"race_medal":0,"score":"1667023544","product_id":100309001,"comment_content":"token的方式是怎么处理多终端登录以及“踢下线”类似的功能的呢？","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592044,"discussion_content":"你好，sky，很高兴收到你的留言，踢下线可以用网关黑名单方式，每个业务网关会解开token，发现redis中有这个uid以及低于指定版本，就会要求更换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667043890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1392585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","nickname":"Sky","note":"","ucode":"4C5A5AB73E8B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":592073,"discussion_content":"如果还是要访问redis的话，每个用户登录的时候都要check一下redis，似乎与session的模式区别不大。另外如果要做多终端登录，一个账号可以在手机和电脑登录，并且一个终端只能保持一个登录，如果用token的方式似乎没有办法实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667062318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":592044,"ip_address":"上海"},"score":592073,"extra":""},{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1392585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","nickname":"Sky","note":"","ucode":"4C5A5AB73E8B90","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592169,"discussion_content":"你好，sky，很高兴能够收到你的深度思考，这里的redis是网关使用的redis和用户中心集中管理有些不一样，他可以并行多个实例，至于踢出消息如何同步可以用kafka广播发放即可。\n\n使用token如果需要互斥可以让网关的redis共同维护一个用户版本，这个版本是用来区分token是否过期，每次客户端登录的时候刷新这个版本就可以让网关发现他不是一套设备。最后，这个方案核心是降低用户中心的依赖和降低请求压力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667183813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":592073,"ip_address":"北京"},"score":592169,"extra":""},{"author":{"id":1392585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","nickname":"Sky","note":"","ucode":"4C5A5AB73E8B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":592247,"discussion_content":"谢谢解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667236817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":592169,"ip_address":"上海"},"score":592247,"extra":""}]}]},{"had_liked":false,"id":360930,"user_name":"Geek_00乐","can_delete":false,"product_type":"c1","uid":3012150,"ip_address":"北京","ucode":"30D3202B6D25DE","user_header":"https://static001.geekbang.org/account/avatar/00/2d/f6/36/a71438d8.jpg","comment_is_top":false,"comment_ctime":1667008207,"is_pvip":true,"replies":[{"id":"131300","content":"你好，Geek_00乐，很高兴你的心得分享，同时补充一句～子系统不会每次都问询用户中心～导致了这个问题","user_name":"作者回复","comment_id":360930,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667031762,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1667008207","product_id":100309001,"comment_content":"用户如果被拉黑，客户端最快也要在 token 过期后才能退出登陆，这让我们的管理存在一定的延迟。","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592016,"discussion_content":"你好，Geek_00乐，很高兴你的心得分享，同时补充一句～子系统不会每次都问询用户中心～导致了这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667031762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}