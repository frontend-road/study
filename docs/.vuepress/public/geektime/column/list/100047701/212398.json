{"id":212398,"title":"32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）","content":"<p>你好，我是朱晔。</p><p>上一讲的几个例子中，其实都涉及了Stream API的最基本使用方法。今天，我会与你详细介绍复杂、功能强大的Stream API。</p><p>Stream流式操作，用于对集合进行投影、转换、过滤、排序等，更进一步地，这些操作能链式串联在一起使用，类似于SQL语句，可以大大简化代码。可以说，Stream操作是Java 8中最重要的内容，也是这个课程大部分代码都会用到的操作。</p><p>我先说明下，有些案例可能不太好理解，建议你对着代码逐一到源码中查看Stream操作的方法定义，以及JDK中的代码注释。</p><h2>Stream操作详解</h2><p>为了方便你理解Stream的各种操作，以及后面的案例，我先把这节课涉及的Stream操作汇总到了一张图中。你可以先熟悉一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/44/04/44a6f4cb8b413ef62c40a272cb474104.jpg?wh=3521*2617\" alt=\"\"></p><p>在接下来的讲述中，我会围绕订单场景，给出如何使用Stream的各种API完成订单的统计、搜索、查询等功能，和你一起学习Stream流式操作的各种方法。你可以结合代码中的注释理解案例，也可以自己运行源码观察输出。</p><p>我们先定义一个订单类、一个订单商品类和一个顾客类，用作后续Demo代码的数据结构：</p><pre><code>//订单类\n@Data\npublic class Order {\n    private Long id;\n    private Long customerId;//顾客ID\n    private String customerName;//顾客姓名\n    private List&lt;OrderItem&gt; orderItemList;//订单商品明细\n    private Double totalPrice;//总价格\n    private LocalDateTime placedAt;//下单时间\n}\n//订单商品类\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class OrderItem {\n    private Long productId;//商品ID\n    private String productName;//商品名称\n    private Double productPrice;//商品价格\n    private Integer productQuantity;//商品数量\n}\n//顾客类\n@Data\n@AllArgsConstructor\npublic class Customer {\n    private Long id;\n    private String name;//顾客姓名\n}\n</code></pre><p>在这里，我们有一个orders字段保存了一些模拟数据，类型是List<order>。这里，我就不贴出生成模拟数据的代码了。这不会影响你理解后面的代码，你也可以自己下载源码阅读。</order></p><!-- [[[read_end]]] --><h3>创建流</h3><p>要使用流，就要先创建流。创建流一般有五种方式：</p><ul>\n<li>通过stream方法把List或数组转换为流；</li>\n<li>通过Stream.of方法直接传入多个元素构成一个流；</li>\n<li>通过Stream.iterate方法使用迭代的方式构造一个无限流，然后使用limit限制流元素个数；</li>\n<li>通过Stream.generate方法从外部传入一个提供元素的Supplier来构造无限流，然后使用limit限制流元素个数；</li>\n<li>通过IntStream或DoubleStream构造基本类型的流。</li>\n</ul><pre><code>//通过stream方法把List或数组转换为流\n@Test\npublic void stream()\n{\n    Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;).stream().forEach(System.out::println);\n    Arrays.stream(new int[]{1, 2, 3}).forEach(System.out::println);\n}\n\n//通过Stream.of方法直接传入多个元素构成一个流\n@Test\npublic void of()\n{\n    String[] arr = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};\n    Stream.of(arr).forEach(System.out::println);\n    Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).forEach(System.out::println);\n    Stream.of(1, 2, &quot;a&quot;).map(item -&gt; item.getClass().getName()).forEach(System.out::println);\n}\n\n//通过Stream.iterate方法使用迭代的方式构造一个无限流，然后使用limit限制流元素个数\n@Test\npublic void iterate()\n{\n    Stream.iterate(2, item -&gt; item * 2).limit(10).forEach(System.out::println);\n    Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.TEN)).limit(10).forEach(System.out::println);\n}\n\n//通过Stream.generate方法从外部传入一个提供元素的Supplier来构造无限流，然后使用limit限制流元素个数\n@Test\npublic void generate()\n{\n    Stream.generate(() -&gt; &quot;test&quot;).limit(3).forEach(System.out::println);\n    Stream.generate(Math::random).limit(10).forEach(System.out::println);\n}\n\n//通过IntStream或DoubleStream构造基本类型的流\n@Test\npublic void primitive()\n{\n    //演示IntStream和DoubleStream\n    IntStream.range(1, 3).forEach(System.out::println);\n    IntStream.range(0, 3).mapToObj(i -&gt; &quot;x&quot;).forEach(System.out::println);\n\n    IntStream.rangeClosed(1, 3).forEach(System.out::println);\n    DoubleStream.of(1.1, 2.2, 3.3).forEach(System.out::println);\n\n    //各种转换，后面注释代表了输出结果\n    System.out.println(IntStream.of(1, 2).toArray().getClass()); //class [I\n    System.out.println(Stream.of(1, 2).mapToInt(Integer::intValue).toArray().getClass()); //class [I\n    System.out.println(IntStream.of(1, 2).boxed().toArray().getClass()); //class [Ljava.lang.Object;\n    System.out.println(IntStream.of(1, 2).asDoubleStream().toArray().getClass()); //class [D\n    System.out.println(IntStream.of(1, 2).asLongStream().toArray().getClass()); //class [J\n\n    //注意基本类型流和装箱后的流的区别\n    Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).stream()   // Stream&lt;String&gt;\n            .mapToInt(String::length)       // IntStream\n            .asLongStream()                 // LongStream\n            .mapToDouble(x -&gt; x / 10.0)     // DoubleStream\n            .boxed()                        // Stream&lt;Double&gt;\n            .mapToLong(x -&gt; 1L)             // LongStream\n            .mapToObj(x -&gt; &quot;&quot;)              // Stream&lt;String&gt;\n            .collect(Collectors.toList());\n}\n</code></pre><h3>filter</h3><p>filter方法可以实现过滤操作，类似SQL中的where。我们可以使用一行代码，通过filter方法实现查询所有订单中最近半年金额大于40的订单，通过连续叠加filter方法进行多次条件过滤：</p><pre><code>//最近半年的金额大于40的订单\norders.stream()\n        .filter(Objects::nonNull) //过滤null值\n        .filter(order -&gt; order.getPlacedAt().isAfter(LocalDateTime.now().minusMonths(6))) //最近半年的订单\n        .filter(order -&gt; order.getTotalPrice() &gt; 40) //金额大于40的订单\n        .forEach(System.out::println);\t\n</code></pre><p>如果不使用Stream的话，必然需要一个中间集合来收集过滤后的结果，而且所有的过滤条件会堆积在一起，代码冗长且不易读。</p><h3>map</h3><p>map操作可以做转换（或者说投影），类似SQL中的select。为了对比，我用两种方式统计订单中所有商品的数量，前一种是通过两次遍历实现，后一种是通过两次mapToLong+sum方法实现：</p><pre><code>//计算所有订单商品数量\n//通过两次遍历实现\nLongAdder longAdder = new LongAdder();\norders.stream().forEach(order -&gt;\n        order.getOrderItemList().forEach(orderItem -&gt; longAdder.add(orderItem.getProductQuantity())));\n\n//使用两次mapToLong+sum方法实现\nassertThat(longAdder.longValue(), is(orders.stream().mapToLong(order -&gt;\n        order.getOrderItemList().stream()\n                .mapToLong(OrderItem::getProductQuantity).sum()).sum()));\n</code></pre><p>显然，后一种方式无需中间变量longAdder，更直观。</p><p>这里再补充一下，使用for循环生成数据，是我们平时常用的操作，也是这个课程会大量用到的。现在，我们可以用一行代码使用IntStream配合mapToObj替代for循环来生成数据，比如生成10个Product元素构成List：</p><pre><code>//把IntStream通过转换Stream&lt;Project&gt;\nSystem.out.println(IntStream.rangeClosed(1,10)\n        .mapToObj(i-&gt;new Product((long)i, &quot;product&quot;+i, i*100.0))\n        .collect(toList()));\n</code></pre><h3>flatMap</h3><p>接下来，我们看看flatMap展开或者叫扁平化操作，相当于map+flat，通过map把每一个元素替换为一个流，然后展开这个流。</p><p>比如，我们要统计所有订单的总价格，可以有两种方式：</p><ul>\n<li>直接通过原始商品列表的商品个数*商品单价统计的话，可以先把订单通过flatMap展开成商品清单，也就是把Order替换为Stream<orderitem>，然后对每一个OrderItem用mapToDouble转换获得商品总价，最后进行一次sum求和；</orderitem></li>\n<li>利用flatMapToDouble方法把列表中每一项展开替换为一个DoubleStream，也就是直接把每一个订单转换为每一个商品的总价，然后求和。</li>\n</ul><pre><code>//直接展开订单商品进行价格统计\nSystem.out.println(orders.stream()\n        .flatMap(order -&gt; order.getOrderItemList().stream())\n        .mapToDouble(item -&gt; item.getProductQuantity() * item.getProductPrice()).sum());\n\n//另一种方式flatMap+mapToDouble=flatMapToDouble\nSystem.out.println(orders.stream()\n        .flatMapToDouble(order -&gt;\n                order.getOrderItemList()\n                        .stream().mapToDouble(item -&gt; item.getProductQuantity() * item.getProductPrice()))\n        .sum());\n</code></pre><p>这两种方式可以得到相同的结果，并无本质区别。</p><h3>sorted</h3><p>sorted操作可以用于行内排序的场景，类似SQL中的order by。比如，要实现大于50元订单的按价格倒序取前5，可以通过Order::getTotalPrice方法引用直接指定需要排序的依据字段，通过reversed()实现倒序：</p><pre><code>//大于50的订单,按照订单价格倒序前5\norders.stream().filter(order -&gt; order.getTotalPrice() &gt; 50)\n        .sorted(comparing(Order::getTotalPrice).reversed())\n        .limit(5)\n        .forEach(System.out::println);\t\n</code></pre><h3>distinct</h3><p>distinct操作的作用是去重，类似SQL中的distinct。比如下面的代码实现：</p><ul>\n<li>查询去重后的下单用户。使用map从订单提取出购买用户，然后使用distinct去重。</li>\n<li>查询购买过的商品名。使用flatMap+map提取出订单中所有的商品名，然后使用distinct去重。</li>\n</ul><pre><code>//去重的下单用户\nSystem.out.println(orders.stream().map(order -&gt; order.getCustomerName()).distinct().collect(joining(&quot;,&quot;)));\n\n//所有购买过的商品\nSystem.out.println(orders.stream()\n        .flatMap(order -&gt; order.getOrderItemList().stream())\n        .map(OrderItem::getProductName)\n        .distinct().collect(joining(&quot;,&quot;)));\n</code></pre><h3>skip &amp; limit</h3><p>skip和limit操作用于分页，类似MySQL中的limit。其中，skip实现跳过一定的项，limit用于限制项总数。比如下面的两段代码：</p><ul>\n<li>按照下单时间排序，查询前2个订单的顾客姓名和下单时间；</li>\n<li>按照下单时间排序，查询第3和第4个订单的顾客姓名和下单时间。</li>\n</ul><pre><code>//按照下单时间排序，查询前2个订单的顾客姓名和下单时间\norders.stream()\n        .sorted(comparing(Order::getPlacedAt))\n        .map(order -&gt; order.getCustomerName() + &quot;@&quot; + order.getPlacedAt())\n        .limit(2).forEach(System.out::println);\n//按照下单时间排序，查询第3和第4个订单的顾客姓名和下单时间\norders.stream()\n        .sorted(comparing(Order::getPlacedAt))\n        .map(order -&gt; order.getCustomerName() + &quot;@&quot; + order.getPlacedAt())\n        .skip(2).limit(2).forEach(System.out::println);\n</code></pre><h3>collect</h3><p>collect是收集操作，对流进行终结（终止）操作，把流导出为我们需要的数据结构。“终结”是指，导出后，无法再串联使用其他中间操作，比如filter、map、flatmap、sorted、distinct、limit、skip。</p><p>在Stream操作中，collect是最复杂的终结操作，比较简单的终结操作还有forEach、toArray、min、max、count、anyMatch等，我就不再展开了，你可以查询<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\">JDK文档</a>，搜索terminal operation或intermediate operation。</p><p>接下来，我通过6个案例，来演示下几种比较常用的collect操作：</p><ul>\n<li>第一个案例，实现了字符串拼接操作，生成一定位数的随机字符串。</li>\n<li>第二个案例，通过Collectors.toSet静态方法收集为Set去重，得到去重后的下单用户，再通过Collectors.joining静态方法实现字符串拼接。</li>\n<li>第三个案例，通过Collectors.toCollection静态方法获得指定类型的集合，比如把List<order>转换为LinkedList<order>。</order></order></li>\n<li>第四个案例，通过Collectors.toMap静态方法将对象快速转换为Map，Key是订单ID、Value是下单用户名。</li>\n<li>第五个案例，通过Collectors.toMap静态方法将对象转换为Map。Key是下单用户名，Value是下单时间，一个用户可能多次下单，所以直接在这里进行了合并，只获取最近一次的下单时间。</li>\n<li>第六个案例，使用Collectors.summingInt方法对商品数量求和，再使用Collectors.averagingInt方法对结果求平均值，以统计所有订单平均购买的商品数量。</li>\n</ul><pre><code>//生成一定位数的随机字符串\nSystem.out.println(random.ints(48, 122)\n    .filter(i -&gt; (i &lt; 57 || i &gt; 65) &amp;&amp; (i &lt; 90 || i &gt; 97))\n    .mapToObj(i -&gt; (char) i)\n    .limit(20)\n    .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append)\n    .toString());\n\n//所有下单的用户，使用toSet去重后实现字符串拼接\nSystem.out.println(orders.stream()\n    .map(order -&gt; order.getCustomerName()).collect(toSet())\n    .stream().collect(joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;)));\n\n//用toCollection收集器指定集合类型\nSystem.out.println(orders.stream().limit(2).collect(toCollection(LinkedList::new)).getClass());\n\n//使用toMap获取订单ID+下单用户名的Map\norders.stream()\n    .collect(toMap(Order::getId, Order::getCustomerName))\n    .entrySet().forEach(System.out::println);\n\n//使用toMap获取下单用户名+最近一次下单时间的Map\norders.stream()\n    .collect(toMap(Order::getCustomerName, Order::getPlacedAt, (x, y) -&gt; x.isAfter(y) ? x : y))\n    .entrySet().forEach(System.out::println);\n\n//订单平均购买的商品数量\nSystem.out.println(orders.stream().collect(averagingInt(order -&gt;\n    order.getOrderItemList().stream()\n            .collect(summingInt(OrderItem::getProductQuantity)))));\n</code></pre><p>可以看到，这6个操作使用Stream方式一行代码就可以实现，但使用非Stream方式实现的话，都需要几行甚至十几行代码。</p><p>有关Collectors类的一些常用静态方法，我总结到了一张图中，你可以再整理一下思路：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/de/5af5ba60d7af2c8780b69bc6c71cf3de.png?wh=2923*2375\" alt=\"\"></p><p>其中，groupBy和partitionBy比较复杂，我和你举例介绍。</p><h3>groupBy</h3><p>groupBy是分组统计操作，类似SQL中的group by子句。它和后面介绍的partitioningBy都是特殊的收集器，同样也是终结操作。分组操作比较复杂，为帮你理解得更透彻，我准备了8个案例：</p><ul>\n<li>第一个案例，按照用户名分组，使用Collectors.counting方法统计每个人的下单数量，再按照下单数量倒序输出。</li>\n<li>第二个案例，按照用户名分组，使用Collectors.summingDouble方法统计订单总金额，再按总金额倒序输出。</li>\n<li>第三个案例，按照用户名分组，使用两次Collectors.summingInt方法统计商品采购数量，再按总数量倒序输出。</li>\n<li>第四个案例，统计被采购最多的商品。先通过flatMap把订单转换为商品，然后把商品名作为Key、Collectors.summingInt作为Value分组统计采购数量，再按Value倒序获取第一个Entry，最后查询Key就得到了售出最多的商品。</li>\n<li>第五个案例，同样统计采购最多的商品。相比第四个案例排序Map的方式，这次直接使用Collectors.maxBy收集器获得最大的Entry。</li>\n<li>第六个案例，按照用户名分组，统计用户下的金额最高的订单。Key是用户名，Value是Order，直接通过Collectors.maxBy方法拿到金额最高的订单，然后通过collectingAndThen实现Optional.get的内容提取，最后遍历Key/Value即可。</li>\n<li>第七个案例，根据下单年月分组统计订单ID列表。Key是格式化成年月后的下单时间，Value直接通过Collectors.mapping方法进行了转换，把订单列表转换为订单ID构成的List。</li>\n<li>第八个案例，根据下单年月+用户名两次分组统计订单ID列表，相比上一个案例多了一次分组操作，第二次分组是按照用户名进行分组。</li>\n</ul><pre><code>//按照用户名分组，统计下单数量\nSystem.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, counting()))\n        .entrySet().stream().sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed()).collect(toList()));\n\n//按照用户名分组，统计订单总金额\nSystem.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, summingDouble(Order::getTotalPrice)))\n        .entrySet().stream().sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed()).collect(toList()));\n\n//按照用户名分组，统计商品采购数量\nSystem.out.println(orders.stream().collect(groupingBy(Order::getCustomerName,\n        summingInt(order -&gt; order.getOrderItemList().stream()\n                .collect(summingInt(OrderItem::getProductQuantity)))))\n        .entrySet().stream().sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()).collect(toList()));\n\n//统计最受欢迎的商品，倒序后取第一个\norders.stream()\n        .flatMap(order -&gt; order.getOrderItemList().stream())\n        .collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))\n        .entrySet().stream()\n        .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed())\n        .map(Map.Entry::getKey)\n        .findFirst()\n        .ifPresent(System.out::println);\n\n//统计最受欢迎的商品的另一种方式，直接利用maxBy\norders.stream()\n        .flatMap(order -&gt; order.getOrderItemList().stream())\n        .collect(groupingBy(OrderItem::getProductName, summingInt(OrderItem::getProductQuantity)))\n        .entrySet().stream()\n        .collect(maxBy(Map.Entry.comparingByValue()))\n        .map(Map.Entry::getKey)\n        .ifPresent(System.out::println);\n\n//按照用户名分组，选用户下的总金额最大的订单\norders.stream().collect(groupingBy(Order::getCustomerName, collectingAndThen(maxBy(comparingDouble(Order::getTotalPrice)), Optional::get)))\n        .forEach((k, v) -&gt; System.out.println(k + &quot;#&quot; + v.getTotalPrice() + &quot;@&quot; + v.getPlacedAt()));\n\n//根据下单年月分组，统计订单ID列表\nSystem.out.println(orders.stream().collect\n        (groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(&quot;yyyyMM&quot;)),\n                mapping(order -&gt; order.getId(), toList()))));\n\n//根据下单年月+用户名两次分组，统计订单ID列表\nSystem.out.println(orders.stream().collect\n        (groupingBy(order -&gt; order.getPlacedAt().format(DateTimeFormatter.ofPattern(&quot;yyyyMM&quot;)),\n                groupingBy(order -&gt; order.getCustomerName(),\n                        mapping(order -&gt; order.getId(), toList())))));\n</code></pre><p>如果不借助Stream转换为普通的Java代码，实现这些复杂的操作可能需要几十行代码。</p><h3>partitionBy</h3><p>partitioningBy用于分区，分区是特殊的分组，只有true和false两组。比如，我们把用户按照是否下单进行分区，给partitioningBy方法传入一个Predicate作为数据分区的区分，输出是Map&lt;Boolean, List&lt;T&gt;&gt;：</p><pre><code>public static &lt;T&gt;\nCollector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate) {\n    return partitioningBy(predicate, toList());\n}\n</code></pre><p>测试一下，partitioningBy配合anyMatch，可以把用户分为下过订单和没下过订单两组：</p><pre><code>//根据是否有下单记录进行分区\nSystem.out.println(Customer.getData().stream().collect(\n        partitioningBy(customer -&gt; orders.stream().mapToLong(Order::getCustomerId)\n                .anyMatch(id -&gt; id == customer.getId()))));\n</code></pre><h2>重点回顾</h2><p>今天，我用了大量的篇幅和案例，和你展开介绍了Stream中很多具体的流式操作方法。有些案例可能不太好理解，我建议你对着代码逐一到源码中查看这些操作的方法定义，以及JDK中的代码注释。</p><p>最后，我建议你思考下，在日常工作中还会使用SQL统计哪些信息，这些SQL是否也可以用Stream来改写呢？Stream的API博大精深，但其中又有规律可循。这其中的规律主要就是，理清楚这些API传参的函数式接口定义，就能搞明白到底是需要我们提供数据、消费数据、还是转换数据等。那，掌握Stream的方法便是，多测试多练习，以强化记忆、加深理解。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>使用Stream可以非常方便地对List做各种操作，那有没有什么办法可以实现在整个过程中观察数据变化呢？比如，我们进行filter+map操作，如何观察filter后map的原始数据呢？</li>\n<li>Collectors类提供了很多现成的收集器，那我们有没有办法实现自定义的收集器呢？比如，实现一个MostPopularCollector，来得到List中出现次数最多的元素，满足下面两个测试用例：</li>\n</ol><pre><code>assertThat(Stream.of(1, 1, 2, 2, 2, 3, 4, 5, 5).collect(new MostPopularCollector&lt;&gt;()).get(), is(2));\nassertThat(Stream.of('a', 'b', 'c', 'c', 'c', 'd').collect(new MostPopularCollector&lt;&gt;()).get(), is('c'));\n</code></pre><p>关于Java 8，你还有什么使用心得吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）","id":212374},"right":{"article_title":"33 | 加餐3：定位应用问题，排错套路很重要","id":221982}},"comments":[{"had_liked":false,"id":188835,"user_name":"海拉鲁","can_delete":false,"product_type":"c1","uid":1048681,"ip_address":"","ucode":"6E3493295CED6F","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/69/3b1375ca.jpg","comment_is_top":true,"comment_ctime":1584423926,"is_pvip":true,"replies":[{"id":"72851","content":"👍🏻","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584424913,"ip_address":"","comment_id":188835,"utype":1}],"discussion_count":2,"race_medal":1,"score":"9.2233720813889004e+18","product_id":100047701,"comment_content":"为了写作业又去翻了《Java 8 实战》，测试终于通过了<br>public class MostPopularCollector<br>        implements Collector&lt;Object,   &#47;&#47; 收集String流<br>        Map&lt;Object, Integer&gt;,         &#47;&#47; 累加器是一个Map，key为字符，value为出现的次数<br>        Optional&gt;                     &#47;&#47; 返回的是出现次数最多的字符<br>{<br><br>    &#47;**<br>     * 返回一个在调用时创建的累加器<br>     * @return<br>     *&#47;<br>    public Supplier&lt;Map&lt;Object, Integer&gt;&gt; supplier() {<br>        return () -&gt; new HashMap&lt;&gt;();<br>    }<br><br>    &#47;**<br>     * 定义收集流中数据逻辑<br>     * @return<br>     *&#47;<br>    public BiConsumer&lt;Map&lt;Object, Integer&gt;, Object&gt; accumulator() {<br>        return (Map&lt;Object, Integer&gt; acc, Object chart) -&gt;<br>            acc.compute(chart, (key, val) -&gt; val == null ? 1 : val + 1); &#47;&#47; 如果当前字符未统计则统计为1，否则+1<br>    }<br><br>    &#47;**<br>     * 处理并行操作，其实就是将两个map合成一个，把value加起来<br>     * @return<br>     *&#47;<br>    public BinaryOperator&lt;Map&lt;Object, Integer&gt;&gt; combiner() {<br>        return (Map&lt;Object, Integer&gt; m1,<br>                Map&lt;Object, Integer&gt; m2) -&gt; {<br>            Map&lt;Object, Integer&gt; all = new HashMap&lt;&gt;(m1);<br>            m2.forEach((chart, count) -&gt; all.merge(chart, count, Integer::sum));<br>            return all;<br>        };<br>    }<br><br>    public Function&lt;Map&lt;Object, Integer&gt;, Optional&gt; finisher() {<br>        return (Map&lt;Object, Integer&gt; acc) -&gt; Optional.ofNullable(acc.entrySet()<br>                .stream()<br>                .max(Map.Entry.comparingByValue())<br>                .get().getKey());<br>    }<br><br><br>    public Set&lt;Characteristics&gt; characteristics() {<br>        return Collections.unmodifiableSet(EnumSet.of(Characteristics.CONCURRENT));<br>    }<br>}<br>","like_count":10,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487544,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584424913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1992424,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep3sqfTQey7eKYgGibLnAvaNj9k8gVvIYKVADicOA3DxmXZcDrAkeM8iaJLruiblmEVUr3q2LOVLvYicTw/132","nickname":"郑先生","note":"","ucode":"AA0BA751C4F132","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285614,"discussion_content":"// 略微做了点改动，结合老师之前讲的统计个数的案例，感觉这样更符合老师要求吧，个人愚见>~<\n// Collector<T, A, R>：T 中间操作类型，A 结果类型，R 最终返回类型，一般情况下，A=R\npublic class MostPopularCollector2<T>\n        implements Collector<T, // 收集String流\n        Map<T, LongAdder>, // 累加器是一个Map，key为字符，value为出现的次数\n        Optional<T> > // 返回的是出现次数最多的字符\n{\n\n    /**\n     * 返回一个在调用时创建的累加器 // 源数据对象类型（中间操作对象类型）\n     */\n    public Supplier<Map<T, LongAdder>> supplier() {\n        return ConcurrentHashMap::new;\n    }\n\n    /**\n     * 定义收集流中数据逻辑 // T 中间操作类型\n     */\n    public BiConsumer<Map<T, LongAdder>, T> accumulator() {\n        return (Map<T, LongAdder> acc, T t) ->\n                acc.computeIfAbsent(t, k -> new LongAdder()).increment();\n    }\n\n    /**\n     * 处理并行操作，其实就是将两个map合成一个，把value加起来 //合并部分结果\n     */\n    public BinaryOperator<Map<T, LongAdder>> combiner() {\n        return (m1, m2) -> {\n            m1.forEach((key, val) -> m2.computeIfAbsent(key, k -> new LongAdder()).add(val.longValue()));\n            return m2;\n        };\n    }\n\n    /**\n     * 可选，对结果集的转换\n     */\n    public Function<Map<T, LongAdder>, Optional<T>> finisher() {\n        return acc -> Optional.ofNullable(acc.entrySet()\n                .stream()\n                .max(Comparator.comparingLong(val -> val.getValue().longValue()))\n                .get().getKey());\n    }\n\n    /**\n     *  当前收集器的特性\n     *   CONCURRENT,// 并发\n     *   UNORDERED,// 收集操作不能保证保留顺序\n     *   IDENTITY_FINISH // 标识 finisher 就是 identity（同一性） 函数，类型转换要求必须成功。 A=R时设置，此时finisher不执行\n     */\n    public Set<Characteristics> characteristics() {\n        return Collections.unmodifiableSet(EnumSet.of(Characteristics.CONCURRENT));\n    }","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1592894516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188742,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":true,"comment_ctime":1584410230,"is_pvip":false,"replies":[{"id":"72802","content":"是的，这是一种方法，此外IDEA已经增加了非常方便的Stream调试功能，可以参考https:&#47;&#47;www.jetbrains.com&#47;help&#47;idea&#47;analyze-java-stream-operations.html","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584411773,"ip_address":"","comment_id":188742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720685040005e+18","product_id":100047701,"comment_content":"Stream API 有个 peek 方法可以接收一个 consumer 来打印数据，可以接在任意 transformation 操作后面查看数据","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487505,"discussion_content":"是的，这是一种方法，此外IDEA已经增加了非常方便的Stream调试功能，可以参考https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584411773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190818,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":true,"comment_ctime":1584695661,"is_pvip":false,"replies":[{"id":"73333","content":"<br>private static List&lt;Map&gt; getNoRoomList(List&lt;Map&gt; inspectRooms, List&lt;Map&gt; items) {<br>        return items.stream().filter(item-&gt;inspectRooms.stream().noneMatch(inspectRoom-&gt;inspectRoom.get(&quot;project&quot;).equals(item.get(&quot;checkItem&quot;))))<br>                .collect(Collectors.toList());<br>    }","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584706312,"ip_address":"","comment_id":190818,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720556192993e+18","product_id":100047701,"comment_content":"private List&lt;Map&gt; getNoRoomList(List&lt;Map&gt; inspectRooms, List&lt;Map&gt; items) {<br>    boolean flag = false;<br>    List&lt;Map&gt; noInspectRoom = new ArrayList&lt;&gt;();<br>    for (Map item: items) {<br>        for (Map inspectRoom: inspectRooms) {<br>            if (inspectRoom.get(&quot;project&quot;).equals(item.get(&quot;checkItem&quot;))) {<br>                flag = true;<br>                break;<br>            }<br>        }<br>        if (!flag) {<br>            noInspectRoom.add(item);<br>        }else {<br>            flag = false;<br>        }<br>    }<br>    return noInspectRoom;<br>}<br><br>我直接贴我写的处理代码吧，应该可以理解我的想法，这测试用例还真不好写。","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488060,"discussion_content":"\nprivate static List&amp;lt;Map&amp;gt; getNoRoomList(List&amp;lt;Map&amp;gt; inspectRooms, List&amp;lt;Map&amp;gt; items) {\n        return items.stream().filter(item-&amp;gt;inspectRooms.stream().noneMatch(inspectRoom-&amp;gt;inspectRoom.get(&amp;quot;project&amp;quot;).equals(item.get(&amp;quot;checkItem&amp;quot;))))\n                .collect(Collectors.toList());\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584706312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190385,"user_name":"陈天柱","can_delete":false,"product_type":"c1","uid":1696225,"ip_address":"","ucode":"917BFDC845760D","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/e1/441df85d.jpg","comment_is_top":false,"comment_ctime":1584634814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35944373182","product_id":100047701,"comment_content":"老师把stream的常用api与sql操作联系起来，简直是太“亲民”了！","like_count":8},{"had_liked":false,"id":188937,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1584436052,"is_pvip":true,"replies":[{"id":"72888","content":"非常好","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584438820,"ip_address":"","comment_id":188937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35944174420","product_id":100047701,"comment_content":"以前真没有特意去关注收集器，看了做了，参考了2片文章：<br>https:&#47;&#47;www.cnblogs.com&#47;yw0219&#47;p&#47;9589124.html<br>https:&#47;&#47;my.oschina.net&#47;piorcn&#47;blog&#47;424375<br>最终搞定，请老师指点<br><br>https:&#47;&#47;github.com&#47;y645194203&#47;geektime-java-100&#47;blob&#47;master&#47;MostPopularCollector.java","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487571,"discussion_content":"非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584438820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188703,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1584406348,"is_pvip":false,"replies":[{"id":"72801","content":"IDEA已经增加了非常方便的Stream调试功能，可以参考https:&#47;&#47;www.jetbrains.com&#47;help&#47;idea&#47;analyze-java-stream-operations.html","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584411760,"ip_address":"","comment_id":188703,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23059242828","product_id":100047701,"comment_content":"我目前想到的数据观察的方式比较原始，一种是通过log打印，一种是debug。但我肯定这都不是啥好办法，希望老师告知解放生产力的方法。","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487494,"discussion_content":"IDEA已经增加了非常方便的Stream调试功能，可以参考https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584411760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210104,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1587687877,"is_pvip":false,"replies":[{"id":"78325","content":"还是需要自己想案例实际写一下代码","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587692357,"ip_address":"","comment_id":210104,"utype":1}],"discussion_count":2,"race_medal":1,"score":"18767557061","product_id":100047701,"comment_content":"每天晚上回去敲一点，花了好几个晚上，终于把这两节中的所有代码运行了一遍，只不过似懂非懂，还要继续练习。已经开始在工作中运用一些简单的了，读完这篇文章可能只需要20分钟，但把所有代码都练习一遍，就不是20分钟的事了，要持续学习才行。💪🏽","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492949,"discussion_content":"还是需要自己想案例实际写一下代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587692357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245794,"discussion_content":"收到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587700135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205520,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1586662583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18766531767","product_id":100047701,"comment_content":"Idea 在debug模式有个Trace Current Stream Chain功能，可以很好的查看数据变化","like_count":5},{"had_liked":false,"id":219147,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1589955726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179890318","product_id":100047701,"comment_content":"个人认为，客户端不安全的主要原因是，计算机网络协议。<br>网络环境中一切都是不可预知，切不安全的。<br>无法保证你发出去的数据，就是服务器要的数据；也无法保证你发的数据顺序是1，2，3服务器收到的就是1，2，3.有可能服务器收到的是【3，2，1】  【 2，1，3】 【 3，1，2】，甚至有可能【111】或者压根收不到。<br>在网络中，传输数据的方式，方式是广播，无条件转发，就是任何人都有可能收到，所以必要的就是加密。防止对方知道。<br>任何人都能收到，任何人也都有权力继续转发，谁都不敢保证，转发的时候会不会给你增加些不安全的信息。这也就是服务端需要校验。","like_count":2},{"had_liked":false,"id":197636,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1585388952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175323544","product_id":100047701,"comment_content":"我感觉，比较重要的是，function,optional,consumer,supplier,predicate接口。在stream的学习中，通过单词猜用法。","like_count":2},{"had_liked":false,"id":196469,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1585284016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175218608","product_id":100047701,"comment_content":"实用！","like_count":2},{"had_liked":false,"id":190032,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1584595905,"is_pvip":false,"replies":[{"id":"73134","content":"把测试用例帖一下，不太明白l1和l2是啥。。。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584599070,"ip_address":"","comment_id":190032,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174530497","product_id":100047701,"comment_content":"List&lt;Map&gt; l1，List&lt;Map&gt; l2，两个list，l1中有四个map，其中有key分别为1、2、3、4的四个字段，l2有两个map，其中有key分别为1，2的l1中一样的字段，怎么筛选最终得到一个list，只有key为3、4对应的两个map？写的比较乱，还请老师见谅，我想了下没想出来，最后for循环做的。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487859,"discussion_content":"把测试用例帖一下，不太明白l1和l2是啥。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584599070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189712,"user_name":"初见","can_delete":false,"product_type":"c1","uid":1305062,"ip_address":"","ucode":"14540A66AB6277","user_header":"https://static001.geekbang.org/account/avatar/00/13/e9/e6/ec76a623.jpg","comment_is_top":false,"comment_ctime":1584542016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174476608","product_id":100047701,"comment_content":"现在在生产实践用用了很多stream，看了文稿以后，发现自己在有些使用上串联的不够深入，等有时间针对那些操作进行深入的的串联","like_count":2},{"had_liked":false,"id":189672,"user_name":"insight","can_delete":false,"product_type":"c1","uid":1313322,"ip_address":"","ucode":"6F4E51502D0224","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/2a/c7f5d3ac.jpg","comment_is_top":false,"comment_ctime":1584539919,"is_pvip":false,"replies":[{"id":"73042","content":"看一下toArray的返回类型对比一下输出就知道了","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584540426,"ip_address":"","comment_id":189672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174474511","product_id":100047701,"comment_content":" &#47;&#47;各种转换，后面注释代表了输出结果    <br>System.out.println(IntStream.of(1, 2).toArray().getClass()); &#47;&#47;class [I    <br>System.out.println(Stream.of(1, 2).mapToInt(Integer::intValue).toArray().getClass()); &#47;&#47;class [I    System.out.println(IntStream.of(1, 2).boxed().toArray().getClass()); &#47;&#47;class [Ljava.lang.Object;    System.out.println(IntStream.of(1, 2).asDoubleStream().toArray().getClass()); &#47;&#47;class [D    System.out.println(IntStream.of(1, 2).asLongStream().toArray().getClass()); &#47;&#47;class [J<br><br>老师，这一段代码的输出结果为什么是这样的呀？没看懂，求指教！","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487764,"discussion_content":"看一下toArray的返回类型对比一下输出就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584540426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250662,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1601189030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5896156326","product_id":100047701,"comment_content":"发现使用的时候，经常会不知道到底该传入一个什么样子的函数或者lamda表达式","like_count":1},{"had_liked":false,"id":250659,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1601188233,"is_pvip":false,"replies":[{"id":"91752","content":"https:&#47;&#47;stackoverflow.com&#47;questions&#47;23699371&#47;java-8-distinct-by-property&#47;27872852#27872852","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1601198265,"ip_address":"","comment_id":250659,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5896155529","product_id":100047701,"comment_content":"在实际中，发现distinct需要根据元素类型的属性进行判断，这个时候就需要用别的方式了","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506253,"discussion_content":"https://stackoverflow.com/questions/23699371/java-8-distinct-by-property/27872852#27872852","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601198265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219208,"user_name":"大胖子呀、","can_delete":false,"product_type":"c1","uid":1258251,"ip_address":"","ucode":"4BADF8096254BE","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/0b/fd18c8ab.jpg","comment_is_top":false,"comment_ctime":1589966650,"is_pvip":false,"replies":[{"id":"80975","content":"按照客户直接进行分组聚合不是更简单","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589969795,"ip_address":"","comment_id":219208,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5884933946","product_id":100047701,"comment_content":"工作中遇到一个需求，计算运费：先从运费集合中找出同一个客户的数据，然后类似于累加数量（还有很多其他的逻辑）计算出运费（因为相同的客户数量超过一定数值会有优惠）。最后把计算出来的运费数据插入到数据库里。<br><br>我的做法是：以第一条数据的客户为基准，循环找出相同客户的数据，保存到一个新的集合中，同时从原数据集合里移除这条数据，最后计算出新集合里的运费就可以了。<br><br>感觉这种需求的话，好像就没办法用老师介绍的流方法来遍历计算了，因为不能删除数据，不知道我认为的是不是对的。<br><br>另外就我的实现来说，会不会出现问题？有没有更好的解决方案？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495717,"discussion_content":"按照客户直接进行分组聚合不是更简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589969795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1882517,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b9/95/cabab54b.jpg","nickname":"tong","note":"","ucode":"966DEDE81081D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283167,"discussion_content":"有个问题是，原数据需要其他处理吗，为什么要删除？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592202091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1258251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/0b/fd18c8ab.jpg","nickname":"大胖子呀、","note":"","ucode":"4BADF8096254BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1882517,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b9/95/cabab54b.jpg","nickname":"tong","note":"","ucode":"966DEDE81081D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283228,"discussion_content":"如果不删除，第二个数据和第一个数据是相同的，那么第二次循环就会把除了第一个数据以外其他的数据重新遍历一遍，计算出重复的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592216315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283167,"ip_address":""},"score":283228,"extra":""}]}]},{"had_liked":false,"id":216470,"user_name":"203。","can_delete":false,"product_type":"c1","uid":1903586,"ip_address":"","ucode":"25D508AB07A2FE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0b/e2/a4eddbe6.jpg","comment_is_top":false,"comment_ctime":1589266921,"is_pvip":false,"replies":[{"id":"80108","content":"比如下面的类，id1和id2重复认为是重复的，id3不需要考虑<br>@Data<br>    @Builder<br>    @NoArgsConstructor<br>    @AllArgsConstructor<br>    static class Test {<br>        private String id1;<br>        private String id2;<br>        @EqualsAndHashCode.Exclude<br>        private String id3;<br>    }<br><br>通过Set去重或者通过distinct去重即可：<br><br>List&lt;Test&gt; list = new ArrayList&lt;&gt;();<br>        list.add(new Test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));<br>        list.add(new Test(&quot;a&quot;,&quot;b&quot;,&quot;d&quot;));<br>        System.out.println(list.stream().collect(Collectors.toSet()));<br>        System.out.println(list.stream().distinct().collect(Collectors.toList()));","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589269971,"ip_address":"","comment_id":216470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884234217","product_id":100047701,"comment_content":"老师 我这里有个问题 关于Stream的，业务需求里需要按某几个字段去重(acctId,billingCycleId,prodInstId,offerId)<br>我这里想到了遍历集合areaDatas 后用contains方法判断 重写AcctItemYzfBean实体类的equals方法实现，<br>请问有没有更好的方法？ 代码如下<br><br>List&lt;AcctItemYzfBean&gt; newList = new CopyOnWriteArrayList&lt;&gt;();<br>&#47;&#47;循环过滤、增强翼支付数据<br>Optional.ofNullable(areaDatas)&#47;&#47;集合判空<br>\t\t.orElse(new ArrayList&lt;&gt;())<br>\t\t.stream()&#47;&#47;转化为流 便于下面过滤和增强数据<br>\t\t.filter(Objects::nonNull)&#47;&#47;元素判空<br>\t\t.filter(yzfBean -&gt; this.judgeIfOfferId(yzfBean))&#47;&#47;判断销售品ID是否相同<br>\t\t.filter(yzfBean -&gt; this.enhanceYzfBean(yzfBean))&#47;&#47;增强过滤accNbr和acctId<br>\t\t.filter(yzfBean -&gt; this.judgeIfArrears(yzfBean))&#47;&#47;判断是否不欠费<br>\t\t.filter(yzfBean -&gt; this.judgeIfCancel(yzfBean))&#47;&#47;判断是否销账金额大于0<br>\t\t.filter(yzfBean -&gt; this.judgeIfReturn(yzfBean))&#47;&#47;判断是否上月未返还<br>\t\t.forEach(yzfBean -&gt; {<br>\t\t\t&#47;&#47;去重 重写AcctItemYzfBean.equals方法<br>\t\t\tif(!newList.contains(yzfBean)) {<br>\t\t\t\t&#47;&#47;增强latnName<br>\t\t\t\tyzfBean.setLatnName(commonRegionMap.get(yzfBean.getRegionId()));<br>\t\t\t\t&#47;&#47;增强areaCode<br>\t\t\t\tyzfBean.setAreaCode(areaCode);<br>\t\t\t\t&#47;&#47;数据封装<br>\t\t\t\tnewList.add(yzfBean);<br>\t\t\t}<br>\t\t});<br><br>重写的equals方法\t\t<br>@Override<br>public boolean equals(Object yzfBeanObj) {<br>\tif(yzfBeanObj instanceof AcctItemYzfBean) {<br>\t\tAcctItemYzfBean yzfBean = (AcctItemYzfBean) yzfBeanObj;<br>\t\tif(Tools.isEmpty(yzfBean.getAcctId(), yzfBean.getBillingCycleId(), yzfBean.getProdInstId(),  yzfBean.getOfferId())) {<br>\t\t\treturn false;<br>\t\t}<br>\t\tif(yzfBean.getAcctId().equals(this.acctId) &amp;&amp; yzfBean.getBillingCycleId().equals(this.billingCycleId)<br>\t\t\t\t&amp;&amp; yzfBean.getProdInstId().equals(this.prodInstId) &amp;&amp; yzfBean.getOfferId().equals(this.offerId)) {<br>\t\t\treturn true;<br>\t\t}<br>\t}<br>\treturn super.equals(yzfBeanObj);<br>}","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494831,"discussion_content":"比如下面的类，id1和id2重复认为是重复的，id3不需要考虑\n@Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    static class Test {\n        private String id1;\n        private String id2;\n        @EqualsAndHashCode.Exclude\n        private String id3;\n    }\n\n通过Set去重或者通过distinct去重即可：\n\nList&amp;lt;Test&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();\n        list.add(new Test(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;));\n        list.add(new Test(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;d&amp;quot;));\n        System.out.println(list.stream().collect(Collectors.toSet()));\n        System.out.println(list.stream().distinct().collect(Collectors.toList()));","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589269971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201172,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1585727891,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5880695187","product_id":100047701,"comment_content":"这个文章算是我读起来最吃力的一篇了，哈哈哈，多读读，一时间肯定不能消化","like_count":1},{"had_liked":false,"id":194732,"user_name":"阿怪","can_delete":false,"product_type":"c1","uid":1348349,"ip_address":"","ucode":"323F6F737DFD4F","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/fd/e507a8fb.jpg","comment_is_top":false,"comment_ctime":1585100366,"is_pvip":false,"replies":[{"id":"74084","content":"觉得好可以多分享","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585103217,"ip_address":"","comment_id":194732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880067662","product_id":100047701,"comment_content":"每天上下班阅读，收获满满","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488883,"discussion_content":"觉得好可以多分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585103217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189533,"user_name":"婷","can_delete":false,"product_type":"c1","uid":1612372,"ip_address":"","ucode":"1264B8F777B7CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/9a/54/5d51fda4.jpg","comment_is_top":false,"comment_ctime":1584526033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879493329","product_id":100047701,"comment_content":"打卡 今天收获又不少 感谢老师","like_count":1},{"had_liked":false,"id":351719,"user_name":"永远不要低估一颗冠军的心","can_delete":false,"product_type":"c1","uid":1339230,"ip_address":"","ucode":"FF0DD7382CD3CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/6f/5e/3f7e9ccd.jpg","comment_is_top":false,"comment_ctime":1658127021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658127021","product_id":100047701,"comment_content":" orders 字段保存了一些模拟数据在哪里可以下载呢？","like_count":0},{"had_liked":false,"id":334658,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1645061467,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1645061467","product_id":100047701,"comment_content":".collect(StringBuilder::new, StringBuilder::append, StringBuilder::append)<br>老师，这里没有太懂， 为啥需要两次StringBuilder::append呢","like_count":0},{"had_liked":false,"id":328673,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1640832154,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640832154","product_id":100047701,"comment_content":"太秀了 没想到会有这些操作","like_count":0},{"had_liked":false,"id":278097,"user_name":"夏目🐳","can_delete":false,"product_type":"c1","uid":1101227,"ip_address":"","ucode":"4ED932E1F66F76","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ab/1c3dc64b.jpg","comment_is_top":false,"comment_ctime":1612759536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612759536","product_id":100047701,"comment_content":"如果订单金额是BigDecimal，怎么在分组的时候合并金额呢&#47;&#47;按照用户名分组，统计订单总金额<br>System.out.println(orders.stream().collect(groupingBy(Order::getCustomerName, summingDouble(Order::getTotalPrice)))","like_count":0}]}