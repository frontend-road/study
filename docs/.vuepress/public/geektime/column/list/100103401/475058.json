{"id":475058,"title":"05 | object关键字：你到底有多少种用法？","content":"<p>你好，我是朱涛。这节课我们来学习Kotlin当中object关键字的三种语义，以及它的具体使用场景。</p><p>在前面课程中，我们学习了Kotlin语言的基础语法和面向对象相关的语法，其中涵盖了很多不同类型的关键字。比如说，fun关键字代表了定义函数，class关键字代表了定义类，这些都是一成不变的。但是今天我们要学习的object关键字，却有三种迥然不同的语义，分别可以定义：</p><ul>\n<li>匿名内部类；</li>\n<li>单例模式；</li>\n<li>伴生对象。</li>\n</ul><p>之所以会出现这样的情况，是因为Kotlin的设计者认为，这三种语义本质上都是<strong>在定义一个类的同时还创建了对象</strong>。在这样的情况下，与其分别定义三种不同的关键字，还不如将它们统一成object关键字。</p><p>那么，理解object关键字背后的统一语义，对我们学习这个语法是极其关键的，因为它才是这三种不同语义背后的共同点。通过这个统一语义，我们可以在这三种语义之间建立联系，形成知识体系。这样，我们在后面的学习中才不会那么容易迷失，也不会那么容易遗忘。</p><p>接下来，我们就一起来逐一探讨这三种情况吧。</p><h2>object：匿名内部类</h2><p>首先是object定义的匿名内部类。</p><p>Java当中其实也有匿名内部类的概念，这里我们可以通过跟Java的对比，来具体理解下Kotlin中对匿名内部类的定义。</p><!-- [[[read_end]]] --><p>在Java开发当中，我们经常需要写类似这样的代码：</p><pre><code class=\"language-java\">public interface OnClickListener {\n    void onClick(View v);\n}\n\nimage.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        gotoPreview();\n    }\n});\n</code></pre><p>这就是典型的匿名内部类的写法，View.OnClickListener是一个接口，因此我们在创建它的时候，必须<strong>实现它内部没有实现的方法</strong>。</p><p>类似地，在Kotlin当中，我们会使用object关键字来创建匿名内部类。同样，在它的内部，我们也必须要实现它内部未实现的方法。这种方式不仅可以用于创建接口的匿名内部类，也可以创建抽象类的匿名内部类。</p><pre><code class=\"language-plain\">image.setOnClickListener(object: View.OnClickListener {\n    override fun onClick(v: View?) {\n        gotoPreview()\n    }\n})\n</code></pre><p>需要特殊说明的是，当Kotlin的匿名内部类只有一个需要实现的方法时，我们可以使用SAM转换，最终使用Lambda表达式来简化它的写法。这个话题我们会留到第7讲再详细分析。</p><p>所以也就是说，Java和Kotlin相同的地方就在于，它们的接口与抽象类，都不能直接创建实例。想要创建接口和抽象类的实例，我们必须通过匿名内部类的方式。</p><p>不过，在Kotlin中，匿名内部类还有一个特殊之处，就是我们在使用object定义匿名内部类的时候，其实还可以<strong>在继承一个抽象类的同时，来实现多个接口</strong>。</p><p>我们看个具体的例子：</p><pre><code class=\"language-plain\">interface A {\n    fun funA()\n}\n\ninterface B {\n    fun funB()\n}\n\nabstract class Man {\n    abstract fun findMan()\n}\n\nfun main() {\n    // 这个匿名内部类，在继承了Man类的同时，还实现了A、B两个接口\n    val item = object : Man(), A, B{\n        override fun funA() {\n            // do something\n        }\n        override fun funB() {\n            // do something\n        }\n        override fun findMan() {\n            // do something\n        }\n    }\n}\n</code></pre><p>让我们分析一下这段代码。接口A，它内部有一个funA()方法，接口B，它内部有一个funB()方法，抽象类Man，它内部有一个抽象方法findMan()。</p><p>接着，在main()函数当中，我们使用object定义了一个匿名内部类。这个匿名内部类，不仅继承了抽象类Man，还同时实现了接口A、接口B。而这种写法，在Java当中其实是不被支持的。</p><p>在日常的开发工作当中，我们有时会遇到这种情况：我们需要继承某个类，同时还要实现某些接口，为了达到这个目的，我们不得不定义一个内部类，然后给它取个名字。但这样的类，往往只会被用一次就再也没有其他作用了。</p><p>所以针对这种情况，使用object的这种语法就正好合适。我们既不用再定义内部类，也不用想着该怎么给这个类取名字，因为用过一次后就不用再管了。</p><h2>object：单例模式</h2><p>接着，我们再来了解下object定义的第二种语义，也就是单例模式。</p><p>在Kotlin当中，要实现<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\">单例模式</a>其实非常简单，我们直接用object修饰类即可：</p><pre><code class=\"language-plain\">object UserManager {\n    fun login() {}\n}\n</code></pre><p>从以上代码中我们可以发现，当使用object以后，就不必再写class关键字了。<strong>我们只需要关注业务逻辑</strong>，至于这个单例模式到底是如何实现的，我们交给Kotlin编译器就行了。这种便捷性，在Java当中是不可想象的。要知道，单例模式的实现，在Java当中是会被当做面试题来考的！而在Kotlin当中，它已变得无比简单。</p><p>在<a href=\"https://time.geekbang.org/column/article/473529\">第3讲</a>里，我带你学习过如何研究Kotlin的原理，那么如果你想看看Kotlin编译器到底是如何实现单例模式的，你也可以反编译看看对应的Java代码：</p><pre><code class=\"language-java\">public final class UserManager {\n\n   public static final UserManager INSTANCE; \n\n   static {\n      UserManager var0 = new UserManager();\n      INSTANCE = var0;\n   }\n\n   private UserManager() {}\n\n   public final void login() {}\n}\n</code></pre><p>可以看到，当我们使用object关键字定义单例类的时候，Kotlin编译器会将其<strong>转换成静态代码块的单例模式</strong>。因为<code>static{}</code>代码块当中的代码，由虚拟机保证它只会被执行一次，因此，它在保证了线程安全的前提下，同时也保证我们的INSTANCE只会被初始化一次。</p><p>不过到这里，你或许就会发现，这种方式定义的单例模式，虽然具有简洁的优点，但同时也存在两个缺点。</p><ul>\n<li><strong>不支持懒加载。</strong>这个问题很容易解决，我们在后面会提到。</li>\n<li><strong>不支持传参构造单例。</strong>举个例子，在Android开发当中，很多情况下我们都需要用到Context作为上下文。另外有的时候，在单例创建时可能也需要Context才可以创建，那么如果这时候单纯只有object创建的单例，就无法满足需求了。</li>\n</ul><p>那么，Kotlin当中有没有其他方式来实现单例模式呢？答案当然是有的，不过，我们要先掌握object的第三种用法：伴生对象。</p><h2>object：伴生对象</h2><p>我们都知道，Kotlin当中没有static关键字，所以我们没有办法直接定义静态方法和静态变量。不过，Kotlin还是为我们提供了伴生对象，来帮助实现静态方法和变量。</p><p>在正式讲解伴生对象之前，我们先来看看object定义单例的一种特殊情况，看看它是如何演变成“伴生对象”的：</p><pre><code class=\"language-plain\">class Person {\n    object InnerSingleton {\n        fun foo() {}\n    }\n}\n</code></pre><p>可以看到，我们可以将单例定义到一个类的内部。这样，单例就跟外部类形成了一种嵌套的关系，而我们要使用它的话，可以直接这样写：</p><pre><code class=\"language-plain\">Person.InnerSingleton.foo()\n</code></pre><p>以上的代码看起来，foo()就像是静态方法一样。不过，为了一探究竟，我们可以看看Person类反编译成Java后是怎样的。</p><pre><code class=\"language-plain\">public final class Person {\n   public static final class InnerSingleton {\n\n      public static final Person.InnerSingleton INSTANCE;\n\n      public final void foo() {}\n\n      private InnerSingleton() {}\n\n      static {\n         Person.InnerSingleton var0 = new Person.InnerSingleton();\n         INSTANCE = var0;\n      }\n   }\n}\n</code></pre><p>可以看到，foo()并不是静态方法，它实际上是通过调用单例InnerSingleton的实例上的方法实现的：</p><pre><code class=\"language-plain\">// Kotlin当中这样调用\nPerson.InnerSingleton.foo()\n//      等价\n//       ↓  java 当中这样调用\nPerson.InnerSingleton.INSTANCE.foo()\n</code></pre><p>这时候，你可能就会想：<strong>要如何才能实现类似Java静态方法的代码呢？</strong></p><p>其实很简单，我们可以使用“@JvmStatic”这个注解，如以下代码所示：</p><pre><code class=\"language-plain\">class Person {\n    object InnerSingleton {\n        @JvmStatic\n        fun foo() {}\n    }\n}\n</code></pre><p>所以这个时候，如果你再反编译Person类，你会发现，foo()这个方法就变成了InnerSingleton类当中的一个静态方法了。</p><pre><code class=\"language-plain\">public final class Person {\n   public static final class InnerSingleton {\n      // 省略其他相同代码\n      public static final void foo() {}\n   }\n}\n</code></pre><p>这样一来，对于foo()方法的调用，不管是Kotlin还是Java，它们的调用方式都会变成一样的：</p><pre><code class=\"language-plain\">Person.InnerSingleton.foo()\n</code></pre><p>看到这里，如果你足够细心，你一定会产生一个疑问：上面的静态内部类“InnerSingleton”看起来有点多余，我们平时在Java当中写的静态方法，不应该是只有一个层级吗？比如：</p><pre><code class=\"language-java\">public class Person {\n    public static void foo() {}\n}\n\n// 调用的时候，只有一个层级\nPerson.foo()\n</code></pre><p>那么，在Kotlin当中有办法实现这样的静态方法吗？</p><p>答案当然是有的，我们只需要在前面例子当中的object关键字前面，加一个<strong>companion关键字</strong>即可。</p><pre><code class=\"language-plain\">class Person {\n//  改动在这里\n//     ↓\n    companion object InnerSingleton {\n        @JvmStatic\n        fun foo() {}\n    }\n}\n</code></pre><p>companion object，在Kotlin当中就被称作伴生对象，它其实是我们嵌套单例的一种特殊情况。也就是，<strong>在伴生对象的内部，如果存在“@JvmStatic”修饰的方法或属性，它会被挪到伴生对象外部的类当中，变成静态成员。</strong></p><pre><code class=\"language-java\">public final class Person {\n\n   public static final Person.InnerSingleton InnerSingleton = new Person.InnerSingleton((DefaultConstructorMarker)null);\n\n   // 注意这里\n   public static final void foo() {\n      InnerSingleton.foo();\n   }\n\n   public static final class InnerSingleton {\n      public final void foo() {}\n\n      private InnerSingleton() {}\n\n      public InnerSingleton(DefaultConstructorMarker $constructor_marker) {\n         this();\n      }\n   }\n}\n</code></pre><p>根据上面反编译后的代码，我们可以看出来，被挪到外部的静态方法foo()，它最终还是调用了单例InnerSingleton的成员方法foo()，所以它只是做了一层转接而已。</p><p>到这里，也许你已经明白object单例、伴生对象中间的演变关系了：普通的object单例，演变出了嵌套的单例；嵌套的单例，演变出了伴生对象。</p><p>你也可以换个说法：<strong>嵌套单例，是object单例的一种特殊情况；伴生对象，是嵌套单例的一种特殊情况。</strong></p><h2>伴生对象的实战应用</h2><p>前面我们已经使用object关键字实现了最简单的单例模式，这种方式的缺点是不支持懒加载、不支持“getInstance()传递参数”。而借助Kotlin的伴生对象，我们可以实现功能更加全面的单例模式。</p><p>不过，在使用伴生对象实现单例模式之前，我们需要先热热身，用它来实现工厂模式。下面，我就给你详细介绍一下。</p><h3>工厂模式</h3><p>所谓的<a href=\"https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95\">工厂模式</a>，就是指当我们想要统一管理一个类的创建时，我们可以将这个类的构造函数声明成private，然后用工厂模式来暴露一个统一的方法，以供外部使用。Kotlin的伴生对象非常符合这样的使用场景：</p><pre><code class=\"language-plain\">//  私有的构造函数，外部无法调用\n//            ↓\nclass User private constructor(name: String) {\n    companion object {\n        @JvmStatic\n        fun create(name: String): User? {\n            // 统一检查，比如敏感词过滤\n            return User(name)\n        }\n    }\n}\n</code></pre><p>在这个例子当中，我们将User的构造函数声明成了private的，这样，外部的类就无法直接使用它的构造函数来创建实例了。与此同时，我们通过伴生对象，暴露出了一个create()方法。在这个create()方法当中，我们可以做一些统一的判断，比如敏感词过滤、判断用户的名称是否合法。</p><p>另外，由于“伴生对象”本质上还是属于User的嵌套类，伴生对象仍然还算是在User类的内部，所以，我们是可以在create()方法内部调用User的构造函数的。</p><p>这样，我们就通过“伴生对象”巧妙地实现了工厂模式。接下来，我们继续看看如何使用“伴生对象”来实现更加复杂的单例设计模式。</p><h3>另外4种单例模式的写法</h3><p>在前面，我们已经学习了Kotlin当中最简单的单例模式，也就是object关键字。同时，我们也提到了，这种方式虽然简洁，但它也存在两大问题：第一，无法懒加载；第二，不支持传参。</p><p>那么，Kotlin当中有没有既支持懒加载又支持传参的单例模式呢？</p><p>答案当然是有的。接下来，我们就来了解下Kotlin里功能更加全面的4种单例模式，分别是懒加载委托单例模式、Double Check单例模式、抽象类模板单例，以及接口单例模板。</p><p><strong>第一种写法：借助懒加载委托</strong></p><p>其实，针对懒加载的问题，我们在原有的代码基础上做一个非常小的改动就能优化，也就是借助Kotlin提供的“委托”语法。</p><p>比如，针对前面的单例代码，我们在它内部的属性上使用by lazy将其包裹起来，这样我们的单例就能得到一部分的懒加载效果。</p><pre><code class=\"language-plain\">object UserManager {\n    // 对外暴露的 user\n    val user by lazy { loadUser() }\n\n    private fun loadUser(): User {\n        // 从网络或者数据库加载数据\n        return User.create(\"tom\")\n    }\n\n    fun login() {}\n}\n</code></pre><p>可以看到，UserManager内部的user变量变成了懒加载，只要user变量没有被使用过，它就不会触发loadUser()的逻辑。</p><p>这其实是一种<strong>简洁与性能的折中方案</strong>。一个对象所占用的内存资源毕竟不大，绝大多数情况我们都可以接受。而从服务器去请求用户信息所消耗的资源更大，我们能够保证这个部分是懒加载的，就算是不错的结果了。</p><blockquote>\n<p><strong>注意：</strong>这里我们用到了by lazy，它是Kotlin当中的“懒加载委托”语法。我们会在第9讲里详细介绍它。目前你只需要知道，它可以保证懒加载的同时，还能保证线程安全即可。</p>\n</blockquote><p><strong>第二种写法：伴生对象Double Check</strong></p><p>我们直接看代码吧：</p><pre><code class=\"language-plain\">class UserManager private constructor(name: String) {\n    companion object {\n        @Volatile private var INSTANCE: UserManager? = null\n\n        fun getInstance(name: String): UserManager =\n            // 第一次判空\n            INSTANCE?: synchronized(this) {\n            // 第二次判空\n                INSTANCE?:UserManager(name).also { INSTANCE = it }\n            }\n    }\n}\n\n// 使用\nUserManager.getInstance(\"Tom\")\n</code></pre><p>这种写法，其实是借鉴于GitHub上的<a href=\"https://github.com/android/architecture-components-samples/blob/master/BasicRxJavaSampleKotlin/app/src/main/java/com/example/android/observability/persistence/UsersDatabase.kt\">Google官方Demo</a>，它本质上就是Java的<strong>Double Check</strong>。</p><p>首先，我们定义了一个伴生对象，然后在它的内部，定义了一个INSTANCE，它是private的，这样就保证了它无法直接被外部访问。同时它还被注解“@Volatile”修饰了，这可以保证INSTANCE的可见性，而getInstance()方法当中的synchronized，保证了INSTANCE的原子性。因此，这种方案还是线程安全的。</p><p>同时，我们也能注意到，初始化情况下，INSTANCE是等于null的。这也就意味着，只有在getInstance()方法被使用的情况下，我们才会真正去加载用户数据。这样，我们就实现了整个UserManager的懒加载，而不是它内部的某个参数的懒加载。</p><p>另外，由于我们可以在调用getInstance(name)方法的时候传入初始化参数，因此，这种方案也是支持传参的。</p><p>不过，以上的实现方式仍然存在一个问题，在实现了UserManager以后，假设我们又有一个新的需求，要实现PersonManager的单例，这时候我们就需要重新写一次Double Check的逻辑。</p><pre><code class=\"language-plain\">class UserManager private constructor(name: String) {\n    companion object {\n    // 省略代码\n    }\n}\n\nclass PersonManager private constructor(name: String) {\n    companion object {\n        @Volatile private var INSTANCE: PersonManager? = null\n\n        fun getInstance(name: String): PersonManager =\n            INSTANCE?: synchronized(this) {\n                INSTANCE?:PersonManager(name).also { INSTANCE = it }\n            }\n    }\n}\n</code></pre><p>可以看到，不同的单例当中，我们必须反复写Double Check的逻辑，这是典型的坏代码。这种方式不仅很容易出错，同时也不符合编程规则（Don’t Repeat Yourself）。</p><p>那么，有没有一种办法可以让我们复用这部分逻辑呢？答案当然是肯定的。</p><p><strong>第三种写法：抽象类模板</strong></p><p>我们来仔细分析下第二种写法的单例。其实很快就能发现，它主要由两个部分组成：第一部分是INSTANCE实例，第二部分是getInstance()函数。</p><p>现在，我们要尝试对这种模式进行抽象。在面向对象的编程当中，我们主要有两种抽象手段，第一种是<strong>类抽象模板</strong>，第二种是<strong>接口抽象模板</strong>。</p><p>这两种思路都是可以实现的，我们先来试试<strong>抽象类</strong>的方式，将单例当中通用的“INSTANCE实例”和“getInstance()函数”，抽象到BaseSingleton当中来。</p><pre><code class=\"language-plain\">//  ①                          ②                      \n//  ↓                           ↓                       \nabstract class BaseSingleton&lt;in P, out T&gt; {\n    @Volatile\n    private var instance: T? = null\n\n    //                       ③\n    //                       ↓\n    protected abstract fun creator(param: P): T\n\n    fun getInstance(param: P): T =\n        instance ?: synchronized(this) {\n            //            ④\n            //            ↓\n            instance ?: creator(param).also { instance = it }\n    }\n}\n</code></pre><p>在仔细分析每一处注释之前，我们先来整体看一下上面的代码：我们定义了一个抽象类BaseSingleton，在这个抽象类当中，我们把单例当中通用的“INSTANCE实例”和“getInstance()函数”放了进去。也就是说，我们把单例类当中的核心逻辑放到了抽象类当中去了。</p><p>现在，我们再来看看上面的4处注释。</p><ul>\n<li>注释①：abstract关键字，代表了我们定义的BaseSingleton是一个抽象类。我们以后要实现单例类，就只需要继承这个BaseSingleton即可。</li>\n<li>注释②：in P, out T是Kotlin当中的泛型，P和T分别代表了getInstance()的参数类型和返回值类型。注意，这里的P和T，是在具体的单例子类当中才需要去实现的。如果你完全不知道泛型是什么东西，可以先看看<a href=\"https://zh.wikipedia.org/zh/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B\">泛型的介绍</a>，我们在第10讲会详细介绍Kotlin泛型。</li>\n<li>注释③：creator(param: P): T是instance构造器，它是一个抽象方法，需要我们在具体的单例子类当中实现此方法。</li>\n<li>注释④：creator(param)是对instance构造器的调用。</li>\n</ul><p>这里，我们就以前面的UserManager、PersonManager为例，用抽象类模板的方式来实现单例，看看代码会发生什么样的变化。</p><pre><code class=\"language-plain\">class PersonManager private constructor(name: String) {\n    //               ①                  ②\n    //               ↓                   ↓\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n    //                  ③\n    //                  ↓ \n        override fun creator(param: String): PersonManager = PersonManager(param)\n    }\n}\n\nclass UserManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, UserManager&gt;() {\n        override fun creator(param: String): UserManager = UserManager(param)\n    }\n}\n</code></pre><p>在仔细分析注释之前，我们可以看到：UserManager、PersonManager的代码已经很简洁了，我们不必重复去写“INSTANCE实例”和“Double Check”这样的模板代码，只需要简单继承BaseSingleton这个抽象类，按照要求传入泛型参数、实现creator这个抽象方法即可。</p><p>下面我们来分析上面的3处注释。</p><ul>\n<li>注释①：companion object : BaseSingleton，由于伴生对象本质上还是嵌套类，也就是说，它仍然是一个类，那么它就具备类的特性“继承其他的类”。因此，我们让伴生对象继承BaseSingleton这个抽象类。</li>\n<li>注释②：String, PersonManager，这是我们传入泛型的参数P、T对应的实际类型，分别代表了creator()的“参数类型”和“返回值类型”。</li>\n<li>注释③：override fun creator，我们在子类当中实现了creator()这个抽象方法。</li>\n</ul><p>至此，我们就完成了单例的“抽象类模板”。通过这样的方式，我们不仅将重复的代码都统一封装到了抽象类“BaseSingleton”当中，还大大简化了单例的实现难度。</p><p>接下来，让我们对比着看看单例的“接口模板”。</p><p><strong>第四种写法：接口模板</strong></p><p>首先我需要重点强调，<strong>这种方式是不被推荐的</strong>，这里提出这种写法是为了让你熟悉Kotlin接口的特性，并且明白Kotlin接口虽然能做到这件事，但它做得并不够好。</p><p>如果你理解了上面的“抽象类模板”，那么，接口的这种方式你应该也很容易就能想到：</p><pre><code class=\"language-plain\">interface ISingleton&lt;P, T&gt; {\n    // ①\n    var instance: T?\n\n    fun creator(param: P): T\n\n    fun getInstance(p: P): T =\n        instance ?: synchronized(this) {\n            instance ?: creator(p).also { instance = it }\n        }\n}\n</code></pre><p>可以看到，接口模板的代码结构和抽象类的方式如出一辙。而我们之所以可以这么做，也是因为Kotlin接口的两个特性：<strong>接口属性、接口方法默认实现</strong>。在<a href=\"https://time.geekbang.org/column/article/472154\">第1讲</a>的时候，我们提到过，Kotlin当中的接口被增强了，让它与抽象类越来越接近，这个例子正好就可以说明这一点。抽象类能实现单例模板，我们的接口也可以。</p><p>说实话，上面的接口单例模板看起来还是比较干净的，好像也挑不出什么大的毛病。但实际上，如果你看注释①的地方，你会发现：</p><ul>\n<li><strong>instance无法使用private修饰</strong>。这是接口特性规定的，而这并不符合单例的规范。正常情况下的单例模式，我们内部的instance必须是private的，这是为了防止它被外部直接修改。</li>\n<li><strong>instance无法使用@Volatile修饰</strong>。这也是受限于接口的特性，这会引发多线程同步的问题。</li>\n</ul><p>除了ISingleton接口有这样的问题，我们在实现ISingleton接口的类当中，也会有类似的问题。</p><pre><code class=\"language-plain\">class Singleton private constructor(name: String) {\n    companion object: ISingleton&lt;String, Singleton&gt; {\n        //  ①      ②\n        //  ↓       ↓\n        @Volatile override var instance: Singleton? = null\n        override fun creator(param: String): Singleton = Singleton(param)\n    }\n}\n</code></pre><ul>\n<li>注释①：@Volatile，这个注解虽然可以在实现的时候添加，但<strong>实现方</strong>可能会忘记，这会导致隐患。</li>\n<li>注释②：我们在实现instance的时候，仍然无法使用private来修饰。</li>\n</ul><p>因此综合来看，单例“接口模板”并不是一种合格的实现方式。</p><p>不过，在研究这个接口模板的过程中，我们又重温了Kotlin接口属性、接口方法默认实现这两个特性，并且对这两个特性进行一次应用。与此同时，我们也理解了接口模板存在的缺陷，以及不被推荐的原因。</p><p>实际上，从一个知识锚点着手，我们用类似的方式，也可以帮助自己理解Kotlin其他的新特性。而在这个时候，我们会发现，Kotlin语法之间并不是一些孤立的知识点，而是存在一些关联的，通过这种学习方式，能帮助我们快速建立起知识体系，这其实也是保持学习与思考连贯性的好办法。</p><h2>小结</h2><p>这节课，我们学习了object的三种语义，分别是匿名内部类、单例、伴生对象。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/67/cc75cc62f08d1b4f2e604630499f8b67.jpg?wh=1920x1260\" alt=\"图片\"></p><p>Kotlin的匿名内部类和Java的类似，只不过它多了一个功能：匿名内部类可以在继承一个抽象类的同时还实现多个接口。</p><p>另外，object的单例和伴生对象，这两种语义从表面上看是没有任何联系的。但通过这节课的学习我们发现了，单例与伴生对象之间是存在某种演变关系的。<strong>“单例”演变出了“嵌套单例”，而“嵌套单例”演变出了“伴生对象”。</strong></p><p>然后，我们也借助Kotlin伴生对象这个语法，研究了伴生对象的实战应用，比如可以实现工厂模式、懒加载+带参数的单例模式。</p><p>尤其是单例模式，这节课中，我们一共提出了Kotlin当中5种单例模式的写法。除了最后一种“接口模板”的方式，是为了学习研究不被推荐使用以外，其他4种单例模式都是有一定使用场景的。这4种单例之间各有优劣，我们可以在工作中根据实际需求，来选择对应的实现方式：</p><ul>\n<li>如果我们的单例占用内存很小，并且对内存不敏感，不需要传参，直接使用object定义的单例即可。</li>\n<li>如果我们的单例占用内存很小，不需要传参，但它内部的属性会触发消耗资源的网络请求和数据库查询，我们可以使用object搭配by lazy懒加载。</li>\n<li>如果我们的工程很简单，只有一两个单例场景，同时我们有懒加载需求，并且getInstance()需要传参，我们可以直接手写Double Check。</li>\n<li>如果我们的工程规模大，对内存敏感，单例场景比较多，那我们就很有必要使用抽象类模板BaseSingleton了。</li>\n</ul><h2>思考题</h2><p>这节课当中，我们提到的BaseSingleton是否还有改进的空间？这个问题会在第7讲“高阶函数”里做出解答。</p><p>欢迎你在评论区分享你的思路，我们下节课再见。</p>","neighbors":{"left":{"article_title":"04 | 实战：构建一个Kotlin版本的四则运算计算器","id":473656},"right":{"article_title":"06 | 扩展：你的能力边界到底在哪里？","id":475684}},"comments":[{"had_liked":false,"id":329935,"user_name":"InfoQ_0880b52232bf","can_delete":false,"product_type":"c1","uid":2066504,"ip_address":"","ucode":"F06FCC5294C260","user_header":"","comment_is_top":false,"comment_ctime":1641655427,"is_pvip":false,"replies":[{"id":"120181","content":"很抱歉出现了这个疏漏，我会改过来。也真心感谢你指出了这个问题，你让这个课程变得更好了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641695623,"ip_address":"","comment_id":329935,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57476230275","product_id":100103401,"comment_content":"”由于static{}代码块当中的代码，是在类加载的时候被执行的...“<br><br>这句话是有问题的，静态代码块不是在类加载的时候执行的，而是在类初始化时执行的。","like_count":14,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544753,"discussion_content":"很抱歉出现了这个疏漏，我会改过来。也真心感谢你指出了这个问题，你让这个课程变得更好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641695624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559865,"discussion_content":"类加载的过程：加载 校验 准备 解析 初始化 使用 卸载。 看起来也对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649007447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329482,"user_name":"7Promise","can_delete":false,"product_type":"c1","uid":2879220,"ip_address":"","ucode":"BF7C7F042E51F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/f4/27a5080a.jpg","comment_is_top":false,"comment_ctime":1641365426,"is_pvip":false,"replies":[{"id":"120048","content":"不错的思路~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641439903,"ip_address":"","comment_id":329482,"utype":1}],"discussion_count":5,"race_medal":0,"score":"36001103794","product_id":100103401,"comment_content":"BaseSingleton有一个缺点：限制了单例的构造函数只有一个参数。因此可以将p改为函数类型传入。","like_count":8,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544204,"discussion_content":"不错的思路~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641439903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474816,"avatar":"https://static001.geekbang.org/account/avatar/00/16/81/00/1df7bb5d.jpg","nickname":"yvanbu","note":"","ucode":"49294808179081","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586300,"discussion_content":"函数类型也需要指定输入参数的个数和类型以及输出参数的类型，并没有办法实现你说的这个问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662094904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657434,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4a/5a/14eb7973.jpg","nickname":"杨小妞","note":"","ucode":"DF5AE317301023","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559373,"discussion_content":"传lambda好像不行。为什么不直接传对象作为参数呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648722169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2880445,"avatar":"","nickname":"Geek_88bbcf","note":"","ucode":"6E73B054EFE7DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545922,"discussion_content":"请问具体怎么实现？能贴个代码观摩一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642083902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2466331,"avatar":"https://static001.geekbang.org/account/avatar/00/25/a2/1b/0a4f9177.jpg","nickname":"vox","note":"","ucode":"0A433DF2BC1D5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2880445,"avatar":"","nickname":"Geek_88bbcf","note":"","ucode":"6E73B054EFE7DA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547577,"discussion_content":"+1 ，到时候传个lambda进来？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642754160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545922,"ip_address":""},"score":547577,"extra":""}]}]},{"had_liked":false,"id":329449,"user_name":"阿康","can_delete":false,"product_type":"c1","uid":2697815,"ip_address":"","ucode":"DF20E1E33A8A34","user_header":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","comment_is_top":false,"comment_ctime":1641353214,"is_pvip":false,"replies":[{"id":"119976","content":"不错的思路~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641367143,"ip_address":"","comment_id":329449,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23116189694","product_id":100103401,"comment_content":"我感觉可以把P换成高级函数当做参数传入，未必每个单例的creator 内部方法都是一样的，是吧？<br>","like_count":6,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543958,"discussion_content":"不错的思路~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641367143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329797,"user_name":"A Lonely Cat","can_delete":false,"product_type":"c1","uid":2885349,"ip_address":"","ucode":"382EBFDD8E5115","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","comment_is_top":false,"comment_ctime":1641543022,"is_pvip":false,"replies":[{"id":"120153","content":"赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641607044,"ip_address":"","comment_id":329797,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18821412206","product_id":100103401,"comment_content":"class DatabaseManager private constructor() {<br><br>    companion object {<br>        @JvmStatic<br>        val instance by lazy { DatabaseManager() }<br>    }<br>}<br><br>这样写也行","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544611,"discussion_content":"赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641607044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333610,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1644423260,"is_pvip":false,"replies":[{"id":"121888","content":"首先，感谢这位同学能提出这么多有趣的见解，这里我一一回复：<br><br>第一点：站在Kotlin语法层面，“伴生对象”跟“静态”已经是语法等价了。<br>第二点：这也是语法层面上的推导，只是说它们语法发展上的关系。另外，伴生对象确实是单例，只是我们一般不这么用。（我提供的反编译代码中public的构造方法只有编译器才能访问，我们开发者是无法直接调用的。）<br>第三点：确实说【拷贝】更合适。<br>第四点：【伴生对象 + @JvmStatic】，它的意义在于让Java调用Kotlin的时候更友好。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644462091,"ip_address":"","comment_id":333610,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10234357852","product_id":100103401,"comment_content":"1、文章中说&quot;Kotlin 还是为我们提供了伴生对象，来帮助实现静态方法和变量&quot; --- 请问伴生对象(companion object)和静态有关系吗？我感觉只是 @JvmStatic 和静态有关系。<br>2、文章中说&quot;伴生对象，是嵌套单例的一种特殊情况&quot; --- 请问伴生对象还能叫单例吗？反编译后，他都有 public 的构造方法了，而且 static 代码块也不见了<br>3、文章中说&quot;@JvmStatic修饰的方法或属性会被挪到伴生对象外部的类当中&quot; --- 这里不应该称为【挪到】吧，因为内部类中的 foo 方法还在那里，说【拷贝】更合适<br>4、请问【伴生对象 + @JvmStatic】有什么意义？单纯拷贝一个成员到外部类中并没有什么意义吧？","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550268,"discussion_content":"首先，感谢这位同学能提出这么多有趣的见解，这里我一一回复：\n\n第一点：站在Kotlin语法层面，“伴生对象”跟“静态”已经是语法等价了。\n第二点：这也是语法层面上的推导，只是说它们语法发展上的关系。另外，伴生对象确实是单例，只是我们一般不这么用。（我提供的反编译代码中public的构造方法只有编译器才能访问，我们开发者是无法直接调用的。）\n第三点：确实说【拷贝】更合适。\n第四点：【伴生对象 + @JvmStatic】，它的意义在于让Java调用Kotlin的时候更友好。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1644462091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550300,"discussion_content":"感谢老师的回复，仔细思考一下，这些解答都是挺有道理的，反而这些问题倒是有些&#34;咬文嚼字&#34;、钻牛角尖哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644478407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591746,"discussion_content":"解答有道理，问题牛角尖，你这不自相矛盾了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666792414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550300,"ip_address":"河北"},"score":591746,"extra":""}]}]},{"had_liked":false,"id":330913,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1642289683,"is_pvip":false,"replies":[{"id":"120719","content":"嗯，不错的思路。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642299615,"ip_address":"","comment_id":330913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937256979","product_id":100103401,"comment_content":"creator 是唯一一个需要实现的方法，我们可以使用 SAM 转换，最终使用 Lambda 表达式来简化它的写法。 <br><br>open class BaseSingleton&lt;in P, out T : Any&gt;(private val creator: (P) -&gt; T) {<br>  @Volatile private var instance: T? = null<br><br>  fun getInstance(param: P): T =<br>    instance ?: synchronized(this) {<br>      instance ?: creator(param).also { instance = it }<br>    }<br>}","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546342,"discussion_content":"嗯，不错的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642299615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330565,"user_name":"木易杨","can_delete":false,"product_type":"c1","uid":1353456,"ip_address":"","ucode":"3C6EFF05AFFACA","user_header":"https://static001.geekbang.org/account/avatar/00/14/a6/f0/50d0931d.jpg","comment_is_top":false,"comment_ctime":1642044608,"is_pvip":false,"replies":[{"id":"120608","content":"因为@JvmStatic是用来修饰静态成员的啊，你想想是不是？","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133625,"ip_address":"","comment_id":330565,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5937011904","product_id":100103401,"comment_content":"class Utils{<br>    @JvmStatic<br>    fun foo(){<br>        println(&quot;foo&quot;)<br>    }<br>}<br>为啥@JvmStatic不能再class中写了？只能在object中。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546034,"discussion_content":"因为@JvmStatic是用来修饰静态成员的啊，你想想是不是？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1642133625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1045303,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","nickname":"张春亮","note":"","ucode":"3921D2A256B2C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":557702,"discussion_content":"object Person {\n    @JvmStatic\n    fun foo() {\n    }\n}\n如果只是想要静态的方法的话，这样也是可以实现的。\n但是kotlin允许这样的写法存在的意义是什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647936844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546034,"ip_address":""},"score":557702,"extra":""},{"author":{"id":2264685,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/6d/f2354440.jpg","nickname":"瞌睡的李先生","note":"","ucode":"88480FAFB4F879","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1045303,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","nickname":"张春亮","note":"","ucode":"3921D2A256B2C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569871,"discussion_content":"如果你想写java那样的xxxUtils，你这样的写法就比较合适了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651582253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":557702,"ip_address":""},"score":569871,"extra":""}]}]},{"had_liked":false,"id":329873,"user_name":"zeki","can_delete":false,"product_type":"c1","uid":2732000,"ip_address":"","ucode":"BCFDED35064BE3","user_header":"https://static001.geekbang.org/account/avatar/00/29/af/e0/69a94af6.jpg","comment_is_top":false,"comment_ctime":1641615821,"is_pvip":false,"replies":[{"id":"120182","content":"我这边在多个编译器版本上测试的结果都是符合描述的，下面是我的代码，或者，你可以贴一下你的代码：<br><br>class Person {<br>    companion object InnerSingleton {<br>        @JvmStatic<br>        fun foo() {}<br>    }<br>}<br><br>&#47;&#47; 反编译<br>public final class Person {<br>   &#47;&#47; 挪到了外面<br>   public static final void foo() {<br>      InnerSingleton.foo();<br>   }   <br>   public static final class InnerSingleton {<br>       &#47;&#47; 省略<br>   }<br>}<br><br>========无static注解===========<br>class Person {<br>    companion object InnerSingleton {<br>        fun foo() {}<br>    }<br>}<br><br>&#47;&#47; 反编译结果<br>public final class Person {<br>   <br>   &#47;&#47; foo() 消失了<br><br>   public static final class InnerSingleton {<br>      public final void foo() {<br>      }<br>   }<br>}","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641696032,"ip_address":"","comment_id":329873,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5936583117","product_id":100103401,"comment_content":"在伴生对象的内部，如果存在“@JvmStatic”修饰的方法或属性，它会被挪到伴生对象外部的类当中，变成静态成员。 这句话是不是有问题呢？我通过查看java代码，发现，属性无论有没有被修饰，都会在外部类中变成静态成员","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544754,"discussion_content":"我这边在多个编译器版本上测试的结果都是符合描述的，下面是我的代码，或者，你可以贴一下你的代码：\n\nclass Person {\n    companion object InnerSingleton {\n        @JvmStatic\n        fun foo() {}\n    }\n}\n\n// 反编译\npublic final class Person {\n   // 挪到了外面\n   public static final void foo() {\n      InnerSingleton.foo();\n   }   \n   public static final class InnerSingleton {\n       // 省略\n   }\n}\n\n========无static注解===========\nclass Person {\n    companion object InnerSingleton {\n        fun foo() {}\n    }\n}\n\n// 反编译结果\npublic final class Person {\n   \n   // foo() 消失了\n\n   public static final class InnerSingleton {\n      public final void foo() {\n      }\n   }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641696032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2732000,"avatar":"https://static001.geekbang.org/account/avatar/00/29/af/e0/69a94af6.jpg","nickname":"zeki","note":"","ucode":"BCFDED35064BE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544816,"discussion_content":"\n\nclass Person {\n    companion object InnerSingleton {\n\n        //food并没有被 @JvmStatic修饰\n        var food: String = &#34;Cola&#34;\n\n        @JvmStatic\n        fun foo() {}\n    }\n}\n\n// 反编译\n\npublic final class Person {\n  // food在外面被定义了\n   @NotNull\n   private static String food = &#34;Cola&#34;; \n\n  // 挪到了外面\n   @JvmStatic\n   public static final void foo() {\n      InnerSingleton.foo();\n   }\n \n   public static final class InnerSingleton {\n      //InnerSingleton 类内部并没有food \n      // 省略\n   }\n}\n\n\n您看下我发的代码呢，这个food,我这确实有点搞不清了，是不是伴生对象内部定义的属性，就是外部类的静态成员呢？而伴生对象内部定义的方法则是遵循“@JvmStatic”修饰的方法，它会被挪到伴生对象外部的类当中，变成静态成员”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641722660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2732000,"avatar":"https://static001.geekbang.org/account/avatar/00/29/af/e0/69a94af6.jpg","nickname":"zeki","note":"","ucode":"BCFDED35064BE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544970,"discussion_content":"这个地方确实容易让人产生迷惑，我尝试在这里详细解释一下，请看注释：\n\npublic final class Person {\n// 表面上看，food在外面被定义在了外面，但它仅仅只是存储了状态\n// 事实上，它是private的，所以这个变量是无法在外部直接访问的。\n// 也就是说：Person.food是无法访问的，要用Person.InnerSingleton.getFood()\n   private static String food = &#34;Cola&#34;;\n \n   public static final class InnerSingleton {\n/\n/ Kotlin 当中的var，其实对应了：food属性 + getFood + setFood\n// 真正对外暴露的getter、setter，仍然还在InnerSingleton\n      public final String getFood() {\n         return Person.food;\n      }\n\n      public final void setFood(@NotNull String var1) {\n         Intrinsics.checkNotNullParameter(var1, &#34;&lt;set-?&gt;&#34;);\n         Person.food = var1;\n      }\n      // 省略\n   }\n}\n\n=================加上JvmStatic======================\n\npublic final class Person {\n\n// getter setter 到了外面\npublic static final String getFood() {\n      Person.InnerSingleton var10000 = InnerSingleton;\n      return food;\n   }\n\n   public static final void setFood(@NotNull String var0) {\n      Person.InnerSingleton var10000 = InnerSingleton;\n      food = var0;\n   }\n \n   public static final class InnerSingleton {\n      // 省略\n   }\n}\n\n出现这种错觉的本质原因，还是因为Kotlin的var变量，在Java当中一分为三了：food、getFood、setFood。希望能够解答你的疑惑，后面有机会的话，我会在加餐里再解释一遍。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1641792944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544816,"ip_address":""},"score":544970,"extra":""},{"author":{"id":2732000,"avatar":"https://static001.geekbang.org/account/avatar/00/29/af/e0/69a94af6.jpg","nickname":"zeki","note":"","ucode":"BCFDED35064BE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545103,"discussion_content":"大概明白了，谢谢您的耐心解答！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641826799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544970,"ip_address":""},"score":545103,"extra":""}]}]},{"had_liked":false,"id":356252,"user_name":"yvanbu","can_delete":false,"product_type":"c1","uid":1474816,"ip_address":"广东","ucode":"49294808179081","user_header":"https://static001.geekbang.org/account/avatar/00/16/81/00/1df7bb5d.jpg","comment_is_top":false,"comment_ctime":1662088769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662088769","product_id":100103401,"comment_content":"「在日常的开发工作当中，我们有时会遇到这种情况：我们需要继承某个类，同时还要实现某些接口，为了达到这个目的，我们不得不定义一个内部类，然后给它取个名字。但这样的类，往往只会被用一次就再也没有其他作用了」关于这个场景能举一个例子吗，如果我只知道这种写法，却不知道具体的应用场景，这样我还是无法理解和掌握","like_count":0},{"had_liked":false,"id":349985,"user_name":"Kuz~","can_delete":false,"product_type":"c1","uid":3041404,"ip_address":"","ucode":"F4A7CD07E8997D","user_header":"https://static001.geekbang.org/account/avatar/00/2e/68/7c/d4b4ed31.jpg","comment_is_top":false,"comment_ctime":1656486121,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1656486121","product_id":100103401,"comment_content":"“同时它还被注解“@Volatile”修饰了，这可以保证 INSTANCE 的可见性”<br>volatile在双重锁中不是为了禁止指令重排吗？","like_count":0,"discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591750,"discussion_content":"应该是禁止指令重排","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666792639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343450,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1650857752,"is_pvip":false,"replies":[{"id":"125647","content":"区别其实在于Java调用方式的不同。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651246793,"ip_address":"","comment_id":343450,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650857752","product_id":100103401,"comment_content":"class Person {<br>    companion object {<br>        fun foo(): String {<br>            return &quot;ZCL&quot;<br>        }<br>        <br>        @JvmStatic<br>        fun staticMethod(): String {<br>            return &quot;staticMethod&quot;<br>        }<br>    }<br>}<br>fun main(){<br>    println(Person.foo())<br>    println(Person.staticMethod())<br>}<br>如果单单的是在写法上的话，不加@JvmStatic也是可以从最外层调用的。<br>但是反编译之后foo()方法就没有出现在最外层的函数内。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568898,"discussion_content":"区别其实在于Java调用方式的不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651246793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341884,"user_name":"louc","can_delete":false,"product_type":"c1","uid":2728241,"ip_address":"","ucode":"08FB5A46314B2B","user_header":"https://static001.geekbang.org/account/avatar/00/29/a1/31/ca97e229.jpg","comment_is_top":false,"comment_ctime":1649902765,"is_pvip":false,"replies":[{"id":"124953","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649950660,"ip_address":"","comment_id":341884,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649902765","product_id":100103401,"comment_content":"BaseSingleton 的提取之前，getInstance 在子类的companion object中可以加 @JvmStatic，但是提取后就无法加这个注解了，造成java代码调用不友好了，这个算个缺点吧","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563206,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649950660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340662,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1649007714,"is_pvip":false,"replies":[{"id":"124599","content":"由于companion无法单独使用，如果要对比“companion object”与“object”，那么它们之间的差异，就在于字节码上的这些变化了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649134578,"ip_address":"","comment_id":340662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649007714","product_id":100103401,"comment_content":"companion 只是为了将 @jvmstatic 修饰的方法，挪到外面么？？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560034,"discussion_content":"由于companion无法单独使用，如果要对比“companion object”与“object”，那么它们之间的差异，就在于字节码上的这些变化了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649134578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339238,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1648003272,"is_pvip":false,"replies":[{"id":"123994","content":"所以，目前来说，Kotlin 字节码转换还有很大的提升空间。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648029364,"ip_address":"","comment_id":339238,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648003272","product_id":100103401,"comment_content":"为什么工具类中的静态的无参静态函数会被转换成属性，这样子不是会多一个静态对象的开销么","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557940,"discussion_content":"所以，目前来说，Kotlin 字节码转换还有很大的提升空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648029364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339230,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1648000943,"is_pvip":false,"replies":[{"id":"124305","content":"你这种写法是可以的。不过，在Kotlin当中，我们更建议将重要工具类改成扩展函数。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648522120,"ip_address":"","comment_id":339230,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648000943","product_id":100103401,"comment_content":"我将我们日常项目中的utils类直接转换成kotlin的时候，转换出来的是如下格式的。直接使用object+@JvmStatic，而没有出现companion。这是什么原因呢，是建议用这种写法写静态方法么<br>object Utils {<br>      @JvmStatic<br>      fun dp2px(){<br>      }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558916,"discussion_content":"你这种写法是可以的。不过，在Kotlin当中，我们更建议将重要工具类改成扩展函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648522120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339117,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1647930450,"is_pvip":false,"replies":[{"id":"123998","content":"这其实是因为Kotlin 没有static，最终选择了这种方式，它们的本质不一样，但能达到同样的目的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648029564,"ip_address":"","comment_id":339117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647930450","product_id":100103401,"comment_content":"&#47;&#47; Kotlin当中这样调用Person.InnerSingleton.foo(）<br>&#47;&#47; 等价&#47;&#47; <br>java 当中这样调用Person.InnerSingleton.INSTANCE.foo()<br>此处为什么非要如此转换呢，一个非静态的方法为什么非要看起来像静态的调用呢","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557944,"discussion_content":"这其实是因为Kotlin 没有static，最终选择了这种方式，它们的本质不一样，但能达到同样的目的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648029564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338042,"user_name":"故事与酒","can_delete":false,"product_type":"c1","uid":2788244,"ip_address":"","ucode":"1A0CCAA2C31D3C","user_header":"https://static001.geekbang.org/account/avatar/00/2a/8b/94/09dca97d.jpg","comment_is_top":false,"comment_ctime":1647250776,"is_pvip":false,"replies":[{"id":"123606","content":"关键还是在于@JvmStatic这个注解，它在外部增加了一个桥接的方法。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1647306602,"ip_address":"","comment_id":338042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647250776","product_id":100103401,"comment_content":"为什么在伴生对象时，没有了类名了，有类名的时候可不可以直接用外部类名调用","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556303,"discussion_content":"关键还是在于@JvmStatic这个注解，它在外部增加了一个桥接的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647306602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333470,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1644376433,"is_pvip":false,"replies":[{"id":"121873","content":"字节码反编译成Java其实也是有损的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644414566,"ip_address":"","comment_id":333470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644376433","product_id":100103401,"comment_content":"使用 object 定义匿名内部类的时候，可以在继承一个抽象类的同时，来实现多个接口，但是反编译后为啥语法不正确？<br><br>   public static final void main() {<br>      &lt;undefinedtype&gt; item = new A() {<br>         public void funA() {<br>         }<br><br>         public void funB() {<br>         }<br><br>         public void findMan() {<br>         }<br>      };<br>      item.findMan();<br>   }","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550195,"discussion_content":"字节码反编译成Java其实也是有损的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644414566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332948,"user_name":"苍王","can_delete":false,"product_type":"c1","uid":1621978,"ip_address":"","ucode":"92F4A7513AF228","user_header":"https://static001.geekbang.org/account/avatar/00/18/bf/da/fede41ea.jpg","comment_is_top":false,"comment_ctime":1643870639,"is_pvip":true,"replies":[{"id":"121691","content":"嗯，你真细心，在这里先感谢你的补充。不过这种写法和直接的object单例没有功能上的差异：都不支持传参。这样一来，这种写法的实战意义就不大了，不过研究意义还是有的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643984870,"ip_address":"","comment_id":332948,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1643870639","product_id":100103401,"comment_content":"java 单例有一种静态内部类实现的方式，那么用kotlin是不是可以这样写<br>class SingleInstance private constructor() {<br><br>    companion object {<br>        @JvmStatic<br>        fun getInstance(): SingleInstance = Holder.instance<br>    }<br><br>    private object Holder {<br>        val instance = SingleInstance()<br>    }<br><br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549438,"discussion_content":"嗯，你真细心，在这里先感谢你的补充。不过这种写法和直接的object单例没有功能上的差异：都不支持传参。这样一来，这种写法的实战意义就不大了，不过研究意义还是有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643984870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591752,"discussion_content":"张涛的视频课中也是这么写的，主要区别是少了一个@JvmStatic注解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666793062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329956,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1641697567,"is_pvip":false,"replies":[{"id":"120248","content":"不错的思路。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641791392,"ip_address":"","comment_id":329956,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641697567","product_id":100103401,"comment_content":"in P 这个param 可以使用函数，这样就不需要creator 了，也不会限制单例的构造只能用一个入参","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544962,"discussion_content":"不错的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641791392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329486,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":2879648,"ip_address":"","ucode":"881EA1DE7A33B8","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f0/a0/43168e73.jpg","comment_is_top":false,"comment_ctime":1641367380,"is_pvip":false,"replies":[{"id":"120049","content":"你可以将其理解为代码复用。我们的实际逻辑还是要在单例当中的，只是在外部加了一个转接的方法。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641440079,"ip_address":"","comment_id":329486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641367380","product_id":100103401,"comment_content":"既然伴生对象针对于@JvmStatic修饰的方法在外部类创建了一个同名静态方法进行对单例类转接，那么为什么反编译之后java中依然是通过 “外部类.内部单例类实例.方法” 的形式去调用，而不是 “外部类.外部类同名方法”的形式调用","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544206,"discussion_content":"你可以将其理解为代码复用。我们的实际逻辑还是要在单例当中的，只是在外部加了一个转接的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641440079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329439,"user_name":"xiaomengjie","can_delete":false,"product_type":"c1","uid":1136848,"ip_address":"","ucode":"4FC7A90B9DFA09","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/d0/749a57e2.jpg","comment_is_top":false,"comment_ctime":1641351046,"is_pvip":false,"replies":[{"id":"119975","content":"你想想，这就是单例的意义不是么？","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641367097,"ip_address":"","comment_id":329439,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1641351046","product_id":100103401,"comment_content":"要是这么调用的话：<br>UserManager.getInstance(&quot;user1&quot;)<br>UserManager.getInstance(&quot;user2&quot;)<br>不是只有第一次调用时传递的name参数才是有效的了？<br>后续调用传递的name参数就没有意义了啊","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543956,"discussion_content":"你想想，这就是单例的意义不是么？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641367097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1353456,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a6/f0/50d0931d.jpg","nickname":"木易杨","note":"","ucode":"3C6EFF05AFFACA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544164,"discussion_content":"这也算是单例的一个缺点吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641434083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1353456,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a6/f0/50d0931d.jpg","nickname":"木易杨","note":"","ucode":"3C6EFF05AFFACA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591753,"discussion_content":"怎么就是缺点了呢，单例的含义不正是如此么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666793213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544164,"ip_address":"河北"},"score":591753,"extra":""}]}]}]}