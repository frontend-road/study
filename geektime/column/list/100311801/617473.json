{"id":617473,"title":"10｜代码实现（上）：要“贫血”还是要“充血”？","content":"<p>你好，我是钟敬。</p><p>上节课我们根据DDD的分层架构，建立了程序的“骨架”，今天开始，我们来编写具体的逻辑，给骨架上“添肉”。其实仅仅从完成功能的角度来说，这些程序你也会写，<strong>但关键是怎么按照DDD的要求来写</strong>。</p><p>按照DDD的要求，我们首先要考虑的问题是，怎么使代码和模型保持一致？这还可以细化成几个子问题，比如怎么实现业务规则、怎么表示对象间的关联、怎么区分领域逻辑和应用逻辑等等。</p><p>其次，我们还要考虑一些通用的编程问题，比如说是采用贫血模型还是充血模型、怎么减少重复、怎样实现模块化，等等。</p><p>所以接下来三节课，咱们先选取几个比较简单的功能，用不太完善的方法把程序写出来，再一步一步地重构，达到我们希望的样子。在这个过程中，我们也会学到DDD在实现层面的几个模式。</p><p>今天，我们会首先讨论面向对象和面向过程间的权衡，然后在代码层面重点解决层间依赖问题。</p><p>开始之前要先说明一下，下面例子中的代码是用Java和Spring来写的，不过我们的重点是普遍原理而不是语言和框架的细节，所以对于其他语言来说，道理也是一样的。</p><h2>“面向对象”还是“面向过程”？</h2><p>提到编码，我们常常说起的一个问题就是：应该采用<strong>贫血模型</strong>还是<strong>充血模型？</strong></p><p>一些人主张，DDD应该采用充血模型， 但是实践中，多数小伙伴，虽然也觉得充血模型更高大上一点，但用的还是贫血模型。今天咱们就先掰扯一下这个话题。</p><!-- [[[read_end]]] --><p>贫血模型，英文叫做Anemic Domain Model ，是Martin Fowler 在 2003 年提出的，恰好在《DDD》这本书写作的同一年。贫血模型指的是<strong>领域对象中只有数据，没有行为</strong>，由于过于单薄，就好像人贫血了一样，显得不太健康。这种风格违背了面向对象的原则。</p><p>所以，Martin Fowler 认为这是一种反模式，他主张的方式叫做 Rich Domain Model，可以译作“富领域模型”，也就是<strong>领域对象里既包含数据，也包含行为</strong>。</p><p>至于所谓充血模型则是后人提出的，这个人还把模型分成四种：失血模型、贫血模型、充血模型和胀血模型。问题在于他说的贫血模型和Matin Fowler说的又不一样，而“充血模型”和“富领域模型”也不是一回事，这就造成了今天业界术语的混乱。</p><p>所以，为了避免混淆，我不采用“充血模型”这个词。在后面的讨论中，我会把贫血模型称为<strong>面向过程</strong>或者<strong>过程式</strong>编程，把富领域模型称为<strong>面向对象</strong>或<strong>对象式</strong>编程，因为真正的面向对象本来就是包含丰富逻辑的。</p><p>那么问题来了，如果面向对象真的明显好于面向过程，为什么多数人还在用面向过程呢？除了咱们程序员自己学艺不精以外，有没有什么合理性呢？</p><p>其实，早期的面向对象编程，主要是用来开发桌面软件的，比如说开发一个Office、一个IDE 等等。这类软件的特点是基本上整个软件的数据都能装入内存，这样就可以通过对象之间自由的导航实现复杂的逻辑。对象在内存里形成一种网状结构，称为对象图（Object Graph）。</p><p>但是企业应用则有一个本质的不同，就是数据主要在数据库里，每次只能把一小部分远程拿到内存，所以不能在内存里对对象进行自由地导航。<strong>这个区别就造成，早期的面向对象编程很难直接用在企业应用，间接导致了贫血模型的普及。</strong>尽管用 JPA 之类的 ORM 框架可以减少这种痛苦，但底层原因并没有消除，所以ORM框架在解决一些问题的同时，又带来了另外一些的问题。</p><p>早年，很多像Martin Fowler这样的专家认为面向对象就是王道，我把他们称为面向对象的“原教旨主义者”。但是到了今天，包括Martin Fowler在内的很多人已经成长为编程范式的“中立主义者”，也就是并不局限于面向对象，而是将面向对象、面向过程、面向方面、函数式等等编程范式结合起来。这也是咱们的课程所遵循的思想。</p><p>实际上，面向对象和面向过程并不是非黑即白的关系，而是像下面这张图这样：<br>\n<img src=\"https://static001.geekbang.org/resource/image/97/22/97302090bc88c5287a71368e6da52922.jpg?wh=3580x1146\" alt=\"\"></p><p>在纯粹的面向对象和纯粹的面向过程之间有一个广阔的“灰色地带”。这里面的变化非常多，难以穷尽。这两个极端都不是我们要追求的，我们要做的是找到其中的一个平衡点。</p><p>那这个平衡点怎么找呢？根据目前国内多数人的编程习惯，在这门课程里，我们采用这样的原则：<strong>在领域对象不直接或间接访问数据库的前提下，尽量面向对象</strong>。</p><p>为了理解这句话，<strong>咱们一会儿先按面向过程的方式写出程序，然后通过重构，逐渐向面向对象靠拢</strong>。在这个过程里，咱们可以体会不同编程范式的特点，以及思考它们怎样融合。</p><p>另外，由于不能在对象之间自由导航，所以相对传统的面向对象编程来说，我们的编程风格会<strong>偏过程</strong>一些。</p><p>我还是要提醒一句，在架构师的眼里往往没有唯一正确的方法，而是要在几种不同方法中作出权衡。</p><h2>“开卡”和“验卡”</h2><p>好，理论就讲这么多，回到开发过程。现在咱们俩都是资深程序员，另外，还有一个领域专家和我们配合，就叫他老王。</p><p>假设距离领域建模已经过去三四天了，今天我们开始真正编写“添加组织”这个功能。但是有两个问题：第一，尽管几天前已经澄清过需求，但会不会当时有什么遗漏呢？第二，就算当时没有遗漏，那么最近几天，会不会又有些新的变化没有通知到我们呢？</p><p>所以，有必要在真正动手编码之前，找老王再次确认一下。这实际上是敏捷中的一个常用实践，叫做“<strong>开卡</strong>”。相应地，在代码开发完毕，正式提交测试之前，也会把领域专家或测试人员叫过来大体看一下有没有方向上的错误，这一步叫“<strong>验卡</strong>”。这两个实践可以有效避免因为需求理解不一致而导致的返工。</p><p>经过和老王确认，我们果然又发现了几个新的业务规则。比如，同一个组织里，不能有两个同名的下级组织。也就是说，假如“金融开发中心”下面已经有“开发一组”了，那么新加的开发组，不能也叫“开发一组”。</p><p>下面这张表，是和老王澄清需求以后整理的和“添加组织”有关的业务规则。其中绿色部分是这次新加的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/fc/63/fc997996b1a3f023fbe5cda974f68163.jpg?wh=3051x2439\" alt=\"\"></p><p>其实，和业务人员不断澄清需求，不断补充新的领域知识，正是DDD和敏捷软件开发的常态。</p><p>在这个表里我们发现，有一些“租户必须<strong>有效</strong>”“上级组织必须<strong>有效</strong>”这样的规则，说明在相应的实体里要增加<strong>状态</strong>属性来表达“有效”“终止”等状态。经过和老王的讨论，我们决定在<strong>租户、组织、组织类别、员工、客户、合同、项目</strong>等实体中都增加<strong>状态</strong>，并且在数据库里添加相应的字段。</p><p>DDD强调，<strong>在代码编写阶段，如果发现模型的问题，要及时修改模型，始终保持代码和模型的一致。</strong></p><h2>面向过程的代码</h2><p>需求澄清以后，我们终于可以写代码了。假如我刚学了一点DDD的分层架构，但是只会面向过程的方法，那么写出来大概是下面这个样子。</p><p>我们先通过包结构，看一下总体的逻辑。<br>\n<img src=\"https://static001.geekbang.org/resource/image/42/63/4232658100e3f5a1d1ea2e3ec6fd3763.jpg?wh=2900x2018\" alt=\"\"></p><p>这里分成了六步，我们简单解释下。</p><ul>\n<li>第一步，适配器层里的OrgController 通过Restful API接收到<strong>添加组织</strong>的请求，请求数据封装在OrgDto里。</li>\n<li>第二步，Controller以OrgDto为参数，调用应用层里的OrgService服务中的addOrg() 方法进行处理。</li>\n<li>第三步，OrgService对参数进行校验，过程中会调用适配器层里的 Repository 来访问数据库。</li>\n<li>第四步，OrgService创建领域层里的Org对象，也就是<strong>组织</strong>对象。</li>\n<li>第五步，OrgService调用OrgRepository把<strong>组织</strong>对象存到数据库，并回填组织 id。</li>\n<li>第六步，OrgService把<strong>组织</strong>对象装配成DTO，返回给控制器，控制器再返回给前端。</li>\n</ul><p>整个过程还是比较直白的，目前主要逻辑都集中在OrgService里，也就是第三步到第六步。</p><p>我们再看看两个主要的数据类。一个是领域对象类Org。</p><pre><code class=\"language-java\">public class Org {\n    private Long id;\n    private Long tenantId;\n    private Long superiorId;\n    private String orgTypeCode;\n    private Long leaderId;\n    private String name;\n    private OrgStatus status;          // 使用了枚举类型\n    private LocalDateTime createdAt;\n    private Long createdBy;\n    private LocalDateTime lastUpdatedAt;\n    private Long lastUpdatedBy;\n\n    public Org() {\n        status = OrgStatus.EFFECTIVE;  //组织的初始状态默认为有效\n    }\n    \n    //getters and setters ...    \n\n}\n</code></pre><p>另一个是 OrgDto。</p><pre><code class=\"language-java\">public class OrgDto {\n    private Long id;\n    private Long tenantId;\n    private Long superiorId;\n    private String orgTypeCode;\n    private Long leaderId;\n    private String name;\n    private String status;\n    private LocalDateTime createdAt;\n    private Long createdBy;\n    private LocalDateTime lastUpdatedAt;\n    private Long lastUpdatedBy;\n \n    // getters and setters ...\n}\n</code></pre><p>目前这两个类十分相似，而且都只有数据没有行为。唯一的不同是，Org的<strong>状态</strong>属性 Status是一个枚举类型，算是比OrgDto略微“面向对象”一点。</p><h2>层间依赖原则和依赖倒置</h2><p>现在我们从Controller开始逐层往下捋，下面是Controller的代码。</p><pre><code class=\"language-java\">@RestController\npublic class OrgController {\n    private final OrgService orgService;\n    @Autowired\n    public OrgController(OrgService orgService) {\n        this.orgService = orgService;\n    }\n\n    @PostMapping(\"/api/organizations\")\n    public OrgDto addOrg(@RequestBody OrgDto request) {\n        //从请求里解析出 userId ...\n        return orgService.addOrg(request, userId);\n    }\n}\n</code></pre><p>简单起见，我省略了身份认证、Http返回码等处理。所以addOrg方法中只有一句，就是调用Service。<strong>然而就是这一句，已经违反了我们上节课说的层间依赖原则</strong>。你能发现是哪里出了问题吗？</p><p>没错，由于OrgDto是应用服务中addOrg方法的入口参数类型，所以应用层是依赖OrgDto 的，而OrgDto又在适配器层。也就是说，应用层依赖了适配器层。而在上节课的分层架构中，应用层在适配器层的内层，而内层是不应该依赖外层的。这样，就违反了层间依赖原则。</p><p>改起来倒是简单，只要把OrgDto移动到应用层就可以了，修改后是后面这样。<br>\n<img src=\"https://static001.geekbang.org/resource/image/0c/22/0cc1c825684ea1ab16cfe9154b59fc22.jpg?wh=2900x2018\" alt=\"\"></p><p>这里还要注意一点，手工移动类是很麻烦的。现在像IDEA、Eclipse 这样的IDE，都有“重构”菜单，提供了丰富的自动化重构功能，我们应该学会尽量使用。后面课程的重构我们都是尽量依靠重构菜单完成的。</p><p>看完Controller，我们再重点看一下应用层的 OrgService，代码结构是后面这样。</p><pre><code class=\"language-java\">@Service\npublic class OrgService {\n    private final UserRepository userRepository;\n    private final TenantRepository tenantRepository;\n    private final OrgTypeRepository orgTypeRepository;\n    private final OrgRepository orgRepository;\n    private final EmpRepository empRepository;\n\n    @Autowired\n    public OrgService(UserRepository userRepository\n            , TenantRepository tenantRepository\n            , OrgRepository orgRepository\n            , EmpRepository empRepository\n            , OrgTypeRepository orgTypeRepository) {\n            \n            //为各个Repository赋值...        \n    }\n\n    public OrgDto addOrg(OrgDto request, Long userId) {\n        validate(request, userId);\n        Org org = buildOrg(request, userId);\n        org = orgRepository.save(org);  \n        return buildOrgDto(org);\n    }\n\n    private OrgDto buildOrgDto(Org org) {\n        // 将领域对象的值赋给DTO...\n    }\n\n    private Org buildOrg(OrgDto request, Long useId) {\n        // 将DTO的值赋给领域对象...\n    }\n\n    private void validate(OrgDto request) {\n        //进行各种业务规则的校验，会用到上面的各个Repository...  \n    }\n}\n</code></pre><p>主控逻辑在addOrg方法里（19～24行），也很简单，先校验参数，再创建领域对象，然后保存到数据库，最后返回DTO。不过在这里，是不是又发现了一处违反层间依赖的地方呢？</p><p>可能你已经找到了，就是对仓库，也就是Repository的调用。根据上节课，仓库放在适配器层，而应用层调用了仓库，造成应用层对适配器层的依赖，这就再一次违反了层间依赖规则。</p><p>这时候我们该怎么办呢？像前面那样，把仓库移到应用层吗？可是仓库是适配器，就应该放在适配器层呀。这里就要用到一个技巧了，通过两步就可以解决.</p><ul>\n<li>第一步，从仓库抽出一个接口，原来的仓库成为了这个接口的实现类。</li>\n<li>第二步，把这个接口移动到领域层。</li>\n</ul><p>修改后的结构是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/e9/675c3cbde0bdaff612d5cbc8582e5ae9.jpg?wh=2900x2018\" alt=\"\"></p><p>仓库接口都按照 XxxRepository 的形式命名。而仓库的实现是在接口名字的后面加上Jdbc ，这是因为在目前的例子里只是用了Jdbc来做持久化。OrgService中的代码，除了 import 语句要调整一下以外，其他都没有变化。Spring框架会“偷偷地”把实现类注入到相关属性。</p><p>以OrgRepository为例，接口代码是后面这样的。</p><pre><code class=\"language-java\">package chapter10.unjuanable.domain.orgmng; //注意：仓库的接口在领域层\n\n//import ... \n\npublic interface OrgRepository {\n    Optional&lt;Org&gt; findByIdAndStatus(long tenantId, Long id\n                                    , OrgStatus status);\n    int countBySuperiorAndName(long tenantId, Long superiorId\n                                    , String name);\n    boolean existsBySuperiorAndName(Long tenant, Long superior\n                                    , String name);\n    Org save(Org org);\n}\n</code></pre><p>而实现类仍然在适配器层，像后面这样。</p><pre><code class=\"language-java\">//注意：Repository 的实现类在适配器层\npackage chapter10.unjuanable.adapter.driven.persistence.orgmng;\n\n//import ...\n\n@Repository\npublic class OrgRepositoryJdbc implements OrgRepository {\n    JdbcTemplate jdbc;\n    SimpleJdbcInsert insertOrg;\n\n    @Autowired\n    public OrgRepositoryJdbc(JdbcTemplate jdbc) {\n        //...\n    }\n\n    @Override\n    public Optional&lt;Org&gt; findByIdAndStatus(Long tenantId, Long id, OrgStatus status) {\n        //...        \n    }\n\n    @Override\n    public int countBySuperiorAndName(Long tenantId, Long superiorId, String name) {\n        //...\n    }\n\n    @Override\n    public boolean existsBySuperiorAndName(Long tenant, Long superior, String name) {\n        //...\n    }\n    \n    @Override\n    public Org save(Org org) {\n        //...\n    } \n}\n</code></pre><p>为什么这样做就解决了层间依赖呢？让我们画一个UML图来更直观地看一下。<br>\n<img src=\"https://static001.geekbang.org/resource/image/bd/8f/bda60b4e1d8c6dd181bdbb1e33d6e48f.jpg?wh=3733x2343\" alt=\"\"></p><p>这是和程序结构等价的UML图。不过要注意，我们现在画的是设计模型的类图，和前面领域建模的类图会有一些区别。</p><p>首先，在设计图里用的是英文，而领域模型图里用了中文。这是因为用中文更容易和领域专家交流，而设计图是给程序员看的，用英文更贴近代码。中英文的转换则依照词汇表。</p><p>第二个区别是，这个图里画的都不是领域对象，而是用来实现程序的对象。当然，设计图里也可以画领域对象，只不过针对目前这个问题，我们把领域对象省略了。但是反过来，<strong>领域模型图中一定不能存在只有技术人员才懂的内容</strong>。</p><p>现在我们看一下从OrgService到领域层中仓库接口的三个箭头。它们实际上代表了 OrgService中用这三个接口定义的属性。这些箭头也是关联关系，只不过是技术意义上的。由于OrgService可以通过属性导航到仓库，而仓库中并没有属性能够导航到OrgService，所以关联是单向的。关联也是一种依赖关系，所以可以说OrgServie依赖仓库，说明应用层依赖领域层。</p><p>再看从仓库实现类指向接口的带虚线的空三角箭头。这个符号表示类对接口的实现关系，在领域模型中一般是不使用的。实现关系也是一种依赖，所以现在适配器层也依赖了领域层。</p><p>看见没有？原来应用层对适配器层的依赖神奇地消失了，取而代之的是应用层和适配器层两者对领域层的依赖。层间依赖的问题就解决了。</p><p>原来是别的层依赖适配器，现在通过抽取和移动接口，变成了适配器依赖别的层，依赖关系被“倒过来”了。所以这种技巧就称为<strong>依赖倒置</strong>（dependency inversion）<strong>，</strong>是面向对象设计中常见的调整依赖关系的手段。</p><p>最后还有一个问题，为什么要把仓库接口移动到领域层而不是应用层呢？移到应用层不是也可以解决这个问题吗？</p><p>不错，就目前而言，移动到应用层也可以。但是后面我们会看到，领域层中的代码也有可能访问数据库。所以要移动到领域层，否则会出现新的层间依赖问题。</p><h2>总结</h2><p>好，今天的内容先讲到这里，我们来总结一下。</p><p>这节课我们开始编写代码，要实现两个要求：一个是保持代码和模型一致；另一个是符合通用的编程原则和最佳实践。</p><p>我们讨论了“贫血模型”“充血模型”“面向对象”和“面向过程”几个概念的关系。这里我们要清楚，在实践中，面向对象和面向过程往往不是非黑即白的，传统意义上纯粹的面向对象编程在企业应用中未必适合，应该把多种编程范式结合起来。</p><p>我们还讲了敏捷中“开卡”和“验卡”两个实践，补充了业务规则。这里我想再次强调，<strong>编写代码的时候如果发现模型的问题，要及时修改模型，始终保持代码和模型的一致。</strong></p><p>在代码层面，今天的重点是<strong>解决层间依赖问题</strong>。我们做了两个改进：一是把DTO从适配器层移到了应用层；另一个是采用“依赖倒置”原则，使适配器层依赖于领域层。</p><p>在解释依赖倒置时，我们还用到了设计层面的UML图，希望你能借此理解领域模型和设计模型的区别。理解这种区别有两方面的好处，一个是在沟通过程中，知道哪些应该和业务人员讨论，哪些应该只在程序员内部讨论；另一个是区分不同的抽象层次，使我们思考问题的能够更加聚焦和高效。</p><h2>思考题</h2><p>1.在你的心目中，面向对象有哪些特征？假如用偏过程的方式，是否也能实现这些特征？</p><p>2.在今天的程序中，领域逻辑主要体现在哪段代码，它们放对地方了吗？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们继续优化程序，达到DDD的要求，并且更加“面向对象”一点。</p>","comments":[{"had_liked":false,"id":367189,"user_name":"子衿","can_delete":false,"product_type":"c1","uid":1903229,"ip_address":"上海","ucode":"E76CC673517290","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0a/7d/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1675000132,"is_pvip":false,"replies":[{"id":133793,"content":"你们用的是RPC方式是吧。可以把DTO作为单独一个包，让API接口和应用服务都依赖这个DTO包，这样就不违反层间依赖了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675071558,"ip_address":"广东","comment_id":367189,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师这个地方有一个问题，我们通常为了方便微服务调用，会让Controller实现一个XxxApi接口，然后将XxxApi单独打包，这样下游可以将这XxxApi这个接口，通过maven引入到自己项目，然后直接通过XxxApi就可以完成远程调用，我们通常叫XxxApi所在的包为二方库，但如果将DTO放到了应用层，那么DTO和XxxApi就不在一层了，也就是XxxApi在适配器层，而DTO在应用层，如果强行将DTO也对外发布出去，会导致相关应用服务也被发布，这个应用服务对下游来说是没用的，这种有什么好的实践方式吗","like_count":14,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601124,"discussion_content":"你们用的是RPC方式是吧。可以把DTO作为单独一个包，让API接口和应用服务都依赖这个DTO包，这样就不违反层间依赖了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1675071559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1903229,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0a/7d/791d0f5e.jpg","nickname":"子衿","note":"","ucode":"E76CC673517290","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":601579,"discussion_content":"老师我再确认下，是不是就是说API接口，和DTO，都单独放一个公共包，这个包不再是适配器层，而是在适配器、应用服务层外，用于支撑他们，然后适配器层提供APIImpl，实现API接口，此时相当于适配器层依赖这个公共包，然后应用服务层的方法参数，也是DTO，相当于应用服务层也依赖这个公共包，这样应用服务层就不依赖适配器层的DTO了，而是依赖公共包中的DTO","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1675305776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":601124,"ip_address":"浙江","group_id":0},"score":601579,"extra":""}]},{"author":{"id":1903229,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0a/7d/791d0f5e.jpg","nickname":"子衿","note":"","ucode":"E76CC673517290","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601562,"discussion_content":"感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675303469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365235,"user_name":"Geek_1cb6f4","can_delete":false,"product_type":"c1","uid":2670834,"ip_address":"广东","ucode":"2A9E087EA7CB05","user_header":"","comment_is_top":false,"comment_ctime":1672289216,"is_pvip":false,"replies":[{"id":133039,"content":"可以在应用层保存一个一致的dto,在适配器有另外多个不同版本的dto作为适配","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672293211,"ip_address":"广东","comment_id":365235,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"这里有个疑问，开发中发现dto的属性命名实际是要与外部调用者的命名一致的，比如页面请求或者第三方接口。于是就存在同一个dto的多个版本。那么dto不就应该属于适配器层么？搬至应用层后就感觉不那么合适了。","like_count":8,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597873,"discussion_content":"可以在应用层保存一个一致的dto,在适配器有另外多个不同版本的dto作为适配","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1672293211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2673605,"avatar":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","nickname":"赵晏龙","note":"","ucode":"F15730BCA97EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":598048,"discussion_content":"赞同，参考微服务BFF层的概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672474535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597873,"ip_address":"湖南","group_id":0},"score":598048,"extra":""},{"author":{"id":2094062,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgXlnRwqBvzlSWTrv4eZ4hSOhXnr6NOKzVFUIHJbhIEjpkvSjlJEg3xf3Th7uKcUw9I200QDpbdg/132","nickname":"AngryShoes","note":"","ucode":"28E4485EE997AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":603349,"discussion_content":"需要在controller适配器层加一层viewModel吗？用来接收前端传入的参数，因为有时候应用层的dto不一定完全跟前端传参一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676123621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597873,"ip_address":"湖南","group_id":0},"score":603349,"extra":""}]},{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"skull","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620502,"discussion_content":"dto放在应用层没什么问题，本来就是在应用层转领域对象，dto不止起到传输对象的作用，还要做领域对象转换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686222130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365148,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"广东","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1672195592,"is_pvip":false,"replies":[{"id":132971,"content":"1，用@repository @autowired spring自动会注入\n2，分层架构一般只规定方向对就可以了，没说不能跨层","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672198218,"ip_address":"广东","comment_id":365148,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"依赖倒置那个 有2个问题需要请教下老师：\n1. 适配器层中 仓库的实现类，什么时候注入 到 Service 中，这里肯定不能在 Service 中初始化 否则还是会依赖\n2. 适配层依赖 领域层，这里不是跨层依赖了吗？","like_count":5,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597727,"discussion_content":"1，用@repository @autowired spring自动会注入\n2，分层架构一般只规定方向对就可以了，没说不能跨层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672198218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365938,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"湖北","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1673251322,"is_pvip":false,"replies":[{"id":133639,"content":"两个问题回答都不错。\n\n关于DTO是否一定要放到应用层的问题，是不一定的。DDD最强调的是领域层要整明白，其他层都好商量。Eric Evans在自己的github例子里就是把DTO放在展现层的。不过还是不建议违反层间依赖原则。这个课程里把DTO放到应用层，是更强调六边形架构的思路。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674269201,"ip_address":"广东","comment_id":365938,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"内容：\n1.权衡问题，个人认为dto不该移动到应用层。就像要不要追加get set方法，原则上破坏封装性不要，实际上框架依赖只能要。java的rpc框架需要dto。如果你为交付负责，我觉得保守点，先追求框架红利，因为你算不准个中成本差异。\n2.仓储的入参具象了（干没了加一层带来的扩展性），直接用聚合根实体就好。仓储是聚合的仓储。\n\n课后题：\n1.封装多态继承。可以，早期带团队面向对象落地难，用dci的思路带团队干过，效果能做出来，就是多了挺多概念，后期不好沟通。\n2.add那块应用层里面。 说不上合不合理。核心逻辑是检验，检验我的观点是跟着领域对象走。但你说dto或则其他内部类加点检验可不可以，可以，不放内里面行不行，挺好，我就只抓领域层内部，其他的不放类里面指不定还是好事。（富客户端 api传递依赖 都是麻烦）（对象转换可以用框架，干净些）","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600370,"discussion_content":"两个问题回答都不错。\n\n关于DTO是否一定要放到应用层的问题，是不一定的。DDD最强调的是领域层要整明白，其他层都好商量。Eric Evans在自己的github例子里就是把DTO放在展现层的。不过还是不建议违反层间依赖原则。这个课程里把DTO放到应用层，是更强调六边形架构的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674269201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"skull","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620506,"discussion_content":"不管你用不用DDD，dto都要放在service层使用的啊，这有什么好质疑的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686223936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"skull","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621658,"discussion_content":"看看ddd的分层。有一条基本思路是用层限制特定模型的作用范围，这样能保证每一层的独立性。\n如果你的代码分层只有mvc 三层，我觉得也挺好，不用纠结这些弯弯绕绕。软件的成功与否和质量关系没有那么大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687432015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620506,"ip_address":"福建","group_id":0},"score":621658,"extra":""}]}]},{"had_liked":false,"id":365426,"user_name":"gitqh","can_delete":false,"product_type":"c1","uid":1020694,"ip_address":"广东","ucode":"3670CBB8CA9F74","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/16/c836afca.jpg","comment_is_top":false,"comment_ctime":1672496727,"is_pvip":false,"replies":[{"id":133254,"content":"这样也可以，其实Evans本人写的代码例子就是这么做的（在Github上搜 dddsample)。我们的课程里之所以这么做，是参考了六边形架构，在六边形架构中，适配器主要适配输入输出的技术关注点，而DTO和领域对象的转换已经不是这个意义上的技术关注点了。所以如果追求纯粹一点的六边形架构，那么就按课程里的，否则，你们现在的做法也可以。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673089803,"ip_address":"广东","comment_id":365426,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"关于将dto移动到application层解决外层依赖内层的问题，我在项目中会用另外一种方式，dto依然在adapter层，adapter层在调用application层的方法时，将参数转换为domain层的对象，这种方式也没有破坏外层依赖内层的规则。\n\n关于这两种方式的对比，想听听老师的观点","like_count":3,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598782,"discussion_content":"这样也可以，其实Evans本人写的代码例子就是这么做的（在Github上搜 dddsample)。我们的课程里之所以这么做，是参考了六边形架构，在六边形架构中，适配器主要适配输入输出的技术关注点，而DTO和领域对象的转换已经不是这个意义上的技术关注点了。所以如果追求纯粹一点的六边形架构，那么就按课程里的，否则，你们现在的做法也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673089803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072357,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5c/e5/5cd7fb17.jpg","nickname":"Mr.H","note":"","ucode":"FEAB798AB45F17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622078,"discussion_content":"但是多了一层转换的话，内存的使用就多了一倍，后面还要再转为domain，这样增加了OOM的风险","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687891596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1072357,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5c/e5/5cd7fb17.jpg","nickname":"Mr.H","note":"","ucode":"FEAB798AB45F17","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636922,"discussion_content":"这点内存增加可以忽略不计吧，而且还有垃圾回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707264317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":622078,"ip_address":"广东","group_id":0},"score":636922,"extra":""}]}]},{"had_liked":false,"id":365381,"user_name":"磐石","can_delete":false,"product_type":"c1","uid":2596222,"ip_address":"广东","ucode":"5E291A0EE25C6D","user_header":"https://static001.geekbang.org/account/avatar/00/27/9d/7e/b8083db8.jpg","comment_is_top":false,"comment_ctime":1672397464,"is_pvip":false,"replies":[{"id":133253,"content":"继续努力","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673089623,"ip_address":"广东","comment_id":365381,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"看高潮了，爽文，继续更新，不要停","like_count":3,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598781,"discussion_content":"继续努力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673089623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132448,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/a0/f12115b7.jpg","nickname":"Sam.张朝","note":"","ucode":"FB20554D94B250","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614473,"discussion_content":"看这些没太大感觉，为啥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681798551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380337,"user_name":"Faddei","can_delete":false,"product_type":"c1","uid":1990585,"ip_address":"浙江","ucode":"0D31C24E4878B2","user_header":"https://static001.geekbang.org/account/avatar/00/1e/5f/b9/6dbac933.jpg","comment_is_top":false,"comment_ctime":1693389821,"is_pvip":false,"replies":[{"id":138567,"content":"repository 查出来的就是领域对象了，不需要再封装。某些情况下要用DO的话，也是 repository 内部的实现，外面是看不到的。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1693555009,"ip_address":"广东","comment_id":380337,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师请教下，repository 查出来的对象就是 domain对象了吗？还是需要再封装一个DO类，再将DO转换成domain","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626979,"discussion_content":"repository 查出来的就是领域对象了，不需要再封装。某些情况下要用DO的话，也是 repository 内部的实现，外面是看不到的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1693555009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2741878,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d6/76/eca918c3.jpg","nickname":"luo","note":"","ucode":"9BE7559B0C88D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":646090,"discussion_content":"那这里有个问题，领域对象中有id字段，使用jpa做orm时，我们会在这上面加@id注解，而@id属于适配器层，领域层依赖了适配器层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717318713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":626979,"ip_address":"广东","group_id":0},"score":646090,"extra":""}]}]},{"had_liked":false,"id":373224,"user_name":"NoSuchMethodError","can_delete":false,"product_type":"c1","uid":3326684,"ip_address":"江苏","ucode":"F227B98677E3C3","user_header":"https://static001.geekbang.org/account/avatar/00/32/c2/dc/78e809b7.jpg","comment_is_top":false,"comment_ctime":1682258615,"is_pvip":false,"replies":[{"id":136610,"content":"如果关注的是整个企业的人和系统的交互，就是业务用例；如果关注的是人和单个系统的交互，就是系统用例。和app层直接相关的是系统用例。不过“app层只负责业务流程的编排”这句话本身过于笼统，含义不明。准确的说，app向外部提供的一个API对应与用例中的一个步骤。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1683373548,"ip_address":"广东","comment_id":373224,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"有个问题想问下，我看到有说法说app层只负责业务流程的编排，那业务流程是不是指的是业务用例或者系统用例？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617201,"discussion_content":"如果关注的是整个企业的人和系统的交互，就是业务用例；如果关注的是人和单个系统的交互，就是系统用例。和app层直接相关的是系统用例。不过“app层只负责业务流程的编排”这句话本身过于笼统，含义不明。准确的说，app向外部提供的一个API对应与用例中的一个步骤。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683373548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370443,"user_name":"Ramanujan","can_delete":false,"product_type":"c1","uid":1066325,"ip_address":"广东","ucode":"0BAE43F63938C3","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/55/518f0ccb.jpg","comment_is_top":false,"comment_ctime":1678840754,"is_pvip":false,"replies":[{"id":135130,"content":"简单回答：偏面向过程（我用“面向过程”代替“贫血”的说法）。详细回答：在领域对象不直接或间接访问数据库的情况下，尽量面向对象（我用“面向对象”代替“贫血”的说法），在纯粹的面向对象和纯粹面向过程之间取得一个平衡。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678927979,"ip_address":"广东","comment_id":370443,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师，你这个实现是贫血还是充血","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609290,"discussion_content":"简单回答：偏面向过程（我用“面向过程”代替“贫血”的说法）。详细回答：在领域对象不直接或间接访问数据库的情况下，尽量面向对象（我用“面向对象”代替“贫血”的说法），在纯粹的面向对象和纯粹面向过程之间取得一个平衡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678927979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365657,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"广东","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1672879865,"is_pvip":false,"replies":[{"id":133229,"content":"1 首先让模型轻量一点，其次要完善开发流程，在需求梳理，代码评审等环节检查\n2 这些确实没放对，下节课聊","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672995931,"ip_address":"广东","comment_id":365657,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"一些思考和问题\n1. 如何保证模型永远是最新的，有时候只会改代码，不改模型，这里就是绝大部分程序员不能保证统一，很多时候文档迭代就会滞后。\n2. 领域逻辑体现在应用层的OrgService里行为validate、buildOrgDto、buildOrg位置不对，应该把这些行为放到各自的领域对象里，比如validate、buildOrgDto放到OrgDto里，buildOrg放到Org里","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598697,"discussion_content":"1 首先让模型轻量一点，其次要完善开发流程，在需求梳理，代码评审等环节检查\n2 这些确实没放对，下节课聊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672995931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132448,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/a0/f12115b7.jpg","nickname":"Sam.张朝","note":"","ucode":"FB20554D94B250","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614474,"discussion_content":"这里是不是就很面向过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681798631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379268,"user_name":"无问","can_delete":false,"product_type":"c1","uid":1546586,"ip_address":"上海","ucode":"F841A16374CC84","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/5a/32f3df3c.jpg","comment_is_top":false,"comment_ctime":1691639810,"is_pvip":false,"replies":[{"id":138432,"content":"结合《DDD》一书以及作者在github上的示例代码来看，infrastructure 包含了两个作用，一个是公共框架和工具性的基础代码，另一个是 repository 的实现，将者两种不同意义的代码放在同一层是不合适的。所以，在课程里，我把这两个意思分别放在了 common 和 driven adapter 里。其中 driven adapter 是采用了六边形架构的命名。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1693056929,"ip_address":"广东","comment_id":379268,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"repository的具体实现的位置跟我常见的ddd架构不太一样 没放在infra里 是出于什么原因？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626526,"discussion_content":"结合《DDD》一书以及作者在github上的示例代码来看，infrastructure 包含了两个作用，一个是公共框架和工具性的基础代码，另一个是 repository 的实现，将者两种不同意义的代码放在同一层是不合适的。所以，在课程里，我把这两个意思分别放在了 common 和 driven adapter 里。其中 driven adapter 是采用了六边形架构的命名。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693056929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378434,"user_name":"LittleFatz","can_delete":false,"product_type":"c1","uid":1052722,"ip_address":"广东","ucode":"C374FBE3D63FDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/32/9256dc82.jpg","comment_is_top":false,"comment_ctime":1690251790,"is_pvip":false,"replies":[{"id":138089,"content":"基本是这样。严格的说，Org表达的是领域概念，至于和数据库的映射，是第二性的。OrgDto可以看作Org的门面。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1691070287,"ip_address":"广东","comment_id":378434,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"“非常近似的 OrgDto 和 Org 为什么不能合二为一？”\n关于这个问题我的理解是，OrgDTO更多的是为了自身应用和其他应用的交互问题，而Org只是自身应用的数据库表的直接映射。因为很多时候对外返回一个OrgDTO中，可能会包含很多其他关联实体的数据","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624930,"discussion_content":"基本是这样。严格的说，Org表达的是领域概念，至于和数据库的映射，是第二性的。OrgDto可以看作Org的门面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691070287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376306,"user_name":"末日，成欢","can_delete":false,"product_type":"c1","uid":1812201,"ip_address":"陕西","ucode":"BBAEBB9C93558A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132","comment_is_top":false,"comment_ctime":1686657676,"is_pvip":false,"replies":[{"id":137255,"content":"依赖关系有两种，一种是开发态，一种是运行态。层间依赖原则说的是开发态，你说的间接盗用了持久层是运行态。你细品一下。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1686840092,"ip_address":"广东","comment_id":376306,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，还有一个疑问，适配层做数据库持久化我可以理解，但是逻辑角度, 应用层还是间接调用了持久层做数据存储，这不是层间关系混乱了吗","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621134,"discussion_content":"依赖关系有两种，一种是开发态，一种是运行态。层间依赖原则说的是开发态，你说的间接盗用了持久层是运行态。你细品一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1686840092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2760458,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/1f/0a/3dd0cabc.jpg","nickname":"黑夜看星星","note":"","ucode":"20A2FDA0CC5DC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":628963,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696346092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":621134,"ip_address":"广东","group_id":0},"score":628963,"extra":""}]}]},{"had_liked":false,"id":376305,"user_name":"末日，成欢","can_delete":false,"product_type":"c1","uid":1812201,"ip_address":"陕西","ucode":"BBAEBB9C93558A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132","comment_is_top":false,"comment_ctime":1686656363,"is_pvip":false,"replies":[{"id":137250,"content":"抽接口的目的，关键是为了依赖倒置。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1686837848,"ip_address":"广东","comment_id":376305,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"\n老师，有个疑问，repositry说的是直接调用数据库,如果我在对repositry这层再封装一层,直接用这一层是不是也可以能够达到隔离变化,而不必抽一个接口。\n那么我这一层是不是也需要放到领域层?","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621128,"discussion_content":"抽接口的目的，关键是为了依赖倒置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686837849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372919,"user_name":"黄旗锋_APP小程序H5开发","can_delete":false,"product_type":"c1","uid":2949144,"ip_address":"浙江","ucode":"0B5B88A345F236","user_header":"https://static001.geekbang.org/account/avatar/00/2d/00/18/0a611c6b.jpg","comment_is_top":false,"comment_ctime":1681796061,"is_pvip":false,"replies":[{"id":136322,"content":"首先我还是倾向于用“面向过程”（代替“贫血模型”）和“面向对象”（代替“充血模型”）这两个数据。\n你说的对，目前的做法是偏面向过程的，在后面的课程中会进一步总结这种方法的特点。在这种风格中，最主要的点是领域对象不会访问数据库。\n\n如果要更加面相对象的话，领域对象就需要访问数据库了。那么，像你说的做法，是一种可行的做法。另外一种是使用JPA HIbernate这样的标准和框架，会更简洁一些，不过这些方法对程序员要求更高。\n","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1682235789,"ip_address":"广东","comment_id":372919,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师，有一个问题请教一下，我感觉现在的写法好像还是贫血模型，因为领域对象基本上就是对属性的get和set，而不包含具体的业务逻辑，业务逻辑主要还是在Repository仓储类和领域层的Handler中，在application层中还是要调用Repository和Handler中的方法。充血模型在领域驱动里面是如何体现出来的呢？是不是把orgRepository.findById()和orgHandler.update(org)这些的逻辑写在Org这个领域对象的一个方法中供application调用，才是更加符合充血模型呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615380,"discussion_content":"首先我还是倾向于用“面向过程”（代替“贫血模型”）和“面向对象”（代替“充血模型”）这两个数据。\n你说的对，目前的做法是偏面向过程的，在后面的课程中会进一步总结这种方法的特点。在这种风格中，最主要的点是领域对象不会访问数据库。\n\n如果要更加面相对象的话，领域对象就需要访问数据库了。那么，像你说的做法，是一种可行的做法。另外一种是使用JPA HIbernate这样的标准和框架，会更简洁一些，不过这些方法对程序员要求更高。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682235789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369695,"user_name":"神经蛙","can_delete":false,"product_type":"c1","uid":1803623,"ip_address":"广东","ucode":"2D71FC12E420AB","user_header":"https://static001.geekbang.org/account/avatar/00/1b/85/67/0d121bc4.jpg","comment_is_top":false,"comment_ctime":1677815490,"is_pvip":false,"replies":[{"id":134727,"content":"到底是module还是包，只是名称问题。原书5.5节的标题是“Modules (a.k.a. Packages)” 【模块（又称为“包”）】","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677919155,"ip_address":"广东","comment_id":369695,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"应用层应该还是得以来基础设施层。包的分层没问题，但是聚合一个层应该使用module而不是包\n","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607477,"discussion_content":"到底是module还是包，只是名称问题。原书5.5节的标题是“Modules (a.k.a. Packages)” 【模块（又称为“包”）】","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677919155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367964,"user_name":"py","can_delete":false,"product_type":"c1","uid":1496577,"ip_address":"上海","ucode":"2372522D715419","user_header":"https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg","comment_is_top":false,"comment_ctime":1675769080,"is_pvip":false,"replies":[{"id":133995,"content":"面向对象的基本特征是封装继承和多态。其他的可以继续往下看。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675830634,"ip_address":"广东","comment_id":367964,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1. 面向对象一定是有属性也有方法，方法可属性紧密相关，和所抽象的事物含义相匹配。\n2. 不清楚对不对","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602644,"discussion_content":"面向对象的基本特征是封装继承和多态。其他的可以继续往下看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675830634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367885,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1675699477,"is_pvip":true,"replies":[{"id":133998,"content":"谢谢指出代码问题。业务规则变更有可能影响领域模型，说演进模型比说重新建模要好些，模型本来就是在不断演进中的","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675831868,"ip_address":"广东","comment_id":367885,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"利用开卡和验卡的过程补充业务规则，这个的确比较敏捷。如果规则改变的比较多，那么是不是需要重新进行业务建模？\n\n非常近似的 OrgDto 和 Org 为什么不能合二为一？如果没有 OrgDto，那么后面也就不用移动了。\n\n从  UML 来看，可以很清楚的看到位于 Application 应用层的 OrgService 通过 Domain 领域层的接口，调用 Adapter 适配器层的持久化代码。\n\n顺便学习了领域模型和设计模型在 UML 中表现出来的差别，特别是其中对于中英文运用的区别，可以借鉴。\n\n通过抽取和移动接口，将被依赖的适配器层转换为适配器层依赖别的层，如果这个就是 Dependency Inversion 依赖倒置，那么倒是解决了困扰我很久的问题。\n\n看代码有点头大，为什么不能让 DDD 止步于设计？\n\n抄了一遍代码，不止 OrgService 类上面需要增加 @Service 注解；XxxRepositoryJdbc 类上面也需要增加 @Repository 注解。\n\n对于思考题，\n\n1. 面向对象三大特征，封装、继承、多态，偏过程的方式能实现，之前看到过用 C 语言实现面向对象的，不过没有必要，也无法发挥优势；\n\n2. 在这段程序中，领域逻辑主要体现在 OrgService 类中，似乎略有不妥，感觉应该放在 Domain 域中","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602649,"discussion_content":"谢谢指出代码问题。业务规则变更有可能影响领域模型，说演进模型比说重新建模要好些，模型本来就是在不断演进中的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675831868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366919,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1674617572,"is_pvip":false,"replies":[{"id":135209,"content":"非常好","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678983502,"ip_address":"广东","comment_id":366919,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1. 在你的心目中，面向对象有哪些特征？假如用偏过程的方式，是否也能实现这些特征？\n面向对象编程将数据和对象组合在一起，主要有四大特征：封装、抽象、继承、多态。面向过程编程也可以实现这四大特征，在简单的业务场景，面向过程编程和面向对象编程区别不大，例如很多功能性的crud，面向过程编程反而更加简单。在大规模业务复杂的业务场景，面向对象编程的代码更加具备易复用，易拓展，易维护。\n2. 在今天的程序中，领域逻辑主要体现在哪段代码，它们放对地方了吗？\n在application层的添加组织的代码，添加组织只是组织领域的业务应该放在领域层。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609497,"discussion_content":"非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678983502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366557,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"浙江","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1673925613,"is_pvip":false,"replies":[{"id":134776,"content":"R019就是你说的那个意思，按你说的“直接下级”会更好。\n代码笔误，谢谢指出，我回头改。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677930765,"ip_address":"广东","comment_id":366557,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"钟老师开卡验卡补充的一个业务规则R019是不是不太妥，同个组织下不能有同名组织，应该还有限制条件吧比如直接下级组织，举个例子开发中心有金融开发中心和消费者开发中心，金融开发中心下有开发一组，消费者开发中心也可以有开发一组，这样开发中心就有了两个同名下级组织开发一组；\n还有一个，应用层的OrgService代码中漏加了@Service注解，不然没法注入到Spring容器中导致bean缺失无法启动","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607532,"discussion_content":"R019就是你说的那个意思，按你说的“直接下级”会更好。\n代码笔误，谢谢指出，我回头改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677930765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267107,"avatar":"https://static001.geekbang.org/account/avatar/00/13/55/a3/88cbb981.jpg","nickname":"　","note":"","ucode":"246CD8612E84EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600606,"discussion_content":"1.业务问题不用纠结，学的是技术。2.应该只是漏了，或者其他地方有配置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674614626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"海南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366461,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1104180,"ip_address":"广东","ucode":"C2F4E624810E3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/34/165e862f.jpg","comment_is_top":false,"comment_ctime":1673832895,"is_pvip":false,"replies":[{"id":134771,"content":"笔误，多谢指出。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677930200,"ip_address":"广东","comment_id":366461,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"OrgService类上为什么没加@Service注解了，如果没加在适配器层如何注入OrgService的","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607525,"discussion_content":"笔误，多谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677930201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365547,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1672751563,"is_pvip":false,"replies":[{"id":133412,"content":"有收获就好，后面内容更精彩！","user_name":"编辑回复","user_name_real":"编辑","uid":1501385,"ctime":1673435309,"ip_address":"北京","comment_id":365547,"utype":2}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"对“仓库放在适配器层”有了直观的了解。原来 DDD 的代码是这样！","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599310,"discussion_content":"有收获就好，后面内容更精彩！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1673435309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365412,"user_name":"leesper","can_delete":false,"product_type":"c1","uid":1351104,"ip_address":"广东","ucode":"CC76320571BECA","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg","comment_is_top":false,"comment_ctime":1672470718,"is_pvip":false,"replies":[{"id":133257,"content":"回答得基本没问题。关于偏过程风格的问题，实际上，用C模拟面向对象，是用“纯”过程式的语言来模拟，所以比较麻烦。而我们说的“偏”过程，用的仍然是面向对象语言，所以会方便和直观很多。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673090134,"ip_address":"广东","comment_id":365412,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"思考题：\n1. 在我心目中面向对象的特征主要是：封装，继承和多态。用偏过程的方式能实现，但比较麻烦，我见过用C写的OOP风格代码，用了很多很tricky的技巧，不熟悉C特性的话可读性不是那么直观\n\n2. 今天的代码中领域逻辑主要体现在buildOrg()，它根据业务规则创建领域对象Org，它实现在应用层故没有放对地方，应该放领域层","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598788,"discussion_content":"回答得基本没问题。关于偏过程风格的问题，实际上，用C模拟面向对象，是用“纯”过程式的语言来模拟，所以比较麻烦。而我们说的“偏”过程，用的仍然是面向对象语言，所以会方便和直观很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673090134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365108,"user_name":"Geek_8ac303","can_delete":false,"product_type":"c1","uid":1888721,"ip_address":"广东","ucode":"64A176DE7F498E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIERY97h7dmXbtur6rhZWA9Jb3TtSsJh7icDdFjdLmruTXC22qibOVTmW2a04TxMhxqtNJibYL1iaU7yQ/132","comment_is_top":false,"comment_ctime":1672115549,"is_pvip":false,"replies":[{"id":132996,"content":"您的每个层基本都可以和ddd分层架构对上。模型层大体对应领域层，可以在稍微面向对象一点。bo不是很理解，是dto吗？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1672229074,"ip_address":"广东","comment_id":365108,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"看了老师这个分层，感觉很简洁，虽然和我们项目结构不一样，但是大致一样\n在其他文章中有看到这样的分层\n控制器层（控制器、vo）\nservice层（service、BO（贫血模型）、Domain（富领域模型））\n仓库层（repository）\n模型层（entity、常量、枚举）\n我在开发的项目中是这样分的\n控制器层（控制器）\nservice层（service）\n仓库层（repository）\n模型层（entity（贫血的领域模型，方法都在service里）、BO（只有必要的情况下才声明，结构和entity略有不同，范围更小或者是更大），常量、枚举）\n您怎么看","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597785,"discussion_content":"您的每个层基本都可以和ddd分层架构对上。模型层大体对应领域层，可以在稍微面向对象一点。bo不是很理解，是dto吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672229074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703256,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","nickname":"6点无痛早起学习的和尚","note":"","ucode":"33A8A1CDA103F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598493,"discussion_content":"我们的开发项目分层也是跟你们差不多，1. Controller 调用 Service，2. Service 调用 Repository，3. Repository 调用 xxMapper，第 1 步传输对象就是 xxRequest，第二步传输对象就是 xxEntity（DB 实体），如果 Service 层之间互相调用传输 xxDto，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672879775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367914,"user_name":"mm马","can_delete":false,"product_type":"c1","uid":1462076,"ip_address":"江苏","ucode":"8CD674E4F61FC7","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/3c/296b5fa7.jpg","comment_is_top":false,"comment_ctime":1675737104,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"从仓库抽象出一个接口移到领域层，而适配层的仓库成为了这个接口的实现类 -- 能力供应商模式","like_count":2},{"had_liked":false,"id":383813,"user_name":"Geek_有心","can_delete":false,"product_type":"c1","uid":2379461,"ip_address":"广东","ucode":"A940B79C84329C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kFuWg0sRPIT94SGU5Ciaic1LXlHpMkAf4vC0GlCURVFZczUnL0sMhf3TBombsTxReicxl7VhafI5uHyoShUpwoHOg/132","comment_is_top":false,"comment_ctime":1699696569,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"但是企业应用则有一个本质的不同，就是数据主要在数据库里，每次只能把一小部分远程拿到内存，所以不能在内存里对对象进行自由地导航。这个区别就造成，早期的面向对象编程很难直接用在企业应用，间接导致了贫血模型的普及。   这里和tw的徐昊说的早起oo的鼻祖语言small talk有个虚拟镜像的东西 ，会把内存中所以对象持久化 。启动时会加载。所以内存对象等同于持久化对象。两者很相似","like_count":0},{"had_liked":false,"id":378529,"user_name":"Wheat Liu","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"北京","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/8b417c84.jpg","comment_is_top":false,"comment_ctime":1690373026,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"个人觉得应该adapter层调用app层也应该贯彻依赖倒置原则，由外到内就是：dto和rpc接口放在一起打包（假如包名叫sdk），adapter层定义app层的接口和dto，实现sdk包，调用app层接口并进行dto转换，这样可以完全将adapter层和app层解耦\n","like_count":0},{"had_liked":false,"id":369230,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1677250092,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100311801,"comment_content":"第 10 课笔记 https:&#47;&#47;wyyl1.com&#47;post&#47;23&#47;05&#47;\n代码只实现了 Org save(Org org) 保存数据到 MySQL 功能，其他功能我也没有完全明白，后续再说\n地址 https:&#47;&#47;github.com&#47;wyyl1&#47;geektime-ddd&#47;tree&#47;2","like_count":0}]}