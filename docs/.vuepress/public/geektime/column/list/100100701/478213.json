{"id":478213,"title":"14｜标准库：如何使用互斥量等技术协调线程运行？","content":"<p>你好，我是于航。</p><p>在上一讲中，我主要介绍了有关并发编程的一些基础知识，并通过一个简单的例子展示了如何在 C 语言中进行线程创建等基本操作。同时我也向你介绍了，数据竞争、竞态条件，以及指令重排等因素，都在如何影响着多线程应用的执行正确性。那么，有哪些方法可以辅助我们解决这些问题呢？</p><p>今天我们就来看看 C 语言为并发编程提供的几大利器：互斥量、原子操作、条件变量，以及线程本地变量。</p><h2>使用互斥量</h2><p>从本质上来看，互斥量（Mutex）其实就是一把锁。一个线程在访问某个共享资源前，需要先对互斥量进行加锁操作。此时，其他任何想要再对互斥量进行加锁的线程都会被阻塞，直至当前线程释放该锁。而当锁被释放后，所有之前被阻塞的线程都开始继续运行，并再次重复之前的步骤，开始“争夺”可以对互斥量进行加锁的名额。通过这种方式，我们便可以保证每次在对多线程共享的资源进行操作时，都仅只有一个线程。</p><p>在 C 语言中，我们可以通过头文件 threads.h 提供的，以 “mtx_” 为前缀的相关接口来使用互斥量的能力。你应该还记得我在<a href=\"https://time.geekbang.org/column/article/477358\">上一讲</a>中提到的，那段存在数据竞争的 C 示例代码。这里我对它进行了改写，如下所示：</p><pre><code class=\"language-c++\">#include &lt;threads.h&gt;\n#include &lt;stdio.h&gt;\n#define THREAD_COUNT 10\n#define THREAD_LOOP 100000000\nmtx_t mutex;\nlong counter = 0;\nint run(void* data) {\n&nbsp; for (int i = 0; i &lt; THREAD_LOOP; i++) {\n&nbsp; &nbsp; mtx_lock(&amp;mutex);  // 对互斥量加锁，\n&nbsp; &nbsp; counter++;\n&nbsp; &nbsp; mtx_unlock(&amp;mutex);  // 释放一个互斥量；\n&nbsp; }\n&nbsp; printf(\"Thread %d terminates.\\n\", *((int*) data));\n&nbsp; return thrd_success;\n}\nint main(void) {\n#ifndef __STDC_NO_THREADS__\n&nbsp; int ids[THREAD_COUNT];\n&nbsp; mtx_init(&amp;mutex, mtx_plain);  // 创建一个简单、非递归的互斥量对象；\n&nbsp; thrd_t threads[THREAD_COUNT];\n&nbsp; for (int i = 0; i &lt; THREAD_COUNT; i++) {\n&nbsp; &nbsp; ids[i] = i + 1;\n&nbsp; &nbsp; thrd_create(&amp;threads[i], run, ids + i);&nbsp;\n&nbsp; }\n&nbsp; for (int i = 0; i &lt; THREAD_COUNT; i++)\n&nbsp; &nbsp; thrd_join(threads[i], NULL);\n&nbsp; printf(\"Counter value is: %ld.\\n\", counter);\n&nbsp; mtx_destroy(&amp;mutex);  // 销毁一个互斥量对象；\n#endif\n&nbsp; return 0;&nbsp;\n}\n</code></pre><!-- [[[read_end]]] --><p>可以看到，在代码的第 19 行，我们使用 mtx_init 函数创建了一个基本类型（mtx_plain）的互斥量对象（下文中简称互斥量）。紧接着，在 run 函数内部，对变量 counter 进行值累加操作前，我们需要通过 mtx_lock 函数，来对之前创建的互斥量进行加锁操作。同样地，当进程使用完共享变量后，还需要通过 mtx_unlock 函数对互斥量进行解锁，来让其他线程有机会继续对共享变量进行处理。最后，在代码的第 28 行，程序退出前，我们销毁了之前创建的互斥量。</p><p>总的来看，<strong>在 C 语言中，互斥量可以被分为三种类型</strong><strong>：</strong><strong>mtx_plain、mtx_recursive 与 mtx_timed</strong>。</p><p>其中，mtx_plain 为最简单类型的互斥量，我们可以对它进行基本的加锁和解锁，但不能将其用在需要“重复加锁”的场景（比如函数的递归调用）中。这是因为，即使当前线程拥有该锁，对同一个 mtx_plain 互斥量的再次加锁也会导致该线程被阻塞。而此时，便会产生死锁的问题，即当前线程等待自己解锁后才能够再次进行加锁，而想要解锁，则需要让线程先加锁以完成当前功能的执行。</p><p>相反，mtx_recursive 类型的互斥量也被称为“可重入互斥量（Reentrant Mutex）”，顾名思义，它可以被用在需要重复加锁的场景中。该类型互斥量可以被同一个线程重复锁定多次，而不会阻塞线程。但相应地，对它的完全解锁也需要执行对应多次的 mtx_unlock。</p><p>而最后一种是 mtx_timed 类型的互斥量，它具有特殊的“超时属性”。这意味着，通过配合使用 mtx_timedlock 函数，我们可以实现“带超时限制的互斥量加锁”，即线程在尝试给对应互斥量加锁时，只会以阻塞的方式等待一定时间。若超过给定时间后仍未给互斥量成功上锁，则线程继续执行。</p><p>除了上面提到过的函数，C 标准库还提供了另外两个与“互斥”有关的函数。这里，我将它们整理在了下面的表格中，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/17/78714c4df8217a2fc56b750301722817.jpg?wh=1920x536\" alt=\"图片\"></p><p>利用互斥锁能够帮助我们解决数据竞争问题，但在某些对性能要求更加严苛的场景下，它可能并非最好的选择。接下来，让我们来看看另一种可以避免数据竞争的方式，原子操作。</p><h2>使用原子操作</h2><p>原子是化学反应中不可被继续分割的基本微粒，那么顾名思义，“原子操作”的意思就是操作本身无法再被划分为更细的步骤。当我们在多个不同线程中对共享资源进行原子操作时，编译器和 CPU 将会保证这些操作的正确执行，即同一时刻只会有一个线程在进行这些操作。而只有在该线程将整个操作全部执行完毕后，其他线程才可以继续执行同样的操作。</p><p>类似地，通过 C11 提供的名为 stdatomic.h 的头文件，我们可以方便地使用这些原子操作能力。比如，在下面这段代码中，我们便通过这种方式，解决了<a href=\"https://time.geekbang.org/column/article/477358\">上一讲</a>中那个实例的数据竞争问题。</p><pre><code class=\"language-c++\">#include &lt;threads.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdatomic.h&gt;\n#define THREAD_COUNT 10\n#define THREAD_LOOP 100000000\n#if !defined(__STDC_NO_ATOMICS__)\n_Atomic long counter = 0;&nbsp; // 定义一个原子类型全局变量，用来记录线程的累加值；\n#endif\nint run(void* data) {\n&nbsp; for (int i = 0; i &lt; THREAD_LOOP; i++)\n&nbsp; &nbsp; atomic_fetch_add_explicit(&amp;counter, 1, memory_order_relaxed);  // 使用原子加法操作；\n&nbsp; printf(\"Thread %d terminates.\\n\", *((int*) data));\n&nbsp; return thrd_success;\n}\nint main(void) {\n#if !defined(__STDC_NO_THREADS__) || !defined(__STDC_NO_ATOMICS__)\n&nbsp; int ids[THREAD_COUNT];\n&nbsp; thrd_t threads[THREAD_COUNT];&nbsp;&nbsp;\n&nbsp; for (int i = 0; i &lt; THREAD_COUNT; i++) {\n&nbsp; &nbsp; ids[i] = i + 1;\n&nbsp; &nbsp; thrd_create(&amp;threads[i], run, ids + i);\n&nbsp; }\n&nbsp; for (int i = 0; i &lt; THREAD_COUNT; i++)\n&nbsp; &nbsp; thrd_join(threads[i], NULL);\n&nbsp; printf(\"Counter value is: %ld.\\n\", counter);\n#endif\n&nbsp; return 0;&nbsp;\n}\n</code></pre><p>与使用线程控制相关接口类似，我们也需要通过名为 <strong>STDC_NO_ATOMICS</strong> 的宏，来判断编译器是否对原子操作提供支持。可以看到，我们分别在代码的第 6 行与第 16 行进行了相应的预处理判断。</p><p>接下来，在代码的第 7 行，我们使用 C11 新引入的 <code>_Atomic</code> 关键字，修饰了原有的全局变量 counter，以将它定义为一个原子类型（这里也可以直接使用 C 标准库为我们封装好的宏 atomic_long）。</p><p>紧接着，在 run 函数内部，代码的第 11 行，我们使用名为 atomic_fetch_add_explicit 的函数来完成对 counter 变量的累加过程。该函数为我们提供了一种原子累加操作，可以使线程在进行数据累加时独占整个变量。除此之外，你还需要注意：通过该函数的第三个参数，我们还可以指定当前操作需要满足的内存顺序。</p><p>在上一讲中我提到，由于编译器和处理器可能会采用指令重排来优化程序的运行效率，因此，当在多核 CPU 上运行存在线程间数据依赖的多线程应用时，程序的正确性可能会出现问题。那么，怎样解决这个问题呢？我们来看下面这段代码。这里，我通过指定各个原子操作的具体内存顺序，修复了上一讲最后一小节中提到的例子。</p><pre><code class=\"language-c++\">#include &lt;threads.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdatomic.h&gt;\n#if !defined(__STDC_NO_ATOMICS__)\natomic_int x = 0, y = 0;\n#endif\nint run(void* v) {\n&nbsp; atomic_store_explicit(&amp;x, 10, memory_order_relaxed);\n&nbsp; atomic_store_explicit(&amp;y, 20, memory_order_release);\n}\nint observe(void* v) {\n&nbsp; while(atomic_load_explicit(&amp;y, memory_order_acquire) != 20);\n&nbsp; printf(\"%d\", atomic_load_explicit(&amp;x, memory_order_relaxed));\n}\nint main(void) {\n#if !defined(__STDC_NO_THREADS__) || !defined(__STDC_NO_ATOMICS__)\n&nbsp; thrd_t threadA, threadB;&nbsp;&nbsp;\n&nbsp; thrd_create(&amp;threadA, run, NULL);\n&nbsp; thrd_create(&amp;threadB, observe, NULL);\n&nbsp; thrd_join(threadA, NULL);\n&nbsp; thrd_join(threadB, NULL);\n#endif\n&nbsp; return 0;&nbsp;\n}\n</code></pre><p>可以看到，我们修改了线程 run 和 observe 中对原子类型变量 x 和 y 的读写操作。其中，函数 atomic_load_explicit 用来读取某个原子类型变量的值；而对它们的修改，则使用函数 atomic_store_explicit 进行。除此之外，这两个函数都支持通过它们的最后一个参数，来指定相应操作需要遵循的内存顺序。</p><p>在这段修改后的代码中，一共使用到了三种不同的内存顺序（对应三个枚举值）。首先，我们来看看它们的具体定义。为了方便你观察，我将这些信息整理在了下面的表格中。</p><p><img src=\"https://static001.geekbang.org/resource/image/37/3c/377071e6c666ddc088d3ea27f255793c.jpg?wh=1920x689\" alt=\"图片\"></p><p>相信看过这三种内存顺序的定义后，你已经对它们的作用有个大致了解了。其中，对于使用了 memory_order_relaxed 的操作，我们并不需要对它们的执行顺序做任何保证。相反，编译器和处理器可以按照需求进行适当的优化。</p><p>而在 run 线程中，为了保证对变量 x 的修改过程一定发生在变量 y 的值被修改前，我们便需要使用 memory_order_release 来限制对变量 y 的修改，一定要在之前的所有修改都完成后再进行。同样地，对于 observe 线程来说，为了防止处理器提前将变量 x 的值放入缓存，这里，我们也需要通过 memory_order_acquire，来保证对变量 y 进行的读操作一定会比对变量 x 的读操作先发生。你可以通过下面这张图片，直观地理解上面我们提到的各个操作之间的执行关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/71/6249a06dd718c52159bd57a423005871.jpg?wh=2248x1467\" alt=\"\"></p><p>除了我们在上面的例子中用到的三种内存顺序外，C 语言还提供了另外 3 种不同的内存顺序，供我们在不同的场景中使用。如果想了解关于它们的更多信息，你可以参考<a href=\"https://en.cppreference.com/w/c/atomic/memory_order\">这个链接</a>。</p><p>总的来看，C11 通过 stdatomic.h 头文件为我们提供了大量可用于原子操作的相关类型、宏，以及函数。相较于使用互斥量，原子操作可以让我们更加清晰和方便地抽象并行代码，而不需要频繁进行加锁与释放锁的操作。</p><p>不仅如此，从执行性能角度，原子操作的执行通常直接依赖于 CPU 提供的相应的原子机器指令，比如在 x86-64 平台上，atomic_fetch_add_explicit 函数对应的 <code>lock add</code> 指令。而使用互斥量则需要让线程阻塞，还要频繁进行上下文切换，因此与之相比，原子操作的性能通常会更好。</p><p>这里，我将一些与原子操作相关的常用标准库函数整理在了下面的表格中，供你参考。你也可以点击<a href=\"https://en.cppreference.com/w/c/atomic\">这个链接</a>，查看更多信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/01/7a/0162c8f6488551746c1364f39994f47a.jpg?wh=1920x1182\" alt=\"图片\"></p><h2>使用条件变量</h2><p>条件变量是一种常用的线程同步机制。通过上一小节的例子，你会发现，在多线程应用中，存在着一种十分常见的线程间同步模式，即某个线程的执行依赖于另一个线程对数据首先进行的预处理。在上面的例子中，observe 线程中某段逻辑的执行需要等待 run 线程将原子变量 y 的值变为 20。这里，我们通过“忙等待（Busy Waiting）”的方式实现了这个效果。</p><p>用忙等待虽然可以达到我们的预期，但这是一种十分“昂贵”的方式，甚至会被认为是一种反模式，应该避免使用。这是因为，忙等待需要让线程反复检查某个条件是否为真，因此，需要浪费大量宝贵的 CPU 资源在无用的活动上。那么，有没有更好的办法，既可以尽量减少处理器资源的浪费，又能够解决线程间数据依赖的问题呢？答案是有的，这个方法就是使用条件变量。</p><p>来看下面这个例子：</p><pre><code class=\"language-c++\">#include &lt;threads.h&gt;\n#include &lt;stdio.h&gt;\nmtx_t mutex;\ncnd_t cond;  // 定义一个条件变量；\nint done = 0;\nint run(void* data) {\n&nbsp; mtx_lock(&amp;mutex);&nbsp;\n&nbsp; done = 1;\n&nbsp; cnd_signal(&amp;cond);  // 通知等待中的线程；\n&nbsp; mtx_unlock(&amp;mutex);&nbsp;\n&nbsp; return thrd_success;\n}\nint main(void) {\n#ifndef __STDC_NO_THREADS__\n&nbsp; mtx_init(&amp;mutex, mtx_plain);&nbsp;\n&nbsp; cnd_init(&amp;cond);  // 初始化条件变量；\n&nbsp; thrd_t thread;&nbsp;&nbsp;\n&nbsp; thrd_create(&amp;thread, run, NULL);\n&nbsp; mtx_lock(&amp;mutex);&nbsp;\n&nbsp; while (done == 0) {\n&nbsp; &nbsp; cnd_wait(&amp;cond, &amp;mutex);  // 让当前线程进入等待队列；\n&nbsp; }\n&nbsp; mtx_unlock(&amp;mutex);&nbsp;\n&nbsp; printf(\"The value of done is: %d\", done);\n  mtx_destroy(&amp;mutex);\n  cnd_destroy(&amp;cond);  // 销毁条件变量；\n#endif\n&nbsp; return 0;&nbsp;\n}\n</code></pre><p>这段代码的基本逻辑与上一小节的例子类似。从第 23 行开始的代码，执行前需要等待 run 线程首先将全局变量 done 的值修改为 1。代码的第 15~16 行，我们初始化了需要使用的互斥量对象与条件变量对象。在 main 线程对应代码的第 19~23 行，我们使用了与条件变量相关的函数 cnd_wait。该函数在被调用时，需要当前线程获得一个互斥锁，并将其作为实参传递给它，函数调用后锁会被释放。同时，所有执行到此处的线程都将被阻塞。</p><p>接下来，让我们把目光移到 run 线程。</p><p>在 run 线程代码的第 8 行，我们将变量 done 的值修改为 1。紧接着，通过调用函数 cnd_signal，run 线程得以“通知”所有之前被阻塞在函数 cnd_wait 处的线程，来让它们中的一个可以继续运行。当然，在这个例子中，我们只有 main 函数对应的一个线程。此时，互斥量将被重新上锁，main 线程将继续执行接下来的指令。在代码的第 24~26 行，它打印出了全局变量 done 的值，并销毁了互斥量与条件变量对象。最后，程序执行完毕。</p><p>可以看到，实际上，<strong>条件变量为我<strong><strong>们</strong></strong>提供了一种线程间的“通知”能力</strong>。某个线程可以在完成了某件事情后，通知并唤醒等待线程，让其继续工作，完成接下来的任务。而在这个过程中，我们不需要通过忙等待的方式，让线程频繁查询标志量。因此，CPU 资源得到了更好的利用。</p><p>这里，我向你提一个小问题：为什么我们在代码的第 20 行使用 <code>while</code> 语句，而不是 <code>if</code> 语句呢？欢迎在评论区告诉我你的答案。</p><p>在并发编程中，条件变量是一个十分强大的武器。通过它，我们可以进一步实现监视器（Monitor）、管程等工具和同步原语。而且，它也可以很好地解决经典的生产者-消费者问题。如果你对这部分内容感兴趣，可以参考《C++ Concurrency in Action》和《现代操作系统》等书，来进行更加深入的学习。虽然它们并不会专门介绍基于 C 语言的并发编程，但其中的很多概念，甚至 C++ 接口，与 C 语言都是类似和相通的。</p><p>除了上述代码中用到的条件变量方法外，C 标准库还提供了另外两个常用函数。我将它们整理在了下面的表格中，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/d9/b86fe8de3106d0430523ea29833d02d9.jpg?wh=1920x666\" alt=\"图片\"></p><p>最后，让我们再回过头来，看看与线程直接相关的另一个内容，线程本地变量。</p><h2>使用线程本地变量</h2><p>除了可以共享存在于进程内的全局变量外，线程还可以拥有属于它自己的线程本地变量（TLS）。</p><p>顾名思义，线程本地变量的值仅能够在某个具体线程的生存期内可用。变量的实际存储空间会在线程开始时分配，线程结束时回收。线程不会对这些变量的读写操作产生数据竞争。我们来看一个例子：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;threads.h&gt;\n#include &lt;stdatomic.h&gt;\n#define THREAD_COUNT 10\n#define THREAD_LOOP 10000\n_Thread_local int counter = 0;&nbsp; // 定义线程本地变量；\nint run(void *data) {\n&nbsp; for (int i = 0; i &lt; THREAD_LOOP; ++i)\n&nbsp; &nbsp; counter += 1;&nbsp; // 更新当前线程所属的 counter 变量值；\n&nbsp; return counter;\n}\nint main(int argc, char const *argv[]) {\n&nbsp; thrd_t threads[THREAD_COUNT];\n&nbsp; int sum = 0, result = 0;\n&nbsp; for (int i = 0; i &lt; THREAD_COUNT; ++i)\n&nbsp; &nbsp; thrd_create(&amp;threads[i], run, NULL);\n&nbsp; for (int i = 0; i &lt; THREAD_COUNT; ++i) {\n&nbsp; &nbsp; thrd_join(threads[i], &amp;result);\n&nbsp; &nbsp; sum += result;&nbsp; // 累加每个线程的计算值；\n&nbsp; }\n&nbsp; printf(\"The value of count is %d.\\n\", sum);\n&nbsp; return 0;\n}\n</code></pre><p>可以看到，这段代码的逻辑十分简单：我们创建了 10 个（对应 THREAD_COUNT）线程，让它们同时对全局变量 counter 进行累加，并持续 10000 次（对应 THREAD_LOOP）。然后，在 main 线程的最后，我们将累加后的值打印了出来。</p><p>看到这里，相信你的第一感觉肯定是：应该通过互斥锁或原子操作等方式，来防止多个线程在对 counter 变量进行修改时产生数据竞争。但在这里，我却没有这样做，而是采用了一种更加便捷的方式。这一切，都要得益于线程本地变量的存在。</p><p>在代码的第 6 行，我们使用 <code>_Thread_local</code> 关键字（也可以使用宏 thread_local），将全局变量 counter 标记为线程本地变量。这意味着，每个线程都会在创建时生成仅属于当前线程的变量 counter。因此，当本线程在对 counter 变量进行累加时，便不会受到其他线程的影响。而当线程退出时，通过代码第 18 行的 thrd_join，我们得以在 main 线程中将每个结束线程返回的，各自的 counter 值再进行统一累加，从而得到最后的计算结果。你可以通过下图来直观地理解这个过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/de/1e4ba90a95a72yyd1a458a50299b6cde.jpg?wh=2248x1764\" alt=\"\"></p><p>总之，线程本地变量为我们提供了另一种可以避免数据竞争的方式。除此之外，它也可以被用来存储线程独有的一些信息，比如 errno 的值。</p><p>我们在上面代码中使用的是<strong>以关键字来定义线程本地变量的方式</strong>，除此之外，标准库还提供了一系列的函数，可以实现同样的目的。但不同之处在于，通过 tss_create 等函数来创建线程本地变量时，还可以为其指定对应的析构函数。这样，当线程退出时，便可以确保相应的线程本地资源（比如堆内存）能够以正确的方式被清理。这里，我将相关的函数列在了下面的表格中，供你参考。你也可以点击<a href=\"https://en.cppreference.com/w/c/atomic\">这个链接</a>查看更多信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/00/ec/00980e87a07d7e1f63f4yyc010033eec.jpg?wh=1920x653\" alt=\"图片\"></p><h2>总结</h2><p>好了，讲到这里，今天的内容也就基本结束了。最后我来给你总结一下。</p><p>在本讲中，我主要介绍了有关互斥量、原子操作、条件变量，以及线程本地变量的相关内容。合理地使用这些方式，我们就可以避免多线程应用经常会遇到的，由于数据竞争、竞态条件，以及指令重排引起的问题。</p><p>其中，互斥量让我们可以通过对它进行<strong>加锁与解锁</strong>的方式，来限制多个线程的执行，以让它们有序地使用共享资源。在 C 语言中，互斥量被分为三种类型，mtx_plain 为最基本类型，mtx_recursive 可以被用在需要重复加锁的场景中，而 mtx_timed 则使得互斥量具有了超时属性。通过与 mtx_timedlock 结合使用，它可以让线程在给互斥量加锁时，只尝试有限的一段时间。</p><p>原子操作是一种更便捷的可以用来避免数据竞争的方式。通过使用 <code>_Atomic</code> 关键字，我们可以将变量定义为原子类型。而当线程访问该类型变量时，便可<strong>按照“不可分割”的形式，一次性完成整个操作</strong>。不仅如此，在进行原子操作时，还可以同时指定操作需要满足的内存顺序。原子操作的实现通常依赖于所在平台的特殊机器指令，而 C 标准库则通过直接提供常用同步原语的方式，帮我们屏蔽了这些细节。</p><p><strong>条件变量提供了线程间的通知能力。</strong>它可以让线程在完成某件事情后，通知需要进行后续处理的等待线程，从而让具有数据依赖关系的线程以一种更加高效的方式进行同步。除此之外，条件变量还可被用于实现监视器、管程等更多复杂的同步机制。</p><p>最后，线程本地变量也是一种可用于解决数据竞争的常用方式。具体的操作是在 C 代码中，为全局变量添加 <code>_Thread_local</code> 关键字。<strong>这样，就会仅在线程创建时，才生成仅属于当前线程的本地同名变量。</strong> 因此，当前线程对该变量的修改便不会被其他线程影响。</p><h2>思考题</h2><p>x86-64 指令集中的 mfence、lfence 与 sfence 指令，它们具体有什么作用呢？试着查找资料了解一下，并在评论区分享你的发现。</p><p>今天的课程到这里就结束了，希望可以帮助到你，也希望你在下方的留言区和我一起讨论。同时，欢迎你把这节课分享给你的朋友或同事，我们一起交流。</p>","neighbors":{"left":{"article_title":"13｜标准库：你需要了解的 C 并发编程基础知识有哪些？","id":477358},"right":{"article_title":"15｜标准库：信号与操作系统软中断有什么关系？","id":479176}},"comments":[{"had_liked":false,"id":330689,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1642123169,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14527025057","product_id":100100701,"comment_content":"使用 while 的原因是，当阻塞的线程被重新调度运行时，done 的值可能被改变了，不是预期值。","like_count":3,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551573,"discussion_content":"没错，这是一个重要原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645063874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331149,"user_name":"ZR2021","can_delete":false,"product_type":"c1","uid":1707352,"ip_address":"","ucode":"4F685C7516F057","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","comment_is_top":false,"comment_ctime":1642465106,"is_pvip":false,"replies":[{"id":"122232","content":"1. 没错！防止 Spurious Wakeup 是其中一个重要原因；<br>2. 实际上 C 标准中的大部分线程控制，以及条件变量等能力的实现，在 Unix 等系统上都是直接通过 pthread 库来实现的。你会发现接口使用上虽然有差异，但却也并不大。C 标准只是将最小的可用子集进行了标准化。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1645033364,"ip_address":"","comment_id":331149,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10232399698","product_id":100100701,"comment_content":"使用while是防止广播通知方式的虚假唤醒吧，需要用户进一步判断，但是，我看还有人说可能存在非广播方式的虚假唤醒，不知道什么场景下会出现这种情况，还有，我们现在使用的都是pthread 库，不知道跟老师讲的c库自带的这些原子等操作有什么区别……","like_count":2,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551520,"discussion_content":"1. 没错！防止 Spurious Wakeup 是其中一个重要原因；\n2. 实际上 C 标准中的大部分线程控制，以及条件变量等能力的实现，在 Unix 等系统上都是直接通过 pthread 库来实现的。你会发现接口使用上虽然有差异，但却也并不大。C 标准只是将最小的可用子集进行了标准化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645033364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346458,"user_name":"ckj","can_delete":false,"product_type":"c1","uid":2874125,"ip_address":"","ucode":"1505C25A06C82C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/db/0d/99dac7e2.jpg","comment_is_top":false,"comment_ctime":1653148550,"is_pvip":false,"replies":[{"id":"127253","content":"是这样的。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1656229947,"ip_address":"","comment_id":346458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5948115846","product_id":100100701,"comment_content":"请问下 条件变量的例子中 21行 main中的互斥量重新加锁是不是需要等run中的释放之后才能加锁？ 因为mtx_plain?","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577611,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656229947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334087,"user_name":"墨","can_delete":false,"product_type":"c1","uid":2616644,"ip_address":"","ucode":"8198903D2029D2","user_header":"https://static001.geekbang.org/account/avatar/00/27/ed/44/4399a41a.jpg","comment_is_top":false,"comment_ctime":1644737826,"is_pvip":false,"replies":[{"id":"122164","content":"实际上这里的 while 循环不会持续执行，所有执行到 cnd_wait 的线程都会被阻塞，直到有子线程在适当时刻通过 cnd_signal “通知” main 线程。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1644936753,"ip_address":"","comment_id":334087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5939705122","product_id":100100701,"comment_content":"用了条件变量后，还是有循环一直在判断 done 的值啊，只不过变成到 main 函数中判断了，感觉和之前没啥区别啊","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551236,"discussion_content":"实际上这里的 while 循环不会持续执行，所有执行到 cnd_wait 的线程都会被阻塞，直到有子线程在适当时刻通过 cnd_signal “通知” main 线程。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644936753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330885,"user_name":"白花风信子","can_delete":false,"product_type":"c1","uid":2850941,"ip_address":"","ucode":"89CA70180EA326","user_header":"https://static001.geekbang.org/account/avatar/00/2b/80/7d/51914d34.jpg","comment_is_top":false,"comment_ctime":1642248888,"is_pvip":false,"replies":[{"id":"120832","content":"并发编程由于相关概念较多，可以试着先从 13 14 这两讲中提到的基础内容熟悉起来。比如可以找一本专门讲并发编程的书看，这样可以有一个较为统一和完整的认知。当然，专门讲 C 并发的书不是很多，可以选择性看看 Thierry Delisle 写的《Concurrency in C》 ，或者《C++ Concurrency in Action》。","user_name":"作者回复","user_name_real":"作者","uid":"1005890","ctime":1642337871,"ip_address":"","comment_id":330885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937216184","product_id":100100701,"comment_content":"并发编程这儿感觉有点不熟悉.....请问有什么练习的建议吗？感觉和平常接触的有很多不同。","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546531,"discussion_content":"并发编程由于相关概念较多，可以试着先从 13 14 这两讲中提到的基础内容熟悉起来。比如可以找一本专门讲并发编程的书看，这样可以有一个较为统一和完整的认知。当然，专门讲 C 并发的书不是很多，可以选择性看看 Thierry Delisle 写的《Concurrency in C》 ，或者《C++ Concurrency in Action》。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642337871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358023,"user_name":"范文龙","can_delete":false,"product_type":"c1","uid":1027214,"ip_address":"北京","ucode":"E77A5AF5BDBE6C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/8e/cb4cf9cb.jpg","comment_is_top":false,"comment_ctime":1663835438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663835438","product_id":100100701,"comment_content":"文中的例子，可以直接将 counter 放到任务栈中。<br>int run(void *data) {<br>  int counter = 0;<br>  for (int i = 0; i &lt; THREAD_LOOP; ++i)<br>    counter += 1;  &#47;&#47; 更新当前线程所属的 counter 变量值；<br>  return counter;<br>}","like_count":0},{"had_liked":false,"id":351636,"user_name":"赖淦","can_delete":false,"product_type":"c1","uid":2863084,"ip_address":"","ucode":"62A0F35B49C08A","user_header":"https://static001.geekbang.org/account/avatar/00/2b/af/ec/df1c0a1d.jpg","comment_is_top":false,"comment_ctime":1658030025,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1658030025","product_id":100100701,"comment_content":"老师，条件变量和信号量是相同的概念吗？","like_count":0,"discussions":[{"author":{"id":1216016,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8e/10/10092bb1.jpg","nickname":"Luke","note":"","ucode":"C34D4C44DBCE03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586720,"discussion_content":"不是一个概念，不过有相似的地方。内容比较多，具体的你可以搜索一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662458673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351377,"user_name":"dapaul","can_delete":false,"product_type":"c1","uid":1239335,"ip_address":"","ucode":"A53E0018F138A1","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/27/2aa8fb31.jpg","comment_is_top":false,"comment_ctime":1657763015,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1657763015","product_id":100100701,"comment_content":"老师，使用条件变量那段的例子不会死锁吗？main线程中加锁，然后阻塞等待,锁没释放。创建的线程等锁去释放条件变量，一直等不到锁，两边都在等","like_count":0,"discussions":[{"author":{"id":1239335,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/27/2aa8fb31.jpg","nickname":"dapaul","note":"","ucode":"A53E0018F138A1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579921,"discussion_content":"明白了，cnd_wait在挂起等待时会释放锁，等到条件变量满足时会重新上锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657775072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348599,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1655231737,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1655231737","product_id":100100701,"comment_content":"mutex有syscall吗？需要调用fetex系统调用吗？写一段cpp代码，在20个线程里每个县城++10万次，一个用mutex抢一个锁，一个用原子变量++，在mac的m1 max上运行，mutex要快得多","like_count":0},{"had_liked":false,"id":345180,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1652091469,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652091469","product_id":100100701,"comment_content":"开始还以为if只判断一次，while会一直判断，以为这个就是答案，但是看了大家的答案之后，发现没有那么简单，根据作者的回答，查了下虚假唤醒，本质还是多线程，每一个线程的cond状态是不一样，如果使用if那只有一个线程进入wait，那使用while，后面的线程也会进入wait。<br>lfence、sfence、mfence，内存屏障。保证cup缓存与内存一致。","like_count":0},{"had_liked":false,"id":343334,"user_name":"左星辰","can_delete":false,"product_type":"c1","uid":1432830,"ip_address":"","ucode":"A67D772F6AA584","user_header":"https://static001.geekbang.org/account/avatar/00/15/dc/fe/f11f25dd.jpg","comment_is_top":false,"comment_ctime":1650787354,"is_pvip":true,"replies":[{"id":"125802","content":"memory_order 的设置会被编译器编译为对应平台上的 fence 指令，比如 x86-64 下的 mfence、lfence 与 sfence 指令。可以看看这三个指令的具体用途，其他平台均是类似的。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1651722180,"ip_address":"","comment_id":343334,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650787354","product_id":100100701,"comment_content":"memory_order的设置会被编译器处理很好理解，但是是如何被处理器理解的呢？","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570284,"discussion_content":"memory_order 的设置会被编译器编译为对应平台上的 fence 指令，比如 x86-64 下的 mfence、lfence 与 sfence 指令。可以看看这三个指令的具体用途，其他平台均是类似的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651722180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}