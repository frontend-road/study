{"id":734381,"title":"04｜各司其职的Server：拆分响应模块与处理模块","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>在上一节课，我们基于最早的最小可用HttpServer服务器进行了改造。主要包括对HTTP协议返回内容中的状态行与返回头进行封装，以及引入动态资源和Servlet的概念，对Web端返回内容进行了扩充，已经有点Servlet容器的雏形了。</p><p>但我也提到，当前我们自定义的Servlet接口是不满足Java Servlet规范的。因此这节课我们首先会讨论如何符合Servlet规范，在Java的规则下实现MiniTomcat。</p><p>其次，在当前的HttpServer中，HttpServer类承担了接收客户端请求、调用Servlet、响应客户端等多种功能，功能太多了，因此我们要将其进行功能拆分，使各个部分各司其职。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/a2/54c07fb03981dca6c02f61a9279b4aa2.png?wh=2144x874\" alt=\"\"></p><p>好，就让我们一起来动手实现。</p><h2>项目结构</h2><p>这节课我们计划采用Maven结构对项目的包依赖进行管理，省去了导入jar包的环节。但有一点我们始终坚持，就是引入最少的依赖包，一切功能尽可能用最原生的JDK来实现，以便于我们从头做起更深地理解原理。在这节课中，项目结构变化如下：</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><p>对比上节课的目录，你会发现新增了HttpConnector.java和HttpProcessor.java，这正是用来拆分HttpServer两个类的，而我们自定义的Servlet就消失不见了。根据Servlet规范，取而代之的应该是javax.servlet.Servlet类。</p><p>接下来我们需要把javax.servlet.Servlet引入到代码之中，参考以下pom.xml：</p><pre><code class=\"language-xml\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;day3&lt;/groupId&gt;\n    &lt;artifactId&gt;day3&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n            &lt;version&gt;3.4&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;  \n</code></pre><h2>适配Servlet规范</h2><p>所谓符合规范，对编写程序来讲，就是遵守流程调用时序和使用规定的API接口及数据格式。对Servlet规范来讲，<strong>第一个要遵守的就是必须实现 Servlet 接口。</strong></p><p>在引入上文的servlet-api依赖后，我们可以把原来自己定义的Servlet接口删除，用javax.servlet.Servlet替换。我们先看看javax.servlet.Servlet的接口定义。</p><pre><code class=\"language-java\">package javax.servlet;\nimport java.io.IOException;\npublic interface Servlet {\n    void init(ServletConfig var1) throws ServletException;\n    ServletConfig getServletConfig();\n    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n    String getServletInfo();\n    void destroy();\n}\n</code></pre><p>在工程中替换后，原先的代码会立即报错，因为service方法传入的参数是ServletRequest和ServletResponse，而我们目前使用的是自定义的Request类和Response类。</p><p>因此，接下来分别让Request和Response实现ServletRequest与ServletResponse，实现如下：</p><pre><code class=\"language-java\">public class Request implements ServletRequest{\n    private InputStream input;\n    private String uri;\n    //以输入流作为Request的接收参数\n    public Request(InputStream input) {\n        this.input = input;\n    }\n    //简单的parser，假定从输入流中一次性获取全部字节，存放到2K缓存中\n    public void parse() {\n        StringBuffer request = new StringBuffer(2048);\n        int i;\n        byte[] buffer = new byte[2048];\n        try {\n            i = input.read(buffer);\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n            i = -1;\n        }\n        for (int j=0; j&lt;i; j++) {\n            request.append((char) buffer[j]);\n        }\n        //从输入的字符串中解析URI\n        uri = parseUri(request.toString());\n    }\n    //根据协议格式，以空格为界，截取中间的一段，即为URI\n    private String parseUri(String requestString) {\n        int index1, index2;\n        index1 = requestString.indexOf(' ');\n        if (index1 != -1) {\n            index2 = requestString.indexOf(' ', index1 + 1);\n            if (index2 &gt; index1)\n                return requestString.substring(index1 + 1, index2);\n        }\n        return null;\n    }\n    public String getUri() {\n        return uri;\n    }\n    @Override\n    public AsyncContext getAsyncContext() {\n        return null;\n    }\n    @Override\n    public Object getAttribute(String arg0) {\n        return null;\n    }\n    @Override\n    public Enumeration&lt;String&gt; getAttributeNames() {\n        return null;\n    }\n    @Override\n    public String getCharacterEncoding() {\n        return null;\n    }\n    @Override\n    public int getContentLength() {\n        return 0;\n    }\n    @Override\n    public long getContentLengthLong() {\n        return 0;\n    }\n    @Override\n    public String getContentType() {\n        return null;\n    }\n    @Override\n    public DispatcherType getDispatcherType() {\n        return null;\n    }\n    @Override\n    public ServletInputStream getInputStream() throws IOException {\n        return null;\n    }\n    @Override\n    public String getLocalAddr() {\n        return null;\n    }\n    @Override\n    public String getLocalName() {\n        return null;\n    }\n    @Override\n    public int getLocalPort() {\n        return 0;\n    }\n    @Override\n    public Locale getLocale() {\n        return null;\n    }\n    @Override\n    public Enumeration&lt;Locale&gt; getLocales() {\n        return null;\n    }\n    @Override\n    public String getParameter(String arg0) {\n        return null;\n    }\n    @Override\n    public Map&lt;String, String[]&gt; getParameterMap() {\n        return null;\n    }\n    @Override\n    public Enumeration&lt;String&gt; getParameterNames() {\n        return null;\n    }\n    @Override\n    public String[] getParameterValues(String arg0) {\n        return null;\n    }\n    @Override\n    public String getProtocol() {\n        return null;\n    }\n    @Override\n    public BufferedReader getReader() throws IOException {\n        return null;\n    }\n    @Override\n    public String getRealPath(String arg0) {\n        return null;\n    }\n    @Override\n    public String getRemoteAddr() {\n        return null;\n    }\n    @Override\n    public String getRemoteHost() {\n        return null;\n    }\n    @Override\n    public int getRemotePort() {\n        return 0;\n    }\n    @Override\n    public RequestDispatcher getRequestDispatcher(String arg0) {\n        return null;\n    }\n    @Override\n    public String getScheme() {\n        return null;\n    }\n    @Override\n    public String getServerName() {\n        return null;\n    }\n    @Override\n    public int getServerPort() {\n        return 0;\n    }\n    @Override\n    public ServletContext getServletContext() {\n        return null;\n    }\n    @Override\n    public boolean isAsyncStarted() {\n        return false;\n    }\n    @Override\n    public boolean isAsyncSupported() {\n        return false;\n    }\n    @Override\n    public boolean isSecure() {\n        return false;\n    }\n    @Override\n    public void removeAttribute(String arg0) {\n    }\n    @Override\n    public void setAttribute(String arg0, Object arg1) {\n    }\n    @Override\n    public void setCharacterEncoding(String arg0) throws UnsupportedEncodingException {\n    }\n    @Override\n    public AsyncContext startAsync() throws IllegalStateException {\n        return null;\n    }\n    @Override\n    public AsyncContext startAsync(ServletRequest arg0, ServletResponse arg1) throws IllegalStateException {\n        return null;\n    }\n}\n</code></pre><p>从代码中可以看出，我们只是简单地实现了对URI的解析，别的方法都是留空的。Java的API考虑得很全面，在Request里面新增了许多接口实现方法，但是就基本功能来讲，只要很少的方法就可以了，我们暂且先把这些现在不用的方法放在一边不实现。</p><p>接下来我们看看Response类的改造。</p><pre><code class=\"language-java\">package server;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Locale;\npublic class Response implements ServletResponse{\n    Request request;\n    OutputStream output;\n    PrintWriter writer;\n    String contentType = null;\n    long contentLength = -1;\n    String charset = null;\n    String characterEncoding = null;\n\n    //以输出流作为接收参数\n    public Response(OutputStream output) {\n        this.output = output;\n    }\n    public void setRequest(Request request) {\n        this.request = request;\n    }\n    public OutputStream getOutput() {\n        return this.output;\n    }\n    @Override\n    public void flushBuffer() throws IOException {\n    }\n    @Override\n    public int getBufferSize() {\n        return 0;\n    }\n    @Override\n    public String getCharacterEncoding() {\n        return this.characterEncoding;\n    }\n    @Override\n    public String getContentType() {\n        return null;\n    }\n    @Override\n    public Locale getLocale() {\n        return null;\n    }\n    @Override\n    public ServletOutputStream getOutputStream() throws IOException {\n        return null;\n    }\n    @Override\n    public PrintWriter getWriter() throws IOException {\n        writer = new PrintWriter(new OutputStreamWriter(output,getCharacterEncoding()), true);\n        return writer;\n    }\n    @Override\n    public boolean isCommitted() {\n        return false;\n    }\n    @Override\n    public void reset() {\n    }\n    @Override\n    public void resetBuffer() {\n    }\n    @Override\n    public void setBufferSize(int arg0) {\n    }\n    @Override\n    public void setCharacterEncoding(String arg0) {\n        this.characterEncoding = arg0;\n    }\n    @Override\n    public void setContentLength(int arg0) {\n    }\n    @Override\n    public void setContentLengthLong(long arg0) {\n    }\n    @Override\n    public void setContentType(String arg0) {\n    }\n    @Override\n    public void setLocale(Locale arg0) {\n    }\n}\n\n</code></pre><p>同样的，这个API也提供了一大堆方法。Response类里也因为实现接口，新增了许多接口实现方法，在目前这个阶段，我们只需要关注 <strong>getWriter()</strong> 这一个方法。</p><pre><code class=\"language-java\">public PrintWriter getWriter() throws IOException {\n&nbsp; &nbsp; writer = new PrintWriter(new OutputStreamWriter(output,getCharacterEncoding()), true);\n&nbsp; &nbsp; return writer;\n}\n</code></pre><p>看上述实现，在这之前我们用 <code>byte[]</code> 数组类型作为output的输出，这对业务程序员来说是不太便利的，因此我们现在支持往输出流里写入String字符串数据，于是就需要用到PrintWriter类。可以看到这里调用了 <code>getCharacterEncoding()</code> 方法，一般常用的是UTF-8，所以在调用 <code>getWriter()</code> 之前，一定要先调用 <code>setCharacterEncoding()</code> 设置字符集。</p><p>在PrintWriter构造函数中，我们目前设置了一个值为true。这个值的含义为autoflush，当为true时，println、printf等方法会自动刷新输出流的缓冲。</p><p>当提供了writer后，我们着手改造ServletProcessor，改造后如下所示：</p><pre><code class=\"language-java\">public class ServletProcessor {\n    //返回串的模板，实际返回时替换变量\n    private static String OKMessage = \"HTTP/1.1 ${StatusCode} ${StatusName}\\r\\n\"+\n            \"Content-Type: ${ContentType}\\r\\n\"+\n            \"Server: minit\\r\\n\"+\n            \"Date: ${ZonedDateTime}\\r\\n\"+\n            \"\\r\\n\";\n    public void process(Request request, Response response) {\n        String uri = request.getUri(); //获取URI\n        //按照简单规则确定servlet名，认为最后一个/符号后的就是servlet名\n        String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n        URLClassLoader loader = null;\n        PrintWriter writer = null;\n        try {\n            // create a URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            //从全局变量HttpServer.WEB_ROOT中设置类的目录\n            File classPath = new File(HttpServer.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        }\n        catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n        //获取PrintWriter\n        try {\n            response.setCharacterEncoding(\"UTF-8\");\n            writer = response.getWriter();\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        }\n        //加载servlet\n        Class&lt;?&gt; servletClass = null;\n        try {\n            servletClass = loader.loadClass(servletName);\n        }\n        catch (ClassNotFoundException e) {\n            System.out.println(e.toString());\n        }\n        \n        //生成返回头\n        String head = composeResponseHead();\n        writer.println(head);\n        Servlet servlet = null;\n        try {  \n            //调用servlet，由servlet写response体\n            servlet = (Servlet) servletClass.newInstance();\n            servlet.service(request, response);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n    }\n    //生成返回头，根据协议格式替换变量\n    private String composeResponseHead() {\n        Map&lt;String,Object&gt; valuesMap = new HashMap&lt;&gt;();\n        valuesMap.put(\"StatusCode\",\"200\");\n        valuesMap.put(\"StatusName\",\"OK\");\n        valuesMap.put(\"ContentType\",\"text/html;charset=UTF-8\");\n        valuesMap.put(\"ZonedDateTime\", DateTimeFormatter.ISO_ZONED_DATE_TIME.format(ZonedDateTime.now()));\n        StrSubstitutor sub = new StrSubstitutor(valuesMap);\n        String responseHead = sub.replace(OKMessage);\n        return responseHead;\n    }\n}\n</code></pre><p>主要变化有 3 处。</p><ol>\n<li>使用PrintWriter接口替换了原来的OutputStream。</li>\n<li>在加载Servlet之前设置characterEncoding为 UTF-8，再获取Writer。</li>\n<li>Writer中设置了autoflush，因此不再需要像原来一样手动设置output.flush。</li>\n</ol><p>最后则是调整用来测试的HelloServlet，实现Servlet接口，在输出之前设置characterEncoding。</p><pre><code class=\"language-java\">public class HelloServlet implements Servlet{\n    @Override\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        res.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Hello World 你好\" + \"&lt;/h1&gt;\\n\";\n        res.getWriter().println(doc);\n    }\n    @Override\n    public void destroy() {\n    }\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n    @Override\n    public void init(ServletConfig arg0) throws ServletException {\n    }\n}\n</code></pre><p>通过测试我们可以看到，中文正确地输出了。</p><h2>HttpServer职能拆解</h2><p>在服务器符合Servlet规范之后，我们再转向服务器本身，也就是HttpServer这个核心实现类。</p><p>目前我们已拥有基本的Servlet Container功能，具备接收客户端请求，调用Servlet以及响应客户端请求的能力。为了达到各司其职的目标，我们可以把它拆分成两个大块：Connecctor和Processor，分别负责处理接收、响应客户端请求以及调用Servlet。</p><p>实现HttpProcessor.java如下：</p><pre><code class=\"language-java\">public class HttpProcessor {\n    public HttpProcessor(){\n    }\n    public void process(Socket socket) {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = socket.getInputStream();\n            output = socket.getOutputStream();\n            // create Request object and parse\n            Request request = new Request(input);\n            request.parse();\n            // create Response object\n            Response response = new Response(output);\n            response.setRequest(request);\n\n            // check if this is a request for a servlet or a static resource\n            // a request for a servlet begins with \"/servlet/\"\n            if (request.getUri().startsWith(\"/servlet/\")) {\n                ServletProcessor processor = new ServletProcessor();\n                processor.process(request, response);\n            }\n            else {\n                StaticResourceProcessor processor = new StaticResourceProcessor();\n                processor.process(request, response);\n            }\n            // Close the socket\n            //socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>在HttpProcessor中，process方法具体实现和原本并没有差异，只是新增Socket参数传入。现在有了这个专门的机构来分工，调用Servlet或者是静态资源。</p><p>HttpConnector实现如下：</p><pre><code class=\"language-java\">public class HttpConnector implements Runnable {\n    public void run() {\n        ServerSocket serverSocket = null;\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        while (true) {\n            Socket socket = null;\n            try {\n                socket = serverSocket.accept();\n                HttpProcessor processor = new HttpProcessor();\n                processor.process(socket);\n                // Close the socket\n                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public void start() {\n        Thread thread = new Thread(this);\n        thread.start();\n    }\n}\n</code></pre><p>需要注意的是HttpConnector，它实现了Runnable接口，把它看作一个线程，支持并发处理，提高整个服务器的吞吐量。而Socket的关闭，最后也统一交给Connector处理。</p><p>这样整个服务器基本的工作流程就是：由Connector接收连接，来了一个Socket之后，就转手交给Processor进行处理，处理完之后再返回给Connector来关闭。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/6d/15e4d0e702f7da74fb8c185c8b31e26d.png?wh=2200x448\" alt=\"\"></p><p>最后调整HttpServer类，当前这个类的实现非常简单，只用于启动Connector这个线程，来等待客户端的请求连接。</p><pre><code class=\"language-java\">public class HttpServer {\n    public static final String WEB_ROOT =\n            System.getProperty(\"user.dir\") + File.separator + \"webroot\";\n    public static void main(String[] args) {\n        HttpConnector connector = new HttpConnector();\n        connector.start();\n    }\n}\n</code></pre><h2>测试</h2><p>在 <code>src/test/java/test</code> 目录下，修改HelloServlet。</p><pre><code class=\"language-java\">package test;\nimport java.io.IOException;\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\npublic class HelloServlet implements Servlet{\n    @Override\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        res.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Hello World 你好\" + \"&lt;/h1&gt;\\n\";\n        res.getWriter().println(doc);\n    }\n    @Override\n    public void destroy() {\n    }\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n    @Override\n    public void init(ServletConfig arg0) throws ServletException {\n    }\n}\n</code></pre><p>实现的Servlet是javax.servlet.Servlet，新增characterEncoding设置，最后用Writer输出自定义的HTML文本。</p><p>在准备工作进行完毕之后，我们运行HttpServer服务器，键入 <a href=\"http://localhost:8080/hello.txt,\">http://localhost:8080/hello.txt</a> 后，可以发现hello.txt里的所有文本内容，都作为返回体展示在浏览器页面上了。再输入 <a href=\"http://localhost:8080/servlet/test.HelloServlet\">http://localhost:8080/servlet/test.HelloServlet</a> 后，就可以看到浏览器显示：Hello World 你好。这也是我们在HelloServlet里定义的返回资源内容。</p><p>这说明整体功能改造成功。</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/55/58/5521ab5327b8b25419138a9fbcd78358.jpg?wh=2564x1626\" alt=\"\"></p><p>这节课我们按照Servlet规范，对Request、Response类以及测试用的HelloServlet进行了改造，主要的内容就是支持规范，所以从代码层面看增加了许多方法，但是目前我们都没有用到，实现的也仅仅是核心部分。</p><p>然后我们进一步将HttpServer功能进行拆分解耦，分成Connector和Processor，Connector负责实现接收网络连接和返回，Processor负责处理逻辑，即调用Servlet并返回。各个部分各司其职，并且考虑实现Runnable接口支持独立线程并发调用，为未来提高整体性能做准备。</p><p>本节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter04\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter04</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：我们现在是在一个无限循环中每接收一个Socket连接就临时创建一个Processor来处理这个Socket，处理完毕之后再开始下一个循环，这个Server是串行工作模式，怎么提高这个Server的并发度？</p><p>欢迎你把你思考后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":386145,"user_name":"？新！","can_delete":false,"product_type":"c1","uid":1537709,"ip_address":"四川","ucode":"56E547E279A10A","user_header":"https://static001.geekbang.org/account/avatar/00/17/76/ad/f192d95e.jpg","comment_is_top":false,"comment_ctime":1704188790,"is_pvip":false,"replies":[{"id":140780,"content":"有道理。你看一下catalina开头的日志文件。\n再启用一下AccessLogValve看看。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1704328764,"ip_address":"湖南","comment_id":386145,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"老师我有个关于tomcat连接层的问题求教？\n    场景：外部nginx日志记录调用了A服务并且超时，但是A服务本地日志localhost_access_log，没有记录，了解后怀疑是连接层，会等待队列就超时了，所以没有到容器层，没有被localhost_access_log记录？\n    问题：\n        1  我的怀疑是否可能？\n        2 有办法验证吗？比如tomcat等待队列超时或者accept超时，能记录日志\n      ","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635026,"discussion_content":"有道理。你看一下catalina开头的日志文件。\n再启用一下AccessLogValve看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704328764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1537709,"avatar":"https://static001.geekbang.org/account/avatar/00/17/76/ad/f192d95e.jpg","nickname":"？新！","note":"","ucode":"56E547E279A10A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":635044,"discussion_content":"首先感谢老师的解答，我描述的不太准确，我重新描述一下\n   问题和猜测：我想验证请求是在maxConnections的LimitLatch等待中超时的，还是在work线程池队列中等待超时的？\n    1 背景一样，首先AccessLogValve已经开启，对应的access_log中几乎没有超时的请求记录。该Valve配置是在Host下，如果连接没有被worker线程消费，那么AccessLogValve器可能就记录不到【个人了解】\n    2 【个人了解的】catalina 是Engine层日志，也就是说如果按照我的猜测，应该也不会有记录吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704339082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":635026,"ip_address":"四川","group_id":0},"score":635044,"extra":""}]}]},{"had_liked":false,"id":385466,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1702692723,"is_pvip":false,"replies":[{"id":140481,"content":"Q1, 你自己看URL api帮助文档\nQ2, @Override是一个编译时注解，加上是一个好习惯，没有也不会出运行时错误\nQ3，这个问题好。有些浏览器将请求分成简单请求和非简单请求，对于非简单请求，浏览器会先发出一个OPTIONS预检请求，这是为了安全性的原因。MiniTomcat没有考虑这些实际工作中的复杂性，直接忽略了。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1702778673,"ip_address":"北京","comment_id":385466,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：streamHandler不需要赋值吗？\nServletProcessor.java的process方法中：\nURLStreamHandler streamHandler = null;\nurls[0] = new URL(null, repository, streamHandler);\n代码声明了变量“streamHandler”，\n但是没有赋值，然后直接用来创建URL的对象。\n请问：为什么没有给“streamHandler”赋值？\n\nQ2：HttpConnector的run方法为什么没有注解？\n类定义：HttpConnector implements Runnable，\n其run方法上面没有注解，Idea2019提示：\nMissing &#39;@Override&#39; annotation on &#39;run()&#39; 。\n但程序能运行。请问老师的代码中，run方法为什么没有注解？\n\nQ3：第03课代码，一次请求，socket = serverSocket.accept();为什么运行两次？\nHttpServer.java文件中,while(true)代码块,在serverSocket.accept();这里阻塞。浏览器中输入请求，创建Request，成功地走完了整个流程。走完整个流程后按道理应该还在serverSocket.accept();这里阻塞。但竟然再次创建Request，不过在Request类的parse函数中，在i = input.read(buffer);这个地方不再往下面执行。我在input.read前后都加了打印语句，前面的打印语句执行了，后面的没有执行，神奇啊，为什么啊？\n简单地说，就是：浏览器发送一个请求，HttpServer收到了两个request,第一个正常处理，第二个不能正常执行。（我用的是Chrome浏览器，也许和浏览器有关？）","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633914,"discussion_content":"Q1, 你自己看URL api帮助文档\nQ2, @Override是一个编译时注解，加上是一个好习惯，没有也不会出运行时错误\nQ3，这个问题好。有些浏览器将请求分成简单请求和非简单请求，对于非简单请求，浏览器会先发出一个OPTIONS预检请求，这是为了安全性的原因。MiniTomcat没有考虑这些实际工作中的复杂性，直接忽略了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702778673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607786,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/6a/fe18b26d.jpg","nickname":"名字好腻害","note":"","ucode":"2D157076F1D5B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642961,"discussion_content":"Q1:我也有这个疑问,查了下可能是这样\nSpecifying a handler of null indicates that the URL should use a default stream handler for the protocol.\nProtocol handlers for the following protocols are guaranteed to exist on the search path :-http, https, file, and jar\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713947284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331059,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4f/73/d0fffc16.jpg","nickname":"seeker of truth","note":"","ucode":"76ABF9D985BFF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636044,"discussion_content":"针对Q1，我猜他大约是想问为什么在代码里引入了URLStreamHandler这个变量，但全程都是null，干嘛不直接用null来做函数调用。我乱猜是为了使代码更靠近文档，也方便将来更新代码，使用真的handler吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705510325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1607786,"avatar":"https://static001.geekbang.org/account/avatar/00/18/88/6a/fe18b26d.jpg","nickname":"名字好腻害","note":"","ucode":"2D157076F1D5B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1331059,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4f/73/d0fffc16.jpg","nickname":"seeker of truth","note":"","ucode":"76ABF9D985BFF1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642956,"discussion_content":"直接用null编译不了,URL构造方法还有一个三个String参数的构造方法,如果streamHandler也用null,编译器不知道用哪个构造方法,过不了编译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713944874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":636044,"ip_address":"湖北","group_id":0},"score":642956,"extra":""}]},{"author":{"id":1331059,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4f/73/d0fffc16.jpg","nickname":"seeker of truth","note":"","ucode":"76ABF9D985BFF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636043,"discussion_content":"针对Q1，我猜他大约是想问为什么在代码里引入了URLStreamHandler这个变量，但全程都是null，干嘛不直接用null来做函数调用。我乱猜是为了使代码更靠近文档，也方便将来更新代码，使用真的handler吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705510324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385405,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1702597090,"is_pvip":false,"replies":[{"id":140478,"content":"提高并发度有一系列技术。能第一反应出来的就是多线程，将processor设计成多个线程，放到一个池子里面，服务器接受前端多个请求后交给后面线程池子里面的多个processor线程来并发处理。这解决了一部分问题，但是对一个processor来说，它还是串行工作的，当它涉及到数据库访问网络访问文件操作的时候，可以进一步再分线程。不过程序模式需要调整成使用Future或者CompletableFuture,完全的响应式编程结构复杂。JDK21提出的virtual thread很好地解决了这个问题。实际工作中，要根据场景要求进行选择。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1702776475,"ip_address":"北京","comment_id":385405,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"😄池子+队列， 学艺不精具体细节答不上来， 请老师指点。","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633911,"discussion_content":"提高并发度有一系列技术。能第一反应出来的就是多线程，将processor设计成多个线程，放到一个池子里面，服务器接受前端多个请求后交给后面线程池子里面的多个processor线程来并发处理。这解决了一部分问题，但是对一个processor来说，它还是串行工作的，当它涉及到数据库访问网络访问文件操作的时候，可以进一步再分线程。不过程序模式需要调整成使用Future或者CompletableFuture,完全的响应式编程结构复杂。JDK21提出的virtual thread很好地解决了这个问题。实际工作中，要根据场景要求进行选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702776475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":633976,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702864687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":633911,"ip_address":"广东","group_id":0},"score":633976,"extra":""}]}]},{"had_liked":false,"id":385816,"user_name":"stars","can_delete":false,"product_type":"c1","uid":1055100,"ip_address":"陕西","ucode":"8A75D9E1909729","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/7c/25abe455.jpg","comment_is_top":false,"comment_ctime":1703433833,"is_pvip":false,"replies":[{"id":140640,"content":"没有简单的答案。对Tomcat这种场景，前面的线程用于接收客户端网络连接，后面的线程用于业务处理（合理的假定会消耗数据库），这种场景就是会提高吞吐量的。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1703655420,"ip_address":"湖南","comment_id":385816,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"只是在主线程启动了一个子线程，这样就提高吞吐率了吗？请教老师。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634555,"discussion_content":"没有简单的答案。对Tomcat这种场景，前面的线程用于接收客户端网络连接，后面的线程用于业务处理（合理的假定会消耗数据库），这种场景就是会提高吞吐量的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703655420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}