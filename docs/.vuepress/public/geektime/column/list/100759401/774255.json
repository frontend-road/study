{"id":774255,"title":"12｜自定义指标：如何通过自定义指标，监控前端页面更多状态","content":"<p>你好，我是三桥。</p><p>这节课，我们继续学习前端全链路的另一种链路日志，自定义日志。</p><p>通常来说，我们会在业务代码里主动输出一些日志，通过日志追踪可能发生的异常或流程以外的地方。</p><p>如果说，请求类日志、资源类日志、脚本异常类日志是全链路中最基础底层的日志，那么自定义日志就是更接近业务的链路日志。它的实现原理类似于封装console对象，也是为业务提供了一个链路日志的函数。</p><h2>为什么要做全链路的自定义埋点</h2><p>很多前端同学都喜欢在业务逻辑代码中使用 <code>console.log</code> 来打印日志信息，从而调试和定位问题，因为这种日志能够覆盖前端业务逻辑里很多特殊的场景。</p><p>这么做有什么问题吗？我们先来看一个很有代表性的例子。</p><pre><code class=\"language-typescript\">try {\n&nbsp; const jsonstr = '{\"name\": \"前端全链路优化实战\", \"course\": 30, \"source\": \"geekbang\"}'\n&nbsp; var data = JSON.parse(jsonstr);\n&nbsp; console.log(data.name);\n&nbsp; console.log(data.course);\n} catch (err) {\n&nbsp; console.error(err);\n}\n</code></pre><p>上面的代码使用了 <code>JSON.parse</code> 函数，将一个json字符串解析为JSON对象。要知道，例子中展示的字符串是一个标准json字符串，对于 <code>parse</code> 函数而言，它是能正常解析出来的。</p><!-- [[[read_end]]] --><p>我们知道，任何一个函数的运行必然涉及输入和输出两个过程，而且数据的输入往往是不可靠的。<code>JSON.parse</code> 函数同理，如果输入的字符串不符合JSON对象的格式要求，代码就会抛出一个 <code>SyntaxError</code> 异常。</p><p>其实，在真实的前端项目里，像 <code>JSON.parse</code> 这样的函数逻辑非常多。通常情况下，数据输入来自两个方面，一个是后端接口提供的数据，另一个就是来自用户输入，例如表单数据。如果我们不校验这样输入错误的逻辑，只要JavaScript代码报错，就没法往下执行，程序也会直接崩溃。这是我们不愿意看到的情况。</p><p>我们再回来分析上面的代码，虽然代码中使用了try-catch来捕获代码的异常情况，但我们并没有在catch中给出发生异常时的处理机制，只是偶尔会使用 <code>console.log</code> 输出error信息。</p><p>虽然进入catch事件的概率非常低，但只要是进入了异常，就肯定是我们没有预想到的情况。对于这些特殊情况，我们可以在全链路里面通过日志记录下来，帮助我们分析用户的真实情况，改善产品的用户体验。</p><p>总之，<strong>要提前发现潜在的业务问题</strong>，<strong>改善产品的用户体验，自定义链路日志是前端全链路必不可少的日志类型。</strong></p><p>接下来，我们就来实现自定义链路日志的基本函数。</p><h2>实现通用自定义链路日志</h2><p>在前面的课程里，我们已经定义了全链路的基本数据结构。其中自定义链路日志的数据类型是 <code>TraceDataLog</code> 。这次，我们就以这种数据结构类型实现通用自定义日志函数。</p><h3>通用底层日志函数</h3><p>我们首先创建一个名为 <code>log</code> 的函数，参数为 <code>TraceDataLog</code> 数据类型。这么做的目的是根据业务的实际情况构造 <code>TraceDataLog</code> 数据，例如 <code>level</code> 、 <code>type</code> 、 <code>message</code> 、 <code>name</code> 等字段值。在 <code>log</code> 函数内部，我们只需关注存储用户行为和发送日志两项任务就好。</p><p>具体实现的代码参考如下。</p><pre><code class=\"language-typescript\">// src/baseTrace.ts\n\nexport class BaseTrace implements BaseTraceInterface {\n\tpublic log(log: TraceDataLog) {\n\t&nbsp; this.saveBreadcrumb({\n\t&nbsp; &nbsp; name: 'customer-log',\n\t&nbsp; &nbsp; level: log.level,\n\t&nbsp; &nbsp; type: dataTypes2BreadcrumbsType(log.type),\n\t&nbsp; &nbsp; category: dataCategory2BreadcrumbsCategory(log.type),\n\t&nbsp; &nbsp; message: log.message,\n\t&nbsp; &nbsp; time: getTimestamp(),\n\t&nbsp; })\n\t&nbsp; this.send(log)\n\t}\n}\n\n</code></pre><p>我们来看下 <code>log</code> 函数代码，在存储用户行为的数据中，type和category两个字段都需要通过额外的函数转换成合适的值，确保符合数据的一致性。</p><p>另外， <code>log</code> 函数的入参参数是一个完整的日志数据对象。这样的入参存在一个问题，就是调用log函数前，还要构造一个完整的日志数据对象，然后你会发现，对于业务来说，使用 <code>log</code> 函数这件事情变得更复杂了。</p><p>因此，我们以 <code>log</code> 函数为基础，实现3个预设不同级别的自定义日志函数，它们分别是普通日志info，告警日志warning，错误日志error。有了这3个级别的自定义日志，业务逻辑就能以最小代码量接入链路日志。</p><h3>普通日志函数</h3><p>普通日志函数的功能是记录业务逻辑中普通级别的日志信息，可以用来调试业务日志、自定义catch日志。</p><p>首先我们定义一个名为 <code>info</code> 的函数，它提供了两个入参参数：message和tag。<code>message</code>参数是用于记录日志信息的，而 <code>tag</code> 参数是为了区分不同的日志而提供的打标签的功能，当然这个参数是非必须的，可以自由选择。</p><p>具体实现的代码参考如下。</p><pre><code class=\"language-typescript\">// src/baseTrace.ts\n\nexport class BaseTrace implements BaseTraceInterface {\n&nbsp; public info(message: string, tag?: string) {\n&nbsp; &nbsp; this.log({\n&nbsp; &nbsp; &nbsp; name: 'customer-log',\n&nbsp; &nbsp; &nbsp; type: TraceDataTypes.LOG,\n&nbsp; &nbsp; &nbsp; level: TraceDataSeverity.Info,\n&nbsp; &nbsp; &nbsp; message,\n&nbsp; &nbsp; &nbsp; time: getTimestamp(),\n&nbsp; &nbsp; &nbsp; dataId: hashCode(`${message}|${tag || ''}`),\n&nbsp; &nbsp; &nbsp; tag,\n&nbsp; &nbsp; })\n&nbsp; }\n}\n</code></pre><h3>告警日志函数</h3><p>告警日志会记录业务逻辑里需要重点关注的地方。主要预警数据校验失败这类场景。如果校验失败，我们就可以考虑上报告警类型日志了。</p><p><code>warn</code> 日志函数跟 <code>info</code> 函数的实现原理是相同的，唯一的区别是level属性使用的是 <code>warning</code> 值。</p><p>具体实现的代码参考如下。</p><pre><code class=\"language-typescript\">// src/baseTrace.ts\n\nexport class BaseTrace implements BaseTraceInterface {\n\n\tpublic warn(message: string, tag?: string) {\n&nbsp; &nbsp; this.log({\n&nbsp; &nbsp; &nbsp; name: 'customer-log',\n&nbsp; &nbsp; &nbsp; type: TraceDataTypes.LOG,\n&nbsp; &nbsp; &nbsp; level: TraceDataSeverity.Warning,\n&nbsp; &nbsp; &nbsp; message,\n&nbsp; &nbsp; &nbsp; time: getTimestamp(),\n&nbsp; &nbsp; &nbsp; dataId: hashCode(`${message}|${tag || ''}`),\n&nbsp; &nbsp; &nbsp; tag,\n&nbsp; &nbsp; })\n&nbsp; }\n}\n</code></pre><h3>错误日志函数</h3><p>错误日志函数的主要作用是捕获并记录业务逻辑中出现的代码异常。它能够详细记录异常信息，包括但不限于JSON解析错误，以及通过try-catch语句捕获的异常情况。通常来说，在代码中上报这种类型的日志，肯定是业务出现了一些问题。所以反过来看，每当出现线上问题的时候，自定义的错误日志必定是我们重点关注的地方。</p><p>错误日志函数与 <code>info</code> 和 <code>warn</code> 函数的实现基本上一样，唯一区别是level属性直接使用 <code>error</code> 值。具体实现的代码参考如下。</p><pre><code class=\"language-typescript\">// src/baseTrace.ts\n\nexport class BaseTrace implements BaseTraceInterface {\n&nbsp;&nbsp;\n&nbsp; public error(message: string, tag?: string) {\n&nbsp; &nbsp; this.log({\n&nbsp; &nbsp; &nbsp; name: 'customer-error',\n&nbsp; &nbsp; &nbsp; type: TraceDataTypes.LOG,\n&nbsp; &nbsp; &nbsp; level: TraceDataSeverity.Error,\n&nbsp; &nbsp; &nbsp; message,\n&nbsp; &nbsp; &nbsp; time: getTimestamp(),\n&nbsp; &nbsp; &nbsp; dataId: hashCode(`${message}|${tag || ''}`),\n&nbsp; &nbsp; &nbsp; tag,\n&nbsp; &nbsp; })\n&nbsp; }\n}\n</code></pre><h3>dataId属性的特点</h3><p>你可能已经注意到，这三个日志函数都使用了相同的算法生成 <code>dataId</code> 属性值，也就是 <code>message</code> 和 <code>tag</code> 两个参数值拼接组合，然后使用 <code>hashCode</code> 函数转换成新字符串。</p><p>这个算法有一个特点，就是会出现重复值。这样设计的原因是什么呢？</p><p>这是因为，在前端项目中，如果某一段业务逻辑里频繁出现同样的错误，例如100个用户中有10个都抛出了同样的异常，那就至少会出现10个相同dataId的日志。这说明这段代码逻辑存在问题，这时就需要投入时间排查原因了。</p><h2>如何用好自定义链路埋点？</h2><p>好了。学完了如何定义通用的自定义日志函数后，那怎么用呢？在什么场景下调用呢？</p><p>很多前端同学对自己实现的代码和逻辑都过于自信，很少考虑到出现逻辑异常时的流程和处理方案。最多就是为了调试问题而增加 <code>console.log</code> 日志。这时候你会发现，前端异常问题抛出来了，但日志确在用户手上，没法提供给前端同学，特别是使用 <code>JSON.parse</code> 转换格式的问题。</p><h3>JSON转换格式问题</h3><p>前面有一段示例代码，我是用try-catch捕获的 <code>JSON.parse</code> 函数解析异常。相信很多前端同学都会有意识地去增加捕获的日志输出，但在真实项目中，这部分还是会不知不觉地被忽略。</p><p>例如下面的代码。</p><pre><code class=\"language-typescript\">data.forEach((item: string) =&gt; {\n\tarr.push(JSON.parse(item));\n});\n</code></pre><p>你一定能看得懂上面的代码，而且大概率也写过类似的代码，直接在 <code>push</code> 函数的参数上调用 <code>JSON.parse</code> 函数，不做任何的try-catch容错处理，因为这样写真的很方便很简洁。这样的写法会导致什么问题？</p><p>答案是，当 <code>JSON.parse</code> 无法解析数据时，会直接抛出 <code>SyntaxError</code> ，导致 <code>forEach</code> 逻辑无法正常运行。</p><p>所以，使用JSON.parse函数时，我们不能因为方便就忽略容错处理。正确的做法是单独用一行代码去解析JSON数据，并在catch中增加上报错误日志。</p><p>看下示例代码。</p><pre><code class=\"language-typescript\">// test.js\n// 第二条字符串是不符合JSON格式的字符串\nconst data = [\n&nbsp; '{\"name\": \"前端全链路优化实战\", \"course\": 30, \"source\": \"geekbang\"}',\n&nbsp; '{\"name\": \"前端全链路优化实战\", \"course\": 30, \"source\"}',\n&nbsp; '{\"name\": \"前端全链路优化实战\", \"course\": 30, \"source\": \"geekbang\"}',\n]\nconst arr = []\n&nbsp;&nbsp;\ndata.forEach(item =&gt; {\n&nbsp; try {\n&nbsp; &nbsp; const itemObj&nbsp; = JSON.parse(item)\n&nbsp; &nbsp; arr.push(itemObj)\n&nbsp; } catch (err) {\n\tconsole.error(err)\n    // 通过自定义链路日志函数上报到服务器\n&nbsp; &nbsp; traceSDK.error(err.message, 'forEach|JSON.parse')\n&nbsp; }\n});\n\nconsole.log(arr)\n\n// SyntaxError: Expected ':' after property name in JSON at position 44 (line 1 column 45)\n//&nbsp; &nbsp; at JSON.parse (&lt;anonymous&gt;)\n//&nbsp; &nbsp; at auth:16:29\n//&nbsp; &nbsp; at Array.forEach (&lt;anonymous&gt;)\n//&nbsp; &nbsp; at test:14:8\n//test:22 (2) [{…}, {…}]\n</code></pre><h3>取值的问题</h3><p>除了 <code>JSON.parse</code> 这种JavaScript内置函数外，前端同学在做业务时还会封装大量函数来提高业务逻辑的复用。一个最典型的例子是前端同学使用 <code>localStorage</code> 特性做增删改的逻辑。</p><p>我们先来看下最常见的使用 <code>localStorage</code> 的例子。</p><pre><code class=\"language-typescript\">function recommendCourseList() {\n&nbsp; const result = localStorage.getItem('userInfo')\n&nbsp; try {\n&nbsp; &nbsp; const resObj = JSON.parse(result)\n&nbsp; &nbsp; const list = getRecommendCourseList(resObj.userId);\n&nbsp; &nbsp; return list\n&nbsp; } catch (err) {\n&nbsp; &nbsp; console.error(err)\n&nbsp; &nbsp; return []\n&nbsp; }\n&nbsp; return []&nbsp;\n}\n</code></pre><p>在这段代码里，有三个关键代码逻辑，一个是使用 <code>localstorage.getItem</code> 读取 <code>userInfo</code> 数据，另一个是使用 <code>JSON.parse</code> 解析JSON对象 <code>resObj</code> ，最后是把<code>resObj</code>对象的 <code>userId</code> 传给 <code>getRecommendCourseList</code> 函数获取推荐课程列表。</p><p>在这里， <code>JSON.parse</code> 的问题和 <code>getRecommendCourseList</code> 的实现逻辑这两个地方就不再探讨。我们来重点看看 <code>localStorage.getItem</code> 带来了什么问题？</p><p>我们先理解下 <code>localStorage.getItem</code> 的作用， <code>localStorage</code> 是浏览器提供的一种在客户端存储数据的机制，它可以在客户端存储或读取数据，在一些简单的用户配置或本地缓存数据等场景都会用到。而getItem就是读取数据的方法。</p><p>既然数据是存储在浏览器本地，也就是说还得需要程序主动地存储才会有数据。那我们假设，在读取数据之前，就没有被存储起来，后续的使用数据逻辑应该怎么兼容呢？</p><p>我们先来分析下场景。</p><p>从上面的代码逻辑来看，<code>getItem</code> 读取数据存在不可预估的输出结果，是因为我们没有做容错处理吗？那后续的逻辑是我们预想要的结果吗？</p><p>换个角度，从业务逻辑来看，为什么getItem获取不到数据呢？是因为我们的逻辑不够严谨吗？还是说我们允许它存在空值呢？</p><p>在我看来，我们无法用任何数据或证据来证明我们猜测的问题。唯一能做的就是在真实的环境和用户行为下捕获问题的证据，才能知道如何解决。不管怎样，使用<code>localStorage.getItem</code> 方法获取数据都是不可信任的，极有可能返回undefined。如果返回值是undefined，那运行JSON.parse就是不可预期的结果了。</p><p>现在，我们尝试来优化上面的代码，让代码出现异常时，依旧能捕获到现场的信息。</p><p>第一步就是把 <code>localStorage.getItem</code> 也一并放到try-catch里。</p><pre><code class=\"language-typescript\">function recommendCourseList() {\n&nbsp; try {\n\tconst result = localStorage.getItem('userInfo')\n&nbsp; &nbsp; const resObj = JSON.parse(result)\n&nbsp; &nbsp; const list = getRecommendCourseList(resObj.userId);\n&nbsp; &nbsp; return list\n&nbsp; } catch (err) {\n&nbsp; &nbsp; console.error(err)\n&nbsp; &nbsp; // 通过自定义链路日志函数上报到服务器\n&nbsp; &nbsp; traceSDK.error(err.message, 'recommendCourseList')\n&nbsp; &nbsp; return []\n&nbsp; }\n&nbsp; return []&nbsp;\n}\n</code></pre><p>好了，我们稍微移一下位置后，就暂时解决了前面的问题。不过，<code>localStorage</code> 逻辑和 <code>JSON.parse</code> 逻辑都放在同一个try-catch里，在真实的环境下，它们俩都有可能因为输入的不确定性导致异常报错。这样我们就很难判断究竟是哪一行代码报错的，是哪个位置的输入导致的问题。</p><p>所以，第二步优化是封装 <code>localStorage.getItem</code>，让该函数能在更多场景下接入全链路的监视范围。</p><pre><code class=\"language-typescript\">function getItem(key: string) {\n&nbsp; try {\n&nbsp; &nbsp; const result = localStorage.getItem(key)\n&nbsp; &nbsp; if (result === undefined) {\n&nbsp; &nbsp; &nbsp; console.warn(`GET KEY[${key}] Not Found.`)\n&nbsp; &nbsp; &nbsp; return null\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return result\n&nbsp; } catch (err) {\n&nbsp; &nbsp; console.warn(`GET KEY[${key}] error. message: ${err.message}`)\n\t&nbsp; traceSDK.warn(`GET KEY[${key}] error. message: ${err.message}`)\n&nbsp; &nbsp; return null\n&nbsp; }\n}\n</code></pre><p>第三步优化，就是处理 <code>recommendCourseList</code> 函数内数据的容错处理，让我们能够实时了解真实异常情况。</p><pre><code class=\"language-typescript\">function recommendCourseList() {\n&nbsp; const result = getItem('userInfo')\n&nbsp; if (result !== null) {\n&nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; const resObj = JSON.parse(result)\n&nbsp; &nbsp; &nbsp; const list = getRecommendCourseList(resObj.userId);\n&nbsp; &nbsp; &nbsp; return list\n&nbsp; &nbsp; } catch (err) {\n&nbsp; &nbsp; &nbsp; console.error(err)\n&nbsp; &nbsp; &nbsp; // 通过自定义链路日志函数上报到服务器\n&nbsp; &nbsp; &nbsp; traceSDK.error(err.message, 'recommendCourseList|JSON.parse')\n&nbsp; &nbsp; &nbsp; return []\n&nbsp; &nbsp; }\n&nbsp; }\n&nbsp; console.warn('get[userInfo] value is null. ')\n&nbsp; traceSDK.warn('get[userInfo] value is null. ', 'recommendCourseList|getUserInfo')\n&nbsp; return []&nbsp;\n}\n</code></pre><p>经过优化之后， <code>recommendCourseList</code> 函数的逻辑已经在我们的全链路监控范围内。</p><p>因为全链路日志都能覆盖到每个逻辑场景，例如输入输出的异常，有if就必须有else，内置函数的错误抛出等等。</p><h3>Promise的reject函数</h3><p>此外，还存在一种特殊的情况，就是异步函数的应用场景。通常，我们会用Promise对象来解决异步的问题。Promise对象是JavaScript中处理异步操作的一种机制，它可以帮助我们更好地处理异步逻辑。</p><p>我们都知道，在处理异步业务逻辑的过程中，Promise要面对许多复杂的情况。有些情况必须使用 <code>reject</code> 抛出失败、异常等状态，才能够让业务根据实际情况作出逻辑的调整。</p><p>既然这种异常、失败存在概率性问题，我们就需要监控这些概率问题，提早发现并修复。怎么做呢？最简单的方法就是增加链路日志，例如下面代码。</p><pre><code class=\"language-typescript\">const example = new Promise(function(resolve, reject) {\n&nbsp; try {\n&nbsp; &nbsp; throw new Error('test');\n&nbsp; } catch(e) {\n&nbsp; &nbsp; reject(e);\n&nbsp; }\n})\n\nexample.catch(function(error) {\n&nbsp; console.log(error);\n&nbsp; traceSDK.warn(err.message, 'Promise|example|catch')\n});\n</code></pre><p>从上述代码可以看到，其实现在的逻辑只针对了当前的Promise对象，但并非每个业务Promise逻辑都会定义catch事件。那下一个问题就是，怎么才能捕获所有未定义catch事件的异步问题呢？</p><p>我们可以通过监听unhandlerrejection事件来达到捕获这些异步问题，具体实现的代码如下。</p><pre><code class=\"language-typescript\">window.addEventListener('unhandledrejection', function(event) {\n&nbsp; console.warn('Unhandled Promise Rejection:', event.reason);\n  traceSDK.warn(event.reason, 'Promise|example|catch')\n});\n</code></pre><h3>更多业务场景</h3><p>事实上，一个大型的前端应用，不止上面举例的三种代码逻辑场景。</p><p>首先是<strong>核心业务流程</strong>。“核心”的定义是只要这段代码报错或者是函数运行报错都会导致JavaScript脚本执行中断，功能无法继续使用。这种情况就必须做好链路日志埋点工作，实时监控脚本运行的状态。</p><p>第二就是<strong>使用第三方JavaScript库或SDK</strong>，例如前端和App原生的通讯SDK，小程序也会使用一些原生方法。依赖外部的交互往往是问题出现最频繁的地方，因此我们也必须要做好链路日志埋点，保证排查问题时能够通过日志判断问题的实际情况。</p><p>第三是前端页面有大量的<strong>全局事件和元素事件</strong>，例如触屏事件 <code>touchstart</code> 和 <code>touchend</code>、页面显示与隐藏的 <code>pageHide</code> 和 <code>pageShow</code> 事件，还有页面滚动事件 <code>onScroll</code> 等等。这些事件都会影响用户的使用体验，我建议根据实际情况去埋点链路日志，通过监控事件帮助提前发现问题。</p><h2>总结</h2><p>这节课我们重点学习了前端全链路的自定义链路日志，它能通过埋点监控页面或功能的状态，帮助前端同学在业务逻辑中提前发现问题。</p><p>在课程里，我们通过实现通用的日志函数和不同等级的日志函数两种方式，让前端同学可以在不同的业务场景下调用日志函数。同时，我还举了三种最常见的业务场景案例，帮助你了解自定义日志函数的使用方法。</p><p>前端全链路的自定义日志函数，是帮助业务逻辑发现问题而存在的。我们在实现业务逻辑时，不能总是关心功能是如何实现的，还必须关注功能的非正常流程状态以及异常情况的影响范围。</p><p>当然，有时候我们不可能一下子就把功能的实现想得很透，特别是经过多次迭代的同一份代码，更需要通过埋点来监控它，确保我们代码的质量能经过业务的考验。</p><p>需要再次强调的是，在全链路自定义日志埋点方案里，我们不能只关注错误埋点，非正常流程、异常捕获和核心逻辑也是全链路监控的重要组成部分。</p><h2>思考题</h2><p>现在留给你一道思考题。你现在负责的前端项目中，还有哪些业务场景需要通过链路日志重点监控呢？你应该如何优化这些业务场景和链路日志之间的逻辑关系呢？不妨尝试下。</p><p>欢迎你在留言区和我交流。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p>","neighbors":{"left":{"article_title":"11｜用户行为指标：如何有效监听用户交互行为？","id":772186},"right":{"article_title":"13｜关联后端：如何通过Skywalking把接口关联到后端服务？","id":774278}},"comments":[{"had_liked":false,"id":392579,"user_name":"苏果果","can_delete":false,"product_type":"c1","uid":2852467,"ip_address":"北京","ucode":"12A62ED032F345","user_header":"https://static001.geekbang.org/account/avatar/00/2b/86/73/5190bbde.jpg","comment_is_top":true,"comment_ctime":1721270752,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"完整源码入口：\nhttps:&#47;&#47;github.com&#47;sankyutang&#47;fontend-trace-geekbang-course","like_count":0},{"had_liked":false,"id":390652,"user_name":"westfall","can_delete":false,"product_type":"c1","uid":1632773,"ip_address":"上海","ucode":"F3F5CB7DF695FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/ea/05/9976b871.jpg","comment_is_top":false,"comment_ctime":1715857201,"is_pvip":false,"replies":[{"id":142515,"content":"确实会有的，有些操作系统会被魔改，甚至以安全为理由，删减不少内置特性。","user_name":"作者回复","user_name_real":"编辑","uid":1327155,"ctime":1719819984,"ip_address":"广东","comment_id":390652,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"说出来你可能不信，都 2024 年了，还有一些安卓手机自带的浏览器不支持 localStorage","like_count":0,"discussions":[{"author":{"id":1327155,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/33/11e434ba.jpg","nickname":"三橋sankyu 🐩","note":"","ucode":"2129405EA8D3D7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647302,"discussion_content":"确实会有的，有些操作系统会被魔改，甚至以安全为理由，删减不少内置特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719819984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395506,"user_name":"Ryan","can_delete":false,"product_type":"c1","uid":1687571,"ip_address":"湖北","ucode":"A316CBB3CAB97B","user_header":"https://static001.geekbang.org/account/avatar/00/19/c0/13/52cd5ea8.jpg","comment_is_top":false,"comment_ctime":1730993621,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"想问一下老师，这个课有做前端异常回放吗？很想学习这块怎么做，实时录屏肯定不行、","like_count":0},{"had_liked":false,"id":392035,"user_name":"zer0fire","can_delete":false,"product_type":"c1","uid":1468410,"ip_address":"四川","ucode":"F51772844B1534","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/fa/720f57fa.jpg","comment_is_top":false,"comment_ctime":1719802654,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"老师是否有空画一下架构脑图吗？或者贴一下 github 地址？感觉现在贴的代码虽然已经让我学到很多了，但是缺乏统一的视角，有点琐碎","like_count":0}]}