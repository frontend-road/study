{"id":787526,"title":"29｜经验：优化就是减少请求数量和质量","content":"<p>你好，我是三桥。</p><p>前几节课，我们主要围绕Web Vitals的核心指标优化了前端性能问题。</p><p>前端全链路的性能优化是一个复杂的问题。一些常见的优化技巧，总结起来大概有6点。</p><ol>\n<li>优化以减少请求量，包括合并资源、减少HTTP请求数、<code>gzip</code> 压缩、懒加载等。</li>\n<li>优化以加快请求速度，包括DNS预解析、减少域名数量、HTTP2协议、CDN分发、WebP图片格式等。</li>\n<li>缓存优化，包括离线缓存 <code>manifest</code>、HTTP协议的缓存请求等。</li>\n<li>渲染优化，包括服务器端渲染（SSR）、客户端渲染（CSR）、静态站点生成（SSG）等。</li>\n<li>CSS优化，具体方法包括避免使用 <code>table</code> 布局、减少深层级的选择器、使用 <code>className</code> 批量修改元素样式、利用GPU渲染动画等。</li>\n<li>前端工程化，例如代码分包、<code>tree shaking</code> 等。</li>\n</ol><p>这些优化方法都是前端技术的基础，但在实际性能优化的时候不一定都会用到。这节课，我们就梳理一些容易被忽视但非常实用的技巧。有4个方向，用户网络环境、小图标、响应式设计以及缓存数据优先。</p><h2>用户网络环境</h2><p>我们的目标是让前端页面快速触达用户，<strong>让用户优先体验到内容，然后才是功能交互。</strong></p><p>第27节课，我们在4G网络和不缓存资源两个条件下模拟了低速网络用户的情况，并对此进行了性能优化。</p><!-- [[[read_end]]] --><p>对于低速网络的用户，我们需要提供快速访问网站的条件，最直接的解决方式是根据用户的网络状态调整我们提供的资源。</p><p>目前，前端页面可以通过使用 <code>Network Information API</code> 来判断网络状态。下面是使用这个API的基本示例。</p><pre><code class=\"language-javascript\">let type = navigator.connection.effectiveType;\n\nfunction onConnectionChange() {\n&nbsp; console.log(\n&nbsp; &nbsp; `设备的网络连接从 ${type} 变为了 ${navigator.connection.effectiveType}`,\n&nbsp; );\n&nbsp; type = navigator.connection.effectiveType;\n}\n\nconnection.addEventListener(\"change\", onConnectionChange);\n</code></pre><p>代码中的第一行使用了 <code>navigator.connection.effectiveType</code> 返回连接的有效类型。这是一个衡量往返时间和下行链路的标准，也能用来判断用户的网络速度。然后，我们可以通过 <code>connection</code> 对象的change事件来监听网络的变化。</p><p>除此之外，<code>connection</code> 对象还提供了其它四个属性来判断用户网络状况，包括<code>downlink</code>、<code>rtt</code>、<code>saveData</code> 和 <code>type</code>。其中，<code>downlink</code> 和 <code>rtt</code> 主要是用于测量速度和网络稳定性的。</p><p>在上述代码之上，我们还可以调整代码，继续完善。比如使用netSpeed全局变量来判断用户当前的网络状态，具体代码如下。</p><pre><code class=\"language-javascript\">function checkEffectiveType() {\n\tif(/\\slow-2g|2g|3g/.test(navigator.connection.effectiveType)){\n\t&nbsp; return false;\n&nbsp; }\n&nbsp; return true\n}\n\n// 定义全局变量，告诉程序当前用户网络质量\n// true为高速网络，false为低速网络\nlet netSpeed = checkEffectiveType();\n\n// 前端如何判断用户的网络质量，浏览器原生的API：navigator.connection\nfunction onConnectionChange(){\n&nbsp; netSpeed = checkEffectiveType()\n}\nnavigator.connection.addEventListener('change', onConnectionChange);\n</code></pre><p>都是判断网络状态，有了netSpeed全局变量后又有什么不一样吗？有的，我们可以通过4个方法来提升用户体验。</p><ol>\n<li>根据网络速度的快慢，提供不同格式的资源，例如高清或标清图片。</li>\n<li>当用户网速较慢时，可以选择默认字体，不用网络字体。</li>\n<li>通过监控，帮助用户解决网络质量问题，如提醒用户更换网络，或注意流量费用。</li>\n<li>网速较慢时，增加延迟上传或下载的提醒。</li>\n</ol><p>比如第一点，我们可以利用网络速度状态，区分用户，并提供不同的图片，例如大小、质量等。参考代码如下。</p><pre><code class=\"language-javascript\">// 定义全局变量，告诉程序当前用户网络质量\n// true为高速网络，false为低速网络\nlet netSpeed = checkEffectiveType();\n// 阿里云OSS图片参数\nlet ossParams = 'x-oss-process=image/resize,w_200/quality,q_80'\n\nconst exampleImage = 'https://oss-console-img-demo-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/example.jpg'\n\nfunction checkEffectiveType() {\n\tif(/\\slow-2g|2g|3g/.test(navigator.connection.effectiveType)){\n&nbsp; &nbsp; &nbsp; ossParams = 'x-oss-process=image/resize,w_100/quality,q_60'\n\t&nbsp; return false;\n&nbsp; }\n&nbsp; return true\n}\n\n// 前端如何判断用户的网络质量，浏览器原生的API：navigator.connection\nfunction onConnectionChange(){\n&nbsp; netSpeed = checkEffectiveType()\n&nbsp; if (!netSpeed) {\n&nbsp; &nbsp; ossParams = 'x-oss-process=image/resize,w_100/quality,q_60'\n&nbsp; } else {\n&nbsp; &nbsp; ossParams = 'x-oss-process=image/resize,w_200/quality,q_80'\n&nbsp; }\n}\nnavigator.connection.addEventListener('change', onConnectionChange);\n\n\n\n// 完整OSS图片地址\nconsole.log(exampleImage + '?' + ossParams)\n</code></pre><p>在这个例子中，我们通过定义全局变量ossParams来记录图片需要使用哪种参数。如果用户处于高速网络状态，那就返回200px宽度和80%相对质量的图片；否则，返回100px宽度和60%相对质量的图片。</p><h2>小图标</h2><p>我们讨论了很多优化图片加载的方法，但你有没有发现，我说的都是大面积的图片，那那些小的不起眼的图片怎么办呢？</p><p>小图片，通常是指小于5K，或者宽度和高度小于50像素的图片。网页图片的加载是异步的，小图片过多会影响用户首次访问的加载速度，尤其是Icon图片。</p><p>我们来看看H5站点使用Icon图片的地方。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/1b/21ab94bf07edaf9a7496206bf3d08e1b.png?wh=2000x1980\" alt=\"图片\"></p><p>上图展示了两个H5站，我列出了五个使用 <code>Icon</code> 小图标的地方。如果你是前端新手，可能会直接用图片替代这些小图标，但这并不是最佳做法。最佳的做法是<strong>使用SVG来实现Icon小图标</strong>。</p><p>我给你提供三种方法来获取 <code>Icon</code> 图标SVG代码。</p><p>首先，大多数前端项目都是基于Vue和React的后台管理系统，通常会选择 <code>Element</code> 或 <code>Ant Design</code> 作为主要的前端UI框架。对于这类项目，UI框架通常都提供了基于SVG的 <code>Icon</code> 图标组件，前端同学来可以直接使用，因此这里不再详细说明。</p><p>第二，如果研发团队有设计师，通常UI设计稿会有大量的小图标。设计师通常会直接提供图片素材，包括Icon图标。</p><p>在这种情况下，我们可以使用如蓝湖这类的设计平台，将 <code>Icon</code> 图标导出为SVG代码。以下图示只需三步即可完成SVG代码的下载。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/5a/507eccd33cc31363f196ec9264e2295a.png?wh=2000x1466\" alt=\"图片\"></p><p>然后，我们只需要将SVG代码封装成组件，便可以直接引用，参考代码如下。</p><pre><code class=\"language-javascript\">import React from \"react\";\nexport const ArrowIcon = () =&gt; (\n&nbsp; &lt;svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\n    &lt;g id=\"Group 337\"&gt;\n      &lt;path id=\"Union\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9.84853 2.35148C9.3799 1.88285 8.6201 1.88285 8.15147 2.35148C7.68284 2.82011 7.68284 3.57991 8.15147 4.04854L9.80294 5.70001L1.2 5.70001C0.537258 5.70001 0 6.23727 0 6.90001C0 7.56275 0.537258 8.10001 1.2 8.10001L9.40294 8.10001L8.15147 9.35148C7.68284 9.82011 7.68284 10.5799 8.15147 11.0485C8.6201 11.5172 9.3799 11.5172 9.84853 11.0485L13.3485 7.54854C13.8172 7.07991 13.8172 6.32011 13.3485 5.85148L9.84853 2.35148Z\" fill=\"#00CA51\"/&gt;\n    &lt;/g&gt;\n  &lt;/svg&gt;\n)\n</code></pre><p>第三种方法适用于没有设计师的前端团队。前端同学可以根据项目需求，在一些图标平台上找到合适的图标，并将其转换为SVG代码。</p><p>比如，我经常使用的是<a href=\"https://www.iconfont.cn/\">iconfont.cn</a>。通过下面的示图中的四个步骤，你就可以得到图标的SVG代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/c6/84caba2dae9670e9a9eb4b5527fef5c6.png?wh=2000x784\" alt=\"图片\"></p><p>总的来说，<strong>只要网页中的图片可以用SVG来表示，那就尽量使用SVG格式。</strong>这样能够减少网页加载过程中图片的异步加载数量，提高网页加载速度。</p><h2>响应式设计</h2><p>响应式设计的概念已经存在一段时间了。在早期，我们会根据用户设备的屏幕尺寸调整页面布局。但现在，由于设备类型和尺寸越来越多，我们已经很少使用响应式设计来实现网页布局。</p><p>不过，可能你没有意识到，响应式设计还可以帮助我们解决性能问题。其中，CSS媒体查询是响应式设计的关键部分，它能让我们根据视口的大小创建不同的布局。</p><p>例如，当媒体查询发现视口宽度小于480像素时，我们可以初步判断用户设备屏幕尺寸较小。再结合前面的 <code>navigator.connection</code> 对象，我们可以判断用户是否在低速网络下使用低端设备访问前端页面。</p><p>以下示例代码是通过媒体查询，区分三种不同屏幕尺寸的CSS样式。</p><pre><code class=\"language-css\">// media.css\n\n//屏幕分辨率介于360px与600px之间时不使用背景图\n@media screen and (min-width: 360px) and (max-width: 600px) {\n\tbody {\n\t\tbackground: none;\n&nbsp; }\n}\n\n//屏幕分辨率介于600px与1024px之间时使用普通背景图\n@media screen and (min-width: 600px) and (max-width: 1024px) {\n\tbody {\n\t\tbackground:no-repeat url(\"./bg.png\");;\n&nbsp; }\n}\n\n//屏幕分辨率大于1024px时使用高清背景图\n@media screen and (min-width: 1024px) {\n&nbsp; body {\n\t\tbackground:no-repeat url(\"./bg-retina.png\");;\n&nbsp; }\n}\n</code></pre><p>代码逻辑简单明了，如果用户的屏幕较小，我们就不在CSS中使用图片作为背景。如果屏幕大于1024像素，我们就认为他的设备硬件较好，并且可能在高速网络中，所以我们可以提供更高清晰度的图片作为背景。</p><p>然而，适配不同屏幕分辨率的代码会随着页面布局的增多而增加。为了减少媒体查询代码的增多，我们可以利用媒体查询的另一个特性来分解代码。</p><p>我们知道，浏览器允许在 <code>link</code> 元素上添加 <code>media</code> 属性。所以，根据屏幕分辨率大小，我们可以选择有效的CSS内容并进行解析。例如，我们可以将上述代码改造成三个CSS样式文件。</p><pre><code class=\"language-xml\">&lt;link rel=\"stylesheet\" href=\"css/mobile.css\" media=\"screen and (min-width: 360px) and (max-width: 600px)\"&gt;\n&lt;link rel=\"stylesheet\" href=\"css/tablet.css\" media=\"screen and (min-width: 600px) and (max-width: 1024px)\"&gt;\n&lt;link rel=\"stylesheet\" href=\"css/desktop.css\" media=\"screen and (min-width: 1024px)\"&gt;\n</code></pre><p>不过，<strong>使用媒体查询的优化方案不适用于整个网页的布局适应，你可以把它看成一个降级方案，减少不必要的资源请求。</strong>这样，低速网络或低端设备的用户可以快速访问页面，从而提高页面转化率。</p><h2>缓存数据优先</h2><p>我在第23节课讲解了三星合作项目里的H5信息流项目。我们团队针对信息流数据做了一个小优化，就是缓存文章列表数据。</p><p>为什么我们要进行这样的数据缓存呢？</p><p>我们知道，前端请求业务数据是异步的，如文章列表、文章推荐列表、购物车商品等。对用户来说，这种异步请求获取数据存在延迟。如果接口请求时间过长，页面内容出现的时间也会延长，甚至会出现部分白屏。</p><p>为了解决数据获取延迟导致的页面加载慢的问题，前端可以采用缓存数据优先的策略，保证页面的完整性。</p><p>因此，无论信息流列表是新的还是旧的，当用户打开三星浏览器时，都能够立即显示。在有内容的情况下，用户无需等待就可以浏览历史数据，就像今日头条的首页一样，每次打开都默认有信息流文章。</p><p>我们看看在三星合作项目中的数据流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/9c/dece629d00ccb208f2a704e658a3479c.png?wh=2918x2915\" alt=\"\"></p><p>缓存优先的策略是，前端页面首先读取并显示本地缓存的数据，同时异步请求新数据。新数据返回后，更新缓存并显示最新数据。</p><p>这种策略实现逻辑简单，只需使用LocalStorage就能实现数据缓存。下面是一个基于这种策略的代码示例。</p><pre><code class=\"language-javascript\">// 从本地缓存中读取数据\nlet cacheData = localStorage.getItem('cacheData');\n\nif (cacheData) {\n\t// 如果缓存数据存在，先渲染缓存数据\n\ttry {\n\t&nbsp; render(JSON.parse(cacheData));\n&nbsp; } catch (err) {\n\t&nbsp; console.error(err);\n&nbsp; }\n}\n\n// 发起异步请求获取最新数据\nfetch('&lt;https://api.example.com/data&gt;')\n\t.then(response =&gt; response.json())\n&nbsp; .then(data =&gt; {\n\t&nbsp; // 更新缓存数据\n&nbsp; &nbsp; localStorage.setItem('cacheData', JSON.stringify(data));\n\t&nbsp; &nbsp; // 渲染最新数据\n&nbsp; &nbsp; &nbsp; render(data);\n\t});\n</code></pre><p>这段代码首先试图从 <code>LocalStorage</code> 中获取缓存数据。如果存在，就先用这些数据渲染页面。无论是否存在缓存数据，都会异步获取最新数据。当最新数据返回时，更新 <code>LocalStorage</code> 中的缓存，并用这些数据重新渲染页面。</p><p>不过，缓存优先策略存在一定的限制，并非适合大多数场景，因为只有在相同浏览器下用户才重复使用缓存数据，例如在同一个App的WebView当中。而且，<code>LocalStorage</code> 的存储空间有限，如果需要缓存的数据过多，可能会导致存储空间不足。此外，由于缓存数据可能会过期，我们也要定期更新或清除缓存数据，确保用户始终获得最新数据。</p><p>总的来说，<strong>本地缓存数据优先渲染页面，可以减少白屏时间，改善用户体验。</strong></p><h2>总结</h2><p>总结一下，本节课我们学习了四种前端性能优化小技巧。</p><p>采用SVG小图标已成为Web开发的标准做法。网络环境判断和响应式设计都是为了适配用户群体，确保快速触达用户。缓存优先策略在特定场景下先显示内容，再延后更新新内容，让用户先快速体验页面功能。</p><p>虽然每种优化技巧有其适用场景，但在实践中，我们不能忘记最基本和最常见的优化方法。这些基本方法为提高前端页面的性能和效率提供了坚实的基础。</p><p>到目前为止，前端性能优化没有固定标准和方法，只有实践经验。<strong>实际上，前端性能优化就是在做减法</strong>，减少不必要的请求和文件大小，优化异步链路，根据用户群体做降级方案，其最终目的是提升业务转化率并促成交易。</p><p>同样，前端全链路性能优化以用户为中心，不仅要解决用户问题，还要提升产品用户体验。下节课我们一起来学习如何使用工具来辅助前端全链路优化。</p><h2>思考题</h2><p>在本节课的最后，给你布置一道思考题。</p><p>前端全链路性能优化和常见性能优化的基本同理相似。在你参与的性能优化当中，还有哪些是减少请求量和优化链路的经验？我们可以一起探讨一下。</p><p>欢迎你在留言区和我交流。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p>","neighbors":{"left":{"article_title":"28｜视觉：避免发生布局偏移影响用户交互","id":785552},"right":{"article_title":"30｜工具：最容易被忽视的工具和定位问题路径","id":788713}},"comments":[{"had_liked":false,"id":392596,"user_name":"苏果果","can_delete":false,"product_type":"c1","uid":2852467,"ip_address":"北京","ucode":"12A62ED032F345","user_header":"https://static001.geekbang.org/account/avatar/00/2b/86/73/5190bbde.jpg","comment_is_top":true,"comment_ctime":1721271066,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"完整源码入口：\nhttps:&#47;&#47;github.com&#47;sankyutang&#47;fontend-trace-geekbang-course","like_count":0}]}