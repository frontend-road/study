{"id":510492,"title":"20｜DI Container（8）：如何实现Method Injection部分的功能？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现注入依赖容器。</p><h2>回顾代码与任务列表</h2><p>到目前为止，我们的代码是这样的：</p><pre><code>ContextConfig.java:\n \npackage geektime.tdd.di;\n    \nimport java.util.*;\nimport static java.util.List.of;\n    \npublic class ContextConfig {\n    private Map&lt;Class&lt;?&gt;, ComponentProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();\n    \n    public &lt;Type&gt; void bind(Class&lt;Type&gt; type, Type instance) {\n        providers.put(type, new ComponentProvider&lt;Type&gt;() {\n            @Override\n            public Type get(Context context) {\n                return instance;\n            }\n            @Override\n            public List&lt;Class&lt;?&gt;&gt; getDependencies() {\n                return of();\n            }\n        });\n    }\n    \n    public &lt;Type, Implementation extends Type&gt;\n    void bind(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation) {\n        providers.put(type, new ConstructorInjectionProvider&lt;&gt;(implementation));\n    }\n    \n    public Context getContext() {\n        providers.keySet().forEach(component -&gt; checkDependencies(component, new Stack&lt;&gt;()));\n        return new Context() {\n            @Override\n            public &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type) {\n                return Optional.ofNullable(providers.get(type)).map(provider -&gt; (Type) provider.get(this));\n            }\n        };\n    }\n    \n    private void checkDependencies(Class&lt;?&gt; component, Stack&lt;Class&lt;?&gt;&gt; visiting) {\n        for (Class&lt;?&gt; dependency: providers.get(component).getDependencies()) {\n            if (!providers.containsKey(dependency)) throw new DependencyNotFoundException(component, dependency);\n            if (visiting.contains(dependency)) throw new CyclicDependenciesFoundException(visiting);\n            visiting.push(dependency);\n            checkDependencies(dependency, visiting);\n            visiting.pop();\n        }\n    }\n    \n    interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        List&lt;Class&lt;?&gt;&gt; getDependencies();\n    }\n}\n    \nConstructorInjectionProvider.java:\n    \npackage geektime.tdd.di;\n    \nimport jakarta.inject.Inject;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Parameter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport static java.util.Arrays.stream;\n    \nclass ConstructorInjectionProvider&lt;T&gt; implements ContextConfig.ComponentProvider&lt;T&gt; {\n    private Constructor&lt;T&gt; injectConstructor;\n    private List&lt;Field&gt; injectFields;\n    \n    public ConstructorInjectionProvider(Class&lt;T&gt; component) {\n        this.injectConstructor = getInjectConstructor(component);\n        this.injectFields = getInjectFields(component);\n    }\n    \n    @Override\n    public T get(Context context) {\n        try {\n            Object[] dependencies = stream(injectConstructor.getParameters())\n                    .map(p -&gt; context.get(p.getType()).get())\n                    .toArray(Object[]::new);\n            T instance = injectConstructor.newInstance(dependencies);\n            for (Field field : injectFields)\n                field.set(instance, context.get(field.getType()).get());\n            return instance;\n        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    @Override\n    public List&lt;Class&lt;?&gt;&gt; getDependencies() {\n        return Stream.concat(stream(injectConstructor.getParameters()).map(Parameter::getType),\n                injectFields.stream().map(Field::getType)).toList();\n    }\n    \n    private static &lt;T&gt; List&lt;Field&gt; getInjectFields(Class&lt;T&gt; component) {\n        List&lt;Field&gt; injectFields = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while (current != Object.class) {\n            injectFields.addAll(stream(current.getDeclaredFields()).filter(f -&gt; f.isAnnotationPresent(Inject.class))\n                    .toList());\n            current = current.getSuperclass();\n        }\n        return injectFields;\n    }\n    \n    private static &lt;Type&gt; Constructor&lt;Type&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = stream(implementation.getConstructors())\n                .filter(c -&gt; c.isAnnotationPresent(Inject.class)).collect(Collectors.toList());\n        if (injectConstructors.size() &gt; 1) throw new IllegalComponentException();\n        return (Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; {\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new IllegalComponentException();\n            }\n        });\n    }\n}\n    \nContext.java:\npackage geektime.tdd.di;\n\nimport java.util.Optional;\n\npublic interface Context {\n    &lt;Type&gt; Optional&lt;Type&gt; get(Class&lt;Type&gt; type);\n}\n</code></pre><p>任务列表状态为：</p><ul>\n<li>\n<p><s>无需构造的组件——组件实例</s></p>\n</li>\n<li>\n<p>如果注册的组件不可实例化，则抛出异常</p>\n<ul>\n<li>抽象类</li>\n<li>接口</li>\n</ul>\n</li>\n<li>\n<p><s>构造函数注入</s></p>\n<ul>\n<li><s>无依赖的组件应该通过默认构造函数生成组件实例</s></li>\n<li><s>有依赖的组件，通过Inject标注的构造函数生成组件实例</s></li>\n<li><s>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</s></li>\n<li><s>如果组件有多于一个Inject标注的构造函数，则抛出异常</s></li>\n<li><s>如果组件没有Inject标注的构造函数，也没有默认构造函数（新增任务）</s></li>\n<li><s>如果组件需要的依赖不存在，则抛出异常</s></li>\n<li><s>如果组件间存在循环依赖，则抛出异常</s></li>\n</ul>\n</li>\n<li>\n<p>字段注入</p>\n<ul>\n<li><s>通过Inject标注将字段声明为依赖组件</s></li>\n<li>如果字段为final，则抛出异常</li>\n<li><s>依赖中应包含Inject Field声明的依赖</s></li>\n</ul>\n</li>\n<li>\n<p>方法注入</p>\n<ul>\n<li>通过Inject标注的方法，其参数为依赖组件</li>\n<li>通过Inject标注的无参数方法，会被调用</li>\n<li>按照子类中的规则，覆盖父类中的Inject方法</li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li>依赖中应包含Inject Method声明的依赖</li>\n</ul>\n</li>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可以声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><h2>视频演示</h2><p>让我们进入今天的部分：</p><p><video poster=\"https://media001.geekbang.org/92578fb9ad174382af500c026a384476/snapshots/b888b7de981e4f6398ac4b04a5f755db-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4d4d9e84-180601ef555-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/2b972989cf454496ab38c0c5be79a1f3/577f89f2091c46ba9b6e990f615b552b-7d09cb042451e0d3c515c63fe20b145b-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>在进入下节课之前，希望你能认真思考如下两个问题，并选择最有感触的一道进行回答。</p><ol>\n<li>要怎样重构测试代码？可以分享一下你的大致思路。</li>\n<li>在这节课中，让你比较有收获的地方是什么？可以分享一到两个。</li>\n</ol><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码的链接分享出来。相信经过你的思考与实操，学习效果会更好！</p>","neighbors":{"left":{"article_title":"19｜DI Container（7）：如何实现Field Injection部分的功能？","id":510489},"right":{"article_title":"21｜DI Container（9）：怎样重构测试代码？","id":510495}},"comments":[{"had_liked":false,"id":355679,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"广东","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1661646707,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661646707","product_id":100109401,"comment_content":"2. 最有感触的几点有：1.需求能变成测试用例，再根据测试用例需要的效果调整代码，减少了关注点。2.关于 Method Constructor Field Stream 和常见 Api 的用法也挺重要的。","like_count":0},{"had_liked":false,"id":347093,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1653710668,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653710668","product_id":100109401,"comment_content":"1、下一步行动，核心流程<br>先快速解决遗留下的sad path。<br>重构生产代码之前，先重构测试代码。<br><br>2、测试代码的重构思路，<br>当前测试代码中有部分的测试是在专门测ConstructionInjectionProvider的功能。<br>故可以将相关的测试提取到该测试类中。<br>","like_count":0},{"had_liked":false,"id":344354,"user_name":"tdd学徒","can_delete":false,"product_type":"c1","uid":1724083,"ip_address":"","ucode":"CC9C3EAD1B29B4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMbq1icuB8U1T7Vpic8FjKFdanvdt9bzClBmYqFUXmtKmh2Zibn9Dic6A8pjdoBiaia1LCrnA/132","comment_is_top":false,"comment_ctime":1651486900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651486900","product_id":100109401,"comment_content":"这段父类先调，子类后调的构造真巧妙  <br>   static class SuperClassWithInjectMethod {<br>            int superCalled = 0;<br><br>            @Inject<br>            void install() {<br>                superCalled++;<br>            }<br>        }<br><br>        static class SubClassWithInjectMethod extends SuperClassWithInjectMethod {<br>            int subCalled = 0;<br><br>            @Inject<br>            void installAnother() {<br>                subCalled = superCalled + 1;<br>            }<br>        }","like_count":0},{"had_liked":false,"id":344105,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1651242632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651242632","product_id":100109401,"comment_content":"收获<br><br>1. 掌握了从子类递归寻找到父类的方法<br>while (current != Object.class) {<br>  current = current.getSuperclass();<br>}<br><br>2. 利用 Collections.reverse() 方法可以轻松反转集合，不用之前的逻辑反过来实现一遍<br>- 遇事不要冲动，直接想到的不一定是最好的<br>- 多思考，尽量使用工具方法简化问题<br><br>3. 渐渐的比之前更理解代码了","like_count":0},{"had_liked":false,"id":343759,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1651041805,"is_pvip":false,"replies":[{"id":"125490","content":"不是删除了，任务列表没有问题哈～是解决方案的变化，导致任务列表发生了变化。到项目最后，任务列表大概变了三分之一 ","user_name":"编辑回复","user_name_real":"编辑","uid":"2189689","ctime":1651042154,"ip_address":"","comment_id":343759,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1651041805","product_id":100109401,"comment_content":"编辑，字段注入那里，被删除掉了一项，之前还有4项的。","like_count":0,"discussions":[{"author":{"id":1743208,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/99/68/62a3e325.jpg","nickname":"阿拉星","note":"","ucode":"B5FB18E4A9D408","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568006,"discussion_content":"不是删除了，任务列表没有问题哈～是解决方案的变化，导致任务列表发生了变化。到项目最后，任务列表大概变了三分之一 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651042154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]}]}