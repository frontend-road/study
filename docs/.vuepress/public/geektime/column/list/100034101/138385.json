{"id":138385,"title":"17 | First和Follow集合：用LL算法推演一个实例","content":"<p>在前面的课程中，我讲了递归下降算法。这个算法很常用，但会有回溯的现象，在性能上会有损失。所以我们要把算法升级一下，实现带有预测能力的自顶向下分析算法，避免回溯。而要做到这一点，就需要对自顶向下算法有更全面的了解。</p><p>另外，在留言区，有几个同学问到了一些问题，涉及到对一些基本知识点的理解，比如：</p><ul>\n<li>基于某个语法规则做解析的时候，什么情况下算是成功，什么情况下算是失败？</li>\n<li>使用深度优先的递归下降算法时，会跟广度优先的思路搞混。</li>\n</ul><p>要搞清这些问题，也需要全面了解自顶向下算法。比如，了解Follow集合和$符号的用法，能帮你解决第一个问题；了解广度优先算法能帮你解决第二个问题。</p><p>所以，本节课，我先把自顶向下分析的算法体系梳理一下，让你先建立更加清晰的全景图，然后我再深入剖析LL算法的原理，讲清楚First集合与Follow集合这对核心概念，最终让你把自顶向下的算法体系吃透。</p><h2>自顶向下分析算法概述</h2><p>自顶向下分析的算法是一大类算法。总体来说，它是从一个非终结符出发，逐步推导出跟被解析的程序相同的Token串。</p><p>这个过程可以看做是一张图的搜索过程，这张图非常大，因为针对每一次推导，都可能产生一个新节点。下面这张图只是它的一个小角落。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/87/46/876d50f726b34f5c4218cd919f78cf46.jpg?wh=1142*874\" alt=\"\"></p><p>算法的任务，就是在大图中，找到一条路径，能产生某个句子（Token串）。比如，我们找到了三条橘色的路径，都能产生“2+3*5”这个表达式。</p><p>根据搜索的策略，有<strong>深度优先（Depth First）和广度优先（Breadth First）</strong>两种，这两种策略的推导过程是不同的。</p><p><strong>深度优先</strong>是沿着一条分支把所有可能性探索完。以“add-&gt;mul+add”产生式为例，它会先把mul这个非终结符展开，比如替换成pri，然后再把它的第一个非终结符pri展开。只有把这条分支都向下展开之后，才会回到上一级节点，去展开它的兄弟节点。</p><p>递归下降算法就是深度优先的，这也是它不能处理左递归的原因，因为左边的分支永远也不能展开完毕。</p><p>而针对“add-&gt;add+mul”这个产生式，<strong>广度优先</strong>会把add和mul这两个都先展开，这样就形成了四条搜索路径，分别是mul+mul、add+mul+mul、add+pri和add+mul*pri。接着，把它们的每个非终结符再一次展开，会形成18条新的搜索路径。</p><p>所以，广度优先遍历，需要探索的路径数量会迅速爆炸，成指数级上升。哪怕用下面这个最简单的语法，去匹配“2+3”表达式，都需要尝试20多次，更别提针对更复杂的表达式或者采用更加复杂的语法规则了。</p><pre><code>//一个很简单的语法\nadd -&gt; pri          //1\nadd -&gt; add + pri    //2\npri -&gt; Int          //3\npri -&gt; (add)        //4\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/d2/dd/d2f4c3a577ee6c7b4b0ffcff3d8792dd.jpg?wh=1142*1062\" alt=\"\"></p><p>这样看来，指数级上升的内存消耗和计算量，使得广度优先根本没有实用价值。虽然上面的算法有优化空间，但无法从根本上降低算法复杂度。当然了，它也有可以使用左递归文法的优点，不过我们不会为了这个优点去忍受算法的性能。</p><p>而深度优先算法在内存占用上是线性增长的。考虑到回溯的情况，在最坏的情况下，它的计算量也会指数式增长，但我们可以通过优化，让复杂度降为线性增长。</p><p>了解广度优先算法，你的思路会得到拓展，对自顶向下算法的本质有更全面的理解。另外，在写算法时，你也不会一会儿用深度优先，一会儿用广度优先了。</p><p>针对深度优先算法的优化方向是减少甚至避免回溯，思路就是给算法加上预测能力。比如，我在解析statement的时候，看到一个if，就知道肯定这是一个条件语句，不用再去尝试其他产生式了。</p><p><strong>LL算法就属于这类预测性的算法。</strong>第一个L，是Left-to-right，代表从左向右处理程序代码。第二个L，是Leftmost，意思是最左推导。</p><p>按照语法规则，一个非终结符展开后，会形成多个子节点，其中包含终结符和非终结符。最左推导是指，从左到右依次推导展开这些非终结符。采用Leftmost的方法，在推导过程中，句子的左边逐步都会被替换成终结符，只有右边的才可能包含非终结符。</p><p>以“2+3*5”为例，它的推导顺序从左到右，非终结符逐步替换成了终结符：</p><p><img src=\"https://static001.geekbang.org/resource/image/dc/21/dce93faf1fbce5d439b38b02c07e7e21.jpg?wh=1142*823\" alt=\"\"></p><p>下图是上述推导过程建立起来的AST，“1、2、3……”等编号是AST节点创建的顺序：</p><p><img src=\"https://static001.geekbang.org/resource/image/44/a5/443c87e6af51a42a76f5d58220e4fda5.jpg?wh=1142*685\" alt=\"\"></p><p>好了，我们把自顶向下分析算法做了总体概述，并讲清楚了最左推导的含义，现在来看看LL算法到底是怎么回事。</p><h2>计算和使用First集合</h2><p>LL算法是带有预测能力的自顶向下算法。在推导的时候，我们希望当存在多个候选的产生式时，瞄一眼下一个（或多个）Token，就知道采用哪个产生式。如果只需要预看一个Token，就是LL(1)算法。</p><p>拿statement的语法举例子，它有好几个产生式，分别产生if语句、while语句、switch语句……</p><pre><code>statement\n    : block\n    | IF parExpression statement (ELSE statement)?\n    | FOR '(' forControl ')' statement\n    | WHILE parExpression statement\n    | DO statement WHILE parExpression ';'\n    | SWITCH parExpression '{' switchBlockStatementGroup* switchLabel*                \n    | RETURN expression? ';'\n    | BREAK IDENTIFIER? ';'\n    | CONTINUE IDENTIFIER? ';'\n    | SEMI\n    | statementExpression=expression ';'\n    | identifierLabel=IDENTIFIER ':' statement\n    ;\n</code></pre><p>如果我看到下一个Token是if，那么后面跟着的肯定是if语句，这样就实现了预测，不需要一个一个产生式去试。</p><p>问题来了，if语句的产生式的第一个元素就是一个终结符，这自然很好判断，可如果是一个非终结符，比如表达式语句，那该怎么判断呢？</p><p>我们可以为statement的每条分支计算一个集合，集合包含了这条分支所有可能的起始Token。如果每条分支的起始Token是不一样的，也就是这些集合的交集是空集，那么就很容易根据这个集合来判断该选择哪个产生式。我们把这样的集合，<strong>就叫做这个产生式的First集合。</strong></p><p>First集合的计算很直观，假设我们要计算的产生式是x：</p><ul>\n<li>如果x以Token开头，那么First(x)包含的元素就是这个Token，比如if语句的First集合就是{IF}。</li>\n<li>如果x的开头是非终结符a，那么First(x)要包含First(a)的所有成员。比如expressionStatment是以expression开头，因此它的First集合要包含First(expression)的全体成员。</li>\n<li>如果x的第一个元素a能够产生ε，那么还要再往下看一个元素b，把First(b)的成员也加入到First(x)，以此类推。如果所有元素都可能返回ε，那么First(x)也应该包含ε，意思是x也可能产生ε。比如下面的blockStatements产生式，它的第一个元素是blockStatement*，也就意味着blockStatement的数量可能为0，因此可能产生ε。那么First(blockStatements)除了要包含First(blockStatement)的全部成员，还要包含后面的“；”。</li>\n</ul><pre><code>blockStatements\n        : blockStatement*\n        ;\n</code></pre><ul>\n<li>最后，如果x是一个非终结符，它有多个产生式可供选择，那么First(x)应包含所有产生式的First()集合的成员。比如statement的First集合要包含if、while等所有产生式的First集合的成员。并且，如果这些产生式只要有一个可能产生ε，那么x就可能产生ε，因此First(x)就应该包含ε。</li>\n</ul><p>在本讲的示例程序里，我们可以用<a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/SampleGrammar.java\">SampleGrammar.expressionGrammar()</a>方法获得一个表达式的语法，把它dump()一下，这其实是消除了左递归的表达式语法：</p><pre><code>expression\t: assign ;\nassign\t: equal | assign1 ;\nassign1 : '=' equal assign1 | ε;  \nequal\t: rel equal1 ;\nequal1\t: ('==' | '!=') rel equal1 | ε ;\nrel\t\t: add rel1 ;\nrel1\t: ('&gt;=' | '&gt;' | '&lt;=' | '&lt;') add rel1 | ε ;\nadd\t\t: mul add1 ;\nadd1\t: ('+' | '-') mul add1 | ε ;\nmul\t\t: pri mul1 ;\nmul1\t: ('*' | '/') pri mul1 | ε ;\npri\t\t: ID | INT_LITERAL | LPAREN expression RPAREN ;\n</code></pre><p>我们用GrammarNode类代表语法的节点，形成一张语法图（蓝色节点的下属节点之间是“或”的关系，也就是语法中的竖线）。</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/7b/a9a2210fcf94ac474259fca459b86e7b.jpg?wh=1142*759\" alt=\"\"></p><p>基于这个数据结构能计算每个非终结符的First集合，可以参考<a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/LLParser.java\">LLParser</a>类的caclFirstSets()方法。运行示例程序可以打印出表达式语法中各个非终结符的First集合。</p><p>在计算时你要注意，因为上下文无关文法是允许递归嵌套的，所以这些GrammarNode节点构成的是一个图，而不是树，不能通过简单的遍历树的方法来计算First集合。比如，pri节点是expression的后代节点，但pri又引用了expression（pri-&gt;(expression)）。这样，计算First(expression)需要用到First(pri)，而计算First(pri)又需要依赖First(expression)。</p><p>破解这个僵局的方法是用“不动点法”来计算。多次遍历图中的节点，看看每次有没有计算出新的集合成员。比如，第一遍计算的时候，当求First(pri)的时候，它所依赖的First(expression)中的成员可能不全，等下一轮继续计算时，发现有新的集合成员，再加进来就好了，直到所有集合的成员都没有变动为止。</p><p>现在我们可以用First集合进行分支判断了，不过还要处理产生式可能为ε的情况，比如“+mul add1 | ε”或“blockStatement*”都会产生ε。</p><h2>计算和使用Follow集合</h2><p>对ε的处理分成两种情况。</p><p><strong>第一种情况，是产生式中的部分元素会产生ε。</strong>比如，在Java语法里，声明一个类成员的时候，可能会用public、private这些来修饰，但也可以省略不写。在语法规则中，这个部分是“accessModifier?”，它就可能产生ε。</p><pre><code>memberDeclaration : accessModifier? type identifier ';' ;\naccessModifier : 'public' | 'private' ;\ntype : 'int' | 'long' | 'double' ;\n</code></pre><p>所以，当我们遇到下面这两个语句的时候，都可以判断为类成员的声明：</p><pre><code>public int a;\nint b; \n</code></pre><p>这时，type能够产生的终结符 ‘int’、‘long’和‘double’也在memberDeclaration的First集合中。这样，我们实际上把accessModifier给穿透了，直接到了下一个非终结符type。所以这类问题依靠First集合仍然能解决。在解析的过程中，如果下一个Token是 ‘int’，我们可以认为accessModifier返回了ε，忽略它，继续解析下一个元素type，因为它的First集合中才会包含 ‘int’。</p><p><strong>第二种情况是产生式本身（而不是其组成部分）产生ε。</strong>这类问题仅仅依靠First集合是无法解决的，要引入另一个集合：Follow集合。它是所有可能跟在某个非终结符之后的终结符的集合。</p><p>以block语句为例，在PlayScript.g4中，大致是这样定义的：</p><pre><code>block\n    : '{' blockStatements '}'\n    ;\n\nblockStatements\n    : blockStatement*\n    ;\n    \nblockStatement\n    : variableDeclarators ';'\n    | statement\n    | functionDeclaration\n    | classDeclaration\n    ;\n</code></pre><p>也就是说，block是由blockStatements构成的，而blockStatements可以由0到n个blockStatement构成，因此可能产生ε。</p><p>接下来，我们来看看解析block时会发生什么。</p><p>假设花括号中一个语句也没有，也就是blockStatments实际上产生了ε。那么在解析block时，首先读取了一个Token，即“{”，然后处理blockStatements，我们再预读一个Token，发现是“}”，那这个右花括号是blockStatement的哪个产生式的呢？实际上它不在任何一个产生式的First集合中，下面是进行判断的伪代码：</p><pre><code>nextToken = tokens.peek();                //得到'}'\nnextToken in First(variableDeclarators) ? //no\nnextToken in First(statement) ?           //no\nnextToken in First(functionDeclaration) ? //no\nnextToken in First(classDeclaration) ?    //no\n</code></pre><p>我们找不到任何一个可用的产生式。这可怎么办呢？除了可能是blockStatments本身产生了ε之外，还有一个可能性就是出现语法错误了。而要继续往下判断，就需要用到Follow集合。</p><p>像blockStatements的Follow集合只有一个元素，就是右花括号“}”。所以，我们只要再检查一下nextToken是不是花括号就行了：</p><pre><code>//伪代码\nnextToken = tokens.peek();                //得到'}'\nnextToken in First(variableDeclarators) ? //no\nnextToken in First(statement) ?           //no\nnextToken in First(functionDeclaration) ? //no\nnextToken in First(classDeclaration) ?    //no\n\nif (nextToken in Follow(blockStatements)) //检查Follow集合\n  return Epsilon;                         //推导出ε\nelse\n  error;                                  //语法错误\n</code></pre><p>那么怎么计算非终结符x的Follow集合呢？</p><ul>\n<li>扫描语法规则，看看x后面都可能跟哪些符号。</li>\n<li>对于后面跟着的终结符，都加到Follow(x)集合中去。</li>\n<li>如果后面是非终结符，就把它的First集合加到自己的Follow集合中去。</li>\n<li>最后，如果后面的非终结符可能产出ε，就再往后找，直到找到程序终结符号。</li>\n</ul><p>这个符号通常记做$，意味一个程序的结束。比如在表达式的语法里，expression 后面可能跟这个符号，expression 的所有右侧分支的后代节点也都可能跟这个符号，也就是它们都可能出现在程序的末尾。但另一些非终结符，后面不会跟这个符号，如blockstatements，因为它后面肯定会有“}”。</p><p>你可以参考<a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/LLParser.java\">LLParser</a>类的caclFollowSets()方法，这里也要用到不动点法做计算。运行程序可以打印出示例语法的的Follow集合。我把程序打印输出的First和follow集合整理如下（其实打印输出还包含一些中间节点，这里就不展示了）：</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/30/d53bee2e3c9f0ce4e0d0eb6df05f3e30.jpg?wh=1142*762\" alt=\"\"></p><p>在表达式的解析中，我们会综合运用First和Follow集合。比如，对于“add1 -&gt; + mul add1 | ε”，如果预读的下一个Token是+，那就按照第一个产生式处理，因为+在First(“+ mul add1”)集合中。如果预读的Token是&gt;号，那它肯定不在First(add1)中，而我们要看它是否属于Follow(add1)，如果是，那么add1就产生一个ε，否则就报错。</p><h2>LL算法和文法</h2><p>现在我们已经建立了对First集合、Follow集合和LL算法计算过程的直觉认知。这样再写出算法的实现，就比较容易了。用LL算法解析语法的时候，我们可以选择两种实现方式。</p><p>第一种，还是采用递归下降算法，只不过现在的递归下降算法是没有任何回溯的。无论走到哪一步，我们都能准确地预测出应该采用哪个产生式。</p><p>第二种，是采用表驱动的方式。这个时候需要基于我们计算出来的First和Follow集合构造一张预测分析表。根据这个表，查找在遇到什么Token的情况下，应该走哪条路径。</p><p>这两种方式是等价的，你可以根据自己的喜好来选择，我用的是第一种。关于算法，我们就说这么多，接下来，我们谈谈如何设计符合LL(k)特别是LL(1)算法的文法。</p><p>我们已经知道左递归的文法是要避免的，也知道要如何避免。除此之外，我们要尽量抽取左公因子，这样可以避免First集合产生交集。举例来说，变量声明和函数声明的规则在前半截都差不多，都是类型后面跟着标识符：</p><pre><code>statement : variableDeclare | functionDeclare | other;\nvariableDeclare : type Identifier ('=' expression)? ;\nfuncationDeclare : type Identifier '(' parameterList ')' block ;\n</code></pre><p>具体例子如下：</p><pre><code>int age；\nint cacl(int a, int b){\n  return a + b;\n}\n</code></pre><p>这样的语法规则，如果按照LL(1)算法，First(variableDeclare)和First(funcationDeclare)是相同的，没法决定走哪条路径。你就算用LL(2)，也是一样的，要用到LL(3)才行。但对于LL(k) k &gt; 1来说，程序开销有点儿大，因为要计算更多的集合，构造更复杂的预测分析表。</p><p>不过这个问题很容易解决，只要把它们的左公因子提出来就可以了：</p><pre><code>statement: declarator | other;\ndeclarator : declarePrefix （variableDeclarePostfix                \n                            |functionDeclarePostfix) ;\nvariableDeclarePostfix : ('=' expression)? ;\nfunctionDeclarePostfix : '(' parameterList ')' block ;\n</code></pre><p>这样，解析程序先解析它们的公共部分，即declarePrefix，然后再看后面的差异。这时，它俩的First集合，一个{ =  ; }，一个是{  (  }，两者没有交集，能够很容易区分。</p><h2>课程小结</h2><p>本节课我们比较全面地梳理了自顶向下算法。语法解析过程可以看做是对图的遍历过程，遍历时可以采取深度优先或广度优先的策略，这里要注意，你可能在做深度优先遍历的时候，误用广度优先的思路。</p><p>针对LL算法，我们通过实例分析了First集合和Follow集合的使用场景和计算方式。掌握了这两个核心概念，特别是熟悉它们的使用场景，你会彻底掌握LL算法。</p><h2>一课一思</h2><p>处理ε是LL算法中的关键点。在你熟悉的语言中，哪些语法会产生ε，你在做语法解析的时候会怎样处理它们？欢迎在留言区分享你的思考。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>本节课的示例代码我放在了文末，供你参考。</p><ul>\n<li>lab/16～18（算法篇的示例代码）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/lab/16-18\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/lab/16-18\">GitHub</a></li>\n<li>LLParser.java（LL算法的语法解析器）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/LLParser.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/16-18/src/main/java/play/parser/LLParser.java\">GitHub</a></li>\n</ul>","neighbors":{"left":{"article_title":"16 | NFA和DFA：如何自己实现一个正则表达式工具？","id":137286},"right":{"article_title":"18 | 移进和规约：用LR算法推演一个实例","id":139628}},"comments":[{"had_liked":false,"id":135371,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1569140481,"is_pvip":false,"replies":[{"id":"52092","content":"是的。它会自动处理。<br>Antlr这个工具做了大量的工作，让开发者编写语法的时候，可以效率更高。<br>这样的工具，也不是采用固化的LL(1)或LL(2)算法，而是有能力根据语法去决定解析策略。实在不行了还可以回溯。你会发现：1.生产中使用的编译器，会综合采用多种技术，而不仅仅是单纯的采用某个算法。<br>2.如果要写符合LL(1)算法的语法，其实语法很啰嗦。这是在编译技术发展的早期，计算能力有限，大家更重视执行的效率。而现在，计算能力很强，可以更加照顾开发者效率，而不是计算效率。所有Antlr的语法很友好，很人性化。从表达式的语法就可见一斑。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1569300106,"ip_address":"","comment_id":135371,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35928878849","product_id":100034101,"comment_content":"Antlr中LL(k)中k是多少，是Antlr根据我们的文法动态决定的吗？还是老师文中说的那些写LL文法的注意点，我们在写Antlr文法的时候需要注意吗？Antlr会帮助我们自动处理这些吗？","like_count":8,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468160,"discussion_content":"是的。它会自动处理。\nAntlr这个工具做了大量的工作，让开发者编写语法的时候，可以效率更高。\n这样的工具，也不是采用固化的LL(1)或LL(2)算法，而是有能力根据语法去决定解析策略。实在不行了还可以回溯。你会发现：1.生产中使用的编译器，会综合采用多种技术，而不仅仅是单纯的采用某个算法。\n2.如果要写符合LL(1)算法的语法，其实语法很啰嗦。这是在编译技术发展的早期，计算能力有限，大家更重视执行的效率。而现在，计算能力很强，可以更加照顾开发者效率，而不是计算效率。所有Antlr的语法很友好，很人性化。从表达式的语法就可见一斑。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569300106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168353,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1578053491,"is_pvip":false,"replies":[{"id":"74265","content":"谢谢你分享自己的感受。<br>我再加几句。你说的对。编译器的前端，带有很强的形式体系的特征。形式语言能够描述程序的语法，也能用于描述数学上的公理体系。逻辑学、哲学领域，通常也需要这样抽象级别的体系。所以抽象程度确实挺高。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585191120,"ip_address":"","comment_id":168353,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18757922675","product_id":100034101,"comment_content":"今日份总结：今天是一个扫盲的学习，有以下两点总结<br><br>1.编译的过程：词法分析 语法分析 语义分析<br>1.1词法分析：读取的内容是字符，根据词法规则输出token。几乎不涉及语言的语法特性，是编译器的基础。<br>1.2语法分析:读取的内容是token，输出的是语法树AST。语言的表达式等功能又这部分中定义的上下文无关文法来实现。<br>1.3语义分析:操作的对象是AST，所谓语义主要完成上下文相关的推理逻辑，如类型问题，定义声明问题等<br><br>2.说说我对编译原理的初次见面感觉：编译原理相比于其他计算机基础知识而言，他的难主要集中在需要高度的对现实生活规则的抽象能力、逻辑思维能力，否则写不出没问题的上下文无关文法规则，以及无法发现、处理其中蕴含的一些“逻辑坑”，如左递归等问题。而一些其他的知识点，如算法部分，这些其实相比于抽象能力来说，就要简单、通用、好理解的多，更加考验你的编程基础，而不是脑子。","like_count":4,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480201,"discussion_content":"谢谢你分享自己的感受。\n我再加几句。你说的对。编译器的前端，带有很强的形式体系的特征。形式语言能够描述程序的语法，也能用于描述数学上的公理体系。逻辑学、哲学领域，通常也需要这样抽象级别的体系。所以抽象程度确实挺高。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585191120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135377,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1569141744,"is_pvip":false,"replies":[{"id":"57600","content":"把箭头指在线上这种画法确实不大好，会有歧义。我回头更新一版图，让箭头指向每个存储位置的格子上。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573377575,"ip_address":"","comment_id":135377,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14454043632","product_id":100034101,"comment_content":"还是不太明白为什么要有Follow集这个东西，如果First集中查找不到的话，直接将推导为ε，然后接着去推导下一个，如果发现不在下一个的First集中再报错，好像也不会有什么性能损失，那为什么要费那么大力气构建Follow集呢？","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468164,"discussion_content":"把箭头指在线上这种画法确实不大好，会有歧义。我回头更新一版图，让箭头指向每个存储位置的格子上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573377575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411173,"discussion_content":"blockStatements后面如果是;，那判断;的first集合能推导不出错误吧？不过这个只是假设，不知道这种情况合理不合理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635860916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2421178,"avatar":"","nickname":"Geek_7dac90","note":"","ucode":"1FFDA0A2792707","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366152,"discussion_content":"这应该就不是LL(1)了吧 应该是2了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617971325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320560,"user_name":"军","can_delete":false,"product_type":"c1","uid":1096197,"ip_address":"","ucode":"EEFB3A39259CF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/05/2cd96ff1.jpg","comment_is_top":false,"comment_ctime":1636379791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5931347087","product_id":100034101,"comment_content":"first集合和子集构造法很像呢","like_count":1},{"had_liked":false,"id":230227,"user_name":"墨灵","can_delete":false,"product_type":"c1","uid":1409700,"ip_address":"","ucode":"185D70CA20BEEE","user_header":"https://static001.geekbang.org/account/avatar/00/15/82/a4/a92c6eca.jpg","comment_is_top":false,"comment_ctime":1593316897,"is_pvip":false,"replies":[{"id":"85233","content":"恭喜你！<br>并且，你不是孤独的。我们公司的一名前端工程师，已经被我忽悠到编译的道路上了:-)<br>而且，编译技术在完成很多高级的前端工作方面大有可为！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1593500318,"ip_address":"","comment_id":230227,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888284193","product_id":100034101,"comment_content":"https:&#47;&#47;github.com&#47;moling3650&#47;Frontend-01-Template&#47;blob&#47;master&#47;week12&#47;ast.js<br>用JavaScript写了一个四则计算器，总算搞明白产生式和LL算法的对应关系了，这课真是太不容易了，对于一个前端来说。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499805,"discussion_content":"恭喜你！\n并且，你不是孤独的。我们公司的一名前端工程师，已经被我忽悠到编译的道路上了:-)\n而且，编译技术在完成很多高级的前端工作方面大有可为！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593500318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137264,"user_name":"Geek_f9ea2d","can_delete":false,"product_type":"c1","uid":1633065,"ip_address":"","ucode":"CB9B422F034493","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBThvjr88V0BVAOC4PicPUNPITZ2la5iciatFNYyicibcwicBjIaxElz77xsphqStrr81CSQeTXiaBVMTAA/132","comment_is_top":false,"comment_ctime":1569672152,"is_pvip":false,"replies":[{"id":"53910","content":"因为这些孩子节点是父节点最右边的。那么父节点后面会跟什么终结符，这些子节点也会跟这些终结符。<br>如果一个非终结符位于上一级产生式的最右边，比如：A-&gt;abcdB中的B，（我们用大小写区分终结符和非终结符）那么找到可能出现在它右边的终结符，实际上不是那么好找。要看看A后面都可能跟啥，比如：C-&gt;abcAb，那么A的Follow集合中有b，B的Follow集合中也要有b。<br>实际上，我觉得自己的这个实现比较笨拙，受限于我采用的GrammarNode这样的数据结构。后面有时间的话，我再写个更加简洁的算法给大家参考。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570711144,"ip_address":"","comment_id":137264,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5864639448","product_id":100034101,"comment_content":"老师好，对First集合我基本能理解，对Fllow集合的计算，我看的有点懵，这个方法：addToRightChild 为什么需要：把某个节点的Follow集合，也给它所有右边分枝的后代节点？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469005,"discussion_content":"因为这些孩子节点是父节点最右边的。那么父节点后面会跟什么终结符，这些子节点也会跟这些终结符。\n如果一个非终结符位于上一级产生式的最右边，比如：A-&amp;gt;abcdB中的B，（我们用大小写区分终结符和非终结符）那么找到可能出现在它右边的终结符，实际上不是那么好找。要看看A后面都可能跟啥，比如：C-&amp;gt;abcAb，那么A的Follow集合中有b，B的Follow集合中也要有b。\n实际上，我觉得自己的这个实现比较笨拙，受限于我采用的GrammarNode这样的数据结构。后面有时间的话，我再写个更加简洁的算法给大家参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570711144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2260390,"avatar":"https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg","nickname":"温雅小公子","note":"","ucode":"9EA63E36D7C85C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"discussion":{"id":589198,"discussion_content":"这个这个我实在无法理解，怎么就要看父节点的follow，明明最右边的非终结符不再跟着符号了啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664509823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":469005,"ip_address":"河北"},"score":589198,"extra":""}]}]},{"had_liked":false,"id":359200,"user_name":"温雅小公子","can_delete":false,"product_type":"c1","uid":2260390,"ip_address":"河北","ucode":"9EA63E36D7C85C","user_header":"https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg","comment_is_top":false,"comment_ctime":1665320596,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1665320596","product_id":100034101,"comment_content":"那个pri结点应该是蓝色吧，他的子节点是或的关系。","like_count":0},{"had_liked":false,"id":316554,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1634386403,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1634386403","product_id":100034101,"comment_content":"哈哈，看到一愣一愣的","like_count":0},{"had_liked":false,"id":287679,"user_name":"coconut","can_delete":false,"product_type":"c1","uid":2344081,"ip_address":"","ucode":"07B95C7A6AC2F7","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/91/a017bf72.jpg","comment_is_top":false,"comment_ctime":1618106810,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1618106810","product_id":100034101,"comment_content":"和某评论一样有一个疑问，为什么要计算Follow集合？<br><br>似乎用First集合就可以实现不回溯的递归下降算法。<br><br>遇到下面的文法，如果token不在 First(+ mul add1) 中，就直接匹配 ε。也不一定要计算 Follow(add1)<br><br>  add1 -&gt; + mul add1 | ε<br>","like_count":0,"discussions":[{"author":{"id":1444483,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","nickname":"风","note":"","ucode":"E1CE0825AAF805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413484,"discussion_content":"如果只用First集合，那么在遇到文中说的第2种epsilon情况时，你就只能认为它是epsilon，继续往下parse，而万一出现的是语法错误，这里就产生回溯了。如果此时引进Follow集合，那么你就能在不往下试探的情况下，及时判断是否是语法错误。\nFirst/Follow 集合的引入，就是为了能够不往下做多余的试探。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636476455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050269,"avatar":"","nickname":"minghu6","note":"","ucode":"F44058E21B14C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371778,"discussion_content":"要根据Follow集合判断是自身存在e还是语法错误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619965372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206904,"user_name":"yydsx","can_delete":false,"product_type":"c1","uid":1590391,"ip_address":"","ucode":"8C6251216900DF","user_header":"","comment_is_top":false,"comment_ctime":1586955346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586955346","product_id":100034101,"comment_content":"class LLParser 里面的 241行   <br>   if (i == grammar.getChildCount()) {<br>                            rightChildren.add(left);<br>      }<br>是不是应为<br>   if (i == grammar.getChildCount()-1) {<br>                            rightChildren.add(left);<br>                        }<br>如果i == grammar.getChildCount()  那么花括号里面的代码将永远不会执行","like_count":0},{"had_liked":false,"id":175863,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1580872511,"is_pvip":false,"replies":[{"id":"74297","content":"就是说，根据语法规则，有的非终结符可能出现在程序的末尾的，另一些非终结符永远也不可能出现在程序末尾。<br>比如，在语法规则中，blockStatements是block的一部分，也只出现在这一个地方。而block呢，前后一定环绕着花括号，这就导致了blockStatements后面必然是跟着“}”的。<br>换句话说，block是可能出现在程序结尾的，而blockStatement不可能。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585203758,"ip_address":"","comment_id":175863,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580872511","product_id":100034101,"comment_content":"这个符号通常记做 $，意味一个程序的结束。比如在表达式的语法里，expression 后面可能跟这个符号，expression 的所有右侧分支的后代节点也都可能跟这个符号，也就是它们都可能出现在程序的末尾。但另一些非终结符，后面不会跟这个符号，如 blockstatements，因为它后面肯定会有“}”。<br>这一段看了好几遍，没有看懂，老师能不能再解释下？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482934,"discussion_content":"就是说，根据语法规则，有的非终结符可能出现在程序的末尾的，另一些非终结符永远也不可能出现在程序末尾。\n比如，在语法规则中，blockStatements是block的一部分，也只出现在这一个地方。而block呢，前后一定环绕着花括号，这就导致了blockStatements后面必然是跟着“}”的。\n换句话说，block是可能出现在程序结尾的，而blockStatement不可能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585203758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157581,"user_name":"LeeR","can_delete":false,"product_type":"c1","uid":1687425,"ip_address":"","ucode":"767666864C6307","user_header":"https://static001.geekbang.org/account/avatar/00/19/bf/81/4c45a87b.jpg","comment_is_top":false,"comment_ctime":1575202540,"is_pvip":false,"replies":[{"id":"74296","content":"$是整个输入串右边的结束标记（endmarker）。<br>我们可以用EOF表示这个结束标记，因为这个时候源代码文件已经到结尾了。但理论上你还可以用某个特殊的Token来表示程序结束，只不过不常见罢了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585203200,"ip_address":"","comment_id":157581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575202540","product_id":100034101,"comment_content":"老师你好，$ 是不是就是EOF符号，表示程序和文件的结束？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476472,"discussion_content":"$是整个输入串右边的结束标记（endmarker）。\n我们可以用EOF表示这个结束标记，因为这个时候源代码文件已经到结尾了。但理论上你还可以用某个特殊的Token来表示程序结束，只不过不常见罢了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585203200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145654,"user_name":"余晓飞","can_delete":false,"product_type":"c1","uid":1007370,"ip_address":"","ucode":"EEC632FF776327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/0a/7f9c476b.jpg","comment_is_top":false,"comment_ctime":1572337261,"is_pvip":false,"replies":[{"id":"77226","content":"你说的没错。谢谢你的细心！<br>带1的非终结符（assign1, equal1, rel1, add1, mul1）的First结合的都包含Epsilon。<br>运行LLParser.java会输出正确的First集合。<br>我让编辑同学改一下图。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586929426,"ip_address":"","comment_id":145654,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572337261","product_id":100034101,"comment_content":"我把程序打印输出的 First 和 follow 集合整理如下（其实打印输出还包含一些中间节点，这里就不展示了）：<br><br>这段下面的图中 assign1 的First 集合应该包含 Epsilon","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472512,"discussion_content":"你说的没错。谢谢你的细心！\n带1的非终结符（assign1, equal1, rel1, add1, mul1）的First结合的都包含Epsilon。\n运行LLParser.java会输出正确的First集合。\n我让编辑同学改一下图。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586929426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143807,"user_name":"余晓飞","can_delete":false,"product_type":"c1","uid":1007370,"ip_address":"","ucode":"EEC632FF776327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/0a/7f9c476b.jpg","comment_is_top":false,"comment_ctime":1571794455,"is_pvip":false,"replies":[{"id":"77224","content":"没有写错。<br>是注释没有跟代码同步，少了赋值表达式的规则，已经修改过了。<br>运行LLParser，可以dump这个语法规则。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1586928583,"ip_address":"","comment_id":143807,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571794455","product_id":100034101,"comment_content":"expression  : assign ;<br>assign  : equal | assign1 ;<br>assign1 : &#39;=&#39; equal assign1 | ε;  <br><br>文中这里第二行 assign 是不写错了？<br>我看代码SimpleGrammar.java中有这一行GrammarNode assign = exp.createChild(&quot;assign&quot;, GrammarNodeType.And);<br>注释中刚好缺了关于assign的内容。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471698,"discussion_content":"没有写错。\n是注释没有跟代码同步，少了赋值表达式的规则，已经修改过了。\n运行LLParser，可以dump这个语法规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586928583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137995,"user_name":"余晓飞","can_delete":false,"product_type":"c1","uid":1007370,"ip_address":"","ucode":"EEC632FF776327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/0a/7f9c476b.jpg","comment_is_top":false,"comment_ctime":1569973979,"is_pvip":false,"replies":[{"id":"53841","content":"你看得很细。上下两个图没配起来，两张图用的语法规则是不同的，插图的时候插错了，而且推导过程跳了步骤，我修改一下！<br>多谢你帮我发现！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570679593,"ip_address":"","comment_id":137995,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569973979","product_id":100034101,"comment_content":"下图是上述推导过程建立起来的 AST，“1、2、3……”等编号是 AST 节点创建的顺序<br>对这段话后前后两幅图有疑惑，前面一副图中的第4行是怎么直接到第5行的，<br>如果通过下面右递归版的产生式推导似乎省略了一步？<br>add -&gt; mul | mul + add<br>mul -&gt; pri | pri * mul<br>pri -&gt; Id | Num | (add) <br><br>后面一幅图中节点8, 9, 10在节点12, 13之前生成，似乎这与前一幅图第6到8行的展开顺序不一致？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469340,"discussion_content":"你看得很细。上下两个图没配起来，两张图用的语法规则是不同的，插图的时候插错了，而且推导过程跳了步骤，我修改一下！\n多谢你帮我发现！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570679593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137927,"user_name":"余晓飞","can_delete":false,"product_type":"c1","uid":1007370,"ip_address":"","ucode":"EEC632FF776327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/0a/7f9c476b.jpg","comment_is_top":false,"comment_ctime":1569924185,"is_pvip":false,"replies":[{"id":"53863","content":"没错，mul展开成mul*pri。笔误了。多谢指出！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570697586,"ip_address":"","comment_id":137927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569924185","product_id":100034101,"comment_content":"这样就形成了四条搜索路径，分别是 mul+mul、add+mul+mul、add+pri 和 add+mul+pri。<br>这里最后一个是不是应该为add+mul*pri","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469312,"discussion_content":"没错，mul展开成mul*pri。笔误了。多谢指出！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570697586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135397,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1569145857,"is_pvip":false,"replies":[{"id":"54562","content":"这句看不懂？我抽空多加点注释。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1571107560,"ip_address":"","comment_id":135397,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569145857","product_id":100034101,"comment_content":"https:&#47;&#47;github.com&#47;RichardGong&#47;PlayWithCompiler&#47;blob&#47;master&#47;lab&#47;16-18&#47;src&#47;main&#47;java&#47;play&#47;parser&#47;LLParser.java#L242","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468174,"discussion_content":"这句看不懂？我抽空多加点注释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571107560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}