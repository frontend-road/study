{"id":738641,"title":"09｜有状态的Response：实现Session传递与Keep-alive","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上节课我们已经实现对URI里路径的解析，用于适配GET请求时，将参数代入请求地址的情况，而且在请求参数中引入了Cookie与Session，为HTTP引入状态，存储用户的相关信息。但我也提到了，我们暂未在Response返回参数中回写Session信息，所以客户端程序没办法接受这个信息，自然也无法再回传给Server，这是我们接下来要改造的方向。</p><p>此外，现在我们对一个Socket的管理是这样的：建立一个Socket，交给Processor处理，当Processor处理完毕后随即把这个Socket关闭。这样也引出一个问题：一个网页的页面上可能有很多模块，每次都需要访问服务器拿到相应资源，导致本可以使用同一个Socket解决的问题，却需要创建多个Socket，这是对资源的浪费，所以这节课我们也来探讨一下用什么技术来解决这个问题。</p><p>接下来我们一起来动手实现。</p><h2>项目结构</h2><p>这节课我们先只引入了一个工具类CookieTools，用来处理Cookie，其余项目结构并没有发生改变，你可以参考我给出的目录。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ CookieTools.java\n│  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpHeader.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpRequest.java\n│  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  ├─ HttpResponse.java\n│  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionFacade.java\n│  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  │  ├─ TestServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><h2>有状态的Response</h2><p>上节课我们已经构造了Session，但我们没把它存放到Response返回参数里。所以客户端获取不到这个信息，也就没法再回传给Server。接下来我们开始一步步改造，让Response也拥有状态。</p><p>首先是添加CookieTools.java类，这个类主要用于提供Cookie处理工具类。你可以看一下示例代码。</p><pre><code class=\"language-java\">public class CookieTools {\n    public static String getCookieHeaderName(Cookie cookie) {\n        return \"Set-Cookie\";\n    }\n    public static void getCookieHeaderValue(Cookie cookie, StringBuffer buf) {\n        String name = cookie.getName();\n        if (name == null)\n            name = \"\";\n        String value = cookie.getValue();\n        if (value == null)\n            value = \"\";\n        buf.append(name);\n        buf.append(\"=\");\n        buf.append(value);\n    }\n    static void maybeQuote (int version, StringBuffer buf,String value){\n        if (version == 0 || isToken (value))\n            buf.append (value);\n        else {\n            buf.append ('\"');\n            buf.append (value);\n            buf.append ('\"');\n        }\n    }\n    private static final String tspecials = \"()&lt;&gt;@,;:\\\\\\\"/[]?={} \\t\";\n    private static boolean isToken (String value) {\n        int len = value.length ();\n        for (int i = 0; i &lt; len; i++) {\n            char c = value.charAt (i);\n            if (c &lt; 0x20 || c &gt;= 0x7f || tspecials.indexOf (c) != -1)\n                return false;\n        }\n        return true;\n    }\n}\n</code></pre><p>通过代码可以知道，这个工具类主要是用来快速获取Cookie对应的取值，这里我就不多说了。</p><p>为了更好地适配对HTTP协议的解析，DefaultHeaders类和HttpRequest类中的代码也要一并调整。首先是调整DefaultHeaders类中，COOKIE_NAME与JSESSIONID_NAME的值。</p><pre><code class=\"language-java\">package server;\npublic class DefaultHeaders {\n    static final String COOKIE_NAME = \"cookie\";\n    static final String JSESSIONID_NAME = \"jsessionid\";\n}\n</code></pre><p>对应HttpRequest类中parseRequestLine方法也要进行调整。</p><pre><code class=\"language-java\">package server;\npublic class HttpRequest implements HttpServletRequest {\n    private void parseRequestLine() {\n        int question = requestLine.indexOf(\"?\");\n        if (question &gt;= 0) {\n            queryString = new String(requestLine.uri, question + 1, requestLine.uriEnd - question - 1);\n            uri = new String(requestLine.uri, 0, question);\n            String tmp = \";\" + DefaultHeaders.JSESSIONID_NAME + \"=\";\n            int semicolon = uri.indexOf(tmp);\n            if (semicolon &gt;= 0) {\n                sessionid = uri.substring(semicolon+tmp.length());\n                uri = uri.substring(0, semicolon);\n            }\n        } else {\n            queryString = null;\n            uri = new String(requestLine.uri, 0, requestLine.uriEnd);\n            String tmp = \";\" + DefaultHeaders.JSESSIONID_NAME + \"=\";\n            int semicolon = uri.indexOf(tmp);\n            if (semicolon &gt;= 0) {\n                sessionid = uri.substring(semicolon+tmp.length());\n                uri = uri.substring(0, semicolon);\n            }\n        }\n    }\n}\n</code></pre><p>相比之前，主要调整了下面这段解析。</p><pre><code class=\"language-java\">  uri = new String(requestLine.uri, 0, requestLine.uriEnd);\n  String tmp = \";\" + DefaultHeaders.JSESSIONID_NAME + \"=\";\n  int semicolon = uri.indexOf(tmp);\n  if (semicolon &gt;= 0) {\n    sessionid = uri.substring(semicolon+tmp.length());\n    uri = uri.substring(0, semicolon);\n  }\n</code></pre><p>还有在parseHeaders方法中，获取到header的name之后，增加两行转换代码，确保header都以小写字母进行比较处理。</p><pre><code class=\"language-java\">String name = new String(header.name,0,header.nameEnd);\nString value = new String(header.value, 0, header.valueEnd);\nname = name.toLowerCase();\n</code></pre><p>上述是我们要做的些许前置准备工作，接下来让我们把目光投向HttpResponse类，看看如何将Request请求内获取的Cookie与Server生成的Session传入Response返回参数内，让Client也能获取到。</p><p>HttpRespose返回类中需要调整的核心方法是sendHeaders，通过这个方法把参数设置到Response返回头内，你可以看一下调整后的代码，未改变的部分没有在这里列举出来。</p><pre><code class=\"language-java\">package server;\npublic class HttpResponse implements HttpServletResponse {\n    ArrayList&lt;Cookie&gt; cookies = new ArrayList&lt;&gt;();\n    \n    public void sendHeaders() throws IOException {\n        PrintWriter outputWriter = getWriter();\n        outputWriter.print(this.getProtocol());\n        outputWriter.print(\" \");\n        outputWriter.print(status);\n        if (message != null) {\n            outputWriter.print(\" \");\n            outputWriter.print(message);\n        }\n        outputWriter.print(\"\\r\\n\");\n        if (getContentType() != null) {\n            outputWriter.print(\"Content-Type: \" + getContentType() + \"\\r\\n\");\n        }\n        if (getContentLength() &gt;= 0) {\n            outputWriter.print(\"Content-Length: \" + getContentLength() + \"\\r\\n\");\n        }\n        Iterator&lt;String&gt; names = headers.keySet().iterator();\n        while (names.hasNext()) {\n            String name = names.next();\n            String value = headers.get(name);\n            outputWriter.print(name);\n            outputWriter.print(\": \");\n            outputWriter.print(value);\n            outputWriter.print(\"\\r\\n\");\n        }\n        HttpSession session = this.request.getSession(false);\n        if (session != null) {\n            Cookie cookie = new Cookie(DefaultHeaders.JSESSIONID_NAME, session.getId());\n            cookie.setMaxAge(-1);\n            addCookie(cookie);\n        }\n        synchronized (cookies) {\n            Iterator&lt;Cookie&gt; items = cookies.iterator();\n            while (items.hasNext()) {\n                Cookie cookie = (Cookie) items.next();\n                outputWriter.print(CookieTools.getCookieHeaderName(cookie));\n                outputWriter.print(\": \");\n                StringBuffer sbValue = new StringBuffer();\n                CookieTools.getCookieHeaderValue(cookie, sbValue);\n                System.out.println(\"set cookie jsessionid string : \"+sbValue.toString());\n                outputWriter.print(sbValue.toString());\n                outputWriter.print(\"\\r\\n\");\n            }\n        }\n        outputWriter.print(\"\\r\\n\");\n        outputWriter.flush();\n   }\n   \n    @Override\n    public void addCookie(Cookie cookie) {\n      synchronized (cookies) {\n          cookies.add(cookie);\n      }\n}\n   // 省略其他 getter 和 setter 方法\n</code></pre><p>根据Servlet规范，Response的Header中 Set-Cookie需要满足下面的格式，任选一种即可。</p><ul>\n<li><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</code></li>\n<li><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;</code></li>\n<li><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;number&gt;</code></li>\n<li><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;</code></li>\n<li><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;</code></li>\n<li><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure</code></li>\n</ul><p>在当前的Server中，我们就使用了最基本的格式：<code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</code>。参考设置如下：</p><pre><code class=\"language-plain\">Set-Cookie: jsessionid=FA73014B317A489994D0B394F4EBF4EA\n</code></pre><p>就像上述sendHeaders方法里代码展示的，我们增加了一段代码，在Set-Cookie中把Session信息带入进去。</p><pre><code class=\"language-java\">HttpSession session = this.request.getSession(false);\nif (session != null) {\n    Cookie cookie = new Cookie(DefaultHeaders.JSESSIONID_NAME, session.getId());\n    cookie.setMaxAge(-1);\n    addCookie(cookie);\n}\nsynchronized (cookies) {\n    Iterator&lt;Cookie&gt; items = cookies.iterator();\n    while (items.hasNext()) {\n        Cookie cookie = (Cookie) items.next();\n        outputWriter.print(CookieTools.getCookieHeaderName(cookie));\n        outputWriter.print(\": \");\n        StringBuffer sbValue = new StringBuffer();\n        CookieTools.getCookieHeaderValue(cookie, sbValue);\n        System.out.println(\"set cookie jsessionid string : \"+sbValue.toString());\n        outputWriter.print(sbValue.toString());\n        outputWriter.print(\"\\r\\n\");\n    }\n}\n</code></pre><p>这样，我们就做到了<strong>在返回给客户端的信息中带有用户相关信息</strong>，之后如果客户端再发请求，就可以把这些用户信息再回传，后端处理的时候就不再需要重新获取用户相关信息，而是可以直接拿到，这样就可以把多次没有上下文关联的HTTP访问打包成同一个用户访问。</p><h2>Socket重复使用</h2><p>接下来我们再粗浅地探讨一下另外一个问题，就像前面提到的，我们目前对Socket的使用比较简单，Processor处理完毕后随即就关闭，这样在页面请求资源比较多的时候，就会成为系统的性能瓶颈。因为这需要每次访问中打开连接和关闭连接。</p><p>在HTTP协议1.1版本中支持了可持续的连接，而且是默认的方式，在Request请求头中可以展现。</p><pre><code class=\"language-java\">connection: keep-alive\n</code></pre><p>在持续的连接中，服务器不会关闭Socket，这样一个网页的相关资源在发请求时可以共用一个Socket。所以在客户端和服务器端之间会有多次的请求流和返回流的交互，这样又会产生一个新的问题，就是我们怎么知道什么时候应该关闭它呢？答案是传输完毕后，通过一个头信息告知对方可以关闭了。</p><pre><code class=\"language-plain\">connection: close\n</code></pre><p>还有，对一次请求和返回的交互，对于动态生成的内容我们也无法获取Content-Length的数值，客户端怎么知道服务器返回的数据传完了呢？之前把这个值固定写死只适用于简单的返回固定内容的场景。</p><p>HTTP协议也考虑到了这一点，在1.1版本中，采用了一个特殊的头部信息transfer-encoding，来表明数据流采用分块（chunk）的方式进行发送传输。</p><pre><code class=\"language-plain\">Transfer-Encoding: chunked\n</code></pre><p>你可以看一下传输的数据格式的定义。</p><pre><code class=\"language-plain\">[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n] …… [chunk size = 0][\\r\\n][\\r\\n]\n</code></pre><p>这种格式我们在这里简单解释一下。</p><ol>\n<li>编码是由若干个块组成，由一个标明长度为0的块结束，也就是说，检测到 <code>chunk size = 0</code> 表示数据流已传输完毕。</li>\n<li>每个chunk有两部分组成，第一部分是这个分块的长度，第二部分则是前一部分指定长度对应的内容，每个部分用CRLF换行符隔开。</li>\n<li>结束时只标识CRLF。</li>\n</ol><p>我们用下面这个示意图可以更好地展示数据传输的格式。</p><pre><code class=\"language-plain\">分块的长度 —— chunk size ｜ CRLF\n分块的数据 —— chunk data ｜ CRLF\n分块的长度 —— chunk size ｜ CRLF\n分块的数据 —— chunk data ｜ CRLF\n       ……  // 此处省略\n分块的长度 —— chunk size ｜ CRLF\n分块的数据 —— chunk data ｜ CRLF\n分块的长度 —— 0 ｜ CRLF\n结束标识符 —— CRLF\n</code></pre><p>有了固定格式之后，就可以按照规定，一部分一部分地发送数据了。也因为分块的存在，我们今后就不需要考虑content length这个值了。</p><p>这里我给出了一个响应包的参考示例，你可以看一下。</p><pre><code class=\"language-plain\">HTTP/1.1 200 OK\nContent-Type: text/plain\nTransfer-Encoding: chunked\n\n35\nThis is the data in the first chunk\n26\nand this is the second one\n3\ncon\n8\nsequence\n0\n</code></pre><p>其中的道理我们理解了之后，接下来我们就可以开始着手改造代码了。在代码里面，我们只是在Processor中加上Keep-alive的判断，决定是否关闭Socket。因为是一个粗浅的探讨，所以我们没有真的按照chunk的模式回送response。后面我们也没有实现，探讨这一部分内容主要是为了了解原理。</p><p>你可以看一下需要调整的代码。</p><pre><code class=\"language-java\">package server;\npublic class HttpProcessor implements Runnable{\n    private Socket socket;\n    private boolean available = false;\n    private HttpConnector connector;\n    private int serverPort = 0;\n    private boolean keepAlive = false;\n    private boolean http11 = true;\n\n    public void process(Socket socket) {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = socket.getInputStream();\n            output = socket.getOutputStream();\n            keepAlive = true;\n            while (keepAlive) {\n                // create Request object and parse\n                HttpRequest request = new HttpRequest(input);\n                request.parse(socket);\n                // handle session\n                if (request.getSessionId() == null || request.getSessionId().equals(\"\")) {\n                    request.getSession(true);\n                }\n                // create Response object\n                HttpResponse response = new HttpResponse(output);\n                response.setRequest(request);\n//               response.sendStaticResource();\n                request.setResponse(response);\n                try {\n                    response.sendHeaders();\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n                // check if this is a request for a servlet or a static resource\n                // a request for a servlet begins with \"/servlet/\"\n                if (request.getUri().startsWith(\"/servlet/\")) {\n                    ServletProcessor processor = new ServletProcessor();\n                    processor.process(request, response);\n                }\n                else {\n                    StaticResourceProcessor processor = new StaticResourceProcessor();\n                    processor.process(request, response);\n                }\n                finishResponse(response);\n                System.out.println(\"response header connection------\"+response.getHeader(\"Connection\"));\n                if (\"close\".equals(response.getHeader(\"Connection\"))) {\n                    keepAlive = false;\n                }\n            }\n            // Close the socket\n            socket.close();\n            socket = null;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    private void finishResponse(HttpResponse response) {\n        response.finishResponse();\n    }\n}\n</code></pre><p>我们来分析一下这段代码，一个小变动在于新增了serverPort、keepAlive与http11三个域，而且为了更好的安全性，都用private关键字修饰。而核心改动在于<strong>process方法</strong>，把里面的多数方法放置在while循环之中，使用keepAlive变量控制，如果检测到response的头部信息是close，那么就把keepAlive设置成false，退出循环，关闭Socket。</p><p>而客户端也可以在请求头中加上Connection: close指定要关闭连接，因此HttpRequest的parseHeaders方法内也可以进行调整，现在HttpRequest中将parseHeaders方法调整成下面这个样子了。</p><pre><code class=\"language-java\">else if (name.equals(DefaultHeaders.CONNECTION_NAME)) {\n    headers.put(name, value);\n    if (value.equals(\"close\")) {\n        response.setHeader(\"Connection\", \"close\");\n    }\n</code></pre><p>增加了是否为close的判断，用来设置请求头。<br>\nHttpRequest还有其他调整：新增域和setter方法，其他未改动的部分我就不在这里列出了。</p><pre><code class=\"language-java\">package server；\npublic class HttpRequest implements HttpServletRequest {\n    private HttpResponse response;\n    public HttpRequest() {\n    }\n    public void setStream(InputStream input) {\n        this.input = input;\n        this.sis = new SocketInputStream(this.input, 2048);\n    }\n    public void setResponse(HttpResponse response) {\n        this.response = response;\n    }&nbsp; &nbsp;\n} &nbsp; &nbsp; &nbsp;\n</code></pre><p>再看HttpResponse类的调整。</p><pre><code class=\"language-java\">package server；\npublic class HttpResponse implements HttpServletResponse {\n    String characterEncoding = \"UTF-8\";\n    public HttpResponse() {\n    }\n    public void setStream(OutputStream output) {\n        this.output = output;\n    }\n    //提供这个方法完成输出\n    public void finishResponse() {\n      try {\n          this.getWriter().flush();\n      } catch (IOException e) {\n          e.printStackTrace();\n      }\n   }\n}\n</code></pre><p>而HttpProcessor类，就要调用HttpResponse中的finishResponse方法，这是因为我们修改了一下时序，在ServletProcessor中不管header头处理了，只调用 <code>servlet.service(requestFacade, responseFacade)</code> 这一方法。</p><p>过去我们在ServletProcessor中初始化ClassLoader，现在把类加载器改写成全局可用的，把初始化放在HttpConnector里。</p><p>所以接下来我们要改写ServletProcessor、HttpConnector两个类。</p><p>HttpConnector主要修改如下：</p><pre><code class=\"language-java\">package server;\npublic class HttpConnector implements Runnable {\n    int minProcessors = 3;\n    int maxProcessors = 10;\n    int curProcessors = 0;\n    Deque&lt;HttpProcessor&gt; processors = new ArrayDeque&lt;&gt;();\n    public static Map&lt;String, HttpSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();\n    //一个全局的class loader\n    public static URLClassLoader loader = null;\n    public void run() {\n        ServerSocket serverSocket = null;\n        int port = 8080;\n        try {\n            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        try {\n            //class loader初始化\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(HttpServer.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        }\n        catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n        // initialize processors pool\n        for (int i = 0; i &lt; minProcessors; i++) {\n            HttpProcessor initprocessor = new HttpProcessor(this);\n            initprocessor.start();\n            processors.push(initprocessor);\n        }\n        curProcessors = minProcessors;\n        while (true) {\n            Socket socket = null;\n            try {\n                socket = serverSocket.accept();\n                HttpProcessor processor = createProcessor();\n                if (processor == null) {\n                    socket.close();\n                    continue;\n                }\n                processor.assign(socket);\n                // Close the socket\n//                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><p>HttpConnector新增了loader变量，还将下面这段代码从ServletProcessor中移除了。</p><pre><code class=\"language-java\">        try {\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(HttpServer.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        }\n        catch (IOException e) {\n            System.out.println(e.toString());\n        }\n</code></pre><p>因此ServletProcessor的调整就比较简单了，将servletClass变量的赋值，直接交由HttpConnector处理，而且不再需要调用 <code>response.sendHeaders</code> 方法，你可以看一下当前ServletProcessor的代码。</p><pre><code class=\"language-java\">package server;\npublic class ServletProcessor {\n    public void process(HttpRequest request, HttpResponse response) {\n        String uri = request.getUri();\n        String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n        response.setCharacterEncoding(\"UTF-8\");\n        Class&lt;?&gt; servletClass = null;\n        try {\n            servletClass = HttpConnector.loader.loadClass(servletName);\n        }\n        catch (ClassNotFoundException e) {\n            System.out.println(e.toString());\n        }\n        Servlet servlet = null;\n        try {\n            servlet = (Servlet) servletClass.newInstance();\n            HttpRequestFacade requestFacade = new HttpRequestFacade(request);\n            HttpResponseFacade responseFacade = new HttpResponseFacade(response);\n            System.out.println(\"Call Service()\");\n            servlet.service(requestFacade, responseFacade);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n    }\n}\n</code></pre><p>可以看到，这个类变简单了。</p><h2>测试</h2><p>这节课我们还是在 <code>src/test/java/test</code> 目录下使用TestServlet进行测试，这一次我们改写doGet方法。</p><pre><code class=\"language-java\">package test;\npublic class TestServlet extends HttpServlet{\n    static int count = 0;\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        System.out.println(\"Enter doGet()\");\n        System.out.println(\"parameter name : \"+request.getParameter(\"name\"));\n        TestServlet.count++;\n        System.out.println(\"::::::::call count ::::::::: \" + TestServlet.count);\n        if (TestServlet.count &gt; 2) {\n            response.addHeader(\"Connection\", \"close\");\n        }\n        HttpSession session = request.getSession(true);\n        String user = (String) session.getAttribute(\"user\");\n        System.out.println(\"get user from session : \" + user);\n        if (user == null || user.equals(\"\")) {\n            session.setAttribute(\"user\", \"yale\");\n        }\n        response.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Test 你好\" + \"&lt;/h1&gt;\\n\";\n        System.out.println(doc);\n        response.getWriter().println(doc);\n    }\n    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        System.out.println(\"Enter doGet()\");\n        System.out.println(\"parameter name : \"+request.getParameter(\"name\"));\n        response.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Test 你好\" + \"&lt;/h1&gt;\\n\";\n        System.out.println(doc);\n        response.getWriter().println(doc);\n    }\n}\n</code></pre><p>我们在TestServlet里面用一个静态全局计数器，如果是第三次以上，就把头部信息设置为 <code>Connection:close</code> 。这样从浏览器里可以看到，第一次第二次访问之后，数据返回但是浏览器连接没有停，第三次后才停下来。这说明keepAlive参数生效了。但是我们要知道这些探讨都是粗浅的，代码只是演示了这个概念，我们没有完整实现Keep-alive以及Chunked。</p><h2>小结</h2><p>这节课我们将无状态的HTTP连接改造成了有状态的连接，这是通过Cookie和Session来实现的。具体来讲，首次访问后，在Response返回头信息中就带上jsessionid和Cookie信息，传到客户浏览器端后，再次提交的时候，浏览器带上jsessionid传回给服务器，用同一个jsessionid代表了同一个会话。这样，从用户来看，浏览器服务器多次往返交互就是在一个会话中，从效果上就是把无状态连接变成有状态连接。</p><p>然后我们简单探讨了一下Keep-alive和chunked模式，让同一个Socket可以用于多次访问，减少了Socket的连接和关闭。但是我们实际实现中对这个的支持并不充分，后面也没有用到。</p><p>本节课完整代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter09\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter09</a></p><h2>思考题</h2><p>学完了这节课的内容，我们可以试着练习一下：写一段代码，按照chunked模式返回响应内容。</p><p>欢迎你把你写的代码分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":386007,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1703833563,"is_pvip":false,"replies":[{"id":140707,"content":"你可能有点纠结了，我是讲Tomcat原理，所以会提到keep-alive，其实，你现在可以不用深究这个，知道就行，因为现在全部都是keep-alive。想了解http协议，看看《图解http》就挺好，要研究它，看看《http权威指南》","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704027046,"ip_address":"湖南","comment_id":386007,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"在补充一点\n3、while (keepAlive) 为了保持 socket 存活， 会影响非 keep-alive 的请求， 导致死循环。 这块内容老师是否有好的书籍推荐或者以后有加餐， 这样我们可以进行深一层次的探索。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634823,"discussion_content":"你可能有点纠结了，我是讲Tomcat原理，所以会提到keep-alive，其实，你现在可以不用深究这个，知道就行，因为现在全部都是keep-alive。想了解http协议，看看《图解http》就挺好，要研究它，看看《http权威指南》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704027046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634835,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704065112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634823,"ip_address":"广东","group_id":0},"score":634835,"extra":""}]}]},{"had_liked":false,"id":386005,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1703832102,"is_pvip":false,"replies":[{"id":140706,"content":"1，双方都可以控制\n2，chunked现在是常用的，http1.1默认就是keep-alive，要表示http完毕或者指定长度或者用chunked。你注意看一下浏览器network返回，应该都是chunked，这个并不是对应于什么特定场合。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704026791,"ip_address":"湖南","comment_id":386005,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"老师， 我有几个问题\n1、服务器端和客户端双方是否都可以控制 close Connection 和使用 chunked 传输？\n2、chunked 应用场景有哪些？  目前想到大文件传输， 在现有代码基础上， 自己动手尝试了客户端传输小量文本数据， 客户端多次使用socket 请求服务端， 但服务端并非收到一次请求就返回一次结果， finishResponse 之后也是无法收到服务端返回的结果， 必须 close Connection 才能收到服务端的请求，并且是多次请求合并返回的结果； 这跟我想的有点不一样， 我想的是这个复用的 socket 然后请求一次就返回一次结果， 然后客户端进行处理， 比如客户端请求一个js、一个 css、一个 html， 是需要  close Connection 之后才能返回吗？ 不知道是哪方面想的不对， 还得老师指点。 ","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634822,"discussion_content":"1，双方都可以控制\n2，chunked现在是常用的，http1.1默认就是keep-alive，要表示http完毕或者指定长度或者用chunked。你注意看一下浏览器network返回，应该都是chunked，这个并不是对应于什么特定场合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704026791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634836,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704065429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634822,"ip_address":"广东","group_id":0},"score":634836,"extra":""}]}]},{"had_liked":false,"id":385935,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1703686814,"is_pvip":false,"replies":[{"id":140710,"content":"keep-alive是浏览器给定的，现在已经是默认的了。\ntest是包名，你看看你的java里面的package。业务程序方面的问题，只有靠你自己慢慢调试了。\n","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704027458,"ip_address":"湖南","comment_id":385935,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：Http请求头中的“connection: keep-alive”是谁控制的？\n该部分是浏览器填的，浏览器是自动填的吗？在填的时候是否受到了服务器的控制？\nQ2：静态访问不能返回内容\n本课程代码，运行后在浏览器中输入：http:&#47;&#47;localhost:8080&#47;hello.txt\n浏览器上没有任何输出，空白，为什么？\n\nQ3：错误的servlet网址也能返回\n访问地址：http:&#47;&#47;localhost:8080&#47;servlet&#47;test.HelloServlet，此网址是不小心敲错了，在ServletProcessor.java中打印出来的servletName就是test.HelloServlet，接下来的代码“servletClass = HttpConnector.loader.loadClass(servletName);”竟然没有报错，代码中只有HelloServlet和TestServlet，并没有test.HelloServlet，为什么loadClass还能成功？\n\n浏览器上显示的内容是“Hello World 你好”，根据此内容推测，应该是用了HelloServlet。但我在HelloServlet的输出中，随便增加字符：&quot;Hello World 111你好123&quot; ，重新编译运行，\n但浏览器上显示的还是“Hello World 你好”，为什么？\n\nQ4：小问题：HelloServlet.java中也多了一个导包语句。\n“import jdk.internal.util.xml.impl.Pair;”\n估计和上节课的一样，也是IDE自动导入的，我已注释掉该代码。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634827,"discussion_content":"keep-alive是浏览器给定的，现在已经是默认的了。\ntest是包名，你看看你的java里面的package。业务程序方面的问题，只有靠你自己慢慢调试了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704027458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385909,"user_name":"top啦它","can_delete":false,"product_type":"c1","uid":2568744,"ip_address":"上海","ucode":"1F2656293D1B9F","user_header":"https://static001.geekbang.org/account/avatar/00/27/32/28/078ec46c.jpg","comment_is_top":false,"comment_ctime":1703650205,"is_pvip":false,"replies":[{"id":140671,"content":"听一下你的建议","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1703821397,"ip_address":"湖南","comment_id":385909,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"后面要手写什么？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634699,"discussion_content":"听一下你的建议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703821397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":2568744,"avatar":"https://static001.geekbang.org/account/avatar/00/27/32/28/078ec46c.jpg","nickname":"top啦它","note":"","ucode":"1F2656293D1B9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634706,"discussion_content":"mq","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703824060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634699,"ip_address":"上海","group_id":0},"score":634706,"extra":""}]},{"author":{"id":1786951,"avatar":"","nickname":"Geek_50a5cc","note":"","ucode":"0F6C1C2552261F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635133,"discussion_content":"redis","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704437331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394005,"user_name":"wild wings.Luv","can_delete":false,"product_type":"c1","uid":3790749,"ip_address":"上海","ucode":"D76D40B24B4998","user_header":"https://static001.geekbang.org/account/avatar/00/39/d7/9d/73390cc0.jpg","comment_is_top":false,"comment_ctime":1725526327,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"socket没有关闭。但是同一个用户的下一个http请求，需要找到对应的socket吗，还是不需要？","like_count":0},{"had_liked":false,"id":389712,"user_name":"Geek_320730","can_delete":false,"product_type":"c1","uid":3035552,"ip_address":"北京","ucode":"CF7E6C8E91D2C4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XWv3mvIFORNgRk9wF8QLb9aXfh1Uz1hADtUmlFwQJVxIzhBf8HWc4QqU7iaTzj8wB5p5QJLRAvlQNrOqXtrg1Og/132","comment_is_top":false,"comment_ctime":1713292382,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"按照 chunked 模式返回响应内容: https:&#47;&#47;github.com&#47;kuifir&#47;MiniTomcat&#47;tree&#47;test-chunk","like_count":0}]}