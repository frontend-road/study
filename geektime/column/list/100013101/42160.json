{"id":42160,"title":"33 | 临时对象池sync.Pool","content":"<p>到目前为止，我们已经一起学习了Go语言标准库中最重要的那几个同步工具，这包括非常经典的互斥锁、读写锁、条件变量和原子操作，以及Go语言特有的几个同步工具：</p><ol>\n<li><code>sync/atomic.Value</code>；</li>\n<li><code>sync.Once</code>；</li>\n<li><code>sync.WaitGroup</code></li>\n<li><code>context.Context</code>。</li>\n</ol><p>今天，我们来讲Go语言标准库中的另一个同步工具：<code>sync.Pool</code>。</p><p><code>sync.Pool</code>类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与Go语言的很多同步工具一样，<code>sync.Pool</code>类型也属于结构体类型，它的值在被真正使用之后，就不应该再被复制了。</p><p>这里的“临时对象”的意思是：不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在任何时候发生，并且完全不会影响到程序的功能。</p><p>同时，它们也应该是无需被区分的，其中的任何一个值都可以代替另一个。如果你的某类值完全满足上述条件，那么你就可以把它们存储到临时对象池中。</p><p>你可能已经想到了，我们可以把临时对象池当作针对某种数据的缓存来用。实际上，在我看来，临时对象池最主要的用途就在于此。</p><p><code>sync.Pool</code>类型只有两个方法——<code>Put</code>和<code>Get</code>。Put用于在当前的池中存放临时对象，它接受一个<code>interface{}</code>类型的参数；而Get则被用于从当前的池中获取临时对象，它会返回一个<code>interface{}</code>类型的值。</p><!-- [[[read_end]]] --><p>更具体地说，这个类型的<code>Get</code>方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，那么这个方法就会使用当前池的<code>New</code>字段创建一个新值，并直接将其返回。</p><p><code>sync.Pool</code>类型的<code>New</code>字段代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：<code>func() interface{}</code>。</p><p>这个函数是<code>Get</code>方法最后的临时对象获取手段。<code>Get</code>方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结果值并不会被存入当前的临时对象池中，而是直接返回给<code>Get</code>方法的调用方。</p><p>这里的<code>New</code>字段的实际值需要我们在初始化临时对象池的时候就给定。否则，在我们调用它的<code>Get</code>方法的时候就有可能会得到<code>nil</code>。所以，<code>sync.Pool</code>类型并不是开箱即用的。不过，这个类型也就只有这么一个公开的字段，因此初始化起来也并不麻烦。</p><p>举个例子。标准库代码包<code>fmt</code>就使用到了<code>sync.Pool</code>类型。这个包会创建一个用于缓存某类临时对象的<code>sync.Pool</code>类型值，并将这个值赋给一个名为<code>ppFree</code>的变量。这类临时对象可以识别、格式化和暂存需要打印的内容。</p><pre><code>var ppFree = sync.Pool{\n New: func() interface{} { return new(pp) },\n}\n</code></pre><p>临时对象池<code>ppFree</code>的<code>New</code>字段在被调用的时候，总是会返回一个全新的<code>pp</code>类型值的指针（即临时对象）。这就保证了<code>ppFree</code>的<code>Get</code>方法总能返回一个可以包含需要打印内容的值。</p><p><code>pp</code>类型是<code>fmt</code>包中的私有类型，它有很多实现了不同功能的方法。不过，这里的重点是，它的每一个值都是独立的、平等的和可重用的。</p><blockquote>\n<p><span class=\"reference\">更具体地说，这些对象既互不干扰，又不会受到外部状态的影响。它们几乎只针对某个需要打印内容的缓冲区而已。由于<code>fmt</code>包中的代码在真正使用这些临时对象之前，总是会先对其进行重置，所以它们并不在意取到的是哪一个临时对象。这就是临时对象的平等性的具体体现。</span></p>\n</blockquote><p>另外，这些代码在使用完临时对象之后，都会先抹掉其中已缓冲的内容，然后再把它存放到<code>ppFree</code>中。这样就为重用这类临时对象做好了准备。</p><p>众所周知的<code>fmt.Println</code>、<code>fmt.Printf</code>等打印函数都是如此使用<code>ppFree</code>，以及其中的临时对象的。因此，在程序同时执行很多的打印函数调用的时候，<code>ppFree</code>可以及时地把它缓存的临时对象提供给它们，以加快执行的速度。</p><p>而当程序在一段时间内不再执行打印函数调用时，<code>ppFree</code>中的临时对象又能够被及时地清理掉，以节省内存空间。</p><p>显然，在这个维度上，临时对象池可以帮助程序实现可伸缩性。这就是它的最大价值。</p><p>我想，到了这里你已经清楚了临时对象池的基本功能、使用方式、适用场景和存在意义。我们下面来讨论一下它的一些内部机制，这样，我们就可以更好地利用它做更多的事。</p><p>首先，我来问你一个问题。这个问题很可能也是你想问的。今天的问题是：为什么说临时对象池中的值会被及时地清理掉？</p><p>这里的典型回答是：因为，Go语言运行时系统中的垃圾回收器，所以在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。</p><h2>问题解析</h2><p>我在前面已经向你讲述了临时对象会在什么时候被创建，下面我再来详细说说它会在什么时候被销毁。</p><p><code>sync</code>包在被初始化的时候，会向Go语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值。我们可以把它称为池清理函数。</p><p>一旦池清理函数被注册到了Go语言运行时系统，后者在每次即将执行垃圾回收时就都会执行前者。</p><p>另外，在<code>sync</code>包中还有一个包级私有的全局变量。这个变量代表了当前的程序中使用的所有临时对象池的汇总，它是元素类型为<code>*sync.Pool</code>的切片。我们可以称之为池汇总列表。</p><p>通常，在一个临时对象池的<code>Put</code>方法或<code>Get</code>方法第一次被调用的时候，这个池就会被添加到池汇总列表中。正因为如此，池清理函数总是能访问到所有正在被真正使用的临时对象池。</p><p>更具体地说，池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为<code>nil</code>，然后再把这个池中的所有本地池列表都销毁掉。</p><p>最后，池清理函数会把池汇总列表重置为空的切片。如此一来，这些池中存储的临时对象就全部被清除干净了。</p><p>如果临时对象池以外的代码再无对它们的引用，那么在稍后的垃圾回收过程中，这些临时对象就会被当作垃圾销毁掉，它们占用的内存空间也会被回收以备他用。</p><p>以上，就是我对临时对象清理的进一步说明。首先需要记住的是，池清理函数和池汇总列表的含义，以及它们起到的关键作用。一旦理解了这些，那么在有人问到你这个问题的时候，你应该就可以从容地应对了。</p><p>不过，我们在这里还碰到了几个新的词，比如：私有临时对象、共享临时对象列表和本地池。这些都代表着什么呢？这就涉及了下面的问题。</p><h2>知识扩展</h2><h3>问题1：临时对象池存储值所用的数据结构是怎样的？</h3><p>在临时对象池中，有一个多层的数据结构。正因为有了它的存在，临时对象池才能够非常高效地存储大量的值。</p><p>这个数据结构的顶层，我们可以称之为本地池列表，不过更确切地说，它是一个数组。这个列表的长度，总是与Go语言调度器中的P的数量相同。</p><p>还记得吗？Go语言调度器中的P是processor的缩写，它指的是一种可以承载若干个G、且能够使这些G适时地与M进行对接，并得到真正运行的中介。</p><p>这里的G正是goroutine的缩写，而M则是machine的缩写，后者指代的是系统级的线程。正因为有了P的存在，G和M才能够进行灵活、高效的配对，从而实现强大的并发编程模型。</p><p>P存在的一个很重要的原因是为了分散并发程序的执行压力，而让临时对象池中的本地池列表的长度与P的数量相同的主要原因也是分散压力。这里所说的压力包括了存储和性能两个方面。在说明它们之前，我们先来探索一下临时对象池中的那个数据结构。</p><p>在本地池列表中的每个本地池都包含了三个字段（或者说组件），它们是：存储私有临时对象的字段<code>private</code>、代表了共享临时对象列表的字段<code>shared</code>，以及一个<code>sync.Mutex</code>类型的嵌入字段。</p><p><img src=\"https://static001.geekbang.org/resource/image/82/22/825cae64e0a879faba34c0a157b7ca22.png?wh=1168*729\" alt=\"\"><br>\n<strong>sync.Pool中的本地池与各个G的对应关系</strong></p><p>实际上，每个本地池都对应着一个P。我们都知道，一个goroutine要想真正运行就必须先与某个P产生关联。也就是说，一个正在运行的goroutine必然会关联着某个P。</p><p>在程序调用临时对象池的<code>Put</code>方法或<code>Get</code>方法的时候，总会先试图从该临时对象池的本地池列表中，获取与之对应的本地池，依据的就是与当前的goroutine关联的那个P的ID。</p><p>换句话说，一个临时对象池的<code>Put</code>方法或<code>Get</code>方法会获取到哪一个本地池，完全取决于调用它的代码所在的goroutine关联的那个P。</p><p>既然说到了这里，那么紧接着就会有下面这个问题。</p><h3>问题 2：临时对象池是怎样利用内部数据结构来存取值的？</h3><p>临时对象池的<code>Put</code>方法总会先试图把新的临时对象，存储到对应的本地池的<code>private</code>字段中，以便在后面获取临时对象的时候，可以快速地拿到一个可用的值。</p><p>只有当这个<code>private</code>字段已经存有某个值时，该方法才会去访问本地池的<code>shared</code>字段。</p><p>相应的，临时对象池的<code>Get</code>方法，总会先试图从对应的本地池的<code>private</code>字段处获取一个临时对象。只有当这个<code>private</code>字段的值为<code>nil</code>时，它才会去访问本地池的<code>shared</code>字段。</p><p>一个本地池的<code>shared</code>字段原则上可以被任何goroutine中的代码访问到，不论这个goroutine关联的是哪一个P。这也是我把它叫做共享临时对象列表的原因。</p><p>相比之下，一个本地池的<code>private</code>字段，只可能被与之对应的那个P所关联的goroutine中的代码访问到，所以可以说，它是P级私有的。</p><p>以临时对象池的<code>Put</code>方法为例，它一旦发现对应的本地池的<code>private</code>字段已存有值，就会去访问这个本地池的<code>shared</code>字段。当然，由于<code>shared</code>字段是共享的，所以此时必须受到互斥锁的保护。</p><p>还记得本地池嵌入的那个<code>sync.Mutex</code>类型的字段吗？它就是这里用到的互斥锁，也就是说，本地池本身就拥有互斥锁的功能。<code>Put</code>方法会在互斥锁的保护下，把新的临时对象追加到共享临时对象列表的末尾。</p><p>相应的，临时对象池的<code>Get</code>方法在发现对应本地池的<code>private</code>字段未存有值时，也会去访问后者的<code>shared</code>字段。它会在互斥锁的保护下，试图把该共享临时对象列表中的最后一个元素值取出并作为结果。</p><p>不过，这里的共享临时对象列表也可能是空的，这可能是由于这个本地池中的所有临时对象都已经被取走了，也可能是当前的临时对象池刚被清理过。</p><p>无论原因是什么，<code>Get</code>方法都会去访问当前的临时对象池中的所有本地池，它会去逐个搜索它们的共享临时对象列表。</p><p>只要发现某个共享临时对象列表中包含元素值，它就会把该列表的最后一个元素值取出并作为结果返回。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/21/df956fe29f35b41a14f941a9efd80d21.png?wh=1183*675\" alt=\"\"><br>\n<strong>从sync.Pool中获取临时对象的步骤</strong></p><p>当然了，即使这样也可能无法拿到一个可用的临时对象，比如，在所有的临时对象池都刚被大清洗的情况下就会是如此。</p><p>这时，<code>Get</code>方法就会使出最后的手段——调用可创建临时对象的那个函数。还记得吗？这个函数是由临时对象池的<code>New</code>字段代表的，并且需要我们在初始化临时对象池的时候给定。如果这个字段的值是<code>nil</code>，那么<code>Get</code>方法此时也只能返回<code>nil</code>了。</p><p>以上，就是我对这个问题的较完整回答。</p><h2>总结</h2><p>今天，我们一起讨论了另一个比较有用的同步工具——<code>sync.Pool</code>类型，它的值被我称为临时对象池。</p><p>临时对象池有一个<code>New</code>字段，我们在初始化这个池的时候最好给定它。临时对象池还拥有两个方法，即：<code>Put</code>和<code>Get</code>，它们分别被用于向池中存放临时对象，和从池中获取临时对象。</p><p>临时对象池中存储的每一个值都应该是独立的、平等的和可重用的。我们应该既不用关心从池中拿到的是哪一个值，也不用在意这个值是否已经被使用过。</p><p>要完全做到这两点，可能会需要我们额外地写一些代码。不过，这个代码量应该是微乎其微的，就像<code>fmt</code>包对临时对象池的用法那样。所以，在选用临时对象池的时候，我们必须要把它将要存储的值的特性考虑在内。</p><p>在临时对象池的内部，有一个多层的数据结构支撑着对临时对象的存储。它的顶层是本地池列表，其中包含了与某个P对应的那些本地池，并且其长度与P的数量总是相同的。</p><p>在每个本地池中，都包含一个私有的临时对象和一个共享的临时对象列表。前者只能被其对应的P所关联的那个goroutine中的代码访问到，而后者却没有这个约束。从另一个角度讲，前者用于临时对象的快速存取，而后者则用于临时对象的池内共享。</p><p>正因为有了这样的数据结构，临时对象池才能够有效地分散存储压力和性能压力。同时，又因为临时对象池的<code>Get</code>方法对这个数据结构的妙用，才使得其中的临时对象能够被高效地利用。比如，该方法有时候会从其他的本地池的共享临时对象列表中，“偷取”一个临时对象。</p><p>这样的内部结构和存取方式，让临时对象池成为了一个特点鲜明的同步工具。它存储的临时对象都应该是拥有较长生命周期的值，并且，这些值不应该被某个goroutine中的代码长期的持有和使用。</p><p>因此，临时对象池非常适合用作针对某种数据的缓存。从某种角度讲，临时对象池可以帮助程序实现可伸缩性，这也正是它的最大价值。</p><h2>思考题</h2><p>今天的思考题是：怎样保证一个临时对象池中总有比较充足的临时对象？</p><p>请从临时对象池的初始化和方法调用两个方面作答。必要时可以参考<code>fmt</code>包以及demo70.go文件中使用临时对象池的方式。</p><p>感谢你的收听，我们下次再见。</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","comments":[{"had_liked":false,"id":170144,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1578538143,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"104657753247","product_id":100013101,"comment_content":"go1.13对本地池的shared共享列表做了存储结构变更,改为双向链表（在shared的头部存，尾部取），取消锁以提高性能","like_count":25,"discussions":[{"author":{"id":1198125,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg","nickname":"Alan","note":"","ucode":"9C66CBCFB3A109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128801,"discussion_content":"老哥说得没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578664831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153353,"user_name":"数字记忆","can_delete":false,"product_type":"c1","uid":1227797,"ip_address":"","ucode":"26E16F65F559A1","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/15/23ce17f9.jpg","comment_is_top":false,"comment_ctime":1574221398,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65998730838","product_id":100013101,"comment_content":"这个代码很形象：<br><br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;sync&quot;<br>\t&quot;time&quot;<br>)<br><br>&#47;&#47; 一个[]byte的对象池，每个对象为一个[]byte<br>var bytePool = sync.Pool{<br>\tNew: func() interface{} {<br>\t\tb := make([]byte, 1024)<br>\t\treturn &amp;b<br>\t},<br>}<br><br>func main() {<br>\ta := time.Now().Unix()<br>\tfmt.Println(a)<br>\t&#47;&#47; 不使用对象池<br>\tfor i := 0; i &lt; 1000000000; i++{<br>\t\tobj := make([]byte,1024)<br>\t\t_ = obj<br>\t}<br>\tb := time.Now().Unix()<br>\tfmt.Println(b)<br>\t&#47;&#47; 使用对象池<br>\tfor i := 0; i &lt; 1000000000; i++{<br>\t\tobj := bytePool.Get().(*[]byte)<br>\t\t_ = obj<br>\t\tbytePool.Put(obj)<br>\t}<br>\tc := time.Now().Unix()<br>\tfmt.Println(c)<br>\tfmt.Println(&quot;without pool &quot;, b - a, &quot;s&quot;)<br>\tfmt.Println(&quot;with    pool &quot;, c - b, &quot;s&quot;)<br>}<br><br>&#47;&#47;  run时禁用掉编译器优化，才会体现出有pool的优势<br>&#47;&#47;  go run -gcflags=&quot;-l -N&quot; testSyncPool1.go","like_count":15,"discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389896,"discussion_content":"你好，我将你的代码放入 demo70.go 中，运行结果如下：\n\ngo run -gcflags=&#34;-l -N&#34; demo70.go\n1629473756\n1629473768\n1629473784\nwithout pool  12 s\nwith pool  16 s\n\n好像使用 pool 时间 反而变长了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629473958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40008,"user_name":"到不了的塔","can_delete":false,"product_type":"c1","uid":1258362,"ip_address":"","ucode":"0F5BE3CB58DE31","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/7a/ac307bfc.jpg","comment_is_top":false,"comment_ctime":1542438810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48787079066","product_id":100013101,"comment_content":"临时对象池初始化时指定new字段对应的函数返回一个新建临时对象；<br>临时对象使用完毕时调用临时对象池的put方法，把该临时对象put回临时对象池中。<br>这样就能保证一个临时对象池中总有比较充足的临时对象。","like_count":11},{"had_liked":false,"id":233287,"user_name":"赵赟","can_delete":false,"product_type":"c1","uid":1164481,"ip_address":"","ucode":"B027E6F3449F9C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/c1/1118e24e.jpg","comment_is_top":false,"comment_ctime":1594279758,"is_pvip":false,"replies":[{"id":"86216","content":"这么说也不准确。看这行源码：<br><br>shared  poolChain<br><br>poolChain 这个类型的方法会动用原子操作。<br><br>再看这行源码：<br><br>var allPoolsMu Mutex<br><br>allPoolsMu 会保护单一程序中的所有 sync.Pool，而不是某一个 Pool 的本地池。<br><br>然而，sync.Pool 只会在获取 P 的 ID 以及查找对应的 本地池的时候才会动用 allPoolsMu，而在操作本地池的时候没有用。<br><br>所以，综上来看，本地池的操作已经通过更好的设计去掉了互斥锁，改为原子操作，同时仅在必要时（也就是定位本地池时）短暂动用互斥锁。<br><br>我没去看新 Pool 的性能测试，但是相信一定又有了不小的性能提升。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1594354354,"ip_address":"","comment_id":233287,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40248985422","product_id":100013101,"comment_content":"看了一下 1.14 的源码，那个锁现在是全局的了，即一个临时对象池中本地池列表中的所有本地池都共享一个锁，而不是每个本地池都有自己的锁。","like_count":9,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500974,"discussion_content":"这么说也不准确。看这行源码：\n\nshared  poolChain\n\npoolChain 这个类型的方法会动用原子操作。\n\n再看这行源码：\n\nvar allPoolsMu Mutex\n\nallPoolsMu 会保护单一程序中的所有 sync.Pool，而不是某一个 Pool 的本地池。\n\n然而，sync.Pool 只会在获取 P 的 ID 以及查找对应的 本地池的时候才会动用 allPoolsMu，而在操作本地池的时候没有用。\n\n所以，综上来看，本地池的操作已经通过更好的设计去掉了互斥锁，改为原子操作，同时仅在必要时（也就是定位本地池时）短暂动用互斥锁。\n\n我没去看新 Pool 的性能测试，但是相信一定又有了不小的性能提升。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594354354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96396,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1558408648,"is_pvip":false,"replies":[{"id":"34530","content":"我大概明白你的意思。这篇文章你可能还没有仔细看。<br><br>你需要先搞清楚（以下内容在文章里都有）：<br><br>在涉及到本地池的 shared 字段的时候会有锁，但是这种锁是分段锁，也就是说，每个本地池都会有自己的锁。<br><br>因此，在对应某个 P 的本地池的锁处于锁定状态的时候，所有正试图访问（不论是 Get 还是 Put）这个本地池的 goroutine 都会被阻塞。<br><br>一个临时对象池拥有的本地池的数量与 P 的数量相同。所以，即使有 goroutine 因此被阻塞，往往也只是少数。又因为分段锁的缘故，它们被锁住的时间一般也是很短暂的。<br><br>当你知道了这些，你就会明白，临时对象池在并发访问方面是很高效的。<br><br>再结合我在专栏里揭示的访问步骤和细节，你应该就可以搞懂你问的问题了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1558417890,"ip_address":"","comment_id":96396,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31623179720","product_id":100013101,"comment_content":"还有一个问题，如果多goruntine同时申请临时对象池内资源，所有goruntine都可以同时获取到吗，还是只能有一个goruntine获取到，其它的goruntine都阻塞，直到这个goruntine释放完后才能使用","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450863,"discussion_content":"我大概明白你的意思。这篇文章你可能还没有仔细看。\n\n你需要先搞清楚（以下内容在文章里都有）：\n\n在涉及到本地池的 shared 字段的时候会有锁，但是这种锁是分段锁，也就是说，每个本地池都会有自己的锁。\n\n因此，在对应某个 P 的本地池的锁处于锁定状态的时候，所有正试图访问（不论是 Get 还是 Put）这个本地池的 goroutine 都会被阻塞。\n\n一个临时对象池拥有的本地池的数量与 P 的数量相同。所以，即使有 goroutine 因此被阻塞，往往也只是少数。又因为分段锁的缘故，它们被锁住的时间一般也是很短暂的。\n\n当你知道了这些，你就会明白，临时对象池在并发访问方面是很高效的。\n\n再结合我在专栏里揭示的访问步骤和细节，你应该就可以搞懂你问的问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558417890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256764,"user_name":"小罗希冀","can_delete":false,"product_type":"c1","uid":1311995,"ip_address":"","ucode":"88416458FF0041","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/fb/40f298bb.jpg","comment_is_top":false,"comment_ctime":1603724525,"is_pvip":false,"replies":[{"id":"93492","content":"你这句话的前后逻辑不通啊，sync.Pool 和 map 是两个东西啊，它们的适用场景完全不一样啊。<br><br>sync.Pool 用于缓存“可交换”、“可遗失”的对象。可交换的意思是就是，我用对象 A 也可以，用对象 B 也可以，无所谓。可遗失的意思是，存在里边的对象没了就没了，无所谓，我再创建一个就是了。<br><br>map 如果用作缓存的话，其中的元素值是“不可交换”的，通常也是“不可遗失”的（或者说对遗失敏感的）。你思考一下。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1603766033,"ip_address":"","comment_id":256764,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27373528301","product_id":100013101,"comment_content":"请问一下老师, 如果syn.Pool广泛的应用场景是缓存, 那为什么不直接使用map缓存呢?这样岂不是更方便, 更快捷?","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508108,"discussion_content":"你这句话的前后逻辑不通啊，sync.Pool 和 map 是两个东西啊，它们的适用场景完全不一样啊。\n\nsync.Pool 用于缓存“可交换”、“可遗失”的对象。可交换的意思是就是，我用对象 A 也可以，用对象 B 也可以，无所谓。可遗失的意思是，存在里边的对象没了就没了，无所谓，我再创建一个就是了。\n\nmap 如果用作缓存的话，其中的元素值是“不可交换”的，通常也是“不可遗失”的（或者说对遗失敏感的）。你思考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603766033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311995,"avatar":"https://static001.geekbang.org/account/avatar/00/14/04/fb/40f298bb.jpg","nickname":"小罗希冀","note":"","ucode":"88416458FF0041","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318710,"discussion_content":"明白了，谢谢老师的解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603811702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156987,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1575009336,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23049845816","product_id":100013101,"comment_content":"二刷","like_count":5,"discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389846,"discussion_content":"朋友，介意加你微信讨论一下么？对这个专栏相关内容我有部分疑惑的地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629449046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099379,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","nickname":"疯琴","note":"","ucode":"82ACAA4A27753D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305561,"discussion_content":"同二","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600001058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278666,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1811495,"ip_address":"","ucode":"3F5D8721F577D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","comment_is_top":false,"comment_ctime":1613186809,"is_pvip":false,"replies":[{"id":"101421","content":"因为P是调度的核心啊，起到了衔接M和G的作用。P实际上也是“并发线”的根数，所以：若少于P数量则未充分利用并发机制，若多于P数量则加重了调度器的负担。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1613625387,"ip_address":"","comment_id":278666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10203121401","product_id":100013101,"comment_content":"为啥本地池列表长度不是跟M一致，而是跟P一致？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515462,"discussion_content":"因为P是调度的核心啊，起到了衔接M和G的作用。P实际上也是“并发线”的根数，所以：若少于P数量则未充分利用并发机制，若多于P数量则加重了调度器的负担。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613625387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245987,"user_name":"郭星","can_delete":false,"product_type":"c1","uid":1182219,"ip_address":"","ucode":"8A0F5DF80E0C61","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/0b/985d3800.jpg","comment_is_top":false,"comment_ctime":1599125652,"is_pvip":false,"replies":[{"id":"90452","content":"这个测试比较困难，私有临时对象主要是为了加速对象的存取，但是临时对象池**并不保证**返回给我的对象是按照固定顺序的，你可以认为是随机的。<br><br>我们也没必要测试，知道有这样一个加速优化就好了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1599191307,"ip_address":"","comment_id":245987,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10189060244","product_id":100013101,"comment_content":"&quot;在每个本地池中，都包含一个私有的临时对象和一个共享的临时对象列表。前者只能被其对应的 P 所关联的那个 goroutine 中的代码访问到，而后者却没有这个约束&quot;<br>对于private只能被当前协程才能访问,其他协程不能访问到private,这个应该怎么测试呢?<br>import (<br>\t&quot;runtime&quot;<br>\t&quot;sync&quot;<br>\t&quot;testing&quot;<br>)<br><br>type cache struct {<br>\tvalue int<br>}<br>func TestShareAndPrivate(t *testing.T) {<br>\tp := sync.Pool{}<br>\t&#47;&#47; 在主协程写入10<br>\tp.Put(cache{value: 10})<br>\tvar wg sync.WaitGroup<br>\twg.Add(1)<br>\tgo func() {<br>\t\tfor i := 0; i &lt; 10; i++ {<br>\t\t\tp.Put(cache{value: i})<br>\t\t}<br>\t\twg.Done()<br>\t}()<br>\twg.Wait()<br>\twg.Add(1)<br>\tgo func() {<br>\t\tfor true {<br>\t\t\tv := p.Get()<br>\t\t\tif v == nil {<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\tt.Log(v)<br>\t\t}<br>\t\twg.Done()<br>\t}()<br>\twg.Wait()<br>}<br>这段代码没有体现出来私有和共享的区别","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505030,"discussion_content":"这个测试比较困难，私有临时对象主要是为了加速对象的存取，但是临时对象池**并不保证**返回给我的对象是按照固定顺序的，你可以认为是随机的。\n\n我们也没必要测试，知道有这样一个加速优化就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599191307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208180,"user_name":"越努力丨越幸运","can_delete":false,"product_type":"c1","uid":1302603,"ip_address":"","ucode":"1E11FA1A2AFA9E","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/4b/bbb48b22.jpg","comment_is_top":false,"comment_ctime":1587294388,"is_pvip":false,"replies":[{"id":"77831","content":"不会跳过，但是它用的不是锁，而是原子操作，因为存的都是指针。所以速度会非常快。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1587351020,"ip_address":"","comment_id":208180,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10177228980","product_id":100013101,"comment_content":"老师，当一个goroutine在访问某个临时对象池中一个本地池的shared字段时被锁住，此时另外一个goroutine访问临时对象池时，是会跳过这个本地池，去访问其他的本地池，还是说会被阻塞住？<br>","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492370,"discussion_content":"不会跳过，但是它用的不是锁，而是原子操作，因为存的都是指针。所以速度会非常快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587351020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200776,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1585649529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175584121","product_id":100013101,"comment_content":"直到看到最近两三章，我才体会到，老师就是在讲源码啊！对着源码学习课程，对着课程学习源码。事半功倍！！","like_count":2},{"had_liked":false,"id":114470,"user_name":"闫飞","can_delete":false,"product_type":"c1","uid":1013162,"ip_address":"","ucode":"30C782D30108D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/aa/21275b9d.jpg","comment_is_top":false,"comment_ctime":1563322846,"is_pvip":false,"replies":[{"id":"41927","content":"你放在一个池子里的实例最好是一个类型的，要不后面用的时候会很麻烦。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1563419653,"ip_address":"","comment_id":114470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10153257438","product_id":100013101,"comment_content":"这里存放的临时对象是否是无状态，无唯一标识符的纯值对象? 对象的类型是否都是一样，还是说必须要用户自己做好具体类型的判定?","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458678,"discussion_content":"你放在一个池子里的实例最好是一个类型的，要不后面用的时候会很麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563419653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35307,"user_name":"苏安","can_delete":false,"product_type":"c1","uid":1197188,"ip_address":"","ucode":"78E15EF2F2816A","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/84/25a17f05.jpg","comment_is_top":false,"comment_ctime":1540515608,"is_pvip":false,"replies":[{"id":"13312","content":"我会讲完的，放心，预计45讲左右。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541482091,"ip_address":"","comment_id":35307,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10130450200","product_id":100013101,"comment_content":"老师，不知道还有几讲，最初的课程大纲有相关的拾遗章节，不知道后续的安排还有没？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427511,"discussion_content":"我会讲完的，放心，预计45讲左右。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541482091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308284,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1629516815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924484111","product_id":100013101,"comment_content":"意外之喜，隔壁专栏鸟窝的《Go 并发编程实战课》对 sync.Pool 有了新的补充，这一讲有困惑的同学可以过去康康。","like_count":1},{"had_liked":false,"id":207261,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1587039386,"is_pvip":false,"replies":[{"id":"77689","content":"你要想了解Go语言的调度器，可与你参考我写的那本《Go并发编程实战》。（因为一句两句说不清楚）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1587286972,"ip_address":"","comment_id":207261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882006682","product_id":100013101,"comment_content":"之前学习 go routine的时候 初次了解到这个p以为就是用来调度goroutine的  但是今天又讨论到这个p 这个P还关联到了临时对象池，这个临时对象池也涉及到被运行时系统所清理 所以我产生了以为 这个p时候就是运行时系统呢？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492060,"discussion_content":"你要想了解Go语言的调度器，可与你参考我写的那本《Go并发编程实战》。（因为一句两句说不清楚）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587286972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167864,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577953694,"is_pvip":false,"replies":[{"id":"65198","content":"不是，是返回结果变量err的值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1577967685,"ip_address":"","comment_id":167864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872920990","product_id":100013101,"comment_content":"请问老师，demo70 的 37 行 return 后面没跟东西，是相当于 return nil 么？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480029,"discussion_content":"不是，是返回结果变量err的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577967685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35650,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1540729632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5835696928","product_id":100013101,"comment_content":"是不是临时对象池里面最多有2p个临时对象","like_count":1},{"had_liked":false,"id":355430,"user_name":"Haij!","can_delete":false,"product_type":"c1","uid":1223089,"ip_address":"四川","ucode":"934287EFD9A593","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/b1/0d550474.jpg","comment_is_top":false,"comment_ctime":1661360767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661360767","product_id":100013101,"comment_content":"fmt包为了识别、格式化和暂存需要打印的内容，定义了一个名为pp的结构体。调用不同的打印方法时，都需要一个pp的结构体介入逻辑进行处理；如果未使用sync.Pool，则每次均会通过new函数初始化pp类型的变量，这时会频繁申请内存。所以为避免每次需要时都调用pp的new方法申请内存，故基于sync.Pool创建一个临时对象池。当打印操作很活跃时，可以直接从池中获取pp结构体并使用；使用后抹取过程中的信息再存入。一方面可以利用“缓存”特性进行性能提升，避免频繁内存申请分配；另一方面可以借由sync.Pool初始时在运行时系统注册的cleanPool方法，及时清理空间，释放内存。","like_count":0},{"had_liked":false,"id":327405,"user_name":"林嘉裕","can_delete":false,"product_type":"c1","uid":2369404,"ip_address":"","ucode":"D143FF584B67CF","user_header":"https://static001.geekbang.org/account/avatar/00/24/27/7c/97b0c1dd.jpg","comment_is_top":false,"comment_ctime":1640101729,"is_pvip":false,"replies":[{"id":"119175","content":"你要是真是想清空，重新 Put 一个空的 map 就好了啊，切片的话也可以这样操作。只要这个 map 或者 slice 再没有别的代码引用它了，GC 就会进行回收了。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1640148497,"ip_address":"","comment_id":327405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640101729","product_id":100013101,"comment_content":"数组可以通过put(arr[:0])清空，如果是map呢？只能通过遍历？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540742,"discussion_content":"你要是真是想清空，重新 Put 一个空的 map 就好了啊，切片的话也可以这样操作。只要这个 map 或者 slice 再没有别的代码引用它了，GC 就会进行回收了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640148497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319063,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1635562552,"is_pvip":false,"replies":[{"id":"115715","content":"这里的 free() 是为了重用当前的这个 p ，每个 p 放回 ppFree 的时机都不一样，怎么统一 free 呢？即使可以，也没什么切实的好处啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1635676996,"ip_address":"","comment_id":319063,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635562552","product_id":100013101,"comment_content":"由于fmt包中的代码在真正使用这些临时对象之前，总是会先对其进行重置，<br>func newPrinter() *pp {<br>\tp := ppFree.Get().(*pp)<br>\tp.panicking = false<br>\tp.erroring = false<br>\tp.wrapErrs = false<br>\tp.fmt.init(&amp;p.buf)<br>\treturn p<br>}<br>思考：这段重置的代码为什么不能放到使用完成后，一并p.free<br>func (p *pp) free() {<br>\t&#47;&#47; Proper usage of a sync.Pool requires each entry to have approximately<br>\t&#47;&#47; the same memory cost. To obtain this property when the stored type<br>\t&#47;&#47; contains a variably-sized buffer, we add a hard limit on the maximum buffer<br>\t&#47;&#47; to place back in the pool.<br>\t&#47;&#47;<br>\t&#47;&#47; See https:&#47;&#47;golang.org&#47;issue&#47;23199<br>\tif cap(p.buf) &gt; 64&lt;&lt;10 {<br>\t\treturn<br>\t}<br><br>\tp.buf = p.buf[:0]<br>\tp.arg = nil<br>\tp.value = reflect.Value{}<br>\tp.wrappedErr = nil<br>\tppFree.Put(p)<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529482,"discussion_content":"这里的 free() 是为了重用当前的这个 p ，每个 p 放回 ppFree 的时机都不一样，怎么统一 free 呢？即使可以，也没什么切实的好处啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635676996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312349,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1631763329,"is_pvip":false,"replies":[{"id":"113184","content":"像连接这种其实不是太适合，因为里面的临时对象可能会被GC清理掉（除非你觉得时不时重建连接无所谓）。主要应用场景还是公用缓存之类的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1631774387,"ip_address":"","comment_id":312349,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631763329","product_id":100013101,"comment_content":"我理解pool使用场景是 做一个结构体原型池，一般用在结构体创建成本较高的场景，如db 连接 ，http连接等","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526946,"discussion_content":"像连接这种其实不是太适合，因为里面的临时对象可能会被GC清理掉（除非你觉得时不时重建连接无所谓）。主要应用场景还是公用缓存之类的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631774387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308254,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1629474399,"is_pvip":false,"replies":[{"id":"111672","content":"第一个问题，sync.Pool 从一开始就不止 Put 和 Get，好的设计就不可能只有公开方法没有私有方法。<br><br>第二个问题，STW 是 Stop The World 的缩写，在这里的含义是：当 GC 进行到某个关键步骤时需要停止一切调度工作以及 goroutine 的一般运行工作。<br><br>第三个问题，除了前面几课，我都是在逼着你们去看Go语言源码。至少是专栏中这些重点包里的源码，一定要仔细看。<br><br>关于并发这块，如果实在看不明白，建议先把我的那本《Go并发编程实战》第二版买来好好看看。Go语言虽然每年会发布两个次级版本，但是在并发的基本理念和主导方法方面就没有动摇过。要想真正理解，看我的那本书，熟悉这方面的底层逻辑，然后仔细看源码。<br><br>总之，这个专栏有的地方看似有些跳脱，但实则有它的逻辑在里面。学技术，学美国的先进技术，不逼自己是不行的，因为它们进展很快。<br><br>正因为发展很快，所以在简要了解全局之后就要找机会直接往地底下挖，挖到底层逻辑，挖到第一性原理，仔细弄明白，再回过头来看上层的建筑，一定会一目了然。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1629619624,"ip_address":"","comment_id":308254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629474399","product_id":100013101,"comment_content":"以下问题，盼老师看到了，帮忙解答一下：<br><br>1：  文中说：“sync.Pool类型只有两个方法——Put和Get”。 我的golang版本是：go1.16.4，不止这两个方法了，还有：getSlow、pin、pinSlow，不过他们都是包级私有的方法。<br><br>2： 像： allPools 这个 变量的 上面的 注释最后 写的 “STW.” 代表什么意思呀？<br><br>3：课程到目前 sync.pool 这一讲为止，前面的文章基本都懂了。就是这一讲读了几遍，看的还是一知半解。我以为这一讲牵扯的源码比较多 而且 感觉 难度 有点大。不知道 郝林老师 三年后重新看这个有没有什么新的想法 能否帮我重新梳理一下或者给一些 关于学习 sync.pool的建议？<br><br>多谢老师的解答。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525444,"discussion_content":"第一个问题，sync.Pool 从一开始就不止 Put 和 Get，好的设计就不可能只有公开方法没有私有方法。\n\n第二个问题，STW 是 Stop The World 的缩写，在这里的含义是：当 GC 进行到某个关键步骤时需要停止一切调度工作以及 goroutine 的一般运行工作。\n\n第三个问题，除了前面几课，我都是在逼着你们去看Go语言源码。至少是专栏中这些重点包里的源码，一定要仔细看。\n\n关于并发这块，如果实在看不明白，建议先把我的那本《Go并发编程实战》第二版买来好好看看。Go语言虽然每年会发布两个次级版本，但是在并发的基本理念和主导方法方面就没有动摇过。要想真正理解，看我的那本书，熟悉这方面的底层逻辑，然后仔细看源码。\n\n总之，这个专栏有的地方看似有些跳脱，但实则有它的逻辑在里面。学技术，学美国的先进技术，不逼自己是不行的，因为它们进展很快。\n\n正因为发展很快，所以在简要了解全局之后就要找机会直接往地底下挖，挖到底层逻辑，挖到第一性原理，仔细弄明白，再回过头来看上层的建筑，一定会一目了然。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629619624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288206,"user_name":"mkii","can_delete":false,"product_type":"c1","uid":1674466,"ip_address":"","ucode":"534914EC7EA304","user_header":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","comment_is_top":false,"comment_ctime":1618363878,"is_pvip":false,"replies":[{"id":"104628","content":"有一个问题：你每次都新建字节切片 make([]byte, 1024)，这样是不好的（与 sync.Pool 的设计初衷相悖）。既然作为缓冲池，就应该先 Put 足够的对象。New 这个函数只是备用的，属于 B 方案。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1618386130,"ip_address":"","comment_id":288206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618363878","product_id":100013101,"comment_content":"老师你好，预期是使用pool 和不使用pool相比，平均操作时间长但分配内存少。目前看起来不是这样的，是我的代码有问题吗？麻烦老师解答一下。<br>func BenchmarkBufferPool(b *testing.B) {<br>\tvar pool = sync.Pool{New: func() interface{} {<br>\t\treturn make([]byte, 1024)<br>\t}}<br><br>\tb.ResetTimer()<br>\tfor i := 0; i &lt; b.N; i++ {<br>\t\tbytesObj := pool.Get().([]byte)<br>\t\t_ = bytesObj<br>\t\tpool.Put(bytesObj)<br>\t}<br>\tb.StopTimer()<br>}<br>func BenchmarkBuffer(b *testing.B) {<br>\tb.ResetTimer()<br>\tfor i := 0; i &lt; b.N; i++ {<br>\t\tbytesObj := make([]byte, 1024)<br>\t\t_ = bytesObj<br>\t}<br>\tb.StopTimer()<br>}<br>========<br>go test -bench=. -benchmem<br>========<br>goos: windows<br>goarch: amd64<br>pkg: go_demo&#47;src&#47;go-core-36&#47;syncpool<br>BenchmarkBufferPool-6           26087295                50.1 ns&#47;op            32 B&#47;op          1 allocs&#47;op<br>BenchmarkBuffer-6               1000000000               0.268 ns&#47;op           0 B&#47;op          0 allocs&#47;op<br>PASS<br>ok      go_demo&#47;src&#47;go-core-36&#47;syncpool 1.972s","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518547,"discussion_content":"有一个问题：你每次都新建字节切片 make([]byte, 1024)，这样是不好的（与 sync.Pool 的设计初衷相悖）。既然作为缓冲池，就应该先 Put 足够的对象。New 这个函数只是备用的，属于 B 方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618386130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287556,"user_name":"Geek_9b9769","can_delete":false,"product_type":"c1","uid":1312225,"ip_address":"","ucode":"48A1DEC02CFAE3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tmVLphkQHLxRsAOZOzJNhJKXvAhkvvT8koMjMUpIQbJN1e8Uico1habQvNibvibI14yM7DWVicJIgNriaib9tRv735mg/132","comment_is_top":false,"comment_ctime":1618026867,"is_pvip":false,"replies":[{"id":"104542","content":"sync.Pool是一个相对较重的同步工具啊，当然会有性能损耗啊。即使你只用原子操作，也会有性能损耗，只不过很小而已。这就是在用速度换安全（换正确性）啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1618205355,"ip_address":"","comment_id":287556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618026867","product_id":100013101,"comment_content":"老师，我有个问题，我用sync.Pool写了一个benchmark, sync.Pool比不用的时候性能变差了，为什么<br>pb.UserInfo是protoBuf的一个数据结构<br><br>使用pool代码:<br>func BenchmarkPool(b *testing.B) {<br><br>\tvar pool = sync.Pool{<br>\t\tNew: func() interface{} {<br>\t\t\treturn new(pb.UserInfo)<br>\t\t},<br>\t}<br><br>\tfor i := 0; i &lt; b.N; i++ {<br>\t\tpb := pool.Get().(*pb.UserInfo)<br>\t\tpb.IsOK = true<br>\t\tpb.Maps = make(map[string]int32)<br>\t\tpool.Put(pb)<br>\t}<br><br>}<br>benchmark结果：<br>goos: windows<br>goarch: amd64<br>pkg: learn<br>cpu: AMD Ryzen 7 4800H with Radeon Graphics<br>BenchmarkPool<br>BenchmarkPool-16<br>24863664\t        58.62 ns&#47;op\t      48 B&#47;op\t       1 allocs&#47;op<br>PASS<br><br>不使用pool的代码：<br>func BenchmarkNoPool(b *testing.B) {<br>\tfor i := 0; i &lt; b.N; i++ {<br>\t\tpb := new(pb.UserInfo)<br>\t\tpb.IsOK = true<br>\t\tpb.Maps = make(map[string]int32)<br>\t}<br>}<br><br>benchmark结果：<br>goos: windows<br>goarch: amd64<br>pkg: learn<br>cpu: AMD Ryzen 7 4800H with Radeon Graphics<br>BenchmarkNoPool<br>BenchmarkNoPool-16<br>28364434\t        41.48 ns&#47;op\t      48 B&#47;op\t       1 allocs&#47;op","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518347,"discussion_content":"sync.Pool是一个相对较重的同步工具啊，当然会有性能损耗啊。即使你只用原子操作，也会有性能损耗，只不过很小而已。这就是在用速度换安全（换正确性）啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618205355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240944,"user_name":"ArtistLu","can_delete":false,"product_type":"c1","uid":1166373,"ip_address":"","ucode":"2E641A3EB4F9AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/cc/25/8c6eab2c.jpg","comment_is_top":false,"comment_ctime":1597129040,"is_pvip":true,"replies":[{"id":"89071","content":"很简单，对低层的字节切片执行 p.buf[:0]，然后再重置其他一些字段。详见 src&#47;fmt&#47;print.go 中的 func (p *pp) free() 。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1597137666,"ip_address":"","comment_id":240944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597129040","product_id":100013101,"comment_content":"老师， 能简单讲下 “使用完临时对象之后，都会先抹掉其中已缓冲的内容”，其中抹掉缓冲如何实现的吗？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503602,"discussion_content":"很简单，对低层的字节切片执行 p.buf[:0]，然后再重置其他一些字段。详见 src/fmt/print.go 中的 func (p *pp) free() 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597137666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207270,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1587040017,"is_pvip":false,"replies":[{"id":"77477","content":"想清楚之后可以看看最后的思考题答案。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1587091854,"ip_address":"","comment_id":207270,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587040017","product_id":100013101,"comment_content":"关于思考题 我觉得要及时回收 外加提供new字段 不然肯定会出现 不够用的情况","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492064,"discussion_content":"想清楚之后可以看看最后的思考题答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587091854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207267,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1587039769,"is_pvip":false,"replies":[{"id":"77478","content":"这个由 GOMAXPROCS 决定。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1587091950,"ip_address":"","comment_id":207267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587039769","product_id":100013101,"comment_content":"还有就是 到底go语言中有多少个p?","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492062,"discussion_content":"这个由 GOMAXPROCS 决定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587091950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207265,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1587039654,"is_pvip":false,"replies":[{"id":"77688","content":"你自己不需要考虑扩容的事情，如果想知道底层是怎么运作的，最好的方式就是直接看源码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1587286892,"ip_address":"","comment_id":207265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587039654","product_id":100013101,"comment_content":"然后临时对象池底层依赖的是数组 我想问的是 初始化的时候这个数组是多大？后面是否还涉及到扩容呢？ 我本来以为底层是链表 因为增删方便，后来才发现是为了查询方便","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492061,"discussion_content":"你自己不需要考虑扩容的事情，如果想知道底层是怎么运作的，最好的方式就是直接看源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587286892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184232,"user_name":"湛","can_delete":false,"product_type":"c1","uid":1228275,"ip_address":"","ucode":"08D2E233A952C8","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/f3/a59e8c99.jpg","comment_is_top":false,"comment_ctime":1583251716,"is_pvip":false,"replies":[{"id":"71327","content":"语法上讲是可以的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1583306784,"ip_address":"","comment_id":184232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583251716","product_id":100013101,"comment_content":"请问 sync.Pool可以作为切片的一部分吗","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485937,"discussion_content":"语法上讲是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583306784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170684,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1198125,"ip_address":"","ucode":"9C66CBCFB3A109","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg","comment_is_top":false,"comment_ctime":1578664288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578664288","product_id":100013101,"comment_content":"threalocal 有点像，只不过pool的垃圾回收是系统处理，哦，另外还多了个共享列表，哈哈","like_count":0},{"had_liked":false,"id":103454,"user_name":"benying","can_delete":false,"product_type":"c1","uid":1247522,"ip_address":"","ucode":"DEBAB485F381CC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","comment_is_top":false,"comment_ctime":1560439009,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560439009","product_id":100013101,"comment_content":"打卡,讲的蛮清楚了<br>老师的课程难度比较适中,挺好的","like_count":0},{"had_liked":false,"id":96395,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1558408402,"is_pvip":false,"replies":[{"id":"34528","content":"你说的“不存在”是什么意思？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1558415966,"ip_address":"","comment_id":96395,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1558408402","product_id":100013101,"comment_content":"你好，请问put一个不存在的临时对象池会引发别的问题吗","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450862,"discussion_content":"你说的“不存在”是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558415966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1446512,"avatar":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","nickname":"Lywane","note":"","ucode":"2B0027AA069CE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218340,"discussion_content":"Put一个nil就直接返回了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585649585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86577,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1555402268,"is_pvip":false,"replies":[{"id":"31139","content":"Get 的时候只会想法设法拿到一个临时对象，而不会移动任何对象。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555405007,"ip_address":"","comment_id":86577,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555402268","product_id":100013101,"comment_content":"请教老师一个问题: Get方法从临时对象池中取走一个私有临时对象时, 会不会把自己的共享临时对象列表中的临时对象转移一个为私有临时对象, 以方便下一个Get方法调用? 从文中的内容看, 应该是不会的","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447079,"discussion_content":"Get 的时候只会想法设法拿到一个临时对象，而不会移动任何对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555405007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71833,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1551447487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551447487","product_id":100013101,"comment_content":"打卡😘ོ","like_count":0},{"had_liked":false,"id":43041,"user_name":"Supetsnail","can_delete":false,"product_type":"c1","uid":1048431,"ip_address":"","ucode":"49D2B3A562939E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/6f/1fce2a11.jpg","comment_is_top":false,"comment_ctime":1543147457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543147457","product_id":100013101,"comment_content":"这个怎么做一下benchmark验证下效率？","like_count":0},{"had_liked":false,"id":43040,"user_name":"Supetsnail","can_delete":false,"product_type":"c1","uid":1048431,"ip_address":"","ucode":"49D2B3A562939E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/6f/1fce2a11.jpg","comment_is_top":false,"comment_ctime":1543147403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543147403","product_id":100013101,"comment_content":"这个怎么能做一个benchmark对比？","like_count":0}]}