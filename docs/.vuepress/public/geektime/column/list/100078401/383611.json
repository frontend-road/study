{"id":383611,"title":"15 | Linux初始化（下）：从_start到第一个进程","content":"<p>你好，我是LMOS。</p><p>今天我们继续来研究Linux的初始化流程，为你讲解如何解压内核，然后讲解Linux内核第一个C函数。最后，我们会用Linux的第一个用户进程的建立来收尾。</p><p>如果用你上手去玩一款新游戏做类比的话，那么上节课只是新手教程，而这节课就是更深入的实战了。后面你会看到很多熟悉的“面孔”，像是我们前面讲过的CPU工作模式、MMU页表等等基础知识，这节课都会得到运用。</p><h2>解压后内核初始化</h2><p>下面，我们先从setup.bin文件的入口_start开始，了解启动信息结构，接着由16位main函数切换CPU到保护模式，然后跳入vmlinux.bin文件中的startup_32函数重新加载段描述符。</p><p>如果是64位的系统，就要进入startup_64函数，切换到CPU到长模式，最后调用extract_kernel函数解压Linux内核，并进入内核的startup_64函数，由此Linux内核开始运行。</p><h3>为何要从_start开始</h3><p>通过上节课对vmlinuz文件结构的研究，我们已经搞清楚了其中的vmlinux.bin是如何产生的，它是由linux/arch/x86/boot/compressed目录下的一些目标文件，以及piggy.S包含的一个vmlinux.bin.gz的压缩文件一起生成的。</p><!-- [[[read_end]]] --><p>vmlinux.bin.gz文件则是由编译的Linux内核所生成的elf格式的vmlinux文件，去掉了文件的符号信息和重定位信息后，压缩得到的。</p><p>CPU是无法识别压缩文件中的指令直接运行的，必须先进行解压后，然后解析elf格式的文件，把其中的指令段和数据段加载到指定的内存空间中，才能由CPU执行。</p><p>这就需要用到前面的setup.bin文件了，_start正是setup.bin文件的入口，在head.S文件中定义，代码如下。</p><pre><code>#linux/arch/x86/boot/head.S\n\t.code16\n\t.section &quot;.bstext&quot;, &quot;ax&quot;\n\t.global bootsect_start\nbootsect_start:\n\tljmp\t$BOOTSEG, $start2\nstart2:\n#……\n#这里的512字段bootsector对于硬盘启动是用不到的\n#……\n\t.globl\t_start\n_start:\n\t\t.byte\t0xeb\t\t# short (2-byte) jump\n\t\t.byte\tstart_of_setup-1f #这指令是用.byte定义出来的，跳转start_of_setup-1f\n#……\n#这里是一个庞大的数据结构，没展示出来，与linux/arch/x86/include/uapi/asm/bootparam.h文件中的struct setup_header一一对应。这个数据结构定义了启动时所需的默认参数\n#……\nstart_of_setup:\n\tmovw\t%ds, %ax\n\tmovw\t%ax, %es   #ds = es\n\tcld               #主要指定si、di寄存器的自增方向，即si++ di++\n\n\tmovw\t%ss, %dx\n\tcmpw\t%ax, %dx\t# ds 是否等于 ss\n\tmovw\t%sp, %dx     \n\tje\t2f\t\t\n\t# 如果ss为空则建立新栈\n\tmovw\t$_end, %dx\n\ttestb\t$CAN_USE_HEAP, loadflags\n\tjz\t1f\n\tmovw\theap_end_ptr, %dx\n1:\taddw\t$STACK_SIZE, %dx\n\tjnc\t2f\n\txorw\t%dx, %dx\t\n2:\n\tandw\t$~3, %dx\n\tjnz\t3f\n\tmovw\t$0xfffc, %dx\t\n3:\tmovw\t%ax, %ss\n\tmovzwl\t%dx, %esp\t\n\tsti\t\t\t# 栈已经初始化好，开中断\n\tpushw\t%ds\n\tpushw\t$6f\n\tlretw      # cs=ds ip=6：跳转到标号6处\n6:\n\tcmpl\t$0x5a5aaa55, setup_sig #检查setup标记\n\tjne\tsetup_bad\n\tmovw\t$__bss_start, %di\n\tmovw\t$_end+3, %cx\n\txorl\t%eax, %eax\n\tsubw\t%di, %cx\n\tshrw\t$2, %cx\n\trep; stosl          #清空setup程序的bss段\n\tcalll\tmain  #调用C语言main函数 \n</code></pre><h3>setup_header结构</h3><p>下面我们重点研究一下setup_header结构，这对我们后面的流程很关键。它定义在linux/arch/x86/include/uapi/asm/bootparam.h文件中，如下所示。</p><pre><code>struct setup_header {    \n__u8    setup_sects;        //setup大小\n__u16   root_flags;         //根标志   \n__u32   syssize;            //系统文件大小\n__u16   ram_size;           //内存大小\n__u16   vid_mode;    \n__u16   root_dev;           //根设备号\n__u16   boot_flag;          //引导标志\n//……\n__u32   realmode_swtch;     //切换回实模式的函数地址     \n__u16   start_sys_seg;    \n__u16   kernel_version;     //内核版本    \n__u8    type_of_loader;     //引导器类型 我们这里是GRUB\n__u8    loadflags;          //加载内核的标志 \n__u16   setup_move_size;    //移动setup的大小\n__u32   code32_start;       //将要跳转到32位模式下的地址 \n__u32   ramdisk_image;      //初始化内存盘映像地址，里面有内核驱动模块 \n__u32   ramdisk_size;       //初始化内存盘映像大小\n//……\n} __attribute__((packed));\n</code></pre><p>前面提到过，硬盘中MBR是由GRUB写入的boot.img，因此这里的linux/arch/x86/boot/head.S中的bootsector对于硬盘启动是无用的。</p><p>GRUB将vmlinuz的setup.bin部分读到内存地址0x90000处，然后跳转到0x90200开始执行，恰好跳过了前面512字节的bootsector，从_start开始。</p><h3>16位的main函数</h3><p>我们通常用C编译器编译的代码，是32位保护模式下的或者是64位长模式的，却很少编译成16位实模式下的，其实setup.bin大部分代码都是16位实模式下的。</p><p>从前面的代码里，我们能够看到在linux/arch/x86/boot/head.S中调用了main函数，该函数在linux/arch/x86/boot/main.c文件中，代码如下 。</p><pre><code>//定义boot_params变量\nstruct boot_params boot_params __attribute__((aligned(16)));\nchar *HEAP = _end;\nchar *heap_end = _end; \n//……\nvoid main(void){\n    //把先前setup_header结构复制到boot_params结构中的hdr变量中，在linux/arch/x86/include/uapi/asm/bootparam.h文件中你会发现boot_params结构中的hdr的类型正是setup_header结构  \n    copy_boot_params();\n    //初始化早期引导所用的console    \n    console_init();    \n    //初始化堆 \n    init_heap();\n    //检查CPU是否支持运行Linux    \n    if (validate_cpu()) {        \n        puts(&quot;Unable to boot - please use a kernel appropriate &quot;             &quot;for your CPU.\\n&quot;);        \n        die();    \n    }\n    //告诉BIOS我们打算在什么CPU模式下运行它\n    set_bios_mode();\n    //查看物理内存空间布局    \n    detect_memory();\n    //初始化键盘\n    keyboard_init();\n    //查询Intel的(IST)信息。    \n    query_ist();\n    /*查询APM BIOS电源管理信息。*/\n    #if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)   \n    query_apm_bios();\n    #endif\n    //查询EDD BIOS扩展数据区域的信息\n    #if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE) \n    query_edd();\n    #endif\n    //设置显卡的图形模式    \n    set_video();\n    //进入CPU保护模式，不会返回了       \n    go_to_protected_mode();\n}\n</code></pre><p>上面这些函数都在linux/arch/x86/boot/目录对应的文件中，都是调用BIOS中断完成的，具体细节，你可以自行查看。</p><p>我这里列出的代码只是帮助你理清流程，我们继续看看go_to_protected_mode()函数，在linux/arch/x86/boot/pm.c中，代码如下。</p><pre><code>//linux/arch/x86/boot/pm.c\nvoid go_to_protected_mode(void){    \n    //安装切换实模式的函数\n    realmode_switch_hook();\n    //开启a20地址线，是为了能访问1MB以上的内存空间\n    if (enable_a20()) {        \n        puts(&quot;A20 gate not responding, unable to boot...\\n&quot;);\n        die();    \n    }\n    //重置协处理器，早期x86上的浮点运算单元是以协处理器的方式存在的    \n    reset_coprocessor();\n    //屏蔽8259所示的中断源   \n    mask_all_interrupts();\n    //安装中断描述符表和全局描述符表，    \n    setup_idt();    \n    setup_gdt();\n    //保护模式下长跳转到boot_params.hdr.code32_start\n    protected_mode_jump(boot_params.hdr.code32_start,                (u32)&amp;boot_params + (ds() &lt;&lt; 4));\n}\n</code></pre><p>protected_mode_jump是个汇编函数，在linux/arch/x86/boot/pmjump.S文件中。代码逻辑和我们前面（<a href=\"https://time.geekbang.org/column/article/375278\">第5节课</a>）学到的保护模式切换是一样的。只是多了<strong>处理参数的逻辑</strong>，即跳转到boot_params.hdr.code32_start中的地址。</p><p>这个地址在linux/arch/x86/boot/head.S文件中设为0x100000，如下所示。</p><pre><code>code32_start:\nlong\t0x100000\n</code></pre><p><strong>需要注意的是，GRUB会把vmlinuz中的vmlinux.bin部分，放在1MB开始的内存空间中。通过这一跳转，正式进入vmlinux.bin中。</strong></p><h3>startup_32函数</h3><p>startup_32中需要重新加载段描述符，之后计算vmlinux.bin文件的编译生成的地址和实际加载地址的偏移，然后重新设置内核栈，检测CPU是否支持长模式，接着再次计算vmlinux.bin加载地址的偏移，来确定对其中vmlinux.bin.gz解压缩的地址。</p><p>如果CPU支持长模式的话，就要设置64位的全局描述表，开启CPU的PAE物理地址扩展特性。再设置最初的MMU页表，最后开启分页并进入长模式，跳转到startup_64，代码如下。</p><pre><code>\t.code32\nSYM_FUNC_START(startup_32)\n\tcld\n\tcli\n\tleal\t(BP_scratch+4)(%esi), %esp\n\tcall\t1f\n1:\tpopl\t%ebp\n\tsubl\t$ rva(1b), %ebp\n    #重新加载全局段描述符表\n\tleal\trva(gdt)(%ebp), %eax\n\tmovl\t%eax, 2(%eax)\n\tlgdt\t(%eax)\n    #……篇幅所限未全部展示代码\n    #重新设置栈\n\tleal\trva(boot_stack_end)(%ebp), %esp\n    #检测CPU是否支持长模式\n\tcall\tverify_cpu\n\ttestl\t%eax, %eax\n\tjnz\t.Lno_longmode\n    #……计算偏移的代码略过\n    #开启PAE\n    movl\t%cr4, %eax\n\torl\t$X86_CR4_PAE, %eax\n\tmovl\t%eax, %cr4\n    #……建立MMU页表的代码略过\n    #开启长模式\n    movl\t$MSR_EFER, %ecx\n\trdmsr\n\tbtsl\t$_EFER_LME, %eax\n    #获取startup_64的地址\n    leal\trva(startup_64)(%ebp), %eax\n    #……篇幅所限未全部展示代码\n    #内核代码段描述符索和startup_64的地址引压入栈\n    pushl\t$__KERNEL_CS\n\tpushl\t%eax\n    #开启分页和保护模式\n\tmovl\t$(X86_CR0_PG | X86_CR0_PE), %eax \n\tmovl\t%eax, %cr0\n    #弹出刚刚栈中压入的内核代码段描述符和startup_64的地址到CS和RIP中，实现跳转，真正进入长模式。\n\tlret\nSYM_FUNC_END(startup_32）\n</code></pre><h3>startup_64函数</h3><p>现在，我们终于开启了CPU长模式，从startup_64开始真正进入了64位的时代，可喜可贺。</p><p>startup_64函数同样也是在linux/arch/x86/boot/compressed/head64.S文件中定义的。</p><p>startup_64函数中，初始化长模式下数据段寄存器，确定最终解压缩地址，然后拷贝压缩vmlinux.bin到该地址，跳转到decompress_kernel地址处，开始解压vmlinux.bin.gz，代码如下。</p><pre><code>\t.code64\n\t.org 0x200\nSYM_CODE_START(startup_64)\n\tcld\n\tcli\n\t#初始化长模式下数据段寄存器\n\txorl\t%eax, %eax\n\tmovl\t%eax, %ds\n\tmovl\t%eax, %es\n\tmovl\t%eax, %ss\n\tmovl\t%eax, %fs\n\tmovl\t%eax, %gs\n    #……重新确定内核映像加载地址的代码略过\n    #重新初始化64位长模式下的栈\n    leaq\trva(boot_stack_end)(%rbx), %rsp\n    #……建立最新5级MMU页表的代码略过\n    #确定最终解压缩地址，然后拷贝压缩vmlinux.bin到该地址\n    pushq\t%rsi\n\tleaq\t(_bss-8)(%rip), %rsi\n\tleaq\trva(_bss-8)(%rbx), %rdi\n\tmovl\t$(_bss - startup_32), %ecx\n\tshrl\t$3, %ecx\n\tstd\n\trep\tmovsq\n\tcld\n\tpopq\t%rsi\n    #跳转到重定位的Lrelocated处\n    leaq\trva(.Lrelocated)(%rbx), %rax\n\tjmp\t*%rax\nSYM_CODE_END(startup_64)\n\n\t.text\nSYM_FUNC_START_LOCAL_NOALIGN(.Lrelocated)\n    #清理程序文件中需要的BSS段\n\txorl\t%eax, %eax\n\tleaq    _bss(%rip), %rdi\n\tleaq    _ebss(%rip), %rcx\n\tsubq\t%rdi, %rcx\n\tshrq\t$3, %rcx\n\trep\tstosq\n    #……省略无关代码\n\tpushq\t%rsi\t\t\t\n\tmovq\t%rsi, %rdi\t\t\n\tleaq\tboot_heap(%rip), %rsi\n    #准备参数：被解压数据的开始地址 \t\n\tleaq\tinput_data(%rip), %rdx\n    #准备参数：被解压数据的长度 \t\n\tmovl\tinput_len(%rip), %ecx\n    #准备参数：解压数据后的开始地址 \t\t\n\tmovq\t%rbp, %r8\n    #准备参数：解压数据后的长度\n\tmovl\toutput_len(%rip), %r9d\n    #调用解压函数解压vmlinux.bin.gz，返回入口地址\n    call\textract_kernel\n\tpopq\t%rsi\n    #跳转到内核入口地址 \n\tjmp\t*%rax\nSYM_FUNC_END(.Lrelocated)\n</code></pre><p>上述代码中最后到了extract_kernel函数，它就是解压内核的函数，下面我们就来研究它。</p><h3>extract_kernel函数</h3><p>从startup_32函数到startup_64函数，其间经过了保护模式、长模式，最终到达了extract_kernel函数，extract_kernel函数根据piggy.o中的信息从vmlinux.bin.gz中解压出vmlinux。</p><p>根据前面的知识点，我们知道vmlinux正是编译出Linux内核elf格式的文件，只不过它被去掉了符号信息。所以，extract_kernel函数不仅仅是解压，还需要解析elf格式。</p><p>extract_kernel函数是在linux/arch/x86/boot/compressed/misc.c文件中定义的。</p><pre><code>asmlinkage __visible void *extract_kernel(\n                                void *rmode, memptr heap,\n                                unsigned char *input_data,\n                                unsigned long input_len,\n                                unsigned char *output,\n                                unsigned long output_len\n                                ){    \n    const unsigned long kernel_total_size = VO__end - VO__text;\n    unsigned long virt_addr = LOAD_PHYSICAL_ADDR;    \n    unsigned long needed_size;\n    //省略了无关性代码\n    debug_putstr(&quot;\\nDecompressing Linux... &quot;);    \n    //调用具体的解压缩算法解压\n    __decompress(input_data, input_len, NULL, NULL, output, output_len,            NULL, error);\n    //解压出的vmlinux是elf格式，所以要解析出里面的指令数据段和常规数据段\n    //返回vmlinux的入口点即Linux内核程序的开始地址  \n    parse_elf(output); \n    handle_relocations(output, output_len, virt_addr);    debug_putstr(&quot;done.\\nBooting the kernel.\\n&quot;);\n    return output;\n}\n</code></pre><p>正如上面代码所示，extract_kernel函数调用__decompress函数，对vmlinux.bin.gz使用特定的解压算法进行解压。解压算法是编译内核的配置选项决定的。</p><p>但是，__decompress函数解压出来的是vmlinux文件是elf格式的，所以还要调用parse_elf函数进一步解析elf格式，把vmlinux中的指令段、数据段、BSS段，根据elf中信息和要求放入特定的内存空间，返回指令段的入口地址。</p><p>请你注意，在Lrelocated函数的最后一条指令：jmp *rax，其中的rax中就是保存的extract_kernel函数返回的入口点，就是从这里开始进入了Linux内核。</p><h3>Linux内核的startup_64</h3><p><strong>这里我提醒你留意，此时的startup_64函数并不是之前的startup_64函数，也不参与前面的链接工作。</strong></p><p>这个startup_64函数定义在linux/arch/x86/kernel/head_64.S文件中，它是内核的入口函数，如下所示。</p><pre><code>#linux/arch/x86/kernel/head_64.S\t\n    .code64\nSYM_CODE_START_NOALIGN(startup_64)\n\t#切换栈\n    leaq\t(__end_init_task - SIZEOF_PTREGS)(%rip), %rsp\n\t#跳转到.Lon_kernel_cs:\n    pushq\t$__KERNEL_CS\n\tleaq\t.Lon_kernel_cs(%rip), %rax\n\tpushq\t%rax\n\tlretq\n.Lon_kernel_cs:\n    #对于第一个CPU，则会跳转secondary_startup_64函数中1标号处\n\tjmp 1f\nSYM_CODE_END(startup_64)\n</code></pre><p>上述代码中省略了和流程无关的代码，对于SMP系统加电之后，总线仲裁机制会选出多个CPU中的一个CPU，称为BSP，也叫第一个CPU。它负责让BSP CPU先启动，其它CPU则等待BSP CPU的唤醒。</p><p>这里我来分情况给你说说。对于第一个启动的CPU，会跳转secondary_startup_64函数中1标号处，对于其它被唤醒的CPU则会直接执行secondary_startup_64函数。</p><p>接下来，我给你快速过一遍secondary_startup_64函数，后面的代码我省略了这个函数对更多CPU特性（设置GDT、IDT，处理了MMU页表等）的检查，因为这些工作我们早已很熟悉了，代码如下所示。</p><pre><code>SYM_CODE_START(secondary_startup_64)\n    #省略了大量无关性代码\n1:\n\tmovl\t$(X86_CR4_PAE | X86_CR4_PGE), %ecx\n#ifdef CONFIG_X86_5LEVEL\n\ttestl\t$1, __pgtable_l5_enabled(%rip)\n\tjz\t1f\n\torl\t$X86_CR4_LA57, %ecx\n1:\n#endif\n    #省略了大量无关性代码\n.Ljump_to_C_code:\n\tpushq\t$.Lafter_lret\t\n\txorl\t%ebp, %ebp\n    #获取x86_64_start_kernel函数地址赋给rax\t\n\tmovq\tinitial_code(%rip), %rax\n\tpushq\t$__KERNEL_CS\t\n    #将x86_64_start_kernel函数地址压入栈中\n\tpushq\t%rax\n    #弹出__KERNEL_CS\t和x86_64_start_kernel函数地址到CS：RIP完成调用\t\n    lretq\n.Lafter_lret:\nSYM_CODE_END(secondary_startup_64)\n#保存了x86_64_start_kernel函数地址\nSYM_DATA(initial_code,\t.quad x86_64_start_kernel)\n</code></pre><p>在secondary_startup_64函数一切准备就绪之后，最后就会调用x86_64_start_kernel函数，看它的名字好像是内核的开始函数，但真的是这样吗，我们一起看看才知道。</p><h2>Linux内核的第一个C函数</h2><p>若不是经历了前面的分析讲解。要是我问你Linux内核的第一个C函数是什么，你可能无从说起，就算一通百度之后，仍然无法确定。</p><p>但是，只要我们跟着代码的执行流程，就会发现<strong>在secondary_startup_64函数的最后，调用的x86_64_start_kernel函数是用C语言写的，那么它一定就是Linux内核的第一个C函数。</strong>它在linux/arch/x86/kernel/head64.c文件中被定义，这个文件名你甚至都能猜出来，如下所示。</p><pre><code>asmlinkage __visible void __init x86_64_start_kernel(char * real_mode_data){    \n    //重新设置早期页表\n    reset_early_page_tables();\n    //清理BSS段\n    clear_bss();\n    //清理之前的顶层页目录\n    clear_page(init_top_pgt);\n    //复制引导信息\n    copy_bootdata(__va(real_mode_data));\n    //加载BSP CPU的微码\n    load_ucode_bsp();\n    //让顶层页目录指向重新设置早期页表\n    init_top_pgt[511] = early_top_pgt[511];\n    x86_64_start_reservations(real_mode_data);\n}\nvoid __init x86_64_start_reservations(char *real_mode_data){  \n   //略过无关的代码\n    start_kernel();\n}\n</code></pre><p>x86_64_start_kernel函数中又一次处理了页表，处理页表就是处理Linux内核虚拟地址空间，Linux虚拟地址空间是一步步完善的。</p><p>然后，x86_64_start_kernel函数复制了引导信息，即struct boot_params结构体。最后调用了x86_64_start_reservations函数，其中处理了平台固件相关的东西，就是调用了大名鼎鼎的start_kernel函数。</p><h2>有名的start_kernel函数</h2><p>start_kernel函数之所以有名，这是因为在互联网上，在各大Linux名著之中，都会大量宣传它Linux内核中的地位和作用，正如其名字表达的含意，这是内核的开始。</p><p>但是问题来了。我们一路走来，发现start_kernel函数之前有大量的代码执行，那这些代码算不算内核的开始呢？当然也可以说那就是内核的开始，也可以说是前期工作。</p><p>其实，start_kernel函数中调用了大量Linux内核功能的初始化函数，它定义在/linux/init/main.c文件中。</p><pre><code>void start_kernel(void){    \n    char *command_line;    \n    char *after_dashes;\n    //CPU组早期初始化\n    cgroup_init_early();\n    //关中断\n    local_irq_disable();\n    //ARCH层初始化\n    setup_arch(&amp;command_line);\n    //日志初始化      \n    setup_log_buf(0);    \n    sort_main_extable();\n    //陷阱门初始化    \n    trap_init();\n    //内存初始化    \n    mm_init();\n    ftrace_init();\n    //调度器初始化\n    sched_init();\n    //工作队列初始化\n    workqueue_init_early();\n    //RCU锁初始化\n    rcu_init();\n    //IRQ 中断请求初始化\n    early_irq_init();    \n    init_IRQ();    \n    tick_init();    \n    rcu_init_nohz();\n    //定时器初始化 \n    init_timers();    \n    hrtimers_init();\n    //软中断初始化    \n    softirq_init();    \n    timekeeping_init();\n    mem_encrypt_init();\n    //每个cpu页面集初始化\n    setup_per_cpu_pageset();    \n    //fork初始化建立进程的 \n    fork_init();    \n    proc_caches_init();    \n    uts_ns_init();\n    //内核缓冲区初始化    \n    buffer_init();    \n    key_init();    \n    //安全相关的初始化\n    security_init();  \n    //VFS数据结构内存池初始化  \n    vfs_caches_init();\n    //页缓存初始化    \n    pagecache_init();\n    //进程信号初始化    \n    signals_init();    \n    //运行第一个进程 \n    arch_call_rest_init();\n}\n</code></pre><p>start_kernel函数我如果不做精简，会有200多行，全部都是初始化函数，我只留下几个主要的初始化函数，这些函数的实现细节我们无需关心。</p><p>可以看到，Linux内核所有功能的初始化函数都是在start_kernel函数中调用的，这也是它如此出名，如此重要的原因。</p><p>一旦start_kernel函数执行完成，Linux内核就具备了向应用程序提供一系列功能服务的能力。这里对我们而言，我们只关注一个arch_call_rest_init函数。下面我们就来研究它。 如下所示。</p><pre><code>void __init __weak arch_call_rest_init(void){    \n    rest_init();\n}\n</code></pre><p>这个函数其实非常简单，它是一个<strong>包装函数</strong>，其中只是直接调用了rest_init函数。</p><p>rest_init函数的重要功能就是建立了两个Linux内核线程，我们看看精简后的rest_init函数：</p><pre><code>noinline void __ref rest_init(void){    struct task_struct *tsk;\n    int pid;\n    //建立kernel_init线程\n    pid = kernel_thread(kernel_init, NULL, CLONE_FS);   \n    //建立khreadd线程 \n    pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n}\n</code></pre><p>Linux内核线程可以执行一个内核函数， 只不过这个函数有独立的线程上下文，可以被Linux的进程调度器调度，对于kernel_init线程来说，执行的就是kernel_init函数。</p><h2>Linux的第一个用户进程</h2><p>当我们可以建立第一个用户进程的时候，就代表Linux内核的初始流程已经基本完成。</p><p>经历了“长途跋涉”，我们也终于走到了这里<strong>。Linux内核的第一个用户态进程是在kernel_init线程建立的，而kernel_init线程执行的就是kernel_init函数。</strong>那kernel_init函数到底做了什么呢？</p><pre><code>static int __ref kernel_init(void *unused){   \n     int ret;\n     if (ramdisk_execute_command) {       \n         ret = run_init_process(ramdisk_execute_command);        \n         if (!ret)            \n             return 0;        \n         pr_err(&quot;Failed to execute %s (error %d)\\n&quot;,ramdisk_execute_command, ret);    \n     }\n     if (execute_command) {        \n         ret = run_init_process(execute_command);        \n         if (!ret)            \n         return 0;        \n         panic(&quot;Requested init %s failed (error %d).&quot;,              execute_command, ret);    \n     }\n    if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||                    !try_to_run_init_process(&quot;/etc/init&quot;) ||        !try_to_run_init_process(&quot;/bin/init&quot;) ||        !try_to_run_init_process(&quot;/bin/sh&quot;))        \n    return 0;\npanic(&quot;No working init found.  Try passing init= option to kernel. &quot;          &quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;);\n}\n</code></pre><p>结合上述代码，可以发现ramdisk_execute_command和execute_command都是内核启动时传递的参数，它们可以在GRUB启动选项中设置。</p><p>比方说，通常引导内核时向command line传递的参数都是 init=xxx ，而对于initrd 则是传递 rdinit=xxx 。</p><p>但是，通常我们不会传递参数，所以这个函数会执行到上述代码的15行，依次尝试以/sbin/init、/etc/init、/bin/init、/bin/sh这些文件为可执行文件建立进程，但是只要其中之一成功就行了。</p><p>try_to_run_init_process和run_init_process函数的核心都是调用sys_fork函数建立进程的，这里我们不用关注它的实现细节。</p><p>到这里，Linux内核已经建立了第一个进程，Linux内核的初始化流程也到此为止了。</p><h2>重点回顾</h2><p>又到了课程尾声，Linux初始化流程的学习我们就告一段落了，我来给你做个总结。</p><p>今天我们讲得内容有点多，我们从_start开始到startup32、startup64函数 ，到extract_kernel函数解压出真正的Linux内核文件vmlinux开始，然后从Linux内核的入口函数startup_64到Linux内核第一个C函数，最后接着从Linux内核start_kernel函数的建立 ，说到了第一个用户进程。</p><p>一起来回顾一下这节课的重点：</p><p>1.GRUB加载vmlinuz文件之后，会把控制权交给vmlinuz文件的setup.bin的部分中_start，它会设置好栈，清空bss，设置好setup_header结构，调用16位main切换到保护模式，最后跳转到1MB处的vmlinux.bin文件中。</p><p>2.从vmlinux.bin文件中startup32、startup64函数开始建立新的全局段描述符表和MMU页表，切换到长模式下解压vmlinux.bin.gz。释放出vmlinux文件之后，由解析elf格式的函数进行解析，释放vmlinux中的代码段和数据段到指定的内存。然后调用其中的startup_64函数，在这个函数的最后调用Linux内核的第一个C函数。</p><p>3.Linux内核第一个C函数重新设置MMU页表，随后便调用了最有名的start_kernel函数， start_kernel函数中调用了大多数 Linux内核功能性初始化函数，在最后调用rest_init函数建立了两个内核线程，在其中的kernel_init线程建立了第一个用户态进程。</p><p><img src=\"https://static001.geekbang.org/resource/image/09/58/0910c3a68df6dde27b511cf13f85d158.jpg\" alt=\"\" title=\"Linux 初始化要点示意图\"></p><p>不知道你感觉到没有，Linux的启动流程相比于我们的Cosmos启动流程复杂得多。</p><p>Linux之所以如此复杂，是因为它把完成各种功能的模块组装了一起，而我们Cosmos则把内核之前的初始化工作，分离出来，形成二级引导器，二级引导器也是由多文件模块组成的，最后用我们的映像工具把它们封装在一起。</p><p>对比之下，你就可以明白，<strong>软件工程模块化</strong>是多么重要了。</p><h2>思考题</h2><p>你能指出上文中Linux初始化流程里，主要函数都被链接到哪些对应的二进制文件中了？</p><p>欢迎你在留言区跟我交流互动，也欢迎你把这节课分享给同事、朋友。</p><p>我是LMOS，我们下节课见！</p>","neighbors":{"left":{"article_title":"14 | Linux初始化（上）：GRUB与vmlinuz的结构","id":382733},"right":{"article_title":"16 | 划分土地（上）：如何划分与组织内存？","id":384366}},"comments":[]}