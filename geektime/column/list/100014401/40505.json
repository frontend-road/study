{"id":40505,"title":"16 | 如何搭建一套适合你的服务追踪系统？","content":"<p><a href=\"http://time.geekbang.org/column/article/15273\">专栏第8期</a>我给你讲了服务追踪系统的原理以及实现，简单回顾一下服务追踪系统的实现，主要包括三个部分。</p>\n<ul>\n<li>\n<p>埋点数据收集，负责在服务端进行埋点，来收集服务调用的上下文数据。</p>\n</li>\n<li>\n<p>实时数据处理，负责对收集到的链路信息，按照traceId和spanId进行串联和存储。</p>\n</li>\n<li>\n<p>数据链路展示，把处理后的服务调用数据，按照调用链的形式展示出来。</p>\n</li>\n</ul>\n<p>如果要自己从0开始实现一个服务追踪系统，针对以上三个部分你都必须有相应的解决方案。首先你需要在业务代码的框架层开发调用拦截程序，在调用的前后收集相关信息，把信息传输给到一个统一的处理中心。然后处理中心需要实时处理收集到链路信息，并按照traceId和spanId进行串联，处理完以后再存到合适的存储中。最后还要能把存储中存储的信息，以调用链路图或者调用拓扑图的形式对外展示。</p>\n<p>可以想象这个技术难度以及开发工作量都不小，对于大部分中小业务团队来说，都十分具有挑战。不过幸运的是，业界已经有不少开源的服务追踪系统实现，并且应用范围也已经十分广泛，对大部分的中小业务团队来说，足以满足对服务追踪系统的需求。</p>\n<p>业界比较有名的服务追踪系统实现有阿里的鹰眼、Twitter开源的OpenZipkin，还有Naver开源的Pinpoint，它们都是受Google发布的Dapper论文启发而实现的。其中阿里的鹰眼解决方案没有开源，而且由于阿里需要处理数据量比较大，所以鹰眼的定位相对定制化，不一定适合中小规模的业务团队，感兴趣的同学可以点击本期文章末尾“拓展阅读”进行学习。</p><!-- [[[read_end]]] -->\n<p><span class=\"orange\">下面我主要来介绍下开源实现方案OpenZipkin和Pinpoint，再看看它们有什么区别。</span></p>\n<h2>OpenZipkin</h2>\n<p>OpenZipkin是Twitter开源的服务追踪系统，下面这张图展示了它的架构设计。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/69/33/699916c60cd31a2b8d7ab0335038cf33.png?wh=661*504\" alt=\"\" /><br />\n（图片来源：<a href=\"https://zipkin.io/public/img/architecture-1.png\">https://zipkin.io/public/img/architecture-1.png</a>）</p>\n<p>从图中看，OpenZipkin主要由四个核心部分组成。</p>\n<ul>\n<li>\n<p>Collector：负责收集探针Reporter埋点采集的数据，经过验证处理并建立索引。</p>\n</li>\n<li>\n<p>Storage：存储服务调用的链路数据，默认使用的是Cassandra，是因为Twitter内部大量使用了Cassandra，你也可以替换成Elasticsearch或者MySQL。</p>\n</li>\n<li>\n<p>API：将格式化和建立索引的链路数据以API的方式对外提供服务，比如被UI调用。</p>\n</li>\n<li>\n<p>UI：以图形化的方式展示服务调用的链路数据。</p>\n</li>\n</ul>\n<p>它的工作原理可以用下面这张图来描述。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/4c/d9/4c036659e0d14176215686f1a1129ed9.png?wh=692*912\" alt=\"\" /><br />\n（图片来源：<a href=\"https://zipkin.io/pages/architecture.html\">https://zipkin.io/pages/architecture.html</a>）</p>\n<p>具体流程是，通过在业务的HTTP Client前后引入服务追踪代码，这样在HTTP方法“/foo”调用前，生成trace信息：TraceId：aa、SpanId：6b、annotation：GET /foo，以及当前时刻的timestamp：1483945573944000，然后调用结果返回后，记录下耗时duration，之后再把这些trace信息和duration异步上传给Zipkin Collector。</p>\n<h2>Pinpoint</h2>\n<p>Pinpoint是Naver开源的一款深度支持Java语言的服务追踪系统，下面这张图是它的架构设计。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/d8/a4/d8b526a56b633c34364924a2d00905a4.png?wh=769*428\" alt=\"\" /><br />\n（图片来源：<a href=\"http://naver.github.io/pinpoint/1.7.3/images/pinpoint-architecture.png\">http://naver.github.io/pinpoint/1.7.3/images/pinpoint-architecture.png</a>）</p>\n<p>Pinpoint主要也由四个部分组成。</p>\n<ul>\n<li>\n<p>Pinpoint Agent：通过Java字节码注入的方式，来收集JVM中的调用数据，通过UDP协议传递给Collector，数据采用Thrift协议进行编码。</p>\n</li>\n<li>\n<p>Pinpoint Collector：收集Agent传过来的数据，然后写到HBase Storgage。</p>\n</li>\n<li>\n<p>HBase Storage：采用HBase集群存储服务调用的链路信息。</p>\n</li>\n<li>\n<p>Pinpoint Web UI：通过Web UI展示服务调用的详细链路信息。</p>\n</li>\n</ul>\n<p>它的工作原理你可以看这张图。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/87/95/8730864e70d666267e40e1cc4d622195.png?wh=1102*690\" alt=\"\" /><br />\n（图片来源：<a href=\"http://naver.github.io/pinpoint/1.7.3/images/td_figure6.png\">http://naver.github.io/pinpoint/1.7.3/images/td_figure6.png</a>）</p>\n<p>具体来看，就是请求进入TomcatA，然后生成TraceId：TomcatA^ TIME ^ 1、SpanId：10、pSpanId：-1（代表是根请求），接着TomatA调用TomcatB的hello方法，TomcatB生成TraceId：TomcatA^ TIME ^1、新的SpanId：20、pSpanId：10（代表是TomcatA的请求），返回调用结果后将trace信息发给Collector，TomcatA收到调用结果后，将trace信息也发给Collector。Collector把trace信息写入到HBase中，Rowkey就是traceId，SpanId和pSpanId都是列。然后就可以通过UI查询调用链路信息了。</p>\n<h2>选型对比</h2>\n<p>根据我的经验，考察服务追踪系统主要从下面这几个方面。</p>\n<p><strong>1. 埋点探针支持平台的广泛性</strong></p>\n<p>OpenZipkin和Pinpoint都支持哪些语言平台呢？</p>\n<p>OpenZipkin提供了不同语言的Library，不同语言实现时需要引入不同版本的Library。</p>\n<p>官方提供了C#、Go、Java、JavaScript、Ruby、Scala、PHP等主流语言版本的Library，而且开源社区还提供了更丰富的不同语言版本的Library，详细的可以点击<a href=\"https://zipkin.io/pages/existing_instrumentations\">这里</a>查看；而Pinpoint目前只支持Java语言。</p>\n<p>所以从探针支持的语言平台广泛性上来看，OpenZipkin比Pinpoint的使用范围要广，而且开源社区很活跃，生命力更强。</p>\n<p><strong>2. 系统集成难易程度</strong></p>\n<p>再来看下系统集成的难易程度。</p>\n<p>以OpenZipkin的Java探针Brave为例，它只提供了基本的操作API，如果系统要想集成Brave，必须在配置里手动里添加相应的配置文件并且增加trace业务代码。具体来讲，就是你需要先修改工程的POM依赖，以引入Brave相关的JAR包。</p>\n<pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;io.zipkin.brave&lt;/groupId&gt;\n        &lt;artifactId&gt;brave-bom&lt;/artifactId&gt;\n        &lt;version&gt;${brave.version}&lt;/version&gt;\n        &lt;type&gt;pom&lt;/type&gt;\n        &lt;scope&gt;import&lt;/scope&gt;\n      &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n  &lt;/dependencyManagement&gt;\n</code></pre>\n<p>然后假如你想收集每一次HTTP调用的信息，你就可以使用Brave在Apache Httpclient基础上封装的httpClient，它会记录每一次HTTP调用的信息，并上报给OpenZipkin。</p>\n<pre><code>httpclient =TracingHttpClientBuilder.create(tracing).build();\n</code></pre>\n<p>而Pinpoint是通过字节码注入的方式来实现拦截服务调用，从而收集trace信息的，所以不需要代码做任何改动。Java字节码注入的大致原理你可以参考下图。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/4a/75/4a27448c52515020c1f687e8e3567875.png?wh=1071*617\" alt=\"\" /><br />\n（图片来源：<a href=\"http://naver.github.io/pinpoint/1.7.3/images/td_figure3.png\">http://naver.github.io/pinpoint/1.7.3/images/td_figure3.png</a>）</p>\n<p>我来解释一下，就是JVM在加载class二进制文件时，动态地修改加载的class文件，在方法的前后执行拦截器的before()和after()方法，在before()和after()方法里记录trace()信息。而应用不需要修改业务代码，只需要在JVM启动时，添加类似下面的启动参数就可以了。</p>\n<pre><code>-javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar\n-Dpinpoint.agentId=&lt;Agent's UniqueId&gt;\n-Dpinpoint.applicationName=&lt;The name indicating a same service (AgentId collection)\n</code></pre>\n<p>所以从系统集成难易程度上看，Pinpoint要比OpenZipkin简单。</p>\n<p><strong>3. 调用链路数据的精确度</strong></p>\n<p>从下面这张OpenZipkin的调用链路图可以看出，OpenZipkin收集到的数据只到接口级别，进一步的信息就没有了。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/33/23/33c924c5563be070416d8133e255af23.jpg?wh=1920*398\" alt=\"\" /><br />\n（图片来源：<a href=\"http://ovcjgn2x0.bkt.clouddn.com/zipkin-info.jpg\">http://ovcjgn2x0.bkt.clouddn.com/zipkin-info.jpg</a>）</p>\n<p>再来看下Pinpoint，因为Pinpoint采用了字节码注入的方式实现trace信息收集，所以它能拿到的信息比OpenZipkin多得多。从下面这张图可以看出，它不仅能够查看接口级别的链路调用信息，还能深入到调用所关联的数据库信息。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/5f/3e/5f365d3c49cdb113bf6b08f5e3b36e3e.jpg?wh=1920*752\" alt=\"\" /><br />\n（图片来源：<a href=\"http://ovcjgn2x0.bkt.clouddn.com/pp-info.jpg\">http://ovcjgn2x0.bkt.clouddn.com/pp-info.jpg</a>）</p>\n<p>同理在绘制链路拓扑图时，OpenZipkin只能绘制服务与服务之间的调用链路拓扑图，比如下面这张示意图。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/a7/e9/a7575c0826b77d236ddffe92d4d3c1e9.jpg?wh=1920*830\" alt=\"\" /><br />\n（图片来源：<a href=\"http://ovcjgn2x0.bkt.clouddn.com/zipdependency1.jpg\">http://ovcjgn2x0.bkt.clouddn.com/zipdependency1.jpg</a>）</p>\n<p>而Pinpoint不仅能够绘制服务与服务之间，还能绘制与DB之间的调用链路拓扑图，比如下图。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/e5/1e/e59d46aa62e542246732ab9a985d281e.jpg?wh=1164*643\" alt=\"\" /><br />\n（图片来源：<a href=\"http://ovcjgn2x0.bkt.clouddn.com/ppreal.jpg\">http://ovcjgn2x0.bkt.clouddn.com/ppreal.jpg</a>）</p>\n<p>所以，从调用链路数据的精确度上看，Pinpoint要比OpenZipkin精确得多。</p>\n<h2>总结</h2>\n<p>今天我给你讲解了两个开源服务追踪系统OpenZipkin和Pinpoint的具体实现，并从埋点探针支持平台广泛性、系统集成难易程度、调用链路数据精确度三个方面对它们进行了对比。</p>\n<p>从选型的角度来讲，如果你的业务采用的是Java语言，那么采用Pinpoint是个不错的选择，因为它不需要业务改动一行代码就可以实现trace信息的收集。除此之外，Pinpoint不仅能看到服务与服务之间的链路调用，还能看到服务内部与资源层的链路调用，功能更为强大，如果你有这方面的需求，Pinpoint正好能满足。</p>\n<p>如果你的业务不是Java语言实现，或者采用了多种语言，那毫无疑问应该选择OpenZipkin，并且，由于其开源社区很活跃，基本上各种语言平台都能找到对应的解决方案。不过想要使用OpenZipkin，还需要做一些额外的代码开发工作，以引入OpenZipkin提供的Library到你的系统中。</p>\n<p>除了OpenZipkin和Pinpoint，业界还有其他开源追踪系统实现，比如Uber开源的Jaeger，以及国内的一款开源服务追踪系统SkyWalking。不过由于目前应用范围不是很广，这里就不详细介绍了，感兴趣的同学可以点击“拓展阅读”自行学习。</p>\n<h2>思考题</h2>\n<p>OpenZipkin在探针采集完数据后有两种方式把数据传递给Collector，一种是通过HTTP调用，一种是基于MQ的异步通信方式，比如使用RabbitMQ或者Kafka，你觉得哪种方式更好一些？为什么？</p>\n<p>欢迎你在留言区写下自己的思考，与我一起讨论。</p>\n<hr />\n<p><strong>拓展阅读：</strong></p>\n<p>阿里巴巴鹰眼：<a href=\"http://ppt.geekbang.org/slide/download/939/595f4cdcb9d52.pdf/18\">http://ppt.geekbang.org/slide/download/939/595f4cdcb9d52.pdf/18</a></p>\n<p>Jaeger：<a href=\"https://www.jaegertracing.io\">https://www.jaegertracing.io</a></p>\n<p>SkyWalking：<a href=\"https://github.com/apache/incubator-skywalking\">https://github.com/apache/incubator-skywalking</a></p>\n<p></p>\n","comments":[{"had_liked":false,"id":28112,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1538009587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"117502126579","product_id":100014401,"comment_content":"http效率低，但是无需做额外的工作，mq吞吐量更大，但是需要部署，所以视数据量而定，如果数据量小，http就可以，数据量大，就要用到mq","like_count":28},{"had_liked":false,"id":30408,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1538830117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57373404965","product_id":100014401,"comment_content":"我的回答来自《Spring微服务实战》<br>1、使用Spring Cloud可以很方便的集成Zipkin，详见“第9章 使用Spring Cloud Sleuth 和 Zipkin进行分布式跟踪》<br>2、从功能角度来看，不管使用HTTP、RabbitMQ、Kafka，Zipkin的行为没有任何差异。通过使用HTTP追踪，Zipkin使用异步线程发送性能数据。另外使用RabbitMQ或Kafka来收集跟踪数据的主要优势是，如果Zipkin服务器关闭，任何发送给Zipkin的跟踪信息都将”排队“，直到Zipkin能够收集数据。（238页）","like_count":14},{"had_liked":false,"id":31375,"user_name":"arebya","can_delete":false,"product_type":"c1","uid":1142802,"ip_address":"","ucode":"074ECE8D6C1874","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/12/aa74da82.jpg","comment_is_top":false,"comment_ctime":1539165755,"is_pvip":false,"replies":[{"id":"11329","content":"嗯，从开源社区角度考虑，openzipkin要比pinpoint更符合","user_name":"作者回复","user_name_real":"古月中心相心","uid":"1010144","ctime":1539223650,"ip_address":"","comment_id":31375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31603936827","product_id":100014401,"comment_content":"在项目中我们也对比过zipkin和pinpoint，个人认为还要考虑以下几方面：<br>1、定制成本   两者都需要对中间件进行定制化的开发，zipkin开源社区更活跃些，遇到的问题也比较容易解决。pinpoint自身支持了很多的plugin,如果想要二次开发，需要了解它的扩展机制，代码上来说会稍微复杂。<br>2、维护成本   pinpoint需要维护单独的hbase集群（当然hdfs也少不了）<br>3、规范   pinpoint是自己走的一套，没有遵守opentracing标准规范，zipkin已有相应实现","like_count":8,"discussions":[{"author":{"id":1010144,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/69/e0/ff8ee2e2.jpg","nickname":"胡忠想","note":"","ucode":"0792605FC265B4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426311,"discussion_content":"嗯，从开源社区角度考虑，openzipkin要比pinpoint更符合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539223650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91217,"user_name":"凌天","can_delete":false,"product_type":"c1","uid":1109551,"ip_address":"","ucode":"761344882F4432","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/2f/aecf69a5.jpg","comment_is_top":false,"comment_ctime":1556935064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27326738840","product_id":100014401,"comment_content":"跟大众点评的cat区别呢","like_count":7},{"had_liked":false,"id":28679,"user_name":"focus　根","can_delete":false,"product_type":"c1","uid":1126545,"ip_address":"","ucode":"4FD612ACE353E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/91/75a69d33.jpg","comment_is_top":false,"comment_ctime":1538125832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14423027720","product_id":100014401,"comment_content":"我是做Android音视频开发的 现在想往后台和微服务方向转  想问问作者有什么看法呢","like_count":4},{"had_liked":false,"id":28761,"user_name":"楼下小黑哥","can_delete":false,"product_type":"c1","uid":1014680,"ip_address":"","ucode":"453B099B0EE52E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg","comment_is_top":false,"comment_ctime":1538141631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10128076223","product_id":100014401,"comment_content":"基于不同场景选择不一样。本来刚看到问题，本人觉得第一想法就是MQ比较适合。但是使用MQ 需要搭建相应的消息系统。这就相对引入一些复杂度。对于前期项目刚开始，可以使用http，能快速对接上追踪系统。而随着后期项目渐入稳定，然后 http 的调用相对而言，效率偏低，如果并发十分大，可能会影响项目原本的稳定性。这个时候就可以考虑使用MQ，提高吞吐量。<br> 哈哈 说个题外话，总感觉要在代合耦合这种代码，就感觉十分不舒服。：（","like_count":2},{"had_liked":false,"id":106982,"user_name":"萧箫萧","can_delete":false,"product_type":"c1","uid":1218358,"ip_address":"","ucode":"B8259F3CDFCCAD","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/36/6addd2b6.jpg","comment_is_top":false,"comment_ctime":1561431565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856398861","product_id":100014401,"comment_content":"对于微服务架构模式下，主业务应用和后端子业务应用通过nginx网关代理，这种情况下 如何在nginx上对接pinpoint链路追踪呢？","like_count":1},{"had_liked":false,"id":28677,"user_name":"金hb.Ryan 冷空氣駕到","can_delete":false,"product_type":"c1","uid":1222233,"ip_address":"","ucode":"CAD363576696E4","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/59/1689ea0c.jpg","comment_is_top":false,"comment_ctime":1538125323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833092619","product_id":100014401,"comment_content":"留言支持mq但我觉得可能http侵入更低，http层后面可以接入kafka等. <br>我们内部其实也做了类似dapper做参考的链路系统，有个问题1如何考虑采样率的实现，2pinpoint每个层都trace一下会不会有性能问题？","like_count":1},{"had_liked":false,"id":28673,"user_name":"herome","can_delete":false,"product_type":"c1","uid":1097654,"ip_address":"","ucode":"F00A539371C206","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/b6/ee3b4ef7.jpg","comment_is_top":false,"comment_ctime":1538124680,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5833091976","product_id":100014401,"comment_content":"美团的OCTO 很不错","like_count":1},{"had_liked":false,"id":28241,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1538030970,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5832998266","product_id":100014401,"comment_content":"spring cloud全家桶居然没有自己实现的服务追踪系统？","like_count":1,"discussions":[{"author":{"id":1481744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/10/14c70627.jpg","nickname":"CrossOrigin","note":"","ucode":"472ECAAC7573DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289942,"discussion_content":"Sleuth ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594277229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28079,"user_name":"黄朋飞","can_delete":false,"product_type":"c1","uid":1107062,"ip_address":"","ucode":"A1E7E0460A1BCC","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/76/a97242c0.jpg","comment_is_top":false,"comment_ctime":1538006562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832973858","product_id":100014401,"comment_content":"消息队列更合适一些，原因1 服务某一段时间耗时增加不至于影响现有服务的调用。2 采用消息队列可以有效控制消费舒服，对于缓解存储端压力是个不错的选择。3 消息队列吞吐量更强","like_count":1},{"had_liked":false,"id":28077,"user_name":"doubleRabbit","can_delete":false,"product_type":"c1","uid":1047296,"ip_address":"","ucode":"3EE93C493D3431","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/00/fed9a47b.jpg","comment_is_top":false,"comment_ctime":1538006510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832973806","product_id":100014401,"comment_content":"kafka合适些，它原本定位于日志领域，为了解决数据一致性不那么高，而并发量，可扩展性要求高的场景，现在已聚焦与分布式的流式平台，监控类的业务合适。","like_count":1},{"had_liked":false,"id":314950,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633609266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633609266","product_id":100014401,"comment_content":"服务追踪的作用：<br>  1、优化系统瓶颈<br>  2、优化链路调用<br>  3、生成网络拓扑<br>  4、透明传输数据<br><br>服务追踪系统主要包括三个部分：<br>  1、埋点数据收集<br>  2、实时数据处理<br>  3、数据链路展示<br><br>业界比较有名的服务追踪系统实现有阿里的鹰眼、Twitter 开源的 OpenZipkin，还有 Naver 开源的 Pinpoint。<br><br>其中Pinpoint是和Java平台深度结合的，Pinpoint 不仅能看到服务与服务之间的链路调用，还能看到服务内部与资源层的链路调用。OpenZipkin 提供了不同语言的 Library，不同语言实现时需要引入不同版本的 Library。官方提供了 C#、Go、Java、JavaScript、Ruby、Scala、PHP 等主流语言版本的 Library，而且开源社区还提供了更丰富的不同语言版本的 Library。<br><br>相对来说，Pinpoint的集成更加简单方便。","like_count":0},{"had_liked":false,"id":260052,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1604914965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604914965","product_id":100014401,"comment_content":"不错，需要一些这种文章扩展下见识，之前大佬让做trace的选型，这就是一篇不错的参考文章。","like_count":0},{"had_liked":false,"id":103887,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1560560058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560560058","product_id":100014401,"comment_content":"感谢，没直接用过，涨涨见识，感觉开源对于软件技术的发展不可限量。","like_count":0},{"had_liked":false,"id":98565,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1559030399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559030399","product_id":100014401,"comment_content":"异步mq更好，不会对原来对被追踪的业务请求产生多余影响","like_count":0},{"had_liked":false,"id":91996,"user_name":"帽子丨影","can_delete":false,"product_type":"c1","uid":1225395,"ip_address":"","ucode":"2B34892A2DE83E","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","comment_is_top":false,"comment_ctime":1557150541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557150541","product_id":100014401,"comment_content":"还是没明白服务b如何拿到服务a生成的trance id","like_count":0},{"had_liked":false,"id":84783,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1554906697,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554906697","product_id":100014401,"comment_content":"老师，看了本章后，我有一个地方不理解；假设场景，微服务A调用微服务B，那么服务B是怎么知道服务A生成的id呢？如果是调用服务时当参数传过去的，那岂不是等于侵入了业务代码了吗？有没有不侵入业务代码的方法？","like_count":0,"discussions":[{"author":{"id":1177289,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/c9/4da2a82a.jpg","nickname":"黄大仙","note":"","ucode":"337B6E811CF47D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2496,"discussion_content":"通过http走，可以放在header头里面，通过tcp走，可以放在uri里面","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563723240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57539,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1546830769,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1546830769","product_id":100014401,"comment_content":"pinpoint  性能是个硬伤","like_count":0,"discussions":[{"author":{"id":1177289,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/c9/4da2a82a.jpg","nickname":"黄大仙","note":"","ucode":"337B6E811CF47D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2497,"discussion_content":"可以搞个动态采样率之类的机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563723289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32215,"user_name":"波波安","can_delete":false,"product_type":"c1","uid":1002452,"ip_address":"","ucode":"2A677908E5A75D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/d4/b7719327.jpg","comment_is_top":false,"comment_ctime":1539486028,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1539486028","product_id":100014401,"comment_content":"我觉得采用异步通信的方式好一些。<br>1、同步http发送方式对业务代码性能影响大。<br>2、消息队列的消息可以被不同的消费组处理。数据处理更灵活。<br>3、消息队列本身也有一定的消息存储和缓冲的能力。当采集进程短时间有问题时，不会导致数据的丢失，等恢复正常后可以继续消费。","like_count":0},{"had_liked":false,"id":30819,"user_name":"____CC","can_delete":false,"product_type":"c1","uid":1214199,"ip_address":"","ucode":"0CA5623BA75E7D","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/f7/639c4760.jpg","comment_is_top":false,"comment_ctime":1539004689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539004689","product_id":100014401,"comment_content":"pinpoint支持dubbo、thrift这类非http的调用吗","like_count":0},{"had_liked":false,"id":30343,"user_name":"文敦复","can_delete":false,"product_type":"c1","uid":1195258,"ip_address":"","ucode":"B8F4A6BD5D7805","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/fa/e2990931.jpg","comment_is_top":false,"comment_ctime":1538800808,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1538800808","product_id":100014401,"comment_content":"openzipkin应该就是集成在springcloud中的吧？","like_count":0,"discussions":[{"author":{"id":1481744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/10/14c70627.jpg","nickname":"CrossOrigin","note":"","ucode":"472ECAAC7573DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289943,"discussion_content":"Sleuth 组件就是zipkin的封装","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594277284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29096,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1013850,"ip_address":"","ucode":"AF5196A960F63F","user_header":"","comment_is_top":false,"comment_ctime":1538268160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538268160","product_id":100014401,"comment_content":"mq可以支持更高的并发，更加处理更加灵活","like_count":0},{"had_liked":false,"id":28394,"user_name":"sudden","can_delete":false,"product_type":"c1","uid":1128846,"ip_address":"","ucode":"7FEF669F63CC02","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/8e/9973100b.jpg","comment_is_top":false,"comment_ctime":1538069388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538069388","product_id":100014401,"comment_content":"mq更合适些，因为低耦合","like_count":0}]}