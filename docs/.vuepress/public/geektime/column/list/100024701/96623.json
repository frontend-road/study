{"id":96623,"title":"24 | 物理内存管理（下）：会议室管理员如何分配会议室？","content":"<p>前一节，前面我们解析了整页的分配机制。如果遇到小的对象，物理内存是如何分配的呢？这一节，我们一起来看一看。</p><h2>小内存的分配</h2><p>前面我们讲过，如果遇到小的对象，会使用slub分配器进行分配。那我们就先来解析它的工作原理。</p><p>还记得咱们创建进程的时候，会调用dup_task_struct，它想要试图复制一个task_struct对象，需要先调用alloc_task_struct_node，分配一个task_struct对象。</p><p>从这段代码可以看出，它调用了kmem_cache_alloc_node函数，在task_struct的缓存区域task_struct_cachep分配了一块内存。</p><pre><code>static struct kmem_cache *task_struct_cachep;\n\ntask_struct_cachep = kmem_cache_create(&quot;task_struct&quot;,\n\t\t\tarch_task_struct_size, align,\n\t\t\tSLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT, NULL);\n\nstatic inline struct task_struct *alloc_task_struct_node(int node)\n{\n\treturn kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);\n}\n\nstatic inline void free_task_struct(struct task_struct *tsk)\n{\n\tkmem_cache_free(task_struct_cachep, tsk);\n}\n</code></pre><p>在系统初始化的时候，task_struct_cachep会被kmem_cache_create函数创建。这个函数也比较容易看懂，专门用于分配task_struct对象的缓存。这个缓存区的名字就叫task_struct。缓存区中每一块的大小正好等于task_struct的大小，也即arch_task_struct_size。</p><p>有了这个缓存区，每次创建task_struct的时候，我们不用到内存里面去分配，先在缓存里面看看有没有直接可用的，这就是<strong>kmem_cache_alloc_node</strong>的作用。</p><!-- [[[read_end]]] --><p>当一个进程结束，task_struct也不用直接被销毁，而是放回到缓存中，这就是<strong>kmem_cache_free</strong>的作用。这样，新进程创建的时候，我们就可以直接用现成的缓存中的task_struct了。</p><p>我们来仔细看看，缓存区struct kmem_cache到底是什么样子。</p><pre><code>struct kmem_cache {\n\tstruct kmem_cache_cpu __percpu *cpu_slab;\n\t/* Used for retriving partial slabs etc */\n\tunsigned long flags;\n\tunsigned long min_partial;\n\tint size;\t\t/* The size of an object including meta data */\n\tint object_size;\t/* The size of an object without meta data */\n\tint offset;\t\t/* Free pointer offset. */\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tint cpu_partial;\t/* Number of per cpu partial objects to keep around */\n#endif\n\tstruct kmem_cache_order_objects oo;\n\t/* Allocation and freeing of slabs */\n\tstruct kmem_cache_order_objects max;\n\tstruct kmem_cache_order_objects min;\n\tgfp_t allocflags;\t/* gfp flags to use on each alloc */\n\tint refcount;\t\t/* Refcount for slab cache destroy */\n\tvoid (*ctor)(void *);\n......\n\tconst char *name;\t/* Name (only for display!) */\n\tstruct list_head list;\t/* List of slab caches */\n......\n\tstruct kmem_cache_node *node[MAX_NUMNODES];\n};\n\n</code></pre><p>在struct kmem_cache里面，有个变量struct list_head list，这个结构我们已经看到过多次了。我们可以想象一下，对于操作系统来讲，要创建和管理的缓存绝对不止task_struct。难道mm_struct就不需要吗？fs_struct就不需要吗？都需要。因此，所有的缓存最后都会放在一个链表里面，也就是LIST_HEAD(slab_caches)。</p><p>对于缓存来讲，其实就是分配了连续几页的大内存块，然后根据缓存对象的大小，切成小内存块。</p><p>所以，我们这里有三个kmem_cache_order_objects类型的变量。这里面的order，就是2的order次方个页面的大内存块，objects就是能够存放的缓存对象的数量。</p><p>最终，我们将大内存块切分成小内存块，样子就像下面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/5e/172839800c8d51c49b67ec8c4d07315e.jpeg?wh=2483*1523\" alt=\"\"></p><p>每一项的结构都是缓存对象后面跟一个下一个空闲对象的指针，这样非常方便将所有的空闲对象链成一个链。其实，这就相当于咱们数据结构里面学的，用数组实现一个可随机插入和删除的链表。</p><p>所以，这里面就有三个变量：size是包含这个指针的大小，object_size是纯对象的大小，offset就是把下一个空闲对象的指针存放在这一项里的偏移量。</p><p>那这些缓存对象哪些被分配了、哪些在空着，什么情况下整个大内存块都被分配完了，需要向伙伴系统申请几个页形成新的大内存块？这些信息该由谁来维护呢？</p><p>接下来就是最重要的两个成员变量出场的时候了。kmem_cache_cpu和kmem_cache_node，它们都是每个NUMA节点上有一个，我们只需要看一个节点里面的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/0a/45f38a0c7bce8c98881bbe8b8b4c190a.jpeg?wh=2603*2033\" alt=\"\"></p><p>在分配缓存块的时候，要分两种路径，<strong>fast path</strong>和<strong>slow path</strong>，也就是<strong>快速通道</strong>和<strong>普通通道</strong>。其中kmem_cache_cpu就是快速通道，kmem_cache_node是普通通道。每次分配的时候，要先从kmem_cache_cpu进行分配。如果kmem_cache_cpu里面没有空闲的块，那就到kmem_cache_node中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</p><p>我们来看一下，kmem_cache_cpu里面是如何存放缓存块的。</p><pre><code>struct kmem_cache_cpu {\n\tvoid **freelist;\t/* Pointer to next available object */\n\tunsigned long tid;\t/* Globally unique transaction id */\n\tstruct page *page;\t/* The slab from which we are allocating */\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct page *partial;\t/* Partially allocated frozen slabs */\n#endif\n......\n};\n</code></pre><p>在这里，page指向大内存块的第一个页，缓存块就是从里面分配的。freelist指向大内存块里面第一个空闲的项。按照上面说的，这一项会有指针指向下一个空闲的项，最终所有空闲的项会形成一个链表。</p><p>partial指向的也是大内存块的第一个页，之所以名字叫partial（部分），就是因为它里面部分被分配出去了，部分是空的。这是一个备用列表，当page满了，就会从这里找。</p><p>我们再来看kmem_cache_node的定义。</p><pre><code>struct kmem_cache_node {\n\tspinlock_t list_lock;\n......\n#ifdef CONFIG_SLUB\n\tunsigned long nr_partial;\n\tstruct list_head partial;\n......\n#endif\n};\n</code></pre><p>这里面也有一个partial，是一个链表。这个链表里存放的是部分空闲的内存块。这是kmem_cache_cpu里面的partial的备用列表，如果那里没有，就到这里来找。</p><p>下面我们就来看看这个分配过程。kmem_cache_alloc_node会调用slab_alloc_node。你还是先重点看这里面的注释，这里面说的就是快速通道和普通通道的概念。</p><pre><code>/*\n * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)\n * have the fastpath folded into their functions. So no function call\n * overhead for requests that can be satisfied on the fastpath.\n *\n * The fastpath works by first checking if the lockless freelist can be used.\n * If not then __slab_alloc is called for slow processing.\n *\n * Otherwise we can simply pick the next object from the lockless free list.\n */\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n......\n\ttid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);\n\tc = raw_cpu_ptr(s-&gt;cpu_slab);\n......\n\tobject = c-&gt;freelist;\n\tpage = c-&gt;page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} \n......\n\treturn object;\n}\n</code></pre><p>快速通道很简单，取出cpu_slab也即kmem_cache_cpu的freelist，这就是第一个空闲的项，可以直接返回了。如果没有空闲的了，则只好进入普通通道，调用__slab_alloc。</p><pre><code>static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n......\nredo:\n......\n\t/* must check again c-&gt;freelist in case of cpu migration or IRQ */\n\tfreelist = c-&gt;freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\n\tfreelist = get_freelist(s, page);\n\n\n\tif (!freelist) {\n\t\tc-&gt;page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\nload_freelist:\n\tc-&gt;freelist = get_freepointer(s, freelist);\n\tc-&gt;tid = next_tid(c-&gt;tid);\n\treturn freelist;\n\n\nnew_slab:\n\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c-&gt;page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &amp;c);\n......\n\treturn freeli\n\n</code></pre><p>在这里，我们首先再次尝试一下kmem_cache_cpu的freelist。为什么呢？万一当前进程被中断，等回来的时候，别人已经释放了一些缓存，说不定又有空间了呢。如果找到了，就跳到load_freelist，在这里将freelist指向下一个空闲项，返回就可以了。</p><p>如果freelist还是没有，则跳到new_slab里面去。这里面我们先去kmem_cache_cpu的partial里面看。如果partial不是空的，那就将kmem_cache_cpu的page，也就是快速通道的那一大块内存，替换为partial里面的大块内存。然后redo，重新试下。这次应该就可以成功了。</p><p>如果真的还不行，那就要到new_slab_objects了。</p><pre><code>static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\n\tfreelist = get_partial(s, flags, node, c);\n\n\n\tif (freelist)\n\t\treturn freelist;\n\n\n\tpage = new_slab(s, flags, node);\n\tif (page) {\n\t\tc = raw_cpu_ptr(s-&gt;cpu_slab);\n\t\tif (c-&gt;page)\n\t\t\tflush_slab(s, c);\n\n\n\t\tfreelist = page-&gt;freelist;\n\t\tpage-&gt;freelist = NULL;\n\n\n\t\tstat(s, ALLOC_SLAB);\n\t\tc-&gt;page = page;\n\t\t*pc = c;\n\t} else\n\t\tfreelist = NULL;\n\n\n\treturn freelis\n</code></pre><p>在这里面，get_partial会根据node id，找到相应的kmem_cache_node，然后调用get_partial_node，开始在这个节点进行分配。</p><pre><code>/*\n * Try to allocate a partial slab from a specific node.\n */\nstatic void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tint available = 0;\n\tint objects;\n......\n\tlist_for_each_entry_safe(page, page2, &amp;n-&gt;partial, lru) {\n\t\tvoid *t;\n\n\n\t\tt = acquire_slab(s, n, page, object == NULL, &amp;objects);\n\t\tif (!t)\n\t\t\tbreak;\n\n\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc-&gt;page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available &gt; slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\t}\n......\n\treturn object;\n</code></pre><p>acquire_slab会从kmem_cache_node的partial链表中拿下一大块内存来，并且将freelist，也就是第一块空闲的缓存块，赋值给t。并且当第一轮循环的时候，将kmem_cache_cpu的page指向取下来的这一大块内存，返回的object就是这块内存里面的第一个缓存块t。如果kmem_cache_cpu也有一个partial，就会进行第二轮，再次取下一大块内存来，这次调用put_cpu_partial，放到kmem_cache_cpu的partial里面。</p><p>如果kmem_cache_node里面也没有空闲的内存，这就说明原来分配的页里面都放满了，就要回到new_slab_objects函数，里面new_slab函数会调用allocate_slab。</p><pre><code>static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s-&gt;oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p;\n\tint idx, order;\n\tbool shuffle;\n\n\n\tflags &amp;= gfp_allowed_mask;\n......\n\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\tif (unlikely(!page)) {\n\t\too = s-&gt;min;\n\t\talloc_gfp = flags;\n\t\t/*\n\t\t * Allocation may have failed due to fragmentation.\n\t\t * Try a lower order alloc if possible\n\t\t */\n\t\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\t\tif (unlikely(!page))\n\t\t\tgoto out;\n\t\tstat(s, ORDER_FALLBACK);\n\t}\n......\n\treturn page;\n}\n</code></pre><p>在这里，我们看到了alloc_slab_page分配页面。分配的时候，要按kmem_cache_order_objects里面的order来。如果第一次分配不成功，说明内存已经很紧张了，那就换成min版本的kmem_cache_order_objects。</p><p>好了，这个复杂的层层分配机制，我们就讲到这里，你理解到这里也就够用了。</p><h2>页面换出</h2><p>另一个物理内存管理必须要处理的事情就是，页面换出。每个进程都有自己的虚拟地址空间，无论是32位还是64位，虚拟地址空间都非常大，物理内存不可能有这么多的空间放得下。所以，一般情况下，页面只有在被使用的时候，才会放在物理内存中。如果过了一段时间不被使用，即便用户进程并没有释放它，物理内存管理也有责任做一定的干预。例如，将这些物理内存中的页面换出到硬盘上去；将空出的物理内存，交给活跃的进程去使用。</p><p>什么情况下会触发页面换出呢？</p><p>可以想象，最常见的情况就是，分配内存的时候，发现没有地方了，就试图回收一下。例如，咱们解析申请一个页面的时候，会调用get_page_from_freelist，接下来的调用链为get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node，通过这个调用链可以看出，页面换出也是以内存节点为单位的。</p><p>当然还有一种情况，就是作为内存管理系统应该主动去做的，而不能等真的出了事儿再做，这就是内核线程<strong>kswapd</strong>。这个内核线程，在系统初始化的时候就被创建。这样它会进入一个无限循环，直到系统停止。在这个循环中，如果内存使用没有那么紧张，那它就可以放心睡大觉；如果内存紧张了，就需要去检查一下内存，看看是否需要换出一些内存页。</p><pre><code>/*\n * The background pageout daemon, started as a kernel thread\n * from the init process.\n *\n * This basically trickles out pages so that we have _some_\n * free memory available even if there is no other activity\n * that frees anything up. This is needed for things like routing\n * etc, where we otherwise might have all activity going on in\n * asynchronous contexts that cannot page things out.\n *\n * If there are applications that are active memory-allocators\n * (most normal use), this basically shouldn't matter.\n */\nstatic int kswapd(void *p)\n{\n\tunsigned int alloc_order, reclaim_order;\n\tunsigned int classzone_idx = MAX_NR_ZONES - 1;\n\tpg_data_t *pgdat = (pg_data_t*)p;\n\tstruct task_struct *tsk = current;\n\n\n    for ( ; ; ) {\n......\n        kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,\n\t\t\t\t\tclasszone_idx);\n......\n        reclaim_order = balance_pgdat(pgdat, alloc_order, classzone_idx);\n......\n    }\n}\n\n</code></pre><p>这里的调用链是balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node，是以内存节点为单位的，最后也是调用shrink_node。</p><p>shrink_node会调用shrink_node_memcg。这里面有一个循环处理页面的列表，看这个函数的注释，其实和上面我们想表达的内存换出是一样的。</p><pre><code>/*\n * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.\n */\nstatic void shrink_node_memcg(struct pglist_data *pgdat, struct mem_cgroup *memcg,\n\t\t\t      struct scan_control *sc, unsigned long *lru_pages)\n{\n......\n\tunsigned long nr[NR_LRU_LISTS];\n\tenum lru_list lru;\n......\n\twhile (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||\n\t\t\t\t\tnr[LRU_INACTIVE_FILE]) {\n\t\tunsigned long nr_anon, nr_file, percentage;\n\t\tunsigned long nr_scanned;\n\n\n\t\tfor_each_evictable_lru(lru) {\n\t\t\tif (nr[lru]) {\n\t\t\t\tnr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);\n\t\t\t\tnr[lru] -= nr_to_scan;\n\n\n\t\t\t\tnr_reclaimed += shrink_list(lru, nr_to_scan,\n\t\t\t\t\t\t\t    lruvec, memcg, sc);\n\t\t\t}\n\t\t}\n......\n\t}\n......\n</code></pre><p>这里面有个lru列表。从下面的定义，我们可以想象，所有的页面都被挂在LRU列表中。LRU是Least Recent Use，也就是最近最少使用。也就是说，这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。</p><p>内存页总共分两类，一类是<strong>匿名页</strong>，和虚拟地址空间进行关联；一类是<strong>内存映射</strong>，不但和虚拟地址空间关联，还和文件管理关联。</p><p>它们每一类都有两个列表，一个是active，一个是inactive。顾名思义，active就是比较活跃的，inactive就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p><pre><code>enum lru_list {\n\tLRU_INACTIVE_ANON = LRU_BASE,\n\tLRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,\n\tLRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,\n\tLRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,\n\tLRU_UNEVICTABLE,\n\tNR_LRU_LISTS\n};\n\n\n#define for_each_evictable_lru(lru) for (lru = 0; lru &lt;= LRU_ACTIVE_FILE; lru++)\n\n\nstatic unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,\n\t\t\t\t struct lruvec *lruvec, struct mem_cgroup *memcg,\n\t\t\t\t struct scan_control *sc)\n{\n\tif (is_active_lru(lru)) {\n\t\tif (inactive_list_is_low(lruvec, is_file_lru(lru),\n\t\t\t\t\t memcg, sc, true))\n\t\t\tshrink_active_list(nr_to_scan, lruvec, sc, lru);\n\t\treturn 0;\n\t}\n\n\n\treturn shrink_inactive_list(nr_to_scan, lruvec, sc, lru);\n</code></pre><p>从上面的代码可以看出，shrink_list会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，shrink_inactive_list就需要对页面进行回收；对于匿名页来讲，需要分配swap，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p><h2>总结时刻</h2><p>好了，对于物理内存的管理就讲到这里了，我们来总结一下。对于物理内存来讲，从下层到上层的关系及分配模式如下：</p><ul>\n<li>\n<p>物理内存分NUMA节点，分别进行管理；</p>\n</li>\n<li>\n<p>每个NUMA节点分成多个内存区域；</p>\n</li>\n<li>\n<p>每个内存区域分成多个物理页面；</p>\n</li>\n<li>\n<p>伙伴系统将多个连续的页面作为一个大的内存块分配给上层；</p>\n</li>\n<li>\n<p>kswapd负责物理页面的换入换出；</p>\n</li>\n<li>\n<p>Slub Allocator将从伙伴系统申请的大内存块切成小块，分配给其他系统。</p>\n</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/52/54/527e5c861fd06c6eb61a761e4214ba54.jpeg?wh=2368*1693\" alt=\"\"></p><h2>课堂练习</h2><p>内存的换入和换出涉及swap分区，那你知道如何检查当前swap分区情况，如何启用和关闭swap区域，如何调整swappiness吗？</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","neighbors":{"left":{"article_title":"23 | 物理内存管理（上）：会议室管理员如何分配会议室？","id":96103},"right":{"article_title":"25 | 用户态内存映射：如何找到正确的会议室？","id":97030}},"comments":[{"had_liked":false,"id":97552,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1558693218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"130407712098","product_id":100024701,"comment_content":"- 小内存分配, 例如分配 task_struct 对象<br>    - 会调用 kmem_cache_alloc_node 函数, 从 task_struct 缓存区域 task_struct_cachep(在系统初始化时, 由 kmem_cache_create 创建) 分配一块内存<br>    - 使用 task_struct 完毕后, 调用 kmem_cache_free 回收到缓存池中<br>    - struct kmem_cache 用于表示缓存区信息, 缓存区即分配连续几个页的大块内存, 再切成小内存<br>    - 小内存即缓存区的每一项, 都由对象和指向下一项空闲小内存的指针组成(随机插入&#47;删除+快速查找空闲)<br>    - struct kmem_cache 中三个 kmem_cache_order_objects 表示不同的需要分配的内存块大小的阶数和对象数<br>    - 分配缓存的小内存块由两个路径 fast path 和 slow path , 分别对应 struct kmem_cache 中的 kmem_cache_cpu 和 kmem_cache_node<br>    - 分配时先从 kmem_cache_cpu 分配, 若其无空闲, 再从 kmem_cache_node 分配, 还没有就从伙伴系统申请新内存块<br>    - struct kmem_cache_cpu 中<br>        - page 指向大内存块的第一个页<br>        - freelist 指向大内存块中第一个空闲项<br>        - partial 指向另一个大内存块的第一个页, 但该内存块有部分已分配出去, 当 page 满后, 在 partial 中找<br>    - struct kmem_cache_node<br>        - 也有 partial, 是一个链表, 存放部分空闲的多个大内存块, 若 kmem_cacche_cpu 中的 partial 也无空闲, 则在这找<br>    - 分配过程<br>        - kmem_cache_alloc_node-&gt;slab_alloc_node<br>        - 快速通道, 取出 kmem_cache_cpu 的 freelist , 若有空闲直接返回<br>        - 普通通道, 若 freelist 无空闲, 调用 `__slab_alloc`<br>        - `__slab_alloc` 会重新查看 freelist, 若还不满足, 查看 kmem_cache_cpu 的 partial <br>        - 若 partial 不为空, 用其替换 page, 并重新检查是否有空闲<br>        - 若还是无空闲, 调用 new_slab_objects<br>        - new_slab_objects 根据节点 id 找到对应 kmem_cache_node , 调用 get_partial_node<br>        - 首先从 kmem_cache_node 的 partial 链表拿下一大块内存, 替换 kmem_cache_cpu 的 page, 再取一块替换 kmem_cache_cpu 的 partial<br>        - 若 kmem_cache_node 也没有空闲, 则在 new_slab_objects 中调用 new_slab-&gt;allocate_slab-&gt;alloc_slab_page 根据某个 kmem_cache_order_objects 设置申请大块内存<br>- 页面换出<br>    - 触发换出: <br>    - 1) 分配内存时发现没有空闲; 调用 `get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node`<br>    - 2) 内存管理主动换出, 由内核线程 kswapd 实现<br>    - kswapd 在内存不紧张时休眠, 在内存紧张时检测内存 调用 balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node<br>    - 页面都挂在 lru 链表中, 页面有两种类型: 匿名页; 文件内存映射页<br>    - 每一类有两个列表: active 和 inactive 列表<br>    - 要换出时, 从 inactive 列表中找到最不活跃的页换出<br>    - 更新列表, shrink_list 先缩减 active 列表, 再缩减不活跃列表<br>    - 缩减不活跃列表时对页面进行回收:<br>        - 匿名页回收: 分配 swap, 将内存也写入文件系统<br>        - 文件内存映射页: 将内存中的文件修改写入文件中","like_count":31},{"had_liked":false,"id":96663,"user_name":"W.jyao","can_delete":false,"product_type":"c1","uid":1422582,"ip_address":"","ucode":"C57B3A78B6A795","user_header":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","comment_is_top":false,"comment_ctime":1558485922,"is_pvip":false,"replies":[{"id":"49276","content":"多看几遍就好了","user_name":"作者回复","comment_id":96663,"uid":"1001590","ip_address":"","utype":1,"ctime":1567609412,"user_name_real":"刘超@网易云"}],"discussion_count":4,"race_medal":0,"score":"83162864546","product_id":100024701,"comment_content":"真心看不懂了，😔😔😔","like_count":20,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450959,"discussion_content":"多看几遍就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567609412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5168,"discussion_content":"看到你这么说，我也就放心了，因为我也是这样哈哈。一开始还能看懂文字，也能看懂代码，到现在完全忽略代码只看文字都很吃力，完全靠硬撑。这专栏太硬核了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566026093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1968013,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/07/8d/3e76560f.jpg","nickname":"王建峰","note":"","ucode":"8BF1AEFFA7EA5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379200,"discussion_content":"看着头大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623750574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1817246,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/ba/9e/b0d5542d.jpg","nickname":"Geek_6f2a39","note":"","ucode":"EA58EA41164AC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191920,"discussion_content":"已经做好再看一次的准备了，加油共勉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583046319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114462,"user_name":"超超","can_delete":false,"product_type":"c1","uid":1476077,"ip_address":"","ucode":"D0751F29553481","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/ed/905b052f.jpg","comment_is_top":false,"comment_ctime":1563322311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"78872733639","product_id":100024701,"comment_content":"1.系统在什么情况下才会使用SWAP？<br><br>实际上，并不是等所有的物理内存都消耗完毕之后，才去使用swap的空间，什么时候使用是由swappiness 参数值控制。<br>[root@rhce ~]# cat &#47;proc&#47;sys&#47;vm&#47;swappiness<br><br>60<br>该值默认值是60.<br><br>swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间，<br><br>swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。<br><br>现在服务器的内存动不动就是上百G，所以我们可以把这个参数值设置的低一些，让操作系统尽可能的使用物理内存，降低系统对swap的使用，从而提高系统的性能。<br><br>","like_count":19},{"had_liked":false,"id":96925,"user_name":"鲍勃","can_delete":false,"product_type":"c1","uid":1142312,"ip_address":"","ucode":"9B5E4A5B1A54E5","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/28/1e307312.jpg","comment_is_top":false,"comment_ctime":1558536304,"is_pvip":false,"replies":[{"id":"49261","content":"其实哪门课都一样哈","user_name":"作者回复","comment_id":96925,"uid":"1001590","ip_address":"","utype":1,"ctime":1567608360,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"65983045744","product_id":100024701,"comment_content":"果然和你的网络课程一样，越到后面越hold不住😂","like_count":16,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451068,"discussion_content":"其实哪门课都一样哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567608360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114463,"user_name":"超超","can_delete":false,"product_type":"c1","uid":1476077,"ip_address":"","ucode":"D0751F29553481","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/ed/905b052f.jpg","comment_is_top":false,"comment_ctime":1563322380,"is_pvip":false,"replies":[{"id":"46602","content":"如此认真，典范啊","user_name":"作者回复","comment_id":114463,"uid":"1001590","ip_address":"","utype":1,"ctime":1566363968,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"57397897228","product_id":100024701,"comment_content":"2. 如何修改swappiness参数？<br><br>--临时性修改：<br><br>[root@rhce ~]# sysctl vm.swappiness=10<br><br>vm.swappiness = 10<br><br>[root@rhce ~]# cat &#47;proc&#47;sys&#47;vm&#47;swappiness<br>10<br>这里我们的修改已经生效，但是如果我们重启了系统，又会变成60.<br><br>--永久修改：<br>在&#47;etc&#47;sysctl.conf 文件里添加如下参数：<br>vm.swappiness=10<br>或者：<br>[root@rhce ~]# echo &#39;vm.swappiness=10&#39; &gt;&gt;&#47;etc&#47;sysctl.conf<br><br>保存，重启，就生效了。","like_count":14,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458675,"discussion_content":"如此认真，典范啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566363968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96648,"user_name":"欠债太多","can_delete":false,"product_type":"c1","uid":1099238,"ip_address":"","ucode":"B0CC91FA6F3981","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/e6/50c5b805.jpg","comment_is_top":false,"comment_ctime":1558484130,"is_pvip":true,"replies":[{"id":"49277","content":"重点关注流程，不关注细节","user_name":"作者回复","comment_id":96648,"uid":"1001590","ip_address":"","utype":1,"ctime":1567609431,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"57393058978","product_id":100024701,"comment_content":"看到现在，代码越来越多，关于代码的阅读需要么？怎么去做呢","like_count":14,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450953,"discussion_content":"重点关注流程，不关注细节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567609431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521245,"avatar":"https://static001.geekbang.org/account/avatar/00/17/36/5d/7f16e05b.jpg","nickname":"Gabriel","note":"","ucode":"5E5306B4E3533A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190704,"discussion_content":"先看注释。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582972250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96871,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1558526306,"is_pvip":false,"replies":[{"id":"49264","content":"赞","user_name":"作者回复","comment_id":96871,"uid":"1001590","ip_address":"","utype":1,"ctime":1567608459,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"44508199266","product_id":100024701,"comment_content":"花了4个多小时终于把笔记做完<br>分享给大家：<br>https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;10907734.html","like_count":11,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451043,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567608459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96601,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1558457390,"is_pvip":false,"replies":[{"id":"49279","content":"加油，多看几遍","user_name":"作者回复","comment_id":96601,"uid":"1001590","ip_address":"","utype":1,"ctime":1567609491,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"40213163054","product_id":100024701,"comment_content":"这几节看起来吃力了，需要理解的外围知识很多！","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450929,"discussion_content":"加油，多看几遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567609491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114469,"user_name":"超超","can_delete":false,"product_type":"c1","uid":1476077,"ip_address":"","ucode":"D0751F29553481","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/ed/905b052f.jpg","comment_is_top":false,"comment_ctime":1563322681,"is_pvip":false,"replies":[{"id":"46601","content":"赞","user_name":"作者回复","comment_id":114469,"uid":"1001590","ip_address":"","utype":1,"ctime":1566363929,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"31628093753","product_id":100024701,"comment_content":"3. 如何查看swap分区<br>swapon -s<br>cat &#47;proc&#47;swaps<br>free<br>vmstat<br>以上4类命令都可以查看swap分区的大小和使用情况","like_count":8,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458677,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566363929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96671,"user_name":"guojiun","can_delete":false,"product_type":"c1","uid":1020017,"ip_address":"","ucode":"FF9FC87C9E4E72","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/71/e961e311.jpg","comment_is_top":false,"comment_ctime":1558486818,"is_pvip":false,"replies":[{"id":"49273","content":"赞","user_name":"作者回复","comment_id":96671,"uid":"1001590","ip_address":"","utype":1,"ctime":1567609171,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"31623257890","product_id":100024701,"comment_content":"https:&#47;&#47;events.static.linuxfound.org&#47;sites&#47;events&#47;files&#47;slides&#47;slaballocators.pdf 這裡有清楚的視意圖，對照著看會更清楚！","like_count":8,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450963,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567609171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223805,"user_name":"sundy","can_delete":false,"product_type":"c1","uid":1724856,"ip_address":"","ucode":"581D4B976524B6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/51/b8/f76b15a1.jpg","comment_is_top":false,"comment_ctime":1591184433,"is_pvip":false,"replies":[{"id":"83006","content":"其实是有一个整体思路的，被代码打断了，可以讲代码总结一个段落大意，然后再穿起来看，是不是好一些","user_name":"作者回复","comment_id":223805,"uid":"1001590","ip_address":"","utype":1,"ctime":1591753071,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"23066020913","product_id":100024701,"comment_content":"真的应该少粘代码 多讲原理、多抽象，不然很难将您讲的东西串联起来，连基本原理都不了解硬生生的讲代码实在是让人困惑","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497246,"discussion_content":"其实是有一个整体思路的，被代码打断了，可以讲代码总结一个段落大意，然后再穿起来看，是不是好一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591753071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114472,"user_name":"超超","can_delete":false,"product_type":"c1","uid":1476077,"ip_address":"","ucode":"D0751F29553481","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/ed/905b052f.jpg","comment_is_top":false,"comment_ctime":1563322888,"is_pvip":false,"replies":[{"id":"46599","content":"赞","user_name":"作者回复","comment_id":114472,"uid":"1001590","ip_address":"","utype":1,"ctime":1566363922,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"18743192072","product_id":100024701,"comment_content":"参考文章：https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;6JVpke8bDKI9lvh_l6QF-w","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458679,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566363922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279805,"user_name":"绿箭侠","can_delete":false,"product_type":"c1","uid":1528536,"ip_address":"","ucode":"B994F558A98E29","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/d8/123a4981.jpg","comment_is_top":false,"comment_ctime":1613967840,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10203902432","product_id":100024701,"comment_content":"这个专栏最大的好处就是能将那些专业的厚的书籍的宽泛知识点串起来，能帮助深入理解！！！","like_count":2,"discussions":[{"author":{"id":2028554,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK8HE5kCNluviaVjzPSk0YuacxXF6HFV2257c4edGGpnZSCR2e2Z7S9c89ahY6A4WsbtLMhfgeicYeA/132","nickname":"中华小厨神","note":"","ucode":"2C4CB3D6777969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369966,"discussion_content":"精髓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619236162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96963,"user_name":"chengzise","can_delete":false,"product_type":"c1","uid":1006070,"ip_address":"","ucode":"1C27D216359894","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/f6/ed66d1c1.jpg","comment_is_top":false,"comment_ctime":1558567433,"is_pvip":false,"replies":[{"id":"34859","content":"是的，会映射成为虚拟地址，是整页会有虚拟地址","user_name":"作者回复","comment_id":96963,"uid":"1001590","ip_address":"","utype":1,"ctime":1558680975,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10148502025","product_id":100024701,"comment_content":"老师好，这两节讲的是物理内存的管理和分配，大概逻辑是看的懂的，细节需要继续反复研读才行。其中有个问题，kmem_cache部分已经属于页内小内存分配，这个分配算法属于虚拟内存分配，不算物理内存管理范畴吧？ 就是说先分配物理内存页，映射到虚拟内存空间，再在这个虚拟内存分配小内存给程序逻辑使用。希望老师解答一下。","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451081,"discussion_content":"是的，会映射成为虚拟地址，是整页会有虚拟地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558680975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281640,"user_name":"徐少文","can_delete":false,"product_type":"c1","uid":1670331,"ip_address":"","ucode":"8E35B10DA44EE3","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/bb/635a2710.jpg","comment_is_top":false,"comment_ctime":1614837797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909805093","product_id":100024701,"comment_content":"看到这里非常有一种看Windows内核原理与实现的感受了，就是感觉经常摆出一大堆数据结构，看的太痛苦了。打算记好笔记然后每天打开看一看。","like_count":1},{"had_liked":false,"id":237183,"user_name":"Spring","can_delete":false,"product_type":"c1","uid":1222211,"ip_address":"","ucode":"8175463FB4705B","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/43/cb6ab349.jpg","comment_is_top":false,"comment_ctime":1595731179,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5890698475","product_id":100024701,"comment_content":"有了快速通道，为什么还需要普通通道，这一点搞不明白","like_count":1,"discussions":[{"author":{"id":1000550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/66/95976d10.jpg","nickname":"一路向前","note":"","ucode":"853B90DF308425","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298380,"discussion_content":"快速通道是cahe_cpu，比普通通道代价更大","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597284188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224337,"user_name":"stevensafin","can_delete":false,"product_type":"c1","uid":1053553,"ip_address":"","ucode":"CC692A740C5FD5","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/71/3762b089.jpg","comment_is_top":false,"comment_ctime":1591347592,"is_pvip":false,"replies":[{"id":"83003","content":"其实通过里面的图，基本能够理解整个流程。大概的思想和咱们通过多级缓存加速数据库访问差不多，一级找不到找二级，二级找不到找数据库。","user_name":"作者回复","comment_id":224337,"uid":"1001590","ip_address":"","utype":1,"ctime":1591752935,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5886314888","product_id":100024701,"comment_content":"对于slab分配内存的机制，是不是可以用个流程图来表示会更好一点？还有就是快慢通道的速度差距和具体设计原因能不能说明一下，感谢老师","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497446,"discussion_content":"其实通过里面的图，基本能够理解整个流程。大概的思想和咱们通过多级缓存加速数据库访问差不多，一级找不到找二级，二级找不到找数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591752935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129254,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1567071392,"is_pvip":false,"replies":[{"id":"48746","content":"一个内存块的slub全部释放之后，整个页都会回收","user_name":"作者回复","comment_id":129254,"uid":"1001590","ip_address":"","utype":1,"ctime":1567493393,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5862038688","product_id":100024701,"comment_content":"老师，slub存在回收机制吧？就是slub中空闲很多的时候，是不是会这些内存块释放，返回给系统呢？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465362,"discussion_content":"一个内存块的slub全部释放之后，整个页都会回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567493393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129239,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1567069169,"is_pvip":false,"replies":[{"id":"48748","content":"不是同一块的。备用列表，当 page 满了，就会从这里找<br>","user_name":"作者回复","comment_id":129239,"uid":"1001590","ip_address":"","utype":1,"ctime":1567493634,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5862036465","product_id":100024701,"comment_content":"老师，kmem_cache_cpu中的page和partial不是指向同一块内存区域的吧，为什么会这么设计呢？partial的作用是什么呢？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465351,"discussion_content":"不是同一块的。备用列表，当 page 满了，就会从这里找\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567493634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112532,"user_name":"无咎","can_delete":false,"product_type":"c1","uid":1479120,"ip_address":"","ucode":"B9759B5646F3AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","comment_is_top":false,"comment_ctime":1562752977,"is_pvip":true,"replies":[{"id":"46715","content":"对每个NUMA结点来说，都有一个单独的kswapd守护进程","user_name":"作者回复","comment_id":112532,"uid":"1001590","ip_address":"","utype":1,"ctime":1566385924,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5857720273","product_id":100024701,"comment_content":"kswapd 在内存紧张的时候，开始工作，那么这个紧张的条件是什么？总的物理内存还是按照 zone 来区分呢？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457783,"discussion_content":"对每个NUMA结点来说，都有一个单独的kswapd守护进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566385924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98145,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1047936,"ip_address":"","ucode":"CA1869B139A4F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/80/52763d62.jpg","comment_is_top":false,"comment_ctime":1558920758,"is_pvip":false,"replies":[{"id":"35389","content":"物理内存分配完毕一整页的时候，会通过page_address分配一个虚拟地址，小块都是基于这个虚拟地址的。","user_name":"作者回复","comment_id":98145,"uid":"1001590","ip_address":"","utype":1,"ctime":1559100856,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5853888054","product_id":100024701,"comment_content":"老师，有个疑问，这些内存小块的分配及释放，都是在物理内存中完成的呢，还是在虚拟内存中完成再映射对对应的物理内存呢？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451576,"discussion_content":"物理内存分配完毕一整页的时候，会通过page_address分配一个虚拟地址，小块都是基于这个虚拟地址的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559100856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96957,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1558564079,"is_pvip":false,"replies":[{"id":"49259","content":"对的对的，可以讲好久呢","user_name":"作者回复","comment_id":96957,"uid":"1001590","ip_address":"","utype":1,"ctime":1567608236,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5853531375","product_id":100024701,"comment_content":"slab分配器内容很多，这样讲一讲大体框架也不错，要不然就更看不懂了","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451079,"discussion_content":"对的对的，可以讲好久呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567608236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334107,"user_name":"赵军林","can_delete":false,"product_type":"c1","uid":1098601,"ip_address":"","ucode":"226A9E7582F24E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/69/7353dd4c.jpg","comment_is_top":false,"comment_ctime":1644747519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644747519","product_id":100024701,"comment_content":"老师，slub分配的都是数据结构固定的对象，如task_struct、mm_struct，如果程序中有字符串，字符串的大小固定，这个是怎么分配的呢","like_count":0},{"had_liked":false,"id":321463,"user_name":"Jia Tiancai","can_delete":false,"product_type":"c1","uid":2548102,"ip_address":"","ucode":"EF2F5FE8A0DF3E","user_header":"","comment_is_top":false,"comment_ctime":1636885870,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1636885870","product_id":100024701,"comment_content":"kmem_cache_cpu 和 kmem_cache_node，它们都是每个 NUMA 节点上有一个。<br>麻烦老师帮忙解答一下疑问，kmem_cache不同的object都会创建对应的kmem_cache，为什么每个NVMA节点上只有一个呢？单个NVMA节点上会存在多个kmem_cache_cpu 和 kmem_cache_node吧!","like_count":0},{"had_liked":false,"id":306538,"user_name":"小方","can_delete":false,"product_type":"c1","uid":1480022,"ip_address":"","ucode":"CB2970313E2489","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/56/116c25d5.jpg","comment_is_top":false,"comment_ctime":1628601457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628601457","product_id":100024701,"comment_content":"您好，问个代码实现的问题，kmem cache cpu里面的变量freelist为啥定义为二重指针，注释里面写的是指向可用的object，在快速分配通道里面，直接就返回freelist了，所以你说的那个链表图是不是有点小问题，下个空闲对象的指针是不是要指向object，而不是指向下个空闲对象指针？","like_count":0},{"had_liked":false,"id":276088,"user_name":"坚","can_delete":false,"product_type":"c1","uid":2019536,"ip_address":"","ucode":"C02AB1CDE39D1A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d0/d0/a6c6069d.jpg","comment_is_top":false,"comment_ctime":1611792474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611792474","product_id":100024701,"comment_content":"有点不懂快速通道和普通通道里面的partital的区别，还有就是进程销毁后缓存是放回哪里不太懂。","like_count":0},{"had_liked":false,"id":266619,"user_name":"--","can_delete":false,"product_type":"c1","uid":1075167,"ip_address":"","ucode":"A262E3991E69DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/df/8b85d0d9.jpg","comment_is_top":false,"comment_ctime":1607418191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607418191","product_id":100024701,"comment_content":"slab对象如果大于一个页的大小，那么slab是否也仍然会产生内存碎片？如果对象的大小是4kB+1Byte，那么大的内存块是2*4kB，这样其实每次分配一个对象之后仍然有大量内存是未使用的。我的理解正确吗？","like_count":0},{"had_liked":false,"id":241398,"user_name":"一路向前","can_delete":false,"product_type":"c1","uid":1000550,"ip_address":"","ucode":"853B90DF308425","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/66/95976d10.jpg","comment_is_top":false,"comment_ctime":1597284446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597284446","product_id":100024701,"comment_content":"虚拟内存是通过内存页来访问物理内存的，系统使用过程中，不断分配+频繁换入换出页，会不会造成页表不连续，不知道会不会整理页表呢？","like_count":0},{"had_liked":false,"id":236257,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1595379505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595379505","product_id":100024701,"comment_content":"讲的很好，是看源码特别好的指导文档。很多人反馈看不懂，主要是这门课不适合，而不是课程不好。对照源码按照老师的独立走一遍就可以熟悉linux内存管理的核心了。","like_count":0},{"had_liked":false,"id":223223,"user_name":"南瓜","can_delete":false,"product_type":"c1","uid":1079562,"ip_address":"","ucode":"53561F551857A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0a/a417ec1c.jpg","comment_is_top":false,"comment_ctime":1591023319,"is_pvip":false,"replies":[{"id":"83008","content":"每一节的总结，都有个图和流程，足够到达了解的程度了","user_name":"作者回复","comment_id":223223,"uid":"1001590","ip_address":"","utype":1,"ctime":1591753180,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1591023319","product_id":100024701,"comment_content":"过于贴近于机器实现细节，除非很熟、或者一番时间、精力苦功夫，否则不得要领，草草掠过；<br><br>即刻时间带给的，我想更多是快速的知识了解。本文这点细节过于偏向细节描述，难以达到快速了解程度","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497062,"discussion_content":"每一节的总结，都有个图和流程，足够到达了解的程度了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591753180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204492,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1586407472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586407472","product_id":100024701,"comment_content":"老师，kmem_cache_cpu中的page和partial是指向同一块内存区域么？既然page列表里没有了，partial还有么，还需要到partial里再找一下？","like_count":0},{"had_liked":false,"id":184760,"user_name":"天竺葵柠檬橙花柚","can_delete":false,"product_type":"c1","uid":1545971,"ip_address":"","ucode":"0F3620FABAEECB","user_header":"https://static001.geekbang.org/account/avatar/00/17/96/f3/b06a899c.jpg","comment_is_top":false,"comment_ctime":1583397117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583397117","product_id":100024701,"comment_content":"讲的真好，不然光自己看深入理解linux内核那本书内存管理章节，也无法把流程梳理的那么清楚，老师这两章有图有文有代码，看了两天也能做到理解大体框架和关键结构，再整理笔记时不时复习下，效率很高。","like_count":0},{"had_liked":false,"id":160948,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1576067982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576067982","product_id":100024701,"comment_content":"kmem_cache应该是种高速缓存，用来解决对象频繁分配和释放的问题，其实就是直接把不用的对象在放回链表里，而不是释放对象的内存","like_count":0},{"had_liked":false,"id":116615,"user_name":"栋能","can_delete":false,"product_type":"c1","uid":1006849,"ip_address":"","ucode":"8BD9C939D3E8E1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/01/9cd84003.jpg","comment_is_top":false,"comment_ctime":1563882027,"is_pvip":false,"replies":[{"id":"46426","content":"这里的意思是每个NUMA节点，自己换出自己的，不是将整个NUMA节点都换出","user_name":"作者回复","comment_id":116615,"uid":"1001590","ip_address":"","utype":1,"ctime":1566299952,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1563882027","product_id":100024701,"comment_content":"我想知道文中 “对于缓存来讲，其实就是分配了连续几页的大内存块，然后根据缓存对象大小，切成小内存块” 中，小内存块和页大小是怎么个关系？按我的理解小内存块就是task_struct对象大小，一个页中有很多。而kmem_cache_cpu中对于中freelist是大内存块中的项，这个这个项和小内存块或task_struct有个什么关系？是大小一样呢，还是怎个关系？还有最后讲页面换出单位是内存节点，这个节点不可能是整个NUMA节吧，是指啥我没看明白","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459611,"discussion_content":"这里的意思是每个NUMA节点，自己换出自己的，不是将整个NUMA节点都换出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566299952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105732,"user_name":"skye","can_delete":false,"product_type":"c1","uid":1027840,"ip_address":"","ucode":"C55C9F52C78A00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/00/9b49f42b.jpg","comment_is_top":false,"comment_ctime":1561079424,"is_pvip":false,"replies":[{"id":"48887","content":"mmap","user_name":"作者回复","comment_id":105732,"uid":"1001590","ip_address":"","utype":1,"ctime":1567504525,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1561079424","product_id":100024701,"comment_content":"老师能讲讲大块内存的分配吗","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454791,"discussion_content":"mmap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567504525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102924,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1560329539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560329539","product_id":100024701,"comment_content":"查看分区情况：&#47;proc&#47;swaps","like_count":0},{"had_liked":false,"id":99250,"user_name":"zhj","can_delete":false,"product_type":"c1","uid":1311772,"ip_address":"","ucode":"65B9E222D6E075","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/1c/b0c6c009.jpg","comment_is_top":false,"comment_ctime":1559182315,"is_pvip":false,"replies":[{"id":"49235","content":"在页表做了标记，说明已经换出了","user_name":"作者回复","comment_id":99250,"uid":"1001590","ip_address":"","utype":1,"ctime":1567604966,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1559182315","product_id":100024701,"comment_content":"麻烦问下，换出不活跃物理页的时候，对于原来进程A是无感知的，A中的页表保存了虚拟地址到物理地址的映射，在A视角看来还是原来大小的内存，但当A需要访问这个不活跃的页时，这个映射关系已经不成立，所以我的问题就是当换出发生的时候，对A的页表是进行了什么特殊处理，望老师答疑下","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452036,"discussion_content":"在页表做了标记，说明已经换出了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567604966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98620,"user_name":"川云","can_delete":false,"product_type":"c1","uid":1265438,"ip_address":"","ucode":"3D56399A7C5BDF","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/1e/e2b7a9ba.jpg","comment_is_top":false,"comment_ctime":1559043407,"is_pvip":false,"replies":[{"id":"35370","content":"谢谢，这门课主要强调流程，代码是个印证，不适合作为特别严肃的代码分析书籍看，为了突出内核工作机制和流程，删除和省略了很多内核代码","user_name":"作者回复","comment_id":98620,"uid":"1001590","ip_address":"","utype":1,"ctime":1559099968,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1559043407","product_id":100024701,"comment_content":"讲得真好，深入到代码层面，否则要是自己研究太困难了，不过也确实需要一定的Linux基础，根据老师的讲解再去看下linux内核的书籍，会提升的更快的","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451757,"discussion_content":"谢谢，这门课主要强调流程，代码是个印证，不适合作为特别严肃的代码分析书籍看，为了突出内核工作机制和流程，删除和省略了很多内核代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559099968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96669,"user_name":"金子菇凉的铁粉小逗","can_delete":false,"product_type":"c1","uid":1000602,"ip_address":"","ucode":"6A2C601F6EEBB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/9a/c03bea17.jpg","comment_is_top":false,"comment_ctime":1558486691,"is_pvip":false,"replies":[{"id":"49274","content":"不能吧","user_name":"作者回复","comment_id":96669,"uid":"1001590","ip_address":"","utype":1,"ctime":1567609386,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1558486691","product_id":100024701,"comment_content":"怎么自定义页面换出？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450962,"discussion_content":"不能吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567609386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}