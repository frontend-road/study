{"id":475927,"title":"12 | OpenFeign：服务间调用组件 OpenFeign 是怎么“隔空取物”的？","content":"<p>你好，我是姚秋辰。</p><p>在前面的课程中，我们借助Nacos的服务发现能力，使用WebClient实现了服务间调用。从功能层面上来讲，我们已经完美地实现了微服务架构下的远程服务调用，但是从易用性的角度来看，这种实现方式似乎对开发人员并不怎么友好。</p><p>我们来回顾一下，在前面的实战项目中，我是怎样使用WebClient发起远程调用的。</p><pre><code>webClientBuilder.build()\n    // 声明这是一个POST方法\n    .post()\n    // 声明服务名称和访问路径\n    .uri(&quot;http://coupon-calculation-serv/calculator/simulate&quot;)\n    // 传递请求参数的封装\n    .bodyValue(order)\n    .retrieve()\n    // 声明请求返回值的封装类型\n    .bodyToMono(SimulationResponse.class)\n    // 使用阻塞模式来获取结果\n    .block()\n</code></pre><p>从上面的代码我们可以看出，为了发起一个服务请求，我把整个服务调用的所有信息都写在了代码中，从请求类型、请求路径、再到封装的参数和返回类型。编程体验相当麻烦不说，更关键的是这些代码没有很好地践行职责隔离的原则。</p><p>在业务层中我们应该关注<strong>具体的业务实现</strong>，而WebClient的远程调用引入了很多与业务无关的概念，比如请求地址、请求类型等等。从职责分离的角度来说，<strong>我们应该尽量把这些业务无关的逻辑</strong>，<strong>从业务代码中剥离出去</strong>。</p><p>那么，Spring Cloud中有没有一个组件，在实现远程服务调用的同时，既能满足简单易用的接入要求，又能很好地将业务无关的代码与业务代码隔离开呢？</p><p>这个可以有，今天我就来带你了解Spring Cloud中的一个叫做OpenFeign的组件，看看它是如何简化远程服务调用的，除此之外，我还会为你详细讲解这背后的底层原理。</p><!-- [[[read_end]]] --><h2>了解OpenFeign</h2><p>OpenFeign组件的前身是Netflix Feign项目，它最早是作为Netflix OSS项目的一部分，由Netflix公司开发。后来Feign项目被贡献给了开源组织，于是才有了我们今天使用的Spring Cloud OpenFeign组件。</p><p>OpenFeign提供了一种声明式的远程调用接口，它可以大幅简化远程调用的编程体验。在了解OpenFeign的原理之前，我们先来体验一下OpenFeign的最终疗效。我用了一个Hello World的小案例，带你看一下由OpenFeign发起的远程服务调用的代码风格是什么样的。</p><pre><code>String response = helloWorldService.hello(&quot;Vincent Y.&quot;);\n</code></pre><p>你可能会问，这不就是本地方法调用吗？没错！使用OpenFeign组件来实现远程调用非常简单，就像我们使用本地方法一样，只要一行代码就能实现WebClient组件好几行代码干的事情。而且这段代码不包含任何业务无关的信息，完美实现了调用逻辑和业务逻辑之间的职责分离。</p><p>那么，OpenFeign组件在底层是如何实现远程调用的呢？接下来我就带你了解OpenFeign组件背后的工作流程。</p><p>OpenFeign使用了一种“动态代理”技术来封装远程服务调用的过程，我们在上面的例子中看到的helloWorldService其实是一个特殊的接口，它是由OpenFeign组件中的FeignClient注解所声明的接口，接口中的代码如下所示。</p><pre><code>@FeignClient(value = &quot;hello-world-serv&quot;)\npublic interface HelloWorldService {\n\n    @PostMapping(&quot;/sayHello&quot;)\n    String hello(String guestName);\n}\n</code></pre><p>到这里你一定恍然大悟了，原来<strong>远程服务调用的信息被写在了FeignClient接口中</strong>。在上面的代码里，你可以看到，服务的名称、接口类型、访问路径已经通过注解做了声明。OpenFeign通过解析这些注解标签生成一个“动态代理类”，这个代理类会将接口调用转化为一个远程服务调用的Request，并发送给目标服务。</p><p>那么OpenFeign的动态代理是如何运作的呢？接下来，我就带你去深入了解这背后的流程。</p><h2>OpenFeign的动态代理</h2><p>在项目初始化阶段，OpenFeign会生成一个代理类，对所有通过该接口发起的远程调用进行动态代理。我画了一个流程图，帮你理解OpenFeign的动态代理流程，你可以看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/f3/71e8f4670ff50088a676051efe04fef3.jpg?wh=2000x1035\" alt=\"\"></p><p>上图中的步骤1到步骤3是在项目启动阶段加载完成的，只有第4步“调用远程服务”是发生在项目的运行阶段。</p><p>下面我来解释一下上图中的几个关键步骤。</p><p>首先，在项目启动阶段，<strong>OpenFeign框架会发起一个主动的扫包流程</strong>，从指定的目录下扫描并加载所有被@FeignClient注解修饰的接口。</p><p>然后，<strong>OpenFeign会针对每一个FeignClient接口生成一个动态代理对象</strong>，即图中的FeignProxyService，这个代理对象在继承关系上属于FeignClient注解所修饰的接口的实例。</p><p>接下来，<strong>这个动态代理对象会被添加到Spring上下文中，并注入到对应的服务里</strong>，也就是图中的LocalService服务。</p><p>最后，<strong>LocalService会发起底层方法调用</strong>。实际上这个方法调用会被OpenFeign生成的代理对象接管，由代理对象发起一个远程服务调用，并将调用的结果返回给LocalService。</p><p>我猜你一定很好奇：OpenFeign是如何通过动态代理技术创建代理对象的？我画了一张流程图帮你梳理这个过程，你可以参考一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/09/6277f25f9dc535cd6673bd9bc960c409.jpg?wh=2000x1035\" alt=\"\"></p><p>我把OpenFeign组件加载过程的重要阶段画在了上图中。接下来我带你梳理一下OpenFeign动态代理类的创建过程。了解了这个过程，你就会更加理解下节课的实战内容。</p><ol>\n<li>项目加载：在项目的启动阶段，<strong>EnableFeignClients注解</strong>扮演了“启动开关”的角色，它使用Spring框架的<strong>Import注解</strong>导入了FeignClientsRegistrar类，开始了OpenFeign组件的加载过程。</li>\n<li>扫包：<strong>FeignClientsRegistrar</strong>负责FeignClient接口的加载，它会在指定的包路径下扫描所有的FeignClients类，并构造FeignClientFactoryBean对象来解析FeignClient接口。</li>\n<li>解析FeignClient注解：<strong>FeignClientFactoryBean</strong>有两个重要的功能，一个是解析FeignClient接口中的请求路径和降级函数的配置信息；另一个是触发动态代理的构造过程。其中，动态代理构造是由更下一层的ReflectiveFeign完成的。</li>\n<li>构建动态代理对象：<strong>ReflectiveFeign</strong>包含了OpenFeign动态代理的核心逻辑，它主要负责创建出FeignClient接口的动态代理对象。ReflectiveFeign在这个过程中有两个重要任务，一个是解析FeignClient接口上各个方法级别的注解，将其中的远程接口URL、接口类型（GET、POST等）、各个请求参数等封装成元数据，并为每一个方法生成一个对应的MethodHandler类作为方法级别的代理；另一个重要任务是将这些MethodHandler方法代理做进一步封装，通过Java标准的动态代理协议，构建一个实现了InvocationHandler接口的动态代理对象，并将这个动态代理对象绑定到FeignClient接口上。这样一来，所有发生在FeignClient接口上的调用，最终都会由它背后的动态代理对象来承接。</li>\n</ol><p>MethodHandler的构建过程涉及到了复杂的元数据解析，OpenFeign组件将FeignClient接口上的各种注解封装成元数据，并利用这些元数据把一个方法调用“翻译”成一个远程调用的Request请求。</p><p>那么上面说到的“元数据的解析”是如何完成的呢？它依赖于OpenFeign组件中的Contract协议解析功能。Contract是OpenFeign组件中定义的顶层抽象接口，它有一系列的具体实现，其中和我们实战项目有关的是SpringMvcContract这个类，从这个类的名字中我们就能看出来，它是专门用来解析Spring MVC标签的。</p><p>SpringMvcContract的继承结构是SpringMvcContract-&gt;BaseContract-&gt;Contract。我这里拿一段SpringMvcContract的代码，帮助你深入理解它是如何将注解解析为元数据的。这段代码的主要功能是解析FeignClient方法级别上定义的Spring MVC注解。</p><pre><code>// 解析FeignClient接口方法级别上的RequestMapping注解\nprotected void processAnnotationOnMethod(MethodMetadata data, Annotation methodAnnotation, Method method) {\n   // 省略部分代码...\n   \n   // 如果方法上没有使用RequestMapping注解，则不进行解析\n   // 其实GetMapping、PostMapping等注解都属于RequestMapping注解\n   if (!RequestMapping.class.isInstance(methodAnnotation)\n         &amp;&amp; !methodAnnotation.annotationType().isAnnotationPresent(RequestMapping.class)) {\n      return;\n   }\n\n   // 获取RequestMapping注解实例\n   RequestMapping methodMapping = findMergedAnnotation(method, RequestMapping.class);\n   // 解析Http Method定义，即注解中的GET、POST、PUT、DELETE方法类型\n   RequestMethod[] methods = methodMapping.method();\n   // 如果没有定义methods属性则默认当前方法是个GET方法\n   if (methods.length == 0) {\n      methods = new RequestMethod[] { RequestMethod.GET };\n   }\n   checkOne(method, methods, &quot;method&quot;);\n   data.template().method(Request.HttpMethod.valueOf(methods[0].name()));\n\n   // 解析Path属性，即方法上写明的请求路径\n   checkAtMostOne(method, methodMapping.value(), &quot;value&quot;);\n   if (methodMapping.value().length &gt; 0) {\n      String pathValue = emptyToNull(methodMapping.value()[0]);\n      if (pathValue != null) {\n         pathValue = resolve(pathValue);\n         // 如果path没有以斜杠开头，则补上/\n         if (!pathValue.startsWith(&quot;/&quot;) &amp;&amp; !data.template().path().endsWith(&quot;/&quot;)) {\n            pathValue = &quot;/&quot; + pathValue;\n         }\n         data.template().uri(pathValue, true);\n         if (data.template().decodeSlash() != decodeSlash) {\n            data.template().decodeSlash(decodeSlash);\n         }\n      }\n   }\n\n   // 解析RequestMapping中定义的produces属性\n   parseProduces(data, method, methodMapping);\n\n   // 解析RequestMapping中定义的consumer属性\n   parseConsumes(data, method, methodMapping);\n\n   // 解析RequestMapping中定义的headers属性\n   parseHeaders(data, method, methodMapping);\n   data.indexToExpander(new LinkedHashMap&lt;&gt;());\n}\n</code></pre><p>通过上面的方法，我们可以看到，OpenFeign对RequestMappings注解的各个属性都做了解析。</p><p>如果你在项目中使用的是GetMapping、PostMapping之类的注解，没有使用RequestMapping，那么OpenFeign还能解析吗？当然可以。以GetMapping为例，它对RequestMapping注解做了一层封装。如果你查看下面关于GetMapping注解的代码，你会发现这个注解头上也挂了一个RequestMapping注解。因此OpenFeign可以正确识别GetMapping并完成加载。</p><pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.GET)\npublic @interface GetMapping {\n// ...省略部分代码\n}\n</code></pre><p>到这里，相信你已经了解了OpenFeign的工作流程，下节课我将带你进行实战项目的改造，将coupon-customer-serv中的WebClient调用替换为基于OpenFeign的远程服务调用。</p><h2>总结</h2><p>现在，我们来回顾一下这节课的重点内容。</p><p>今天你清楚了OpenFeign要解决的问题，我还带你了解了OpenFeign的工作流程，这里面的重点是<strong>动态代理机制</strong>。OpenFeing通过Java动态代理生成了一个“代理类”，这个代理类将接口调用转化成为了一个远程服务调用。</p><p>动态代理是各个框架经常用到的技术，也是面试中的一个核心考点。对于大多数技术人员来说，日常工作就是堆业务代码，似乎是用不上动态代理，这部分的知识点就是面试前突击一下。但如果你参与到框架类业务的研发，你会经常运用到动态代理技术。我建议你借着这次学习OpenFeign的机会，深入研究一下动态代理的应用。</p><p>如果你对OpenFeign的动态代理流程感兴趣，想要摸清楚这里面的门道，我推荐你一个很高效的学习途径：<strong>Debug</strong>。你可以在OpenFeign组件的FeignClientsRegistrar中打上一个断点，这是OpenFeign初始化的起点，然后你以Debug模式启动应用程序，当程序执行到断点处之后，你可以手动一步步跟着断点往下走，顺藤摸瓜了解OpenFeign的整个加载过程。</p><h2>思考题</h2><p>结合这两节课我给你讲的服务调用的知识，通过阅读<a href=\"https://github.com/spring-cloud/spring-cloud-openfeign\">OpenFeign的源码</a>，你能描述出OpenFeign底层的实现吗？欢迎在留言区写下自己的思考，与我一起讨论。</p><p>好啦，这节课就结束啦。欢迎你把这节课分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们下节课再见！</p>","comments":[{"had_liked":false,"id":332674,"user_name":"~","can_delete":false,"product_type":"c1","uid":2495621,"ip_address":"","ucode":"BE5E3BD6EE3665","user_header":"https://static001.geekbang.org/account/avatar/00/26/14/85/73e55be5.jpg","comment_is_top":true,"comment_ctime":1643458117,"is_pvip":false,"replies":[{"id":"121664","content":"这么认真分析的同学，绝对是个潜力股！同学你用的女生头像，是妹子吗？还缺男朋友不，我这大把可以跟你一块debug的精壮小伙排队求介绍","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1643812929,"ip_address":"","comment_id":332674,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233721158076006e+18","product_id":100101301,"comment_content":"这节课好早就学完了，但是后面的思考题一直没有时间搞清楚，今天闲下来后 debug 一遍后，大概明白具体流程了。<br>我觉得 OpenFeign 的远程调用分为两步<br>1. 首先是生成动态代理类，然后将代理类作为 bean 注入到 Spring 容器中<br>2. 然后是在调用过程中，代理类通过进行网络请求，向调用方做请求。<br><br>动态代理的原理其实 duckduckgo 一下就能找到无数篇文章，就不多说了，这里 OpenFeign 其实底层调用的是 Feign 的方法，生成了代理类，使用的是 JDK 的动态代理，然后 bean 注入。<br>调用过程，就是代理类作为客户端向被调用方发送请求，接收相应的过程。其中，feign 自行封装了 JDK java.net 相关的网络请求方法，可以重点关注一下 Client 类。我之前没有了解过，以为是直接用的 netty 或者其他的网络中间件；请求过程中还有 Loadbalancer 进行负载均衡；收到响应后，还需要对响应类进行解析，才能真正取出正确的响应信息。<br><br>最后：这些天还在忙其他东西，尽管老师更一篇看一篇，但是有些还要深入了解的，就要等到把所有文章的思考题摸清楚后再一步步填坑了。比如 OpenFeign 用的自行封装的 jdk 网络组件，是否可以使用其他中间件（例如 netty）实现呢？在请求过程中实现的负载均衡 loadbalancer 是怎么工作的？<br>以及我在 debug 过程中发现的问题：一旦发起调用时间过长，就会报错 「stream is closed」，io 没学好的我这方面之后也得稍微努力一下；在使用 debug 启动过程中，就出现过对 feign 的动态代理类调用 hashcode 代理方法的情况，应该是 spring 某个组件调用的（我在是数据库相关），但具体是谁我也不清楚。<br><br>以上就是大体的总结和我自己记录的问题，希望以后有时间把挖的坑慢慢填上，如果有什么问题或者不对的地方，欢迎大家批评指出~","like_count":19,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549296,"discussion_content":"这么认真分析的同学，绝对是个潜力股！同学你用的女生头像，是妹子吗？还缺男朋友不，我这大把可以跟你一块debug的精壮小伙排队求介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643812930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331115,"user_name":"卡特","can_delete":false,"product_type":"c1","uid":1060491,"ip_address":"","ucode":"FF63677089E701","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/8b/32a8c5a0.jpg","comment_is_top":false,"comment_ctime":1642430458,"is_pvip":true,"replies":[{"id":"121278","content":"之前使用的方式对使用webclient发起的调用可以这么使用，换成openfeign也要相应的换个姿势。我提一个研究方向，同学可以沿着这个方向看一下，根据前面我讲的Feign组件底层类结构和顺腾摸瓜的方法（debug），找到那个负责做负载均衡的client（比如从FeignLoadBalancerAutoConfiguration下去找线索），然后看一下底层注入的那个标准的spring cloud loadbalancer类是什么，然后在spring上下文中构造一个@Primary的默认主类就可以。<br><br>","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642920190,"ip_address":"","comment_id":331115,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31707201530","product_id":100101301,"comment_content":"金丝雀发布在微服务之间的通过openfeign流量转发规则咋定义和实现?","like_count":8,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547876,"discussion_content":"之前使用的方式对使用webclient发起的调用可以这么使用，换成openfeign也要相应的换个姿势。我提一个研究方向，同学可以沿着这个方向看一下，根据前面我讲的Feign组件底层类结构和顺腾摸瓜的方法（debug），找到那个负责做负载均衡的client（比如从FeignLoadBalancerAutoConfiguration下去找线索），然后看一下底层注入的那个标准的spring cloud loadbalancer类是什么，然后在spring上下文中构造一个@Primary的默认主类就可以。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642920190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329725,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1641513945,"is_pvip":true,"replies":[{"id":"120144","content":"Q：降级不是笔误，当调用请求失败了，转而去执行一段“降级”逻辑，其实把它叫做异常处理逻辑也可以。<br>Q2: openfeign不是webclient的升级版本，你可以把它理解为另一套技术选型，是实现同一个目的的两种不同的手段。<br>Q3: openfeign背后的技术非常底层，如果追根溯源其实是使用了java.net包下的原生HttpURLConnection，同学可以打开Client类看一下convertAndSend的源码<br>Q4: 没错webclient是webflux的冰山一角<br>Q3","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641561810,"ip_address":"","comment_id":329725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18821383129","product_id":100101301,"comment_content":"老师您好，我有4个问题，请指教：Q1：“构造请求路径、降级方法”，这句话中的“降级”是不是笔误？ Q2：openfeign是否可以认为是webclient的一个升级版本？  Q3：netflix体系中，feign是对ribbon的封装，feign的底层用的是ribbon，那么，openfeign的底层也是用webclient吗？ Q4： webclient只是webflux的一个很小的部分，而且不是webflux的主要功能，对吗？  ","like_count":4,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544552,"discussion_content":"Q：降级不是笔误，当调用请求失败了，转而去执行一段“降级”逻辑，其实把它叫做异常处理逻辑也可以。\nQ2: openfeign不是webclient的升级版本，你可以把它理解为另一套技术选型，是实现同一个目的的两种不同的手段。\nQ3: openfeign背后的技术非常底层，如果追根溯源其实是使用了java.net包下的原生HttpURLConnection，同学可以打开Client类看一下convertAndSend的源码\nQ4: 没错webclient是webflux的冰山一角\nQ3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641561810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329911,"user_name":"风筝","can_delete":false,"product_type":"c1","uid":1563904,"ip_address":"","ucode":"4A847EA6A2A1AB","user_header":"https://static001.geekbang.org/account/avatar/00/17/dd/00/4a7b9a9f.jpg","comment_is_top":false,"comment_ctime":1641637076,"is_pvip":true,"replies":[{"id":"120206","content":"因为Ribbon已经被spring cloud的去Netflix化大方向给剔除掉了，现在官方组件的新版本里已经找不到Ribbon的依赖项了，所以新版本用loadbalancer是唯一的选项。但有一说一，我觉得loadbalancer的功能相比Ribbon来说还有点距离，从内置负载均衡策略上就比ribbon差了很多。没辙，spring官方社区不能容忍“断更”的组件","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641728059,"ip_address":"","comment_id":329911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14526538964","product_id":100101301,"comment_content":"老师，OpenFeign是自动集成了Loadbalancer了吗？以前OpenFeign是集成的ribbon，为啥现在又改为Loadbalancer？这个是出于什么考虑","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544837,"discussion_content":"因为Ribbon已经被spring cloud的去Netflix化大方向给剔除掉了，现在官方组件的新版本里已经找不到Ribbon的依赖项了，所以新版本用loadbalancer是唯一的选项。但有一说一，我觉得loadbalancer的功能相比Ribbon来说还有点距离，从内置负载均衡策略上就比ribbon差了很多。没辙，spring官方社区不能容忍“断更”的组件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641728059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331656,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1642688531,"is_pvip":true,"replies":[{"id":"121193","content":"如果是api网关代理请求，那么本质上就不是基于服务发现技术构建的，因为请求必须绕网关，不是从服务注册表里直连目标服务","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642777091,"ip_address":"","comment_id":331656,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937655827","product_id":100101301,"comment_content":"如果公司用的是api网关去代理请求的。是不是就没有必要用openFeign了。没有服务名并且path也不一样","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547631,"discussion_content":"如果是api网关代理请求，那么本质上就不是基于服务发现技术构建的，因为请求必须绕网关，不是从服务注册表里直连目标服务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642777091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329824,"user_name":"逝影落枫","can_delete":false,"product_type":"c1","uid":1064489,"ip_address":"","ucode":"34788B4A504CD1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/29/cc30bd9d.jpg","comment_is_top":false,"comment_ctime":1641554513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5936521809","product_id":100101301,"comment_content":"类似的还有retrofit 和forest吧","like_count":1},{"had_liked":false,"id":329715,"user_name":"so long","can_delete":false,"product_type":"c1","uid":1449679,"ip_address":"","ucode":"2A6B47BB32FC18","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/cf/97cd8be1.jpg","comment_is_top":false,"comment_ctime":1641491620,"is_pvip":false,"replies":[{"id":"120143","content":"万变不离其宗，一个典型的现象就是不写实现通过接口声明就能实现业务逻辑的，底层基本都是用了动态代理做proxy","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641560899,"ip_address":"","comment_id":329715,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5936458916","product_id":100101301,"comment_content":"这个是不是和mybatis创建数据访问接口的代理类的过程差不多","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544549,"discussion_content":"万变不离其宗，一个典型的现象就是不写实现通过接口声明就能实现业务逻辑的，底层基本都是用了动态代理做proxy","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641560899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717835,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/36/4b/9bf00ad4.jpg","nickname":"南京伪学霸","note":"","ucode":"A50997D56A77F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576502,"discussion_content":"有一点小区别，Spring集成MyBatis是先将beanClass为Mapper接口的Bean定义对象注册到了beanDefinitionMap中，后面再替换为FactoryBean；而OpenFeign只是生成了beanClass为FeignClient接口的Bean定义对象，并没有注册，而是又创建了一个新的FeignClient接口对应的FactoryBean的Bean定义对象，才会将FactoryBean的Bean定义对象注册到了beanDefinitionMap中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655610404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345520,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1652347403,"is_pvip":false,"replies":[{"id":"126157","content":"国内环境下dubbo使用居多，包括我自己也是dubbo和hsf用的更多一些，从体感上来说RPC确实更方便一些。如果在国外公司任职的话，dubbo就销声匿迹了，主要还是看自己公司的技术栈","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1652583250,"ip_address":"","comment_id":345520,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652347403","product_id":100101301,"comment_content":"老师，关于 OpenFeign 这样基于 HTTP 的远程调用，和 dubbo 这样基于 TCP 的远程调用，使用时候有什么选型建议吗？感觉 dubbo 的性能要好很多","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572040,"discussion_content":"国内环境下dubbo使用居多，包括我自己也是dubbo和hsf用的更多一些，从体感上来说RPC确实更方便一些。如果在国外公司任职的话，dubbo就销声匿迹了，主要还是看自己公司的技术栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652583250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329724,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1641513620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641513620","product_id":100101301,"comment_content":"源码之下，了无秘密㊙️","like_count":0}]}