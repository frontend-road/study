{"id":778919,"title":"12｜Native方法：打通底层软件与高层应用的关键","content":"<p>你好，我是海纳。</p><p>在过去的几节课中，我们实现了函数的基本功能。实际上，在 Python 中有很多内建函数，例如，range、print、len 等都是内建函数。这些内建函数往往是使用 C/C++ 在虚拟机内部实现的，所以我们把这些函数也称为 native 函数。</p><p>这节课我们就通过实现 len 方法来讲解如何在虚拟机里实现 native 函数。</p><h2>实现内建函数（Builtin Function）</h2><p>在 Python 开发者看来，内建函数和普通函数是一样。也就是说，开发者使用自定义的函数和使用 len、print 等内建函数时，并不需要感知它们之间有什么不同。</p><p>这就决定了，在虚拟机层面，我们希望内建函数与 FunctionObject 所代表的自定义函数也是统一的。所以我们选择继续使用 FunctionObject 来代表内建函数，不同点在于，普通的FunctionObject 是由 MAKE_FUNCTION 字节码使用 CodeObject 主动创建的。前边两节课，我们重点介绍了这个机制。</p><p>但是内建函数并没有对应的字节码，它的所有实现都在虚拟机内部，也就是说，内建函数都是使用 C++ 来实现的。这里需要一种方法把 CALL_FUNCTION 与虚拟机内部的实现联系起来。我们还是要在 FunctionObject 身上想办法。</p><!-- [[[read_end]]] --><p>我们可以在 FunctionObject 里增加一个方法，名为 call。当调用一个 FunctionObject 时，如果虚拟机检查到当前的 FunctionObject 是内建函数的话，就通过 call 方法去调用相关的逻辑。</p><p>要完成以上功能，第一个要解决的问题就是如何判断一个 FunctionObject 所代表的函数是不是内建函数。</p><p>这个问题的本质是<strong>判断对象的类型</strong>，虚拟机使用对象的 <strong>Klass</strong> 来判断一个对象的类型。在这里，我们继续使用这种方法，引入一个 NativeFunctionKlass 来代表内建函数。</p><pre><code class=\"language-c++\">// runtime/functionObject.hpp\nclass NativeFunctionKlass : public Klass {\nprivate:\n&nbsp; &nbsp; NativeFunctionKlass();\n&nbsp; &nbsp; static NativeFunctionKlass* instance;\n\npublic:\n&nbsp; &nbsp; static NativeFunctionKlass* get_instance();\n};\n\n// runtime/functionObject.cpp\nNativeFunctionKlass* NativeFunctionKlass::instance = NULL;\n\nNativeFunctionKlass* NativeFunctionKlass::get_instance() {\n&nbsp; &nbsp; if (instance == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; instance = new NativeFunctionKlass();\n\n&nbsp; &nbsp; return instance;\n}\n\nNativeFunctionKlass::NativeFunctionKlass() {\n&nbsp; &nbsp; set_super(FunctionKlass::get_instance());\n}\n</code></pre><p>如果要创建一个内建函数，只需要把它的 Klass 指向 NativeFunctionKlass 的实例即可。</p><p>第二个要解决的问题，是如何实现 call 方法。</p><p>print、len、range 等都是内建函数，它们 call 方法的逻辑各不相同。一种策略是像之前实现 print 方法一样，为每一种不同的对象实现不同的 print 方法。这样做的话，就是为 len 这个函数对象创建一个独立的 Klass，为 range 这个函数对象也创建一个独立的 Klass，在 Klass 内部实现不同的 call 的逻辑。这样做当然可以，但是太复杂了。</p><p>我们回到问题的本源，len 和 range 都是内建函数，不同的只是它们被调用时要执行什么功能。那我们其实可以使用函数指针来完成这个需求。</p><pre><code class=\"language-c++\">HiObject* len(ObjList args);\ntypedef HiObject* (*NativeFuncPointer)(ObjList args);\n\nclass FunctionObject : public HiObject {\nprivate:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; NativeFuncPointer _native_func;\n\npublic:\n&nbsp; &nbsp; FunctionObject(NativeFuncPointer nfp);\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; HiObject*&nbsp; call(ObjList args);\n};\n</code></pre><p>在 FunctionObject 的定义里，引入一个函数指针，这个指针指向的函数可以接受 ObjList 作为参数，并且返回值类型是 HiObject*（第 2 行和第 7 行）。</p><p>我们把所有的参数都放入到参数列表 args 中去了，而 args 是不定长的，所以理论上这种类型可以接受任意多的参数，用于实现内建函数是绰绰有余的。</p><p>接下来就是上面的声明所对应的具体实现：</p><pre><code class=\"language-c++\">FunctionObject::FunctionObject(NativeFuncPointer nfp) {\n&nbsp; &nbsp; _func_code = NULL;\n&nbsp; &nbsp; _func_name = NULL;\n&nbsp; &nbsp; _flags&nbsp; &nbsp; &nbsp;= 0;\n&nbsp; &nbsp; _globals&nbsp; &nbsp;= NULL;\n&nbsp; &nbsp; _native_func = nfp;\n\n&nbsp; &nbsp; set_klass(NativeFunctionKlass::get_instance());\n}\n\nHiObject* FunctionObject::call(ObjList args) {\n&nbsp; &nbsp; return (*_native_func)(args);\n}\n</code></pre><p>在实现了 NativeFunctionKlass 以后，就可以在 FunctionObject 中使用它了，将FunctionObject 的 Klass 设为 NativeFunctionKlass 的实例，这个 FunctionObject 就代表一个内建函数了（第 8 行）。同时，要把函数指针指向具体的函数实现（第 6 行）。在 call 方法里，通过函数指针调用到具体的方法。</p><p>接下来我们就以一个具体的例子来说明如何实现内建函数。</p><h3>实现 len 方法</h3><p>我们以 len 方法为例，在 len 的具体实现中，只需要调用对象的 len 方法即可。目前虚拟机里只有 String 类型，所以我们在 StringKlass 中添加 len 的实现。</p><pre><code class=\"language-c++\">// runtime/functionObject.cpp\nHiObject* len(ObjList args) {\n&nbsp; &nbsp; return args-&gt;get(0)-&gt;len();\n}\n\n// object/hiObject.cpp\nHiObject* HiObject::len() {\n&nbsp; &nbsp; return klass()-&gt;len(this);\n}\n\n// object/hiString.cpp\nHiObject* StringKlass::len(HiObject* x) {\n&nbsp; &nbsp; return new HiInteger(((HiString*)x)-&gt;length());\n}\n</code></pre><p>列表、元组、字典等类型也支持 len 方法。我们这里先略过，等到后面实现列表类和字典类的时候，会把相应类型的 len 方法都正确地实现。</p><p>最后，还要把 len 函数加到 _builtins 表中去。建立起 Python 中“len”符号与内建函数的联系。</p><pre><code class=\"language-c++\">#define PUSH(x)&nbsp; &nbsp; &nbsp; &nbsp;_frame-&gt;stack()-&gt;add((x))\n\nInterpreter::Interpreter() {\n&nbsp; &nbsp; _builtins = new Map&lt;HiObject*, HiObject*&gt;();\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; _builtins-&gt;put(new HiString(\"len\"),&nbsp; &nbsp; &nbsp; new FunctionObject(len));\n}\n\nvoid Interpreter::build_frame(HiObject* callable, ObjList args) {\n&nbsp; &nbsp; if (callable-&gt;klass() == NativeFunctionKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; PUSH(((FunctionObject*)callable)-&gt;call(args));\n&nbsp; &nbsp; }\n&nbsp; &nbsp; else if (callable-&gt;klass() == FunctionKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; FrameObject* frame = new FrameObject((FunctionObject*) callable, args);\n&nbsp; &nbsp; &nbsp; &nbsp; frame-&gt;set_sender(_frame);\n&nbsp; &nbsp; &nbsp; &nbsp; _frame = frame;\n&nbsp; &nbsp; }\n}\n</code></pre><p>在 build_frame 里，我们要对 native 函数和普通函数加以区分。前边已经分析过了，区分的关键就在于 Klass 的类型，如果是 FunctionKlass，就仍然走原来的路径，创建 FrameObject。如果是 NativeFunctionKlass，就调用 FunctionObject 的 call 方法，并且把 call 的返回值放到栈里。</p><p>我们通过一个测试用例来验证我们的实现。</p><pre><code class=\"language-python\">s = \"hello\"\nprint len(s)\n\ndef py_len(o):\n&nbsp; &nbsp; return len(o)\n\nprint py_len(s)\n</code></pre><p>这里有一点需要注意的是，在某些情况下，py_len 中对 len 函数的调用会被翻译成LOAD_GLOBAL。而我们之前在实现 LOAD_GLOBAL 的时候，只去检查了 FrameObject 里的全局变量表。实际上这是不够的，我们还应该在查找失败以后，继续查找内建变量表。这个逻辑与 LOAD_NAME 是一样的，代码实现也相对简单，你可以自己实现，这里就不再列出源代码了。</p><h3>实现print函数</h3><p>实现了第一个内建函数以后，我们再来修改 print 函数就很简单了。从<a href=\"https://time.geekbang.org/column/article/772694\">第 4 节课</a>开始，我们就一直在使用各种方法对 print 方法进行规避，现在终于到了正面解决它的时候了。</p><p>第一步，在 builtin 里增加一项，将 <code>\"print\"</code> 字符串与 object_print 方法关联起来。</p><pre><code class=\"language-c++\">Interpreter::Interpreter() {\n    _builtins = new Map&lt;HiObject*, HiObject*&gt;();\n    // ...\n    _builtins-&gt;put(new HiString(\"print\"),    new FunctionObject(object_print));\n    _builtins-&gt;put(new HiString(\"len\"),      new FunctionObject(len));\n}\n</code></pre><p>第二步，实现 object_print 方法。</p><pre><code class=\"language-c++\">HiObject* object_print(ObjList args) {\n&nbsp; &nbsp; HiObject* arg0 = args-&gt;get(0);\n&nbsp; &nbsp; arg0-&gt;print();\n&nbsp; &nbsp; printf(\"\\n\");\n\n&nbsp; &nbsp; return Universe::HiNone;\n}\n</code></pre><p>最后，把 CALL_FUNCTION 里的规避方法直接去掉就可以了，这个字节码的实现也变得非常简洁了。</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n    _frame = new FrameObject(codes);\n    while (_frame-&gt;has_more_codes()) {\n\t    unsigned char op_code = _frame-&gt;get_op_code();\n        ...\n        switch (op_code) {\n\t\t...\n            case ByteCode::CALL_FUNCTION:\n                if (op_arg &gt; 0) {\n                    args = new ArrayList&lt;HiObject*&gt;(op_arg);\n                    while (op_arg--) {\n                        args-&gt;set(op_arg, POP());\n                    }\n                }\n\n                fo = static_cast&lt;FunctionObject*&gt;(POP());\n                build_frame(fo, args);\n\n                if (args != NULL) {\n                    delete args;\n                    args = NULL;\n                }\n                break;\n        ...\n        }\n    }\n}\n\n</code></pre><p>上述两个例子详细地展示了如何新增内建函数。从例子中可以看到，在打通了第一个例子以后，新增内建函数就变得非常简单了。</p><p>接下来，我们再看内建类型的方法是如何实现的。</p><h2>实现方法（Method）</h2><p>我们使用函数（function）和方法（method）这两个名词来区分一个函数是否与类绑定。在 C++ 这种面向对象编程语言中，如果一个函数不与类相关，在类的外部独立定义，就会被称为函数。</p><p>如果一个函数在类中定义，只有通过类的实例才能调用，这种函数就被称为方法。这里我们是严格区分函数和方法的。例如下面的两个例子。</p><pre><code class=\"language-python\">def foo():\n&nbsp; &nbsp; print(\"hello\")\n\t\nclass A(object):\n&nbsp; &nbsp; def func(self):\n&nbsp; &nbsp; &nbsp; &nbsp; print(self)\n&nbsp; &nbsp; &nbsp; &nbsp; print(\"world\")\n\na = A()\na.func()\n</code></pre><p>foo 不和任何对象相联系，独立定义，它就是一个函数，而 func 则必须通过 A 的实例 a 进行调用，而且 a 还会继续作为实参传入到 func 中去，也就是说，第一个参数 self 实际上就是对象 a。</p><p>通过这两个例子我们展示了函数和方法的区别。由于我们的虚拟机现在还不能支持 class 语句定义类，所以你可以使用标准 Python 虚拟机来执行这个例子，便于观察这个例子的执行结果。</p><p>虽然目前的虚拟机还不能支持自定义类型，但也实现了多种内建类型，例如整数、字符串和列表等，所以我们仍然可以实现某些内建类型的方法。接下来我们就以 String 类型的 upper 方法来说明如何实现一个内建类型的方法。</p><p>我们从最简单的例子开始。Python 中的 String 类型，定义了一个方法 upper，它的作用是返回一个新的字符串，新字符串中的所有字母都变成大写的。通过下面的例子来观察 upper 方法的效果。</p><pre><code class=\"language-python\">s = \"hello\"\nt = s.upper()\n\nprint(s)\nprint(t)\n</code></pre><p>使用标准虚拟机执行这个例子，结果是 hello 和 HELLO，这说明对字符串 s 调用 upper 方法，并不会改变 s 的内容，而是会返回一个新的字符串。我们再来看这一段代码所对应的字节码是什么。</p><pre><code class=\"language-python\">&nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 ('hello')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (s)\n\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (s)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 LOAD_METHOD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (upper)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 CALL_METHOD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (t)\n\n&nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (s)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18 POP_TOP\n\n&nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;22 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 (t)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;24 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;26 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;28 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30 RETURN_VALUE\n&nbsp; &nbsp;consts\n&nbsp; &nbsp; &nbsp; 'hello'\n&nbsp; &nbsp; &nbsp; None\n&nbsp; &nbsp;names ('s', 'upper', 't', 'print')\n</code></pre><p>这段字节码里的大多数指令我们都已经见过了。新的指令只有两条：LOAD_METHOD 和 CALL_METHOD（第 5 行和第 6 行）。</p><p>LOAD_METHOD 是一个带有参数的字节码，它的参数是一个整数，这是一个 names 表中的序号。在这个具体的例子里，参数为 1，也就是 names 表中的第 1 项，正是字符串 <code>\"upper\"</code>， 这就意味着 LOAD_METHOD 的真实参数其实是方法名 upper。</p><p>在 LOAD_METHOD 之前，已经通过 LOAD_NAME 把字符串 s 加载到栈顶了。而 LOAD_METHOD 是一个需要两个操作数的字节码，一个是调用方法的目标对象，另一个是方法的名称。</p><p>目标对象通过预先加载到操作数栈来提供，方法的名称则通过 names 表的序号，以字节码参数的形式提供。</p><p>另外一个字节码 CALL_METHOD 的实现和 CALL_FUNCTION 的实现是一样的，它可以直接复用 CALL_FUNCTION 的代码，这里就不再赘述了。</p><p>由于 upper 是字符串类的一个方法，我们自然会想到在代表字符串类的 StringKlass 中增加这个方法。其实，不仅仅是 StringKlass 中会增加新的方法，其他所有类型的 Klass 都有定义新的方法，例如列表对象的 append 方法、字典对象的 update 方法等等。所以我们可以在 Klass 中引入一个 Map，专门用于记录某一种类型上的所有属性和方法。</p><pre><code class=\"language-c++\">class Klass {\nprivate:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; HiDict*&nbsp; &nbsp; &nbsp; &nbsp;_klass_dict;\n\npublic:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; void set_klass_dict(HiDict* dict)&nbsp; &nbsp; &nbsp;{ _klass_dict = dict; }\n&nbsp; &nbsp; HiDict* klass_dict()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { return _klass_dict; }\n&nbsp; &nbsp; ...\n};\n</code></pre><p>我们可以在 StringKlass 的 klass_dict 中，以字符串 <code>\"upper\"</code> 为 key，以 string_upper 方法为 value。这样一来，我们就可以把方法与其名称联系起来了。</p><pre><code class=\"language-c++\">// runtime/hiString.cpp\nHiObject* string_upper(ObjList args) {\n&nbsp; &nbsp; HiObject* arg0 = args-&gt;get(0);\n&nbsp; &nbsp; assert(arg0-&gt;klass() == StringKlass::get_instance());\n\n&nbsp; &nbsp; HiString* str_obj = (HiString*)arg0;\n\n&nbsp; &nbsp; int length = str_obj-&gt;length();\n&nbsp; &nbsp; if (length &lt;= 0)\n&nbsp; &nbsp; &nbsp; &nbsp; return Universe::HiNone;\n\n&nbsp; &nbsp; char* v = new char[length];\n&nbsp; &nbsp; char c;\n&nbsp; &nbsp; for (int i = 0; i &lt; length; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; c = str_obj-&gt;value()[i];\n&nbsp; &nbsp; &nbsp; &nbsp; // convert to upper\n&nbsp; &nbsp; &nbsp; &nbsp; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v[i] = c - 0x20;\n&nbsp; &nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v[i] = c;\n&nbsp; &nbsp; }\n\n\tHiString* s = new HiString(v, length);\n\tdelete[] v;\n&nbsp; &nbsp; return s;\n}\n\n// runtime/universe.cpp\nvoid Universe::genesis() {\n&nbsp; &nbsp; HiTrue&nbsp; &nbsp; &nbsp; &nbsp;= new HiInteger(1);\n&nbsp; &nbsp; HiFalse&nbsp; &nbsp; &nbsp; = new HiInteger(0);\n&nbsp; &nbsp; HiNone&nbsp; &nbsp; &nbsp; &nbsp;= new HiObject();\n\n&nbsp; &nbsp; // initialize StringKlass\n&nbsp; &nbsp; HiDict* klass_dict = new HiDict();\n&nbsp; &nbsp; StringKlass::get_instance()-&gt;set_klass_dict(klass_dict);\n&nbsp; &nbsp; klass_dict-&gt;put(new HiString(\"upper\"), new FunctionObject(string_upper));\n}\n</code></pre><p>string_upper 函数实现了 upper 方法的逻辑（第 2 行至第 26 行）。upper 方法的逻辑比较简单，思路就是对字符串里的所有字符进行遍历，如果该字符是小写字母，就将其变成大写字母。做法就是直接将字符减去 32，即 16 进制的 20，因为大写字母的 ASCII 码值比相应的小写字母的值小 32。</p><p>genesis 函数又把它封装成了一个内建方法。以字符串 <code>\"upper\"</code> 为 key，将这个 function 放到了 klass_dict 中（第 35 行至 37 行）。</p><p>这里要多解释一下 genesisi 方法。这个方法只在虚拟机初始化的时候调用一次。为什么要把 StringKlass 的初始化放到这个地方呢？能不能直接在 StringKlass 的构造函数里完成初始化呢？</p><p>答案是不能，因为我们在初始化 StringKlass 的 klass_dict 时，会使用字符串 <code>\"upper\"</code> ，它是一个 HiString 对象。而 HiString 对象又依赖于 StringKlass。这种循环依赖会使程序陷入无限递归调用中。</p><p>为了解决这个问题，我们只能把 StringKlass 的初始化逻辑搬到外面来，而最合适做初始化的地方，自然就是这个只在虚拟机启动时执行一次的“创世纪”函数。</p><p>然后，我们来实现 LOAD_METHOD 这条指令。</p><pre><code class=\"language-c++\">// [runtime/interpreter.cpp]\nvoid Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::LOAD_ATTR:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::LOAD_METHOD:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = _frame-&gt;_names-&gt;get(op_arg);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(v-&gt;getattr(w));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\n// object/hiObject.cpp\nHiObject* HiObject::getattr(HiObject* x) {\n&nbsp; &nbsp; HiObject* result = Universe::HiNone;\n&nbsp; &nbsp; result = klass()-&gt;klass_dict()-&gt;get(x);\n&nbsp; &nbsp; return result;\n}\n</code></pre><p>查找属性和方法的逻辑都被封装到对象的 getattr 方法里了。好像一切都是正常的，但我们思考一下，upper 方法的参数是怎么传递的，问题就出现了。</p><p>upper 方法看上去是不用传任何参数的，但实际上，它却有一个隐含的参数：调用方法时的那个目标对象，在这节课的例子中，就是字符串“hello”。</p><p>虚拟机需要一种机制来传递这个隐式的参数。在之前的讲解中，我们已经明确了函数和方法的不同。函数没有隐含的参数，但是方法有，所以我们可以为方法定义一种新的类型，让它完成传递隐式参数的功能。这个新的类型就是 MethodObject。</p><pre><code class=\"language-c++\">// runtime/functionObject.hpp\n// Method objects.\nclass MethodKlass : public Klass {\nprivate:\n&nbsp; &nbsp; MethodKlass();\n&nbsp; &nbsp; static MethodKlass* instance;\n\npublic:\n&nbsp; &nbsp; static MethodKlass* get_instance();\n};\n\nclass MethodObject : public HiObject {\nfriend class MethodKlass;\n\nprivate:\n&nbsp; &nbsp; HiObject* _owner;\n&nbsp; &nbsp; FunctionObject* _func;\n\npublic:\n&nbsp; &nbsp; MethodObject(FunctionObject* func) : _owner(NULL), _func(func) {\n&nbsp; &nbsp; &nbsp; &nbsp; set_klass(MethodKlass::get_instance());\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; MethodObject(FunctionObject* func, HiObject* owner) : _owner(owner), _func(func) {\n&nbsp; &nbsp; &nbsp; &nbsp; set_klass(MethodKlass::get_instance());\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; void set_owner(HiObject * x)&nbsp; &nbsp;{ _owner = x; }\n&nbsp; &nbsp; HiObject* owner()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { return _owner; }\n&nbsp; &nbsp; FunctionObject* func()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _func; }\n};\n\n\n\n// runtime/functionObject.cpp\n/*\n&nbsp;*&nbsp; Operations for methods\n&nbsp;*&nbsp; Method is a wrapper for function.\n&nbsp;*/\nMethodKlass* MethodKlass::instance = NULL;\n\nMethodKlass* MethodKlass::get_instance() {\n&nbsp; &nbsp; if (instance == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; instance = new MethodKlass();\n\n&nbsp; &nbsp; return instance;\n}\n\nMethodKlass::MethodKlass() {\n&nbsp; &nbsp; set_klass_dict(new HiDict());\n}\n</code></pre><p>上述代码定义了 MethodObject 和 MethodKlass。定义一种新的 Object 以及它所对应的 Klass 对于我们来说已经算得上是轻车熟路了。</p><p>在这段代码里，我们看到 MethodObject 不过是 FunctionObject 的一层封装而已。MethodObject 与 FunctionObject 的唯一区别就是 MethodObject 多了一个 _owner 属性。</p><p>定义完了 MethodObject 以后，我们终于可以把 getattr 的逻辑补全了。如果从 klass_dict 中得到的是一个 FunctionObject，那么我们应该构建一个 MethodObject，把 FunctionObject 与目标对象绑定在一起。</p><pre><code class=\"language-c++\">HiObject* HiObject::getattr(HiObject* x) {\n&nbsp; &nbsp; HiObject* result = Universe::HiNone;\n\n&nbsp; &nbsp; result = klass()-&gt;klass_dict()-&gt;get(x);\n\n&nbsp; &nbsp; if (result == Universe::HiNone)\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n\n&nbsp; &nbsp; // Only klass attribute needs bind.\n&nbsp; &nbsp; if (MethodObject::is_function(result)) {\n&nbsp; &nbsp; &nbsp; &nbsp; result = new MethodObject((FunctionObject*)result, this);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return result;\n}\n</code></pre><p>LOAD_METHOD 终于完成了，这条字节码执行成功以后，加载到栈顶的就是一个正确的 MethodObject 了。</p><p>最后一步，CALL_FUNCTION 处还要增加对 MethodObject 的支持。所以我们要在 build_frame 中对 MethodObject 加以处理。</p><pre><code class=\"language-c++\">void Interpreter::build_frame(HiObject* callable, ObjList args) {\n&nbsp; &nbsp; if (callable-&gt;klass() == NativeFunctionKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; PUSH(((FunctionObject*)callable)-&gt;call(args));\n&nbsp; &nbsp; }\n&nbsp; &nbsp; else if (callable-&gt;klass() == MethodKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; MethodObject* method = (MethodObject*) callable;\n&nbsp; &nbsp; &nbsp; &nbsp; if (!args) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = new ArrayList&lt;HiObject*&gt;(1);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; args-&gt;insert(0, method-&gt;owner());\n&nbsp; &nbsp; &nbsp; &nbsp; build_frame(method-&gt;func(), args);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; else if (callable-&gt;klass() == FunctionKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; FrameObject* frame = new FrameObject((FunctionObject*) callable, args);\n&nbsp; &nbsp; &nbsp; &nbsp; frame-&gt;set_sender(_frame);\n&nbsp; &nbsp; &nbsp; &nbsp; _frame = frame;\n&nbsp; &nbsp; }\n}\n</code></pre><p>栈顶那个被调用的对象如果是 MethodObject 时，我们就将其 owner 放到参数列表的第一位（第 5 至 11 行）。我们正是通过这种方式将隐式参数与实参一起传给方法的。编译运行，就会发现这节课开始的那个 test_upper 的例子可以正确执行了。</p><p>到此为止，虚拟机中已经有了基本的内建类型、整数和字符串，也有了基本的函数和方法的功能。函数和方法还有更多的机制，但这需要虚拟机中支持了更多的内建对象以后才能实现。在完善函数的全部特性之前，我们下一节课需要先实现列表和字典这两种重要的内建类型。</p><h2>总结</h2><p>我们这节课重点介绍了如何实现内建函数和内建方法。我们使用 NativeFunctionKlass 来标识内建函数。一个 FunctionObject 的类型是内建函数，那么它就会包含一个函数指针，指向 C++ 所实现的函数。</p><p>在虚拟机的初始化阶段，builtin 结构中把字符串与 FunctionObject 关联起来，这样就可以使 LOAD_NAME 字节码正确地将 FunctionObject 加载到栈顶。</p><p>当函数被调用时，可以通过函数指针调用到相关的逻辑里。你可以看一下整体的流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/11/6bea886237c2427e3e155305fece5211.png?wh=1804x518\" alt=\"图片\"></p><p>在这节课的第二部分，我们讲解了如何实现一个内建方法。函数和方法的不同就在于是否绑定对象。所以内建方法需要使用 LOAD_METHOD 字节码进行加载，在加载的过程中，虚拟机将方法与对象进行绑定。</p><h2>思考题</h2><p>你是否能向虚拟机中添加更多的内建函数呢？欢迎你把你的想法分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"11｜函数的参数：赋予函数意义的关键特性","id":776961},"right":{"article_title":"13｜列表（上）：Python语言的核心数据结构","id":780132}},"comments":[{"had_liked":false,"id":395269,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1730008400,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":395219,"user_name":"冯某","can_delete":false,"product_type":"c1","uid":3889476,"ip_address":"上海","ucode":"7E78ECA53DF453","user_header":"https://static001.geekbang.org/account/avatar/00/3b/59/44/727b90a8.jpg","comment_is_top":false,"comment_ctime":1729764083,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"这里没有留言","like_count":0}]}