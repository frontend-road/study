{"id":213872,"title":"17  | Hashicorp Raft（一）：如何跨过理论和代码之间的鸿沟？","content":"<p>你好，我是韩健。</p><p>很多同学在开发系统的时候，都会有这样的感觉：明明自己看了很多资料，掌握了技术背后的原理，可在开发和调试的时候还是很吃力，这是为什么呢？</p><p>答案很简单，因为理论和实践本来就是两回事，实践不仅需要掌握API接口的用法，还需要理解API背后的代码实现。</p><p>所以，如果你在使用Raft开发分布式系统的时候，仅仅阅读Raft论文或者Raft实现的API手册，是远远不够的。你还要吃透API背后的代码实现，“不仅知其然，也要知其所以然”，这样才能“一切尽在掌握中”，从而开发实现能稳定运行的分布式系统。那么怎么做才能吃透Raft的代码实现呢？</p><p>要知道，任何Raft实现都承载了两个目标：实现Raft算法的原理，设计易用的API接口。所以，你不仅要从算法原理的角度理解代码实现，而且要从场景使用的角度理解API接口的用法。</p><p>而我会用两节课的时间，<strong>从代码实现和接口使用两个角度，</strong>带你循序渐进地掌握当前流行的一个Raft实现：<a href=\"https://github.com/hashicorp/raft\">Hashicorp Raft</a>（以最新稳定版v1.1.1为例）。希望你在这个过程中集中注意力，勾划重点，以便提高学习效率，吃透原理对应的技术实现，彻底掌握Raft算法的实战技巧。</p><p>本节课，我会从算法原理的角度，聊一聊Raft算法的核心功能（领导者选举和日志复制）在Hashicorp Raft中是如何实现的。（如果Raft算法的原理你已经忘得差不多了，那你可以先回顾下7～9讲，加深印象之后，再进入今天的学习。）</p><!-- [[[read_end]]] --><h2>Hashicorp Raft如何实现领导者选举？</h2><p><strong>在我看来，阅读源码的关键，在于找到代码的入口函数，</strong>比如在Golang代码中，程序的入口函数一般为main()函数，那么领导者选举的入口函数是哪个呢？</p><p>我们知道，典型的领导者选举在本质上是节点状态的变更。具体到Hashicorp Raft源码中，领导者选举的入口函数run()，在raft.go中以一个单独的协程运行，来实现节点状态变迁，就像下面的样子：</p><pre><code>func (r *Raft) run() {\n        for {\n                select {\n                // 关闭节点\n                case &lt;-r.shutdownCh:\n                        r.setLeader(&quot;&quot;)\n                        return\n                default:\n                }\n\n                switch r.getState() {\n                // 跟随者\n                case Follower:\n                        r.runFollower()\n                // 候选人\n                case Candidate:\n                        r.runCandidate()\n                // 领导者\n                case Leader:\n                        r.runLeader()\n                }\n        }\n}\n</code></pre><p>从上面这段代码中，你能看到，Follower（跟随者）、Candidate（候选人）、Leader（领导者）三个节点状态对应的功能，都被抽象成一个函数，分别是runFollower()、runCandidate()和runLeader()。</p><h3>数据结构</h3><p>在<a href=\"https://time.geekbang.org/column/article/204472\">07讲</a>中，我们先学习了节点状态，不过主要侧重理解节点状态的功能作用（比如说，跟随者相当于普通群众，领导者是霸道总裁），并没有关注它在实际代码中是如何实现的，所以我们先来看看在Hashicorp Raft中是如何实现节点状态的。</p><p>节点状态相关的数据结构和函数，是在state.go中实现的。跟随者、候选人和领导者的3个状态，是由RaftState定义的，一个无符号32位的只读整型数值（uint32）：</p><pre><code>type RaftState uint32\nconst (\n        // 跟随者\n        Follower RaftState = iota\n        // 候选人\n        Candidate\n        // 领导者\n        Leader\n        // 关闭状态\n        Shutdown\n)\n</code></pre><p>需要注意的是，<strong>也存在一些需要使用字符串格式的节点状态的场景（比如日志输出），</strong>这时你可以使用RaftState.String()函数。</p><p>你应该还记得，每个节点都有属于本节点的信息（比如任期编号），那么在代码中如何实现这些信息呢？这就要说到raftState数据结构了。</p><p>raftState属于结构体类型，是表示节点信息的一个大数据结构，里面包含了只属于本节点的信息，比如节点的当前任期编号、最新提交的日志项的索引值、存储中最新日志项的索引值和任期编号、当前节点的状态等，就像下面的样子：</p><pre><code>type raftState struct {\n        // 当前任期编号\n        currentTerm uint64\n\n        // 最大被提交的日志项的索引值\n        commitIndex uint64\n\n        // 最新被应用到状态机的日志项的索引值\n        lastApplied uint64\n\n        // 存储中最新的日志项的索引值和任期编号  \n        lastLogIndex uint64\n        lastLogTerm  uint64\n\n        // 当前节点的状态\n        state RaftState\n\n        ......\n}\n</code></pre><p>节点状态与节点信息的定义就是这么简单，这里我就不多说了。而在分布式系统中要实现领导者选举，更重要的一层内容是实现RPC消息，因为领导者选举的过程，就是一个RPC通讯的过程。</p><p>在理论篇中我说过，Raft算法中支持多种RPC消息（比如请求投票RPC消息、日志复制RPC消息）。所以接下来我们看一看，在Hashicorp Raft中又是怎样实现RPC消息的。又因为在一个RPC消息中，最重要的部分就是消息的内容，所以我们先来看一看RPC消息对应的数据结构。</p><p>RPC消息相关的数据结构是在commands.go中定义的，比如，日志复制RPC的请求消息，对应的数据结构为AppendEntriesRequest。而AppendEntriesRequest是一个结构体类型，里面包含了Raft算法论文中约定的字段，比如以下这些内容。</p><ul>\n<li>Term：当前的任期编号。</li>\n<li>PrevLogEntry：表示当前要复制的日志项，前面一条日志项的索引值。</li>\n<li>PrevLogTerm：表示当前要复制的日志项，前面一条日志项的任期编号。</li>\n<li>Entries：新日志项。</li>\n</ul><p>具体的结构信息，就像下面的样子：</p><pre><code>type AppendEntriesRequest struct {\n        // 当前的任期编号，和领导者信息（包括服务器ID和地址信息）\n        Term   uint64\n        Leader []byte\n\n        // 当前要复制的日志项，前面一条日志项的索引值和任期编号\n        PrevLogEntry uint64\n        PrevLogTerm  uint64\n\n        // 新日志项\n        Entries []*Log\n\n        // 领导者节点上的已提交的日志项的最大索引值\n        LeaderCommitIndex uint64\n}\n</code></pre><p>我建议你可以采用上面的思路，对照着算法原理去学习其他RPC消息的实现，这样一来你就能掌握独立学习的能力了。其他RPC消息的数据结构我就不一一描述了（如果你遇到问题，可以在留言区留言）。</p><p>现在，你已经了解了节点状态和RPC消息的格式，掌握了这些基础知识后，我们继续下一步，看看在Hashicorp Raft中是如何进行领导者选举的。</p><h3>选举领导者</h3><p>首先，在初始状态下，集群中所有的节点都处于跟随者状态，函数runFollower()运行，大致的执行步骤，就像下图的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/28/15/28753c692659fa4017c6a943c3d05b15.jpg?wh=1142*723\" alt=\"\"></p><p>我带你走一遍这五个步骤，便于你加深印象。</p><ol>\n<li>根据配置中的心跳超时时长，调用randomTimeout()函数来获取一个随机值，用以设置心跳超时时间间隔。</li>\n<li>进入到for循环中，通过select实现多路IO复用，周期性地获取消息和处理。如果步骤1中设置的心跳超时时间间隔发生了超时，执行步骤3。</li>\n<li>如果等待心跳信息未超时，执行步骤4，如果等待心跳信息超时，执行步骤5。</li>\n<li>执行continue语句，开始一次新的for循环。</li>\n<li>设置节点状态为候选人，并退出runFollower()函数。</li>\n</ol><p>当节点推举自己为候选人之后，函数runCandidate()执行，大致的执行步骤，如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/4d/989efd10cdff6825356b8a4310e5704d.jpg?wh=1142*784\" alt=\"\"></p><p>同样的，我们走一遍这个过程，加深一下印象。</p><ol>\n<li>首先调用electSelf()发起选举，给自己投一张选票，并向其他节点发送请求投票RPC消息，请求他们选举自己为领导者。然后调用randomTimeout()函数，获取一个随机值，设置选举超时时间。</li>\n<li>进入到for循环中，通过select实现多路IO复用，周期性地获取消息和处理。如果发生了选举超时，执行步骤3，如果得到了投票信息，执行步骤4。</li>\n<li>发现了选举超时，退出runCandidate()函数，然后再重新执行runCandidate()函数，发起新一轮的选举。</li>\n<li>如果候选人在指定时间内赢得了大多数选票，那么候选人将当选为领导者，调用setState()函数，将自己的状态变更为领导者，并退出runCandidate()函数。</li>\n</ol><p>当节点当选为领导者后，函数runLeader()就执行了：</p><p><img src=\"https://static001.geekbang.org/resource/image/17/3e/17619089bc683d8a1a2bd20bf678503e.jpg?wh=1142*998\" alt=\"\"></p><p>整个过程，主要有4个步骤。</p><ol>\n<li>调用startStopReplication()，执行日志复制功能。</li>\n<li>然后启动新的协程，调用replicate()函数，执行日志复制功能。</li>\n<li>接着在replicate()函数中，启动一个新的协程，调用heartbeat()函数，执行心跳功能。</li>\n<li>在heartbeat()函数中，周期性地发送心跳信息，通知其他节点，我是领导者，我还活着，不需要你们发起新的选举。</li>\n</ol><p>其实，在Hashicorp Raft中实现领导者选举并不难，你只要充分理解上述步骤，并记住，领导者选举本质上是节点状态变迁，跟随者、候选人、领导者对应的功能函数分别为runFollower()、runCandidate()、runLeader()，就可以了。</p><h2>Hashicorp Raft如何复制日志？</h2><p>学习<a href=\"https://time.geekbang.org/column/article/205784\">08</a>讲之后，你应该知道了日志复制的重要性，因为Raft是基于强领导者模型和日志复制，最终实现强一致性的。那么你该如何学习日志复制的代码实现呢？和学习“如何实现领导者选举”一样，你需要先了解了日志相关的数据结构，阅读日志复制相关的代码。</p><p>学习了理论篇后，你应该还记得日志复制是由领导者发起的，跟随者来接收的。可能有同学已经想到了，领导者复制日志和跟随者接收日志的入口函数，应该分别在runLeader()和runFollower()函数中调用的。赞！理解正确！</p><ul>\n<li>领导者复制日志的入口函数为startStopReplication()，在runLeader()中，以r.startStopReplication()形式被调用，作为一个单独协程运行。</li>\n<li>跟随者接收日志的入口函数为processRPC()，在runFollower()中以r.processRPC(rpc)形式被调用，来处理日志复制RPC消息。</li>\n</ul><p>不过，在分析日志复制的代码实现之前，咱们先来聊聊日志相关的数据结构，便于你更好地理解代码实现。</p><h3>数据结构</h3><p>08讲中我提到过，一条日志项主要包含了3种信息，分别是指令、索引值、任期编号，而在Hashicorp Raft实现中，日志对应的数据结构和函数接口是在log.go中实现的，其中，日志项对应的数据结构是结构体类型的，就像下面的样子：</p><pre><code>type Log struct {\n        // 索引值\n        Index uint64\n\n        // 任期编号\n        Term uint64\n\n        // 日志项类别\n        Type LogType\n\n        // 指令\n        Data []byte\n\n        // 扩展信息\n        Extensions []byte\n}\n</code></pre><p>我强调一下，与协议中的定义不同，日志项对应的数据结构中，包含了LogType和Extensions两个额外的字段：</p><ul>\n<li>LogType可用于标识不同用途的日志项，比如，使用LogCommand标识指令对应的日志项，使用LogConfiguration表示成员变更配置对应的日志项。</li>\n<li>Extensions可用于在指定日志项中存储一些额外的信息。<strong>这个字段使用的比较少，在调试等场景中可能会用到，你知道有这么个字段就可以了。</strong><br>\n说完日志复制对应的数据结构，我们分步骤看一下，在Hashicorp Raft中是如何实现日志复制的。</li>\n</ul><h3>领导者复制日志</h3><p>日志复制是由领导者发起，在runLeader()函数中执行的，主要有这样几个步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/63/c2aa9f2c31571e8cdc4dbe13ef210663.jpg?wh=1142*540\" alt=\"\"></p><ol>\n<li>在 runLeader()函数中，调用startStopReplication()函数，执行日志复制功能。</li>\n<li>启动一个新协程，调用replicate()函数，执行日志复制相关的功能。</li>\n<li>在replicate()函数中，调用replicateTo()函数，执行步骤4，如果开启了流水线复制模式，执行步骤5。</li>\n<li>在replicateTo()函数中，进行日志复制和日志一致性检测，如果日志复制成功，则设置s.allowPipeline = true，开启流水线复制模式。</li>\n<li>调用pipelineReplicate()函数，采用更高效的流水线方式，进行日志复制。</li>\n</ol><p>在这里我强调一下，在什么条件下开启了流水线复制模式，很多同学可能会在这一块儿产生困惑，因为代码逻辑上有点儿绕。<strong>你可以这么理解，是在不需要进行日志一致性检测，复制功能已正常运行的时候，开启了流水线复制模式，</strong>目标是在环境正常的情况下，提升日志复制性能，如果在日志复制过程中出错了，就进入RPC复制模式，继续调用replicateTo()函数，进行日志复制。</p><h3>跟随者接收日志</h3><p>领导者复制完日志后，跟随者会接收日志并开始处理日志。跟随者接收和处理日志，是在runFollower()函数中执行的，主要有这样几个步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/99/96/99458f26ef6387bc8b20b16380d46896.jpg?wh=1142*573\" alt=\"\"></p><ol>\n<li>在runFollower()函数中，调用processRPC()函数，处理接收到的RPC消息。</li>\n<li>在processRPC()函数中，调用appendEntries()函数，处理接收到的日志复制RPC请求。</li>\n<li>appendEntries()函数，是跟随者处理日志的核心函数。在步骤3.1中，比较日志一致性；在步骤3.2中，将新日志项存放在本地；在步骤3.3中，根据领导者最新提交的日志项索引值，来计算当前需要被应用的日志项，并应用到本地状态机。</li>\n</ol><p>讲到这儿，你应该可以了解日志复制的代码实现了吧。关于更多的Raft原理的代码实现，你可以继续阅读源码来学习，如果在学习过程中有疑问，欢迎给我留言。</p><h2>内容小结</h2><p>本节课我主要带你了解了如何从算法原理的角度理解Hashicorp Raft实现，有几个重点我想强调一下：</p><ol>\n<li>\n<p>跟随者、候选人、领导者3种节点状态都有分别对应的功能函数，当需要查看各节点状态相关的功能实现时（比如，跟随者如何接收和处理日志），都可以将对应的函数作为入口函数，来阅读代码和研究功能实现。</p>\n</li>\n<li>\n<p>raft.go是Hashicorp Raft的核心代码文件，大部分的核心功能都是在这个文件中实现的，平时可以多研究这个文件中的代码，直到彻底吃透，掌握。</p>\n</li>\n<li>\n<p>在Hashicorp Raft中，支持两种节点间通讯机制，内存型和TCP协议型，其中，内存型通讯机制，主要用于测试，2种通讯机制的代码实现，分别在文件inmem_transport.go和tcp_transport.go中。</p>\n</li>\n<li>\n<p>Hashicorp Raft实现，是常用的Golang版Raft算法的实现，被众多流行软件使用，如Consul、InfluxDB、IPFS等，相信你对它并不陌生。其他的实现还有<a href=\"https://github.com/goraft/raft\">Go-Raft</a>、<a href=\"https://github.com/logcabin/logcabin\">LogCabin</a>、<a href=\"https://github.com/willemt/raft\">Willemt-Raft</a>等，不过我建议你在后续开发分布式系统时，优先考虑Hashicorp Raft，因为Hashicorp Raft实现，功能完善、代码简洁高效、流行度高，可用性和稳定性被充分打磨。</p>\n</li>\n</ol><p>最后，关于如何高效地阅读源码，我还想多说一说。在我看来，高效阅读源码的关键在于抓住重点，要有“底线”，不要芝麻和西瓜一把抓，什么都想要，最终陷入到枝节琐碎的细节中出不来。什么是重点呢？我认为重点是数据结构和关键的代码执行流程，比如在Hashicorp Raft源码中，日志项对应的数据结构、RPC消息对应的数据结构、选举领导者的流程、日志复制的流程等，这些就是重点。</p><p>有的同学可能还有疑问：在阅读源码的时候，如果遇到不是很明白的代码，该怎么办呢？我建议你可以通过打印日志或GDB单步调试的方式，查看上下文中的变量的内容、代码执行逻辑等，帮助理解。</p><h2>课堂思考</h2><p>在Hashicorp Raft实现中，我讲了如何实现选举领导者，以及如何复制日志等，那么在Hashicorp Raft中，网络通讯是如何实现的呢？欢迎在留言区分享你的看法，与我一同讨论。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"16 | InfluxDB企业版一致性实现剖析：他山之石，可以攻玉","id":212394},"right":{"article_title":"18 | Hashicorp Raft（二）：如何以“集群节点”为中心使用API？","id":215116}},"comments":[{"had_liked":false,"id":196737,"user_name":"姜川","can_delete":false,"product_type":"c1","uid":1684311,"ip_address":"","ucode":"0F8A349623EAB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","comment_is_top":false,"comment_ctime":1585308933,"is_pvip":false,"replies":[{"id":"75556","content":"加一颗星:)","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1585934505,"ip_address":"","comment_id":196737,"utype":1}],"discussion_count":2,"race_medal":0,"score":"83189687557","product_id":100046101,"comment_content":"Java版可以看dledger ","like_count":20,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489372,"discussion_content":"加一颗星:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585934505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2733281,"avatar":"","nickname":"Geek_f4512f","note":"","ucode":"3CB387D2943590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388973,"discussion_content":"我擦 你这是 救命留言啊！！！！ Top1 ;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629080561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190558,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1584668637,"is_pvip":false,"replies":[{"id":"76013","content":"可以这么理解，Raft是通过实现各节点日志的一致等，最终实现了强一致性，能保证写操作完成后，就能立即和一直读到新数据，这也是Consul他们所需要的。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1586202414,"ip_address":"","comment_id":190558,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35944407005","product_id":100046101,"comment_content":"Raft 说到底就是保证集群中各节点的日志一致，那么在  Consul、InfluxDB、IPFS 中，Raft 又是怎么被使用的呢？","like_count":8,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488004,"discussion_content":"可以这么理解，Raft是通过实现各节点日志的一致等，最终实现了强一致性，能保证写操作完成后，就能立即和一直读到新数据，这也是Consul他们所需要的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586202414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211624,"discussion_content":"https://github.com/tinylcy/rastore 找到一个基于 Raft 的分布式存储，值得一看。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584870856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190966,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1584713936,"is_pvip":false,"replies":[{"id":"77967","content":"加一颗星:），发、收分离，持续异步发送日志项，不阻塞，也不需要考虑日志不一致等异常情况，纯复制。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1587406489,"ip_address":"","comment_id":190966,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31649485008","product_id":100046101,"comment_content":"流水线复制是如何优化日志复制的性能的呢？","like_count":7,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488090,"discussion_content":"加一颗星:），发、收分离，持续异步发送日志项，不阻塞，也不需要考虑日志不一致等异常情况，纯复制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587406489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213031,"discussion_content":"看了一下，分离发送与接收的操作，即在复制日志的时候，发送日志复制请求给 follower ，然后异步等待相应，既可以不断的发送请求；非流水线的话，是发送日志复制请求后，阻塞等待相应，才能发下一个请求。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585044215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194270,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1585044427,"is_pvip":false,"replies":[{"id":"76005","content":"加一颗星:)，调用match()函数，来统计日志复制结果和判断大多数的，并将结果发送到commitCh，最终在leaderLoop()中处理committed日志项的。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1586199456,"ip_address":"","comment_id":194270,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23059880907","product_id":100046101,"comment_content":"Leader 收到 client 请求，然后把日志写到自己的 disk 中，然后通知 Follower 复制日志，然后 leader 等待相应，收到大多数相应后，commit 该条日志；在代码中，只找到了 “Leader 收到 client 请求，然后把日志写到自己的 disk 中，然后通知 Follower 复制日志”，没找到 leader 是如何判断是否有大多数相应，且是在什么时候 commit 的。希望老师可以指点一下？<br>PS：源代码中的 chan 通信，真的折磨人。","like_count":6,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488799,"discussion_content":"加一颗星:)，调用match()函数，来统计日志复制结果和判断大多数的，并将结果发送到commitCh，最终在leaderLoop()中处理committed日志项的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586199456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300192,"user_name":"Ricky Fung","can_delete":false,"product_type":"c1","uid":1051363,"ip_address":"","ucode":"7AEA1F8EC4A088","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/e3/9637bfdb.jpg","comment_is_top":false,"comment_ctime":1625040744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14509942632","product_id":100046101,"comment_content":"c++ 实现可以看百度开源的 braft：https:&#47;&#47;github.com&#47;baidu&#47;braft<br>java实现可以看蚂蚁金服开源的sofa-jraft：https:&#47;&#47;github.com&#47;sofastack&#47;sofa-jraft","like_count":4},{"had_liked":false,"id":229037,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1592883520,"is_pvip":true,"replies":[{"id":"88047","content":"加一颗星:)，条件1，当前集群只有它一个节点，那么此时不需要进行领导者选举；条件2：该节点不具有投票权，不能进行领导者选举。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1596135437,"ip_address":"","comment_id":229037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10182818112","product_id":100046101,"comment_content":"老师 runFollower()里面这两个判断 if r.configurations.latestIndex == 0 和 if r.configurations.latestIndex == r.configurations.committedIndex &amp;&amp; !hasVote(r.configurations.latest, r.localID) 原理是什么啊？","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499306,"discussion_content":"加一颗星:)，条件1，当前集群只有它一个节点，那么此时不需要进行领导者选举；条件2：该节点不具有投票权，不能进行领导者选举。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596135437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199292,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1585485943,"is_pvip":true,"replies":[{"id":"75452","content":"Hashicorp Raft是个package，可以将它理解成库（lib），是没有main函数的，可以通过API函数（比如AddVoter()）或者核心函数（比如run()），作为入口函数，来进一步学习。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1585844622,"ip_address":"","comment_id":199292,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10175420535","product_id":100046101,"comment_content":"Hashicorp Raft  找了半天 没有找到入口 main 函数","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489816,"discussion_content":"Hashicorp Raft是个package，可以将它理解成库（lib），是没有main函数的，可以通过API函数（比如AddVoter()）或者核心函数（比如run()），作为入口函数，来进一步学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585844622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192874,"user_name":"坤","can_delete":false,"product_type":"c1","uid":1010922,"ip_address":"","ucode":"74E6838226A405","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/ea/ce9854a5.jpg","comment_is_top":false,"comment_ctime":1584877149,"is_pvip":false,"replies":[{"id":"75568","content":"package是无法直接编译的，需要在程序的main()中被调用后，才能编译。可以编译、研究下20讲的程序。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1585937140,"ip_address":"","comment_id":192874,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174811741","product_id":100046101,"comment_content":"韩老师，您好，hashicorp 实现的raft package, 我看github上的标签是build failed, 我试过多个tag都是一样的。","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488478,"discussion_content":"package是无法直接编译的，需要在程序的main()中被调用后，才能编译。可以编译、研究下20讲的程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585937140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190465,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1584662674,"is_pvip":false,"replies":[{"id":"75707","content":"加油！有问题多交流:)","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1586019782,"ip_address":"","comment_id":190465,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10174597266","product_id":100046101,"comment_content":"好，下去结合之前的理论看看源码","like_count":2,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487986,"discussion_content":"加油！有问题多交流:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586019782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300193,"user_name":"Ricky Fung","can_delete":false,"product_type":"c1","uid":1051363,"ip_address":"","ucode":"7AEA1F8EC4A088","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/e3/9637bfdb.jpg","comment_is_top":false,"comment_ctime":1625042063,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5920009359","product_id":100046101,"comment_content":"java实现可参考蚂蚁金服开源的 sofa-jraft：https:&#47;&#47;github.com&#47;sofastack&#47;sofa-jraft<br>c++实现可参考百度开源的 braft：https:&#47;&#47;github.com&#47;baidu&#47;braft","like_count":2,"discussions":[{"author":{"id":2733281,"avatar":"","nickname":"Geek_f4512f","note":"","ucode":"3CB387D2943590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388975,"discussion_content":"SOFAJRaft 是从百度的 braft 移植而来，做了一些优化和改进，感谢百度 braft 团队开源了如此优秀的 C++ RAFT 实现 历害啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629080939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221753,"user_name":"cyq","can_delete":false,"product_type":"c1","uid":1656802,"ip_address":"","ucode":"958972090C4447","user_header":"https://static001.geekbang.org/account/avatar/00/19/47/e2/cfbeb06c.jpg","comment_is_top":false,"comment_ctime":1590583627,"is_pvip":false,"replies":[{"id":"87264","content":"加一颗星:)，存在领导者，或者它发现了有比它更适合作为领导者的节点，具体来说，就是接收到领导者的心跳，或者接收到的投票请求的响应中的任期编号，比它的大。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1595343685,"ip_address":"","comment_id":221753,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5885550923","product_id":100046101,"comment_content":"对于hashicorp&#47;raft的代码中，如果一个节点是candidate状态。那么他是在什么时候会恢复为Follower的身份?","like_count":1,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496553,"discussion_content":"加一颗星:)，存在领导者，或者它发现了有比它更适合作为领导者的节点，具体来说，就是接收到领导者的心跳，或者接收到的投票请求的响应中的任期编号，比它的大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595343685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2733281,"avatar":"","nickname":"Geek_f4512f","note":"","ucode":"3CB387D2943590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388979,"discussion_content":"假如开场 A(1s) B(2s) C(3s) ，然后A的1s转完了，发现还没有领导，就投了自己一票 任期为1 另外转发RPC 给  B C 节点，这时B C 节点还在自转呢；由于网络阻塞，A发给B的RPC 没有及时到B，B自己的2s转完了(C 还在转3s中)，也发现没有领导者，也就自己投了自己的一票，任期为1，再转发RPC给A B节点 , 这时局面 该咋办呢？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629081599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193458,"user_name":"Michael Tesla","can_delete":false,"product_type":"c1","uid":1033053,"ip_address":"","ucode":"C627F090293608","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/5d/ced9b5c2.jpg","comment_is_top":false,"comment_ctime":1584894227,"is_pvip":false,"replies":[{"id":"75565","content":"加一颗星:)。我推荐，先大概了解下算法的原理，然后将Raft实现（比如Hashicorp Raft）使用起来，有了感觉后，再将代码和论文结合着学习。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1585936660,"ip_address":"","comment_id":193458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879861523","product_id":100046101,"comment_content":"老师，是不是得先把大论文看一遍，再看代码，效果比较好？","like_count":1,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488561,"discussion_content":"加一颗星:)。我推荐，先大概了解下算法的原理，然后将Raft实现（比如Hashicorp Raft）使用起来，有了感觉后，再将代码和论文结合着学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585936660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190511,"user_name":"冷笑的花猫","can_delete":false,"product_type":"c1","uid":1119029,"ip_address":"","ucode":"6C368FBB577470","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/35/45391914.jpg","comment_is_top":false,"comment_ctime":1584666109,"is_pvip":false,"replies":[{"id":"76171","content":"加一颗星:)，问题1：重新发起新的选举。问题2：主要是任期编号，更多信息可以参考下07讲的内容。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1586279878,"ip_address":"","comment_id":190511,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879633405","product_id":100046101,"comment_content":"选举leader那段，先投自己一票，然后通过rpc让其它节点投票给自己。有些不理解，1  如果随机时间没收到投票怎么办？2  其它节点是如何回应这个投票信息的，基于什么标准决定投还是不投？ 谢谢","like_count":1,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487995,"discussion_content":"加一颗星:)，问题1：重新发起新的选举。问题2：主要是任期编号，更多信息可以参考下07讲的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586279878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342352,"user_name":"tiny🌾","can_delete":false,"product_type":"c1","uid":1119851,"ip_address":"","ucode":"7A4DE00381D1F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/6b/af7c7745.jpg","comment_is_top":false,"comment_ctime":1650205270,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650205270","product_id":100046101,"comment_content":"只有一个领导节点能写，那怎么保证性能了？ 如果写性能扛不住怎么办啊","like_count":0},{"had_liked":false,"id":313190,"user_name":"DavidJiang","can_delete":false,"product_type":"c1","uid":1643779,"ip_address":"","ucode":"92EBF337569A1B","user_header":"https://static001.geekbang.org/account/avatar/00/19/15/03/682bd618.jpg","comment_is_top":false,"comment_ctime":1632304545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632304545","product_id":100046101,"comment_content":"这个日志复制复制的具体是啥?和mysql中的binlog有什么本质的区别,看上去都是指令在本地执行.那么是否也会面临binlog复制的问题?","like_count":0},{"had_liked":false,"id":288230,"user_name":"Geek_a2ca6c","can_delete":false,"product_type":"c1","uid":2149579,"ip_address":"","ucode":"B22D001F1CD8A2","user_header":"","comment_is_top":false,"comment_ctime":1618371682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618371682","product_id":100046101,"comment_content":"我看这个实现的源代码里，requestvote函数，先是检查本地状态机的leader信息有没有，如果有leader信息，并且和发起投票的节点不一致，就拒绝本次投票。那是不是说并不是最先超时发起投票的节点不一定成为主几点，的集群大多数人超时后失去leader信息后，才会发起投票吗。","like_count":0},{"had_liked":false,"id":286318,"user_name":"David","can_delete":false,"product_type":"c1","uid":1044324,"ip_address":"","ucode":"8A5F064C911714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ef/64/5b71bb14.jpg","comment_is_top":false,"comment_ctime":1617253845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617253845","product_id":100046101,"comment_content":"老师好，订阅这门课程有收获，谢谢！<br>在阅读Raft源代码时，有个疑问（可能是还没有看明白原因）：follower接收投票请求时，会做些参数验证，具体代码是这几行：<br>if leader := r.Leader(); leader != &quot;&quot; &amp;&amp; leader != candidate &amp;&amp; !req.LeadershipTransfer {<br>\t\tr.logger.Warn(fmt.Sprintf(&quot;Rejecting vote request from %v since we have a leader: %v&quot;,<br>\t\t\tcandidate, leader))<br>\t\treturn<br>\t}<br>我的疑问是这样的：某候选者进入拉票阶段时，因每个follower的timeout不一样，这行代码:<br>leader := r.Leader(); leader != &quot;&quot; &amp;&amp; leader != candidate &amp;&amp; !req.LeadershipTransfer 有概率似乎为true的，请问老师这里怎么理解呢，非常感谢！<br>\t","like_count":0},{"had_liked":false,"id":261010,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1605172526,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605172526","product_id":100046101,"comment_content":"最近正好学习了go，真是干货满满。","like_count":0},{"had_liked":false,"id":230058,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1593248517,"is_pvip":false,"replies":[{"id":"87385","content":"加一颗星:)，不同的函数封装，replicate函数是在startStopReplication函数中被调用的，可以结合源码来理解哈。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1595439369,"ip_address":"","comment_id":230058,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593248517","product_id":100046101,"comment_content":"startStopReplication和replicate函数区别是啥？怎么都是日志复制相关功能...","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499750,"discussion_content":"加一颗星:)，不同的函数封装，replicate函数是在startStopReplication函数中被调用的，可以结合源码来理解哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595439369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208596,"user_name":"cbping","can_delete":false,"product_type":"c1","uid":1608798,"ip_address":"","ucode":"16D891E80A352B","user_header":"https://static001.geekbang.org/account/avatar/00/18/8c/5e/8cb6fad1.jpg","comment_is_top":false,"comment_ctime":1587388334,"is_pvip":false,"replies":[{"id":"77947","content":"文章开始处有链接，在这里，我显式贴下：https:&#47;&#47;github.com&#47;hashicorp&#47;raft","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1587397526,"ip_address":"","comment_id":208596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587388334","product_id":100046101,"comment_content":"源码在哪里呢？","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492530,"discussion_content":"文章开始处有链接，在这里，我显式贴下：https://github.com/hashicorp/raft","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587397526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203058,"user_name":"阿鼎","can_delete":false,"product_type":"c1","uid":1042634,"ip_address":"","ucode":"EE763513563F50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","comment_is_top":false,"comment_ctime":1586133515,"is_pvip":false,"replies":[{"id":"75944","content":"需要做全面的监控能力，监控是业务之眼，需要做好基础监控、统计上报、埋点上报和告警，比如，CPU、内存、进程运行、写请求数据、读请求数、写失败数、业务日志等，另外，可以考虑做全链路监控。基础工具，可以考虑InfluxDB、Grafana、ES等。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1586167308,"ip_address":"","comment_id":203058,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586133515","product_id":100046101,"comment_content":"请问老师，分布式系统，日志分散，排查问题有什么经验？有什么基础工具可以运用。","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490749,"discussion_content":"需要做全面的监控能力，监控是业务之眼，需要做好基础监控、统计上报、埋点上报和告警，比如，CPU、内存、进程运行、写请求数据、读请求数、写失败数、业务日志等，另外，可以考虑做全链路监控。基础工具，可以考虑InfluxDB、Grafana、ES等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586167308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}