{"id":485746,"title":"26 | 微服务网关：如何设置请求转发、跨域和限流规则？","content":"<p>你好，我是姚秋辰。</p><p>在上节课中，我们了解了如何在Spring Cloud Gateway中加载一个路由，以及常用的内置谓词都有哪些。今天我们就来动手实践一把，在实战项目中搭建一个Gateway网关，并完成三个任务：设置跨域规则、添加路由和实现网关层限流。这三个任务将以怎样的方式展开呢？</p><p>首先是跨域规则，它是一段添加在配置文件中的逻辑。我将在编写网关配置文件的同时，顺便为你讲解下跨域的基本原理，以及如何设置同源访问策略。</p><p>然后，我将使用基于Java代码的方式来定义静态路由规则。当然了，你也可以使用配置文件来编写路由，用代码还是用配置全凭个人喜好。不过呢，如果你的路由规则比较复杂，比如，它包含了大量谓词和过滤器，那么我还是推荐你使用代码方式，可读性高，维护起来也容易一些。</p><p>最后就是网关层限流，我们将使用内置的Lua脚本，并借助Redis组件来完成网关层限流。</p><p>闲话少叙，我们先去搭建一个微服务网关应用吧。你可以在<a href=\"https://gitee.com/banxian-yao/geekbang-coupon-center\">Gitee代码仓库</a>中找到下面所有源码。</p><h2>创建微服务网关</h2><p>微服务网关是一个独立部署的平台化组件，我们先在middleware目录下创建一个名为gateway的子模块。接下来的工作就是按部就班地搞定依赖项、配置项和路由规则。</p><!-- [[[read_end]]] --><h3>添加依赖项</h3><p>我们要在这个模块的pom.xml文件中添加几个关键依赖项，分别是Gateway、Nacos和Loadbalancer。你可以参考下面的代码。</p><pre><code class=\"language-plain\">&lt;dependencies&gt;\n    &lt;!-- Gateway正经依赖 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- Nacos服务发现 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n    &lt;/dependency&gt;    \n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- Redis+Lua限流 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    \n    &lt;!-- 其它非关键注解请参考源码 --&gt;\n&lt;/dependencies&gt;\n</code></pre><p>这里我只列出了核心依赖项，还有一些辅助依赖组件我没有一一列出，你可以参考源码，查看完整的依赖项列表。</p><p>在这几个核心依赖项中，打头的spring-cloud-starter-gateway是最重要的一个，它是实现了网关功能模块的基础组件。而Nacos和Loadbalancer则扮演了“导航”的作用，让Gateway在请求转发的过程中可以通过“服务发现+负载均衡”定位到对应的服务节点。最后一个是Redis依赖项，待会儿我们会用它来实现网关层限流。</p><p>虽然我没有把链路追踪组件的相关依赖项添加到Gateway组件中，但是网关通常是一次服务调用的起点，我们在搭建线上应用的时候，应当把Gateway纳入到链路追踪体系当中。所以呢我们需要将Sleuth、Zipkin还有ELK集成进来，我把这个任务留给了你来实现，你可以从依赖项的添加开始，完整回顾一下前面学过的链路追踪知识点，温故而又知新。</p><p>依赖项添加完成后，我们接下来去编写bootstrap.yml和application.yml配置文件。</p><h3>添加配置文件</h3><p>首先，我们创建一个bootstrap.yml，将“coupon-gateway”定义为当前项目的名称。使用bootstrap.yml的目的之一是优先加载Nacos Config配置项，我们要借助Nacos来完成动态路由表的加载，这部分的内容我将放到下一课再讲。</p><pre><code class=\"language-plain\">spring:\n  application:\n    name: coupon-gateway\n</code></pre><p>接下来，我们创建一个application.yml。这个配置文件里的内容主要就两部分，一部分是Nacos服务发现的配置项，这段是老生常谈了咱就不再展开讲了。另一部分是Gateway特有的配置项，我们来看一下。</p><p>我会通过Java代码来落地各种路由规则，所以你看到的配置文件并不包含任何路由规则，非常干净清爽。如果你比较喜欢用配置项来定义路由规则，那你可以在spring.cloud.gateway.routes节点下尽情发挥，定义各种路由、谓词断言和过滤器规则。我在<a href=\"https://time.geekbang.org/column/article/485068\">上节课</a>开头写了几个在yml中定义路由规则的例子，你可以参考一下。</p><pre><code class=\"language-yaml\">server:\n  port: 30000\nspring:\n  # 分布式限流的Redis连接\n  redis:\n    host: localhost\n    port: 6379\n  cloud:\n    nacos:\n      # Nacos配置项\n      discovery:\n        server-addr: localhost:8848\n        heart-beat-interval: 5000\n        heart-beat-timeout: 15000\n        cluster-name: Cluster-A\n        namespace: dev\n        group: myGroup\n        register-enabled: true\n    gateway:\n      discovery:\n        locator:\n          # 创建默认路由，以\"/服务名称/接口地址\"的格式规则进行转发\n          # Nacos服务名称本来就是小写，但Eureka默认大写\n          enabled: true\n          lower-case-service-id: true\n      # 跨域配置\n      globalcors:\n        cors-configurations:\n          '[/**]':\n            # 授信地址列表\n            allowed-origins:\n              - \"http://localhost:10000\"\n              - \"https://www.geekbang.com\"\n            # cookie, authorization认证信息\n            expose-headers: \"*\"\n            allowed-methods: \"*\"\n            allow-credentials: true\n            allowed-headers: \"*\"\n            # 浏览器缓存时间\n            max-age: 1000          \n</code></pre><h3></h3><p>上面这段配置代码的重点是<strong>全局跨域规则</strong>，我在spring.cloud.gateway.globalcors下添加了一段跨域规则的相关配置，这里我们就来展开说道说道。</p><h3>什么是跨域规则</h3><p>在了解如何配置跨域规则之前，我需要先为你讲一讲什么是浏览器的“<strong>同源保护策略</strong>”。</p><p>如果前后端是分离部署的，大部分情况下，前端系统和后端API都在同一个根域名下，但也有少数情况下，前后端位于不同域名。比如前端页面的地址是geekbang.com，后端API的访问地址是infoq.com。如果一个应用请求发生了跨域名访问，比如位于geekbang.com的页面通过Node.js访问了infoq.com的后端API，这种情况就叫“跨域请求”。</p><p>我们的浏览器对跨域访问的请求设置了一道保护措施，在跨域调用发起之前，浏览器会尝试发起一个OPTIONS类型的请求到目标地址，探测一下你的后台服务是否支持跨域调用。如果你的后端Say NO，那么前端浏览器就会阻止这次非同源访问。通过这种方式，一些美女聊天类的钓鱼网站就无法对你实施跨站脚本攻击了，这就是浏览器端的同源保护策略。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/6e/6bfd90ef7bb1bae3da1f5d56cc01fb6e.jpg?wh=1920x650\" alt=\"图片\"></p><p>不过也有一种例外，比如你的前端网站和后端接口确实部署在了两个域名，而这两个域名背后都是正经应用，这时候为了让浏览器可以通过同源保护策略的检查，你就必须在后台应用里设置跨域规则，告诉浏览器哪些跨域请求是可以被接受的。</p><p>我们接下来就来了解一下，如何通过跨域配置的参数来控制跨域访问。这些参数都定义在的spring.cloud.gateway.globalcors.cors-configurations节点的[/*<em>*]路径下，[/</em>**]这串通配符可以匹配所有请求路径。当然了，你也可以为某个特定的路径设置跨域规则（比如[/order/]）。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/de/dfa28388e7fae3c99ed29e2323ffe1de.jpg?wh=1920x840\" alt=\"图片\"></p><p>在这上面的几个配置项中，allowed-origins是最重要的，你需要将受信任的域名添加到这个列表当中。从安全性角度考虑，非特殊情况下我并不建议你使用*通配符，因为这意味着后台服务可以接收任何跨域发来的请求。</p><p>到这里，所有配置都已经Ready了，我们可以去代码中定义路由规则了。</p><h2>定义路由规则</h2><p>我推荐你使用一个独立的配置类来管理路由规则，这样代码看起来比较清晰。比如我这里就在com.geekbang.gateway下面创建了RoutesConfiguration类，为三个微服务分别定义了简单明了的规则。你可以参考一下这段代码。</p><pre><code class=\"language-java\">@Configuration\npublic class RoutesConfiguration {\n\n    @Bean\n    public RouteLocator declare(RouteLocatorBuilder builder) {\n        return builder.routes()\n                .route(route -&gt; route\n                        .path(\"/gateway/coupon-customer/**\")\n                        .filters(f -&gt; f.stripPrefix(1))\n                        .uri(\"lb://coupon-customer-serv\")\n                ).route(route -&gt; route\n                        .order(1)\n                        .path(\"/gateway/template/**\")\n                        .filters(f -&gt; f.stripPrefix(1))\n                        .uri(\"lb://coupon-template-serv\")\n                ).route(route -&gt; route\n                        .path(\"/gateway/calculator/**\")\n                        .filters(f -&gt; f.stripPrefix(1))\n                        .uri(\"lb://coupon-calculation-serv\")\n            ).build();\n    }\n}\n</code></pre><p>这三个路由规则都是大同小异的。我们就以第二个路由规则为例，你可以看出，路由设置遵循了一套三连的风格。</p><p>首先，我使用path谓词约定了路由的匹配规则为path=“/template/**”。这里你要注意的是，如果某一个请求匹配上了多个路由，但你又想让各个路由之间有个先后匹配顺序，这时你就可以使用order(n)方法设定路由优先级，n数字越小则优先级越高。</p><p>接下来，我使用了一个stripPrefix过滤器，将path访问路径中的第一个前置子路径删除掉。这样一来，/gateway/template/xxx的访问请求经由过滤器处理后就变成了/template/xxx。同理，如果你想去除path中打头的前两个路径，那就使用stripPrefix(2)，参数里传入几它就能吞掉几个prefix path。</p><p>最后，我使用uri方法指定了当前路由的目标转发地址，这里的“lb://coupon-template-serv”表示使用本地负载均衡将请求转发到名为“coupon-template-serv”的服务。</p><p>在这一套三连里，谓词和uri你是再熟悉不过了，但这个filter想必还是第一次见到。我来带你简单了解一下Gateway Filter的使用方式，再用一个简单的小案例教你借助过滤器来实现基于Lua + Redis的网关层限流。</p><h2>Filter和网关限流</h2><p>在<a href=\"https://time.geekbang.org/column/article/484447\">第23课</a>中，我们了解了Gateway过滤器在一个Request生命周期中的作用阶段。其实Filter的一大功能无非就是对Request和Response动手动脚，为什么这么说呢？比如你想对Request Header和Parameter进行删改，又或者从Response里面删除某个Header，那么你就可以使用下面这种方式，通过链式Builder风格构造过滤器链。</p><pre><code class=\"language-plain\">.route(route -&gt; route\n        .order(1)\n        .path(\"/gateway/template/**\")\n        .filters(f -&gt; f.stripPrefix(1)\n                // 修改Request参数\n                .removeRequestHeader(\"mylove\")\n                .addRequestHeader(\"myLove\", \"u\")\n                .removeRequestParameter(\"urLove\")\n                .addRequestParameter(\"urLove\", \"me\")\n                // response系列参数 不一一列举了\n                .removeResponseHeader(\"responseHeader\")\n        )\n        .uri(\"lb://coupon-template-serv\")\n</code></pre><p>当然了，Gateway的内置过滤器远不止上面这几个，还包括了redirect转发、retry重试、修改requestBody等等内置Filter。如果你对这些内容感兴趣，你可以根据IDE中自动弹出的代码提示来了解它们，再配几个到路由规则里把玩一下。</p><p>接下来，我们通过一个轻量级的网关层限流方案来进一步熟悉Filter的使用，这个限流方案所采用的底层技术是Redis + Lua。</p><p>Redis你一定很熟悉了，而Lua这个名词你可能是第一次听说，但提到愤怒的小鸟这个游戏，你一定不陌生，这个游戏就是用Lua语言写的。Lua是一类很小巧的脚本语言，它和Redis可以无缝集成，你可以在Lua脚本中执行Redis的CRUD操作。在这个限流方案中，Redis用来保存限流计数，而限流规则则是定义在Lua脚本中，默认使用令牌桶限流算法。如果你对Lua脚本的内容感兴趣，可以在IDE中全局搜索request_rate_limiter.lua这个文件。</p><p>前面我们已经添加了Redis的依赖和连接配置，现在你可以直接来定义限流参数了。我在Gateway模块里新建了一个RedisLimitationConfig类，专门用来定义限流参数。我们用到的主要参数有两个，一个是限流的维度，另一个是限流规则，你可以参考下面的代码。</p><pre><code class=\"language-plain\">@Configuration\npublic class RedisLimitationConfig {\n\n    // 限流的维度\n    @Bean\n    @Primary\n    public KeyResolver remoteHostLimitationKey() {\n        return exchange -&gt; Mono.just(\n                exchange.getRequest()\n                        .getRemoteAddress()\n                        .getAddress()\n                        .getHostAddress()\n        );\n    }\n    \n    //template服务限流规则\n    @Bean(\"tempalteRateLimiter\")\n    public RedisRateLimiter templateRateLimiter() {\n        return new RedisRateLimiter(10, 20);\n    }\n    \n    // customer服务限流规则\n    @Bean(\"customerRateLimiter\")\n    public RedisRateLimiter customerRateLimiter() {\n        return new RedisRateLimiter(20, 40);\n    }\n\n    @Bean(\"defaultRateLimiter\")\n    @Primary\n    public RedisRateLimiter defaultRateLimiter() {\n        return new RedisRateLimiter(50, 100);\n    }\n}\n</code></pre><p>我在remoteHostLimitationKey这个方法中定义了一个以Remote Host Address为维度的限流规则，当然了你也可以自由发挥，改用某个请求参数或者用户ID为限流规则的统计维度。其它的三个方法定义了基于令牌桶算法的限流速率，RedisRateLimiter类接收两个int类型的参数，第一个参数表示每秒发放的令牌数量，第二个参数表示令牌桶的容量。通常来说一个请求会消耗一张令牌，如果一段时间内令牌产生量大于令牌消耗量，那么积累的令牌数量最多不会超过令牌桶的容量。<br>\n定义好了限流参数之后，我们来看一下如何将限流规则应用到路由表中。</p><p>因为Gateway路由规则都定义在RoutesConfiguration类中，所以你需要把刚才我们定义的限流参数类注入到RoutesConfiguration类中。考虑到不同的路由表可能会使用不同的限流参数，所以你在定义多个限流参数的时候，可以使用@Bean(“customerRateLimiter”)这种方式来做区分，然后在Autowired注入对象的时候，使用@Qualifier(“customerRateLimiter”)指定想要加载的限流参数就可以了。</p><pre><code class=\"language-plain\">@Autowired\nprivate KeyResolver hostAddrKeyResolver;\n\n@Autowired\n@Qualifier(\"customerRateLimiter\")\nprivate RateLimiter customerRateLimiter;\n\n@Autowired\n@Qualifier(\"tempalteRateLimiter\")\nprivate RateLimiter templateRateLimiter;\n</code></pre><p>限流参数注入完成之后，接下来我们只需要添加一个内置的限流过滤器，分别指定限流的维度、限流速率就可以了，你可以参考下面这段rquestRateLimiter过滤器配置代码。除了限流参数之外，我还额外定义了一个Status Code，当服务请求被限流的时候，后端服务便会返回我指定的这个Status Code。</p><pre><code class=\"language-plain\">.route(route -&gt; route.path(\"/gateway/coupon-customer/**\")\n        .filters(f -&gt; f.stripPrefix(1)\n            .requestRateLimiter(limiter-&gt; {\n                limiter.setKeyResolver(hostAddrKeyResolver);\n                limiter.setRateLimiter(customerRateLimiter);\n                // 限流失败后返回的HTTP status code\n                limiter.setStatusCode(HttpStatus.BANDWIDTH_LIMIT_EXCEEDED);\n            }\n            )\n        )\n        .uri(\"lb://coupon-customer-serv\")\n</code></pre><p>到这里，我们就完整搭建了Gateway组件的路由和限流规则，最后你只需要写一个普通的启动类就可以在本地测试了。接下来我来带你回顾一下这一节的重点内容吧。</p><h2>总结</h2><p>今天我们为三个微服务组件设置了路由规则和限流规则。尽管Gateway组件本身提供了丰富的内置谓词和过滤器，但在实际项目中我们大多用不到它们，因为网关层的核心用途只是简单的路由转发，<strong>为了保证组件之间的职责隔离，我并不建议通过谓词和过滤器实现带有业务属性的逻辑</strong>。</p><p>那什么样的逻辑可以在网关层实现呢？比如一些通用的身份鉴权、登录检测和签名验签之类的服务，你可以将这类安全检测的逻辑前置到网关层来实现，这样可以对不合法请求做快速失败处理。</p><h2>思考题</h2><p>结合这节课的内容，请你尝试说一说，内置Filter是如何实现的，它继承了哪些通用类和接口。再请你在本地用类似的方式实现一个自定义的过滤器，并配置到路由表中。你可以使用这个过滤器完成一些简单的业务，比如打印所有发到网关服务的请求和响应参数。</p><p>好啦，这节课就结束啦。欢迎你把这节课分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们下节课再见！</p>","neighbors":{"left":{"article_title":"25 | 微服务网关：Gateway 中的路由和谓词有何应用？","id":485068},"right":{"article_title":"27 | 微服务网关：如何借助 Nacos 实现动态路由规则？","id":486260}},"comments":[{"had_liked":false,"id":333998,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1644659798,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"44594332758","product_id":100101301,"comment_content":"请教老师几个问题：<br>Q1：Gateway的限流与sentinel的限流是什么关系？<br>Gateway的限流是替代sentinel的限流吗？或者是相互配合？从“总结”部分来看，老师你是不赞成在Gateway做限流吗？<br>Q2：定义路由规则中的uri用的lb，gateway怎么知道是用的哪一个loadbalancer? 需要配置吗？在哪里配置的？<br>Q3：小鸟游戏用的lua，是主要开发语言，还是辅助开发语言？<br>小鸟游戏可以在安卓和iOS上运行，那么。Lua有自己的虚拟机吗？<br>Q4：pom文件中加入了actuator依赖，请问actuator可以用来实现对整个微服务系统的监控吗？<br>Q5：跨域设置校验是谁完成的？<br>在配置文件中设置跨域信息后，是谁负责完成跨域校验的？是SpringBoot完成的吗？还是上层业务代码完成的？我个人理解是SpringBoot完成的，上层业务代码没有看到有相应的处理代码。<br>Q6：expose-headers表示“被暴露出去的Header属性”，暴露给谁？暴露给浏览器吗？ 如果不设置，浏览器获取不到这些属性吗？是用什么方法不暴露的？对字段加密还是禁止访问？<br>Q7：request_rate_limiter.lua，搜不到？<br>搜索方法：Edit -&gt;Find-&gt;Find in Path,但搜不到，为什么？（下载的是最新代码，IDEA2019）","like_count":11},{"had_liked":false,"id":345242,"user_name":"勤奋的樂","can_delete":false,"product_type":"c1","uid":1798640,"ip_address":"","ucode":"BF341C5378097F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/71/f0/07c72ca6.jpg","comment_is_top":false,"comment_ctime":1652153973,"is_pvip":false,"replies":[{"id":"126170","content":"蟹腰，先上结论：配合使用。<br><br>gateway只能做“外部流量”-&gt;“微服务集群”这一道的限流，粒度比较粗狂。sentinel面相的限流维度是“资源”，也就是说它可以在微服务之间调用流转的环节做精细力度的限流，且有多种多样的流控效果。<br><br>总之来说网关限流（redis, gateway etc..）是一种相对廉价的粗粒度限流手段，应用sentinel的成本是高于网关限流的，但同时可以获取更灵活+多维度的限流效果<br><br>request_rate_limiter是gateway开源代码里的一个文件，同学要到spring cloud的源码库里找哦","user_name":"作者回复","comment_id":345242,"uid":"2819998","ip_address":"","utype":1,"ctime":1652584903,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10242088565","product_id":100101301,"comment_content":"向老师请教一个问题，gateway做限流和sentinel限流两者的关系，是配合使用还是二选一？<br>我的理解是：gateway服务也要像nacos服务中心组册，本质上它也是微服务体系中的一个服务提供者，应该用sentinel统领整个微服务体系，做全局的流量控制，请求经过sentinel粗粒度流量整形后，在gateway中再针对具体的服务规则，进行细粒度的资源调配和请求转发。<br>不知道我的理解是不是对的，望指正<br>PS: gitee上最新的代码中找不到request_rate_limiter.lua文件","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572055,"discussion_content":"蟹腰，先上结论：配合使用。\n\ngateway只能做“外部流量”-&gt;“微服务集群”这一道的限流，粒度比较粗狂。sentinel面相的限流维度是“资源”，也就是说它可以在微服务之间调用流转的环节做精细力度的限流，且有多种多样的流控效果。\n\n总之来说网关限流（redis, gateway etc..）是一种相对廉价的粗粒度限流手段，应用sentinel的成本是高于网关限流的，但同时可以获取更灵活+多维度的限流效果\n\nrequest_rate_limiter是gateway开源代码里的一个文件，同学要到spring cloud的源码库里找哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652584903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333919,"user_name":"inrtyx","can_delete":false,"product_type":"c1","uid":1246178,"ip_address":"","ucode":"81CD18FF34ABAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","comment_is_top":false,"comment_ctime":1644584227,"is_pvip":true,"replies":[{"id":"122051","content":"网关鉴权可以通过oauth实现（spring提供了spring-cloud-starter-oauth2），根据oauth 2.0的规范有很多种不同的对接方式。我推荐一个网站可以进一步了解oauth规范 https:&#47;&#47;oauth.net&#47;2&#47;","user_name":"作者回复","comment_id":333919,"uid":"2819998","ip_address":"","utype":1,"ctime":1644749976,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10234518819","product_id":100101301,"comment_content":"老师，能否讲讲网关如何鉴权？即鉴权时序图","like_count":2,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550826,"discussion_content":"网关鉴权可以通过oauth实现（spring提供了spring-cloud-starter-oauth2），根据oauth 2.0的规范有很多种不同的对接方式。我推荐一个网站可以进一步了解oauth规范 https://oauth.net/2/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644749976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342484,"user_name":"刚强","can_delete":false,"product_type":"c1","uid":1011730,"ip_address":"","ucode":"51718AB9640EB6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/70/12/f96d267e.jpg","comment_is_top":false,"comment_ctime":1650287202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650287202","product_id":100101301,"comment_content":"postman测试gateway，一直403。调查DefaultCorsProcessor.processRequest方法后发现，CorsUtils.isCorsRequest(request)=true。跨域了，origin=chrome-extension:&#47;&#47;XXXX。把这个加到yml里面就可以了。","like_count":1},{"had_liked":false,"id":340374,"user_name":"Geek_8d3106","can_delete":false,"product_type":"c1","uid":2959758,"ip_address":"","ucode":"0B2F97ED03963C","user_header":"","comment_is_top":false,"comment_ctime":1648783294,"is_pvip":false,"replies":[{"id":"125175","content":"忘了阿里云这道坎儿，这个简单，在gateway源码里有一个lua限流脚本，只要本地根据阿里云的要求重写这个脚本，然后指定gateway在auto-config阶段加载你重新定义的这个脚本就行了","user_name":"作者回复","comment_id":340374,"uid":"2819998","ip_address":"","utype":1,"ctime":1650416379,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1648783294","product_id":100101301,"comment_content":"使用阿里云Redis集群，会报以下错误<br>Caused by: io.lettuce.core.RedisCommandExecutionException: ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array, and KEYS should not be in expression<br>这是因为阿里云的Redis集群对Lua脚本调用的时候做了限制：所有key都应该由KEYS数组来传递，redis.call&#47;pcall中调用的redis命令，key的位置必须是KEYS array（不能使用Lua变量替换KEYS），否则直接返回错误信息。<br>不知道是否有好的解决方案？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565167,"discussion_content":"忘了阿里云这道坎儿，这个简单，在gateway源码里有一个lua限流脚本，只要本地根据阿里云的要求重写这个脚本，然后指定gateway在auto-config阶段加载你重新定义的这个脚本就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650416379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333829,"user_name":"黄叶","can_delete":false,"product_type":"c1","uid":2332411,"ip_address":"","ucode":"8D8C566F7772A6","user_header":"https://static001.geekbang.org/account/avatar/00/23/96/fb/af39abb1.jpg","comment_is_top":false,"comment_ctime":1644551871,"is_pvip":true,"replies":[{"id":"122053","content":"我在想会不会是后台跨域的method列表里只写了Options，没有加上其他方法呢？同学可以把浏览器里的request header（包括Options和后面那个真实请求）发出来我们看下","user_name":"作者回复","comment_id":333829,"uid":"2819998","ip_address":"","utype":1,"ctime":1644750705,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"1644551871","product_id":100101301,"comment_content":"老师请问下，今天试着写了gateway+vue整合。<br>vue请求发送给后端，预检通过了但是当真正发送跨域请求时，提示：CORS错误，也配置了gateway跨域 但是就是不成功","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550829,"discussion_content":"我在想会不会是后台跨域的method列表里只写了Options，没有加上其他方法呢？同学可以把浏览器里的request header（包括Options和后面那个真实请求）发出来我们看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644750705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2332411,"avatar":"https://static001.geekbang.org/account/avatar/00/23/96/fb/af39abb1.jpg","nickname":"黄叶","note":"","ucode":"8D8C566F7772A6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550834,"discussion_content":"解决了，我是gateway+oauth2++security，要通过配置addFilterBefore的方式来实现跨域，我猜是因为security是由过滤器组成的，导致配置的跨域过滤器没有生效，这里可以打个断点看跨域的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644753028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2332411,"avatar":"https://static001.geekbang.org/account/avatar/00/23/96/fb/af39abb1.jpg","nickname":"黄叶","note":"","ucode":"8D8C566F7772A6","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":550891,"discussion_content":"是直接使用spring security 么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644799199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550834,"ip_address":""},"score":550891,"extra":""}]}]}]}