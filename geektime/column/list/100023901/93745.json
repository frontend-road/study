{"id":93745,"title":"30 | 线程本地存储模式：没有共享，就没有伤害","content":"<p>民国年间某山东省主席参加某大学校庆演讲，在篮球场看到十来个人穿着裤衩抢一个球，观之实在不雅，于是怒斥学校的总务处长贪污，并且发话：“多买几个球，一人发一个，省得你争我抢！”小时候听到这个段子只是觉得好玩，今天再来看，却别有一番滋味。为什么呢？因为其间蕴藏着解决并发问题的一个重要方法：<strong>避免共享</strong>。</p><p>我们曾经一遍一遍又一遍地重复，多个线程同时读写同一共享变量存在并发问题。前面两篇文章我们突破的是写，没有写操作自然没有并发问题了。其实还可以突破共享变量，没有共享变量也不会有并发问题，正所谓是<strong>没有共享，就没有伤害</strong>。</p><p>那如何避免共享呢？思路其实很简单，多个人争一个球总容易出矛盾，那就每个人发一个球。对应到并发编程领域，就是每个线程都拥有自己的变量，彼此之间不共享，也就没有并发问题了。</p><p>我们在<a href=\"https://time.geekbang.org/column/article/86695\">《11 | Java线程（下）：为什么局部变量是线程安全的？》</a>中提到过<strong>线程封闭</strong>，其本质上就是避免共享。你已经知道通过局部变量可以做到避免共享，那还有没有其他方法可以做到呢？有的，<strong>Java语言提供的线程本地存储（ThreadLocal）就能够做到</strong>。下面我们先看看ThreadLocal到底该如何使用。</p><h2>ThreadLocal的使用方法</h2><!-- [[[read_end]]] --><p>下面这个静态类ThreadId会为每个线程分配一个唯一的线程Id，如果<strong>一个线程</strong>前后两次调用ThreadId的get()方法，两次get()方法的返回值是相同的。但如果是<strong>两个线程</strong>分别调用ThreadId的get()方法，那么两个线程看到的get()方法的返回值是不同的。若你是初次接触ThreadLocal，可能会觉得奇怪，为什么相同线程调用get()方法结果就相同，而不同线程调用get()方法结果就不同呢？</p><pre><code>static class ThreadId {\n  static final AtomicLong \n  nextId=new AtomicLong(0);\n  //定义ThreadLocal变量\n  static final ThreadLocal&lt;Long&gt; \n  tl=ThreadLocal.withInitial(\n    ()-&gt;nextId.getAndIncrement());\n  //此方法会为每个线程分配一个唯一的Id\n  static long get(){\n    return tl.get();\n  }\n}\n</code></pre><p>能有这个奇怪的结果，都是ThreadLocal的杰作，不过在详细解释ThreadLocal的工作原理之前，我们再看一个实际工作中可能遇到的例子来加深一下对ThreadLocal的理解。你可能知道SimpleDateFormat不是线程安全的，那如果需要在并发场景下使用它，你该怎么办呢？</p><p>其实有一个办法就是用ThreadLocal来解决，下面的示例代码就是ThreadLocal解决方案的具体实现，这段代码与前面ThreadId的代码高度相似，同样地，不同线程调用SafeDateFormat的get()方法将返回不同的SimpleDateFormat对象实例，由于不同线程并不共享SimpleDateFormat，所以就像局部变量一样，是线程安全的。</p><pre><code>static class SafeDateFormat {\n  //定义ThreadLocal变量\n  static final ThreadLocal&lt;DateFormat&gt;\n  tl=ThreadLocal.withInitial(\n    ()-&gt; new SimpleDateFormat(\n      &quot;yyyy-MM-dd HH:mm:ss&quot;));\n      \n  static DateFormat get(){\n    return tl.get();\n  }\n}\n//不同线程执行下面代码\n//返回的df是不同的\nDateFormat df =\n  SafeDateFormat.get()；\n</code></pre><p>通过上面两个例子，相信你对ThreadLocal的用法以及应用场景都了解了，下面我们就来详细解释ThreadLocal的工作原理。</p><h2>ThreadLocal的工作原理</h2><p>在解释ThreadLocal的工作原理之前， 你先自己想想：如果让你来实现ThreadLocal的功能，你会怎么设计呢？ThreadLocal的目标是让不同的线程有不同的变量V，那最直接的方法就是创建一个Map，它的Key是线程，Value是每个线程拥有的变量V，ThreadLocal内部持有这样的一个Map就可以了。你可以参考下面的示意图和示例代码来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/34/6a93910f748ebc5b984ae7ac67283034.png?wh=1142*484\" alt=\"\"></p><center><span class=\"reference\">ThreadLocal持有Map的示意图</span></center><pre><code>class MyThreadLocal&lt;T&gt; {\n  Map&lt;Thread, T&gt; locals = \n    new ConcurrentHashMap&lt;&gt;();\n  //获取线程变量  \n  T get() {\n    return locals.get(\n      Thread.currentThread());\n  }\n  //设置线程变量\n  void set(T t) {\n    locals.put(\n      Thread.currentThread(), t);\n  }\n}\n</code></pre><p>那Java的ThreadLocal是这么实现的吗？这一次我们的设计思路和Java的实现差异很大。Java的实现里面也有一个Map，叫做ThreadLocalMap，不过持有ThreadLocalMap的不是ThreadLocal，而是Thread。Thread这个类内部有一个私有属性threadLocals，其类型就是ThreadLocalMap，ThreadLocalMap的Key是ThreadLocal。你可以结合下面的示意图和精简之后的Java实现代码来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/02/3cb0a8f15104848dec63eab269bac302.png?wh=1142*480\" alt=\"\"></p><center><span class=\"reference\">Thread持有ThreadLocalMap的示意图</span></center><pre><code>class Thread {\n  //内部持有ThreadLocalMap\n  ThreadLocal.ThreadLocalMap \n    threadLocals;\n}\nclass ThreadLocal&lt;T&gt;{\n  public T get() {\n    //首先获取线程持有的\n    //ThreadLocalMap\n    ThreadLocalMap map =\n      Thread.currentThread()\n        .threadLocals;\n    //在ThreadLocalMap中\n    //查找变量\n    Entry e = \n      map.getEntry(this);\n    return e.value;  \n  }\n  static class ThreadLocalMap{\n    //内部是数组而不是Map\n    Entry[] table;\n    //根据ThreadLocal查找Entry\n    Entry getEntry(ThreadLocal key){\n      //省略查找逻辑\n    }\n    //Entry定义\n    static class Entry extends\n    WeakReference&lt;ThreadLocal&gt;{\n      Object value;\n    }\n  }\n}\n</code></pre><p>初看上去，我们的设计方案和Java的实现仅仅是Map的持有方不同而已，我们的设计里面Map属于ThreadLocal，而Java的实现里面ThreadLocalMap则是属于Thread。这两种方式哪种更合理呢？很显然Java的实现更合理一些。在Java的实现方案里面，ThreadLocal仅仅是一个代理工具类，内部并不持有任何与线程相关的数据，所有和线程相关的数据都存储在Thread里面，这样的设计容易理解。而从数据的亲缘性上来讲，ThreadLocalMap属于Thread也更加合理。</p><p>当然还有一个更加深层次的原因，那就是<strong>不容易产生内存泄露</strong>。在我们的设计方案中，ThreadLocal持有的Map会持有Thread对象的引用，这就意味着，只要ThreadLocal对象存在，那么Map中的Thread对象就永远不会被回收。ThreadLocal的生命周期往往都比线程要长，所以这种设计方案很容易导致内存泄露。而Java的实现中Thread持有ThreadLocalMap，而且ThreadLocalMap里对ThreadLocal的引用还是弱引用（WeakReference），所以只要Thread对象可以被回收，那么ThreadLocalMap就能被回收。Java的这种实现方案虽然看上去复杂一些，但是更加安全。</p><p>Java的ThreadLocal实现应该称得上深思熟虑了，不过即便如此深思熟虑，还是不能百分百地让程序员避免内存泄露，例如在线程池中使用ThreadLocal，如果不谨慎就可能导致内存泄露。</p><h2>ThreadLocal与内存泄露</h2><p>在线程池中使用ThreadLocal为什么可能导致内存泄露呢？原因就出在线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着Thread持有的ThreadLocalMap一直都不会被回收，再加上ThreadLocalMap中的Entry对ThreadLocal是弱引用（WeakReference），所以只要ThreadLocal结束了自己的生命周期是可以被回收掉的。但是Entry中的Value却是被Entry强引用的，所以即便Value的生命周期结束了，Value也是无法被回收的，从而导致内存泄露。</p><p>那在线程池中，我们该如何正确使用ThreadLocal呢？其实很简单，既然JVM不能做到自动释放对Value的强引用，那我们手动释放就可以了。如何能做到手动释放呢？估计你马上想到<strong>try{}finally{}方案</strong>了，这个简直就是<strong>手动释放资源的利器</strong>。示例的代码如下，你可以参考学习。</p><pre><code>ExecutorService es;\nThreadLocal tl;\nes.execute(()-&gt;{\n  //ThreadLocal增加变量\n  tl.set(obj);\n  try {\n    // 省略业务逻辑代码\n  }finally {\n    //手动清理ThreadLocal \n    tl.remove();\n  }\n});\n</code></pre><h2>InheritableThreadLocal与继承性</h2><p>通过ThreadLocal创建的线程变量，其子线程是无法继承的。也就是说你在线程中通过ThreadLocal创建了线程变量V，而后该线程创建了子线程，你在子线程中是无法通过ThreadLocal来访问父线程的线程变量V的。</p><p>如果你需要子线程继承父线程的线程变量，那该怎么办呢？其实很简单，Java提供了InheritableThreadLocal来支持这种特性，InheritableThreadLocal是ThreadLocal子类，所以用法和ThreadLocal相同，这里就不多介绍了。</p><p>不过，我完全不建议你在线程池中使用InheritableThreadLocal，不仅仅是因为它具有ThreadLocal相同的缺点——可能导致内存泄露，更重要的原因是：线程池中线程的创建是动态的，很容易导致继承关系错乱，如果你的业务逻辑依赖InheritableThreadLocal，那么很可能导致业务逻辑计算错误，而这个错误往往比内存泄露更要命。</p><h2>总结</h2><p>线程本地存储模式本质上是一种避免共享的方案，由于没有共享，所以自然也就没有并发问题。如果你需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。</p><p>线程本地存储模式是解决并发问题的常用方案，所以Java SDK也提供了相应的实现：ThreadLocal。通过上面我们的分析，你应该能体会到Java SDK的实现已经是深思熟虑了，不过即便如此，仍不能尽善尽美，例如在线程池中使用ThreadLocal仍可能导致内存泄漏，所以使用ThreadLocal还是需要你打起精神，足够谨慎。</p><h2>课后思考</h2><p>实际工作中，有很多平台型的技术方案都是采用ThreadLocal来传递一些上下文信息，例如Spring使用ThreadLocal来传递事务信息。我们曾经说过，异步编程已经很成熟了，那你觉得在异步场景中，是否可以使用Spring的事务管理器呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":92211,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1557201651,"is_pvip":false,"replies":[{"id":"34454","content":"threadlocal=线程数，局部变量=调用量，差距太大了","user_name":"作者回复","comment_id":92211,"uid":"1269969","ip_address":"","utype":1,"ctime":1558362215,"user_name_real":"王宝令"}],"discussion_count":11,"race_medal":0,"score":"525543211763","product_id":100023901,"comment_content":"有个疑问请教老师，避免共享变量的两种解决方案，在高并发情况下，使用局部变量会频繁创建对象，使用threadlocal也是针对线程创建新变量，都是针对线程维度，threadlocal并未体现出什么优势，为什么还要用threadlocal","like_count":123,"discussions":[{"author":{"id":1062797,"avatar":"","nickname":"Cv","note":"","ucode":"C77CE172B5AA28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115829,"discussion_content":"但是添加了remove后不是一样的吗?","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1578038540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298346,"discussion_content":"局部变量是针对线程执行的方法，thread是针对线程。我是这么理解的，如果是线程池内线程，一个线程可能会调用多次这个方法。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597276084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768152,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fa/d8/7c2b6c0b.jpg","nickname":"闲人","note":"","ucode":"9A8F33260A44E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97890,"discussion_content":"线程可以复用，所以线程变量也被复用了？前提是线程变量没有被remove吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577115938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449178,"discussion_content":"threadlocal=线程数，局部变量=调用量，差距太大了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1558362215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391374,"discussion_content":"这个b就是自己看了几本中文翻译的书然后出来骗人了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630421575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1621553,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/proaRF0lED9TdZcS5saibFrOSfL9nfMQkbKfoAqtbONWyBplZjPMaSL3icGOxc60SPHFAhtC0yibDQ1CBYpJZXgRg/132","nickname":"Geek_be63c6","note":"","ucode":"93447D86C450D6","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589128,"discussion_content":"我真的yue了，你这种东西，人家有义务回答问题么，而且老师明明说的是正确的，你去看看别的课程，不理问题的人多了去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664437273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":391374,"ip_address":"广东"},"score":589128,"extra":""}]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391373,"discussion_content":"回答的问题驴唇不对马嘴","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630421539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1661365,"avatar":"https://static001.geekbang.org/account/avatar/00/19/59/b5/26d3c637.jpg","nickname":"Yc","note":"","ucode":"407776D104D6F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544027,"discussion_content":"哪里不对了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641381972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":391373,"ip_address":""},"score":544027,"extra":""}]},{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588221,"discussion_content":"ThreadLocal在线程中相当于全局变量，比如一个请求打进来到结束都是tomcat的一个线程来执行的，只需要new一次, remove一次，但是方法是调用一次new一次。ThreadLocal比较适合存context类的对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663596661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138722,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/22/92284df2.jpg","nickname":"其实我很屌","note":"","ucode":"2B75EAAD748A60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393931,"discussion_content":"如果你的对象是单例的，不用threadlocal就有问题，好像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631666589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40980,"discussion_content":"好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572318001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92239,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1557209999,"is_pvip":false,"replies":[{"id":"34436","content":"👍","user_name":"作者回复","comment_id":92239,"uid":"1269969","ip_address":"","utype":1,"ctime":1558358425,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"400989168527","product_id":100023901,"comment_content":"不可以，因为ThreadLocal内的变量是线程级别的，而异步编程意味着线程不同，不同线程的变量不可以共享","like_count":94,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449188,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558358425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96779,"user_name":"承香墨影","can_delete":false,"product_type":"c1","uid":1023750,"ip_address":"","ucode":"4D6A4D6E1ED29F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","comment_is_top":false,"comment_ctime":1558505474,"is_pvip":false,"replies":[{"id":"34653","content":"这种用法一般是为了在一个线程里传递全局参数，也叫上下文信息，局部变量不能跨方法，这个用法不是用来解决局部变量重复创建的","user_name":"作者回复","comment_id":96779,"uid":"1269969","ip_address":"","utype":1,"ctime":1558535597,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"254961575938","product_id":100023901,"comment_content":"老师您好，有个问题想请教。<br>在线程池中使用 ThreadLocal，您给的解决方案是，使用后手动释放。<br>那这样和使用线程的局部变量有什么区别？每次线程执行的时候都去创建对象并存储在 ThreadLocal 中，用完就释放掉了，下次执行依然需要重新创建，并存入 ThreadLocalMap 中，这样并没有解决局部变量频繁创建对象的问题。","like_count":60,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451013,"discussion_content":"这种用法一般是为了在一个线程里传递全局参数，也叫上下文信息，局部变量不能跨方法，这个用法不是用来解决局部变量重复创建的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1558535597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92371,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1557240665,"is_pvip":false,"replies":[{"id":"33512","content":"感谢回复！！！！","user_name":"作者回复","comment_id":92371,"uid":"1269969","ip_address":"","utype":1,"ctime":1557645868,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"203420703577","product_id":100023901,"comment_content":"上面有些同学说多线程是simpledateformat会打印出一样名称的对象，我刚刚也试了下，的确可以复现，但其实是simpledateformat对象的toString()方法搞得鬼，该类是继承object类的tostring方法，如下有个hashcode()方法，但该类重写了hashcode方法，在追溯到hashcode方法，pattern.hashcode(),pattern就是我们的yyyy-MM-dd,这个是一直保持不变的，现在终于真相大白了","like_count":47,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449231,"discussion_content":"感谢回复！！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557645868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256301,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2b/6d/7a6b5df4.jpg","nickname":"坏蛋","note":"","ucode":"9C99151F30DF0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408843,"discussion_content":"    /**\n     * The pattern string of this formatter.  This is always a non-localized\n     * pattern.  May not be null.  See class documentation for details.\n     * @serial\n     */\n    private String pattern;\n\n    public SimpleDateFormat(String pattern)\n    {\n        this(pattern, Locale.getDefault(Locale.Category.FORMAT));\n    }\n    \n     public SimpleDateFormat(String pattern, Locale locale)\n    {\n        if (pattern == null || locale == null) {\n            throw new NullPointerException();\n        }\n\n        initializeCalendar(locale);\n        this.pattern = pattern;\n        this.formatData = DateFormatSymbols.getInstanceRef(locale);\n        this.locale = locale;\n        initialize(locale);\n    }\n    \n    @Override\n    public int hashCode()\n    {\n        return pattern.hashCode();\n        // just enough fields for a reasonable distribution\n    }\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635332071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92089,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1557188014,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"74571632046","product_id":100023901,"comment_content":"java实现异步的方式基本上就是多线程了，而threadlocal是线程封闭的，不能在线程之间共享，就谈不上全局的事务管理了。","like_count":17},{"had_liked":false,"id":97755,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1558765695,"is_pvip":false,"replies":[{"id":"34940","content":"有心👍","user_name":"作者回复","comment_id":97755,"uid":"1269969","ip_address":"","utype":1,"ctime":1558779306,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"61688307839","product_id":100023901,"comment_content":"自己写了下对ThreadLocal的源码分析https:&#47;&#47;juejin.im&#47;post&#47;5ce7e0596fb9a07ee742ba79，感兴趣的可以看下哦，老师也帮忙看下哦 ","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451401,"discussion_content":"有心👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558779306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2282481,"avatar":"","nickname":"Geek_157395","note":"","ucode":"D00CBA7A104FE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369190,"discussion_content":"写这个源码分析感觉有收获吗？感觉这块儿只需要知道讲的这些知识就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618970668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132642,"user_name":"So","can_delete":false,"product_type":"c1","uid":1485274,"ip_address":"","ucode":"60095793800451","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/fLsz4MWRfXUNutWJQLtCMYsEibczUJbGBWIcean2vJZYll5nGRkmHgV3BbXVicGt6qUmDEcZM0VlOdj8O06UhjvQ/132","comment_is_top":false,"comment_ctime":1568183881,"is_pvip":false,"replies":[{"id":"50903","content":"是的","user_name":"作者回复","comment_id":132642,"uid":"1269969","ip_address":"","utype":1,"ctime":1568268342,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"44517856841","product_id":100023901,"comment_content":"一个ThreadLocal只能保存一个变量，那如果有多个变量要保存，是不是要建多个ThreadLocal？","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467050,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568268342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392431,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","nickname":"a(๑≖ิټ≖ิ)✌","note":"","ucode":"AEF9B5CA1605DF","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290191,"discussion_content":"存个map，map存多个值也可以吧","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1594371653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372552,"discussion_content":"存多个k","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620375359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102821,"user_name":"GEEKBANG_6638780","can_delete":false,"product_type":"c1","uid":1268264,"ip_address":"","ucode":"952194E56FD8C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","comment_is_top":false,"comment_ctime":1560308975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31625080047","product_id":100023901,"comment_content":"@vic<br>想问一下如果gc发生在对threadLocal的 set和get操作之间，get的时候value对应的key已经被gc了，不是拿不到我之前放进threadLocal的对象了吗？这样对业务不会有问题吗？<br>---------------------------------<br>是的，一般建议threadlocal采用static修饰，而且遵循try finally编程","like_count":7},{"had_liked":false,"id":92183,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1557197110,"is_pvip":false,"replies":[{"id":"34571","content":"有同学已经找到原因了，是tostring的锅","user_name":"作者回复","comment_id":92183,"uid":"1269969","ip_address":"","utype":1,"ctime":1558449085,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"31621968182","product_id":100023901,"comment_content":"请问一下老师，我刚刚对simpledateformat加threadlocal，但是不同线程得到的simpledateformat对象是一样的，代码如下：<br>public class Tool {<br>    public static void main(String[] args) throws Exception{<br>        System.out.println(SafeDateFormat.get());<br>        System.out.println(Thread.currentThread().getName());<br>        new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                System.out.println(Thread.currentThread().getName());<br>                System.out.println(SafeDateFormat.get());<br>            }<br>        }).start();<br><br>    }<br><br>    static class SafeDateFormat{<br>        static final ThreadLocal&lt;SimpleDateFormat&gt; sdf =<br>                ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));<br>        static SimpleDateFormat get(){<br>            return sdf.get();<br>        }<br>    }<br>}<br>请问存在什么问题","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449172,"discussion_content":"有同学已经找到原因了，是tostring的锅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558449085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92417,"user_name":"天天向善","can_delete":false,"product_type":"c1","uid":1108250,"ip_address":"","ucode":"6AE57FB2B15043","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/1a/6ba207a3.jpg","comment_is_top":false,"comment_ctime":1557270844,"is_pvip":true,"replies":[{"id":"33678","content":"很有这种可能，所以不能用它存状态数据","user_name":"作者回复","comment_id":92417,"uid":"1269969","ip_address":"","utype":1,"ctime":1557758715,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"23032107324","product_id":100023901,"comment_content":"有个疑问请教，线程多路复用，使用thread local有什么注意的，会不会不同请求获取内容相同，造成后续业务错误","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449251,"discussion_content":"很有这种可能，所以不能用它存状态数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557758715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121557,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/15/8ad4e24a.jpg","nickname":"yaomon","note":"","ucode":"4742547EB92BCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159502,"discussion_content":"趟过这个坑，用完手动清理😫","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580700437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93642,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1557543076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18737412260","product_id":100023901,"comment_content":"getEntry(): 0x61c88647，解决hash碰撞的一个神奇的数","like_count":4},{"had_liked":false,"id":128032,"user_name":"xinglichea","can_delete":false,"product_type":"c1","uid":1176447,"ip_address":"","ucode":"986DA07BF3CA89","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/7f/2dd9409b.jpg","comment_is_top":false,"comment_ctime":1566823155,"is_pvip":false,"replies":[{"id":"52711","content":"工程上建议不要做假设，万一出了问题不好查","user_name":"作者回复","comment_id":128032,"uid":"1269969","ip_address":"","utype":1,"ctime":1569668221,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14451725043","product_id":100023901,"comment_content":"老师，<br>文中提到解决内存泄露的方法是显示调用remove()方法，但貌似ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value，即：在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。<br><br>那么是不是可以说明，如果线程在后续操作中会继续调用set()、get()的话，就不需要显示调用remove()了。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464762,"discussion_content":"工程上建议不要做假设，万一出了问题不好查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569668221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118316,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1564319703,"is_pvip":false,"replies":[{"id":"43340","content":"👍","user_name":"作者回复","comment_id":118316,"uid":"1269969","ip_address":"","utype":1,"ctime":1564358574,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14449221591","product_id":100023901,"comment_content":"---启发---<br>老师对ThreadLocal的思考上，让我对理解一个类的设计问题上有所启发。对一个类的实例、方法等的设计，除了功能上的考虑外，也要考虑安全性、性能问题，也可以站在抽象的角度思考其逻辑。<br>","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460355,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564358574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101961,"user_name":"盐多必失","can_delete":false,"product_type":"c1","uid":1218415,"ip_address":"","ucode":"B9DBB12E0D1D74","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/6f/4cd459f2.jpg","comment_is_top":false,"comment_ctime":1560075367,"is_pvip":false,"replies":[{"id":"36776","content":"大智若愚，谁说的清呢，一起鄙视那些不加密的吧😄","user_name":"作者回复","comment_id":101961,"uid":"1269969","ip_address":"","utype":1,"ctime":1560127261,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"14444977255","product_id":100023901,"comment_content":"某山东省主席…… 宝令小哥哥这加密算法做得太好了，^_^","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453189,"discussion_content":"大智若愚，谁说的清呢，一起鄙视那些不加密的吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560127261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95142,"user_name":"ddup","can_delete":false,"product_type":"c1","uid":1101760,"ip_address":"","ucode":"D8EC573DA46A10","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c0/8e4c1135.jpg","comment_is_top":false,"comment_ctime":1557973768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14442875656","product_id":100023901,"comment_content":"System.identityHashCode(dateFormat)); 这个来打印内存地址。","like_count":3},{"had_liked":false,"id":92107,"user_name":"lik","can_delete":false,"product_type":"c1","uid":1103027,"ip_address":"","ucode":"9565C94A9B773A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/b3/96847546.jpg","comment_is_top":false,"comment_ctime":1557189249,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10147123841","product_id":100023901,"comment_content":"想问一下如果gc发生在对threadLocal的 set和get操作之间，get的时候value对应的key已经被gc了，不是拿不到我之前放进threadLocal的对象了吗？这样对业务不会有问题吗？","like_count":2,"discussions":[{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319250,"discussion_content":"你创建的threadLocal对象如果是局部变量，set后，方法没执行完，这个threadLocal被栈引用，不会被回收。如果你创建的是对象的属性，那么对象回收前，也不会回收该threadLocal对象。所以只要你这个对象还在用，GC就不会回收它。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603973167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92074,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557186206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10147120798","product_id":100023901,"comment_content":"打卡！我认为不行吧，文末提到ThreadLocal创建的线程变量子线程无法继承了。","like_count":2},{"had_liked":false,"id":326810,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1639707031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5934674327","product_id":100023901,"comment_content":"如果需要在线程池中实现子线程继承父线程的线程变量，该如何去做","like_count":1},{"had_liked":false,"id":264591,"user_name":"我真不是地球","can_delete":false,"product_type":"c1","uid":1451048,"ip_address":"","ucode":"873F7222DE35BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/24/28/9b5b1396.jpg","comment_is_top":false,"comment_ctime":1606535337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5901502633","product_id":100023901,"comment_content":"void set(T t) {<br>    locals.put(<br>      Thread.currentThread(), t);<br>  }<br><br>老师，key不会被顶掉么？","like_count":1},{"had_liked":false,"id":245368,"user_name":"蓝山","can_delete":false,"product_type":"c1","uid":1066264,"ip_address":"","ucode":"FBF673D51FF644","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/18/3d05adb4.jpg","comment_is_top":false,"comment_ctime":1598926030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893893326","product_id":100023901,"comment_content":"不能。当前线程和被调用异步线程分属不同线程。但确可做到。","like_count":1},{"had_liked":false,"id":235805,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1595207752,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5890175048","product_id":100023901,"comment_content":"对于中间有线程池的操作，如果需要上下文传递的情况，可以使用阿里开源的TransmitableThreadLocal","like_count":1},{"had_liked":false,"id":95882,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1460415,"ip_address":"","ucode":"04B803AED7C22F","user_header":"https://static001.geekbang.org/account/avatar/00/16/48/bf/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1558240745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853208041","product_id":100023901,"comment_content":"异步编程应该慎用ThreadLocal。因为不再是同一个线程执行，所以获取不到原本想获取的数据","like_count":1},{"had_liked":false,"id":92399,"user_name":"狂风骤雨","can_delete":false,"product_type":"c1","uid":1305749,"ip_address":"","ucode":"5CE9B9438FAB3F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZSibeTatZ2ImL5Xu3QqdTWQs5nyQAxDlsm3m0KicP3TN6icJqYricvhjOFfTB2B3oLInU45CC9LtqMA/132","comment_is_top":false,"comment_ctime":1557247180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852214476","product_id":100023901,"comment_content":"线程的本地存储是加了native关键字来修饰的么","like_count":1},{"had_liked":false,"id":92378,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1557241349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852208645","product_id":100023901,"comment_content":"扩展:可以打断点进ThreadLocal的getmap方法里面可以直接看到slf对象是不同的","like_count":1},{"had_liked":false,"id":92076,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557186444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852153740","product_id":100023901,"comment_content":"这节的ThreadLocal，我记得15年刚开始工作的时候，工作中有一个需要动态切换数据源的需求，Spring+Hibernate框架，当时通过百度查到用ThreadLocal，使用AOP在进入service层之前来切换数据源。正好跟这里文章说的Spring使用ThreadLocal来传递事物信息意思一样吧。","like_count":1},{"had_liked":false,"id":329938,"user_name":"我 我 我","can_delete":false,"product_type":"c1","uid":1180597,"ip_address":"","ucode":"DB9BC7110A7B3F","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/b5/cf6a5f97.jpg","comment_is_top":false,"comment_ctime":1641658181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641658181","product_id":100023901,"comment_content":"spring的事务管理器只能在一个线程内使用， 可以在子线程里是可以做一个完整事务（从开启事务到提交事务）提交吧。","like_count":0},{"had_liked":false,"id":308000,"user_name":"苏彧","can_delete":false,"product_type":"c1","uid":1622448,"ip_address":"","ucode":"C016B28DF7449C","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/b0/b52d9ade.jpg","comment_is_top":false,"comment_ctime":1629353419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629353419","product_id":100023901,"comment_content":"ThreadLocal可用来存储用户信息","like_count":0},{"had_liked":false,"id":285129,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1616636111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616636111","product_id":100023901,"comment_content":"写一个统一管理线程池对象，利用try- with- resource统一管理Threadlocal的回收","like_count":0},{"had_liked":false,"id":283625,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1615860089,"is_pvip":false,"replies":[{"id":"103033","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616043889,"ip_address":"","comment_id":283625,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615860089","product_id":100023901,"comment_content":"异步意味着多线程，不能用ThreadLocal继而无法使用事务","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517096,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616043889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278534,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1613026607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613026607","product_id":100023901,"comment_content":"二刷  有个问题问下 如果只是想在线程中传递变量,为什么不直接用一个Thread的成员变量呢?","like_count":0},{"had_liked":false,"id":268309,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1608130954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608130954","product_id":100023901,"comment_content":"安全的SimpleDateFormat代码，乍一看打印结果竟然一样。后面用==判断，才发现并不时同一个对象。相同的打印结果其实是SimpleDateFormat.pattern（即“yyyy-MM-dd”）一样导致的<br><br>&#47;**<br> * 线程安全的SimpleDateFormat<br> *&#47;<br>public class SafeSimpleDateFormat {<br><br>    private static ThreadLocal&lt;SimpleDateFormat&gt; tl =<br>            ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));<br><br>    public static SimpleDateFormat get(){<br>        return tl.get();<br>    }<br><br>    public static void main(String[] args){<br>        print(get());<br>        print(get());<br>        int size = 2;<br>        for(int i = 0; i &lt; size; i++){<br>            new Thread(()-&gt;{<br>                print(get());<br>                print(get());<br>            }, &quot;线程&quot; + i).start();<br>        }<br>    }<br><br>    static void print(Object obj){<br>        System.out.println(Thread.currentThread().getName()  + &quot;__&quot; + obj);<br>    }<br>}<br><br>打印结果：<br>main__java.text.SimpleDateFormat@f67a0200<br>main__java.text.SimpleDateFormat@f67a0200<br>线程1__java.text.SimpleDateFormat@f67a0200<br>线程0__java.text.SimpleDateFormat@f67a0200<br>线程1__java.text.SimpleDateFormat@f67a0200<br>线程0__java.text.SimpleDateFormat@f67a0200<br>","like_count":0},{"had_liked":false,"id":239062,"user_name":"阿拉丁灯","can_delete":false,"product_type":"c1","uid":1277094,"ip_address":"","ucode":"59664187E74917","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","comment_is_top":false,"comment_ctime":1596424800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596424800","product_id":100023901,"comment_content":"老师您好，把key，value都设置为强引用，最后一起remove这样会不会更简单一点？","like_count":0},{"had_liked":false,"id":224675,"user_name":"Just","can_delete":false,"product_type":"c1","uid":2022626,"ip_address":"","ucode":"35FA6917DE1D04","user_header":"https://static001.geekbang.org/account/avatar/00/1e/dc/e2/a3abd320.jpg","comment_is_top":false,"comment_ctime":1591503376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591503376","product_id":100023901,"comment_content":"ThreadLocal本来就是为了线程本地存储，实现线程安全的目的，如果异步场景使用相当于多个线程之间共享。没有共享就没有伤害。","like_count":0},{"had_liked":false,"id":222259,"user_name":"redis","can_delete":false,"product_type":"c1","uid":1066278,"ip_address":"","ucode":"91C54605384F51","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/26/f54c9888.jpg","comment_is_top":false,"comment_ctime":1590728881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590728881","product_id":100023901,"comment_content":"InheritableThreadLocal 不适合在线程池中使用还有个原因，线程复用，而不是创建，这个时候就挂了，业务还是参数透传靠谱点","like_count":0},{"had_liked":false,"id":200988,"user_name":"So","can_delete":false,"product_type":"c1","uid":1485274,"ip_address":"","ucode":"60095793800451","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/fLsz4MWRfXUNutWJQLtCMYsEibczUJbGBWIcean2vJZYll5nGRkmHgV3BbXVicGt6qUmDEcZM0VlOdj8O06UhjvQ/132","comment_is_top":false,"comment_ctime":1585703237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585703237","product_id":100023901,"comment_content":"想问下使用InheritableThreadLocal传递父线程的变量给子线程和使用构造方法显式传值给子线程，子线程用成员变量接收供子线程使用，这两种方式有什么区别？","like_count":0},{"had_liked":false,"id":176747,"user_name":"Chuan","can_delete":false,"product_type":"c1","uid":1438352,"ip_address":"","ucode":"FACEC5DAC36A7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4akcIyIOXB2OqibTe7FF90hwsBicxkjdicUNTMorGeIictdr3OoMxhc20yznmZWwAvQVThKPFWgOyMw/132","comment_is_top":false,"comment_ctime":1581153970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581153970","product_id":100023901,"comment_content":"大家考虑的由于Entry的key对ThreadLocal对象是弱引用，在GC的时候会被回收，可能存在某一次get时，get不到值，所以一般的实践方法是，给这个ThreadLocal变量设置为static。设置为static有两个好处：<br>1. 为ThreadLocal对象添加了一个强引用，这样ThreadLocal对象不会被回收。所以这里需要我们在使用完 后手动回收。<br>2. 解决了“ThreadLocal对象无法解决共享对象的更新问题”这一问题，该实践在阿里巴巴开发手册上有推荐。当ThreadLocal对象为静态变量，在类加载时被初始化后，所有此类的实例对象都可以操作改变量。<br><br>不知道上述说法是否有问题，请老师指正！","like_count":0},{"had_liked":false,"id":168167,"user_name":"Cv","can_delete":false,"product_type":"c1","uid":1062797,"ip_address":"","ucode":"C77CE172B5AA28","user_header":"","comment_is_top":false,"comment_ctime":1578024265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578024265","product_id":100023901,"comment_content":"文中的例子工具类SafeDateFormat在被线程池使用时可能导致OOM, 加上remove后又一样每次需要销毁重新创建, 那么我们在写这个工具类时是否就直接new一个临时的DateFormat出来用,而不使用threadlocal比较好呢","like_count":0},{"had_liked":false,"id":166898,"user_name":"某不知名挨踢男","can_delete":false,"product_type":"c1","uid":1332106,"ip_address":"","ucode":"BD2223CD9D7C2A","user_header":"https://static001.geekbang.org/account/avatar/00/14/53/8a/f9ef54c1.jpg","comment_is_top":false,"comment_ctime":1577627229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577627229","product_id":100023901,"comment_content":"在学习android handler原理的时候，Looper就是使用ThreadLocal存放looper对象的。当时只知道ThreadLocal是每个线程只有一个，一直存在着困惑ThreadLocal是怎么做到的呢？现在有了答案了，谢谢老师。","like_count":0},{"had_liked":false,"id":160681,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1576020472,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576020472","product_id":100023901,"comment_content":"有个疑问：Thread 对象和运行的线程是同一个东西吗，如果不是，能解释一下区别吗？如果是有如下疑问：<br>ThreadLocal 创建map时有如下代码。<br>void createMap(Thread t, T firstValue) {<br>        t.threadLocals = new ThreadLocalMap(this, firstValue);<br>    }<br><br>如果在一个执行流程里定义了多个theadLocal, 根据这段代码，t.threadLocals的引用就指向了最后一个threadLocal的定义。感觉java sdk 肯定不会这样啊。老师能解释一下吗？","like_count":0,"discussions":[{"author":{"id":1270617,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2EOx1qgJEYDIfQYEZvaORasynqBFW3SSaG9msGaMI7XUxESDLzXu1ibzicCA6p6CvhsBegleCrHeA/132","nickname":"Geek_7dd5bf","note":"","ucode":"FAB0E6CD0992DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387811,"discussion_content":"如果一个线程中，定义了多个ThreadLocal,只有第一个ThreadLocal会执行到createMap新建map的逻辑，后续的ThreadLocal会执行set方法时，内部有判断如果当前线程已经创建了ThreadLocalMap，则直接使用，而不重新创建，所以这个线程内所有的ThreadLocal公用一个ThreadLocalMap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628430119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156194,"user_name":"林肯","can_delete":false,"product_type":"c1","uid":1008582,"ip_address":"","ucode":"D2C97220230DE5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","comment_is_top":false,"comment_ctime":1574831191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574831191","product_id":100023901,"comment_content":"老师好，请教个问题。弱引用对象只能生存到下一次gc前，如果下一次gc时线程还在而且我还需要用到threadlocal，这时候岂不是取不到数据？","like_count":0},{"had_liked":false,"id":142903,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1571578490,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1571578490","product_id":100023901,"comment_content":"老师，对于ThreadLocal导致内存泄漏，整体逻辑上我是明白的，但有一点还是糊涂，我也去google很多文章，还是不完全明白。就是这个Entry数组里面的弱引用，它会在下一次GC之后就被回收了，但这个回收仅仅只是ThreadLocal实例的一个引用吧，ThreadLocal实例对象自身是final static修饰的，它应该一直都在吧。这个ThreadLocal实例对象是所有线程都会引用的，也就是说，内存泄漏的主要还是value，跟这个key没什么太大关系。如果这个key又改回强引用，那么内存泄漏也只是多了一个ThreadLocal实例的引用，我的理解对么？","like_count":0,"discussions":[{"author":{"id":1277094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","nickname":"阿拉丁灯","note":"","ucode":"59664187E74917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296001,"discussion_content":"我也是这么理解的，我还有个问题就是为啥key，valu不都设置为强引用，最后一起remove？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596424682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128035,"user_name":"xinglichea","can_delete":false,"product_type":"c1","uid":1176447,"ip_address":"","ucode":"986DA07BF3CA89","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/7f/2dd9409b.jpg","comment_is_top":false,"comment_ctime":1566823402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566823402","product_id":100023901,"comment_content":"老师，还有个问题就是线程在执行过程中会不会出现ThreadLocal.get()的Value为null，由于弱引用的原因，GC把key回收掉了，所以无法找到对应的value值，感觉Entry对类在做设计的时候是不是用软引用较为合适些，至少是在内存空间不够的情况下，再进行回收，出现null的几率要比弱使用低的多。","like_count":0},{"had_liked":false,"id":118113,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1564244678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564244678","product_id":100023901,"comment_content":"老师我有一个问题，threadlock 在key 因为弱引用被回收后，在set和get 方法中不是会 调用replaceStaleEntry 释放掉Entry 。怎么有内存泄漏呢？","like_count":0},{"had_liked":false,"id":118088,"user_name":"SGT","can_delete":false,"product_type":"c1","uid":1546883,"ip_address":"","ucode":"D88847279B5ADE","user_header":"https://static001.geekbang.org/account/avatar/00/17/9a/83/5df195a2.jpg","comment_is_top":false,"comment_ctime":1564235065,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1564235065","product_id":100023901,"comment_content":"老师，不太明白为啥是threadlocal使用了弱引用造成oom，这个应该部会造成oom吧，根本原因在于threadlocalmap的生命周期和thread一样长，才造成了oom吧，我不太明白为啥弱引用也会造成oom，或者换句话说如果弱引用会造成oom，那干嘛不换成强引用了","like_count":0,"discussions":[{"author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62303,"discussion_content":"老师说的是内存泄露，不是内存溢出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574831266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110210,"user_name":"capo","can_delete":false,"product_type":"c1","uid":1178016,"ip_address":"","ucode":"6FD72DA5DBC220","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/a0/2240fb2c.jpg","comment_is_top":false,"comment_ctime":1562208435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562208435","product_id":100023901,"comment_content":"老师你好，我们看两个线程里面get获取的值是打印内存地址吗？System.identityHashCode","like_count":0},{"had_liked":false,"id":107452,"user_name":"达拉崩吧斑的比卜","can_delete":false,"product_type":"c1","uid":1447604,"ip_address":"","ucode":"04D54EFD2056D5","user_header":"https://static001.geekbang.org/account/avatar/00/16/16/b4/88dfd8af.jpg","comment_is_top":false,"comment_ctime":1561538275,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561538275","product_id":100023901,"comment_content":"老师，怎么确定一个线程使用的是哪一个threadlocal呢？","like_count":0,"discussions":[{"author":{"id":1344007,"avatar":"https://static001.geekbang.org/account/avatar/00/14/82/07/5940b400.jpg","nickname":"SaimSaim","note":"","ucode":"E4755472EF6C1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6567,"discussion_content":"看get()的源码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566978459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97588,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1558702899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558702899","product_id":100023901,"comment_content":"老师，写demo的时候发现，threadlocalmap中始终会有两个陌生的entry，value是两个软引，分别是StringDecoder和StringEncoder，为什么会有这两个东西呢？这里指定的GBK是用来指明线程所有上下文文本编码格式的吗？","like_count":0},{"had_liked":false,"id":95419,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1558054940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558054940","product_id":100023901,"comment_content":"期待老师解答这里的思考题。","like_count":0},{"had_liked":false,"id":94353,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1557794778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557794778","product_id":100023901,"comment_content":"异步场景中，被调用方可以自己用spring的事事务来管理吧？","like_count":0},{"had_liked":false,"id":93139,"user_name":"_light","can_delete":false,"product_type":"c1","uid":1324723,"ip_address":"","ucode":"ACE2ABC357C5FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/36/b3/c4a2f3fd.jpg","comment_is_top":false,"comment_ctime":1557406639,"is_pvip":false,"replies":[{"id":"33205","content":"我也没看过，最近太忙了😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557411413,"ip_address":"","comment_id":93139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557406639","product_id":100023901,"comment_content":"老师，你好<br> 阿里有一个TransmittableThreadLocal据说是支持线程池线程复用的继承了InheritableThreadLocal类的东西，我试了下确实可以，他可以在线程池线程执行时拿到正确的父类本地变量，其实也不是父类，就是初始化赋值TransmittableThreadLocal的那个线程的数据，因为我们的线程池一般都是静态全局的，谁是父类都说不清楚。感觉这个好强大啊，他包装了线程池，看了好几次源码都没啃下来，实在是好奇怎么实现的，老师有空可以帮我们分析下不啦😀","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449502,"discussion_content":"我也没看过，最近太忙了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557411413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92357,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1557239595,"is_pvip":false,"replies":[{"id":"67561","content":"建议不要异步，除非你能保证子线程用的数据库连接和主线程是一样的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579776211,"ip_address":"","comment_id":92357,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557239595","product_id":100023901,"comment_content":"老师你好，请教一下，spring有事务管理并发安全，但是事务里使用异步编程的安全一般怎么保证呢？比如在事务里新开一个线程执行service方法，这个方法会脱离原有的事务，如果这个异步方法里涉及到对数据库的操作，应该怎么保证数据安全性呢？在保证安全的情况下，spring的事务方法中哪些操作适合异步执行呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449225,"discussion_content":"建议不要异步，除非你能保证子线程用的数据库连接和主线程是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579776211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92259,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1557216031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557216031","product_id":100023901,"comment_content":"老师你好，我如下方式不同线程返回的SimpleDateFormat对象也是同一份，是什么原因：<br><br>public class SafeDateFormat {<br><br>    static final ThreadLocal&lt;DateFormat&gt; tl = ThreadLocal.withInitial(<br>            () -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)<br>    );<br><br>    static DateFormat get(){<br>        return tl.get();<br>    }<br><br>    public static void main(String[] args) {<br>        for (int i=0;i&lt;5;i++){<br>            new Thread(() -&gt; {<br>                System.out.println(SafeDateFormat.get());<br>            }).start();<br>        }<br>    }<br>}","like_count":0},{"had_liked":false,"id":92124,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1557190768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557190768","product_id":100023901,"comment_content":"不能使用，异步编程是不同线程执行，无法获取同一份ThreadLocal变量","like_count":0},{"had_liked":false,"id":92112,"user_name":"袁阳","can_delete":false,"product_type":"c1","uid":1329594,"ip_address":"","ucode":"B397F760CDC53A","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/ba/02742d56.jpg","comment_is_top":false,"comment_ctime":1557189655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557189655","product_id":100023901,"comment_content":"老师，我有个问题，ThreadLocal.ThreadLocalMap的set方法并没有加锁，它在Thread中的可见性是包可见的，那么如果我在Thread这个类所在包里面并发调用一个Thread.threadLocals.set()方法，是不是也不是线程安全的？请老师解答","like_count":0},{"had_liked":false,"id":92091,"user_name":"青莲","can_delete":false,"product_type":"c1","uid":1181787,"ip_address":"","ucode":"6BA5D5D47DE38E","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/5b/2a342424.jpg","comment_is_top":false,"comment_ctime":1557188046,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1557188046","product_id":100023901,"comment_content":"异步一般采用线程池执行任务，这里就会有一个事务的可继承性问题，事物资源的释放，以及线程池执行了任务是否会产生业务错乱","like_count":0},{"had_liked":false,"id":92086,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1557187558,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1557187558","product_id":100023901,"comment_content":"不行，不同的线程，不同的ThreadLocal，且不具有集成性","like_count":0}]}