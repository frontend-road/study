{"id":283787,"title":"10 分析篇 | 内存泄漏时，我们该如何一步步找到根因？","content":"<p>你好，我是邵亚方。</p><p>通过我们前面的基础篇以及案例篇的学习，你对内存泄漏应该有了自己的一些理解。这节课我来跟你聊一聊系统性地分析内存泄漏问题的方法：也就是说，在面对内存泄漏时，我们该如何一步步去找到根因？</p><p>不过，我不会深入到具体语言的实现细节，以及具体业务的代码逻辑中，而是会从Linux系统上通用的一些分析方法来入手。这样，不论你使用什么开发语言，不论你在开发什么，它总能给你提供一些帮助。</p><h2>如何定位出是谁在消耗内存 ？</h2><p>内存泄漏的外在表现通常是系统内存不够，严重的话可能会引起OOM (Out of Memory)，甚至系统宕机。那在发生这些现象时，惯用的分析套路是什么呢？</p><p>首先，我们需要去找出到底是谁在消耗内存，/proc/meminfo可以帮助我们来快速定位出问题所在。</p><p>/proc/meminfo中的项目很多，我们没必要全部都背下来，不过有些项是相对容易出问题的，也是你在遇到内存相关的问题时，需要重点去排查的。我将这些项列了一张表格，也给出了每一项有异常时的排查思路。</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/30/a48d1c573d19e30ecee8dc6f6fdd3930.jpg?wh=4215*3139\" alt=\"\"></p><p>总之，如果进程的内存有问题，那使用top就可以观察出来；如果进程的内存没有问题，那你可以从/proc/meminfo入手来一步步地去深入分析。</p><!-- [[[read_end]]] --><p>接下来，我们分析一个实际的案例，来看看如何分析进程内存泄漏是什么原因导致的。</p><h2>如何去分析进程的内存泄漏原因？</h2><p>这是我多年以前帮助一个小伙伴分析的内存泄漏问题。这个小伙伴已经使用top排查出了业务进程的内存异常，但是不清楚该如何去进一步分析。</p><p>他遇到的这个异常是，业务进程的虚拟地址空间（VIRT）被消耗很大，但是物理内存（RES）使用得却很少，所以他怀疑是进程的虚拟地址空间有内存泄漏。</p><p>我们在“<a href=\"https://time.geekbang.org/column/article/280455\">06讲</a>”中也讲过，出现该现象时，可以用top命令观察（这是当时保存的生产环境信息，部分信息做了脱敏处理）：</p><pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                     \n31108 app      20   0  285g 4.0g  19m S 60.6 12.7  10986:15 app_server  \n</code></pre><p>可以看到app_server这个程序的虚拟地址空间（VIRT这一项）很大，有285GB。</p><p>那该如何追踪app_server究竟是哪里存在问题呢？</p><p>我们可以用pidstat命令（关于该命令，你可以<a href=\"https://linux.die.net/man/1/pidstat\">man pidstat</a>）来追踪下该进程的内存行为，看看能够发现什么现象。</p><pre><code>$ pidstat -r -p 31108  1\n\n\n04:47:00 PM     31108    353.00      0.00 299029776 4182152  12.73  app_server\n...\n04:47:59 PM     31108    149.00      0.00 299029776 4181052  12.73  app_server\n04:48:00 PM     31108    191.00      0.00 299040020 4181188  12.73  app_server\n...\n04:48:59 PM     31108    179.00      0.00 299040020 4181400  12.73  app_server\n04:49:00 PM     31108    183.00      0.00 299050264 4181524  12.73  app_server\n...\n04:49:59 PM     31108    157.00      0.00 299050264 4181456  12.73  app_server\n04:50:00 PM     31108    207.00      0.00 299060508 4181560  12.73  app_server\n...\n04:50:59 PM     31108    127.00      0.00 299060508 4180816  12.73  app_server\n04:51:00 PM     31108    172.00      0.00 299070752 4180956  12.73  app_server\n</code></pre><p>如上所示，在每个整分钟的时候，VSZ会增大10244KB，这看起来是一个很有规律的现象。然后，我们再来看下增大的这个内存区域到底是什么，你可以通过/proc/PID/smaps来看（关于/proc提供的信息，你可以回顾我们课程的“<a href=\"https://time.geekbang.org/column/article/279307\">05讲</a>”）：</p><p>增大的内存区域，具体如下：</p><pre><code>$ cat /proc/31108/smaps \n...\n7faae0e49000-7faae1849000 rw-p 00000000 00:00 0 \nSize:              10240 kB\nRss:                  80 kB\nPss:                  80 kB\nShared_Clean:          0 kB\nShared_Dirty:          0 kB\nPrivate_Clean:         0 kB\nPrivate_Dirty:        80 kB\nReferenced:           60 kB\nAnonymous:            80 kB\nAnonHugePages:         0 kB\nSwap:                  0 kB\nKernelPageSize:        4 kB\nMMUPageSize:           4 kB\n7faae1849000-7faae184a000 ---p 00000000 00:00 0 \nSize:                  4 kB\nRss:                   0 kB\nPss:                   0 kB\nShared_Clean:          0 kB\nShared_Dirty:          0 kB\nPrivate_Clean:         0 kB\nPrivate_Dirty:         0 kB\nReferenced:            0 kB\nAnonymous:             0 kB\nAnonHugePages:         0 kB\nSwap:                  0 kB\nKernelPageSize:        4 kB\nMMUPageSize:           4 kB\n</code></pre><p>可以看到，它包括：一个私有地址空间，这从rw-p这个属性中的private可以看出来；以及一个保护页 ，这从—p这个属性可以看出来，即进程无法访问。对于有经验的开发者而言，从这个4K的保护页就可以猜测出应该跟线程栈有关了。</p><p>然后我们跟踪下进程申请这部分地址空间的目的是什么，通过strace命令来跟踪系统调用就可以了。因为VIRT的增加，它的系统调用函数无非是mmap或者brk，那么我们只需要strace的结果来看下mmap或brk就可以了。</p><p>用strace跟踪如下：</p><pre><code>$ strace -t -f -p 31108 -o 31108.strace\n</code></pre><p>线程数较多，如果使用-f来跟踪线程，跟踪的信息量也很大，逐个搜索日志里面的mmap或者brk真是眼花缭乱， 所以我们来grep一下这个大小(10489856即10244KB)，然后过滤下就好了：</p><pre><code>$ cat 31108.strace | grep 10489856    \n31152 23:00:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31151 23:01:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31157 23:02:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31158 23:03:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31165 23:04:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31163 23:05:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31153 23:06:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31155 23:07:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31149 23:08:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31147 23:09:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31159 23:10:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31157 23:11:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31148 23:12:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31150 23:13:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31173 23:14:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n</code></pre><p>从这个日志我们可以看到，出错的是mmap()这个系统调用，那我们再来看下mmap这个内存的目的：</p><pre><code>31151 23:01:00 mmap(NULL, 10489856, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;\n31151 23:01:00 mprotect(0x7fa94bbc0000, 4096, PROT_NONE &lt;unfinished ...&gt;   &lt;&lt;&lt; 创建一个保护页  \n31151 23:01:00 clone( &lt;unfinished ...&gt;   &lt;&lt;&lt; 创建线程\n31151 23:01:00 &lt;... clone resumed&gt; child_stack=0x7fa94c5afe50, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND\n|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID\n|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fa94c5c09d0, tls=0x7fa94c5c0700, child_tidptr=0x7fa94c5c09d0) = 20610\n</code></pre><p>可以看出，这是在clone时申请的线程栈。到这里你可能会有一个疑问：既然线程栈消耗了这么多的内存，那理应有很多才对啊？</p><p>但是实际上，系统中并没有很多app_server的线程，那这是为什么呢？答案其实比较简单：线程短暂执行完毕后就退出了，可是mmap的线程栈却没有被释放。</p><p>我们来写一个简单的程序复现这个现象，问题的复现是很重要的，如果很复杂的问题可以用简单的程序来复现，那就是最好的结果了。</p><p>如下是一个简单的复现程序：mmap一个40K的线程栈，然后线程简单执行一下就退出。</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#define _SCHED_H \n#define __USE_GNU \n#include &lt;bits/sched.h&gt;\n \n#define STACK_SIZE 40960\n \nint func(void *arg)\n{\n    printf(&quot;thread enter.\\n&quot;);\n    sleep(1);\n    printf(&quot;thread exit.\\n&quot;);\n \n    return 0;\n}\n\n\nint main()\n{\n    int thread_pid;\n    int status;\n    int w;\n \n    while (1) {\n        void *addr = mmap(NULL, STACK_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0);\n        if (addr == NULL) {\n            perror(&quot;mmap&quot;);\n            goto error;\n        }\n        printf(&quot;creat new thread...\\n&quot;);\n        thread_pid = clone(&amp;func, addr + STACK_SIZE, CLONE_SIGHAND|CLONE_FS|CLONE_VM|CLONE_FILES, NULL);\n        printf(&quot;Done! Thread pid: %d\\n&quot;, thread_pid);\n        if (thread_pid != -1) {\n            do {\n                w = waitpid(-1, NULL, __WCLONE | __WALL);\n                if (w == -1) {\n                    perror(&quot;waitpid&quot;);\n                    goto error;\n                }\n            } while (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));\n        }\n        sleep(10);\n   }\n\n error:\n    return 0;\n}\n</code></pre><p>然后我们用pidstat观察该进程的执行，可以发现它的现象跟生产环境中的问题是一致的：</p><pre><code>$ pidstat -r -p 535 5\n11:56:51 PM   UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command\n11:56:56 PM     0       535      0.20      0.00    4364    360   0.00  a.out\n11:57:01 PM     0       535      0.00      0.00    4364    360   0.00  a.out\n11:57:06 PM     0       535      0.20      0.00    4404    360   0.00  a.out\n11:57:11 PM     0       535      0.00      0.00    4404    360   0.00  a.out\n11:57:16 PM     0       535      0.20      0.00    4444    360   0.00  a.out\n11:57:21 PM     0       535      0.00      0.00    4444    360   0.00  a.out\n11:57:26 PM     0       535      0.20      0.00    4484    360   0.00  a.out\n11:57:31 PM     0       535      0.00      0.00    4484    360   0.00  a.out\n11:57:36 PM     0       535      0.20      0.00    4524    360   0.00  a.out\n^C\nAverage:        0       535      0.11      0.00    4435    360   0.00  a.out\n</code></pre><p>你可以看到，VSZ每10s增大40K，但是增加的那个线程只存在了1s就消失了。</p><p>至此我们就可以推断出app_server的代码哪里有问题了，然后小伙伴去修复该代码Bug，很快就把该问题给解决了。</p><p>当然了，应用程序的内存泄漏问题其实是千奇百怪的，分析方法也不尽相同，我们讲述这个案例的目的是为了告诉你一些通用的分析技巧。我们掌握了这些通用分析技巧，很多时候就可以以不变来应万变了。</p><h2>课堂总结</h2><p>这节课我们讲述了系统性分析Linux上内存泄漏问题的分析方法，要点如下：</p><ul>\n<li>top工具和/proc/meminfo文件是分析Linux上内存泄漏问题，甚至是所有内存问题的第一步，我们先找出来哪个进程或者哪一项有异常，然后再针对性地分析；</li>\n<li>应用程序的内存泄漏千奇百怪，所以你需要掌握一些通用的分析技巧，掌握了这些技巧很多时候就可以以不变应万变。但是，这些技巧的掌握，是建立在你的基础知识足够扎实的基础上。你需要熟练掌握我们这个系列课程讲述的这些基础知识，熟才能生巧。</li>\n</ul><h2>课后作业</h2><p>请写一个内存泄漏的程序，然后观察/proc/[pid]/maps以及smaps的变化（pid即内存泄漏的程序的pid）。欢迎你在留言区与我讨论。</p><p>感谢你的阅读，如果你认为这节课的内容有收获，也欢迎把它分享给你的朋友，我们下一讲见。</p>","comments":[{"had_liked":false,"id":287220,"user_name":"石小","can_delete":false,"product_type":"c1","uid":1781893,"ip_address":"","ucode":"4258C686F289A6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","comment_is_top":false,"comment_ctime":1617845236,"is_pvip":false,"replies":[{"id":"104501","content":"这是为了防止栈溢出问题，当线程栈溢出后，就会写这个保护页，进而出发segfault。","user_name":"作者回复","user_name_real":"邵亚方","uid":"1981399","ctime":1618146031,"ip_address":"","comment_id":287220,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44567518196","product_id":100058001,"comment_content":"“对于有经验的开发者而言，从这个 4K 的保护页就可以猜测出应该跟线程栈有关了。” 请问老师怎么理解这局话？","like_count":10,"discussions":[{"author":{"id":1981399,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3b/d7/9d942870.jpg","nickname":"邵亚方","note":"","ucode":"CDFABCB81B9782","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518235,"discussion_content":"这是为了防止栈溢出问题，当线程栈溢出后，就会写这个保护页，进而出发segfault。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618146031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257690,"user_name":"飘云","can_delete":false,"product_type":"c1","uid":1446494,"ip_address":"","ucode":"C6FE0310D6853C","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/5e/77b67a85.jpg","comment_is_top":false,"comment_ctime":1604058669,"is_pvip":false,"replies":[{"id":"93851","content":"pthread_create的时候可能会调用clone，clone是一个系统调用，pthread是lib库，库函数其实是对系统调用的封装。<br>物理内存泄露并没有什么高效的分析方式，只能通过追踪malloc&#47;free来看在哪里申请的没有去释放。","user_name":"作者回复","user_name_real":"邵亚方","uid":"1981399","ctime":1604143539,"ip_address":"","comment_id":257690,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23078895149","product_id":100058001,"comment_content":"写应用层代码的时候会用到clone么，不都用pthread么？ 用pthread不会出现例子中的问题吧。 <br>另外，内存泄露很多时候是malloc了内存但是没有free，有什么好的方法快速定位是哪儿分配的内存忘了free呢？","like_count":5,"discussions":[{"author":{"id":1981399,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3b/d7/9d942870.jpg","nickname":"邵亚方","note":"","ucode":"CDFABCB81B9782","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508417,"discussion_content":"pthread_create的时候可能会调用clone，clone是一个系统调用，pthread是lib库，库函数其实是对系统调用的封装。\n物理内存泄露并没有什么高效的分析方式，只能通过追踪malloc/free来看在哪里申请的没有去释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604143539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1494491,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","nickname":"Bachue Zhou","note":"","ucode":"3175754775CA32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1981399,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3b/d7/9d942870.jpg","nickname":"邵亚方","note":"","ucode":"CDFABCB81B9782","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":574994,"discussion_content":"还是没有理解，如果只调用 pthread 系列方法操作线程，应该是不会需要手动分配回收线程栈的，也就不存在 bug 的可能，不清楚为何需要直接用到系统调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654513699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":508417,"ip_address":""},"score":574994,"extra":""}]}]},{"had_liked":false,"id":257289,"user_name":"Richard","can_delete":false,"product_type":"c1","uid":1316758,"ip_address":"","ucode":"893F958B9DD161","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","comment_is_top":false,"comment_ctime":1603930590,"is_pvip":false,"replies":[{"id":"93850","content":"对的 只是虚拟地址空间产生了问题 实际的物理内存并没有问题 整个系统的内存并没有异常","user_name":"作者回复","user_name_real":"邵亚方","uid":"1981399","ctime":1604143359,"ip_address":"","comment_id":257289,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14488832478","product_id":100058001,"comment_content":"老师好，这个案例讲的是虚拟内存泄露，我想问一下:虚拟内存分配后在使用前不会真正的分配物理内存，那这个案例是不是仅仅是进程的虚拟内存存在问题？整个Linux系统的内存应该没有异常对不对？","like_count":3,"discussions":[{"author":{"id":1981399,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3b/d7/9d942870.jpg","nickname":"邵亚方","note":"","ucode":"CDFABCB81B9782","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508285,"discussion_content":"对的 只是虚拟地址空间产生了问题 实际的物理内存并没有问题 整个系统的内存并没有异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604143359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248080,"user_name":"Geek_circle","can_delete":false,"product_type":"c1","uid":1711469,"ip_address":"","ucode":"B85D0E9CEE8786","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epUBQibdMCca340MFZOe5I1GwZ0PosPIzA0TPCNzibgH00w45Zmv4jmL0mFRHMUM9FuKiclKOCBjSmsw/132","comment_is_top":false,"comment_ctime":1600002944,"is_pvip":false,"replies":[{"id":"91448","content":"内存水位不足后就会唤醒kswapd来回收内存，如果kswapd可以回收内存并且内存水位持续高，kswapd就会一直忙，它的使用率就会高。只有在回收不到内存的情况下，才会触发oom killer来杀进程。<br>你说的这种情况就是可以回收到内存，但是回收比较困难 所以才产生这种情况。","user_name":"作者回复","user_name_real":"邵亚方","uid":"1981399","ctime":1600569862,"ip_address":"","comment_id":248080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14484904832","product_id":100058001,"comment_content":"老师好，当系统内存不足,发现kswapd0进程持续运行，使用率超过90%多,load过百,但是系统日志中并没有记录到oom killer 。想知道系统内存不足时，启动kswapd和oom killer条件和优先级是什么样的呢？","like_count":3,"discussions":[{"author":{"id":1981399,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3b/d7/9d942870.jpg","nickname":"邵亚方","note":"","ucode":"CDFABCB81B9782","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505561,"discussion_content":"内存水位不足后就会唤醒kswapd来回收内存，如果kswapd可以回收内存并且内存水位持续高，kswapd就会一直忙，它的使用率就会高。只有在回收不到内存的情况下，才会触发oom killer来杀进程。\n你说的这种情况就是可以回收到内存，但是回收比较困难 所以才产生这种情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600569862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248064,"user_name":"jssfy","can_delete":false,"product_type":"c1","uid":1137238,"ip_address":"","ucode":"F16353CFE607B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/56/115c6433.jpg","comment_is_top":false,"comment_ctime":1599997572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10189932164","product_id":100058001,"comment_content":"问题分析过程很赞，开头的总结性图表也很赞！","like_count":2},{"had_liked":false,"id":263663,"user_name":"dpzain","can_delete":false,"product_type":"c1","uid":1510874,"ip_address":"","ucode":"AA069519176892","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTINb3EmV5q6ytNWclxke1OicbEAw4ZSmibSCrNGZPDCnAjsGDwG3jJQcuEwAcFRffBQouXFEaERQbfw/132","comment_is_top":false,"comment_ctime":1606211559,"is_pvip":false,"replies":[{"id":"96001","content":"jvm堆外内存泄漏，在明确哪些任务在泄漏内存后，最好能否结合代码来进行打点追踪，看看哪里有问题。","user_name":"作者回复","user_name_real":"邵亚方","uid":"1981399","ctime":1606638327,"ip_address":"","comment_id":263663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5901178855","product_id":100058001,"comment_content":"现在生产环境 是jvm 程序 跑在docker容器， jvm 堆内内存 监控一切正常，但是每隔半个月 mem从50%到90% ，按照上面的方法发现确实有对外内存在缓慢的泄漏   非常慢（没5s - 20s 增加几kb甚至  几十个byte ）找不出任何规律 怎么破；","like_count":1,"discussions":[{"author":{"id":1981399,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/3b/d7/9d942870.jpg","nickname":"邵亚方","note":"","ucode":"CDFABCB81B9782","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510260,"discussion_content":"jvm堆外内存泄漏，在明确哪些任务在泄漏内存后，最好能否结合代码来进行打点追踪，看看哪里有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606638327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357527,"user_name":"mong","can_delete":false,"product_type":"c1","uid":1040067,"ip_address":"广东","ucode":"CA5CAECC4648B8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/c3/e0a4c93f.jpg","comment_is_top":false,"comment_ctime":1663337521,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663337521","product_id":100058001,"comment_content":"老师, 看了你的这些文章, 对线上内存的定位也有一些思路, 我正面临的一个Java应用程序内存有问题的, VIRT, RSS的内存很高, 用&#47;proc&#47;pid&#47;smaps, 发现有很多64M的内存申请,占了将近3个G 如下:<br>7fe698000000-7fe69bffa000 rw-p 00000000 00:00 0 <br>Size:              65512 kB<br>KernelPageSize:        4 kB<br>MMUPageSize:           4 kB<br>Rss:               62456 kB<br>Pss:               62456 kB<br>Shared_Clean:          0 kB<br>Shared_Dirty:          0 kB<br>Private_Clean:         0 kB<br>Private_Dirty:     62456 kB<br>Referenced:        62448 kB<br>Anonymous:         62456 kB<br>LazyFree:              0 kB<br>AnonHugePages:         0 kB<br>ShmemPmdMapped:        0 kB<br>Shared_Hugetlb:        0 kB<br>Private_Hugetlb:       0 kB<br>Swap:                  0 kB<br>SwapPss:               0 kB<br>Locked:                0 kB<br>VmFlags: rd wr mr mw me nr <br>但到这一步我无法继续的下去, 我用gdp dump了这段的地址的bin下来, 打开文件都Null, 所以我的java内存的堆的内存通过监控看也比较稳定, 所以目前没有什么头绪, 所以相让你指点一点, 接下来应该从哪里继续的排查;","like_count":0},{"had_liked":false,"id":347793,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1654434534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654434534","product_id":100058001,"comment_content":"不太懂，smaps 的内容这么多，如何找到出问题的部分？是多次 cat smaps 然后做 diff 吗？","like_count":0},{"had_liked":false,"id":346056,"user_name":"Felix","can_delete":false,"product_type":"c1","uid":1317899,"ip_address":"","ucode":"9318688F3C5419","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAWUhO0xSjD6wbGScY5WOujAE94vNYWlWmsVdibb0IWbXzSSNXJHp0lqfWVq8ZicKBsEY1EuAWArew/132","comment_is_top":false,"comment_ctime":1652793100,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652793100","product_id":100058001,"comment_content":"真是读书万卷，其意自现","like_count":0},{"had_liked":false,"id":259407,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1604719614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604719614","product_id":100058001,"comment_content":"对底层的基础理论不牢靠，原来定位问题有这么多的方法。学习了","like_count":0},{"had_liked":false,"id":255553,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1007254,"ip_address":"","ucode":"E28F2602BA25DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","comment_is_top":false,"comment_ctime":1603371723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603371723","product_id":100058001,"comment_content":"赞，之前有过比较类似的排查思路。","like_count":0},{"had_liked":false,"id":247558,"user_name":"ermaot","can_delete":false,"product_type":"c1","uid":1304459,"ip_address":"","ucode":"DD5AC5FFEAA9CC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1PyKtnO7QRIP8mlcGNu4wpYVjOo6ZZ7pNIxbmRSYK0KvbcXPVcsiba4ibo1GTjQrRYibiaPxrrTPtlGnzoDEP7tDBQ/132","comment_is_top":false,"comment_ctime":1599741253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599741253","product_id":100058001,"comment_content":"曲径通幽，豁然开朗。基础要扎实，但工具也要熟啊","like_count":0}]}