{"id":293536,"title":"10｜面试即正义第二期：常见的动态规划面试题串烧","content":"<p>你好，我是卢誉声。</p><p>在前面的课程中，我们使用动态规划解题模板（套路），解决了多种类型的动态规划算法问题。这其中包括背包问题、子数组问题和子序列问题等，它们绝大多数都属于求最优解（最大值和最小值）类型的问题。</p><p>除此之外，我们还需要掌握另外两大类型的动归问题，它们分别是求方案总数以及求可行性（True或False）。虽然这两类动归问题的提法不同，但我们仍然可以使用之前总结的动态规划解题模板（套路），只需稍作调整就可以了。</p><p>那这样的话，我们今天的课程目标也就非常清晰了，就是把这两类典型的动态规划问题弄明白。现在，就让从最简单的题目开始吧！</p><h2>简单的路径规划</h2><p>路径规划问题是十分常见的动态规划面试问题，这类问题通常都是模拟现实中的路径规划。一般来说，它会给你一个指定的图，以及与图相对应的约定条件，然后让你计算出路径的总数或最优路径等。我们一般把这种问题归类到求方案总数这一类别中。</p><p>现在，我们来看下最简单的路径规划问题。</p><h3>算法问题分析</h3><p>问题：一个机器人位于一个 m * n 网格的左上角 （起始点在下图中标记为“开始” ），机器人每次只能向下或者向右移动一步，现在机器人试图达到网格的右下角（在下图中标记为“结束”）。问总共有多少条不同的路径？</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/10/51/105a1f11f948e5d61d7d61c01184a251.png?wh=1311*622\" alt=\"\"></p><p>比如上图是一个7 * 3的网格，我们希望知道从起点到终点能有多少条不同的路径。</p><pre><code>示例：\n\n输入：m = 3, n = 2\n输出： 3 \n解释: 从左上角开始，总共有 3 条路径可以到达右下角：\n1. 向右 -&gt; 向右 -&gt; 向下\n2. 向右 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向右\n</code></pre><p>当遇到一个问题时，我们先要确定这个问题能否使用动态规划来进行求解，那就看一下该问题是否满足动归问题的三大特征吧。这个你应该非常熟悉了！</p><ol>\n<li>重叠子问题：显然，求方案总数必定涉及穷举，那么在穷举过程中就难以避免出现重叠子问题的计算。比如说，格子 (4, 3) 的路径数量和格子 (3, 4) 的路径数量肯定都会依赖于格子 (3, 3) 的路径数量。因此，如果我们要求格子 (3, 3) 的路径数量，那么在求解格子 (4, 3) 和格子 (3, 4) 的时候，就不需要进行重复计算了；</li>\n<li>无后效性：然后判断该问题是否是无后效性的。由于我们的机器人只能向下或者向右走，因此格子的路径数量求解是单向的，所以子问题肯定是无后效性的；</li>\n<li>最优子结构：由于这个问题中机器人每次只能向右或者向下走一步，因此如果要产生不同的路径肯定从当前格子的上方下来，或者从当前格子的左侧过来，所以第 (m, n) 个格子的路径数量就是第 (m-1, n) 个格子的路径数量加上第 (m, n-1) 个格子的路径数量，所以这里存在所谓的最优子结构。</li>\n</ol><p>通过以上判断，我们得知该问题可以利用动态规划思想来进行求解。</p><h3>写出状态转移方程</h3><p>现在，我们来看看如何写出该问题的状态转移方程。</p><p>参照我们已经反复使用过的解题模板，先要确定<strong>初始化状态</strong>。从原问题可以看出，初始化状态是网格的第一行和第一列。网格的第一行永远只能从左侧的格子往前走，第一列永远只能从上方的格子向下走。由于我们只能向右或向下走，因此，第一行和第一列的格子永远只能存在 1 条路径。</p><p>接着，确定<strong>状态参数</strong>。原问题的状态参数其实就是格子的行数和列数，只要知道行数 $i$ 和列数 $j$ 就能知道这个格子的路径数量。因此，我们得到两个状态参数，分别是代表行数的 $i$ 和代表列数的 $j$。</p><p>那么，在确定了初始化状态和状态参数后，就要进行状态存储。这里我们的状态存储空间是一个二维数组 <strong>$DP[i][j]$，表示第 $i$ 行、第 $j$ 列的路径数量</strong>。你可以通过以下图示加深理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/42/6b72fc1c072beac66904c7ebbd864542.png?wh=1374*448\" alt=\"\"></p><p>从表格中我们可以看出，第一行和第一列是格子的序号。其中填写了 1 的格子，就是初始状态，深色的格子就是$DP[i][j]$，表示第 $i$ 行、第 $j$ 列的路径数量。我们可以计算一下，这个格子的路径数量是 $DP[i-1][j] + DP[i][j-1]$。</p><p>现在一切就绪，我们来写<strong>状态转移方程</strong>。</p><p>$$DP(i, j)=\\left\\{\\begin{array}{c}<br>\nDP[i-1][j] + DP[i][j-1], &amp; if \\ i\\ne0\\ or\\ j\\ne0 \\\\\\<br>\n1,  &amp; i=0\\ and\\ j=0<br>\n\\end{array}\\right.$$</p><p>我们可以这么理解这个状态转移方程：它由初始状态和后续的状态转移构成。当 $i$ 和 $j$ 为 0 时（假定格子从 0 开始而不是 1 开始），函数结果就是 1；否则，就是 $DP[i- 1][j] + DP[i][j-1]$。</p><h3>编写代码进行求解</h3><p>对于这个简单的路径规划问题，我们可以用状态转移方程直接写出算法代码。</p><p>Java 实现：</p><pre><code>int getPathCount(int m, int n) {\n    int[][] dp = new int[m][n];\n\n    // 初始化状态\n    for (int i = 0; i &lt; m; i ++) { dp[i][0] = 1; } \n    for (int j = 0; j &lt; n; j ++) { dp[0][j] = 1; }\n\n    for (int i = 1; i &lt; m; i ++) { // 状态转移过程\n        for (int j = 1; j &lt; n; j ++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1]; // 输出答案\n}\n</code></pre><p>C++ 实现：</p><pre><code>int GetPathCount(int m, int n) {\n    int dp[m][n];\n\n    // 初始化状态\n    for (int i = 0; i &lt; m; i ++) { dp[i][0] = 1; }\n    for (int j = 0; j &lt; n; j ++) { dp[0][j] = 1; }\n\n    for (int i = 1; i &lt; m; i ++) { // 状态转移过程\n        for (int j = 1; j &lt; n; j ++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1]; // 输出答案\n}\n</code></pre><h2>带障碍的路径规划</h2><p>刚才讲到的路径规划问题，属于“简单”的路径规划，那在实际的面试中呢，往往不会那么简单。或者说，面试官会在你给出上述解答后，提高问题难度，然后再考察你的应变能力。</p><p>为了防止这种情况发生，同时也是学习动归必修的内容。现在，我们来看一看带障碍的路径规划问题该如何求解。</p><h3>算法问题分析</h3><p>问题：一个机器人位于一个 m * n 网格的左上角 （起始点在下图中标记为“开始” ）。机器人每次只能向下或者向右移动一步，现在机器人试图达到网格的右下角（在下图中标记为“结束”）。考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径？</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/72/6b23f87fedec91b2e27ca6935576ab72.png?wh=1311*622\" alt=\"\"></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><pre><code>示例：\n\n输入：\n[ \n  [0, 0, 0], \n  [0, 1, 0], \n  [0, 0, 0] \n]\n输出: 2\n解释：3 * 3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n</code></pre><p>显然，这个问题要比前面的问题复杂一些，在网格中加入了障碍物这一要素，也就是说有些格子是无法通行的，那么这个时候应该如何求解呢？</p><p>我们静下心来仔细想想，其实这个问题并没有产生本质变化。待求的子问题还是第 (m, n) 格子的不同路径总数。唯一的区别在于，其中一些格子有障碍物，无法通行。因此，对这些格子来说，其路径总数就是 0。</p><p>所以，重叠子问题、无后效性和最优子结构跟上一个问题是相同的。</p><h3>写出状态转移方程</h3><p>虽然基本的子问题没变，但是由于问题产生了变化，因此状态转移方程肯定会有所改变。</p><p>首先，我们还是确定<strong>初始化状态</strong>。依然先考虑网格的第一行和第一列，第一行永远只能从左侧的格子往前走；第一列永远只能从上方的格子往下走。由于我们只能向右或向下走，所以第一行和第一列的格子永远只能存在 1 条路径。但是，我们还需要再考虑那些有障碍的格子，对这些格子来说，它们的路径总数应该是 0 而不是 1。</p><p>由于该问题的基本计算规则没有发生变化。因此，<strong>状态参数</strong>依然是格子的行数和列数，我们只要知道了行数 $i$ 和列数 $j$ 就能知道这个格子的路径数量。</p><p>同理可得，状态存储空间依然是一个二维数组 <strong>$DP[i][j]$，表示第 $i$ 行、第 $j$ 列的路径数量</strong>。你可以参考上一个问题的表格，来加深对备忘录的理解。</p><p>好了，现在就是重头戏了，写出我们的<strong>状态转移方程</strong>。这个时候我们需要注意：对这些存在障碍的格子，它们的状态需要设为 0。为此，我们得到了以下状态转移方程：</p><p>$$DP(i, j)=\\left\\{\\begin{array}{c}<br>\n1,  &amp; i=0\\ and\\ j=0\\ and\\ u(i,j)=0 \\\\\\<br>\n0,  &amp; u(i,j)=1 \\\\\\<br>\nDP[i-1][j] + DP[i][j-1] &amp; otherwise<br>\n\\end{array}\\right.$$</p><p>从公式中可以得知，u(i, j) 表示格子 (i, j) 的编码：1 为有障碍物，0 为无障碍物。因此，当 u(i, j) 为 1 的时候，$DP[i][j] = 0$；否则的话，状态转移函数就跟上一个问题没有区别。</p><h3>编写代码进行求解</h3><p>写好状态转移方程后，我直接给出算法代码的实现。</p><p>Java实现：</p><pre><code>int getPathCountWithBlocks(int[][] v) {\n    int m = v.length;\n    int n = v[0].length;\n\n    int[][] dp = new int[m][n];\n\n    // 初始化状态\n    for (int i = 0; i &lt; m; i ++) { dp[i][0] = v[i][0] == 1 ? 0 : 1; }\n    for (int j = 0; j &lt; n; j ++) { dp[0][j] = v[0][j] == 1 ? 0 : 1; }\n\n    for (int i = 1; i &lt; m; i ++) { // 状态转移过程\n        for (int j = 1; j &lt; n; j ++) {\n            if (v[i][j] == 1) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    return dp[m - 1][n - 1]; // 输出答案\n}\n</code></pre><p>C++实现：</p><pre><code>int GetPathCount(const vector&lt;vector&lt;int&gt;&gt;&amp; v) {\n    int m = v.size();\n    int n = v[0].size();\n\n    int dp[m][n]; memset(dp, 0, sizeof(dp));\n\n    // 初始化状态\n    for (int i = 0; i &lt; m; i ++) { dp[i][0] = v[i][0] ? 0 : 1; }\n    for (int j = 0; j &lt; n; j ++) { dp[0][j] = v[0][j] ? 0 : 1; }\n\n    for (int i = 1; i &lt; m; i ++) { // 状态转移过程\n        for (int j = 1; j &lt; n; j ++) {\n            if (v[i][j]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    return dp[m - 1][n - 1]; // 输出答案\n}\n</code></pre><p>通过以上讲解，你会发现：即便原问题增加了障碍物，我们求解问题的基本思路也没怎么发生变化，只是在初始化状态时多考虑了一下有障碍物这种情况。</p><h2>跳跃游戏</h2><p>接下来我们看看求可行性问题（True或False），这是最后一类我们“可能”还未触及的动归问题。我为什么要说可能呢？这是因为我们完全可以通过问题的转化，将其他类型的问题转化成求可行性问题。</p><p>比如我们在早期讨论的硬币找零问题，当时我们要求的是：最少需要几枚硬币凑出总金额。但那个问题显然存在无法用硬币凑出解的情况（至于这种情况，原问题要求返回 -1）。因此，如果我们把原问题修改成：你能否用用最少的硬币凑出总金额？这样就变成了一个求可行性问题了。</p><p>当然，除了上述的情况外，有些面试题目也会直接提出求可行性的问题。对于这类问题，<strong>我们只需要知道某个问题是否可以被解决即可。</strong>既然说到这了，就让我们来看一下跳跃游戏这个常考的题目吧。</p><p>题目：给出一个非负整数数组 A，你最初定位在数组的第一个位置。数组中的每个元素代表你在那个位置可以跳跃的最大长度。判断你是否能到达数组的最后一个位置。</p><pre><code>示例1：\n\n输入：A = [2, 3, 1, 1, 6]\n输出： True\n解释: 我们可以先跳 1 步，从位置 0 到达位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n</code></pre><pre><code>示例2：\n\n输入：A = [4, 2, 1, 0, 0, 6]\n输出： False\n解释: 无论从开头怎么跳跃，你最多都只能到达位置 3 或位置 4，但这两个位置的最大跳跃长度是 0，所以你永远不可能到达最后一个位置。\n</code></pre><h3>算法问题分析</h3><p>这个问题其实很简单，每个数字表示了跳跃距离的可能性，这就涉及到了排列组合的问题。因此，我们可以考虑使用穷举来解该问题。但显然穷举不是一个好的面试问题的答案，因此，我们考虑使用动态规划来进行求解。</p><p>我们就按照动态规划的解题套路来分析一下，先来判断该问题是否满足动态规划特征。</p><ol>\n<li>重叠子问题：这个问题肯定存在重叠子问题，比如求能否到达 $i$ 和 $i-1$ 这两个位置，那么肯定都需要确定 $i-2$ 这个位置的答案。因此，必定存在重叠子问题；</li>\n<li>无后效性：该问题明显也无后效性，只有后续的子问题依赖于前面的子问题；</li>\n<li>最优子结构：该问题是否存在最优子结构呢？当我们在一个位置的时候，我们可以知道最远可以跳到什么位置。因此，如果我们想要知道能否到达位置 $i$，就需要逐个看前面的位置，判定能否从 $i-1$、$i-2$、$i-3$ … 的位置跳到位置 $i$ 上。然后，再看 $i-1$ 这个位置是否能够到达，因此肯定存在最优子结构。</li>\n</ol><p>好了，判断过后我们知道这个问题可以使用动态规划的状态转移方程来进行求解。现在，让我们来看一看如何写出这个状态转移方程吧。</p><h3>写出状态转移方程</h3><p>首先，我们要考虑<strong>初始化状态</strong>。这个问题的初始化状态就是 0 这个位置。因为这个位置是出发点，因此肯定可以到达，所以我们可以将其初始化成 True。而对其他位置，则可以根据状态转移方程来计算得出。</p><p>接着，<strong>状态参数</strong>也比较容易看出，只有数组的位置是变化的，因此状态参数就是当前位置 $i$。</p><p>由于只有一个状态参数，因此我们可以使用一维数组 <strong>$DP[i]$ 来表示能否从出发点到达位置 $i$</strong>。</p><p>那么，状态转移方程中的<strong>决策</strong>是什么呢？就像前面所说的，如果我们想要知道能否到达位置 $i$，就需要逐个看前面的位置，判定能否从位置 $i-1$、$i-2$、$i-3$ … 跳到位置 $i$ 上。然后，再看 $i-1$ 这个位置是否能够到达。</p><p>通过以上分析，我们就可以给出状态转移方程的定义了。</p><p>$$DP[i]=\\left\\{\\begin{array}{c}<br>\nTrue,  &amp; i = 0 \\\\\\<br>\n(DP[j] = true)\\ and\\ (max(A[j]+j) \\geq i),  &amp; i \\ne 0\\ and\\ j &lt; i \\\\\\<br>\n\\end{array}\\right.$$</p><h3>编写代码进行求解</h3><p>有了状态转移方程，求解代码也就不难了。按照惯例，我直接给出求解代码。</p><p>Java 实现：</p><pre><code>public boolean canJump(int[] nums) {\n    int n = nums.length;\n    if (n &lt;= 1) { return true; }\n\n    boolean[] dp = new boolean[n];\n    // 初始化状态\n    for (int i = 0; i &lt; n; i++) { dp[i] = false; }\n    dp[0] = true;\n\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) { // j &lt; i\n            if (dp[j] &amp;&amp; j + nums[j] &gt;= i) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    return dp[n - 1]; // 输出答案\n}\n</code></pre><p>C++ 实现：</p><pre><code>bool canJump(vector&lt;int&gt;&amp; nums) {\n      int n = nums.size();\n      if (n &lt;= 1) { return true; }\n\n      bool dp[n]; memset(dp, 0, sizeof(dp));\n      dp[0] = true; // 初始化状态\n\n      for (int i = 1; i &lt; n; i++) {\n          for (int j = 0; j &lt; i; j++) { // j &lt; i\n              if (dp[j] &amp;&amp; j + nums[j] &gt;= i) {\n                  dp[i] = true;\n                  break;\n              }\n          }\n      }\n\n      return dp[n - 1]; // 输出答案\n}\n</code></pre><h2>课程总结</h2><p>以上就是求方案总数类型问题，以及求可行性类型问题的解法了。</p><p>事实上，我们完全可以通过转化其它类型的问题，来得到求可行性类型的动态规划问题。比如说，在带障碍的路径规划中，我们求的是路径总数。但是，当我将题目改一下：问能否从起点移动到终点？这样就变成了求可行性的问题。</p><p>我们依然在遵循之前给出的动态规划解题模板来求解问题。首先，根据重叠子问题、无后向性和最优子结构来确定能否用动态规划解题。然后，再确定初始化状态、状态参数，接着确定状态存储数组（即备忘录），最终写出关键的状态转移方程。</p><p>一旦写出状态转移方程，我们的问题就解决掉一大半了。你可以按照这种思路，自己去尝试解决一些实际的面试问题，从而加深你对解题模板的利用和理解。过程中如果遇到困难，欢迎随时在留言区中提出。</p><h2>课后思考</h2><p>这节课我们学习了路径规划的解法，那么在带障碍的路径规划问题的基础上，我再为每条边设定一个长度（也就是不同格子之间行进的距离是不同的），此时该如何求出从起点到终点的最大长度呢？</p><p>欢迎留言和我分享你的答案，我会第一时间给你反馈。如果今天的内容对你有所启发，也欢迎把文章分享给你身边的朋友，邀请他一起学习！</p>","comments":[{"had_liked":false,"id":258357,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1604396891,"is_pvip":false,"replies":[{"id":"94422","content":"没有问题，很好，有时间可以多刷刷leetcode，给自己提出更高的要求。也可以参考14｜面试即正义第三期：刷题指南，熟能生巧～<br><br>有关于重叠子问题，在13｜动态规划算法设计的关键：最优子结构与状态依赖有更深入的讲解。对于图的解释，稍后会作出改进和更新。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1604900446,"ip_address":"","comment_id":258357,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14489298779","product_id":100060501,"comment_content":"带障碍的可行性那个题目在leetcode上要求打出路径，补一个带路劲的c++代码给有需要的小伙伴<br>&#47;&#47;leetcode:面试题 08.02. 迷路的机器人<br>class Solution {<br>public:<br>    vector&lt;vector&lt;int&gt;&gt; pathWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {<br>        &#47;&#47; 判断边界条件<br>        vector&lt;vector&lt;int&gt;&gt; res;<br>        int row = obstacleGrid.size();<br>        if(!row) return res;<br>        int col = obstacleGrid[0].size();<br>        if(!col) return res;<br>        if(obstacleGrid[0][0] == 1 || obstacleGrid[row -1][col -1] == 1) return res;<br>        &#47;&#47; 初始化边界条件<br>        int dp[row][col];memset(dp,0,sizeof(dp));<br>        dp[row-1][col-1] = 1;<br>        for(int i{row-2} ; i&gt;=0;i--) {&#47;&#47;初始化最后一列<br>            if(obstacleGrid[i][col-1] == 1) dp[i][col-1] = 0;<br>            else dp[i][col-1] = dp[i+1][col-1];<br>        }<br>        for(int i{col-2};i&gt;=0;i--) {&#47;&#47;初始化最后一行<br>            if(obstacleGrid[row-1][i] == 1) dp[row-1][i] = 0;<br>            else dp[row-1][i] = dp[row-1][i+1];<br>        }<br>        &#47;&#47;求路径<br>        for(int i{row-2};i&gt;=0;--i) {<br>            for(int j{col-2}; j&gt;=0 ;--j) {<br>                if(obstacleGrid[i][j] == 1) dp[i][j] = 0;<br>                else dp[i][j] = max(dp[i+1][j],dp[i][j+1]);<br>            }<br>        }<br>        if(dp[0][0] == 0) return res;<br>        int r{0},c{0};<br>        while(r != row-1 || c != col-1) {<br>            res.push_back({r,c});<br>            int down{0};&#47;&#47;内部变量不会默认初始化C++，一定要小心<br>            if(r &lt; row-1) down = dp[r+1][c];<br>            int right{0};<br>            if(c &lt; col-1) right = dp[r][c+1];<br>            if(down &gt;= right) r++;<br>            else c++;<br>        }<br>        res.push_back({row-1,col-1});<br>        return res;<br>    }<br>};<br><br>话说回来，感觉老师这个专利每篇质量不一啊，大部分都挺好，但背包问题那两讲，图画的有问题，备忘录，重叠子问题部分描述的有些晦涩，劝退了好多小伙伴啊，感觉把那两章重新写一哈，这个专栏的价值能翻一倍","like_count":4,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508631,"discussion_content":"没有问题，很好，有时间可以多刷刷leetcode，给自己提出更高的要求。也可以参考14｜面试即正义第三期：刷题指南，熟能生巧～\n\n有关于重叠子问题，在13｜动态规划算法设计的关键：最优子结构与状态依赖有更深入的讲解。对于图的解释，稍后会作出改进和更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604900446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114352,"avatar":"https://static001.geekbang.org/account/avatar/00/11/00/f0/fe94061e.jpg","nickname":"假装在养🐷","note":"","ucode":"D0AB9CD03E0D5B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576858,"discussion_content":"背包给看懵逼了，差点劝退了，从子数组开始，感觉又上道了，我觉得我又行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655816585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325454,"discussion_content":"完全背包的确是最困难的，我都看蒙了，看了隔壁数据结构与算法的方法，才找到点感觉。完全背包直接上递推公式的确跳跃有点大，如果能把递归讲讲，难度会稍微好点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605323575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252679,"user_name":"傻猫周大福","can_delete":false,"product_type":"c1","uid":2088255,"ip_address":"","ucode":"C3975AD7E7CA2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriazqrbvq8h7B9JfjmKF9xMB2fSxc9adVGoveQP0IMkDib6k4Jyb931icAWBUFp6MB25Eqbe0O9bvLg/132","comment_is_top":false,"comment_ctime":1602431138,"is_pvip":true,"replies":[{"id":"92677","content":"这个问题其实最好的方法不是递归，只是为了训练如何使用递归求解问题。能思考更好的解决方案是很好的！给你一个赞。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1602856321,"ip_address":"","comment_id":252679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10192365730","product_id":100060501,"comment_content":"为何不试试逆序遍历呢<br>func JumpGame(arr []int) bool {<br>\tindex := len(arr) - 1<br>\tfor i := index - 1; i &gt;= 0; i-- {<br>\t\tif i+arr[i] &gt;= index {<br>\t\t\tindex = i<br>\t\t}<br>\t}<br>\tif index == 0 {<br>\t\treturn true<br>\t}<br>\treturn false<br>}","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506834,"discussion_content":"这个问题其实最好的方法不是递归，只是为了训练如何使用递归求解问题。能思考更好的解决方案是很好的！给你一个赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602856321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252003,"user_name":"我是一把火","can_delete":false,"product_type":"c1","uid":2069916,"ip_address":"","ucode":"20E61D44CCD8AC","user_header":"","comment_is_top":false,"comment_ctime":1602050909,"is_pvip":false,"replies":[{"id":"92687","content":"没有问题，赞！<br><br>这道题目动态规划本身也不是最优方案，有很多的可优化之处。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1602856661,"ip_address":"","comment_id":252003,"utype":1}],"discussion_count":6,"race_medal":0,"score":"10191985501","product_id":100060501,"comment_content":"跳跃游戏题目，我尝试了一下只用一层for循环，dp[i]保存的是所能达到的最远位置，每次需要先判断一下可达的最远位置是否能够到当前位置。<br>def canJump(arr):<br>    dp = [0 for _ in range(len(arr))]<br>    dp[0] = arr[0]<br>    for i in range(1, len(arr)):<br>        if dp[i-1] &lt; i: return False<br>        dp[i] = max(dp[i-1], i + arr[i])<br>    return True","like_count":3,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506687,"discussion_content":"没有问题，赞！\n\n这道题目动态规划本身也不是最优方案，有很多的可优化之处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602856661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310875,"discussion_content":"我偷个懒，直接贴leetcode上别人的解法哈。（pad上手敲不方便）\n\nclass Solution:\n    def canJump(self, nums) :\n        max_i = 0       #初始化当前能到达最远的位置\n        for i, jump in enumerate(nums):   #i为当前位置，jump是当前位置的跳数\n            if max_i>=i and i+jump>max_i:  #如果当前位置能到达，并且当前位置+跳数>最远位置  \n                max_i = i+jump  #更新最远能到达位置\n        return max_i>=i\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602086726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351380,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9e/d4/c7b175bb.jpg","nickname":"lumiere","note":"","ucode":"BA42277B58BE3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343983,"discussion_content":"我也是这个思路，我想着这也算动归的思路啊！！！有重叠子问题，无后效性，最优子结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611225059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325452,"discussion_content":"我想了一会也是这个思路，还准备提问呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605323368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2088255,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriazqrbvq8h7B9JfjmKF9xMB2fSxc9adVGoveQP0IMkDib6k4Jyb931icAWBUFp6MB25Eqbe0O9bvLg/132","nickname":"傻猫周大福","note":"","ucode":"C3975AD7E7CA2A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311651,"discussion_content":"试试逆序遍历吧\nfunc JumpGame(arr []int) bool {\n\tindex := len(arr) - 1\n\tfor i := index - 1; i >= 0; i-- {\n\t\tif i+arr[i] >= index {\n\t\t\tindex = i\n\t\t}\n\t}\n\tif index == 0 {\n\t\treturn true\n\t}\n\treturn false\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602431155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2088255,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriazqrbvq8h7B9JfjmKF9xMB2fSxc9adVGoveQP0IMkDib6k4Jyb931icAWBUFp6MB25Eqbe0O9bvLg/132","nickname":"傻猫周大福","note":"","ucode":"C3975AD7E7CA2A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":325453,"discussion_content":"这个思路我也想过，但是没想通，哈哈，赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605323405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311651,"ip_address":""},"score":325453,"extra":""}]}]},{"had_liked":false,"id":287889,"user_name":"Jonathan","can_delete":false,"product_type":"c1","uid":1484965,"ip_address":"","ucode":"031E0DC776E8A0","user_header":"https://static001.geekbang.org/account/avatar/00/16/a8/a5/27466113.jpg","comment_is_top":false,"comment_ctime":1618209404,"is_pvip":true,"replies":[{"id":"104653","content":"只要有一个格子具有障碍物后面都是0，因为无法向上走。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1618411482,"ip_address":"","comment_id":287889,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1618209404","product_id":100060501,"comment_content":"带障碍物的不同路径中，初始化操作除了（0，0）位置是根据数组值进行判断，其他应该是根据上一个dp值进行判断吧。比如（0，1）位置是障碍物，那么（0，2）肯定就是0。因为没办法通过（0，0）走到（0，2）","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518455,"discussion_content":"只要有一个格子具有障碍物后面都是0，因为无法向上走。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618411482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1443589,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iamkqQRZFTAQgclRqskib3n860CStDuxq2aiaZO7EicDfLJwCdZ9gZiajhBoTNuFKH47DLKO5C4GHxukN5L1VOpcR6Q/132","nickname":"Geek_457f47","note":"","ucode":"B9EB1B46AA4D85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569792,"discussion_content":"文章，那个初始话，好像是有问题，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651556567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278597,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1613121239,"is_pvip":false,"replies":[{"id":"101318","content":"是的，这里代码需要修改，0代表有障碍，如果第一行或者第一列遇到了障碍，后面的应该都是算会遇到障碍。<br>感谢你指出问题，正文已修正。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1613370268,"ip_address":"","comment_id":278597,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613121239","product_id":100060501,"comment_content":"有障碍物的路径问题，老师的java版代码应该是有问题的，在leetcode上提交是失败的，在初始化那块有点问题，第一列只要存在障碍物，应该直接break出循环，第一行的初始化也一样<br>public int uniquePathsWithObstacles(int[][] obstacleGrid) {<br>        &#47;&#47; 行数<br>        int m = obstacleGrid.length;<br>        &#47;&#47; 列数<br>        int n = obstacleGrid[0].length;<br><br>        int[][] dp = new int[m][n];<br><br>        &#47;&#47; 初始化状态<br>        for(int i = 0; i &lt; m; i++) {<br>            dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : 1;<br>            &#47;&#47; 第一列只要出现障碍物，下面的肯定是0<br>            if(obstacleGrid[i][0] == 1) {<br>                break;<br>            }<br>        }<br>        for(int j = 0; j &lt; n; j++) {<br>            dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : 1;<br>            &#47;&#47; 第一行只要出现障碍物，后面的肯定是0<br>            if(obstacleGrid[0][j] == 1) {<br>                break;<br>            }<br>        }<br><br>        &#47;&#47; 状态转移方程<br>        for (int i = 1; i &lt; m; i++) {<br>            for (int j = 1; j &lt; n; j++) {<br>                if (obstacleGrid[i][j] == 1) {<br>                    dp[i][j] = 0;<br>                } else {<br>                    dp[i][j] = dp[i-1][j] + dp[i][j-1];<br>                }<br>            }<br>        }<br>        return dp[m-1][n-1];<br>    }","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515441,"discussion_content":"是的，这里代码需要修改，0代表有障碍，如果第一行或者第一列遇到了障碍，后面的应该都是算会遇到障碍。\n感谢你指出问题，正文已修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613370268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261404,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1605323627,"is_pvip":false,"replies":[{"id":"95666","content":"恩，学习的最好方法就是自己独立思考如何解决问题。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230858,"ip_address":"","comment_id":261404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605323627","product_id":100060501,"comment_content":"二刷，都是自己独立思考递推公式，找到感觉了，非常赞的专栏","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509474,"discussion_content":"恩，学习的最好方法就是自己独立思考如何解决问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259999,"user_name":"帽子狗","can_delete":false,"product_type":"c1","uid":2106663,"ip_address":"","ucode":"51596F366AF068","user_header":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","comment_is_top":false,"comment_ctime":1604904950,"is_pvip":false,"replies":[{"id":"95669","content":"其实DP也就是用更加朴素的思想来求解。当然数字一大直接计算组合数的确容易溢出。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230900,"ip_address":"","comment_id":259999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604904950","product_id":100060501,"comment_content":"第一个老数学题了， 机器人一定会走 m + n - 2 步，其中有 n - 1步往下走。<br>所以结果C((m+n-2), (n-1))。<br>不过计算组合数可能溢出，dp算是大数求组合数的防溢出方案吧。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509082,"discussion_content":"其实DP也就是用更加朴素的思想来求解。当然数字一大直接计算组合数的确容易溢出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251844,"user_name":"混混","can_delete":false,"product_type":"c1","uid":1360730,"ip_address":"","ucode":"5526B22ABDEB07","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcHOOqDpy7giaJQr3SNj3ZsmymdxBndTYv2uOEiaDGHUianG5ZpZyiasV70qRuqX4r5baZvqR0Ya6TUA/132","comment_is_top":false,"comment_ctime":1601904405,"is_pvip":false,"replies":[{"id":"92689","content":"如果考虑实现优化的确是这样。但是为了让初始化和后面的求解过程看起来清晰明了，所以这里在初始化就不做过多的延伸了。但是如果理解了动态规划的确可以做这种实现上的优化。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1602856765,"ip_address":"","comment_id":251844,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1601904405","product_id":100060501,"comment_content":"带障碍的路径问题中，初始状态，对应第一行或者第一列，出现一个障碍后，后面的路径是不是都应该为0，而不是只有障碍的地方是0？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506631,"discussion_content":"如果考虑实现优化的确是这样。但是为了让初始化和后面的求解过程看起来清晰明了，所以这里在初始化就不做过多的延伸了。但是如果理解了动态规划的确可以做这种实现上的优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602856765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2069916,"avatar":"","nickname":"我是一把火","note":"","ucode":"20E61D44CCD8AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310760,"discussion_content":"是的，第一行或第一列的某个位置上遇到障碍物后，后面的位置都应该是0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602038442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251793,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1601874683,"is_pvip":true,"replies":[{"id":"92690","content":"没有问题，赞。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1602856814,"ip_address":"","comment_id":251793,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601874683","product_id":100060501,"comment_content":"&#47;&#47;v[i][j] - i为行，j为列，值为0时表示此路不通，大于0时表示从上方或左方到达此点的长度<br>&#47;&#47; 0 &lt;= i,j &lt; 1000<br>&#47;&#47;0 &lt;= v[i][j] &lt; 1000<br>int getMaxPathLenWithBlocks(int[][] v) {<br>    int m = v.length;<br>    int n = v[0].length;<br><br>    int[][] dp = new int[m][n];<br><br>    &#47;&#47; 初始化状态<br>    for (int i = 0; i &lt; m; i ++) { dp[i][0] = v[i][0] == 0 ? 0 : i &gt; 0 ? dp[i-1][0] +  v[i][0]: v[i][0]; }<br>    for (int j = 0; j &lt; n; j ++) { dp[0][j] = v[0][j] == 0 ? 0 : j &gt; 0 ? dp[0][j-1] +  v[0][j]: v[0][j]; }<br><br>    for (int i = 1; i &lt; m; i ++) { &#47;&#47; 状态转移过程<br>        for (int j = 1; j &lt; n; j ++) {<br>            if (v[i][j] == 0) {<br>                dp[i][j] = 0;<br>            } else {<br>                dp[i][j] = Math.max(dp[i - 1][j],dp[i][j - 1]) + v[i][j];<br>            }<br>        }<br>    }<br><br>    return dp[m - 1][n - 1]; &#47;&#47; 输出答案<br>}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506612,"discussion_content":"没有问题，赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602856814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}