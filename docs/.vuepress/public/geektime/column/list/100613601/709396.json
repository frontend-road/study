{"id":709396,"title":"18｜被忽视的变量：带你全面认识JVM中的变量","content":"<p>你好，我是康杨。今天我们来重新审视一下JVM中的变量。</p><p>变量是我们操作JVM的最小单元，它在日常工作中很容易被忽略掉，而实际上它对内存管理和垃圾回收机制的影响很大。</p><p>深入地了解变量有助于我们理解强引用、弱引用和虚引用之间的区别以及对对象回收的影响，帮助我们更加灵活地使用Java内存模型，避免一些特殊情况下的内存泄漏和性能问题。而学会从不同的维度去认识变量，也是我们写出高性能的程序的基础。</p><h2>JVM中的变量</h2><p>这节课我们将通过一个实际的例子去了解JVM中的变量以及变量中的类型。</p><h3>静态类型和实际类型</h3><pre><code class=\"language-java\">Food food = new Fruit();\n</code></pre><p>作为一个变量food，它有一个静态类型和一个实际类型。静态类型是指变量最初被定义时的类型，而实际类型则是指变量所引用的对象的类型。当变量指向一个子类对象时，就有了多态的能力。让我们先看一下下面这段代码。</p><pre><code class=\"language-java\">class Food {\n&nbsp;&nbsp;&nbsp; public void eat() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"Eat some food\");\n&nbsp;&nbsp;&nbsp; }\n}\nclass Fruit extends Food {\n&nbsp;&nbsp;&nbsp; @Override\n&nbsp;&nbsp;&nbsp; public void eat() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"Eat some fruits\");\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; public void peel() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"Peel the fruit\");\n&nbsp;&nbsp;&nbsp; }\n}\nclass Main {\n&nbsp;&nbsp;&nbsp; public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Food food = new Fruit();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; food.eat();&nbsp; // 输出: Eat some fruits\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (food instanceof Fruit) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fruit fruit = (Fruit) food;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fruit.peel();&nbsp; // 输出: Peel the fruit\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><!-- [[[read_end]]] --><p>在这段代码中，我们有一个Food类和一个Fruit类，Fruit继承自Food。通过使用Food类型的变量来引用一个Fruit对象，我们可以实现多态。<br>\n现在，让我们来解读一下这段代码。变量food的静态类型是Food，但是它实际引用了一个Fruit对象。这意味着尽管food的外表是Food类型，但它能够调用Fruit类中的方法。</p><p>当我们调用 <code>food.eat()</code> 时，JVM根据food的实际类型决定调用的是Fruit类覆盖的eat方法，于是输出了 <code>Eat some fruits</code>。这就是多态的魔力，可以通过food的实际类型来决定执行的行为。</p><p>如果我们想调用Fruit类中特有的方法peel，我们需要进行类型转换。通过使用instanceof关键字来判断food是否实际引用了一个Fruit对象，如果是的话，就可以安全地将food转换为Fruit类型，然后调用peel方法。而JVM背后的实现原理，正是我们之前介绍的OOP-Klass模型和虚函数表。</p><p>在food背后，有一个与它对应的klass对象，它记录了food的类型信息，就像是有一个标签写着food的品类和特点。每个klass对象维护着一个虚函数表，记录了类中所有的虚函数以及对应的指针。当food调用一个方法时，JVM根据它的实际类型找到它的klass对象，然后在虚函数表中寻找正确的函数指针，使得food能够调用正确的方法。这种实现方式让我们具备了多态性，让它的行为可以根据实际情况进行适应。</p><p>多态是面向对象编程中非常重要的概念，它带来了代码的灵活性和可扩展性，让我们能够更好地应对不同的需求。</p><h2><strong>生存空间</strong></h2><p>在Java中，变量的创建位置有三个：栈上、堆中和方法区中。变量的生命周期不同，所以它们会被创建在不同的位置。</p><p>首先，栈上的变量是局部变量，包括方法中定义的变量和代码块中定义的变量。它们的生命周期与方法调用或代码块的执行周期相同。变量在栈上的创建非常快速，而且在方法或代码块执行结束后会自动销毁。在使用栈上的变量之前，必须显式地为其赋值。</p><p>接下来，堆中的变量是通过new关键字创建的对象和数组。它们的生命周期与对象或数组本身相同，当没有引用指向它们时，会被垃圾收集器回收。堆中的变量创建比较耗时，需要为对象或数组分配内存空间，并进行初始化。在对象创建时，成员变量会被赋予默认值。</p><p>最后，方法区中的变量主要是静态变量。它们的生命周期与类的生命周期相同，在类被加载时创建，在类被卸载时销毁。静态变量在方法区中创建并初始化，在使用之前已经具有默认值。</p><p>现在，我们来看一个示例代码。</p><pre><code class=\"language-java\">public class Food {\n&nbsp; &nbsp; private String name;\n&nbsp; &nbsp; private int quantity;\n&nbsp;\n&nbsp; &nbsp; public Food(String name, int quantity) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.name = name;\n&nbsp; &nbsp; &nbsp; &nbsp; this.quantity = quantity;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; public void eat() {\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"Eating \" + name);\n&nbsp; &nbsp; &nbsp; &nbsp; quantity--;\n&nbsp; &nbsp; }\n&nbsp;\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; Food food = new Food(\"Apple\", 5);\n&nbsp; &nbsp; &nbsp; &nbsp; food.eat();\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"Remaining quantity: \" + food.quantity);\n&nbsp; &nbsp; }\n}\n</code></pre><p>这个示例中，我们创建了一个Food类，它有一个name属性和一个quantity属性。在构造方法中，我们通过传入的参数对这两个属性进行赋值。eat()方法用于消耗食物，每次调用会令quantity减1。在main()方法中，我们创建了一个Food对象food，调用了它的eat()方法并打印剩余数量的代码。</p><p>在这个示例中，food对象是在堆中创建的，因为它是通过new关键字创建的。name和quantity属性是实例变量，会随着对象的创建而被初始化。quantity在每次调用eat()方法时会发生变化。在main()方法中，我们可以看到剩余数量被正确地打印出来。</p><p>希望通过这个示例，你能更好地理解变量的创建位置和初始化之间的关系。不同的变量在不同的位置创建，并且在相应的生命周期内进行初始化和销毁。了解这些概念对于理解JVM和Java程序的运行机制非常重要。</p><h2>回收</h2><pre><code class=\"language-java\">Food food = new Fruit();\n</code></pre><p>在这行代码中，创建了一个强引用 food，它指向了一个Fruit对象。强引用意味着只要food存在，即使内存即将耗尽，垃圾回收器也不会回收这个对象的内存。</p><p>接下来，我们详细解读一下不同类型引用的特性和使用场景。</p><h3>强引用（Strong Reference）</h3><p>强引用是最常见的引用类型，它的作用是让对象存活期与引用的存活期保持一致。只要存在强引用指向一个对象，无论JVM内存是否充足，该对象都不会被回收。在上面的代码中，food就是一个强引用，只要food存在，所指向的Fruit对象就不会被回收。</p><h3>软引用（Soft Reference）</h3><p>软引用是一种比较灵活的引用类型，它的作用是描述非必要对象。当JVM内存即将耗尽，也就是说OOM之前，垃圾回收器会将软引用对象列为可回收的对象范围，为程序提供更多可用空间。在实际应用中，软引用常用于缓存机制中，用来缓存一些大对象或者需要频繁创建销毁的对象。如果在代码中使用软引用，可以使用SoftReference类进行封装和管理。</p><p>软引用的使用示例：</p><pre><code class=\"language-java\">SoftReference&lt;Fruit&gt; food = new SoftReference&lt;&gt;(new Fruit());\nFruit fruit = food.get();\nif (fruit == null) {\n&nbsp;&nbsp;&nbsp; // 重新创建并赋值给fruit\n}\n</code></pre><h3>弱引用（Weak Reference）</h3><p>弱引用是相对于强引用的一种引用类型，强度较弱。如果一个对象只存在弱引用，且不存在强引用或软引用指向它，垃圾回收器在下一次进行垃圾回收时就会回收它。弱引用主要用于描述一些不是必需的对象，在强引用断开后该引用将不再持有对象。如果在代码中使用弱引用，可以使用WeakReference类进行封装和管理。</p><p>弱引用的使用示例：</p><pre><code class=\"language-java\">WeakReference&lt;Fruit&gt; food = new WeakReference&lt;&gt;(new Fruit());\nFruit fruit = food.get();\nif (fruit == null) {\n&nbsp;&nbsp;&nbsp; // 对象已被回收，需要重新创建并赋值给fruit\n}\n</code></pre><h3>虚引用（Phantom Reference）</h3><p>虚引用是引用强度最弱的引用类型，它与其他引用类型略有不同。定义虚引用后，无法通过虚引用获取所指向的对象，并且虚引用对象无法直接使用。虚引用主要用于在对象被回收时收到通知，用于执行一些清理工作或记录相关日志。在代码中使用虚引用需要配合ReferenceQueue类进行管理。</p><p>虚引用的使用示例：</p><pre><code class=\"language-java\">ReferenceQueue&lt;Fruit&gt; queue = new ReferenceQueue&lt;&gt;();\nPhantomReference&lt;Fruit&gt; food = new PhantomReference&lt;&gt;(new Fruit(), queue);\n// 执行一些清理工作或记录相关日志\n</code></pre><h3>注意事项</h3><ol>\n<li>\n<p>引用类型的选择要根据实际需求来决定，根据对象的重要性和特点来选择合适的引用类型。</p>\n</li>\n<li>\n<p>在使用软引用和弱引用时，需要注意空指针异常，因为调用get()方法时可能返回null值。</p>\n</li>\n<li>\n<p>虚引用一般用于特殊情况下的对象管理，不常用于普通业务逻辑中。</p>\n</li>\n</ol><p>这就是关于引用类型的详细介绍和使用示例。根据不同场景需求，选择不同的引用类型可以更有效地管理内存，提高程序性能。</p><h2>变量的本质</h2><pre><code class=\"language-java\">&nbsp;Fruit fruit = new Fruit();\n</code></pre><p>我们回到这段代码，这次让我们从编程范式的视角来重新审视这段代码。</p><p>命令式编程和声明式编程一个非常大的区别，其实就是变量。命令式中的变量代表着运行时中内存的状态，而声明式的变量则是表达式的别名。我们首先了解下状态的内涵。</p><p>状态是指程序中的各种变量、对象和数据的集合，而这些变量、对象和数据的值会随着程序的执行而发生变化。在命令式编程中，我们通过改变变量的值来改变程序的状态，因此需要一步一步地指示程序应该如何执行。</p><p>而在声明式编程中，我们更关注所需达到的结果，而不是每一步应该如何执行。声明式编程更注重描述问题的“是什么”，而不是解决问题的“如何”。</p><p>现在让我们通过一个例子来说明这个区别。假设我们有一个函数food，它承载了一个特定类型的操作。我们假设food声明为 <code>Supplier&lt;Food&gt; food = () -&gt; new Fruit();</code>。</p><p>在命令式编程中，我们会关注如何创建一个Fruit对象并将其赋值给food变量。我们会告诉计算机具体的步骤，就是使用 <code>new Fruit()</code> 来创建一个Fruit对象，并将其赋值给food变量。这是一种以指令为基础的编程方式，就是告诉计算机应该如何执行。</p><p>然而，在声明式编程中，我们更关注食物对象应该具备什么特性，而不是如何创建它。我们声明food是一个供应商类型的变量，并使用Lambda表达式定义这个供应商，返回一个新的Fruit对象。具体的创建过程则由编程环境和运行时系统自动完成。这种方式更注重描述问题，而不是具体的实现步骤。</p><p>接下来，让我们补充完整代码，并提供一些最佳实践和注意事项。</p><pre><code class=\"language-java\">import java.util.function.Supplier;\n&nbsp;\npublic class Main {\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; // 使用命令式编程创建一个Fruit对象并赋值给fruit变量\n&nbsp; &nbsp; &nbsp; &nbsp; Fruit fruit = new Fruit();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 使用声明式编程创建一个返回Fruit对象的供应商并赋值给food变量\n&nbsp; &nbsp; &nbsp; &nbsp; Supplier&lt;Food&gt; food = () -&gt; new Fruit();\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; // 进行一些操作，例如调用供应商返回的对象\n&nbsp; &nbsp; &nbsp; &nbsp; Food newFood = food.get();\n&nbsp; &nbsp; &nbsp; &nbsp; String foodName = newFood.getName();\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"我有一个\" + foodName);\n&nbsp; &nbsp; }\n}\n&nbsp;\ninterface Food {\n&nbsp; &nbsp; String getName();\n}\n&nbsp;\nclass Fruit implements Food {\n&nbsp; &nbsp; public String getName() {\n&nbsp; &nbsp; &nbsp; &nbsp; return \"水果\";\n&nbsp; &nbsp; }\n}\n</code></pre><p>在这个示例代码中，我们使用命令式编程和声明式编程的方式分别创建了一个Fruit对象并赋值给对应的变量。注意，在声明式编程中，我们不需要指定对象创建的具体步骤，只需定义一个返回Food类型的对象的供应商，并将其赋值给变量。然后我们可以通过调用供应商获取对象的方法来对变量进行操作。</p><h2>重点回顾</h2><p>变量有两个重要的属性：静态类型和实际类型。静态类型是变量最初定义时的类型，而实际类型则是所引用对象的类型。利用多态的特性，我们可以通过一个父类类型的变量来引用子类的对象。</p><p>在内存管理方面，我们可以使用不同的引用类型，比如强引用、软引用、弱引用和虚引用。强引用是最常见的，只要一个对象被强引用指向，这个对象就会一直存活。软引用和弱引用则用于描述非必要对象，可以在内存紧张时被回收。虚引用是一种引用强度最弱的引用类型，一般用于对象回收通知和执行清理工作。</p><p>另外，我们还可以区分命令式编程和声明式编程的方式。命令式编程关注如何执行任务，而声明式编程关注我们想要达到的结果。在声明式编程中，变量是表达式的别名，更注重问题的描述而不是具体的实现步骤。</p><p>通过理解这些概念，我们可以更好地理解变量的静态类型和实际类型之间的关系、多态的原理、不同引用类型的特点和用途，以及命令式编程和声明式编程的区别。这样的认知可以改善我们的编程技能和思维方式，并且更好地理解Java程序的运行机制（特性）。</p><h2>思考题</h2><p>学而不思则罔，学完这节课之后，我给你留两个问题。</p><ol>\n<li>什么是变量的静态类型和实际类型？</li>\n<li>我们还可以从哪些视角来看待Java中的变量？</li>\n</ol><p>希望你认真思考，然后把思考后的结果分享到评论区，我们一起讨论，如果有收获的话，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p><h2>💡点亮你的知识框架图</h2><p><img src=\"https://static001.geekbang.org/resource/image/2d/06/2d2f6f55ef11fe50f62cb229af7f2806.jpg?wh=5703x4070\" alt=\"\"></p>","neighbors":{"left":{"article_title":"17｜偷龙转凤：JVM中的扩展之道","id":707960},"right":{"article_title":"19｜云时代的线程模型：领略线程与虚拟线程的风采","id":711840}},"comments":[{"had_liked":false,"id":382158,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"广东","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1696809867,"is_pvip":false,"replies":[{"id":140214,"content":" 你的理解有一定道理。实际上，声明式编程是一种更高级别的抽象，它强调的是“做什么”，而非“怎么做”。而命令式编程则是具体制定了执行步骤，告诉计算机“怎么做”。\n在声明式编程中，我们只需要描述我们想要什么，而不需要详细描述如何得到它。这种编程方法抽象了很多底层细节。比如SQL就是一种典型的声明式语言，在编写SQL查询时，我们并不需要关心数据库如何寻找或排序数据，只需声明我们想要什么样的结果。\n而在命令式编程中，我们一步步告诉计算机如何完成任务，每一步都必须详细描述。大部分编程语言，像C，Python，Java等都属于这种类型。\n当然，为了实现声明式编程的语言或框架，背后往往需要命令式编程做支撑，所以你可以说声明式编程封装了命令式编程。但这样的封装为我们的编程指明了更清晰的目标，并且能够让我们的代码更易读和简洁，这是其价值所在。而声明式与命令式区别，也可以看成是阿隆佐邱奇和图灵的区别，建议你看一下https:&#47;&#47;www.yinwang.org&#47;blog-cn&#47;2013&#47;07&#47;13&#47;church-turing","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1700637012,"ip_address":"北京","comment_id":382158,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"感觉，声明式编程就是封装了一下命令式编程而已","like_count":2,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632293,"discussion_content":" 你的理解有一定道理。实际上，声明式编程是一种更高级别的抽象，它强调的是“做什么”，而非“怎么做”。而命令式编程则是具体制定了执行步骤，告诉计算机“怎么做”。\n在声明式编程中，我们只需要描述我们想要什么，而不需要详细描述如何得到它。这种编程方法抽象了很多底层细节。比如SQL就是一种典型的声明式语言，在编写SQL查询时，我们并不需要关心数据库如何寻找或排序数据，只需声明我们想要什么样的结果。\n而在命令式编程中，我们一步步告诉计算机如何完成任务，每一步都必须详细描述。大部分编程语言，像C，Python，Java等都属于这种类型。\n当然，为了实现声明式编程的语言或框架，背后往往需要命令式编程做支撑，所以你可以说声明式编程封装了命令式编程。但这样的封装为我们的编程指明了更清晰的目标，并且能够让我们的代码更易读和简洁，这是其价值所在。而声明式与命令式区别，也可以看成是阿隆佐邱奇和图灵的区别，建议你看一下https://www.yinwang.org/blog-cn/2013/07/13/church-turing","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700637013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386878,"user_name":"ple","can_delete":false,"product_type":"c1","uid":1120057,"ip_address":"浙江","ucode":"E1C4519C325994","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/39/3274257b.jpg","comment_is_top":false,"comment_ctime":1705770794,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"这儿表达有些误解，Java8以后文中的静态变量存储在堆上。https:&#47;&#47;openjdk.org&#47;jeps&#47;122","like_count":3},{"had_liked":false,"id":385637,"user_name":"八宝","can_delete":false,"product_type":"c1","uid":1324501,"ip_address":"河南","ucode":"89D991A930FDEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/35/d5/17833946.jpg","comment_is_top":false,"comment_ctime":1703030720,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100613601,"comment_content":"我们还可以从哪些视角来看待 Java 中的变量？\n从线程安全的角度看，常量天生安全，那么我们用的最多的变量呢？\n1.方法区创建的变量（既静态变量），并发访问时会存在线程安全问题，需要加锁来保证数据的正确性。\n2.堆中创建的变量，如果不存在逃逸现象，不存在跨线程使用，不需要考虑线程安全；\n涉及到多线程访问，如 HashMap 等容器的并发 put，就要加锁或改用线程安全的容器。\n3.如果在栈上创建的变量，生命周期都是方法内，随着方法的执行，出栈就会被回收，不需要考虑线程安全。","like_count":0}]}