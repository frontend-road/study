{"id":523160,"title":"22｜微服务拆分（二）：三招搞定数据库表解耦","content":"<p>你好，我是姚琪琳。</p><p>上节课，我们学习了微服务拆分之初，需要搭建好的两个基础设施，一个是基于开关的反向代理，另一个是数据同步机制。有了这两个设施做保障，接下来就可以大刀阔斧地一一拆解了。</p><p>除此之外，我们还讲了如何用API来取代代码依赖。你可能已经发现了，这个实践与其说是解决了对于单体代码的依赖，不如说是解决了对于单体数据库的依赖。</p><p>诚然，对于保险系统以及大多数这种数据密集型系统来说，所有的操作最终都将体现到数据库上。在这类系统的改造过程中，最不好解决的问题莫过于数据库表的解耦了。</p><p>这种面向数据库编程在21世纪初的国内是十分流行的，像Delphi、VB等都提供了很方便的数据库连接组件，而PowerBuilder更是推出了可以直连数据库的DataWindow，将数据的访问和展示耦合在了一起。</p><p>在这样的大背景下，将所有逻辑都放在客户端组件的Smart UI模式，以及将业务逻辑和数据访问逻辑混杂的“事务脚本模式”为什么如此流行，也就不难理解了。然而随着业务的发展，这种模式的弊病也越来越明显，很多团队都意识到了这个问题并着手解决。但在遗留系统中，这样的代码还是随处可见。</p><p>在微服务拆分的过程中，如何界定数据库表的所有权，进而拆分给不同的服务，就成了最为棘手的工作。这节课我们一起继续探索遗留系统的改造实践，按照从易到难的顺序，分别学习三种行之有效的方法，帮你搞定数据库表的解耦。</p><!-- [[[read_end]]] --><h2>第一招：用API调用取代连表查询</h2><p>在<a href=\"https://time.geekbang.org/column/article/522486\">上一节课</a>的代码示例中，我们分别用PolicyDao和UnderwriteApplicationDao去查询保单和核保申请数据，再组合成我们需要的核保申请数据并返回。</p><p>然而，在大多数遗留系统中，模块对于数据的所有权边界往往是很模糊的，也就是说，在任何模块中都可以随意访问本属于其他模块的数据。</p><p>所以，对于这样的代码，真实情况往往是这样：使用一个连表查询，一次性查出所有想要的数据。</p><pre><code class=\"language-java\">// 核保服务中的代码 - UnderwriteApplicationService.java\npublic UnderwriteApplicationDto getUnderwriteApplication(long policyId) {\n  UnderwriteApplicationDao underwriteApplicationDao = new UnderwriteApplicationDao();\n  UnderwriteApplicationModel underwriteApplicationModel = underwriteApplicationDao.getUnderwriteApplication(policyId);\n  return getUnderwriteApplicationDto(underwriteApplicationModel);\n}\n\n// 核保服务中的代码 - UnderwriteApplicationDao.java\npublic UnderwriteApplicationModel getUnderwriteApplication(long policyId) {\n  String sql = \"SELECT * FROM TBL_UNDERWRITE_APPLICATION UC, TBL_POLICY P WHERE UC.POLICY_ID = P.ID AND P.ID = :policyId\";\n  return executeSqlAndConvertToUnderwriteApplicationModel(sql, policyId);\n}\n</code></pre><p>注意，我们忽略了具体的执行SQL语句的框架，它可能直接使用了JDBC，也可能使用了MyBatis，这并不是重点。重点是如何拆分这样一个SQL语句。</p><p>在这条SQL语句中，TBL_UNDERWRITE_APPLICATION是指核保申请所对应的表，显然它应该属于核保数据库，而TBL_POLICY是保单所对应的表，应该留在单体库中。</p><p>怎么拆分呢？其实要拆分这样的连表查询并不难，我们的方案和上节课处理代码依赖问题采用的方法类似，也是通过API的方式来替换。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/db/8c56234086125ce90d29f755c87e2bdb.jpg?wh=1920x1263\" alt=\"图片\"></p><p>具体来说仍然是三步走，即调自己、调服务、组数据。最终的代码也几乎与解决代码依赖的方案一样，这里就不重复说了，你可以回顾第二十一节课。</p><p>用API调用取代连表查询和上节课的用API调用取代代码依赖，都用到了两种前面学到的模式，分别是改造老城区的<strong>变更数据所有权模式</strong>，和建设新城区中的<strong>数据库包装服务模式</strong>。</p><p>在核保服务和单体服务的分权之争中，开发人员作为裁判做了这样一件事儿：把保单数据的访问功能从核保服务那里剥离出来，核保服务不再拥有这部分数据的所有权，而是转给单体服务。</p><p>当然了，在现阶段拆分出来的数据，会暂且放在统一的数据API中，至于到底划到单体中哪个模块，不是我们现阶段应该关注的。这里为了变更数据所有权，我们采用把数据库封装为API的方式。获取保单数据的API仅仅是个提供数据库数据的接口，不包含任何业务逻辑。</p><p>到这里，简单的数据解耦我们就能轻松应对了。但遗留系统的代码千奇百怪，各种数据库表的连表查询更是百怪千奇，接下来咱们就来迎战更高难的复杂查询。</p><h2>第二招：为复杂查询建立单独的数据库</h2><p>下面这张图是我从一个真实的遗留系统中提取出来的SQL语句，我对具体的内容做了模糊处理，但重要的是了解它的长度和复杂度。</p><p><img src=\"https://static001.geekbang.org/resource/image/51/9e/51e1ea23177d429d794a75d736d7b29e.jpg?wh=1920x3324\" alt=\"图片\"></p><p>这种复杂查询在遗留系统中屡见不鲜，我甚至在有的项目中遇到过需要十几张A4纸才能完整打印的SQL语句。</p><p>如果非要硬来，对上面这种复杂SQL也用API调用来替换，那成本和风险都是相当高的，而且有些甚至是做不到的。比如有些查询会把分页逻辑也写在SQL语句里，但如果WHERE条件中包含单体服务中的表，把这个依赖转换成API查询，然后在内存中再去过滤，分页就会乱掉。</p><p>那么对于类似这样的复杂查询应该如何处理呢？你可以针对这样的查询，提取一个单独的查询数据库出来。</p><p><img src=\"https://static001.geekbang.org/resource/image/70/20/70f66ee0ccf812282b18yy7fa1382f20.jpg?wh=1920x1260\" alt=\"图片\"></p><p>我们新建一个独立的数据库，把核保和单体数据库中的数据都同步到这个数据库中，核保服务可以直接连接到该库中进行查询操作。由于该库包含了查询所需的全部表，因此SQL语句甚至不需要做任何修改，只需要区分查询和修改数据库的连接地址就可以了。</p><p>这样在一定程度上还实现了<strong>读写分离</strong>。在未来剥离单体服务中对于核保表的依赖时，也可以让单体服务访问查询数据库。以后再从单体中继续剥离其他服务时，也同样可以复用这个库，可谓一举多得。</p><p>有同学可能会问，多个微服务共享一个数据库，这不是典型的反模式吗？注意这里我们共享的并不是业务数据，而是查询数据，是只读的。它并不需要独立演进。</p><p>比如如果单体库独立进行了修改，并且不需要让核保服务知道，查询库就不需要跟着修改，反之亦然。而如果单体库的修改需要通知核保服务做出相应的修改，可能就需要同时修改查询库，并且重新部署，这也是很正常的情况，因为反正都需要重新部署核保服务。</p><p>最重要的是，我们通过新的、单独的查询数据库，极大地降低了认知负载，再也不需要去修改复杂的SQL语句了。回顾一下第十五节课的内容，这其实就是<strong>报表数据库模式</strong>。</p><h2>第三招：冗余数据</h2><p>除了单独的查询数据库，还有一种方式是将复杂查询所用到的数据，都冗余到核保库中。这样，复杂SQL仍然不需要做修改，改造的成本也非常低。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/e0/132f74cc8a437d3d47e3ac78cca2dbe0.jpg?wh=1920x1303\" alt=\"图片\"></p><p>都有哪些数据需要冗余到核保服务中呢？表面上看，是核保服务中，所有查询SQL中所涉及到的表和字段的并集。不过实际上，我们应该先把这些表和字段分类，对不同的类别采取不同的处理策略。</p><h3>快照数据的冗余</h3><p><strong>第一种类型是快照数据</strong>。快照数据是指那些只关心数据当时的状态，而不关心数据后续变化的场景。我们可以把这类数据存储（或缓存）在消费端，一方面需要这些数据的时候就不需要远程获取了，提升了性能，另一方面当远程服务宕机的时候，也不至于影响消费端服务。</p><p>关于这类数据，我们最常见的就是微信头像更新。你一定发现了，在点击好友头像的时候会更新一下头像，平时我们看到的都是他以前用的头像，这个头像就是本地存储的一个快照。</p><p>平时我们聊天和视频，头像是否是最新的我们并不关心，等到点击头像的时候再更新，我们也不会觉得有啥问题。相反，如果一定要保持头像的实时更新，对每一个手机客户端来说，都是非常严重的资源消耗。</p><p>遗留系统中其实也存在类似的数据。比如每个核保申请都有一个核保员对其进行核保。假设某个核保员叫张三，后来改名为李四，我们是希望由他核保的历史核保申请信息上，显示的仍然是张三，还是改名后的李四呢？如果仍然可以显示张三，那么我们就说核保申请上的核保员姓名这个信息，可以存储为快照数据。</p><p>按照大多数遗留系统的设计，核保申请表上存储的就是员工表的主键。当员工（核保员也是员工，因此信息存储在员工表里）改名后，连表查出来的员工姓名肯定会发生改变。我们在做服务拆分的时候，可以用API调用来取代这个连表查询，从而得到员工的新姓名。</p><p>但当查询极其复杂，无法用API调用来取代的时候，你就可以回过头来想想，某个核保申请上的核保员姓名，是否必须是最新的，是否可以仅存一份快照数据而没必要更新。</p><p>冗余数据放在哪？我们有两种处理方法。</p><p>第一种方法是冗余到主表上。比如核保申请表上本来存储的是员工主键，现在可以增加一列姓名。在创建核保申请时，同时插入员工的主键和姓名。在查询时，不通过员工主键连表查询员工表，而是直接查出姓名。采取这种方法时，需要对原有SQL进行少量修改。</p><p>第二种方式是冗余到新表中。有时候要冗余的某张表的字段会很多，比如除了员工姓名，可能还需要员工号、员工级别、员工所在分公司等。</p><p>除此之外，还包括申请核保的员工信息、保单的投保人信息、被保人信息等等。如果这些字段都冗余到主表，就会喧宾夺主，关注点不聚焦。因此我们可以把这些字段分别冗余到不同的新表中。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/9b/500da652ddc9b91a6e85c3a6d1d36d9b.jpg?wh=1920x829\" alt=\"图片\"></p><p>值得注意的是，新表的名称应该根据业务去命名，而不能跟原表的名称一样。像申请人、核保员都来自原来的员工表，我们没有办法在核保库中建一个员工表，来解决这两份数据的快照。</p><p>因此我们要建一张核保申请人表，一张核保申请核保员表，分别来存储申请人和核保员的快照数据。在快照表中，不再像原表那样以员工ID为主键，而应该以核保表的主键为主键，将原来的一对多关系改为一对一。采取这种方法时，原有SQL的改动就更少了，可能只需要改一下表名。</p><h3>业务数据的冗余</h3><p><strong>第二种需要冗余的数据是业务数据</strong>。业务数据与快照数据不同，它的变化会影响到当前业务，因此不能按快照进行冗余。比如被保人的年龄在申请的时候填错了，进行了修改，如果还是以快照数据来存储，在核保服务中就无法得到新的年龄，就会得出不同的核保结论。</p><p>因此对于冗余到核保库中的业务数据，必须进行同步，以得到最新值。同步方式可以参见第二十一节课的内容。</p><p>在实际项目中，必须与业务人员一起讨论哪些数据是快照数据，哪些数据是业务数据。这一点开发人员是决定不了的，必须由业务人员来决定，但开发人员可以给出一些建议。比如业务人员在得知要将核保员姓名改成快照的时候，他们和开发人员之间很可能会发生这样的对话：</p><p>业务人员：系统使用了很多年，都是随时可以查出最新的核保员姓名，这么改不符合业务（注意这里可能并不是真正的业务，而是软件系统培养出来的操作习惯，开发人员要善于捕捉这一点）。</p><p>开发人员：那我们想想在纸质办公时代，核保员就是在核保申请上签个字或盖个章，证明是他操作的核保申请。这个签章其实就是快照，他当时叫什么名字，签章就是什么名字，以后改名了当时的签章也不会变了，不是吗？</p><p>业务人员若有所思：……</p><p>开发人员趁热打铁：所以快照才是真正符合业务的，对吗？</p><p>业务人员：纸质时代签名盖章很可能是无奈之举，我们引入软件系统不就是为了带来这些便利吗？而且像报表之类的功能，比如按核保员名称去查询他所核保的所有核保申请，如果改名了就查不出来了，会非常不方便。</p><p>开发人员：您说的很有道理，报表这里我们会特殊处理以满足功能，但是在当前这个复杂查询的场景里，我们是否可以只查出当时的快照呢？</p><p>业务人员：可以吧……</p><p>这当然是一个假想的偏理想化的对话情景，真实的情况下要想说服业务人员可能相当困难，因为看问题的视角不同。但也是非常值得去尝试的，因为一旦存储成快照数据，的确会给服务拆分带来极大的便利，显著地降低认知负载。</p><p>注意，以上两种类型的数据，我们都只需要冗余我们用到的字段，不需要的字段就没必要冗余了。</p><p>在第一次创建主表数据（即核保申请）的时候，我们可以连带着把所要冗余的快照数据和业务数据，一起插入到核保库的相应表中。当业务数据发生变化的时候，再通过同步机制将其同步到核保库中。</p><h3>参考数据的冗余</h3><p><strong>第三种需要冗余的数据是参考数据</strong>，即Reference Data。参考数据是指那些对其他数据进行分类的数据，如国家的名称和缩写（如CHN、USA等）、机场的三字码（如PEK、DAX等）、货币代码（如CNY、USD等）。这些数据都是静态不变，或变化很慢的数据，因此也有人称之为静态数据。</p><p>在单体的遗留系统中，这类参考数据往往存储在单体的数据库或配置文件中，只有单体服务可以访问到。在从单体向外拆分微服务的时候，这类参考数据也是需要冗余的，否则拆分出来的服务就无法使用了。</p><p>不管参考数据存储在数据库还是配置文件中，我们都可以直接在新服务中也创建一份，直接使用即可。这是认知负载最低的解决方案。如果由于某种原因导致参考数据发生了变化，直接在两个库或配置文件中都进行修改就可以了，毕竟这种情况发生的概率很低，没有必要在它们之间建立同步机制。</p><p>当然更理想的方式是将参考数据加载到缓存中，供多个服务使用，这样就没有必要冗余了。如果遗留系统原来就是这么做的，当然可以直接复用。但如果不是，就没有必要非按照理想的方式来，毕竟这需要额外的工作量。</p><p>我们在遗留系统现代化的过程中，要切忌这种发散式的思维方式。本来目标是服务拆分，结果却引入了参考数据治理这个新的任务，导致工作不聚焦，工作范围扩大。</p><h2>小结</h2><p>今天的内容讲完了，我们做个总结。</p><p>我为你梳理了一张表格，对比了拆分查询SQL的三种方案，以及上面没有提到的一些优势和不足。你可以结合自己的实际需求，对照表格选择更合理的方案。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/f2/9cdaf73cd4072290b70336d2c6ec91f2.jpg?wh=1920x886\" alt=\"图片\"></p><p>上面我们介绍的解耦数据库表的方法都是基于查询的SQL，对于INSERT、UPDATE和DELETE的SQL，我们也可以用API调用来取代，这里就不详细介绍了。</p><h2>思考题</h2><p>感谢你学完了今天的课程，今天的思考题是这样的：假设我们要将员工信息冗余到核保服务的数据库中，以下两种方式各有哪些优缺点呢？他们所对应的SQL语句有什么区别？</p><p>方案一：</p><p>TBL_UNDERWRITE_APPLICATION（核保申请表）</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/7d/9ffd7afd512559c6dea84323f7b8147d.jpg?wh=1920x698\" alt=\"图片\"></p><p>方案二：</p><p>TBL_UNDERWRITE_APPLICATION（核保申请表）</p><p><img src=\"https://static001.geekbang.org/resource/image/44/5d/44638231df64d762736bf1e22cca9b5d.jpg?wh=1920x847\" alt=\"图片\"></p><p>TBL_EMPLOYEE（员工表）</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/0a/a3ee3113a531144651738824ccb7e00a.jpg?wh=1920x712\" alt=\"图片\"></p><p>欢迎你在留言区跟我交流互动。如果你身边有朋友遇到解耦数据库表的困惑，也推荐你把这节课分享给他。</p>","neighbors":{"left":{"article_title":"21｜微服务拆分（一）：迈出遗留系统现代化第一步","id":522486},"right":{"article_title":"23｜微服务拆分（三）：如何拆分存储过程？","id":523851}},"comments":[{"had_liked":false,"id":347402,"user_name":"Williamleelol","can_delete":false,"product_type":"c1","uid":1019105,"ip_address":"","ucode":"4C9379D25AEC09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erD8CwHKGGIia1HwRBxy5GxMLTfGGzOeLjrmZ6ich9Ng7bbPia89iaSibbldnV4uiaKNXFcO2vQ3ztibCrDw/132","comment_is_top":false,"comment_ctime":1653990630,"is_pvip":false,"replies":[{"id":126772,"content":"你好，这是一个非常好的问题，为了更准确地回答，我特意咨询了一下我的前同事，现腾讯云的Serverless专家架构师杨政权，以下是他的回答：\n\nFaaS解决的问题：FaaS平台的特点是更精细的资源分配、更精确的计费粒度、低运维成本以及弹性伸缩的能力，在我来FaaS主要解决两个问题：\n\n1）企业的IT投资分配问题：FaaS属于Serverless的一个分支，对于大部分企业来说，尤其是成长期的SMB企业，运维一个K8S集群、虚拟机集群或者IDC并不会带来核心竞争力的提升，通过Serverless提供的低运维成本的方案，降低企业在基础运维、资源调度等方面的成本，从而把更多的IT投资分配到那些核心的业务能力提升上\n2）传统容量预测的矛盾问题：资源准备的太多导致利用率多，资源准备的太少又可能会影响线上业务，FaaS这种跟随请求量进行主动扩容的模式让「准备的资源」和「实际所需的资源」尽量贴合；所以更适合的通常也是矛盾最突出的场景，那些业务有波峰波谷、量级难以预测，同时业务又对于实时性有较高要求的业务场景，如电商大促、批量的音视频处理、服务端渲染SSR 等\n\nFaaS的粒度：一个好的FaaS应用设计应该可以充分地利用平台所提供的优势\n\n1）通过业务的逻辑拆分分离特定的业务，代码体积、内存消耗和应用初始化时间降低，从而获得更快速的弹性扩容，提升该业务场景的吞吐量；和微服务类似，拆分之后在编程语言和技术栈的选择上也会更加灵活。\n2）但是正如您所说，过度的拆分的确会带来新的问题，2019年Thoughtworks技术雷达就提出「Lambda pinball」的概念，并放到了On Hold的位置，过度的FaaS拆分很容易陷入构建分布式单体的陷阱中，还会导致冷启动过多的问题，降低FaaS实例的复用率。在拆分的时候仍然需要关注业务逻辑的内聚性，让每一个FaaS包含一个相对完整的应用场景，在逻辑边界的基础上进行物理边界的优化，通过Faas的实际运行消耗，如冷启动速度、内存闲置情况、实例并发数等指标进行优化。\n3）目前FaaS的应用设计还缺少成熟的方法论支持，最佳的方式还是通过实际的运行结果，结合业务场景的要求进行实际压测，然后观察性能、成本和平台指标进行针对性的优化。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1654418713,"ip_address":"","comment_id":347402,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"姚老师你好：\n咱们本个专栏主要讲遗留系统现代化，传统意义上基本都是一个大泥球式的单体服务开始。最近我接手却正好相反，服务分的很碎很细，并且有很多坏味道比如一个需求需要修改很多服务，典型的分布式单体。在众多问题中我有一点没想清楚，因为用到了非常多的faas，每个faas有薄（比如只做消息体转换）有厚（做业务流程处理）。个人风格是非常不建议这么做的因为会导致认知负载太高，几十个faas最终没人说的全，不知道一个流程是从哪里开始的，有问题排查成本也升高。但是话说回来faas真正解决的问题是什么呢？强调function的话最终我想不管如何管理也一定会变得数量特别多直到难以管理，最佳实践是什么样的？\n辛苦～","like_count":8,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574882,"discussion_content":"你好，这是一个非常好的问题，为了更准确地回答，我特意咨询了一下我的前同事，现腾讯云的Serverless专家架构师杨政权，以下是他的回答：\n\nFaaS解决的问题：FaaS平台的特点是更精细的资源分配、更精确的计费粒度、低运维成本以及弹性伸缩的能力，在我来FaaS主要解决两个问题：\n\n1）企业的IT投资分配问题：FaaS属于Serverless的一个分支，对于大部分企业来说，尤其是成长期的SMB企业，运维一个K8S集群、虚拟机集群或者IDC并不会带来核心竞争力的提升，通过Serverless提供的低运维成本的方案，降低企业在基础运维、资源调度等方面的成本，从而把更多的IT投资分配到那些核心的业务能力提升上\n2）传统容量预测的矛盾问题：资源准备的太多导致利用率多，资源准备的太少又可能会影响线上业务，FaaS这种跟随请求量进行主动扩容的模式让「准备的资源」和「实际所需的资源」尽量贴合；所以更适合的通常也是矛盾最突出的场景，那些业务有波峰波谷、量级难以预测，同时业务又对于实时性有较高要求的业务场景，如电商大促、批量的音视频处理、服务端渲染SSR 等\n\nFaaS的粒度：一个好的FaaS应用设计应该可以充分地利用平台所提供的优势\n\n1）通过业务的逻辑拆分分离特定的业务，代码体积、内存消耗和应用初始化时间降低，从而获得更快速的弹性扩容，提升该业务场景的吞吐量；和微服务类似，拆分之后在编程语言和技术栈的选择上也会更加灵活。\n2）但是正如您所说，过度的拆分的确会带来新的问题，2019年Thoughtworks技术雷达就提出「Lambda pinball」的概念，并放到了On Hold的位置，过度的FaaS拆分很容易陷入构建分布式单体的陷阱中，还会导致冷启动过多的问题，降低FaaS实例的复用率。在拆分的时候仍然需要关注业务逻辑的内聚性，让每一个FaaS包含一个相对完整的应用场景，在逻辑边界的基础上进行物理边界的优化，通过Faas的实际运行消耗，如冷启动速度、内存闲置情况、实例并发数等指标进行优化。\n3）目前FaaS的应用设计还缺少成熟的方法论支持，最佳的方式还是通过实际的运行结果，结合业务场景的要求进行实际压测，然后观察性能、成本和平台指标进行针对性的优化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654418713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347331,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1653950739,"is_pvip":false,"replies":[{"id":126649,"content":"其实时间并不是主要问题，它既然能长成这个样子，业务方也一定是可以忍受的。最主要的问题是：1. 无法维护，2. 数据所有权不清楚","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1653960870,"ip_address":"","comment_id":347331,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"文中以图片表示的复杂查询令人吃惊，没见过这么长的查询。\nQ1  这么长的查询，一般需要多长时间？ 比如100ms？\nQ2  除了时间，从实际应用的角度，这种复杂查询还有哪些问题？","like_count":1,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574297,"discussion_content":"其实时间并不是主要问题，它既然能长成这个样子，业务方也一定是可以忍受的。最主要的问题是：1. 无法维护，2. 数据所有权不清楚","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653960871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}