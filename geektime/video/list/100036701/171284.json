{"id":171284,"title":"44 | 优化使用：“整改”线程模型让\"响应\"健步如飞","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":157485,"user_name":"灿烂明天","can_delete":false,"product_type":"c3","uid":1322455,"ip_address":"","ucode":"07DA56B0680D0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/d7/74fc8f38.jpg","comment_is_top":false,"comment_ctime":1575174105,"is_pvip":false,"replies":[{"id":60551,"content":"不知道你是不是有点误解了，给一个handler设置线程池，只对那个绑定的handler有效，对其他的处理无效，比如接受连接，还是用默认的nio event loop group.","user_name":"作者回复","user_name_real":"傅健","uid":1638649,"ctime":1575323243,"ip_address":"","comment_id":157485,"utype":1}],"discussion_count":1,"race_medal":2,"score":2,"product_id":100036701,"comment_content":"老师，我想问下，我按照你视频去试，设置了那个un开头的线程池，还是用了默认的nioeventloopgroup，这是什么原因吗？","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476443,"discussion_content":"不知道你是不是有点误解了，给一个handler设置线程池，只对那个绑定的handler有效，对其他的处理无效，比如接受连接，还是用默认的nio event loop group.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575323243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176982,"user_name":"fomy","can_delete":false,"product_type":"c3","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1581241512,"is_pvip":false,"replies":[{"id":68864,"content":"前面一句话，你说的感觉不太合理，如果你的业务线程已经不是复用IO线程（读取数据&#47;响应数据）的时候，你增加NioEventLoopGroup的线程数意义不大，因为它等于纯处理IO事件了，用默认的就行，相当于属于CPU密集型了，增大线程数可能起反作用；\n后面一句话合理，补充一点，单独独立出来后，还有个好处是可以和IO的处理的线程分开。\n","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1581388361,"ip_address":"","comment_id":176982,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"当连接客户端数很多时，增大NioEventLoopGroup的线程数。\n当某个handler处理很慢时，通过使用UnorderedThreadPoolEventExecutor线程池来处理该Handler。\n\n这样理解是否合理？","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483267,"discussion_content":"前面一句话，你说的感觉不太合理，如果你的业务线程已经不是复用IO线程（读取数据/响应数据）的时候，你增加NioEventLoopGroup的线程数意义不大，因为它等于纯处理IO事件了，用默认的就行，相当于属于CPU密集型了，增大线程数可能起反作用；\n后面一句话合理，补充一点，单独独立出来后，还有个好处是可以和IO的处理的线程分开。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581388361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156886,"user_name":"鱼向北游","can_delete":false,"product_type":"c3","uid":1439908,"ip_address":"","ucode":"580EC7DCE57E9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132","comment_is_top":false,"comment_ctime":1574991998,"is_pvip":false,"replies":[{"id":60553,"content":"其实大多都是应该如此调整的，或者做类似的单独定义线程池的，为什么？因为我们的业务大多都是io密集型或者较长返回的，但是呢，业务不属于netty层，所以他不会提前帮我们定义好，所以我们自己才要定义下，实际中，我们用的大都是自己单独定义一个线程池，而不是netty自带的(用它也没问题)，就是ppt提的另外一种，因为可以随心所欲。","user_name":"作者回复","user_name_real":"傅健","uid":1638649,"ctime":1575324312,"ip_address":"","comment_id":156886,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"为了更解耦也可以把请求入队列，然后其他业务消费，消费完再找channel发回去 这个unordered线程池以前用的比较少 涨知识了","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476262,"discussion_content":"其实大多都是应该如此调整的，或者做类似的单独定义线程池的，为什么？因为我们的业务大多都是io密集型或者较长返回的，但是呢，业务不属于netty层，所以他不会提前帮我们定义好，所以我们自己才要定义下，实际中，我们用的大都是自己单独定义一个线程池，而不是netty自带的(用它也没问题)，就是ppt提的另外一种，因为可以随心所欲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575324312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156752,"user_name":"姚远","can_delete":false,"product_type":"c3","uid":1680082,"ip_address":"","ucode":"AB278EF7581440","user_header":"https://static001.geekbang.org/account/avatar/00/19/a2/d2/1d1ae570.jpg","comment_is_top":false,"comment_ctime":1574947573,"is_pvip":false,"replies":[{"id":61712,"content":"在传入参数nioeventloop情况下，还是不会的，主要和这个参数pinEventExecutor（ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP）有关系，childExecutors.get(group)这个key是group，并不是channel，所以多个channel触发的服务器处理，还是单个EventExecutor。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576474678,"ip_address":"","comment_id":156752,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师第二种情况使用nioeventloop当作threadpool的时候 因为一个channel会绑定loop中的一个线程 所以变成串行之行了。如果把客户端改成多个channel发送就会使用loop里的其他线程了吧。","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476222,"discussion_content":"在传入参数nioeventloop情况下，还是不会的，主要和这个参数pinEventExecutor（ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP）有关系，childExecutors.get(group)这个key是group，并不是channel，所以多个channel触发的服务器处理，还是单个EventExecutor。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250327,"avatar":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","nickname":"微微一笑","note":"","ucode":"CFA7ABE81D0B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385668,"discussion_content":"老师你这里说的不对吧？多个客户端的情况下，会根据不同的客户端分配不同的thread去处理handle！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627201823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156455,"user_name":"飞翔","can_delete":false,"product_type":"c3","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1574878958,"is_pvip":false,"replies":[{"id":61530,"content":"估计你问的是非netty自带的线程池的方式，你把消息和ctx一起封装成一个新对象比如Task传给线程池，然后消息执行完成后。就可以直接用ctx来写了，那个就有绑定的channel.","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576210295,"ip_address":"","comment_id":156455,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师 我想问一下  用线程池之后， 那么nioeventloop 线程就执行完了， 那等线程池里的线程读取数据库得到数据 返回的时候 怎么找到他要发送的channel呀","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476115,"discussion_content":"估计你问的是非netty自带的线程池的方式，你把消息和ctx一起封装成一个新对象比如Task传给线程池，然后消息执行完成后。就可以直接用ctx来写了，那个就有绑定的channel.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576210295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1680082,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a2/d2/1d1ae570.jpg","nickname":"姚远","note":"","ucode":"AB278EF7581440","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64471,"discussion_content":"handler里的入参不是有channelcontext吗 这个里边能获取当前channel对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574949073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356894,"user_name":"18324110918","can_delete":false,"product_type":"c3","uid":1561775,"ip_address":"重庆","ucode":"DDD837E1C225FB","user_header":"","comment_is_top":false,"comment_ctime":1662688364,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，请问我设置了un开头的线程池也设置了名字为“business”，但是不显示线程名字，只显示10条了“order&#39;s executing complete”","like_count":0},{"had_liked":false,"id":350508,"user_name":"金金","can_delete":false,"product_type":"c3","uid":1162729,"ip_address":"","ucode":"2371D6F8FD01CC","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/e9/14c729c3.jpg","comment_is_top":false,"comment_ctime":1656968130,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，你好，多线程获取handle和多线程写handler，是否都是线程安全的呢？","like_count":0},{"had_liked":false,"id":342093,"user_name":"未来","can_delete":false,"product_type":"c3","uid":1246530,"ip_address":"","ucode":"6ACFFC4628F4E8","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/42/cf5c229a.jpg","comment_is_top":false,"comment_ctime":1650011621,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"本地的map里面保存了channel，我在EventLoop的支持线程外使用channel.writeAndFlush(new TextWebSocketFrame(&quot;121212121&quot;)） 和使用connect.eventLoop().execute(()-&gt; connect.writeAndFlush(new TextWebSocketFrame(&quot;121212121&quot;)));  直接复用EventLoop的工作线程发送数据  避免上下文切换 我看源码发送数据的时候是有这个inEventLoopd 判断的,这个是不是后者性能更好？","like_count":0},{"had_liked":false,"id":264050,"user_name":"jackhance","can_delete":false,"product_type":"c3","uid":1261634,"ip_address":"","ucode":"934B0D20CCD06C","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/42/d5c23178.jpg","comment_is_top":false,"comment_ctime":1606319886,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"多线程处理业务也会带来共享资源的争用问题，虽然使用到了多线程，但是在生成环境下，不一定最优，也不一定能提高效率\nNioEventLoopGroup使用线程封闭，避免了资源的争用问题","like_count":0}]}