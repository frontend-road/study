{"id":389082,"title":"04｜跨越现实的障碍（上）：要性能还是要模型？","content":"<p>你好，我是徐昊。今天我们来聊聊通过关联对象（Assocation Object）建模聚合（Aggregation）。</p><p>在前面三节课，我们学习了领域驱动设计中的“两关联一循环”：模型与软件实现关联；统一语言与模型关联；提炼知识的循环。其中，统一语言与提炼知识的循环作为一种更为平衡的权责关系，促进了业务方与技术方更好的协作。而这一切又是以模型与软件实现关联为基础。</p><p>然而落地到实践中，关联模型与软件实现总有一些让人纠结与苦恼的地方。引起这些苦恼的主要原因是<strong>架构风格的变化</strong>。我们已经从单机时代过渡到了多层单体架构，以及云原生分布式架构，但我们所采用的建模思路与编程风格并没有彻底跟上时代的步伐，这种差异通常会以<strong>性能问题</strong>或是<strong>代码坏味道</strong>的形式出现。</p><p>如果我们想要真正发挥出领域驱动设计的作用，就需要<strong>在不同架构风格下，找到能够维持模型与软件实现统一的办法</strong>。这也是这个领域常看常新，总能产生新实践的原因。</p><p>因而接下来，我会用三节课来介绍一组实现模式，帮助我们应对从单机架构过渡到多层架构，保持模型与软件实现的关联。这些模式也是我们后面学习在微服务和云原生时代，实施领域驱动设计方法的基础。</p><p>今天这节课，我们就先从关联对象这一方法开始讲起。关联对象是一个古老的设计/分析模式，Martin Fowler在<a href=\"https://book.douban.com/subject/4832380/\">《分析模式》</a>中讨论过它。Peter Coad将它视为一种常见的业务构成模式，并应用到业务分析中。而我大概从2005年开始，使用它建模领域驱动设计中的聚合与关联关系，以解决领域模型（Domain Model）中对技术组件的封装问题。</p><!-- [[[read_end]]] --><p>不过，在讲解到关联对象的具体做法之前，我们需要先看一下<strong>领域驱动设计中的聚合关系在具体实现中存在哪些问题</strong>。了解了问题所在，我们才能更有针对性地去寻找解决办法。</p><h2>无法封装的数据库开销</h2><p>在应用领域驱动设计的时候，聚合与聚合根（Aggregation Root）是构成“富含知识的模型（Knowledge Rich Model）”的关键。通过聚合关系，我们可以将<strong>被聚合对象的集合逻辑放置于聚合/聚合根里，而不是散落在外，或是放在其他无关的服务中</strong>。这么做可以使得逻辑富集于模型中，避免“逻辑泄露”。</p><p>不过落到具体实现上，我们经常会遇到这样一个挑战，即：<strong>这些被聚合的对象，通常都是被数据库持久化</strong>（Persistent）<strong>的集合</strong>（Collection）。也就是说，数据库系统的引入，网络I/O与其他性能开销无法被接口抽象隔离。而将具体技术实现引入领域模型，则有悖领域驱动设计的理念。</p><p>接下来，我们就通过一个例子，在具体的上下文中看一看存在什么问题。然后，再看一下这个问题在建模思路上产生的根源，以及要如何修正我们的建模思路。</p><h3>集合遍历与N+1</h3><p>让我们再回到在<a href=\"https://time.geekbang.org/column/article/387945\">第二讲</a>里展示的极客时间专栏的例子：</p><pre><code>class User {\n\n\n   private List&lt;Subscription&gt; subscriptions;\n\n\n   // 获取用户订阅的所有专栏\n   public List&lt;Subscription&gt; getSubscriptions() {\n     ...\n   }\n   \n   // 计算所订阅的专栏的总价\n   public double getTotalSubscriptionFee() {\n     ...\n   }\n}\n\n\nclass UserRepository {\n  ...\n  public User findById(long id) {\n    ...\n  }\n</code></pre><p>按照面向对象和领域驱动设计提倡的做法，User作为聚合根，需要管控其对应的Subscription。现在我们有一个简单且常见的需求：在页面上，显示对用户已经订阅过的专栏进行分页处理。那么，我们大概会这么写：</p><pre><code>user.getSubscriptions().subList(from, from + pageSize);\n</code></pre><p>可以发现，在这段代码里，我们假设所有的Subscription都在内存里，因此所有的计算与逻辑都可以在内存中完成了。那么，我们就需要在读取User的时候，将它对应的所有订阅过的专栏信息都从数据库读取到内存中，以便后续使用。</p><p>如果是少量订阅的场景，比如几个或者几十个，那这段代码并没有什么问题。但如果有个特别好学的人，买了几万甚至几百万个专栏呢（先假设专栏有无限个）？此时将所有订阅过的专栏都读取到内存里，这就意味着会有巨大的网络I/O开销和内存占用。</p><p>当然，这里你可能会说，JPA/Hibernate等ORM提供了延迟加载啊。是的，但这又会引入<strong>经典的性能瓶颈N + 1问题</strong>。因为随着延迟加载集合的遍历，其中的Subscription对象会被依次加载。</p><p>延迟加载的实现流程是这样的：</p><ul>\n<li>先执行一条查询获取集合的概况。比如总共有多少条记录之类的信息。</li>\n<li>然后根据概况信息，生成一个集合对象。这时候集合对象基本上是空的，不占用什么内存空间。</li>\n<li>随后，当我们需要集合内的具体信息的时候，它再根据我们需要访问的对象，按需从数据库中读取。</li>\n</ul><p>理论上讲，这是为了避免一次性读入大量数据带来的性能问题，而提出的解决办法。</p><p>然而，如果需要获取所有的数据，那么我们总共就会有N+1次数据库访问：1次是指第一次获取概况的访问，N次指而后集合中N个对象每个一次。而每一次加载，都伴随着对数据库的访问，自然就会带来I/O与数据库的开销。特别是频繁地对数据库访问，可能会阻塞其他人，从而造成性能瓶颈。</p><p>在这种情况下，我们其实没有什么好的选择：<strong>要么是一次性读入全部数据，避免N + 1问题；要么是引入N+1问题，变成钝刀子割肉</strong>。</p><p>为了避免这两种情况，很自然地，你会想起这样一种做法：通过查询语句一次性定位所需分页，这样只需要一次查询就能解决问题。不过这么做的困难在于，<strong>分页查询的逻辑要放在哪个对象上，才能保持模型与软件实现的关联</strong>。</p><p>一种做法是<strong>为订阅</strong>（Subscription）<strong>构造一个独立的Repository对象</strong>，将逻辑放在里面（也是Spring推荐的做法）：</p><pre><code>interface SubscriptionRepository extends ... {\n  public Page&lt;Subscription&gt; findPaginated(int from, int size);\n}\n</code></pre><p>这种做法的问题就是会导致<strong>逻辑泄露</strong>。Subscription被User聚合，那么User所拥有的Subscription的集合逻辑应该被封装在User中，这样才能保证User是“逻辑丰富的模型”，因为<strong>非聚合根提供Repository是一种坏味道</strong>。</p><p>如果聚合到User上是可行的吗？其实也不行。因为这么做会将技术实现细节引入领域逻辑中，而无法保持领域逻辑的独立。代码如下：</p><pre><code>public class User {\n    public List&lt;Subscription&gt; getSubscriptions() {\n      ....\n    }\n    \n    public List&lt;Subscription&gt; getSubscriptions(int from, int size) {\n       return db.executeQuery(....);\n    }\n }\n</code></pre><p>造成这种两难局面的根源在于，<strong>我们希望在模型中使用集合接口，并借助它封装具体技术实现的细节</strong>。因为在我们的概念中，<strong>内存中的集合与数据库是等价的，都可以通过集合接口封装</strong>。但实际情况是，我们无法忽略数据库带来的额外作用与开销，内存中的集合与数据库并不是等价的，封装失败。</p><p>那么，为什么在我们的概念中，我们会认为内存中的集合与数据库是等价的，是可以通过集合接口封装的呢？这就要从面向对象技术的开端——Smalltalk系统说起了。</p><h3>Smalltalk中集合与数据库是等价的</h3><p>鲜少有人了解的一个事实是，<strong>集合与数据库的等价，在早期面向对象系统Smalltalk中是一个基础概念</strong>。</p><p>这其实不难理解，如果对象中包含的状态可以映射为数据库表中的一列，那么一组对象自然就可以映射成一张表了。有了一张表，自然也就可以看作是一个最小的数据库了。</p><p>Smalltalk作为面向对象系统内置的一套<strong>面向对象数据库</strong>（Object Oriented Database）。于是在使用Smalltalk系统时，集合与数据库是无差别的。如下图所示，展示了Smalltalk系统的构成。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/3d/c3d0e09fd9faa5bdc4313032fe15423d.jpg?wh=7885x4244\" alt=\"\"></p><p>如上图所示，Smalltalk中除了虚拟机（Virtual Machine）之外，还有虚拟镜像（Virtual Image，VI）。<strong>虚拟镜像相当于虚拟机内存的持久化保存</strong>。每次虚拟机启动的时候，都会把虚拟镜像中的信息读入到内存中以恢复状态，而Java、.NET虚拟机并不会保留之前内存中的信息。</p><p>打个比方。Smalltalk虚拟机的启动过程，类似于VMWare虚拟机上的Pause，内存中的所有状态都被持久化保存了，那么我们可以继续从之前暂停的地方开始。而其他语言的虚拟机则是彻底地重启（Restart），并不会保留之前的结果。</p><p>在Smalltalk的虚拟镜像中，存储着所有的代码和数据。我们称呼Smalltalk为一个面向对象系统，而不仅仅是面向对象语言。因为它既是一门面向对象语言，也是一个虚拟机的操作系统，还是一个面向对象数据库。</p><p>那么在这样的系统中，Smalltalk中的集合（无论是Array、List，还是什么）就等同于一个数据库。只要这个集合被创建出来，除非显示化地通过垃圾回收销毁，否则它就会被虚拟镜像持久化。<strong>垃圾收集和持久化一样，都可以被看作是对象生命周期</strong>（Object Lifecycle）<strong>的一个状态</strong>。</p><p>因此，数据库中的数据和非数据库中的数据，都可以通过Collection表达，我们不用再去区分它。而在Smalltalk中，这种等价关系深刻影响了我们的思路和建模习惯，毕竟我们所熟知的面向对象语言都从Smalltalk中借鉴了大量的概念。而早期的建模者也大都来自Smalltalk社区，比如Peter Coad、Kent Beck、Martin Fowler等（当然我也是）。所以我们学习建模方法的时候，或多或少有一些源自Smalltalk社区的习惯。</p><p>然而随着时代的发展，这种习惯在多层架构（Mulit-tier Architecture）下遇到了挑战。那么接下来我们就看看多层架构是怎么彻底割裂了集合与数据库的。</p><h3>多层架构彻底割裂了集合与数据库</h3><p>Smalltalk在中国未曾真正地流行过，大多数人是从C++甚至是Java、.NET开始接触面向对象编程的。而无论是C++、Java，还是后来的面向对象编程语言，其实都不是完整的面向对象系统。</p><p>集合作为面向对象中的重要概念，被吸纳入这些语言后，就去掉了与数据库的强关联（毕竟这些语言默认不带有数据库模块）。因此，集合虽然在概念上仍然等同于数据库，但如此简单粗暴的建模，就会遇到我们前面提到的“是否N+1”的两难选择。</p><p>那么Java、.NET这些语言为什么要这么做呢？它们为什么不能像Smalltalk一样，内涵完整地面对象数据库呢？这其实是架构风格演化的结果。</p><p>我们明显可以发现，<strong>Smalltalk是典型的单机单体架构</strong>。从操作系统、数据库到应用程序，都在一个虚拟机上，就好像是一台小型机一样。这样的<strong>架构结构无法水平扩展</strong>（horizontal scaling）<strong>，只能垂直扩展</strong>（vertical scaling）。这就意味着我们需要<strong>不断提高单点的计算能力，才能提高整个的容量与吞吐</strong>。这并不符合架构的整体发展趋势。</p><p>进入21世纪后，随着对系统容量要求的增加，易于水平扩展的三层架构逐渐成为行业主流。而数据库作为一个独立组件，则不再与应用合体。示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/11/2a/11142c4ab83c9ef344e7e811c274b02a.jpg?wh=8000x4500\" alt=\"\"></p><p>于是，Smalltalk的面向对象系统在这种架构下分别变成了：应用程序中间件（对应Smalltalk虚拟机）和数据库（对应Smalltalk虚拟镜像的持久化数据部分）。</p><p>多层架构彻底割裂了对象集合与数据库，这对我们实现领域模型建模提出了挑战，对Collection逻辑的建模也就难以摆脱具体实现细节了。那就是我们<strong>必须明确哪些是持久化的数据，并对它的一些逻辑区别对待</strong>。这就是原味面向对象范型（Vanilla Object Oriented），在架构风格演化过程中遇到的挑战。</p><p>几乎所有实施过DDD的人，都在这个问题上挣扎过。如果对于如此常见且如此简单的分页功能，我们都无法将模型与软件实现关联的话。那么，面对更复杂的问题时我们要怎么办呢？这是大多数怀揣理想准备实施DDD的人，碰到的第一个阻碍。</p><p>关联对象就是一种解决这个问题的设计模式。</p><h2>关联对象</h2><p><strong>关联对象</strong>，顾名思义，就是<strong>将对象间的关联关系直接建模出来，然后再通过接口与抽象的隔离，把具体技术实现细节封装到接口的实现中</strong>。这样既可以保证概念上的统一，又能够避免技术实现上的限制。</p><p>现在让我们再来看看极客时间专栏的例子，如果使用关联对象，如何帮我们避免N+1和逻辑泄露的问题。</p><h3>使用关联对象实现聚合关系</h3><p>首先我们需要定义关联对象，因为我们需要表达的是User与Subscription间的一对多的关系，那么最简单的命名方法是将两个对象名字组合，从而得到关联对象的名字UserSubscriptions：</p><pre><code>public interface UserSubscriptions extends Iterable&lt;Subscription&gt; {\n   List&lt;Subscription&gt; subList(int from, int to); //分页\n   double getTotalSubscriptionFee(); //获取总共花费\n   int count(); //获取总订阅数\n   Iterable&lt;Subscription&gt; sort(...);\n   ....\n}\n</code></pre><p>当然，我们最好是从业务上下文出发，寻找更具有业务含义的名字，毕竟我们是要形成统一语言的，源自业务的名字总是更容易被非技术角色所理解。</p><p>比如这里我们要表达的是用户已经订阅的专栏，或者是用户已经购买的专栏，那么PaidColumn，甚至MySubscriptions，都不错，看哪一个更容易被团队接受了。我这里选择MySubscriptions，于是User对象就变成了这样：</p><pre><code>public interface MySubscriptions extends Iterable&lt;Subscription&gt; {\n...\n}\n\n\npublic class User {\n  private MySubscriptions mySubscriptions;\n  \n  public MySubscriptions getMySubscriptions() {\n     return mySubscriptions\n  }\n}\n</code></pre><p>那么之前对于分页和计算的调用也就相应地变为：</p><pre><code>user.getMySubscriptions().subList(0, 10);\nuser.getMySubscriptions().getTotalSubscriptionFee();\n</code></pre><p>很明显，我们没有逻辑泄露，User是Subscription的聚合根，那么与之相关的逻辑也仍然被封装在User的上下文中，当然是进一步被封装在关联对象中。</p><p>那么我们怎么解决持久化的问题呢？怎么从领域对象中，移除掉对技术实现的依赖呢？秘诀就在于<strong>接口与实现分离</strong>。代码如下：</p><pre><code>package model.impl.db;\n\n\npublic class MySubscriptionsDB implements MySubscriptions {\n  ...\n  private User user;\n\n\n  public List&lt;Subscription&gt; subList(int from, int to) {\n    return db.executeQuery(...);\n  }\n  ...\n</code></pre><p>在这里，我们将与数据库访问相关的逻辑毫不避讳地封装到MySubscriptionsDB中。不过，作为领域对象的User类，并不会知道它使用了数据库，因为它仅仅通过MySubscriptions接口，访问它所需要的功能。此时我们可以通过简单的分包的策略：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/04/e8c35b784e7ec2553df31d7c1c364004.jpg?wh=7164x3335\" alt=\"\"></p><p>从上图中包的架构上看，模型的包中有MySubscriptions、User、UserRepository。与数据库相关的代码的包里有MySubscriptionsDB和UserRepositoryDB。于是，我们成功地将核心的领域逻辑与实现细节分开了。</p><p>当然最后还有一个问题：<strong>如何将MySubscriptionsDB与User结合在一起</strong>？最直接的做法就是这样：</p><pre><code>public UserRepositoryDB implements UserRepository {\n  ...\n  public User findBy(long id) {\n      User user = .....;\n      return setMySubscription(user);\n  }\n  \n  public List&lt;User&gt; findBy(....) {\n      List&lt;User&gt; user = .....;\n      return user.map(user -&gt; setMySubscription(user));\n  }\n  \n  private User setMySubscription(User user) {\n      user.setMySubscriptions(new MySubscriptionDB(db, user));\n      return user;      \n  }\n}\n</code></pre><p>因为User是聚合根，从数据库中读取的User对象都需要从UserRepository中获取。那么，在UserRepository的具体实现中为User对象设置MySubscription对象，是再自然不过的选择了。</p><p>当然更简洁漂亮的做法，是通过Java CDI API或是框架提供的生命周期实践监听器，来完成关联对象的设置。</p><h3>隔离技术实现细节与领域逻辑</h3><p>通过引入关联对象，我们可以更好地隔离领域逻辑与技术实现细节。在这里，我们还是用极客时间专栏的例子来解释。</p><p>如果这时候Subscription信息并不是存在数据库中，而是通过RESTful API从另一个系统中获取的。那么，我们只需提供另一个MySubscriptions的实现就可以了：</p><pre><code>package model.impl.api;\n\n\npublic class MySubscriptionsAPI implements MySubscriptions {\n  ...\n  private User user;\n\n\n  public List&lt;Subscription&gt; subList(int from, int to) {\n    return client.findSubscriptions(....);\n  }\n  ...\n</code></pre><p>这种改变并不会传递到领域逻辑层，对于分页和计算的调用仍然为：</p><pre><code>user.getMySubscriptions().subList(0, 10);\nuser.getMySubscriptions().getTotalSubscriptionFee();\n</code></pre><p>RESTful API的性能瓶颈和需要调整的地方与数据库不同，这种变化都被关联对象的接口封装隔离了。</p><p>从面向对象编程的角度来说，我们很容易理解为什么关联对象可以带来如此多的好处。在诸多面向对象的最佳实践中，有一条是说要尽可能避免使用原始类型（primitive type）。因为原始类型没有对概念进行提取，也缺乏封装，所以我们应该尽可能地使用自定义的类去替换它们。</p><p>不过如果我们把语言内提供的集合类型（List等）也当作原始类型的话，关联对象就是对这一条建议自然的扩展：<strong>使用自定义关联对象，而不是集合类型来表示对象间的关联</strong>。</p><h3>通过集体逻辑揭示意图</h3><p>关联对象除了可以帮助聚拢逻辑、隔离实现细节之外，还能从概念上帮助我们获得更好的领域模型，因为关联对象是对集体逻辑的直接建模。</p><p>所谓<strong>集体逻辑，是指个体不具备，而成为一个集体之后才具备的能力。哪怕是同一群个体，组成了不同的集体，就会具有不同的逻辑</strong>。</p><p>我们仍然回到极客时间专栏的例子上，来帮助你理解。比如我们现在的模型是这样的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/72/a2/7288282fa92473a66ef9d012d90b6aa2.jpg?wh=7000x2908\" alt=\"\"></p><pre><code>public class User {\n   private List&lt;Subscription&gt; subscriptions;\n   \n   ....\n}\n\n\npublic class Column {\n    private List&lt;Subscription&gt; subscriptions;\n    \n    ....\n}\n</code></pre><p>在这段代码中，User中的List<subscription>表示用户已订阅的所有专栏，而Column中的List<subscription>，则表示所有订阅了专栏的用户。虽然同为Subscription的集合，但是当它们组成集体时，在不同的上下文中则具有不同的含义。</subscription></subscription></p><p>那么如果显式地表达为关联对象，可以进一步澄清我们的意图，得到揭示意图的接口（Intention Revealing Interface）。代码如下：</p><pre><code>public class User {\n\n\n   public static interface MySubscriptions extends Iterable&lt;Subscription&gt; {\n   ...\n   }\n   \n   private MySubscriptions mySubscriptions;\n   \n   ...\n}\n\n\npublic class Column {\n\n\n    public static interface MyReaders extends Iterable&lt;Subscription&gt; {\n    ...\n    }\n    \n    private MyReaders myReaders；\n\n\n    ..\n</code></pre><p>在这段代码中，我们通过引入关联对象，可以将这两个不同的集体变更为User.MySubscriptions和Column.MyReaders，然后在各自的上下文去定义不同的集体逻辑。</p><p>比如我订阅的专栏可以计算我一共付了多少钱，而在我的读者中，可以计算订阅者对专栏的平均打分情况，示意代码如下：</p><pre><code>public static interface MySubscriptions extends Iterable&lt;Subscription&gt; {\n  double getTotalFee();\n}\n\n\npublic static interface MyReaders extends Iterable&lt;Subscription&gt; {\n  double getAverageRating();\n}\n</code></pre><h2><strong>小结</strong></h2><p>我们来简单地总结一下。随着架构风格的演化与改变，面向对象技术中的集合，从与数据库完全等价，变成了与数据库完全割裂的东西。</p><p>然而在概念上，我们仍留有<strong>通过集合封装内存中的对象与数据库中的数据</strong>的习惯。这使得我们在使用领域驱动设计的时候，特别是使用聚合关系的时候，变得左右为难：<strong>要么放弃性能，获得更好的模型；要么泄露逻辑，以得到可接受的性能</strong>。</p><p>但是关联对象，则可以让我们在更加明确揭示意图的同时，去解决性能与逻辑封装的问题。我个人从很早就开始将关联对象作为实现聚合关系的默认方法了，它从未让我失望（it never fails me）。我建议你也试一试，这样我就不用给你解释什么叫惊喜了。</p><p>编辑小提示：为了方便读者间的交流学习，我们建立了微信读者群。想要加入的同学，戳此加入<a href=\"https://jinshuju.net/f/wjtvTP\">“如何落地业务建模”交流群</a>&gt;&gt;&gt;</p><h2>思考题</h2><p>关联对象实际上是通过将隐式的概念显式化建模来解决问题的，这是面向对象技术解决问题的通则：永远可以通过引入另一个对象解决问题。那么在领域模型中还有哪些隐式概念呢？这些概念会给我们带来什么麻烦呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/cd/f8900fc84acabbc502b519bf358786cd.jpg?wh=1500x1798\" alt=\"\"></p><p>欢迎把你的思考和想法分享在留言区，我会和你交流。同时呢，我也会把其中一些不错的回答置顶，供大家学习。</p>","comments":[{"had_liked":false,"id":300418,"user_name":"Geek_3531cc","can_delete":false,"product_type":"c1","uid":1549138,"ip_address":"","ucode":"E9FBABBB15CD95","user_header":"","comment_is_top":true,"comment_ctime":1625149367,"is_pvip":false,"replies":[{"id":"108878","content":"可以在关联对象上直接增加方法，关联对象表示聚合逻辑。灵活很多","user_name":"作者回复","comment_id":300418,"uid":"2537798","ip_address":"","utype":1,"ctime":1625153248,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"9.2233720599548006e+18","product_id":100082101,"comment_content":"感谢老师的好文章。我这边有个疑问，专栏聚合了内容同理也可以用关联对象模式，那如果作者需要对专栏里的其中一个内容进行修改，需要先获取专栏然后通过关联对象获取要修改的内容进行修改，再将整个专栏聚合进行保存，这样是否还是没有保障到性能呢？","like_count":5,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522728,"discussion_content":"可以在关联对象上直接增加方法，关联对象表示聚合逻辑。灵活很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625153248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300604,"user_name":"阿鸡","can_delete":false,"product_type":"c1","uid":1589246,"ip_address":"","ucode":"F181422D4EB444","user_header":"https://static001.geekbang.org/account/avatar/00/18/3f/fe/35d1afbd.jpg","comment_is_top":false,"comment_ctime":1625238304,"is_pvip":false,"replies":[{"id":"108913","content":"这样user就退化为纯粹的无逻辑数据对象了，也就是贫血对象","user_name":"作者回复","comment_id":300604,"uid":"2537798","ip_address":"","utype":1,"ctime":1625269686,"user_name_real":"徐八叉"}],"discussion_count":6,"race_medal":0,"score":"57459813152","product_id":100082101,"comment_content":"想请问为什么不直接在UserRepository中添加关于分页的逻辑？虽然能感觉到不太恰当，但是好像也没暴露逻辑，并且user也没依赖具体db实现","like_count":14,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522776,"discussion_content":"这样user就退化为纯粹的无逻辑数据对象了，也就是贫血对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625269686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206912,"avatar":"","nickname":"wwlleo","note":"","ucode":"5119810EA156F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583040,"discussion_content":"我觉得放在UserRepository里也没问题，但是本质核心是需要这个getMySubscriptions()来显式的说明，这里拿到的List，是 “我的订阅”  ，而不是 一个 随便的List数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659881984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2076069,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ad/a5/4b7351b1.jpg","nickname":"Ken","note":"","ucode":"BA2193542A4705","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557291,"discussion_content":"八股文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647756501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550159,"discussion_content":"同问，什么 User 就变成贫血对象了？是因为分页操作在集合对象上面吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644398572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1029051,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b3/bb/abb7bfe3.jpg","nickname":"rusess","note":"","ucode":"C6F46B368F3392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405027,"discussion_content":"为什么这样 ，User 就变成贫血对象了？ 他不是还有 getSubscriptions  这个方法吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634482865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1158603,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/cb/3391d24c.jpg","nickname":"Halo","note":"","ucode":"12CFC7DFF250AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1029051,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b3/bb/abb7bfe3.jpg","nickname":"rusess","note":"","ucode":"C6F46B368F3392","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570615,"discussion_content":"只有get、set方法不就是贫血对象吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651836624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":405027,"ip_address":""},"score":570615,"extra":""}]}]},{"had_liked":false,"id":300711,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1625321083,"is_pvip":true,"replies":[{"id":"108941","content":"之前在美国的DDD大会上很多实践者严肃地讨论要不要放弃关系型数据库。","user_name":"作者回复","comment_id":300711,"uid":"2537798","ip_address":"","utype":1,"ctime":1625325637,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"44574994043","product_id":100082101,"comment_content":"以前只是觉得语言中对象与关系型数据库之间的转换非常不自然，从未问过为什么会是这样，感谢老师今天帮我理清这层关系，原来二者在单体架构时期是等价，是因为后来分层以后才被割裂了，感觉现在的多层是把以前在语言内部实现的机制给放大化了，且为了通用性把CRUD等细节暴露出来了，导致编程语言在使用时感觉不那么自然和一体化了。<br><br>通过将隐式的概念显式化建模，就我自己的理解是需要把隐藏背后想表达的真实意途给找出来，比如今天的例子就是要操作数据，操作数据可以是操作数据库也可以是操作NOSQL等其它各种实现方式，第一反应是操作数据库是一种惯性思维，它并不是真正想要做的事。","like_count":10,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522799,"discussion_content":"之前在美国的DDD大会上很多实践者严肃地讨论要不要放弃关系型数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625325637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300446,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1625158897,"is_pvip":false,"replies":[{"id":"108896","content":"pojo是幻想 cqrs是邪教","user_name":"作者回复","comment_id":300446,"uid":"2537798","ip_address":"","utype":1,"ctime":1625197206,"user_name_real":"徐八叉"}],"discussion_count":3,"race_medal":0,"score":"23099995377","product_id":100082101,"comment_content":"关于内容：<br>1.基础类型偏执。这是一个坏味道，但仅在个人或者小团队的小项目中能看到它被认真对待（也只有刻意训练，践行代码健身操时能被认真对待）。一旦项目变大时间变长人数变多，不知不觉就被抛弃了（毕竟这么写对于不理解的人来说真的会被骂死。一段代码要求阅读者有比较高的认知才能有比较好的可读性。以教育阅读者为前题的同理心写出来的代码还算得上同理心吗？）。<br>2.CQRS。就这个分页场景，我多半是以单独的查询模型来承接。只有在命令&#47;写操作才会构建聚合来实现。这么想来，似乎破坏了一个聚合模型应有的完整性。停顿几秒钟，这里我本觉得只是遵循CQRS，但实际上只是单纯不希望领域聚合实体具备任何io操作。确实，这样没有依赖任何除jdk程序库之外的技术代码，但是pojo对象的行为运行期具备db操作，而这自然又会牵扯到框架，那么这个pojo对象便不再纯粹，只能算是伪pojo。概念的咬文嚼字没有意义，不过伪pojo多了io操作这个不可靠因素，测试验证自然也得多些操作和心思，这是好是坏呢，从长期看又如何？。合理了模型的概念却提高了迭代维护时的心智负担，这是个问题。毕竟我们学习概念，并非想捧着去吵架，而是想通过概念解决自己的实际问题。<br><br>课后题：<br>1.隐式概念：规则，流程，参数（一个函数入参太多时，往往会引起我们的关注和思考，看看这里是不是有一个隐式的概念能包含这些参数）<br>2.发现有滞后性，基本只有在迭代中，坏味道积累到一定程度，引发注意，重新定义和审视时才能发现。但更多的时候是被遗漏。不过漏了本身感觉也并非不合理，不见得就是麻烦。","like_count":4,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522735,"discussion_content":"pojo是幻想 cqrs是邪教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625197206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204178,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/d2/a39e5cea.jpg","nickname":"狩月","note":"","ucode":"472CCBFBE77785","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381711,"discussion_content":"领域模型未必要是pojo吧， 心智负担是有的， DDD本身就有心智负担","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625192148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204178,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/d2/a39e5cea.jpg","nickname":"狩月","note":"","ucode":"472CCBFBE77785","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381749,"discussion_content":"未必，挺多操作会出现老师的这个问题。比如原子操作不可拆。 但pojo就像一种设计模式，还是想尽量维持。换句话说，一旦违反pojo就要慎重。有些负担是知识层面的，有些不是，我指的是后者。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625198776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381711,"ip_address":""},"score":381749,"extra":""}]}]},{"had_liked":false,"id":300882,"user_name":"赵晏龙","can_delete":false,"product_type":"c1","uid":2673605,"ip_address":"","ucode":"F15730BCA97EE0","user_header":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","comment_is_top":false,"comment_ctime":1625415705,"is_pvip":false,"replies":[{"id":"108975","content":"作为通用方法建模的是集合逻辑。有整整五年 我们在全球范围内 看到使用cqrs的项目几乎都失败了 仍然很多人前赴后继 不是邪教是什么","user_name":"作者回复","comment_id":300882,"uid":"2537798","ip_address":"","utype":1,"ctime":1625418416,"user_name_real":"徐八叉"}],"discussion_count":4,"race_medal":0,"score":"18805284889","product_id":100082101,"comment_content":"关联对象我更多的是用来解决业务上的多对多关系，至于分页这个逻辑，我倒是目前还没遇到过这样的场景，不过看完有一些疑问：Subscription虽然通过接口隔离了数据库操作，但是如果Subscription本身有一些业务逻辑呢？是否就考虑把接口换成抽象类，在抽象类中实现业务？<br>另外，在我看来，这种方式应该只在遇到数据库性能问题的时候使用，不应该作为通用方法来使用。有一些影响领域模型只对业务模型进行实现的单一职责。<br><br>另另另另外，CQRS邪教您如何解读的？","like_count":5,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522840,"discussion_content":"作为通用方法建模的是集合逻辑。有整整五年 我们在全球范围内 看到使用cqrs的项目几乎都失败了 仍然很多人前赴后继 不是邪教是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625418416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550162,"discussion_content":"还是没有太明白，使用cqrs为什么会导致项目失败呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644399312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":522840,"ip_address":""},"score":550162,"extra":""}]},{"author":{"id":2673605,"avatar":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","nickname":"赵晏龙","note":"","ucode":"F15730BCA97EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382149,"discussion_content":"好的，那我认为我的理解基本和您在同一条线上，那个我试图用抽象类解决的问题，您遇到过吗？您有没有更好的思路？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625451382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2673605,"avatar":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","nickname":"赵晏龙","note":"","ucode":"F15730BCA97EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382112,"discussion_content":"不好意思没有仔细检查，最后一句应该是：有一些影响领域【类】只对领域模型进行实现的单一职责原则（当然，这个原则是在我自己做架构的时候给自己定的）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625416482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300396,"user_name":"Oops!","can_delete":false,"product_type":"c1","uid":1479474,"ip_address":"","ucode":"E2678CC12121A7","user_header":"https://static001.geekbang.org/account/avatar/00/16/93/32/e11fcd33.jpg","comment_is_top":false,"comment_ctime":1625139017,"is_pvip":false,"replies":[{"id":"108877","content":"需要持久化或者来着三方系统的聚合","user_name":"作者回复","comment_id":300396,"uid":"2537798","ip_address":"","utype":1,"ctime":1625149513,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"18805008201","product_id":100082101,"comment_content":"集合是面向对象模型中广泛存在的概念,如果全都使用关联对象进行建模, 是否会导致类爆炸呢? 有什么可以遵循的规则或者方法来鉴别哪些隐式的集合概念使用关联对象进行建模比较好, 哪些则不然呢? 是不是如果两个对象之间仅仅是简单的包含关系, 可以先用系统提供的集合容器来建模实现, 等到业务复杂了, 需要对这个集合进行除了增删改查之外的操作时, 再使用关联对象进行建模?<br><br><br><br>","like_count":4,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522724,"discussion_content":"需要持久化或者来着三方系统的聚合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625149513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306644,"user_name":"张振华","can_delete":false,"product_type":"c1","uid":1201810,"ip_address":"","ucode":"292EFD886FC55A","user_header":"https://static001.geekbang.org/account/avatar/00/12/56/92/5cea89e6.jpg","comment_is_top":false,"comment_ctime":1628654917,"is_pvip":true,"replies":[{"id":"111043","content":"没","user_name":"作者回复","comment_id":306644,"uid":"2537798","ip_address":"","utype":1,"ctime":1628655477,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"14513556805","product_id":100082101,"comment_content":"老师有没有好的项目和代码，推荐一下。结合着研究下","like_count":3,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524854,"discussion_content":"没","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628655477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301034,"user_name":"tongzh","can_delete":false,"product_type":"c1","uid":1041904,"ip_address":"","ucode":"EEB48527EFCE3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/f0/fad6bf9e.jpg","comment_is_top":false,"comment_ctime":1625490939,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14510392827","product_id":100082101,"comment_content":"关键对象模式，不仅成功解耦了领域模型和具体实现，还成功构造出了富含知识的模型","like_count":3},{"had_liked":false,"id":302673,"user_name":"马若飞","can_delete":false,"product_type":"c1","uid":1046394,"ip_address":"","ucode":"3D0327329A10AE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/7a/55618020.jpg","comment_is_top":false,"comment_ctime":1626328991,"is_pvip":false,"replies":[{"id":"109538","content":"哥 别这样","user_name":"作者回复","comment_id":302673,"uid":"2537798","ip_address":"","utype":1,"ctime":1626335679,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"10216263583","product_id":100082101,"comment_content":"“集合作为面向对象中的重要概念，被吸纳入这些语言后，就去掉了与数据库的强关联”——从语言演进历史得出问题本源，膜拜！","like_count":2,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523381,"discussion_content":"哥 别这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626335679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300532,"user_name":"吴鹏","can_delete":false,"product_type":"c1","uid":1002113,"ip_address":"","ucode":"EB7A78CD198E33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/81/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1625208254,"is_pvip":false,"replies":[{"id":"108905","content":"满是惊喜，值得拥有","user_name":"编辑回复","comment_id":300532,"uid":"2189689","ip_address":"","utype":2,"ctime":1625221721,"user_name_real":"李辰洋"}],"discussion_count":1,"race_medal":0,"score":"10215142846","product_id":100082101,"comment_content":"看到作者thoughtWorks背景毫不犹豫就订阅了，看到这里就感觉值回票价了","like_count":2,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"🐑","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522757,"discussion_content":"满是惊喜，值得拥有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625221721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339963,"user_name":"worry","can_delete":false,"product_type":"c1","uid":1047773,"ip_address":"","ucode":"AF2BDAF6F6370E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/dd/0e17bf09.jpg","comment_is_top":false,"comment_ctime":1648515045,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5943482341","product_id":100082101,"comment_content":"如果订阅的内容较多，是不是应该建模为2个聚合根，在实现领域驱动设计这本书里应该是这样建议的。这些年被spring框架绑架的java开发人员大体不会这样写，思路被限制了。思路很新颖👍。但是，这样是不是也就意味着把数据访问对象注入到了model？虽说这里的MySubscriptions没有加Repository，实际上就是。","like_count":1},{"had_liked":false,"id":335475,"user_name":"银太","can_delete":false,"product_type":"c1","uid":1051765,"ip_address":"","ucode":"B505D15F7CB839","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/75/e7c6c403.jpg","comment_is_top":false,"comment_ctime":1645531492,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5940498788","product_id":100082101,"comment_content":"MySubscriptions还有一些疑问，如果增加订阅，持久化应该是repo来做，但是subList的实现又是直接读取db的，那怎么维护两者之间的统一？","like_count":1,"discussions":[{"author":{"id":2388512,"avatar":"https://static001.geekbang.org/account/avatar/00/24/72/20/733fdd94.jpg","nickname":"王帅","note":"","ucode":"EE352769ABFAA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569294,"discussion_content":"我理解subList只做读取不做增减，增加的职责任然用user","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1651396524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305675,"user_name":"OWL","can_delete":false,"product_type":"c1","uid":1637730,"ip_address":"","ucode":"BF0B231476464F","user_header":"https://static001.geekbang.org/account/avatar/00/18/fd/62/a9587f94.jpg","comment_is_top":false,"comment_ctime":1628094430,"is_pvip":true,"replies":[{"id":"110590","content":"可以","user_name":"作者回复","comment_id":305675,"uid":"2537798","ip_address":"","utype":1,"ctime":1628127394,"user_name_real":"徐八叉"}],"discussion_count":1,"race_medal":0,"score":"5923061726","product_id":100082101,"comment_content":"关联对象确实是一种很巧妙的方法。但是也有疑惑，比如UserRepo获取user后，修改其部分subscriptions，容易产生修改逻辑后UserRepo.set(user)。而其实应该是在Subscriptions关联对象上操作。关联对象隐藏了Subscription聚合的Repo。<br><br>而Eric的DDD中，则是大聚合拆分出多个小聚合，然后通过小聚合中持有聚合根的Id相互关联。同时小聚合自然有自己的repo。而这种拆分，模型的完整性和独立性也减弱，所以需要结合service来完成业务。<br><br>既然引入关联对象，完全去Repo如何？UsersRepo直接用Users来替代。","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524476,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628127394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301562,"user_name":"大碗","can_delete":false,"product_type":"c1","uid":1027207,"ip_address":"","ucode":"F9CDC0C5BE48AC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/87/8ed5880a.jpg","comment_is_top":false,"comment_ctime":1625739061,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5920706357","product_id":100082101,"comment_content":"请问下老师，用户新订阅一个专栏的写法应该什么样子的？比如<br>UserApplication类<br>public void subcribe(User user,Subcrtion subcrition){<br>\tuser.subcribe(subcrtion);<br>\tuserRepository.save(user);<br>}<br>User类<br>public void subcribe(Subcribtion subcribition){<br>\tthis.mySubcrtions.add(subcribtion)<br>}<br>MySubcritions类<br>public void add(Subcrtion subcribtion){<br>\tdb.insert();<br>\t&#47;&#47; or<br>\tmapper.insert();<br>}<br>","like_count":1,"discussions":[{"author":{"id":1057843,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","nickname":"阿甘","note":"","ucode":"BC93175B70E05D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588146,"discussion_content":"既然 user.subscribe的时候就已经通过MySubscrition.insert到DB了，User还需要save吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663575124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2388512,"avatar":"https://static001.geekbang.org/account/avatar/00/24/72/20/733fdd94.jpg","nickname":"王帅","note":"","ucode":"EE352769ABFAA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569991,"discussion_content":"贴一段stackoverflow上的示例：\n\n//Domain level:\n\npublic interface IOrderItemList {\n\n   IEnumerable&lt;OrderItem&gt; GetItems();\n\n}\n\npublic class Order {\n\n    private IOrderItemList _orderItems;\n\n    public IEnumerable&lt;OrderItem&gt; OrderItems \n          { get { return _orderItems.GetItems() } };\n\n    public Order(IOrderItemList orderItems) \n    {\n        _orderItems = orderItems;\n    }\n}\n\npublic class OrderItemList : IOrderItemList\n{\n    private IList&lt;OrderItem&gt; _orderItems;\n\n    public IEnumerable&lt;OrderItem&gt; GetItems() {\n        return _orderItems; //or another logic\n    }\n\n    //other implementation details\n}\n\n//Data level\n\npublic class OrderItemListProxy : IOrderItemList\n{\n    //link to &#39;real&#39; object\n    private OrderItemList _orderItemList;\n\n    private int _orderId;\n    //alternatively:\n    //private OrderEntity _orderEntity;\n\n    //ORM context\n    private DbContext _context;\n\n    public OrderItemListProxy(int orderId, DbContext context)\n    {\n       _orderId = orderId;\n       _context = context;\n    }\n\n    public IEnumerable&lt;OrderItem&gt; GetItems() {\n        if (_orderItemList == null) \n        {\n            var orderItemEntities = DbContext.Orders\n              .Single(order =&gt; order.Id == _orderId).OrderItems;\n\n            var orderItems = orderItemEntites.Select(...);\n            //alternatively: use factory to create OrderItem from OrderItemEntity\n            _orderItemList = new OrderItemList(orderItems);\n        }\n        return _orderItemList.GetItems();\n    }\n\n}\n\npublic class OrderRepository\n{\n   //ORM context\n   private DbContext _context;\n\n    Order GetOrder(int id)\n    {\n        var orderEntity = _context.Single(order =&gt; order.Id == id);\n        var order = new Order(new OrderItemListProxy(id, _context))\n        //alternatively:\n        //var order = new Order(new OrderItemListProxy(orderEntity, _context))\n        ...\n        //init other fields\n        ...\n    }\n    //other methods\n    ...\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651632526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045862,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/66/ff9fb166.jpg","nickname":"姚磊","note":"","ucode":"94C1399716AAD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385282,"discussion_content":"有类似的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626964083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300514,"user_name":"大海浮萍","can_delete":false,"product_type":"c1","uid":1067638,"ip_address":"","ucode":"7A3B9011C639ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/76/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1625202702,"is_pvip":false,"replies":[{"id":"108899","content":"持久化user是通过user repo进行的，user不会调用任何db 它只调用接口。从实际执行上看 user的确夹杂db行为，但是从user来看并没有，db行为被封装了<br>","user_name":"作者回复","comment_id":300514,"uid":"2537798","ip_address":"","utype":1,"ctime":1625207387,"user_name_real":"徐八叉"}],"discussion_count":4,"race_medal":0,"score":"5920169998","product_id":100082101,"comment_content":"我们最近在做聚合落地的时候确实遇到了性能问题，有两个问题想请教一下：<br>第一个问题，以user-subscription聚合为例，使用关联对象，那么在聚合的持久化上，是不是得分为两步？第一步是先在user实体中使用关联对象接口先持久化subscription的实体，第二步是等整个聚合计算结束后，再持久化聚合根用户，这样算是真正的业务关注点与技术关注点分离吗？毕竟你是在user实体中显示地调用接口做db操作。<br>第二个问题，随着迭代的进行，关联对象接口的impl类中db操作会越来越多，从而导致user行为中大量夹杂着和数据库的交互，会不会逐渐退化成面相过程编程？<br><br>课后题<br>在业务系统实践中，个人认为其中一大复杂度来源于规则校验，往往一个用例中伴随着大量的规则校验，这里面可能会有隐式概念，如果不能准确识别，并尽早建模，可能会导致代码臃肿，架构腐化","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522752,"discussion_content":"持久化user是通过user repo进行的，user不会调用任何db 它只调用接口。从实际执行上看 user的确夹杂db行为，但是从user来看并没有，db行为被封装了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625207387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382389,"discussion_content":"规则校验的话，建议看下周志明老师的架构课程。其中有个章节详细描述了如何优雅的设计校验。其实就是在实体对象上增加Valid注解，把验证逻辑内聚在实体中。 做到一处验证到处通用。符合DDD的充血行为","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1625554151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101556,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/f4/5bfc786a.jpg","nickname":"Vilochen.","note":"","ucode":"19D9BF8534B480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396984,"discussion_content":"如果不同业务对同一实体校验逻辑不同该如何处理呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632535535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382389,"ip_address":""},"score":396984,"extra":""}]},{"author":{"id":1181500,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/3c/ab8a4a6d.jpg","nickname":"awephy","note":"","ucode":"26B92D201881B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388318,"discussion_content":"他指的更多是业务规则，不是属性必要性检查规则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628693870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300356,"user_name":"狩月","can_delete":false,"product_type":"c1","uid":1204178,"ip_address":"","ucode":"472CCBFBE77785","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/d2/a39e5cea.jpg","comment_is_top":false,"comment_ctime":1625126097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920093393","product_id":100082101,"comment_content":"这个模式很接地气啊！期待更多内容","like_count":1},{"had_liked":false,"id":358877,"user_name":"JianXu","can_delete":false,"product_type":"c1","uid":1033219,"ip_address":"上海","ucode":"2A61BDBB573BDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg","comment_is_top":false,"comment_ctime":1664959032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664959032","product_id":100082101,"comment_content":"本质上就是增加一层抽象，本来subscription 的逻辑是直接放在user 的实现类里，现在user 只接触代表subscription 的接口，具体的实现从user 类挪到了subscription 的实现类，也就是关联对象实现类。","like_count":0},{"had_liked":false,"id":358226,"user_name":"JianXu","can_delete":false,"product_type":"c1","uid":1033219,"ip_address":"上海","ucode":"2A61BDBB573BDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg","comment_is_top":false,"comment_ctime":1664089959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664089959","product_id":100082101,"comment_content":"public class Column {<br>    private List&lt;Subscription&gt; subscriptions;<br>    <br>    ....<br>}<br><br>老师，我没有明白为什么column 是代表所有订阅了专栏的用户，Iterable&lt;Subscription&gt; 代表的是订阅的专栏对象，对吗？怎么从subscriptions 里到用户呢？我们并没有从Subscription 到用户的关联啊。","like_count":0},{"had_liked":false,"id":342624,"user_name":"chmod","can_delete":false,"product_type":"c1","uid":1121078,"ip_address":"","ucode":"F148C85A7C9FCC","user_header":"https://static001.geekbang.org/account/avatar/00/11/1b/36/0998732e.jpg","comment_is_top":false,"comment_ctime":1650368500,"is_pvip":true,"replies":[{"id":"125208","content":"smart ui不需要domain model","user_name":"作者回复","comment_id":342624,"uid":"2537798","ip_address":"","utype":1,"ctime":1650440096,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1650368500","product_id":100082101,"comment_content":"这个真的能解决性能问题吗？<br>再复杂点的情况，比如h类包含alist 、blist、clist。这些全部都要在一个页面上显示。用仓储+Dao可以用一条sql解决。但是分解成关联对象模式的话，都得分开查。性能肯定更加差，这种情况有更好的解决方案么？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565320,"discussion_content":"smart ui不需要domain model","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650440096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339994,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1648529436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648529436","product_id":100082101,"comment_content":"针对接口编程，隐藏实现感觉就是DDD了","like_count":0},{"had_liked":false,"id":338153,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1582420,"ip_address":"","ucode":"349FD35822DC8A","user_header":"https://static001.geekbang.org/account/avatar/00/18/25/54/ef2ca14f.jpg","comment_is_top":false,"comment_ctime":1647326229,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647326229","product_id":100082101,"comment_content":"自问自答: <br>和用户订阅的分页为什么不封装在Subscription类中有什么区别?<br>MySubscription逻辑更加丰富, 可以表示一个用户拥有的那些订阅的模型.  它不是一个单纯的数据对象, 不是贫血模型. ","like_count":0},{"had_liked":false,"id":334422,"user_name":"Pen","can_delete":false,"product_type":"c1","uid":1802395,"ip_address":"","ucode":"0A88CBF6BCAAD5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erKop8iby4yp4Yhian8RPoBicWXviaevTMNsPpXNj1ccdWB0BiaIeIOibiaI6sXBeMj8p3eEIyvM9huKRM1g/132","comment_is_top":false,"comment_ctime":1644928534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644928534","product_id":100082101,"comment_content":"老师，同问MySubscriptions 在spring 项目中是不是可以直接@Autowired 注入user","like_count":0},{"had_liked":false,"id":322186,"user_name":"无争就是yk","can_delete":false,"product_type":"c1","uid":1019128,"ip_address":"","ucode":"8739E996ACD746","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/f8/d378c121.jpg","comment_is_top":false,"comment_ctime":1637226333,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1637226333","product_id":100082101,"comment_content":"UserRepositoryDB 中每次查询到的对象都要setMySubscription 这个隐性开销和团队认知成本不小。另外如果是在真实的spring 项目中，mySubscriptions 是注入到User 中的吗？这样的话感觉MySubscriptionsDB 持有User 对象有点奇怪。","like_count":0,"discussions":[{"author":{"id":1189765,"avatar":"https://static001.geekbang.org/account/avatar/00/12/27/85/06fbdeac.jpg","nickname":"Vincent","note":"","ucode":"F0A32C9210FF42","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558832,"discussion_content":"一样的问题，spring的框架怎么玩？mybatis都是注入的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648479322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321784,"user_name":"mars","can_delete":false,"product_type":"c1","uid":1407604,"ip_address":"","ucode":"1C57AEC0AC60D7","user_header":"https://static001.geekbang.org/account/avatar/00/15/7a/74/fcb8bc4c.jpg","comment_is_top":false,"comment_ctime":1637046369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637046369","product_id":100082101,"comment_content":"解决方式有点类似于DCI架构中的场景，在什么样的场景中扮演什么样的角色，从而有什么样的行为。分而治之，减少上帝类，好文。<br>之前可能只能只领域服务实现的部分逻辑可以聚合到模型中，聚合关系更强，👍","like_count":0},{"had_liked":false,"id":321323,"user_name":".benxiaohai52","can_delete":false,"product_type":"c1","uid":1221835,"ip_address":"","ucode":"8F748310484724","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/cb/407d9a81.jpg","comment_is_top":false,"comment_ctime":1636792644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636792644","product_id":100082101,"comment_content":"能否给出实用的demo关联对象相关的，这块一直是我的疑惑","like_count":0},{"had_liked":false,"id":315294,"user_name":"八歌","can_delete":false,"product_type":"c1","uid":1025218,"ip_address":"","ucode":"B54B99716358DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/c2/e8ab13d7.jpg","comment_is_top":false,"comment_ctime":1633789387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633789387","product_id":100082101,"comment_content":"计算机的所有问题，都可以通过夹塞一个中间层来解决😂","like_count":0},{"had_liked":false,"id":311568,"user_name":"黄大仙","can_delete":false,"product_type":"c1","uid":1610676,"ip_address":"","ucode":"6C79E6991EC3B8","user_header":"https://static001.geekbang.org/account/avatar/00/18/93/b4/22f438d0.jpg","comment_is_top":false,"comment_ctime":1631298404,"is_pvip":true,"replies":[{"id":"112899","content":"这哪里隐藏了？","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1631326587,"ip_address":"","comment_id":311568,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1631298404","product_id":100082101,"comment_content":"在建模完毕后，实现模型的接口时，暗含了实现人员必须知道的一个逻辑：UserRepositoryDB 必须在获取 User 时在 User 内设置好 MySubscription。<br>这个隐藏的逻辑该如何优雅地由建模人员传承到实现人员？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526662,"discussion_content":"这哪里隐藏了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631326587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127789,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/6d/836d7259.jpg","nickname":"常华","note":"","ucode":"C07D4A7C2895EC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414532,"discussion_content":"我理解这位同学的意思是，这个设计问题“如何将 MySubscriptionsDB 与 User 结合在一起？”的答案，如何能强制保证实现人员正确实现了？在您的例子中答案是实现的一部分，而没有作为显式的产出，作为模型的一部分。不知道是否理解正确？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636805699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1610676,"avatar":"https://static001.geekbang.org/account/avatar/00/18/93/b4/22f438d0.jpg","nickname":"黄大仙","note":"","ucode":"6C79E6991EC3B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1127789,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/6d/836d7259.jpg","nickname":"常华","note":"","ucode":"C07D4A7C2895EC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":540770,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640158969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414532,"ip_address":""},"score":540770,"extra":""}]},{"author":{"id":1206912,"avatar":"","nickname":"wwlleo","note":"","ucode":"5119810EA156F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583038,"discussion_content":"单元测试或者集成测试保证啊，你从UserRepository里面拿了一个User出来，结果MySubscriptions没有数据，测试就通不过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659881368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1057843,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","nickname":"阿甘","note":"","ucode":"BC93175B70E05D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1206912,"avatar":"","nickname":"wwlleo","note":"","ucode":"5119810EA156F9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588148,"discussion_content":"拿User的时候一定要获取“我的订阅”吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663575290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":583038,"ip_address":"广东"},"score":588148,"extra":""}]}]},{"had_liked":false,"id":311008,"user_name":"SochiLee","can_delete":false,"product_type":"c1","uid":1537865,"ip_address":"","ucode":"47596594EDF4D7","user_header":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","comment_is_top":false,"comment_ctime":1631014779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631014779","product_id":100082101,"comment_content":"如果要分页查user，则需要构建用户的拥有方，比如用户组UserGroup，再使用关系对象MyUsers进行分页查。我这么理解对吗？","like_count":0},{"had_liked":false,"id":309694,"user_name":"dbzh","can_delete":false,"product_type":"c1","uid":1005239,"ip_address":"","ucode":"047EE06E129E44","user_header":"","comment_is_top":false,"comment_ctime":1630306792,"is_pvip":true,"replies":[{"id":"112162","content":"超纲了","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1630310219,"ip_address":"","comment_id":309694,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630306792","product_id":100082101,"comment_content":"老师可否讲讲CQRS的项目为什么几乎都失败了呢？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525971,"discussion_content":"超纲了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630310219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308378,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1629562430,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1629562430","product_id":100082101,"comment_content":"觉得本质还是在于看待角度，在 subscription repository 上做分页是逻辑泄露，原因在于单个 subscription 不存在分页、总数一说。其实感觉在 List 的基础上实现分页也可以的，反正 list 也是一个接口，本身也就具有行为。可能没有经历过老师那个年代，OOP中内存集合和数据库的割裂没有太多感触，感觉增加个中间层就又链接上了（这不也是解决问题的万金油）","like_count":0,"discussions":[{"author":{"id":1029051,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b3/bb/abb7bfe3.jpg","nickname":"rusess","note":"","ucode":"C6F46B368F3392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405052,"discussion_content":"比如C# 的Endity Framework linq , IQueryable 代替 IList ?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634484635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306770,"user_name":"awephy","can_delete":false,"product_type":"c1","uid":1181500,"ip_address":"","ucode":"26B92D201881B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/3c/ab8a4a6d.jpg","comment_is_top":false,"comment_ctime":1628694749,"is_pvip":true,"replies":[{"id":"111114","content":"不是复杂查询 就是简单查询","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1628736950,"ip_address":"","comment_id":306770,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628694749","product_id":100082101,"comment_content":"从另一个角度看，前端界面显示的多样化是分页需求驱动的诱因，而领域建模往往不会把前端的变化纳入考虑范围内，所以分页的需求，使用数据驱动也未尝不可。倘若这么做，系统内会同时存在领域驱动和数据驱动两者设计理念，写入链路遵从领域驱动，保证领域的完整；复杂的查询链路遵从数据驱动，应对前端展示的需求。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524910,"discussion_content":"不是复杂查询 就是简单查询","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628736950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306669,"user_name":"张振华","can_delete":false,"product_type":"c1","uid":1201810,"ip_address":"","ucode":"292EFD886FC55A","user_header":"https://static001.geekbang.org/account/avatar/00/12/56/92/5cea89e6.jpg","comment_is_top":false,"comment_ctime":1628664615,"is_pvip":true,"replies":[{"id":"111052","content":"这只是泛型签名而已 跟贫血还是充血无关","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1628671588,"ip_address":"","comment_id":306669,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1628664615","product_id":100082101,"comment_content":"我的仓储是泛型IOrderRepository&lt;T,String&gt;，我在应用时不知道怎么传这个T。因为按照理解就是实体是充血模型，它作为泛型是否合适，应该怎么办？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524863,"discussion_content":"这只是泛型签名而已 跟贫血还是充血无关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628671588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/56/92/5cea89e6.jpg","nickname":"张振华","note":"","ucode":"292EFD886FC55A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388298,"discussion_content":"我把实体作为泛型的类型可以吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628686640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305574,"user_name":"张逃逃","can_delete":false,"product_type":"c1","uid":1435550,"ip_address":"","ucode":"DBF3A573CDF7DB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/9e/5853da22.jpg","comment_is_top":false,"comment_ctime":1628054491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628054491","product_id":100082101,"comment_content":"将关联对象作为实现聚合关系的默认方法。学到一招！","like_count":0},{"had_liked":false,"id":304137,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1627269642,"is_pvip":true,"replies":[{"id":"110067","content":"简单情况其实也对应不了数据库","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1627299320,"ip_address":"","comment_id":304137,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627269642","product_id":100082101,"comment_content":"问题原因：Java集合是一种隐含的原始类型。在简单的情况下它可以跟数据库的表相对应，但复杂情况下，没法实现它跟数据库之间的复杂转换。<br>解决方案：不要用原始集合，用自己封装的带有业务逻辑的“集合”。<br>豁然开朗。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523946,"discussion_content":"简单情况其实也对应不了数据库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627299320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303759,"user_name":"姚磊","can_delete":false,"product_type":"c1","uid":1045862,"ip_address":"","ucode":"94C1399716AAD2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/66/ff9fb166.jpg","comment_is_top":false,"comment_ctime":1626964255,"is_pvip":false,"replies":[{"id":"109959","content":"比如挂orm框架的事件 去做注入","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1627010359,"ip_address":"","comment_id":303759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626964255","product_id":100082101,"comment_content":"更简洁漂亮的做法，是通过 Java CDI API或是框架<br><br>这个能再具体说一下吗？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523813,"discussion_content":"比如挂orm框架的事件 去做注入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627010359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303659,"user_name":"輪迴","can_delete":false,"product_type":"c1","uid":1010641,"ip_address":"","ucode":"7504F61285BE35","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/d1/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1626918900,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626918900","product_id":100082101,"comment_content":"用组合，不用继承","like_count":0},{"had_liked":false,"id":303077,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1626579737,"is_pvip":false,"replies":[{"id":"109669","content":"看后面","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626588516,"ip_address":"","comment_id":303077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626579737","product_id":100082101,"comment_content":"这个user在不同的聚合根里是不是会有多个同名对象，然后实现不一样？否则user要处理的业务会爆炸","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523547,"discussion_content":"看后面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626588516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301965,"user_name":"rusess","can_delete":false,"product_type":"c1","uid":1029051,"ip_address":"","ucode":"C6F46B368F3392","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/bb/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1626000119,"is_pvip":false,"replies":[{"id":"109318","content":"不会 my subscription的实现里也是用join","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626135156,"ip_address":"","comment_id":301965,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1626000119","product_id":100082101,"comment_content":"感谢老师的好文。我的问题是， 如果是要获取用户列表，然后在每行用户信息上面同时显示一个专栏列表，通过MySubscriptions的方式查专栏 ，这样又会变成 N + 1 查。 实际的DB实现 应该是通过join的方式一次性查询，那我在模型上应该如何定义方法？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523138,"discussion_content":"不会 my subscription的实现里也是用join","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626135156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1057377,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/61/580bb3c3.jpg","nickname":"hk","note":"","ucode":"92996CA0BCDD66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571836,"discussion_content":"八叉老师你好，假如拆分了两个独立的用户库和专栏库，不能用join操作了,有啥好的解决方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652426584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":523138,"ip_address":""},"score":571836,"extra":""}]}]},{"had_liked":false,"id":300924,"user_name":"Reason","can_delete":false,"product_type":"c1","uid":1512618,"ip_address":"","ucode":"719EA4D5E5BC5A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epuvKVmiaiaYDRFVRX3rGwSS4T1jibEKibqZYQjxob03ibdmguKzRsftAssCTDVWrdXL7ojNagaIdjIvzA/132","comment_is_top":false,"comment_ctime":1625451115,"is_pvip":false,"replies":[{"id":"108995","content":"关联对象是领域模型一部分 为什么在领域之外？","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625457350,"ip_address":"","comment_id":300924,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1625451115","product_id":100082101,"comment_content":"getTotalSubscriptionFee应该是一个领域内的计算逻辑吧？通过接口定义的话，计算逻辑是不是就泄露到领域之外了？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522852,"discussion_content":"关联对象是领域模型一部分 为什么在领域之外？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625457350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537865,"avatar":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","nickname":"SochiLee","note":"","ucode":"47596594EDF4D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394013,"discussion_content":"这个问题的意思应该是“getTotalSubscriptionFee也有计算逻辑比如A+B+C，使用关联对象的话这个逻辑就会被写道MySubscriptionsDb中，所以逻辑泄漏出去了“，我也有这个疑惑。老师回答的关联对象是领域模型中的一部份，难道指的是MySubscriptions和MySubscriptionsDb都属于关联对象都属于模型中的一部分？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631689247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300901,"user_name":"Geek_5cfbf30","can_delete":false,"product_type":"c1","uid":1549766,"ip_address":"","ucode":"8541352DD3E2E8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4iaw2G8Giao2mp7R09IrHQIGfL6VM13Zts7EEUsDxlIP1ABF3x3iaK6ibZ5aIF2QSUheiaNyUfZMl6iaMg/132","comment_is_top":false,"comment_ctime":1625448211,"is_pvip":false,"replies":[{"id":"108987","content":"是不是关系性数据 并不影响在概念上是不是聚合 聚合也不是关系型数据库的概念","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625452172,"ip_address":"","comment_id":300901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625448211","product_id":100082101,"comment_content":"cqrs 是为了防止复杂的查询增加了领域逻辑的复杂度, 毕竟读的请求逻辑不会很复杂, 会需要获取多个聚合根才能构造出对象, 也是降低落地DDD的复杂度, 毕竟查询还是可以按照以前直接写sql的方式, 而且可以优化性能, 但是边界确实容易扩大. 我们没有再重新定义一个新的读模型, 因为用于承载聚合的数据模型已经够用了. <br>之前也有疑惑碰到聚合有一对多或者多对多的情况如何处理, 之前是通过拆分成两个聚合处理的, 但拆分之后他们的关联又变得比较弱. 关联对象这个没想到, 后续可以好好实践一下.<br><br>我有个疑问, 如果用非关系型数据库如何处理复杂的查询, 因为通过聚合去存不一定能很好的满足读的需求, 设计聚合的时候不会去考虑读的问题, 但表设计的时候会有些考虑. <br>落地DDD一开始最不适应就是性能问题, 例如聚合需要整个保存整个读取, 目前项目数据量不大, 所以大家都觉得问题不大, 但后面量大了, 并发量大了, 有些担心会出问题.","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522846,"discussion_content":"是不是关系性数据 并不影响在概念上是不是聚合 聚合也不是关系型数据库的概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625452172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300798,"user_name":"箭和方糖","can_delete":false,"product_type":"c1","uid":1938767,"ip_address":"","ucode":"818AAAFC0FD681","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIibashTHtGDWH5L0NlbuOrA6ZuI4uc1HkMD0hbIt8iaoH8hFf3jpb8jjhsvrRLTIazZP3YoR5WpMpg/132","comment_is_top":false,"comment_ctime":1625391184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625391184","product_id":100082101,"comment_content":"这个模式确实很巧妙，称得上是惊喜。然而它却是情理之中，利用面向对象的接口抽象实现，妙！","like_count":0},{"had_liked":false,"id":300722,"user_name":"四仔","can_delete":false,"product_type":"c1","uid":1047789,"ip_address":"","ucode":"7EACD1EA498B47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/ed/e066bbf2.jpg","comment_is_top":false,"comment_ctime":1625328030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625328030","product_id":100082101,"comment_content":"越看越觉得值！！！","like_count":0},{"had_liked":false,"id":300382,"user_name":"威","can_delete":false,"product_type":"c1","uid":1068542,"ip_address":"","ucode":"C921CDCB22B9A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","comment_is_top":false,"comment_ctime":1625133138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625133138","product_id":100082101,"comment_content":"希望老师后面能介绍一些异步回调怎样结合到领域建模里面去","like_count":0},{"had_liked":false,"id":300355,"user_name":"狩月","can_delete":false,"product_type":"c1","uid":1204178,"ip_address":"","ucode":"472CCBFBE77785","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/d2/a39e5cea.jpg","comment_is_top":false,"comment_ctime":1625126052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625126052","product_id":100082101,"comment_content":"有点像控制的更精细的ORM Lazyload?","like_count":0},{"had_liked":false,"id":300308,"user_name":"威","can_delete":false,"product_type":"c1","uid":1068542,"ip_address":"","ucode":"C921CDCB22B9A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","comment_is_top":false,"comment_ctime":1625104822,"is_pvip":false,"replies":[{"id":"108863","content":"也可以转换为数据视角 然后通过关联对象封装","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1625107896,"ip_address":"","comment_id":300308,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625104822","product_id":100082101,"comment_content":"老师，请问如果不是访问数据库，而是说技术上需要调用RPC，或者去缓存例如REDIS取数据，这样的逻辑要怎样封装呢","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522704,"discussion_content":"也可以转换为数据视角 然后通过关联对象封装","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625107896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}