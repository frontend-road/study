{"id":212049,"title":"58 | 模板模式（上）：剖析模板模式在JDK、Servlet、JUnit等中的应用","content":"<p>上两节课我们学习了第一个行为型设计模式，观察者模式。针对不同的应用场景，我们讲解了不同的实现方式，有同步阻塞、异步非阻塞的实现方式，也有进程内、进程间的实现方式。除此之外，我还带你手把手实现了一个简单的EventBus框架。</p><p>今天，我们再学习另外一种行为型设计模式，模板模式。我们多次强调，绝大部分设计模式的原理和实现，都非常简单，难的是掌握应用场景，搞清楚能解决什么问题。模板模式也不例外。模板模式主要是用来解决复用和扩展两个问题。我们今天会结合Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList四个例子来具体讲解这两个作用。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>模板模式的原理与实现</h2><p>模板模式，全称是模板方法设计模式，英文是Template Method Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：</p><blockquote>\n<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>\n</blockquote><!-- [[[read_end]]] --><p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p><p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>原理很简单，代码实现就更加简单，我写了一个示例代码，如下所示。templateMethod()函数定义为final，是为了避免子类重写它。method1()和method2()定义为abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。</p><pre><code>public abstract class AbstractClass {\n  public final void templateMethod() {\n    //...\n    method1();\n    //...\n    method2();\n    //...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n}\n\npublic class ConcreteClass1 extends AbstractClass {\n  @Override\n  protected void method1() {\n    //...\n  }\n  \n  @Override\n  protected void method2() {\n    //...\n  }\n}\n\npublic class ConcreteClass2 extends AbstractClass {\n  @Override\n  protected void method1() {\n    //...\n  }\n  \n  @Override\n  protected void method2() {\n    //...\n  }\n}\n\nAbstractClass demo = ConcreteClass1();\ndemo.templateMethod();\n</code></pre><h2>模板模式作用一：复用</h2><p>开篇的时候，我们讲到模板模式有两大作用：复用和扩展。我们先来看它的第一个作用：复用。</p><p>模板模式把一个算法中不变的流程抽象到父类的模板方法templateMethod()中，将可变的部分method1()、method2()留给子类ContreteClass1和ContreteClass2来实现。所有的子类都可以复用父类中模板方法定义的流程代码。我们通过两个小例子来更直观地体会一下。</p><h3>1.Java InputStream</h3><p>Java IO类库中，有很多类的设计用到了模板模式，比如InputStream、OutputStream、Reader、Writer。我们拿InputStream来举例说明一下。</p><p>我把InputStream部分相关代码贴在了下面。在代码中，read()函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了read()，只是参数跟模板方法不同。</p><pre><code>public abstract class InputStream implements Closeable {\n  //...省略其他代码...\n  \n  public int read(byte b[], int off, int len) throws IOException {\n    if (b == null) {\n      throw new NullPointerException();\n    } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {\n      throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n      return 0;\n    }\n\n    int c = read();\n    if (c == -1) {\n      return -1;\n    }\n    b[off] = (byte)c;\n\n    int i = 1;\n    try {\n      for (; i &lt; len ; i++) {\n        c = read();\n        if (c == -1) {\n          break;\n        }\n        b[off + i] = (byte)c;\n      }\n    } catch (IOException ee) {\n    }\n    return i;\n  }\n  \n  public abstract int read() throws IOException;\n}\n\npublic class ByteArrayInputStream extends InputStream {\n  //...省略其他代码...\n  \n  @Override\n  public synchronized int read() {\n    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;\n  }\n}\n</code></pre><h3>2.Java AbstractList</h3><p>在Java AbstractList类中，addAll()函数可以看作模板方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但函数实现直接抛出了UnsupportedOperationException异常。前提是，如果子类不重写是不能使用的。</p><pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {\n    rangeCheckForAdd(index);\n    boolean modified = false;\n    for (E e : c) {\n        add(index++, e);\n        modified = true;\n    }\n    return modified;\n}\n\npublic void add(int index, E element) {\n    throw new UnsupportedOperationException();\n}\n</code></pre><h2>模板模式作用二：扩展</h2><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转，你可以结合<a href=\"https://time.geekbang.org/column/article/177444\">第19节</a>来一块理解。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。我们通过Junit TestCase、Java Servlet两个例子来解释一下。</p><h3>1.Java Servlet</h3><p>对于Java Web项目开发来说，常用的开发框架是SpringMVC。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发Web项目，必然会用到Servlet。实际上，使用比较底层的Servlet来开发Web项目也不难。我们只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，来分别处理get和post请求。具体的代码示例如下所示：</p><pre><code>public class HelloServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req, resp);\n  }\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(&quot;Hello World.&quot;);\n  }\n}\n</code></pre><p>除此之外，我们还需要在配置文件web.xml中做如下配置。Tomcat、Jetty等Servlet容器在启动的时候，会自动加载这个配置文件中的URL和Servlet之间的映射关系。</p><pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;/servlet-class&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre><p>当我们在浏览器中输入网址（比如，<a href=\"http://127.0.0.1:8080/hello\">http://127.0.0.1:8080/hello</a> ）的时候，Servlet容器会接收到相应的请求，并且根据URL和Servlet之间的映射关系，找到相应的Servlet（HelloServlet），然后执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据（“Hello world”）到网页。</p><p>我们现在来看，HttpServlet的service()函数长什么样子。</p><pre><code>public void service(ServletRequest req, ServletResponse res)\n    throws ServletException, IOException\n{\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &amp;&amp;\n            res instanceof HttpServletResponse)) {\n        throw new ServletException(&quot;non-HTTP request or response&quot;);\n    }\n    request = (HttpServletRequest) req;\n    response = (HttpServletResponse) res;\n    service(request, response);\n}\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n{\n    String method = req.getMethod();\n    if (method.equals(METHOD_GET)) {\n        long lastModified = getLastModified(req);\n        if (lastModified == -1) {\n            // servlet doesn't support if-modified-since, no reason\n            // to go through further expensive logic\n            doGet(req, resp);\n        } else {\n            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince &lt; lastModified) {\n                // If the servlet mod time is later, call doGet()\n                // Round down to the nearest second for a proper compare\n                // A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            }\n        }\n    } else if (method.equals(METHOD_HEAD)) {\n        long lastModified = getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n    } else if (method.equals(METHOD_PUT)) {\n        doPut(req, resp);\n    } else if (method.equals(METHOD_DELETE)) {\n        doDelete(req, resp);\n    } else if (method.equals(METHOD_OPTIONS)) {\n        doOptions(req,resp);\n    } else if (method.equals(METHOD_TRACE)) {\n        doTrace(req,resp);\n    } else {\n        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);\n        Object[] errArgs = new Object[1];\n        errArgs[0] = method;\n        errMsg = MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    }\n}\n</code></pre><p>从上面的代码中我们可以看出，HttpServlet的service()方法就是一个模板方法，它实现了整个HTTP请求的执行流程，doGet()、doPost()是模板中可以由子类来定制的部分。实际上，这就相当于Servlet框架提供了一个扩展点（doGet()、doPost()方法），让框架用户在不用修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><h3>2.JUnit TestCase</h3><p>跟Java Servlet类似，JUnit框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown()等），让框架用户可以在这些扩展点上扩展功能。</p><p>在使用JUnit测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的TestCase类。在TestCase类中，runBare()函数是模板方法，它定义了执行测试用例的整体流程：先执行setUp()做些准备工作，然后执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。</p><p>TestCase类的具体代码如下所示。尽管setUp()、tearDown()并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但\b这部分也是可以在子类中定制的，所以也符合模板模式的定义。</p><pre><code>public abstract class TestCase extends Assert implements Test {\n  public void runBare() throws Throwable {\n    Throwable exception = null;\n    setUp();\n    try {\n      runTest();\n    } catch (Throwable running) {\n      exception = running;\n    } finally {\n      try {\n        tearDown();\n      } catch (Throwable tearingDown) {\n        if (exception == null) exception = tearingDown;\n      }\n    }\n    if (exception != null) throw exception;\n  }\n  \n  /**\n  * Sets up the fixture, for example, open a network connection.\n  * This method is called before a test is executed.\n  */\n  protected void setUp() throws Exception {\n  }\n\n  /**\n  * Tears down the fixture, for example, close a network connection.\n  * This method is called after a test is executed.\n  */\n  protected void tearDown() throws Exception {\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>在模板模式经典的实现中，模板方法定义为final，可以避免被子类重写。需要子类重写的方法定义为abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。</p><p>模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><h2>课堂讨论</h2><p>假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？</p><pre><code>public abstract class AbstractClass {\n  public final void templateMethod1() {\n    //...\n    method1();\n    //...\n    method2();\n    //...\n  }\n  \n  public final void templateMethod2() {\n    //...\n    method3();\n    //...\n    method4();\n    //...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n  protected abstract void method3();\n  protected abstract void method4();\n}\n</code></pre><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？","id":211239},"right":{"article_title":"59 | 模板模式（下）：模板模式与Callback回调函数有何区别和联系？","id":212802}},"comments":[{"had_liked":false,"id":188734,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1584409659,"is_pvip":false,"discussion_count":15,"race_medal":0,"score":"925002378299","product_id":100039001,"comment_content":"文末的问题，在 spring 生命周期中，InstantiationAwareBeanPostProcessorAdapter<br>就是解决这个问题的。<br>写个适配器，把所有抽象方法默认实现一下，子类继承这个 adapter 就行了。","like_count":216,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476835,"discussion_content":"我理解的面向对象分析，就是需求分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188544,"user_name":"Eclipse","can_delete":false,"product_type":"c1","uid":1589989,"ip_address":"","ucode":"E7EB0BA99FA644","user_header":"https://static001.geekbang.org/account/avatar/00/18/42/e5/61cfe267.jpg","comment_is_top":false,"comment_ctime":1584366883,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"413901227299","product_id":100039001,"comment_content":"可以借鉴AbstractList的addall实现。提供默认的方法method1...method4方法，每个方法直接抛出异常，使用模板方法的时候强制重写用到的method方法，用不到的method不用重写。","like_count":97,"discussions":[{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300950,"discussion_content":"不是抛异常，是直接定义为空方法","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1598337583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301464,"discussion_content":"非抽象的方法你怎么让实现为空？只能抛异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598532181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300950,"ip_address":""},"score":301464,"extra":""},{"author":{"id":1590960,"avatar":"https://static001.geekbang.org/account/avatar/00/18/46/b0/4f45e06e.jpg","nickname":"天雨流芳","note":"","ucode":"81657BA9C900FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1613665,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/61/c46b42f4.jpg","nickname":"talkyoung","note":"","ucode":"8D231FA9004B64","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318754,"discussion_content":"？？？ 不填写逻辑代码，不就是空方法么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603845503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301464,"ip_address":""},"score":318754,"extra":""},{"author":{"id":2317835,"avatar":"","nickname":"Geek_cead38","note":"","ucode":"7F8350E9DB040E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1590960,"avatar":"https://static001.geekbang.org/account/avatar/00/18/46/b0/4f45e06e.jpg","nickname":"天雨流芳","note":"","ucode":"81657BA9C900FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327886,"discussion_content":"你子类察觉不到是空方法啊，又不告诉子类需要重写，业务不就出错了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1606008490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318754,"ip_address":""},"score":327886,"extra":""}]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392986,"discussion_content":"正解，提供默认的方法实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631196769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414289,"discussion_content":"nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636709580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1611241,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/e9/46acca0c.jpg","nickname":"谈笑风生又一年","note":"","ucode":"9E72A85B14F38D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336900,"discussion_content":"控制子类不掉用就是了，子类调用本身就是问题，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608726678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188027,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1584315354,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"297937058778","product_id":100039001,"comment_content":"如果两个模版方法没有耦合，可以拆分成两个类，如果不能拆分，那就为每个方法提供默认实现","like_count":70},{"had_liked":false,"id":188801,"user_name":"最好的狗焕啊","can_delete":false,"product_type":"c1","uid":1669182,"ip_address":"","ucode":"6F77A37326618F","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/3e/84b18502.jpg","comment_is_top":false,"comment_ctime":1584417129,"is_pvip":false,"discussion_count":42,"race_medal":0,"score":"194857945449","product_id":100039001,"comment_content":"争哥，一年前就很崇拜你了，但是现在很迷茫，三年的开发经验了，一直在小公司，做的项目最多的数据量也只是十几万的用户，平常下班每天都会坚持学习两个小时，已经坚持一年半了，看了数据结构和算法，还有认真刷过题，看了网络协议，也看了框架方面的书等等，也认真做了笔记，然后想投递独角兽公司，但是简历都不通过，理由是学历和项目都没有亮点，我是本科毕业，看了网上的一些阿里或者百度这样的公司的面试题，发现自己也会，但是投递的简历都不通过，真的很迷茫，不知道这样的坚持有没有用，现在想回到老家一个二线城市，做着一份养老的工作","like_count":46},{"had_liked":false,"id":188816,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1584420684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"96073701196","product_id":100039001,"comment_content":"参考装饰器模式那一课中JAVA IO类库中的做法，引入一个中间父类，实现所有的抽象方法，然后再让业务类去继承这个中间的父类。","like_count":23},{"had_liked":false,"id":188287,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1584335814,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"96073616326","product_id":100039001,"comment_content":"提供一个 Base 类，实现 method1 到 method4 的所有抽象方法，然后子类继承 Base 类，一般可以直接复用 Base 类中的 method1 到 method4 方法，如果需要重写，直接重写该方法就好。这样就能省去所有子类实现所有抽象方法<br><br>继承抽象方法的基类 Base<br>public class Base extends AbstractClass {<br>    @Override<br>    protected void method1() {<br>        System.out.println(&quot;1&quot;);<br>    }<br><br>    @Override<br>    protected void method2() {<br>        System.out.println(&quot;2&quot;);<br>    }<br><br>    @Override<br>    protected void method3() {<br>        System.out.println(&quot;3&quot;);<br>    }<br><br>    @Override<br>    protected void method4() {<br>        System.out.println(&quot;4&quot;);<br>    }<br>}<br><br>子类 A 需要重写 method1 方法<br>public class SubA extends Base {<br><br>    &#47;&#47; 只需要重写 method1<br>    @Override<br>    public void method1() {<br>        System.out.println(&quot;重写 method1&quot;);<br>    }<br><br>    public static void main(String[] args) {<br>        Base A = new SubA();<br>        A.templateMethod1();<br>    }<br>}<br><br>输出结果为<br><br>重写 method1<br>2<br><br>","like_count":23},{"had_liked":false,"id":188023,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1584314110,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"74598758142","product_id":100039001,"comment_content":"父类中不用抽象方法，提供一个空的实现，子类根据需要重写。","like_count":17,"discussions":[{"author":{"id":1119911,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/a7/b3491533.jpg","nickname":"酸菜泡面","note":"","ucode":"74592566C52E74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155723,"discussion_content":"对照着mvc的例子写一个贫血的demo，反过来就容易理解充血模型了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580278677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131957,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","nickname":"王振华 程序员","note":"","ucode":"31BB337642B882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70186,"discussion_content":"我也准备找本java的书，跟着敲出个小项目，估计就理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575335628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188093,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1584321058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40239026722","product_id":100039001,"comment_content":"课后思考：<br>一. 能修改框架代码情况：<br>定义一个父类，给不需要调用的抽象方法一个默认实现，子类继承该父类。<br><br>二. 如果可以修改框架代码的情况下：<br>1.templateMethod1与templateMethod2相关：可以将不需要调用的方法修改成protected并提供默认空实现。<br>2.templateMethod1与templateMethod2不相关：接口隔离原则，考虑将AbstractClass拆分成两个类分别定义两个方法。","like_count":10},{"had_liked":false,"id":188020,"user_name":"宁锟","can_delete":false,"product_type":"c1","uid":1249781,"ip_address":"","ucode":"815FC9A9EBB109","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","comment_is_top":false,"comment_ctime":1584313686,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27354117462","product_id":100039001,"comment_content":"定义两个抽象类，继承模板类，分别给不需要的方法定义空实现","like_count":6,"discussions":[{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233676,"discussion_content":"感觉模板模式和抽象类的实现方式和场景相同啊？\n他俩有什么区别呢？求大佬解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586938235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253344,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602690005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18782559189","product_id":100039001,"comment_content":"不会java 所以一下没看懂模版方法模式  看了其他资料才明白 所以记录一下<br><br>我们把装修房子这件事比做模版方法，装修房子的大流程事固定不变<br>把安装水电，收纳柜，电视墙这些细节比做可以被子类实现的抽象方法<br><br>我们可以通过重写安装水电，收纳柜，电视墙 这些方法来自定义我们的装修风格，但是不影响整体的装修流程","like_count":4},{"had_liked":false,"id":188026,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1584315085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469216973","product_id":100039001,"comment_content":"如果其他的类不考虑复用的话，可以将这些抽取成一个基类，就是两个抽象类。分别给不需要的方法定义空实现。","like_count":3},{"had_liked":false,"id":263107,"user_name":"Geek_cead38","can_delete":false,"product_type":"c1","uid":2317835,"ip_address":"","ucode":"7F8350E9DB040E","user_header":"","comment_is_top":false,"comment_ctime":1606008807,"is_pvip":false,"replies":[{"id":"96109","content":"������","user_name":"作者回复","comment_id":263107,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700845,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"10195943399","product_id":100039001,"comment_content":"我觉得即便是使用装饰器还是直接重写method1-4，对于需要子类重写的方法要么抛不支持异常，要么抽象，不然子类察觉不到必须重写，导致模板函数的业务出错","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510098,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384853,"discussion_content":"争哥回复的杂是 乱码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626772790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206804,"user_name":"好饿早知道送外卖了","can_delete":false,"product_type":"c1","uid":1132304,"ip_address":"","ucode":"AED22DB5BF8FC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","comment_is_top":false,"comment_ctime":1586938209,"is_pvip":false,"discussion_count":3,"race_medal":2,"score":"10176872801","product_id":100039001,"comment_content":"感觉模板模式和抽象类的实现方式和场景相同啊？<br>他俩有什么区别呢？求大佬们解惑","like_count":2,"discussions":[{"author":{"id":2258139,"avatar":"https://static001.geekbang.org/account/avatar/00/22/74/db/9a19a859.jpg","nickname":"海南小硕哥","note":"","ucode":"EA5AA6D5E35667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338281,"discussion_content":"模板模式可以通过抽象类的方式来实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609231489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028947,"avatar":"","nickname":"Geek5350","note":"","ucode":"6EB4553707C357","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380733,"discussion_content":"模板模式基于抽象类，单纯抽象类不能约束执行流程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624677922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338869,"discussion_content":"除了上面的解释，我想还可以这么理解，模板方法模式复用的是行为流程，扩展的是行为流程中的具体环节的行为，其目的是对行为流程建模，行为针对的对象往往通过动态注入；而抽象类是对物Object的建模，即包括属性，也包括行为。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609406587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188095,"user_name":"付昱霖","can_delete":false,"product_type":"c1","uid":1488464,"ip_address":"","ucode":"9CB3A8A8504885","user_header":"https://static001.geekbang.org/account/avatar/00/16/b6/50/5d9ef58d.jpg","comment_is_top":false,"comment_ctime":1584321209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174255801","product_id":100039001,"comment_content":"使用外观模式，用一个新类再次包装，只暴露需要的接口。","like_count":2},{"had_liked":false,"id":188012,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1584296757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174231349","product_id":100039001,"comment_content":"课后作业的思考：对于必须要子类实现的方法定义为抽象方法或throw Exception，对于变动比较少但是同时也不想失去扩展性的方法添加默认实现，调用时优先获取用户自定义方法，获取不到的情况下使用默认方法","like_count":2},{"had_liked":false,"id":301861,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1625922601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920889897","product_id":100039001,"comment_content":"用组合代替继承","like_count":1},{"had_liked":false,"id":231649,"user_name":"向往的生活","can_delete":false,"product_type":"c1","uid":1397298,"ip_address":"","ucode":"0E8DB45357820F","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","comment_is_top":false,"comment_ctime":1593743037,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5888710333","product_id":100039001,"comment_content":"个人感觉这里的复用和扩展都是一回事呢。核心思想就是将不变和可变进行分离。","like_count":1},{"had_liked":false,"id":190462,"user_name":"柏油","can_delete":false,"product_type":"c1","uid":1604468,"ip_address":"","ucode":"92BFEEEE8BBFA0","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/74/9b88e040.jpg","comment_is_top":false,"comment_ctime":1584662543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879629839","product_id":100039001,"comment_content":"可以提供一个adapter默认实现所有方法，子类重写需要的方法即可，比如Spring的InstantiationAwareBeanPostProcessorAdapter就是给所有方法提供默认实现，不过jkd1.8在接口中可以使用default默认实现，在InstantiationAwareaBeanPostProcessor接口中提供了默认实现，也就不需要在用Adapter 了","like_count":1},{"had_liked":false,"id":188031,"user_name":"自来也","can_delete":false,"product_type":"c1","uid":1681814,"ip_address":"","ucode":"94CF8E5FF6DEC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/a9/96/6d517a06.jpg","comment_is_top":false,"comment_ctime":1584316233,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879283529","product_id":100039001,"comment_content":"Es框架里，abstractrunable是属于包装者还是模板。感觉更像包装者。不管啥了，总之觉得这样挺好用的。父类public就好了，就能解决没必要强制重写了。","like_count":1,"discussions":[{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205699,"discussion_content":"缺省适配器\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584333027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188010,"user_name":"Sinclairs","can_delete":false,"product_type":"c1","uid":1019373,"ip_address":"","ucode":"0042C53C86E3A2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/ed/ea2cbf3a.jpg","comment_is_top":false,"comment_ctime":1584294328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879261624","product_id":100039001,"comment_content":"如果项目中多次用到这个类的话, 可以单独实现一个基类来继承这个模版类, 将不需要的扩展方法进行默认实现.<br>项目开发中直接使用基类方法就好.","like_count":1},{"had_liked":false,"id":355534,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"上海","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1661477254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661477254","product_id":100039001,"comment_content":"我以前这样写过，终于知道，原来这也是个模式","like_count":0},{"had_liked":false,"id":351894,"user_name":"遇见阳光","can_delete":false,"product_type":"c1","uid":1203576,"ip_address":"","ucode":"378E5D37B3CD0E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/78/f011d586.jpg","comment_is_top":false,"comment_ctime":1658281755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658281755","product_id":100039001,"comment_content":"缺省适配器模式可以解决该问题.","like_count":0},{"had_liked":false,"id":348248,"user_name":"寒光","can_delete":false,"product_type":"c1","uid":1206187,"ip_address":"","ucode":"061BE413595F21","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","comment_is_top":false,"comment_ctime":1654874632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654874632","product_id":100039001,"comment_content":"父类可以全部空实现模板方法，子类按需要重写相应的模板方法。","like_count":0},{"had_liked":false,"id":347605,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1654219950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654219950","product_id":100039001,"comment_content":"我们可以实现一个子类，继承这个抽象类。然后对其中一个不需要使用的模板方法的抽象方法提供默认实现。抛出unsupport的异常。然后其他子类可以再继承这个默认实现类。只需要实现剩下的我们需要使用的模板方法即可。","like_count":0},{"had_liked":false,"id":331719,"user_name":"silas","can_delete":false,"product_type":"c1","uid":1553046,"ip_address":"","ucode":"EEFF1E8ED00EE6","user_header":"https://static001.geekbang.org/account/avatar/00/17/b2/96/a524ebf6.jpg","comment_is_top":false,"comment_ctime":1642736260,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642736260","product_id":100039001,"comment_content":"public void add(int index, E element) { throw new UnsupportedOperationException();} 这个的目的是什么呀?看到很多这样的写法,可是不清楚为什么要抛出异常呢?","like_count":0,"discussions":[{"author":{"id":1498641,"avatar":"https://static001.geekbang.org/account/avatar/00/16/de/11/72f96304.jpg","nickname":"M.O(∩_∩)O","note":"","ucode":"B245C2BA20DDA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550945,"discussion_content":"当然是不强制子类实现这个方法呐，例如栈就只需要实现push方法即可。但客户端类要调用的话还是得告诉用户这个方法不能用的，所以就使用抛异常的方案了；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644821318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325194,"user_name":"述为","can_delete":false,"product_type":"c1","uid":1238965,"ip_address":"","ucode":"E62AEC705AEDC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/b5/c08b71e1.jpg","comment_is_top":false,"comment_ctime":1638858738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638858738","product_id":100039001,"comment_content":"每一次看都有不同的收获，争哥牛逼","like_count":0},{"had_liked":false,"id":319837,"user_name":"Dale","can_delete":false,"product_type":"c1","uid":1242602,"ip_address":"","ucode":"AD19A33FE5EEDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/ea/5f046856.jpg","comment_is_top":false,"comment_ctime":1635962412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635962412","product_id":100039001,"comment_content":"1.文末问题，使用适配器模式写一个类来兼容这一个一&quot;有问题&quot;的类，它默认实现了不相关的接口，业务代码不直接继承框架提供的类，转而继承这个适配器类。<br><br>2.发现前端的 React 框架提供的类组件就是使用的模板模式：所有类组件都应该继承自 Component 类，而在 Component 类中实现了 setState 等模板方法，封装了组件 state 更新、UI 重新渲染等一系列功能，达到了“复用”的效果; 同时，通过强制类组件实现 render 方法，以及可选的 construstor 和各种生命周期钩子函数，允许组件实现各种定制化，达到了“扩展”的效果。以前隐隐约约觉得有些明白这种设计，但感觉直到今天才真的明白了，感谢小争哥！<br><br>---------------------------------------------------------------<br><br>看评论区有同学在说找工作的事情，打个小广告，坐标重庆，一知名外企，现大量招收前端、后端、大数据、机器学习、运营等人才。薪资待遇佳，上班不打卡！感兴趣的同学加q1176314965。","like_count":0},{"had_liked":false,"id":318708,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1635398408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635398408","product_id":100039001,"comment_content":"课后问题可以创建一个类继承抽象模板类，提供模板类抽象方法的默认实现逻辑。然后再创建子类继承这个类。子类就可以只实现需要的逻辑，其他抽象方法的实现可以使用父类的默认实现逻辑。","like_count":0},{"had_liked":false,"id":309589,"user_name":"韦春丹","can_delete":false,"product_type":"c1","uid":1048757,"ip_address":"","ucode":"7D84F50F08C05A","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/b5/95d1ff3e.jpg","comment_is_top":false,"comment_ctime":1630243276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630243276","product_id":100039001,"comment_content":"在抽象方法和具体子类之间加一层，类似 java.awt.event.WindowAdapter，为所有抽象方法提供一个空实现，所有具体子类都继承 Adapter","like_count":0},{"had_liked":false,"id":304385,"user_name":"Geek_24b328","can_delete":false,"product_type":"c1","uid":2703896,"ip_address":"","ucode":"A70EF877660962","user_header":"","comment_is_top":false,"comment_ctime":1627379073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627379073","product_id":100039001,"comment_content":"直接搞个抽象子类，private 封装一下不可以吗，","like_count":0},{"had_liked":false,"id":301839,"user_name":"AnChen","can_delete":false,"product_type":"c1","uid":1945351,"ip_address":"","ucode":"15DD4CD8DBF97A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK5OShV75tc9yo0E2DEu1vUvdwp2kVSFu2cDaffsJ71Z7zS89HYDbCrqkakTCLXfcNP4HvQkQRkQA/132","comment_is_top":false,"comment_ctime":1625906362,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625906362","product_id":100039001,"comment_content":"看了一下评论区的解决方案，发现其实本质来说，去除method1~4的abstract修饰词就能等价实现，所以我认为这个并不是一个理想的解决方案。看完下一节以后，恍然大悟，发现用callback来解决这个问题是比较合适的。这也就是58节中，组合优于继承的体现吧。","like_count":0},{"had_liked":false,"id":290745,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1619719172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619719172","product_id":100039001,"comment_content":"模版类是不是必须是抽象类吗？","like_count":0},{"had_liked":false,"id":288425,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618465569,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618465569","product_id":100039001,"comment_content":"课堂讨论<br>由于说的是框架提供的类，所以可以考虑提供基类继承默认实现，默认实现中抛出需重写异常<br>子类实现基类后，若调用了需要使用的模板方法而没重写其算法骨架中的抽象方法会抛出异常<br>若不需要调用其他模板方法则无影响","like_count":0},{"had_liked":false,"id":287535,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1618019204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618019204","product_id":100039001,"comment_content":"我个人的想法：<br>新增两个abstract 类，一个实现temp2中调用的抽象方法为空实现，保留temp1调用的method抽象方法，继续让子类去实现。另一个以此类推。<br>这个方式适用于模板方法个数比较少的情况","like_count":0},{"had_liked":false,"id":287432,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1617948312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617948312","product_id":100039001,"comment_content":"移动客户端的开发模式就是典型的模版模式，基础的视图控制器就是模版代码，我们在视图控制器的生命周期执行业务逻辑。","like_count":0},{"had_liked":false,"id":285796,"user_name":"CT","can_delete":false,"product_type":"c1","uid":1329656,"ip_address":"","ucode":"FF8725B6FABF54","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/f8/457342fa.jpg","comment_is_top":false,"comment_ctime":1617015104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617015104","product_id":100039001,"comment_content":"1. 看看能不能拆成多个类，使用组合方式<br>2. 提供默认实现类，子类继承这个默认实现类并重写需要的方法","like_count":0},{"had_liked":false,"id":285747,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1617000954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617000954","product_id":100039001,"comment_content":"思考题：<br>提供子类继承AbstractClass，将其中一个模板方法调用的抽象方法抛出空实现异常","like_count":0},{"had_liked":false,"id":280979,"user_name":"～灯火阑珊","can_delete":false,"product_type":"c1","uid":2004985,"ip_address":"","ucode":"B26CB4EA188C7A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/97/f9/3fcc851c.jpg","comment_is_top":false,"comment_ctime":1614509648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614509648","product_id":100039001,"comment_content":"后面课堂讨论是想说迪米特法则吧， 根据业务再次抽象出不同的接口， 谁用哪种接口就实现哪种， 一句话就是 “不要给我 我不需要的东西。”","like_count":0},{"had_liked":false,"id":274553,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1611057028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611057028","product_id":100039001,"comment_content":"课后题，属于原始类对不能用， 需要一种补救措施。因此，适配器模式解决。","like_count":0},{"had_liked":false,"id":270884,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1609311572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609311572","product_id":100039001,"comment_content":"模板模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。<br><br>&#47;&#47; 普通模板类<br>public abstract class MubanTest {<br>    void testCase(){<br>        System.out.println(&quot;start.....业务&quot;);<br>        if (1==1){<br>            hehe();<br>        }<br><br>        System.out.println(&quot;end。。。。业务&quot;);<br>    }<br><br>    abstract void hehe();<br>}<br><br>&#47;&#47; 子类继承MubanTest 实现抽象方法<br>public class MubanTestImpl extends MubanTest {<br>    @Override<br>    void hehe() {<br>        System.out.println(&quot;模板设计&quot;);<br>    }<br>}<br><br>&#47;&#47; main方法<br>public class TempTest {<br>    public static void main(String[] args) {<br>        MubanTestImpl mubanTest = new MubanTestImpl();<br>        mubanTest.testCase();<br>    }<br>}<br><br><br><br>你看，MubanTest类不需要管自己要不要去怎么实现hehe方法，而是管好自己，谁要是继承了这个模板，你就要把我的功能给实现了","like_count":0},{"had_liked":false,"id":270497,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1609146117,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609146117","product_id":100039001,"comment_content":"增加一个类默认实现所有模板方法，其余类继承这个类。","like_count":0},{"had_liked":false,"id":263541,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1606180339,"is_pvip":false,"replies":[{"id":"96093","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700736,"ip_address":"","comment_id":263541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606180339","product_id":100039001,"comment_content":"结尾问题有两种解决方法：<br>1. 写适配器来转化<br>2. 提供默认实现不要求强制实现","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510229,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260488,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1605022716,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605022716","product_id":100039001,"comment_content":"对于模板方法首先想到的是模板引擎，我们可以做个类比，在使用模板引擎的时候通常需要定义需要渲染的样式，然后通过占位符的方式指定个性化的内容，那么这里的占位符就是血肉，样式就是模板（骨架），这里的变与不变一目了然","like_count":0},{"had_liked":false,"id":256583,"user_name":"Leaf","can_delete":false,"product_type":"c1","uid":1102194,"ip_address":"","ucode":"9AB56B7971237D","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","comment_is_top":false,"comment_ctime":1603683928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603683928","product_id":100039001,"comment_content":"关于使用模板方法遇到的问题该怎么解决呢？<br>1. 随着业务逻辑的变更，模板方法做了重构，导致需要重写的方法（抽象方法），所有子类要做相应修改<br>2. 为了模板更通用，导致会新增很多需要重写的方法（抽象方法），已有的子类需要被迫实现新增的重写方法（抽象方法）<br>3. 模板模式，子类都是通过继承实现，当子类数量比较多的时候，发现代码的维护性和扩展性会降低","like_count":0},{"had_liked":false,"id":253118,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602602795,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602602795","product_id":100039001,"comment_content":"和装饰器 模式又是不同嘛 感觉场景是一样的","like_count":0,"discussions":[{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346539,"discussion_content":"太不同了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611986195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252661,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1602426921,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1602426921","product_id":100039001,"comment_content":"这个和装饰模式有多大区别啊，感觉几乎是一样的。末尾问题，一种解决思路是大部分留言的实现一个默认父类解决所有abstract 再继承父类单独重写需要的方法，还有一种就是从框架设计上层做个接口隔离 或者设计不同适配器，总之避免一次继承所有接口或者复写所有方法。","like_count":0,"discussions":[{"author":{"id":1206229,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","nickname":"Gopher","note":"","ucode":"3C1F9012BB486D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312581,"discussion_content":"模版方法不能重写，只能重写子类的其他方法，这样大的流程不会变，模版方法里的分支流程 我们可以自定义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602738495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1354013,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","nickname":"大方方","note":"","ucode":"621AD8F1485753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1206229,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","nickname":"Gopher","note":"","ucode":"3C1F9012BB486D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312668,"discussion_content":"谢谢回复  一开始直接感觉两个都是复写接口方法，根据你的提醒重新看了下装饰模式 是我忘了装饰模式细节。装饰模式是新类包含原有类并增强原有类同接口方法  模版模式是子类保持父类流程函数，而子类是继承后专注复写接口函数的实现细节，两者侧重点 一个是增强 一个是复写， 一个是包含一个是继承，我这样理解对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602764850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312581,"ip_address":""},"score":312668,"extra":""}]}]},{"had_liked":false,"id":252178,"user_name":"遇事不决，量子力学","can_delete":false,"product_type":"c1","uid":1397149,"ip_address":"","ucode":"6E5B015F4E427B","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/9d/e6947e9b.jpg","comment_is_top":false,"comment_ctime":1602163620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602163620","product_id":100039001,"comment_content":"add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的——这个不对吧，我实验了下父类中方法只单纯定义异常，子类可以直接使用啊。求争哥解答一下~","like_count":0},{"had_liked":false,"id":250924,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1601282732,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601282732","product_id":100039001,"comment_content":"感觉模板类和抽象类有点像，不过模板模式应该需要限定单个模板算法的大小，太大的模板不易维护、扩展，而且过大的模板很少不存在不能多解耦这种问题。","like_count":0},{"had_liked":false,"id":250784,"user_name":"Geek_558387","can_delete":false,"product_type":"c1","uid":1617369,"ip_address":"","ucode":"2EA857EBC365B5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FqWrN8aNrlXEfo2YeDeCRuWMZ57VzsNC0aibkEIdiaNBdUVPjlBXrg9F4Eb8uMFYckuSgmXQ49vT6SHoicAjeEGdA/132","comment_is_top":false,"comment_ctime":1601219652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601219652","product_id":100039001,"comment_content":"模板方法类中给默认空实现","like_count":0},{"had_liked":false,"id":247456,"user_name":"yht","can_delete":false,"product_type":"c1","uid":1731973,"ip_address":"","ucode":"9496D2BDFA0F41","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gCTJBEQ5byqtz6UxUWqlyCzyqo6lL7UlPSBjGaBhuo9iaOvAERLNibiacjCX02u7ugcgPx83502vgmHD56AaMOuWQ/132","comment_is_top":false,"comment_ctime":1599713328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599713328","product_id":100039001,"comment_content":"如果存在这种情况，就说明框架违反了单一性原则。拆分成两个独立功能的。","like_count":0},{"had_liked":false,"id":240385,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596882977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596882977","product_id":100039001,"comment_content":"1.第一种方法是拆成两个类  不过这个要看是不是符合单一职责原则<br>2.第二种 可以不定义抽象方法  在方法里面抛异常   子类使用必须重写方法","like_count":0},{"had_liked":false,"id":235233,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1594948605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594948605","product_id":100039001,"comment_content":"从单一职责来考虑一个模版类是不是应该只定义一个模版方法，然后通过组合来扩展需要有多个模版方法的问题，而不是把这个问题交个用户去解决；欢迎大家讨论。","like_count":0},{"had_liked":false,"id":232883,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1594137450,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1594137450","product_id":100039001,"comment_content":"1、不用抽象方法，给默认实现<br>2、如果关联不大，可以考虑拆分更加职责单一的接口","like_count":0},{"had_liked":false,"id":231765,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593767031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593767031","product_id":100039001,"comment_content":"课堂讨论：可以用先包装下，编写一个包装类，继承AbstractClass，分别对俩个模板方法中的具体流程中的方法进行重写。对需要用到的模板方法，在包装类的基础上进行扩展。和装饰模式一样，只装饰需要的方法，避免重写没必要装饰的方法","like_count":0},{"had_liked":false,"id":227614,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1592442657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592442657","product_id":100039001,"comment_content":"提供默认实现呗，在有需要的时候才强制要求实现。","like_count":0},{"had_liked":false,"id":226783,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592203592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592203592","product_id":100039001,"comment_content":"客户端&amp;前端开发中的各种生命周期函数，都是模板方法的使用","like_count":0},{"had_liked":false,"id":222396,"user_name":"Boogie 捷","can_delete":false,"product_type":"c1","uid":1541552,"ip_address":"","ucode":"9F54EF69CC0106","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/b0/496ae224.jpg","comment_is_top":false,"comment_ctime":1590784490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590784490","product_id":100039001,"comment_content":"读这篇文章让z我想到了之前在stack overflow看到的 framework vs library:<br>https:&#47;&#47;stackoverflow.com&#47;a&#47;148788","like_count":0},{"had_liked":false,"id":214106,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1588659551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588659551","product_id":100039001,"comment_content":"前面讲的有个地方不是给出答案了吗，直接在抽象类里面提供默认实现，不过是直接抛异常，子类不实现是没法用的<br>","like_count":0},{"had_liked":false,"id":212562,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1588150009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588150009","product_id":100039001,"comment_content":"课后题: 光靠基础屏蔽不了不适用的方法. 给予适配器模式, 在AbstractClass的实现类基础上在弄一个接口类.<br>public interface ITarget {<br>\tvoid templateMethod1();<br>\tvoid method1();<br>\tvoid method2();<br>}<br>调用<br>Demo01 extends AbstractClassAdaptor implements ITarget<br>ITarget vo = new Demo01();<br>vo.templateMethod1();<br>此时会屏蔽不需要的方法","like_count":0},{"had_liked":false,"id":208383,"user_name":"嘉一","can_delete":false,"product_type":"c1","uid":1196864,"ip_address":"","ucode":"8D16BD0B75B019","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","comment_is_top":false,"comment_ctime":1587348076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587348076","product_id":100039001,"comment_content":"文末的问题：<br>可以针对两个模板方法定义两个不同主题的抽象类继承框架的抽象类，在自己定义的抽象类里面对应的去空实现和自己不相关的另外两个抽象方法，同时保留和自己相关的两个抽象方法让自己的子类强制重写，这样一方面可以避免不相关的体力劳动，另一方面也保证了自己在使用模板方法时候一定会重写对应的抽象方法","like_count":0},{"had_liked":false,"id":204379,"user_name":"xuejian.sun","can_delete":false,"product_type":"c1","uid":1046667,"ip_address":"","ucode":"1970D91675122C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/8b/dc3dc04d.jpg","comment_is_top":false,"comment_ctime":1586393825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586393825","product_id":100039001,"comment_content":"有同事滥用模版模式，导致继承了四，五个左右的抽象类，人都看晕了，用那种方式重构比较好啊","like_count":0},{"had_liked":false,"id":203715,"user_name":"全炸攻城狮","can_delete":false,"product_type":"c1","uid":1315968,"ip_address":"","ucode":"DB437F9190575C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZIqY4cs6YKNx0OqeMrbjLIicqiafLNtLYJTN2zTtVPlwXZ7qlJ7xrGQictk1xCq5pEsIyqnkiaCib4zQ/132","comment_is_top":false,"comment_ctime":1586257586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586257586","product_id":100039001,"comment_content":"1.不用抽象方法<br>2.按照分类，定义不同的接口类，类里面是同类型的接口","like_count":0},{"had_liked":false,"id":202807,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1586072358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586072358","product_id":100039001,"comment_content":"父类不要用抽象方法，向AbstractList一样抛出UnsupportedOperationException异常。这样只有在用到的时候才会抛错。  个人还是喜欢用抽象方法，这样在编码的过程中需要强制实现，更不容易出错。","like_count":0},{"had_liked":false,"id":201818,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1585840249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585840249","product_id":100039001,"comment_content":"作为框架定义的扩展点这点，突然觉得视野开阔起来了","like_count":0},{"had_liked":false,"id":201189,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1585730506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585730506","product_id":100039001,"comment_content":"接口隔离，将不需要的接口函数拆分到不同的接口中，抽象类继承这个两个接口，子类仅实现必要的接口即可！","like_count":0},{"had_liked":false,"id":201167,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1585726596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585726596","product_id":100039001,"comment_content":"关于思考题  我觉得应该分离啊 那是两个独立的功能","like_count":0},{"had_liked":false,"id":199466,"user_name":"HYM","can_delete":false,"product_type":"c1","uid":1054178,"ip_address":"","ucode":"4E82D9A285DAFF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/e2/c21553c4.jpg","comment_is_top":false,"comment_ctime":1585489726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585489726","product_id":100039001,"comment_content":"放弃继承使用组合，把method1，method2抽成一个接口，把method3，method4抽成一个接口，在构造方法里根据需要传入对应的接口实例。很明显的是当方法数、方法调用比较简单时采用继承比较合适，但是当调用复杂且需要切分场景时组合更优。<br>另外一种实现是把所有的抽象方法在一个子类类全部实现一遍，但是这种模式是有缺陷的，如果需要调用templateMethod1但是复写了method1和method3，那编译和运行都是没有问题的，但显然最终运行结果是错的。","like_count":0},{"had_liked":false,"id":197627,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1585388684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585388684","product_id":100039001,"comment_content":"提供默认实现，可以为空或者抛出异常，由子类决定是否需要重写<br>也可以将模板拆分成两个类，也能做到一定程度的解耦","like_count":0},{"had_liked":false,"id":197541,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1585384194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585384194","product_id":100039001,"comment_content":"设计模式_58:<br># 作业<br>- 定义两个实现类`AbstractClass1`, `AbstractClass2`<br>- `AbstractClass1`实现方法`method1`,&#39;method2&#39;,将方法修改为`final`并抛出异常,如: <br>```<br>@Override<br>protected final void method3() {<br>    throw new UnsupportedOperationException(&quot;Don&#39;t support method3&quot;);<br>}<br><br>@Override<br>protected final void method4() {<br>    throw new UnsupportedOperationException(&quot;Don&#39;t support method4&quot;);<br>}<br>```<br># 感想<br><br>看内容的过程，反复出现的一个念头: <br>对修改封闭，对扩展开放。<br><br>继续呼应前面的内容。","like_count":0},{"had_liked":false,"id":196568,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1585293546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585293546","product_id":100039001,"comment_content":"提供默认子类，子类中提供默认的实现函数。","like_count":0},{"had_liked":false,"id":196321,"user_name":"change","can_delete":false,"product_type":"c1","uid":1110876,"ip_address":"","ucode":"D78B4B3752B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/5c/8704e784.jpg","comment_is_top":false,"comment_ctime":1585272387,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1585272387","product_id":100039001,"comment_content":"个人笔记：<br>模式在实现时，注意两点<br>1、抽象类中可以实现骨架算法，即串联基本步骤，如果不希望子类修改这个骨架算法，则将这个模板方法设置为final；<br>2、上面提到的基本步骤是可以在子类可定制的，如果必须在子类中才能确定基本步骤的实现，则将这个方法定义成抽象方法；<br>课后思考：<br>可以考虑在抽象类中提供这四个方法的默认实现。<br>个人思考：<br>在这里我想到Java 8中的接口的默认方法语法可以完善模板模式，即模板方法可以是接口的默认方法，基本步骤可以是接口的默认方法或抽象方法，这样子类就是实现这个接口，还可以继承其他的类","like_count":0},{"had_liked":false,"id":193938,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1584999565,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584999565","product_id":100039001,"comment_content":"对于思考题，提供一个类有默认的实现，子类继承这个类即可。","like_count":0},{"had_liked":false,"id":193848,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1584973649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584973649","product_id":100039001,"comment_content":"可以使用一个类去继承实现这4个抽象函数（空实现）。然后有新的类只需要继承并重写其中一个方法即可。这个有点像适配器模式了","like_count":0},{"had_liked":false,"id":193606,"user_name":"葛强强","can_delete":false,"product_type":"c1","uid":1711759,"ip_address":"","ucode":"E9E8B4047AAC63","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/8f/e0cddb8f.jpg","comment_is_top":false,"comment_ctime":1584932937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584932937","product_id":100039001,"comment_content":"根据类的单一职责原则，将抽象类拆分为两个抽象类。","like_count":0},{"had_liked":false,"id":193544,"user_name":"Xs.Ten","can_delete":false,"product_type":"c1","uid":1128376,"ip_address":"","ucode":"2368B9BDDDEE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b8/c887a5ea.jpg","comment_is_top":false,"comment_ctime":1584925600,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584925600","product_id":100039001,"comment_content":"我想到两个方法，请老师指正：<br>1.采用适配器模式；<br>2.抽离成多个类；","like_count":0},{"had_liked":false,"id":192597,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1584862574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584862574","product_id":100039001,"comment_content":"思考题：根据接口隔离的原则，可以根据业务需求，将AbstractClass的接口进行拆分","like_count":0},{"had_liked":false,"id":192025,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584815522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584815522","product_id":100039001,"comment_content":"最难的是掌握应用场景","like_count":0},{"had_liked":false,"id":191238,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1584757068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584757068","product_id":100039001,"comment_content":"不用抽象方法","like_count":0},{"had_liked":false,"id":190145,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1584606921,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584606921","product_id":100039001,"comment_content":"课堂讨论: 使用Callback优化模板方法模式<br>&#47;**模板类*&#47;<br>public class AbsClass {<br><br>    public void templateMethod1(Method1Callback method1Callback,<br>                                Method2Callback method2Callback){<br>        method1Callback.method1();<br>        method2Callback.method2();<br>    }<br><br>    public void templateMethod2(Method3Callback method3Callback,<br>                                Method4Callback method4Callback){<br>        method3Callback.method3();<br>        method4Callback.method4();<br>    }<br><br>    public interface Method1Callback{<br>        void method1();<br>    }<br><br>    public interface Method2Callback{<br>        void method2();<br>    }<br><br>    public interface Method3Callback{<br>        void method3();<br>    }<br><br>    public interface Method4Callback{<br>        void method4();<br>    }<br><br>}<br><br>public class ConcreteClass1 extends AbsClass {<br><br>    public ConcreteClass1() {<br><br>    }<br>}<br><br>       AbsClass instance1 = new ConcreteClass1();<br>        instance1.templateMethod1(() -&gt; System.out.println(&quot;method1 exec&quot;),<br>                () -&gt; System.out.println(&quot;method2 exec&quot;));","like_count":0,"discussions":[{"author":{"id":1355781,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/05/f47e16ec.jpg","nickname":"Tediyoung","note":"","ucode":"247C8FD976BFEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214793,"discussion_content":"ConcreteClass1 extends AbsClass 这里用的是继承我觉得不对，应该用组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585233979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189931,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1584583197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584583197","product_id":100039001,"comment_content":"写个 adapter 把方法重新实现一下, 子类继承 adapter","like_count":0},{"had_liked":false,"id":189835,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584575043,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584575043","product_id":100039001,"comment_content":"jdk8 可以添加默认接口实现","like_count":0},{"had_liked":false,"id":189599,"user_name":"徐旭","can_delete":false,"product_type":"c1","uid":1814806,"ip_address":"","ucode":"1D3091D15373E5","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b1/16/dd11930c.jpg","comment_is_top":false,"comment_ctime":1584533126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584533126","product_id":100039001,"comment_content":"得再加个父类实现空方法，感觉不是很优雅，层次加多了","like_count":0},{"had_liked":false,"id":189310,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1584499007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584499007","product_id":100039001,"comment_content":"课堂讨论<br>分两种情况, 如果子类没有实现方法的必须报错, 那就把父类拆成两个小父类, 各施其职. <br>否则, 就在父类里实现好空的待重写的方法, 这样子类就不用把不需要的都挨个实现一遍了.","like_count":0},{"had_liked":false,"id":189175,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1584463911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584463911","product_id":100039001,"comment_content":"复用指的是子类可以复用父类的模板方法；扩展指的是子类可以通过改写算法骨架内的子方法，实现自己的业务需求。","like_count":0},{"had_liked":false,"id":188871,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1584428807,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584428807","product_id":100039001,"comment_content":"补充一个模板方法模式的应用:<br>Tomcat中有各种组件,connect,service,server,warpper,host等等,他们有着类似的行为模式,init,start,stop,destroy等等,在这里tomcat就使用的模板方法模式,通过接口定义行为,通过抽象类做具体的实现,然后各个组件分别继承抽象类,达到代码的复用和扩展","like_count":0},{"had_liked":false,"id":188595,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1584372888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584372888","product_id":100039001,"comment_content":"课后习题：直接上例子吧？<br>package cn.hy.study.string;<br><br>public class AbstractClass {<br>    public final void templateMethod1() {<br>        method1();<br>        method2();<br>    }<br><br>    protected void method2() {<br>        System.out.println(&quot;method2&quot;);<br>    }<br><br>    protected void method1() {<br>        System.out.println(&quot;method1&quot;);<br>    }<br><br>    public final void templateMethod2() {<br>        method3();<br>        method4();<br>    }<br><br>    protected void method3() {<br>        System.out.println(&quot;method3&quot;);<br>    }<br><br>    protected void method4() {<br>        System.out.println(&quot;method4&quot;);<br>    }<br>}<br><br>class A extends AbstractClass {<br>    @Override<br>    protected void method2() {<br>        System.out.println(&quot;A method2&quot;);<br>    }<br>}<br><br>class B extends AbstractClass {<br>    @Override<br>    protected void method3() {<br>        System.out.println(&quot;B method3&quot;);<br>    }<br>}<br>class  Test {<br>    public static void main(String[] args) {<br>        A a = new A();<br>        B b = new B();<br>        a.templateMethod1();<br>        b.templateMethod2();<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":188589,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1584372573,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584372573","product_id":100039001,"comment_content":"课堂讨论题：我的理解是，这个第三方框架我们是无法修改其源码的。如果以此为前提，我也没想到好办法，1）再写一个基类继承框架的AbstractClass，对无需实现的方法直接给空实现或throw exception；2）新写的基类仍然是Abstract修饰，只对需要实现的方法处理","like_count":0},{"had_liked":false,"id":188543,"user_name":"LiuHu","can_delete":false,"product_type":"c1","uid":1039768,"ip_address":"","ucode":"284E2025C554BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","comment_is_top":false,"comment_ctime":1584366565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584366565","product_id":100039001,"comment_content":"课堂讨论：<br>抽象父类中不用抽象方法，提供一个空的实现，子类根据需要重写，这种方式违反了里氏替换原则原则，改变了父类的行为。<br>我觉得应该将两个模板方法解耦，拆分成两个抽象类是最合适的，这样满足<br>单一职责原则：将用到的和不会用到的拆分开，保持类的功能单一<br>接口隔离原则：客户端只用到 templateMethod1、templateMethod2中的一个，就不要两个都暴露。<br>","like_count":0},{"had_liked":false,"id":188481,"user_name":"123456","can_delete":false,"product_type":"c1","uid":1485820,"ip_address":"","ucode":"9F7C4F3E4416BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/ab/fc/38ccd186.jpg","comment_is_top":false,"comment_ctime":1584359476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584359476","product_id":100039001,"comment_content":"课堂讨论：把1，2方法 放到一个接口中，然后把接口作为模板方法的参数<br><br>不知是否叫策略设计模式了","like_count":0},{"had_liked":false,"id":188439,"user_name":"国奉","can_delete":false,"product_type":"c1","uid":1338758,"ip_address":"","ucode":"9946ADFA81D92E","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/86/2a0717df.jpg","comment_is_top":false,"comment_ctime":1584354172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584354172","product_id":100039001,"comment_content":"模板父类加一个钩子函数，子类来重写钩子函数，来确定那些方法需要调用","like_count":0},{"had_liked":false,"id":188313,"user_name":"rookie","can_delete":false,"product_type":"c1","uid":1573424,"ip_address":"","ucode":"9E28FA97C01F24","user_header":"","comment_is_top":false,"comment_ctime":1584339162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584339162","product_id":100039001,"comment_content":"根据问题描述，有两个templateMethod1()和templateMethod2()模板方法，其中实现调用的方法并没有并集，可以拆分成两个类。","like_count":0},{"had_liked":false,"id":188275,"user_name":"do it","can_delete":false,"product_type":"c1","uid":1309911,"ip_address":"","ucode":"E0753912E8F2AF","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d7/b102034a.jpg","comment_is_top":false,"comment_ctime":1584333905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584333905","product_id":100039001,"comment_content":"课堂讨论：<br>方法一：接口空实现。<br>方法二：定义新的抽象类，不需要使用的接口采用空实现的方式，拓展类基于该抽象类进行实现。","like_count":0},{"had_liked":false,"id":188271,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1584333705,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584333705","product_id":100039001,"comment_content":"首先我认为不应该拆开成两个类，因为如果子类需要实现所有的模版方法，因为java不支持多继承，拆成两个类就没法搞了。简单一点的办法就是把所有要实现的方法变成非抽象的，内部抛出异常, 使其直接使用就报错，只能继承。","like_count":0},{"had_liked":false,"id":188262,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1584333069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584333069","product_id":100039001,"comment_content":"缺省适配器<br>","like_count":0},{"had_liked":false,"id":188228,"user_name":"正在减肥的胖籽。","can_delete":false,"product_type":"c1","uid":1033728,"ip_address":"","ucode":"99E2E4DF599236","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/00/683bb4f0.jpg","comment_is_top":false,"comment_ctime":1584329049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584329049","product_id":100039001,"comment_content":"拆分成2个模板方法。","like_count":0},{"had_liked":false,"id":188216,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1584328327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584328327","product_id":100039001,"comment_content":"打卡  今日学习模版模式，收获：在一个方法中定义了一个算法骨架，并将某些步骤推迟到子类中实现。在我们的项目中也用到了这种模式，比如我们需要对接多个BU的系统，他们之间是通过消息来进行通信，我们定义好一个模板（处理流程），这样各个业务系统的对接时保证主要的流程不变，在预留的扩展点上就行代码编写，从而完成业务。<br>对于课堂讨论我的思考是：引入一个中间类来实现抽象方法，空实现。然后在具体的子类中继承这个中间类，选择性的复写需要的方法。","like_count":0},{"had_liked":false,"id":188181,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1584327079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584327079","product_id":100039001,"comment_content":"参考JUnit TestCase给抽象方法设置默认实现.","like_count":0},{"had_liked":false,"id":188172,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1584326313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584326313","product_id":100039001,"comment_content":"最简单的解决方案,就是对其一个个的实现默认方法,然后在默认实现中,抛出一个运行时异常,但是这种实现方式,很可能导致编写代码时候的不注意,没有在需要调用的方法中,实现原本的抽象方法从而出现异常,而且,按理来说,模板模式一般应用于业务逻辑相关的函数中,为了符合单一职责原则,尽量不要在一个类中出现两个乃至多个业务逻辑相关函数,于是,应该把多个业务逻辑函数拆分到不同的类中","like_count":0},{"had_liked":false,"id":188142,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1584324222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584324222","product_id":100039001,"comment_content":"课堂讨论: <br>考虑使用Adapter Pattern解决接口隔离问题. <br><br>public abstract class AbsClass {<br><br>    public final void templateMethod1(){<br>        method1();<br><br>        method2();<br>    }<br><br>    public final void templateMethod2(){<br>        method3();<br><br>        method4();<br>    }<br><br>    protected abstract void method1();<br>    protected abstract void method2();<br>    protected abstract void method3();<br>    protected abstract void method4();<br><br>}<br><br>public class AbsAdapter extends AbsClass {<br><br>    @Override<br>    protected void method1() {<br>        throw new IllegalStateException(&quot;need subclass implementaion&quot;);<br>    }<br><br>    @Override<br>    protected void method2() {<br>        throw new IllegalStateException(&quot;need subclass implementaion&quot;);<br>    }<br><br>    @Override<br>    protected void method3() {<br>        throw new IllegalStateException(&quot;need subclass implementaion&quot;);<br>    }<br><br>    @Override<br>    protected void method4() {<br>        throw new IllegalStateException(&quot;need subclass implementaion&quot;);<br>    }<br>}<br><br>&#47;**<br> * ConcreteClass1 只用到templateMethod1()*&#47;<br>public class ConcreteClass1 extends AbsAdapter {<br><br>    public ConcreteClass1() {<br>    }<br><br>    @Override<br>    protected void method1() {<br>        System.out.println(&quot;method1 exec&quot;);<br>    }<br><br>public class TestTemplate {<br><br>    public static void main(String[] args) {<br>        AbsClass instance1 = new ConcreteClass1();<br>        AbsClass instance2 = new ConcreteClass2();<br>        instance1.templateMethod1();<br>        instance2.templateMethod2();<br>    }<br>}<br>    @Override<br>    protected void method2() {<br>        System.out.println(&quot;method2 exec&quot;);<br>    }<br>}<br><br><br>","like_count":0},{"had_liked":false,"id":188131,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1584323377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584323377","product_id":100039001,"comment_content":"要点总结：<br>①模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤<br>② 在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。<br>③ 模板方法模式的两大特性：可复用和可扩展<br>思考题：<br>抽象方法改成非抽象的并提供默认的实现。<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476631,"discussion_content":"下一节课有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575424121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188122,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1584322893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584322893","product_id":100039001,"comment_content":"提供默认实现，子类只重写自己需要的方法，其他走父类的默认实现是不是就可以了","like_count":0},{"had_liked":false,"id":188117,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1584322398,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584322398","product_id":100039001,"comment_content":"模版方法是提供一个封装了固定流程业务实现逻辑，具体的实现可以延迟到子类. <br><br>针对课后题：<br>     可以提供默认的实现方法.如果有需要子类再根据实际情况去进行定制.","like_count":0},{"had_liked":false,"id":188060,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1584319412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584319412","product_id":100039001,"comment_content":"课堂讨论：不强势实现，或者，不同功能的模版方法类抽到不同类里面实现。","like_count":0},{"had_liked":false,"id":188055,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1584319084,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1584319084","product_id":100039001,"comment_content":"文中的contrete是什么意思？","like_count":0},{"had_liked":false,"id":188040,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1584317800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584317800","product_id":100039001,"comment_content":"使用策略模式，将模板方法内部的各个阶段操作抽象成不同的接口，根据需要去继承对应的接口并重新实现abstract方法","like_count":0},{"had_liked":false,"id":188032,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1584316255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584316255","product_id":100039001,"comment_content":"打卡","like_count":0}]}