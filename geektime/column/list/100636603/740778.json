{"id":740778,"title":"第 15 章 编译器核心技术概览(1)","content":"<h1 id=\"nav_point_141\">第 15 章　编译器核心技术概览</h1>\n<p>编译技术是一门庞大的学科，我们无法用几个章节对其做完善的讲解。但不同用途的编译器或编译技术的难度可能相差很大，对知识的掌握要求也会相差很多。如果你要实现诸如 C、JavaScript 这类<strong>通用用途语言</strong>（general purpose language），那么就需要掌握较多编译技术知识。例如，理解上下文无关文法，使用巴科斯范式（BNF），扩展巴科斯范式（EBNF）书写语法规则，完成语法推导，理解和消除左递归，递归下降算法，甚至类型系统方面的知识等。但作为前端工程师，我们应用编译技术的场景通常是：表格、报表中的自定义公式计算器，设计一种领域特定语言（DSL）等。其中，实现公式计算器甚至只涉及编译前端技术，而领域特定语言根据其具体使用场景和目标平台的不同，难度会有所不同。Vue.js 的模板和 JSX 都属于领域特定语言，它们的实现难度属于中、低级别，只要掌握基本的编译技术理论即可实现这些功能。</p>\n<h2 id=\"nav_point_142\">15.1　模板 DSL 的编译器</h2>\n<p>编译器其实只是一段程序，它用来将“一种语言 A”翻译成“另外一种语言 B”。其中，语言 A 通常叫作<strong>源代码</strong>（source code），语言 B 通常叫作<strong>目标代码</strong>（object code 或 target code）。编译器将源代码翻译为目标代码的过程叫作<strong>编译</strong>（compile）。完整的编译过程通常包含词法分析、语法分析、语义分析、中间代码生成、优化、目标代码生成等步骤，如图 15-1 所示。</p><!-- [[[read_end]]] -->\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00610.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-1　完整的编译过程</strong></p>\n<p>可以看到，整个编译过程分为编译前端和编译后端。编译前端包含词法分析、语法分析和语义分析，它通常与目标平台无关，仅负责分析源代码。编译后端则通常与目标平台有关，编译后端涉及中间代码生成和优化以及目标代码生成。但是，编译后端并不一定会包含中间代码生成和优化这两个环节，这取决于具体的场景和实现。中间代码生成和优化这两个环节有时也叫“中端”。</p>\n<p>图 15-1 展示了“教科书”式的编译模型，但 Vue.js 的模板作为 DSL，其编译流程会有所不同。对于 Vue.js 模板编译器来说，源代码就是组件的模板，而目标代码是能够在浏览器平台上运行的 JavaScript 代码，或其他拥有 JavaScript 运行时的平台代码，如图 15-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00611.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-2　Vue.js 模板编译器的目标代码是 JavaScript 代码</strong></p>\n<p>可以看到，Vue.js 模板编译器的目标代码其实就是渲染函数。详细而言，Vue.js 模板编译器会首先对模板进行词法分析和语法分析，得到模板 AST。接着，将模板 AST <strong>转换</strong>（transform）成 JavaScript AST。最后，根据 JavaScript AST 生成 JavaScript 代码，即渲染函数代码。图 15-3 给出了 Vue.js 模板编译器的工作流程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00612.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-3　Vue.js 模板编译器的工作流程</strong></p>\n<p>AST 是 abstract syntax tree 的首字母缩写，即抽象语法树。所谓模板 AST，其实就是用来描述模板的抽象语法树。举个例子，假设我们有如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;\n   &lt;h1 v-if=\"ok\"&gt;Vue Template&lt;/h1&gt;\n &lt;/div&gt;\n</code></pre>\n<p>这段模板会被编译为如下所示的 AST：</p>\n<pre class=\"code-rows\"><code> const ast = {\n   // 逻辑根节点\n   type: 'Root',\n   children: [\n     // div 标签节点\n     {\n       type: 'Element',\n       tag: 'div',\n       children: [\n         // h1 标签节点\n         {\n           type: 'Element',\n           tag: 'h1',\n           props: [\n             // v-if 指令节点\n             {\n               type: 'Directive', // 类型为 Directive 代表指令\n               name: 'if'，       // 指令名称为 if，不带有前缀 v-\n               exp: {\n                 // 表达式节点\n                 type: 'Expression',\n                 content: 'ok'\n               }\n             }\n           ]\n         }\n       ]\n     }\n   ]\n }\n</code></pre>\n<p>可以看到，AST 其实就是一个具有层级结构的对象。模板 AST 具有与模板同构的嵌套结构。每一棵 AST 都有一个逻辑上的根节点，其类型为 <code>Root</code>。模板中真正的根节点则作为 <code>Root</code> 节点的 <code>children</code> 存在。观察上面的 <code>AST</code>，我们可以得出如下结论。</p>\n<ul>\n<li>不同类型的节点是通过节点的 <code>type</code> 属性进行区分的。例如标签节点的 <code>type</code> 值为 <code>'Element'</code>。</li>\n<li>标签节点的子节点存储在其 <code>children</code> 数组中。</li>\n<li>标签节点的属性节点和指令节点会存储在 <code>props</code> 数组中。</li>\n<li>不同类型的节点会使用不同的对象属性进行描述。例如指令节点拥有 <code>name</code> 属性，用来表达指令的名称，而表达式节点拥有 <code>content</code> 属性，用来描述表达式的内容。</li>\n</ul>\n<p>我们可以通过封装 <code>parse</code> 函数来完成对模板的词法分析和语法分析，得到模板 AST，如图 15-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00613.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-4　<code>parse</code> 函数的作用</strong></p>\n<p>我们也可以用下面的代码来表达模板解析的过程：</p>\n<pre class=\"code-rows\"><code> const template = `\n   &lt;div&gt;\n     &lt;h1 v-if=\"ok\"&gt;Vue Template&lt;/h1&gt;\n   &lt;/div&gt;\n `\n<p>const templateAST = parse(template)<br />\n</code></pre></p>\n<p>可以看到，<code>parse</code> 函数接收字符串模板作为参数，并将解析后得到的 AST 作为返回值返回。</p>\n<p>有了模板 AST 后，我们就可以对其进行语义分析，并对模板 AST 进行转换了。什么是语义分析呢？举几个例子。</p>\n<ul>\n<li>检查 <code>v-else</code> 指令是否存在相符的 <code>v-if</code> 指令。</li>\n<li>分析属性值是否是静态的，是否是常量等。</li>\n<li>插槽是否会引用上层作用域的变量。</li>\n<li>……</li>\n</ul>\n<p>在语义分析的基础上，我们即可得到模板 AST。接着，我们还需要将模板 AST 转换为 JavaScript AST。因为 Vue.js 模板编译器的最终目标是生成渲染函数，而渲染函数本质上是 JavaScript 代码，所以我们需要将模板 AST 转换成用于描述渲染函数的 JavaScript AST。</p>\n<p>我们可以封装 <code>transform</code> 函数来完成模板 AST 到 JavaScript AST 的转换工作，如图 15-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00614.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-5　<code>transform</code> 函数的作用</strong></p>\n<p>同样，我们也可以用下面的代码来表达：</p>\n<pre class=\"code-rows\"><code> const templateAST = parse(template)\n const jsAST = transform(templateAST)\n</code></pre>\n<p>我们会在下一章详细讲解 JavaScript AST 的结构。</p>\n<p>有了 JavaScript AST 后，我们就可以根据它生成渲染函数了，这一步可以通过封装 <code>generate</code> 函数来完成，如图 15-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00615.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-6　<code>generate</code> 函数的作用</strong></p>\n<p>我们也可以用下面的代码来表达代码生成的过程：</p>\n<pre class=\"code-rows\"><code> const templateAST = parse(template)\n const jsAST = transform(templateAST)\n const code = generate(jsAST)\n</code></pre>\n<p>在上面这段代码中，<code>generate</code> 函数会将渲染函数的代码以字符串的形式返回，并存储在 <code>code</code> 常量中。图 15-7 给出了完整的流程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00616.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-7　将 Vue.js 模板编译为渲染函数的完整流程</strong></p>\n<h2 id=\"nav_point_143\">15.2　<code>parser</code> 的实现原理与状态机</h2>\n<p>在上一节中，我们讲解了 Vue.js 模板编译器的基本结构和工作流程，它主要由三个部分组成：</p>\n<ul>\n<li>用来将模板字符串解析为模板 AST 的解析器（<code>parser</code>）；</li>\n<li>用来将模板 AST 转换为 JavaScript AST 的转换器（<code>transformer</code>）；</li>\n<li>用来根据 JavaScript AST 生成渲染函数代码的生成器（<code>generator</code>）。</li>\n</ul>\n<p>本节，我们将详细讨论解析器 <code>parser</code> 的实现原理。</p>\n<p>解析器的入参是字符串模板，解析器会逐个读取字符串模板中的字符，并根据一定的规则将整个字符串切割为一个个 Token。这里的 Token 可以视作词法记号，后续我们将使用 Token 一词来代表词法记号进行讲解。举例来说，假设有这样一段模板：</p>\n<pre class=\"code-rows\"><code> &lt;p&gt;Vue&lt;/p&gt;\n</code></pre>\n<p>解析器会把这段字符串模板切割为三个 Token。</p>\n<ul>\n<li>开始标签：<code>&lt;p&gt;</code>。</li>\n<li>文本节点：<code>Vue</code>。</li>\n<li>结束标签：<code>&lt;/p&gt;</code>。</li>\n</ul>\n<p>那么，解析器是如何对模板进行切割的呢？依据什么规则？这就不得不提到有限状态自动机。千万不要被这个名词吓到，它理解起来并不难。所谓“有限状态”，就是指有限个状态，而“自动机”意味着随着字符的输入，解析器会自动地在不同状态间迁移。拿上面的模板来说，当我们分析这段模板字符串时，<code>parse</code> 函数会逐个读取字符，状态机会有一个初始状态，我们记为“初始状态 1”。图 15-8 给出了状态迁移的过程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00617.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-8　解析器的状态机图</strong></p>\n<p>我们用自然语言来描述图 15-8 给出的状态迁移过程。</p>\n<ul>\n<li>状态机始于“初始状态 1”。</li>\n<li>在“初始状态 1”下，读取模板的第一个字符 <code>&lt;</code>，状态机会进入下一个状态，即“标签开始状态 2”。</li>\n<li>在“标签开始状态 2”下，读取下一个字符 <code>p</code>。由于字符 <code>p</code> 是字母，所以状态机会进入“标签名称状态 3”。</li>\n<li>在“标签名称状态 3”下，读取下一个字符 <code>&gt;</code>，此时状态机会从“标签名称状态 3”迁移回“初始状态 1”，并记录在“标签名称状态”下产生的标签名称 <code>p</code>。</li>\n<li>在“初始状态 1”下，读取下一个字符 <code>V</code>，此时状态机会进入“文本状态 4”。</li>\n<li>在“文本状态 4”下，继续读取后续字符，直到遇到字符 <code>&lt;</code> 时，状态机会再次进入“标签开始状态 2”，并记录在“文本状态 4”下产生的文本内容，即字符串“<code>Vue</code>”。</li>\n<li>在“标签开始状态 2”下，读取下一个字符 <code>/</code>，状态机会进入“结束标签状态 5”。</li>\n<li>在“结束标签状态 5”下，读取下一个字符 <code>p</code>，状态机会进入“结束标签名称状态 6”。</li>\n<li>在“结束标签名称状态 6”下，读取最后一个字符 <code>&gt;</code>，它是结束标签的闭合字符，于是状态机迁移回“初始状态 1”，并记录在“结束标签名称状态 6”下生成的结束标签名称。</li>\n</ul>\n<p>经过这样一系列的状态迁移过程之后，我们最终就能够得到相应的 Token 了。观察图 15-8 可以发现，有的圆圈是单线的，而有的圆圈是双线的。双线代表此时状态机是一个合法的 Token。</p>\n<p>另外，图 15-8 给出的状态机并不严谨。实际上，解析 HTML 并构造 Token 的过程是有规范可循的。在 WHATWG 发布的关于浏览器解析 HTML 的规范中，详细阐述了状态迁移。图 15-9 截取了该规范中定义的在“初始状态”下状态机的状态迁移过程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00618.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-9　Data State</strong></p>\n<p>可以看到，在“初始状态”（Data State）下，当遇到字符 <code>&lt;</code> 时，状态机会迁移到 <code>tag open state</code>，即“标签开始状态”。如果遇到字符 <code>&lt;</code> 以外的字符，规范中也都有对应的说明，应该让状态机迁移到怎样的状态。不过 Vue.js 的模板作为一个 DSL，并非必须遵守该规范。但 Vue.js 的模板毕竟是类 HTML 的实现，因此，尽可能按照规范来做，不会有什么坏处。更重要的一点是，规范中已经定义了非常详细的状态迁移过程，这对于我们编写解析器非常有帮助。</p>\n<p>按照有限状态自动机的状态迁移过程，我们可以很容易地编写对应的代码实现。因此，有限状态自动机可以帮助我们完成对模板的<strong>标记化</strong>（tokenized），最终我们将得到一系列 Token。图 15-8 中描述的状态机的实现如下：</p>\n<pre class=\"code-rows\"><code> // 定义状态机的状态\n const State = {\n   initial: 1,    // 初始状态\n   tagOpen: 2,    // 标签开始状态\n   tagName: 3,    // 标签名称状态\n   text: 4,       // 文本状态\n   tagEnd: 5,     // 结束标签状态\n   tagEndName: 6  // 结束标签名称状态\n }\n // 一个辅助函数，用于判断是否是字母\n function isAlpha(char) {\n   return char &gt;= 'a' &amp;&amp; char &lt;= 'z' || char &gt;= 'A' &amp;&amp; char &lt;= 'Z'\n }\n<p>// 接收模板字符串作为参数，并将模板切割为 Token 返回<br />\nfunction tokenize(str) {<br />\n// 状态机的当前状态：初始状态<br />\nlet currentState = State.initial<br />\n// 用于缓存字符<br />\nconst chars = []<br />\n// 生成的 Token 会存储到 tokens 数组中，并作为函数的返回值返回<br />\nconst tokens = []<br />\n// 使用 while 循环开启自动机，只要模板字符串没有被消费尽，自动机就会一直运行<br />\nwhile(str) {<br />\n// 查看第一个字符，注意，这里只是查看，没有消费该字符<br />\nconst char = str[0]<br />\n// switch 语句匹配当前状态<br />\nswitch (currentState) {<br />\n// 状态机当前处于初始状态<br />\ncase State.initial:<br />\n// 遇到字符 &lt;<br />\nif (char === ‘&lt;’) {<br />\n// 1. 状态机切换到标签开始状态<br />\ncurrentState = State.tagOpen<br />\n// 2. 消费字符 &lt;<br />\nstr = str.slice(1)<br />\n} else if (isAlpha(char)) {<br />\n// 1. 遇到字母，切换到文本状态<br />\ncurrentState = State.text<br />\n// 2. 将当前字母缓存到 chars 数组<br />\nchars.push(char)<br />\n// 3. 消费当前字符<br />\nstr = str.slice(1)<br />\n}<br />\nbreak<br />\n// 状态机当前处于标签开始状态<br />\ncase State.tagOpen:<br />\nif (isAlpha(char)) {<br />\n// 1. 遇到字母，切换到标签名称状态<br />\ncurrentState = State.tagName<br />\n// 2. 将当前字符缓存到 chars 数组<br />\nchars.push(char)<br />\n// 3. 消费当前字符<br />\nstr = str.slice(1)<br />\n} else if (char === ‘/’) {<br />\n// 1. 遇到字符 /，切换到结束标签状态<br />\ncurrentState = State.tagEnd<br />\n// 2. 消费字符 /<br />\nstr = str.slice(1)<br />\n}<br />\nbreak<br />\n// 状态机当前处于标签名称状态<br />\ncase State.tagName:<br />\nif (isAlpha(char)) {<br />\n// 1. 遇到字母，由于当前处于标签名称状态，所以不需要切换状态，<br />\n// 但需要将当前字符缓存到 chars 数组<br />\nchars.push(char)<br />\n// 2. 消费当前字符<br />\nstr = str.slice(1)<br />\n} else if (char === ‘&gt;’) {<br />\n// 1.遇到字符 &gt;，切换到初始状态<br />\ncurrentState = State.initial<br />\n// 2. 同时创建一个标签 Token，并添加到 tokens 数组中<br />\n// 注意，此时 chars 数组中缓存的字符就是标签名称<br />\ntokens.push({<br />\ntype: ‘tag’,<br />\nname: chars.join(‘’)<br />\n})<br />\n// 3. chars 数组的内容已经被消费，清空它<br />\nchars.length = 0<br />\n// 4. 同时消费当前字符 &gt;<br />\nstr = str.slice(1)<br />\n}<br />\nbreak<br />\n// 状态机当前处于文本状态<br />\ncase State.text:<br />\nif (isAlpha(char)) {<br />\n// 1. 遇到字母，保持状态不变，但应该将当前字符缓存到 chars 数组<br />\nchars.push(char)<br />\n// 2. 消费当前字符<br />\nstr = str.slice(1)<br />\n} else if (char === ‘&lt;’) {<br />\n// 1. 遇到字符 &lt;，切换到标签开始状态<br />\ncurrentState = State.tagOpen<br />\n// 2. 从 文本状态 --&gt; 标签开始状态，此时应该创建文本 Token，并添加到 tokens 数组<br />\n// 注意，此时 chars 数组中的字符就是文本内容<br />\ntokens.push({<br />\ntype: ‘text’,<br />\ncontent: chars.join(‘’)<br />\n0           })<br />\n1           // 3. chars 数组的内容已经被消费，清空它<br />\n2           chars.length = 0<br />\n3           // 4. 消费当前字符<br />\n4           str = str.slice(1)<br />\n5         }<br />\n6         break<br />\n7       // 状态机当前处于标签结束状态<br />\n8       case State.tagEnd:<br />\n9         if (isAlpha(char)) {<br />\n0           // 1. 遇到字母，切换到结束标签名称状态<br />\n1           currentState = State.tagEndName<br />\n2           // 2. 将当前字符缓存到 chars 数组<br />\n3           chars.push(char)<br />\n4           // 3. 消费当前字符<br />\n5           str = str.slice(1)<br />\n6         }<br />\n7         break<br />\n8       // 状态机当前处于结束标签名称状态<br />\n9       case State.tagEndName:<br />\n0         if (isAlpha(char)) {<br />\n1           // 1. 遇到字母，不需要切换状态，但需要将当前字符缓存到 chars 数组<br />\n2           chars.push(char)<br />\n3           // 2. 消费当前字符<br />\n4           str = str.slice(1)<br />\n5         } else if (char === ‘&gt;’) {<br />\n6           // 1. 遇到字符 &gt;，切换到初始状态<br />\n7           currentState = State.initial<br />\n8           // 2. 从 结束标签名称状态 --&gt; 初始状态，应该保存结束标签名称 Token<br />\n9           // 注意，此时 chars 数组中缓存的内容就是标签名称<br />\n0           tokens.push({<br />\n1             type: ‘tagEnd’,<br />\n2             name: chars.join(‘’)<br />\n3           })<br />\n4           // 3. chars 数组的内容已经被消费，清空它<br />\n5           chars.length = 0<br />\n6           // 4. 消费当前字符<br />\n7           str = str.slice(1)<br />\n8         }<br />\n9         break<br />\n0     }<br />\n1   }<br />\n2<br />\n3   // 最后，返回 tokens<br />\n4   return tokens<br />\n5 }<br />\n</code></pre></p>\n<p>上面这段代码看上去比较冗长，可优化的点非常多。这段代码高度还原了图 15-8 中展示的状态机，配合代码中的注释会更容易理解。</p>\n<p>使用上面给出的 <code>tokenize</code> 函数来解析模板 <code>&lt;p&gt;Vue&lt;/p&gt;</code>，我们将得到三个 Token：</p>\n<pre class=\"code-rows\"><code> const tokens = tokenize(`&lt;p&gt;Vue&lt;/p&gt;`)\n // [\n //   { type: 'tag', name: 'p' },        // 开始标签\n //   { type: 'text', content: 'Vue' },  // 文本节点\n //   { type: 'tagEnd', name: 'p' }      // 结束标签\n // ]\n</code></pre>\n<p>现在，你已经明白了状态机的工作原理，以及模板编译器将模板字符串切割为一个个 Token 的过程。但拿上述例子来说，我们并非总是需要所有 Token。例如，在解析模板的过程中，结束标签 Token 可以省略。这时，我们就可以调整 <code>tokenize</code> 函数的代码，并选择性地忽略结束标签 Token。当然，有时我们也可能需要更多的 Token，这都取决于具体的需求，然后据此灵活地调整代码实现。</p>\n<p>总而言之，通过有限自动机，我们能够将模板解析为一个个 Token，进而可以用它们构建一棵 AST 了。但在具体构建 AST 之前，我们需要思考能否简化 <code>tokenize</code> 函数的代码。实际上，我们可以通过正则表达式来精简 <code>tokenize</code> 函数的代码。上文之所以没有从最开始就采用正则表达式来实现，是因为<strong>正则表达式的本质就是有限自动机</strong>。当你编写正则表达式的时候，其实就是在编写有限自动机。</p>\n<h2 id=\"nav_point_144\">15.3　构造 AST</h2>\n<p>实际上，不同用途的编译器之间可能会存在非常大的差异。它们唯一的共同点是，都会将源代码转换成目标代码。但如果深入细节即可发现，不同编译器之间的实现思路甚至可能完全不同，其中就包括 AST 的构造方式。对于通用用途语言（GPL）来说，例如 JavaScript 这样的脚本语言，想要为其构造 AST，较常用的一种算法叫作递归下降算法，这里面需要解决 GPL 层面才会遇到的很多问题，例如最基本的运算符优先级问题。然而，对于像 Vue.js 模板这样的 DSL 来说，首先可以确定的一点是，它不具有运算符，所以也就没有所谓的运算符优先级问题。DSL 与 GPL 的区别在于，GPL 是图灵完备的，我们可以使用 GPL 来实现 DSL。而 DSL 不要求图灵完备，它只需要满足特定场景下的特定用途即可。</p>\n<p>为 Vue.js 的模板构造 AST 是一件很简单的事。HTML 是一种标记语言，它的格式非常固定，标签元素之间天然嵌套，形成父子关系。因此，一棵用于描述 HTML 的 AST 将拥有与 HTML 标签非常相似的树型结构。举例来说，假设有如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;\n</code></pre>\n<p>在上面这段模板中，最外层的根节点是 <code>div</code> 标签，它有两个 <code>p</code> 标签作为子节点。同时，这两个 <code>p</code> 标签都具有一个文本节点作为子节点。我们可以将这段模板对应的 AST 设计为：</p>\n<pre class=\"code-rows\"><code> const ast = {\n   // AST 的逻辑根节点\n   type: 'Root',\n   children: [\n     // 模板的 div 根节点\n     {\n       type: 'Element',\n       tag: 'div',\n       children: [\n         // div 节点的第一个子节点 p\n         {\n           type: 'Element',\n           tag: 'p',\n           // p 节点的文本节点\n           children: [\n             {\n               type: 'Text',\n               content: 'Vue'\n             }\n           ]\n         },\n         // div 节点的第二个子节点 p\n         {\n           type: 'Element',\n           tag: 'p',\n           // p 节点的文本节点\n           children: [\n             {\n               type: 'Text',\n               content: 'Template'\n             }\n           ]\n         }\n       ]\n     }\n   ]\n }\n</code></pre>\n<p>可以看到，AST 在结构上与模板是“同构”的，它们都具有树型结构，如图 15-10 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00619.jpeg\" alt=\"\" width=\"63%\" style=\"width: 63%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-10　AST 的结构</strong></p>\n<p>了解了 AST 的结构，接下来我们的任务是，使用程序根据模板解析后生成的 Token 构造出这样一棵 AST。首先，我们使用上一节讲解的 <code>tokenize</code> 函数将本节开头给出的模板进行标记化。解析这段模板得到的 <code>tokens</code> 如下所示：</p>\n<pre class=\"code-rows\"><code> const tokens = tokenize(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)\n</code></pre>\n<p>执行上面这段代码，我们将得到如下 <code>tokens</code>：</p>\n<pre class=\"code-rows\"><code> const tokens = [\n   ,          // div 开始标签节点\n   ,            // p 开始标签节点\n   ,      // 文本节点\n   ,         // p 结束标签节点\n   ,            // p 开始标签节点\n   , // 文本节点\n   ,         // p 结束标签节点\n           // div 结束标签节点\n ]\n</code></pre>\n<p>根据 Token 列表构建 AST 的过程，其实就是对 Token 列表进行扫描的过程。从第一个 Token 开始，顺序地扫描整个 Token 列表，直到列表中的所有 Token 处理完毕。在这个过程中，我们需要维护一个栈 <code>elementStack</code>，这个栈将用于维护元素间的父子关系。每遇到一个开始标签节点，我们就构造一个 <code>Element</code> 类型的 AST 节点，并将其压入栈中。类似地，每当遇到一个结束标签节点，我们就将当前栈顶的节点弹出。这样，栈顶的节点将始终充当父节点的角色。扫描过程中遇到的所有节点，都会作为当前栈顶节点的子节点，并添加到栈顶节点的 <code>children</code> 属性下。</p>\n<p>还是拿上例来说，图 15-11 给出了在扫描 Token 列表之前，Token 列表、父级元素栈和 AST 三者的状态。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00620.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-11　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>在图 15-11 中，左侧的是 Token 列表，我们将会按照从上到下的顺序扫描 Token 列表，中间和右侧分别展示了栈 <code>elementStack</code> 的状态和 AST 的状态。可以看到，它们最初都只有 <code>Root</code> 根节点。</p>\n<p>接着，我们对 Token 列表进行扫描。首先，扫描到第一个 Token，即“开始标签（<code>div</code>）”，如图 15-12 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00621.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-12　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>由于当前扫描到的 Token 是一个开始标签节点，因此我们创建一个类型为 <code>Element</code> 的 AST 节点 <code>Element(div)</code>，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点是 <code>Root</code> 根节点，所以我们将新建的 <code>Element(div)</code> 节点作为 <code>Root</code> 根节点的子节点添加到 AST 中，最后将新建的 <code>Element(div)</code> 节点压入 <code>elementStack</code> 栈。</p>\n<p>接着，我们扫描下一个 Token，如图 15-13 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00622.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-13　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>扫描到的第二个 Token 也是一个开始标签节点，于是我们再创建一个类型为 <code>Element</code> 的 AST 节点 <code>Element(p)</code>，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点为 <code>Element(div)</code> 节点，所以我们将新建的 <code>Element(p)</code> 节点作为 <code>Element(div)</code> 节点的子节点添加到 AST 中，最后将新建的 <code>Element(p)</code> 节点压入 <code>elementStack</code> 栈。</p>\n<p>接着，我们扫描下一个 Token，如图 15-14 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00623.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-14　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>扫描到的第三个 Token 是一个文本节点，于是我们创建一个类型为 <code>Text</code> 的 AST 节点 <code>Text(Vue)</code>，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点为 <code>Element(p)</code> 节点，所以我们将新建的 <code>Text(p)</code> 节点作为 <code>Element(p)</code> 节点的子节点添加到 AST 中。</p>\n<p>接着，扫描下一个 Token，如图 15-15 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00624.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-15　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>此时扫描到的 Token 是一个结束标签，所以我们需要将栈顶的 <code>Element(p)</code> 节点从 <code>elementStack</code> 栈中弹出。接着，扫描下一个 Token，如图 15-16 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00625.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-16　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>此时扫描到的 Token 是一个开始标签。我们为它新建一个 AST 节点 <code>Element(p)</code>，并将其作为当前栈顶节点 <code>Element(div)</code> 的子节点。最后，将 <code>Element(p)</code> 压入 <code>elementStack</code> 栈中，使其成为新的栈顶节点。</p>\n<p>接着，扫描下一个 Token，如图 15-17 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00626.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-17　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>此时扫描到的 Token 是一个文本节点，所以只需要为其创建一个相应的 AST 节点 <code>Text(Template)</code> 即可，然后将其作为当前栈顶节点 <code>Element(p)</code> 的子节点添加到 AST 中。</p>\n<p>接着，扫描下一个 Token，如图 15-18 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00627.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-18　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>此时扫描到的 Token 是一个结束标签，于是我们将当前的栈顶节点 <code>Element(p)</code> 从 <code>elementStack</code> 栈中弹出。</p>\n<p>接着，扫描下一个 Token，如图 15-19 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00628.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-19　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>此时，扫描到了最后一个 Token，它是一个 <code>div</code> 结束标签，所以我们需要再次将当前栈顶节点 <code>Element(div)</code> 从 <code>elementStack</code> 栈中弹出。至此，所有 Token 都被扫描完毕，AST 构建完成。图 15-20  给出了最终状态。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00629.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-20　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p>\n<p>如图 15-20 所示，在所有 Token 扫描完毕后，一棵 AST 就构建完成了。</p>\n<p>扫描 Token 列表并构建 AST 的具体实现如下：</p>\n<pre class=\"code-rows\"><code> // parse 函数接收模板作为参数\n function parse(str) {\n   // 首先对模板进行标记化，得到 tokens\n   const tokens = tokenize(str)\n   // 创建 Root 根节点\n   const root = {\n     type: 'Root',\n     children: []\n   }\n   // 创建 elementStack 栈，起初只有 Root 根节点\n   const elementStack = [root]\n<p>// 开启一个 while 循环扫描 tokens，直到所有 Token 都被扫描完毕为止<br />\nwhile (tokens.length) {<br />\n// 获取当前栈顶节点作为父节点 parent<br />\nconst parent = elementStack[elementStack.length - 1]<br />\n// 当前扫描的 Token<br />\nconst t = tokens[0]<br />\nswitch (t.type) {<br />\ncase ‘tag’:<br />\n// 如果当前 Token 是开始标签，则创建 Element 类型的 AST 节点<br />\nconst elementNode = {<br />\ntype: ‘Element’,<br />\ntag: t.name,<br />\nchildren: []<br />\n}<br />\n// 将其添加到父级节点的 children 中<br />\nparent.children.push(elementNode)<br />\n// 将当前节点压入栈<br />\nelementStack.push(elementNode)<br />\nbreak<br />\ncase ‘text’:<br />\n// 如果当前 Token 是文本，则创建 Text 类型的 AST 节点<br />\nconst textNode = {<br />\ntype: ‘Text’,<br />\ncontent: t.content<br />\n}<br />\n// 将其添加到父节点的 children 中<br />\nparent.children.push(textNode)<br />\nbreak<br />\ncase ‘tagEnd’:<br />\n// 遇到结束标签，将栈顶节点弹出<br />\nelementStack.pop()<br />\nbreak<br />\n}<br />\n// 消费已经扫描过的 token<br />\ntokens.shift()<br />\n}</p>\n<p>// 最后返回 AST<br />\nreturn root<br />\n}<br />\n</code></pre></p>\n<p>上面这段代码很好地还原了上文中介绍的构建 AST 的思路，我们可以使用如下代码对其进行测试：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)\n</code></pre>\n<p>运行这句代码，我们将得到与本节开头给出的 AST 一致的结果。这里有必要说明一点，当前的实现仍然存在诸多问题，例如无法处理自闭合标签等。这些问题我们会在第 16 章详细讲解。</p>\n","comments":[{"had_liked":false,"id":395944,"user_name":"Faye","can_delete":false,"product_type":"c1","uid":1293886,"ip_address":"北京","ucode":"7E8351CB61A764","user_header":"https://static001.geekbang.org/account/avatar/00/13/be/3e/aef2c613.jpg","comment_is_top":false,"comment_ctime":1732504372,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"牛！","like_count":0}]}