{"id":101436,"title":"24 | 冒险和预测（三）：CPU里的“线程池”","content":"<p>过去两讲，我为你讲解了通过增加资源、停顿等待以及主动转发数据的方式，来解决结构冒险和数据冒险问题。对于结构冒险，由于限制来自于同一时钟周期不同的指令，要访问相同的硬件资源，解决方案是增加资源。对于数据冒险，由于限制来自于数据之间的各种依赖，我们可以提前把数据转发到下一个指令。</p><p>但是即便综合运用这三种技术，我们仍然会遇到不得不停下整个流水线，等待前面的指令完成的情况，也就是采用流水线停顿的解决方案。比如说，上一讲里最后给你的例子，即使我们进行了操作数前推，因为第二条加法指令依赖于第一条指令从内存中获取的数据，我们还是要插入一次NOP的操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/2d/49f3a9b1ae2972ac5c6cfca7731bf12d.jpeg?wh=2497*640\" alt=\"\"></p><p>那这个时候你就会想了，那我们能不能让后面没有数据依赖的指令，在前面指令停顿的时候先执行呢？</p><p>答案当然是可以的。毕竟，流水线停顿的时候，对应的电路闲着也是闲着。那我们完全可以先完成后面指令的执行阶段。</p><h2>填上空闲的NOP：上菜的顺序不必是点菜的顺序</h2><p>之前我为你讲解的，无论是流水线停顿，还是操作数前推，归根到底，只要前面指令的特定阶段还没有执行完成，后面的指令就会被“阻塞”住。</p><p>但是这个“阻塞”很多时候是没有必要的。因为尽管你的代码生成的指令是顺序的，但是如果后面的指令不需要依赖前面指令的执行结果，完全可以不必等待前面的指令运算完成。</p><!-- [[[read_end]]] --><p>比如说，下面这三行代码。</p><pre><code>a = b + c\nd = a * e\nx = y * z\n</code></pre><p>计算里面的 x ，却要等待 a 和 d 都计算完成，实在没啥必要。所以我们完全可以在 d 的计算等待 a 的计算的过程中，先把 x 的结果给算出来。</p><p>在流水线里，后面的指令不依赖前面的指令，那就不用等待前面的指令执行，它完全可以先执行。</p><p><img src=\"https://static001.geekbang.org/resource/image/37/ef/37ba6c453e530660cecbbfcf56a3ecef.jpeg?wh=2386*1048\" alt=\"\"></p><p>可以看到，因为第三条指令并不依赖于前两条指令的计算结果，所以在第二条指令等待第一条指令的访存和写回阶段的时候，第三条指令就已经执行完成了。</p><p>这就好比你开了一家餐馆，顾客会排队来点菜。餐馆的厨房里会有洗菜、切菜、炒菜、上菜这样的各个步骤。后厨也是按照点菜的顺序开始做菜的。但是不同的菜需要花费的时间和工序可能都有差别。有些菜做起来特别麻烦，特别慢。比如做一道佛跳墙有好几道工序。我们没有必要非要等先点的佛跳墙上菜了，再开始做后面的炒鸡蛋。只要有厨子空出来了，就可以先动手做前面的简单菜，先给客户端上去。</p><p>这样的解决方案，在计算机组成里面，被称为<strong>乱序执行</strong>（Out-of-Order Execution，OoOE）。乱序执行，最早来自于著名的IBM 360。相信你一定听说过《人月神话》这本软件工程届的经典著作，它讲的就是IBM 360开发过程中的“人生体会”。而IBM 360困难的开发过程，也少不了第一次引入乱序执行这个新的CPU技术。</p><h2>CPU里的“线程池”：理解乱序执行</h2><p>那么，我们的CPU怎样才能实现乱序执行呢？是不是像玩俄罗斯方块一样，把后面的指令，找一个前面的坑填进去就行了？事情并没有这么简单。其实，从今天软件开发的维度来思考，乱序执行好像是在指令的执行阶段，引入了一个“线程池”。我们下面就来看一看，在CPU里，乱序执行的过程究竟是怎样的。</p><p>使用乱序执行技术后，CPU里的流水线就和我之前给你看的5级流水线不太一样了。我们一起来看一看下面这张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/04/153f8d5e4a4363399133e1d7d9052804.jpeg?wh=2143*2737\" alt=\"\"></p><p>1.在取指令和指令译码的时候，乱序执行的CPU和其他使用流水线架构的CPU是一样的。它会一级一级顺序地进行取指令和指令译码的工作。</p><p>2.在指令译码完成之后，就不一样了。CPU不会直接进行指令执行，而是进行一次指令分发，把指令发到一个叫作保留站（Reservation Stations）的地方。顾名思义，这个保留站，就像一个火车站一样。发送到车站的指令，就像是一列列的火车。</p><p>3.这些指令不会立刻执行，而要等待它们所依赖的数据，传递给它们之后才会执行。这就好像一列列的火车都要等到乘客来齐了才能出发。</p><p>4.一旦指令依赖的数据来齐了，指令就可以交到后面的功能单元（Function Unit，FU），其实就是ALU，去执行了。我们有很多功能单元可以并行运行，但是不同的功能单元能够支持执行的指令并不相同。就和我们的铁轨一样，有些从上海北上，可以到北京和哈尔滨；有些是南下的，可以到广州和深圳。</p><p>5.指令执行的阶段完成之后，我们并不能立刻把结果写回到寄存器里面去，而是把结果再存放到一个叫作重排序缓冲区（Re-Order Buffer，ROB）的地方。</p><p>6.在重排序缓冲区里，我们的CPU会按照取指令的顺序，对指令的计算结果重新排序。只有排在前面的指令都已经完成了，才会提交指令，完成整个指令的运算结果。</p><p>7.实际的指令的计算结果数据，并不是直接写到内存或者高速缓存里，而是先写入存储缓冲区（Store Buffer面，最终才会写入到高速缓存和内存里。</p><p>可以看到，在乱序执行的情况下，只有CPU内部指令的执行层面，可能是“乱序”的。只要我们能在指令的译码阶段正确地分析出指令之间的数据依赖关系，这个“乱序”就只会在互相没有影响的指令之间发生。</p><p>即便指令的执行过程中是乱序的，我们在最终指令的计算结果写入到寄存器和内存之前，依然会进行一次排序，以确保所有指令在外部看来仍然是有序完成的。</p><p>有了乱序执行，我们重新去执行上面的3行代码。</p><pre><code>a = b + c\nd = a * e\nx = y * z\n</code></pre><p>里面的 d 依赖于 a 的计算结果，不会在 a 的计算完成之前执行。但是我们的CPU并不会闲着，因为 x = y * z 的指令同样会被分发到保留站里。因为 x 所依赖的 y 和 z 的数据是准备好的， 这里的乘法运算不会等待计算 d，而会先去计算 x 的值。</p><p>如果我们只有一个FU能够计算乘法，那么这个FU并不会因为 d 要等待 a 的计算结果，而被闲置，而是会先被拿去计算 x。</p><p>在 x 计算完成之后，d 也等来了 a 的计算结果。这个时候，我们的FU就会去计算出 d 的结果。然后在重排序缓冲区里，把对应的计算结果的提交顺序，仍然设置成 a -&gt; d -&gt; x，而计算完成的顺序是 x -&gt; a -&gt; d。</p><p>在这整个过程中，整个计算乘法的FU都没有闲置，这也意味着我们的CPU的吞吐率最大化了。</p><p>整个乱序执行技术，就好像在指令的执行阶段提供一个“线程池”。指令不再是顺序执行的，而是根据池里所拥有的资源，以及各个任务是否可以进行执行，进行动态调度。在执行完成之后，又重新把结果在一个队列里面，按照指令的分发顺序重新排序。即使内部是“乱序”的，但是在外部看起来，仍然是井井有条地顺序执行。</p><p>乱序执行，极大地提高了CPU的运行效率。核心原因是，现代CPU的运行速度比访问主内存的速度要快很多。如果完全采用顺序执行的方式，很多时间都会浪费在前面指令等待获取内存数据的时间里。CPU不得不加入NOP操作进行空转。而现代CPU的流水线级数也已经相对比较深了，到达了14级。这也意味着，同一个时钟周期内并行执行的指令数是很多的。</p><p>而乱序执行，以及我们后面要讲的高速缓存，弥补了CPU和内存之间的性能差异。同样，也充分利用了较深的流水行带来的并发性，使得我们可以充分利用CPU的性能。</p><h2>总结延伸</h2><p>好了，总结一下。这一讲里，我为你介绍了乱序执行，这个解决流水线阻塞的技术方案。因为数据的依赖关系和指令先后执行的顺序问题，很多时候，流水线不得不“阻塞”在特定的指令上。即使后续别的指令，并不依赖正在执行的指令和阻塞的指令，也不能继续执行。</p><p>而乱序执行，则是在指令执行的阶段通过一个类似线程池的保留站，让系统自己去动态调度先执行哪些指令。这个动态调度巧妙地解决了流水线阻塞的问题。指令执行的先后顺序，不再和它们在程序中的顺序有关。我们只要保证不破坏数据依赖就好了。CPU只要等到在指令结果的最终提交的阶段，再通过重排序的方式，确保指令“实际上”是顺序执行的。</p><h2>推荐阅读</h2><p>想要更深入地了解CPU的乱序执行的知识，我们就不能局限于组成原理，而要深入到体系结构中去了。你可以读一下《计算机体系结构：量化研究方法》的3.4和3.5章节。</p><p>想要了解乱序执行为什么可行，你可以看看Wikipedia上，乱序执行所依赖的<a href=\"https://en.wikipedia.org/wiki/Tomasulo_algorithm\">Tomasulo算法</a>。这个算法，也是在IBM 360时代引入的。</p><h2>课后思考</h2><p>在现代Intel的CPU的乱序执行的过程中，只有指令的执行阶段是乱序的，后面的内存访问和数据写回阶段都仍然是顺序的。这种保障内存数据访问顺序的模型，叫作强内存模型（Strong Memory Model）。你能想一想，我们为什么要保障内存访问的顺序呢？在前后执行的指令没有相关数据依赖的情况下，为什么我们仍然要求这个顺序呢？</p><p>欢迎留言和我分享你的疑惑和见解。你也可以把今天的内容，分享给你的朋友，和他一起学习和进步。</p><p></p>","neighbors":{"left":{"article_title":"23 | 冒险和预测（二）：流水线里的接力赛","id":101172},"right":{"article_title":"25 | 冒险和预测（四）：今天下雨了，明天还会下雨么？","id":102166}},"comments":[{"had_liked":false,"id":160069,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1575863660,"is_pvip":false,"replies":[{"id":"68672","content":"👍","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581240202,"ip_address":"","comment_id":160069,"utype":1}],"discussion_count":2,"race_medal":0,"score":"181964490092","product_id":100026001,"comment_content":"应该是数据一致性问题，多核访问相同的内存。但是有自己的缓存，寄存器。","like_count":43,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477248,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581240202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391143,"discussion_content":"能不能举个具体的例子啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630314280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115126,"user_name":"焰火","can_delete":false,"product_type":"c1","uid":1244606,"ip_address":"","ucode":"D3353B386DE3B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","comment_is_top":false,"comment_ctime":1563498090,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"100347745898","product_id":100026001,"comment_content":"数据从cpu --&gt; 寄存器 --&gt; 内存， 数据从CPU到内存中间有个寄存器，寄存器和内存数据交换应该也是整页交换，如果不顺序写回寄存器的话，很有可能在寄存器页边界的时候，到内存发生时间差，导致后面寄存器再重新取内存的时候发生数据错误，之前数据不依赖，不保证后面数据不依赖。所以还是顺序写回比较安全。","like_count":24,"discussions":[{"author":{"id":1571152,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f9/50/d0ea075b.jpg","nickname":"陈金龙","note":"","ucode":"684F1C733A6C27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259942,"discussion_content":"寄存器就那么十多个，可以整页交换么","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588831379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2192255,"avatar":"","nickname":"嘻嘻嘻","note":"","ucode":"84ED79E03135E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532105,"discussion_content":"寄存器不算cpu内部的？内存分页也不是直接分到寄存器，两者的存储容量不在一个数量级。感觉你这个评论可能会误导很多人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637518787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161256,"discussion_content":"非顺序写回的情况下，也会有你说的页边界问题吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580881327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105029,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1560906708,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"40215612372","product_id":100026001,"comment_content":"我觉得强内存模型是为了保证不同指令对同一内存地址的读写正确性，不同指令的执行不仅仅有寄存器数据依赖，还会有内存数据依赖。","like_count":9,"discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15943,"discussion_content":"同一地址读写关系，采用高速缓存解决；流水线冒泡，采用乱序解决","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568862682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244606,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fd/be/079c78c7.jpg","nickname":"焰火","note":"","ucode":"D3353B386DE3B5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2337,"discussion_content":"没太明白您的意思，如果同一地址在有写读关系的话，那说明这两条写读指令是有数据依赖的，应该不会发生乱序吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563497196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209084,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1587487201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18767356385","product_id":100026001,"comment_content":"徐老师您好。我有两个问题如下：<br>1. 乱序执行是否在debug模式下不启用？还是说reorder输出后，已经满足了单步执行下的顺序？<br>2. 乱序执行这样的优化是否对编码过程透明？换言之，编码过程中有意识的遵从乱序原则，是否会对运行效率有影响？个人感觉是会有影响的，至少在reserve和reorder两个阶段降低了排序难度。您认为呢？","like_count":4},{"had_liked":false,"id":186181,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1583773577,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14468675465","product_id":100026001,"comment_content":"老师您好！乱序执行就是我们平时说的指令重排么？","like_count":4,"discussions":[{"author":{"id":1215637,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8c/95/a6d85a18.jpg","nickname":"老袁","note":"","ucode":"0968F54699BCDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573966,"discussion_content":"java里面的指令重排序就是这个原因，加volatile可以避免指令重排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653749249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105379,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1239833,"ip_address":"","ucode":"AA1B8EA613E3A9","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/19/19e706a5.jpg","comment_is_top":false,"comment_ctime":1560991324,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10150925916","product_id":100026001,"comment_content":"老师，有一点没想明白。五级流水线，取指令-译指令-执行-访存-写回。这里的访存是干什么的？能否具体举例讲一讲？我理解访存是把数据读入寄存器。那这样的话，访存应该先于执行才对。感谢答疑","like_count":2,"discussions":[{"author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133757,"discussion_content":"访存是计算过程中访问数据的内存地址","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578986734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1270780,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8AdNibZHbZriaqLQZrNPcX8hVOpY91o0ELl7eOq7qy3aTibjia10ymIsKUKW6Ucs9SuXBDWlg6sjahw/132","nickname":"逆舟","note":"","ucode":"B303B4B8E10E0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1795371,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","nickname":"许先森","note":"","ucode":"1F42D4A6B5C6AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273793,"discussion_content":"请问您的意思 也就是访问内存 完再继续执行计算是吗？\n这里的访存有没有可能是直接将计算结果写回内存呢？但是计算结果都是写回寄存器，因为内存太慢。如果写回内存，再通过单独的 store 指令？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590501052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":133757,"ip_address":""},"score":273793,"extra":""},{"author":{"id":1696883,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e4/73/74dce191.jpg","nickname":"鼠里鼠气","note":"","ucode":"4793476BBDB202","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1270780,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8AdNibZHbZriaqLQZrNPcX8hVOpY91o0ELl7eOq7qy3aTibjia10ymIsKUKW6Ucs9SuXBDWlg6sjahw/132","nickname":"逆舟","note":"","ucode":"B303B4B8E10E0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325206,"discussion_content":"我觉得这里的访存应该这样理解“首先这个五级流水线，它代表一条指令的五个不同的阶段，其次不是所有指令都有完整的五个阶段，例如上一讲的STORE、ADD指令，访存应该要放在具体的指令中才好理解，在STORE中，执行代表这条指令的执行，访存代表读内存，而在ADD中，没有访存这一步，也就是不会把计算结果写回内存” 。个人观点","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605252468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273793,"ip_address":""},"score":325206,"extra":""},{"author":{"id":2656204,"avatar":"","nickname":"Geek_b809fe","note":"","ucode":"14BB37416285AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1696883,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e4/73/74dce191.jpg","nickname":"鼠里鼠气","note":"","ucode":"4793476BBDB202","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379260,"discussion_content":"你说得对，有的指令如LOAD/STORE，在访存阶段之前的执行阶段其实就是计算需要访问数据的地址；而有的指令如ADD可能只有执行阶段而不需要进行访存阶段。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623780330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325206,"ip_address":""},"score":379260,"extra":""}]}]},{"had_liked":false,"id":104962,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1560899446,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5855866742","product_id":100026001,"comment_content":"搜了下资料，假如有两个阶段，之间没有数据依赖，第一个阶段判断变量a是否为true，再执行，否则退出。第二个阶段直接把a置为false，如果乱序执行，第二个阶段先执行影响业务逻辑，第一个阶段本来可以执行的，现在直接退出了","like_count":1,"discussions":[{"author":{"id":2303222,"avatar":"","nickname":"Geek_f7bc9b","note":"","ucode":"83EBA43585B2B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327819,"discussion_content":"这个问题是多核CPU数据一致性问题 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605961766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270780,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8AdNibZHbZriaqLQZrNPcX8hVOpY91o0ELl7eOq7qy3aTibjia10ymIsKUKW6Ucs9SuXBDWlg6sjahw/132","nickname":"逆舟","note":"","ucode":"B303B4B8E10E0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273794,"discussion_content":"你这不就是先读后写的数据依赖吗？ 怎么能说没有数据依赖呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590501143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349880,"user_name":"一頭蠻牛","can_delete":false,"product_type":"c1","uid":1209653,"ip_address":"","ucode":"887E596A1DBF2D","user_header":"https://static001.geekbang.org/account/avatar/00/12/75/35/a0c15ca8.jpg","comment_is_top":false,"comment_ctime":1656405081,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1656405081","product_id":100026001,"comment_content":"老师 请问保留站靠什么“保留”数据   它又是什么 cpu缓存，内存，还是寄存器","like_count":1},{"had_liked":false,"id":327487,"user_name":"一棹烟波","can_delete":false,"product_type":"c1","uid":2309872,"ip_address":"","ucode":"BCCD6ADDD1E90A","user_header":"https://static001.geekbang.org/account/avatar/00/23/3e/f0/9e7288d2.jpg","comment_is_top":false,"comment_ctime":1640145546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640145546","product_id":100026001,"comment_content":"老师，您好。请问乱序执行需要在编写代码层面，对多条C++语句进行重排，还是编译器会自行优化重排。","like_count":0},{"had_liked":false,"id":321056,"user_name":"活着即是修行","can_delete":false,"product_type":"c1","uid":2258416,"ip_address":"","ucode":"C420AA71FB7F9F","user_header":"https://static001.geekbang.org/account/avatar/00/22/75/f0/2c65887d.jpg","comment_is_top":false,"comment_ctime":1636637078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636637078","product_id":100026001,"comment_content":"我们在进行CPU乱序执行的过程中，可以认为是在译码和执行的过程中增加了一个缓冲层，这样可以让CPU能够选择满足条件的指令进行执行。在指令执行完结果之后，CPU又将结果按照指令译码的顺序重排序，这样做是保证新数据不会被旧数据给覆盖。","like_count":0},{"had_liked":false,"id":307255,"user_name":"Linux C·Core Api","can_delete":false,"product_type":"c1","uid":2413481,"ip_address":"","ucode":"E370F0627E8B11","user_header":"https://static001.geekbang.org/account/avatar/00/24/d3/a9/2b84cc97.jpg","comment_is_top":false,"comment_ctime":1628990903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628990903","product_id":100026001,"comment_content":"课后思考问题。应该说的是多线程下的访问和回写问题。课程现在介绍的都是基于单核的","like_count":0},{"had_liked":false,"id":307031,"user_name":"Geek_337e21","can_delete":false,"product_type":"c1","uid":2274627,"ip_address":"","ucode":"D51F99290C30C8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyNezT33TyZdPI8DtRe7LzV9geutjMkaNNByOkyMXhNQVia5CJE54lWrBpicftq7jdo8bCcXhokjUQ/132","comment_is_top":false,"comment_ctime":1628834008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628834008","product_id":100026001,"comment_content":"思考题：是不是因为数据的局部性存储原理，一般顺序位置相近的指令访问的数据都会集中在某一块地方，可以从高速缓存中加载，速度快，而如果乱序执行，缓存可能就失去了意义，需要不停更新缓存，从内存中获取数据。","like_count":0},{"had_liked":false,"id":292640,"user_name":"skye","can_delete":false,"product_type":"c1","uid":1027840,"ip_address":"","ucode":"C55C9F52C78A00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/00/9b49f42b.jpg","comment_is_top":false,"comment_ctime":1620909318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620909318","product_id":100026001,"comment_content":"C++11引入的内存模型，如果不采用强内存模型，那访存和写回阶段是不是就不要遵循取指顺序了？","like_count":0},{"had_liked":false,"id":291319,"user_name":"童言","can_delete":false,"product_type":"c1","uid":1565441,"ip_address":"","ucode":"6FE5804578354B","user_header":"https://static001.geekbang.org/account/avatar/00/17/e3/01/a254f22d.jpg","comment_is_top":false,"comment_ctime":1620204652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620204652","product_id":100026001,"comment_content":"指令的乱序执行：解决了ALU空闲等待的问题。通过加入保留站，使译码后的指令进行统一管理，ALU直接与保留站对接。由于保留站具有视野的全局性，能够知道哪些指令是没有依赖的，因此可以下发给ALU进行执行。<br>感觉有点像Go语言的GMP模型，M就是ALU，P就是保留站，G就是若干的译码后的指令。","like_count":0},{"had_liked":false,"id":280277,"user_name":"城北时公","can_delete":false,"product_type":"c1","uid":2034418,"ip_address":"","ucode":"4719AE65CB564D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKG6nZXNOaobCtd2XQbnoh0QcovEDn6MfqXxhC4niaAeK8BZ7a2l87Q4wDE00FNUXS9MeOyLrmZWAw/132","comment_is_top":false,"comment_ctime":1614149217,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1614149217","product_id":100026001,"comment_content":"请问，多线程情况下，加volatile关键字，不但会禁止指令重排序，也会禁止CPU乱序执行么？","like_count":0,"discussions":[{"author":{"id":1262808,"avatar":"https://static001.geekbang.org/account/avatar/00/13/44/d8/1a1761f9.jpg","nickname":"James_Shangguan","note":"","ucode":"F5855BC008DDEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393425,"discussion_content":"我的理解，volatile关键字禁止指令重排序，禁止的是加了关键字的那一段指令，等于告诉CPU这一部分不要重排序；但是其余的指令是否重排序，CPU是会根据规则判断，如果认为没有前后数据依赖，还是会进行重排序的。老师帮忙确认下这样理解有没有问题？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631426709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1262808,"avatar":"https://static001.geekbang.org/account/avatar/00/13/44/d8/1a1761f9.jpg","nickname":"James_Shangguan","note":"","ucode":"F5855BC008DDEA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576267,"discussion_content":"我也这样认为的，volatile是给编译器看的，阻止编译乱序，但执行乱序是管不了的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655382836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":393425,"ip_address":""},"score":576267,"extra":""}]}]},{"had_liked":false,"id":277707,"user_name":"林杨","can_delete":false,"product_type":"c1","uid":1207687,"ip_address":"","ucode":"FE192D8D6FF036","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/87/21e516ec.jpg","comment_is_top":false,"comment_ctime":1612521293,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1612521293","product_id":100026001,"comment_content":"讲的真好，必需点赞下","like_count":0},{"had_liked":false,"id":240048,"user_name":"wy","can_delete":false,"product_type":"c1","uid":1064681,"ip_address":"","ucode":"41C1B304E7F032","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e9/116f1dee.jpg","comment_is_top":false,"comment_ctime":1596726606,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596726606","product_id":100026001,"comment_content":"老师，假如有两个操作<br>a=1+2;<br>a=2+2;<br>最后a是3还是4？","like_count":0,"discussions":[{"author":{"id":1363348,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cd/94/c08d783c.jpg","nickname":"前来打酱油的","note":"","ucode":"50457A9017AE46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323109,"discussion_content":"现代编译器直接就给你优化成a=4了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604887280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230954,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1593530714,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593530714","product_id":100026001,"comment_content":"乱序分发，在固定的流水线的上游装了个调度器，alu少浪费","like_count":0},{"had_liked":false,"id":207580,"user_name":"WENMURAN","can_delete":false,"product_type":"c1","uid":1915404,"ip_address":"","ucode":"5D1CE8B41937C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXNhbTULKiakib8lYXrvGF2zPwfedooBzC2EtSv1nt1MwV1KUvTkcJrvCBFvcdwJicnr3OEXnk9GUCg/132","comment_is_top":false,"comment_ctime":1587112334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587112334","product_id":100026001,"comment_content":"冒险和预测三:<br>解决流水线停顿的方案，<br>流水线停顿的时候，对应的电路也是停着的，这时我们可以先把后面的指令调到前面来先执行，充分利用这个空挡。<br>有些指令必须依赖前面指令的数据，有些则不用，我们才用乱序执行的方法，把这些没有前后依赖的指令可以提前利用空挡执行，就相当于在CPU里面创造一个进程池。哪个指令准备就绪就执行哪个，某一个发生阻塞时，先执行其他指令。<br>指令执行完后，按照前面指令的顺序返回数据。","like_count":0},{"had_liked":false,"id":201317,"user_name":"sun","can_delete":false,"product_type":"c1","uid":1136181,"ip_address":"","ucode":"948FD34662AFB0","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/35/eeee9309.jpg","comment_is_top":false,"comment_ctime":1585750338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585750338","product_id":100026001,"comment_content":"比如 两个线程分别在两个核中执行fun1（）{int i1=1; int i2=i1+1; boolean b = true;）和fun2（）{if(b) {System.out.println()i2}},假设 协会阶段不是顺序的，b=true被先写回缓存中，此时因为内存屏障，同步到主存中b位true，i2为0，另一个线程输出0，也就是说如果不保证最后的写回阶段有序，内存屏障也会失效？？<br>请问老师是这样吗？","like_count":1},{"had_liked":false,"id":195299,"user_name":"Fibonacci","can_delete":false,"product_type":"c1","uid":1168361,"ip_address":"","ucode":"31DB723EB4BBA1","user_header":"https://static001.geekbang.org/account/avatar/00/11/d3/e9/59ff9004.jpg","comment_is_top":false,"comment_ctime":1585155908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585155908","product_id":100026001,"comment_content":"老师，你好，请问核间中断是用来做啥的？线程和进程通信吗？","like_count":0},{"had_liked":false,"id":190991,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1584716367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584716367","product_id":100026001,"comment_content":"老师你好，a，d，x的关系我是这么理解的：<br>a和x没有依赖关系，因此，可以并行执行，按你说的x执行更快，但由于需要等待前面的所有指令计算完成，因此，x需要在重排序缓冲区等待。<br>接着a指令执行完了，写入到重排序缓冲区。假设a前面没有指令了，则a可以先提交指令。<br>接着d通过数据转发的方式得到a值，计算并写入重排序缓冲区，然后由于d前面没有指令需要等待，所以提交d指令。<br>最后x指令前面没有需要等待了，所以提交x指令。所以指令的提交是a-&gt;d-&gt;x,而实际计算完成结果是x-&gt;a-&gt;d。","like_count":0},{"had_liked":false,"id":171650,"user_name":"许先森","can_delete":false,"product_type":"c1","uid":1795371,"ip_address":"","ucode":"1F42D4A6B5C6AF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","comment_is_top":false,"comment_ctime":1578986905,"is_pvip":false,"replies":[{"id":"68113","content":"许先森同学，<br><br>会啊，所以需要有冒险检测，以及触发数据冒险，用NOP去填充一些流水线的位置，避免程序出错。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580637473,"ip_address":"","comment_id":171650,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578986905","product_id":100026001,"comment_content":"我的思考是上面的例子只是简单的计算，会不会是后面有一些逻辑运算对a和x的结果读取有顺序要求，如果不保证先正确读取a再正确读取到x的话会对逻辑运算有影响。","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481452,"discussion_content":"许先森同学，\n\n会啊，所以需要有冒险检测，以及触发数据冒险，用NOP去填充一些流水线的位置，避免程序出错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171595,"user_name":"许先森","can_delete":false,"product_type":"c1","uid":1795371,"ip_address":"","ucode":"1F42D4A6B5C6AF","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/2b/446ef7b6.jpg","comment_is_top":false,"comment_ctime":1578971915,"is_pvip":false,"replies":[{"id":"68112","content":"许先森同学，<br><br>你好，这个就是会触发数据冒险，把整个指令执行往后延。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580637428,"ip_address":"","comment_id":171595,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578971915","product_id":100026001,"comment_content":"“3. 这些指令不会立刻执行，而要等待它们所依赖的数据，传递给它们之后才会执行。这就好像一列列的火车都要等到乘客来齐了才能出发。”<br>这里有个问题啊，所有指令都是在保留站中等待自己依赖的数据，那如果依赖的是上一条指令的结果呢？","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481428,"discussion_content":"许先森同学，\n\n你好，这个就是会触发数据冒险，把整个指令执行往后延。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580637428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163001,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1576638910,"is_pvip":false,"replies":[{"id":"68666","content":"Hash同学，<br><br>你好，可以想一想具体在什么情况下，会不是我们预期的结果呢？","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581238958,"ip_address":"","comment_id":163001,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576638910","product_id":100026001,"comment_content":"我觉得如果不保证它们的执行顺序的话，那最终得到的结果也可能不是我们期望的结果","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478208,"discussion_content":"Hash同学，\n\n你好，可以想一想具体在什么情况下，会不是我们预期的结果呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581238958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145022,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1572163406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572163406","product_id":100026001,"comment_content":"---问题---<br>老师您好，对于指令提交部分不是很理解，如果指令提交部分依然是需要保证原有指令顺序的话，那不是在这个部分先完成的指令依然要等待原有顺序在它之前的指令的完成，比如“x = y * z”要等待“d = a * e”的执行完成才能提交？","like_count":0},{"had_liked":false,"id":139079,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1570542162,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1570542162","product_id":100026001,"comment_content":"对于老师在文中举例的三行代码，由于都是加法指令那么是否有可能前两行代码先被转发进行优化，而不出现文中老师说的这种情况呢？如果是这样那相当于第2、3条指令都会插入一个NOP，应该和文中说到的情况能达到一样的优化效果。还有文中老师说到的这种乱序执行优化，第2条指令在等待第1条指令访存，而此时由于乱序执行优化仍然要保持最后的提交顺序，指令1的结果并不会写会到寄存器中，而是输出到重排序缓冲区，那么此时指令2是到缓冲区拿到的依赖数据吗？老师有空解答一下","like_count":0},{"had_liked":false,"id":138936,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1570513103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570513103","product_id":100026001,"comment_content":"保障内存访问的顺序 就类似于在编程中多线程对同一个变量的操作一样，会导致数据不可预测，导致出错","like_count":0},{"had_liked":false,"id":135307,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1569122235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569122235","product_id":100026001,"comment_content":"1  增加高速缓存和指令跳转解决的是，一条指令，的效率问题。这样，一条大指令执行顺序还是顺序执行。 <br> 2  乱序执行，是指在指令执行之前，和指令执行之后分别增加保栈和指令缓冲区，确保指令能够异步执行。","like_count":0},{"had_liked":false,"id":128648,"user_name":"Mango","can_delete":false,"product_type":"c1","uid":1515101,"ip_address":"","ucode":"D34F0424F4F742","user_header":"https://static001.geekbang.org/account/avatar/00/17/1e/5d/62fdc917.jpg","comment_is_top":false,"comment_ctime":1566923146,"is_pvip":false,"replies":[{"id":"52640","content":"Mango同学你好，<br><br>可以更具体一点么，离答案很接近了，但是我认为这个不能叫做“数据冒险”问题。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1569659165,"ip_address":"","comment_id":128648,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566923146","product_id":100026001,"comment_content":"思考题，感觉是内存屏障，防止多核CPU操作共享内存时出现数据冒险问题。","like_count":0,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465039,"discussion_content":"Mango同学你好，\n\n可以更具体一点么，离答案很接近了，但是我认为这个不能叫做“数据冒险”问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569659165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128562,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1566904166,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566904166","product_id":100026001,"comment_content":"课后思考题回答：<br>如果数据写回不是按照顺序的话，如果对同一个数据的修改顺序反了，可能导致最终的结果就是错误的","like_count":0,"discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15946,"discussion_content":"思考题问的是  ：对【内存访问】如果不是按照顺序访问会出现什么问题，并没有涉及到删增改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568862797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106499,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561336908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561336908","product_id":100026001,"comment_content":"老师好!非常通俗易懂，不过story buffer(存储缓冲区)我是第一次见。老师能稍微介绍下么？寄存器-&gt;多级高速缓存-&gt;主存之前的理解是这样的。。","like_count":0},{"had_liked":false,"id":106496,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561336618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561336618","product_id":100026001,"comment_content":"感觉判断，数据是否准备就绪有点难度，老师后面会讲么?乱序执行的时候怎么保证依赖顺序正确。数据依赖，反依赖，输出依赖那个。","like_count":0},{"had_liked":false,"id":105585,"user_name":"古夜","can_delete":false,"product_type":"c1","uid":1341612,"ip_address":"","ucode":"0A82D3CFCEDF07","user_header":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","comment_is_top":false,"comment_ctime":1561036083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561036083","product_id":100026001,"comment_content":"老师好，有没有什么思路从硬件角度理解多线程呢？有什么资料可以作为参考呢？","like_count":0},{"had_liked":false,"id":105466,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1399673,"ip_address":"","ucode":"929E3FFD14EFC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/5b/79/d55044ac.jpg","comment_is_top":false,"comment_ctime":1561008273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561008273","product_id":100026001,"comment_content":"强内存模型可以保证数据的一致性🌝🌝","like_count":0},{"had_liked":false,"id":105230,"user_name":"鱼向北游","can_delete":false,"product_type":"c1","uid":1439908,"ip_address":"","ucode":"580EC7DCE57E9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132","comment_is_top":false,"comment_ctime":1560942395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560942395","product_id":100026001,"comment_content":"思考题应该是程序真实逻辑有时候会依赖内存访问顺序，而不是单单依赖数据的计算结果正确性吧","like_count":0},{"had_liked":false,"id":105176,"user_name":"lzhao","can_delete":false,"product_type":"c1","uid":1509217,"ip_address":"","ucode":"9E71888215D3E1","user_header":"","comment_is_top":false,"comment_ctime":1560933477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560933477","product_id":100026001,"comment_content":"计算后的值写到Store Buffer中，什么时候写道主内存和寄存器呢？带来的可见性问题，通知屏障指令又是怎么解决的，能单独开一章节讲这个问题吗？或者我加你的联系方式，单独针对几个问题问一下？谢谢","like_count":0},{"had_liked":false,"id":105160,"user_name":"lzhao","can_delete":false,"product_type":"c1","uid":1509217,"ip_address":"","ucode":"9E71888215D3E1","user_header":"","comment_is_top":false,"comment_ctime":1560931812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560931812","product_id":100026001,"comment_content":"能不能配合指令重排序带来的并发性问题，cpu时怎么解决的，Java语言里面为什么又要定义自己的一套内存模型，是CPU 的内存模型解决不掉这种并发问题吗？多个CPU指令重排序会带来什么样的并发问题？","like_count":0},{"had_liked":false,"id":105001,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1560904631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560904631","product_id":100026001,"comment_content":"然后在重排序缓冲区里，把对应的计算结果的提交顺序，仍然设置成 a -&gt; d -&gt; x，而计算完成的顺序是 x -&gt; a -&gt; d。为什么x先完成","like_count":0},{"had_liked":false,"id":104999,"user_name":"D","can_delete":false,"product_type":"c1","uid":1027596,"ip_address":"","ucode":"5BB4D16FE39BFF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/0c/f39f847a.jpg","comment_is_top":false,"comment_ctime":1560904612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560904612","product_id":100026001,"comment_content":"因为程序的逻辑，依赖于计算结果，所以计算可以乱序，但是程序逻辑无法保证了。","like_count":0},{"had_liked":false,"id":104965,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1560899636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560899636","product_id":100026001,"comment_content":"有时候不能保证开发者的程序打乱指令执行顺序结果一致，比如我上次编译ffnpeg的测试版，make -j 4就错误，单核编译make就可以，是不是这个原因呢","like_count":0}]}