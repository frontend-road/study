{"id":767358,"title":"18｜测试策略（一）：如何构造有效的测试策略？","content":"<p>你好，我是徐昊，今天我们来继续学习AI时代的软件工程。</p><p>上节课，我们展示了按照测试驱动开发（Test Driven Development，TDD）的节奏，与大语言模型（Large Language Model，LLM）结对编程（Pairing Programming）的过程。还展示了我们如何使用这样的方式，在保证质量的前提下兼顾速度，获得实打实的效率提升。</p><p>然而，我们上节课展示的例子非常的简单，是一个仅仅包含一个类的工具类代码。因而针对它的测试策略也非常的简单。换成更复杂的场景，我们就需要构建有效的测试策略，才能保证通过测试策略得到顺畅的开发节奏。</p><h2>使用测试四象限构造测试策略</h2><p>提到测试策略，很多人会不自觉地想到测试金字塔（Testing Pyramid）。这是2009年Mike Cohn在他的著作《Succedding with Agile》提到的一个隐喻，借助金字塔结构描述不同层次的测试。比如Mike Cohn自己就给出了一个三层的金字塔结构，分别对应单元测试（Unit Tests）、服务测试（Service Tests）和用户界面测试（User Interface Tests）。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/01/84901388166d77429c3510e7a96ea301.jpg?wh=1608x749\" alt=\"\"><br>\n然而测试金字塔这个隐喻，主要想说明的是自动化测试的分布，以及不同层之间的对应关系。良好的自动化测试，应该符合金字塔式的分布，也就是能够提供快速反馈的细粒度测试占据多数，而缓慢昂贵的粗粒度测试应该只有一小部分。</p><!-- [[[read_end]]] --><p>其实这里非常容易忽略的一点是：<strong>每当有一个处于金字塔上层的测试失败，必然有多个处于底层的测试失败。</strong>这才是测试金字塔的核心隐喻。下层的测试撑起上层的测试，而不是毫无关联的两套测试。</p><p>所以测试金字塔并不能帮助我们设计有效的测试策略，<strong>它只能帮我们检查我们的自动化测试集合是否处于良好状态，以及不同层之间的测试是否存在必要的关联。</strong>设计测试策略，测试四象限（Agile Testing Quadrants）是一个更好的框架和工具。</p><p>测试四象限是2003年由Brian Marick提出的，最开始的名字叫做Marick的测试矩阵（Marick’s Test Matrix）。Brian Marick开创性地将不同种类的测试放置在不同的象限，用来说明它们的作用。后来这逐渐演化为广为人知的测试四象限：</p><p><img src=\"https://static001.geekbang.org/resource/image/95/2f/95eecddaf814a61775368c293116ca2f.jpg?wh=2400x1960\" alt=\"\"></p><p>首先我们可以看到，Brain Marick选取了两个维度构成四象限，分别是<strong>测试的目的以及测试的受众</strong>。测试的目的被分成支持团队（Supporting Team）和评价产品（Critique Product），测试的受众被分成技术导向（Technology Facing）和业务导向（Business Facing）。</p><p>测试的受众很好理解，那么测试的目的是什么意思呢？所谓支持团队，是指测试主要目的是为开发团队提供反馈。而评价产品，则是指测试的主要目的是评估产品在不同维度上的表现。</p><p>比如登录系统的功能测试，它是团队的自动化回归测试（Regression Test）的一部分，同时它也可能是用户验收测试（UAT）的一部分。同样一个测试，它的目的是完全不同的。对于回归测试而言，它的目的主要是告诉团队功能是否被破坏；而对于用户验收测试而言，目的则是验证功能是否能满足用户的需要。因而我们在思考测试的时候，要综合考虑测试的目的与受众，而不是仅仅关注在具体的测试上。</p><p>然后，按照测试的目的与受众，可以自然地划分出四个象限：</p><ol>\n<li>第一象限（Q1），技术导向的支持团队的测试。这个象限中的测试是为交付团队中的<strong>技术人员</strong>提供快速反馈，是为了在组件和子系统的粒度上定位问题。常见的单元测试（Unit Testing）、组件测试（Component Testing）都属于这个象限；</li>\n<li>第二象限（Q2），业务导向的支持团队的测试。这个象限中的测试是为交付团队提供关于<strong>业务</strong>的反馈，是根据验收条件（Acceptance Criteria）构造的各种测试。功能测试（Functional Testing）、用户故事测试（Story Testing）、示例说明（Specification by Example）都属于这个象限。需要注意，这些测试并不只对业务人员有用，对团队中所有人都非常重要；</li>\n<li>第三象限（Q3），业务导向的评价产品的测试。这个象限中的测试评价的是产品是否能够提供业务价值。主要是从功能和用户交互的维度上评价。用户验收测试、探索性测试（Exploratory Testing）、可用性测试（Usabliltiy Testing）都属于这个象限；</li>\n<li>第四象限（Q4），技术导向的评价产品的测试。这个象限中的测试评价的是产品的跨功能特性（Cross function requirements），比如安全性、性能、容量、负载等等。所以显而易见，性能测试（Performance Testing）、安全测试（Security Testing）等测试属于这个象限。</li>\n</ol><p>测试四象限可以从全局出发，帮助我们理解不同种类的测试到底发挥了什么作用。因此，测试四象限是承载测试策略的绝佳框架。而<strong>构造测试策略的过程，也就变成选择恰当的测试类型，分别放入不同象限的过程。</strong></p><h2>通过验收条件构造支持团队的测试</h2><p>在使用四个象限构造测试策略时，评价产品的Q3和Q4象限是比较容易构造的。而支持团队的Q1和Q2象限则比较困难。</p><p>这一方面是因为绝大多数交付团队对于Q3与Q4象限的测试更加熟悉，另一方面也是因为 <strong>Q3和Q4象限的测试相对正交，彼此之间不存在太大的关联</strong>。比如，Q4象限的性能测试并不依赖于Q3象限中的UAT、可用性测试或探索性测试。</p><p><strong>而支持团队的Q1和Ｑ2象限的测试之间则存在更深的关联</strong>。当我们只有Q2象限的测试时，我们只知道出了问题，但不知道是哪个组件的问题；而当我们只有Q1象限的测试时，我们只知道组件出了问题，但不知道这会带来什么影响。</p><p>因而单纯地在团队中引入功能测试（Q2象限）和单元测试（Q1象限），并不能达到支持团队的效果。我们更需要的是，<strong>建立Q1和Q2象限测试间的关联，这是测试策略中的极为重要的一环。</strong></p><p>那么怎么样才能有效地建立Q1和Q2象限测试的关联呢？有两个关键，一是验收条件，二是TDD的任务分解。</p><p>正如我们之前讲过的，验收条件是用户故事（User Story）的重要组成部分，用于帮助开发团队和客户明确产品或功能的期望表现、功能要求和可接受的标准。那么站在测试的角度上说，<strong>每一个验收条件，都可以对应一组功能测试（Q2象限测试）。</strong></p><p>TDD的任务分解是将待开发的任务，分解为一组可测试的任务，这是测试驱动开发的核心。当我们同时使用验收条件澄清需求时，我们需要做的就是在验收条件的上下文中，按照不同的功能上下文，进行任务分解。</p><p>所谓功能上下文，可以是一个模块，一个组件，一个类（Class）或一个函数（function）。而通常我们使用测试驱动进行开发的时候，会持续对任务进行分解，直到功能上下文达到合适的粒度为止。因而站在测试的角度上说，<strong>每一个可测试的任务都对应着一组组件测试（Q1象限测试）</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/0d/5a/0d5c0047c4a16cca9705f722cd7ebe5a.jpg?wh=1780x1080\" alt=\"\"></p><p>通过任务分解得到的 <strong>Q1象限和Q2象限的测试必然存在内在的关联关系</strong>。当验收条件对应的测试失败时，必然意味着某个功能上下文中的功能不满足预期。那么该功能上下文中，必然有某个任务项没有做到位。那么该任务项对应的测试，必然也会失败。</p><p>不难发现，通过任务分解分解得到的Q1象限和Q2象限测试，还很容易满足测试金字塔的结构。因为<strong>处于金字塔上层的Q2象限测试失败，必然有多个处于底层的Q1象限测试失败。</strong>Q1象限的测试撑起上层Q2象限的测试，而不是毫无关联的两套测试。</p><h2>小结</h2><p>当我们按照测试驱动开发的节奏与大语言模型结对编程时，构建支持团队的测试（Q1象限和Q2象限）是至关重要的一步。</p><p>Q1象限的测试能够撑起上层Q2象限的测试，而不是毫无关联的两套测试。通过验收条件和TDD的任务分解，能够帮我们有效建立起这两套测试的关联。</p><p>Q2象限的测试，可以帮助我们验证LLM生成的代码是否满足验收条件的诉求；Q1象限的测试则帮助我们聚焦到某个具体的功能上下文中，避免因Token限制带来的一系列麻烦。</p><p>那么现在的关键就在于功能上下文要如何划分。这是我们下节课要讨论的问题。</p><h2>思考题</h2><p>你觉得有哪些划分功能上下文的方法？</p><p>欢迎在留言区分享你的想法，我会让编辑置顶一些优质回答供大家学习讨论。</p>","comments":[{"had_liked":false,"id":389757,"user_name":"王达菲","can_delete":false,"product_type":"c1","uid":2711301,"ip_address":"陕西","ucode":"C17DA3C40E2E76","user_header":"https://static001.geekbang.org/account/avatar/00/29/5f/05/6a5c22eb.jpg","comment_is_top":false,"comment_ctime":1713398880,"is_pvip":false,"replies":[{"id":141821,"content":"课里都写了 仔细看","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1713480961,"ip_address":"北京","comment_id":389757,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"测试的四象限困扰我很久了，主要是几个概念，何为业务？何为技术？比如说安全性，这是业务还是技术。所谓支持团队该如何理解？感觉Q1和Q2是偏向于功能测试，验证功能设计与实现的一致性，那么是不是意味团队就只关注于功能验证？问题有点多，烦劳徐老师解惑","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642332,"discussion_content":"课里都写了 仔细看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713480961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046394,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/7a/55618020.jpg","nickname":"马若飞","note":"","ucode":"3D0327329A10AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642217,"discussion_content":"可以先了解一下功能性需求和非功能性需求（质量属性），你就有答案了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1713421621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389789,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1713452487,"is_pvip":true,"replies":[{"id":141833,"content":"理想情况是一组人\n","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1713740524,"ip_address":"浙江","comment_id":389789,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"🤔☕️🤔☕️🤔\n【R】测试金字塔的隐喻：上层测试失败，必然多个底层的测试失败。\n测试四象限（Agile Testing Quadrant）：\n（Business vs Technology）x Facing\nCritique Product vs Supporting Team\nQ1：Technology Facing + Supporting Team\nQ2：Business Facing + ^^^\nQ3：^^^ + Critique Product\nQ4：^^^^^^ + ^^^\n关联Q1&amp;Q2的关键：验收条件 + 分解TDD任务（待开发任务 分解为 可测试任务）。\n【.I.】有种情况让我尴尬，那就是问题在别处那里发现，有种情况让我更尴尬，那就是加点打印再去别处复现，还有种情况让我气愤，那就是复现后改动再拿去让别人去验证，还有种情况让我更气愤，那就是问题再次出现时，谁有打印就谁去负责排查。\n有种做法让我认可，那就是在尴尬的打印中复现问题后，赶紧跑回自己家，去分析这个问题现象，是因为自己缺少哪方面的验证点，去改进现在的测试用例、或者再补充一个新的测试用例，并且在名字上能够有T0和T1&#47;2+的区分，用新的验证用例在自己家复现问题，再去修复问题不迟，最后给出去之前，本地所有用例都通过，才有自信问题已搞定，才明白新问题给自己带来多少认知和能力的提升。\n【Q】Q1&amp;Q2指向的支持团队，开发人员+测试人员 or 测试开发人员？ 即这2个象限的测试用例，由2组人独立设计实现，还是由1组人全包设计实现？\n— by 术子米德@2024年4月18日","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642674,"discussion_content":"理想情况是一组人\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713740524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645392,"discussion_content":"测试人员/QA 写的测试用例，有价值，不过太晚了，一般都是开发完成准备提测了，才出来，黄花菜都凉了。\n\n所以只能开发自己搞，TQA 整出 AC 得到 Q2，再按测试工序分解成 Q1，顺便锻炼自己的任务分解能力。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716084116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389720,"user_name":"范飞扬","can_delete":false,"product_type":"c1","uid":2721761,"ip_address":"浙江","ucode":"A665DF46833A81","user_header":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","comment_is_top":false,"comment_ctime":1713319799,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"1、Q1 象限测试，直接叫“单元级别功能测试”不是更好么？我有三个理由。第一、叫组件测试的话，忽略了类和函数。第二、 光和别人说组件测试，别人也可能理解成是Q2的测试。第三、老师在自己的 TDD 课里就是把 Q1 的测试称作“单元级别功能测试”。\n\n2、那么，很自然的，Q2象限测试叫功能测试就不合适了。难道Q1的测试不是功能测试么？Q1也是功能测试，粒度更小罢了。所以，Q2的测试可以称作“系统级别功能测试”，这样就和Q1的“单元级别功能测试”对应上了。\n\n3、不过，Q2 测试更好的名字可能是 Acceptance Test. 很巧，就在老师说的《Succeeding with Agile》里，Mike Cohn推荐了一本书叫《Test driven: TDD and acceptance TDD for Java developers》。这本书里就提到，ATDD (Acceptance TDD) 帮助开发者构建满足商业需要的软件，而 TDD 帮助开发者保障了软件的技术质量[1]。那么，很自然的，Q2的测试可以称作 Acceptance Test.\n\n4、International Software Testing Qualifications Board (ISTQB) 对于 Acceptance Test 的定义是“验证系统是否满足验收条件的测试”[2]。 从这个定义可以看出，Acceptance Test 直接和验收条件相关联，那么，很自然的，Q2的测试可以称作 Acceptance Test.\n\n5、对于熟悉徐昊老师的TDD课程的同学，Q1 和 Q2 的测试还可以有另一套命名。可以看出，本文需求分解的图片和 TDD 课程里的图片极为相似，就是把功能点称作了验收条件。那么，很自然的，Q2 测试可以称作功能点测试，Q1 测试可以称作功能上下文测试。\n\n6、接着第 5 条，通过和本文的图片进行比对，可以发现当年 TDD 课程里的图片其实漏画了 Q2的测试，应该补上。\n\n7、接着第 5 条，那思考题就很简单了，老师讲过。\n\n思考题：你觉得有哪些划分功能上下文的方法？\n\n方法一、可以通过预先设计（Upfront Design）的架构愿景（比如 MVC）划分功能上下文。这对应了 TDD 的伦敦学派。\n\n方法二、可以通过演进式设计（Evlutionary Design）提取或梳理架构愿景，再划分功能上下文。主要方法是重构，特别是重构到模式（Refactoring to Patterns）。这对应了 TDD 的经典学派。\n\n\n注释：\n[1] : Acceptance test-driven development(acceptance TDD) is what helps developers build high-quality software that fulfills the business’s needs as reliably as TDD helps ensure the software’s technical quality.\n\n[2]: https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Acceptance_testing","like_count":5,"discussions":[{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642144,"discussion_content":"8、接着第 6 条，不仅图片少了Q2测试，TDD 的流程也少了个编写Q2测试，应该补上。（如果不写Q2的测试，可能会被坑的，别问我怎么知道的。。。可以参考第 3 条说的）实际上，老师在TDD课里，演示 ArgParser 时，就是先写了个 Q2 测试，然后写了 Q1 测试，用 Q1 测试进入红/绿/重构循环。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1713345519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390699,"user_name":"范飞扬","can_delete":false,"product_type":"c1","uid":2721761,"ip_address":"广东","ucode":"A665DF46833A81","user_header":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","comment_is_top":false,"comment_ctime":1716029537,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"原文：构造测试策略的过程，也就变成选择恰当的测试类型，分别放入不同象限的过程。\n\n思考：\n1、测试类型和象限不是一个东西么？\n2、参考直播里讲的，这里应该是：“选择恰当的组件类型，分别放入不同象限”吧，而不是测试类型\n","like_count":0,"discussions":[{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645391,"discussion_content":"对于 1 ，也可以说，一个象限包含了多个测试类型，不过我觉得，这两区别开来的作用不大，所以可以当成一个东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716083841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390231,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1714812768,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"2024年05月04日16:49:34 来完成一下课后作业\n划分功能上下文的方法，一般会以业务功能（接口）去划分，然后任务项通过架构分层划分（http 层、业务逻辑层、数据交互层）","like_count":0},{"had_liked":false,"id":389791,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1713452895,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"🤔☕️🤔☕️🤔\n【Q】哪些划分功能上下文的方法？\n【A】方法1：看看当下，手头有些什么技术栈的人来参与设计实现验证，想想未来，会有怎样技术栈的人来维护修正改进；方法2：分析当前需求要解决的问题，跟业界公开的架构风格与设计模式，它们所解决的问题的近似程度，越类似越可参考借鉴，即采用其划分方法；\n— by 术子米德@2024年4月18日","like_count":0},{"had_liked":false,"id":389784,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"福建","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1713447680,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"TDD 里面的测试都是功能测试， 在这里的 Q2 和 Q1 是否可以理解为粒度不同的功能测试？ ","like_count":0},{"had_liked":false,"id":389737,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"北京","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1713347951,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"&gt; 每一个可测试的任务都对应着一组组件测试（Q1 象限测试）\n\n“任务”最终都要落实到代码层面,由代码中的工作单元(抽象模型)即结构体、方法、类、函数等提供功能来完成该“任务”. \n\n“可测试的任务”, 相当于在说, 你在设计模型&#47;工作的单元的时候, 除了要提供功能以完成“任务”还要考虑其可测试性——以容易编写测试的方式来设计并实现该模型&#47;工作单元. 先写测试会倒逼你朝着可测试方向设计模型&#47;工作单元.\n\n“组件测试”其实也是工作单元&#47;模型的功能测试, 为什么是一组呢? 因为要覆盖正常情况、边界情况和异常情况\n\n","like_count":0},{"had_liked":false,"id":389733,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"北京","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1713346295,"is_pvip":true,"replies":null,"discussion_count":5,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"在老师的TDD课程中介绍TDD流程时 https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;496703 有类似的图片, 但用“功能点”替代了这里的“验收条件”. 当然,TDD课程中也说了, “首先将需求分解为功能点，也就是将需求转化为一系列可验证的里程碑点”\n是不是可以这样理解:\n1. 需求分解的产物就是功能点集合&#47;列表即各个用户故事的验收条件的集合&#47;列表\n2. 功能点就是某个用户故事的验收条件\n2. “可验证的里程碑点”, 是不是可以理解为, 当某个用户故事的所有验收条件(功能点)都实现了,并且将代码提交后, 此时软件就可以工作、验证的状态.","like_count":0,"discussions":[{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642586,"discussion_content":"里程碑点和功能点是一对一的关系吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713676804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1187021,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","nickname":"Gojustforfun","note":"","ucode":"7513A40F27344F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642940,"discussion_content":"取决于团队对“里程碑点”的定义和理解\n\n如果里程碑点=功能点，功能点=验收条件，那么只要实现一个验收条件并将其合并到代码库，此时软件就是可工作，可验证的状态——测试团队可以进行后续验证\n\n如果里程碑点=功能点，功能点=用户故事，用户故事=验收条件集合，那么在实现一个完整用户故事后并将其合并到代码库，此时软件才算可工作，可验证的状态——测试团队可以进行后续验证\n\n我一般是实现完整用户故事再提测。欢迎讨论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713925037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":642586,"ip_address":"北京","group_id":0},"score":642940,"extra":""},{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1187021,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","nickname":"Gojustforfun","note":"","ucode":"7513A40F27344F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":642941,"discussion_content":"老师说：首先将需求分解为功能点，也就是将需求转化为一系列可验证的里程碑点\n\n同时参考，老师的那张图，可以看出，里程碑点=功能点=AC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713925209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":642940,"ip_address":"广东","group_id":0},"score":642941,"extra":""},{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1187021,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","nickname":"Gojustforfun","note":"","ucode":"7513A40F27344F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":643045,"discussion_content":"在TDD课的开篇词，老师说：一个个测试就像一个个里程碑点（Milestone）。\n可以看出，里程碑点=功能点=AC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714004169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":642940,"ip_address":"广东","group_id":0},"score":643045,"extra":""}]}]}]}