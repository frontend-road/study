{"id":479991,"title":"14｜自动化注入神器（一）：sqlmap的设计思路解析","content":"<p>你好，我是王昊天。</p><p>从古至今，人们为了方便自己的生活，发明出各种各样的工具。就拿扫地来说，这是我小时候最讨厌的家务活动，因为扫地时扬起的灰尘会让我十分难受，而且有的死角很难被打扫干净。扫地机器人的出现给我们带来了极大的便利，我们只要拥有它，就不需要再亲自扫地了。</p><p>在前几节课中，我们学习了SQL注入的原理和方法，相信你已经小试牛刀了。不知道你在做注入测试的时候是否会觉得困难呢？反正我学的时候是遇到了不少困难，比如，绕过技巧多种多样，我们几乎不可能全部记住它们，就算记住了我们一一去尝试也需要很多的时间，费时又伤神。</p><p>就像我们刚才说过的，当问题出现时，我们常常会创造出一种工具，来解决对应的问题。那么有没有一款工具，能帮我们自动去进行注入测试呢？答案是肯定的，这个工具就是sqlmap。</p><p>这节课呢，我们正式开启sqlmap学习之旅，深入探究这款自动化注入神器的实现原理。<strong>首先我们要对一些知识有所了解，包括如何获取软件的代码，如何搭建软件的运行环境，以及软件文件功能等。接下来，我们会对sqlmap的工作流程做一个整体的介绍，这会为我们后续学习sqlmap打好基础。</strong></p><h2>sqlmap</h2><p><img src=\"https://static001.geekbang.org/resource/image/34/9a/347a42c49613eea753d176b53396ba9a.png?wh=1895x662\" alt=\"图片\"></p><p>我们先来看看到底什么是sqlmap。</p><!-- [[[read_end]]] --><p>sqlmap是一个帮助我们自动检测sql注入是否存在的测试工具，它会使用不同注入方法进行测试，并将测试结果展示给我们，供我们利用。这些方法都是我们之前学过的内容，包括联合注入、时延注入、布尔盲注、报错注入和堆查询注入。如果你感兴趣，可以去上节课寻找更加详细的介绍。</p><p>因为它的持续更新和维护，所以大家普遍认为它既方便又好用，从图片中我们可以看到超过4k的fork数量，以及高频的源码更新。就像一枚硬币的两面，这种优势也会伴随一些问题，比如给我们阅读源代码增加了难度，而我们要想真正去理解、掌握这款工具，就必须要迎难而上，对它的源代码进行剖析。</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/ca/2e17e69bf2856256754fc409ab2ebaca.png?wh=1751x480\" alt=\"图片\"></p><p><strong>代码获取</strong></p><p>我们用如下命令将sqlmap的源代码克隆下来。</p><pre><code class=\"language-bash\">git clone https://github.com/sqlmapproject/sqlmap\ncd sqlmap\n</code></pre><p>因为该过程需要访问外网，所以克隆的速度会较为缓慢，当然我们可以借助一些代理工具来加速这个过程。</p><p>这里我们分析的sqlmap版本是最新的版本1.6，它于2022年初发布，相比于上一代1.5.12版本，只是修复了几个编码异常，并且替换版本信息，并没有什么重大的改动。因此学习两个大版本的代码都是可以的。</p><p><img src=\"https://static001.geekbang.org/resource/image/35/80/35e9758f3c123549d2a25488c9224580.png?wh=1296x363\" alt=\"图片\"><img src=\"https://static001.geekbang.org/resource/image/65/e6/65ff8f7d9aca2ac1b79afbf44548fbe6.png?wh=1243x347\" alt=\"图片\"></p><p>在获取到源代码之后，我们还需要配置软件的运行环境，这样sqlmap才能顺利的运行。下面让我们进入到环境搭建这一步骤。</p><p><strong>环境搭建</strong></p><p>这节课，我们采用的分析环境是python3.10.1，可以利用下面的命令新建一个虚拟的解释环境，这样做有利于运行环境的隔离，防止其他环境因素干扰sqlmap的执行过程。</p><pre><code class=\"language-bash\">python3 -m venv venv\n</code></pre><p><strong>配置文件</strong></p><p>在做完环境搭建之后，sqlmap已经具有运行能力了。但是我们还需要知道哪个文件才是它的配置文件，即哪个文件会对它的运行产生影响。所以呢，接下来我们就来看看，sqlmap中有哪些重要的文件，它们又有哪些功能。</p><p>首先我们一起看下sqlmap的配置文件<code>sqlmap.conf</code>：</p><pre><code class=\"language-python\"># At least one of these options has to be specified to set the source to\n# get target URLs from.\n[Target]\n\n# Target URL.\n# Example: http://192.168.1.121/sqlmap/mysql/get_int.php?id=1&amp;cat=2\nurl =\n\n# Direct connection to the database.\n# Examples:\n#   mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME\n#   oracle://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_SID\ndirect = \n\n# Parse targets from Burp or WebScarab logs\n# Valid: Burp proxy (http://portswigger.net/suite/) requests log file path\n# or WebScarab proxy (http://www.owasp.org/index.php/Category:OWASP_WebScarab_Project)\n# 'conversations/' folder path\nlogFile = \n\n# Scan multiple targets enlisted in a given textual file\nbulkFile =\n\n# Load HTTP request from a file\n# Example (file content): POST /login.jsp HTTP/1.1\\nHost: example.com\\nUser-Agent: Mozilla/4.0\\n\\nuserid=joe&amp;password=guessme\nrequestFile = \n\n# At least one of these options has to be specified to set the source to\n# get target URLs from.\n[Target]\n\n# Target URL.\n# Example: http://192.168.1.121/sqlmap/mysql/get_int.php?id=1&amp;cat=2\nurl =\n\n# Direct connection to the database.\n# Examples:\n#   mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME\n#   oracle://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_SID\ndirect = \n\n# Parse targets from Burp or WebScarab logs\n# Valid: Burp proxy (http://portswigger.net/suite/) requests log file path\n# or WebScarab proxy (http://www.owasp.org/index.php/Category:OWASP_WebScarab_Project)\n# 'conversations/' folder path\nlogFile = \n\n# Scan multiple targets enlisted in a given textual file\nbulkFile =\n\n# Load HTTP request from a file\n# Example (file content): POST /login.jsp HTTP/1.1\\nHost: example.com\\nUser-Agent: Mozilla/4.0\\n\\nuserid=joe&amp;password=guessme\nrequestFile = \n......\n# Force back-end DBMS operating system to provided value. If this option is\n\n# set, the back-end DBMS identification process will be minimized as\n\n# needed.\n\n# If not set, sqlmap will detect back-end DBMS operating system\n\n# automatically by default.\n\n# Valid: linux, windows\n\nos = \n......\n</code></pre><p>由于配置文件很长，所以这里没有全部展示出来。我们需要知道的是，<strong>配置文件的参数配置可以对sqlmap程序运行的流程产生影响</strong>。举个例子，在配置文件中可以设置OS配置项，sqlmap就无需探测操作系统的类型了，这样就可以帮助我们在一些特定情况下优化sqlmap的执行速度。</p><p>看完配置文件之后，我们回忆一下之前学过的内容，在做SQL注入时，都需要经历哪些步骤呢？</p><p></p><p>我们知道，一般来说SQL注入攻击可以分为三步，首先是寻找注入点，之后要选择闭合参数的位置，最后要根据需求选择合适的payload，来实现我们的注入攻击操作。</p><p>sqlmap和手动SQL注入的思想是相似的，程序可以直接从请求的参数中获取到注入点位置的信息，而闭合参数的位置和payload的选择则会因为它们的多样性变得略微复杂，下面就让我们一起来看看与之相关的两个配置文件。</p><p></p><p>我们先来看sqlmap中闭合参数的配置内容，这里举个例子帮助你来理解什么是闭合参数。以一个典型的SQL注入语句为例：</p><pre><code class=\"language-python\">SELECT id FROM users WHERE name = '$name';\n</code></pre><p>想要对其进行注入，就需要将name参数闭合，这在前两节课中有过较深入的探讨。</p><p>对于sqlmap而言，data.xml.boundaries.xml就是用于闭合参数的配置文件，通过该文件我们可以确定闭合元素的字符和位置等等信息，了解该文件有助于我们理解sqlmap真正发送的测试payload的格式，关于payload格式这部分的内容我们会在下一讲具体的讲解。</p><pre><code class=\"language-plain\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;!--\nTag: &lt;boundary&gt;\n    How to prepend and append to the test ' &lt;payload&gt;&lt;comment&gt; ' string.\n\n    Sub-tag: &lt;level&gt;\n        From which level check for this test.\n\n        Valid values:\n            1: Always (&lt;100 requests)\n            2: Try a bit harder (100-200 requests)\n            3: Good number of requests (200-500 requests)\n            4: Extensive test (500-1000 requests)\n            5: You have plenty of time (&gt;1000 requests)\n\n    Sub-tag: &lt;clause&gt;\n        In which clause the payload can work.\n\n        NOTE: for instance, there are some payload that do not have to be\n        tested as soon as it has been identified whether or not the\n        injection is within a WHERE clause condition.\n......\n</code></pre><p>而关于payload这一部分，就让我们看一看sqlmap中payload的配置文件夹，<code>data.xml.payloads/</code>。这个文件夹储存有不同注入攻击类型的payload信息。</p><p>该文件夹下的每一个文件都与程序中一个重要的结构test息息相关，它是一个payload的基本信息单元，每个test里面包含了一个完整的payload需要的信息， sqlmap发送的攻击载荷就是在此基础上进行加工得出的，如下代码就是这个文件夹下的<code>boolean_blind.xml</code>文件的部分内容，这里我们选取了完整的test结构方便你了解。</p><pre><code class=\"language-python\"> &lt;test&gt;\n\n        &lt;title&gt;AND boolean-based blind - WHERE or HAVING clause (MySQL comment)&lt;/title&gt;\n\n        &lt;stype&gt;1&lt;/stype&gt;\n\n        &lt;level&gt;3&lt;/level&gt;\n\n        &lt;risk&gt;1&lt;/risk&gt;\n\n        &lt;clause&gt;1&lt;/clause&gt;\n\n        &lt;where&gt;1&lt;/where&gt;\n\n        &lt;vector&gt;AND [INFERENCE]&lt;/vector&gt;\n\n        &lt;request&gt;\n\n            &lt;payload&gt;AND [RANDNUM]=[RANDNUM]&lt;/payload&gt;\n\n            &lt;comment&gt;#&lt;/comment&gt;\n\n        &lt;/request&gt;\n\n        &lt;respons e&gt;\n\n            &lt;comparison&gt;AND [RANDNUM]=[RANDNUM1]&lt;/comparison&gt;\n\n        &lt;/response&gt;\n\n        &lt;details&gt;\n\n            &lt;dbms&gt;MySQL&lt;/dbms&gt;\n\n        &lt;/details&gt;\n\n    &lt;/test&gt;\n</code></pre><p>可以看到它的结构内部定义攻击类型、方式、生效位置、关联数据库等等信息。<br>\n至此，我们大致了解了sqlmap工作的底层依赖。下一步只需要分析和掌握sqlmap的运行过程，日后在使用中我们就可以更加得心应手。</p><p>sqlmap作为一个规模较大的工具，在启动过程中首先会执行一些初始化操作，下面就让我们一起学习sqlmap的初始化过程，通过这部分内容你可以明白sqlmap在启动之初做了哪些事情。</p><h2>初始化过程</h2><p>sqlmap的初始化过程包含四个步骤：环境初始化、命令行参数的解析、全局变量的赋值，以及运行环境的检查。我们将结合代码和图片注释，顺着sqlmap代码运行的顺序，详细讲述每一个步骤。下面让我们从环境初始化开始吧。</p><p><strong>环境初始化</strong></p><p>首先我们会发现，sqlmap的入口文件是sqlmap.py，这个文件的main如下所示：</p><pre><code class=\"language-python\">if __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        pass\n    except SystemExit:\n        raise\n    except:\n        traceback.print_exc()\n    finally:\n        if threading.active_count() &gt; 1:\n            os._exit(getattr(os, \"_exitcode\", 0))\n        else:\n            sys.exit(getattr(os, \"_exitcode\", 0))\nelse:\n    __import__(\"lib.controller.controller\")\n</code></pre><p>根据main函数的名字，我们可以知道，程序的核心逻辑一定被封装在了mian函数里面。因此，我们可以进入到mian函数里查看。</p><pre><code class=\"language-python\">def main():\n    try:\n        dirtyPatches()\n        resolveCrossReferences()\n        checkEnvironment()\n        setPaths(modulePath())\n        banner()\n        args = cmdLineParser()\n        cmdLineOptions.update(args.__dict__ if hasattr(args, \"__dict__\") else args)\n        initOptions(cmdLineOptions)\n        if checkPipedInput():\n            conf.batch = True\n        if conf.get(\"api\"):\n            from lib.utils.api import StdDbOut\n            from lib.utils.api import setRestAPILog\n            sys.stdout = StdDbOut(conf.taskid, messagetype=\"stdout\")\n            sys.stderr = StdDbOut(conf.taskid, messagetype=\"stderr\")\n            setRestAPILog()\n        conf.showTime = True\n        dataToStdout(\"[!] legal disclaimer: %s\\n\\n\" % LEGAL_DISCLAIMER, forceOutput=True)\n        dataToStdout(\"[*] starting @ %s\\n\\n\" % time.strftime(\"%X /%Y-%m-%d/\"), forceOutput=True)\n        init()\n</code></pre><p>进入到mian函数之后我们就会发现，环境初始化初始化过程的代码就在这里，该过程引入了两个重要数据容器的映射conf和kb。他们都是全局的环境变量，是存储程序运行中间数据和信息数据的容器，其中sqlmap的结果信息、注入信息、控制信息都是通过它们进行读写来完成程序的执行的。这部分内容我们会在下节课展开。</p><pre><code class=\"language-python\">from lib.core.data import conf\nfrom lib.core.data import kb\n</code></pre><p>在这里，为了你更好地理解它们，我们先来看看这两个数据结构是什么，这里我们可以找到lib.core.data.py文件进行观察。</p><pre><code class=\"language-python\"># object to share within function and classes command\n\n# line options and settings\n\nconf = AttribDict()\n\n\n\n\n\n# object to share within function and classes results\n\nkb = AttribDict()\n</code></pre><p>可以发现，这两个数据结构是作者自己封装的函数，封装的主要目的是实现深拷贝（<code>__deepcopy__</code> ）这个魔法函数。通过这种方式，Python内容数据的拷贝操作会被大大优化。</p><pre><code class=\"language-python\">class AttribDict(dict):\n      ......\n    def __deepcopy__(self, memo):\n\n        retVal = self.__class__()\n\n        memo[id(self)] = retVal\n\n\n\n\n\n        for attr in dir(self):\n\n            if not attr.startswith('_'):\n\n                value = getattr(self, attr)\n\n                if not isinstance(value, (types.BuiltinFunctionType, types.FunctionType, types.MethodType)):\n\n                    setattr(retVal, attr, copy.deepcopy(value, memo))\n\n\n\n\n\n        for key, value in self.items():\n\n            retVal.__setitem__(key, copy.deepcopy(value, memo))\n\n\n\n\n\n        return retVal\n</code></pre><p>接下来我们继续观察main函数。</p><pre><code class=\"language-python\">        dirtyPatches()  # 补丁函数\n        resolveCrossReferences()  # 消除交叉引用\n        checkEnvironment()  # 检查环境\n        setPaths(modulePath())  # 如果使用py2exe 作为file获取程序路径的替代 设置绝对路径\n        banner()\n</code></pre><p>我们可以看到，程序在进入到try语句之后，首先会执行几个函数。</p><p></p><p>第一个函数是dirtyPatches() ，它是一个补丁函数。</p><pre><code class=\"language-python\">def dirtyPatches():\n    \"\"\"\n    Place for \"dirty\" Python related patches\n    \"\"\"\n    # accept overly long result lines (e.g. SQLi results in HTTP header responses)\n    _http_client._MAXLINE = 1 * 1024 * 1024\n    # prevent double chunked encoding in case of sqlmap chunking (Note: Python3 does it automatically if 'Content-length' is missing)\n    if six.PY3:\n        if not hasattr(_http_client.HTTPConnection, \"__send_output\"):\n            _http_client.HTTPConnection.__send_output = _http_client.HTTPConnection._send_output\n        def _send_output(self, *args, **kwargs):\n            if conf.get(\"chunked\") and \"encode_chunked\" in kwargs:\n                kwargs[\"encode_chunked\"] = False\n            self.__send_output(*args, **kwargs)\n        _http_client.HTTPConnection._send_output = _send_output\n    # add support for inet_pton() on Windows OS\n    if IS_WIN:\n        from thirdparty.wininetpton import win_inet_pton\n    # Reference: https://github.com/nodejs/node/issues/12786#issuecomment-298652440\n    codecs.register(lambda name: codecs.lookup(\"utf-8\") if name == \"cp65001\" else None)\n    # Reference: http://bugs.python.org/issue17849\n    if hasattr(_http_client, \"LineAndFileWrapper\"):\n        def _(self, *args):\n            return self._readline()\n        _http_client.LineAndFileWrapper._readline = _http_client.LineAndFileWrapper.readline\n        _http_client.LineAndFileWrapper.readline = _\n    # to prevent too much \"guessing\" in case of binary data retrieval\n    thirdparty.chardet.universaldetector.MINIMUM_THRESHOLD = 0.90\n    match = re.search(r\" --method[= ](\\w+)\", \" \".join(sys.argv))\n    if match and match.group(1).upper() != PLACE.POST:\n        PLACE.CUSTOM_POST = PLACE.CUSTOM_POST.replace(\"POST\", \"%s (body)\" % match.group(1))\n    # https://github.com/sqlmapproject/sqlmap/issues/4314\n    try:\n        os.urandom(1)\n    except NotImplementedError:\n        if six.PY3:\n            os.urandom = lambda size: bytes(random.randint(0, 255) for _ in range(size))\n        else:\n            os.urandom = lambda size: \"\".join(chr(random.randint(0, 255)) for _ in xrange(size))\n</code></pre><p>之所称它为补丁函数呢，是因为这个函数功能，主要用来处理sqlmap的一些历史信息。例如支持Python2升级Python3、支持Windows平台的inet_pton()函数、限制httplib的最大行长度等等。这些操作对sqlmap的实际功能影响并不是特别大，属于保证用户体验和系统设置的正常选项，我们不需要过多关心。</p><p>接下来是resolveCrossReferences函数，它的作用是消除交叉引用。我们通过下面这个示例理解下什么是交叉引用。</p><pre><code class=\"language-python\">```python\na.py\nfrom b import b_var\na_var = 1\nb.py\nfrom a import a_var\nb_var = 2\n</code></pre><pre><code>这就是一个交叉引用的示例，文件`a.py`和`b.py`互相引用导致了运行的python解释器报错。为了避免交叉引用引起这样的问题，这里我们选择通过`resolveCrossReferences()`函数来消除交叉引用。\n```python\ndef resolveCrossReferences():\n    “””\n    Place for cross-reference resolution\n    “””\n    lib.core.threads.isDigit = isDigit\n    lib.core.threads.readInput = readInput\n    lib.core.common.getPageTemplate = getPageTemplate\n    lib.core.convert.filterNone = filterNone\n    lib.core.convert.isListLike = isListLike\n    lib.core.convert.shellExec = shellExec\n    lib.core.convert.singleTimeWarnMessage = singleTimeWarnMessage\n    lib.core.option._pympTempLeakPatch = pympTempLeakPatch\n    lib.request.connect.setHTTPHandlers = _setHTTPHandlers\n    lib.utils.search.setHTTPHandlers = _setHTTPHandlers\n    lib.controller.checks.setVerbosity = setVerbosity\n    lib.utils.sqlalchemy.getSafeExString = getSafeExString\n    thirdparty.ansistrm.ansistrm.stdoutEncode = stdoutEncode\n</code></pre><p>sqlmap在消除交叉引用之后，程序会开始运行检查环境的函数checkEnvironment()。</p><pre><code class=\"language-python\">def checkEnvironment():\n    try:\n         os.path.isdir(modulePath())\n    except UnicodeEncodeError:\n        errMsg = “your system does not properly handle non-ASCII paths. “\n        errMsg += “Please move the sqlmap’s directory to the other location”\n        logger.critical(errMsg)\n        raise SystemExit\n    if LooseVersion(VERSION) &lt; LooseVersion(“1.0”):\n        errMsg = “your runtime environment (e.g. PYTHONPATH) is “\n        errMsg += “broken. Please make sure that you are not running “\n        errMsg += “newer versions of sqlmap with runtime scripts for older “\n        errMsg += “versions”\n        logger.critical(errMsg)\n        raise SystemExit\n    # Patch for pip (import) environment\n    if “sqlmap.sqlmap” in sys.modules:\n        for _ in (“cmdLineOptions”, “conf”, “kb”):\n            globals()[_] = getattr(sys.modules[“lib.core.data”], _)\n        for _ in (“SqlmapBaseException”, “SqlmapShellQuitException”, “SqlmapSilentQuitException”, “SqlmapUserQuitException”):\n            globals()[_] = getattr(sys.modules[“lib.core.exception”], _)\n</code></pre><p>checkEnvironment函数会对当前的环境进行初步检查，检查的内容包括，存放sqlmap的路径是否包含非ASCII字符，以及sqlmap的版本是否小于1.0。</p><p>下一个函数<code>setPaths(modulePath())</code>是用来给项目中的文件夹和文件设置绝对路径的。</p><pre><code class=\"language-python\">def setPaths(rootPath):\n    \"\"\"\n    Sets absolute paths for project directories and files\n    \"\"\"\n    paths.SQLMAP_ROOT_PATH = rootPath\n    # sqlmap paths\n    paths.SQLMAP_DATA_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"data\")\n    paths.SQLMAP_EXTRAS_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"extra\")\n    paths.SQLMAP_SETTINGS_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"lib\", \"core\", \"settings.py\")\n    paths.SQLMAP_TAMPER_PATH = os.path.join(paths.SQLMAP_ROOT_PATH, \"tamper\")\n    paths.SQLMAP_PROCS_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"procs\")\n    paths.SQLMAP_SHELL_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"shell\")\n    paths.SQLMAP_TXT_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"txt\")\n    paths.SQLMAP_UDF_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"udf\")\n    paths.SQLMAP_XML_PATH = os.path.join(paths.SQLMAP_DATA_PATH, \"xml\")\n    paths.SQLMAP_XML_BANNER_PATH = os.path.join(paths.SQLMAP_XML_PATH, \"banner\")\n    paths.SQLMAP_XML_PAYLOADS_PATH = os.path.join(paths.SQLMAP_XML_PATH, \"payloads\")\n    # sqlmap files\n    paths.COMMON_COLUMNS = os.path.join(paths.SQLMAP_TXT_PATH, \"common-columns.txt\")\n    paths.COMMON_FILES = os.path.join(paths.SQLMAP_TXT_PATH, \"common-files.txt\")\n    paths.COMMON_TABLES = os.path.join(paths.SQLMAP_TXT_PATH, \"common-tables.txt\")\n    paths.COMMON_OUTPUTS = os.path.join(paths.SQLMAP_TXT_PATH, 'common-outputs.txt')\n    paths.SQL_KEYWORDS = os.path.join(paths.SQLMAP_TXT_PATH, \"keywords.txt\")\n    paths.SMALL_DICT = os.path.join(paths.SQLMAP_TXT_PATH, \"smalldict.txt\")\n    paths.USER_AGENTS = os.path.join(paths.SQLMAP_TXT_PATH, \"user-agents.txt\")\n    paths.WORDLIST = os.path.join(paths.SQLMAP_TXT_PATH, \"wordlist.tx_\")\n    paths.ERRORS_XML = os.path.join(paths.SQLMAP_XML_PATH, \"errors.xml\")\n    paths.BOUNDARIES_XML = os.path.join(paths.SQLMAP_XML_PATH, \"boundaries.xml\")\n    paths.QUERIES_XML = os.path.join(paths.SQLMAP_XML_PATH, \"queries.xml\")\n    paths.GENERIC_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"generic.xml\")\n    paths.MSSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"mssql.xml\")\n    paths.MYSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"mysql.xml\")\n    paths.ORACLE_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"oracle.xml\")\n    paths.PGSQL_XML = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"postgresql.xml\")\n    for path in paths.values():\n        if any(path.endswith(_) for _ in (\".txt\", \".xml\", \".tx_\")):\n            checkFile(path)\n    if IS_WIN:\n        # Reference: https://pureinfotech.com/list-environment-variables-windows-10/\n        if os.getenv(\"LOCALAPPDATA\"):\n            paths.SQLMAP_HOME_PATH = os.path.expandvars(\"%LOCALAPPDATA%\\\\sqlmap\")\n        elif os.getenv(\"USERPROFILE\"):\n            paths.SQLMAP_HOME_PATH = os.path.expandvars(\"%USERPROFILE%\\\\Local Settings\\\\sqlmap\")\n        else:\n            paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(\"~\")), \"sqlmap\")\n    else:\n        paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(\"~\")), \".sqlmap\")\n        if not os.path.isdir(paths.SQLMAP_HOME_PATH):\n            if \"XDG_DATA_HOME\" in os.environ:\n                paths.SQLMAP_HOME_PATH = os.path.join(os.environ[\"XDG_DATA_HOME\"], \"sqlmap\")\n            else:\n                paths.SQLMAP_HOME_PATH = os.path.join(os.path.expandvars(os.path.expanduser(\"~\")), \".local\", \"share\", \"sqlmap\")\n    paths.SQLMAP_OUTPUT_PATH = getUnicode(paths.get(\"SQLMAP_OUTPUT_PATH\", os.path.join(paths.SQLMAP_HOME_PATH, \"output\")), encoding=sys.getfilesystemencoding() or UNICODE_ENCODING)\n    paths.SQLMAP_DUMP_PATH = os.path.join(paths.SQLMAP_OUTPUT_PATH, \"%s\", \"dump\")\n    paths.SQLMAP_FILES_PATH = os.path.join(paths.SQLMAP_OUTPUT_PATH, \"%s\", \"files\")\n    # History files\n    paths.SQLMAP_HISTORY_PATH = getUnicode(os.path.join(paths.SQLMAP_HOME_PATH, \"history\"), encoding=sys.getfilesystemencoding() or UNICODE_ENCODING)\n    paths.API_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"api.hst\")\n    paths.OS_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"os.hst\")\n    paths.SQL_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"sql.hst\")\n    paths.SQLMAP_SHELL_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"sqlmap.hst\")\n    paths.GITHUB_HISTORY = os.path.join(paths.SQLMAP_HISTORY_PATH, \"github.hst\")\n</code></pre><p>设置完绝对路径后我们可以看到，sqlmap运行了一个banner函数，它对于sqlmap的运行没有实际的作用，但是作者可以通过banner函数绘制一幅字符画，是不是很酷！</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/c2/a5dc76a4f24686649413121e108d58c2.png?wh=1556x290\" alt=\"图片\"></p><p>下方是banner函数的代码，你在构建自己工具的时候也可以考虑引入这种有趣的小函数，为你的工具增添个性化色彩，让它看起来又酷又实用。</p><pre><code class=\"language-python\">def banner():\n    \"\"\"\n    This function prints sqlmap banner with its version\n    \"\"\"\n    if not any(_ in sys.argv for _ in (\"--version\", \"--api\")) and not conf.get(\"disableBanner\"):\n        result = BANNER\n        if not IS_TTY or any(_ in sys.argv for _ in (\"--disable-coloring\", \"--disable-colouring\")):\n            result = clearColors(result)\n        elif IS_WIN:\n            coloramainit()\n        dataToStdout(result, forceOutput=True)\n</code></pre><p><strong>命令行参数解析</strong></p><p>经过上面的函数执行之后，基本环境已经配置好了，程序将开始处理用户的输入，包括有命令行参数以及配置的文件参数。</p><pre><code class=\"language-python\">def main():\n    \"\"\"\n    Main function of sqlmap when running from command line.\n    \"\"\"\n    try:\n        dirtyPatches()\n        resolveCrossReferences()\n        checkEnvironment()\n        setPaths(modulePath())\n        banner()\n        # Store original command line options for possible later restoration\n        args = cmdLineParser()\n        cmdLineOptions.update(args.__dict__ if hasattr(args, \"__dict__\") else args)\n        initOptions(cmdLineOptions)\n</code></pre><p><strong>全局变量赋值与环境检查</strong></p><p>在接收用户的输入参数之后，程序开始进入init方法，这个方法是一个重要的前期配置方法，里面包含大量的配置操作，这些操作我们可以进入函数中观察。</p><pre><code class=\"language-python\">def init():\n    _useWizardInterface() # 启动引导模式\n    setVerbosity() # 设置默认的日志输出详细度\n    _saveConfig()  # 保存当前扫描的配置\n    _setRequestFromFile() # 解析 request file 的文件内容\n    _cleanupOptions() # 为 conf 中的参数赋初值\n    _cleanupEnvironment() \n    _purge() # 清空 sqlmap 相关信息\n    _checkDependencies() # 检查是否缺失依赖\n    _createHomeDirectories() # 创建 output、history 目录\n    _createTemporaryDirectory() # 创建临时目录\n    _basicOptionValidation() # 验证部分参数值是否符合预期\n    _setProxyList() # 解析 proxy file 的文件内容\n    _setTorProxySettings() # 设置 tor 代理\n    _setDNSServer() # 创建 DNS 服务器\n    _adjustLoggingFormatter() # 初始化日志格式化工具\n    _setMultipleTargets() # 解析 burp log 的文件内容\n    _listTamperingFunctions() # 输出 tamper 的详细信息\n    _setTamperingFunctions() # 设置后续要调用的 tamper\n    _setPreprocessFunctions() # 设置处理请求的函数\n    _setPostprocessFunctions() # 设置处理响应的函数\n    _setTrafficOutputFP() # 创建 trafficFile 并获取文件句柄\n    _setupHTTPCollector() # 创建 HAR 文件\n    _setHttpChunked() # 设置 chunked \n    _checkWebSocket() # 检查 websocket 环境是否正常\n\n    parseTargetDirect() # 解析数据库链接\n\n    if any((conf.url, conf.logFile, conf.bulkFile, conf.requestFile, conf.googleDork, conf.stdinPipe)):\n        _setHostname() # 设置 conf 中的 hostname\n        _setHTTPTimeout() # 设置请求最大超时时间\n        _setHTTPExtraHeaders() # 设置请求的 headers\n        _setHTTPCookies() # 设置请求的 cookies\n        _setHTTPReferer() # 设置请求的 referer\n        _setHTTPHost() # 设置请求的 host\n        _setHTTPUserAgent() # 设置请求的 UA\n        _setHTTPAuthentication() # 设置请求的认证信息\n        _setHTTPHandlers() # 设置对应的请求处理类\n        _setDNSCache() # 设置 dns 缓存\n        _setSocketPreConnect() \n        _setSafeVisit()\n        _doSearch() # 处理 Google Dork 解析\n        _setStdinPipeTargets() # 从 pipeline 中获取 targets\n        _setBulkMultipleTargets() # 从文本中获取 targets\n        _checkTor() # 检查 tor 代理\n        _setCrawler() # 设置爬虫信息\n        _findPageForms() # 寻找页面中的表单\n        _setDBMS() # 设置 DBMS\n        _setTechnique() # 设置检测类型\n\n    _setThreads() # 设置线程数\n    _setOS() # 设置操作系统类型\n    _setWriteFile() # 设置文件写入信息\n    _setMetasploit() # 设置 MSF 信息\n    _setDBMSAuthentication() # 设置 DBMS 的认证信息\n    loadBoundaries() # 加载 Boundaries\n    loadPayloads() # 加载 Payloads\n    _setPrefixSuffix() # 设置新的 prefix 和sufix\n    update() # 更新 sqlmap\n    _loadQueries() # 加载 queries\n</code></pre><p>其实我们只需要根据后面的注释，了解每个函数大概实现的功能就可以了，它们有些与初始化配置文件相关，有些与实际攻击过程相关。实际上，这里只是会初步解析命令行传入的参数，并不涉及到大部分函数的调用过程，在这里我们不需要理解的很细致，我们的核心关注点应该在注入逻辑上。</p><pre><code class=\"language-python\">        init()\n        if not conf.updateAll:\n            # Postponed imports (faster start)\n            if conf.smokeTest:\n                from lib.core.testing import smokeTest\n                os._exitcode = 1 - (smokeTest() or 0)\n            elif conf.vulnTest:\n                from lib.core.testing import vulnTest\n                os._exitcode = 1 - (vulnTest() or 0)\n            else:\n                from lib.controller.controller import start\n                if conf.profile:\n                    from lib.core.profiling import profile\n                    globals()[\"start\"] = start\n                    profile()\n                else:\n                    try:\n                        if conf.crawlDepth and conf.bulkFile:\n                            targets = getFileItems(conf.bulkFile)\n                            for i in xrange(len(targets)):\n                                target = None\n                                try:\n                                    kb.targets = OrderedSet()\n                                    target = targets[i]\n                                    if not re.search(r\"(?i)\\Ahttp[s]*://\", target)\n                                        target = \"http://%s\" % target\n                                    infoMsg = \"starting crawler for target URL '%s' (%d/%d)\" % (target, i + 1, len(targets))\n                                    logger.info(infoMsg)\n                                    crawl(target)\n                                except Exception as ex:\n                                    if target and not isinstance(ex, SqlmapUserQuitException):\n                                        errMsg = \"problem occurred while crawling '%s' ('%s')\" % (target, getSafeExString(ex))\n                                        logger.error(errMsg)\n                                    else:\n                                        raise\n                                else:\n                                    if kb.targets:\n                                        start()\n</code></pre><p>学习完毕init方法之后，我们就完成了整个初始化过程。</p><h2>总结</h2><p>这节课，我们学习了自动化SQL注入测试工具–sqlmap的设计思路。</p><p>作为业内知名且常用的SQL自动化注入工具，sqlmap已经持续维护了超过10年的时间。作为有梦想的工程师，我们不仅需要掌握如何使用sqlmap，更要学习它的设计思想和工作原理，站在巨人的肩膀上才能帮助我们看的更远。</p><p>sqlmap的代码量十分庞大，因为掌握其核心设计思想和工作原理就十分重要，这会成为我们深入代码逻辑探索的风向标。因此，在了解如何获取sqlmap代码以及如何搭建sqlmap的运行环境后，我们进一步学习了sqlmap设计原理的相关知识，比如sqlmap的配置文件介绍等。</p><p>接下来，与大部分开源软件的设计思路类似，sqlmap在真正开始工作前需要做大量的初始化工作，因此我们对sqlmap的初始化流程进行了梳理。经过分析，总结出它主要包含有全局变量初始化、命令行参数解析、全局变量赋值以及环境检查这四个通用的初始化步骤，然后我们又具体学习了这四个流程是如何实现的。</p><p>在学习完sqlmap的初始化后，很快我们就会进入sqlmap的工作流程学习，这时我们需要重新审视sqlmap的设计架构，了解我们所处的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/bc/0fbeefeec2d41ffd8949e164076180bc.png?wh=1436x768\" alt=\"图片\"></p><p>这是我整理的一幅sqlmap工作原理图，在本节课我们学习了sqlmap工作前的初始化流程，这些内容可以帮助你认识到sqlmap设计时的底层逻辑。下节课我们将正式开始学习sqlmap的自动化注入功能，它的起点是预注入，也是我们在前几节课程中所讲的起手式阶段。</p><h2>思考</h2><p>sqlmap的初始化流程有什么值得改进的地方吗？</p><p>欢迎在评论区留下你的思考，我们下节课再见。</p>","neighbors":{"left":{"article_title":"13｜注入（下）：SQL注入技战法及相关安全实践","id":479104},"right":{"article_title":"15｜自动化注入神器（二）：sqlmap的设计架构解析","id":480759}},"comments":[{"had_liked":false,"id":344139,"user_name":"ret2basic","can_delete":false,"product_type":"c1","uid":1543736,"ip_address":"","ucode":"9AA978903F1FB8","user_header":"https://static001.geekbang.org/account/avatar/00/17/8e/38/5da64ae6.jpg","comment_is_top":false,"comment_ctime":1651292910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651292910","product_id":100101501,"comment_content":"老师mian函数是什么 刀削面还是手擀面","like_count":0}]}