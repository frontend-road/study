{"id":773270,"title":"12｜枚举类型","content":"","comments":[{"had_liked":false,"id":395998,"user_name":"fatme","can_delete":false,"product_type":"c3","uid":1034451,"ip_address":"广东","ucode":"75A805D2BB2AD1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","comment_is_top":false,"comment_ctime":1732637138,"is_pvip":false,"replies":[{"id":143787,"content":"这里的两个C是同一个东西，是值域的。所以你会看到T是个函数类型。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1732695350,"ip_address":"江苏","comment_id":395998,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"class C {}\ntype T = typeof C;\n这里的 typeof 后面的 C，是指类型域里面的 C 呢，还是值域里面的 C 呢？我觉得是类型域里面的 C。如果是这样的话，这个 C 其实就是 class C 实现的 interface C。那么 typeof C 是表示什么意思呢，interface C 的类型，是指什么？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654438,"discussion_content":"这里的两个C是同一个东西，是值域的。所以你会看到T是个函数类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732695350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654426,"discussion_content":"看了第 14 课就明白了，typeof 是 ts 中唯一一个可以从 js 变量取得其类型信息的关键字。所以 typeof C 里面的 C 是指 js class C。那么，type T = typeof C 就应该是一个构造函数类型。\nclass C {}\ntype T = typeof C\n// 单独构造签名是等价的\ninterface C_Constructor {\n    new (): C;\n}\ntype Constructor_Same_As_T = C_Constructor extends T ? T extends C_Constructor  ?  true  :  false  :  false; // 得到 true\n\n// 构造签名加 prototype 属性是等价的\ninterface C_Constructor_2 {\n    new (): C;\n    prototype: C;\n}\ntype Constructor_2_Same_As_T = C_Constructor_2 extends T ? T extends C_Constructor_2  ?  true  :  false  :  false; // 得到 true\n\n// 用第 9 课提到的用 interface 实现构造函数类型的方法来定义 interface。但是这样定义的 interface 和 T 并不等价。这说明 es6 class 和 es5 constructor 并不等价，es6 class 不是单纯的语法糖。\ninterface C_Constructor_3 {\n    new (): C;\n    (this: C): void;\n    prototype: C;\n}\ntype Constructor_3_Same_As_T = C_Constructor_3 extends T ? T extends C_Constructor_3  ?  true  :  false  :  false; // 得到 false","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732680368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394846,"user_name":"何故","can_delete":false,"product_type":"c3","uid":3926279,"ip_address":"北京","ucode":"620A90204C9880","user_header":"https://static001.geekbang.org/account/avatar/00/3b/e9/07/511b3fa6.jpg","comment_is_top":false,"comment_ctime":1728542673,"is_pvip":false,"replies":[{"id":143376,"content":"是这样，我觉得你的VSCode配置存在一些异常的情况。\n\n你可能需要验证一下，应该是“不使用n!”的方式，会存在报错的情况，而只要使用了“n!”来声明，那么无论有没有tsconfig.json都不会报错。\n\n接下来我说说相关的问题。\n\n首先，如果是`let n!: number`，那么在代码中可以像视频里示例的那样正常使用，也就是说“不赋值时也可以访问”。因为 ! 是“确定赋值断言”运算符，它表明n是“确定赋值”过的，所以不需要预先赋值。\n\n但是，一些情况下，即使不使用“！”，视频中的示例也是正常而不报错的。这取决于你是否在tsconfig.json打开了strict &#47; strictNullChecks选项。如果你没有打开（缺省为false的话），那么即使不使用“!”，也不会报错。\n\n接下来问题来了。不同的vscode的配置是不一样的，而且vscode缺省为ts的项目初始化了一个tsconfig.json——即使当前目录中没有这个文件，也受“内部的、缺省的、不可见的”这个tsconfig.json的影响。简而言之的，总有一个tsconfig.json在影响vscode检查当前打开的.ts文件。这些配置项可以在vscode的“配置（settings）”中找到，查找一下strictNullChecks就可以看到。\n\n总结来说，以下两种方式之一：\n1、在tsconfig.json中将strict&#47;strictNullChecks置为false，或\n2、在vscode中将配置strictNullChecks的checkbox取消\n那么，不使用“n!”的时候，也能通过语法检查而不报错。\n\n上述两种方式中，第1种是优先的，也就是有tsconfig.json时，会忽略vscode中的配置。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1728569267,"ip_address":"江苏","comment_id":394846,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"let n!: number; 这种定义方式在文件中没有安装tsconfig.json的时候不报错，但是安装之后vscode就会报错，请问老师这是为什么呢。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652274,"discussion_content":"是这样，我觉得你的VSCode配置存在一些异常的情况。\n\n你可能需要验证一下，应该是“不使用n!”的方式，会存在报错的情况，而只要使用了“n!”来声明，那么无论有没有tsconfig.json都不会报错。\n\n接下来我说说相关的问题。\n\n首先，如果是`let n!: number`，那么在代码中可以像视频里示例的那样正常使用，也就是说“不赋值时也可以访问”。因为 ! 是“确定赋值断言”运算符，它表明n是“确定赋值”过的，所以不需要预先赋值。\n\n但是，一些情况下，即使不使用“！”，视频中的示例也是正常而不报错的。这取决于你是否在tsconfig.json打开了strict / strictNullChecks选项。如果你没有打开（缺省为false的话），那么即使不使用“!”，也不会报错。\n\n接下来问题来了。不同的vscode的配置是不一样的，而且vscode缺省为ts的项目初始化了一个tsconfig.json——即使当前目录中没有这个文件，也受“内部的、缺省的、不可见的”这个tsconfig.json的影响。简而言之的，总有一个tsconfig.json在影响vscode检查当前打开的.ts文件。这些配置项可以在vscode的“配置（settings）”中找到，查找一下strictNullChecks就可以看到。\n\n总结来说，以下两种方式之一：\n1、在tsconfig.json中将strict/strictNullChecks置为false，或\n2、在vscode中将配置strictNullChecks的checkbox取消\n那么，不使用“n!”的时候，也能通过语法检查而不报错。\n\n上述两种方式中，第1种是优先的，也就是有tsconfig.json时，会忽略vscode中的配置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728569267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":3926279,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/e9/07/511b3fa6.jpg","nickname":"何故","note":"","ucode":"620A90204C9880","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":652286,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728612939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":652274,"ip_address":"北京","group_id":0},"score":652286,"extra":""}]}]},{"had_liked":false,"id":391152,"user_name":"暗黑之刃","can_delete":false,"product_type":"c3","uid":1123058,"ip_address":"上海","ucode":"A94D64F37F6B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/f2/b4cd43ea.jpg","comment_is_top":false,"comment_ctime":1717466446,"is_pvip":false,"replies":[{"id":142246,"content":"对呀。B是一个类型呀。\n\ntype B = A，是引用了A的一个类型，而不是A的全部。这一点在第11讲（上一讲）中正好讲过了呵。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1717490548,"ip_address":"江苏","comment_id":391152,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"enum A {\n  a = 1,\n  b = 2,\n}\n\ntype B = A;\nconsole.log(B);\n\n我这直接编译不过去 提示错误。\nerror TS2693: &#39;B&#39; only refers to a type, but is being used as a value here.\nconsole.log(B)","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646171,"discussion_content":"对呀。B是一个类型呀。\n\ntype B = A，是引用了A的一个类型，而不是A的全部。这一点在第11讲（上一讲）中正好讲过了呵。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717490549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391043,"user_name":"Geek_aeb936","can_delete":false,"product_type":"c3","uid":3887128,"ip_address":"日本","ucode":"863338D4895F25","user_header":"","comment_is_top":false,"comment_ctime":1717133190,"is_pvip":false,"replies":[{"id":142229,"content":"赞👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1717171675,"ip_address":"江苏","comment_id":391043,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"做了下测试\n```typescript\nenum EnumX {\n  A,\n  B,\n  C\n}\n\ntype EnumType = typeof EnumX;\n\nclass ClassX { }\ntype ClassType = typeof ClassX;\n\nconst enumTest: EnumType = EnumX;\nconst classTest: ClassType = ClassX;\n\nconsole.log(enumTest); &#47;&#47; 打印枚举的构造函数\nconsole.log(typeof EnumX); &#47;&#47; 输出: &quot;object&quot;\nconsole.log(classTest); &#47;&#47; 打印类的构造函数\nconsole.log(typeof ClassX); &#47;&#47; 输出: &quot;function&quot;\n```\n\nlog:\n\n[LOG]: {\n  &quot;0&quot;: &quot;A&quot;,\n  &quot;1&quot;: &quot;B&quot;,\n  &quot;2&quot;: &quot;C&quot;,\n  &quot;A&quot;: 0,\n  &quot;B&quot;: 1,\n  &quot;C&quot;: 2\n} \n[LOG]: &quot;object&quot; \n[LOG]: class ClassX {\n} \n[LOG]: &quot;function&quot; \n\n对应js转换\n\n```javascript\n&quot;use strict&quot;;\nvar EnumX;\n(function (EnumX) {\n    EnumX[EnumX[&quot;A&quot;] = 0] = &quot;A&quot;;\n    EnumX[EnumX[&quot;B&quot;] = 1] = &quot;B&quot;;\n    EnumX[EnumX[&quot;C&quot;] = 2] = &quot;C&quot;;\n})(EnumX || (EnumX = {}));\nclass ClassX {\n}\nconst enumTest = EnumX;\nconst classTest = ClassX;\nconsole.log(enumTest); &#47;&#47; 打印枚举的构造函数\nconsole.log(typeof EnumX); &#47;&#47; 输出: &quot;object&quot;\nconsole.log(classTest); &#47;&#47; 打印类的构造函数\nconsole.log(typeof ClassX); &#47;&#47; 输出: &quot;function&quot;\n```\n这样看是能理解了","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646040,"discussion_content":"赞👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717171675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390835,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1716434568,"is_pvip":false,"replies":[{"id":142141,"content":"“完全求值的意义”？\n\n我也不太好说这样的意义算是什么，但枚举通常是用作常量的，也就是说完全求值的结果如果是常量，那显然就可以在编译阶段使用和优化，换言之，不依赖执行就可以做类型检查或数据有效性检查。\n\n但问题是在TypeScript中还存在非const enum，例如一个成员的值是a = Number(10)，这样情况下，.d.ts中该成员就被置空。——关键在于我想不通置空的作用是什么，反正类型检查时什么用也没有，（或许？）可能用作占位？","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1716462655,"ip_address":"江苏","comment_id":390835,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"enum ExampleEnum {\n    Value,\n  &#47;&#47; 在枚举的初始值中如何引用既有的枚举值？\n  &#47;&#47; 有以下三种:\n    Value1 = 1,\n    &#47;&#47; 方式1 直接引用\n    Value2 = Value1 + 1,\n    &#47;&#47; 方式2 通过枚举名引用\n    Value3 = ExampleEnum.Value2 + 2,\n    &#47;&#47; 方式3 通过字符串索引引用\n    Value4 = ExampleEnum[&#39;Value1&#39;] * 3,\n}\n\n&#47;&#47; js\n&#47;&#47; var ExampleEnum;\n&#47;&#47; (function (ExampleEnum) {\n&#47;&#47;     ExampleEnum[ExampleEnum[&quot;Value&quot;] = 0] = &quot;Value&quot;;\n&#47;&#47;     ExampleEnum[ExampleEnum[&quot;Value1&quot;] = 1] = &quot;Value1&quot;;\n&#47;&#47;     ExampleEnum[ExampleEnum[&quot;Value2&quot;] = 2] = &quot;Value2&quot;;\n&#47;&#47;     ExampleEnum[ExampleEnum[&quot;Value3&quot;] = 4] = &quot;Value3&quot;;\n&#47;&#47;     ExampleEnum[ExampleEnum[&quot;Value4&quot;] = 3] = &quot;Value4&quot;;\n&#47;&#47; })(ExampleEnum || (ExampleEnum = {}));\n\nconsole.log(typeof ExampleEnum)\n&#47;&#47; typeof ExampleEnum === &#39;object&#39;\n\n&#47;&#47; 根据 tsc 后得到的js代码可以看出\n&#47;&#47; 因为 Enum[Enum[&quot;key&quot;] = &quot;value&quot;] = &quot;key&quot;\n&#47;&#47; 所以 ExampleEnum 其实是一个 vaule 和 key 存在互相映射关系的 object \n\n&#47;&#47; 从 EET 包含各种 对象类型 拥有的属性也可以 看出 它是一个对象\ntype EET = Omit&lt;ExampleEnum, &#39;never&#39;&gt;;\n&#47;&#47;   ^?\n\n&#47;&#47; .d.ts\n&#47;&#47; declare enum ExampleEnum {\n&#47;&#47;     Value = 0,\n&#47;&#47;     Value1 = 1,\n&#47;&#47;     Value2 = 2,\n&#47;&#47;     Value3 = 4,\n&#47;&#47;     Value4 = 3\n&#47;&#47; }\n&#47;&#47; 疑问: 在ts中声明 ExampleEnum 部分枚举成员 初始值 是引用的进行的赋值，最后类型直接得到了结果（编译时完全求值）\n&#47;&#47; 这里完全求值的意义是什么呢？为什么要这么做？是因为类型系统的原因吗？\n\ntype EETT = Omit&lt;typeof ExampleEnum, &#39;never&#39;&gt;;\n&#47;&#47;   ^?\n&#47;&#47; type EETT = {\n&#47;&#47;     readonly Value1: ExampleEnum.Value1;\n&#47;&#47;     readonly Value: ExampleEnum.Value;\n&#47;&#47;     readonly Value2: ExampleEnum.Value2;\n&#47;&#47;     readonly Value3: ExampleEnum.Value3;\n&#47;&#47;     readonly Value4: ExampleEnum.Value4;\n&#47;&#47; }\n\n&#47;&#47; typeof Enum 的计算结果是一个由枚举成员构成的, key 为 Enum 中成员的 value, value 为 Enum 中成员的 key 的 对象类型","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645636,"discussion_content":"“完全求值的意义”？\n\n我也不太好说这样的意义算是什么，但枚举通常是用作常量的，也就是说完全求值的结果如果是常量，那显然就可以在编译阶段使用和优化，换言之，不依赖执行就可以做类型检查或数据有效性检查。\n\n但问题是在TypeScript中还存在非const enum，例如一个成员的值是a = Number(10)，这样情况下，.d.ts中该成员就被置空。——关键在于我想不通置空的作用是什么，反正类型检查时什么用也没有，（或许？）可能用作占位？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716462655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390834,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1716433758,"is_pvip":false,"replies":[{"id":142142,"content":"哦！！！首先，你太习惯把单行注释写到代码的下面（而不是上面），这差点搞疯了我~ 好几次。\n\n其次，关于EYConstruct这个类型，它其实是一个函数类型（构造器），所以关于它的考察，最好使用ConstructorParameters&lt;&gt;和InstanceType&lt;&gt;这两个泛型工具，而不是Omit&lt;&gt;。因为我在现阶段的课程中一直是想避免讲泛型的，所以很多其它工具都没有加入进来讲，并且也不太深入讨论“函数&#47;构造器类型”，所以你在做深入分析时，就有点捉襟见肘。\n\n接下来，当你使用Omit&lt;TPOEY, ...&gt;时，你得到的将会是一个对象接口，而不是带函数签名的接口。——注意，没有任何方法可以取函数签名！所以，EYTT是一个对象类型&#47;接口类型，EYConstruct2同样如此，二者在做赋值兼容性检查时，只比较对象成员（也就是结构兼容），所以V2为true。至于后续的，你应该就可以自行分析了。\n\n至于你的疑问，“typeof ExampleY 是 EYConstruct2 的 派生”这个判断是错的，V3只能说明TPOEY与后者结构一致，TPOEY“多出了”构造签名，因此是“更具体的类型”，所以可以赋给相对更抽象的接口（EYConstruct2），反之则不可以，仅此而已。\n\nEYConstruct2是函数&#47;构造器ExampleY()作为对象的界面（将包括构造器中声明的静态成员列表）。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1716463803,"ip_address":"江苏","comment_id":390834,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"class ExampleY {\n  a: string = &quot;&quot;\n}\n\ntype TPOEY = typeof ExampleY\n&#47;&#47;   ^?\n\ntype EYConstruct = {\n  new (): ExampleY\n};\n\ntype V1 = EYConstruct extends TPOEY ? TPOEY extends EYConstruct ? true : false : false; &#47;&#47; true\n&#47;&#47;  ^?\n&#47;&#47; 根据 V1 可以得出 typeof ExampleY 是一个 构造函数类型\nconsole.log(typeof ExampleY);\n&#47;&#47; 在js 运行环境下 类被编译为一个构造函数, 所以 typeof ExampleY 返回 &#39;function&#39;\ntype EYTT = Omit&lt;TPOEY, never&gt;;\n&#47;&#47;   ^?\ntype EYConstruct2 = {\n  prototype: ExampleY\n};\ntype V2 = EYConstruct2 extends EYTT ? EYTT extends EYConstruct2 ? true : false : false; &#47;&#47; true\n&#47;&#47;  ^?\n&#47;&#47; 所以 &#47;&#47; type EYTT = { prototype: ExampleY; }\ntype V3 = TPOEY extends EYConstruct2 ? true : false; &#47;&#47; true\n&#47;&#47;  ^?\ntype V4 = EYConstruct2 extends TPOEY ? true : false; &#47;&#47; false\n&#47;&#47;  ^?\n&#47;&#47; 疑问：根据 V2 \\ V3 \\ V4  可以得出 typeof ExampleY 是 EYConstruct2 的 派生，在 js 和 ts 中 EYConstruct2 它对应的含义分别是什么？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645638,"discussion_content":"哦！！！首先，你太习惯把单行注释写到代码的下面（而不是上面），这差点搞疯了我~ 好几次。\n\n其次，关于EYConstruct这个类型，它其实是一个函数类型（构造器），所以关于它的考察，最好使用ConstructorParameters&lt;&gt;和InstanceType&lt;&gt;这两个泛型工具，而不是Omit&lt;&gt;。因为我在现阶段的课程中一直是想避免讲泛型的，所以很多其它工具都没有加入进来讲，并且也不太深入讨论“函数/构造器类型”，所以你在做深入分析时，就有点捉襟见肘。\n\n接下来，当你使用Omit&lt;TPOEY, ...&gt;时，你得到的将会是一个对象接口，而不是带函数签名的接口。——注意，没有任何方法可以取函数签名！所以，EYTT是一个对象类型/接口类型，EYConstruct2同样如此，二者在做赋值兼容性检查时，只比较对象成员（也就是结构兼容），所以V2为true。至于后续的，你应该就可以自行分析了。\n\n至于你的疑问，“typeof ExampleY 是 EYConstruct2 的 派生”这个判断是错的，V3只能说明TPOEY与后者结构一致，TPOEY“多出了”构造签名，因此是“更具体的类型”，所以可以赋给相对更抽象的接口（EYConstruct2），反之则不可以，仅此而已。\n\nEYConstruct2是函数/构造器ExampleY()作为对象的界面（将包括构造器中声明的静态成员列表）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716463803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1160078,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","nickname":"Jack Q","note":"","ucode":"A7DBC311884FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":645697,"discussion_content":"好的老师😂 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716548005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645638,"ip_address":"广东","group_id":0},"score":645697,"extra":""}]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645645,"discussion_content":"多写一点，其实有非常崎岖的路线和诡异的方法能取调用签名，但一则并非正途，再则要到非常晚的时候（大概第40+讲）才会提及，所以……就先当没有吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716474860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390582,"user_name":"westfall","can_delete":false,"product_type":"c3","uid":1632773,"ip_address":"上海","ucode":"F3F5CB7DF695FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/ea/05/9976b871.jpg","comment_is_top":false,"comment_ctime":1715695131,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"console.log(typeof X); &#47;&#47; &#39;object&#39;\n是因为这里的 X 是作为值而不是类型来处理的\n如果 X 是常量枚举，console.log(typeof X); 会报错，因为常量枚举不会同时声明一个值","like_count":1,"discussions":[{"author":{"id":2866983,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/bf/27/7f7acf6c.jpg","nickname":"halo","note":"","ucode":"574BDA398A81C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645166,"discussion_content":"老师的思考题 好像不是常量枚举吧 是因为没有枚举成员 相当于没有写这个类型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715839355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}