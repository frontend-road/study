{"id":620500,"title":"13｜容器化：如何为不同语言快速构建多平台镜像？","content":"<p>你好，我是王炜。从这节课开始，我们来容器化的实践。</p><p>在<a href=\"https://time.geekbang.org/column/article/612566\">第1讲</a>中，我们以 Python Flask 应用为例，展示了如何编写 Dockerfile ，如何构建和推送镜像。在编写 Dockerfile 方面，我为你介绍了构建镜像通用的套路。</p><p>但对于其他非 Python 语言编写的业务应用来说，如何快速构建镜像呢？</p><p>在这节课，我会介绍不同语言构建镜像的例子和模板，包括常用的后端语言 Java、Golang、Node.js 以及前端 Vue 框架编写的业务应用，每一种语言我都会设计一个接近真实的构建容器镜像的例子。此外，考虑构建镜像对多平台的兼容性，我还会介绍一种构建多平台镜像的方法，这样，我们构建出来的镜像就能够兼容多个不同的 CPU 平台了。未来，如果你需要对实际的业务应用进行容器化改造，完全可以参考我们这节课的内容。</p><p>在开始之前，你需要确保已经在本地安装了 Docker，并将我提前准备好的示例应用仓库克隆到本地：<a href=\"https://github.com/lyzhang1999/gitops.git\">https://github.com/lyzhang1999/gitops.git</a>。</p><h2>Java 应用容器化</h2><p>我们先来看 Java 应用的容器化。</p><p>常见的 Java 应用启动方式有两种，这也就意味着镜像构建方式也有两种。一种是将应用打包成 Jar 包，在镜像内直接启动应用 Jar 包来构建镜像。另一种是在容器里通过 Spring Boot 插件直接启动应用。接下来，我分别介绍这两种镜像构建方式。</p><!-- [[[read_end]]] --><h3>启动 Jar 包的构建方式</h3><p>以 Spring Boot 和 Maven 为例，我已经提前创建好了一个 Demo 应用，我们以它为例子介绍如何使用 Jar 包构建镜像。</p><p>在将示例应用克隆到本地后，进入 Spring Boot Demo 目录并列出所有文件。</p><pre><code class=\"language-yaml\">$ cd gitops/docker/13/spring-boot\n$ ls -al\ntotal 80\ndrwxr-xr-x&nbsp; 12 weiwang&nbsp; staff&nbsp; &nbsp; 384 10&nbsp; 5 11:17 .\ndrwxr-xr-x&nbsp; &nbsp;4 weiwang&nbsp; staff&nbsp; &nbsp; 128 10&nbsp; 5 11:17 ..\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; &nbsp; 6 10&nbsp; 5 10:30 .dockerignore\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; 374 10&nbsp; 5 11:05 Dockerfile\ndrwxr-xr-x&nbsp; &nbsp;4 weiwang&nbsp; staff&nbsp; &nbsp; 128 10&nbsp; 5 11:17 src\n......\n</code></pre><p>在这里，我们重点关注 <strong>src 目录、Dockerfile 文件和 .dockerignore 文件</strong>。</p><p>首先，src 目录下的 src/main/java/com/example/demo/DemoApplication.java 文件的内容是 Demo 应用的主体文件，它包含一个 /hello 接口，使用 Get 请求访问后会返回 “Hello World”。</p><pre><code class=\"language-yaml\">\n\npackage com.example.demo;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@SpringBootApplication\n@RestController\npublic class DemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n    \n    @GetMapping(\"/hello\")\n    public String hello(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n        return String.format(\"Hello %s!\", name);\n    }\n}\n</code></pre><p>Demo 应用的主体内容虽然很简单，但它代表了 <strong>Spring Boot + Maven</strong> 的典型组合，只要符合这两种技术选型，你都可以直接参考这里的例子来容器化你的业务应用。</p><p>接下来，是构建镜像的核心内容 Dockerfile 文件。</p><pre><code class=\"language-yaml\"># syntax=docker/dockerfile:1\n\nFROM eclipse-temurin:17-jdk-jammy as builder\nWORKDIR /opt/app\nCOPY .mvn/ .mvn\nCOPY mvnw pom.xml ./\nRUN ./mvnw dependency:go-offline\nCOPY ./src ./src\nRUN ./mvnw clean install\n \n \nFROM eclipse-temurin:17-jre-jammy\nWORKDIR /opt/app\nEXPOSE 8080\nCOPY --from=builder /opt/app/target/*.jar /opt/app/*.jar\nCMD [\"java\", \"-jar\", \"/opt/app/*.jar\" ]\n</code></pre><p>刚开始学习 Dockerfile 的同学可能会感到疑惑，为什么这里有两个 FROM 语句呢？</p><p>实际上，这里使用了多阶段构建的方式，你可以理解为，第一个阶段的构建产物可以作为下一个阶段的输入，这里你只需要先知道这种用法就好，后面的课程我们还会有更详细的介绍。</p><p><strong>我们来看第一阶段的构建，也就是从第 3 行到第 9 行。</strong>第 3 行 FROM 表示把 eclipse-temurin:17-jdk-jammy 作为 build 阶段的基础镜像，然后使用 WORKDIR 关键字指定了工作目录为 /opt/app，后续的文件操作都会在这个工作目录下展开。</p><p>接下来，第 5 和第 6 行通过 COPY 关键字将 .mvn 目录和 mvnw、pom.xml 文件复制到了工作目录下，第 7 行通过 RUN 关键字运行 ./mvnw dependency:go-offline 来安装依赖。然后，第 8 行将 src 目录复制到了镜像中，第 9 行使用 RUN 关键字执行 ./mvnw clean install 进行编译。</p><p><strong>第 12 行到 16 行是第二个构建阶段。</strong>第 12 行表示使用 eclipse-temurin:17-jre-jammy 作为基础镜像，第 13 行同样指定了工作目录为 /opt/app，第 14 行的 EXPOSE 关键字之前我们有提到过，它是一个备注功能，并不是要暴露真实容器端口的意思。</p><p>第 15 行的 COPY 语句比较复杂，它指的是从 builder 阶段也就是将第一个阶段位于 /opt/app/target/ 目录下所有的 .jar 文件都拷贝到当前构建阶段镜像的 /opt/app/ 目录下。第 16 行使用 CMD 关键字定义了启动命令，也就是通过 java -jar 的方式启动应用。</p><p>最后，.dockerignore 的功能和我们熟悉的 .gitignore 文件功能类似，它指的是在构建过程中需要忽略的文件或目录，合理的文件忽略策略将有助于提高构建镜像的速度。在这个例子中，因为我们要在容器里重新编译应用，所以我们忽略了本地的 target 目录。</p><p>接下来，我们就可以使用 docker build 命令来构建镜像了。</p><pre><code class=\"language-yaml\">$ docker build -t spring-boot .\n</code></pre><p>当镜像构建完成后，我们要使用 docker run 命令启动镜像，并通过 --publish 暴露端口。</p><pre><code class=\"language-yaml\">$ docker run --publish 8080:8080 spring-boot\n......\n2022-10-05 03:59:48.746&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] com.example.demo.DemoApplication&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: Starting DemoApplication v0.0.1-SNAPSHOT using Java 17.0.4.1 on da50d0bb2460 with PID 1 (/opt/app/*.jar started by root in /opt/app)\n2022-10-05 03:59:48.748&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] com.example.demo.DemoApplication&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: No active profile set, falling back to 1 default profile: \"default\"\n2022-10-05 03:59:49.643&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.s.b.w.embedded.tomcat.TomcatWebServer&nbsp; : Tomcat initialized with port(s): 8080 (http)\n2022-10-05 03:59:49.655&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.apache.catalina.core.StandardService&nbsp; &nbsp;: Starting service [Tomcat]\n2022-10-05 03:59:49.656&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] org.apache.catalina.core.StandardEngine&nbsp; : Starting Servlet engine: [Apache Tomcat/9.0.65]\n2022-10-05 03:59:49.754&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.a.c.c.C.[Tomcat].[localhost].[/]&nbsp; &nbsp; &nbsp; &nbsp;: Initializing Spring embedded WebApplicationContext\n2022-10-05 03:59:49.755&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 933 ms\n2022-10-05 03:59:50.105&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] o.s.b.w.embedded.tomcat.TomcatWebServer&nbsp; : Tomcat started on port(s): 8080 (http) with context path ''\n2022-10-05 03:59:50.117&nbsp; INFO 1 --- [&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;main] com.example.demo.DemoApplication&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: Started DemoApplication in 1.796 seconds (JVM running for 2.221)\n</code></pre><p>打开一个新的命令行终端，并使用 curl 访问 hello 接口验证返回内容。</p><pre><code class=\"language-yaml\">$ curl localhost:8080/hello&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\nHello World!\n</code></pre><p>如果要终止 spring-boot 应用，你可以回到执行 docker run 的命令行终端，并使用 ctrll+c 来停止容器。</p><p>如果你跟着我操作到了这里，说明你也已经成功以 Jar 包的方式将 Spring Boot 应用构建为 Docker 镜像了。</p><h3>Spring Boot 插件的构建方式</h3><p>除了使用 Jar 包，Spring Boot 应用还可以通过 ./mvnw spring-boot:run 的方式启动，这意味着我们也可以把它作为镜像的启动命令。</p><p>我还是以 Spring Boot 示例应用为例，我在示例应用 Dockerfile 文件同级目录下已经提前准备好了 Dockerfile-Boot 文件，下面是该文件的内容。</p><pre><code class=\"language-yaml\"># syntax=docker/dockerfile:1\n\nFROM eclipse-temurin:17-jdk-jammy\n\nWORKDIR /app\n\nCOPY .mvn/ .mvn\nCOPY mvnw pom.xml ./\nRUN ./mvnw dependency:resolve\n\nCOPY src ./src\nCMD [\"./mvnw\", \"spring-boot:run\"]\n</code></pre><p>相比较 Jar 的启动方式，Spring Boot 插件的启动方式显得更加简单。在构建过程中，我们实际上还用了一个小技巧：第 7 和第 8 行代表单独复制了依赖清单文件 pom.xml 而不是复制整个根目录，目的是在依赖不变的情况下充分利用 Docker 构建缓存。</p><p>在这个 Dockerfile 文件中有两条关键的命令，一个 mvnw dependency:resolve 用于安装依赖，另一个 mvnw spring-boot:run 命令用来启动应用。</p><p>接下来，我们使用 docker build 命令构建镜像，这里要注意增加 -f 参数指定新的 Dockerfile 文件。</p><pre><code class=\"language-yaml\">$ docker build -t spring-boot . -f Dockerfile-Boot\n</code></pre><p>镜像构建成功后，使用 docker run 命令启动镜像。</p><pre><code class=\"language-yaml\">$ docker run --publish 8080:8080 spring-boot\n</code></pre><p>最后，你可以尝试用 curl 访问 localhost:8080/hello 接口，将会得到 Hello World 返回结果。</p><p>Spring Boot 插件的启动方式虽然比较简单，但它将构建过程延迟到了启动阶段，并且依赖镜像的 JDK 工具，对于生产环境来说这些都不是必要的。如果你通过 docker images 命令仔细对比两次构建镜像占用的空间大小，你会发现，第一种方式构建生成的镜像大概在 280M 左右，而第二种构建方式生成的镜像在 500M 左右。在实际的生产环境中，我更推荐你使用第一种方式来构建 Java 镜像。</p><h2>Golang 应用容器化</h2><p>下面我们继续来看 Go 应用的容器化。</p><p>以 Echo 框架为例，我提前编写好了一个简单的示例应用。在将示例应用克隆到本地后，你可以进入 docker/13/golang 目录并查看。</p><pre><code class=\"language-yaml\">$ cd gitops/docker/13/golang\n$ ls -al\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; &nbsp;292 10&nbsp; 5 14:16 Dockerfile\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; &nbsp;599 10&nbsp; 5 14:12 go.mod\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; 2825 10&nbsp; 5 14:12 go.sum\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; &nbsp;235 10&nbsp; 5 14:13 main.go\n</code></pre><p>main.go 文件是应用的主体文件，包含一个 /hello 接口，通过 Get 方法请求后，将返回 Hello World 字符串。</p><pre><code class=\"language-yaml\">package main\n\nimport (\n    \"net/http\"\n    \"github.com/labstack/echo/v4\"\n)\n\nfunc main() {\n    e := echo.New()\n    e.GET(\"/hello\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"Hello World Golang\")\n    })\n    e.Logger.Fatal(e.Start(\":8080\"))\n}\n</code></pre><p>接下来，我们来看 Dockerfile 的内容。</p><pre><code class=\"language-yaml\"># syntax=docker/dockerfile:1\nFROM golang:1.17 as builder\nWORKDIR /opt/app\nCOPY . .\nRUN go build -o example\n\nFROM ubuntu:latest\nWORKDIR /opt/app\nCOPY --from=builder /opt/app/example /opt/app/example\nEXPOSE 8080\nCMD [\"/opt/app/example\"]\n</code></pre><p>同样地，这个 Dockerfile 包含了两个构建阶段，第一个构建阶段是以 golang:1.17 为基础镜像，然后我们执行 go build 命令编译并输出可执行文件，将其命名为 example。</p><p>第二个构建阶段是以 ubuntu:latest 为基础镜像，第 9 行通过 COPY 关键字将第一个阶段构建的 example 可执行文件复制到镜像的 /opt/app/ 目录下，最后，使用 CMD 来运行 example 启动应用。</p><p>现在，我们可以通过 docker build 来构建镜像。</p><pre><code class=\"language-yaml\">$ docker build -t golang .\n</code></pre><p>接下来，使用 docker run 来启动镜像。</p><pre><code class=\"language-yaml\">$ docker run --publish 8080:8080 golang\n&nbsp; &nbsp;____&nbsp; &nbsp; __\n&nbsp; / __/___/ /&nbsp; ___\n&nbsp;/ _// __/ _ \\/ _ \\\n/___/\\__/_//_/\\___/ v4.9.0\nHigh performance, minimalist Go web framework\nhttps://echo.labstack.com\n____________________________________O/_______\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; O\\\n⇨ http server started on [::]:8080\n</code></pre><p>如果你还没有终止之前运行的 Spring Boot 示例，在运行 Golang 示例时，你可能会得到 “Bind for 0.0.0.0:8080 failed: port is already allocated” 的错误。你可以通过 docker ps 命令来查看 Spring Demo 的容器 ID，并通过 docker stop [Container ID] 来终止它。这时候再运行 Golang 示例就能够正常启动了。</p><p>现在，你可以使用 curl 命令来访问 localhost:8080/hello 接口，查看是否返回了预期的 Hello World Golang 字符串。</p><h2>Node.js 应用容器化</h2><p>以 Express.js 框架为例，我已经提前编写好了一个简单示例，在将示例应用克隆到本地后，你可以进入 docker/13/node 目录并查看。</p><pre><code class=\"language-yaml\">$ cd gitops/docker/13/node\n$ ls -al\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; &nbsp;12 10&nbsp; 5 16:45 .dockerignore\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; 589 10&nbsp; 5 16:39 Dockerfile\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; 230 10&nbsp; 5 16:44 app.js\ndrwxr-xr-x&nbsp; 60 weiwang&nbsp; staff&nbsp; &nbsp;1920 10&nbsp; 5 16:26 node_modules\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; 39326 10&nbsp; 5 16:26 package-lock.json\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; 251 10&nbsp; 5 16:26 package.json\n</code></pre><p>app.js 是示例应用的主体文件，包含一个 /hello 接口。当我们通过 Get 请求访问时，会返回“Hello World Node.js”字符串。</p><pre><code class=\"language-yaml\">const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/hello', (req, res) =&gt; {\n  res.send('Hello World Node.js')\n})\n\napp.listen(port, () =&gt; {\n  console.log(`Example app listening on port ${port}`)\n})\n</code></pre><p>.dockerignore 是构建镜像时的忽略文件，在这个例子中，忽略了 node_modules 目录。</p><pre><code class=\"language-yaml\">$ cat .dockerignore\nnode_modules\n</code></pre><p>接着我们来看一下 Dockerfile 文件的内容。</p><pre><code class=\"language-yaml\"># syntax=docker/dockerfile:1\nFROM node:latest AS build\nRUN sed -i \"s@http://\\(deb\\|security\\).debian.org@https://mirrors.aliyun.com@g\" /etc/apt/sources.list\nRUN apt-get update &amp;&amp; apt-get install -y dumb-init\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN npm ci --only=production\n \n\nFROM node:16.17.0-bullseye-slim\nENV NODE_ENV production\nCOPY --from=build /usr/bin/dumb-init /usr/bin/dumb-init\nUSER node\nWORKDIR /usr/src/app\nCOPY --chown=node:node --from=build /usr/src/app/node_modules /usr/src/app/node_modules\nCOPY --chown=node:node . /usr/src/app\nCMD [\"dumb-init\", \"node\", \"app.js\"]\n</code></pre><p>这是一个由两个阶段组成的镜像构建方法。第一个阶段使用 node:latest 作为 build 阶段的基础镜像，同时安装了 dumb-init 组件。此外，这种构建方法还将 package.json 和 package-lock.json 复制到镜像内，并通过 npm ci --only=production 命令安装依赖。</p><p>从第 10 行开始是第二个构建阶段，这里使用了 node:16.17.0-bullseye-slim 作为基础镜像，此外，我们还为 Express 配置了 NODE_ENV=production 的环境变量，代表在生产环境中使用。这会改变 Express.js 框架的默认配置，如日志等级、缓存处理策略等。然后，我们还要将 build 阶段安装的 dumb-init 组件、依赖以及源码复制到第二个阶段的镜像中，修改源码和依赖目录的用户组。最后，通过 CMD 命令使用 node 启动 app.js。</p><p>在将 NodeJS 容器化的过程中，有一个需要特别注意的细节，由于 NodeJS 并不是设计以 PID=1 的进程运行的，所以常规的启动方式并不能让 NodeJS 程序在容器内接收到 Kill 信号，这会导致 Node 进程不能被优雅终止（例如更新时突然中断），所以我们可以通过 dumb-init 组件来启动 Node 进程。</p><p>现在，我们可以通过 docker build 来构建镜像。</p><pre><code class=\"language-yaml\">$ docker build -t nodejs .\n</code></pre><p>接下来，使用 docker run 来启动镜像。</p><pre><code class=\"language-yaml\">$ docker run --publish 3000:3000 nodejs\nExample app listening on port 3000\n</code></pre><p>进行到这里，你可以使用 curl 命令来访问 localhost:3000/hello 接口，查看是否返回了预期的 Hello World Node.js 字符串。</p><h2>Vue 应用容器化</h2><p>常见的 Vue 应用容器化方案有两种，第一种是将 http-server 组件作为代理服务器来构建镜像，第二种是让 Nginx 作为代理服务器来构建镜像。接下来，我会分别介绍这两种镜像构建方式。</p><h3>Http-server 构建方式</h3><p>先看 http-server 的构建方式。以 Vue 框架为例，我已经提前将项目进行了初始化，接下来你需要将示例应用克隆到本地，然后进入 docker/13/vue/example 目录并查看。</p><pre><code class=\"language-yaml\">$ cd gitops/docker/13/vue/example\n$ ls -al\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; &nbsp;12 10&nbsp; 5 17:26 .dockerignore\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; 172 10&nbsp; 5 17:27 Dockerfile\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; &nbsp; 0 10&nbsp; 5 17:34 Dockerfile-Nginx\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; 631 10&nbsp; 5 17:23 README.md\n-rw-r--r--&nbsp; &nbsp;1 weiwang&nbsp; staff&nbsp; &nbsp; 337 10&nbsp; 5 17:23 index.html\n......\n</code></pre><p>在这个例子中，.dockerignore 文件的内容和 Node.js 应用一样，都是忽略 node_modules 目录，以便加速镜像的构建速度。</p><p>接下来，我们重点关注 Dockerfile 文件内容。</p><pre><code class=\"language-yaml\"># syntax=docker/dockerfile:1\n\nFROM node:lts-alpine\nRUN npm install -g http-server\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nEXPOSE 8080\nCMD [ \"http-server\", \"dist\" ]\n</code></pre><p>简单分析一下上面 Dockerfile 的内容。首先使用 node:lts-alpine 作为基础镜像，然后安装 http-server 作为代理服务器，第 6 行代表的含义是，将 package.json 和 package-lock.json 复制到镜像内，并使用 npm install 安装依赖。这里让依赖安装和源码安装解耦的目的是尽量使用 Docker 镜像构建缓存，只要在 package.json 文件内容不变的情况下，即便是源码改变，都可以使用已经下载好的 npm 依赖缓存。</p><p>依赖安装完毕后，第 8 行，我们要将项目源码复制到镜像内，并且通过 npm run build 来构建 dist 目录，最后，第 12 行，使用 http-server 来启动 dist 目录的静态文件。</p><p>现在，我们可以通过 docker build 来构建镜像了。</p><pre><code class=\"language-yaml\">$ docker build -t vue .\n</code></pre><p>接下来，使用 docker run 启动镜像。</p><pre><code class=\"language-yaml\">$ docker run --publish 8080:8080 vue\nStarting up http-server, serving dist\n\nhttp-server version: 14.1.1\n\nhttp-server settings:&nbsp;\nCORS: disabled\n......\n</code></pre><p>到这里，你可以打开浏览器访问 <a href=\"http://localhost:8080\">http://localhost:8080</a> ，如果出现 Vue 示例应用的项目，说明镜像构建完成，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/f2/cae462930f97f9e5fb22bdf7ea3366f2.png?wh=1920x1038\" alt=\"图片\"></p><h3>Nginx 构建方式</h3><p>在上面的例子中，我们使用 http-server 来对外提供服务，这在开发和测试场景，或者是在小型的使用场景中是完全可以的。不过，<strong>在正式的生产环境中，我推荐你把 Nginx 作为反向代理服务器来对外提供服务，它也是性能最好、使用最广泛和稳定性最高的一种方案。</strong></p><p>在 Vue 示例项目的同级目录下，我已经创建好了名为 Dockerfile-Nginx 文件。</p><pre><code class=\"language-yaml\"># syntax=docker/dockerfile:1\n\nFROM node:lts-alpine as build-stage\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM nginx:stable-alpine as production-stage\nCOPY --from=build-stage /app/dist /usr/share/nginx/html\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre><p>这个 Dockerfile 定义了两个构建阶段，第一个阶段是第 3 行到第 8 行的内容，其他的是第二阶段的内容。</p><p>第一阶段的构建过程和我们在上面提到的 http-server 的构建方式非常类似，它是以 node:lts-alpine 为基础镜像，同时复制 package.json 和 package-lock.json 并安装依赖，然后再复制项目源码并且执行 npm run build 来构建项目，生成 dist 目录。</p><p>第二个阶段的构建过程则是引入了一个新的 nginx:stable-alpine 镜像作为运行镜像，还将第一阶段构建的 dist 目录复制到了第二阶段的 /usr/share/nginx/html 目录中。这个目录是 Nginx 默认的网页目录，默认情况下，Nginx 将使用该目录的内容作为静态资源。最后第 13 行以前台的方式启动 Nginx。</p><p>现在，我们可以通过 docker build 来构建镜像。</p><pre><code class=\"language-yaml\">$ docker build -t vue-nginx -f Dockerfile-Nginx .\n</code></pre><p>接下来，使用 docker run 启动镜像。</p><pre><code class=\"language-yaml\">$ docker run --publish 8080:80 vue-nginx\n/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration\n/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh\n10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf\n10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh\n......\n</code></pre><p>最后，打开浏览器访问 <a href=\"http://localhost:8080\">http://localhost:8080</a> 验证一下，如果出现和前面提到的 http-server 构建方式一样的 Vue 示例应用界面，就说明镜像构建成功了。</p><h2>构建多平台镜像</h2><p>好了，上面的案例，我们都是通过在本地执行 docker build 命令来构建镜像，然后在本地通过 docker run 命令来执行的。实际上，在构建镜像时，Docker 会默认构建本机对应平台的镜像，例如常见的 AMD64 平台，这在大多数情况是适用的。</p><p>但是，当我们使用不同平台的设备尝试启动这个镜像时，可能会遇到下面的问题。</p><pre><code class=\"language-yaml\">WARNING: The requested image's platform (linux/arm64/v8) does not match the detected host platform (linux/amd64) and no specific platform was requested\n</code></pre><p>产生这个问题的原因是，构建和运行设备的 CPU 平台存在差异。在实际项目中，最典型的例子是构建镜像的计算机是 AMD64 架构，但运行镜像的机器是 ARM64。</p><p>要查看镜像适用于什么平台，你可以找到 DockerHub 镜像详情页。例如， Alpine 镜像适用的平台就可以在这个<a href=\"https://hub.docker.com/_/alpine/tags\">链接</a>查看，详情页截图如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/9d/fa9e309a63a2e8ac5dbbebab1a30529d.png?wh=1920x966\" alt=\"图片\"></p><p>从这个页面我们可以看出，Apline 镜像适用的平台非常多，例如 Linux/386、Linux/amd64 等等。一般情况下，在构建镜像时，我们只会构建本机平台的镜像，但是当拉取镜像时，Docker 会自动拉取符合当前平台的镜像版本。</p><p>那么，怎么才能真正实现跨平台的<strong>“一次构建，到处运行”</strong>目标呢？Docker 为我们提供了构建多平台镜像的方法：buildx。</p><h3>初始化</h3><p>要使用 Buildx，首先需要创建构建器，你可以使用 docker buildx create 命令来创建它，并将其命名为 mybuilder。</p><pre><code class=\"language-yaml\">$ $ docker buildx create --name builder\nbuilder\n</code></pre><p>然后，将 mybuilder 设置为默认的构建器。</p><pre><code class=\"language-yaml\">$ docker buildx use builder\n</code></pre><p>接下来，初始化构建器，这一步主要是启动 buildkit 容器。</p><pre><code class=\"language-yaml\">$ $ docker buildx inspect --bootstrap\n[+] Building 19.1s (1/1) FINISHED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp;=&gt; [internal] booting buildkit&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 19.1s\n&nbsp;=&gt; =&gt; pulling image moby/buildkit:buildx-stable-1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18.3s\n&nbsp;=&gt; =&gt; creating container buildx_buildkit_mybuilder0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0.8s\nName:&nbsp; &nbsp;builder\nDriver: docker-container\n\nNodes:\nName:&nbsp; &nbsp; &nbsp; mybuilder0\nEndpoint:&nbsp; unix:///var/run/docker.sock\nStatus:&nbsp; &nbsp; running\nBuildkit:&nbsp; v0.10.4\nPlatforms: linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/arm/v7, linux/arm/v6\n</code></pre><p>初始化完成后，我们可以从返回结果中看到支持的平台，例如 Linux/amd64、Linux/arm64 等。</p><h3>构建多平台镜像</h3><p>这时候，我们就可以尝试使用 buildx 来构建多平台镜像了。我已经提前编写好了一个简单示例，在将示例应用克隆到本地后，你可以进入 docker/13/multi-arch 目录并查看。</p><pre><code class=\"language-yaml\">$ cd gitops/docker/13/multi-arch\n$ ls -al\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; &nbsp;439 10&nbsp; 5 23:49 Dockerfile\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; 1075 10&nbsp; 5 18:34 go.mod\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; 6962 10&nbsp; 5 18:34 go.sum\n-rw-r--r--&nbsp; 1 weiwang&nbsp; staff&nbsp; &nbsp;397 10&nbsp; 5 18:39 main.go\n</code></pre><p>main.go 是示例应用的主体文件，我们启动一个 HTTP 服务器，访问根路径可以返回 Runtime 包的一些内置变量。</p><pre><code class=\"language-yaml\">package main\nimport (\n    \"net/http\"\n    \"runtime\"\n    \"github.com/gin-gonic/gin\"\n)\nvar (\n    r = gin.Default()\n)\nfunc main() {\n    r.GET(\"/\", indexHandler)\n    r.Run(\":8080\")\n}\nfunc indexHandler(c *gin.Context) {\n    var osinfo = map[string]string{\n        \"arch\":    runtime.GOARCH,\n        \"os\":      runtime.GOOS,\n        \"version\": runtime.Version(),\n    }\n    c.JSON(http.StatusOK, osinfo)\n}\n</code></pre><p>相比较单一平台的构建方法，在构建多平台镜像的时候，我们可以在 Dockerfile 内使用一些内置变量，例如 BUILDPLATFORM、TARGETOS 和 TARGETARCH，他们分别对应构建平台（例如 Linux/amd64）、系统（例如 Linux）和架构（例如 AMD64）。</p><pre><code class=\"language-yaml\"># syntax=docker/dockerfile:1\nFROM --platform=$BUILDPLATFORM golang:1.18 as build\nARG TARGETOS TARGETARCH\nWORKDIR /opt/app\nCOPY go.* ./\nRUN go mod download\nCOPY . .\nRUN --mount=type=cache,target=/root/.cache/go-build \\\nGOOS=$TARGETOS GOARCH=$TARGETARCH go build -o /opt/app/example .\n\nFROM ubuntu:latest\nWORKDIR /opt/app\nCOPY --from=build /opt/app/example ./example\nCMD [\"/opt/app/example\"]\n</code></pre><p>这个 Dockerfile 包含两个构建阶段，第一个构建阶段是从第 2 行至第 9 行，第二个构建阶段是从第 11 行到第 14 行。</p><p><strong>我们先看第一个构建阶段。</strong></p><p>第 2 行 FROM 基础镜像增加了一个 --platform=$BUILDPLATFORM 参数，它代表“强制使用不同平台的基础镜像”，例如 Linux/amd64。在没有该参数配置的情况下，Docker 默认会使用构建平台（本机）对应架构的基础镜像。</p><p>第 3 行 ARG 声明了使用两个内置变量 TARGETOS 和 TARGETARCH，TARGETOS 代表系统，例如 Linux，TARGETARCH 则代表平台，例如 Amd64。这两个参数将会在 Golang 交叉编译时生成对应平台的二进制文件。</p><p>第 4 行 WORKDIR 声明了工作目录。</p><p>第 5 行的意思是通过 COPY 将 go.mod 和 go.sum 拷贝到镜像中，并在第 6 行使用 RUN 来运行 go mod download 下载依赖。这样，在这两个文件不变的前提下，Docker 将使用构建缓存来加快构建速度。</p><p>在下载完依赖之后，我们通过第 7 行把所有源码文件复制到镜像内。</p><p>第 8 行有两个含义，首先， --mount=type=cache,target=/root/.cache/go-build 的目的是告诉Docker 使用 Golang 构建缓存，加快镜像构建的速度。接下来，GOOS=$TARGETOS GOARCH=$TARGETARCH go build -o /opt/app/example . 代表的含义是 Golang 交叉编译。注意，$TARGETOS 和 $TARGETARCH 是我们提到的内置变量，在具体构建镜像的时候，Docker 会帮我们填充进去。</p><p><strong>第二个构建阶段比较简单，主要是使用 ubuntu:latest 基础镜像，将第一个构建阶段生成的二进制文件复制到镜像内，然后指定镜像的启动命令。</strong></p><p>接下来，我们就可以开始构建多平台镜像了。</p><p>在开始构建之前，先执行 docker login 登录到 DockerHub。</p><pre><code class=\"language-yaml\">$ docker login\nUsername:\nPassword:\nLogin Succeeded\n</code></pre><p>接下来，使用 docker buildx build 一次性构建多平台镜像。</p><pre><code class=\"language-yaml\">$ docker buildx build --platform linux/amd64,linux/arm64 -t lyzhang1999/multi-arch:latest --push&nbsp; .\n</code></pre><p>在这个命令中，我们使用 --platform 参数指定了两个平台：Linux/amd64 和 Linux/arm64，同时 -t 参数指定了镜像的 Tag，而 --push 参数则代表构建完成后直接将镜像推送到 DockerHub。</p><p>还记得我们在 Dockerfile 第 2 行增加的 --platform=$BUILDPLATFORM 参数吗？当执行这条命令时，Docker 会分别使用 Amd64 和 Arm64 两个平台的 golang:1.18 镜像，并且在对应的镜像内执行编译过程。</p><p>执行完命令后，镜像会上传到 DockerHub 平台。进入这个镜像详情页我们就会发现它同时兼容了 Amd64 和 Arm64 两个平台。这样，多平台镜像就构建完成了。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/77/ab41d5c634eff040c1a05b49708c9077.png?wh=1920x889\" alt=\"图片\"></p><h2>总结</h2><p>在这节课，我为你介绍了主流语言镜像构建的案例，包括后端语言 Golang、Java、Node.js 以及前端 Vue 框架。</p><p>在这些案例中，我尽量按照真实的生产环境来编写 Dockerfile，我使用到了一些 Dockerfile 的高级用法，例如多阶段构建、使用缓存和使用 .dockerignore 等，这些用法可以帮助我们加速构建镜像和缩小镜像大小。当你需要将实际的业务进行容器化改造时，可以直接参考我编写的案例。</p><p>此外，我还介绍了如何使用 buildx 构建多平台镜像。在这一部分，我通过一个真实的例子介绍了如何构建 Golang 的多平台镜像。一般情况下，多平台镜像并不常用，但如果你构建的镜像需要兼容不同的 CPU 平台，那就可以通过这种方法来实现。</p><p>这节课我还提到了“多阶段构建”，但并没有对它做深入讲解，这是我们下节课的重点。</p><h2>思考题</h2><p>最后，给你留一道思考题吧。</p><p>结合相关资料，请你简单分享一下为什么我们能构建非本地平台的镜像呢？（提示：Docker QEMU。）</p><p>欢迎你给我留言交流讨论，你也可以把这节课分享给更多的朋友一起阅读。我们下节课见。</p>","neighbors":{"left":{"article_title":"12｜如何自动检查业务真实的健康状态？","id":620065},"right":{"article_title":"14｜容器化：如何将镜像体积缩减 90%？","id":621351}},"comments":[{"had_liked":false,"id":366071,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"广东","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1673358087,"is_pvip":false,"replies":[{"id":133382,"content":"也是一种不错的实践方式。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1673403531,"ip_address":"广东","comment_id":366071,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"多平台构建在dockerfile写架构信息感觉很麻烦\n\n我们的做法是from 的基础镜像做成多架构，然后dockerfile正常写即可，构建的时候指定架构就行了","like_count":5,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599208,"discussion_content":"也是一种不错的实践方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673403532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366639,"user_name":"郑海成","can_delete":false,"product_type":"c1","uid":1192616,"ip_address":"北京","ucode":"B0363EA4B2C646","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/a8/d5bf5445.jpg","comment_is_top":false,"comment_ctime":1674009081,"is_pvip":true,"replies":[{"id":133585,"content":"👍🏻很易懂的原理解释。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1674011080,"ip_address":"广东","comment_id":366639,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"思考题：查了一些关于qemu的原理，尝试理解一下。docker buildx 通过qemu的user mod（binfmt_misc）注册一个转换程序动态转换不同cpu架构之间的命令😁","like_count":4,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600093,"discussion_content":"👍🏻很易懂的原理解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674011080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372290,"user_name":"Geek_df0d4d","can_delete":false,"product_type":"c1","uid":3583561,"ip_address":"上海","ucode":"C801D2B152AB63","user_header":"","comment_is_top":false,"comment_ctime":1680945478,"is_pvip":false,"replies":[{"id":135906,"content":"是的，除了 COPY，ADD 指令也会忽略 .dockerignore 定义的内容。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1681000340,"ip_address":"广东","comment_id":372290,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"请问.dockerignore是不是只有Dockerfile中指定COPY . .的时候才有作用？","like_count":1,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612911,"discussion_content":"是的，除了 COPY，ADD 指令也会忽略 .dockerignore 定义的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681000341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2608728,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ce/58/71ed845f.jpg","nickname":"Dexter","note":"","ucode":"909CABC4AC4AC9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623855,"discussion_content":"印象中和Dockerfile中的指令无关，如果.dockerignore没有指定，都会进入到构建上下文中，导致构建内存撑爆了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689917420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372282,"user_name":"Geek_df0d4d","can_delete":false,"product_type":"c1","uid":3583561,"ip_address":"上海","ucode":"C801D2B152AB63","user_header":"","comment_is_top":false,"comment_ctime":1680940941,"is_pvip":false,"replies":[{"id":135905,"content":"也是一种方式，不过加入专用的打包服务器就变成有状态了，Dockerfile 的思想是可以在任何地方构建。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1680999320,"ip_address":"广东","comment_id":372282,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"多阶段构建，那为什么不直接用专门的打包服务器构建呢，然后直接第二阶段构建就好了？","like_count":1,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612910,"discussion_content":"也是一种方式，不过加入专用的打包服务器就变成有状态了，Dockerfile 的思想是可以在任何地方构建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680999321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365907,"user_name":"jeffery","can_delete":false,"product_type":"c1","uid":1219972,"ip_address":"广东","ucode":"35E2DAA386FB86","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/84/171b2221.jpg","comment_is_top":false,"comment_ctime":1673191050,"is_pvip":false,"replies":[{"id":133289,"content":"👍🏻 macOS 和 Windows Docker desktop 是包含 buildx 的，Linux 需要按照你的方法手动安装。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1673230137,"ip_address":"广东","comment_id":365907,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"buildx 需要安装\nhttps:&#47;&#47;github.com&#47;docker&#47;buildx#linux-packages\nmkdir -pv ~&#47;.docker&#47;cli-plugins&#47;\nwget -O ~&#47;.docker&#47;cli-plugins&#47;docker-buildx \\\n    https:&#47;&#47;github.com&#47;docker&#47;buildx&#47;releases&#47;download&#47;v0.9.1&#47;buildx-v0.9.1.linux-amd64\n\nchmod a+x ~&#47;.docker&#47;cli-plugins&#47;docker-buildx\n\n然后命令\n $ docker buildx create --name builder 才能生效","like_count":1,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598929,"discussion_content":"👍🏻 macOS 和 Windows Docker desktop 是包含 buildx 的，Linux 需要按照你的方法手动安装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673230138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377198,"user_name":"Index","can_delete":false,"product_type":"c1","uid":1078909,"ip_address":"日本","ucode":"815A1A62F846CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/7d/04c95885.jpg","comment_is_top":false,"comment_ctime":1688050702,"is_pvip":false,"replies":[{"id":137451,"content":"完整的 Dockerfile 发一下，此外你可以尝试更换一个 JDK 镜像测试，另外检查 mvnw 命令执行的位置是源码目录。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1688089168,"ip_address":"广东","comment_id":377198,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"Step 5&#47;12 : RUN .&#47;mvnw dependency:go-offline\n ---&gt; Running in b16f1d8d26ec\nError: JAVA_HOME is not defined correctly.\n  We cannot execute &#47;opt&#47;java&#47;openjdk&#47;bin&#47;java\nThe command &#39;&#47;bin&#47;sh -c .&#47;mvnw dependency:go-offline&#39; returned a non-zero code: 1\n\n老师你好，这是什么原因，为啥JAVA_HOME会不正确，在eclipse-temurin:17-jdk-jammy镜像里不是已经设置好了吗？","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622293,"discussion_content":"完整的 Dockerfile 发一下，此外你可以尝试更换一个 JDK 镜像测试，另外检查 mvnw 命令执行的位置是源码目录。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688089168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1078909,"avatar":"https://static001.geekbang.org/account/avatar/00/10/76/7d/04c95885.jpg","nickname":"Index","note":"","ucode":"815A1A62F846CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":622544,"discussion_content":"完整dockerfile\n# syntax=docker/dockerfile:1\n\nFROM eclipse-temurin:17-jdk-jammy as builder\nWORKDIR /opt/app\nCOPY .mvn/ .mvn\nCOPY mvnw pom.xml ./\nRUN ./mvnw dependency:go-offline\nCOPY ./src ./src\nRUN ./mvnw clean install\n\n\nFROM eclipse-temurin:17-jre-jammy\nWORKDIR /opt/app\nEXPOSE 8080\nCOPY --from=builder /opt/app/target/*.jar /opt/app/*.jar\nCMD [&#34;java&#34;, &#34;-jar&#34;, &#34;/opt/app/*.jar&#34; ]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688390756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":622293,"ip_address":"四川","group_id":0},"score":622544,"extra":""}]},{"author":{"id":1078909,"avatar":"https://static001.geekbang.org/account/avatar/00/10/76/7d/04c95885.jpg","nickname":"Index","note":"","ucode":"815A1A62F846CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622547,"discussion_content":"我是在mac上操作的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688392563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078909,"avatar":"https://static001.geekbang.org/account/avatar/00/10/76/7d/04c95885.jpg","nickname":"Index","note":"","ucode":"815A1A62F846CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622546,"discussion_content":"单独run这个java基础镜像出现这个错误，但是我docker的可使用内存还有很多\n[~/ops]$ docker run eclipse-temurin:17-jdk-jammy\n[0.029s][warning][os,thread] Failed to start thread &#34;GC Thread#0&#34; - pthread_create failed (EPERM) for attributes: stacksize: 1024k, guardsize: 4k, detached.\n#\n# There is insufficient memory for the Java Runtime Environment to continue.\n# Cannot create worker GC thread. Out of system resources.\n# An error report file with more information is saved as:\n# //hs_err_pid1.log","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688392508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370225,"user_name":"陈敏","can_delete":false,"product_type":"c1","uid":2841834,"ip_address":"福建","ucode":"A8F05ADF47E5F0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erUYW4duhqyicJEAOaEAbtSiaz22iaUmV1Mh1SJGcwRgicyZC16Rk3fJFvwXuhZJP6lqjLKCH13TEvrGg/132","comment_is_top":false,"comment_ctime":1678583587,"is_pvip":false,"replies":[{"id":135023,"content":"一般不这么做。因为如果按这个方案的话，PVC 的代码来源可能是 ConfigMap 或者 Secret，而他们的大小是有限制的，另外更新它们也不方便。","user_name":"作者回复","user_name_real":"作者","uid":1275456,"ctime":1678665921,"ip_address":"广东","comment_id":370225,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"老师你好，请教下，本节课的 nginx 镜像构建是把静态资源放在镜像中，如果我们采用 pvc 挂载静态资源的方式，是不是可以避免每次改代码需要重打镜像，重启容器？这种方式会更好吗？","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608790,"discussion_content":"一般不这么做。因为如果按这个方案的话，PVC 的代码来源可能是 ConfigMap 或者 Secret，而他们的大小是有限制的，另外更新它们也不方便。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678665922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368872,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"北京","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1676855831,"is_pvip":false,"replies":[{"id":134341,"content":"👍🏻 是的，这里没有考虑到先安装依赖以及缓存的问题。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1676861552,"ip_address":"广东","comment_id":368872,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"go的两阶段构建有一个问题，每次go代码有更新重新build，都会导致重新下载所有依赖库，没法利用缓存，编译速度被拖的很慢","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605685,"discussion_content":"👍🏻 是的，这里没有考虑到先安装依赖以及缓存的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676861552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":605807,"discussion_content":"看了您的下一篇文章完美解决了这个问题，太赞了～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676871486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":605685,"ip_address":"北京","group_id":0},"score":605807,"extra":""}]}]},{"had_liked":false,"id":368287,"user_name":"Geek_988110","can_delete":false,"product_type":"c1","uid":2141731,"ip_address":"重庆","ucode":"6649AB9475B31B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/eXPVCBWf4piaxJZL6tibMTjWqYfu9gDCkpgfRDAASMn4YOybkriabMw4VGlwqDIbAt26R1LysGWfKDhiaWNxnAicM9w/132","comment_is_top":false,"comment_ctime":1676107527,"is_pvip":false,"replies":[{"id":134103,"content":"可能是网络原因导致的，用香港的虚拟机构建试试？","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1676120070,"ip_address":"广东","comment_id":368287,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":" =&gt; CACHED [builder 4&#47;7] COPY mvnw pom.xml .&#47;                                                                                    0.0s \n =&gt; ERROR [builder 5&#47;7] RUN .&#47;mvnw dependency:go-offline   \n\n老师你好，为什么会提示该error信息。容器里面是有这个文件的","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603343,"discussion_content":"可能是网络原因导致的，用香港的虚拟机构建试试？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676120071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367873,"user_name":"GeekZd","can_delete":false,"product_type":"c1","uid":1039886,"ip_address":"北京","ucode":"D2AA3305A6AFE8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/0e/af8dd241.jpg","comment_is_top":false,"comment_ctime":1675694809,"is_pvip":false,"replies":[{"id":133978,"content":"试一下直接用 docker pull 这个镜像看看是不是网络问题。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1675730183,"ip_address":"广东","comment_id":367873,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"Step 1&#47;12 : FROM eclipse-temurin:v17-jdk-jammy as builder\nError parsing reference: &quot;eclipse-temurin:v17-jdk-jammy as builder&quot; is not a valid repository&#47;tag: invalid reference format  这个报错咋回事？","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602290,"discussion_content":"试一下直接用 docker pull 这个镜像看看是不是网络问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675730183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039886,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/0e/af8dd241.jpg","nickname":"GeekZd","note":"","ucode":"D2AA3305A6AFE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602501,"discussion_content":"估计是这个原因，从docker.io拉不下来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675781916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367112,"user_name":"徐石头","can_delete":false,"product_type":"c1","uid":1035885,"ip_address":"湖南","ucode":"D8FA8A64FB7E33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/6d/530df0dd.jpg","comment_is_top":false,"comment_ctime":1674955858,"is_pvip":true,"replies":[{"id":133911,"content":"能具体一点嘛","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1675415709,"ip_address":"广东","comment_id":367112,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"为什么需要两次构建，只要第一次构建可以吗？","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601816,"discussion_content":"能具体一点嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675415709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366676,"user_name":"Adam","can_delete":false,"product_type":"c1","uid":1305633,"ip_address":"广东","ucode":"338BA720880E4F","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg","comment_is_top":false,"comment_ctime":1674033796,"is_pvip":false,"replies":[{"id":133926,"content":"多平台构建 buildx 应该是目前最好的选择了。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1675416920,"ip_address":"广东","comment_id":366676,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"老师，请教个问题，除了docker buildx这种工具外，还有没有其它工具也可以用来进行多平台构建。感觉docker in docker的方式不太灵活，kaniko又满足不了。","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601833,"discussion_content":"多平台构建 buildx 应该是目前最好的选择了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675416920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365981,"user_name":"GAC·DU","can_delete":false,"product_type":"c1","uid":1385403,"ip_address":"广东","ucode":"7847FBE1C13740","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/bb/a1a61f7c.jpg","comment_is_top":false,"comment_ctime":1673274834,"is_pvip":false,"replies":[{"id":133339,"content":"应该是网络问题，可以尝试参考第16讲的内容，用 github action 来构建，这样就可以解决网络问题了。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1673331448,"ip_address":"广东","comment_id":365981,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"老师，执行.&#47;mvnw dependency:go-offline一直卡着不动是什么情况？","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599090,"discussion_content":"应该是网络问题，可以尝试参考第16讲的内容，用 github action 来构建，这样就可以解决网络问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673331448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365888,"user_name":"jeffery","can_delete":false,"product_type":"c1","uid":1219972,"ip_address":"广东","ucode":"35E2DAA386FB86","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/84/171b2221.jpg","comment_is_top":false,"comment_ctime":1673181121,"is_pvip":false,"replies":[{"id":133282,"content":"看起来是代理或者网络的问题，配置 Go proxy 能解决吗？","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1673192164,"ip_address":"广东","comment_id":365888,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"1. git clone https:&#47;&#47;github.com&#47;lyzhang1999&#47;gitops.git\nfatal: unable to access ‘https:&#47;&#47;github.com&#47;…&#47;.g\n解决方案：\n~# git config --global http.proxy\n~# git config --unset http.proxy\n2. https:&#47;&#47;github.com&#47;lyzhang1999&#47;gitops&#47;blob&#47;main&#47;docker&#47;13&#47;golang&#47;Dockerfile#L6\n之前添加goproxy\nRUN go env -w GO111MODULE=on\nRUN go env -w GOPROXY=https:&#47;&#47;goproxy.cn,direct\n遇到错误：\nStep 6&#47;14 : RUN go mod download\n---&gt; Running in bd45f51f1f37\ngo mod download: github.com&#47;labstack&#47;echo&#47;v4@v4.10.0: Get &quot;https:&#47;&#47;proxy.golang.org&#47;github.com&#47;labstack&#47;echo&#47;v4&#47;@v&#47;v4.10.0.info&quot;: dial tcp 172.217.163.49:443: connect: connection refused\n...\nThe command &#39;&#47;bin&#47;sh -c go mod download&#39; returned a non-zero code: 1\n\n","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598906,"discussion_content":"看起来是代理或者网络的问题，配置 Go proxy 能解决吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673192164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1219972,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9d/84/171b2221.jpg","nickname":"jeffery","note":"","ucode":"35E2DAA386FB86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":598928,"discussion_content":"配置的七牛云 goproxy  下载速度给力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673229900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598906,"ip_address":"陕西","group_id":0},"score":598928,"extra":""},{"author":{"id":1092907,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ad/2b/90f97327.jpg","nickname":"勇","note":"","ucode":"B35EF6232A3A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":600960,"discussion_content":"配置GOPROXY后可以解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674977331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598906,"ip_address":"上海","group_id":0},"score":600960,"extra":""}]}]},{"had_liked":false,"id":365779,"user_name":"êｗěｎ","can_delete":false,"product_type":"c1","uid":1066707,"ip_address":"广东","ucode":"5000233111BEFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d3/e25d104a.jpg","comment_is_top":false,"comment_ctime":1672995508,"is_pvip":false,"replies":[{"id":133237,"content":"支持的，常见的 arm64，amd64，ppc64le 等都支持。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1673004224,"ip_address":"广东","comment_id":365779,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"请问下，ubuntu 这个镜像是能支持不同架构的吧？","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598716,"discussion_content":"支持的，常见的 arm64，amd64，ppc64le 等都支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673004224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365772,"user_name":"无名无姓","can_delete":false,"product_type":"c1","uid":2621412,"ip_address":"广东","ucode":"487BD5AA2CD305","user_header":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","comment_is_top":false,"comment_ctime":1672990121,"is_pvip":false,"replies":[{"id":133236,"content":"有异构的 K8s 集群就可能会需要，例如运行在 ARM64 平台的 K8s。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1673004035,"ip_address":"广东","comment_id":365772,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"多平台构建一般都是什么样的环境下面才使用呢","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598714,"discussion_content":"有异构的 K8s 集群就可能会需要，例如运行在 ARM64 平台的 K8s。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673004035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365822,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"广东","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1673084233,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"最后多平台构建\nFROM ubuntu 镜像的时候 也要加上 --platform=$BUILDPLATFORM 参数","like_count":1},{"had_liked":false,"id":365747,"user_name":"橙汁","can_delete":false,"product_type":"c1","uid":1332257,"ip_address":"北京","ucode":"EC3FF10D708C9D","user_header":"https://static001.geekbang.org/account/avatar/00/14/54/21/0bac2254.jpg","comment_is_top":false,"comment_ctime":1672969130,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100312001,"comment_content":"原来nodejs应用启动后默认pid不是1，用了1年多都没注意 一会赶紧看看","like_count":0}]}