{"id":39683,"title":"24 | 字段访问相关优化","content":"<p>在上一篇文章中，我介绍了逃逸分析，也介绍了基于逃逸分析的优化方式锁消除、栈上分配以及标量替换等内容。</p>\n<p>其中的标量替换，可以看成将对象本身拆散为一个个字段，并把原本对对象字段的访问，替换为对一个个局部变量的访问。</p>\n<pre><code>class Foo {\n  int a = 0;\n}\n\nstatic int bar(int x) {\n  Foo foo = new Foo();\n  foo.a = x;\n  return foo.a;\n}\n</code></pre>\n<p>举个例子，上面这段代码中的<code>bar</code>方法，经过逃逸分析以及标量替换后，其优化结果如下所示。（确切地说，是指所生成的IR图与下述代码所生成的IR图类似。之后不再重复解释。）</p>\n<pre><code>static int bar(int x) {\n  int a = x;\n  return a;\n}\n</code></pre>\n<p>由于Sea-of-Nodes IR的特性，局部变量不复存在，取而代之的是一个个值。在例子对应的IR图中，返回节点将直接返回所输入的参数。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/14/5d/14c64d61e81b764253a2fc96795d095d.png?wh=234*196\" alt=\"\" /></p>\n<p><strong>经过标量替换的<code>bar</code>方法</strong></p>\n<p>下面我列举了<code>bar</code>方法经由C2即时编译生成的机器码（这里略去了指令地址的前48位）。</p>\n<pre><code>  # {method} 'bar' '(I)I' in 'FieldAccessTest'\n  # parm0:    rsi       = int             // 参数x\n  #           [sp+0x20]  (sp of caller)\n0x06a0: sub    rsp,0x18                   // 创建方法栈桢\n0x06a7: mov    QWORD PTR [rsp+0x10],rbp   // 无关指令\n0x06ac: mov    eax,esi                    // 将参数x存入返回值eax中\n0x06ae: add    rsp,0x10                   // 弹出方法栈桢\n0x06b2: pop    rbp                        // 无关指令\n0x06b3: mov    r10,QWORD PTR [r15+0x70]   // 安全点测试\n0x06b7: test   DWORD PTR [r10],eax        // 安全点测试\n0x06ba: ret\n</code></pre>\n<blockquote>\n<p>在X86_64的机器码中，每当使用call指令进入目标方法的方法体中时，我们需要在栈上为当前方法分配一块内存作为其栈桢。而在退出该方法时，我们需要弹出当前方法所使用的栈桢。</p>\n</blockquote>\n<blockquote>\n<p>由于寄存器rsp维护着当前线程的栈顶指针，因此这些操作都是通过增减寄存器rsp来实现的，即上面这段机器码中偏移量为0x06a0以及0x06ae的指令。</p>\n</blockquote><!-- [[[read_end]]] -->\n<blockquote>\n<p>在介绍安全点（safepoint）时我曾介绍过，HotSpot虚拟机的即时编译器将在方法返回时插入安全点测试指令，即图中偏移量为0x06b3以及0x06ba的指令。其中真正的安全点测试是0x06b7指令。</p>\n</blockquote>\n<blockquote>\n<p>如果虚拟机需要所有线程都到达安全点，那么该test指令所访问的内存地址所在的页将被标记为不可访问，而该指令也将触发segfault，并借由segfault处理器进入安全点之中。通常，该指令会附带<code>; {poll_return}</code>这样子的注释，这里被我略去了。</p>\n</blockquote>\n<blockquote>\n<p>在X8_64中，前几个传入参数会被放置于寄存器中，而返回值则需要存放在rax寄存器中。有时候你会看到返回值被存入eax寄存器中，这其实是同一个寄存器，只不过rax表示64位寄存器，而eax表示32位寄存器。具体可以参考x86 calling conventions[1]。</p>\n</blockquote>\n<p>当忽略掉创建、弹出方法栈桢，安全点测试以及其他无关指令之后，所剩下的方法体就只剩下偏移量为0x06ac的mov指令，以及0x06ba的ret指令。前者将所传入的int型参数x移至代表返回值的eax寄存器中，后者是退出当前方法并返回至调用者中。</p>\n<p>虽然在部分情况下，逃逸分析以及基于逃逸分析的优化已经十分高效了，能够将代码优化到极其简单的地步，但是逃逸分析毕竟不是Java虚拟机的银色子弹。</p>\n<p>在现实中，Java程序中的对象或许本身便是逃逸的，或许因为方法内联不够彻底而被即时编译器当成是逃逸的。这两种情况都将导致即时编译器无法进行标量替换。这时候，针对对象字段访问的优化也变得格外重要起来。</p>\n<pre><code>static int bar(Foo o, int x) {\n  o.a = x;\n  return o.a;\n}\n</code></pre>\n<p>在上面这段代码中，对象<code>o</code>是传入参数，不属于逃逸分析的范围（Java虚拟机中的逃逸分析针对的是新建对象）。该方法会将所传入的int型参数<code>x</code>的值存储至实例字段<code>Foo.a</code>中，然后再读取并返回同一字段的值。</p>\n<p>这段代码将涉及两次内存访问操作：存储以及读取实例字段<code>Foo.a</code>。我们可以轻易地将其手工优化为直接读取并返回传入参数x的值。由于这段代码较为简单，因此它极大可能被编译为寄存器之间的移动指令（即将输入参数<code>x</code>的值移至寄存器eax中）。这与原本的内存访问指令相比，显然要高效得多。</p>\n<pre><code>static int bar(Foo o, int x) {\n  o.a = x;\n  return x;\n}\n</code></pre>\n<p>那么即时编译器是否能够作出类似的自动优化呢？</p>\n<h2>字段读取优化</h2>\n<p>答案是可以的。即时编译器会优化实例字段以及静态字段访问，以减少总的内存访问数目。具体来说，它将沿着控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。</p>\n<p>当即时编译器遇到对同一字段的读取节点时，如果缓存值还没有失效，那么它会将读取节点替换为该缓存值。</p>\n<p>当即时编译器遇到对同一字段的存储节点时，它会更新所缓存的值。当即时编译器遇到可能更新字段的节点时，如方法调用节点（在即时编译器看来，方法调用会执行未知代码），或者内存屏障节点（其他线程可能异步更新了字段），那么它会采取保守的策略，舍弃所有缓存值。</p>\n<p>在前面的例子中，我们见识了缓存字段存储节点的情况。下面我们来看一下缓存字段读取节点的情况。</p>\n<pre><code>static int bar(Foo o, int x) {\n  int y = o.a + x;\n  return o.a + y;\n}\n</code></pre>\n<p>在上面这段代码中，实例字段<code>Foo.a</code>将被读取两次。即时编译器会将第一次读取的值缓存起来，并且替换第二次字段读取操作，以节省一次内存访问。</p>\n<pre><code>static int bar(Foo o, int x) {\n  int t = o.a;\n  int y = t + x;\n  return t + y;\n}\n</code></pre>\n<p>如果字段读取节点被替换成一个常量，那么它将进一步触发更多优化。</p>\n<pre><code>static int bar(Foo o, int x) {\n  o.a = 1;\n  if (o.a &gt;= 0)\n    return x;\n  else\n    return -x;\n}\n</code></pre>\n<p>例如在上面这段代码中，实例字段<code>Foo.a</code>会被赋值为1。接下来的if语句将判断同一实例字段是否不小于0。经过字段读取优化之后，<code>&gt;=</code>节点的两个输入参数分别为常数1和0，因此可以直接替换为具体结果<code>true</code>。如此一来，else分支将变成不可达代码，可以直接删除，其优化结果如下所示。</p>\n<pre><code>static int bar(Foo o, int x) {\n  o.a = 1;\n  return x;\n}\n</code></pre>\n<p>我们再来看另一个例子。下面这段代码的<code>bar</code>方法中，实例字段<code>a</code>会被赋值为<code>true</code>，后面紧跟着一个以<code>a</code>为条件的while循环。</p>\n<pre><code>class Foo {\n  boolean a;\n  void bar() {\n    a = true;\n    while (a) {}\n  }\n  void whatever() { a = false; }\n}\n</code></pre>\n<p>同样，即时编译器会将while循环中读取实例字段<code>a</code>的操作直接替换为常量<code>true</code>，即下面代码所示的死循环。</p>\n<pre><code>  void bar() {\n    a = true;\n    while (true) {}\n  }\n// 生成的机器码将陷入这一死循环中\n0x066b: mov    r11,QWORD PTR [r15+0x70] // 安全点测试\n0x066f: test   DWORD PTR [r11],eax      // 安全点测试\n0x0672: jmp    0x066b                   // while (true)\n</code></pre>\n<p>在介绍Java内存模型时，我们便知道可以通过volatile关键字标记实例字段<code>a</code>，以此强制对它的读取。</p>\n<p>实际上，即时编译器将在volatile字段访问前后插入内存屏障节点。这些内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。</p>\n<p>就我们的例子而言，尽管在X86_64平台上，volatile字段读取操作前后的内存屏障是no-op，在即时编译过程中的屏障节点，还是会阻止即时编译器的字段读取优化，强制在循环中使用内存读取指令访问实例字段<code>Foo.a</code>的最新值。</p>\n<pre><code>0x00e0: movzx  r11d,BYTE PTR [rbx+0xc]   // 读取a\n0x00e5: mov    r10,QWORD PTR [r15+0x70]  // 安全点测试\n0x00e9: test   DWORD PTR [r10],eax       // 安全点测试\n0x00ec: test   r11d,r11d                 // while (a)\n0x00ef: jne    0x00e0                    // while (a)\n</code></pre>\n<p>同理，加锁、解锁操作也同样会阻止即时编译器的字段读取优化。</p>\n<h2>字段存储优化</h2>\n<p>除了字段读取优化之外，即时编译器还将消除冗余的存储节点。如果一个字段先后被存储了两次，而且这两次存储之间没有对第一次存储内容的读取，那么即时编译器可以将第一个字段存储给消除掉。</p>\n<pre><code>class Foo {\n  int a = 0;\n  void bar() {\n    a = 1;\n    a = 2;\n  }\n}\n</code></pre>\n<p>举例来说，上面这段代码中的<code>bar</code>方法先后存储了两次<code>Foo.a</code>实例字段。由于第一次存储之后没有读取<code>Foo.a</code>的值，因此，即时编译器会将其看成冗余存储，并将之消除掉，生成如下代码：</p>\n<pre><code>  void bar() {\n    a = 2;\n  }\n</code></pre>\n<p>实际上，即便是在这两个字段存储操作之间读取该字段，即时编译器还是有可能在字段读取优化的帮助下，将第一个存储操作当成冗余存储给消除掉。</p>\n<pre><code>class Foo {\n  int a = 0;\n  void bar() {\n    a = 1;\n    int t = a;\n    a = t + 2;\n  }\n}\n// 优化为\nclass Foo {\n  int a = 0;\n  void bar() {\n    a = 1;\n    int t = 1;\n    a = t + 2;\n  }\n}\n// 进一步优化为\nclass Foo {\n  int a = 0;\n  void bar() {\n    a = 3;\n  }\n}\n</code></pre>\n<p>当然，如果所存储的字段被标记为volatile，那么即时编译器也不能将冗余的存储操作消除掉。</p>\n<p>这种情况看似很蠢，但实际上并不少见，比如说两个存储之间隔着许多其他代码，或者因为方法内联的缘故，将两个存储操作（如构造器中字段的初始化以及随后的更新）纳入同一个编译单元里。</p>\n<h2>死代码消除</h2>\n<p>除了字段存储优化之外，局部变量的死存储（dead store）同样也涉及了冗余存储。这是死代码消除（dead code eliminiation）的一种。不过，由于Sea-of-Nodes IR的特性，死存储的优化无须额外代价。</p>\n<pre><code>int bar(int x, int y) {\n  int t = x*y;\n  t = x+y;\n  return t;\n}\n</code></pre>\n<p>上面这段代码涉及两个存储局部变量操作。当即时编译器将其转换为Sea-of-Nodes IR之后，没有节点依赖于t的第一个值<code>x*y</code>。因此，该乘法运算将被消除，其结果如下所示：</p>\n<pre><code>int bar(int x, int y) {\n  return x+y;\n}\n</code></pre>\n<p>死存储还有一种变体，即在部分程序路径上有冗余存储。</p>\n<pre><code>int bar(boolean f, int x, int y) {\n  int t = x*y;\n  if (f)\n    t = x+y;\n  return t;\n}\n</code></pre>\n<p>举个例子，上面这段代码中，如果所传入的boolean类型的参数<code>f</code>是<code>true</code>，那么在程序执行路径上将先后进行两次对局部变量<code>t</code>的存储。</p>\n<p>同样，经过Sea-of-Nodes IR转换之后，返回节点所依赖的值是一个phi节点，将根据程序路径选择<code>x+y</code>或者<code>x*y</code>。也就是说，当<code>f</code>为<code>true</code>的程序路径上的乘法运算会被消除，其结果如下所示：</p>\n<pre><code>int bar(boolean f, int x, int y) {\n  int t;\n  if (f)\n    t = x+y;\n  else\n    t = x*y;\n  return t;\n}\n</code></pre>\n<p>另一种死代码消除则是不可达分支消除。不可达分支就是任何程序路径都不可到达的分支，我们之前已经多次接触过了。</p>\n<p>在即时编译过程中，我们经常因为方法内联、常量传播以及基于profile的优化等，生成许多不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。</p>\n<pre><code>int bar(int x) {\n  if (false)\n    return x;\n  else\n    return -x;\n}\n</code></pre>\n<p>举个例子，在上面的代码中，if语句将一直跳转至else分支之中。因此，另一不可达分支可以直接消除掉，形成下面的代码：</p>\n<pre><code>int bar(int x) {\n  return -x;\n}\n</code></pre>\n<h2>总结与实践</h2>\n<p>今天我介绍了即时编译器关于字段访问的优化方式，以及死代码消除。</p>\n<p>即时编译器将沿着控制流缓存字段存储、读取的值，并在接下来的字段读取操作时直接使用该缓存值。</p>\n<p>这要求生成缓存值的访问以及使用缓存值的读取之间没有方法调用、内存屏障，或者其他可能存储该字段的节点。</p>\n<p>即时编译器还会优化冗余的字段存储操作。如果一个字段的两次存储之间没有对该字段的读取操作、方法调用以及内存屏障，那么即时编译器可以将第一个冗余的存储操作给消除掉。</p>\n<p>此外，我还介绍了死代码消除的两种形式。第一种是局部变量的死存储消除以及部分死存储消除。它们可以通过转换为Sea-of-Nodes IR来完成。第二种则是不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。</p>\n<p>今天的实践环节，请思考即时编译器会怎么优化下面代码中的除法操作？</p>\n<pre><code>int bar(int x, int y) {\n  int t = x/y;\n  t = x+y;\n  return t;\n}\n\n</code></pre>\n<p>[1]  <a href=\"https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI\">https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI</a><br />\n</p>\n","neighbors":{"left":{"article_title":"23 | 逃逸分析","id":18048},"right":{"article_title":"25 | 循环优化","id":39814}},"comments":[{"had_liked":false,"id":24327,"user_name":"Void_seT","can_delete":false,"product_type":"c1","uid":1070863,"ip_address":"","ucode":"DD55CB0198A5CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/0f/1f229bf5.jpg","comment_is_top":false,"comment_ctime":1536902753,"is_pvip":false,"replies":[{"id":"8920","content":"对的，因为有除0异常所以编译器没法优化掉这个除法","user_name":"作者回复","comment_id":24327,"uid":"1176688","ip_address":"","utype":1,"ctime":1536935776,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"61666444897","product_id":100010301,"comment_content":"因为x&#47;y会有除0异常，这部分代码是否会被优化掉，不太确定，望老师指点。","like_count":15,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423937,"discussion_content":"对的，因为有除0异常所以编译器没法优化掉这个除法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1536935776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25820,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1537445264,"is_pvip":false,"replies":[{"id":"9402","content":"按照自己的节奏学习就好啦，等以后遇到问题了也可以回来提问的。","user_name":"作者回复","comment_id":25820,"uid":"1176688","ip_address":"","utype":1,"ctime":1537454453,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"35897183632","product_id":100010301,"comment_content":"老师，请问一下，读这个专栏有点像涨视野的感觉，暂时来说对我看代码提供了新的灵感，但目前只能听，没法提问，这种感觉是是因为我底子不够么？还是我实践得比较少？","like_count":9,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424427,"discussion_content":"按照自己的节奏学习就好啦，等以后遇到问题了也可以回来提问的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537454453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51731,"user_name":"誓言的梦","can_delete":false,"product_type":"c1","uid":1187581,"ip_address":"","ucode":"EC9F6E2DFFF940","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/fd/a14d2be6.jpg","comment_is_top":false,"comment_ctime":1545229908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23020066388","product_id":100010301,"comment_content":"有除零的异常 是通过什么手段&#47;机制知道 还是写死的除法不能优化  或者回不回是通过 检测当输入除数为0就不优化  输入不为0时才优化","like_count":6},{"had_liked":false,"id":180999,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1582456751,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14467358639","product_id":100010301,"comment_content":"判断输入如果y为0则抛出异常，否则直接返回x+y","like_count":3,"discussions":[{"author":{"id":1303813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/05/fc769d45.jpg","nickname":"Geek_zhw","note":"","ucode":"AABE15F9895613","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274417,"discussion_content":"why\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590580763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1303813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/05/fc769d45.jpg","nickname":"Geek_zhw","note":"","ucode":"AABE15F9895613","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":284727,"discussion_content":"因为有异常所以不会优化代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592616868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":274417,"ip_address":""},"score":284727,"extra":""}]}]},{"had_liked":false,"id":24268,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1536887217,"is_pvip":false,"replies":[{"id":"8918","content":"多谢指出！已修改！","user_name":"作者回复","comment_id":24268,"uid":"1176688","ip_address":"","utype":1,"ctime":1536935684,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"14421789105","product_id":100010301,"comment_content":"&quot;其中真正的安全点测试是 0x06ba 指令&quot;应该是0x06b7指令","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423905,"discussion_content":"多谢指出！已修改！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536935684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2060756,"avatar":"","nickname":"在下蟑螂王","note":"","ucode":"E66A65A327095A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302875,"discussion_content":"这个人，有丶东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599054113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226546,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1592137268,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10182071860","product_id":100010301,"comment_content":"总结下来：<br>编绎器对于读取及存储指令的优化<br>对于读取，如果涉及一个堆对象同一个字段的多次读取，且不涉及该字段的写操作则会优化成方法执行中的缓存。只在第一次读取该对象字段时会从堆中取。会将该对象字段值缓存在局部变量表中。后面读取从这个地方取。这就涉及到一个多线程的可见性问题。如果想要去除可以设置为volatile或加lock,syncronized锁。<br>对于写操作，如果一个方法体对于一个变量的写是会覆盖的，则只会保留最后一个写操作。<br>还有一个优化则可以对于不可到达的分支代码进行消除，本质上都是减少不执行的代码，减少编绎成机器码后存储到code cache中的大小。","like_count":3},{"had_liked":false,"id":24340,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1536912472,"is_pvip":false,"replies":[{"id":"9022","content":"课后实践中的除法无法优化，因为可能存在除零异常。即时编译器需要判断除数是否为0","user_name":"作者回复","comment_id":24340,"uid":"1176688","ip_address":"","utype":1,"ctime":1537175917,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10126847064","product_id":100010301,"comment_content":"Return x+y ；","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423945,"discussion_content":"课后实践中的除法无法优化，因为可能存在除零异常。即时编译器需要判断除数是否为0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537175917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24275,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1536888935,"is_pvip":true,"replies":[{"id":"8919","content":"消除不了，有位同学答出来了，有除零异常","user_name":"作者回复","comment_id":24275,"uid":"1176688","ip_address":"","utype":1,"ctime":1536935731,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10126823527","product_id":100010301,"comment_content":"除法操作直接消除，返回return x+y;\t？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423909,"discussion_content":"消除不了，有位同学答出来了，有除零异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536935731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145613,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1572330095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5867297391","product_id":100010301,"comment_content":"JVM, 将字节码转成机器码，想深入了解挺难的，不过掌握其中的核心部分应该就够用了，毕竟咱不是JVM工程师，各有分工。","like_count":2},{"had_liked":false,"id":124698,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1565947039,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5860914335","product_id":100010301,"comment_content":"越走到后面就是天书啊，一篇文章至少三遍","like_count":1,"discussions":[{"author":{"id":1303813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/05/fc769d45.jpg","nickname":"Geek_zhw","note":"","ucode":"AABE15F9895613","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274418,"discussion_content":"每天3遍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590580813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96003,"user_name":"xingoo","can_delete":false,"product_type":"c1","uid":1059270,"ip_address":"","ucode":"622B6EEB7C1001","user_header":"https://static001.geekbang.org/account/avatar/00/10/29/c6/7fd7efa3.jpg","comment_is_top":false,"comment_ctime":1558309700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853276996","product_id":100010301,"comment_content":"字段缓存<br>存储优化<br>死代码消除:冗余代码，不可达代码","like_count":2},{"had_liked":false,"id":24644,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1537178995,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5832146291","product_id":100010301,"comment_content":"希望老师推荐一本 JVM 书籍，（除了《深入理解java 虚拟机》，因为我发现最新出版也是2013年的）","like_count":1,"discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118763,"discussion_content":"《深入理解Java虚拟机》第三版刚出来啦","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578189928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24288,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1536890745,"is_pvip":false,"replies":[{"id":"8922","content":"我记得就叫read elimination和write elimination。第三节的是dead store elimination和partial redundancy elimination。<br><br>Graal的相关代码在PEReadEliminationClosure以及ReadEliminationClosure中。可以自行阅读。","user_name":"作者回复","comment_id":24288,"uid":"1176688","ip_address":"","utype":1,"ctime":1536936350,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5831858041","product_id":100010301,"comment_content":"这一篇洋洋洒洒，其实覆盖了更多后端优化的算法，是否可以罗列一下对应算法名称供参考？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423915,"discussion_content":"我记得就叫read elimination和write elimination。第三节的是dead store elimination和partial redundancy elimination。\n\nGraal的相关代码在PEReadEliminationClosure以及ReadEliminationClosure中。可以自行阅读。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536936350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24281,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1536889709,"is_pvip":true,"replies":[{"id":"8921","content":"一般我们写代码都会在保持代码可读性的同时，尽量减少编译器工作量","user_name":"作者回复","comment_id":24281,"uid":"1176688","ip_address":"","utype":1,"ctime":1536935953,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5831857005","product_id":100010301,"comment_content":"感觉写代码的能力水平跟编译器优化工作量还是有点关系的。","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423913,"discussion_content":"一般我们写代码都会在保持代码可读性的同时，尽量减少编译器工作量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536935953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206162,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1586797962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586797962","product_id":100010301,"comment_content":"看起来就是在做代码优化，其实这些优化也是程序员应该去做的，而不是留给编译器去做。第一是为了代码质量，第二你不确定编译器会不会按你的想法去优化。","like_count":0},{"had_liked":false,"id":98956,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1559120028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559120028","product_id":100010301,"comment_content":"越了解，发现自己懂得越少","like_count":0},{"had_liked":false,"id":59879,"user_name":"『LHCY』","can_delete":false,"product_type":"c1","uid":1188449,"ip_address":"","ucode":"A8B5E0467B5F25","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/61/bbfb2d4a.jpg","comment_is_top":false,"comment_ctime":1547429147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547429147","product_id":100010301,"comment_content":"不知道现在发还会不会回复。<br>while（a.flag）{<br>    System.out.println();<br>}<br>这种方式，在flag没有被volatile多线程方式修改flag=false会退出循环，是因为打印函数中的锁阻止了字段优化吗","like_count":0},{"had_liked":false,"id":30249,"user_name":"o","can_delete":false,"product_type":"c1","uid":1104326,"ip_address":"","ucode":"4028A59700647A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg","comment_is_top":false,"comment_ctime":1538740379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538740379","product_id":100010301,"comment_content":"大佬，可否专门开一章讲讲对象的属性会在那些时候触发更新主存&#47;用户内存？分别是单线程不同方法，多线程不同方法、多线程相同方法。是否和方法体大小也有关系？例如就是在该篇文章中，如果while的代码块足够简单就会形成死循环，但是如果加了输出语句就不会（之前测试volatile关键字的时候遇到过，晚点贴一下主要代码🙏）","like_count":0}]}