{"id":278949,"title":"09｜原子性：2PC还是原子性协议的王者吗？","content":"<p>你好，我是王磊，你也可以叫我Ivan。今天，我要和你讲一讲分布式事务的原子性。</p><p>在限定“分布式”范围之前，我们先认识一下“事务的原子性”是啥。</p><p>如果分开来看的话，事务可以理解为包含一系列操作的序列，原子则代表不可分割的最小粒度。</p><p>而合起来看的话，事务的原子性就是让包含若干操作的事务表现得像一个最小粒度的操作。这个操作一旦被执行，只有“成功”或者“失败”这两种结果。这就好像比特（bit），只能代表0或者1，没有其他选择。</p><p>为什么要让事务表现出原子性呢？我想举个从ATM取款的例子。</p><p>现在，你走到一台ATM前，要从自己50,000元的账户上取1,000元现金。当你输入密码和取款金额后， ATM会吐出1,000块钱，同时你的账户余额会扣减1,000元；虽然有些时候，ATM出现故障，无法吐钞，系统会提示取款失败，但你的余额还会保持在50,000元。</p><p>总之，要么既吐钞又扣减余额，要么既不吐钞又不扣减余额，你拿到手的现金和账户余额总计始终是50,000元，这就是一个具有原子性的事务。</p><p>显然，吐钞和扣减余额是两个不同的操作，而且是分别作用在ATM和银行的存款系统上。当事务整合了两个独立节点上的操作时，我们称之为分布式事务，其达成的原子性也就是分布式事务的原子性。</p><!-- [[[read_end]]] --><p>关于事务的原子性，图灵奖得主、事务处理大师詹姆斯·格雷（Jim Gray）给出了一个更权威的定义：</p><p><em><strong>Atomicity</strong></em>: Either all the changes from the transaction occur (writes, and messages sent), or none occur.</p><p>这句话说得很精炼，我再和你解释下。</p><p>原子性就是要求事务只有两个状态：</p><ul>\n<li>一是成功，也就是所有操作全部成功；</li>\n<li>二是失败，任何操作都没有被执行，即使过程中已经执行了部分操作，也要保证回滚这些操作。</li>\n</ul><p>要做到事务原子性并不容易，因为多数情况下事务是由多个操作构成的序列。而分布式事务原子性的外在表现与事务原子性一致，但前者要涉及多个物理节点，而且增加了网络这个不确定性因素，使得问题更加复杂。</p><h2>实现事务原子性的两种协议</h2><p>那么，如何协调内部的多项操作，对外表现出统一的成功或失败状态呢？这需要一系列的算法或协议来保证。</p><h3>面向应用层的TCC</h3><p>原子性提交协议有不少，按照其作用范围可以分为面向应用层和面向资源层。我想先给你介绍一种“面向应用层”中比较典型的协议，TCC协议。</p><p>TCC是Try、Confirm和Cancel三个单词的缩写，它们是事务过程中的三个操作。关于TCC的适用场景嘛，还记得我在<a href=\"https://time.geekbang.org/column/article/271373\">第1讲</a>中介绍的“单元架构 + 单体数据库”吗? 这类方案需要在应用层实现事务的原子性，经常会用到TCC协议。</p><p>下面，我用一个转账的例子向你解释TCC处理流程。</p><p>小明和小红都是番茄银行的客户，现在小明打算给小红转账2,000元，这件事在番茄银行存款系统中是如何实现的呢？</p><p>我们先来看下系统的架构示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/5c/2a34990e1c95645f3942cd7d358f4c5c.jpg?wh=2700*1724\" alt=\"9.1\"></p><p>显然，番茄银行的存款系统是单元化架构的。也就是说，系统由多个单元构成，每个单元包含了一个存款系统的部署实例和对应的数据库，专门为某一个地区的用户服务。比如，单元A为北京用户服务，单元B为上海用户服务。</p><p>单元化架构的好处是每个单元只包含了部分用户，这样运行负载比较小，而且一旦出现问题，也只影响到少部分客户，可以提升整个存款系统的可靠性。</p><p>不过这种架构也有局限性。那就是虽然单元内的客户转账非常容易，但是跨单元的转账需要引入额外的处理机制，而TCC就是一种常见的选择。</p><p>TCC的整个过程由两类角色参与，一类是事务管理器，只能有一个；另一类是事务参与者，也就是具体的业务服务，可以是多个，每个服务都要提供Try、Confirm和Cancel三个操作。</p><p>下面是TCC的具体执行过程。</p><p>小明的银行卡在北京的网点开户，而小红的银行卡是在上海出差时办理的，所以两人的账户分别在单元A和单元B上。现在小明的账户余额是4,900元，要给小红转账2,000元，一个正常流程是这样的。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/cd/613371c67df3e1910a77785320586acd.jpg?wh=2700*1510\" alt=\"9.2\"></p><p>第一阶段，事务管理器会发出Try 操作，要求进行资源的检查和预留。也就是说，单元A要检查小明账户余额并冻结其中的2,000元，而单元B要确保小红的账户合法，可以接收转账。在这个阶段，两者账户余额始终不会发生变化。</p><p>第二阶段，因为参与者都已经做好准备，所以事务管理器会发出Confirm操作，执行真正的业务，完成2,000元的划转。</p><p>但是很不幸，小红账户是无法接收转账的非法账户，处理过程就变成下面的样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/01/f8/01fdc99cb9ba3233yyaa6a9cbee731f8.jpg?wh=2700*1514\" alt=\"9.3\"></p><p>第一阶段，事务管理器发出Try指令，单元B对小红账户的检查没有通过，回复No。而单元A检查小明账户余额正常，并冻结了2,000元，回复Yes。</p><p>第二阶段，因为前面有参与者回复No，所以事务管理器向所有参与者发出Cancel指令，让已经成功执行Try操作的单元A执行Cancel操作，撤销在Try阶段的操作，也就是单元A解除2,000元的资金冻结。</p><p>从上述流程可以发现，<strong>TCC仅是应用层的分布式事务框架</strong>，具体操作完全依赖于业务编码实现，可以做针对性的设计，但是这也意味着业务侵入会比较深。</p><p>此外，考虑到网络的不可靠，操作指令必须能够被重复执行，这就要求Try、Confirm、Cancel必须是幂等性操作，也就是说，要确保执行多次与执行一次得到相同的结果。显然，这又增加了开发难度。</p><p>那还有其他的选择吗？</p><p>当然有，我们来看看数据库领域最常用的两阶段提交协议（Two-Phase Commit，2PC），这也是面向资源层的典型协议。</p><h3>数据库领域最常用的2PC</h3><p>2PC的首次正式提出是在Jim Gray 1977年发表的一份文稿中，文稿的题目是“<a href=\"https://cs.nyu.edu/courses/fall18/CSCI-GA.3033-002/papers/Gray1978.pdf\">Notes on Data Base Operating Systems</a>”，对当时数据库系统研究成果和实践进行了总结，而2PC在工程中的应用还要再早上几年。</p><p>2PC的处理过程也分为准备和提交两个阶段，每个阶段都由事务管理器与资源管理器共同完成。其中，事务管理器作为事务的协调者只有一个，而资源管理器作为参与者执行具体操作允许有多个。</p><p>2PC具体是如何运行的呢？我们还是说回小明转账的例子。</p><p>小明给小红转账没有成功，两人又到木瓜银行来尝试。</p><p>木瓜银行的存款系统采用了分库分表方案，系统架构大致是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/24/4f417c89459f5f2f30bf7148ea747824.jpg?wh=2700*1377\" alt=\"9.4\"></p><p>在木瓜银行的存款系统中，所有客户的数据被分散存储在多个数据库实例中，这些数据库实例具有完全相同的表结构。业务逻辑部署在应用服务器上，通过数据库中间件访问底层的数据库实例。数据库中间件作为事务管理器，资源管理器就是指底层的数据库实例。</p><p>假设，小明和小红的数据分别被保存在数据库D1和D2上。</p><p>我们还是先讲正常的处理流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/1f/c1e92da6dbf1d6e92628383089a8ab1f.jpg?wh=2700*1518\" alt=\"9.5\"></p><p>第一阶段是准备阶段，事务管理器首先向所有参与者发送待执行的SQL，并询问是否做好提交事务的准备（Prepare）；参与者记录日志、分别锁定了小明和小红的账户，并做出应答，协调者接收到反馈Yes，准备阶段结束。</p><p>第二阶段是提交阶段，如果所有数据库的反馈都是Yes，则事务管理器会发出提交（Commit）指令。这些数据库接受指令后，会进行本地操作，正式提交更新余额，给小明的账户扣减2,000元，给小红的账户增加2,000元，然后向协调者返回Yes，事务结束。</p><p>那如果小明的账户出了问题，导致转账失败，处理过程会是怎样呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/c8/8c1cd6763c88b1fbf9be14402f3bfbc8.jpg?wh=2700*1494\" alt=\"9.6\"></p><p>第一阶段，事务管理器向所有数据库发送待执行的SQL，并询问是否做好提交事务的准备。</p><p>由于小明之前在木瓜银行购买了基金定投产品，按照约定，每月银行会自动扣款购买基金，刚好这个自动扣款操作正在执行，先一步锁定了账户。数据库D1发现无法锁定小明的账户，只能向事务管理器返回失败。</p><p>第二阶段，因为事务管理器发现数据库D1不具备执行事务的条件，只能向所有数据库发出“回滚”（Rollback）指令。所有数据库接收到指令后撤销第一阶段的操作，释放资源，并向协调者返回Yes，事务结束。小明和小红的账户余额均保持不变。</p><h3>2PC的三大问题</h3><p>学完了TCC和2PC的流程，我们来对比下这两个协议。</p><p>相比于TCC，2PC的优点是借助了数据库的提交和回滚操作，不侵入业务逻辑。但是，它也存在一些明显的问题：</p><ol>\n<li><strong>同步阻塞</strong></li>\n</ol><p>执行过程中，数据库要锁定对应的数据行。如果其他事务刚好也要操作这些数据行，那它们就只能等待。其实同步阻塞只是设计方式，真正的问题在于这种设计会导致分布式事务出现高延迟和性能的显著下降。</p><ol start=\"2\">\n<li><strong>单点故障</strong></li>\n</ol><p>事务管理器非常重要，一旦发生故障，数据库会一直阻塞下去。尤其是在第二阶段发生故障的话，所有数据库还都处于锁定事务资源的状态中，从而无法继续完成事务操作。</p><ol start=\"3\">\n<li><strong>数据不一致</strong></li>\n</ol><p>在第二阶段，当事务管理器向参与者发送Commit请求之后，发生了局部网络异常，导致只有部分数据库接收到请求，但是其他数据库未接到请求所以无法提交事务，整个系统就会出现数据不一致性的现象。比如，小明的余额已经能够扣减，但是小红的余额没有增加，这样就不符合原子性的要求了。</p><p>你可能会问：<strong>这些问题非常致命呀，2PC到底还能不能用？</strong></p><p>所以，网上很多文章会建议你避免使用2PC，替换为 TCC或者其他事务框架。</p><p>但我要告诉你的是，别轻易放弃，2PC都提出40多年了，学者和工程师们也没闲着，已经有很多对2PC的改进都在不同程度上解决了上述问题。</p><p>事实上，多数分布式数据库都是在2PC协议基础上改进，来保证分布式事务的原子性。这里我挑选了两个有代表性的2PC改进模型和你展开介绍，它们分别来自分布式数据库的两大阵营，NewSQL和PGXC。</p><h2>分布式数据库的两个2PC改进模型</h2><h3>NewSQL阵营：Percolator</h3><p>首先，我们要学习的是NewSQL阵营的Percolator。</p><p>Percolator来自Google的论文“<a href=\"https://www.cs.princeton.edu/courses/archive/fall10/cos597B/papers/percolator-osdi10.pdf\">Large-scale Incremental Processing Using Distributed Transactions and Notifications</a>”，因为它是基于分布式存储系统BigTable建立的模型，所以可以和NewSQL无缝链接。</p><p>Percolator模型同时涉及了隔离性和原子性的处理。今天，我们主要关注原子性的部分，在讲并发控制时，我再展开隔离性的部分。</p><p>使用Percolator模型的前提是事务的参与者，即数据库，要<strong>支持多版本并发控制（MVCC）</strong>。不过你不用担心，现在主流的单体数据库和分布式数据库都是支持的MVCC。</p><p>在转账事务开始前，小明和小红的账户分别存储在分片P1和P2上。如果你不了解分片的含义，可以回到<a href=\"https://time.geekbang.org/column/article/275696\">第6讲</a>学习。当然，你也可以先用单体数据库来替换分片的概念，这并不会妨碍对流程的理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/67/55141bef63a89718517cda63512af967.jpg?wh=2700*1256\" alt=\"9.7\"></p><p>上图中的Ming代表小明，Hong代表小红。在分片的账户表中各有两条记录，第一行记录的指针（write）指向第二行记录，实际的账户余额存储在第二行记录的Bal. data字段中。</p><p>Bal.data分为两个部分，冒号前面的是时间戳，代表记录的先后次序；后面的是真正的账户余额。我们可以看到，现在小明的账户上有4,900元，小红的账户上有300元。</p><p>我们来看下Percolator的流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/25/e610bcb9d4fa5b53cf9e7f293b4da425.jpg?wh=2700*1441\" alt=\"9.8\"></p><p><strong>第一，准备阶段</strong>，事务管理器向分片发送Prepare请求，包含了具体的数据操作要求。</p><p>分片接到请求后要做两件事，写日志和添加私有版本。关于私有版本，你可以简单理解为，在lock字段上写入了标识信息的记录就是私有版本，只有当前事务能够操作，通常其他事务不能读写这条记录。</p><p>你可能注意到了，两个分片上的lock内容并不一样。</p><p>主锁的选择是随机的，参与事务的记录都可能拥有主锁，但一个事务只能有一条记录拥有主锁，其他参与事务的记录在lock字段记录了指针信息“primary@Ming.bal”，指向主锁记录。</p><p>准备阶段结束的时候，两个分片都增加了私有版本记录，余额正好是转账顺利执行后的数字。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/60/f2a39536e65c8e0f4c282a0e05274160.jpg?wh=2700*1522\" alt=\"9.9\"></p><p><strong>第二，提交阶段</strong>，事务管理器只需要和拥有主锁的分片通讯，发送Commit指令，且不用附带其他信息。</p><p>分片P1增加了一条新记录时间戳为8，指向时间戳为7的记录，后者在准备阶段写入的主锁也被抹去。这时候7、8两条记录不再是私有版本，所有事务都可以看到小明的余额变为2,700元，事务结束。</p><p>你或许要问，为什么在提交阶段不用更新小红的记录？</p><p>Percolator最有趣的设计就是这里，因为分片P2的最后一条记录，保存了指向主锁的指针。其他事务读取到Hong7这条记录时，会根据指针去查找Ming.bal，发现记录已经提交，所以小红的记录虽然是私有版本格式，但仍然可视为已经生效了。</p><p>当然，这种通过指针查找的方式，会给读操作增加额外的工作。如果每个事务都照做，性能损耗就太大了。所以，还会有其他异步线程来更新小红的余额记录，最终变成下面的样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/d2/c8dc734cd33a8149eeb1ffb2f435e6d2.jpg?wh=2700*1516\" alt=\"9.10\"></p><p>现在，让我们对比2PC的问题，来看看Percolator模型有哪些改进。</p><ol>\n<li><strong>数据不一致</strong></li>\n</ol><p>2PC的一致性问题主要缘自第二阶段，不能确保事务管理器与多个参与者的通讯始终正常。</p><p>但在Percolator的第二阶段，事务管理器只需要与一个分片通讯，这个Commit操作本身就是原子的。所以，事务的状态自然也是原子的，一致性问题被完美解决了。</p><ol start=\"2\">\n<li><strong>单点故障</strong></li>\n</ol><p>Percolator通过日志和异步线程的方式弱化了这个问题。</p><p>一是，Percolator引入的异步线程可以在事务管理器宕机后，回滚各个分片上的事务，提供了善后手段，不会让分片上被占用的资源无法释放。</p><p>二是，事务管理器可以用记录日志的方式使自身无状态化，日志通过共识算法同时保存在系统的多个节点上。这样，事务管理器宕机后，可以在其他节点启动新的事务管理器，基于日志恢复事务操作。</p><p>Percolator模型在分布式数据库的工程实践中被广泛借鉴。比如，分布式数据库TiDB，完全按照该模型实现了事务处理；CockroachDB也从Percolator模型获得灵感，设计了自己的2PC协议。</p><p>CockroachDB的变化在于没有随机选择主锁，而是引入了一张全局事务表，所有分片记录的指针指向了这个事务表中对应的事务记录。单就原子性处理来说，这种设计似乎差异不大，但在相关设计上会更有优势，具体是什么优势呢，下一讲我来揭晓答案。</p><h3>PGXC阵营：GoldenDB的一阶段提交</h3><p>那么，分布式数据库的另一大阵营，PGXC，又如何解决2PC的问题呢？</p><p>GoldenDB展现了另外一种改良思路，称之为“一阶段提交”。</p><p>GoldenDB遵循PGXC架构，包含了四种角色：协调节点、数据节点、全局事务器和管理节点，其中协调节点和数据节点均有多个。GoldenDB的数据节点由MySQL担任，后者是独立的单体数据库。</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/70/0fa31de65b7c81yydda0d319ebe06070.jpg?wh=2700*1122\" alt=\"9.11\"></p><p>虽然名字叫“一阶段提交”，但GoldenDB的流程依然可以分为两个阶段。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/e2/142b33b069b60562f89acdb83c3346e2.jpg?wh=2700*641\" alt=\"9.12\"></p><p>第一阶段，GoldenDB的协调节点接到事务后，在全局事务管理器（GTM）的全局事务列表中将事务标记成活跃的状态。这个标记过程是GoldenDB的主要改进点，实质是通过全局事务列表来申请资源，规避可能存在的事务竞争。</p><p>这样的好处是避免了与所有参与者的通讯，也减少了很多无效的资源锁定动作。</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/f3/f65854eceef3335edc3b8930879115f3.jpg?wh=2700*1202\" alt=\"\"></p><p>第二阶段，协调节点把一个全局事务分拆成若干子事务，分配给对应的MySQL去执行。如果所有操作成功，协调者节点会将全局事务列表中的事务标记为结束，整个事务处理完成。如果失败，子事务在单机上自动回滚，而后反馈给协调者节点，后者向所有数据节点下发回滚指令。</p><p><strong>由于GoldenDB属于商业软件，公开披露信息有限，我们也就不再深入细节了，你只要能够理解上面我讲的两个阶段就够了。</strong></p><p>GoldenDB的“一阶段提交”，本质上是改变了资源的申请方式，更准确的说法是，并发控制手段从锁调度变为时间戳排序（Timestamp Ordering）。这样，在正常情况下协调节点与数据节点只通讯一次，降低了网络不确定性的影响，数据库的整体性能有明显提升。因为第一阶段不涉及数据节点的操作，也就弱化了数据一致性和单点故障的问题。</p><h2>小结</h2><p>好了，以上就是今天的主要内容了，我希望你能记住以下几点：</p><ol>\n<li>事务的原子性就是让包含若干操作的事务表现得像一个最小粒度的操作，而这个操作一旦被执行只有两种结果，成功或者失败。</li>\n<li>相比于单机事务，分布式事务原子性的复杂之处在于增加了多物理设备和网络的不确定性，需要通过一定的算法和协议来实现。这类协议也有不少，我重点介绍了TCC和2PC这两个常用协议。</li>\n<li>TCC提供了一个应用层的分布式事务框架，它对参与者没有特定要求，但有较强的业务侵入；2PC是专为数据库这样的资源层设计的，不侵入业务，也是今天分布式数据库主流产品的选择。</li>\n<li>考虑到2PC的重要性和人们对其实用价值的误解，我又展开说明2PC的两种改良模型，分别是Percolator和GoldenDB的“一阶段提交”。Percolator将2PC第二阶段工作简化到极致，减少了与参与者的通讯，完美解决了一致性问题，同时通过日志和异步线程弱化了单点故障问题。GoldenDB则改良了2PC第一阶段的资源协调过程，将协调者与多个参与者的交互转换为协调者与全局事务管理器的交互，同样达到了减少通讯的效果，弱化了一致性和单点故障的问题。</li>\n</ol><p>这节课马上就要结束了，你可能要问，为什么咱们没学三阶段提交协议（Three-Phase Commit，3PC）呢？</p><p>原因也很简单，因为3PC虽然试图解决2PC的问题，但它的通讯开销更大，在网络分区时也无法很好地工作，很少在工程实践中使用，所以我就没有介绍，你只要知道有这么个协议就好。</p><p>另外，我还要提示一个容易与2PC协议混淆的概念，也就是两阶段封锁协议（Two-Phase Locking，2PL）。</p><p>我认为，这种混淆并不只是因为名字相似。从整个分布式事务看，原子性协议之外还有一层隔离性协议，由后者保证事务能够成功申请到资源。在相当长的一段时间里，2PC与2PL的搭配都是一种主流实现方式，可能让人误以为它们是可以替换的术语。实际上，两者是截然不同的，2PC是原子性协议，而2PL是一种事务的隔离性协议，也是一种并发控制算法。</p><p>在这一节中，其实我们多次提到了并发控制算法，但都没有展开介绍，原因是这部分内容确实比较复杂，没办法用三言两语说清，我会在后面第13讲和第14讲中详细解释。</p><p>两种改良模型都一定程度上化解了2PC的单点故障和数据一致性问题，但同步阻塞导致的性能问题还没有根本改善，而这也是2PC最被诟病的地方，可能也是很多人放弃分布数据库的理由。</p><p>可是，2PC注定就是延时较长、性能差吗？或者说分布式数据库中的分布式事务，延时一定很长吗？</p><p>我想告诉你的是，其实不少优秀的分布式数据库产品已经大幅缩短了2PC的延时，无论是理论模型还是工程实践都已经过验证。</p><p>那么，它们又有哪些精巧构思呢？我将在下一讲为你介绍这些黑科技。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/91/0a676d16295d91870a30caa1fccd4c91.jpg?wh=2700*2715\" alt=\"\"></p><h2>思考题</h2><p>最后，我给你留下一个思考题。今天内容主要围绕着2PC展开，而它的第一阶段“准备阶段”也被称为“投票阶段”，“投票”这个词是不是让你想到Paxos协议呢？</p><p>那么，你觉得2PC和Paxos协议有没有关系，如果有又是什么关系呢？</p><p>如果你想到了答案，又或者是触发了你对相关问题的思考，都可以在评论区和我聊聊，我会在下一讲和你一起探讨。最后，谢谢你的收听，希望这节课能带给你一些收获，欢迎你把它分享给周围的朋友，一起进步。</p><h2>学习资料</h2><p>Daniel Peng and Frank Dabek: <a href=\"https://www.cs.princeton.edu/courses/archive/fall10/cos597B/papers/percolator-osdi10.pdf\"><em>Large-scale Incremental Processing Using Distributed Transactions and Notifications</em></a></p><p>Jim Gray: <a href=\"https://cs.nyu.edu/courses/fall18/CSCI-GA.3033-002/papers/Gray1978.pdf\"><em>Notes on Data Base Operating Systems</em></a></p>","neighbors":{"left":{"article_title":"08 | 基础篇大串讲：重难点回顾+思考题答疑+知识全景图","id":277741},"right":{"article_title":"10 | 原子性：如何打破事务高延迟的魔咒？","id":279660}},"comments":[{"had_liked":false,"id":244607,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1598593795,"is_pvip":true,"replies":[{"id":"90528","content":"是的，赞。还有延伸内容，同样建议关注第15讲。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599291478,"ip_address":"","comment_id":244607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57433168643","product_id":100057401,"comment_content":"paxos是共识算法，是对同一份数据的达成共识。2pc更多是为了达成的多份不同数据修改的原子性。不知道这样理解对不？","like_count":14,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504634,"discussion_content":"是的，赞。还有延伸内容，同样建议关注第15讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599291478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245985,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1001947,"ip_address":"","ucode":"1813E7F86A17E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/db/1d669080.jpg","comment_is_top":false,"comment_ctime":1599125563,"is_pvip":true,"replies":[{"id":"90526","content":"问题1，如果单元A成功，单元B失败，则面临一个选择。如果以努力成功为目标，则可以再次向单元B发送指令，有可能成功，这也是为什么要求操作具有幂等性。当然也可以直接撤销A操作，是A与B一样都是失败状态，这种就是失败回滚。<br>问题2，没有收到应答，其实也和问题1类似，重试争取成功，或者直接回滚。但这里面有个问题是，如果无论发送任何指令，单元B始终也没有返回，怎么办。这个时候基本上就是要人工干预了。当然，对于这种网络通讯故障也不是没有解决办法，有种协议叫做Paxos Commmit，可以极大缓解这个问题，我会在第15讲答疑篇详细介绍，你可以关注下。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599289772,"ip_address":"","comment_id":245985,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31663896635","product_id":100057401,"comment_content":"请问老师，TCC 第二阶段<br>1. 如果向单元 A 发出 confirm 操作成功且收到成功应答，但向单元 B 发出 confirm 操作失败，这时是否需要通过其它手段来回滚（或者补偿） A 的变更呢？<br>2. 如果向单元 A 发出 confirm 操作成功且收到成功应答，向单元 B 发出 confirm 操作成功，但没有收到成功应答，是否应该先确认 B 的状态，然后再决定是否需要回滚（或者补偿）A 的变更呢？<br><br>对于上面2中情况，通常是怎么做的呢？通过分析日志发现异常然后处理吗？","like_count":7,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505029,"discussion_content":"问题1，如果单元A成功，单元B失败，则面临一个选择。如果以努力成功为目标，则可以再次向单元B发送指令，有可能成功，这也是为什么要求操作具有幂等性。当然也可以直接撤销A操作，是A与B一样都是失败状态，这种就是失败回滚。\n问题2，没有收到应答，其实也和问题1类似，重试争取成功，或者直接回滚。但这里面有个问题是，如果无论发送任何指令，单元B始终也没有返回，怎么办。这个时候基本上就是要人工干预了。当然，对于这种网络通讯故障也不是没有解决办法，有种协议叫做Paxos Commmit，可以极大缓解这个问题，我会在第15讲答疑篇详细介绍，你可以关注下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599289772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303651,"discussion_content":"所以这里的a，b不是说的就一台机器，paxos组的话，失败的概率会低很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599323612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2119634,"avatar":"https://static001.geekbang.org/account/avatar/00/20/57/d2/f19e849d.jpg","nickname":"可爱の哆","note":"","ucode":"A3E7919D242776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303519,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599289993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244620,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1598597245,"is_pvip":false,"replies":[{"id":"90281","content":"TCC可使用的手段更灵活，不限于数据库锁了。比如，可以增加一个“未冻结余额”字段，初始值和余额一样，一阶段时直接在这个字段上扣减金额，这样后发生的事务如果发现剩下的“未冻结余额”不够，就会返回失败，这样多事务就可以协同了。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1598961452,"ip_address":"","comment_id":244620,"utype":1}],"discussion_count":5,"race_medal":0,"score":"23073433725","product_id":100057401,"comment_content":"老师不是很理解为什么TCC就不用像2PC那样加锁和记日志了呢？TCC如何保证事务隔离性呢？如果有其他代码修改同一行数据怎么办？","like_count":5,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504639,"discussion_content":"TCC可使用的手段更灵活，不限于数据库锁了。比如，可以增加一个“未冻结余额”字段，初始值和余额一样，一阶段时直接在这个字段上扣减金额，这样后发生的事务如果发现剩下的“未冻结余额”不够，就会返回失败，这样多事务就可以协同了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598961452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299763,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d5/33/d79fae5c.jpg","nickname":"Hommin","note":"","ucode":"C020CA5DE785DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395943,"discussion_content":"其实这就相当于在业务中手动加锁。数据库的锁是让其他的&#34;selelct for update&#34;无法访问该行数据，而“冻结余额”字段则是将部分资源移到小黑屋里面让其他的查询请求无法访问到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632365699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114356,"avatar":"https://static001.geekbang.org/account/avatar/00/11/00/f4/cc5f0896.jpg","nickname":"Jowin","note":"","ucode":"19017F7D06C22A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349944,"discussion_content":"tcc和2PC的区别主要是两点：一是实现层面不一样，tcc应用层，2PC在DB；二是实现手段不一样，2PC完全依赖DB资源锁定，tcc因为在应用实现，就可以有更多手段，不一定依赖DB资源锁定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613637667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066372,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/84/b8fae908.jpg","nickname":"myco 前","note":"","ucode":"A39FC9D8325154","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302385,"discussion_content":"tcc和业务逻辑强绑定，try阶段预留出足够的资源，比如转账先冻结要转出的金额；冻结以后这行数据能否被继续修改完全由业务逻辑决定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598898378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103764,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/94/063405ef.jpg","nickname":"亮亮","note":"","ucode":"1637C4A17BD7B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302354,"discussion_content":"我理解try阶段就加了锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598884808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268361,"user_name":"xyx","can_delete":false,"product_type":"c1","uid":2250114,"ip_address":"","ucode":"1AECC9DDAC3D11","user_header":"https://static001.geekbang.org/account/avatar/00/22/55/82/985411a8.jpg","comment_is_top":false,"comment_ctime":1608168956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14493070844","product_id":100057401,"comment_content":"2pc是为了保证事务内的多个操作原子性以达到数据一致性<br><br>paxos&#47;raft是保证多个副本数据之间的一致性<br><br>早期时候还真把写两者当作上下文优化关系去理解了…","like_count":3},{"had_liked":false,"id":283912,"user_name":"daka","can_delete":false,"product_type":"c1","uid":1307998,"ip_address":"","ucode":"A23D82FF956793","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8ibLXicovSNwEJhP4BOIPxEMle1ZUq1He58xztgBXTQFicdp5m5ibRHwUSoUVk5xQMWFwFXhp56ibm1Q/132","comment_is_top":false,"comment_ctime":1615981420,"is_pvip":false,"replies":[{"id":"103113","content":"谢谢你的肯定。这个专栏是跳出某个具体产品来讲原理，所以还是很挑听众的，能在每讲都有所收获，说明你也更厉害啊，点赞。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1616156161,"ip_address":"","comment_id":283912,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10205916012","product_id":100057401,"comment_content":"老师的水平非常高啊，每看一讲都有收获，强推","like_count":3,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517178,"discussion_content":"谢谢你的肯定。这个专栏是跳出某个具体产品来讲原理，所以还是很挑听众的，能在每讲都有所收获，说明你也更厉害啊，点赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616156161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247543,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1599738063,"is_pvip":false,"replies":[{"id":"90913","content":"第一个问题，如果只实现“用主锁来控制事务的原子性，从锁保留指向主锁的指针”这个设计，那确实不一定要用MVCC。Percolator是一个工业实现，它要解决自己的业务需求，除了原子性还有隔离性要处理，使用了MVCC还可以解决读写冲突嘛。<br>第二个问题，我觉得是设计细节，采用其他形式应该也是可以的。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599746653,"ip_address":"","comment_id":247543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10189672655","product_id":100057401,"comment_content":"感觉老师这里可以对Percolator的设计思想再阐述得更详细一些：<br>1. 为什么需要MVCC来实现percolator?或者说为什么要保存多个版本的key才能实现percolator?<br>2. 为什么要有个write指向实际数据存储的行？而不是直接存储对应数据？","like_count":2,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505431,"discussion_content":"第一个问题，如果只实现“用主锁来控制事务的原子性，从锁保留指向主锁的指针”这个设计，那确实不一定要用MVCC。Percolator是一个工业实现，它要解决自己的业务需求，除了原子性还有隔离性要处理，使用了MVCC还可以解决读写冲突嘛。\n第二个问题，我觉得是设计细节，采用其他形式应该也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599746653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246815,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1599485095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894452391","product_id":100057401,"comment_content":"这个思考题我延伸到Raft思考一下：<br>Raft里面基于Leader的复制是否就是一种2PC呢？有写请求时，Leader先发给大多数节点，成功再写入。但是又好像不完全一样。面试的时候面试官也说这不是2PC。","like_count":1},{"had_liked":false,"id":245853,"user_name":"myrfy","can_delete":false,"product_type":"c1","uid":1169401,"ip_address":"","ucode":"2814BAE5D70098","user_header":"","comment_is_top":false,"comment_ctime":1599094946,"is_pvip":false,"replies":[{"id":"90408","content":"从公开资料看，也没有太特别的设计，就是把这个进程独立部署，这样不会与其他任务竞争资源。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599108398,"ip_address":"","comment_id":245853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5894062242","product_id":100057401,"comment_content":"老师，GlodenDB如何避免全局管理器成为瓶颈呢？","like_count":2,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504994,"discussion_content":"从公开资料看，也没有太特别的设计，就是把这个进程独立部署，这样不会与其他任务竞争资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599108398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245488,"user_name":"南国","can_delete":false,"product_type":"c1","uid":1897062,"ip_address":"","ucode":"0D8D3C5F4EB8AE","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f2/66/b16f9ca9.jpg","comment_is_top":false,"comment_ctime":1598957632,"is_pvip":false,"replies":[{"id":"90805","content":"我觉得2PC还不是共识算法，因为参与者并不是对一件事情（一个状态）投票，而是要让多个独立的状态要保持一致，且参与者并不了解这种一致性。可以参照15讲的Paxos Commit协议再体会下。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599647496,"ip_address":"","comment_id":245488,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5893924928","product_id":100057401,"comment_content":"感觉2PC和Basic-Paxos的过程好像啊，第一阶段的区别是2PC需要全部的回复，而Paxos只需要一半以上的Acceptor回复；第二阶段就几乎一模一样了。至于为什么第一阶段有这样的区别，大概是2PC的每一个节点职能（包括数据）都不相同，要满足一致性约束必须全部的节点的同意；而Paxos抛去每个节点角色不同，它们存储的数据都一样（理想中一致，实际不一致，Paxos会出现日志空缺），为了全局一致，一次同意一半以上就可以了，因为两次一半以上一定是有交集的，这保证了paxos需要的一致性。<br><br>至于它们的关系，我觉得它们都是共识算法（consensus），适用前提区别在于节点职能是否相同。","like_count":1,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504896,"discussion_content":"我觉得2PC还不是共识算法，因为参与者并不是对一件事情（一个状态）投票，而是要让多个独立的状态要保持一致，且参与者并不了解这种一致性。可以参照15讲的Paxos Commit协议再体会下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599647496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244980,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1598772385,"is_pvip":true,"replies":[{"id":"90224","content":"如果加了secondary锁，其他事务确实会读取到，是为了追溯事务状态，再决定读取哪个版本。而在异步线程或第一个读操作维护好状态后，就不再是私有版本了，所以我们说“通常其他事务不能读写”","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1598926292,"ip_address":"","comment_id":244980,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5893739681","product_id":100057401,"comment_content":"关于Percolator，文中提到“在 lock 字段上写入了标识信息的记录就是私有版本，只有当前事务能够操作”，而在例子中又有其他事务读到了私有版本的数据，这是为什么呢？","like_count":1,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504756,"discussion_content":"如果加了secondary锁，其他事务确实会读取到，是为了追溯事务状态，再决定读取哪个版本。而在异步线程或第一个读操作维护好状态后，就不再是私有版本了，所以我们说“通常其他事务不能读写”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598926292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244549,"user_name":"chenchukun","can_delete":false,"product_type":"c1","uid":1298833,"ip_address":"","ucode":"C9F9D51F2EC7A0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibtic993snK2Drdwypz6SJajPk7g3JuEP1puDhomplXSGl9YobOp5uJZVGLRalHwNwS7cdHr3iasFbmz38GicNibknA/132","comment_is_top":false,"comment_ctime":1598576398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893543694","product_id":100057401,"comment_content":"个人的理解是paxos可以用于解决2PC的单点故障和数据不一致问题，协调者和参与者利用paxos实现多副本一致，在节点宕机后可切换到副本节点继续完成2PC流程。<br>今天讲的内容，Percolator很好理解，很好的解决了传统2PC存在的问题。<br>但是对于PGXC的解决方案还是不明白，几个问题请教一下老师，或者请老师帮忙推荐一下相关学习资料。<br>1、PGXC中分布式事务的实现是不是也是基于单体数据库的XA事务来实现的？像MYSQL的XA要避免脏读是需要工作在可串行级别下的，若是使用XA如何解决XA的性能问题呢？<br>2、关于利用GTM实现资源分配这点不是很理解，是指由GTM负责从SQL中解析出事务要读写的数据，然后判断读写冲突吗？<br>3、在MYSQL中事务在提交前是不会写binlog的，是不是意味着MYSQL实现分布式数据库就没办法利用binlog进行主备同步了，因为若2PC的提交阶段，某个节点宕机后不恢复，没办法利用备库继续执行。<br>4、PGXC类型的分布式数据库，是不是需要实现在并发执行多个事务时，保证所有节点按照相同的顺序执行SQL？这个问题看起来也很复杂，没想明白。","like_count":1},{"had_liked":false,"id":327011,"user_name":"杜思奇","can_delete":false,"product_type":"c1","uid":2865281,"ip_address":"","ucode":"390D2D5045AE95","user_header":"https://static001.geekbang.org/account/avatar/00/2b/b8/81/a0afe928.jpg","comment_is_top":false,"comment_ctime":1639836320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639836320","product_id":100057401,"comment_content":"Paxos协议与2PC协议在分布式数据库中起到的作用并不相同。Paxos协议用于保证同一数据分片的多个副本之间的数据一致性。当这些副本分不到不同的节点上时，这个需求尤其强烈。2PC协议用于保证属于多个数据分片上的操作的原子性。","like_count":0},{"had_liked":false,"id":304127,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1627266081,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1627266081","product_id":100057401,"comment_content":"Percolator的设计中，对于不是转账这种场景 A-&gt;B 的这种关系的，主锁应该怎么选择？","like_count":0,"discussions":[{"author":{"id":1076487,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIKoEicqUZTJly55qoUXRmK4wia7YbnibsMncJaO6tKgKAQNJRfpMsibvfeiaukIibsCsuaic8QjQ3gOoTGA/132","nickname":"张可夫斯基","note":"","ucode":"3B8DF6D98583F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554533,"discussion_content":"Primary Lock是在事务涉及的Row里随机选的，无需特别指定是哪个。 Primary Lock主要与commit行结合起来，判断事务是否是成功、进行中、还是已经失败了，其中成功很好判断，有commit行就表示已经成功，进行中和失败就不好判断了，不过percolator另辟蹊径，在另一个事务需要操作的行中如果还有锁，就会启动清理锁机制，清理锁要先将以前事务的Primary Lock删掉（字段值置为空），如果以前事务还在进行中，提交时也会删除Primary Lock，这两个操作就会互斥，只有一个会成功。然后各事务根据相关情况去做后续处理。 具体可以参考https://segmentfault.com/a/1190000040716583。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646451878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282121,"user_name":"唐名之","can_delete":false,"product_type":"c1","uid":1004394,"ip_address":"","ucode":"F472C71E043E03","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/JKKWS6TzhncvAA0p0NDiaATPIvMicSM76vNAg9IG1ibibcJYPAiaicYjZfq4gAV8GRtcTpOibfRD8vzqHBtL0ibmhwQsbg/132","comment_is_top":false,"comment_ctime":1615097215,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1615097215","product_id":100057401,"comment_content":"因为分片 P2 的最后一条记录，保存了指向主锁的指针。其他事务读取到 Hong7 这条记录时，会根据指针去查找 Ming.bal，发现记录已经提交，所以小红的记录虽然是私有版本格式，但仍然可视为已经生效了。 <br><br>分片二这儿的ming.bal如何查询到事务已经提交？","like_count":0,"discussions":[{"author":{"id":1004394,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/JKKWS6TzhncvAA0p0NDiaATPIvMicSM76vNAg9IG1ibibcJYPAiaicYjZfq4gAV8GRtcTpOibfRD8vzqHBtL0ibmhwQsbg/132","nickname":"唐名之","note":"","ucode":"F472C71E043E03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356282,"discussion_content":"老师能帮忙解答下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615559321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278995,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1613529924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613529924","product_id":100057401,"comment_content":"能不能说 2PC就是在数据库层面实现TCC的逻辑？相当于把 应用层的逻辑在数据库层实现了，这样应用层就不用重复实现，也避免了分布式提交对应用的侵入？","like_count":0},{"had_liked":false,"id":246432,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1599323905,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599323905","product_id":100057401,"comment_content":"paxos提供可靠性，2pc提供原子性，所以3pc没优势？","like_count":0},{"had_liked":false,"id":246431,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1599323438,"is_pvip":true,"replies":[{"id":"90585","content":"理论上是不会的。GoldenDB是通过全局事务列表统一控制，数据节点（也就是单体数据库）基于日志实现回滚。TCC只要三个操作都正确实现，理论上也不会出现中间状态。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599387098,"ip_address":"","comment_id":246431,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599323438","product_id":100057401,"comment_content":"tcc和goden的方式隔离性有问题吧？ 都可能出现读中间状态的情况","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505140,"discussion_content":"理论上是不会的。GoldenDB是通过全局事务列表统一控制，数据节点（也就是单体数据库）基于日志实现回滚。TCC只要三个操作都正确实现，理论上也不会出现中间状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599387098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246163,"user_name":"Bryant.C","can_delete":false,"product_type":"c1","uid":1172363,"ip_address":"","ucode":"0DF832373CFA97","user_header":"https://static001.geekbang.org/account/avatar/00/11/e3/8b/27f875ba.jpg","comment_is_top":false,"comment_ctime":1599194453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599194453","product_id":100057401,"comment_content":"自己认为2pc更像是一种思想，多个节点对某件事达成共识，其实paxos完成的也是类似的行为，就单个操作在多副本上达成一致或共识，因此借鉴了2pc思想","like_count":0},{"had_liked":false,"id":244786,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1598676133,"is_pvip":false,"replies":[{"id":"90411","content":"嗯，这个场景比较适合TCC","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599111929,"ip_address":"","comment_id":244786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598676133","product_id":100057401,"comment_content":"还有，最近有一个业务，涉及到两个的系统，业务也要求两个系统必须都成功或者都失败，通过报文交互，正好适合TCC这种业务层面的协议","like_count":0,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504701,"discussion_content":"嗯，这个场景比较适合TCC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599111929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244784,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1598675402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598675402","product_id":100057401,"comment_content":"我的理解是2PC中的任何一个节点都是逻辑的，可以有多个物理节点组成，PAXOS可以让这个逻辑节点内部的值达成一致，就是各种一致性模型。<br><br>而2PC是解决分布式的事物，参与的各个节点的值是不一样的，比如小明节点的余额是2900，而小红节点的余额是2300","like_count":0},{"had_liked":false,"id":244697,"user_name":"李鑫磊","can_delete":false,"product_type":"c1","uid":1101615,"ip_address":"","ucode":"D06517CFCEEE00","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","comment_is_top":false,"comment_ctime":1598620269,"is_pvip":false,"replies":[{"id":"90527","content":"是的，点赞。不过两者也可以联系起来看，我在第15讲会有详细说明。","user_name":"作者回复","user_name_real":"王磊(Ivan)","uid":"1602401","ctime":1599291409,"ip_address":"","comment_id":244697,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598620269","product_id":100057401,"comment_content":"2PC 解决的是：<br>1）小明账户 - 100；<br>2）小红账户 + 100；<br>3）小明和小红账户信息存储在不同的数据库实例中；<br>Basic Paxos 解决的问题：<br>1）客户端不停的有 a=xxx 这样的操作；<br>2）Basic Paxos 就是让多个节点就 x 的值达成一致；<br>3）说白了就是数据在多副本之间的复制；<br>不知道我的理解对不对？","like_count":1,"discussions":[{"author":{"id":1602401,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/61/3059679f.jpg","nickname":"王磊(Ivan)","note":"","ucode":"CF0B955A06FE2A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504668,"discussion_content":"是的，点赞。不过两者也可以联系起来看，我在第15讲会有详细说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599291409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244586,"user_name":"伟伟哦","can_delete":false,"product_type":"c1","uid":1394961,"ip_address":"","ucode":"51E5FC28E6F0B3","user_header":"https://static001.geekbang.org/account/avatar/00/15/49/11/31d961a1.jpg","comment_is_top":false,"comment_ctime":1598585984,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1598585984","product_id":100057401,"comment_content":"老师课程 TCC、3cp、2pc这些，或者以后课程， 可以接入下代码吗？","like_count":0,"discussions":[{"author":{"id":1905171,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","nickname":"扩散性百万咸面包","note":"","ucode":"6D703D51553B42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301647,"discussion_content":"如果是伪代码的话，其实已经有了。如果是实际的TiDB之类的代码的话，可能一两个片段不好说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598597182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}