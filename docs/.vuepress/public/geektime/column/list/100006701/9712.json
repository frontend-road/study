{"id":9712,"title":"第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？","content":"<p>我在<a href=\"http://time.geekbang.org/column/article/9103\">专栏第17讲</a>中介绍过线程是不能够重复启动的，创建或销毁线程存在一定的开销，所以利用线程池技术来提高系统资源利用效率，并简化线程管理，已经是非常成熟的选择。</p><p>今天我要问你的问题是，<span class=\"orange\">Java并发类库提供的线程池有哪几种？ 分别有什么特点？</span></p><h2>典型回答</h2><p>通常开发者都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的ExecutorService类型或者不同的初始参数。</p><p>Executors目前提供了5种不同的线程池创建配置：</p><ul>\n<li>\n<p>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。</p>\n</li>\n<li>\n<p>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</p>\n</li>\n<li>\n<p>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</p>\n</li>\n<li>\n<p>newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</p>\n</li>\n<li>\n<p>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8才加入这个创建方法，其内部会构建<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html\">ForkJoinPool</a>，利用<a href=\"https://en.wikipedia.org/wiki/Work_stealing\">Work-Stealing</a>算法，并行地处理任务，不保证处理顺序。</p>\n</li>\n</ul><!-- [[[read_end]]] --><h2>考点分析</h2><p>Java并发包中的Executor框架无疑是并发编程中的重点，今天的题目考察的是对几种标准线程池的了解，我提供的是一个针对最常见的应用方式的回答。</p><p>在大多数应用场景下，使用Executors提供的5个静态工厂方法就足够了，但是仍然可能需要直接利用ThreadPoolExecutor等构造函数创建，这就要求你对线程构造方式有进一步的了解，你需要明白线程池的设计和结构。</p><p>另外，线程池这个定义就是个容易让人误解的术语，因为ExecutorService除了通常意义上“池”的功能，还提供了更全面的线程管理、任务提交等方法。</p><p>Executor框架可不仅仅是线程池，我觉得至少下面几点值得深入学习：</p><ul>\n<li>\n<p>掌握Executor框架的主要内容，至少要了解组成与职责，掌握基本开发用例中的使用。</p>\n</li>\n<li>\n<p>对线程池和相关并发工具类型的理解，甚至是源码层面的掌握。</p>\n</li>\n<li>\n<p>实践中有哪些常见问题，基本的诊断思路是怎样的。</p>\n</li>\n<li>\n<p>如何根据自身应用特点合理使用线程池。</p>\n</li>\n</ul><h2>知识扩展</h2><p>首先，我们来看看Executor框架的基本组成，请参考下面的类图。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/5b/fc70c37867c7fbfb672fa3e37fe14b5b.png?wh=757*456\" alt=\"\"></p><p>我们从整体上把握一下各个类型的主要设计目的：</p><ul>\n<li>Executor是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。</li>\n</ul><pre><code>void execute(Runnable command);\n</code></pre><p>Executor的设计是源于Java早期线程API使用的教训，开发者在实现应用逻辑时，被太多线程创建、调度等不相关细节所打扰。就像我们进行HTTP通信，如果还需要自己操作TCP握手，开发效率低下，质量也难以保证。</p><ul>\n<li>ExecutorService则更加完善，不仅提供service的管理功能，比如shutdown等方法，也提供了更加全面的提交任务机制，如返回<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Future.html\">Future</a>而不是void的submit方法。</li>\n</ul><pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);\n</code></pre><p>注意，这个例子输入的可是<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Callable.html\">Callable</a>，它解决了Runnable无法返回结果的困扰。</p><ul>\n<li>\n<p>Java标准类库提供了几种基础实现，比如<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.html\">ThreadPoolExecutor</a>、<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html\">ScheduledThreadPoolExecutor</a>、<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html\">ForkJoinPool</a>。这些线程池的设计特点在于其高度的可调节性和灵活性，以尽量满足复杂多变的实际应用场景，我会进一步分析其构建部分的源码，剖析这种灵活性的源头。</p>\n</li>\n<li>\n<p>Executors则从简化使用的角度，为我们提供了各种方便的静态工厂方法。</p>\n</li>\n</ul><p>下面我就从源码角度，分析线程池的设计与实现，我将主要围绕最基础的ThreadPoolExecutor源码。ScheduledThreadPoolExecutor是ThreadPoolExecutor的扩展，主要是增加了调度逻辑，如想深入了解，你可以参考相关<a href=\"https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example\">教程</a>。而ForkJoinPool则是为ForkJoinTask定制的线程池，与通常意义的线程池有所不同。</p><p>这部分内容比较晦涩，罗列概念也不利于你去理解，所以我会配合一些示意图来说明。在现实应用中，理解应用与线程池的交互和线程池的内部工作过程，你可以参考下图。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/65/18b64aee22c67f488171a73133e4d465.png?wh=1072*482\" alt=\"\"></p><p>简单理解一下：</p><ul>\n<li>工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为0的SynchronousQueue（使用newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用LinkedBlockingQueue。</li>\n</ul><pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;\n\n</code></pre><ul>\n<li>内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认60秒）后结束线程。</li>\n</ul><pre><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();\n</code></pre><p>线程池的工作线程被抽象为静态内部类Worker，基于<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html\">AQS</a>实现。</p><ul>\n<li>\n<p>ThreadFactory提供上面所需要的创建线程逻辑。</p>\n</li>\n<li>\n<p>如果任务提交时被拒绝，比如线程池已经处于SHUTDOWN状态，需要为其提供处理逻辑，Java标准库提供了类似<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html\">ThreadPoolExecutor.AbortPolicy</a>等默认实现，也可以按照实际需求自定义。</p>\n</li>\n</ul><p>从上面的分析，就可以看出线程池的几个基本组成部分，一起都体现在线程池的构造函数中，从字面我们就可以大概猜测到其用意：</p><ul>\n<li>\n<p>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目（除非设置了allowCoreThreadTimeOut）。对于不同的线程池，这个值可能会有很大区别，比如newFixedThreadPool会将其设置为nThreads，而对于newCachedThreadPool则是为0。</p>\n</li>\n<li>\n<p>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数。同样进行对比，对于newFixedThreadPool，当然就是nThreads，因为其要求是固定大小，而newCachedThreadPool则是Integer.MAX_VALUE。</p>\n</li>\n<li>\n<p>keepAliveTime和TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。</p>\n</li>\n<li>\n<p>workQueue，工作队列，必须是BlockingQueue。</p>\n</li>\n</ul><p>通过配置不同的参数，我们就可以创建出行为大相径庭的线程池，这就是线程池高度灵活性的基础。</p><pre><code>public ThreadPoolExecutor(int corePoolSize,\n                      \tint maximumPoolSize,\n                      \tlong keepAliveTime,\n                      \tTimeUnit unit,\n                      \tBlockingQueue&lt;Runnable&gt; workQueue,\n                      \tThreadFactory threadFactory,\n                      \tRejectedExecutionHandler handler)\n\n</code></pre><p>进一步分析，线程池既然有生命周期，它的状态是如何表征的呢？</p><p>这里有一个非常有意思的设计，ctl变量被赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。试想，实际系统中，虽然我们可以指定线程极限为Integer.MAX_VALUE，但是因为资源限制，这只是个理论值，所以完全可以将空闲位赋予其他意义。</p><pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n// 真正决定了工作线程数的理论上限 \nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int COUNT_MASK = (1 &lt;&lt; COUNT_BITS) - 1;\n// 线程池状态，存储在数字的高位\nprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;\n…\n// Packing and unpacking ctl\nprivate static int runStateOf(int c)  { return c &amp; ~COUNT_MASK; }\nprivate static int workerCountOf(int c)  { return c &amp; COUNT_MASK; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n</code></pre><p>为了让你能对线程生命周期有个更加清晰的印象，我这里画了一个简单的状态流转图，对线程池的可能状态和其内部方法之间进行了对应，如果有不理解的方法，请参考Javadoc。<strong>注意</strong>，实际Java代码中并不存在所谓Idle状态，我添加它仅仅是便于理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/a1/c50ce5f2ff4ae723c6267185699ccda1.png?wh=840*626\" alt=\"\"></p><p>前面都是对线程池属性和构建等方面的分析，下面我选择典型的execute方法，来看看其是如何工作的，具体逻辑请参考我添加的注释，配合代码更加容易理解。</p><pre><code>public void execute(Runnable command) {\n…\n\tint c = ctl.get();\n// 检查工作线程数目，低于corePoolSize则添加Worker\n\tif (workerCountOf(c) &lt; corePoolSize) {\n    \tif (addWorker(command, true))\n        \treturn;\n    \tc = ctl.get();\n\t}\n// isRunning就是检查线程池是否被shutdown\n// 工作队列可能是有界的，offer是比较友好的入队方式\n\tif (isRunning(c) &amp;&amp; workQueue.offer(command)) {\n    \tint recheck = ctl.get();\n// 再次进行防御性检查\n    \tif (! isRunning(recheck) &amp;&amp; remove(command))\n        \treject(command);\n    \telse if (workerCountOf(recheck) == 0)\n        \taddWorker(null, false);\n\t}\n// 尝试添加一个worker，如果失败意味着已经饱和或者被shutdown了\n\telse if (!addWorker(command, false))\n    \treject(command);\n}\n</code></pre><p><strong>线程池实践</strong></p><p>线程池虽然为提供了非常强大、方便的功能，但是也不是银弹，使用不当同样会导致问题。我这里介绍些典型情况，经过前面的分析，很多方面可以自然的推导出来。</p><ul>\n<li>\n<p>避免任务堆积。前面我说过newFixedThreadPool是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量系统内存，甚至是出现OOM。诊断时，你可以使用jmap之类的工具，查看是否有大量的任务对象入队。</p>\n</li>\n<li>\n<p>避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的HTTP/2 client API中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是1K 、100K还是1M以上？），所以很难明确设定一个线程数目。</p>\n</li>\n<li>\n<p>另外，如果线程数目不断增长（可以使用jstack等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。</p>\n</li>\n<li>\n<p>避免死锁等同步问题，对于死锁的场景和排查，你可以复习<a href=\"http://time.geekbang.org/column/article/9266\">专栏第18讲</a>。</p>\n</li>\n<li>\n<p>尽量避免在使用线程池时操作ThreadLocal，同样是<a href=\"http://time.geekbang.org/column/article/9103\">专栏第17讲</a>已经分析过的，通过今天的线程池学习，应该更能理解其原因，工作线程的生命周期通常都会超过任务的生命周期。</p>\n</li>\n</ul><p><strong>线程池大小的选择策略</strong></p><p>上面我已经介绍过，线程池大小不合适，太多或太少，都会导致麻烦，所以我们需要去考虑一个合适的线程池大小。虽然不能完全确定，但是有一些相对普适的规则和思路。</p><ul>\n<li>\n<p>如果我们的任务主要是进行计算，那么就意味着CPU的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照CPU核的数目N或者N+1。</p>\n</li>\n<li>\n<p>如果是需要较多等待的任务，例如I/O操作比较多，可以参考Brain Goetz推荐的计算方法：</p>\n</li>\n</ul><pre><code>线程数 = CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间/平均工作时间）\n</code></pre><p>这些时间并不能精准预计，需要根据采样或者概要分析等方式进行计算，然后在实际中验证和调整。</p><ul>\n<li>上面是仅仅考虑了CPU等限制，实际还可能受各种系统资源限制影响，例如我最近就在Mac OS X上遇到了大负载时<a href=\"http://danielmendel.github.io/blog/2013/04/07/benchmarkers-beware-the-ephemeral-port-limit/\">ephemeral端口受限</a>的情况。当然，我是通过扩大可用端口范围解决的，如果我们不能调整资源的容量，那么就只能限制工作线程的数目了。这里的资源可以是文件句柄、内存等。</li>\n</ul><p>另外，在实际工作中，不要把解决问题的思路全部指望到调整线程池上，很多时候架构上的改变更能解决问题，比如利用背压机制的<a href=\"http://www.reactive-streams.org/\">Reactive Stream</a>、合理的拆分等。</p><p>今天，我从Java创建的几种线程池开始，对Executor框架的主要组成、线程池结构与生命周期等方面进行了讲解和分析，希望对你有所帮助。</p><h2>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是从逻辑上理解，线程池创建和生命周期。请谈一谈，如果利用newSingleThreadExecutor()创建一个线程池，corePoolSize、maxPoolSize等都是什么数值？ThreadFactory可能在线程池生命周期中被使用多少次？怎么验证自己的判断？</p><p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p><p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p><p></p>","neighbors":{"left":{"article_title":"第20讲 | 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？","id":9588},"right":{"article_title":"第22讲 | AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？","id":9788}},"comments":[{"had_liked":false,"id":13531,"user_name":"I am a psycho","can_delete":false,"product_type":"c1","uid":1103501,"ip_address":"","ucode":"0B65ECADB378C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/8d/7db04ad3.jpg","comment_is_top":false,"comment_ctime":1529725532,"is_pvip":false,"replies":[{"id":"4586","content":"不错，很棒的总结；<br>我问threadFactory次数，其实是问worker都在什么情况下会被创建，比如，比较特别的，任务抛异常时；随便自定义一个threadfactory，模拟提交任务就能体会到","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529945061,"ip_address":"","comment_id":13531,"utype":1}],"discussion_count":3,"race_medal":0,"score":"250637828700","product_id":100006701,"comment_content":"通过看源码可以得知，core和max都是1，而且通过FinalizableDelegatedExecutorService进行了包装，保证线程池无法修改。同时shutdown方法通过调用interruptIdleWorkers方法，去停掉没有工作的线程，而shutdownNow方法是直接粗暴的停掉所有线程。无论是shutdown还是shutdownNow都不会进行等待，都会直接将线程池状态设置成shutdown或者stop，如果需要等待，需要调用awaitTernination方法。查找了一下threadFactory的使用，只找到了在worker创建的时候，用来初始化了线程。","like_count":59,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419681,"discussion_content":"不错，很棒的总结；\n我问threadFactory次数，其实是问worker都在什么情况下会被创建，比如，比较特别的，任务抛异常时；随便自定义一个threadfactory，模拟提交任务就能体会到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529945061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2781060,"avatar":"","nickname":"Geek_39bdd5","note":"","ucode":"CEC28F9978165F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587603,"discussion_content":"其实意思是线程池的中的线程抛异常了怎么办？异常线程会被回收掉，重新在创建一个新的线程，所以会新调用一次threadfactory","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663166131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384978,"discussion_content":"ExecutorService executorService = newSingleThreadExecutor();\n\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626837559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13539,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1529731749,"is_pvip":true,"replies":[{"id":"4591","content":"任务出异常是要避免","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529945885,"ip_address":"","comment_id":13539,"utype":1}],"discussion_count":3,"race_medal":0,"score":"203393194661","product_id":100006701,"comment_content":"我觉得还有一点很重要，就是放在线程池中的线程要捕获异常，如果直接抛出异常，每次都会创建线程，也就等于线程池没有发挥作用，如果大并发下一直创建线程可能会导致JVM挂掉。最近遇到的一个坑","like_count":48,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419683,"discussion_content":"任务出异常是要避免","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529945885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1091505,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKKOWAmUxaHaPYJbYojcxmXV6dRKicLycqZaCJwkGdAbkBAm37wFXqbiaCHK5qia0GVQMz1eXlx8pic0A/132","nickname":"dellenovo","note":"","ucode":"C0C82721EBD706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578410,"discussion_content":"我尝试了一下，奇怪的是，发现线程抛出的异常会成为task中的outcome属性，没有重现楼主的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656722011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117339,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/9b/0835caf1.jpg","nickname":"大反派","note":"","ucode":"425D85B39D8A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408231,"discussion_content":"没理解，这句话是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635211072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66494,"user_name":"Harry陈祥","can_delete":false,"product_type":"c1","uid":1016584,"ip_address":"","ucode":"EC44D97731116D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/08/91caf5c1.jpg","comment_is_top":false,"comment_ctime":1549947976,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"147578836040","product_id":100006701,"comment_content":"老师您好。有次面试，面试官问：为什么java的线程池当核心线程满了以后，先往blockingQueue中存任务，queue满了以后才会创建非核心线程？ 是在问，为什么要这么设计？<br>请问这个问题应该怎么回答？","like_count":35,"discussions":[{"author":{"id":1595176,"avatar":"https://static001.geekbang.org/account/avatar/00/18/57/28/be7550d2.jpg","nickname":"mo","note":"","ucode":"FB3E8C827BE5CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190609,"discussion_content":"\n举个例子，5个程序员开发5个需求，能有条不紊地开发，加入又来了3个需求，排下期，5个开发依旧能搞定，但这个时候忽然又来了10个需求，5个程序员超负荷运转也完成不了，这个时候怎么办呢，该招人了吧。但是招人也是需要到一定条件才招的，不是来一个需求就需要招一个人，到时候需求开发完了，新招的人裁掉是要付很大代价的。猜想线程池的原理也大概如此，核心池满了后新来一任务就新开一线程处理，直到撑到最大线程数，到时候一空闲下来又得销毁，线程池经历这频繁地创建与销毁，性能也会有所损失，而有效地先利用等待队列，则能发挥出线程池原本的能力","likes_number":64,"is_delete":false,"is_hidden":false,"ctime":1582965435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1294453,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c0/75/92b953a5.jpg","nickname":"澤","note":"","ucode":"AFD6A55B7BC55B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301968,"discussion_content":"如果先增加非核心线程再加入队列，那么有可能会出现频繁的创建和销毁线程的情况，线程是稀有资源，频繁的创建和销毁线程正是线程池所避讳的。如果先阻塞队列满了再增加非核心线程，则可以表明一段时间内任务数是在稳步提升并且大于核心线程的处理速度的，这种情况下适合创建非核心线程。","likes_number":32,"is_delete":false,"is_hidden":false,"ctime":1598725081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337810,"avatar":"https://static001.geekbang.org/account/avatar/00/14/69/d2/78775848.jpg","nickname":"我的名字叫胡子","note":"","ucode":"662EF1E3E0638F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39344,"discussion_content":"个人理解：queue满了以后，说明设定的核心线程处理任务的速度小于任务入队的速度，也就是核心线程不够用，所以才创建非核心线程，不知道这么理解对不对","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1571915154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215066,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg","nickname":"shen","note":"","ucode":"AE5737B0C7DC4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57564,"discussion_content":"我的理解是创建线程有开销，只需要等待下就可以处理多出来的任务。我们场景大部分应该是时候核心线程已经够用了，可能某些时候任务比较多而已，即使这个时候其他线程处理好任务可以立马处理队列里的任务，所以没必要再创建非核心线程","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574612899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054472,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/08/566fb246.jpg","nickname":"L!en6o","note":"","ucode":"E0931CB8998260","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185162,"discussion_content":"线程复用就是用一个线程从队列不断获取任务执行，否则也不叫线程池，没有了复用的意义。不断创建新线程处理任务，那么队列也无意义。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582599953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/76/0c07376d.jpg","nickname":"蒙奇君杰","note":"","ucode":"2DBCECD149730F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309724,"discussion_content":"最大程度的利用线程资源。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601426395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64373,"discussion_content":"看了会源码，发现在我们在执行Executor的execute方法时，最终会执行到ThreadPoolExecutor的runWorker(Worker w)方法。仔细阅读这个方法的逻辑，我们会发现：它里面正是在判断当前线程池的活动线程数是否大于核心线程数，如果超过的话就会让非核心线程先把缓存队列blockingQueue里面的任务给消费掉，等消费完后再销毁该非核心线程；而如果当前活动线程数小于等于核心线程数，那么在使用核心线程执行任务时，即使当前缓存队列的任务都执行完了，那么该核心线程也会处于阻塞状态，而不会被销毁掉。这样就保证了线程池中总是有处于就绪的线程在等待任务消费。所以，上面提到的问题，我个人认为这样设计的原因：就是为了尽可能地保证线程池中有足够多的线程处于就绪状态（也即保存最大数量的、可长期存活的活动线程），一旦有新的任务产生，则立马会有线程响应。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574946797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136959,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epNoWjGv759Dn3v4kkRhUGr2wN48VwMdIDrH6q1XYHqmia21iaRqekQNslUefPyfsylnSeLnEuhBwdw/132","nickname":"shupian416","note":"","ucode":"4DC22BCF5C5414","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563419,"discussion_content":"因为线程的创建和使用是有代价的，使用线程池的原因就是为了最大限度避免线程的代价。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649991579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/c1/2f9bde7a.jpg","nickname":"张军","note":"","ucode":"38277A1FE5183C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377453,"discussion_content":"dubbo里有自己的线程池实现，优先创建线程，线程达到最大数目后，再往队列里面放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622647659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/c4/e87a61ec.jpg","nickname":"这就是编程","note":"","ucode":"4091B3EB368E9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212805,"discussion_content":"Tomcat 的线程池就是不是这样的，他就是，先创建线程，当线程数到达最大的的时候，加入到队列中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585018237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1756181,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cc/15/35622b02.jpg","nickname":"Jason","note":"","ucode":"B2765DD1D90B0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1009348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/c4/e87a61ec.jpg","nickname":"这就是编程","note":"","ucode":"4091B3EB368E9F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259691,"discussion_content":"组织下语言好不好。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588811634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212805,"ip_address":""},"score":259691,"extra":""}]}]},{"had_liked":false,"id":13528,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1529723531,"is_pvip":false,"replies":[{"id":"4587","content":"Doug Lea这个实现基本是工业标准了，除非特定场景需求","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529945201,"ip_address":"","comment_id":13528,"utype":1}],"discussion_count":10,"race_medal":0,"score":"108903905931","product_id":100006701,"comment_content":"疑问，为什么当初sun的线程池模式要设计成队列满了才能创建非核心线程？类比其他类似池的功能实现，很多都是设置最小数最大数，达到最大数才向等待队列里加入，比如有的连接池实现。","like_count":26,"discussions":[{"author":{"id":1595176,"avatar":"https://static001.geekbang.org/account/avatar/00/18/57/28/be7550d2.jpg","nickname":"mo","note":"","ucode":"FB3E8C827BE5CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190606,"discussion_content":"举个例子，5个程序员开发5个需求，能有条不紊地开发，加入又来了3个需求，排下期，5个开发依旧能搞定，但这个时候忽然又来了10个需求，5个程序员超负荷运转也完成不了，这个时候怎么办呢，该招人了吧。但是招人也是需要到一定条件才招的，不是来一个需求就需要招一个人，到时候需求开发完了，新招的人裁掉是要付很大代价的。猜想线程池的原理也大概如此，核心池满了后新来一任务就新开一线程处理，直到撑到最大线程数，到时候一空闲下来又得销毁，线程池经历这频繁地创建与销毁，性能也会有所损失，而有效地先利用等待队列，则能发挥出线程池原本的能力","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582965199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1595176,"avatar":"https://static001.geekbang.org/account/avatar/00/18/57/28/be7550d2.jpg","nickname":"mo","note":"","ucode":"FB3E8C827BE5CC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191930,"discussion_content":"你说得很有道理。\n我后来看到极客时间另外一个老师对这个问题的解释为：jdk线程池最早设计时主要考虑的是cpu密集型场景，所以任务多了，增加线程解决不了问题。\n当时我觉得似乎是这样。佐证是一些第三方为了服务io密集型，确实自己实现了线程池。\n但我觉的你的解释更有说服力，因为一些研究表明，基于那些数据库连接池的场景，恰恰因为没按照jdk这种思路导致性能不好","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1583047635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":190606,"ip_address":""},"score":191930,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336818,"discussion_content":"其实自己在使用时知道明确的场景,自然就知道怎么设置线程池参数了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608708863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":191930,"ip_address":""},"score":336818,"extra":""},{"author":{"id":1179557,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","nickname":"clz1341521","note":"","ucode":"3BDB4AB454C918","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545392,"discussion_content":"说的很对，好像tomcat使用的线程池就是先扩大线程数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641947996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":191930,"ip_address":""},"score":545392,"extra":""}]},{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419679,"discussion_content":"Doug Lea这个实现基本是工业标准了，除非特定场景需求","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1529945201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1947356,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NGib8v9Lml2KjSHick5qMw9Vaibbb5l1qeTKE2BqbNDU8ibyhkhVFbxPmvKrhjKibKesvUYAQxbJ5wEc4aQLibBCfu6A/132","nickname":"Geek_cb636c","note":"","ucode":"3B2143CF379015","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298766,"discussion_content":"这个没明白呢 为啥队列满了就创建非核心线程 按理说即便是队列满了那也是队列里的优先啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597393692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415305,"avatar":"https://static001.geekbang.org/account/avatar/00/15/98/89/ca8fa978.jpg","nickname":"GkTian","note":"","ucode":"05B11A512A8892","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167542,"discussion_content":"创建线程会加锁，直接放入队列里，多方便。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581507886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/19/9318f9a2.jpg","nickname":"Drake Wang","note":"","ucode":"9A735F70EE54F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96866,"discussion_content":"不好意思，没看明白老师的回答跟这位同学的提问有何联系，谁帮忙解释下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577097680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1113737,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","nickname":"xuanyuan","note":"","ucode":"1EC79B9372868F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1014809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/19/9318f9a2.jpg","nickname":"Drake Wang","note":"","ucode":"9A735F70EE54F9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149785,"discussion_content":"新的任务加入：\n1. 队列满了才创建非核心线程\n2. 先创建非核心线程，直到不能创建线程，新的任务入队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579779226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96866,"ip_address":""},"score":149785,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1014809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/19/9318f9a2.jpg","nickname":"Drake Wang","note":"","ucode":"9A735F70EE54F9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336819,"discussion_content":"jdk线程池实现逻辑: 只有队列满了才会按照最大线程数创建非核心线程 , 有些开发者搞个无界队列意味着工作线程数永远是核心线程数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608708967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96866,"ip_address":""},"score":336819,"extra":""}]}]},{"had_liked":false,"id":96698,"user_name":"nb Ack","can_delete":false,"product_type":"c1","uid":1137171,"ip_address":"","ucode":"2C1B99C85C8CCD","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/13/3160996d.jpg","comment_is_top":false,"comment_ctime":1558489079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65982998519","product_id":100006701,"comment_content":"阻塞性：<br>BlockQueue存入任务队列时是没有阻塞，使用的是offer，无阻塞添加方法。<br>BlockQueue取出任务队列时是有阻塞，有超时使用poll取值，无超时使用take阻塞方法取值<br><br>添加任务逻辑：<br>1.当任务数小于核心线程数，新建核心线程来执行任务<br>2.任务数大于核心线程数，队列不满，放入任务队列<br>3.任务数大于核心线程数，队列已满，新建线程执行<br>4.任务数大于核心线程数，队列已满，工作线程已达最大线程数，拒绝任务，抛出异常（而不是阻塞任务，等待进入队列）<br>","like_count":16},{"had_liked":false,"id":14166,"user_name":"沈琦斌","can_delete":false,"product_type":"c1","uid":1160094,"ip_address":"","ucode":"6C97F7C7A9ED0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/9e/c88ac921.jpg","comment_is_top":false,"comment_ctime":1530200872,"is_pvip":false,"replies":[{"id":"4759","content":"你是说cachedthreadpool？那个大小是浮动的，不是1；如果说single，executorservice毕竟还提供了工作队列，生命周期管理，工作线程维护等很多事，还是要高效","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530237849,"ip_address":"","comment_id":14166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57364775720","product_id":100006701,"comment_content":"老师，我想问的是cache的线程池大小是1，每次还要新创建，那和我自己创建而不用线程池有什么区别？","like_count":14,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419892,"discussion_content":"你是说cachedthreadpool？那个大小是浮动的，不是1；如果说single，executorservice毕竟还提供了工作队列，生命周期管理，工作线程维护等很多事，还是要高效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530237849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60711,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1547535010,"is_pvip":false,"replies":[{"id":"23361","content":"实践是好习惯","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549821485,"ip_address":"","comment_id":60711,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40202240674","product_id":100006701,"comment_content":"写了个简单demo玩了下。<br>创建线程池会初始化线程工厂，工作线程是在提交任务的创建的。工作线程在执行任务中抛出异常，再次提交任务会又新建工作线程。newFixedThreadPool 正常执行任务时会优先创建线程已达到核心线程数，不会优先复用空闲工作线程。<br>```<br>&#47;**<br> * 线程池工作线程执行任务抛出异常<br> *&#47;<br>@Test<br>public void test03() throws InterruptedException {<br>    &#47;&#47; java.util.concurrent.Executors.DefaultThreadFactory.DefaultThreadFactory 构造线程工厂<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    Runnable task = new Runnable() {<br>        @Override<br>        public void run() {<br>            System.out.println(&quot;hello world&quot;);<br>            &#47;&#47; 抛出异常<br>            throw new RuntimeException();<br>        }<br>    };<br>    executorService.execute(task);<br>    &#47;&#47; 提交任务通过 DefaultThreadFactory.newThread() 创建线程<br>    TimeUnit.SECONDS.sleep(2);<br>    &#47;&#47; 前一个工作线程在执行任务中抛出异常，再提交任务又会新建工作线程<br>    executorService.execute(task);<br><br>    TimeUnit.SECONDS.sleep(3);<br>}<br>```","like_count":10,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436593,"discussion_content":"实践是好习惯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549821485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217472,"discussion_content":"dalvik虚拟机中，任意子线程crash，都会导致进程crash。。。\n和 jvm不一样。所以 线程池 这里 表现也会不同","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585563232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13653,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1529904071,"is_pvip":false,"replies":[{"id":"4584","content":"core和Max源码或者逻辑分析都很清楚；而创建线程次数理论上是不确定的，比如任务执行中抛异常，就要重新创建worker","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529944673,"ip_address":"","comment_id":13653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18709773255","product_id":100006701,"comment_content":"core和max应该都是1。验证的方法是自己写一个Threadlocal, 里面有相应创建线程的日志，然后把它传入创建线程池。","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419712,"discussion_content":"core和Max源码或者逻辑分析都很清楚；而创建线程次数理论上是不确定的，比如任务执行中抛异常，就要重新创建worker","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529944673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72749,"user_name":"Ifdevil","can_delete":false,"product_type":"c1","uid":1212912,"ip_address":"","ucode":"79DB0ADE9AD082","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/f0/695ca05f.jpg","comment_is_top":false,"comment_ctime":1551709614,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14436611502","product_id":100006701,"comment_content":"老师您好，我看了线程池源码，里面是用HashSet存放worker的，为什么这里用hashset呢？去重？线程池需要去重吗？","like_count":3,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336820,"discussion_content":"set底层是map ,put,get,remove都是O(1)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608709045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63760,"user_name":"GK java","can_delete":false,"product_type":"c1","uid":1115562,"ip_address":"","ucode":"AA54E8CAAB974C","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/aa/3c7c00a4.jpg","comment_is_top":false,"comment_ctime":1548490549,"is_pvip":false,"replies":[{"id":"23338","content":"通常建议明确关闭，要看具体场景，我们的应用对于关闭本身是如何定义，有没有要求，什么时机触发，需要保证优雅的退出吗？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549816834,"ip_address":"","comment_id":63760,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433392437","product_id":100006701,"comment_content":"线程池到底需不需要关闭","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437709,"discussion_content":"通常建议明确关闭，要看具体场景，我们的应用对于关闭本身是如何定义，有没有要求，什么时机触发，需要保证优雅的退出吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549816834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69603,"user_name":"不告诉你","can_delete":false,"product_type":"c1","uid":1140831,"ip_address":"","ucode":"983AE997A29B1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/5f/2b4abbb6.jpg","comment_is_top":false,"comment_ctime":1550796368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10140730960","product_id":100006701,"comment_content":"无论是创建核心线程还是非核心线程，都需要获取全局锁。只有在工作队列满了以后才去创建非核心线程，应该就是为了在时间上尽量延后非核心线程的创建，为了线程池的性能做考虑吧。","like_count":2},{"had_liked":false,"id":14816,"user_name":"欣","can_delete":false,"product_type":"c1","uid":1100644,"ip_address":"","ucode":"35658943C6F20F","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/64/4afad7da.jpg","comment_is_top":false,"comment_ctime":1530674119,"is_pvip":false,"replies":[{"id":"5007","content":"谢谢指出","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530716156,"ip_address":"","comment_id":14816,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10120608711","product_id":100006701,"comment_content":"杨老师，我照着文章翻看源码，下面那块是不是不太对？<br>----------------<br>Executors 目前提供了 5 种不同的线程池创建配置：<br><br>newSingleThreadExecutor，它创建的是个 FinalizableDelegatedExecutorService<br><br>newSingleThreadScheduledExecutor 创建的是 ScheduledThreadPoolExecutor","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420144,"discussion_content":"谢谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530716156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156309,"discussion_content":"newSingleThreadExecutor()，创建的是FinalizableDelegatedExecutorService\nnewSingleThreadScheduledExecutor()，创建的是DelegatedScheduledExecutorService\nnewScheduledThreadPool(int corePoolSize)，创建的是 ScheduledThreadPoolExecutor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580350624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14133,"user_name":"镰仓","can_delete":false,"product_type":"c1","uid":1011300,"ip_address":"","ucode":"0548B222E194C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/64/456c280d.jpg","comment_is_top":false,"comment_ctime":1530189906,"is_pvip":false,"replies":[{"id":"4760","content":"android我并没有特别的经验，尽管很多方面是通用的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530237914,"ip_address":"","comment_id":14133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10120124498","product_id":100006701,"comment_content":"听了一段时间课程，质量很高。我的需求是android JavaVM","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419880,"discussion_content":"android我并没有特别的经验，尽管很多方面是通用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530237914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185503,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1583594939,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5878562235","product_id":100006701,"comment_content":"corePoolSize=maxPoolSize=1<br><br> ThreadFactory threadFactory = new ThreadFactory(){<br>    @Override<br>    public Thread newThread(Runnable r) {<br>        System.out.println(&quot;new thread ...&quot;);<br>        return new Thread(r,&quot;Thread-&quot;+System.currentTimeMillis());<br>    }<br>};<br><br>ExecutorService executorService = Executors.newSingleThreadExecutor(threadFactory);<br><br>executorService.execute(()-&gt;{<br>    System.out.println(&quot;A Run&quot;);<br>});<br><br>executorService.execute(()-&gt;{<br>    System.out.println(&quot;B Run Exception&quot;);<br>    throw new RuntimeException();<br>});<br><br>executorService.execute(() -&gt; {<br>    System.out.println(&quot;C Run&quot;);<br>});<br><br>结果，发生两次创建线程，也就是发生异常之后，原先线程会被替换掉，具体看ThreadPoolExecutor的processWorkerExit()方法","like_count":2,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305375,"discussion_content":"感谢补充！！和老师说的对上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599899031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164560,"user_name":"何義","can_delete":false,"product_type":"c1","uid":1135585,"ip_address":"","ucode":"5DC5FB72D5AE00","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/e1/dd7b3206.jpg","comment_is_top":false,"comment_ctime":1577027384,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5871994680","product_id":100006701,"comment_content":"请教一下，多线程下面是否可以再嵌套多线程","like_count":1,"discussions":[{"author":{"id":1054472,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/08/566fb246.jpg","nickname":"L!en6o","note":"","ucode":"E0931CB8998260","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185166,"discussion_content":"可以 但是不利于管理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582600058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72433,"user_name":"康","can_delete":false,"product_type":"c1","uid":1435518,"ip_address":"","ucode":"8BDC8135070244","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/7e/34fa766f.jpg","comment_is_top":false,"comment_ctime":1551624405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846591701","product_id":100006701,"comment_content":"我的理解，设置非核心线程的目的是防止任务数的段时间激增，导致任务数过多，从而核心线程处理时间太长。正常情况下要保证线程数小于核心线程数，非核心线程会过一段时间就被移出，保证了资源的利用，而核心一般不会变少","like_count":1},{"had_liked":false,"id":254520,"user_name":"影山飞雄","can_delete":false,"product_type":"c1","uid":1626622,"ip_address":"","ucode":"127F4CA21207D8","user_header":"https://static001.geekbang.org/account/avatar/00/18/d1/fe/2ca6f40a.jpg","comment_is_top":false,"comment_ctime":1603122317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603122317","product_id":100006701,"comment_content":"想问下这个单线程池情况下，内部的包装类的作用是什么？<br>A wrapper class that exposes only the ExecutorService methods  * of an ExecutorService implementation.<br>这是源代码的注释，是为了只暴露ExecutorService的方法，而不暴露父类AbstractExecutorService的方法吗？","like_count":0},{"had_liked":false,"id":230278,"user_name":"大成尊者","can_delete":false,"product_type":"c1","uid":1783367,"ip_address":"","ucode":"42473322052B11","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/47/8e80082c.jpg","comment_is_top":false,"comment_ctime":1593334710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593334710","product_id":100006701,"comment_content":"如果利用 newSingleThreadExecutor() 创建一个线程池，corePoolSize、maxPoolSize 等都是什么数值？ThreadFactory 可能在线程池生命周期中被使用多少次？怎么验证自己的判断？<br>答：corePoolSize、maxPoolSize 都是1，ThreadFactory只会被调用1次。验证倒没想到怎么验证，不过new Thread()的时候，指定了线程名称中带了AtomicInteger，可以看这个值是多少，如果是1，就说明值执行了一次。","like_count":0},{"had_liked":false,"id":207321,"user_name":"赤云","can_delete":false,"product_type":"c1","uid":1093258,"ip_address":"","ucode":"67476D582D8B6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","comment_is_top":false,"comment_ctime":1587047314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587047314","product_id":100006701,"comment_content":"原来SingleThreadPoolExecutor是使用LingkBlockQueue维护工作队列 ，第一个节点 创建Worker 线程 ，之后的线程使用 enqueue(node)方法构建链 ","like_count":1},{"had_liked":false,"id":207315,"user_name":"赤云","can_delete":false,"product_type":"c1","uid":1093258,"ip_address":"","ucode":"67476D582D8B6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","comment_is_top":false,"comment_ctime":1587046710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587046710","product_id":100006701,"comment_content":"ThreadPoolExecutor.java 616行创建Worder的时候使用ThreadFactory构建线程","like_count":0},{"had_liked":false,"id":192680,"user_name":"飘香剑雨","can_delete":false,"product_type":"c1","uid":1494747,"ip_address":"","ucode":"96221CCD687594","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/db/72b7c594.jpg","comment_is_top":false,"comment_ctime":1584867833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584867833","product_id":100006701,"comment_content":"size都是1吧","like_count":0},{"had_liked":false,"id":180481,"user_name":"rike","can_delete":false,"product_type":"c1","uid":1583833,"ip_address":"","ucode":"920AAD0BD9245C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","comment_is_top":false,"comment_ctime":1582293261,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1582293261","product_id":100006701,"comment_content":"文章中“建议按照 CPU 核的数目 N 或者 N+1。”，这里的n是指多少？","like_count":0,"discussions":[{"author":{"id":2289255,"avatar":"https://static001.geekbang.org/account/avatar/00/22/ee/67/e97fea7d.jpg","nickname":"[ThumbsUp]","note":"","ucode":"428818387DE5F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325755,"discussion_content":"System.out.println(Runtime.getRuntime().availableProcessors());","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605425517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305377,"discussion_content":"？？？CPU核心数啊不是写的就是   CPU核的数目 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599899869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054472,"avatar":"https://static001.geekbang.org/account/avatar/00/10/17/08/566fb246.jpg","nickname":"L!en6o","note":"","ucode":"E0931CB8998260","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185165,"discussion_content":"机器CUP核数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582600046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155584,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574715057,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574715057","product_id":100006701,"comment_content":"我个人更倾向于用rxjava解决多线程的问题而不是直接操作线程池。","like_count":0,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217475,"discussion_content":"小心线程溢出。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585563505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155583,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574714955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574714955","product_id":100006701,"comment_content":"newCachedThreadPool() 60s时间窗口缓存线程，适合的场景是系统需要的线程数在每分钟是差不多的。<br>newFixedThreadPool(int nThreads)，设定了活动线程的最大值，如果超过这个数目，线程进入等待状态。适合场景例如总共只有n个CPU，为了提高效率，最多的并行也就是n。<br>newSingleThreadExecutor()，单线程执行，可以保证多个线程的执行顺序。<br>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize) 周期性调度<br>newWorkStealingPool(int parallelism) 并行处理线程","like_count":0},{"had_liked":false,"id":125297,"user_name":"rain","can_delete":false,"product_type":"c1","uid":1172175,"ip_address":"","ucode":"6124FDC6542F43","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/cf/eb6cea42.jpg","comment_is_top":false,"comment_ctime":1566141218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566141218","product_id":100006701,"comment_content":"学习了一下，自己总结一下：https:&#47;&#47;www.jhonrain.org&#47;2018&#47;09&#47;14&#47;%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%89%96%E6%9E%90&#47;","like_count":0},{"had_liked":false,"id":122918,"user_name":"bruce","can_delete":false,"product_type":"c1","uid":1205608,"ip_address":"","ucode":"43ABEBE19DFFF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/68/6d4e4168.jpg","comment_is_top":false,"comment_ctime":1565573714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565573714","product_id":100006701,"comment_content":"杨老师，文章中你指出newCachedThreadPool使用于大量短时间任务的场景。大量短时间任务这个是如何定义的，是否可以给出一些具体的业务使用场景。谢谢！","like_count":0},{"had_liked":false,"id":96332,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1558400038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558400038","product_id":100006701,"comment_content":"为什么cache线程池用的是大小为0的队列呢？","like_count":0},{"had_liked":false,"id":90207,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556447914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556447914","product_id":100006701,"comment_content":"core&#47;max size都是1。但是后面的 我就不知道怎么验证了","like_count":0},{"had_liked":false,"id":77630,"user_name":"木刻","can_delete":false,"product_type":"c1","uid":1157430,"ip_address":"","ucode":"0A3226FEE3983B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","comment_is_top":false,"comment_ctime":1552975218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552975218","product_id":100006701,"comment_content":"老师好，如果我一台服务器上跑好几个程序，每个程序都有自己的线程池，那每个程序中的线程池数量都配置自己本程序根据CPU核数和IO等算出的理论值吗","like_count":0},{"had_liked":false,"id":67020,"user_name":"森","can_delete":false,"product_type":"c1","uid":1118939,"ip_address":"","ucode":"FDFD5C54D9239B","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/db/d70eb05e.jpg","comment_is_top":false,"comment_ctime":1550056729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550056729","product_id":100006701,"comment_content":"老师你好，如果创建一个线程池，核心线程数为1，最大线程数为10，现在有100个线程并发，这90个线程怎么处理的（全部压在栈中吗）？假设栈中最多只能存放50个线程，剩下40个线程放在哪里？","like_count":0},{"had_liked":false,"id":65961,"user_name":"JasonLai","can_delete":false,"product_type":"c1","uid":1271726,"ip_address":"","ucode":"5DBF54914AE73E","user_header":"https://static001.geekbang.org/account/avatar/00/13/67/ae/f7e8ce72.jpg","comment_is_top":false,"comment_ctime":1549803798,"is_pvip":false,"replies":[{"id":"23353","content":"看应用是否有类似高并发、高负载等需求，如果没有，简便的方法也许就足够了；如果有，用构造函数创建是可取的，例如，可以限制最大线程数目，避免过度创建线程而OOM等","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549819551,"ip_address":"","comment_id":65961,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549803798","product_id":100006701,"comment_content":"老师你好，我在学些线程池时候遇到一个说法，创建线程池不推荐使用executors<br>而是使用threadpoolexecutor去创建。首先executor都是继承于threadpoolexecutor 其次是编写的线程池更为明确运行规则，有助于规避资源耗尽的风险。请老师分析下这种说法，其次是您的观点","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438660,"discussion_content":"看应用是否有类似高并发、高负载等需求，如果没有，简便的方法也许就足够了；如果有，用构造函数创建是可取的，例如，可以限制最大线程数目，避免过度创建线程而OOM等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549819551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60621,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1547519796,"is_pvip":false,"replies":[{"id":"23328","content":"难道我记错了...我去翻一下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549813036,"ip_address":"","comment_id":60621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547519796","product_id":100006701,"comment_content":"Geotz那本java并发实战线程池大小计算还有个CPU利用率？<br>线程数 = CPU 核数 × CPU利用率 ×（1 + 平均等待时间 &#47; 平均工作时间）","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436562,"discussion_content":"难道我记错了...我去翻一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549813036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23582,"user_name":"夏日","can_delete":false,"product_type":"c1","uid":1132250,"ip_address":"","ucode":"495A8D4E95CA2D","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/da/4aa4b89c.jpg","comment_is_top":false,"comment_ctime":1536537181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536537181","product_id":100006701,"comment_content":"老师好，newsingle 可以做类似单机版的秒杀吧？当然秒杀是分布式的。总觉得这么好的特点会被其他中间件封装利用。","like_count":0},{"had_liked":false,"id":19549,"user_name":"绍晖","can_delete":false,"product_type":"c1","uid":1194932,"ip_address":"","ucode":"4196CF795417EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/b4/b8d0f8c8.jpg","comment_is_top":false,"comment_ctime":1533873414,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1533873414","product_id":100006701,"comment_content":"请谈一谈，如果利用 newSingleThreadExecutor() 创建一个线程池，corePoolSize、maxPoolSize 等都是什么数值？ThreadFactory 可能在线程池生命周期中被使用多少次？怎么验证自己的判断？","like_count":0},{"had_liked":false,"id":18396,"user_name":"洗头用酱油","can_delete":false,"product_type":"c1","uid":1181339,"ip_address":"","ucode":"BDD6B32C55858F","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/9b/ade9c3bd.jpg","comment_is_top":false,"comment_ctime":1533290133,"is_pvip":false,"replies":[{"id":"6463","content":"Linked本身是可选的，不指定容量就是int max，newsingle记得就没指定，换个角度默认指定什么好呢","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1533400334,"ip_address":"","comment_id":18396,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1533290133","product_id":100006701,"comment_content":"老师，我看NewSingleExecutor 所有的队列是LinkedBlockingQueue，它好像是有界的队列不是无界的吧？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421508,"discussion_content":"Linked本身是可选的，不指定容量就是int max，newsingle记得就没指定，换个角度默认指定什么好呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533400334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13617,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1529883294,"is_pvip":false,"replies":[{"id":"4583","content":"工厂是创建线程；执行完成通常是说任务，而不是线程，任务才是我们关心的；可以用Future","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529944167,"ip_address":"","comment_id":13617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529883294","product_id":100006701,"comment_content":"老师 放入队列中的线程是直接调用start方法还是把队列中的线程放入线程工厂，让线程工厂执行？<br>另外，怎么判断一个线程是否执行完成呢？（只有执行完成才返回结果）谢谢老师","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419701,"discussion_content":"工厂是创建线程；执行完成通常是说任务，而不是线程，任务才是我们关心的；可以用Future","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529944167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}