{"id":6970,"title":"第4讲 | 强引用、软引用、弱引用、幻象引用有什么区别？","content":"<p>在Java语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握Java对象生命周期和JVM内部相关机制非常有帮助。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</span></p>\n<h2>典型回答</h2>\n<p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响</strong>。</p>\n<p>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>\n<p>软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>\n<p>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p>\n<!-- [[[read_end]]] -->\n<p>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制，比如，通常用来做所谓的Post-Mortem清理机制，我在专栏上一讲中介绍的Java平台自身Cleaner机制等，也有人利用幻象引用监控对象的创建和销毁。</p>\n<h2>考点分析</h2>\n<p>这道面试题，属于既偏门又非常高频的一道题目。说它偏门，是因为在大多数应用开发中，很少直接操作各种不同引用，虽然我们使用的类库、框架可能利用了其机制。它被频繁问到，是因为这是一个综合性的题目，既考察了我们对基础概念的理解，也考察了对底层对象生命周期、垃圾收集机制等的掌握。</p>\n<p>充分理解这些引用，对于我们设计可靠的缓存等框架，或者诊断应用OOM等问题，会很有帮助。比如，诊断MySQL connector-j驱动在特定模式下（useCompression=true）的内存泄漏问题，就需要我们理解怎么排查幻象引用的堆积问题。</p>\n<h2>知识扩展</h2>\n<p>1.对象可达性状态流转分析</p>\n<p>首先，请你看下面流程图，我这里简单总结了对象生命周期和不同可达性状态，以及不同状态可能的改变关系，可能未必100%严谨，来阐述下可达性的变化。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/36/b0/36d3c7b158eda9421ef32463cb4d4fb0.png?wh=497*585\" alt=\"\" /></p>\n<p>我来解释一下上图的具体状态，这是Java定义的不同可达性级别（reachability level），具体如下：</p>\n<ul>\n<li>\n<p>强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。</p>\n</li>\n<li>\n<p>软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。</p>\n</li>\n<li>\n<p>弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近finalize状态的时机，当弱引用被清除的时候，就符合finalize的条件了。</p>\n</li>\n<li>\n<p>幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且finalize过了，只有幻象引用指向这个对象的时候。</p>\n</li>\n<li>\n<p>当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。</p>\n</li>\n</ul>\n<p>判断对象可达性，是JVM垃圾收集器决定如何处理对象的一部分考虑。</p>\n<p>所有引用类型，都是抽象类java.lang.ref.Reference的子类，你可能注意到它提供了get()方法：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ba/3e/bae702d46c665e12113f5abd876eb53e.png?wh=661*41\" alt=\"\" /></p>\n<p>除了幻象引用（因为get永远返回null），如果对象还没有被销毁，都可以通过get方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！这也是为什么我在上面图里有些地方画了双向箭头。</p>\n<p>所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</p>\n<p>但是，你觉得这里有没有可能出现什么问题呢？</p>\n<p>不错，如果我们错误的保持了强引用（比如，赋值给了static变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄漏，就可以从这个角度检查。</p>\n<p>2.引用队列（ReferenceQueue）使用</p>\n<p>谈到各种引用的编程，就必然要提到引用队列。我们在创建各种引用并关联到相应对象时，可以选择是否需要关联引用队列，JVM会在特定时机将引用enqueue到队列里，我们可以从队列里获取引用（remove方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get方法只返回null，如果再不指定引用队列，基本就没有意义了。看看下面的示例代码。利用引用队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被finalize了，处于幻象可达状态），执行后期处理逻辑。</p>\n<pre><code>Object counter = new Object();\nReferenceQueue refQueue = new ReferenceQueue&lt;&gt;();\nPhantomReference&lt;Object&gt; p = new PhantomReference&lt;&gt;(counter, refQueue);\ncounter = null;\nSystem.gc();\ntry {\n    // Remove是一个阻塞方法，可以指定timeout，或者选择一直阻塞\n    Reference&lt;Object&gt; ref = refQueue.remove(1000L);\n    if (ref != null) {\n        // do something\n    }\n} catch (InterruptedException e) {\n    // Handle it\n}\n</code></pre>\n<p>3.显式地影响软引用垃圾收集</p>\n<p>前面泛泛提到了引用对垃圾收集的影响，尤其是软引用，到底JVM内部是怎么处理它的，其实并不是非常明确。那么我们能不能使用什么方法来影响软引用的垃圾收集呢？</p>\n<p>答案是有的。软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以M bytes为单位）。从Java  1.3.1开始，提供了-XX:SoftRefLRUPolicyMSPerMB参数，我们可以以毫秒（milliseconds）为单位设置。比如，下面这个示例就是设置为3秒（3000毫秒）。</p>\n<pre><code>-XX:SoftRefLRUPolicyMSPerMB=3000\n</code></pre>\n<p>这个剩余空间，其实会受不同JVM模式影响，对于Client模式，比如通常的Windows 32 bit JDK，剩余空间是计算当前堆里空闲的大小，所以更加倾向于回收；而对于server模式JVM，则是根据-Xmx指定的最大值来计算。</p>\n<p>本质上，这个行为还是个黑盒，取决于JVM实现，即使是上面提到的参数，在新版的JDK上也未必有效，另外Client模式的JDK已经逐步退出历史舞台。所以在我们应用时，可以参考类似设置，但不要过于依赖它。</p>\n<p>4.诊断JVM引用情况</p>\n<p>如果你怀疑应用存在引用（或finalize）导致的回收问题，可以有很多工具或者选项可供选择，比如HotSpot JVM自身便提供了明确的选项（PrintReferenceGC）去获取相关信息，我指定了下面选项去使用JDK 8运行一个样例应用：</p>\n<pre><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC\n</code></pre>\n<p>这是JDK 8使用ParrallelGC收集的垃圾收集日志，各种引用数量非常清晰。</p>\n<pre><code>0.403: [GC (Allocation Failure) 0.871: [SoftReference, 0 refs, 0.0000393 secs]0.871: [WeakReference, 8 refs, 0.0000138 secs]0.871: [FinalReference, 4 refs, 0.0000094 secs]0.871: [PhantomReference, 0 refs, 0 refs, 0.0000085 secs]0.871: [JNI Weak Reference, 0.0000071 secs][PSYoungGen: 76272K-&gt;10720K(141824K)] 128286K-&gt;128422K(316928K), 0.4683919 secs] [Times: user=1.17 sys=0.03, real=0.47 secs] \n</code></pre>\n<p><strong>注意：JDK 9对JVM和垃圾收集日志进行了广泛的重构</strong>，类似PrintGCTimeStamps和PrintReferenceGC已经不再存在，我在专栏后面的垃圾收集主题里会更加系统的阐述。</p>\n<p>5.Reachability Fence</p>\n<p>除了我前面介绍的几种基本引用类型，我们也可以通过底层API来达到强引用的效果，这就是所谓的设置<strong>reachability fence</strong>。</p>\n<p>为什么需要这种机制呢？考虑一下这样的场景，按照Java语言规范，如果一个对象没有指向强引用，就符合垃圾收集的标准，有些时候，对象本身并没有强引用，但是也许它的部分属性还在被使用，这样就导致诡异的问题，所以我们需要一个方法，在没有强引用情况下，通知JVM对象是在被使用的。说起来有点绕，我们来看看Java 9中提供的案例。</p>\n<pre><code>class Resource {\n private static ExternalResource[] externalResourceArray = ...\n int myIndex; Resource(...) {\n     myIndex = ...\n     externalResourceArray[myIndex] = ...;\n     ...\n }\n protected void finalize() {\n     externalResourceArray[myIndex] = null;\n     ...\n }\n public void action() {\n try {\n     // 需要被保护的代码\n     int i = myIndex;\n     Resource.update(externalResourceArray[i]);\n } finally {\n     // 调用reachbilityFence，明确保障对象strongly reachable\n     Reference.reachabilityFence(this);\n }\n }\n private static void update(ExternalResource ext) {\n    ext.status = ...;\n }\n} \n</code></pre>\n<p>方法action的执行，依赖于对象的部分属性，所以被特定保护了起来。否则，如果我们在代码中像下面这样调用，那么就可能会出现困扰，因为没有强引用指向我们创建出来的Resource对象，JVM对它进行finalize操作是完全合法的。</p>\n<pre><code>new Resource().action()\n</code></pre>\n<p>类似的书写结构，在异步编程中似乎是很普遍的，因为异步编程中往往不会用传统的“执行-&gt;返回-&gt;使用”的结构。</p>\n<p>在Java 9之前，实现类似功能相对比较繁琐，有的时候需要采取一些比较隐晦的小技巧。幸好，java.lang.ref.Reference给我们提供了新方法，它是JEP 193: Variable Handles的一部分，将Java平台底层的一些能力暴露出来：</p>\n<pre><code>static void reachabilityFence(Object ref)\n</code></pre>\n<p>在JDK源码中，reachabilityFence大多使用在Executors或者类似新的HTTP/2客户端代码中，大部分都是异步调用的情况。编程中，可以按照上面这个例子，将需要reachability保障的代码段利用try-finally包围起来，在finally里明确声明对象强可达。</p>\n<p>今天，我总结了Java语言提供的几种引用类型、相应可达状态以及对于JVM工作的意义，并分析了引用队列使用的一些实际情况，最后介绍了在新的编程模式下，如何利用API去保障对象不被意外回收，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？给你留一道练习题，你能从自己的产品或者第三方类库中找到使用各种引用的案例吗？它们都试图解决什么问题？</p>\n<p>请你在留言区写写你的答案，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享出去，或许你能帮到他。</p>\n","neighbors":{"left":{"article_title":"第3讲 | 谈谈final、finally、 finalize有什么不同？","id":6906},"right":{"article_title":"第5讲 | String、StringBuffer、StringBuilder有什么区别？","id":7349}},"comments":[{"had_liked":false,"id":32201,"user_name":"杨晓峰","can_delete":false,"product_type":"c1","uid":1009360,"ip_address":"","ucode":"2BF255467A978F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","comment_is_top":true,"comment_ctime":1539483698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233722316678001e+18","product_id":100006701,"comment_content":"这里提供一个真是有关reachability的例子，也是reachabilityFence的一个使用http:&#47;&#47;mail.openjdk.java.net&#47;pipermail&#47;jdk-dev&#47;2018-October&#47;002067.html<br><br>清楚说明对方法的调用并不能保证对象存活","like_count":46},{"had_liked":false,"id":9133,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":true,"comment_ctime":1526627842,"is_pvip":false,"replies":[{"id":"2739","content":"空的Finalize实现，不会起作用的；<br>Finalizer是懒家伙，试试system.runfinalization；","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526630527,"ip_address":"","comment_id":9133,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233721371656991e+18","product_id":100006701,"comment_content":"接着上个问题：<br>老师，问个问题:我自己定义一个类，重写finalize方法后，创建一个对象，被幻想引用，同时该幻想对象使用ReferenceQueue。<br>当我这个对象指向null，被GC回收后，ReferenceQueue中没有改对象，不知道是什么原因？如果我把类中的finalize方法移除，ReferenceQueue就能获取被释放的对象。<br><br>2018-05-17作者回复文章图里阐明了，幻象引用enque发生在finalize之后，你查查是不是卡在FinalReference queue里了，那是实现finalization的地方<br><br>杨老师，我去查看了，Final reference和Reference发现是Reference Handle线程在监控，但是Debug进出去，还是没有搞清楚原理。<br><br>不过，我又发现类中自定义得Finalize,如果是空的，正常。如果类中有任何代码，都不能进入Reference Queue，怀疑是对象没有被GC回收。","like_count":23,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417980,"discussion_content":"空的Finalize实现，不会起作用的；\nFinalizer是懒家伙，试试system.runfinalization；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526630527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482665,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NPfmxlo2j93hOjYoJV54WHYFkeibzibUbRGhGCyicty5NXPx9XKxicZotfmjqhcibUbjJYnW8rLFDatleT2zhyaTlqg/132","nickname":"小永","note":"","ucode":"40AB78B21615D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13467,"discussion_content":"- 我也有同样的困扰，但我发现一个现象“如果实现了finalize，System.gc()后Finalizer执行时会把入队的引用remove掉（显示调用remove方法）”,你可以打个断点看到remove被不明物体显示调用了，所以后面自己的逻辑里再调用remove阻塞获取时返回null；\n- 至于finalize里有代码就会出现问题，我怀疑是JVM条件编译时消除了此代码或者JIT时做了某种GC优化之类，没有证实过，仅供参考；\n我也没明白，对于自定义类实现了finalize方法的情况下，如果发生上面的现象，如何通过幻象引用进行编程，毕竟引用队列已经remove过了啊。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568671071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8353,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1526112240,"is_pvip":true,"replies":[{"id":"2516","content":"高手","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526274754,"ip_address":"","comment_id":8353,"utype":1}],"discussion_count":22,"race_medal":0,"score":"4214889029616","product_id":100006701,"comment_content":"在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。<br><br>1 强引用<br><br>特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。<br><br>2 软引用<br><br>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。<br><br>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<br><br>3 弱引用<br><br>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><br>应用场景：弱应用同样可用于内存敏感的缓存。<br><br>4 虚引用<br><br>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue); <br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。<br><br>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。","like_count":982,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417682,"discussion_content":"高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526274754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1952958,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJE5Y62XOTFc7B25pqzmI6nqInMmVNSAic8Yg3hsDbgtVb3ovFib4wUUwOficbKkuicOGvCqm8r761Fw/132","nickname":"Geek_0de10a","note":"","ucode":"ECA4552867055C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257208,"discussion_content":"比作者讲的清楚多了，感觉作者这里讲的一点都不清楚，或者对新手很不友好","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1588531369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1952958,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJE5Y62XOTFc7B25pqzmI6nqInMmVNSAic8Yg3hsDbgtVb3ovFib4wUUwOficbKkuicOGvCqm8r761Fw/132","nickname":"Geek_0de10a","note":"","ucode":"ECA4552867055C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285785,"discussion_content":"老师是有些地方讲的很乱感觉是自己懂了高估了读者的水准，但是这个总结也不算完美也有讲错的地方，老师讲的虽乱但基本没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592938537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":257208,"ip_address":""},"score":285785,"extra":""}]},{"author":{"id":1401685,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oEicpuoN6vAdFuvIicibn6OsUIDIsMlWVkd21mcd53zjoBIXdiadZCXFkJDUUWPkHuheybQjxQLQnPuxRMpszXmQ4A/132","nickname":"Jovi","note":"","ucode":"E5D399A3E4F02A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343144,"discussion_content":"完爆作者","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1610955299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149302,"discussion_content":"比作者讲的强几个数量级，原来大神憋着不做声在评论区。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1579743846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285851,"discussion_content":"老师是有些地方讲的很乱感觉是自己懂了高估了读者的水准，但是这个总结也不算完美也有讲错的地方，老师讲的虽乱但基本没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592970299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":149302,"ip_address":""},"score":285851,"extra":""}]},{"author":{"id":1108853,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rlToqaXUGUWPNTHic2pDQR2gibqibWAbhkoeoDccDrCkOG3BPYdJac7yNNwbrpbLDfCteiagrhticiaAhrkIIymxlOFg/132","nickname":"loversInJapan","note":"","ucode":"8A26970BD792A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3853,"discussion_content":"你比作者讲得清楚多了。。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1564886249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108853,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rlToqaXUGUWPNTHic2pDQR2gibqibWAbhkoeoDccDrCkOG3BPYdJac7yNNwbrpbLDfCteiagrhticiaAhrkIIymxlOFg/132","nickname":"loversInJapan","note":"","ucode":"8A26970BD792A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285852,"discussion_content":"老师是有些地方讲的很乱感觉是自己懂了高估了读者的水准，但是这个总结也不算完美也有讲错的地方，老师讲的虽乱但基本没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592970315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3853,"ip_address":""},"score":285852,"extra":""},{"author":{"id":1563245,"avatar":"https://static001.geekbang.org/account/avatar/00/17/da/6d/7c8fdb14.jpg","nickname":"嗯。","note":"","ucode":"30FC6EF9A01070","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291833,"discussion_content":"哪里错了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594967807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285852,"ip_address":""},"score":291833,"extra":""},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1563245,"avatar":"https://static001.geekbang.org/account/avatar/00/17/da/6d/7c8fdb14.jpg","nickname":"嗯。","note":"","ucode":"30FC6EF9A01070","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292993,"discussion_content":"名字和回收时机总有一个是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595406256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291833,"ip_address":""},"score":292993,"extra":""}]},{"author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4272,"discussion_content":"觉得你比作者讲得清晰。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1565264831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1409357,"avatar":"https://static001.geekbang.org/account/avatar/00/15/81/4d/5f892de2.jpg","nickname":"Echo","note":"","ucode":"F04C6BC4E288A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47222,"discussion_content":"你比作者讲的好","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1573297484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103445,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/55/47e76936.jpg","nickname":"叶易","note":"","ucode":"0983EA217ACF28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181133,"discussion_content":"之前自己写的关于引用的一篇文章，大家可以看看也可以相互学习一下https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582340689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066928,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","nickname":"冬风向左吹","note":"","ucode":"376C45C5134F93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3846,"discussion_content":"这四个的区别和使用场景解释的很清楚","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564880053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1830939,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaoouNOT0uLbN3fondbSTTfWjDJibVuFubGWDvzsgCtYmBpaTwvRMQbS0uXoIsUz6aPf7I1S75Rkg/132","nickname":"周靖峰","note":"","ucode":"997B9776F923F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285948,"discussion_content":"所以幻象引用就是所谓的虚引用吧？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1592994184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276563,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","nickname":"高志强","note":"","ucode":"68737002043752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331268,"discussion_content":"mark，总结的比作者还到位！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606819179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181248,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/40/ff77554d.jpg","nickname":"养🐱","note":"","ucode":"3CBBBEFD3945B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230301,"discussion_content":"谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586739573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1924811,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5e/cb/ad85b408.jpg","nickname":"黃喻榆","note":"","ucode":"644312AE93C490","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555846,"discussion_content":"Thanks!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647081076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285784,"discussion_content":"“如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。”综合整个评论区以及简书上有人总结的概念我认为这部分说明是完全错误的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592938389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215141,"discussion_content":"虚引用到底杂怎么使用的，只是泛泛而谈，没有意义。\n你这个系统通知的凭据是什么？源码中没看到\n其会在finalize调用时 入队自己关联的queue\n所以其使用方法 还是需要用户代码主动check？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585290143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1494177,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cc/a1/16d488fc.jpg","nickname":"阿国","note":"","ucode":"2801861BB1C115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48698,"discussion_content":"Mark ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573520559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8411,"user_name":"海怪哥哥","can_delete":false,"product_type":"c1","uid":1127866,"ip_address":"","ucode":"E82536F7259525","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/ba/01762322.jpg","comment_is_top":false,"comment_ctime":1526189155,"is_pvip":false,"replies":[{"id":"2501","content":"牛","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526270816,"ip_address":"","comment_id":8411,"utype":1}],"discussion_count":12,"race_medal":0,"score":"1934261472355","product_id":100006701,"comment_content":"我的理解，java的这种抽象很有意思。<br>强引用就像大老婆，关系很稳固。<br>软引用就像二老婆，随时有失宠的可能，但也有扶正的可能。<br>弱引用就像情人，关系不稳定，可能跟别人跑了。<br>幻像引用就是梦中情人，只在梦里出现过。","like_count":451,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417703,"discussion_content":"牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526270816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636683,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkTktMhVRbkn7U3mvnHUBBKkbzf17l98iaYZ35MQibvZPeZfXDV1licucYOI1Z70hk51X7TB9K8erpg/132","nickname":"刘鑫","note":"","ucode":"E818077E19CD98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24796,"discussion_content":"高手中的高手","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570266006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149305,"discussion_content":"比作者和云生程序员更厉害。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579743979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2642519,"avatar":"https://static001.geekbang.org/account/avatar/00/28/52/57/7212af10.jpg","nickname":"FAN","note":"","ucode":"C36DC4429F4A08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570544,"discussion_content":"NB啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651809852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122277,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/e5/053ebfc9.jpg","nickname":"•••","note":"","ucode":"D7F185FC4BFE14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570356,"discussion_content":"哈哈，才华哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651741474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2408132,"avatar":"https://static001.geekbang.org/account/avatar/00/24/be/c4/c4a8198c.jpg","nickname":"大星星和小猩猩","note":"","ucode":"16817D5C063C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389036,"discussion_content":"想象力丰富","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629100229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1436958,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/1e/d5ab9825.jpg","nickname":"大智若宇","note":"","ucode":"7AA696AD29313C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343977,"discussion_content":"这个比喻很有意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611222850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015938,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg","nickname":"梅子黄时雨","note":"","ucode":"9F788D09C2E9E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304869,"discussion_content":"😅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599703118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1635421,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f4/5d/b67c6c57.jpg","nickname":"sharphuang","note":"","ucode":"4E84B0B88A1D48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302988,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599104878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291750,"discussion_content":"牛皮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594946317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078675,"avatar":"https://static001.geekbang.org/account/avatar/00/10/75/93/8135f895.jpg","nickname":"bywuu","note":"","ucode":"2EDDB7E70CABB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219921,"discussion_content":"太了不起，一下就记住了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585824853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644768,"avatar":"https://static001.geekbang.org/account/avatar/00/19/18/e0/fa5a473b.jpg","nickname":"Geek_dbb622","note":"","ucode":"9A061D09F48208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175765,"discussion_content":"想女人想疯啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581994837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8492,"user_name":"肖一林","can_delete":false,"product_type":"c1","uid":1113317,"ip_address":"","ucode":"1DE45D906EB836","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/e5/605f423f.jpg","comment_is_top":false,"comment_ctime":1526263119,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"1062383185231","product_id":100006701,"comment_content":"这篇文章只描述了强引用，软引用，弱引用，幻想引用的特征。没有讲他们的概念，更没有讲怎么用…gc roots也没提到。希望能补充完来龙去脉，让没有太多基础的人也能看懂","like_count":248,"discussions":[{"author":{"id":1070051,"avatar":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","nickname":"来碗绿豆汤","note":"","ucode":"B0AB63B8D9729F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24271,"discussion_content":"确实写的很烂","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1570075603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145750,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/96/95a6e13a.jpg","nickname":"poetess","note":"","ucode":"240159FB179205","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3511,"discussion_content":"这个文章真是越看越头大，啥都是点一下","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1564543562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1144012,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJL6oZUWKOHYkEDqsegvtRhHdfekAQ74A8BFIiah6u8PY5N31aicVeGJpKNaicPaH9FjyBNAvrpbU45w/132","nickname":"rrsx","note":"","ucode":"EB63D2B27CA514","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1145750,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/96/95a6e13a.jpg","nickname":"poetess","note":"","ucode":"240159FB179205","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21418,"discussion_content":"赞同","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1569481719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3511,"ip_address":""},"score":21418,"extra":""},{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144012,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJL6oZUWKOHYkEDqsegvtRhHdfekAQ74A8BFIiah6u8PY5N31aicVeGJpKNaicPaH9FjyBNAvrpbU45w/132","nickname":"rrsx","note":"","ucode":"EB63D2B27CA514","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349693,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613461936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21418,"ip_address":""},"score":349693,"extra":""}]},{"author":{"id":1179298,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/a2/5252a278.jpg","nickname":"对方正在输入。。。","note":"","ucode":"7B0DEB4D9B43D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349501,"discussion_content":"基本上每篇文章，我都是看评论看懂的。。。。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1613271274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401685,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oEicpuoN6vAdFuvIicibn6OsUIDIsMlWVkd21mcd53zjoBIXdiadZCXFkJDUUWPkHuheybQjxQLQnPuxRMpszXmQ4A/132","nickname":"Jovi","note":"","ucode":"E5D399A3E4F02A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343142,"discussion_content":"确实，浪费精力和人民币","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1610955259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473346,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7b/42/8607b8f8.jpg","nickname":"Believer","note":"","ucode":"53C32C9F6C35FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344477,"discussion_content":"评论才是精华","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611473145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36977,"discussion_content":"完全看蒙逼\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571473401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555838,"discussion_content":"对啊  我觉得这篇是真的烂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647078648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2408132,"avatar":"https://static001.geekbang.org/account/avatar/00/24/be/c4/c4a8198c.jpg","nickname":"大星星和小猩猩","note":"","ucode":"16817D5C063C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389037,"discussion_content":"对呀，压根就没有介绍4种引用的概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629100297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1985143,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/4a/77/f394be95.jpg","nickname":"Alpahe","note":"","ucode":"4ED1C3302C0E8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358642,"discussion_content":"是啊完全看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616026760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1987202,"avatar":"","nickname":"Geek_783cc7","note":"","ucode":"C43F76B1978FA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337543,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608969723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8320,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1526091435,"is_pvip":false,"replies":[{"id":"2518","content":"非常不错，高手；<br>你可以参考jdk内部cleaner使用，一个方面就贴太多，有凑字数嫌疑了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526274880,"ip_address":"","comment_id":8320,"utype":1}],"discussion_count":7,"race_medal":0,"score":"929239027371","product_id":100006701,"comment_content":"1. 强引用：项目中到处都是。<br><br>2. 软引用：图片缓存框架中，“内存缓存”中的图片是以这种引用来保存，使得JVM在发生OOM之前，可以回收这部分缓存<br><br>3. 虚引用：在静态内部类中，经常会使用虚引用。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏<br><br>4. 幽灵引用：这种引用的get()方法返回总是null，所以，可以想象，在平常的项目开发肯定用的少。但是根据这种引用的特点，我想可以通过监控这类引用，来进行一些垃圾清理的动作。不过具体的场景，还是希望峰哥举几个稍微详细的实战性的例子？","like_count":216,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417672,"discussion_content":"非常不错，高手；\n你可以参考jdk内部cleaner使用，一个方面就贴太多，有凑字数嫌疑了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526274880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215142,"discussion_content":"弱引用 --》比较典型的安卓里面 handler泄露解决","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585290321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482665,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NPfmxlo2j93hOjYoJV54WHYFkeibzibUbRGhGCyicty5NXPx9XKxicZotfmjqhcibUbjJYnW8rLFDatleT2zhyaTlqg/132","nickname":"小永","note":"","ucode":"40AB78B21615D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13469,"discussion_content":"好像解释了ThreadLocal#ThreadLocalMap里的Entry为什么要声明为弱引用了，如果一个线程被挂起或者发生死锁，好像threadLocal就没办法正常回收了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568671609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645866,"avatar":"","nickname":"frosro","note":"","ucode":"29BB9FC40800D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7003,"discussion_content":"这里的虚引用就是文章里的弱引用吧。幽灵引用就是文章里的虚引用吧。有点懵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1482665,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NPfmxlo2j93hOjYoJV54WHYFkeibzibUbRGhGCyicty5NXPx9XKxicZotfmjqhcibUbjJYnW8rLFDatleT2zhyaTlqg/132","nickname":"小永","note":"","ucode":"40AB78B21615D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645866,"avatar":"","nickname":"frosro","note":"","ucode":"29BB9FC40800D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13468,"discussion_content":"明显这写错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568671368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7003,"ip_address":""},"score":13468,"extra":""},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645866,"avatar":"","nickname":"frosro","note":"","ucode":"29BB9FC40800D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29656,"discussion_content":"嗯 就是weakreference   ，翻译的差别。弱引用的翻译比较好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570777914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7003,"ip_address":""},"score":29656,"extra":""}]},{"author":{"id":1058002,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/d2/40353046.jpg","nickname":"zeroxus","note":"","ucode":"9DBB3A81F01792","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1847,"discussion_content":"结合应用场景，立马就有感觉了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562988725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9113,"user_name":"龙猫猫猫猫","can_delete":false,"product_type":"c1","uid":1131334,"ip_address":"","ucode":"B487E83EDF2FFC","user_header":"","comment_is_top":false,"comment_ctime":1526611734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"435318308630","product_id":100006701,"comment_content":"热评第一讲得比这文章还好","like_count":102},{"had_liked":false,"id":8796,"user_name":"Jane","can_delete":false,"product_type":"c1","uid":1126744,"ip_address":"","ucode":"FEB5FA991CAC9F","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/58/ddd35b42.jpg","comment_is_top":false,"comment_ctime":1526448522,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"306469126538","product_id":100006701,"comment_content":"引用出现的根源是由于GC内存回收的基本原理—GC回收内存本质上是回首对象，而目前比较流行的回收算法是可达性分析算法，从GC Roots开始按照一定的逻辑判断一个对象是否可达，不可达的话就说明这个对象已死（除此之外另外一种常见的算法就是引用计数法，但是这种算法有个问题就是不能解决相互引用的问题）。基于此Java向用户提供了四种可用的引用：即我们本章讲解到的几种，同时还提供了一种不可被使用的引用—FinalReference，这个引用是和析构函数密切相关的）。强引用，开发者可以通过new的方式创建，其它的几种引用Java提供了相应的类：SoftReference、WeakReference、PhantomReference。如果你去查看源码你会发现，这个类实现的核心是Reference与ReferenceQueue（更通俗地说引用队列）两个类，而且这两个类也特别的简单。Reference类似一个链表结构，通过创建一个守护线程来执行对应引用的清除、Cleaner.clean（如果传入的对象是该类的话）、以及引用的入队操作（需要在创建引用的时候制定一个引用队列）；ReferenceQueue这是制定了引用队列的一些具体操作，简单的来说它也是一个链表结构，并提供了一些基本的链表操作）。而除了强引用外其它的都是继承于此，通过这样的类约束了引用的相关内容，便于和GC进行交互。这几种引用的区别如下：<br>1:强引用是只有当GC明确判断该引用无效的时候才会回收相应的引用对象，即使抛出OOME警告。<br>2:软引用是当GC检测到继续创建对象会导致OOME的时候会进行一次垃圾回收，这次回收会讲软引用回收以防抛出异常，根据这样的特点该引用常用来被当作缓存使用。<br>3:虚引用是哪些如果引用未被使用，就会在最近的一次GC的时候被回收。例如Java的TheardLocal与动态代理都是基于这样的一个引用实现的，一般针对那些比较敏感的数据。<br>4:幻想引用是针对那些已经执行完析构函数之后，仍然需要在执行一些其它操作的对象：比如资源对象的关闭就可以用到这个引用。","like_count":72,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384003,"discussion_content":"引用的区别哪里：3:虚引用是，应该为为弱引用，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626333545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282910,"discussion_content":"可达性分析算法就是为了解决引用计数法的循环引用问题。。。  怎么可能还会出现循环引用？ 多种引用类型的出现是为了满足更丰富的使用场景，比如一些缓存之类，可以在内存告急时放弃自己，保证程序可正常运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592116608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1092044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a9/cc/c417c886.jpg","nickname":"湮灭星空","note":"","ucode":"B1061A4C298E13","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321839,"discussion_content":"你理解错了，再看一遍他的评论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604637709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282910,"ip_address":""},"score":321839,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383996,"discussion_content":"原话是：除此之外另外一种常见的算法就是引用计数法，但是这种算法有个问题就是不能解决相互引用的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626332600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282910,"ip_address":""},"score":383996,"extra":""}]},{"author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25257,"discussion_content":"这个讲的比作者透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570491754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8573,"user_name":"feitian","can_delete":false,"product_type":"c1","uid":1123623,"ip_address":"","ucode":"56167A8210F48F","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/27/5aef841d.jpg","comment_is_top":false,"comment_ctime":1526343068,"is_pvip":true,"replies":[{"id":"2577","content":"好建议，回头和极客反馈下","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526368359,"ip_address":"","comment_id":8573,"utype":1}],"discussion_count":2,"race_medal":0,"score":"237749544348","product_id":100006701,"comment_content":"我觉得录音和文字可以不一样，不要兼顾这两者，录音内容应该远多于文字，就像PPT一样，讲述的人表述的会远多于文字体现出来的东西。所以不用为了录音方便考虑文字内容多少，文字尽量能不靠录音也是完整的，录音的内容会更丰富，但有些不好描述的部分，比如代码要配合文字一起看。","like_count":55,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417774,"discussion_content":"好建议，回头和极客反馈下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526368359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2540922,"avatar":"","nickname":"Geek_309ecf","note":"","ucode":"2A41F7B21F7AFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362650,"discussion_content":"...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616998612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8474,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1526257729,"is_pvip":false,"replies":[{"id":"2512","content":"谢谢反馈，我会平衡一下，主要是贴太多代码很容易字数就满了，也不利于录音频","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526274440,"ip_address":"","comment_id":8474,"utype":1}],"discussion_count":2,"race_medal":0,"score":"199094753345","product_id":100006701,"comment_content":"希望可以配合一些实际的例子来讲解各种引用会更好，不会仅停留在理论理解层面，实际例子更有助于理解！","like_count":45,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417738,"discussion_content":"谢谢反馈，我会平衡一下，主要是贴太多代码很容易字数就满了，也不利于录音频","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526274440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1418862,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a6/6e/21907ff9.jpg","nickname":"X中倪","note":"","ucode":"F28FAFF2FEDD1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6718,"discussion_content":"作者说：贴太多代码容易字数就满了。我感觉字数不重要，重要的是，我们看了都懂。能够快速的理解、掌握，达到百问不倒。多写千吧字，浪费的是作者两个小时时间，对于不理解的内容我们花费的时间不只两个小时，网上找答案，分析对错。时间就是金钱，我不是在抢你的钱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567067611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8361,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1526117342,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"181914743774","product_id":100006701,"comment_content":"对各种引用的理解，可以理解为对象对 jvm 堆内存的占用时长。对于对象可达性垃圾回收算法，可达性可以认为回收内存的标志。<br>1，强引用，只要对象引用可达，对象使用的内存就一直被占用。<br>2，软引用，对象使用的内存一直占用，直到 jvm 认为有必要回收内存。<br>3，弱引用，对象使用的内存一直占用，直到下一次 gc。<br>求赞。😂 😂 😂 ","like_count":43,"discussions":[{"author":{"id":1811337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/89/2aaf109f.jpg","nickname":"大新","note":"","ucode":"4ABC791BD4B491","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278830,"discussion_content":"下一次GC是指新生代还是老年代？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591239277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9906,"user_name":"kursk.ye","can_delete":false,"product_type":"c1","uid":1015995,"ip_address":"","ucode":"9D6A3854E408F9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/bb/c0ed9d76.jpg","comment_is_top":false,"comment_ctime":1527153146,"is_pvip":false,"replies":[{"id":"3253","content":"非常感谢反馈；<br>关于引用计数，也有优势，我记得某个国外一线互联网公司调优python，就是只用引用计数，关闭gc","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527484647,"ip_address":"","comment_id":9906,"utype":1}],"discussion_count":2,"race_medal":0,"score":"151851008506","product_id":100006701,"comment_content":"于是我google到了这篇文章,http:&#47;&#47;www.kdgregory.com&#47;index.php?page=java.refobj ，花了几天（真的是几天，不是几小时）才基本读完，基本理解这几个reference的概念和作用，从这个角度来讲非常感谢作者，如果不是本文的介绍，我还以为GC还是按照reference counter的原理处理，原来思路早变了。话说回来，《Java Reference Objects》真值得大家好好琢磨，相信可以回答很多人的问题，比如strong reference , soft reference , weak reference怎么互转，如果一个obj 已经 = null,就obj = reference.get()呗，再有，文章中用weak reference 实现 canonicalizing map改善内存存储效率，减小存储空间的例子，真是非常经典啊。也希望作者以后照顾一下低层次读者，写好技术铺垫和名词定义。顺便问一下大家是怎么留言的，在手机上打那么多字，还有排版是怎么处理的，我是先在电脑上打好字再COPY上来的，大家和我一样吗？","like_count":36,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418248,"discussion_content":"非常感谢反馈；\n关于引用计数，也有优势，我记得某个国外一线互联网公司调优python，就是只用引用计数，关闭gc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527484647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645866,"avatar":"","nickname":"frosro","note":"","ucode":"29BB9FC40800D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7005,"discussion_content":"大神，英文不行好想哭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567251336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12071,"user_name":"kyq叶鑫","can_delete":false,"product_type":"c1","uid":1129030,"ip_address":"","ucode":"0002BFD7569B06","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/46/9fd9bd26.jpg","comment_is_top":false,"comment_ctime":1528550066,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"147557438130","product_id":100006701,"comment_content":"看到第四讲了，每一讲都看到留言有朋友说看完之后还是懵懵的希望作者多提供实际例子，因为大家都是理工思维，不喜虚的，喜欢直接上干货，建议作者可以从读者背景方面改善文章内容，软硬兼并。","like_count":34},{"had_liked":false,"id":8861,"user_name":"爱吃面的蝎子王","can_delete":false,"product_type":"c1","uid":1128773,"ip_address":"","ucode":"1A5CCC63BC509C","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/45/4ba3caec.jpg","comment_is_top":false,"comment_ctime":1526486191,"is_pvip":false,"replies":[{"id":"2699","content":"谢谢反馈，回头把必要概念加个链接或解释","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526597684,"ip_address":"","comment_id":8861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"117490603183","product_id":100006701,"comment_content":"希望作者照顾层次化的读者，讲名词概念要有具体解释，并能举例一二帮助理解，不然看完依旧似懂非懂一知半解。","like_count":27,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417876,"discussion_content":"谢谢反馈，回头把必要概念加个链接或解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526597684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8313,"user_name":"kugool","can_delete":false,"product_type":"c1","uid":1105981,"ip_address":"","ucode":"4F0E19ABE67E5A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/3d/11897c07.jpg","comment_is_top":false,"comment_ctime":1526087357,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"104605302461","product_id":100006701,"comment_content":"感觉自己的基础还很差 除了强引用 其它几个都不是很明白","like_count":24,"discussions":[{"author":{"id":1559178,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/a5U0nqaicLy5ZJkESxBd5lMicNQcTTDK8vURyyWiabHxic7vS1VVk7HWTZg6ltyWJ3n9jb3Gq554ibfjsf7bv1v1Sdw/132","nickname":"十大杰出青年","note":"","ucode":"BAB4AA12604CF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174120,"discussion_content":"我也是，一脸懵逼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581869478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8655,"user_name":"程序猿的小浣熊","can_delete":false,"product_type":"c1","uid":1118125,"ip_address":"","ucode":"7D26B2F5C4379C","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/ad/19cc513d.jpg","comment_is_top":false,"comment_ctime":1526354934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74540798966","product_id":100006701,"comment_content":"我觉得可以在github上托管事例代码，说到关键代码的时候，直接链接过去就好。这样就能丰富内容了。","like_count":17},{"had_liked":false,"id":8455,"user_name":"男人，7分熟。","can_delete":false,"product_type":"c1","uid":1129067,"ip_address":"","ucode":"D0A9F75235E646","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/6b/18329c89.jpg","comment_is_top":false,"comment_ctime":1526228715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70245705451","product_id":100006701,"comment_content":"留言区，个个都是人才","like_count":16},{"had_liked":false,"id":8720,"user_name":"Geek_5b11b8","can_delete":false,"product_type":"c1","uid":1131898,"ip_address":"","ucode":"B1BBA989A08D6B","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/7a/3f8241ef.jpg","comment_is_top":false,"comment_ctime":1526385596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65950895036","product_id":100006701,"comment_content":"看了之后，收获不是很大，有没有具体的应用案例或者实际开发中的应用场景","like_count":15},{"had_liked":false,"id":8484,"user_name":"面试官问","can_delete":false,"product_type":"c1","uid":1009375,"ip_address":"","ucode":"F9CE89589772F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/df/501ba989.jpg","comment_is_top":false,"comment_ctime":1526260915,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"61655803059","product_id":100006701,"comment_content":"Android开发面试中这道题大家基本都会，Java后端面试中遇到好些人说没听过的，说到底有部分人还是Java基础不过关，只会用框架。","like_count":15},{"had_liked":false,"id":8405,"user_name":"coder王","can_delete":false,"product_type":"c1","uid":1121990,"ip_address":"","ucode":"21465DC3850BCB","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/c6/6f817e6e.jpg","comment_is_top":false,"comment_ctime":1526183981,"is_pvip":false,"replies":[{"id":"2502","content":"图片相当比较大，所以图片缓存是典型场景","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526270873,"ip_address":"","comment_id":8405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53065791533","product_id":100006701,"comment_content":"Android 中的Glide 图片加载框架的内存缓存就使用到了弱引用缓存机制😁","like_count":12,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417700,"discussion_content":"图片相当比较大，所以图片缓存是典型场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526270873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91007,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1106515,"ip_address":"","ucode":"A2FD39E882DF19","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/53/ff7501a2.jpg","comment_is_top":false,"comment_ctime":1556783785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40211489449","product_id":100006701,"comment_content":"几种引用可以形象化为下面的例子<br>公司的优化制度<br>强引用，优秀员工，即便公司亏空也不优化<br>软引用，一般员工，公司亏空时才优化<br>弱引用，通知要优化，但还在公司<br>虚引用，已经优化，不在公司了，留着引用不为他来干事，而是最后给到这个人发工资","like_count":8},{"had_liked":false,"id":8340,"user_name":"wangbo","can_delete":false,"product_type":"c1","uid":1125722,"ip_address":"","ucode":"3F0C9C320F0A1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/5a/d965c147.jpg","comment_is_top":false,"comment_ctime":1526100456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40180806120","product_id":100006701,"comment_content":"除了强引用，其它的都不懂","like_count":9},{"had_liked":false,"id":47862,"user_name":"windam","can_delete":false,"product_type":"c1","uid":1154114,"ip_address":"","ucode":"8ED1BEAFFDAD30","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/42/b1fa9a1a.jpg","comment_is_top":false,"comment_ctime":1544238369,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31609009441","product_id":100006701,"comment_content":"Reference.reachabilityFence(this);<br><br>没有理解这个例子是怎么保护try块中的执行代码的。<br><br>reachabilityFence 发生在 finally里，那么，这句话执行的时候，不是try块里的代码已经执行完成过了吗？<br><br>如果执行try块中的代码时，还没有走到这句，jvm 又怎么知道不能对这个对象做 finalize？<br><br>","like_count":7,"discussions":[{"author":{"id":1446316,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","nickname":"Corner","note":"","ucode":"7862D593172536","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38295,"discussion_content":"R大的解释https://www.zhihu.com/question/51244545/answer/126055789","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571756953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561459104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8382,"user_name":"凉白开","can_delete":false,"product_type":"c1","uid":1119698,"ip_address":"","ucode":"B20E671BE97649","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/d2/be877cf2.jpg","comment_is_top":false,"comment_ctime":1526138579,"is_pvip":false,"replies":[{"id":"2507","content":"正解，前面回复过，ThteadLocal是和线程生命周期绑定的，所以遇到线程池就可能出现这种问题，因为worker通常一直活着","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526272948,"ip_address":"","comment_id":8382,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31590909651","product_id":100006701,"comment_content":"threadlocalmap里的key为弱引用 使用过后 应该remove  否则容易出现oom 因为可能key被回收了 它的值还在","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417690,"discussion_content":"正解，前面回复过，ThteadLocal是和线程生命周期绑定的，所以遇到线程池就可能出现这种问题，因为worker通常一直活着","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526272948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103445,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/55/47e76936.jpg","nickname":"叶易","note":"","ucode":"0983EA217ACF28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181123,"discussion_content":"杨老师这个场景应该有问题吧，在线程池中应该不能直接使用ThreadLocal","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582339896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48896,"user_name":"lasdaybg","can_delete":false,"product_type":"c1","uid":1053818,"ip_address":"","ucode":"C292CF7263ED81","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/7a/7b8dd310.jpg","comment_is_top":false,"comment_ctime":1544576444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27314380220","product_id":100006701,"comment_content":"我是来看评论的","like_count":6},{"had_liked":false,"id":20586,"user_name":"Kris","can_delete":false,"product_type":"c1","uid":1206813,"ip_address":"","ucode":"0D01BE449E1EC8","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/1d/466e21a0.jpg","comment_is_top":false,"comment_ctime":1534568001,"is_pvip":false,"replies":[{"id":"7562","content":"看来文章需要改进...","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1535038273,"ip_address":"","comment_id":20586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27304371777","product_id":100006701,"comment_content":"是我基础太差了吗？看着似懂非懂朦朦胧胧的感觉","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422317,"discussion_content":"看来文章需要改进...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535038273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8318,"user_name":"有渔@蔡","can_delete":false,"product_type":"c1","uid":1099829,"ip_address":"","ucode":"4AB669229892C8","user_header":"","comment_is_top":false,"comment_ctime":1526088859,"is_pvip":false,"replies":[{"id":"2444","content":"已回复，如果有其他情况可以介绍一下细节，马上飞机去美国，有段时间不能回复，抱歉","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526101714,"ip_address":"","comment_id":8318,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27295892635","product_id":100006701,"comment_content":"好文章，就需要这样深的。有个留言问ThreadLocal中，entry的key为软引用，value为实际object.当key被回收后，object会产生内存泄露问题。同请具体解答。谢谢","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417671,"discussion_content":"已回复，如果有其他情况可以介绍一下细节，马上飞机去美国，有段时间不能回复，抱歉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526101714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1635513,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f4/b9/66f78e40.jpg","nickname":"杨军","note":"","ucode":"1BB7B6DCD42A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5461,"discussion_content":"不会产生内存泄漏，value正常情况下会被回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566286100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8315,"user_name":"鸠摩智","can_delete":false,"product_type":"c1","uid":1106201,"ip_address":"","ucode":"853E584FC4CD64","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/19/c756aaed.jpg","comment_is_top":false,"comment_ctime":1526087599,"is_pvip":true,"replies":[{"id":"2442","content":"未必是直接写，类似基础架构处理mysql oom就会用到了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526100985,"ip_address":"","comment_id":8315,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27295891375","product_id":100006701,"comment_content":"这个确实是日常开发所接触不到的知识点，所以看起来挺费力的","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417668,"discussion_content":"未必是直接写，类似基础架构处理mysql oom就会用到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526100985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8314,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1526087515,"is_pvip":false,"replies":[{"id":"2443","content":"1，被缓存的对象在使用时是有强引用的<br>2，这种通常是ThreadLocal被worker线程音乐了，worker不会停的<br>3，按照Java语言规范发生回收是合规的，所以极端情况会出现field不可用情况","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526101431,"ip_address":"","comment_id":8314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27295891291","product_id":100006701,"comment_content":"1. 一直不太理解弱引用。文中的“比如”在其他好多地方也这么说——“如果试图获取对象时...否则重新实例化”，但习惯并发编程的人会觉得，假如刚实例化之后，又恰好被回收了呢？<br>2.后来看了ThreadLocalMap的Entry代码，我会觉得“弱引用也许为了一些工具类在设计时又要考虑易用性，又要尽量防止开发者编程不当造成内存泄漏”，比如Entry弱引用了ThreadLocal&lt;?&gt;，就不会由于Entry本身一直存在使得对应的ThreadLocal&lt;?&gt;实例一直无法回收？<br>3. new Resource().action()那里我以前一直以为，对象的方法在运行期间一定会持有this引用，间接使得对象的field可达不会被回收。现在看来是错的？<br><br>请老师解惑和纠错一下万分感谢","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417667,"discussion_content":"1，被缓存的对象在使用时是有强引用的\n2，这种通常是ThreadLocal被worker线程音乐了，worker不会停的\n3，按照Java语言规范发生回收是合规的，所以极端情况会出现field不可用情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526101431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82980,"user_name":"书生依旧","can_delete":false,"product_type":"c1","uid":1069827,"ip_address":"","ucode":"4B2181160AD303","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/03/24a892b7.jpg","comment_is_top":false,"comment_ctime":1554364732,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23029201212","product_id":100006701,"comment_content":"回复 Miaozhe：<br><br>带有非空的 finalize() 方法的类会被 JVM 特殊处理：当 GC 发现这样的类的一个实例已经不再被任何活的强引用所引用时，就会把它放入 finalizer queue，排队调用其 finalize() 方法。而当这样的一个实例的 fianlize() 方法被调用（并且该实例没有被复活）之后，下一次 GC 就可以把它看作普通对象来清理掉了。<br><br>所以一个带 finalize() 方法的类的实例，从已经失去所有强引用到真正被GC回收，通常要经历两次GC。<br><br>所以，想让视线 finalize 的虚引用 enque 需要三行代码：<br><br>System.gc();  &#47;&#47; 将虚引用加入 finalizer queue<br>System.runFinalization();  &#47;&#47; 迫使虚应用的 finalize 执行<br>System.gc();  &#47;&#47; GC 清除虚引用，enque<br>","like_count":5,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285927,"discussion_content":"扯淡，一个System.gc(); 就够了。这里面有非空fianlize方法么？木有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592990255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215145,"discussion_content":"最后的三行代码 解释有问题吧。。finalize之后，才会将 虚引用queue到自己的refQueue吧。。到底啥时候检测 refQueue.remove() 其使用场景 才是关键吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585290828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8852,"user_name":"小情绪","can_delete":false,"product_type":"c1","uid":1020311,"ip_address":"","ucode":"92D8081DB8DB45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/97/3762ca10.jpg","comment_is_top":false,"comment_ctime":1526482833,"is_pvip":false,"replies":[{"id":"2639","content":"好的，后面文章平衡下，贴多了代码也有人说凑字数...","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526517143,"ip_address":"","comment_id":8852,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23001319313","product_id":100006701,"comment_content":"多谢杨老师，建议多结合代码讲解会更清晰，毕竟代码是最好的诠释。","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417868,"discussion_content":"好的，后面文章平衡下，贴多了代码也有人说凑字数...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526517143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24625,"user_name":"爱喝咖啡的小锐锐","can_delete":false,"product_type":"c1","uid":1227884,"ip_address":"","ucode":"2F7595ECC51DC8","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/6c/2a0e7f61.jpg","comment_is_top":false,"comment_ctime":1537174394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18717043578","product_id":100006701,"comment_content":"看了三四遍，在去百度了一下其他博客，勉强大概能懂一些，还是希望有实际场合结合或者简单但的例子，基础不是特别好，有实际场景demo代码可能看着更懂一些。","like_count":4},{"had_liked":false,"id":8436,"user_name":"gayguygogogo","can_delete":false,"product_type":"c1","uid":1116813,"ip_address":"","ucode":"4D2C6D9D1BA39F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/8d/f30e204f.jpg","comment_is_top":false,"comment_ctime":1526217000,"is_pvip":false,"replies":[{"id":"2508","content":"好的，谢谢反馈","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526273001,"ip_address":"","comment_id":8436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18706086184","product_id":100006701,"comment_content":"讲些能夯实基础同时在开发中需要用到的","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417718,"discussion_content":"好的，谢谢反馈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526273001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8410,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1526188995,"is_pvip":false,"replies":[{"id":"2503","content":"谢谢，我尽量兼顾，有不足后面会补充","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526270943,"ip_address":"","comment_id":8410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18706058179","product_id":100006701,"comment_content":"看得还是比较蒙，希望配合一些例子举例说明","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417702,"discussion_content":"谢谢，我尽量兼顾，有不足后面会补充","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526270943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8308,"user_name":"呵呵","can_delete":false,"product_type":"c1","uid":1052862,"ip_address":"","ucode":"986CC73CFBBC67","user_header":"","comment_is_top":false,"comment_ctime":1526084997,"is_pvip":false,"replies":[{"id":"2448","content":"可以简化下几个方面：对gc是否影响；什么时候enqueue；get返回什么","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526103069,"ip_address":"","comment_id":8308,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18705954181","product_id":100006701,"comment_content":"弱引用，幻影引用还是理解不清楚","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417664,"discussion_content":"可以简化下几个方面：对gc是否影响；什么时候enqueue；get返回什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526103069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144334,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571899801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14456801689","product_id":100006701,"comment_content":"强引用表示没你不可<br>软引用表示有你最好<br>弱引用表示你可有可无<br>幻像引用表示你将死，还是把身外之物分了吧。<br><br>","like_count":3},{"had_liked":false,"id":67882,"user_name":"Lh","can_delete":false,"product_type":"c1","uid":1102951,"ip_address":"","ucode":"19CA4286A49DB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/67/0eaa81a4.jpg","comment_is_top":false,"comment_ctime":1550308798,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14435210686","product_id":100006701,"comment_content":"在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。<br><br>1 强引用<br><br>特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。<br><br>2 软引用<br><br>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。<br><br>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<br><br>3 弱引用<br><br>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><br>应用场景：弱应用同样可用于内存敏感的缓存。<br><br>4 虚引用<br><br>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue); <br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。<br><br>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。","like_count":3,"discussions":[{"author":{"id":1436675,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ec/03/eeb4bdc9.jpg","nickname":"建","note":"","ucode":"4B5CBCB5610CC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158566,"discussion_content":"比作者讲的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580605412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344,"discussion_content":"感觉比作者讲得清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561459398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31391,"user_name":"黑羽","can_delete":false,"product_type":"c1","uid":1053338,"ip_address":"","ucode":"D68FD2B38A1D0E","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/9a/062f83c8.jpg","comment_is_top":false,"comment_ctime":1539170881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14424072769","product_id":100006701,"comment_content":"老师讲得有点抽象，最后可以举例讲下在实际项目中几种引用的应用。<br>请问：<br>1. 软引用和弱引用在什么时候加入引用队列？是在finalize方法执行之前吗？<br>2. 幻象引用在什么时候加入引用队列？幻象引用是不是在finalize方法执行完在对象被回收之前加入队列？","like_count":3},{"had_liked":false,"id":8311,"user_name":"funnyx","can_delete":false,"product_type":"c1","uid":1115049,"ip_address":"","ucode":"A9B8E27919AE4D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoZqcVJzUjfu5noOW6OPAh6ibrBicibLmicibnVyVLHdf7GwAzf2th5s1oQ9pUbLpmq2mlVBauUZn8QUnw/132","comment_is_top":false,"comment_ctime":1526085879,"is_pvip":false,"replies":[{"id":"2445","content":"我理解，FQ移除后，如果有幻象引用，就处于幻象可达状态，走对应逻辑，然后就可以销毁了；如果没有幻象引用，就直接处于不可达状态，可以销毁","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526101995,"ip_address":"","comment_id":8311,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14410987767","product_id":100006701,"comment_content":"有个问题想请教一下峰哥，就是对象回收的时机，如果最后这个对象被认为要回收，那么会被添加到F-QUEUE的一个队列中，由一个优先级比较低的线程缓慢执行，在JVM对该队列进行标记之后，如果该对象还没有和引用链建立关联，那么该对象应该就被回收了，但是如果被调用了finalize()方法，该对象也不一定会被回收，那么该对象从F-QUEUE被移除之后，后续的垃圾回收该如何进行？因为一个finalize（）最多只会被调用一次。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417666,"discussion_content":"我理解，FQ移除后，如果有幻象引用，就处于幻象可达状态，走对应逻辑，然后就可以销毁了；如果没有幻象引用，就直接处于不可达状态，可以销毁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526101995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268787,"user_name":"acqierement","can_delete":false,"product_type":"c1","uid":1234980,"ip_address":"","ucode":"AC8DA74B9CB924","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/24/f48a38f4.jpg","comment_is_top":false,"comment_ctime":1608348577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10198283169","product_id":100006701,"comment_content":"1:  强引用：代码中普遍存在的引用赋值，比如 Object =new Object(); 无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。<br>2：软引用：用来描述一些还有用，但非必须的对象。在系统将要发生内存溢出前，会被回收。<br>3：弱引用：用来描述非必须对象。不论内存是否足够，垃圾回收时弱引用对象都会被回收。<br>4：虚引用：无法通过虚引用来访问对象实例，完全不会对对象的生存周期造成影响。和引用队列结合使用，可用于追踪垃圾收集，在对象被清理时发出系统通知。<br>","like_count":2},{"had_liked":false,"id":148355,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1572998243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10162932835","product_id":100006701,"comment_content":"4 强引用，软引用，弱引用，幻像引用 变量除了原始的数据类型，其他所有的都是引用类型，指向各种不同的对象 ，不同的引用类型，提现的是对象不同的可达性状态和对垃圾收集的影响，4.1 强引用 最常见的普通对象引用，只要有强引用指向这种对象，垃圾收集器不会碰，如果没有其他的引用关系，超过作用域或者指向null，垃圾收集器就会进行回收 4.2 软引用 是相对强对象弱化的引用，可以让对象赦免一些垃圾收集，是JVM发现内存不够时，会把软引用的对象回收，一般用于内存缓存 ，如果有内存会先不回收 4.3 弱引用 不能使对象免于垃圾收集，仅仅提供了一种访问弱对象的途径，如果对象在就使用，不在就创建。缓存也是这种类型 4.4 幻像引用 不能通过它访问对象，仅仅是提供了一种机制，在对象在finalize之后，做某些事情的机制。4.5 对象的状态分析 创建对象到对象初始化到强引用状态，强引用即强可达，比如创建一个对象，创建对象的线程对对象就是强可达，强引用可以和软引用和弱引用互转，除了弱引用不能转为软引用，这三种引用都可以被finalize，幻像可达，没有强可达，软和弱可达，并且finalize过，只有幻像引用指向这个对象，最后一个状态 unreachable ，意味着对象可以被清理了。除了幻像引用，强引用，软，弱引用都可以通过get获取对象，弱引用就变成了强引用，垃圾收集器也会二次确认，看下弱引用和软引用没有转成强引用。","like_count":2},{"had_liked":false,"id":90136,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556424278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10146358870","product_id":100006701,"comment_content":"ArrayBlockingQueue 中的Itr用到了 若引用<br><br>  class Itrs {<br><br>        &#47;**<br>         * Node in a linked list of weak iterator references.<br>         *&#47;<br>        private class Node extends WeakReference&lt;Itr&gt; {<br>            Node next;<br><br>            Node(Itr iterator, Node next) {<br>                super(iterator);<br>                this.next = next;<br>            }<br>        }<br>}<br><br>还有 ForkJoinTask中也用到了若引用<br><br>    static final class ExceptionNode extends WeakReference&lt;ForkJoinTask&lt;?&gt;&gt; {<br>        final Throwable ex;<br>        ExceptionNode next;<br>        final long thrower;  &#47;&#47; use id not ref to avoid weak cycles<br>        final int hashCode;  &#47;&#47; store task hashCode before weak ref disappears<br>        ExceptionNode(ForkJoinTask&lt;?&gt; task, Throwable ex, ExceptionNode next) {<br>            super(task, exceptionTableRefQueue);<br>            this.ex = ex;<br>            this.next = next;<br>            this.thrower = Thread.currentThread().getId();<br>            this.hashCode = System.identityHashCode(task);<br>        }<br>    }<br><br>很多地方都用到了 Reference 但是用来做什么了，  还需要自己再好好看看，找这样的专栏多读读。 ","like_count":2},{"had_liked":false,"id":85754,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1555223265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145157857","product_id":100006701,"comment_content":"Java中的四种引用状态，和C++ boost中的智能指针其实挺相似的。当然并非是完全一致啦。<br>boost::scoped_ptr<br>boost::shared_ptr<br>boost::weak_ptr<br>boost::intrusive_ptr<br>感觉很多时候跨语言比较一下，会对大家更有提高一些呢。","like_count":2},{"had_liked":false,"id":56094,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1546392736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10136327328","product_id":100006701,"comment_content":"在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。<br><br>1 强引用<br><br>特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。<br><br>2 软引用<br><br>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。<br><br>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<br><br>3 弱引用<br><br>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br><br>应用场景：弱应用同样可用于内存敏感的缓存。<br><br>4 虚引用<br><br>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue); <br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。<br><br>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。","like_count":2},{"had_liked":false,"id":31685,"user_name":"郝攀刚จุ๊บ","can_delete":false,"product_type":"c1","uid":1206745,"ip_address":"","ucode":"8AE7A85093E51A","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/d9/968df259.jpg","comment_is_top":false,"comment_ctime":1539264593,"is_pvip":false,"replies":[{"id":"11964","content":"理解这个更多是利于当出现引用处理问题时诊断，例如gc被影响，资源未释放","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1539737169,"ip_address":"","comment_id":31685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10129199185","product_id":100006701,"comment_content":"感觉理论上的话都懂。但是具体用在什么地方，或者自己在项目上哪些情况可以用，这都不太清楚！","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426465,"discussion_content":"理解这个更多是利于当出现引用处理问题时诊断，例如gc被影响，资源未释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539737169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8510,"user_name":"Mr. Zhang","can_delete":false,"product_type":"c1","uid":1126169,"ip_address":"","ucode":"AB955F70FC8355","user_header":"https://static001.geekbang.org/account/avatar/00/11/2f/19/8de031a1.jpg","comment_is_top":false,"comment_ctime":1526282005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10116216597","product_id":100006701,"comment_content":"还是配合例子讲解会比较清楚","like_count":2},{"had_liked":false,"id":8506,"user_name":"孙晓明","can_delete":false,"product_type":"c1","uid":1117094,"ip_address":"","ucode":"CAD28E4D5A3E76","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/a6/b234aa79.jpg","comment_is_top":false,"comment_ctime":1526276687,"is_pvip":false,"replies":[{"id":"2532","content":"恕我孤陋寡闻了，没有什么直接关系","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526343909,"ip_address":"","comment_id":8506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10116211279","product_id":100006701,"comment_content":"看完这篇文章之后，对这四种引用还是一知半解。不知道它们与JVM中heap的新生代，老生代，永代是什么关系？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417751,"discussion_content":"恕我孤陋寡闻了，没有什么直接关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526343909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118274,"user_name":"吴晓波尼尼","can_delete":false,"product_type":"c1","uid":1617844,"ip_address":"","ucode":"1C806CFC6ADC36","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/usX58SweWDFqjCmtkvPOWD3QUKZGlpNpibZvrTwiaOwPvcCLYjU2AST5GvicjFOdScUmuribQJiciaGkxj4FJzYVcVcA/132","comment_is_top":false,"comment_ctime":1564306997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859274293","product_id":100006701,"comment_content":" String string = new String(&quot;强引用&quot;);<br> System.out.println(string);<br> WeakReference&lt;String&gt; stringWeakReference = new WeakReference&lt;&gt;(new String(&quot;234&quot;));<br> System.out.println(stringWeakReference.get());<br> string = stringWeakReference.get();<br> System.gc();<br> System.out.println(stringWeakReference.get());<br>弱引用指向强引用是这么实现的吗","like_count":1},{"had_liked":false,"id":81878,"user_name":"请叫我华仔","can_delete":false,"product_type":"c1","uid":1465300,"ip_address":"","ucode":"307D39B12CEF61","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/d4/f4a2888a.jpg","comment_is_top":false,"comment_ctime":1554077655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849044951","product_id":100006701,"comment_content":"测试了一下，限定Xmx100m，然后创建1000个占1M内存的数组，强引用报OOM，软引用和弱引用不报内存溢出。软引用情况下，进行full gc，耗时更长。<br><br>WeakHashMap原理<br>Entry继承了WeakReference，key被弱引用，可以被回收。如果key被回收，则该Entry被放入引用队列。在对WeakHashMap进行操作时，会先清理已经放入引用队列的Entry，value是这时候去掉强引用的。有一个问题：会不会出现弱引用对象已经被回收，但还没有进入到队列的情况？这种情况出现，应该对功能没影响，因为此时WeakReference的get会返回null。","like_count":1},{"had_liked":false,"id":35614,"user_name":"维#","can_delete":false,"product_type":"c1","uid":1125848,"ip_address":"","ucode":"DC5FFFD2C1E895","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/d8/e06ec517.jpg","comment_is_top":false,"comment_ctime":1540710122,"is_pvip":true,"replies":[{"id":"16129","content":"臭名昭著的问题","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1543625428,"ip_address":"","comment_id":35614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835677418","product_id":100006701,"comment_content":"上个月ThreadLocal在线程池环境下，OOM过，记忆犹新。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427599,"discussion_content":"臭名昭著的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543625428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33367,"user_name":"奇妙","can_delete":false,"product_type":"c1","uid":1254221,"ip_address":"","ucode":"DCB796520024ED","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/4d/24433399.jpg","comment_is_top":false,"comment_ctime":1539780210,"is_pvip":false,"replies":[{"id":"12319","content":"出作用域即可，一般不需要明确设置为null","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1540256454,"ip_address":"","comment_id":33367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834747506","product_id":100006701,"comment_content":"杨老师，请问是不是在设置对象为空，以及方法弹栈，导致方法中对象的作用域消失，才能被gc关注到？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426964,"discussion_content":"出作用域即可，一般不需要明确设置为null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540256454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16474,"user_name":"needEndeavor.","can_delete":false,"product_type":"c1","uid":1114817,"ip_address":"","ucode":"2AEE0BB0F6471F","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/c1/9fd29367.jpg","comment_is_top":false,"comment_ctime":1531969865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5826937161","product_id":100006701,"comment_content":"有个疑问，当软引用的构造函数传入引用队列的条件下，到底是在对象被回收后，引用加入到队列中？还是在回收前该引用加入队列中的？","like_count":1},{"had_liked":false,"id":15893,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1531620928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5826588224","product_id":100006701,"comment_content":"老师好，有个疑问想问下，弱引用一旦被回收，就会加入注册引用队列，那么引用队列不一样会占用内存，不等于没有回收么？","like_count":1},{"had_liked":false,"id":9628,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1114542,"ip_address":"","ucode":"29FA49EEDBFF92","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg","comment_is_top":false,"comment_ctime":1526993365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821960661","product_id":100006701,"comment_content":"软引用在内存不足时回收，而弱引用在有内存回收发生时就会被回收掉","like_count":1},{"had_liked":false,"id":9626,"user_name":"岁月如歌","can_delete":false,"product_type":"c1","uid":1114542,"ip_address":"","ucode":"29FA49EEDBFF92","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/ae/f298ef27.jpg","comment_is_top":false,"comment_ctime":1526993044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821960340","product_id":100006701,"comment_content":"软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象","like_count":1},{"had_liked":false,"id":9592,"user_name":"张小来","can_delete":false,"product_type":"c1","uid":1124295,"ip_address":"","ucode":"87E5B615E3823D","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/c7/75b7631c.jpg","comment_is_top":false,"comment_ctime":1526973122,"is_pvip":false,"replies":[{"id":"2964","content":"图片","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527035932,"ip_address":"","comment_id":9592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5821940418","product_id":100006701,"comment_content":"对内存敏感的缓存，老师可以举个例子吗？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418128,"discussion_content":"图片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527035932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9515,"user_name":"牛肉味鲜果橙","can_delete":false,"product_type":"c1","uid":1121522,"ip_address":"","ucode":"5640DBE28E83F6","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/f2/6548ab5e.jpg","comment_is_top":false,"comment_ctime":1526946152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821913448","product_id":100006701,"comment_content":"这个系列的学习买的好值，既能看到作者对Java深层次的讲解，又能看能评论专区的各种大神的理解。","like_count":1},{"had_liked":false,"id":8838,"user_name":"微笑的向日葵","can_delete":false,"product_type":"c1","uid":1099151,"ip_address":"","ucode":"90659BD4413DF1","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/8f/80443115.jpg","comment_is_top":false,"comment_ctime":1526476861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821444157","product_id":100006701,"comment_content":"并没有 第一次听说这个东西","like_count":1},{"had_liked":false,"id":8752,"user_name":"刀健笑","can_delete":false,"product_type":"c1","uid":1037084,"ip_address":"","ucode":"4077841DA72DCB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/1c/7b106c98.jpg","comment_is_top":false,"comment_ctime":1526402850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821370146","product_id":100006701,"comment_content":"“这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例”，否则重现实例”是指？","like_count":1},{"had_liked":false,"id":8498,"user_name":"jutsu","can_delete":false,"product_type":"c1","uid":1124574,"ip_address":"","ucode":"95CEDEF5D085CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/28/de/54667f13.jpg","comment_is_top":false,"comment_ctime":1526268877,"is_pvip":true,"replies":[{"id":"2523","content":"加油💪","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526276944,"ip_address":"","comment_id":8498,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5821236173","product_id":100006701,"comment_content":"感觉自己理解的慢，每天都会吸收一点进步一点点，谢谢老师","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417747,"discussion_content":"加油💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526276944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8335,"user_name":"thinkers","can_delete":false,"product_type":"c1","uid":1031712,"ip_address":"","ucode":"81159393491E8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/20/8f4e0810.jpg","comment_is_top":false,"comment_ctime":1526096900,"is_pvip":false,"replies":[{"id":"2441","content":"除非对于性能完全不敏感，这就是差不多和极致的差别，有兴趣可以看看netty之类底层的优化","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526100869,"ip_address":"","comment_id":8335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5821064196","product_id":100006701,"comment_content":"除了8种基本数据类型(int,short,byte,long,double,float,boolean,char)，其他都是引用类型！感觉这种引用的分类没有任何实际作用，开发中基本可以忽略点！","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417677,"discussion_content":"除非对于性能完全不敏感，这就是差不多和极致的差别，有兴趣可以看看netty之类底层的优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526100869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8323,"user_name":"George Gong","can_delete":false,"product_type":"c1","uid":1123724,"ip_address":"","ucode":"079FD5B8406948","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/8c/1c9f98f2.jpg","comment_is_top":false,"comment_ctime":1526092593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821059889","product_id":100006701,"comment_content":"这几个引用还是不太懂啊！","like_count":1},{"had_liked":false,"id":352986,"user_name":"开到荼蘼","can_delete":false,"product_type":"c1","uid":2063945,"ip_address":"北京","ucode":"EB5C016D0AA830","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7e/49/2efce374.jpg","comment_is_top":false,"comment_ctime":1659064649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659064649","product_id":100006701,"comment_content":"1.强引用是通过new创建的，我想知道怎么从强引用变成软引用或者弱引用，从代码层面是怎么变化的？<br>2.既然finalize不可靠，虚引用只能通过finalize转变，那虚引用存在有其必要性吗？","like_count":0},{"had_liked":false,"id":339482,"user_name":"🐟🐟🐟","can_delete":false,"product_type":"c1","uid":1607912,"ip_address":"","ucode":"FA780B0100906E","user_header":"https://static001.geekbang.org/account/avatar/00/18/88/e8/b9c40dfe.jpg","comment_is_top":false,"comment_ctime":1648126427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648126427","product_id":100006701,"comment_content":"java.beans.BeanDescriptor有用到WeakReference","like_count":0},{"had_liked":false,"id":336831,"user_name":"ahao","can_delete":false,"product_type":"c1","uid":2898682,"ip_address":"","ucode":"BA63BE2FD58AAB","user_header":"https://static001.geekbang.org/account/avatar/00/2c/3a/fa/31f5319d.jpg","comment_is_top":false,"comment_ctime":1646387991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646387991","product_id":100006701,"comment_content":"老师，有个问题问您一下：对象被GC后，非强引用会被JVMpush进ReferenceQueue，那该queue中的对象何时被清除呢？还是只能人为的remove？","like_count":0},{"had_liked":false,"id":330556,"user_name":"不告诉你","can_delete":false,"product_type":"c1","uid":1140831,"ip_address":"","ucode":"983AE997A29B1A","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/5f/2b4abbb6.jpg","comment_is_top":false,"comment_ctime":1642039959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642039959","product_id":100006701,"comment_content":"为何要设计这么多的引用类型，只保留强引用不香吗？","like_count":0},{"had_liked":false,"id":302990,"user_name":"熊猫","can_delete":false,"product_type":"c1","uid":1080238,"ip_address":"","ucode":"23C85117A16BEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","comment_is_top":false,"comment_ctime":1626497269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626497269","product_id":100006701,"comment_content":"老师，讲的时候希望多举例，连贯些哈，现在看完感觉还是迷迷糊糊","like_count":0},{"had_liked":false,"id":296325,"user_name":"AAA_叶子","can_delete":false,"product_type":"c1","uid":1325994,"ip_address":"","ucode":"1E93617D308EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/aa/e8dfcd7e.jpg","comment_is_top":false,"comment_ctime":1622900136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622900136","product_id":100006701,"comment_content":"强引用： 普通的new 对象<br>软引用：第三方JVM 换成 caffeine 可以创建软引用或者弱引用的key和value<br>弱引用：jdk 里面的 ThreadLocal <br>幻象引用：jdk nio 里面的 DirectBuff 里面的 堆外回收Cleaner 实现。","like_count":0},{"had_liked":false,"id":294529,"user_name":"平常心","can_delete":false,"product_type":"c1","uid":1446513,"ip_address":"","ucode":"BF777548DDC920","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/71/46b3ad0a.jpg","comment_is_top":false,"comment_ctime":1621991368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621991368","product_id":100006701,"comment_content":"我这里有个问题，文中说。   如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。 那我可以理解为赋值给static变量后即使他被主动置为null 也不会变为弱引用吗","like_count":0},{"had_liked":false,"id":279494,"user_name":"子豪sirius","can_delete":false,"product_type":"c1","uid":1117023,"ip_address":"","ucode":"E8D08D2D33E785","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/5f/2cc4060c.jpg","comment_is_top":false,"comment_ctime":1613805562,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1613805562","product_id":100006701,"comment_content":"Reachability Fence这个例子不是很明白。“有些时候，对象本身并没有强引用，但是也许它的部分属性还在被使用”。Resouce创建但是没有付给一个强引用，可能会导致垃圾回收。但是它的部分属性还在被使用。是指哪个属性？如果没有强引用执行Resource的对象，它的属性要通过什么方式使用呢？感觉矛盾","like_count":0},{"had_liked":false,"id":263497,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1606143165,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1606143165","product_id":100006701,"comment_content":"强引用 Strong Reference，常见普通对象引用，表明对象还“活着”，不会被垃圾收集。对应 强可达 Strongly Reachable<br><br>软引用 SoftReference，当 JVM 认为内存不足时，会试图回收，适合用来实现内存敏感的缓存。对应软可达 Softly Reachable<br><br>弱引用 WeakReference，不能豁免垃圾回收，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则就重新实例化。对应弱可达 Weakly Reachable<br><br>幻象引用、虚引用 Phantom Reference，提供一种确保对象在 finalize 以后做事情的机制，比如 Post-Mortem 清理。对应幻象可达 Phantom Reachable","like_count":0},{"had_liked":false,"id":262413,"user_name":"AAA_叶子","can_delete":false,"product_type":"c1","uid":1325994,"ip_address":"","ucode":"1E93617D308EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/aa/e8dfcd7e.jpg","comment_is_top":false,"comment_ctime":1605710395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605710395","product_id":100006701,"comment_content":"NIO里面 用幻象引用 回收堆外内存。ThreadLocal 使用了弱引用","like_count":0},{"had_liked":false,"id":260144,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1604930780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604930780","product_id":100006701,"comment_content":"说实话从来没关心过各种引用，如果不是看到老师的专栏，我都不知道还有幻象引用","like_count":0},{"had_liked":false,"id":253089,"user_name":"陈老幺","can_delete":false,"product_type":"c1","uid":1383995,"ip_address":"","ucode":"6811AD3B0DECA0","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/3b/869684f0.jpg","comment_is_top":false,"comment_ctime":1602592966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602592966","product_id":100006701,"comment_content":"看留言区很有意思，每节看完之后都很期待留言区😁","like_count":0},{"had_liked":false,"id":233595,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1594363854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594363854","product_id":100006701,"comment_content":"做好了reachabilityFence例子的笔记，常用的弱引用有关的对象是ThreadLocal","like_count":0},{"had_liked":false,"id":231132,"user_name":"傅宇新","can_delete":false,"product_type":"c1","uid":1608817,"ip_address":"","ucode":"262496F0E29E84","user_header":"https://static001.geekbang.org/account/avatar/00/18/8c/71/0d1a0ae9.jpg","comment_is_top":false,"comment_ctime":1593590524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593590524","product_id":100006701,"comment_content":"其实很多人应该是了解这四种引用，但是在实际中 什么场景使用还是迷迷糊糊的 老师如果能从实际中举例那就厉害了","like_count":0},{"had_liked":false,"id":214837,"user_name":"云计算小菜鸟","can_delete":false,"product_type":"c1","uid":1146734,"ip_address":"","ucode":"D32CA551ACCF56","user_header":"https://static001.geekbang.org/account/avatar/00/11/7f/6e/863e4b2a.jpg","comment_is_top":false,"comment_ctime":1588829232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588829232","product_id":100006701,"comment_content":"老师和同学们，我有一个小问题想请教一下：<br>老师的这句话：这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！<br>请问软引用和弱引用不是事先定义好的吗？是软引用和弱引用使用get方法之后就会变成强引用这个意思吗？<br>可是为什么呢？<br>本人比较菜 希望各位解答一下谢谢！","like_count":0},{"had_liked":false,"id":200522,"user_name":"地表十进制","can_delete":false,"product_type":"c1","uid":1855791,"ip_address":"","ucode":"C3B5B60748CE67","user_header":"","comment_is_top":false,"comment_ctime":1585615608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585615608","product_id":100006701,"comment_content":"对应强引用，理解为new出来的对象赋值给一个变量。<br><br>软引用-softreference:在内存不足时，垃圾回收器执行时不会回收，反之回收。<br><br>弱引用-weakreference:不管内存是否足够，垃圾回收器执行时都会回收。","like_count":0},{"had_liked":false,"id":197723,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1585395095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585395095","product_id":100006701,"comment_content":"虚引用能不能频繁用呢","like_count":0},{"had_liked":false,"id":196220,"user_name":"ilovealt","can_delete":false,"product_type":"c1","uid":1113180,"ip_address":"","ucode":"35CB4FD836135B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/5c/a3d42cdb.jpg","comment_is_top":false,"comment_ctime":1585261362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585261362","product_id":100006701,"comment_content":"只能听懂60%，得多听几遍啦。","like_count":0},{"had_liked":false,"id":185298,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1583555183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583555183","product_id":100006701,"comment_content":"MyBatis底层的缓存实现其中就有两个是利用引用和引用队列实现的，WeakCache和SofeCache，需要开启的时候可以通过缓存配置","like_count":0},{"had_liked":false,"id":173586,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1579601865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579601865","product_id":100006701,"comment_content":"2. 引用队列（ReferenceQueue）使用谈到各种引用的编程，就必然要提到引用队列。我们在创建各种引用并关联到响应对象时<br>----------------------------------------------------------------------<br>最后五个字“响应对象时”-------&gt;“相应对象时”吧？<br>","like_count":0},{"had_liked":false,"id":172166,"user_name":"苏暮沉觞","can_delete":false,"product_type":"c1","uid":1577580,"ip_address":"","ucode":"532B816D4EF47B","user_header":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","comment_is_top":false,"comment_ctime":1579099944,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579099944","product_id":100006701,"comment_content":"老师，您在文中讲的：“JVM 会在特定时机将引用 enqueue 到队列里”，这个特定时间是指什么时候？看评论中有人说是在回收以后，有人觉得在回收之前的某个时间","like_count":0},{"had_liked":false,"id":145897,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1572400193,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1572400193","product_id":100006701,"comment_content":"老师，new Resource().action()，例子中的对象何时回收呢，会不会造成泄漏","like_count":0},{"had_liked":false,"id":144338,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571899924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571899924","product_id":100006701,"comment_content":"请问杨老师， 例子中的为什么 Reference.reachabilityFence调用要放在finally块里面，多谢！","like_count":0},{"had_liked":false,"id":143689,"user_name":"coderkeep","can_delete":false,"product_type":"c1","uid":1129178,"ip_address":"","ucode":"29EE99F8F19F2E","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/da/7f9cbbd1.jpg","comment_is_top":false,"comment_ctime":1571756351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571756351","product_id":100006701,"comment_content":"Java 中不允许对堆内存的直接申请和释放的操作，也就是说对象一旦不是强引用，后续的 GC 过程无法被干预。我认为 JVM 提供软引用，弱引用，幻象引用和引用队列的机制，实际上是提供了对内存释放过程进行干预和操作的接口。","like_count":0},{"had_liked":false,"id":134765,"user_name":"吖潘吖潘","can_delete":false,"product_type":"c1","uid":1435418,"ip_address":"","ucode":"6DE549504BF31E","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/1a/e86ae6c8.jpg","comment_is_top":false,"comment_ctime":1568912003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568912003","product_id":100006701,"comment_content":"静态变量属于哪一种呢？","like_count":0},{"had_liked":false,"id":128811,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1090784,"ip_address":"","ucode":"563C4A71D80DA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwQvLGE4dMsF4JU0svW3DtGbodpjskbY65FdwF13JdtBYZfgL2IXHlHrdejWzHdjT0RibEIfib4QYA/132","comment_is_top":false,"comment_ctime":1566966956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566966956","product_id":100006701,"comment_content":"threadlocal用的weak引用","like_count":0},{"had_liked":false,"id":126128,"user_name":"Geek_5d2b65","can_delete":false,"product_type":"c1","uid":1623606,"ip_address":"","ucode":"3775160556FAE4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYwe4EFnsKySWl1K1NFQWzuyiaIjLEeibKWsnWp321o1SM9iauoegqAbZM96Cbs0qc19qiaibjchUc8jg/132","comment_is_top":false,"comment_ctime":1566318689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566318689","product_id":100006701,"comment_content":"是不是为了保证对象具有强引用，日常编码中不推荐使用new Resource().action()的写法，毕竟不可能所有方法都加try finally 强制指定为强引用。推荐使用Resource re=new Resource();re.action()","like_count":0},{"had_liked":false,"id":116255,"user_name":"LoveDlei","can_delete":false,"product_type":"c1","uid":1102916,"ip_address":"","ucode":"68065848DF518B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/44/ec084136.jpg","comment_is_top":false,"comment_ctime":1563808296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563808296","product_id":100006701,"comment_content":"老师您好：<br>非常感谢您带来的精彩内容！<br>老师是否可以把这几种引用在GitHub上上传一下实例代码，跟随着代码在解释分析一下这几种引用？<br>提个建议：文章中直接写上GitHub地址即可，还不占用篇幅，这样基础好的可以不用看，基础差一点的可以跟随GitHub的内容配合专栏细细理解分析！<br>之前还真没听过这四种引用的概念。","like_count":0},{"had_liked":false,"id":107106,"user_name":"N_H","can_delete":false,"product_type":"c1","uid":1541386,"ip_address":"","ucode":"109B67557AB3CE","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","comment_is_top":false,"comment_ctime":1561459739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561459739","product_id":100006701,"comment_content":"还有一个问题问一下老师，看到文中有各种引用的相互转换，请问下什么情况下会发生引用的相互转换？这个转换可以用户显示地进行吗？","like_count":0},{"had_liked":false,"id":107095,"user_name":"N_H","can_delete":false,"product_type":"c1","uid":1541386,"ip_address":"","ucode":"109B67557AB3CE","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","comment_is_top":false,"comment_ctime":1561458213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561458213","product_id":100006701,"comment_content":"“不错，如果我们错误地使用了强引用（比如，赋值给了static变量），那么对象可能就没有机会变成弱引用了...”，老师，这一段的内存泄漏不是太理解，能具体说说内存泄漏是怎么造成的吗？","like_count":0},{"had_liked":false,"id":101398,"user_name":"李同学爱学习","can_delete":false,"product_type":"c1","uid":1114774,"ip_address":"","ucode":"D85A7557F6E46E","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/96/7505099c.jpg","comment_is_top":false,"comment_ctime":1559800669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559800669","product_id":100006701,"comment_content":"个人理解：<br>从GC回收策略理解只要对象未被非强引用所引用就可被垃圾回收，而软引用、弱引用以及幻象引用更像是为了满足特定需求（比如软引用可以达到延时回收的效果）而引入的对象细化的逻辑状态，这些逻辑状态不是对象生命周期的必经状态。这些灰色状态如果你有需求用到了那么对象就会经历这些状态，如果没用那么对象就不会经历这些状态。那么问题也就变成了我们如何让对象经历这些灰色状态？拿软引用举例：条件1，没有强引用指向它；条件2，有软引用（SoftReference）指向它。","like_count":0},{"had_liked":false,"id":94918,"user_name":"ingsnow","can_delete":false,"product_type":"c1","uid":1528765,"ip_address":"","ucode":"1C1D1F45E53CAE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erTFrZcEmQMzKDnC6ibZEicAatlcDUQ5qIXt6TicicCwuGsb9kPgiadgbZC2HEDvR1FSDnwQmZ9TgmJEvQ/132","comment_is_top":false,"comment_ctime":1557923604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557923604","product_id":100006701,"comment_content":"感觉除了强引用，其它都不懂，做测试的","like_count":0},{"had_liked":false,"id":92294,"user_name":"PoL","can_delete":false,"product_type":"c1","uid":1416147,"ip_address":"","ucode":"72BA3C2D50D463","user_header":"https://static001.geekbang.org/account/avatar/00/15/9b/d3/41d04923.jpg","comment_is_top":false,"comment_ctime":1557222966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557222966","product_id":100006701,"comment_content":"对象的强引用：对象初始化以后就属于强引用，GC不会碰它，显示设置为NULL，gc才可能收它<br>对象的软引用：比强引用弱一些，可以转换成强引用，内存够GC不碰它，内存不足GC清理<br>对象的弱引用：比软引用更存活周期更短，易被GC回收，内存不足GC清理<br>对象的幻象（虚）引用：存在于对象finalize 阶段，可以用于监控对象的是否被GC回收<br>","like_count":0},{"had_liked":false,"id":81333,"user_name":"刘栋","can_delete":false,"product_type":"c1","uid":1223013,"ip_address":"","ucode":"D0C294E312BCD2","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/65/e9fc7fd1.jpg","comment_is_top":false,"comment_ctime":1553864751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553864751","product_id":100006701,"comment_content":"什么是引用的“作用域”？什么时候会超出引用的“作用域”？","like_count":0},{"had_liked":false,"id":80707,"user_name":"彭发红","can_delete":false,"product_type":"c1","uid":1461374,"ip_address":"","ucode":"9BAC208700791E","user_header":"https://static001.geekbang.org/account/avatar/00/16/4c/7e/4771d8a4.jpg","comment_is_top":false,"comment_ctime":1553700456,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553700456","product_id":100006701,"comment_content":"😄就知道留言区有助攻，真香","like_count":0},{"had_liked":false,"id":70260,"user_name":"Kennedy","can_delete":false,"product_type":"c1","uid":1049022,"ip_address":"","ucode":"C50627007E5ED0","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/be/be358cab.jpg","comment_is_top":false,"comment_ctime":1551060834,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551060834","product_id":100006701,"comment_content":"请老师讲解下这句话的应用场景。”有些时候，对象本身并没有强引用，但是也许它的部分属性还在被使用，”。","like_count":0},{"had_liked":false,"id":67916,"user_name":"hgf","can_delete":false,"product_type":"c1","uid":1085297,"ip_address":"","ucode":"A9649ECFDBD9E8","user_header":"https://static001.geekbang.org/account/avatar/00/10/8f/71/29fb7bc2.jpg","comment_is_top":false,"comment_ctime":1550323186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550323186","product_id":100006701,"comment_content":"在引用队列这一小节代码中，我使用的是Integer对象，如下：<br>        Integer i = 1; &#47;&#47;Integer i = new Integer(1);<br>        ReferenceQueue&lt;Integer&gt; q = new ReferenceQueue();<br>        PhantomReference p = new PhantomReference(i, q);<br>        i = null;<br>        System.gc();<br><br>        try {<br>            Reference ref = q.remove(1000);<br>            if(ref!=null){<br>                System.out.println(ref.hashCode());<br>            }else {<br>                System.out.println(&quot;null&quot;);<br>            }<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br><br>由于integer对象有封箱机制，可以有两种初始化方法， Integer i = 1; 和Integer i = new Integer(1);<br>但是这两种方法初始化的结果却是不一样的，当使用Integer i = 1;这种初始化方法时，ref为null；使用Integer i = new Integer(1);初始化时， ref!=null 。感觉这个和封箱机制中的缓存有关，老师能分析一下原因，帮忙解答一下吗？","like_count":0},{"had_liked":false,"id":62743,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1548146862,"is_pvip":false,"replies":[{"id":"23335","content":"使用相应的构造函数就是了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549814690,"ip_address":"","comment_id":62743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548146862","product_id":100006701,"comment_content":"除了强引用其他三个怎么怎么构造?","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437332,"discussion_content":"使用相应的构造函数就是了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549814690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55697,"user_name":"交叉路口","can_delete":false,"product_type":"c1","uid":1125680,"ip_address":"","ucode":"D1A636F0F4E147","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/30/b840bd9e.jpg","comment_is_top":false,"comment_ctime":1546264499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546264499","product_id":100006701,"comment_content":"可不可以分别结合jdk 中的源码来讲解这些引用类型啊？这边更加好理解和深刻","like_count":0},{"had_liked":false,"id":52565,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1545440370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545440370","product_id":100006701,"comment_content":"强引用，new了一个对象，只要有引用指向这个对象，垃圾回收器会认为活着，不会回收这个对象，变量出了作用域或者手工置为null，就会被垃圾回收器回收 2 软引用用于对内存敏感的缓存，当内存足够不会回收，内存不够进行回收。3 弱引用用于对内存敏感的缓存，垃圾回收器扫描到弱引用对象，都会进行回收，垃圾回收器线程优先级比较低，不一定会立刻回收。优先于软引用被回收。3 幻象引用，提供了一种机制，当对象finalize之后，触发某些特定的操作。引用本质是对象可达性状态和对垃圾回收的影响。","like_count":0},{"had_liked":false,"id":49240,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544629594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544629594","product_id":100006701,"comment_content":"很棒，文章和评论的知识密度都很大，强，软，弱，幻四种引用，平时开发确实使用和关注不多，不过正如峰哥所言，对于性能需要极致优化的就需要关注了，这四种引用的区别主要在于JVM回收对象的优先级有所不同，对于性能调优确实有莫大的关系。<br>需要反复看，收获才会最大化。<br>感谢精彩的分享！","like_count":0},{"had_liked":false,"id":48568,"user_name":"峻铭","can_delete":false,"product_type":"c1","uid":1106202,"ip_address":"","ucode":"63AB23BADACA88","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/1a/20977779.jpg","comment_is_top":false,"comment_ctime":1544489998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544489998","product_id":100006701,"comment_content":"文中说的软引用所引用的对象会在内存不足时回收，那是不是生命周期比强引用长呢","like_count":0},{"had_liked":false,"id":33496,"user_name":"扁担","can_delete":false,"product_type":"c1","uid":1266540,"ip_address":"","ucode":"95B78342FD1893","user_header":"https://static001.geekbang.org/account/avatar/00/13/53/6c/46c4efb0.jpg","comment_is_top":false,"comment_ctime":1539794842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539794842","product_id":100006701,"comment_content":"还是很多疑惑的，不能理解得通透的感觉","like_count":0},{"had_liked":false,"id":21162,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1534944223,"is_pvip":false,"replies":[{"id":"7561","content":"跟踪清理是个常见的例子，实际中有更好的办法；<br>一般是利用ref queue机制做资源释放的最后一道保障","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1535038219,"ip_address":"","comment_id":21162,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1534944223","product_id":100006701,"comment_content":"虽然理解了各个引用的作用。但是我还是不理解幻想引用的作用，幻像引用得到的对象都为null，说明我们也不会用这类对象，那监控他是否回收有什么意义呢？<br>另一种我的理解是，一个对象有好几种引用，比如带有强引用和幻像引用的对象，当强引用失效时，我们就可以根据幻像引用来跟踪它被清理的过程。是按后者这样理解吗，小白一个，望峰哥解答一下。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422557,"discussion_content":"跟踪清理是个常见的例子，实际中有更好的办法；\n一般是利用ref queue机制做资源释放的最后一道保障","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535038219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103445,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/55/47e76936.jpg","nickname":"叶易","note":"","ucode":"0983EA217ACF28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181167,"discussion_content":"DirectByteBuffer申请堆外内存，然后JVM管理不了堆外内存的释放。就要通过这种方式，在对象回收前通过Unsafe类调用native方法释放DirectByteBuffer关联的堆外内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582342358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20228,"user_name":"夏","can_delete":false,"product_type":"c1","uid":1183604,"ip_address":"","ucode":"C479DCAD4C8150","user_header":"https://static001.geekbang.org/account/avatar/00/12/0f/74/8890b63f.jpg","comment_is_top":false,"comment_ctime":1534321189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534321189","product_id":100006701,"comment_content":"对象A如果重写了finalize方法，且finalize方法不为空，finalize方法会被Finalizer的守护线程执行。<br>在执行过程中，Finalizer持有的是强引用，在Finalizer执行完finalize方法后，对象重新变为不可达(Finalizer为后台守护线程，优先级远低于main线程)，幻象引用enqueue。<br>所以，如果重写了finalize方法，gc后，虚引用没有enqueue，可以尝试多触发几次gc，因为Finalizer线程可能还没有执行完finalize方法。<br>我们在实际的编码过程中避免使用finalize方法。","like_count":0},{"had_liked":false,"id":20044,"user_name":"桀","can_delete":false,"product_type":"c1","uid":1204584,"ip_address":"","ucode":"939C1EEFCFC08E","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/68/e5f0ba39.jpg","comment_is_top":false,"comment_ctime":1534232225,"is_pvip":false,"replies":[{"id":"7051","content":"你再随便找个PhontomReference看看，应该都extends Reference，这个都是老代码了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1534318799,"ip_address":"","comment_id":20044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534232225","product_id":100006701,"comment_content":"老师，求解答<br>文中写到“所有引用类型，都是抽象类java.lang.ref.Reference的子类”，这一点如何得知呢，查看api发现并没有显式的有继承关系。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422079,"discussion_content":"你再随便找个PhontomReference看看，应该都extends Reference，这个都是老代码了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534318799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19573,"user_name":"我可能是个程序员","can_delete":false,"product_type":"c1","uid":1051795,"ip_address":"","ucode":"8CA580EA34EEF3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/93/e3014470.jpg","comment_is_top":false,"comment_ctime":1533884413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533884413","product_id":100006701,"comment_content":"幻象引用必须和引用队列（ReferenceQueue）联合使用。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br><br> ReferenceQueue queue=new ReferenceQueue();<br><br>PhantomReference pr=new PhantomReference(object,queue);<br><br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用对列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。<br><br>","like_count":0},{"had_liked":false,"id":19057,"user_name":"Meteor","can_delete":false,"product_type":"c1","uid":1180548,"ip_address":"","ucode":"3938D2A1474DD1","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/84/791fb8f1.jpg","comment_is_top":false,"comment_ctime":1533654113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533654113","product_id":100006701,"comment_content":"还是只对强引用理解，其他三种引用不是太明白。能不能举一些具体的实际例子，来说明一下。","like_count":0},{"had_liked":false,"id":18945,"user_name":"Aaron_涛","can_delete":false,"product_type":"c1","uid":1180617,"ip_address":"","ucode":"067F3CBB1F036C","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/c9/9a9d82ab.jpg","comment_is_top":false,"comment_ctime":1533612395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533612395","product_id":100006701,"comment_content":"老师，请问一下，我用软引用做缓存，我应该怎么回收软引用呢，我的map中还是存在大量软引用","like_count":0},{"had_liked":false,"id":17778,"user_name":"July","can_delete":false,"product_type":"c1","uid":1005384,"ip_address":"","ucode":"553873BE26CDA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/48/3da605c6.jpg","comment_is_top":false,"comment_ctime":1532949321,"is_pvip":false,"replies":[{"id":"6316","content":"例子里是说对象的部分属性可能会有影响，非常corner的例子，也就是理论上","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1533141706,"ip_address":"","comment_id":17778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532949321","product_id":100006701,"comment_content":"老师好，有个疑问，平时也写过类似new Axx().action(); 这样的代码，但是并没有手动调用reachabilityFence()方法，那么这样的话理论上是会有问题的是吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421269,"discussion_content":"例子里是说对象的部分属性可能会有影响，非常corner的例子，也就是理论上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533141706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17721,"user_name":"简繁","can_delete":false,"product_type":"c1","uid":1189562,"ip_address":"","ucode":"BBDF8D1DD904A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pHPfugzib71JdXkKxRITCzTZXmEnl2KvoVVjmf88SUh5S6x8aTCR30J205YRmak6eyhG6Bg75dyW4raHRW88RuQ/132","comment_is_top":false,"comment_ctime":1532912782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532912782","product_id":100006701,"comment_content":"还是很感谢","like_count":0},{"had_liked":false,"id":17494,"user_name":"小菜鸟","can_delete":false,"product_type":"c1","uid":1114659,"ip_address":"","ucode":"16E75180BEFD4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/23/bd476313.jpg","comment_is_top":false,"comment_ctime":1532685512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532685512","product_id":100006701,"comment_content":"老师，关于引用类型的划分！在我们写代码的时候如何区分呢？我感觉平时写的代码都是强引用，没有涉及到其他的引用类型！<br>对于各种引用类型是否有代码样例呢？","like_count":0},{"had_liked":false,"id":16903,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1532305157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532305157","product_id":100006701,"comment_content":"希望来增加每种情况的使用用例，以及使用中需要注意的问题。这样结合更有意义。","like_count":0},{"had_liked":false,"id":16707,"user_name":"Starry-","can_delete":false,"product_type":"c1","uid":1177215,"ip_address":"","ucode":"F319A6AD1B7910","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/7f/b7e08221.jpg","comment_is_top":false,"comment_ctime":1532118605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532118605","product_id":100006701,"comment_content":"还是自己不够优秀，感觉平时写代码并不会考虑到这四种引用之间的区别，或者说项目中都是强引用。如果是这样，不知道会不会对项目代码产生影响？如果答案是项目中为了保证项目正确运行必须定义强引用，那么既然不常用为什么还要存在这样的机制？老师能看到我的留言的话，还请给我回复呀","like_count":0},{"had_liked":false,"id":16551,"user_name":"L99","can_delete":false,"product_type":"c1","uid":1180449,"ip_address":"","ucode":"16FCBA62F388A0","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/21/bcab3032.jpg","comment_is_top":false,"comment_ctime":1532017754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532017754","product_id":100006701,"comment_content":"很强，小白看不懂，点个赞静静的关闭了。","like_count":0},{"had_liked":false,"id":13151,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1529409327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529409327","product_id":100006701,"comment_content":"表示只懂强引用","like_count":0},{"had_liked":false,"id":12996,"user_name":"Len","can_delete":false,"product_type":"c1","uid":1022767,"ip_address":"","ucode":"53C623CE17973F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/2f/b7a3625e.jpg","comment_is_top":false,"comment_ctime":1529256929,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1529256929","product_id":100006701,"comment_content":"老师，在 Wikipedia 上有一个例子，如下：<br>class A {<br>\tWeakReference r = new WeakReference(new String(&quot;I’m here&quot;));<br><br>\tWeakReference sr = new WeakReference(&quot;I’m here&quot;);<br><br><br>\tSystem.gc();<br>\tThread.sleep(100);<br><br>\t&#47;&#47; only r.get() becomes null<br>\tSystem.out.println(&quot;after gc:r =&quot; + r.get() +          &quot;,static=&quot; + sr.get());<br>}<br><br>Java 8 环境运行之后， r.get() 返回 null，但是 sr.get() 不返回 null。<br><br>老师，对上面的例子，我有 2 个疑惑。<br><br>1.我对 sr 不返回 null 的理解是：<br>因为 sr 直接引用的常量池中的字面量 &quot;I’m here&quot;，而常量池对这个字面量本身也有引用，所以无法回收。<br><br>这样理解对吗？<br><br>2.在上面的例子中，假如没有 sr，也即代码变为：<br>class A {<br>\tWeakReference r = new WeakReference(new String(&quot;I’m here&quot;));<br><br>\tSystem.gc();<br>\tThread.sleep(100);<br><br>\t&#47;&#47; only r.get() becomes null<br>\tSystem.out.println(&quot;after gc:r =&quot; + r.get());<br>}<br>在这个类中，在 System.gc 前有 3 个对象，分别是 r、string 对象、常量池中的 &quot;I’m here&quot;。<br>那么，在 gc 之后，常量池中的 &quot;I’m here&quot; 会被垃圾回收吗？","like_count":0},{"had_liked":false,"id":12546,"user_name":"桐.","can_delete":false,"product_type":"c1","uid":1034776,"ip_address":"","ucode":"2811BFD1A538FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ca/18/c74ce7b7.jpg","comment_is_top":false,"comment_ctime":1528902934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528902934","product_id":100006701,"comment_content":"老师，可以举例说明一下这些引用的使用场景么？","like_count":0},{"had_liked":false,"id":12270,"user_name":"chris","can_delete":false,"product_type":"c1","uid":1109640,"ip_address":"","ucode":"6663E3E09457E3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","comment_is_top":false,"comment_ctime":1528736814,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1528736814","product_id":100006701,"comment_content":"这四种引用除了强引用，其他的确实了解甚少，今天一看确实受益匪浅！","like_count":0},{"had_liked":false,"id":12122,"user_name":"vincentjia","can_delete":false,"product_type":"c1","uid":1005699,"ip_address":"","ucode":"EC26D23594600D","user_header":"","comment_is_top":false,"comment_ctime":1528602374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528602374","product_id":100006701,"comment_content":"希望能有实例（代码、伪代码），更直观、更理解。如果篇幅所限，是否可以链接到你的博客？","like_count":0},{"had_liked":false,"id":11647,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1061767,"ip_address":"","ucode":"86F679C62B90AA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epTXXDNFFe90dwTK2s5PxeuYn3MOLvfU6YLQ0uxuf9bXI8dWXgib5LRnOwk1uWiaDHqIGibOKyU4x3CQ/132","comment_is_top":false,"comment_ctime":1528260784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528260784","product_id":100006701,"comment_content":"然后为什么ThreadLocalMap的Entry是弱引用呢？是remove后下一次gc就会立刻释放缓存吧？那为什么普通的Map的entry又不是弱引用？普通的map就不需要把entry设置为弱引用？这个区别在哪？","like_count":0},{"had_liked":false,"id":11624,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1061767,"ip_address":"","ucode":"86F679C62B90AA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epTXXDNFFe90dwTK2s5PxeuYn3MOLvfU6YLQ0uxuf9bXI8dWXgib5LRnOwk1uWiaDHqIGibOKyU4x3CQ/132","comment_is_top":false,"comment_ctime":1528250480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528250480","product_id":100006701,"comment_content":"老师有一个地方我不知道有没理解正确：Cleaner就是给对象设置一个PhantomReference，在对象被回收前会被jvm放进pending队列，ReferenceHandler会在看到这个幻象引用是Cleaner时特殊处理，不加入队列而是调用他的clean方法","like_count":0},{"had_liked":false,"id":11554,"user_name":"英耀","can_delete":false,"product_type":"c1","uid":1113425,"ip_address":"","ucode":"5E886F004BF6C2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/51/7f75a232.jpg","comment_is_top":false,"comment_ctime":1528198981,"is_pvip":true,"replies":[{"id":"3716","content":"是的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528217562,"ip_address":"","comment_id":11554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528198981","product_id":100006701,"comment_content":"请问一下杨老师，能否稍微详谈一下的post-mortem机制？指的是幻象引用+引用队列这一套机制吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418897,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9655,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1527004709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527004709","product_id":100006701,"comment_content":"希望能够听到老师的原声，别人的朗读感觉有点生硬。还有，对于概念的解释，和代码的展示，可以贴个链接。谢谢老师的分享","like_count":0},{"had_liked":false,"id":9556,"user_name":"老实人Honey","can_delete":false,"product_type":"c1","uid":1080653,"ip_address":"","ucode":"EA4AB5C0C33090","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/4d/d98865b2.jpg","comment_is_top":false,"comment_ctime":1526951492,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1526951492","product_id":100006701,"comment_content":"apache commons pool 对象池有提供SoftReferencePool实现","like_count":0},{"had_liked":false,"id":9464,"user_name":"kk","can_delete":false,"product_type":"c1","uid":1124038,"ip_address":"","ucode":"57F66E71F43251","user_header":"https://static001.geekbang.org/account/avatar/00/11/26/c6/31d3a52e.jpg","comment_is_top":false,"comment_ctime":1526889927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526889927","product_id":100006701,"comment_content":"平时开发都是上层应用，基本上都是调用开源库，这些稍微底层的技术以及和性能相关的技术实现，都是调用库来做的，遇到比较多的就是强引用，和弱引用。看了个把小时对后面的几个知识点都很陌生，希望能指导一下，想要更全面的了解这些知识点，应该做哪些方面的准备","like_count":0},{"had_liked":false,"id":9440,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1526872059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526872059","product_id":100006701,"comment_content":"关注<br>2018-05-18作者回复空的Finalize实现，不会起作用的；<br>Finalizer是懒家伙，试试system.runfinalization；<br><br>尝试后，还是不行。<br>我测试发现，自定义的finalize只要有任何变量或对象定义，都不会进入Reference Queue，怀疑是，以为级联依赖的问题，就是说Finalize方法中，有未被回收的对象，那么Finalize所在的对象，就不会被回收。","like_count":0},{"had_liked":false,"id":9262,"user_name":"ls","can_delete":false,"product_type":"c1","uid":1007293,"ip_address":"","ucode":"6C14A1D24DDC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/bd/e28f8ce5.jpg","comment_is_top":false,"comment_ctime":1526711116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526711116","product_id":100006701,"comment_content":"按GC层面自己的理解：强引用是宁愿抛OOM异常也不会回收的对象；软引用是内存不足时会去回收的对象；弱引用只要GC线程有扫描到弱引用就会被回收；而一个对象只有虚引用，等于没有引用一样，随时被GC回收；<br><br><br>关于引用，最近Android有遇到一个小坑；自定义了一个函数，里面 new 了一个实例 A 给 a 引用（强引用），在函数中用 a 去调用底层的函数（底层开线程，耗时耗内存），没考虑到函数过后，强引用就已经过了作用域，当底层吃内存多后触发了 GC 把这个引用和对象回收了；而B对象引用是在 a 引用链底下，当顶层引用被回收了，B也会被回收，B 重写的 finalize 函数又把底层的线程给 kill 了；导致函数调用了，但c层的代码在一段时间后（内存紧张被GC）就不起作用；没基础真可怕，赶紧翻看这讲和上讲的文章补补基础；<br><br>","like_count":0},{"had_liked":false,"id":9230,"user_name":"Nemo","can_delete":false,"product_type":"c1","uid":1126566,"ip_address":"","ucode":"1DDEDF9680D651","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/a6/0dca2856.jpg","comment_is_top":false,"comment_ctime":1526698667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526698667","product_id":100006701,"comment_content":"try { &#47;&#47; 需要被保护的代码<br> int i = myIndex; Resource.update(externalResourceArray[i]); <br>} finally {<br> &#47;&#47; 调用 reachbilityFence，明确保障对象 strongly reachable Reference.reachabilityFence(this); <br>}<br>老师这段代码finally中指定强可达可以理解，不过如果action执行结束以后，这个强引用会被释放掉吗？在什么时候被释放，还是也需要显示的调用api释放呢？","like_count":0},{"had_liked":false,"id":9084,"user_name":"jon","can_delete":false,"product_type":"c1","uid":1113537,"ip_address":"","ucode":"28299C17783414","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/c1/05e45dba.jpg","comment_is_top":false,"comment_ctime":1526605961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526605961","product_id":100006701,"comment_content":"学习了，可是除了强引用平时在用，其他引用要怎么用呢？","like_count":0},{"had_liked":false,"id":8990,"user_name":"arthur","can_delete":false,"product_type":"c1","uid":1116981,"ip_address":"","ucode":"EAD9D9D2837C5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/35/2c56c29c.jpg","comment_is_top":false,"comment_ctime":1526562130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526562130","product_id":100006701,"comment_content":"杨老师您好，我是测试人员，看懂了这些知识点，但平时大都只测试脚本，不会去实现功能，所以对应用场景不是很了解，希望老师能多给一些实例，举一些代码的例子，方便像我这些基础比较差的同学学习","like_count":0},{"had_liked":false,"id":8966,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1526547764,"is_pvip":false,"replies":[{"id":"2695","content":"文章图里阐明了，幻象引用enque发生在finalize之后，你查查是不是卡在FinalReference queue里了，那是实现finalization的地方","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526593835,"ip_address":"","comment_id":8966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526547764","product_id":100006701,"comment_content":"老师，问个问题:我自己定义一个类，重写finalize方法后，创建一个对象，被幻想引用，同时该幻想对象使用ReferenceQueue。<br>当我这个对象指向null，被GC回收后，ReferenceQueue中没有改对象，不知道是什么原因？如果我把类中的finalize方法移除，ReferenceQueue就能获取被释放的对象。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417923,"discussion_content":"文章图里阐明了，幻象引用enque发生在finalize之后，你查查是不是卡在FinalReference queue里了，那是实现finalization的地方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526593835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8950,"user_name":"000","can_delete":false,"product_type":"c1","uid":1052192,"ip_address":"","ucode":"98A810FA164106","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/20/4a8eb862.jpg","comment_is_top":false,"comment_ctime":1526536671,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1526536671","product_id":100006701,"comment_content":"除了强引用，其他的三种平时开发中几乎没使用过","like_count":0},{"had_liked":false,"id":8943,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1526532721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526532721","product_id":100006701,"comment_content":"几种引用会怎么出现相互转化","like_count":0},{"had_liked":false,"id":8803,"user_name":"成","can_delete":false,"product_type":"c1","uid":1121547,"ip_address":"","ucode":"E9B9535881D48C","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/0b/25742bed.jpg","comment_is_top":false,"comment_ctime":1526450989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526450989","product_id":100006701,"comment_content":"有个关于new Resource().action()的问题，在action方法里隐式的this不就说明了可达性吗？望解答","like_count":0},{"had_liked":false,"id":8729,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1127349,"ip_address":"","ucode":"02E2AD0059D3C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/b5/ee3febd6.jpg","comment_is_top":false,"comment_ctime":1526389035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526389035","product_id":100006701,"comment_content":"我们一般所说的内存泄漏是遍历gcroots，那泄漏的对象是在gcroots上的，怎么判定对象泄漏了呢？泄漏对象和未泄漏对象有不同的标志吗？<br>等待老师的解答<br>","like_count":0},{"had_liked":false,"id":8684,"user_name":"张勇","can_delete":false,"product_type":"c1","uid":1120890,"ip_address":"","ucode":"F0C1A539442510","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/7a/5ffb9d63.jpg","comment_is_top":false,"comment_ctime":1526369976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526369976","product_id":100006701,"comment_content":"创建一个Student的强引用对象stu； Student stu=new Student(小王&quot;,3); 创建一个弱引用指向Student SoftReference&lt;Student&gt; softReference=new SoftReference&lt;Student&gt;(stu); 问题1 此时如果stu不我不手动的置成stu=null，就算gc快要发生OOM的时候也不会回收这个Student对象因为它还持有一个强引用stu，这句话对不对？ 问题2 如果stu我置换成了stu=null，此时只有弱引用指向这个student这个时候当内存不足快要发生OOM的时候gc会回收Student占用的这块内存，这句话对不对？ 问题3，如果我从弱引用中获取我这个Student对象，写成 if(softReference.get()!=null) Student student=softReference.get();,此时这个student是强引用还是弱引用，如果是强引用是不是用完以后需要写成student==null,如果不写student==null这句 gc快要发生OOM的时候也不会回收这个Student对象,下次如果继续使用这个对象是不是用同样的方法if(softReference.get()!=null) Student student=softReference.get();在获取这个对象<br><br>老师我这个例子是针对全局变量的，如果是全局变量我上面的问题帮我解答下，谢谢","like_count":0},{"had_liked":false,"id":8667,"user_name":"张勇","can_delete":false,"product_type":"c1","uid":1120890,"ip_address":"","ucode":"F0C1A539442510","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/7a/5ffb9d63.jpg","comment_is_top":false,"comment_ctime":1526359074,"is_pvip":false,"replies":[{"id":"2584","content":"你这几个例子用的都是局部变量？这是有作用域的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526369634,"ip_address":"","comment_id":8667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526359074","product_id":100006701,"comment_content":"   创建一个Student的强引用对象stu；\r        Student stu=new Student(小王&quot;,3);\r\r        创建一个弱引用指向Student\r        SoftReference&lt;Student&gt; softReference=new SoftReference&lt;Student&gt;(stu);\r        问题1 此时如果stu不我不手动的置成stu=null，就算gc快要发生OOM的时候也不会回收这个Student对象因为它还持有一个强引用stu，这句话对不对？\r        问题2 如果stu我置换成了stu=null，此时只有弱引用指向这个student这个时候当内存不足快要发生OOM的时候gc会回收Student占用的这块内存，这句话对不对？\r       \r        问题3，如果我从弱引用中获取我这个Student对象，写成 if(softReference.get()!=null) Student student=softReference.get();,此时这个student是强引用还是弱引用，如果是强引用是不是用完以后需要写成student==null,如果不写student==null这句\r        gc快要发生OOM的时候也不会回收这个Student对象,下次如果继续使用这个对象是不是用同样的方法if(softReference.get()!=null) Student student=softReference.get();在获取这个对象","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417814,"discussion_content":"你这几个例子用的都是局部变量？这是有作用域的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526369634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8624,"user_name":"xuejian.sun","can_delete":false,"product_type":"c1","uid":1046667,"ip_address":"","ucode":"1970D91675122C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/8b/dc3dc04d.jpg","comment_is_top":false,"comment_ctime":1526347999,"is_pvip":false,"replies":[{"id":"2580","content":"不太清楚问题，只少remove以后A B对象都和map没关系了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526369132,"ip_address":"","comment_id":8624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526347999","product_id":100006701,"comment_content":"老师，请教个问题，map中有个普通类A，A中引用了一个ioc管理的B，map.remove（A）后这个A会被GC吗<br><br>","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417799,"discussion_content":"不太清楚问题，只少remove以后A B对象都和map没关系了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526369132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8539,"user_name":"张勇","can_delete":false,"product_type":"c1","uid":1120890,"ip_address":"","ucode":"F0C1A539442510","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/7a/5ffb9d63.jpg","comment_is_top":false,"comment_ctime":1526306627,"is_pvip":false,"replies":[{"id":"2572","content":"取决于什么时候释放，如果一直保持着，就可能是内存泄露的来源了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526368141,"ip_address":"","comment_id":8539,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526306627","product_id":100006701,"comment_content":"对象从软或者弱引用变成强引用后对象还会被gc回收吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417767,"discussion_content":"取决于什么时候释放，如果一直保持着，就可能是内存泄露的来源了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526368141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8526,"user_name":"张勇","can_delete":false,"product_type":"c1","uid":1120890,"ip_address":"","ucode":"F0C1A539442510","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/7a/5ffb9d63.jpg","comment_is_top":false,"comment_ctime":1526298465,"is_pvip":false,"replies":[{"id":"2533","content":"会，建议去理解下局部变量作用域","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526344387,"ip_address":"","comment_id":8526,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526298465","product_id":100006701,"comment_content":"若果我一个强引用的对象只是new出来，并没有使用new出来的这个对象，gc也不会回收这个对象吗？eg : Animal  an=new Animal();  an这个对象我在程序中并不使用，是不是gc不会回收这个对象？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417761,"discussion_content":"会，建议去理解下局部变量作用域","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526344387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8505,"user_name":"夏茶","can_delete":false,"product_type":"c1","uid":1123978,"ip_address":"","ucode":"9348FC873129F8","user_header":"https://static001.geekbang.org/account/avatar/00/11/26/8a/c51a1f81.jpg","comment_is_top":false,"comment_ctime":1526275502,"is_pvip":false,"replies":[{"id":"2522","content":"不是回收，是jvm判断对象处于soft reachable，立即或者过一会儿enqueue到队列里","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526276929,"ip_address":"","comment_id":8505,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526275502","product_id":100006701,"comment_content":"杨老师我有个问题，想请您帮我解惑下，谢谢，代码荣耀说了一句“如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中”，对象被垃圾回收了，把软引用加入到队列里，那这里的软引用是对象吗，如果是对象是什么对象，还能不能取到软引用所引用的对象？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417750,"discussion_content":"不是回收，是jvm判断对象处于soft reachable，立即或者过一会儿enqueue到队列里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526276929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8486,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1526261120,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526261120","product_id":100006701,"comment_content":"大神多来点干货啊，底层的东西太抽象了，看完还是没明白","like_count":0},{"had_liked":false,"id":8360,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1526116505,"is_pvip":false,"replies":[{"id":"2525","content":"谢谢反馈，<br>1，2，不错，画的比较粗糙，注明了不那么严谨，主要是个清楚的示意；<br>3，不是的，Javaspec清楚要求如此；对象处于某种可达状态，不是说有那种引用，是没有其他更“强”的引用关系；finalize如果没有重新不会执行，但逻辑顺序不变","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526277742,"ip_address":"","comment_id":8360,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526116505","product_id":100006701,"comment_content":"1.&#39;对象可达性状态流转分析&#39;章节图示是强软弱幻象引用，而文字说的是强软弱幻象可达，是不是应该都是可达? <br>2. 另外，我注意到软可达和弱可达是单向的，不能从弱到软，这里能多解释下吗?<br>3. 说幻象可达是finalize之后的，这个什么意思?我理解只要是幻象引用，它就是幻象可达，和是否执行了finalize()没有关系<br>请老师解惑","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417685,"discussion_content":"谢谢反馈，\n1，2，不错，画的比较粗糙，注明了不那么严谨，主要是个清楚的示意；\n3，不是的，Javaspec清楚要求如此；对象处于某种可达状态，不是说有那种引用，是没有其他更“强”的引用关系；finalize如果没有重新不会执行，但逻辑顺序不变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526277742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8356,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1526113103,"is_pvip":false,"replies":[{"id":"2515","content":"很高兴有帮助","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526274720,"ip_address":"","comment_id":8356,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526113103","product_id":100006701,"comment_content":"这篇讲得好，以前看书缺少实际使用经验，理解上总是一知半解最后忘了，这次感觉看完就明白了。还是要多结合实践，才能真正理解这些很少用到的东西。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417683,"discussion_content":"很高兴有帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526274720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8329,"user_name":"疯狂的柴犬","can_delete":false,"product_type":"c1","uid":1126094,"ip_address":"","ucode":"343AF3A8953C78","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/ce/b8145a8d.jpg","comment_is_top":false,"comment_ctime":1526094131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526094131","product_id":100006701,"comment_content":"每天都等着更新，讲的挺细的，waiting下一个","like_count":0}]}