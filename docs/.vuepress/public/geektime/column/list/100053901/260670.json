{"id":260670,"title":"07 | 如何在移动App中使用OAuth 2.0？","content":"<p>你好，我是王新栋。</p><p>在前面几讲中，我都是基于Web应用的场景来讲解的OAuth 2.0。除了Web应用外，现实环境中还有非常多的移动App。那么，在移动App中，能不能使用OAuth 2.0 ，又该如何使用OAuth 2.0呢？</p><p>没错，OAuth 2.0最初的应用场景确实是Web应用，但是它的伟大之处就在于，它把自己的核心协议定位成了一个框架而不是单个的协议。这样做的好处是，我们可以基于这个基本的框架协议，在一些特定的领域进行扩展。</p><p>因此，到了桌面或者移动的场景下，OAuth 2.0的协议一样适用。考虑到授权码许可是最完备、最安全的许可类型，所以我在讲移动App如何使用OAuth 2.0的时候，依然会用授权码许可来讲解，毕竟“要用就用最好的”。</p><p>当我们开发一款移动App的时候，可以选择没有Server端的 “纯App” 架构，比如这款App不需要跟自己的Server端通信，或者可以调用其它开放的HTTP接口；当然也可以选择有服务端的架构，比如这款App还想把用户的操作日志记录下来并保存到Server端的数据库中。</p><p>那总结下来呢，移动App可以分为两类，一类是没有Server端的App应用，一类是有Server端的App应用。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/4c/99/4c034e019467aafae511f16055b57b99.png?wh=1604*522\" alt=\"\" title=\"图1 两类移动App\"></p><p>这两类App在使用 OAuth 2.0 时的最大区别，在于获取访问令牌的方式：</p><ul>\n<li>如果有Server端，就建议通过Server端和授权服务做交互来换取访问令牌；</li>\n<li>如果没有Server端，那么只能通过前端通信来跟授权服务做交互，比如在上一讲中提到的隐式许可授权类型。当然，这种方式的安全性就降低了很多。</li>\n</ul><p>有些时候，我们可能觉得自己开发一个App不需要一个Server端。那好，就让我们先来看看没有Server端的App应用如何使用授权码许可类型。</p><h2>没有Server端的App</h2><p>在一个没有Server端支持的纯App应用中，我们首先想到的是，如何可以像Web服务那样，让请求和响应“来去自如”呢。</p><p>你可能会想，我是不是可以将一个“迷你”的Web服务器嵌入到App里面去，这样不就可以像Web应用那样来使用OAuth 2.0 了么？确实，这是行得通的，而且已经有App这样做了。</p><p>这样的App通过监听运行在localhost上的Web服务器URI，就可以做到跟普通的Web应用一样的通信机制。但这种方式不是我们这次要讲的重点，如果你想深入了解可以去查些资料。因为当使用这种方式的时候，请求访问令牌时需要的app_secret就只能保存在用户本地设备上，而这并不是我们所建议的。</p><p>到这里，你应该猜到了，问题的关键在于如何保存app_secret，因为App会被安装在成千上万个终端设备上，app_secret一旦被破解，就将会造成灾难性的后果。这时，有的同学突发奇想，如果不用app_secret，也能在授权码流程里换回访问令牌access_token，不就可以了吗？</p><p>确实可以，但新的问题也来了。在授权码许可类型的流程中，如果没有了app_secret这一层的保护，那么通过授权码code换取访问令牌的时候，就只有授权码code在“冲锋陷阵”了。这时，授权码code一旦失窃，就会带来严重的安全问题。那么，我既不使用app_secret，还要防止授权码code失窃，有什么好的方法吗？</p><p>有，OAuth 2.0 里面就有这样的指导方法。这个方法就是我们将要介绍的PKCE协议，全称是Proof Key for Code Exchange by OAuth Public Clients。</p><p>在下面的流程图中，为了突出第三方软件使用PKCE协议时与授权服务之间的通信过程，我省略了受保护资源服务和资源拥有者的角色：</p><p><img src=\"https://static001.geekbang.org/resource/image/66/52/66648bff2d955b3d714ce597299fbf52.png?wh=1614*1002\" alt=\"\" title=\"图2 使用PKCE协议的流程图\"></p><p>我来和你分析下这个流程中的重点。</p><p>首先，App自己要生成一个随机的、长度在43~128字符之间的、参数为<strong>code_verifier</strong>的字符串验证码；接着，我们再利用这个<strong>code_verifier，<strong>来生成一个被称为“挑战码”的参数</strong>code_challenge</strong>。</p><p>那怎么生成这个code_challenge的值呢？OAuth 2.0 规范里面给出了两种方法，就是看code_challenge_method这个参数的值：</p><ul>\n<li>一种code_challenge_method=plain，此时code_verifier的值就是code_challenge的值；</li>\n<li>另外一种code_challenge_method=S256，就是将code_verifier值进行ASCII编码之后再进行哈希，然后再将哈希之后的值进行BASE64-URL编码，如下代码所示。</li>\n</ul><pre><code>code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))\n</code></pre><p>好了，我知道有这样两个值，也知道它们的生成方法了，但这两个值跟我们的授权码流程有什么关系呢，又怎么利用它们呢？不用着急，我们接着讲。</p><p>授权码流程简单概括起来不是有两步吗，第一步是获取授权码code，第二步是用app_id+app_secret+code获取访问令牌access_token。刚才我们的“梦想”不是设想不使用app_secret，但同时又能保证授权码流程的安全性么？</p><p>没错。code_verifier和code_challenge这两个参数，就是来帮我们实现这个“梦想”的。</p><p>在<strong>第一步获取授权码code的时候，我们使用code_challenge</strong>参数。需要注意的是，我们要同时将code_challenge_method参数也传过去，目的是让授权服务知道生成code_challenge值的方法是plain还是S256。</p><pre><code>https://authorization-server.com/auth?\nresponse_type=code&amp;\napp_id=APP_ID&amp;\nredirect_uri=REDIRECT_URI&amp;\ncode_challenge=CODE_CHALLENGE&amp;\ncode_challenge_method=S256\n</code></pre><p>在<strong>第二步获取访问令牌的时候，我们使用code_verifier参数</strong>，授权服务此时会将code_verifier的值进行一次运算。那怎么运算呢？就是上面code_challenge_method=S256的这种方式。</p><p>没错，第一步请求授权码的时候，已经告诉授权服务生成code_challenge的方法了。所以，在第二步的过程中，授权服务将运算的值跟第一步接收到的值做比较，如果相同就颁发访问令牌。</p><pre><code>POST https://api.authorization-server.com/token?\n  grant_type=authorization_code&amp;\n  code=AUTH_CODE_HERE&amp;\n  redirect_uri=REDIRECT_URI&amp;\n  app_id=APP_ID&amp;\n  code_verifier=CODE_VERIFIER\n</code></pre><p>现在，你就知道了我们是如何使用code_verifier和code_challenge这两个参数的了吧。总结一下就是，换取授权码code的时候，我们使用code_challenge参数值；换取访问令牌的时候，我们使用code_verifier参数值。那么，有的同学会继续问了，我们为什么要这样做呢。</p><p>现在，就让我来和你分析一下。</p><p>我们的愿望是，没有Server端的手机App，也可以使用授权码许可流程，对吧？app_secret不能用，因为它只能被存在用户的设备上，我们担心被泄露。</p><p>那么，在没有了app_secret这层保护的前提下，即使我们的授权码code被截获，再加上code_challenge也同时被截获了，那也没有办法由code_challenge逆推出code_verifier的值。而恰恰在第二步换取访问令牌的时候，授权服务需要的就是code_verifier的值。因此，这也就避免了访问令牌被恶意换取的安全问题。</p><p>现在，我们可以通过PKCE协议的帮助，让没有Server端的App也能够安全地使用授权码许可类型进行授权了。但是，按照 OAuth 2.0 的规范建议，通过后端通信来换取访问令牌是较为安全的方式。所以呢，在这里，我想跟你探讨的是，我们真的不需要一个Server端吗？在做移动应用开发的时候，我们真的从设计上就决定废弃Server端了吗？</p><h2>有Server端的App</h2><p>如果你开发接入过微信登录，就会在微信的官方文档上看到下面这句话：</p><blockquote>\n<p>微信 OAuth 2.0 授权登录目前支持 authorization_code 模式，适用于拥有 Server 端的应用授权。</p>\n</blockquote><p>没错，微信的OAuth 2.0 授权登录，就是建议我们需要一个Server端来支持这样的授权接入。</p><p>那么，有Server端支持的App又是如何使用OAuth 2.0 的授权码许可流程的呢？其实，在前面几讲的基础上，我们现在理解这样的场景并不是什么难事儿。</p><p>我们仍以微信登录为例，看一下<a href=\"https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html\">官方的流程图</a>：</p><p><img src=\"https://static001.geekbang.org/resource/image/86/b1/86d3yy8fa419c94b7e3766fe0a4e3db1.png?wh=1298*570\" alt=\"\" title=\"图3 微信登录流程图\"></p><p>看到这个图，你是不是觉得特别熟悉，跟普通的授权码流程没有区别，仍是两步走的策略：第一步换取授权码code，第二步通过授权码code换取访问令牌access_token。</p><p>这里的第三方应用，就是我们作为开发者来开发的应用，包含了移动App和Server端。我们将其“放大”得到下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/56/5e/564f5b7af360180d270e205df5f9c05e.png?wh=1950*1034\" alt=\"\" title=\"图4 有Server端的App的授权流程\"></p><p>我们从这张“放大”的图中，就会发现有Server端的App在使用授权码流程的时候，跟普通的Web应用几乎没有任何差别。</p><p>大概流程是：当我们访问第三方App的时候，需要用到微信来登录；第三方App可以拉起微信的App，我们会在微信的App里面进行登录及授权；微信Server端验证成功之后会返回一个授权码code，通过微信App传递给了第三方App；后面的流程就是我们熟悉的使用授权码code和app_secret，换取访问令牌access_token的值了。</p><p>这次使用app_secret的时候，我们是在第三方App的Server端来使用的，因此安全性上没有任何问题。</p><h2>总结</h2><p>今天这一讲，我重点和你讲了两块内容，没有Server端的App和有Server端的App分别是如何使用授权码许可类型的。我希望你能够记住以下两点内容。</p><ol>\n<li>我们使用OAuth 2.0协议的目的，就是要起到安全性的作用，但有些时候，因为使用不当反而会造成更大的安全问题，比如将app_secret放入App中的最基本错误。如果放弃了app_secret，又是如何让没有Server端的App安全地使用授权码许可协议呢？针对这种情况，我和你介绍了PKCE协议。它是一种在失去app_secret保护的时候，防止授权码失窃的解决方案。</li>\n<li>我们需要思考一下，我们的App真的不需要一个Server端吗？我建议你在开发移动App的时候，尽可能地都要搭建一个Server端，因为通过后端通信来传输访问令牌比通过前端通信传输要安全得多。我也举了微信的例子，很多官方的开放平台在提供OAuth 2.0服务的时候，都会建议开发者要有一个相应的Server端。</li>\n</ol><p>那么，关于OAuth 2.0 的使用还有哪些安全方面的防范措施是我们要注意的呢，接下来的一讲中我们会重点跟大家介绍。</p><h2>思考题</h2><p>在移动App中，你还能想到有哪些相对安全的方式来使用OAuth 2.0吗？</p><p>欢迎你在留言区分享你的观点，也欢迎你把今天的内容分享给其他朋友，我们一起交流。</p>","neighbors":{"left":{"article_title":"06 | 除了授权码许可类型，OAuth 2.0还支持什么授权流程？","id":259675},"right":{"article_title":"08 | 实践OAuth 2.0时，使用不当可能会导致哪些安全漏洞？","id":261403}},"comments":[{"had_liked":false,"id":234373,"user_name":"青峰","can_delete":false,"product_type":"c1","uid":1215903,"ip_address":"","ucode":"6FB19A41AC7232","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/9f/776d9b2e.jpg","comment_is_top":false,"comment_ctime":1594657672,"is_pvip":false,"replies":[{"id":"86517","content":"在这种code_challenge_method=plain情况下，code_verifier的值和code_challenge的值是一样的。<br><br>我们首先要清楚PKCE的出现是为了解决，客户端如果不想使用服务端来支持，在失去了secret的保护下，怎么让OAuth 2.0 进行的更安全，实际上是为了防止授权码被截获，授权码的截获是发生在授权服务响应客户端【第一次】请求授权码的这个过程里面。<br><br>在code_verifier的值和code_challenge的值是一样的情况下，是做了一个最基本的校验，当客户端【第二次】拿着授权码code和code_verifier来请求access_token的时候，授权服务会判断这次给的code_verifier和上次给的code_challenge值是否一致，如果不一致，拒绝返回access_token。<br><br>code_challenge_method=plain、code_challenge_method=S256、给客户端增加一个服务端支持，这三种情况的安全等级是逐渐增高的。<br><br>安全问题的发生是一个组合问题，安全问题的防护是一个成本问题。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594702989,"ip_address":"","comment_id":234373,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70314134408","product_id":100053901,"comment_content":"请问老师，如果采用第一种办法生成code_verifier，code_challenge_method=plain，那么code_verifier 的值就是 code_challenge 的值。<br>这时候，不是获得了code_challenge 就可以推出 code_verifier 的值了吗？","like_count":16,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501371,"discussion_content":"在这种code_challenge_method=plain情况下，code_verifier的值和code_challenge的值是一样的。\n\n我们首先要清楚PKCE的出现是为了解决，客户端如果不想使用服务端来支持，在失去了secret的保护下，怎么让OAuth 2.0 进行的更安全，实际上是为了防止授权码被截获，授权码的截获是发生在授权服务响应客户端【第一次】请求授权码的这个过程里面。\n\n在code_verifier的值和code_challenge的值是一样的情况下，是做了一个最基本的校验，当客户端【第二次】拿着授权码code和code_verifier来请求access_token的时候，授权服务会判断这次给的code_verifier和上次给的code_challenge值是否一致，如果不一致，拒绝返回access_token。\n\ncode_challenge_method=plain、code_challenge_method=S256、给客户端增加一个服务端支持，这三种情况的安全等级是逐渐增高的。\n\n安全问题的发生是一个组合问题，安全问题的防护是一个成本问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594702989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235229,"user_name":"Harvey","can_delete":false,"product_type":"c1","uid":1254112,"ip_address":"","ucode":"164D1178DA091A","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/e0/6295a753.jpg","comment_is_top":false,"comment_ctime":1594947599,"is_pvip":true,"replies":[{"id":"86911","content":"<br>PKCE机制可以【减轻】针对授权码截获的攻击，公共客户端固有的局限性PKCE并不能解决，所以它起不到secret的作用。<br><br>另外，PKCE是OAuth 2.0的一个增补协议可以单独使用，也可以组合使用，比如，如果在具备保存secret的环境里面已经使用授权码流程的基础上再增加PKCE的支持，将会进一步增强授权码流程的安全性。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594969129,"ip_address":"","comment_id":235229,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31659718671","product_id":100053901,"comment_content":"用code_verifier验证code_challenge通过只能证明后一次请求和前一次是从同一个客户端发起的吧？怎么能起到app_secret证明客户端是谁是否合法的作用呢？","like_count":7,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501647,"discussion_content":"\nPKCE机制可以【减轻】针对授权码截获的攻击，公共客户端固有的局限性PKCE并不能解决，所以它起不到secret的作用。\n\n另外，PKCE是OAuth 2.0的一个增补协议可以单独使用，也可以组合使用，比如，如果在具备保存secret的环境里面已经使用授权码流程的基础上再增加PKCE的支持，将会进一步增强授权码流程的安全性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594969129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234944,"user_name":"leros","can_delete":false,"product_type":"c1","uid":1021455,"ip_address":"","ucode":"02F018C58337E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/0f/d9d878f8.jpg","comment_is_top":false,"comment_ctime":1594843729,"is_pvip":false,"replies":[{"id":"86712","content":"移动端类应用，目前各大开放平台都是要求必须有第三方的服务端的支持，由第三方的服务端来跟平台做交互通信。2012年10月发布了OAuth 2.0 的正式授权协议框架，也就是官方的RFC 6749，在2015年9月增补了PKCE协议，也就是官方的RFC 7636。PKCE发布的目的是为了缓解针对公开客户端的攻击，主要是解决授权码窃听的攻击。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594859618,"ip_address":"","comment_id":234944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27364647505","product_id":100053901,"comment_content":"在PKCE协议下，第三方应用掌握了太多的秘密（verifier, challenge)，考虑到移动终端千差万别，保证第三方应用的安全并不容易","like_count":6,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501554,"discussion_content":"移动端类应用，目前各大开放平台都是要求必须有第三方的服务端的支持，由第三方的服务端来跟平台做交互通信。2012年10月发布了OAuth 2.0 的正式授权协议框架，也就是官方的RFC 6749，在2015年9月增补了PKCE协议，也就是官方的RFC 7636。PKCE发布的目的是为了缓解针对公开客户端的攻击，主要是解决授权码窃听的攻击。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594859618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247675,"user_name":"stanleyjobson","can_delete":false,"product_type":"c1","uid":1702255,"ip_address":"","ucode":"4CA84795F59339","user_header":"https://static001.geekbang.org/account/avatar/00/19/f9/6f/9c008ceb.jpg","comment_is_top":false,"comment_ctime":1599790967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18779660151","product_id":100053901,"comment_content":"PKCE 应该是防止code 返回的时候被hacker 截获 然后直接用code 去获取授权（在没有后台的情况下）。<br>但是如果 获取code 发送请求时。code_verifier 也被截获。 hacker 也是可以通过这两个参数去后台获取token的把？","like_count":4},{"had_liked":false,"id":235082,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1594886652,"is_pvip":false,"replies":[{"id":"86813","content":"移动App类应用不像Web应用或者浏览器应用那样可以让用户通过浏览器来访问，如果为了实现这样的方式，可以尝试的做法是需要移动App类应用能够访问操作系统上的浏览器，为了能够监听到这个前端的响应，还需要通过一个URI提供服务，可以通过一个微型的内嵌在应用内、运行在localhost上的Web服务器。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594907869,"ip_address":"","comment_id":235082,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14479788540","product_id":100053901,"comment_content":"“迷你”的 Web 服务器嵌入到 App 里面去，这个不大理解。<br> App 通过监听运行在 localhost 上的 Web 服务器 URI 这个是怎么实现的？","like_count":3,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501601,"discussion_content":"移动App类应用不像Web应用或者浏览器应用那样可以让用户通过浏览器来访问，如果为了实现这样的方式，可以尝试的做法是需要移动App类应用能够访问操作系统上的浏览器，为了能够监听到这个前端的响应，还需要通过一个URI提供服务，可以通过一个微型的内嵌在应用内、运行在localhost上的Web服务器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594907869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297537,"discussion_content":" 就是WebView啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596962974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234429,"user_name":"哈德韦","can_delete":false,"product_type":"c1","uid":1637085,"ip_address":"","ucode":"E7C9B3D087D2D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/fa/dd/f640711f.jpg","comment_is_top":false,"comment_ctime":1594691472,"is_pvip":false,"replies":[{"id":"86503","content":"PKCE是OAuth 2.0 的一个增订”协议“，来解决【公共客户端】授权码可能遭劫持的问题。公共客户端无法保存配置时的秘钥等信息。Web应用有自己的服务端支持，可以很好的解决秘钥的保存问题，所以Web应用是不建议这样做的，而且移动App也不建议这做我们课程中给出了建议。如果你确实不需要一个服务端的移动App可以尝试这样的方式，PKCE是RFC 7636的内容。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594693811,"ip_address":"","comment_id":234429,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14479593360","product_id":100053901,"comment_content":"如果 Web 端也采用 PKCE 协议，是不是也不需要服务器端了（既纯Web前端也可以对接 OAuth 服务）？","like_count":3,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501389,"discussion_content":"PKCE是OAuth 2.0 的一个增订”协议“，来解决【公共客户端】授权码可能遭劫持的问题。公共客户端无法保存配置时的秘钥等信息。Web应用有自己的服务端支持，可以很好的解决秘钥的保存问题，所以Web应用是不建议这样做的，而且移动App也不建议这做我们课程中给出了建议。如果你确实不需要一个服务端的移动App可以尝试这样的方式，PKCE是RFC 7636的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594693811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248547,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1600219787,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10190154379","product_id":100053901,"comment_content":"“而恰恰在第二步换取访问令牌的时候，授权服务需要的就是 code_verifier 的值。因此，这也就避免了访问令牌被恶意换取的安全问题。”  如果截获的是访问令牌，那PKCE是不是就起不到作用了？目前我的理解，PKCE增强了code被截获的安全性，但对访问令牌被截获，无能为力。","like_count":3,"discussions":[{"author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340100,"discussion_content":"是的，因为少了一层app_secret的保护","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609902775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301464,"user_name":"极客","can_delete":false,"product_type":"c1","uid":1114999,"ip_address":"","ucode":"A4AAA6B4F40E66","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/77/3f6a76a9.jpg","comment_is_top":false,"comment_ctime":1625708193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920675489","product_id":100053901,"comment_content":"想问一下，不用oauth直接用rsa加密传输会不会更好，交互少，没有重定向。1.第三方客户端请求第三方的服务端，拿到我们公钥加密的数据，带上第三方对指定数据的签名，青叔音我们平台，2.我们平台解密验证签名，成功后用第三方的公钥加密正确的token。3第三方去自己的后台解密。只有3个流程还不用担心安全。这个会不会比oauth更好呢？不懂为啥不用这种，各个平台还搞oauth？","like_count":1},{"had_liked":false,"id":286003,"user_name":"邓文斌","can_delete":false,"product_type":"c1","uid":2451952,"ip_address":"","ucode":"DF80790787D34F","user_header":"https://static001.geekbang.org/account/avatar/00/25/69/f0/edecdc5d.jpg","comment_is_top":false,"comment_ctime":1617099134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912066430","product_id":100053901,"comment_content":"请教老师，假如我现在有三个自家的APP，以后可能也有第三方的，这三个APP分别是A,B,C，然后A,B,C有各自的sever端，但是用户资源在A的server端，所以得通过A的sever做登录验证，目前有个需求要做一个统一授权服务器，去给B和C颁发令牌做授权，让B和C通过A授权登录获取用户信息，用Oauth2的哪种模式合适？目前看了你的文章觉得授权码模式合适，感激！现在就是不了解这个授权服务器怎么去落地。","like_count":1},{"had_liked":false,"id":263321,"user_name":"Geek_7c4953","can_delete":false,"product_type":"c1","uid":1809168,"ip_address":"","ucode":"359745D4725D4F","user_header":"","comment_is_top":false,"comment_ctime":1606100757,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5901068053","product_id":100053901,"comment_content":"像微信APP请求自家服务端code的流程，OAuth2.0是否有提供规范呢？我个人是比较支持前后端分离的架构，但OAuth2.0的授权服务似乎都是前后端一体的。像是code模式，都是由后端重定向传递。是否有一种前后端分离的，前端调用code接口，后端返回code后再由前端传递给第三方应用的规范框架呢？就像微信那样。","like_count":1,"discussions":[{"author":{"id":2404887,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","nickname":"达叔灬","note":"","ucode":"5CCBAF13548F02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411789,"discussion_content":"后端回调的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636005826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248551,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1600220209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895187505","product_id":100053901,"comment_content":"思考题，参考PKCE，增加多一层的随机码，发给服务器校验，就能提升安全性。例如微信云服务器的MFA码，阿里云的手机验证码。<br>就像一道安全门如果觉得不够安全，那就再加一道门。实际上，没有绝对的安全，这只是在增加小偷开门对成本。如果增加小偷的开门成本，其实也增加了用户的开门成本。","like_count":1},{"had_liked":false,"id":240882,"user_name":"Geek_7b3867","can_delete":false,"product_type":"c1","uid":1784645,"ip_address":"","ucode":"1E6C67D8098FB0","user_header":"","comment_is_top":false,"comment_ctime":1597109903,"is_pvip":false,"replies":[{"id":"89072","content":"介绍PKCE的时候是为了突出流程，就么有画出用户的角色，生成code_verifier和code_challenge都是在用户点击授权之后产生的，所有的授权流程包括之前讲的授权码等等，都是发生在用户点击了授权按钮之后，才发生的，用户的授权肯定都是在平台上面进行，所以平台一定能够拿到用户的登录态。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1597148846,"ip_address":"","comment_id":240882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5892077199","product_id":100053901,"comment_content":"老师，在有服务器的情况下，详细的那个图中是会拉起微信进行用户授权，这样到了微信开放平台是可以验证是谁授权的；但是无服务器的情况下，生成code_verifier和code_challenge过程并未看到用户授权，这两个值传到微信后台如何判断是谁授权的？如何校验？","like_count":1,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503584,"discussion_content":"介绍PKCE的时候是为了突出流程，就么有画出用户的角色，生成code_verifier和code_challenge都是在用户点击授权之后产生的，所有的授权流程包括之前讲的授权码等等，都是发生在用户点击了授权按钮之后，才发生的，用户的授权肯定都是在平台上面进行，所以平台一定能够拿到用户的登录态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597148846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234687,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1594774229,"is_pvip":false,"replies":[{"id":"86619","content":"可以","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594783134,"ip_address":"","comment_id":234687,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5889741525","product_id":100053901,"comment_content":"code_verifier是不是就可以理解为一个随机字符串","like_count":1,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501469,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594783134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234393,"user_name":"Ryan Pan","can_delete":false,"product_type":"c1","uid":1964309,"ip_address":"","ucode":"235BA0C2AA03A5","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f9/15/584103d6.jpg","comment_is_top":false,"comment_ctime":1594684912,"is_pvip":false,"replies":[{"id":"86531","content":"存在服务端，有一个专有的秘钥服务器，但只用户登录之后换回access_token然后才可以去请求或者操作【带有用户属性】的数据。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594728749,"ip_address":"","comment_id":234393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5889652208","product_id":100053901,"comment_content":"请问如果移动App是自家的，用资源拥有者授权的话，app secret建议存哪里呢？","like_count":1,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501377,"discussion_content":"存在服务端，有一个专有的秘钥服务器，但只用户登录之后换回access_token然后才可以去请求或者操作【带有用户属性】的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594728749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360368,"user_name":"樱花","can_delete":false,"product_type":"c1","uid":1057456,"ip_address":"广东","ucode":"432F43127D847A","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/b0/050676f5.jpg","comment_is_top":false,"comment_ctime":1666507357,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666507357","product_id":100053901,"comment_content":"这种只有在用户输入的callback_url是http的时候, 才有被截获的风险, 然后这套流程才算增加了安全性","like_count":0},{"had_liked":false,"id":351507,"user_name":"路在哪","can_delete":false,"product_type":"c1","uid":1816609,"ip_address":"","ucode":"A4822AD07AD102","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/21/f692bdb0.jpg","comment_is_top":false,"comment_ctime":1657855438,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1657855438","product_id":100053901,"comment_content":"既然 code和 code_challenge ，那么code_verifier不也能截获吗.然后就能又获取token了..","like_count":0,"discussions":[{"author":{"id":1337552,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIZCX6TPTqnEaoia8s6IT0PKUHTeDoXiaLPSibQMQ9Sia6P1bqCYSdanX8g9GRZ3kHp5a6x4enx3tyPuQ/132","nickname":"daidai","note":"","ucode":"67405B4E1005E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585794,"discussion_content":"有道理哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661830235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292674,"user_name":"孟令超","can_delete":false,"product_type":"c1","uid":1433609,"ip_address":"","ucode":"37916911C0F9D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/09/eb3da11d.jpg","comment_is_top":false,"comment_ctime":1620917340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620917340","product_id":100053901,"comment_content":"请问老师能给讲讲app_secret的作用吗，app_secret是起到获取token时候验签的作用","like_count":0},{"had_liked":false,"id":247493,"user_name":"Edison鹏","can_delete":false,"product_type":"c1","uid":2103222,"ip_address":"","ucode":"62E10D50565DC8","user_header":"https://static001.geekbang.org/account/avatar/00/20/17/b6/ac21f221.jpg","comment_is_top":false,"comment_ctime":1599725058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599725058","product_id":100053901,"comment_content":"是否所有支持OAuth2.0协议的平台也都支持PKCE协议呢?","like_count":0},{"had_liked":false,"id":242527,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1597751949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597751949","product_id":100053901,"comment_content":"老师好，第一步使用code_challenge获取授权码，第二步使用code_verifier获取访问令牌；这两步中的请求和响应数据都应该是加密的吧？如果是的话那么之前讲四种授权许可类型时所列举代码示例中的请求和响应数据也都应该是加密的吧。","like_count":0},{"had_liked":false,"id":239631,"user_name":"我行我素","can_delete":false,"product_type":"c1","uid":1224678,"ip_address":"","ucode":"4C69542FAB0671","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg","comment_is_top":false,"comment_ctime":1596599795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596599795","product_id":100053901,"comment_content":"请问：code_verifier在app端随机生成，服务端也不知道结果，那么怎么验证是否是合法的呢？","like_count":0},{"had_liked":false,"id":238481,"user_name":"sanmao","can_delete":false,"product_type":"c1","uid":1395689,"ip_address":"","ucode":"D695D88677E3D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/4b/e9/bbccf643.jpg","comment_is_top":false,"comment_ctime":1596180840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596180840","product_id":100053901,"comment_content":"有一个这样的场景, 我在负责公司的开放平台, 现在公司有一款小程序需要使用这个开放平台. 现在有两个问题困扰了我. 1: 这样要对接多个开放平台的小程序认证流程该如何设计. 2: 已经在微信公众平台认证过的小程序, 再接入公司的开放平台的这个认证过程怎么设计比较合理.","like_count":0},{"had_liked":false,"id":235924,"user_name":"Geek_9ae2b9","can_delete":false,"product_type":"c1","uid":2058357,"ip_address":"","ucode":"E4BB2299AF2646","user_header":"","comment_is_top":false,"comment_ctime":1595247188,"is_pvip":false,"replies":[{"id":"88361","content":"<br>可以理解为PKCE是一种增强","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1596462749,"ip_address":"","comment_id":235924,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595247188","product_id":100053901,"comment_content":"对比了PKCE 协议和隐式许可，两种都是适用于没有Server端的场景。但PKCE 协议感觉更安全，既然如此为什么还需要隐式许可呢？","like_count":0,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501882,"discussion_content":"\n可以理解为PKCE是一种增强","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596462749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235748,"user_name":"微风","can_delete":false,"product_type":"c1","uid":2045555,"ip_address":"","ucode":"C3B22113B96298","user_header":"https://static001.geekbang.org/account/avatar/00/1f/36/73/ac688ddf.jpg","comment_is_top":false,"comment_ctime":1595168948,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595168948","product_id":100053901,"comment_content":"没有 Server 端的 App用例中，如果授权码 code 被截获，再加上 code_challenge 也同时被截获了。那就可以伪造回去token了。怎么保证安全的？","like_count":0,"discussions":[{"author":{"id":1702255,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f9/6f/9c008ceb.jpg","nickname":"stanleyjobson","note":"","ucode":"4CA84795F59339","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305124,"discussion_content":"code_challenge 截获没用。应该是获取到code 同时也需要获取verifer 这样hacker 通过这两个 直接去 获取token 应该也是可以获取到的。，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599791158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234979,"user_name":"suhuijie","can_delete":false,"product_type":"c1","uid":1999277,"ip_address":"","ucode":"DC5A2F27E11DB2","user_header":"","comment_is_top":false,"comment_ctime":1594862373,"is_pvip":false,"replies":[{"id":"88362","content":"微信提供的联合登录肯定是OAuth，至于微信app自身内部使用了什么，这个还需要再确认。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1596462887,"ip_address":"","comment_id":234979,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594862373","product_id":100053901,"comment_content":"微信自己登陆用的什么机制，也是OAuth还是？","like_count":0,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501568,"discussion_content":"微信提供的联合登录肯定是OAuth，至于微信app自身内部使用了什么，这个还需要再确认。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596462887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234810,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1594801938,"is_pvip":true,"replies":[{"id":"86697","content":"PKCE的推出是为了解决使用授权码许可类型的公开客户端容易遭到授权码窃听的攻击的问题。但是对于公开客户端固有的弊端PKCE是解决不了的。<br><br>为了【缓解】这种针对公开客户端的攻击，OAuth发布了一个附加规范，也就是我们说的PKCE。","user_name":"作者回复","user_name_real":"王新栋","uid":"1352303","ctime":1594826038,"ip_address":"","comment_id":234810,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594801938","product_id":100053901,"comment_content":"如果拿到 app_id 是不是就可以冒充该客户端短了？ 还是授权服务还必须要验证 app_id 和 redirect_uri <br>绑定关系的？","like_count":0,"discussions":[{"author":{"id":1352303,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a2/6f/d239ed80.jpg","nickname":"王新栋","note":"","ucode":"0A5D089B8E1E9D","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501513,"discussion_content":"PKCE的推出是为了解决使用授权码许可类型的公开客户端容易遭到授权码窃听的攻击的问题。但是对于公开客户端固有的弊端PKCE是解决不了的。\n\n为了【缓解】这种针对公开客户端的攻击，OAuth发布了一个附加规范，也就是我们说的PKCE。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594826038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234421,"user_name":"inrtyx","can_delete":false,"product_type":"c1","uid":1246178,"ip_address":"","ucode":"81CD18FF34ABAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","comment_is_top":false,"comment_ctime":1594688947,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1594688947","product_id":100053901,"comment_content":"如果请求code的参数和请求token的参数都被截取了，那不就可以反推code_verifier？","like_count":0,"discussions":[{"author":{"id":1465512,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5c/a8/0fc3dce5.jpg","nickname":"Invincible(･ิϖ･ิ)っ","note":"","ucode":"E1CB4D9113C337","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291053,"discussion_content":"sha256散列之后目前基本不可能被反推","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594693115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}