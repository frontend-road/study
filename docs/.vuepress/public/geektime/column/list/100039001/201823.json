{"id":201823,"title":"48 | 代理模式：代理在RPC、缓存、监控等场景中的应用","content":"<p>前面几节，我们学习了设计模式中的创建型模式。创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><p>其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</p><p>从今天起，我们开始学习另外一种类型的设计模式：结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>代理模式的原理解析</h2><p><strong>代理模式</strong>（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。我们通过一个简单的例子来解释一下这段话。</p><!-- [[[read_end]]] --><p>这个例子来自我们在第25、26、39、40节中讲的性能计数器。当时我们开发了一个MetricsCollector类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个MetricsCollector类：</p><pre><code>public class UserController {\n  //...省略其他属性和方法...\n  private MetricsCollector metricsCollector; // 依赖注入\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略login逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // ... 省略register逻辑...\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    //...返回UserVo数据...\n  }\n}\n</code></pre><p>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</p><p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类UserControllerProxy和原始类UserController实现相同的接口IUserController。UserController类只负责业务功能。代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：</p><pre><code>public interface IUserController {\n  UserVo login(String telephone, String password);\n  UserVo register(String telephone, String password);\n}\n\npublic class UserController implements IUserController {\n  //...省略其他属性和方法...\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    //...省略login逻辑...\n    //...返回UserVo数据...\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    //...省略register逻辑...\n    //...返回UserVo数据...\n  }\n}\n\npublic class UserControllerProxy implements IUserController {\n  private MetricsCollector metricsCollector;\n  private UserController userController;\n\n  public UserControllerProxy(UserController userController) {\n    this.userController = userController;\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // 委托\n    UserVo userVo = userController.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = userController.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n\n//UserControllerProxy使用举例\n//因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController = new UserControllerProxy(new UserController());\n</code></pre><p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</p><p>对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：</p><pre><code>public class UserControllerProxy extends UserController {\n  private MetricsCollector metricsCollector;\n\n  public UserControllerProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n//UserControllerProxy使用举例\nUserController userController = new UserControllerProxy();\n</code></pre><h2>动态代理的原理解析</h2><p>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</p><p>如果有50个要添加附加功能的原始类，那我们就要创建50个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p><p>我们可以使用动态代理来解决这个问题。所谓<strong>动态代理</strong>（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</p><p>如果你熟悉的是Java语言，实现动态代理就是件很简单的事情。因为Java语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是Java的反射语法）。我们来看一下，如何用Java的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类。</p><pre><code>public class MetricsCollectorProxy {\n  private MetricsCollector metricsCollector;\n\n  public MetricsCollectorProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public Object createProxy(Object proxiedObject) {\n    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();\n    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);\n    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n  }\n\n  private class DynamicProxyHandler implements InvocationHandler {\n    private Object proxiedObject;\n\n    public DynamicProxyHandler(Object proxiedObject) {\n      this.proxiedObject = proxiedObject;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      long startTimestamp = System.currentTimeMillis();\n      Object result = method.invoke(proxiedObject, args);\n      long endTimeStamp = System.currentTimeMillis();\n      long responseTime = endTimeStamp - startTimestamp;\n      String apiName = proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);\n      metricsCollector.recordRequest(requestInfo);\n      return result;\n    }\n  }\n}\n\n//MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy = new MetricsCollectorProxy();\nIUserController userController = (IUserController) proxy.createProxy(new UserController());\n</code></pre><p>实际上，Spring AOP底层的实现原理就是基于动态代理。用户\b配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p><h2>代理模式的应用场景</h2><p>代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在你的项目开发中。</p><h3>1.业务系统的非功能性需求开发</h3><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><p>如果你熟悉Java语言和Spring开发框架，这部分工作都是可以在Spring AOP切面中完成的。前面我们也提到，Spring AOP底层的实现原理就是基于动态代理。</p><h3>2.代理模式在RPC、缓存中的应用</h3><p><strong>实际上，RPC框架也可以看作一种代理模式</strong>，GoF的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><p>关于远程代理的代码示例，我自己实现了一个简单的RPC框架Demo，放到了GitHub中，你可以点击这里的<a href=\"https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc\">链接</a>查看。</p><p><strong>我们再来看代理模式在缓存中的应用。</strong>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</p><p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p><p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于Spring框架来开发的话，那就可以在AOP切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在AOP切面中拦截请求，如果请求中带有支持缓存的字段（比如http://…?..&amp;cached=true），我们便从缓存（内存缓存或者Redis缓存等）中获取数据直接返回。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.代理模式的原理与实现</strong></p><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p><strong>2.动态代理的原理与实现</strong></p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p><strong>3.代理模式的应用场景</strong></p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。</p><h2>课堂讨论</h2><ol>\n<li>除了Java语言之外，在你熟悉的其他语言中，如何实现动态代理呢？</li>\n<li>我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。</li>\n</ol><p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"47 | 原型模式：如何最快速地clone一个HashMap散列表？","id":200786},"right":{"article_title":"49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？","id":202786}},"comments":[{"had_liked":false,"id":180820,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1582422121,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"688777189481","product_id":100039001,"comment_content":"组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。<br>继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。<br>","like_count":161,"discussions":[{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292410,"discussion_content":"我觉得你说的组合模式的缺点不对，有点儿本末倒置了，即然不需要扩展的方法，那么在抽象成为接口的时候就不应该定义这个方法呀，接口中定义的应该都是会被代理的方法才对。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1595217951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1020311,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/97/3762ca10.jpg","nickname":"小情绪","note":"","ucode":"92D8081DB8DB45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304569,"discussion_content":"同意，可以使用接口隔离原则。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1599616988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292410,"ip_address":""},"score":304569,"extra":""},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342579,"discussion_content":"不对， 一般调用者直接调用的代理类， 他说是代理类需要把真正的类的所有接口都实现一遍","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1610721657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292410,"ip_address":""},"score":342579,"extra":""},{"author":{"id":2309205,"avatar":"","nickname":"Geek_3208d8","note":"","ucode":"4D1153A3C557C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391005,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630228869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292410,"ip_address":""},"score":391005,"extra":""}]},{"author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300584,"discussion_content":"如果需要对子类进行代理，继承式的代理肯定行不通。一种可行的方式是：类 A 需要被代理，定义类 B 继承自 A，并重写所有的方法调用转发给内部的 A 对象。再定义代理类 C，继承自类 B，只重写它需要代理的方法，这样类 A 的子类也可以被类 C 代理。增加类 B 这个中间类的好处是，如果类 A  需要新的代理类，直接让它继承自类 B，然后只重写需要代理的方法即可，其他方法调用自动转发到了底层的被代理对象上了，不必一个个手写，避免重复劳动。\n\nclass A {\n  void a() { System.out.println(&#34;hello&#34;)}\n  void b() {System.out.println(&#34;world&#34;)}\n}\n\nclass B extends A {\n   A a;\n   B(A a) {\n      this.a = a;\n   }\n   void a() {\n      a.a();\n   }\n   void b() {\n      a.b();\n   }\n}\n\nclass C extends B {\n  C(A a) {\n    super(a);\n  }\n  void a() {\n     doSomethingBeforeA();\n     super.a();\n   }\n}\n\nclass D extends B {\n  D(A a) {\n    super(a);\n  }\n  void b() {\n     doSomethingBeforeB();\n     super.b();\n   }\n}","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598182562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1948635,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bb/db/f8c74599.jpg","nickname":"学了忘","note":"","ucode":"00789BBC1E51E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384413,"discussion_content":"类B是多余的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626576661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300584,"ip_address":""},"score":384413,"extra":""}]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201878,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583846893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180347,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1582264565,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"512683372789","product_id":100039001,"comment_content":"      java中,动态代理的实现基于字节码生成技术(代码里就是newProxyInstance片段),可以在jvm运行时动态生成和加载字节码,类似的技术还有asm,cglib,javassist,平时编译java用的javac命令就是字节码生成技术的&quot;老祖宗&quot;<br>     java中用到字节码生成技术的还有JSP编译器.AOP框架,反射等等<br>     深入理解java虚拟机第三版里对动态代理的描述:<br>     动态代理中所说的&quot;动态&quot;,是针对使用Java代码实际编写了代理类的&quot;静态&quot;代理而言的,它的优势不在于省去了编写代理类那一点编码工作量,而是实现了可以在原始类和接口还未知的时候,就确定了代理类的行为,当代理类与原始类脱离直接联系后,就可以很灵活的重用于不同的应用场景之中<br>     ","like_count":118,"discussions":[{"author":{"id":1966533,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg","nickname":"cake","note":"","ucode":"55A7FC6CC1204C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387491,"discussion_content":"JDK不是字节码生成技术吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628214517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205143,"user_name":"trier","can_delete":false,"product_type":"c1","uid":1285659,"ip_address":"","ucode":"498137BC5667AD","user_header":"https://static001.geekbang.org/account/avatar/00/13/9e/1b/9cb138f0.jpg","comment_is_top":false,"comment_ctime":1586537615,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"126140589199","product_id":100039001,"comment_content":"粗略“翻译”至PHP，中间省略了很多关键的判断，主要是想知道有多少PHPer在看。<br><br>interface IUserController <br>{<br>    public function login(String $telephone, String $password);<br>    public function register(String $telephone, String $password);<br>}<br>  <br>class UserController implements IUserController <br>{<br>    public function login(String $telephone, String $password) <br>    {<br>        echo &#39;is Login&#39; . PHP_EOL;<br>    }<br>  <br>    public function register(String $telephone, String $password) <br>    {<br><br>    }<br>}<br><br>class MetricsCollector<br>{<br>    public function recordRequest($requestInfo)<br>    {<br>    }<br>}<br><br>class RequestInfo<br>{<br>    public function __construct($apiName, $responseTime, $startTimestamp)<br>    {<br>    }<br>}<br><br><br>class MetricsCollectorProxy <br>{<br>    private $proxiedObject;<br><br>    private $metricsCollector;<br><br>    public function __construct(MetricsCollector $metricsCollector)<br>    {<br>        $this-&gt;metricsCollector = $metricsCollector;<br>    }<br>    <br>    public function createProxy(object $object)<br>    {<br>        $this-&gt;proxiedObject = $object;<br>        return $this;<br>    }<br><br>    public function __call($method, $arguments)<br>    {<br>        $ref = new ReflectionClass($this-&gt;proxiedObject);<br>        if (!$ref-&gt;hasMethod($method))<br>            throw new Exception(&quot;method not existed&quot;);<br><br>        $method = $ref-&gt;getMethod($method);<br>        $startTimestamp = time();<br>        $userVo = $this-&gt;callMethod($method, $arguments);<br>        $endTimeStamp = time();<br>        $responseTime = $endTimeStamp - $startTimestamp;<br>        $requestInfo = new RequestInfo(&quot;login&quot;, $responseTime, $startTimestamp);<br>        $this-&gt;metricsCollector-&gt;recordRequest($requestInfo);<br><br>        return $userVo;    <br>    }<br><br><br>    private function callMethod(\\ReflectionMethod $method, $arguments)<br>    {<br>        &#47;&#47;前置判断省略<br>        $method-&gt;invokeArgs($this-&gt;proxiedObject, $arguments);  <br>    }<br><br>}<br><br><br>$proxy = new MetricsCollectorProxy(new MetricsCollector);<br>$userController = $proxy-&gt;createProxy(new UserController);<br>$userController-&gt;login(13800138000, &#39;pwd&#39;);<br>","like_count":30,"discussions":[{"author":{"id":1631570,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/52/1a968baa.jpg","nickname":"阿坤","note":"","ucode":"9A2273629BB6E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303732,"discussion_content":"php 怎么实现动态代理？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599364313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1285659,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9e/1b/9cb138f0.jpg","nickname":"trier","note":"","ucode":"498137BC5667AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631570,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/52/1a968baa.jpg","nickname":"阿坤","note":"","ucode":"9A2273629BB6E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318031,"discussion_content":"上面的不就是动态代理嘛？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603631143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303732,"ip_address":""},"score":318031,"extra":""},{"author":{"id":1193298,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/52/bc63d1ef.jpg","nickname":"nick","note":"","ucode":"12A522100DE574","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631570,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e5/52/1a968baa.jpg","nickname":"阿坤","note":"","ucode":"9A2273629BB6E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366310,"discussion_content":"__call，ReflectionClass","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618025191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303732,"ip_address":""},"score":366310,"extra":""}]},{"author":{"id":2956550,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/1d/06/9ee42a30.jpg","nickname":"Mister.张","note":"","ucode":"2DA655DC15EABC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580279,"discussion_content":"优秀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658062184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","nickname":"王先森","note":"","ucode":"1AF1A395107479","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367177,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618283394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2278659,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TUMtkaIMdbFDS28AhjrQcqOhiapNvHyPMApz9QoZZkShZmomJRh6GX2aL2YeSMg4SicdydzdWxXZOZz49HNS9EtA/132","nickname":"Windqiu","note":"","ucode":"EF78D3CF73BCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366740,"discussion_content":"对层主的源代码做了以下几点修改：\n1、callMethod 方法缺少返回值\n2、__call() 方法调用new RequestInfo方法的 &#39;login&#39; 指定改为入参 $method 替换。\n3、createProxy() 函数参数的类型改为 object => IUserController\n修改后，可以根据调用参数的形式，直接操作User的方法\n4、另外测试环境直接根据功能测试类进行的，缺少断言。\n5、由于评论限制2000字，无法贴代码，请自行校验下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618158467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2450539,"avatar":"","nickname":"Geek_f12f39","note":"","ucode":"44A4AC80BADB8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351084,"discussion_content":"优秀了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614149632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180255,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1582225198,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"108956407598","product_id":100039001,"comment_content":"是时候展示我动态语言Python的彪悍了，通过__getattribute__和闭包的配合实现，其中有个注意点就是在获取target时不能使用self.target，不然会递归调用self.__getattribute__导致堆栈溢出：<br>class RealClass(object):<br>    def realFunc(self, s):<br>        print(f&quot;Real func is coming {s}&quot;)<br><br>class DynamicProxy(object):<br>    def __init__(self, target):<br>        self.target = target<br>    <br>    def __getattribute__(self, name):<br>        target = object.__getattribute__(self, &quot;target&quot;)<br>        attr = object.__getattribute__(target, name)<br>        <br>        def newAttr(*args, **kwargs):<br>            print(&quot;Before Calling Func&quot;)<br>            res = attr(*args, **kwargs)<br>            print(&quot;After Calling Func&quot;)<br>            return res<br>        return newAttr","like_count":26,"discussions":[{"author":{"id":1555804,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/5c/acb09bc7.jpg","nickname":"特拉仔","note":"","ucode":"B60AFA3EA26BDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300410,"discussion_content":"\n你这个也不算动态配置了，代理类不是只创建一次，而是需要对每一个被代理的类都初始化一个代理对象，感觉没有必要用特殊方法，可以用一个固定的方法传入类，方法名，参数就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598085057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1712955,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","nickname":"Geek_78eadb","note":"","ucode":"843C6C380D28FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555804,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/5c/acb09bc7.jpg","nickname":"特拉仔","note":"","ucode":"B60AFA3EA26BDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325927,"discussion_content":"确实，这种方法需要改进，使用属性拦截器实现代理模式跟委托+反射差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605481237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300410,"ip_address":""},"score":325927,"extra":""},{"author":{"id":1712955,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","nickname":"Geek_78eadb","note":"","ucode":"843C6C380D28FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555804,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/5c/acb09bc7.jpg","nickname":"特拉仔","note":"","ucode":"B60AFA3EA26BDD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325929,"discussion_content":"有没有改进方法呢，但小争哥的动态代理，也需要不停的初始化代理类 DynamicProxyHandler","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605481542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300410,"ip_address":""},"score":325929,"extra":""}]},{"author":{"id":1283861,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRyUPicEMqGsbsMicHPuvwM8nibfgK8Yt0AibAGUmnic7rLF4zUZ4dBj4ialYz54fOD6sURKwuJIWBNjhg/132","nickname":"咸鱼与果汁","note":"","ucode":"F79383599ACB02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294891,"discussion_content":"当原始类有存在成员变量当时候咋整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596025633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1712955,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OYQh8KlUgMx0sZ35felqqRlboXkcOFib0qGgRHuvFCNIMzxRzxN8SjZpwtDuS0PGV0L0Pneiak7yzcd043f2efbg/132","nickname":"Geek_78eadb","note":"","ucode":"843C6C380D28FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283861,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRyUPicEMqGsbsMicHPuvwM8nibfgK8Yt0AibAGUmnic7rLF4zUZ4dBj4ialYz54fOD6sURKwuJIWBNjhg/132","nickname":"咸鱼与果汁","note":"","ucode":"F79383599ACB02","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325928,"discussion_content":"可以用 hasattr(原始对象，变量) 进行判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605481371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294891,"ip_address":""},"score":325928,"extra":""}]}]},{"had_liked":false,"id":180599,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1582347386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87481693306","product_id":100039001,"comment_content":"Java中的动态代理原理就是运行的时候通过asm在内存中生成一份字节码，而这个字节码就是代理类的字节码，通过System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);设置可以保存这份字节码，反编译后看下其源码就知道Java中的动态代理是什么原理了。","like_count":21},{"had_liked":false,"id":181795,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1582634978,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"61712177122","product_id":100039001,"comment_content":"感谢争哥，今天终于学会了“动态代理”<br>还是要动手试试，代码在这是 https:&#47;&#47;bit.ly&#47;37UqLNf<br><br>学有余力的小伙伴，附上一些资料吧：<br>https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;technotes&#47;guides&#47;reflection&#47;proxy.html<br>https:&#47;&#47;www.baeldung.com&#47;java-dynamic-proxies","like_count":15,"discussions":[{"author":{"id":1192601,"avatar":"https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg","nickname":"Tomy","note":"","ucode":"D7E49E90B0D60F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380403,"discussion_content":"invoke方法什么时候被调用 了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624493039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212701,"discussion_content":"你这个短网址是怎么弄的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585010059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189270,"discussion_content":"赞，我就拿来主义啦。学习起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582863054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181349,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1582529696,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44532202656","product_id":100039001,"comment_content":"笔记：<br><br>- 什么是代理模式：它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。<br><br>- 代理模式得实现：<br>  - 静态代理<br>    1. 实现被代理对象口： 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。<br>    2. 继承被代理对象：代理类继承原始类，然后扩展附加功能。<br>  - 动态代理 ： 在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。 <br>    1.  jdk动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。<br>    2. cglib动态代理是利用asm开源包，对被代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 ","like_count":11,"discussions":[{"author":{"id":1622696,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","nickname":"一格状语","note":"","ucode":"EBA9ED5F97416D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415287,"discussion_content":"在调用具体方法前调用，前？- -！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637047617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192601,"avatar":"https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg","nickname":"Tomy","note":"","ucode":"D7E49E90B0D60F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380404,"discussion_content":"invoke方法什么时候被调用 了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624493048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180308,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1582254846,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"44531927806","product_id":100039001,"comment_content":"1. .net支持反射和动态代理，所以实现方式和java类似；golang目前看到的都是习惯使用代码生成的方式来达成，根据已有代码生成一份加壳代码，调用方使用加壳代码的方法，例好：easyJson给类加上序列化和反序列化功能；gomock生成mock代理。<br>2. 组合与继承的优缺点：<br>没有绝对的优缺点，要看场景比如：<br>当被代理的类所有功能都需要被代理时，使用继承方式就可以编译器检查（被代理类修改时编译期就可以检查出问题）；<br>当被代理的类只是部分功能需要被代理时，使用组合方式就可按需代理，但是如果原来不需要的，后来也需要了就比较尴尬了。<br>继承可能会让代理类被迫实现一些对代理类来说无意义代码，继承方式对代理类的侵入比较大，而组合的侵入影响比继承可控。","like_count":11},{"had_liked":false,"id":180331,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1582257843,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"40236963507","product_id":100039001,"comment_content":"1、OC中通过runtime和分类来实现动态代理.<br>2、组合优势可以直接使用原始类实例,继承要通过代理类实例来操作,可能会导致有人用原始类有人用代理类.而继承可以不改变原始类代码来使用.","like_count":9,"discussions":[{"author":{"id":1344488,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/e8/f726c635.jpg","nickname":"加温后的啤酒","note":"","ucode":"5F30978CDB1606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581357,"discussion_content":"OC中用runtime实现动态代理太大材小用了。用NSProxy即可...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658738174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/93/fed4baec.jpg","nickname":"Null","note":"","ucode":"D48077EBAD2E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392665,"discussion_content":"OC是通过runtime实现动态代理的，分类不能实现动态代理哦，分类是编译时决议的，只能实现静态代理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631092009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1456964,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","nickname":"菜头","note":"","ucode":"C5E95519F9EA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049235,"avatar":"https://static001.geekbang.org/account/avatar/00/10/02/93/fed4baec.jpg","nickname":"Null","note":"","ucode":"D48077EBAD2E87","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564836,"discussion_content":"分类也是运行时决议的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650338417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392665,"ip_address":""},"score":564836,"extra":""}]},{"author":{"id":1589894,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","nickname":"Vicent🍀","note":"","ucode":"70AEA72A0B6F0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179959,"discussion_content":"也写过OC，看到你的回复，才想起来runtime运行时可以增强功能，就是类似AOP动态代理模式啊，快忘完了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582265553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":1589894,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","nickname":"Vicent🍀","note":"","ucode":"70AEA72A0B6F0E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201687,"discussion_content":"不过一般没人这么用，毕竟官方也不推荐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583825019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":179959,"ip_address":""},"score":201687,"extra":""}]}]},{"had_liked":false,"id":180244,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1582216436,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"31646987508","product_id":100039001,"comment_content":"动态代理有两种:jdk动态代理和cglib动态代理。","like_count":7,"discussions":[{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183882,"discussion_content":"jdk动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。\n而cglib动态代理是利用asm开源包，对被代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1582528474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":183895,"discussion_content":"很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582530150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":183882,"ip_address":""},"score":183895,"extra":""}]},{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251928,"discussion_content":"cglib已经挺老了也不更新了，现在是byte-buddy","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588126531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247171,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599623730,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27369427506","product_id":100039001,"comment_content":"动态代码虽然对使用场景讲了，先不说自己如何实现一个动态代码没有讲。就算拿java的现成接口，是不是最起码应该讲下里面的实现。做到知其然知其所以然呢？你这动态代理讲的就像一个hello world。","like_count":7,"discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533377,"discussion_content":"看这个专栏不只是java程序员，其他语言也有。不可能啥都深入讲。Java动态代理原理简单，可以网上找找的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637848897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239082,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1596430395,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23071266875","product_id":100039001,"comment_content":"为啥我感觉静态代理像是装饰器模式","like_count":5,"discussions":[{"author":{"id":1656956,"avatar":"https://static001.geekbang.org/account/avatar/00/19/48/7c/2aaf50e5.jpg","nickname":"coder","note":"","ucode":"3A0940EBF94577","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363689,"discussion_content":"用途不同，静态代理主要做一些与当前业务不同的功能，而装饰器更多的是同类型功能的增强","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1617262411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2314948,"avatar":"","nickname":"小白","note":"","ucode":"ED798245A9B0CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1656956,"avatar":"https://static001.geekbang.org/account/avatar/00/19/48/7c/2aaf50e5.jpg","nickname":"coder","note":"","ucode":"3A0940EBF94577","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553865,"discussion_content":"说到点上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646121616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363689,"ip_address":""},"score":553865,"extra":""}]},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533378,"discussion_content":"设计模式在代码结构都有点类似，主要要看能解决什么编码问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637848981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181122,"user_name":"distdev","can_delete":false,"product_type":"c1","uid":1302798,"ip_address":"","ucode":"22AA05788627C6","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/0e/9ce05946.jpg","comment_is_top":false,"comment_ctime":1582494540,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"23057331020","product_id":100039001,"comment_content":"请问 如果对于业务方法 有多个非业务功能 比如metrics, logging还有其他的 应该实现在一个代理class里？还是一个filter chain里?","like_count":5,"discussions":[{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238254,"discussion_content":"aop里面实现一个chain。根据配置需要进行包装","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587216587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180300,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1582253141,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"23057089621","product_id":100039001,"comment_content":"C#中可以通过emit技术实现动态代理。<br>基于继承的代理适合代理第三方类，jdk中的动态代理只能代理基于接口实现的类，无法代理不是基于接口实现的类。所以在spring中有提供基于jdk实现的动态代理和基于cglib实现的动态代理。","like_count":5},{"had_liked":false,"id":291124,"user_name":"小马哥","can_delete":false,"product_type":"c1","uid":1358045,"ip_address":"","ucode":"B2C0FF38F8C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","comment_is_top":false,"comment_ctime":1620038476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18799907660","product_id":100039001,"comment_content":"不少同学纠结代理模式与后面要学的装饰器模式在功能上不能区分, 小马哥给个最简单的解释<br> *          在行为效果上, 两种设计模式都可以实现增强<br> *          代理模式的增强: 添加非业务功能;<br> *          装饰器模式的增强: 弥补或者扩展业务功能;<br>如果你非要使用装饰器进行非业务功能的增强, 以及使用代理模式扩展业务功能是否可以? 可以, 但是我们学习设计模式的目的是为了写出大牛一样专业的代码, 那么就借鉴设计模式的规则.<br>去高速公路上开车就遵守高速的限速规定","like_count":4},{"had_liked":false,"id":221454,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1590501919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14475403807","product_id":100039001,"comment_content":"代理顾名思义 就是对要调用的方法再次封装到一个新类中，这个类会调用你需要目标方法。<br>一、<br>function a(){&#47;&#47;要做的事}<br>function 代理(){<br>&#47;&#47;你可以在你要代理的方法前加逻辑<br>a();<br>&#47;&#47;也可以在方法后面加<br>}<br>调用  代理() <br>二、动态代理<br>所有要被代理的类都是用同一个规范。<br>比方说都用invoke(){具体逻辑}<br>a.invoke<br>b.invoke<br>c.invoke<br>.....这样写太麻烦。<br>可以在动态代理类中放一个list&lt;string&gt;变量<br>用来存存储要代理的类名<br><br>动态代理里面调用方法<br>public void invoke(){<br>    迭代list <br>    {<br>     反射 创建被代理的具体类<br>    具体类.invoke <br>    }<br>}<br><br>","like_count":3},{"had_liked":false,"id":192889,"user_name":"lcf枫","can_delete":false,"product_type":"c1","uid":1144171,"ip_address":"","ucode":"D51E8F68BD41CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/6b/fd685164.jpg","comment_is_top":false,"comment_ctime":1584877718,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"14469779606","product_id":100039001,"comment_content":"目前看到这里有点懵 分不清代理和装饰器了<br>","like_count":3},{"had_liked":false,"id":186310,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583823657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173758249","product_id":100039001,"comment_content":"<br>今天我回答下第二个问题,在原有的JDK中的代理,是一种基于接口的代理模式,要求代理类只能去代理某些接口,于是乎,为了能直接代理一个代理类,cglib加入了,可以传入一个对象实例,来进行包裹,从而达到代理这种需求,两者实际来说,JDK的代理类创建时间比cglib快的太多了,于是乎更加适合在框架中定义为非单例的类去代理,cglib适合于生成单例式类的代理类","like_count":2},{"had_liked":false,"id":186103,"user_name":"阿德","can_delete":false,"product_type":"c1","uid":1602420,"ip_address":"","ucode":"186D5E19E3CB6E","user_header":"https://static001.geekbang.org/account/avatar/00/18/73/74/3bf4b74e.jpg","comment_is_top":false,"comment_ctime":1583758238,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10173692830","product_id":100039001,"comment_content":"动态代理那里的invoke方法的第一个参数proxy有什么用，一直搞不清楚","like_count":2,"discussions":[{"author":{"id":1048314,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","nickname":"人间四月天","note":"","ucode":"11BE219C23EEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570685,"discussion_content":"这个就是生成的代理类对象，通过这个对象可以获取代理类的名字，不过老师这个例子其实没啥用，应该用被代理类的名字打印。使用场景应该还是有的，只不过常用场景用不到，但是jdk实现者，肯定要实现的通用一些。个人见解。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651856261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048314,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/fa/2a046821.jpg","nickname":"人间四月天","note":"","ucode":"11BE219C23EEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570674,"discussion_content":"要看动态生成的class，就知道这个东东啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651851547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362895,"discussion_content":"估计是由于老师的这个例子中没有用到proxy参数才产生疑惑吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617068014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444317,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/dd/02c73bd3.jpg","nickname":"何岸康","note":"","ucode":"F24898244A170D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266584,"discussion_content":"第一个是代理的实例啊。你想怎么用怎么用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589535859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185344,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583564695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173499287","product_id":100039001,"comment_content":"继承的代理类是通过重写来实现代理，如果超类本身方法间会调用，则被新增的代码也会被重复调用。这其实已经是一种修改，不是一种扩展了。相比下，组合型代理就没有这个问题<br><br>组合型代理需要原来的类有接口(抽象类)，代理类可以实现接口，来通过组合构成代理。继承型代理则没这个问题。","like_count":2},{"had_liked":false,"id":181641,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1582602072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172536664","product_id":100039001,"comment_content":"@Aspect<br>@Component<br>public class CacheAspect {<br><br>    @Pointcut(&quot;execution(* com.example.demo.controller..*(..))&quot;)<br>    public void controller() { }<br><br>    @Around(&quot;controller()&quot;)<br>    public Object around(ProceedingJoinPoint point) throws Throwable {<br>        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();<br>        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();<br>        Object retVal = null;<br>        if (parameterMap.containsKey(&quot;cached&quot;) &amp;&amp; parameterMap.get(&quot;cached&quot;)[0].equals(&quot;true&quot;)) {<br>            &#47;&#47; parameterMap<br>            System.out.println(&quot;get data from cache&quot;);<br>            retVal = 1; &#47;&#47; 省略从cache获取值<br>        } else {<br>            Object[] args = point.getArgs();<br>            retVal = point.proceed(args);<br>        }<br>        return retVal;<br>    }<br><br>}","like_count":2},{"had_liked":false,"id":180278,"user_name":"Summer  空城","can_delete":false,"product_type":"c1","uid":1337146,"ip_address":"","ucode":"6BDBB70FB6F709","user_header":"https://static001.geekbang.org/account/avatar/00/14/67/3a/0dd9ea02.jpg","comment_is_top":false,"comment_ctime":1582247723,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"10172182315","product_id":100039001,"comment_content":"老师好，有个地方不太明白，请指点下。<br>Spring框架实现AOP的时候是在BeanFactory中生成bean的时候触发动态代理替换成代理类的么？<br>如果我们自己想对某个Controller做代理的时候要怎么处理呢？一般是用@Controller注解某个Controller的，而且这个Controller不会实现接口。<br>谢谢老师！","like_count":2,"discussions":[{"author":{"id":1019186,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/uI4ufWlFvKqgK54s903icMx1WmibibjbbUicukgSGrtUt5ibjXXmOHiaGTTojsDOfPagprIwhSGVmibEgdsjYthXWFQgQ/132","nickname":"如果就是风硕","note":"","ucode":"280B9E4E94E0AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184704,"discussion_content":"兄台，我也遇到这个问题了，我对spring注解不熟，能把你的方案分享一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582559026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210588,"avatar":"https://static001.geekbang.org/account/avatar/00/12/78/dc/0c9c9b0f.jpg","nickname":"(´田ω田`)","note":"","ucode":"CA043D3EC6FE7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180056,"discussion_content":"如果我们自己想对某个Controller做代理的时候要怎么处理呢？一般是用@Controller注解某个Controller的，而且这个Controller不会实现接口。\n====================\n直接使用AOP就行了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582273774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1337146,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/3a/0dd9ea02.jpg","nickname":"Summer  空城","note":"","ucode":"6BDBB70FB6F709","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1210588,"avatar":"https://static001.geekbang.org/account/avatar/00/12/78/dc/0c9c9b0f.jpg","nickname":"(´田ω田`)","note":"","ucode":"CA043D3EC6FE7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180133,"discussion_content":"哈哈哈，谢谢啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582279275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":180056,"ip_address":""},"score":180133,"extra":""}]},{"author":{"id":1259140,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/84/788f0c60.jpg","nickname":"勤劳的明酱","note":"","ucode":"05EBE89B80371B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179814,"discussion_content":"bean被增强被postProcessor增强，不是在beanFactory生成bean的时候。可以看一下aop包里AbstractAutoProxyCreator这个抽象类和它的实现类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582254760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1337146,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/3a/0dd9ea02.jpg","nickname":"Summer  空城","note":"","ucode":"6BDBB70FB6F709","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1259140,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/84/788f0c60.jpg","nickname":"勤劳的明酱","note":"","ucode":"05EBE89B80371B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179906,"discussion_content":"好嘞，谢谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582259994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":179814,"ip_address":""},"score":179906,"extra":""}]}]},{"had_liked":false,"id":287806,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1618154416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913121712","product_id":100039001,"comment_content":"golang框架一般会用middleware实现这种所谓的代理（所有接口都需要的某个功能，如记录下接口参数），不过其实是基于职责链模式","like_count":1},{"had_liked":false,"id":236561,"user_name":"夜空咏叹调","can_delete":false,"product_type":"c1","uid":1189074,"ip_address":"","ucode":"CC9350BCF218CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d2/a5e272ce.jpg","comment_is_top":false,"comment_ctime":1595468089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890435385","product_id":100039001,"comment_content":"以前在使用java的动态代理时都有点知其然而不知其所以然的感觉，一直没想明白为什么要多构造一个代理类出来，今天看代理模式突然有种豁然开朗的感觉，这个专栏真的收获很多！！","like_count":1},{"had_liked":false,"id":223333,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1591064460,"is_pvip":false,"replies":[{"id":"85677","content":"我看看，多谢！<br>","user_name":"作者回复","comment_id":223333,"uid":"1190123","ip_address":"","utype":1,"ctime":1593911239,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5886031756","product_id":100039001,"comment_content":"基于继承的静态代理实现的demo中稍微有些瑕疵。 <br>login() 和register() 方法应该直接调用super.login() 和 super.register() ,然后再super前后插入额外的代码 。这样更像在代理，而不是在继承修改父类。给争哥提个不成熟的小建议。<br><br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497103,"discussion_content":"我看看，多谢！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593911239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194175,"user_name":"老余","can_delete":false,"product_type":"c1","uid":1295848,"ip_address":"","ucode":"17AC6C60D0EB86","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yicibWmBIDaSpBYI5wCBDQcYu6mxjvz3XZzBibxSNXFfqCS6OJOjvy2Nc2lyDicZfmneW9ZY4KbicA1sNgLktVSicgkw/132","comment_is_top":false,"comment_ctime":1585033391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880000687","product_id":100039001,"comment_content":"动态代理和 js 中的类装饰器如出一辙哈","like_count":1},{"had_liked":false,"id":187077,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1584007713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878975009","product_id":100039001,"comment_content":"针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http:&#47;&#47;…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。<br><br>如此后台不也得需求实现两套代码吗，cached=true查询缓存，其他的走实时查询。","like_count":1},{"had_liked":false,"id":182277,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1582758643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877725939","product_id":100039001,"comment_content":"打卡～看懂啦，写的真好","like_count":1},{"had_liked":false,"id":181503,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582552737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877520033","product_id":100039001,"comment_content":"课堂讨论:<br><br>2.我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。<br><br>    使用继承方式实现代理模式是一种折衷做法:原则上proxy和client对象并不是严格的is-a关系, 业务变动会导致client类和proxy类必须一起修改, 耦合严重.<br><br>    使用组合的方式实现代理模式才是正派用法. client和proxy职责分离, client类甚至可以包装多层代理!你细品.","like_count":1},{"had_liked":false,"id":180831,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1582423980,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5877391276","product_id":100039001,"comment_content":"python的装饰器是不是代理模式","like_count":1,"discussions":[{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186519,"discussion_content":"我觉得是，装饰器的本质是一个函数，在调用目标函数之前增加“切面”功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582688050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742968,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","nickname":"麦芽科技学堂","note":"","ucode":"A90DDE4B6696BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182655,"discussion_content":"我觉得是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582445857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180279,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1582247903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877215199","product_id":100039001,"comment_content":"组合比继承更灵活，但可能需要重复的代码实现，这就需要用到委托技术解决。继承更简单，如果相应类的行为不太会改变，可以用继承。","like_count":1},{"had_liked":false,"id":345459,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1652281546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652281546","product_id":100039001,"comment_content":"基于组合的模式，会更加灵活一点。因为是代理的接口。把真正的逻辑委托给被代理类。组合的方式，可以灵活替换被代理类。但是需要实现全部的接口方法<br><br>基于继承的代理模式，优点就是可以针对类的部分方法进行代理。缺点就是只能对一个类进行继承代理","like_count":0},{"had_liked":false,"id":345047,"user_name":"felicity","can_delete":false,"product_type":"c1","uid":1691623,"ip_address":"","ucode":"B4D4088C5ABFC1","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/e7/4c2323ba.jpg","comment_is_top":false,"comment_ctime":1651981363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651981363","product_id":100039001,"comment_content":"老师好，想请教一下，代码里的类叫做MetricsCollectorProxy<br>但是通过动态代理添加的逻辑都是给UserController做增强<br>包括您举得第一个静态代理的例子代理类都叫做UserControllerProxy，为什么第二个动态代理的例子变成了MetricsCollectorProxy，个人理解应该还是叫做UserControllerProxy，因为它不是对MetricsCollector的增强。<br>请问老师我的理解对吗还是说您有别的考量，谢谢","like_count":0},{"had_liked":false,"id":343647,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1650965665,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1650965665","product_id":100039001,"comment_content":"just 100?","like_count":0},{"had_liked":false,"id":337076,"user_name":"古杨","can_delete":false,"product_type":"c1","uid":1744092,"ip_address":"","ucode":"8F52AA86B589C7","user_header":"","comment_is_top":false,"comment_ctime":1646610355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646610355","product_id":100039001,"comment_content":"这个设计模式课程真心是常读常新。之前看到这个代理模式，感觉也就那么回事嘛，搞一个类把原始类的方法调用一下，再附加一些逻辑。好像挺简单的。看到后面的spring aop 动态代理，也没有细想。完全就是感觉又是一个面试题。<br>最近在看spring aop的源码，又看一些老师手写aop的框架代码，回头再看这个代理模式章节。忽然豁然开朗了。原来这里早就给讲清楚了，只是之前能力有限，没有理解…","like_count":0},{"had_liked":false,"id":330018,"user_name":"LIFE l=new LIFE()","can_delete":false,"product_type":"c1","uid":2446981,"ip_address":"","ucode":"729BACA3B7FD42","user_header":"https://static001.geekbang.org/account/avatar/00/25/56/85/6da913fa.jpg","comment_is_top":false,"comment_ctime":1641733267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641733267","product_id":100039001,"comment_content":"反射+动态代理是框架的基石","like_count":0},{"had_liked":false,"id":325880,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1639210565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639210565","product_id":100039001,"comment_content":"总结<br>1、代理模式的原理与实现<br>\t在不改变被代理类的情况下，通过引入代理类来给原始类附加功能。通过实现相同接口或继承被代理类的方式来实现代理模式。<br>2、动态代理的原理与实现<br>\t不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。<br>3、代理模式的应用场景<br>\t业务系统的非功能性需求开发-监控、统计、鉴权、限流、事务、幂等、日志<br>\t代理模式在 RPC、缓存中的应用","like_count":0},{"had_liked":false,"id":325550,"user_name":"itschenxiang","can_delete":false,"product_type":"c1","uid":1519547,"ip_address":"","ucode":"7D90194AC52435","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/bb/4236d712.jpg","comment_is_top":false,"comment_ctime":1639020171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639020171","product_id":100039001,"comment_content":"静态代理，使用组合的方式，原始类和代理类为什么需要实现相同的接口呢？这个例子是不是不太恰当","like_count":0},{"had_liked":false,"id":324028,"user_name":"她微笑的脸y","can_delete":false,"product_type":"c1","uid":1813614,"ip_address":"","ucode":"E3B559B10B4A70","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ac/6e/c13d131c.jpg","comment_is_top":false,"comment_ctime":1638263258,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638263258","product_id":100039001,"comment_content":"就是Aop的基础吧","like_count":0},{"had_liked":false,"id":321736,"user_name":"Geek_00e01b","can_delete":false,"product_type":"c1","uid":1597071,"ip_address":"","ucode":"BC76A83B53D0EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","comment_is_top":false,"comment_ctime":1637028586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637028586","product_id":100039001,"comment_content":"从文中中对代理模式的解释来看，iOS中常用的delegate算不上正统的代理模式。因为代理模式是在不改变原始类的基础上为其添加功能，而delegate更像事先设计好的在原始类中需要的位置通过delegate将行为委托给别人执行","like_count":0},{"had_liked":false,"id":314110,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1632841236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632841236","product_id":100039001,"comment_content":"Java并发包 AQS和他的上层使用者，Lock","like_count":0},{"had_liked":false,"id":310424,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1475327,"ip_address":"","ucode":"968C4E50FCCE4B","user_header":"https://static001.geekbang.org/account/avatar/00/16/82/ff/3672e7e9.jpg","comment_is_top":false,"comment_ctime":1630650080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630650080","product_id":100039001,"comment_content":"这代理模式和装饰器模式 感觉一样呀","like_count":0},{"had_liked":false,"id":300161,"user_name":"花花","can_delete":false,"product_type":"c1","uid":2347314,"ip_address":"","ucode":"6BCB9B92101EB2","user_header":"https://static001.geekbang.org/account/avatar/00/23/d1/32/a1963478.jpg","comment_is_top":false,"comment_ctime":1625026211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625026211","product_id":100039001,"comment_content":"aop中的jdk动态代理， 必须要求被代理类实现接口或者继承，通过proxy进行对被代理的增强<br>cglib代理：被代理类的子类，对代理类进行增强<br>静态代理：和被代理类实现同一个接口或继承，在代理类中有被代理类的引用","like_count":0},{"had_liked":false,"id":299142,"user_name":"Tomy","can_delete":false,"product_type":"c1","uid":1192601,"ip_address":"","ucode":"D7E49E90B0D60F","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg","comment_is_top":false,"comment_ctime":1624492261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624492261","product_id":100039001,"comment_content":"DynamicProxyHandler  中invoke方法什么时候被调用 了，跑了一下代码发现它没有被调用 ","like_count":0},{"had_liked":false,"id":297561,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1623637342,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1623637342","product_id":100039001,"comment_content":"java中jdk代理就是基于接口，cglib代理时基于继承类","like_count":0},{"had_liked":false,"id":293022,"user_name":"John","can_delete":false,"product_type":"c1","uid":1228424,"ip_address":"","ucode":"A46AF2906C38C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/88/8d15796f.jpg","comment_is_top":false,"comment_ctime":1621158125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621158125","product_id":100039001,"comment_content":"代理模式的使用需要具体语言对于多态特性的支持，而动态代理更是需要该语言在多态特性的基础上提供了相应的框架予以支持","like_count":0},{"had_liked":false,"id":291965,"user_name":"丰年","can_delete":false,"product_type":"c1","uid":1956371,"ip_address":"","ucode":"1A1483D56EE9B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epyF9Q0OTp7FRgtibvUTiaoSiaKkhrviarcZFic3UrN1sX9ltbbycibxwwaMubpVIuCofoIVBmPYRTfPn9g/132","comment_is_top":false,"comment_ctime":1620628402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620628402","product_id":100039001,"comment_content":"高啊，总算是看懂了传说中的代理模式","like_count":0},{"had_liked":false,"id":291486,"user_name":"Time-sun","can_delete":false,"product_type":"c1","uid":1949865,"ip_address":"","ucode":"47D2EB4FD2F925","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/tiaEaUwoYl8z5FROHibq5XYjjcuTia840dHYT8zqwV4ibfWPNeQHw3ib20iba8bRRkVxwYUCz9ENkDGRsfnmSJQBAALA/132","comment_is_top":false,"comment_ctime":1620304135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620304135","product_id":100039001,"comment_content":"代理模式<br>不变的是业务代码，变化的是在业务上附加的功能（监控、日志、通知等），那么如何解决 在不变化老业务的基础上增加功能的问题呢？把功能放在代理类中。<br>那个如何将代理类和原有的业务类联动起来呢？<br>方式1: 修改原有类，让原有类实现一个接口， 功能类持有原油类的引用，在原有类调用之前或者之后，调用功能类的代码。同时原来调用 原有类的地方，需要改为调用接口。<br>方式2: 新增功能类，继承自原有类，在原有类的之前或者之后调用功能类的逻辑。<br>动态代理，是第一种处理方式<br>","like_count":0},{"had_liked":false,"id":287893,"user_name":"prepared","can_delete":false,"product_type":"c1","uid":1194853,"ip_address":"","ucode":"00E54A5C7CDCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","comment_is_top":false,"comment_ctime":1618210525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618210525","product_id":100039001,"comment_content":"jdk的 Future 也用到了 代理模式","like_count":0},{"had_liked":false,"id":286342,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1656956,"ip_address":"","ucode":"3A0940EBF94577","user_header":"https://static001.geekbang.org/account/avatar/00/19/48/7c/2aaf50e5.jpg","comment_is_top":false,"comment_ctime":1617262458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617262458","product_id":100039001,"comment_content":"看懂了，真棒！","like_count":0},{"had_liked":false,"id":277142,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1612273926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612273926","product_id":100039001,"comment_content":"代理模式 在不改变 原类的基础上 对其功能扩展。<br>为啥不改变原类呢， 因为 扩展的功能和原类的功能 是不同的业务。 <br>代理模式 模式 有点分层的思想 只不过 下层 包含在上层中， 有点像洋葱。<br>本质还是 为了 解耦，遵守开闭， <br>至于 代码得到了精简， 切面，等 我觉得 只是 代理模式带来的好处","like_count":0},{"had_liked":false,"id":269084,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1608518194,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1608518194","product_id":100039001,"comment_content":"iOS的代理在UI框架中用的多，特别是UITableView，这是所有iOS开发都绕不开的一个控件。<br>OC中的代理更像是基于协议实现的通信和和回调，显得更纯粹。没想过在服务端，代理模式还有这样复杂的用法，也没想到这种基于继承扩展的方式也属于代理模式。","like_count":0,"discussions":[{"author":{"id":1023272,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9d/28/bcaf070d.jpg","nickname":"壹","note":"","ucode":"335D34216066E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363664,"discussion_content":"oc的那个代理跟这个是两回事。delegate在跟proxy同一场景下，为了区分，delegate往往译作委托。delegate是将自己的部分需要或者能力委托给一个外部对象去实现。跟proxy完全是不同的场景。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617256162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182656,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/c0/34660957.jpg","nickname":"里外的里","note":"","ucode":"DFC9F7C333CA85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348815,"discussion_content":"iOS那个叫delegate可以翻译成委托","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612744690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2098988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/07/2c/106f95e2.jpg","nickname":"NSblacker","note":"","ucode":"9B134D217F9E70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346400,"discussion_content":"为什么我体会不到oc的代理和这个代理相同呢，能否帮忙类比下兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611934734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267100,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607596774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607596774","product_id":100039001,"comment_content":"打卡：用Java写了三种代理的Demo（JDK原生，cglib，javassist）","like_count":0},{"had_liked":false,"id":264681,"user_name":"海贼王","can_delete":false,"product_type":"c1","uid":1239233,"ip_address":"","ucode":"9F35793FAA3F5E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c1/e2cc1d04.jpg","comment_is_top":false,"comment_ctime":1606574982,"is_pvip":false,"replies":[{"id":"96066","content":"嗯嗯 多谢~！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700563,"ip_address":"","comment_id":264681,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606574982","product_id":100039001,"comment_content":"文章很有实用性，对于拓展思路很有帮助","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510649,"discussion_content":"嗯嗯 多谢~！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262507,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1605752929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605752929","product_id":100039001,"comment_content":"1. kotlin中是有动态代理，而且实现非常简单<br>2. 显然组合优于继承，基于接口可以方便其它类对代理功能进行扩展，缺点在于接口中的方法都必须实现。","like_count":0},{"had_liked":false,"id":262328,"user_name":"成长型思维","can_delete":false,"product_type":"c1","uid":2282974,"ip_address":"","ucode":"2FCE2C05FFCC83","user_header":"https://static001.geekbang.org/account/avatar/00/22/d5/de/f9a465ab.jpg","comment_is_top":false,"comment_ctime":1605693197,"is_pvip":false,"replies":[{"id":"96123","content":"不是，两个不同的模式","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700949,"ip_address":"","comment_id":262328,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605693197","product_id":100039001,"comment_content":"代理模式也叫中介模式吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509785,"discussion_content":"不是，两个不同的模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247201,"user_name":"陈年之后是青葱","can_delete":false,"product_type":"c1","uid":1677464,"ip_address":"","ucode":"93099465D64545","user_header":"https://static001.geekbang.org/account/avatar/00/19/98/98/0aa03974.jpg","comment_is_top":false,"comment_ctime":1599632896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599632896","product_id":100039001,"comment_content":"动态代理相比静态代理是把被代理方法抽象了，感觉有点与命令模式结合的味道。","like_count":0},{"had_liked":false,"id":232613,"user_name":"xmeng","can_delete":false,"product_type":"c1","uid":1731543,"ip_address":"","ucode":"C0CA2182BA3B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","comment_is_top":false,"comment_ctime":1594050322,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594050322","product_id":100039001,"comment_content":"- 什么是代理模式：它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。<br><br>- 代理模式得实现：<br>  - 静态代理<br>    1. 实现被代理对象口： 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。<br>    2. 继承被代理对象：代理类继承原始类，然后扩展附加功能。<br>  - 动态代理 ： 在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。 <br>    1. jdk动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。<br>    2. cglib动态代理是利用asm开源包，对被代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。","like_count":0},{"had_liked":false,"id":232611,"user_name":"xmeng","can_delete":false,"product_type":"c1","uid":1731543,"ip_address":"","ucode":"C0CA2182BA3B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","comment_is_top":false,"comment_ctime":1594050130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594050130","product_id":100039001,"comment_content":"https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;technotes&#47;guides&#47;reflection&#47;proxy.html<br>https:&#47;&#47;www.baeldung.com&#47;java-dynamic-proxies","like_count":0},{"had_liked":false,"id":231798,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1593772370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593772370","product_id":100039001,"comment_content":"iOS的同学们，突然又想到，类似UITableView这种在自己内部调用delegate的设计，和标准的代理模式代码实现方法的差别其实是：因为是框架，所以在代理模式的基础上使用了依赖反转，所以由框架来调用代理类了","like_count":0,"discussions":[{"author":{"id":1064449,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3e/01/9bb11f13.jpg","nickname":"whyoyyx","note":"","ucode":"B111DDAF23AFE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294691,"discussion_content":"引用文中的一段话，从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。\n\n\n如果这里你把has a理解成拥有什么能力或者具备什么行为这类的含义可能更符合些。例如：AliyunImageStorage具备数据存储的能力。如果用behave like不知道咋描述，是行为像存储？\n\n所以我觉得用has a可能更贴切一点。只是这里的has a容易让人类比组合里面的那个has a。但是细想想这两者想表达的意思是一样的。","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1595957052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2465343,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKW6K5tAWnia6qO25hWEhHTpAhO6H6FHS2Bkg99DhZCaLm8opibQ8ZZNBzduCX5zl4F1PUnJcmEctEw/132","nickname":"Geek_383d72","note":"","ucode":"4AE2CFEB56237A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365038,"discussion_content":"抽象类在被继承时体现的是 is-a 关系，接口在被实现时体现的是 can-do 关系\n例如，Plane can fly. Bird can fly，应该把 fly 定义成一个接口。\n\n-- 参考 《码出自效Java 开发手册》","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1617691535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193784,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/38/5a3b72d4.jpg","nickname":"聂旋","note":"","ucode":"40061E5AFDA99C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2465343,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKW6K5tAWnia6qO25hWEhHTpAhO6H6FHS2Bkg99DhZCaLm8opibQ8ZZNBzduCX5zl4F1PUnJcmEctEw/132","nickname":"Geek_383d72","note":"","ucode":"4AE2CFEB56237A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569819,"discussion_content":"从接口角度来说，接口实现类体现的是，must can do and don&#39;t care how to do","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651564304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365038,"ip_address":""},"score":569819,"extra":""}]},{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374733,"discussion_content":"has-a的意思就是拥有什么功能，跟你这个behaves like其实也差不多，表达都是一个意思，懂得是哪个意思就行","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1621330811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303954,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/1mOvT5fApeicXppMP3zADG6XIPicNt5D9dL6y46SF5UUcH0hicG21LM6xSgHJj5oAdzCyeGtLZYHYmlvaFwecrGOA/132","nickname":"考拉出山","note":"","ucode":"917E35FD7B2D06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274136,"discussion_content":"个人觉得这个很难概括全面，一定要描述的话。我的理解是抽象本身就是可以分类的。有的是对身份抽象，有的是对行为抽象。比如我们设计duck的时候，可以将鸭子叫这种能力变为接口，所有鸭子都具有speak叫的能力。这个时候代表所有鸭子has这种能力。但是如果我们把duck定义为抽象，里面声明一个speak方法。那么duck代表一类身份。同理同时继承蝙蝠和人。在代码层面他们的身份就是蝙蝠或者人，只不过从语义上理解应该是具有人和蝙蝠的能力。只能说这样的设计不合理？？ 强行去解释一个不好的设计本身就失去意义(语言不能约束一个人不能去继承一个duck的接口)。但这真的是不良设计？  能用就好，而且很多抽象都是空的，不带任何抽象方法，仅代表身份。约定大于规则\n","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1590545183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393465,"discussion_content":"我觉得不必死抠这些说法，自己理解就行。比如java有很多接口，closeable,cloneable,serializable。一个类如果实现了这些接口，这时候我觉得has-a。表示它拥有这些方法，实现了这些协议，更合适吧。behaves like,看起来像。感觉不太合适。。。。。\n具体来说我觉得上节课老师总结的比较好。对java来说，抽象类主要是解决代码复用的问题，是一种自下而上的设计方法。接口是自上而下的设计方法，主要是为了解决解耦抽象的问题","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1631442790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60371,"discussion_content":"java只支持单继承，多接口。is a 和 has a 是抽象层面的表达。具化的话就是 has some behaviors。 吸血鬼既不是人，也不是蝙蝠。他是新物种，只是具备人和蝙蝠的某些行为。关系当然是has a。 你的抽象能力还不到火候，现在流行的 DDD开发就是根据具象化表达来实现代码。它只是对业务层面（领域，界限）解耦合。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574729489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60410,"discussion_content":"算了，不多说了。我发这个也不是为了说明咱们谁到没到火候的。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574730863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60371,"ip_address":""},"score":60410,"extra":""},{"author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61522,"discussion_content":"只是具备人和蝙蝠的行为 我不人为是 has a 应该是 can do\n\n吸血鬼has a超能力\n吸血鬼can吸血\n吸血鬼can睡觉\n吸血鬼has a生前的容貌\n吸血鬼can说人话\n\n看下来 具备人和蝙蝠的某种行为 跟has a并没有关系 当然&#34;不是&#34;has a","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574780395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60371,"ip_address":""},"score":61522,"extra":""},{"author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61552,"discussion_content":"个人感觉 业务是千变万化的 书本上只提了&#34;has a&#34; &#34;is a&#34;并不代表所有的业务都往上套。这样思维会被束缚。经典的比喻:用惯了锤子，眼里一切都是钉子。曾经的我 不同阶段 对这段话的理解完全不同。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574780779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60371,"ip_address":""},"score":61552,"extra":""}]},{"author":{"id":1371888,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ee/f0/f2577e45.jpg","nickname":"额。","note":"","ucode":"99B1942BAEC011","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370960,"discussion_content":"兄弟，我来晚了，是《敏捷软件开发》里面说的10.3.3 is-a是关于行为的。举了一个很好的例子就是，正方形到底要不要继承自矩形。\n书上还提到了一句话：术语Is-a的含义过于宽泛以至于不能作为子类型的定义。子类型的正确定义是&#34;可替换性的&#34;，这里的可替换性可以通过显示或者隐式的契约来定义","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1619594074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82906,"discussion_content":"其实这些说法都是对的，吸血鬼继承自蝙蝠或者实现了蝙蝠接口，从蝙蝠的角度来说，吸血鬼就是蝙蝠，别忘了蝙蝠有眼睛没视力啊，他们对同类的识别可不就是通过某种特性嘛，呵呵。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576398838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1109632,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/80/db52af6b.jpg","nickname":"Justin","note":"","ucode":"E6C4119C752465","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292369,"discussion_content":"对抽象的理解，要看角度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595207301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":82906,"ip_address":""},"score":292369,"extra":""}]},{"author":{"id":2278659,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TUMtkaIMdbFDS28AhjrQcqOhiapNvHyPMApz9QoZZkShZmomJRh6GX2aL2YeSMg4SicdydzdWxXZOZz49HNS9EtA/132","nickname":"Windqiu","note":"","ucode":"EF78D3CF73BCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360937,"discussion_content":"其实我一直对接口和抽象有迷迷糊糊的概念认知。\n不过通过各种课程，以及代码的观察。\n抽象类，之所以需要抽象，是从类出发的，如果此行为是属于类中必须有的，且具有共性的行为，那么成为抽象类的抽象方法，可以替代成复用。\n如果此行为只是类中的延展行为，可有可没有，非必须，但是针对此行为是有共性的，可以抽象成为接口，用接口的方式去实现。当然如果针对此类是延展行为，但是又非共性，则直接在抽象类实现行为，或者抽象成为抽象方法，让子类实现。\n这是从这一楼的答主上参悟的，具体是否如此，还需要在项目实战中进行深入理解。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1616561407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252396,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/2c/bb123f90.jpg","nickname":"Neexz","note":"","ucode":"BF68EFB92949B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194946,"discussion_content":"Has the ability of an interface","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1583246365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82904,"discussion_content":"接口就是用来描述具有哪些行为。还是很容易理解的。经典翻译就是 &#34;鸭式辨型&#34;，像鸭子一样会嘎嘎叫的，虽然可能是个人，但是从类型的角度理解完全是可以认为人就是鸭子，因为鸭子眼里会嘎嘎叫的都是同类嘛。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576398658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77287,"discussion_content":"behaves like的确从概念上更加贴合表达拥有某种能力～ 但是如果把has a的宾语换成接口中某一个方法是不是就可以说得通，我个人觉得具体的能力还看接口中最小粒度的方法，这是具体的能力和行为，接口只是对这组能力的抽象和封装～ 以上纯属我看了评论后的感受，仅仅提供另一种角度～\n\n另外请问zeta兄弟behaves like这个观点是从什么书看到？\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575899254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77419,"discussion_content":"具体什么书忘记了，大概十年前看的书了，也不是什么有名的书。\n我明白你的意思，但是方法命名都应该是动词，所以在has a 的语境里，无论是动词或动名词做宾语都不太合适。你感受下，has a fly? has a flying? 最终还是会回到has some specific behaviors, 也就是 behaves like.\n之所以斟酌这些文字是因为符合语义的通顺可以帮助更好的设计","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575902811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77287,"ip_address":""},"score":77419,"extra":""},{"author":{"id":1001702,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/e6/36e0a735.jpg","nickname":"pino","note":"","ucode":"B2434724A51E7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97280,"discussion_content":"冒号课堂这本书里有这种说法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577109664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77287,"ip_address":""},"score":97280,"extra":""}]},{"author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61712,"discussion_content":"课程讲到这里 我个人感觉 大家没有注意到一个隐藏在背后的小鬼 那就是&#34;数据&#34;\n\n程序中很多时候继承是为了获得父类中的数据\n比如 我在项目中思考的\n管理员和普通用户会继承一个用户类，其中包括用户的通用数据比如用户名和头像。管理员会有一些额外的数据比如可管理的模块列表，普通用户会有访问历史等。\n业务中当然会有一些相关的操作对应到方法上，但我的项目中更关心这些数据，有时甚至需要只有数据没有方法。这种情况用接口简直是驴唇不对马嘴。我需要的是多重继承在子类用访问多个父类继承过来的数据。这也是getter和setter泛滥成灾的一个隐性原因。因为我没办法集成到我需要的数据，所以我不得不变相的使用setter getter把数据强行解释为行为！\n\n另外 我一直记在心里的\n面向对象的封装 有一层含义 是将数据和这些数据之上的操作封装封装到一起","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574782682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":61996,"discussion_content":"写的这么多挺不容易的，回你一下。你从项目实用角度比较关注数据，但其实关于面相对象中数据层面的抽象基本上是有结论了，那就是可以用组合解决，参考下一章。面相对象理念一路发展下来，我了解的广泛使用的语言里，从最初c++支持多重继承，到java和c#只支持单继承，到现在rust和go连继承都没有了，其中rust在官方教程里明确说明rust采用组合代替继承。所以说至少语言设计者对继承这件事的态度还是比较明显的。\n然后关于你说的“不得不变相的使用setter getter把数据强行解释为行为”，set和get数据本来就是行为呀，当然这个各人理解不同，我就不多说了。而且java方面主流编译器也支持生成getter和setter代码，所以开发上的困扰也不会太多。\n最后我想说的是还是要尽量理解语言设计者的初衷和推荐的最佳实践，不然实际应用中可能导致一些不必要的困扰。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1574812141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61712,"ip_address":""},"score":61996,"extra":""}]},{"author":{"id":1999235,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/81/83/f93b1e62.jpg","nickname":"peaceForce","note":"","ucode":"98A318930DDC9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374933,"discussion_content":"我喜欢这种说法","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621415427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1695455,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","nickname":"时光流逝x","note":"","ucode":"D7334E717D9ED0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369296,"discussion_content":"我的理解是接口只是一个协议,来描述我能提供一种什么样的服务,所以接口只关注的是能不能,抽象类则是我除了能做原来的事情还能对外提供一些额外的服务,所以接口可以根据类的功能选择去实现而抽象类则是去拓展这么理解是否对呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618998387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291488,"discussion_content":"组合是has-a应该没有争议吧o(〃&#39;▽&#39;〃)o","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594835926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292704,"discussion_content":"这个听起来很有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595311597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291488,"ip_address":""},"score":292704,"extra":""}]},{"author":{"id":1127383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/d7/4c443d3e.jpg","nickname":"不可描述","note":"","ucode":"3BEF775A9C6797","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335452,"discussion_content":"菱形继承问题 本来就是个有问题得设计","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608197196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740322,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/22/51f690e1.jpg","nickname":"big熊","note":"","ucode":"8D382BF137EF00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326887,"discussion_content":"is a在java单继承里理解的话没有问题，不用死扣细节多继承时is a对不对，自己理解就行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605694100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389314,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/02/83f47bf9.jpg","nickname":"流沙","note":"","ucode":"6153686D1C34B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324696,"discussion_content":"本来明白了，看了你们的解答，我又迷惑了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605154785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1465986,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","nickname":"longslee","note":"","ucode":"C24E32E5B1B6F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265625,"discussion_content":"英语不错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589421797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136181,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/35/eeee9309.jpg","nickname":"sun","note":"","ucode":"948FD34662AFB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62449,"discussion_content":"大佬，说的太有道理了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574843893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1173517,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","nickname":"Lifelong Learning","note":"","ucode":"3E39BED3E13FB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56313,"discussion_content":"人们总说c++多继承很困扰,带来了许多麻烦,但是如果正确使用的化或者正确理解设计者的初衷的话可能会减少这种麻烦,首先c++的多继承多用于类似java中接口的实现,而java中的继承和抽象完全可以用c++的“单继承”,这样使用C++多继承上也就没有那么多麻烦存在了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574472767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589566,"discussion_content":"我也赞成评论区大部分老哥的理解，其实has-a和behaves like等其他描述都是差不多的，理解上本质意思都差不多，主要表现为实现接口的类就得提供对应的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665130065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1924882,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aXnFBB3XD3lwB3jf1A0PQqT66aJy4yycbRupJI3ia2CUFMuLsvYthM41TDopIIjL8kz7k2xE5vrAtQggQ6Jt8Zw/132","nickname":"付磊","note":"","ucode":"719BD0B72FF2AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580570,"discussion_content":"文章中的理解更加容易让新手理解。懂那个意思就好了。简单才是真理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658275329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172520,"avatar":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","nickname":"R","note":"","ucode":"3721FC8C8DE174","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577528,"discussion_content":"我认为接口是一组行为的抽象。比如王者荣耀所有英雄都有闪现、加血、回城，这一组行为就可以定义为接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656165676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2849207,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p7WrTfywicxkRZTdlSEvzTsrWssRF0YnmGY2ffFYGKjIoNC8fnbMiaI9Kic0gOD3icLiapY5vmYh89yLUH7qgZZicn3g/132","nickname":"Geek_8b8904","note":"","ucode":"3A7967582FFE8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561933,"discussion_content":"我用的java，感觉用到接口的时候是用接口的方法，关注点在让类做什么，而如果用的是父类子类一般还会要他的属性，比如获取一个继承student的类一般会关注他的名字，但是获取一个实现CanSing的类其实只是想让他sing（），并不关心他是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649749821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2838429,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4f/9d/f9157b76.jpg","nickname":"🌝李洞宾","note":"","ucode":"B06F74C2FCD742","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414259,"discussion_content":"好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636703818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2757751,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/14/77/ebbbca83.jpg","nickname":"Hl","note":"","ucode":"2717A5845ED6BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393059,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631237952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030657,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg","nickname":"Leoorz","note":"","ucode":"8912628AD6ADE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391923,"discussion_content":"Behaves like，这个说法词意感觉更贴切，感谢增加理解角度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630714890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361947,"discussion_content":"那么我想问这里AliyunStorage is a ImageStore的话，是不是也可以用抽象类实现？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616810010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382743,"discussion_content":"完全可以，可以通过ImageStore提供模板方法设计，规定上传下载流程。 比如上传的时候检查目录是否存在，然后上传完毕后关闭流资源等。下载也可以按照类似设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625710743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361947,"ip_address":""},"score":382743,"extra":""}]},{"author":{"id":1809713,"avatar":"","nickname":"sleepingcat","note":"","ucode":"AF7E7ED85E557F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350783,"discussion_content":"c++的多继承在java里的表现就是接口实现，那吸血鬼has 人和has 蝙蝠这个描述没异议吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614004509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100117,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/55/3b2526ce.jpg","nickname":"深山何处钟","note":"","ucode":"5D42024E40D751","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326083,"discussion_content":"第二点说的，个人感觉是里氏替换原则的具体应用。真正严格的面向对象开发，应该是遵守里氏替换原则的。而这条原则和老哥你说的“相似的行为”概念有一定的重合。但里氏替换原则的应用其实更广，这里我觉得作者后面一定会专门讲一下这个原则的。莫慌，这才刚刚第9讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605517266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321662,"discussion_content":"看起来将接口定位为has-a确实不太合适，但是第二段多重继承的问题不一定是接口，男人可以多重继承人和雄性两个类，男人is-a人，同时，男人is-a雄性。个人认为，如果多重继承发现并不是is-a的关系，那我怀疑是多重继承出了问题，似乎不应该使用多重继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604620321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":342076,"discussion_content":"把雄性定义成类本来就是一个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610590675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321662,"ip_address":""},"score":342076,"extra":""},{"author":{"id":1250556,"avatar":"https://static001.geekbang.org/account/avatar/00/13/14/fc/3afb6a1f.jpg","nickname":"普朗克","note":"","ucode":"C7EB774F6B1E0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":359573,"discussion_content":"雄性应该是作为一个人的属性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616231683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321662,"ip_address":""},"score":359573,"extra":""}]},{"author":{"id":2098988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/07/2c/106f95e2.jpg","nickname":"NSblacker","note":"","ucode":"9B134D217F9E70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305332,"discussion_content":"我看到上一篇的时候，对has-a也稍微停下来想了一下。基本符合大家留言的意思，表示拥有接口中提供的能力，比如我设计Warrior类，他继承自Person抽象类，且实现一个Peoperty接口来计算攻击力，防御力，血量，表示Warrior拥有此套属性值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599880609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1734656,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/00/675a5795.jpg","nickname":"小龙成Hu","note":"","ucode":"6AFCED06795C91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206710,"discussion_content":"其实继承除了 is-a  还有 like-a的 只是作者没有提及","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584431954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102062,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","nickname":"LYy","note":"","ucode":"8D5C39B9531E71","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114265,"discussion_content":"duck type","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577966445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004716,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/ac/8b94b8b2.jpg","nickname":"mr.su","note":"","ucode":"8A4B9910960118","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76758,"discussion_content":"支持zeta大哥的说法，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575852638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228759,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/d7/9e2c8648.jpg","nickname":"呆猫","note":"","ucode":"69E256E6A19225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66684,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575098142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335155,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","nickname":"拒绝","note":"","ucode":"CB0264C4D3FE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61022,"discussion_content":"优秀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574769821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125806,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","nickname":"瓶子霸哥","note":"","ucode":"A7EEB459AB5550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59415,"discussion_content":"我觉得 behaves like 这个思路应该是对的, 也更接近我对接口的理解. 看很多接口定义都是 behaves 的定义. Clickable, Readable, Writeable 都是 behaves like 的语义. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574688377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57865,"discussion_content":"我觉得这种留言老师应该给出正面回复。毕竟，这篇和上篇都差那么一点意思。尤其是这篇的讨论题，这个题目本身就没有什么标准答案，而是分具体场景来说的。所以我觉得这个题目问在什么需求场景下来做什么样的设计比较好。毕竟如果工程中只有这么一个类，那么无论怎么做都是可以的。如果当项目中有除了阿里云和私有云之外其他的存储方式，可能就是工厂模式？并且如果允许在运行时改变行为方式或许加上策略模式更合适一点。而这些都还没有讲到，现在抛出这些问题有点超纲😥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574645098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58216,"discussion_content":"面向对象设计就像写文章，如你所说，本来也没啥正确答案，而且往往话语权大的人的思想更容易广泛围传播。我毕竟也没什么大厂背景，实力也不足以开个课讲这些，我写的这个评论能被放出来我已经很知足了，大家觉得有道理的话，自行取用就好。上课吸收知识是一方面，带着自己的思考持续寻找答案也很重要。谢谢各位支持。","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1574659095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57865,"ip_address":""},"score":58216,"extra":""}]},{"author":{"id":1248510,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","nickname":"Sheamus","note":"","ucode":"F6EBDFF3575ADA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57763,"discussion_content":"has a 不是具备的意思吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574642586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","nickname":"蚂蚁内推+v","note":"","ucode":"24B10AEE54B3FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56047,"discussion_content":"讲的真是很好，我一直就觉得抽象类对应is-a，接口对应has-a这种描述很有迷惑性，很多时候is-a 也可以用has-a去实现，并无不妥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574427527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","nickname":"蚂蚁内推+v","note":"","ucode":"24B10AEE54B3FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86240,"discussion_content":"现在继承的缺点相对较多，组合比继承更灵活，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576592462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56047,"ip_address":""},"score":86240,"extra":""}]}]},{"had_liked":false,"id":231763,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1593766546,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593766546","product_id":100039001,"comment_content":"iOS同学一起来讨论一下是不是这样哈：有些系统类直接用delegate作为属性值，比如UITableView（包括delegate、dataSource），看起来和代理模式的代码实现不一样，但是作用是一样的，就是给原始类增加和原始类无关的功能，这应该也算是代理模式了；另外，从行为角度或者说算法角度来看，iOS中的这种实现属于模板模式，即在原始类的扩展点上扩展功能","like_count":0,"discussions":[{"author":{"id":1026960,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/90/52d85edf.jpg","nickname":"Alvin","note":"","ucode":"BAC5FDAF1E3E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312016,"discussion_content":"感觉依赖注入是最完美的O(∩_∩)O","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1602562409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/99/dbdee494.jpg","nickname":"REAL_MADIRD","note":"","ucode":"9E327B5456739D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332588,"discussion_content":"这个建议不错，提完问题也要回答呀，这样才是一个闭环，对吧","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1607265648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58202,"discussion_content":"同意你的看法，有时候确实需要听到发问者自己对这个问题的思考","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574658077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1257347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/83/516e62ac.jpg","nickname":"木同","note":"","ucode":"81A7C9E8D27A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74157,"discussion_content":"有道理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575634993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":58202,"ip_address":""},"score":74157,"extra":""}]},{"author":{"id":1038798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/ce/4528cb4b.jpg","nickname":"呼呼","note":"","ucode":"5D7B57C05B5D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84776,"discussion_content":"不能再同意了，很想看到作者对于问题的思考","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1576506086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295939,"discussion_content":"策略模式","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596385364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414537,"discussion_content":"MySQL45讲 YYDS","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636807749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1940536,"avatar":"","nickname":"haiyuan.wu","note":"","ucode":"22BD519B05F49D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337385,"discussion_content":"这也是很有必要。赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608887346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337016,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","nickname":"王智","note":"","ucode":"37D2AD591C1AEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535366,"discussion_content":"我也是。看了十来节，就想知道那些课后作业的答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638420086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374735,"discussion_content":"一般不都是配置文件改对象的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621330874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302406,"discussion_content":"用简单工厂就是正确答案呀，把对象创建抽象为接口，这样就可以在imageJob中使用接口而不是特定的PrivateImageLoader编程了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598919909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230896,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1593517058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593517058","product_id":100039001,"comment_content":" 面向接口的所有子类都必须代理，会出现将不需要代理的类也必须去代理的情况。接口可以实现多个、灵活、可以代理多个同一个类型的对象。<br>继承模式的优点是只需要代理需要的某几个方法，缺点是必须针对特定的父类代理。","like_count":0},{"had_liked":false,"id":227741,"user_name":"无双BaOY_WHA","can_delete":false,"product_type":"c1","uid":1370125,"ip_address":"","ucode":"41F282C31D256C","user_header":"https://static001.geekbang.org/account/avatar/00/14/e8/0d/6d303d18.jpg","comment_is_top":false,"comment_ctime":1592468069,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1592468069","product_id":100039001,"comment_content":"C++没有反射机制，因此实现动态代理比较复杂（我感觉必须先自己实现一套反射机制才行）。<br><br>不过，C++代码中可以嵌入其他脚本语言（如 lua ），动态加载、运行脚本……","like_count":0,"discussions":[{"author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213292,"discussion_content":"我觉得这并不完全正确，取决于方法的复杂性，如果每个城市袭击的方式都大不一样，我觉得还是分开写比较好。有时候并不需要大而全方法，更多需要职责单一的方法","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1585062768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291489,"discussion_content":"可以这样，定义一些基础类attackByMissile，attackByPlane,attackByTank。 \n进攻巴格达时候再将需要的类继承或者组合一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594836664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213292,"ip_address":""},"score":291489,"extra":""},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342077,"discussion_content":"可以定义为虚方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610590797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213292,"ip_address":""},"score":342077,"extra":""},{"author":{"id":1133206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/96/8756eaa2.jpg","nickname":"王也","note":"","ucode":"9EA69B51ECC99F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371445,"discussion_content":"片面了, 抽象方法存在的意义之一 , 就是为了剞劂这种袭击方式不一样的场景.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619770623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213292,"ip_address":""},"score":371445,"extra":""}]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393100,"discussion_content":"高度抽象的情况下，甚至可以直接定义 attack方法，不需要参数。有 CitcyAttacker 这种类去实现 Attacker 接口","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631250245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2829583,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/2d/0f/52e5dcff.jpg","nickname":"右手特别大","note":"","ucode":"9B9A4600B97D81","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576924,"discussion_content":"名字在函数名中不一定就不合理，取决于在它是否在多个地方调用，并且需求上它们代表的同一个事情或场景。如果是， 城市名不作为参数实际上更合适，更加准确详细地表达了它们是同一件事这个信息。1.语法上确保他们的行为是一模一样，不会出现参数拼写错误。2.方便语法搜索阅读代码， 更清晰地查看到底哪些地方也做了这个事情。如果作为参数，也其他城市的也会出现在搜索结果中。3.假如未来这个事情内部逻辑发生变化，或者实现改变了，例如名字换成中文， 城市不再用字符串而是用类来表示等，所有调用它的地方都不受影响。这才是真正的面向接口编程， 面向当前需求概念中的接口，而不我们觉得未来可能会出现的接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655858924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227606,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1592442084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592442084","product_id":100039001,"comment_content":"代理模式和装饰器模式有点像，我觉得最大区别是：代理模式只拦截一次原始逻辑，装饰器模式可以多次嵌套拦截原始逻辑。<br>看到动态代理的代码，突然意识到，作为一个Java程序员居然看不懂这段代码，要赶快补习了。<br>几个月之后再来看这篇文章，以前看过居然全忘了……","like_count":0},{"had_liked":false,"id":225726,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1591841407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591841407","product_id":100039001,"comment_content":"代理模式的应用场景：<br>        1.业务系统的非功能性需求开发，如：监控，统计，鉴权，限流，事物等，这些功能需要在不破坏原有功能的基础上，添加新的功能。<br>        2.在RPC，缓存中应用。<br><br>     实现方法：<br>        1.通过接口实现，业务类和代理类实现同一个接口，在代理类的实现中，调用业务类的代码。<br>        2.通过继承的方式实现，没有办法实现定义接口的时候，通过继承的方式来实现代理<br>        3.当需要代理的类过多的时候，采用动态代理的方式来减少系统的代码量。<br><br><br>     动态代理参考链接：https:&#47;&#47;www.liaoxuefeng.com&#47;wiki&#47;1252599548343744&#47;1264804593397984","like_count":0},{"had_liked":false,"id":221563,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1590540775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590540775","product_id":100039001,"comment_content":"AOP简直是代理模式的最佳实践。<br>","like_count":0},{"had_liked":false,"id":214989,"user_name":"nil","can_delete":false,"product_type":"c1","uid":1507193,"ip_address":"","ucode":"0F5D298C1CBB74","user_header":"https://static001.geekbang.org/account/avatar/00/16/ff/79/3b38c9e1.jpg","comment_is_top":false,"comment_ctime":1588863818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588863818","product_id":100039001,"comment_content":"看完了，代理和装饰者傻傻的分不清，看目录后面有讲解区别和联系，加油学习","like_count":0},{"had_liked":false,"id":214494,"user_name":"俊哥","can_delete":false,"product_type":"c1","uid":1678451,"ip_address":"","ucode":"C5548F817D97B0","user_header":"https://static001.geekbang.org/account/avatar/00/19/9c/73/4d23e4f2.jpg","comment_is_top":false,"comment_ctime":1588758124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588758124","product_id":100039001,"comment_content":"想到了代理模式的另一个应用场景，对被代理类的接口进行访问权限控制，比如只有特定对象才有权限调用被代理类的接口，非法对象调用接口返回失败。","like_count":0},{"had_liked":false,"id":212458,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588127420,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588127420","product_id":100039001,"comment_content":"代理现在应用的确实比较广泛，比如说用byte-buddy或者cglib(基本上不更新、byte-buddy可以推一下了)。<br>常见的有rpc client端、aop切面、注解元驱动、mybatis mapper之类的。<br>争哥下面这段话已经非常精准了～<br>&quot;代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发&quot;","like_count":0},{"had_liked":false,"id":211173,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1587909451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587909451","product_id":100039001,"comment_content":"继承模式局限于Java的单继承，但可以选择实现代理。组合模式必须全部代理，可以灵活选择代理的子接口","like_count":0},{"had_liked":false,"id":209472,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1587555181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587555181","product_id":100039001,"comment_content":"我们今天讲了两种代理模式的实现方法，一种是基于组合，一种基于继承，请对比一下两者的优缺点。<br>组合相对于灵活，能更好的替换组合，而继承耦合度高，如果过于复杂，不好维护","like_count":0},{"had_liked":false,"id":206774,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586932522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586932522","product_id":100039001,"comment_content":"代理模式是：不改变原始类代码的情况下，通过引入一个代理类，给原始类添加功能。<br><br>感觉这个可以跟 VPN 的原理一样。不改变原始网络，只是通过一个代理服务器，让原本不能访问的网站能访问。<br><br>JavaScript 的 ES6 有一个proxy,实现代理模式优先考虑这个","like_count":0},{"had_liked":false,"id":205201,"user_name":"布吉岛","can_delete":false,"product_type":"c1","uid":1356423,"ip_address":"","ucode":"0E4D113D62AD24","user_header":"https://static001.geekbang.org/account/avatar/00/14/b2/87/833d9bb6.jpg","comment_is_top":false,"comment_ctime":1586570076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586570076","product_id":100039001,"comment_content":"动态代理有两种，jdk的动态代理（面向接口，obj.getInterfaces()），cglib的动态代理（面向类, obj.superClass()），spring aop使用的是cglib动态代理","like_count":0},{"had_liked":false,"id":203985,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1586315376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586315376","product_id":100039001,"comment_content":"<br>基于组合的代理模式，实现起来很方便。缺点是无法对第三方类库进行代理。<br><br>基于继承的代理类，如果需要代理的方法和类太多了，就会导致重复代码过多，扩张性不够好。","like_count":0},{"had_liked":false,"id":203659,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1586249337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586249337","product_id":100039001,"comment_content":"组合模式，即使一个简单的功能类，也需要定义接口，开发起来比较麻烦<br>继承模式，无法重写final方法，因此父类中的final方法无法被代理","like_count":0},{"had_liked":false,"id":196994,"user_name":"嘻哈","can_delete":false,"product_type":"c1","uid":1402535,"ip_address":"","ucode":"AEE1512822A399","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/a7/5b7a7523.jpg","comment_is_top":false,"comment_ctime":1585328571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585328571","product_id":100039001,"comment_content":"争哥，rpc demo 中 server 用 多线程的方式作用是什么，不太懂","like_count":0},{"had_liked":false,"id":195695,"user_name":"杰洛特","can_delete":false,"product_type":"c1","uid":1098146,"ip_address":"","ucode":"46D0574654F8AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqEacia8yO1dR5Tal9B7w8PzTRrViajlAvDph96OqcuBGe29icbXOibhibGmaBcO7BfpVia0Y8ksZwsuAYQ/132","comment_is_top":false,"comment_ctime":1585212381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585212381","product_id":100039001,"comment_content":"请问老师，动态代理里面 invoke 函数的第一个参数 Object proxy 有什么用呢？函数实现过程里并没有用到这个参数。","like_count":0},{"had_liked":false,"id":193978,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585010003,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1585010003","product_id":100039001,"comment_content":"我有个疑问：为什么java的原生库只支持实现代理接口的匿名类呢？按照老师的说法：可以有接口用接口，没有接口继承父类就好。为什么非得限制一下呢？是因为担心有一些类或者方法声明为final或者static 违反继承原则吗？那cglib修改字节码就可以突破这个限制？","like_count":0,"discussions":[{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274350,"discussion_content":"生成的代理类要继承JDK反射包里的Proxy类，因为Java是单继承，如果代理类要拥有被代理一样的接口，就只能让被代理类是一个Interface","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590572170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1356423,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b2/87/833d9bb6.jpg","nickname":"布吉岛","note":"","ucode":"0E4D113D62AD24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228697,"discussion_content":"这个问题有解吗？我也想知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586570177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190358,"user_name":"徐同学呀","can_delete":false,"product_type":"c1","uid":1252813,"ip_address":"","ucode":"03383EE820514D","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","comment_is_top":false,"comment_ctime":1584632147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584632147","product_id":100039001,"comment_content":"纸上得来终觉浅，绝知此事要躬行。","like_count":0},{"had_liked":false,"id":189867,"user_name":"不学不行啊","can_delete":false,"product_type":"c1","uid":1335474,"ip_address":"","ucode":"69368165141C2D","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/b2/ccebcb71.jpg","comment_is_top":false,"comment_ctime":1584578289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584578289","product_id":100039001,"comment_content":"单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。","like_count":0,"discussions":[{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":121706,"discussion_content":"SPI方式，通过配置文件的方式，在启动的时候加载实现类","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1578322202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56355,"discussion_content":"tql=太强了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574475793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1051470,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","nickname":"allean","note":"","ucode":"A0D2DB4F219EAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56986,"discussion_content":"国舅所言极是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574556832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56355,"ip_address":""},"score":56986,"extra":""}]},{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118894,"discussion_content":"这种在spring源码中应用的太多太多。你可以在实现中定义一个是否匹配的方法根据一定的规则。详细参考springmvc handle。springmvc messageconvertor。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578198233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178885,"discussion_content":"用自己的语言能讲出本质才是对技术的透彻领悟哦","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582203055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":118894,"ip_address":""},"score":178885,"extra":""}]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58498,"discussion_content":"这不就是spring的思想嘛，不过你还是要修改配置文件，终逃不了要修改些地方","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574678611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1140666,"avatar":"https://static001.geekbang.org/account/avatar/00/11/67/ba/5a1bd8c9.jpg","nickname":"噗╰_╯噗 ","note":"","ucode":"AFB831EB42256D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80912,"discussion_content":"配置修改已经将成本降到了最低，避免了打包发布服务重启等一系列的繁琐流程。如若觉得有更优解，望分享","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576203702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":58498,"ip_address":""},"score":80912,"extra":""},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1140666,"avatar":"https://static001.geekbang.org/account/avatar/00/11/67/ba/5a1bd8c9.jpg","nickname":"噗╰_╯噗 ","note":"","ucode":"AFB831EB42256D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85486,"discussion_content":"可以这样，将processJob抽象化，然后由子类提供getImageStore()的具体实现。思路是隔离变化，封装稳定。当获得imageStore变成不稳定时，就需要隔离他。\npublic void process() { \n    Image image = ...;//处理图片，并封装为Image对象 \n    ImageStore imageStore = getImageStore();\n    imageStore.upload(image, BUCKET_NAME); \n}\n\nabstract ImageStore getImageStore();","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576549200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80912,"ip_address":""},"score":85486,"extra":""},{"author":{"id":1140666,"avatar":"https://static001.geekbang.org/account/avatar/00/11/67/ba/5a1bd8c9.jpg","nickname":"噗╰_╯噗 ","note":"","ucode":"AFB831EB42256D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102161,"discussion_content":"封装稳定隔离变化这没问题，现在的问题是，假如我的应用程序里有私有云和阿里云两个文件上传的实现，如何去切换上传文件时使用的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577327462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85486,"ip_address":""},"score":102161,"extra":""}]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342078,"discussion_content":"依赖注入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610590847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2111332,"avatar":"https://static001.geekbang.org/account/avatar/00/20/37/64/26704448.jpg","nickname":"Hello，World！：)","note":"","ucode":"89F1DB34D197B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590754,"discussion_content":"Spring：你直接报我身份证号算了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666064036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2108743,"avatar":"https://static001.geekbang.org/account/avatar/00/20/2d/47/6a5ab601.jpg","nickname":"CptW","note":"","ucode":"A3174302EBD4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301150,"discussion_content":"阿巴啊把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598425413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","nickname":"ban","note":"","ucode":"E523CE97E48266","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91724,"discussion_content":"我觉得不用配置文件，直接配置在表里面更方便","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576846343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55847,"discussion_content":"tql","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574405459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187587,"user_name":"刘伟龙","can_delete":false,"product_type":"c1","uid":1110912,"ip_address":"","ucode":"D009378493E753","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/80/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1584166322,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584166322","product_id":100039001,"comment_content":" @Override<br>        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>            long startTimestamp = System.currentTimeMillis();<br>            Object result = method.invoke(proxiedObject, args);<br>            long endTimeStamp = System.currentTimeMillis();<br>            long responseTime = endTimeStamp - startTimestamp;<br>            String apiName = proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();<br>            RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);<br>            metricsCollector.recordRequest(requestInfo);<br>            return result;<br>        }<br><br>proxy应该是proxiedObject吧，是不是写错了","like_count":0,"discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292255,"discussion_content":"能分享一下&#34;与特定时限有关的方法，不要暴露到接口中。&#34;么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595156513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189243,"discussion_content":"如果用工厂模式创建，那将来也会有很多的工厂，管理起来也不是很方便吧。\n不过，也是一种方法，把对象的创建交给工厂，将来变化直接修改工厂即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582861274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184375,"user_name":"霹雳大仙pp","can_delete":false,"product_type":"c1","uid":1046893,"ip_address":"","ucode":"F654FD9AEC1D56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","comment_is_top":false,"comment_ctime":1583302842,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1583302842","product_id":100039001,"comment_content":"优先组合；<br>面向抽象编程，代理和被代理类两者都依赖抽象；<br>组合方式更加灵活；","like_count":0},{"had_liked":false,"id":183675,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1583114452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583114452","product_id":100039001,"comment_content":"JDK 动态代理采用组合方式（可以通过 ProxyGenerator 获取代理后的对象字节码），而 CGLIB 动态代理是采用继承方式。所以 CGLIB 只能代理非 final 修辞的类。<br>之前在 Spring 5.1 版本中碰到无法获取代理类上注解的 bug，其原因就是 CGLIB 是继承方式，可以递归获取父类上的注解，而 JDK 动态代理采用组合方式就无法获取代理类的注解。在 Spring 5.2 中通过其它的手段获取 DJK 代理类的注解，已经修复了这个问题。<br>现在元编程非常流行，如何获取被代理类的元信息，也很重要。","like_count":0},{"had_liked":false,"id":183634,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1583086029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583086029","product_id":100039001,"comment_content":"老师，java的反射在JVM层面到底是个什么逻辑？为什么只给了的类的全路径，JVM在运行期间就能得到该类的class文件并生成Class对象？<br><br>我理解是在JVM运行期间开了个线程根据解析到的类的全路径名字找到这个文件，通过类加载器加载到内存中。换句话说，走的过程和new 一个对象一样，只不过new是在编译期完成，反射是在JVM运行期间根据需要去加载。两者所都还是要经过类加载过程，所消耗的时间(代价)是一样？不知道我这样理解对不对？","like_count":0},{"had_liked":false,"id":182798,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1582868311,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1582868311","product_id":100039001,"comment_content":"代理模式有两种实现方式<br>1.代理类和原始类实现相同的接口，原始类只负责原始的业务功能，而代理类通过委托的方式调用原始类来执行业务逻辑，然后可以做一些附加功能。这也是一种基于接口而实现编程的设计思想<br>2.如果原始类没有定义接口且不是我们开发维护的，这属于对外部类的扩展，可以使用继承的方式，只需要用代理类继承原始类，然后附加一些功能","like_count":0},{"had_liked":false,"id":181977,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1582686751,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582686751","product_id":100039001,"comment_content":"第一问 基本上没有遇到过代理模式<br>第二问 我感觉都差不多 前面讲的时候是加了个条件基于接口编程，如果原始类没有实现接口,那么采用继承，但是抛开这个条件来看 其实组合和继承没多大区别 唯一的一点就是继承会破坏封装性而已<br>比如  代理类实现接口类的 login 而第三方库叫login_now  我们不能修改第三方库 那么只能在代理类当中使用第三方库的login_now 其实想想也没多大区别啊 组合和继承 往有大佬能指点一下","like_count":0,"discussions":[{"author":{"id":1912022,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgA8bMuSpADl8xc5DwayHwiaOYXRYIEnSjupnO3tBvVD0ZMobM69cUnm00AtIjZg8uKgEicf4zDziaw/132","nickname":"Geek_a2d228","note":"","ucode":"DCC710651F7D5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333681,"discussion_content":"赞同,策略模式最好不过了,结合spring初始化的时候将不同的实现类封装到Map里,根据枚举code来取对应的实现类,执行就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607592848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181608,"user_name":"uranusleon","can_delete":false,"product_type":"c1","uid":1186044,"ip_address":"","ucode":"3CD5222E590A92","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/fc/a0f8a88d.jpg","comment_is_top":false,"comment_ctime":1582594497,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582594497","product_id":100039001,"comment_content":"第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。 -- 谁可以帮忙解释一下为什么替换成本较大？如果在代理类中调用计数器框架，后面如果更换计数器框架，则代理类中也需要修改，替换成本和不使用代理类也没有看出区别。","like_count":0,"discussions":[{"author":{"id":2089677,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/znc4EjKd64eg7KhiaRzicQAiaWPn6VDicwuRV52bQTBzu96FSwb26viccgFt3wBqtMF0DgXH0cHARdUVBicsLBgv1dYg/132","nickname":"Geek_ff1b3a","note":"","ucode":"1C001B254984B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351203,"discussion_content":"我觉得是不是可以用配置文件+工厂模式+单例模式+反射来实现啊，因为接口本身不含有属性，所以不会引起并发环境下的数据不一致问题，同时也不会产生不必要的对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614176738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181151,"user_name":"jianfa","can_delete":false,"product_type":"c1","uid":1505129,"ip_address":"","ucode":"8DCF9FB92BA270","user_header":"https://static001.geekbang.org/account/avatar/00/16/f7/69/bab9e607.jpg","comment_is_top":false,"comment_ctime":1582507597,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582507597","product_id":100039001,"comment_content":"组合方式更好。组合更加灵活，特别是需要用到一些其他类提供的额外功能的时候，组合可以更好的实现复用，而继承则做不到，而且java只能单继承！<br>设计原则也有云:多用组合少用继承｡◕‿◕｡","like_count":0},{"had_liked":false,"id":181104,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1582475985,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582475985","product_id":100039001,"comment_content":"1. java和.net通过反射实现动态代理，其它语言比如python可以用自省来实现，本质都是利用类的metadata进行编程。<br>2. 组合的方式创建代理类显得更轻量和灵活，继承的层次多了，有时候会不太理解逻辑，方法不停的给override。","like_count":0},{"had_liked":false,"id":180973,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582451012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582451012","product_id":100039001,"comment_content":"设计模式_48:<br><br>我怎么感觉在代理这种用法中，组合的方式完胜呢。","like_count":0},{"had_liked":false,"id":180913,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1582441749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582441749","product_id":100039001,"comment_content":"打卡<br>一、使用场景：<br>1）务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理；<br>2）在 RPC、缓存等应用场景；<br>二、实现方式：<br>1）代理类和原始类实现同样的接口，通过委托的方式调用原始类；<br>2）通过继承扩展附加功能；<br>3）动态代理方式，运行的时候动态地创建原始类对应的代理类（相对1、2中的静态代理，不需要针对每个类都创建一个代理类）；","like_count":0},{"had_liked":false,"id":180803,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1582409837,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582409837","product_id":100039001,"comment_content":"最熟悉的还只有Java，问题1看别的同学留言学习了。<br><br>问题2我的思考如下：<br>基于组合<br>1. 优点：扩展性更好，多层增强下来也比较清楚<br>2. 缺点：对于三方库无法应用<br>基于继承<br>1. 优点：应用面更广<br>2. 缺点：代码多；多层增强的话，继承体系变得越来越复杂<br><br>","like_count":0},{"had_liked":false,"id":180765,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1582382720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582382720","product_id":100039001,"comment_content":"       代理模式可以实现业务需求与非业务需求之间的解耦。这样一来使得业务列与非业务类职责更加单一，可维护性提高。代理有静态代理与动态代理。<br>       静态代理有两种实现方式：基于接口+委派 和 基于类+继承覆写目标类方法。静态代理可适用于被代理类不多，不复杂，可控的情况下。其劣势在于：需要为每一个目标类创建代理类，一旦类增多，维护成本增加。一旦要扩展接口中的功能，代理类与被代理类都需要作相应的修改（违反开闭原则）；在做代理之前，被代理类所有的东西都需要已知，人工干预太多；<br>       动态代理能弥补静态代理的问题，在代理之前，所有的东西可以是未知的。不事先为每个被代理类编写代理类，而是在运行时，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。其劣势在于：必须要有接口的支持。如果需要绕开接口这一点，则使用cglib动态代理来实现。<br>       回到代理模式的本质是实现业务与非业务之间的解耦。其可以应用在业务系统的非功能性需求开发，如日志，监控，限流，事务等。同时也应用于RPC,接口缓存等场景。","like_count":0},{"had_liked":false,"id":180729,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1582375412,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1582375412","product_id":100039001,"comment_content":"如果这篇都看不懂，就真是我们自己的问题了。","like_count":0},{"had_liked":false,"id":180655,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1582359344,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582359344","product_id":100039001,"comment_content":"我在想有木有可能需要在方法中间添加相关的逻辑。","like_count":0},{"had_liked":false,"id":180590,"user_name":"天之炼狱","can_delete":false,"product_type":"c1","uid":1503846,"ip_address":"","ucode":"F99527B4EA04D9","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/66/01a74d6f.jpg","comment_is_top":false,"comment_ctime":1582343999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582343999","product_id":100039001,"comment_content":"争哥，数据转换用什么样的设计模式比较好。比如数据库表转换到XML，或者是XML转换到数据库表，但XML的结构可能因地区要求还不一样。","like_count":0},{"had_liked":false,"id":180506,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1582299054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582299054","product_id":100039001,"comment_content":"终于等到代理模式","like_count":0},{"had_liked":false,"id":180390,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1582273563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582273563","product_id":100039001,"comment_content":"课堂讨论题<br>1. 略<br>2. 组合模式有一个缺点, 就是需要对原始类的全部方法都实现一遍. 继承则没有这个问题了. 不过继承确实无法对一些声明为final的方法进行代理了. <br><br>对了我有一个疑问, 就是代理模式只能代理接口方法吗? 像有对象属性这些, 貌似只能写一个getter方法来代理啊? 如果是这样的话, 那组合模式遇到那种有属性的类, 岂不是要写一大堆getter方法了? 而且其他设计模式好像都是关注接口里面的方法, 并不会关注对象的属. 大家能否指点一下, 谢谢. (这个问题源于我在写自己的类库的时候, 因为对象的类型声明为接口, 所以使用对象的时候无法访问它的属性, 给编码造成了一些麻烦)<br><br>最后顺便提一下, iOS中的代理模式跟这篇文章讲的思想有很大区别, iOS的代理类主要是用来做数据源, 用户自己实现代理类中规定的接口, 然后提供给使用类的对象用来获取数据.","like_count":0},{"had_liked":false,"id":180309,"user_name":"SXPeople","can_delete":false,"product_type":"c1","uid":1313127,"ip_address":"","ucode":"C6D9E2AE5278A9","user_header":"https://static001.geekbang.org/account/avatar/00/14/09/67/b46d3045.jpg","comment_is_top":false,"comment_ctime":1582254969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582254969","product_id":100039001,"comment_content":"组合代理比继承代理模式，在纵向横向的扩展都要灵活<br>继续跟着大牛🐮的脚步向前进","like_count":0},{"had_liked":false,"id":180293,"user_name":"Vicent🍀","can_delete":false,"product_type":"c1","uid":1589894,"ip_address":"","ucode":"70AEA72A0B6F0E","user_header":"https://static001.geekbang.org/account/avatar/00/18/42/86/6b2e81ba.jpg","comment_is_top":false,"comment_ctime":1582251927,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582251927","product_id":100039001,"comment_content":"一：Objective-C中Delegate委托我一般叫做代理，oc中可以声明代理方法和代理对象，如果原有类想要增强，就要声明代理协议和持有代理对象，调用的时候去调用代理对象的代理方法，但我觉的这种编程方式应该不属于动态代理的范畴。因为即使是通过协议约定了方法（类似接口）但实现代码块是维护在一个单独类中，并且需要手动的实例化并传递给实用类。<br>二：<br>组合模式：<br>优点：觉得这种更灵活，可以根据接口定义不同的代理方法进行区分，职责分明，封装性好<br>缺点：代码量会增加；调用链会稍微增长；<br>继承模式：<br>优点是可以增强一些无法侵入修改的代码；<br>缺点是感觉耦合度会提高，如果要修改代理方法，必须要修改继承类，不如使用接口切换方便。有些类 final了，神仙难救啊。","like_count":0,"discussions":[{"author":{"id":2278659,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TUMtkaIMdbFDS28AhjrQcqOhiapNvHyPMApz9QoZZkShZmomJRh6GX2aL2YeSMg4SicdydzdWxXZOZz49HNS9EtA/132","nickname":"Windqiu","note":"","ucode":"EF78D3CF73BCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360938,"discussion_content":"应该还有更优方案，如果实现多态特性是解决方案的一种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616561859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297843,"discussion_content":"感觉这样的话，就失去接口的意义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597070813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55601,"discussion_content":"不对，我们理解错了，确实有最后一个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56568,"discussion_content":"哪个最后一个问题?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574498202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55601,"ip_address":""},"score":56568,"extra":""}]},{"author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55551,"discussion_content":"说的对，感觉奇怪，目前好像我们实现了接口，但是使用的时候没有使用接口，导致最后的那个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574383886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55592,"discussion_content":"嗯，目前实现接口其实就是像争哥说的，一个不注意就没真正意义的抽象. 面向实现编程了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55551,"ip_address":""},"score":55592,"extra":""}]}]},{"had_liked":false,"id":180284,"user_name":"progyoung","can_delete":false,"product_type":"c1","uid":1014692,"ip_address":"","ucode":"0B4898AE78F9F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","comment_is_top":false,"comment_ctime":1582248570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582248570","product_id":100039001,"comment_content":"以前准备面试的时候，总也搞不懂aop背后的原理，今天算是整明白了，谢谢小争哥。","like_count":0},{"had_liked":false,"id":180280,"user_name":"岁月神偷","can_delete":false,"product_type":"c1","uid":1484111,"ip_address":"","ucode":"BA851259EA1F71","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/4f/592d00f2.jpg","comment_is_top":false,"comment_ctime":1582248033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582248033","product_id":100039001,"comment_content":"看完争哥对代理模式的讲解，不仅明白了其原理和实现，更理解到了它的使用场景。感觉学习模式最精华的部分不在原理和实现，而在使用场景，争哥在这方面的内容做得很好，点赞。","like_count":0},{"had_liked":false,"id":180270,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1582246072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582246072","product_id":100039001,"comment_content":"只会java。基于接口和继承都是使用了多态的特性，在运行时用代理类替换。没有优劣之分，应用场景不同。就像争哥提到的，有些没有实现任何接口，而且不是我们开发的类。这时候就用基于继承的动态代理。","like_count":0}]}