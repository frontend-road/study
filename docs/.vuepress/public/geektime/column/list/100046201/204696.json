{"id":204696,"title":"04 | 网络通信：RPC框架在网络通信上更倾向于哪种网络IO模型？","content":"<p>你好，我是何小锋。在上一讲我讲解了RPC框架中的序列化，通过上一讲，我们知道由于网络传输的数据都是二进制数据，所以我们要传递对象，就必须将对象进行序列化，而RPC框架在序列化的选择上，我们更关注序列化协议的安全性、通用性、兼容性，其次才关注序列化协议的性能、效率、空间开销。承接上一讲，这一讲，我要专门讲解下RPC框架中的网络通信，这也是我们在开篇词中就强调过的重要内容。</p><p>那么网络通信在RPC调用中起到什么作用呢？</p><p>我在<a href=\"https://time.geekbang.org/column/article/199650\">[第 01 讲]</a> 中讲过，RPC是解决进程间通信的一种方式。一次RPC调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。服务调用者通过网络IO发送一条请求消息，服务提供者接收并解析，处理完相关的业务逻辑之后，再发送一条响应消息给服务调用者，服务调用者接收并解析响应消息，处理完相关的响应逻辑，一次RPC调用便结束了。可以说，网络通信是整个RPC调用流程的基础。</p><h2>常见的网络IO模型</h2><p>那说到网络通信，就不得不提一下网络IO模型。为什么要讲网络IO模型呢？因为所谓的两台PC机之间的网络通信，实际上就是两台PC机对网络IO的操作。</p><p>常见的网络IO模型分为四种：同步阻塞IO（BIO）、同步非阻塞IO（NIO）、IO多路复用和异步非阻塞IO（AIO）。在这四种IO模型中，只有AIO为异步IO，其他都是同步IO。</p><!-- [[[read_end]]] --><p>其中，最常用的就是同步阻塞IO和IO多路复用，这一点通过了解它们的机制，你会get到。至于其他两种IO模型，因为不常用，则不作为本讲的重点，有兴趣的话我们可以在留言区中讨论。</p><h3>阻塞IO（blocking IO）</h3><p>同步阻塞IO是最简单、最常见的IO模型，在Linux中，默认情况下所有的socket都是blocking的，先看下操作流程。</p><p>首先，应用进程发起IO系统调用后，应用进程被阻塞，转到内核空间处理。之后，内核开始等待数据，等待到数据之后，再将内核中的数据拷贝到用户内存中，整个IO处理完毕后返回进程。最后应用的进程解除阻塞状态，运行业务逻辑。</p><p>这里我们可以看到，系统内核处理IO操作分为两个阶段——等待数据和拷贝数据。而在这两个阶段中，应用进程中IO操作的线程会一直都处于阻塞状态，如果是基于Java多线程开发，那么每一个IO操作都要占用线程，直至IO操作结束。</p><p>这个流程就好比我们去餐厅吃饭，我们到达餐厅，向服务员点餐，之后要一直在餐厅等待后厨将菜做好，然后服务员会将菜端给我们，我们才能享用。</p><h3>IO多路复用（IO multiplexing）</h3><p>多路复用IO是在高并发场景中使用最为广泛的一种IO模型，如Java的NIO、Redis、Nginx的底层实现就是此类IO模型的应用，经典的Reactor模式也是基于此类IO模型。</p><p>那么什么是IO多路复用呢？通过字面上的理解，多路就是指多个通道，也就是多个网络连接的IO，而复用就是指多个通道复用在一个复用器上。</p><p>多个网络连接的IO可以注册到一个复用器（select）上，当用户进程调用了select，那么整个进程会被阻塞。同时，内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核中拷贝到用户进程。</p><p>这里我们可以看到，当用户进程发起了select调用，进程会被阻塞，当发现该select负责的socket有准备好的数据时才返回，之后才发起一次read，整个流程要比阻塞IO要复杂，似乎也更浪费性能。但它最大的优势在于，用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p>同样好比我们去餐厅吃饭，这次我们是几个人一起去的，我们专门留了一个人在餐厅排号等位，其他人就去逛街了，等排号的朋友通知我们可以吃饭了，我们就直接去享用了。</p><h3>为什么说阻塞IO和IO多路复用最为常用？</h3><p>了解完二者的机制，我们就可以回到起初的问题了——我为什么说阻塞IO和IO多路复用最为常用。对比这四种网络IO模型：阻塞IO、非阻塞IO、IO多路复用、异步IO。实际在网络IO的应用上，需要的是系统内核的支持以及编程语言的支持。</p><p>在系统内核的支持上，现在大多数系统内核都会支持阻塞IO、非阻塞IO和IO多路复用，但像信号驱动IO、异步IO，只有高版本的Linux系统内核才会支持。</p><p>在编程语言上，无论C++还是Java，在高性能的网络编程框架的编写上，大多数都是基于Reactor模式，其中最为典型的便是Java的Netty框架，而Reactor模式是基于IO多路复用的。当然，在非高并发场景下，同步阻塞IO是最为常见的。</p><p>综合来讲，在这四种常用的IO模型中，应用最多的、系统内核与编程语言支持最为完善的，便是阻塞IO和IO多路复用。这两种IO模型，已经可以满足绝大多数网络IO的应用场景。</p><h3>RPC框架在网络通信上倾向选择哪种网络IO模型？</h3><p>讲完了这两种最常用的网络IO模型，我们可以看看它们都适合什么样的场景。</p><p>IO多路复用更适合高并发的场景，可以用较少的进程（线程）处理较多的socket的IO请求，但使用难度比较高。当然高级的编程语言支持得还是比较好的，比如Java语言有很多的开源框架对Java原生API做了封装，如Netty框架，使用非常简便；而GO语言，语言本身对IO多路复用的封装就已经很简洁了。</p><p>而阻塞IO与IO多路复用相比，阻塞IO每处理一个socket的IO请求都会阻塞进程（线程），但使用难度较低。在并发量较低、业务逻辑只需要同步进行IO操作的场景下，阻塞IO已经满足了需求，并且不需要发起select调用，开销上还要比IO多路复用低。</p><p>RPC调用在大多数的情况下，是一个高并发调用的场景，考虑到系统内核的支持、编程语言的支持以及IO模型本身的特点，在RPC框架的实现中，在网络通信的处理上，我们会选择IO多路复用的方式。开发语言的网络通信框架的选型上，我们最优的选择是基于Reactor模式实现的框架，如Java语言，首选的框架便是Netty框架（Java还有很多其他NIO框架，但目前Netty应用得最为广泛），并且在Linux环境下，也要开启epoll来提升系统性能（Windows环境下是无法开启epoll的，因为系统内核不支持）。</p><p>了解完以上内容，我们可以继续看这样一个关键问题——零拷贝。在我们应用的过程中，他是非常重要的。</p><h2>什么是零拷贝？</h2><p>刚才讲阻塞IO的时候我讲到，系统内核处理IO操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。以下是具体流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/8a/cdf3358f751d2d71564ab58d4f78bc8a.jpg?wh=4146*1478\" alt=\"\" title=\"网络IO读写流程\"></p><p>应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由CPU将数据拷贝到系统内核的缓冲区中，之后再由DMA将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。</p><p>应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要CPU进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样是不是很浪费CPU和性能呢？那有没有什么方式，可以减少进程间的数据拷贝，提高数据传输的效率呢？</p><p>这时我们就需要零拷贝（Zero-copy）技术。</p><p>所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，都可以通过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，再通过DMA将内核中的数据拷贝到网卡，或将网卡中的数据copy到内核。</p><p>那怎么做到零拷贝？你想一下是不是用户空间与内核空间都将数据写到一个地方，就不需要拷贝了？此时你有没有想到虚拟内存？</p><p><img src=\"https://static001.geekbang.org/resource/image/00/79/0017969e25ed01f650d7879ac0a2cc79.jpg?wh=3938*1853\" alt=\"\" title=\"虚拟内存\"></p><p>零拷贝有两种解决方式，分别是 mmap+write 方式和 sendfile 方式，mmap+write方式的核心原理就是通过虚拟内存来解决的。这两种实现方式都不难，市面上可查阅的资料也很多，在此就不详述了，有问题，可以在留言区中解决。</p><h2>Netty中的零拷贝</h2><p>了解完零拷贝，我们再看看Netty中的零拷贝。</p><p>我刚才讲到，RPC框架在网络通信框架的选型上，我们最优的选择是基于Reactor模式实现的框架，如Java语言，首选的便是Netty框架。那么Netty框架是否也有零拷贝机制呢？Netty框架中的零拷贝和我之前讲的零拷贝又有什么不同呢？</p><p>刚才我讲的零拷贝是操作系统层面上的零拷贝，主要目标是避免用户空间与内核空间之间的数据拷贝操作，可以提升CPU的利用率。</p><p>而Netty的零拷贝则不大一样，他完全站在了用户空间上，也就是JVM上，它的零拷贝主要是偏向于数据操作的优化上。</p><p><strong>那么Netty这么做的意义是什么呢？</strong></p><p>回想下<a href=\"https://time.geekbang.org/column/article/199651\">[第 02 讲]</a>，在这一讲中我讲解了RPC框架如何去设计协议，其中我讲到：在传输过程中，RPC并不会把请求参数的所有二进制数据整体一下子发送到对端机器上，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包，所以消息都需要有边界。那么一端的机器收到消息之后，就需要对数据包进行处理，根据边界对数据包进行分割和合并，最终获得一条完整的消息。</p><p>那收到消息后，对数据包的分割和合并，是在用户空间完成，还是在内核空间完成的呢？</p><p>当然是在用户空间，因为对数据包的处理工作都是由应用程序来处理的，那么这里有没有可能存在数据的拷贝操作？可能会存在，当然不是在用户空间与内核空间之间的拷贝，是用户空间内部内存中的拷贝处理操作。Netty的零拷贝就是为了解决这个问题，在用户空间对数据操作进行优化。</p><p>那么Netty是怎么对数据操作进行优化的呢？</p><ul>\n<li>Netty 提供了 CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的  ByteBuf，避免了各个 ByteBuf 之间的拷贝。</li>\n<li>ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。</li>\n<li>通过 wrap 操作，我们可以将 byte[] 数组、ByteBuf、ByteBuffer  等包装成一个 Netty ByteBuf 对象, 进而避免拷贝操作。</li>\n</ul><p>Netty框架中很多内部的ChannelHandler实现类，都是通过CompositeByteBuf、slice、wrap操作来处理TCP传输中的拆包与粘包问题的。</p><p>那么Netty有没有解决用户空间与内核空间之间的数据拷贝问题的方法呢？</p><p>Netty  的  ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行Socket的读写操作，最终的效果与我刚才讲解的虚拟内存所实现的效果是一样的。</p><p>Netty  还提供  FileRegion  中包装  NIO  的  FileChannel.transferTo()  方法实现了零拷贝，这与Linux  中的  sendfile  方式在原理上也是一样的。</p><h2>总结</h2><p>今天我们详细地介绍了阻塞IO与IO多路复用，拓展了零拷贝相关的知识以及Netty框架中的零拷贝。</p><p>考虑到系统内核的支持、编程语言的支持以及IO模型本身的特点，RPC框架在网络通信的处理上，我们更倾向选择IO多路复用的方式。</p><p>零拷贝带来的好处就是避免没必要的CPU拷贝，让CPU解脱出来去做其他的事，同时也减少了CPU在用户空间与内核空间之间的上下文切换，从而提升了网络通信效率与应用程序的整体性能。</p><p>而Netty的零拷贝与操作系统的零拷贝是有些区别的，Netty的零拷贝偏向于用户空间中对数据操作的优化，这对处理TCP传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。</p><p>在 RPC框架的开发与使用过程中，我们要深入了解网络通信相关的原理知识，尽量做到零拷贝，如使用Netty框架；我们要合理使用ByteBuf子类，做到完全零拷贝，提升RPC框架的整体性能。</p><h2>课后思考</h2><p>回想一下，你所接触的开源中间件框架有哪些框架在网络通信上做到了零拷贝？都是使用哪种方式实现的零拷贝？</p><p>欢迎留言和我分享你的思考和疑惑，也欢迎你把文章分享给你的朋友，邀请他加入学习。我们下节课再见！</p>","comments":[{"had_liked":false,"id":183399,"user_name":"雨霖铃声声慢","can_delete":false,"product_type":"c1","uid":1052607,"ip_address":"","ucode":"656D98310C6DA3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/bf/ee93c4cf.jpg","comment_is_top":false,"comment_ctime":1583032934,"is_pvip":false,"replies":[{"id":"71880","content":"系统层面零拷贝跟应用层零拷贝还是需要区分的","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583751431,"ip_address":"","comment_id":183399,"utype":1}],"discussion_count":8,"race_medal":0,"score":"263576037990","product_id":100046201,"comment_content":"IO多路复用分为select，poll和epoll，文中描述的应该是select的过程，nigix，redis等使用的是epoll，所以光只看这个文章的话会比较迷惑，文中写的太粗了。<br>对于课后思考，目前很多的主流的需要通信的中间件都差不多都实现了零拷贝，如Kfaka，RocketMQ等。kafka的零拷贝是通过java.nio.channels.FileChannel中的transferTo方法来实现的，transferTo方法底层是基于操作系统的sendfile这个system call来实现的。","like_count":61,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485677,"discussion_content":"系统层面零拷贝跟应用层零拷贝还是需要区分的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583751431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1641776,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0d/30/1ae8f1fc.jpg","nickname":"超越","note":"","ucode":"AC629D64704074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551459,"discussion_content":"文章写的确实太水了呀","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1645019082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2163923,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/tmKD96dzOPORx0UbbIocwUR0NO4ApBIIJZ0foOibLq2xkLgV2gficxRMreycHMErXHTQpJHDFWiablxjfhWzXRntg/132","nickname":"Geek_04789d","note":"","ucode":"9341B8934455C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543949,"discussion_content":"1,最早的socket=read+write，read负责数据从磁盘copy到内核缓冲区，内核缓冲区copy到用户缓冲区，用户缓冲区copy到内核socket缓冲区，socket缓冲区copy到协议引擎。\n2,nmap在read的基础上，省去了内核与用户缓冲区的拷贝。因为两者会共享一个缓冲区。这样磁盘copy到内核共享缓冲区，共享缓冲区copy到socket缓冲区，后者copy到协议引擎。\n3,send在nmap的基础上，省去了内核共享缓冲区copy到socket缓冲区，而是直接从内核共享缓冲区copy到协议引擎。在此过程中，socket缓冲区只是记录一些元信息\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1641366479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101234,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/b2/807137b9.jpg","nickname":"北方易初","note":"","ucode":"C57FDBD37F43E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2163923,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/tmKD96dzOPORx0UbbIocwUR0NO4ApBIIJZ0foOibLq2xkLgV2gficxRMreycHMErXHTQpJHDFWiablxjfhWzXRntg/132","nickname":"Geek_04789d","note":"","ucode":"9341B8934455C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585215,"discussion_content":"socket 缓冲是什么缓冲？是网卡的缓冲区吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661402086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":543949,"ip_address":"北京"},"score":585215,"extra":""}]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571121,"discussion_content":"文章写的没有逻辑性啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1652078781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483611,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7mS4TkKnIqEfRTlkfoC2324hLOEhibRNibuBv9nbKeMg7YDDELMM85MIPmW0CZzJvEgZLo2T1DF6sA/132","nickname":"Geek_dispy","note":"","ucode":"E0732EDAA2FAC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414137,"discussion_content":"文章写的一头雾水…","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1636677471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204168,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/c8/13aa8aa9.jpg","nickname":"night","note":"","ucode":"03B3C955092C03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531072,"discussion_content":"可能只是想引入多路复用的概念？ 实际上生产级的应用程序的linux版本， 基本都是使用epoll的。 epoll和select在实现、性能上还是有很多差异的，极客时间上网络编程课程里面有细节，朋友们可以看看","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637220918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2718510,"avatar":"","nickname":"jack123","note":"","ucode":"873D0046EF39D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401391,"discussion_content":"mark，又是评论区比原文精彩系列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633657889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194006,"user_name":"南桥畂翊","can_delete":false,"product_type":"c1","uid":1003956,"ip_address":"","ucode":"A97C49A6309A42","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/b4/0d402ae8.jpg","comment_is_top":false,"comment_ctime":1585013259,"is_pvip":false,"replies":[{"id":"76889","content":"是不太严谨，已改","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1586735658,"ip_address":"","comment_id":194006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"113254162955","product_id":100046201,"comment_content":"所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，可以通过一种方式，直接将数据写入内核或从内核中读取数据，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。<br><br><br>老师，上述说直接将数据写入内核或从内核中读取数据，这部分内存不是属于内核态空间的吧？应该说只是一块物理内存，用户态虚拟地址和内核态虚拟地址都作了页表映射","like_count":27,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488727,"discussion_content":"是不太严谨，已改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586735658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182159,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1582722760,"is_pvip":true,"discussion_count":11,"race_medal":0,"score":"61712264904","product_id":100046201,"comment_content":"老师，我理解的IO多路复用，是应用线程一直再调用select，读取内核准备好数据的socket，所以应用线程是阻塞的，但是老师你文章中举的那个例子，不用应用(用户)打电话去询问的，而是内核(餐馆)打电话通知的，在这期间你还可以去干其他的事情，我感觉你这个案例是异步IO非阻塞的","like_count":14,"discussions":[{"author":{"id":1494621,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/pn1RQkyXjx9osEfJiacTvPG9HRiaDicx7aXaQaW1bW0h7eZOZfbz8YETyjNL5iashdfzuo3GGrfXU7BDqTu0vlmQyQ/132","nickname":"kls","note":"","ucode":"08E68792A264EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280643,"discussion_content":"我觉得例子应该举为  餐厅服务员在那里等待（餐厅服务员相当于select），有客人来了（IO事件），就招待入座，之后餐厅服务员继续等待。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1591585200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372498,"discussion_content":"不是不需要用户去打电话询问，而是多个用户委托了一个代理线程去不断打电话询问，这时，用户是可以去干别的事的，但是委托的这个线程去SELECT 如果没有数据，此时是会阻塞的，还有个问题，异步是指完全的异步，这里内核数据准备好后，通知用户读取，用户去读取的过程还是会阻塞的，异步值得的是，内核准备好数据，和把数据从内核态复制到用户态，这俩个 过程，用户都不会阻塞，很明显IO 多路复用，第一阶段内核准备数据(接收网卡数据)用户是不阻塞的，可以干别的，但是委托的询问线程是会则塞的，而第二阶段，内核准备好数据后，通知用户去读取数据，这个过程，用户还是会则塞的。完全异步指的俩个阶段都不阻塞","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620355784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1547842,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9e/42/ab4f65c8.jpg","nickname":"པག་ཏོན་།","note":"","ucode":"4A70B482F7BB9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410369,"discussion_content":"多路复用就是同步的，用户是什么？用户应用程序发起的一个进程或线程让他去执行 select 操作，select 仍然是阻塞进程的，只是它同时监控了多个 socket 所以老师的例子是错的，所谓的用户也不能做别的事。当某个socket 获取数据时所谓的用户才把所有的socket 的内核描述文件返回，再去遍历读取，整个过程该线程都无法做别的事。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635678403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372498,"ip_address":""},"score":410369,"extra":""}]},{"author":{"id":1320343,"avatar":"https://static001.geekbang.org/account/avatar/00/14/25/97/1299c14a.jpg","nickname":"程序诗人","note":"","ucode":"6981824D0A9B8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344011,"discussion_content":"老师栗子很恰当","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1611233261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2835489,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/44/21/6d27fcf0.jpg","nickname":"бабочка","note":"","ucode":"8EB3AE0BFC335D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411776,"discussion_content":"在家预约同一家店的多个连锁店 哪个有位置了 就去哪家用餐 期间还是要不时轮训排号状态等待位置结果的 这样是不是恰当点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636002842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1659177,"avatar":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","nickname":"凉人。","note":"","ucode":"4DB16004A62015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250738,"discussion_content":"你的这个说法貌似也不太对。select是在有信号产生，然后线程会阻塞等待内核数据准备。这点也是多路复用和异步的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588037727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189371,"discussion_content":"老师修改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582873915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"discussion":{"id":189408,"discussion_content":"老师为什么不喜欢回答问题呢？我看下面好多问题都没有回复，这才更新几篇文章啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582878373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189371,"ip_address":""},"score":189408,"extra":""},{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":189441,"discussion_content":"老师没有不喜欢，他也忙，有回复的节奏……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582883087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189408,"ip_address":""},"score":189441,"extra":""}]},{"author":{"id":1218578,"avatar":"https://static001.geekbang.org/account/avatar/00/12/98/12/a169bdcd.jpg","nickname":"Geek_477c02","note":"","ucode":"CB9A714A50B977","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188275,"discussion_content":"是的，他这个例子举错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582807002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1589989,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/e5/61cfe267.jpg","nickname":"Eclipse","note":"","ucode":"E7EB0BA99FA644","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187586,"discussion_content":"同样好比我们去餐厅吃饭，当我们点完餐之后服务员会记下我们的手机号码，之后我们就可以去逛逛街、逛逛超市，等后厨把饭做好后我们的手机会收到取饭的通知，然后我们再去享用午餐或者晚餐。\n\n我也感觉这例子不恰当，俺这个例子，用户该干啥干啥，不成异步了的嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582736613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188914,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1584433608,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"53124041160","product_id":100046201,"comment_content":"Nginx  sendfile方式<br>Kafka  应该是mmap方式，适合小文件","like_count":12,"discussions":[{"author":{"id":2459923,"avatar":"https://static001.geekbang.org/account/avatar/00/25/89/13/0d3c5008.jpg","nickname":"最好不过","note":"","ucode":"C7DBCD08402DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379913,"discussion_content":"RocketMQ 选择了 mmap + write 这种零拷贝方式，适用于业务级消息这种小块文件的数据持久化和传输；而 Kafka 采用的是 sendfile 这种零拷贝方式，适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输。但是值得注意的一点是，Kafka 的索引文件使用的是 mmap + write 方式，数据文件使用的是 sendfile 方式。\n\n链接：https://juejin.cn/post/6844903949359644680","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1624243220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2459923,"avatar":"https://static001.geekbang.org/account/avatar/00/25/89/13/0d3c5008.jpg","nickname":"最好不过","note":"","ucode":"C7DBCD08402DF8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390191,"discussion_content":"感谢提供的链接，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629708473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379913,"ip_address":""},"score":390191,"extra":""}]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387644,"discussion_content":"好网站","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628316861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199298,"user_name":"stonyliu","can_delete":false,"product_type":"c1","uid":1062631,"ip_address":"","ucode":"E276B9FE907515","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/e7/c9eda4e7.jpg","comment_is_top":false,"comment_ctime":1585486052,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35945224420","product_id":100046201,"comment_content":"零拷贝这块对于一个非JAVA程序员来说就等于没说啥，给给题目自己查吧","like_count":9,"discussions":[{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225390,"discussion_content":"不算netty那份部分，用户态和内核态的切换和拷贝问题都是语言无关是系统的事情。而且通常说的零拷贝也是内核态和用户态的复制问题，所以这个跟java没关系，和操作系统有关系。io这分布跟语言关系都不打","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586357192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276833,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1612148771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31676919843","product_id":100046201,"comment_content":"感觉在零拷贝这块讲的不细致,没有图来展示到底是那块做的优化,单单文字描述让人有点误解,而且对比另外几个课程讲解零拷贝的感觉这块老师似乎还讲错了,用户态到内核态的零拷贝.看完这节课疑问更多了....难受","like_count":8},{"had_liked":false,"id":318735,"user_name":"པག་ཏོན་།","can_delete":false,"product_type":"c1","uid":1547842,"ip_address":"","ucode":"4A70B482F7BB9D","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/42/ab4f65c8.jpg","comment_is_top":false,"comment_ctime":1635408061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23110244541","product_id":100046201,"comment_content":"写的非常粗，可见作者对网络知识了解并不深入，买这个课是真的交了智商税","like_count":6},{"had_liked":false,"id":182224,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1582730445,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23057566925","product_id":100046201,"comment_content":"老师好，有句话不大理解：但它最大的优势在于，用户可以在一个线程内同时处理多个socket的IO请求；<br>1、这个线程指的是维护select的线程吗？<br>2、为什么用户可以在一个线程内处理多个socket的IO请求？我理解，这里的用户，应该指的是客户端调用方，那么多个socket，应该是指，其他客户端调用方发送过来的、且IO还未准备好的socket，都被放在了这个select里，然后因为这个用户的select调用，某个IO完成的socket被返回了。如果我理解的没错，那应该还是，只处理了一个请求啊？（那个IO完成的socket）<br><br>3、Reactor模式是为了应对高并发场景的，假设一个极端情况：请求A过来，处理IO稍微花了点时间，后面就没有任何请求过来了，那么请求A是不是永远得不到响应了？因为Reactor是时间驱动的，请求A的socket被放在select里了，没有新的事件触发它去返回；<br>还是说内核会监视，处理完之后就主动返回给客户端？<br>如果内核会主动返回给客户端，那么为什么说：当用户发起了select调用，进程会被阻塞，当发现该select负责的socket有准备好的数据时才返回，之后才发起一次read。<br>麻烦解答下，谢谢！","like_count":5,"discussions":[{"author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188955,"discussion_content":"io多路复用 顾名思义是io通道的同时运用 并不是处理方可以同时处理socket事件 我的理解是指 采用io多路复用 及时只有一个处理方 也可以接受多个socket io请求 因为注册了就行 如果是阻塞的 那对不起 第一个没完成 第二个请求也进不来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582826458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1099750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","nickname":"川杰","note":"","ucode":"815211E1D698E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189244,"discussion_content":"谢谢，稍微理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582861307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":188955,"ip_address":""},"score":189244,"extra":""}]}]},{"had_liked":false,"id":217508,"user_name":"陈掌门","can_delete":false,"product_type":"c1","uid":1122607,"ip_address":"","ucode":"7A7BB34162D621","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/2f/37c96c64.jpg","comment_is_top":false,"comment_ctime":1589520811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18769389995","product_id":100046201,"comment_content":"讲的真好，全是干货","like_count":4},{"had_liked":false,"id":194077,"user_name":"Q.E.D","can_delete":false,"product_type":"c1","uid":1640062,"ip_address":"","ucode":"618DD1EB30220D","user_header":"https://static001.geekbang.org/account/avatar/00/19/06/7e/daa187da.jpg","comment_is_top":false,"comment_ctime":1585021552,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"18764890736","product_id":100046201,"comment_content":"tcp不是流协议吗，为什么会有粘包这种说法。","like_count":4,"discussions":[{"author":{"id":1618828,"avatar":"","nickname":"面向工资编程","note":"","ucode":"07F797F021BDD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271777,"discussion_content":"粘包是应用层的问题 https://draveness.me/whys-the-design-tcp-message-frame/","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590194745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1997605,"avatar":"","nickname":"蔡佳伟","note":"","ucode":"D7528B73994578","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265065,"discussion_content":"之所以是流，所以粘包啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589371877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1640062,"avatar":"https://static001.geekbang.org/account/avatar/00/19/06/7e/daa187da.jpg","nickname":"Q.E.D","note":"","ucode":"618DD1EB30220D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1997605,"avatar":"","nickname":"蔡佳伟","note":"","ucode":"D7528B73994578","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270339,"discussion_content":"你这个之所以是流，我没搞明白是什么意思。\ntcp本身没有粘包的说法，即使你翻书，书上也没有写这个东西。\n如果说是应用层数据拼装发送和接收解析问题，这个是没错的，因为粘包产生主要是程序写的有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589989720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":265065,"ip_address":""},"score":270339,"extra":""},{"author":{"id":1001700,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/e4/974c38d0.jpg","nickname":"小牛人","note":"","ucode":"D5623BC72BF5F4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1640062,"avatar":"https://static001.geekbang.org/account/avatar/00/19/06/7e/daa187da.jpg","nickname":"Q.E.D","note":"","ucode":"618DD1EB30220D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576653,"discussion_content":"粘包是对应用层来说的，任何基于tcp的协议都会有这个问题，因为tcp是流协议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655726965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":270339,"ip_address":""},"score":576653,"extra":""}]}]},{"had_liked":false,"id":276836,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1612148902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14497050790","product_id":100046201,"comment_content":"缓冲区也是属于用户空间的啊,从缓冲区到内核空间还是需要一次拷贝的啊.为什么这里就说是取消了.只有sendfile可以做到取消用户空间到内核空间的数据拷贝吧?啊啊啊啊,能不能再精致严谨一点呀.","like_count":3},{"had_liked":false,"id":216347,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1589245345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14474147233","product_id":100046201,"comment_content":"网络IO通信模型和零拷贝，这两个知识点在不同的课程上都有讲解，重要性不言而喻，虽然讲解的都算是高手吧！每个人的讲解方式都不一样，理解起来也是有的容易有的费劲。有此推测完全把这块都系统的弄明白，也能讲出来让他人弄明白是比较困难的。不知道别人什么感受，个人觉得何老师讲解的不是很细致和全面，我不太容量理解 之前觉得这块自己理解了，现在发现并没有。我需要找本书，在好好学习一下。<br><br>不过快的原理还是比较容易理解的，不同的网络IO通信模型之所以，有快慢且相差很大，主要是因为，一个是否消除或减少了线程阻塞等待的过程，另一个是否实现了一个链接供多个线程通信复用。零拷贝之所以快是因为它在做减法，省去一次拷贝的动作，少做事尤其是少做费时间的事情速度自然就快起来了。不过具体到每一步，他们是怎么做到的还有待继续学习，计算机是比较复杂的，光理解信息是怎么表示？怎么存储？怎么传输？怎么运算？都比较烧脑了。","like_count":3},{"had_liked":false,"id":294022,"user_name":"学习学习学习学习学习学习学习","can_delete":false,"product_type":"c1","uid":1243322,"ip_address":"","ucode":"FBEF1575658620","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/ba/37c24a08.jpg","comment_is_top":false,"comment_ctime":1621683470,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10211618062","product_id":100046201,"comment_content":"**网络io中的零拷贝**<br><br>系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。<br><br>- 等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中<br>- 拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。<br><br>应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 CPU 将数据拷贝到系统内核的缓冲区中，之后再由 DMA 将这份数据拷贝到网卡中，最后由网卡发送出去。一次写操作数据要拷贝两次才能通过网卡发送出去<br><br>- 零拷贝技术<br>    - 零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，都可以通过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。<br>- 零拷贝实现<br>    - mmap+write 方式，核心原理是通过虚拟内存来解决的<br>    - sendfile 方式<br>- Netty零拷贝实现：<br>    - 用户空间数据操作零拷贝优化<br>        - 收到数据包后，在对数据包进行处理时，需要根据协议，处理数据包，在进行处理时，免不了需要进行在用户空间内部内存中进行拷贝处理，Netty就是在用户空间中对数据操作进行优化<br>        - Netty 提供了 CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的  ByteBuf，避免了各个 ByteBuf 之间的拷贝。<br>        - ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。<br>        - 通过 wrap 操作，我们可以将 byte[] 数组、ByteBuf、ByteBuffer  等包装成一个 Netty ByteBuf 对象, 进而避免拷贝操作。<br>    - 用户空间与内核空间之间零拷贝优化<br>        - Netty  的  ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socket 的读写操作，效果和虚拟内存所实现的效果是一样的。<br>        - Netty  还提供  FileRegion  中包装  NIO  的  FileChannel.transferTo()  方法实现了零拷贝，这与 Linux  中的  sendfile  方式在原理上也是一样的。","like_count":2,"discussions":[{"author":{"id":1073845,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","nickname":"zhanyd","note":"","ucode":"4C994EE512A3C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409663,"discussion_content":"优秀啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635486274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200892,"user_name":"想出家的小和尚","can_delete":false,"product_type":"c1","uid":1931524,"ip_address":"","ucode":"7C079ADC43577F","user_header":"https://static001.geekbang.org/account/avatar/00/1d/79/04/748ee8c9.jpg","comment_is_top":false,"comment_ctime":1585668088,"is_pvip":false,"replies":[{"id":"76884","content":"用户空间和内核空间是系统层面划分的；堆内和堆外是针对jvm进程来讲的","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1586735236,"ip_address":"","comment_id":200892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175602680","product_id":100046201,"comment_content":"老师，直接内存给我的概念很模糊，他指的到底是什么？和jvm中的堆内内存，堆外内存，用户空间，内核空间有什么关系？","like_count":3,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490166,"discussion_content":"用户空间和内核空间是系统层面划分的；堆内和堆外是针对jvm进程来讲的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586735236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183380,"user_name":"阿卧","can_delete":false,"product_type":"c1","uid":1229566,"ip_address":"","ucode":"68C0CC25E57707","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/fe/038a076e.jpg","comment_is_top":false,"comment_ctime":1583031216,"is_pvip":false,"replies":[{"id":"71881","content":"很棒","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583751455,"ip_address":"","comment_id":183380,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10172965808","product_id":100046201,"comment_content":"阻塞IO：<br>1. 阻塞等待：多线程进行IO读取，需要阻塞等待<br>2. 内存两次拷贝：从设备（磁盘或者网络）拷贝到用户空间，再从用户空间拷贝到内核空间<br>IO多路复用<br>1. 一个复用器（selector）监听有多个通道（channel）。实现非阻塞式IO读取、写入<br>2. 内存直接拷贝（derict buffers），直接从用户空间拷贝到内核空间","like_count":2,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485668,"discussion_content":"很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583751455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9f/3f/a51e6376.jpg","nickname":"IT之眼","note":"","ucode":"AB0F40D96C38D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301010,"discussion_content":"从设备（磁盘或者网络）不是先拷贝到内核空间吗？？ 写错了吧。坐着怎么还点赞了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598364207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324656,"user_name":"bigdudo","can_delete":false,"product_type":"c1","uid":1371360,"ip_address":"","ucode":"5938710D7C1149","user_header":"https://static001.geekbang.org/account/avatar/00/14/ec/e0/d072d6f0.jpg","comment_is_top":false,"comment_ctime":1638529235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933496531","product_id":100046201,"comment_content":"前面的BIO，是一个连接一个线程的处理方式，每条线程自己去监听自己的连接，自己去阻塞并accpet。在这里多路复用，可以理解为是一种批量处理的方式，在一条线程里批量处理多个连接，哪个连接有连接上来了，就向用户进程返回有效的连接。这就是一开始说的多路复用的概念，一个线程处理多个连接。多路复用后面的优化迭代也主要是在批量处理这块的数据模型选型和fd有连接上来的回调的不断优化，从纯遍历方式的select（bitmap承载，最大1024）和poll（数组承载，相对于select，解决了1024有限连接弊端），到cpu终端信号回调的epoll（红黑树管理，有效连接获取放到双向链表并返回个用户进程） 至于用户进程这边怎么处理，是单线程一个一个处理recv&#47;send 还是多线程一个线程一个连接的处理recv&#47;send，这是用户进程的处理方式，也是属于我们常知道的netty这些io中间件的范畴（当然最重要的也是包括基础IO类型的选型也是属于此）。","like_count":1},{"had_liked":false,"id":242136,"user_name":"山头","can_delete":false,"product_type":"c1","uid":1610142,"ip_address":"","ucode":"9CD45A7966F37E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/1R7lHGBvwPTVfb3BAQrPX3AhsYWnXyicbUJUYDgWagWxMGTnsNFvKibzeJ8v7fF2vJLQGf2EY9dV07rnn5Mhv9Uw/132","comment_is_top":false,"comment_ctime":1597620822,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5892588118","product_id":100046201,"comment_content":"峰哥，记得前几节你说的是rpc框架是异步发送请求的，现在要用多路复用同步请求了。有点迷糊了，能给串串吗","like_count":1,"discussions":[{"author":{"id":2029859,"avatar":"","nickname":"Geek_8e8cd5","note":"","ucode":"73E0424E5F69FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300152,"discussion_content":"我觉得这两块是不冲突的。异步指的是发起请求的方式，而不是IO模型。发起请求在前，IO模型在后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597970604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225827,"user_name":"金十数据","can_delete":false,"product_type":"c1","uid":1390893,"ip_address":"","ucode":"E4BA783F2C8922","user_header":"https://static001.geekbang.org/account/avatar/00/15/39/2d/e367c30b.jpg","comment_is_top":false,"comment_ctime":1591867879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886835175","product_id":100046201,"comment_content":"使用零拷贝的前提是没有用异步吗","like_count":1},{"had_liked":false,"id":210918,"user_name":"tongmin_tsai","can_delete":false,"product_type":"c1","uid":1045090,"ip_address":"","ucode":"D9423E770D5846","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","comment_is_top":false,"comment_ctime":1587865302,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5882832598","product_id":100046201,"comment_content":"老师，看两张图的对比，原来是应用缓冲区拷贝到内核缓冲区，零拷贝是应用缓冲区拷贝到虚拟内存缓冲区，对比的话，实际上还是有缓冲区的拷贝，怎么理解？老师说零拷贝带来的好处就是避免没必要的 CPU 拷贝，看图上面，感觉反而在应用缓冲区与内核缓冲区之间还加入了一个缓冲区，那不是效率更低了吗？望老师解答","like_count":1,"discussions":[{"author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258969,"discussion_content":"虚拟内存模式下，应用缓存和内核缓存都指向同一块物理内存，所以，拷贝到其中一个缓存就等于拷贝到另一个，从而节省了在两块缓存之间拷贝数据的开销。看这样好理解不","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1588746994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1045090,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","nickname":"tongmin_tsai","note":"","ucode":"D9423E770D5846","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261139,"discussion_content":"谢谢😜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588942453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258969,"ip_address":""},"score":261139,"extra":""}]},{"author":{"id":1433178,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJMzj0MHiaXBdDFp4E16qhu6PZlu6xkJRWgaoJXOeqMDDLqM4vcvUbnVLiactTypZkYibOg7okwm2TAQ/132","nickname":"Geek_921929","note":"","ucode":"26BF6978F040BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338593,"discussion_content":"零拷贝就是省去了内核态到用户态的拷贝，过程中传输虚拟内存地址，而后通过虚拟内存地址发送到网络缓冲区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609319629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209452,"user_name":"嘻嘻","can_delete":false,"product_type":"c1","uid":1325931,"ip_address":"","ucode":"E1EB75DD1C05E0","user_header":"","comment_is_top":false,"comment_ctime":1587551233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882518529","product_id":100046201,"comment_content":"老师，compositeBytebuf那一段，用一个大的字节数组存新读到的片段，不断移动读写指针确定读写位置，循环利用相当于一个ringbuf 不也可以？为什么要搞那么复杂？","like_count":1},{"had_liked":false,"id":209451,"user_name":"嘻嘻","can_delete":false,"product_type":"c1","uid":1325931,"ip_address":"","ucode":"E1EB75DD1C05E0","user_header":"","comment_is_top":false,"comment_ctime":1587551051,"is_pvip":false,"replies":[{"id":"79069","content":"netty里面0更多是buffer类而言","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1588256191,"ip_address":"","comment_id":209451,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5882518347","product_id":100046201,"comment_content":"老师，个人理解netty 堆在内存还是在用户态的，还是要拷贝到内核态啊，为啥零拷贝了？","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492803,"discussion_content":"netty里面0更多是buffer类而言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588256191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325931,"avatar":"","nickname":"嘻嘻","note":"","ucode":"E1EB75DD1C05E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246114,"discussion_content":"堆外内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587727398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205824,"user_name":"上帝之手","can_delete":false,"product_type":"c1","uid":1462433,"ip_address":"","ucode":"2C5E6A40049DE7","user_header":"https://static001.geekbang.org/account/avatar/00/16/50/a1/3a4fd2fe.jpg","comment_is_top":false,"comment_ctime":1586744272,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5881711568","product_id":100046201,"comment_content":"您好！何老师。有一个问题没有看懂，你说的“零拷贝带来的好处就是避免没必要的 CPU 拷贝，让 CPU 解脱出来去做其他的事，同时也减少了 CPU 在用户空间与内核空间之间的上下文切换，从而提升了网络通信效率与应用程序的整体性能。”这段话，带来的好处的是让CPU解脱出来做其他事情，我不太懂，拷贝的过程难道不是由CPU来操作执行的吗？比如上面说的netty的FileChannel.transferTo()方法实现的零拷贝，还不是要CPU来执行吗？怎么就做到解脱CPU了","like_count":1,"discussions":[{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358262,"discussion_content":"cpu处理速度可以发到亿级别，io设备万级别，让cpu来处理这些，那么大部分时间就是在等待数据。cpu切换通过时间片，把cpu解放出来做其他事情而不是在等待数据，那么cpu处理其他的就更快了。所以出现了dma","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615956216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029859,"avatar":"","nickname":"Geek_8e8cd5","note":"","ucode":"73E0424E5F69FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300154,"discussion_content":"DMA就是来解放CPU的，CPU只需要发出一个指令，DMA会自行进行数据拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597970781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a1/8efba078.jpg","nickname":"小墨","note":"","ucode":"8E302FD86999D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287712,"discussion_content":"还有DMA","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593518149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204263,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1586357397,"is_pvip":false,"replies":[{"id":"76868","content":"本质上多路复用还是同步堵塞的","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1586733695,"ip_address":"","comment_id":204263,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5881324693","product_id":100046201,"comment_content":"问一下nio和io多路复用的区别（我认为没区别吧），io多路复用不就是为了实现同步非阻塞？","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491123,"discussion_content":"本质上多路复用还是同步堵塞的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586733695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2417008,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e1/70/eb0d59da.jpg","nickname":"hes","note":"","ucode":"99A83532C33CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344267,"discussion_content":"将多个通道的阻塞，都弄到一个上进行阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611378345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182788,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1582866775,"is_pvip":false,"replies":[{"id":"72798","content":"看下netty的各常用的ChannlHandler和Bytebuf的实现。","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1584411494,"ip_address":"","comment_id":182788,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877834071","product_id":100046201,"comment_content":"老师你讲的netty零拷贝不光做到在用户级别的，还有操作系统级别的，那老师如果我想理解它的怎么做的，因为它源代码看的迷糊，怎样把他实现的高技巧和方法运用到自己这块,灵活运用","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485452,"discussion_content":"看下netty的各常用的ChannlHandler和Bytebuf的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584411494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182160,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1582723408,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5877690704","product_id":100046201,"comment_content":"Redis的网络模型就是IO多路复用，但他是单线程的啊，老师文章中说到IO多路复用一般都是多线程进行实现的，这个怎么理解呢？","like_count":1,"discussions":[{"author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188954,"discussion_content":"其实ios多路复用的核心就是指 在只有一个处理方的时候 如果可以把多个io通道都利用上的方法 重点在io通道的复用（注册就好 不用死等）单线程的话 io如果多个准备好了 也要一个一个处理 如果运用多线程 在多cpu核心的基础上 只是可以同时处理与核心数相同的已经准备好的io事件而已","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1582826171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348954,"user_name":"徐敏","can_delete":false,"product_type":"c1","uid":1302874,"ip_address":"","ucode":"5F16D588591489","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/5a/d2081f1c.jpg","comment_is_top":false,"comment_ctime":1655607953,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655607953","product_id":100046201,"comment_content":"看这个课程，其实是来看一些思路的，没点基础真不行。","like_count":0},{"had_liked":false,"id":348411,"user_name":" AiTBoy","can_delete":false,"product_type":"c1","uid":2890820,"ip_address":"","ucode":"2C79E533424B71","user_header":"https://static001.geekbang.org/account/avatar/00/2c/1c/44/e8649bae.jpg","comment_is_top":false,"comment_ctime":1655088827,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655088827","product_id":100046201,"comment_content":"一次IO分为两步：数据准备 个 数据复制，对应到老师里面的例子就是排队等号和等上菜的过程<br><br>阻塞IO，排队等号和上菜我们都是等着的，不做任何事情<br><br>非阻塞IO，我们先问一下有没有号，如果没有我们可以先去逛街等会再来问下，直到某次刚好有号，我们就可以在餐馆等上菜了<br><br>多路复用，指的是多人同时就餐，有一个人专门去不断的问有没有号，一旦有一个或多个号，就可以让对应有号的人去餐馆等上菜了<br><br>异步IO，前面几种IO我们等上菜的过程不能做任何事，异步IO则可以做其他事，就比如我们占到位了，我们可以先去逛街，等菜都上好了回来吃<br><br>信号驱动IO，我们在手机上下个单，等抢到号了，菜已经上桌了，就会有消息通知我们去吃了<br><br>","like_count":0},{"had_liked":false,"id":340445,"user_name":"施荣荣","can_delete":false,"product_type":"c1","uid":2823089,"ip_address":"","ucode":"7D16C877D40630","user_header":"https://static001.geekbang.org/account/avatar/00/2b/13/b1/9f089294.jpg","comment_is_top":false,"comment_ctime":1648816548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648816548","product_id":100046201,"comment_content":"“但它最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。“这句话怎么感觉描述的是io多路复用的部分实现原理呢，从用户线程角度，其实应该感知不到IO多路复用跟阻塞IO的区别吧，本质上两者一样啊。","like_count":0},{"had_liked":false,"id":326277,"user_name":"ryanxw","can_delete":false,"product_type":"c1","uid":2119325,"ip_address":"","ucode":"0B91EAC8D06EED","user_header":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","comment_is_top":false,"comment_ctime":1639457999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639457999","product_id":100046201,"comment_content":"up讲的都是大体框架，里面涉及的点还是很多的，io多路复用，零拷贝，这两点还是需要具体深入了解学习","like_count":0},{"had_liked":false,"id":291537,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1620353812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620353812","product_id":100046201,"comment_content":"老师好，java nio &#47; netty。使用堆外直接内存也算是一种应用层面的零拷贝吧","like_count":0},{"had_liked":false,"id":290804,"user_name":"头像我老婆","can_delete":false,"product_type":"c1","uid":1248397,"ip_address":"","ucode":"251F60D969AB23","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8d/5293d44d.jpg","comment_is_top":false,"comment_ctime":1619758167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619758167","product_id":100046201,"comment_content":"老师，Netty解决TCP粘包和之前介绍的通过协议解决TCP粘包有什么区别呢？","like_count":0},{"had_liked":false,"id":253747,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2047392,"ip_address":"","ucode":"C84C2D030ACA51","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/a0/acf6b165.jpg","comment_is_top":false,"comment_ctime":1602851757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602851757","product_id":100046201,"comment_content":"你好，阿里现在很多都使用 DPDK 技术，这是不是效率会更高呢？","like_count":0},{"had_liked":false,"id":233711,"user_name":"快乐的平头哥","can_delete":false,"product_type":"c1","uid":1635388,"ip_address":"","ucode":"D7D2FA5DA6D8BF","user_header":"https://static001.geekbang.org/account/avatar/00/18/f4/3c/60bf7a17.jpg","comment_is_top":false,"comment_ctime":1594398981,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1594398981","product_id":100046201,"comment_content":"kafka broker端发数据到消费端 磁盘数据直接发送到socket 不经过用户空间 前提是不能对数据做任何处理","like_count":0,"discussions":[{"author":{"id":2028947,"avatar":"","nickname":"Geek5350","note":"","ucode":"6EB4553707C357","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296836,"discussion_content":"顺序反了，应该 consumer 去 broker 上拉消息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596680303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229338,"user_name":"程序员老王","can_delete":false,"product_type":"c1","uid":1025340,"ip_address":"","ucode":"28577A15F064CF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/3c/7c0d2e57.jpg","comment_is_top":false,"comment_ctime":1592968427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592968427","product_id":100046201,"comment_content":"RPC 调用在大多数的情况下，是一个高并发调用的场景，考虑到系统内核的支持、编程语言的支持以及 IO 模型本身的特点，在 RPC 框架的实现中，在网络通信的处理上，我们会选择 IO 多路复用的方式。开发语言的网络通信框架的选型上，我们最优的选择是基于 Reactor 模式实现的框架，如 Java 语言，首选的框架便是 Netty 框架（Java 还有很多其他 NIO 框架，但目前 Netty 应用得最为广泛），并且在 Linux 环境下，也要开启 epoll 来提升系统性能（Windows 环境下是无法开启 epoll 的，因为系统内核不支持）。","like_count":0},{"had_liked":false,"id":227957,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1592530087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592530087","product_id":100046201,"comment_content":"老师好，请问一下应用层的零拷贝是否用c家族中传递指针也可以实现","like_count":0},{"had_liked":false,"id":216938,"user_name":"蔡佳伟","can_delete":false,"product_type":"c1","uid":1997605,"ip_address":"","ucode":"D7528B73994578","user_header":"","comment_is_top":false,"comment_ctime":1589372162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589372162","product_id":100046201,"comment_content":"老师您好，之前看过别人的文章，用一个ringbuffer来放置多个tcp链接的数据，这样做的效果是什么呢","like_count":0},{"had_liked":false,"id":204155,"user_name":"Jonah","can_delete":false,"product_type":"c1","uid":1079507,"ip_address":"","ucode":"2C4799BD2FF0DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/d3/1dc40aa2.jpg","comment_is_top":false,"comment_ctime":1586343334,"is_pvip":true,"replies":[{"id":"76869","content":"是的","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1586733763,"ip_address":"","comment_id":204155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586343334","product_id":100046201,"comment_content":"典型的Kafka，Rocketmq等","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491091,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586733763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200822,"user_name":"Mike","can_delete":false,"product_type":"c1","uid":1013168,"ip_address":"","ucode":"58601DD413ACC0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/b0/17f46582.jpg","comment_is_top":false,"comment_ctime":1585656798,"is_pvip":true,"replies":[{"id":"76885","content":"是的","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1586735242,"ip_address":"","comment_id":200822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585656798","product_id":100046201,"comment_content":"RocketMq中对消息的读取也用到了零拷贝","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490142,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586735242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195035,"user_name":"郭刚","can_delete":false,"product_type":"c1","uid":1292032,"ip_address":"","ucode":"22CB8ECE8E3DCA","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/00/12149f4e.jpg","comment_is_top":false,"comment_ctime":1585129846,"is_pvip":false,"replies":[{"id":"74955","content":"这个不一定吧，网络之间设备可能","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1585571197,"ip_address":"","comment_id":195035,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585129846","product_id":100046201,"comment_content":"请问一下，RPC调用本地和远程机器之间的带宽是不是千兆起？","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488955,"discussion_content":"这个不一定吧，网络之间设备可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585571197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194224,"user_name":"Geek_7d1d6d","can_delete":false,"product_type":"c1","uid":1163657,"ip_address":"","ucode":"9C3E2E3592A0BF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epY2JtiahsBz4LK1k00DbYoR2Zk56wnYaoBfP63v5X3Xu1kuH1ethAnMOMu6vT9eKQSqHqn3HrTK9Q/132","comment_is_top":false,"comment_ctime":1585039202,"is_pvip":false,"replies":[{"id":"76882","content":"不是的，数据包分割和合并属于网络层，分组属于应用层","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1586734993,"ip_address":"","comment_id":194224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585039202","product_id":100046201,"comment_content":"老师请教一个问题呗：“对数据包的分割和合并”跟咱们说的在传输层说的分组是一个东西吗","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488787,"discussion_content":"不是的，数据包分割和合并属于网络层，分组属于应用层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586734993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185317,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1583560382,"is_pvip":false,"replies":[{"id":"71609","content":"不太准确，用户空间是一个访指范围","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583620224,"ip_address":"","comment_id":185317,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1583560382","product_id":100046201,"comment_content":"老师 用户空间指的是jvm吗？<br>","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486327,"discussion_content":"不太准确，用户空间是一个访指范围","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583620224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200431,"discussion_content":"那用户空间具体指得是什么地方呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583680151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183325,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1582994409,"is_pvip":false,"replies":[{"id":"72797","content":"可以查阅下select、poll、epoll的原理。","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1584411360,"ip_address":"","comment_id":183325,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1582994409","product_id":100046201,"comment_content":"select监视一批socket文件描述符，当某个socket可读或者可写了，那么调用select的线程会被从阻塞中唤醒。这个过程的底层细节是啥啊？比如网卡中断收包，然后中断调用协议栈处理，一直到传输层，然后到socket，发现这个socket是被select监视的，然后将调用select的进程从阻塞队列放到可运行队列，最后在调度点被调度运行。这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485651,"discussion_content":"可以查阅下select、poll、epoll的原理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584411360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029859,"avatar":"","nickname":"Geek_8e8cd5","note":"","ucode":"73E0424E5F69FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300155,"discussion_content":"select是轮询所关注的socket，看缓冲区有没有数据吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597971508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183099,"user_name":"redj","can_delete":false,"product_type":"c1","uid":1251309,"ip_address":"","ucode":"9BD7A1E0FEA881","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ed/f79dd0f6.jpg","comment_is_top":false,"comment_ctime":1582952553,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1582952553","product_id":100046201,"comment_content":"老师说：多个网络连接的 IO 可以注册到一个复用器（select）上，当用户进程调用了 select，那么整个进程会被`阻塞`<br>既然是非阻塞 + IO多路复用，为什么这里会产生阻塞,阻塞的是内核的进程，还是用户的进程？<br>我记得应用进程在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情，应用程序又是怎么腾出手去使用CPU的，如果是阻塞的话？<br>有人能帮我解答一下吗，谢谢啦！！！","like_count":0,"discussions":[{"author":{"id":1618828,"avatar":"","nickname":"面向工资编程","note":"","ucode":"07F797F021BDD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271779,"discussion_content":"非阻塞指的是非阻塞 IO, IO 不阻塞了，但是会阻塞在 select 系统调用上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590194967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258973,"discussion_content":"阻塞的是用户进程，因为select系统调用进入内核态；当select检测到有fd ready之后；用户进程由内核态返回用户态，由用户进程中应用代码来处理。\n\n此外，我觉得你对于内核态，用户态的理解有偏差，可以去复习一下操作系统。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588747401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183097,"user_name":"redj","can_delete":false,"product_type":"c1","uid":1251309,"ip_address":"","ucode":"9BD7A1E0FEA881","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ed/f79dd0f6.jpg","comment_is_top":false,"comment_ctime":1582952338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582952338","product_id":100046201,"comment_content":"老师的话：多个网络连接的 IO 可以注册到一个复用器（select）上，当用户进程调用了 select，那么整个进程会被阻塞","like_count":0},{"had_liked":false,"id":183089,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1582950673,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1582950673","product_id":100046201,"comment_content":"老师好，IO多路复用也是为了解决C10K问题吧，能具体讲一下虚拟内存的作用吗，什么时候会用到，为什么要用。","like_count":0,"discussions":[{"author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258975,"discussion_content":"虚拟内存相关可以复习一下操作系统，他的目的在于给每个操作系统下管理的进程有独占全部内存的“幻觉”。所以，有可能属于不同进程的虚拟地址指向同一块物理内存，这样可以实现进程间IPC。当同样的机制发生在用户进程和内核之间，这样可以用来实现系统级零拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588747626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259109,"discussion_content":"想问下你说的0拷贝是指系统内核和用户内核之间的0拷贝吧，数据从磁盘到内核还是要拷贝一次的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588760884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258975,"ip_address":""},"score":259109,"extra":""},{"author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1253384,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","nickname":"Dovelol","note":"","ucode":"9B5DDF7720F307","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260669,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588892397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259109,"ip_address":""},"score":260669,"extra":""}]}]},{"had_liked":false,"id":182772,"user_name":"yhh","can_delete":false,"product_type":"c1","uid":1105102,"ip_address":"","ucode":"B566981788B6A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/ce/a144dea1.jpg","comment_is_top":false,"comment_ctime":1582863260,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582863260","product_id":100046201,"comment_content":"老师好，请教个问题，我看 零拷贝 虚拟内存 那张图，mmap是也能用于网络io吗？","like_count":0,"discussions":[{"author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258981,"discussion_content":"mmap是本地机进程间IPC机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588748202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182295,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1582765175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582765175","product_id":100046201,"comment_content":"关于网络这块，希望对epoll也进行一下深入对比啊！毕竟不管是nginx netty都使用它进行优化","like_count":0},{"had_liked":false,"id":182230,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1582730835,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1582730835","product_id":100046201,"comment_content":"接上条，我重新思考了下；应该是这样，这里的事件驱动不是常规的客户端请求，而是指请求处理完后的状态变化，例如，当socket状态变为ready for reading时，相当于触发了新的请求，那么select会找到对应的handler进行调用；<br>所以，我刚才举得例子，即使只有一个客户端请求，也会即使的收到服务端的回复；因为这里所谓的event-driven不是指传统意义上的客户端请求的驱动，而是socket经handler处理后状态的变化进行的驱动。<br>请问我的理解对吗？","like_count":0,"discussions":[{"author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258984,"discussion_content":"不太理解你所说的请求处理完后的状态变化是啥意思？select返回意味着它监管的fdset中有fd可以被处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588748399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1099750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","nickname":"川杰","note":"","ucode":"815211E1D698E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259684,"discussion_content":"我就是不理解所谓的fdset是什么意思，fd是什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588810986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258984,"ip_address":""},"score":259684,"extra":""},{"author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1099750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","nickname":"川杰","note":"","ucode":"815211E1D698E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260668,"discussion_content":"fd是file descriptor的缩写，fdset是一组fd的集合。你去查一下linux下select系统调用原型就更清楚了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588892365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259684,"ip_address":""},"score":260668,"extra":""},{"author":{"id":1099750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","nickname":"川杰","note":"","ucode":"815211E1D698E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1876974,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7ibQdsjXeG9eibBAQ8JPzhtaJj8P6YKeYjsg22qUCyGM9nOZkD0VKb4L1YyqBIy0kja6RFUf28Diar1Y6Wr6IhMZp/132","nickname":"Geek_f49323","note":"","ucode":"0B771719D1407E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260801,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588902921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260668,"ip_address":""},"score":260801,"extra":""}]},{"author":{"id":1605134,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7e/0e/b828909c.jpg","nickname":"益","note":"","ucode":"80B610EAE2EFCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194297,"discussion_content":"顶问题。老师方便回答一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583203735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182092,"user_name":"小脚丫","can_delete":false,"product_type":"c1","uid":1058028,"ip_address":"","ucode":"51537B229F15F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCGgico4wOAghiaVXDAhGZr8EYpJOk3AdrePWaHLsWzPNk0tMzax5ibaeztcmysNnxS53ibuAlPjHvxg/132","comment_is_top":false,"comment_ctime":1582706979,"is_pvip":false,"replies":[{"id":"70510","content":"私聊","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582720072,"ip_address":"","comment_id":182092,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1582706979","product_id":100046201,"comment_content":"何老师您好，我是京东员工，看到您这章关于零拷贝的介绍，突然想起来个之前使用jmq的问题想请教您下，Jmq抛出了ERROR com.jd.jmq.common.network.netty.NettyTransport - netty channel exception 10.194.143.76:50088<br>io.netty.handler.codec.DecoderException: java.lang.IndexOutOfBoundsException这个异常，导致我们应用的堆内存里都是heapbytebuffer这个对象，占用了几个G，之后导致不停的full gc。我们的jmq没有使用直接内存吗？ 从现象看，感觉数据都被拷贝到了堆内存中。","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485222,"discussion_content":"私聊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582720072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199732,"discussion_content":"哈哈哈哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583599125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1589989,"avatar":"https://static001.geekbang.org/account/avatar/00/18/42/e5/61cfe267.jpg","nickname":"Eclipse","note":"","ucode":"E7EB0BA99FA644","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187588,"discussion_content":"有招聘信息吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582736675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606999,"avatar":"https://static001.geekbang.org/account/avatar/00/18/85/57/0811c8da.jpg","nickname":"仙女养的🐷","note":"","ucode":"6695C4960475F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187488,"discussion_content":"请问这个因为啥呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582732022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1221705,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/49/1c8598d1.jpg","nickname":"军舰","note":"","ucode":"C7E97415F5196A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1606999,"avatar":"https://static001.geekbang.org/account/avatar/00/18/85/57/0811c8da.jpg","nickname":"仙女养的🐷","note":"","ucode":"6695C4960475F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189014,"discussion_content":"进入京东私聊😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582848414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":187488,"ip_address":""},"score":189014,"extra":""}]}]},{"had_liked":false,"id":181955,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1068163,"ip_address":"","ucode":"107606167D23E8","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/83/7788fc66.jpg","comment_is_top":false,"comment_ctime":1582684381,"is_pvip":true,"replies":[{"id":"70511","content":"这个也是","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582720085,"ip_address":"","comment_id":181955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582684381","product_id":100046201,"comment_content":"课后思考: RocketMQ使用mmap实现零拷贝","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485178,"discussion_content":"这个也是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582720085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181921,"user_name":"益","can_delete":false,"product_type":"c1","uid":1605134,"ip_address":"","ucode":"80B610EAE2EFCE","user_header":"https://static001.geekbang.org/account/avatar/00/18/7e/0e/b828909c.jpg","comment_is_top":false,"comment_ctime":1582680730,"is_pvip":false,"replies":[{"id":"71854","content":"看具体项目需要","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583733917,"ip_address":"","comment_id":181921,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1582680730","product_id":100046201,"comment_content":"请问.NET Core上有与Netty框架类似的网络通信框架吗？<br>请教老师，如果选择用gRPC开发接口服务，从底层原理角度，Java和.NET Core哪个更好呢？","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485168,"discussion_content":"看具体项目需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583733917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","nickname":"有米","note":"","ucode":"C9A10B7A67BC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199733,"discussion_content":"java是世界上最好的语言\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583599176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022452,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/f4/e0484cac.jpg","nickname":"崔伟协","note":"","ucode":"ACDEEDF2A10999","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186610,"discussion_content":"java,下一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582698528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1605134,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7e/0e/b828909c.jpg","nickname":"益","note":"","ucode":"80B610EAE2EFCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1022452,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/f4/e0484cac.jpg","nickname":"崔伟协","note":"","ucode":"ACDEEDF2A10999","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":194295,"discussion_content":"请教原因？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583203559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186610,"ip_address":""},"score":194295,"extra":""}]}]},{"had_liked":false,"id":181900,"user_name":"张先生","can_delete":false,"product_type":"c1","uid":1229114,"ip_address":"","ucode":"E5E11D15CAC1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/3a/2ce09963.jpg","comment_is_top":false,"comment_ctime":1582675975,"is_pvip":false,"replies":[{"id":"70558","content":"netty零拷贝有多种支持，包括它提供的很多buffer。在进行文件网络传输，也可以进行零拷贝的优化。在网络传输过程中没有优化。","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582764489,"ip_address":"","comment_id":181900,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582675975","product_id":100046201,"comment_content":"1.我的理解netty对应用层的零拷贝优化就是把做个tcp包做合并来减少频繁的cpu内核交互，但是cpu内核应该也有个大小限制吧？<br>2.零拷贝只是优化了服务器的开销，对于传输层并没有什么优化吧，因为传输层传输的包大小会受链路上路由可接收的包大小决定拆多少个包","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485161,"discussion_content":"netty零拷贝有多种支持，包括它提供的很多buffer。在进行文件网络传输，也可以进行零拷贝的优化。在网络传输过程中没有优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582764489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}