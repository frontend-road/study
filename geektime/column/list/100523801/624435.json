{"id":624435,"title":"05｜Concepts：解决模板接口的类型与约束定义难题","content":"<p>你好，我是卢誉声。</p><p>在上一讲中，我们了解到C++模板不仅具备强大的泛化能力，自身也是一种“图灵完备”的语言，掀起了C++之父Bjarne Stroustrup自己都没料到的“模板元编程”这一子领域。</p><p>但是，使用模板做泛型编程，最大的问题就是缺少良好的接口，一旦使用过程中出现偏差，报错信息我们难以理解，甚至无从下手。更糟的是，使用模板的代码几乎无法做到程序ABI层面兼容。这些问题的根本原因是C++语言本身缺乏模板参数约束能力，因此，既能拥有良好接口、高性能表达泛化，又能融入语言本身是非常困难的。</p><p>好在C++20标准及其后续演进中，为我们带来了Concepts核心语言特性变更来解决这一难题。那么它能为我们的编程体验带来多大的革新？能解决多少模板元编程的历史遗留问题？今天我们一起探究Concepts。</p><p>课程配套代码，点击<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>即可获取。</p><h2>定义Concepts</h2><p>首先我们看看Concepts是什么，它可不是横空出世的，C++20为模板参数列表添加了一个特性——约束，采用约束表达式对模板参数进行限制。约束表达式可以使用简单的编译期常量表达式，也可以使用C++20引入的requires表达式，并且支持约束的逻辑组合，这是对C++20之前enable_if和type_traits的进一步抽象。</p><!-- [[[read_end]]] --><p>在约束的基础上，C++20正式提出了Concepts，也就是由一组由约束组成的具名集合。</p><p>我们可以将一组通用的约束定义为一个concept，并且，在定义模板函数与模板类中，直接使用这些concept替换通用的typename和class，所以concept的定义必定是约束的表达式，定义方式就像这样。</p><pre><code class=\"language-c++\">template &lt;参数模板&gt;\nconcept 名称 = 约束表达式;\n</code></pre><p>看一个最简单的例子如何定义一个concept，使用 type_traits的简单版本。</p><pre><code class=\"language-c++\">template&lt;class T, class U&gt;\nconcept Derived = std::is_base_of&lt;U, T&gt;::value;\n</code></pre><p>这里定义了一个名为Derived的concept，有两个类型参数T和U，其中的约束定义为 <code>std::is_base_of&lt;U, T&gt;::value</code>，也就是判定U是否为T的基类。相比于传统基于SFINAE和enable_if的方式，这种约束定义明显更加清晰。</p><p>我们再来看一个更加具体的concept。</p><pre><code class=\"language-c++\">class BaseClass {\npublic:\n&nbsp;&nbsp;&nbsp; int32_t getValue() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;\n&nbsp;&nbsp;&nbsp; }\n};\n&nbsp;\ntemplate&lt;class T&gt;\nconcept DerivedOfBaseClass = std::is_base_of_v&lt;BaseClass, T&gt;;\n</code></pre><p>在这段代码中，我先定义了一个基类BaseClass，该类定义了一个成员函数getValue。我又定义了名为DerivedOfBaseClass的concept。需要注意的是，我在这里使用了一个C++17标准之后引入的工具变量模板is_base_of_v，相当于 <code>is_base_of&lt;BaseClass, T&gt;::value</code>。</p><p>简单来说，这里定义的concept，可以判定模板参数T是否为BaseClass的派生类，通过一些现代C++语法变换，我们定义的concept更易读和使用。</p><p>有了定义好的concept，如何使用呢，我写了一个例子。</p><pre><code class=\"language-c++\">template &lt;DerivedOfBaseClass T&gt;\nvoid doGetValue(const T&amp; a) {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Get value:\" &lt;&lt; a.getValue() &lt;&lt; std::endl;\n}\n&nbsp;\nclass DerivedClass: public BaseClass {\npublic:\n&nbsp;&nbsp;&nbsp; int32_t getValue() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;\n&nbsp;&nbsp;&nbsp; }\n};\n&nbsp;\nint32_t c2() {\n&nbsp;&nbsp;&nbsp; DerivedClass d;\n    doGetValue(d);\n&nbsp;\n&nbsp;&nbsp;&nbsp; BaseClass b;\n    doGetValue(b);\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>我们先从代码的第6行开始，定义一个名为DerivedClass的类，它继承BaseClass，并重新定义了函数getValue的具体实现。接着，在函数c2中，我们定义了两个类型分别为DerivedClass和BaseClass的对象，并调用函数doGetValue，在编译时进一步验证我们编写的基于concept的代码。</p><p>doGetValue是代码开头定义的一个模板函数，它的模板参数很特别，采用DerivedOfBaseClass定义了T，而非typename/class，这个意思是实例化时传入的模板参数T，必须符合DerivedOfBaseClass这个concept的要求。</p><p>现在，我们编译运行这段代码，可以看到输出是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/57/1cbf252bed16feb68c4ce4bc0c39d557.jpg?wh=1920x95\" alt=\"图片\"></p><p>那么，如果参数不是BaseClass的派生类，会发生什么呢？我们来看看后面这段代码。</p><pre><code class=\"language-c++\">class NonDerivedClass {\npublic:\n&nbsp;&nbsp;&nbsp; int32_t getValue() const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;\n&nbsp;&nbsp;&nbsp; }\n};\n&nbsp;\nint32_t c2() {\n&nbsp;&nbsp;&nbsp; NonDerivedClass n;\n&nbsp;&nbsp;&nbsp; doGetValue(n);\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>这段代码在编译时会报错，报错信息是这样。<br>\n<img src=\"https://static001.geekbang.org/resource/image/50/b8/5023c870768d73e1913506d70c37c0b8.jpg?wh=1990x502\" alt=\"\"></p><p>这段报错信息中，我们很容易知道，由于NonDerivedClass并非BaseClass的派生类，编译时发生了错误。</p><p>从这个案例看，如果C++模板通过concept进行了“约束”，调用者再也不需要从难以理解的模板编译错误中寻找问题根源了。基于concept的模板编译错误信息，极具指导性，<strong>足够简单、易于理解和纠错。</strong></p><p>不过讲到这里，关于这段代码，模板参数T的概念是DerivedOfBaseClass，函数doGetValue的参数必须符合DerivedOfBaseClass这个概念。</p><pre><code class=\"language-c++\">template&lt;class T&gt;\nconcept DerivedOfBaseClass = std::is_base_of_v&lt;BaseClass, T&gt;;\n</code></pre><p>你可能会有一个疑问：<strong>为何不使用虚函数来解决这个问题呢？</strong>如果将getValue定义成虚函数，并将doGetValue的参数类型设定成const BaseClass&amp;，不也可以实现一样的效果吗？</p><p>事实上，虚函数是基于虚函数表等特性来实现的，会对调用性能产生一定的损耗，也可能因为不同编译器内存模型，产生ABI兼容性问题。但是，如果用模板，编译器就可以通过编译期判定，直接消除虚函数造成的性能副作用，同时，编译器也可以充分利用各种跨函数调用的优化方式，生成性能更好的代码，有效提升生成代码的质量。因此，很多工程场景下，这种方法比基于虚函数实现的多态更加合理。</p><p>所以，我们可以看到，<strong>通过约束与concept这两个C++核心语言特性变更（高级抽象），实现了对模板参数列表与参数的约束的逻辑分离</strong>。这不仅能提升模板函数或类接口的质量，还可以彻底提升代码的可读性。</p><p>如果从语言设计的角度进一步探讨，Concepts，本质就是让开发者能够定义在模板参数列表中直接使用的“类型”，与我们在函数的参数列表上使用的由class定义的类型，理论上讲，是一样的。</p><p>所以，在面向对象的编程思想中，我们思考的如何设计清晰且可复用的class，那从此以后，在泛型编程中我们就需要转变一下，思考如何设计清晰且可复用的concept。可以说，<strong>从C++20标准及其演进标准之后，concept之于C++泛型编程，正如class之于C++面向对象。</strong></p><p>了解了使用Concepts的优点，接下来，我们看看它的高级用法。我们会从requires关键字定义的约束表达式开始，掌握逻辑操作符的组合用法，之后会了解一下requires子句的概念、约束顺序规则，涵盖Concepts的各个重要方面。</p><h2>约束表达式</h2><p>定义Concepts时我们提到，一个concept被定义为约束表达式（constraint expression）。那什么是约束表达式呢？</p><p>从定义上来说，约束表达式是“用于描述模板参数要求的操作符与操作数的序列”，你也可以简单理解为布尔常量表达式。<strong>约束表达式，本身是通过逻辑操作符的方式进行组合的，用于定义更复杂的concept。</strong></p><p>约束的逻辑操作符一共有三种。</p><ul>\n<li>合取式（conjunctions）</li>\n<li>析取式（disjunctions）</li>\n<li>原子约束（atomic constraints）</li>\n</ul><p>编译器实例化一个模板函数或者模板类时，会按照一定顺序，逐一检查模板参数是否符合所有的约束要求（检查顺序具体可参考课后小知识）。我们来深入理解一下这几种逻辑操作符。</p><h3>合取式</h3><p>合取（conjunctions）通俗易懂的说法就是“逻辑与”，AND。在约束表达式中，合取式就是通过 <code>&amp;&amp;</code> 操作符，把两个约束表达式连接到一起的。</p><p>我们来看三个例子。</p><pre><code class=\"language-c++\">template&lt;class T&gt;\nconcept Integral = std::is_integral_v&lt;T&gt;;\n&nbsp;\ntemplate&lt;class T&gt;\nconcept SignedIntegral = Integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n&nbsp;\ntemplate&lt;class T&gt;\nconcept UnsignedIntegral = Integral&lt;T&gt; &amp;&amp; !SignedIntegral&lt;T&gt;;\n</code></pre><p>首先，定义了一个名为Integral的concept，表示参数模板类型需要为整型。</p><p>接着，定义了名为SignedIntegral的concept，表示参数模板类型需要为有符号整型。定义体就是一个合取式，<code>&amp;&amp;</code>  表示这个concept必须同时满足 <code>Integral&lt;T&gt;</code> 这一concept和 <code>std::is_signed_v&lt;T&gt;</code> 这一编译时常量表达式。</p><p>最后，我还定义了名为UnsignedIntegral的concept，表示参数模板类型需要为无符号整型。其定义体表示必须满足 <code>Integral&lt;T&gt;</code> 和 <code>!SignedIntegral&lt;T&gt;</code> 这两个concept。</p><p><strong>编译器在处理合取式的时候，要求左右两侧约束都必须满足。检测过程遵循逻辑与表达式自左向右的短路运算原则</strong>，也就是说，如果左侧表达式不满足要求，右侧表达式也不会执行。因此，即使右侧表达式执行存在问题，也不会被执行，引发检测失败。你可以结合后面的代码加深理解。</p><pre><code class=\"language-c++\">template&lt;typename T&gt;\nconstexpr bool get_value() { return T::value; }\n&nbsp;\ntemplate&lt;typename T&gt;\n&nbsp;&nbsp;&nbsp; requires (sizeof(T) &gt; 1 &amp;&amp; get_value&lt;T&gt;())\nvoid f(T) {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"template version\" &lt;&lt; std::endl;\n}\n\nvoid f(int32_t) {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"int version\" &lt;&lt; std::endl;\n}\n\nvoid c15() {\n&nbsp;&nbsp;&nbsp; f('A');\n}&nbsp;\n</code></pre><p>我们在调用函数f的时候，由于 <code>'A'</code> 的类型为char，其sizeof为1，因此sizeof(T) &gt; 1为false。所以 <code>get_value&lt;T&gt;()</code> 是不会执行的，这里并不会引发编译错误（char类型没有::value）。虽然有些反直觉，但这就是合取式的短路运算原则。</p><h3>析取式</h3><p>析取（disjunctions）就是“逻辑或”，OR。在约束表达式中，析取式就是通过 <code>||</code> 操作符将两个约束表达式连接到一起。具体我们来看代码。</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nconcept Integral = std::is_integral_v&lt;T&gt;;\n&nbsp;\ntemplate &lt;class T&gt;\nconcept FloatingPoint = std::is_floating_point_v&lt;T&gt;;\n&nbsp;\ntemplate &lt;class T&gt;\nconcept Number = Integral&lt;T&gt; || FloatingPoint&lt;T&gt;;\n</code></pre><p>这里定义了三个concept：Integral、FloatingPoint和Number，其中Number这个concept通过 <code>||</code>  将Integral和FloatingPoint这两个concept连接在一起，表达只要为整型或者浮点型即可。</p><p>编译器在处理析取式的时候，<strong>要求左右两侧约束满足其一即可，检测过程遵循逻辑或表达式自左向右的短路运算原则</strong>，也就是只要左侧表达式满足要求，右侧表达式就不会执行。因此，即使这时右侧表达式执行存在问题，也不会被执行引发检测失败。</p><h3>原子约束</h3><p>原子约束（atomic constraints）是最后一种约束表达式，本身是一个很简单的概念，但是对编译器解析约束表达式非常重要，我们单独讲一下。</p><p>原子约束，由表达式E与E的参数映射组成。参数映射指的是E中受约束实体的模板参数（template parameter）与实例化时使用的模板实参（template argument）之间的映射关系。原子约束是在约束规范化过程中形成的，一个原子约束不能包含逻辑与/或表达式。</p><p>编译器在实例化过程中，会检查参数是否满足原子约束。编译器会根据参数映射关系，将模板实参替换成表达式E中的形参。</p><ul>\n<li>如果替换后的表达式是一个非法类型或者非法表达式，说明当前实例化参数不满足约束。</li>\n<li>否则，编译器会对表达式的值进行左右值转换，只有得到的右值类型是bool类型，并且值为true时，编译器才认定为满足约束，否则就是不满足约束。</li>\n</ul><p>值得一提的是，E的值必须是bool类型，不允许通过任何隐式转换变为bool型（这个和C++中的if不一样）。听起来有些复杂，我们看一段代码，很好理解。</p><pre><code class=\"language-c++\">template&lt;typename T&gt;\nstruct S {\n&nbsp;&nbsp;&nbsp; constexpr operator bool() const { return true; }\n};\n&nbsp;\ntemplate&lt;typename T&gt;\n&nbsp;&nbsp;&nbsp; requires (S&lt;T&gt;{})\nvoid f1(T) {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Template\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename T&gt;\n&nbsp;&nbsp;&nbsp; requires (1)\nvoid f2(T) {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Template\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename T&gt;\n&nbsp;&nbsp;&nbsp; requires (static_cast&lt;bool&gt;(S&lt;T&gt;{}))\nvoid f3(T) {\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"Template\" &lt;&lt; std::endl;\n}\n</code></pre><p>在这段代码中，函数f1和f2的约束都会编译失败，只有f3才是正确的原子约束表达式。</p><p>另外，如果在源代码中，两个原子约束表达式相同，参数映射也相等，那么这两个原子约束就是完全相同的。我们看下面这段代码。</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nconcept Floating = std::is_floating_point_v&lt;T&gt;;\n\ntemplate &lt;class T&gt;\nconcept BadNumber = std::is_floating_point_v&lt;T&gt; &amp;&amp; std::is_floating_point_v&lt;T&gt;;\n\ntemplate &lt;class T&gt;\nconcept Number = Floating&lt;T&gt; &amp;&amp; std::is_floating_point_v&lt;T&gt;;\n\ntemplate &lt;Floating T&gt; // #1\nvoid func(T) {}\n\ntemplate &lt;BadNumber T&gt; // #2\nvoid func(T) {}\n\ntemplate &lt;Number T&gt; // #3\nvoid func(T) {}\n</code></pre><p>在这段代码中，如果调用func同时匹配#1和#2，会相互冲突导致编译失败，而同时匹配#1和#3不会。这是因为，BadNumber中第一个 <code>is_floating_v</code> 和Floating中的 <code>is_floating_v</code>，并不会识别为相同的原子约束，导致编译器认为匹配了两个版本，不知道选择哪个版本而失败。</p><p>Number中第一个原子约束直接使用了Floating，所以Number属于Floating的派生约束。虽然两个约束都能匹配，但Number是比Floating更精准的匹配，所以编译器最后会选择#3版本，并不会发生编译错误。</p><p>作为补充，编译器为了后续进行统一的语法和语义分析，会在约束表达式的解析过程中对约束表达式进行规范化。</p><p>学习了三种约束表达式，我们讨论几个重要细节，包括requires表达式、requires子句以及约束顺序等高级话题。</p><h2>requires关键字</h2><p>我们在前面已经看到了由type_traits和requires构成的concept，针对requires表达式和requires子句这两个概念，我们简单说明一下。</p><h3>requires表达式</h3><p>跟type_traits类似，requires表达式本身就是一个谓词。</p><p>requires与普通约束表达式不同，如果其定义体在完成参数替换后，存在非法的类型或表达式，或者requires定义中的约束存在冲突时，会返回false。反之，如果完成参数替换后语法检查以及约束检查全部成功之后，才会返回true。</p><p>定义方式是这样。</p><pre><code class=\"language-c++\">requires (可选参数) { // 表达式结果必须为 bool 类型\n    表达式_1\n    表达式_2\n    ...\n}\n</code></pre><p>“可选参数”声明了一系列局部变量（不支持提供默认参数），大括号中的所有表达式都可以访问这些变量，如果表达式使用了未声明变量，编译时会报错。</p><p>requires大括号内，可以定义几种不同的表达式，分别用于约束接口或函数行为、变量、类型，同时还可以对约束进行组合和嵌套。在这里，我用一个例子来说明这几种不同表达式的用法。</p><pre><code class=\"language-c++\">template&lt;typename T&gt;\nconcept Histogram = requires(T h1, T h2) {\n    h1.getMoments();         // 要求有getMoments接口\n    T::count;                // 要求有静态变量count\n    h1.moments;              // 要求有成员变量moments\n    h1 + h2;                 // 要求对象能够进行+操作\n\n    typename T::type;        // 要求存在类型成员type\n    typename std::vector&lt;T&gt;; // 要求能够模板实例化并与std::vector组合使用\n    \n    { h1.getSubHistogram() } -&gt; same_as&lt;T&gt;;    // 要求接口返回类型与T一致\n    { h1.getUnit() } -&gt; convertible_to&lt;float&gt;; // 要求接口返回类型能转换成float，本质上接口返回类型可能是double\n    { h1 = std::move(h2) } noexcept;          // 要求表达式不能抛出异常\n    \n    requires sizeof(T) &gt; 4;\n};\n</code></pre><p>requires表达式定义中的约束分为四种类型，分别是：</p><ul>\n<li>基本约束：第3到6行，这种独立的、不以关键词开头的表达式语句，都是基本约束，只会进行词法、语法和语义的正确性检查，并不会真实执行。编译器检查通过，则约束检查通过，否则检查失败。</li>\n<li>类型约束：第8到9行，这种使用typename开头的表达式语句是类型约束，表达式用于描述一个类型，如果类型存在，则约束检查通过，否则检查失败。</li>\n<li>组合约束：第11到13行，这种类似“<strong>{} [noexcept] -&gt;约束</strong>”形式的都是组合约束，编译器会执行{}中的语句，并检查其结果类型是否符合后续约束，如果符合约束则检查通过，否则检查失败。此外，还可以通过可选的noexcept检查表达式是否会抛出异常。</li>\n<li>嵌套约束：第15行，requires开头的就是嵌套约束，用于嵌套新的requires表达式，如果requires表达式结果为true则检查通过，否则检查失败。</li>\n</ul><h3>requires子句</h3><p>下面我们看一看，相较于requires表达式这一谓词，requires中出现的另一个关键字——requires子句，又是怎么回事？</p><p>由于requires子句和requires表达式并不是相同的概念，所以我们可能会看到这种代码：</p><pre><code class=\"language-c++\">export template &lt;typename T1, typename  T2&gt;\n&nbsp;&nbsp;&nbsp; requires requires (T1 x, T2 y) { x + y; }\nstd::common_type&lt;T1, T2&gt; func(\n&nbsp;&nbsp;&nbsp; T1 arg1, T2 arg2\n) {\n    return arg1 + arg2;\n}\n</code></pre><p>我们在模板头上定义了一条requires子句，它表达了模板参数应该在什么条件下工作，在这里我们还可以定义更复杂或具体的约束表达式。</p><p>这里有两个requires，但是含义完全不同，<code>requires (T1 x,T2 y) { x + y; }</code> 就是requires子句，而前面的requires就是requires子句的开头，后面所需的是一个约束表达式，只不过requires表达式是约束表达式的一种，所以这是合法的代码。</p><p>requires子句存在的意义是判断它所约束的声明在“上下文”中是否可行。所谓上下文，分为三种。</p><p>1.函数模板：是在执行重载决议中进行的。</p><p>2.模板类：在决策适合的特化版本当中。</p><p>3.模板类中的成员函数：决策当显式实例化时是否生成该函数。</p><h2>约束顺序</h2><p>在前面，我们看到了给模板施加约束后，受约束的版本比未受约束的版本更优。但是，如果两个版本同样含有约束且都满足，哪个最优呢？</p><p>编译器在后续分析前，会将模板中所有的具名concept和requires表达式都替换成其定义，接着进行正规化，直到所有的约束变成原子约束及其合取式或析取式为止。然后分析约束之间的蕴含关系，并根据约束偏序选择最优的版本。</p><p>这里解释一下蕴含关系。针对约束P和约束Q，只有通过P和Q中的原子约束证明P蕴含Q，才认定约束P蕴含约束Q（编译器并不会分析表达式和类型来判定蕴含关系，比如N&gt;0并不蕴含N&gt;=0）。</p><p>蕴含关系非常重要，决定了约束的偏序。如果声明D1所受约束蕴含D2所受约束（或者D2不受约束），并且声明D2所受约束并不蕴含声明D1所受约束，我们就可以认为，声明D1的约束比声明D2的约束更加精准。这说明，当编译器选择声明版本时，如果参数同时符合D1和D2所受约束，编译器会选择D1，也就不会引起编译错误。</p><p>只有了解并利用约束的偏序规则，我们才能更好地组织代码。</p><h2>总结</h2><p>今天我们了解了什么是Concepts，它是由一组由约束组成的具名集合，约束支持普通编译期常量表达式，同时支持采用requires表达式，对模板参数进行更复杂的约束检查，并且支持约束的逻辑组合，这是对C++20之前enable_if和type_traits的进一步抽象。</p><p>在现代C++20标准及其后续演进中，约束的顺序通过概念约束进行决策，而约束的合取式、析取式以及Concepts，在模板函数重载决议与类模板特化决策过程中，扮演了核心角色。编译器通过约束的偏序规则决策出最优解。</p><p>Concepts这种高级抽象，妥善解决了模板接口的类型与约束定义难题，同时也改进了约束顺序决策。</p><p>结合C++泛型编程，约束表达是一个较为复杂的议题，如何正确且有效地利用这一全新特性呢？下一讲，我们将通过实战案例来学习。</p><h2>课后思考</h2><p>我们不止一次提到编译时谓词，你如何理解“编译时计算”和“谓词”？</p><p>不妨在这里分享你的见解，与大家一起分享。我们一同交流。下一讲见！</p><h2>课后小知识</h2><p><img src=\"https://static001.geekbang.org/resource/image/71/d8/71038eda20df7e4cc293eeed79682bd8.jpg?wh=3500x3455\" alt=\"\"></p>","comments":[{"had_liked":false,"id":366918,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1674616913,"is_pvip":false,"replies":[{"id":133864,"content":"Q1：std::is_base_of&lt;T1,T2&gt;严格来说是判断T2是否是T1的派生类或相同类型，而不只是派生类。\n\n\nQ2：原子约束f1和f2的失败原因是这两个都需要隐式转换成bool，所以原文中说“E的值必须是bool类型，不允许通过任何隐式转换变为bool型”。\nF1的requires中的S&lt;T&gt;{}是构造了一个S&lt;T&gt;类型的对象，这个构造对象的语法就是C++11里的统一初始化表达式，相当于S&lt;T&gt;()。然后S这个类有一个operator bool()的成员函数，可以将一个S类型的对象隐式转换成bool类型，这种隐式转换在原子约束中是不允许的。\n原子约束是一个概念，没有关键字。如果想要容易理解一点，非严格来说，基本上不是合取或者析取的合法约束一般就是原子约束了，也就是约束的基本组成部分。\n","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1675349683,"ip_address":"江苏","comment_id":366918,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教老师两个问题：\nQ1：b不是派生类，为什么不报错？\nBaseClass b;    doGetValue(b);  b是BaseClass，不是BaseClass的派生类，为什么不报错？\nQ2：原子约束的f1和f2为什么失败？\nf1前面加的 requires (S&lt;T&gt;{})表示什么意思？为什么失败？\n原子约束有关键字吗？或者说，怎么看出来一个约束是原子约束？\n另外，struct S中的constexpr operator什么意思？","like_count":4,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601690,"discussion_content":"Q1：std::is_base_of&lt;T1,T2&gt;严格来说是判断T2是否是T1的派生类或相同类型，而不只是派生类。\n\n\nQ2：原子约束f1和f2的失败原因是这两个都需要隐式转换成bool，所以原文中说“E的值必须是bool类型，不允许通过任何隐式转换变为bool型”。\nF1的requires中的S&lt;T&gt;{}是构造了一个S&lt;T&gt;类型的对象，这个构造对象的语法就是C++11里的统一初始化表达式，相当于S&lt;T&gt;()。然后S这个类有一个operator bool()的成员函数，可以将一个S类型的对象隐式转换成bool类型，这种隐式转换在原子约束中是不允许的。\n原子约束是一个概念，没有关键字。如果想要容易理解一点，非严格来说，基本上不是合取或者析取的合法约束一般就是原子约束了，也就是约束的基本组成部分。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675349683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379349,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1691774037,"is_pvip":false,"replies":[{"id":138242,"content":"这个requires子句的意思是，只有x+y可以编译成功才匹配这个版本，所以不要求x+y一定是bool型，只要求两个类型可以相加（或者具备operator+重载）。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1692017130,"ip_address":"上海","comment_id":379349,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"requiresexport template &lt;typename T1, typename  T2&gt;\n    requires requires (T1 x, T2 y) { x + y; }\nstd::common_type&lt;T1, T2&gt; func(\n    T1 arg1, T2 arg2\n) {\n    return arg1 + arg2;\n}\n\n没看明白requires requires (T1 x, T2 y) { x + y; }是啥意思，如果第一个requires是子句的关键字，requires (T1 x, T2 y) { x + y; }是表达式的话，那不是说这里必须是bool型的吗？x+y不一定是bool型的吧？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625650,"discussion_content":"这个requires子句的意思是，只有x+y可以编译成功才匹配这个版本，所以不要求x+y一定是bool型，只要求两个类型可以相加（或者具备operator+重载）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692017130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":625653,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692018653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":625650,"ip_address":"北京","group_id":0},"score":625653,"extra":""}]}]},{"had_liked":false,"id":391597,"user_name":"lmnsds","can_delete":false,"product_type":"c1","uid":1069422,"ip_address":"北京","ucode":"0ED5B1443059DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/6e/757d42a0.jpg","comment_is_top":false,"comment_ctime":1718616212,"is_pvip":false,"replies":[{"id":142712,"content":"所谓偏序就是判断两个约束之间的严格程度，如果约束A包含约束B，或者约束A与约束B一致，那么约束A至少与约束B一样严格，约束A就在偏序上大于约束B，如果同时匹配约束A与B，就会选择A（一致的时候选择B也一样）。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1721919288,"ip_address":"上海","comment_id":391597,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"编译器如何判断约束之间的偏序关系呢？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648660,"discussion_content":"所谓偏序就是判断两个约束之间的严格程度，如果约束A包含约束B，或者约束A与约束B一致，那么约束A至少与约束B一样严格，约束A就在偏序上大于约束B，如果同时匹配约束A与B，就会选择A（一致的时候选择B也一样）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1721919288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379619,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1692198628,"is_pvip":false,"replies":[{"id":138324,"content":"requires后边接约束表达式，表示模板参数满足约束表达式要求。约束表达式是一种用于检测类型的表达式，如果将模板参数带入到约束表达式后，约束表达式固定返回常量true ，则表示模板参数满足约束表达式的约束。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1692384304,"ip_address":"上海","comment_id":379619,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"requires 后边接约束表达式，约束表达式应该怎么理解？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625985,"discussion_content":"requires后边接约束表达式，表示模板参数满足约束表达式要求。约束表达式是一种用于检测类型的表达式，如果将模板参数带入到约束表达式后，约束表达式固定返回常量true ，则表示模板参数满足约束表达式的约束。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692384304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371481,"user_name":"MrDuin","can_delete":false,"product_type":"c1","uid":2456646,"ip_address":"辽宁","ucode":"DDE721849E39C2","user_header":"https://static001.geekbang.org/account/avatar/00/25/7c/46/3809b32e.jpg","comment_is_top":false,"comment_ctime":1679982051,"is_pvip":false,"replies":[{"id":135573,"content":"可以阅读一下第23讲，了解一下现代C++标准下的“洋葱”理论，希望能够帮助到你。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1680007302,"ip_address":"上海","comment_id":371481,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"C++20的新特性，对yC++语言的心里负担更大了。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611283,"discussion_content":"可以阅读一下第23讲，了解一下现代C++标准下的“洋葱”理论，希望能够帮助到你。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680007302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}