{"id":740376,"title":"12｜Pipeline与Valve：如何实现容器间的调用、事务管理、权限验证？","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上一节课我们把项目结构进一步抽象成两层Container，分别是Context和Wrapper，从而实现一个服务器管理多个容器，而容器又可以管理多个Servlet，层层嵌套，提升了容器的扩展性。然后我们在这个基础上，参考Tomcat的项目结构，进行对应的调整，让它更贴近Tomcat源码本身。</p><p>接下来我们再转向通用部分的组件，首先考虑的就是日志。日志可以有效帮助我们调试程序运行过程中的问题，在合理的地方打印日志也可以帮助我们了解服务器的运行情况，所以我们接下来会<strong>定义通用的日志组件</strong>。</p><p>在日志组件定义完毕后，我们紧接着会学习<strong>职责链模式</strong>在Tomcat中的应用，当服务器要调用某个具体的Servlet时，是经过这些Contaienr一层一层调用的，所以Tomcat中每个Container的invoke()都是通过职责链模式调用的。</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/de/4e90331a1b5ef8ba077c7cbd5d3670de.png?wh=1920x1147\" alt=\"图片\"></p><p>我们一起来动手实现。</p><h2>项目结构</h2><p>这节课我们新增Logger、Pipeline、Valve、ValveContext接口，以及处理日志Logger与Valve的实现类等众多Java文件，具体内容后面我们会详细说明。你可以看一下现在这个项目的目录结构。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ com\n│  │  │  │  ├─ minit\n│  │  │  │  │  ├─ connector\n│  │  │  │  │  │  ├─ http\n│  │  │  │  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  │  │  │  ├─ HttpConnector.java\n│  │  │  │  │  │  │  ├─ HttpHeader.java\n│  │  │  │  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  │  │  │  ├─ HttpRequestImpl.java\n│  │  │  │  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  │  │  │  ├─ HttpResponseImpl.java\n│  │  │  │  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  │  │  │  ├─ StatisResourceProcessor.java\n│  │  │  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  │  ├─ core\n│  │  │  │  │  │  ├─ ContainerBase.java\n│  │  │  │  │  │  ├─ StandardContext.java\n│  │  │  │  │  │  ├─ StandardContextValve.java\n│  │  │  │  │  │  ├─ StandardPipeline.java\n│  │  │  │  │  │  ├─ StandardWrapper.java\n│  │  │  │  │  │  ├─ StandardWrapperValve.java\n│  │  │  │  │  ├─ logger\n│  │  │  │  │  │  ├─ Constants.java\n│  │  │  │  │  │  ├─ FileLogger.java\n│  │  │  │  │  │  ├─ LoggerBase.java\n│  │  │  │  │  │  ├─ SystemErrLogger.java\n│  │  │  │  │  │  ├─ SystemOutLogger.java\n│  │  │  │  │  ├─ session\n│  │  │  │  │  │  ├─ StandardSession.java\n│  │  │  │  │  │  ├─ StandardSessionFacade.java\n│  │  │  │  │  ├─ startup\n│  │  │  │  │  │  ├─ BootStrap.java\n│  │  │  │  │  ├─ util\n│  │  │  │  │  │  ├─ CookieTools.java\n│  │  │  │  │  │  ├─ StringManager.java\n│  │  │  │  │  ├─ valves\n│  │  │  │  │  │  ├─ AccessLogValve.java\n│  │  │  │  │  │  ├─ ValveBase.java\n│  │  │  │  ├─ Connector.java\n│  │  │  │  ├─ Container.java\n│  │  │  │  ├─ Context.java\n│  │  │  │  ├─ Logger.java\n│  │  │  │  ├─ Pipeline.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ Valve.java\n│  │  │  │  ├─ ValveContext.java\n│  │  │  │  ├─ Wrapper.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  │  ├─ TestServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><h2>引入日志组件</h2><p>首先我们开始着手定义我们服务器的通用日志组件，先看一下Logger接口的定义。</p><pre><code class=\"language-java\">package com.minit;\npublic interface Logger {\n    public static final int FATAL = Integer.MIN_VALUE;\n    public static final int ERROR = 1;\n    public static final int WARNING = 2;\n    public static final int INFORMATION = 3;\n    public static final int DEBUG = 4;\n    public String getInfo();\n    public int getVerbosity();\n    public void setVerbosity(int verbosity);\n    public void log(String message);\n    public void log(Exception exception, String msg);\n    public void log(String message, Throwable throwable);\n    public void log(String message, int verbosity);\n    public void log(String message, Throwable throwable, int verbosity);\n}\n</code></pre><p>我们可以看到接口主要定义了不同的日志级别，以及重载了多个log方法，支持不同的传参。</p><p>接下来我们在Container接口里新增与Logger相关的Getter和Setter方法定义，用作Container的通用实现，你可以看一下示例代码。</p><pre><code class=\"language-java\">package com.minit;\npublic interface Container {\n    public Logger getLogger();\n    public void setLogger(Logger logger);\n}\n</code></pre><p>有了这些定义之后，我们在之前已经定义好的/com/minit/logger目录下提供LoggerBase作为Logger接口的抽象实现类，主体如下：</p><pre><code class=\"language-java\">package com.minit.logger;\npublic abstract class LoggerBase implements Logger {\n    protected int debug = 0;\n    protected static final String info = \"com.minit.logger.LoggerBase/1.0\";\n    protected int verbosity = ERROR;\n    public int getDebug() {\n        return (this.debug);\n    }\n    public void setDebug(int debug) {\n        this.debug = debug;\n    }\n    public String getInfo() {\n        return (info);\n    }\n    public int getVerbosity() {\n        return (this.verbosity);\n    }\n    public void setVerbosity(int verbosity) {\n        this.verbosity = verbosity;\n    }\n    public void setVerbosityLevel(String verbosity) {\n        if (\"FATAL\".equalsIgnoreCase(verbosity))\n            this.verbosity = FATAL;\n        else if (\"ERROR\".equalsIgnoreCase(verbosity))\n            this.verbosity = ERROR;\n        else if (\"WARNING\".equalsIgnoreCase(verbosity))\n            this.verbosity = WARNING;\n        else if (\"INFORMATION\".equalsIgnoreCase(verbosity))\n            this.verbosity = INFORMATION;\n        else if (\"DEBUG\".equalsIgnoreCase(verbosity))\n            this.verbosity = DEBUG;\n    }\n    //这个log方法由上层业务程序员实现\n    public abstract void log(String msg);\n    \n    public void log(Exception exception, String msg) {\n        log(msg, exception);\n    }\n    //核心方法，printStackTrace，然后调用一个业务实现的log(msg)\n    public void log(String msg, Throwable throwable) {\n        CharArrayWriter buf = new CharArrayWriter();\n        PrintWriter writer = new PrintWriter(buf);\n        writer.println(msg);\n        throwable.printStackTrace(writer);\n        Throwable rootCause = null;\n        if  (throwable instanceof ServletException)\n            rootCause = ((ServletException) throwable).getRootCause();\n        if (rootCause != null) {\n            writer.println(\"----- Root Cause -----\");\n            rootCause.printStackTrace(writer);\n        }\n        log(buf.toString());\n    }\n    public void log(String message, int verbosity) {\n        if (this.verbosity &gt;= verbosity)\n            log(message);\n    }\n    public void log(String message, Throwable throwable, int verbosity) {\n        if (this.verbosity &gt;= verbosity)\n            log(message, throwable);\n    }\n}\n</code></pre><p>public void log(String msg, Throwable throwable)这个方法是核心，根据具体实现可以知道，当存在Exception异常时，后端会调用printStackTrace抛出异常，然后调用abstract void log(String msg)方法，记录日志，这个方法是抽象方法，所以交给具体的实现类去记录。</p><p>接下来我们再定义通用类，为后续定义实现类做准备。首先在/com/minit/util包内定义StringManager工具类，这个类的作用在于提供单独的实例用来管理各自包下的日志打印，只需要调用getManager方法即可，不需要频繁创建日志打印对象。主体内容如下所示：</p><pre><code class=\"language-java\">package com.minit.util;\npublic class StringManager {\n    private StringManager(String packageName) {\n    }\n    public String getString(String key) {\n        if (key == null) {\n            String msg = \"key is null\";\n            throw new NullPointerException(msg);\n        }\n        String str = null;\n        str = key;\n        return str;\n    }\n    //用参数拼串\n    public String getString(String key, Object[] args) {\n        String iString = null;\n        String value = getString(key);\n        try {\n            //消除null对象\n            Object nonNullArgs[] = args;\n            for (int i=0; i&lt;args.length; i++) {\n                if (args[i] == null) {\n                    if (nonNullArgs==args) nonNullArgs=(Object[])args.clone();\n                    nonNullArgs[i] = \"null\";\n                }\n            }\n            //拼串\n            iString = MessageFormat.format(value, nonNullArgs);\n        } catch (IllegalArgumentException iae) {\n            StringBuffer buf = new StringBuffer();\n            buf.append(value);\n            for (int i = 0; i &lt; args.length; i++) {\n                buf.append(\" arg[\" + i + \"]=\" + args[i]);\n            }\n            iString = buf.toString();\n        }\n        return iString;\n    }\n    public String getString(String key, Object arg) {\n        Object[] args = new Object[] {arg};\n        return getString(key, args);\n    }\n    public String getString(String key, Object arg1, Object arg2) {\n        Object[] args = new Object[] {arg1, arg2};\n        return getString(key, args);\n    }\n    public String getString(String key, Object arg1, Object arg2,\n                            Object arg3) {\n        Object[] args = new Object[] {arg1, arg2, arg3};\n        return getString(key, args);\n    }\n    public String getString(String key, Object arg1, Object arg2,\n                            Object arg3, Object arg4) {\n        Object[] args = new Object[] {arg1, arg2, arg3, arg4};\n        return getString(key, args);\n    }\n    private static Map&lt;String,StringManager&gt; managers = new ConcurrentHashMap&lt;&gt;();\n    //每个package有相应的StringManager\n    public synchronized static StringManager getManager(String packageName) {\n        StringManager mgr = (StringManager)managers.get(packageName);\n        if (mgr == null) {\n            mgr = new StringManager(packageName);\n            managers.put(packageName, mgr);\n        }\n        return mgr;\n    }\n}\n</code></pre><p>再之后，我们为Logger分别定义Constants常量类、SystemErrLogger标准错误日志类，还有SystemOutLogger标准输出日志类，这几个类目前的定义比较简单，你可以看一下。</p><p>Constants常量类：</p><pre><code class=\"language-java\">package com.minit.logger;\npublic class Constants {\n    public static final String Package = \"com.minit.logger\";\n}\n</code></pre><p>SystemErrLogger标准错误日志类：</p><pre><code class=\"language-java\">package com.minit.logger;\npublic class SystemErrLogger extends LoggerBase {\n    protected static final String info =\n            \"com.minit.logger.SystemErrLogger/0.1\";\n    public void log(String msg) {\n        System.err.println(msg);\n    }\n}\n</code></pre><p>SystemOutLogger标准输出日志类：</p><pre><code class=\"language-java\">package com.minit.logger;\npublic class SystemOutLogger extends LoggerBase {\n    protected static final String info =\n            \"com.minit.logger.SystemOutLogger/1.0\";\n    public void log(String msg) {\n        System.out.println(msg);\n    }\n}\n</code></pre><p>有了前面的铺垫，接下来我们在这里定义LoggerBase其中一个实现类：FileLogger，这个类可以做到根据时间自动生成日志文件，你可以参考我给出的代码主体部分。</p><pre><code class=\"language-java\">package com.minit.logger;\npublic class FileLogger extends LoggerBase{\n    private String date = \"\";\n    private String directory = \"logs\";\n    protected static final String info = \"com.minit.logger.FileLogger/0.1\";\n    private String prefix = \"minit.\";\n    private StringManager sm = StringManager.getManager(Constants.Package);\n    private boolean started = false;\n    private String suffix = \".log\";\n    private boolean timestamp = true;\n    private PrintWriter writer = null;\n    public String getDirectory() {\n        return (directory);\n    }\n    public void setDirectory(String directory) {\n        String oldDirectory = this.directory;\n        this.directory = directory;\n    }\n    public String getPrefix() {\n        return (prefix);\n    }\n    public void setPrefix(String prefix) {\n        String oldPrefix = this.prefix;\n        this.prefix = prefix;\n    }\n    public String getSuffix() {\n        return (suffix);\n    }\n    public void setSuffix(String suffix) {\n        String oldSuffix = this.suffix;\n        this.suffix = suffix;\n    }\n    public boolean getTimestamp() {\n        return (timestamp);\n    }\n    public void setTimestamp(boolean timestamp) {\n        boolean oldTimestamp = this.timestamp;\n        this.timestamp = timestamp;\n    }\n    public void log(String msg) {\n        // 当前时间Construct the timestamp we will use, if requested\n        Timestamp ts = new Timestamp(System.currentTimeMillis());\n        String tsString = ts.toString().substring(0, 19);\n        String tsDate = tsString.substring(0, 10);\n        // 如果日期变化了，新生成一个log文件\n        // If the date has changed, switch log files\n        if (!date.equals(tsDate)) {\n            synchronized (this) {\n                if (!date.equals(tsDate)) {\n                    close();\n                    date = tsDate;\n                    open();\n                }\n            }\n        }\n        // 记录日志，带上时间戳 \n        if (writer != null) {\n            if (timestamp) {\n                writer.println(tsString + \" \" + msg);\n            } else {\n                writer.println(msg);\n            }\n        }\n    }\n    private void close() {\n        if (writer == null)\n            return;\n        writer.flush();\n        writer.close();\n        writer = null;\n        date = \"\";\n    }\n    private void open() {\n        File dir = new File(directory);\n        if (!dir.isAbsolute())\n            dir = new File(System.getProperty(\"catalina.base\"), directory);\n        dir.mkdirs();\n        // 打开日志文件 Open the current log file\n        try {\n            String pathname = dir.getAbsolutePath() + File.separator +\n                    prefix + date + suffix;\n            writer = new PrintWriter(new FileWriter(pathname, true), true);\n        } catch (IOException e) {\n            writer = null;\n        }\n    }\n}\n</code></pre><p>根据定义的属性，还有void log(String msg)方法，服务器会在 /logs/ 目录下生成一个类似minit.yyyy-MM-dd.log格式的日志文件，内部标明了这个文件创建的日期，如果记录的这个日期和当前日期不一样就关闭当前文件，同时再创建一个新的文件，这样就做到每天的日志文件不同，加以区分，方便定位问题。</p><p>里面的open()方法可以用来打开一个文件，close()则用于关闭。</p><p>最后我们在BootStrap中创建这个Logger，并且指派给Container使用，用来打印日志。</p><pre><code class=\"language-java\">package com.minit.startup;\npublic class BootStrap {\n    public static final String WEB_ROOT =\n            System.getProperty(\"user.dir\") + File.separator + \"webroot\";\n    private static int debug = 0;\n    public static void main(String[] args) {\n        if (debug &gt;= 1)\n            log(\".... startup ....\");\n        HttpConnector connector = new HttpConnector();\n        StandardContext container = new StandardContext();\n        connector.setContainer(container);\n        container.setConnector(connector);\n        Logger logger = new FileLogger();\n        container.setLogger(logger);\n        connector.start();\n    }\n    private static void log(String message) {\n        System.out.print(\"Bootstrap: \");\n        System.out.println(message);\n    }\n    private static void log(String message, Throwable exception) {\n        log(message);\n        exception.printStackTrace(System.out);\n    }\n}\n</code></pre><p>在这里，我们把Logger传给Container的原因在于，多个Container可以使用不同的Logger，针对不同的目录和文件进行操作。</p><p>最后我们再完善一些代码，Logger的定义就改造完毕了。</p><p>首先我们在ContainerBase中增加与日志相关的代码。</p><pre><code class=\"language-java\">package com.minit.core;\npublic abstract class ContainerBase implements Container {\n    //ContainerBase中增加与日志相关的代码\n    protected Logger logger = null;\n    public Logger getLogger() {\n        if (logger != null)\n            return (logger);\n        if (parent != null)\n            return (parent.getLogger());\n        return (null);\n    }\n    public synchronized void setLogger(Logger logger) {\n        Logger oldLogger = this.logger;\n        if (oldLogger == logger)\n            return;\n        this.logger = logger;\n    }\n    protected void log(String message) {\n        Logger logger = getLogger();\n        if (logger != null)\n            logger.log(logName() + \": \" + message);\n        else\n            System.out.println(logName() + \": \" + message);\n    }\n\n    protected void log(String message, Throwable throwable) {\n        Logger logger = getLogger();\n        if (logger != null)\n            logger.log(logName() + \": \" + message, throwable);\n        else {\n            System.out.println(logName() + \": \" + message + \": \" + throwable);\n            throwable.printStackTrace(System.out);\n        }\n    }\n    protected String logName() {\n        String className = this.getClass().getName();\n        int period = className.lastIndexOf(\".\");\n        if (period &gt;= 0)\n            className = className.substring(period + 1);\n        return (className + \"[\" + getName() + \"]\");\n    }\n}\n</code></pre><p>再在StandardContext中增加与日志相关的代码。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardContext extends ContainerBase implements Context {\n    public StandardContext() {\n        try {\n            // create a URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(Bootstrap.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        } catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n        log(\"Container created.\");\n    }\n}\n</code></pre><p>在HttpConnector中增加与日志相关的代码。</p><pre><code class=\"language-java\">public class HttpConnector implements Connector, Runnable {\n    private String info = \"com.minit.connector.http.HttpConnector/0.1\";\n    private int port = 8080;\n    int minProcessors = 3;\n    int maxProcessors = 10;\n    int curProcessors = 0;\n    Deque&lt;HttpProcessor&gt; processors = new ArrayDeque&lt;&gt;();\n    public static Map&lt;String, HttpSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();\n    Container container = null;\n    private String threadName = null;\n    \n    //启动connector，记录启动日志\n    public void start() {\n        threadName = \"HttpConnector[\" + port + \"]\";\n        log(\"httpConnector.starting  \" + threadName);\n        Thread thread = new Thread(this);\n        thread.start();\n    }\n    \n    private HttpProcessor newProcessor() {\n        HttpProcessor initprocessor = new HttpProcessor(this);\n        initprocessor.start();\n        processors.push(initprocessor);\n        curProcessors++;\n        log(\"newProcessor\");\n        return ((HttpProcessor) processors.pop());\n    }\n    //记录日志\n    private void log(String message) {\n        Logger logger = container.getLogger();\n        String localName = threadName;\n        if (localName == null)\n            localName = \"HttpConnector\";\n        if (logger != null)\n            logger.log(localName + \" \" + message);\n        else\n            System.out.println(localName + \" \" + message);\n    }\n    //记录日志\n    private void log(String message, Throwable throwable) {\n        Logger logger = container.getLogger();\n        String localName = threadName;\n        if (localName == null)\n            localName = \"HttpConnector\";\n        if (logger != null)\n            logger.log(localName + \" \" + message, throwable);\n        else {\n            System.out.println(localName + \" \" + message);\n            throwable.printStackTrace(System.out);\n        }\n    }\n    public Container getContainer() {\n        return this.container;\n    }\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n    @Override\n    public String getInfo() {\n        return this.info;\n    }\n}\n</code></pre><p>引入日志组件后，我们转向第二部分，也是Tomcat设计里的一个特色：职责链。</p><h2>引入职责链模式</h2><p>当服务器要调用某个具体的Servlet的时候，是先经过这些container的invoke()方法，一层一层调用的。每一个Container内部在真正的任务执行前（如执行Servlet），都会途径过滤层，这些层叫作Valve，一个一个地执行Valve之后再执行Servlet，这样可以给Container做一些过滤的操作，比如权限校验、日志打印、报错输出等。</p><p>在Tomcat中，还引入了一个概念——Pipeline，Container的invoke()方法没有硬编码，而是调用Pipeline的invoke方法。</p><pre><code class=\"language-java\">public void invoke(Request request, Response response) throws IOException, ServletException {\n&nbsp; &nbsp; pipeline.invoke(request, response);\n}\n</code></pre><p>简单来讲，就是每一层Container都有一个Pipeline，也是一根链条，这根链条是许多Valve串起来的。调用某个Container的invoke()，就是找到Pipeline的第一个Valve进行调用，第一个Valve会调用下一个，一个一个传下去，到最后一个Basic Valve，然后调用下一层容器，直到结束。</p><p>而这个Basic Valve则是在每个Container里面都默认存在的，通过Pipeline来依次调用每一个Valve，这就是职责链模式，而且这种方式也像Pipeline名称一样，流水线似的从前往后。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/f3/fce65cab4f5cc552a17f3eee7753a8f3.png?wh=1920x1167\" alt=\"图片\"></p><p>这里我们先定义通用的Valve、ValveContext与Pipeline接口。Valve接口表示的Container中的一段用户增加的逻辑，主要就是一个invoke方法。</p><pre><code class=\"language-java\">package com.minit;\npublic interface Valve {\n    public String getInfo();\n    public Container getContainer();\n    public void setContainer(Container container);\n    public void invoke(Request request, Response response,ValveContext context)\n            throws IOException, ServletException;\n}\n</code></pre><p>ValveContext接口负责调用下一个Valve，这样就会形成一系列对Valve的调用。</p><pre><code class=\"language-java\">package com.minit;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\npublic interface ValveContext {\n    public String getInfo();\n    public void invokeNext(Request request, Response response) throws IOException, ServletException;\n}\n</code></pre><p>Pipeline表示的是Container中的Valve链条，其中有特殊的basic。Pipeline启动Valve链条的调用。</p><pre><code class=\"language-java\">package com.minit;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\npublic interface Pipeline {\n    public Valve getBasic();\n    public void setBasic(Valve valve);\n    public void addValve(Valve valve);\n    public Valve[] getValves();\n    public void invoke(Request request, Response response) throws IOException, ServletException;\n    public void removeValve(Valve valve);\n}\n</code></pre><p>接着定义实现基类——ValveBase。</p><pre><code class=\"language-java\">package com.minit.valves;\npublic abstract class ValveBase implements Valve {\n    protected Container container = null;\n    protected int debug = 0;\n    protected static String info = \"com.minit.valves.ValveBase/0.1\";\n    public Container getContainer() {\n        return (container);\n    }\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n    public int getDebug() {\n        return (this.debug);\n    }\n    public void setDebug(int debug) {\n        this.debug = debug;\n    }\n    public String getInfo() {\n        return (info);\n    }\n}\n</code></pre><p>结合之前的内容，我们将Log与Valve结合，定义AccessLogValve类。这个Valve的作用是记录日志，你可以看一下程序的主体。</p><pre><code class=\"language-java\">package com.minit.valves;\npublic final class AccessLogValve extends ValveBase {\n    //下面的属性都是与访问日志相关的配置参数\n    public static final String COMMON_ALIAS = \"common\";\n    public static final String COMMON_PATTERN = \"%h %l %u %t \\\"%r\\\" %s %b\";\n    public static final String COMBINED_ALIAS = \"combined\";\n    public static final String COMBINED_PATTERN = \"%h %l %u %t \\\"%r\\\" %s %b \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"\";\n    public AccessLogValve() {\n        super();\n        setPattern(\"common\");\n    }\n    private String dateStamp = \"\";\n    private String directory = \"logs\";\n    protected static final String info =\n            \"com.minit.valves.AccessLogValve/0.1\";\n    protected static final String months[] =\n            { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n    private boolean common = false;\n    private boolean combined = false;\n    private String pattern = null;\n    private String prefix = \"access_log.\";\n    private String suffix = \"\";\n    private PrintWriter writer = null;\n    private DateTimeFormatter dateFormatter = null;\n    private DateTimeFormatter dayFormatter = null;\n    private DateTimeFormatter monthFormatter = null;\n    private DateTimeFormatter yearFormatter = null;\n    private DateTimeFormatter timeFormatter = null;\n    private String timeZone = null;\n    private LocalDate currentDate = null;\n    private String space = \" \";\n    private long rotationLastChecked = 0L;\n    \n    //省略属性的getter/setter\n    \n    //这是核心方法invoke\n    public void invoke(Request request, Response response, ValveContext context)\n            throws IOException, ServletException {\n        // 先调用context中的invokeNext，实现职责链调用\n        // Pass this request on to the next valve in our pipeline\n        context.invokeNext(request, response);\n        \n        //以下是本valve本身的业务逻辑\n        LocalDate date = getDate();\n        StringBuffer result = new StringBuffer();\n        // Check to see if we should log using the \"common\" access log pattern\n        //拼串\n        if (common || combined) {\n            //拼串，省略\n        } else { //按照模式拼串\n            // Generate a message based on the defined pattern\n            boolean replace = false;\n            for (int i = 0; i &lt; pattern.length(); i++) {\n                char ch = pattern.charAt(i);\n                if (replace) {\n                    result.append(replace(ch, date, request, response));\n                    replace = false;\n                } else if (ch == '%') {\n                    replace = true;\n                } else {\n                    result.append(ch);\n                }\n            }\n        }\n        log(result.toString(), date);\n    }\n    private synchronized void close() {\n        if (writer == null)\n            return;\n        writer.flush();\n        writer.close();\n        writer = null;\n        dateStamp = \"\";\n    }\n    //按照日期生成日志文件，并记录日志\n    public void log(String message, LocalDate date) {\n        // Only do a logfile switch check once a second, max.\n        long systime = System.currentTimeMillis();\n        if ((systime - rotationLastChecked) &gt; 1000) {\n            // We need a new currentDate\n            currentDate = LocalDate.now();\n            rotationLastChecked = systime;\n            // Check for a change of date\n            String tsDate = dateFormatter.format(currentDate);\n            // If the date has changed, switch log files\n            if (!dateStamp.equals(tsDate)) {\n                synchronized (this) {\n                    if (!dateStamp.equals(tsDate)) {\n                        close();\n                        dateStamp = tsDate;\n                        open();\n                    }\n                }\n            }\n        }\n        // Log this message\n        if (writer != null) {\n            writer.println(message);\n        }\n    }\n\n    //打开日志文件\n    private synchronized void open() {\n        // Create the directory if necessary\n        File dir = new File(directory);\n        if (!dir.isAbsolute())\n            dir = new File(System.getProperty(\"minit.base\"), directory);\n        dir.mkdirs();\n        // Open the current log file\n        try {\n            String pathname = dir.getAbsolutePath() + File.separator +\n                    prefix + dateStamp + suffix;\n            writer = new PrintWriter(new FileWriter(pathname, true), true);\n        } catch (IOException e) {\n            writer = null;\n        }\n    }\n    //替换字符串\n    private String replace(char pattern, LocalDate date, Request request,\n                           Response response) {\n        //省略\n    }\n    private LocalDate getDate() {\n        // Only create a new Date once per second, max.\n        long systime = System.currentTimeMillis();\n        if ((systime - currentDate.getLong(ChronoField.MILLI_OF_SECOND)) &gt; 1000) {\n            currentDate = LocalDate.now();\n        }\n        return currentDate;\n    }\n}\n</code></pre><p>接下来我们定义StandardPipeline，提供Pipeline的标准实现，主体如下：</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardPipeline implements Pipeline{\n    public StandardPipeline() {\n        this(null);\n    }\n    public StandardPipeline(Container container) {\n        super();\n        setContainer(container);\n    }\n    protected Valve basic = null; //basic valve\n    protected Container container = null;\n    protected int debug = 0;\n    protected String info = \"com.minit.core.StandardPipeline/0.1\";\n    protected Valve valves[] = new Valve[0]; //一组valve，可以逐个调用\n    \n    public Valve getBasic() {\n        return (this.basic);\n    }\n    public void setBasic(Valve valve) {\n        // Change components if necessary\n        Valve oldBasic = this.basic;\n        if (oldBasic == valve)\n            return;\n        // Start the new component if necessary\n        if (valve == null)\n            return;\n        valve.setContainer(container);\n        this.basic = valve;\n    }\n\n    //添加valve\n    public void addValve(Valve valve) {\n        // Add this Valve to the set associated with this Pipeline\n        synchronized (valves) {\n            Valve results[] = new Valve[valves.length +1];\n            System.arraycopy(valves, 0, results, 0, valves.length);\n            valve.setContainer(container);\n            results[valves.length] = valve;\n            valves = results;\n        }\n    }\n\n    public Valve[] getValves() {\n        if (basic == null)\n            return (valves);\n        synchronized (valves) {\n            Valve results[] = new Valve[valves.length + 1];\n            System.arraycopy(valves, 0, results, 0, valves.length);\n            results[valves.length] = basic;\n            return (results);\n        }\n    }\n    //核心方法invoke\n    public void invoke(Request request, Response response)\n            throws IOException, ServletException {\n        System.out.println(\"StandardPipeline invoke()\");\n        // 转而调用context中的invoke，发起职责链调用\n        // Invoke the first Valve in this pipeline for this request\n        (new StandardPipelineValveContext()).invokeNext(request, response);\n    }\n    \n    public void removeValve(Valve valve) {\n        synchronized (valves) {\n            // Locate this Valve in our list\n            int j = -1;\n            for (int i = 0; i &lt; valves.length; i++) {\n                if (valve == valves[i]) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j &lt; 0)\n                return;\n            valve.setContainer(null);\n            // Remove this valve from our list\n            Valve results[] = new Valve[valves.length - 1];\n            int n = 0;\n            for (int i = 0; i &lt; valves.length; i++) {\n                if (i == j)\n                    continue;\n                results[n++] = valves[i];\n            }\n            valves = results;\n        }\n    }\n    \n    //内部类，维护了stage，表示valves数组中的位置，逐个invoke\n    protected class StandardPipelineValveContext implements ValveContext {\n        protected int stage = 0;\n\n        public void invokeNext(Request request, Response response)\n                throws IOException, ServletException {\n            System.out.println(\"StandardPipelineValveContext invokeNext()\");\n            int subscript = stage;\n            stage = stage + 1;\n            // Invoke the requested Valve for the current request thread\n            if (subscript &lt; valves.length) {\n                valves[subscript].invoke(request, response, this);\n            } else if ((subscript == valves.length) &amp;&amp; (basic != null)) {\n                basic.invoke(request, response, this);\n            } else {\n                throw new ServletException(\"standardPipeline.noValve\");\n            }\n        }\n    }\n}\n</code></pre><p>在StandardPipeline类中，我们使用了一个数组保存当前valves的值以及单独的Basic Valve。</p><pre><code class=\"language-java\">protected Valve valves[] = new Valve[0];\nprotected Valve basic = null;\n</code></pre><p>对Pipeline的调用变成了启动StandardPipelineValveContext的invokeNext()。</p><pre><code class=\"language-java\">public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n    System.out.println(\"StandardPipeline invoke()\");\n    (new StandardPipelineValveContext()).invokeNext(request, response);\n}\n</code></pre><p>其中StandardPipelineValveContext是StandardPipeline里定义的一个内部类，在这个内部类里，维护了一个stage的域，用来记录Valve的编号。</p><pre><code class=\"language-java\">protected class StandardPipelineValveContext implements ValveContext {\n&nbsp; &nbsp; protected int stage = 0;\n&nbsp; &nbsp; public void invokeNext(Request request, Response response) throws IOException, ServletException {\n&nbsp; &nbsp; &nbsp; &nbsp; int subscript = stage;\n&nbsp; &nbsp; &nbsp; &nbsp; stage = stage + 1;\n&nbsp; &nbsp; &nbsp; &nbsp; // Invoke the requested Valve for the current request thread\n&nbsp; &nbsp; &nbsp; &nbsp; if (subscript &lt; valves.length) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valves[subscript].invoke(request, response, this);\n&nbsp; &nbsp; &nbsp; &nbsp; } else if ((subscript == valves.length) &amp;&amp; (basic != null)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basic.invoke(request, response, this);\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ServletException(\"standardPipeline.noValve\");\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>在判断条件中，根据编号调用valve.invoke()，调用到最后，就是调用Basic Valve的invoke()方法。而valve.invoke()方法调用的本质在于<strong>调用ValveContext的invokeNext()方法</strong>， 随后执行本身的业务任务，参考AccessLogValve也是这样。</p><pre><code class=\"language-java\">public void invoke(Request request, Response response, ValveContext context) throws IOException, ServletException {\n&nbsp; &nbsp; context.invokeNext(request, response);\n}\n</code></pre><p>这样一个一个传递下去，整个链路就调用完毕。</p><p>因为整个服务器的起点是Connector和Container，所以我们得把Pipeline加入到Container中，这就需要调整ContainerBase里的实现。你可以看一下当前ContainerBase类的实现，主体如下：</p><pre><code class=\"language-java\">package com.minit.core;\nimport com.minit.*;\nimport javax.servlet.ServletException;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\npublic abstract class ContainerBase implements Container, Pipeline {\n    protected Map&lt;String, Container&gt; children = new ConcurrentHashMap&lt;&gt;();\n    protected ClassLoader loader = null;\n    protected String name = null;\n    protected Container parent = null;\n    protected Logger logger = null;\n    protected Pipeline pipeline = new StandardPipeline(this); //增加pipeline支持\n    public Pipeline getPipeline() {\n        return (this.pipeline);\n    }\n    public void invoke(Request request, Response response) throws IOException, ServletException {\n        System.out.println(\"ContainerBase invoke()\");\n        pipeline.invoke(request, response);\n    }\n    public synchronized void addValve(Valve valve) {\n        pipeline.addValve(valve);\n    }\n    public Valve getBasic() {\n        return (pipeline.getBasic());\n    }\n    public Valve[] getValves() {\n        return (pipeline.getValves());\n    }\n    public synchronized void removeValve(Valve valve) {\n        pipeline.removeValve(valve);\n    }\n    public void setBasic(Valve valve) {\n        pipeline.setBasic(valve);\n    }\n    public ClassLoader getLoader() {\n        if (loader != null)\n            return (loader);\n        if (parent != null)\n            return (parent.getLoader());\n        return (null);\n    }\n    public synchronized void setLoader(ClassLoader loader) {\n        ClassLoader oldLoader = this.loader;\n        if (oldLoader == loader) {\n            return;\n        }\n        this.loader = loader;\n    }\n\n    protected void log(String message) {\n        Logger logger = getLogger();\n        if (logger != null)\n            logger.log(logName() + \": \" + message);\n        else\n            System.out.println(logName() + \": \" + message);\n    }\n\n    protected void log(String message, Throwable throwable) {\n        Logger logger = getLogger();\n        if (logger != null)\n            logger.log(logName() + \": \" + message, throwable);\n        else {\n            System.out.println(logName() + \": \" + message + \": \" + throwable);\n            throwable.printStackTrace(System.out);\n        }\n    }\n\n}\n</code></pre><p>主要是增加了StandardPipeline的处理，在ContainerBase中引入Pipeline，调用invoke()就变成了调用Pipeline中的invoke()方法实现。</p><pre><code class=\"language-java\">    protected Pipeline pipeline = new StandardPipeline(this);\n    public Pipeline getPipeline() {\n        return (this.pipeline);\n    }\n    public void invoke(Request request, Response response) throws IOException, ServletException {\n        System.out.println(\"ContainerBase invoke()\");\n        pipeline.invoke(request, response);\n    }\n    public synchronized void addValve(Valve valve) {\n        pipeline.addValve(valve);\n    }\n</code></pre><p>而在StandardContext的构造方法中我们也进行调整，增加对Pipeline的处理。</p><pre><code class=\"language-java\">&nbsp;public StandardContext() {\n&nbsp; &nbsp; &nbsp; &nbsp; super();\n&nbsp; &nbsp; &nbsp; &nbsp; pipeline.setBasic(new StandardContextValve());\n}\n</code></pre><p>处理之后，在StandardContext类里调用invoke()方法就很简单了，只要调用ContainerBase的invoke()启动Pipeline，随后调用Pipiline中的invoke()就可以了。</p><pre><code class=\"language-java\">public void invoke(Request request, Response response) throws IOException, ServletException {\n    super.invoke(request, response);\n}\n</code></pre><p>你可以看一下StandardContext类中新增和调整的代码。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardContext extends ContainerBase implements Context{\n    public StandardContext() {\n        super();\n        pipeline.setBasic(new StandardContextValve());\n        try {\n            // create a URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(BootStrap.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        } catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n        log(\"Container created.\");\n    }\n\n    public void invoke(Request request, Response response)\n            throws IOException, ServletException {\n        System.out.println(\"StandardContext invoke()\");\n        super.invoke(request, response);\n    }\n\n    public Wrapper getWrapper(String name){\n        StandardWrapper servletWrapper = servletInstanceMap.get(name);\n        if ( servletWrapper == null) {\n            String servletClassName = name;\n            servletWrapper = new StandardWrapper(servletClassName,this);\n            this.servletClsMap.put(name, servletClassName);\n            this.servletInstanceMap.put(name, servletWrapper);\n        }\n        return servletWrapper;\n    }\n}\n\n</code></pre><p>下面是被StandardContext引用的StandardContextValve类的定义。</p><pre><code class=\"language-java\">package com.minit.core;\nfinal class StandardContextValve extends ValveBase {\n    private static final String info =\n            \"org.apache.catalina.core.StandardContextValve/1.0\";\n    public String getInfo() {\n        return (info);\n    }\n    public void invoke(Request request, Response response, ValveContext valveContext)\n            throws IOException, ServletException {\n        System.out.println(\"StandardContextValve invoke()\");\n        StandardWrapper servletWrapper = null;\n        String uri = ((HttpRequestImpl)request).getUri();\n        String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n        String servletClassName = servletName;\n        StandardContext context = (StandardContext)getContainer();\n        servletWrapper = (StandardWrapper)context.getWrapper(servletName);\n        try {\n            System.out.println(\"Call service()\");\n            servletWrapper.invoke(request, response);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n    }\n}\n</code></pre><p>我们以前写在StandardContext类里面的invoke()方法实现代码，现在用StandardContextValve的invoke()来取代了，从这里面拿到Wrapper后直接调用。这里没有invokeNext()的实现，因为这个Valve是Basic Valve，是最后调用的。</p><p>同理，以前写在StandardWrapper类的invoke实现代码，现在也要用一个Valve来取代了。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardWrapperValve extends ValveBase {\n    @Override\n    public void invoke(Request request, Response response, ValveContext context) throws IOException, ServletException {\n        // TODO Auto-generated method stub\n        System.out.println(\"StandardWrapperValve invoke()\");\n        HttpServletRequest requestFacade = new HttpRequestFacade((HttpRequestImpl) request);\n        HttpServletResponse responseFacade = new HttpResponseFacade((HttpResponseImpl) response);\n        Servlet instance = ((StandardWrapper)getContainer()).getServlet();\n        if (instance != null) {\n            instance.service(requestFacade, responseFacade);\n        }\n    }\n}\n</code></pre><p>而当前的StandardWrapper，修改调整了哪些代码呢？我列出来了，你看一下。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardWrapper extends ContainerBase implements Wrapper {\n    public StandardWrapper(String servletClass, StandardContext parent) {\n        super();\n        pipeline.setBasic(new StandardWrapperValve());\n        this.parent = parent;\n        this.servletClass = servletClass;\n        try {\n            loadServlet();\n        } catch (ServletException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void invoke(Request request, Response response)\n            throws IOException, ServletException {\n        System.out.println(\"StandardWrapper invoke()\");\n        super.invoke(request, response);\n    }\n}\n</code></pre><p>到这里我们的职责链模式就改造好了，最后还有一些调整和改动，让它更贴近Tomcat。主要是HttpRequestImpl和HttpResponseImpl两个实现类，分别支持实现Request接口和Response接口。你可以看一下 <a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter12\">Gitee</a> 中的代码。</p><p>ServletProcessor类里的process方法签名也一并调整成Request与Response。</p><pre><code class=\"language-java\">package com.minit.connector.http;\npublic class ServletProcessor {\n    public void process(Request request, Response response) throws IOException, ServletException {\n        this.connector.getContainer().invoke(request, response);\n    }\n}\n</code></pre><p>到这里这节课的改造就结束了，快试着运行一下吧！</p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/30/b4/30ef2df67afb6c117f5ba53f19a899b4.jpg?wh=3511x2859\" alt=\"\"></p><p>这节课我们先引入了日志组件，通过将日志输出到文件，并用不同日期加以区分，可以帮助我们更好记录服务器运行状态，尽快定位问题。</p><p>随后我们重点研究了Tomcat中的Pipeline，通过Pipeline和Valve的处理，带出了责任链这一设计模式，确保我们在流程走通的前提下，在每一层Container之间增加权限校验、日志打印、错误输出等自定义的处理。</p><p>这节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter12\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter12</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：我们在某个容器的Pipeline中增加三个Valve和一个Basic Valve，那么具体的调用次序是怎样的？</p><p>欢迎你把你想到的方案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"11｜ 多层容器：如何通过实现Context与Wrapper形成多层容器？","id":739356},"right":{"article_title":"13｜Filter与Listener：如何实现过滤和持续监听？","id":741168}},"comments":[{"had_liked":false,"id":386199,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1704321615,"is_pvip":false,"replies":[{"id":140888,"content":"Q1，一般能用常量就不要用魔法值\nQ2，我说后端指两种，一个是web系统中的服务器端，还有一种是指调用的下层，比如controller这一层，用到了service，则会把service堪称controller的后端\nQ3，先用next是模仿的Tomcat\nQ4，没什么特别的，就是比较系统，按照日期区分，按照不同的container分开，access也分开的，比较有层次","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705023475,"ip_address":"澳大利亚","comment_id":386199,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：Logger接口定义中FATAL 为什么用 Integer.MIN_VALUE？\n用0不就可以了吗？\nQ2：“后端”是指什么？\n“存在 Exception 异常时，后端会调用 printStackTrace 抛出异常”这句话中用到的“后端”是指什么？有“后端”就有“前端”，“前端”和“后端”分别指什么？\nQ3：为什么先调用next再调用自身业务?\nAccessLogValve的invoke方法中，先调用context中的invokeNext，实现职责链调用，再调用自己的业务。那就是先处理下一个，再处理自己，如此迭代下去，变成倒序了，类似于堆栈了。假设有3个业务，先到业务1，业务1调用业务2，业务2调用业务3,；业务3处理完以后再处理业务2，最后处理业务1。为什么这样设计？\nQ4：Tomcat中的日志处理有什么特别之处？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635644,"discussion_content":"Q1，一般能用常量就不要用魔法值\nQ2，我说后端指两种，一个是web系统中的服务器端，还有一种是指调用的下层，比如controller这一层，用到了service，则会把service堪称controller的后端\nQ3，先用next是模仿的Tomcat\nQ4，没什么特别的，就是比较系统，按照日期区分，按照不同的container分开，access也分开的，比较有层次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705023475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386190,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1704287211,"is_pvip":false,"replies":[{"id":140889,"content":"概念是对的。你再注意一下几个valve之间的先后次序。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705023520,"ip_address":"澳大利亚","comment_id":386190,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"个人理解是 Valve 先添加先执行，可以当做为 Filter，在 Servlet 前面拦截先执行； Basic 属于自身业务最后执行， 可以当做 Servlet。","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635645,"discussion_content":"概念是对的。你再注意一下几个valve之间的先后次序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705023520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":635764,"discussion_content":"🤣谢老师指正， 仔细再认真看了一遍， Value 是先添加， 但是它的业务是后执行， 也就是先进后出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705138248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":635645,"ip_address":"广东","group_id":0},"score":635764,"extra":""}]}]}]}