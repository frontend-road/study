{"id":136020,"title":"09 | 分布式一致性：让你的消息支持多终端漫游","content":"<p>你好，我是袁武林。今天我们开始进入场景篇的部分，在这个部分中，我会介绍在几种典型的垂直业务场景下，IM系统具体是如何实现的。</p><p>在即时消息的场景里，消息的多终端漫游是一个相对比较高级的功能，所谓的<strong>“多终端漫游”是指：用户在任意一个设备登录后，都能获取到历史的聊天记录。</strong></p><p>这个功能对于有多个手机的用户来说是一个非常有用的功能，试想一下用户在交叉使用多个手机进行聊天后，如果不能在多个终端间自动同步所有的聊天记录，使用体验也不会太好。</p><p>但并不是所有的即时消息App都支持这个特性，比如微信虽然支持多端登录，但不知道出于什么考虑并不能在多端同步历史消息，这可能也是微信为数不多被诟病的一个小问题吧。</p><p>而Telegram和QQ却很好地支持了“多终端漫游”，使得用户在任意端登录都能获取到所有最近收发的消息。</p><h2>如何实现多终端消息漫游</h2><p>那接下来我们看一下，怎么才能让收发的消息能在多个终端漫游。要支持消息多终端漫游一般来说需要两个前置条件：一种是通过设备维度的在线状态来实现，一种是通过离线消息存储来实现。</p><h3>设备维度的在线状态</h3><p>对于在多个终端同时登录并在线的用户，可以让IM服务端在收到消息后推给接收方的多台设备，也推给发送方的其他登录设备。</p><!-- [[[read_end]]] --><p>这样的话，就要求能够按照用户的设备维度来记录在线状态，这个其实也是支持多端登录的一个前提。</p><h3>离线消息存储</h3><p>另外，如果消息发送时，接收方或者发送方只有一台设备在线，可能一段时间后，才通过其他设备登录来查看历史聊天记录，这种离线消息的多终端漫游就需要消息在服务端进行存储了。当用户的离线设备上线时，就能够从服务端的存储中获取到离线期间收发的消息。</p><p>下面，我简单把“多端在线时消息收发的过程”和“离线设备上线时同步消息的过程”画了一下。你可以自行参考，这里就不作具体说明了。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/e5/1ebf1653c400d562c3d5bd07b0f0e1e5.png?wh=1883*1406\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/c0/04/c097f863ec7f5a3988e9a2e05edc3204.png?wh=1637*1146\" alt=\"\"></p><h2>离线消息同步的几个关键点</h2><p>对于多终端同时在线的情况，实现上相对比较简单，只需要维护一套设备维度的在线状态就能同时推送多台设备。</p><p>而离线设备上线后拉取历史消息的过程就要复杂一些，比如，离线消息的存储和普通消息相比差别在哪？应该怎么存？每次上线怎么知道应该拉取哪些离线消息？因此，这里我来主要说一下离线消息同步的问题。</p><h3>离线消息该怎么存？</h3><p>在课程的<a href=\"https://time.geekbang.org/column/article/127978\">第2讲</a>中，我介绍过比较常见的消息索引的存储方式，你可以回想一下：一条消息在服务端存储一般会分为消息内容表和消息索引表，其中消息索引表是按照收发双方的会话维度来设计的，这样便于收发双方各自查看两人间的聊天内容。</p><p>那么问题来了：离线消息的存储是否可以直接使用这个消息索引表？</p><p>首先，对于离线消息的存储，不仅仅需要存储消息，还需要存储一些操作的信令，比如：用户A在设备1删除了和用户B的某条消息，这个信令虽然不是一条消息，也需要在离线消息存储中存起来，这样当用户A的另一台设备2上线时，能通过离线消息存储获取这个删除消息的信令，从而在设备2上也能从本地删除那条消息。</p><p>对于这些操作信令，没有消息ID的概念和内容相关的信息，而且是一个一次性的动作，没必要持久化，也不适合复用消息索引表；另外，消息索引表是收发双方的会话维度，而获取离线消息的时候是接收方或者发送方的单个用户维度来获取数据的，没必要按会话来存，只需要按UID来存储即可。</p><p>此外，还有一个需要考虑的点，离线消息的存储成本是比较高的，而我们并不知道用户到底有几个设备，因此离线消息的存储一般都会有时效和条数的限制，比如保留1周时间，最多存储1000条，这样如果用户一台设备很久不登录然后某一天再上线，只能从离线消息存储中同步最近一周的历史聊天记录。</p><h3>多端消息同步机制</h3><p>离线消息的同步还有一个重要的问题是，由于并不知道用户到底会有多少个终端来离线获取消息，我们在一个终端同步完离线消息后，并不会从离线存储中删除这些消息，而是继续保留以免后续还有该用户的其他设备上线拉取，离线消息的存储也是在不超过大小限制和时效限制的前提下，采用FIFO（先进先出）的淘汰机制。</p><p>这样的话用户在使用某一个终端登录上线时，需要知道应该获取哪些离线消息，否则将所有离线都打包推下去，就会造成两种问题：一个是浪费流量资源；另外可能会导致因为有很多消息在终端中已经存在了，全部下推反而会导致消息重复出现和信令被重复执行的问题。因此，需要一个机制来保证离线消息可以做到按需拉取。</p><p>一种常见的方案是采用版本号来实现多终端和服务端的数据同步。下面简单说一下版本号的概念。</p><ul>\n<li>每个用户拥有一套自己的版本号序列空间。</li>\n<li>每个版本号在该用户的序列空间都具备唯一性，一般是64位。</li>\n<li>当有消息或者信令需要推送给该用户时，会为每条消息或者信令生成一个版本号，并连同消息或者信令存入离线存储中，同时更新服务端维护的该用户的最新版本号。</li>\n<li>客户端接收到消息或者信令后，需要更新本地的最新版本号为收到的最后一条消息或者信令的版本号。</li>\n<li>当离线的用户上线时，会提交本地最新版本号到服务端，服务端比对服务端维护的该用户的最新版本号和客户端提交上来的版本号，如不一致，服务端根据客户端的版本号从离线存储获取“比客户端版本号新”的消息和信令，并推送给当前上线的客户端。</li>\n</ul><p>为了便于理解，我简单把这个离线同步消息的过程画了一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/46/b2979f028df32610328dad4f509a9546.png?wh=2538*1392\" alt=\"\"></p><h3>离线消息存储超过限额了怎么办？</h3><p>在用户上线获取离线消息时，会先进行客户端和服务端的版本号比较，如果版本号不一致才会从离线消息存储中，根据客户端上传的最新版本号来获取“增量消息”。</p><p>如果离线消息存储容量超过限制，部分增量消息被淘汰掉了，会导致根据客户端最新版本号获取增量消息失败。</p><p>这种情况的处理方式可以是：直接下推所有离线消息或者从消息的联系人列表和索引表中获取最近联系人的部分最新的消息，后续让客户端在浏览时再根据“时间相关”的消息ID来按页获取剩余消息，对于重复的消息让客户端根据消息ID去重。</p><p>因为消息索引表里只存储消息，并不存储操作信令，这种处理方式可能会导致部分操作信令丢失，但不会出现丢消息的情况。因此，对于资源充足且对一致性要求高的业务场景，可以尽量提升离线消息存储的容量来提升离线存储的命中率。</p><h3>离线存储写入失败了会怎么样？</h3><p>在处理消息发送的过程中，IM服务端可能会出现在获取到版本号以后写入离线消息存储时失败的情况，在这种情况下，如果版本号本身只是自增的话，会导致取离线消息时无法感知到有消息在写离线存储时失败的情况。</p><p>因为如果这一条消息写离线缓存失败，而下一条消息又成功了，这时拿着客户端版本号来取离线消息时发现，客户端版本号在里面，还是可以正常获取离线消息的，这样就会漏推之前写失败的那一条。</p><p>那么，怎么避免这种离线存储写失败无感知的问题呢？</p><p>一个可行的方案是可以在存储离线消息时不仅存储当前版本号，还存储上一条消息或信令的版本号，获取消息时不仅要求客户端最新版本号在离线消息存储中存在，同时还要求离线存储的消息通过每条消息携带的上一版本号和当前版本号能够整体串联上，否则如果离线存储写入失败，所有消息的这两个版本号是没法串联上的。</p><p>这样，当用户上线拉取离线消息时，IM服务端发现该用户的离线消息版本号不连续的情况后，就可以用和离线消息存储超限一样的处理方式，从消息的联系人列表和索引表来获取最近联系人的部分最新的消息。</p><h3>消息打包下推和压缩</h3><p>对于较长时间不上线的用户，上线后需要拉取的离线消息比较多，如果一条一条下推会导致整个过程很长，客户端看到的就是一条一条消息蹦出来，体验会很差。</p><p>因此，一般针对离线消息的下推会采用整体打包的方式来把多条消息合并成一个大包推下去，同时针对合并的大包还可以进一步进行压缩，通过降低包的大小不仅能减少网络传输时间，还能节省用户的流量消耗。</p><h3>发送方设备的同步问题</h3><p>另外还有一个容易忽视的问题，版本号机制中，我们在下推消息时会携带每条消息的版本号，然后更新为客户端的最新版本号。而问题是发送方用于发出消息的设备本身已经不需要再进行当前消息的推送，没法通过消息下推来更新这台设备的最新版本号，这样的话这台设备如果下线后再上线，上报的版本号仍然是旧的，会导致IM服务端误判而重复下推已经存在的消息。</p><p>针对这个问题，一个比较常见的解决办法是：给消息的发送方设备仍然下推一条只携带版本号的单独的消息，发送方设备接收到该消息只需要更新本地的最新版本号就能做到和服务端的版本号同步了。</p><h2>小结</h2><p>好了，最后我来总结一下今天的内容。</p><p>消息多终端漫游是很多即时消息场景中需要支持的一个特性，要支持消息多终端漫游，有两种实现方式：一种是要求在线状态需要支持用户设备维度进行维护；另一种是要求消息和信令在服务端进行用户维度的离线存储。</p><p>除此之外，还需要一个“多终端和服务端状态同步的机制”来保证数据的最终一致性，业界比较常见的方案是采用版本号机制来根据客户端版本和服务端版本的差异，在用户上线时来获取“增量消息和信令”。离线消息存储未命中时，可以通过持久化的最近联系人列表和索引表来进行有损的补救。针对离线消息的下推还可以通过“多条消息打包和压缩”的方式来优化上线体验。</p><p>最后给大家一个思考题：<strong>如果用户的离线消息比较多，有没有办法来减少用户上线时离线消息的数据传输量？</strong></p><p>以上就是今天课程的内容，你可以给我留言，我们一起讨论。感谢你的收听，我们下期再见。</p><p></p>","comments":[{"had_liked":false,"id":133616,"user_name":"王棕生","can_delete":false,"product_type":"c1","uid":1337944,"ip_address":"","ucode":"901BD0447A871E","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","comment_is_top":false,"comment_ctime":1568621778,"is_pvip":false,"replies":[{"id":"51311","content":"整体上没啥大问题哈，首次拉取可以不带时间戳，默认服务端就获取最新的N条即可。<br>另外时间戳是服务端应用服务器生成的么？多服务器间的时钟差异能接受吗？也可以考虑搭建一套全局的“时间相关的序号生成器”来生成消息ID，使用消息ID作为拉取的cursor，这样时间生成上也相对稳定一些。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568629654,"ip_address":"","comment_id":133616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61698163922","product_id":100034901,"comment_content":"老师，对消息的终端漫游，我这边还有一个云消息的实现方案，望点评！<br>1  所有的消息，全部持久化存储；<br>2  用户在任意一个终端设备登陆后，通过用户的uid、联系人uid去服务端拉取云消息；<br>3  拉取云消息的时候，是按每条消息的时间戳倒序拉取，首次拉取可以取当前时间戳。","like_count":14,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467451,"discussion_content":"整体上没啥大问题哈，首次拉取可以不带时间戳，默认服务端就获取最新的N条即可。\n另外时间戳是服务端应用服务器生成的么？多服务器间的时钟差异能接受吗？也可以考虑搭建一套全局的“时间相关的序号生成器”来生成消息ID，使用消息ID作为拉取的cursor，这样时间生成上也相对稳定一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568629654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133611,"user_name":"王棕生","can_delete":false,"product_type":"c1","uid":1337944,"ip_address":"","ucode":"901BD0447A871E","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","comment_is_top":false,"comment_ctime":1568621093,"is_pvip":false,"replies":[{"id":"51309","content":"是的，推拉结合是一种不错的折中方式。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568629475,"ip_address":"","comment_id":133611,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57403195941","product_id":100034901,"comment_content":"如果用户的离线消息比较多，有没有办法来减少用户上线时离线消息的数据传输量？<br>答： 用户所有的离线消息对用户来说，并不都是关心和感兴趣的，用户可能只是看了与某个最近联系人的最近的几条消息后，之前的都不想看了，所以这个时候如果将之前的离线消息都拉到本地是非常浪费资源的。通常的做法是：<br>1  将用户的所有离线消息，按联系人进行分开；<br>2  用户登录后进入与联系人的聊天窗口时，首先加载与该联系人的最近的10条离线消息；<br>3  当用户用手滑动手机屏幕的时候，再分页拉取10条。","like_count":14,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467448,"discussion_content":"是的，推拉结合是一种不错的折中方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568629475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400489,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5e/a9/cc943f81.jpg","nickname":"Adoph","note":"","ucode":"DE85FA2638BAE4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558871,"discussion_content":"如果有100条离线消息，用户滑动已读最新20条消息，剩下的80条消息的已读状态怎么处理合理，另外下次还会作为离线消息拉取吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648516886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133812,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1568678455,"is_pvip":true,"replies":[{"id":"51492","content":"出于可靠性考虑，一般来说服务端接收到消息不管接收方是否在线都会先存到离线存储中，同步再进行消息在线推送，如果接收方不在线或者在线推送失败，等下次接收方再次上线时会从这个离线存储中获取消息进行补推。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568806789,"ip_address":"","comment_id":133812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27338482231","product_id":100034901,"comment_content":"离线消息什么情况下进行存储呢？当用户A给用户B发送一条消息，发现没有用户B的连接信息，这个时候才进行离线消息的存储吗，还是只要有消息发送给B都会进行离线消息的存储，因为这些消息对于用户B的其他设备来说属于离线消息？","like_count":6,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467513,"discussion_content":"出于可靠性考虑，一般来说服务端接收到消息不管接收方是否在线都会先存到离线存储中，同步再进行消息在线推送，如果接收方不在线或者在线推送失败，等下次接收方再次上线时会从这个离线存储中获取消息进行补推。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568806789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158464,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1575377914,"is_pvip":false,"replies":[{"id":"60943","content":"是的，对于支持多设备同时登陆的场景，用户上线建立长连时是以uid + 设备id 为维度来记录和连接的映射的，所以发消息时携带设备id，服务端就可以区分出具体是用户的哪个设备发送的，下推时就可以区别处理了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1575626935,"ip_address":"","comment_id":158464,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14460279802","product_id":100034901,"comment_content":"最后的发送方设备同步的问题，没太明白。怎么确定发送设备呢？服务端还有一份设备消息的关系表么？","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476736,"discussion_content":"是的，对于支持多设备同时登陆的场景，用户上线建立长连时是以uid + 设备id 为维度来记录和连接的映射的，所以发消息时携带设备id，服务端就可以区分出具体是用户的哪个设备发送的，下推时就可以区别处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575626935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136019,"user_name":"javaworker","can_delete":false,"product_type":"c1","uid":1056209,"ip_address":"","ucode":"ABF9DDDBD3BDBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/d1/f427b83e.jpg","comment_is_top":false,"comment_ctime":1569330696,"is_pvip":true,"replies":[{"id":"52224","content":"第一个问题如果容量超限被淘汰掉仍然取大于版本号的消息下推的话可能会导致消息漏推。比如：客户端当前版本号是1，接下来的消息是2，3，4，假如2被淘汰，那么只会下推3和4，导致2漏推。<br>第二个问题，是的，离线消息按照用户维度来存储，发送方和接收方都会存，因为发送方也可能有多台设备。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569411346,"ip_address":"","comment_id":136019,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14454232584","product_id":100034901,"comment_content":"有几个问题没想明白，望老师帮解答下，谢谢<br>1.文中说如果离线消息存储容量超过限制，部分增量消息被淘汰掉了，会导致根据客户端最新版本号获取增量消息失败。<br>这个问题有些不明白，如果部分增量消息被淘汰，个人觉得也没关系吧，服务端每次把比客户端版本号大的消息都发给客户端就行了啊，怎么会失败呐？<br><br>2.文中说的离线消息表中该怎么存？比如A用户和B用户各有两个终端，但都只登陆了一个终端，这时A用户给B发送了一条消息，是按照A的userid存一条消息，按照B的userid也存一条一样的消息，A端上线拉取A的离线，B端上线拉取B的离线，也就是说A的离线消息有自己发出去的，也有别人发给A的消息，统一按照版本号存下来，A上线后都一起会拉走？","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468422,"discussion_content":"第一个问题如果容量超限被淘汰掉仍然取大于版本号的消息下推的话可能会导致消息漏推。比如：客户端当前版本号是1，接下来的消息是2，3，4，假如2被淘汰，那么只会下推3和4，导致2漏推。\n第二个问题，是的，离线消息按照用户维度来存储，发送方和接收方都会存，因为发送方也可能有多台设备。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569411346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1502409,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ec/c9/45bfcba3.jpg","nickname":"Xinyue Li","note":"","ucode":"0CB92610C8B9FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217205,"discussion_content":"离线消息也要存发送方和接收方分别都是谁吧，这样的话schema和消息索引表很类似啊，如果不考虑存储信令只存储消息的话，离线消息表和持久化的消息索引表区别很小啊。难道是离线消息表存在cache吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585529490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133607,"user_name":"K.Zhou","can_delete":false,"product_type":"c1","uid":1019861,"ip_address":"","ucode":"2D817253F9FDAD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/d5/bab4332a.jpg","comment_is_top":false,"comment_ctime":1568620103,"is_pvip":false,"replies":[{"id":"51308","content":"这个可能是个结果不是个原因，可能微信产品的设计上就是不想支持多终端消息漫游，所以消息不需要长时间存储在服务端。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568629422,"ip_address":"","comment_id":133607,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14453521991","product_id":100034901,"comment_content":"微信不能多端同步消息是因为消息没存在服务端吧？","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467446,"discussion_content":"这个可能是个结果不是个原因，可能微信产品的设计上就是不想支持多终端消息漫游，所以消息不需要长时间存储在服务端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568629422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005030,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","nickname":"GeekAmI","note":"","ucode":"232C0B6DFB9F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45344,"discussion_content":"1. 多设备都在线的情况下，是可以多端同步的；\n2. 电脑端登录时，需要手机端确认，选中“自动同步消息”后，会把手机端的消息同步到电脑端；\n3. 新手机登录微信，也可以从电脑端同步历史消息到手机端。\n\n综上，微信支持多端同步的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573026012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019861,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/d5/bab4332a.jpg","nickname":"K.Zhou","note":"","ucode":"2D817253F9FDAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005030,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","nickname":"GeekAmI","note":"","ucode":"232C0B6DFB9F56","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53255,"discussion_content":"只是部分消息同步 不是全部同步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574150671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45344,"ip_address":""},"score":53255,"extra":""}]}]},{"had_liked":false,"id":288634,"user_name":"Geek_1cc6d1","can_delete":false,"product_type":"c1","uid":1850248,"ip_address":"","ucode":"3E083616DD0742","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZCyXaP2gbxwFHxvtnyaaF2Pyy5KkSMsk9kh7SJl8icp1CD6wicb6VJibiblGibbpDo6IuHrdST6AnWQg/132","comment_is_top":false,"comment_ctime":1618571932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10208506524","product_id":100034901,"comment_content":"离线消息和拉取历史消息有什么区别？","like_count":2},{"had_liked":false,"id":222604,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1590848182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885815478","product_id":100034901,"comment_content":"上线时只推送最近的n条消息，等到用户主动刷新是主动拉取","like_count":2},{"had_liked":false,"id":133502,"user_name":"YidWang","can_delete":false,"product_type":"c1","uid":1619756,"ip_address":"","ucode":"C91A9117EC3540","user_header":"https://static001.geekbang.org/account/avatar/00/18/b7/2c/e1682683.jpg","comment_is_top":false,"comment_ctime":1568594689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863561985","product_id":100034901,"comment_content":"拉去消息量大 主要优化方式：打包压缩或者按需拉取","like_count":1},{"had_liked":false,"id":320047,"user_name":"Geek_LeonSZ","can_delete":false,"product_type":"c1","uid":1904472,"ip_address":"","ucode":"1C748B3A09CD9B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/edMMg8wmu2RRIFVw2UgAytIx7Yjmx3z2sX1Apc3DfX423dIpyKO6Kg2y65bjPF2jRZVt16AbfYS74A6BAWDJGQ/132","comment_is_top":false,"comment_ctime":1636059708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636059708","product_id":100034901,"comment_content":"可以稍微讲一下离线消息是怎么存储的么? 上面讲到&quot;没必要按会话来存，只需要按 UID 来存储即可&quot;。 这个地方可以展开讲讲么? 因为的确是经常会运用到. 可以像第2节课一样, 用一张表来解释下么?","like_count":0},{"had_liked":false,"id":296580,"user_name":"xinHAOr","can_delete":false,"product_type":"c1","uid":1252940,"ip_address":"","ucode":"C37EC11770EF24","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/4c/10174727.jpg","comment_is_top":false,"comment_ctime":1623052335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623052335","product_id":100034901,"comment_content":"老师，离线消息是不是可以只保存信令类消息，非信令类消息通过 用时主动拉取 方式获取？","like_count":0},{"had_liked":false,"id":292924,"user_name":"冯选刚","can_delete":false,"product_type":"c1","uid":1018444,"ip_address":"","ucode":"A186F31A730F04","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/4c/d976b42c.jpg","comment_is_top":false,"comment_ctime":1621082270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621082270","product_id":100034901,"comment_content":"在最后那里，发送方发消息之后，服务端回复的ack包含版本号和消息id 组成是不是也行。还需要单独发一条版本消息吗，如果单独发版本消息是啥时候发","like_count":0},{"had_liked":false,"id":290629,"user_name":"姚佶思","can_delete":false,"product_type":"c1","uid":2498816,"ip_address":"","ucode":"2EDB12A03354C5","user_header":"https://static001.geekbang.org/account/avatar/00/26/21/00/1a4f68cc.jpg","comment_is_top":false,"comment_ctime":1619666110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619666110","product_id":100034901,"comment_content":"在消息列表页面，APP在每次从后台打开到前台，如何保证列表页面中是最新的消息？ <br>  1  使用http请求获取所有消息列表数据，在来回切换到消息列表时，会很频繁，客户端会产生卡顿。<br>  2  如果每次进入到消息列表，由服务器push到客户端。客户端长时间不登陆，会接收到大量的消息。<br>针对这种情况情况改如何设计客户端和服务端的机制？","like_count":0},{"had_liked":false,"id":249703,"user_name":"璟琛","can_delete":false,"product_type":"c1","uid":1189674,"ip_address":"","ucode":"9B158CDDCDF42A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ikib5hH6AA9v1kJWp14ImL8AUcSd75Lorf1lJ0Vpk1bHyrHkjp4IuKa0BWM9pmwSP4Py5qOibCVGaNY5J7iaLt5mQ/132","comment_is_top":false,"comment_ctime":1600764535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600764535","product_id":100034901,"comment_content":"我看评论里面有很多提到推拉结合，按需拉取离线消息的做法，但是当离线设备重新上线的时候一般是在会话列表页，这个时候虽然不用把所有的离线消息都同步下来，但是需要展示每个会话的消息数和最后一条消息吧？这个问题通过按需拉取貌似解决不了？","like_count":0},{"had_liked":false,"id":219536,"user_name":"倔强小德普","can_delete":false,"product_type":"c1","uid":1180884,"ip_address":"","ucode":"4795B744BDDBDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/d4/7173785e.jpg","comment_is_top":false,"comment_ctime":1590037858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590037858","product_id":100034901,"comment_content":"请教两个问题，多设备的情况下，这个版本号是每个账号下面设备的维度记录的吗？<br><br>那个离线表模型大致是怎样的？服务端是如何存储每个同一个账号下面多端设备的版本号信息的","like_count":0},{"had_liked":false,"id":214882,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1588841351,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588841351","product_id":100034901,"comment_content":"消息还有一个问题比较严重，就是因为并发引起的乱序，导致客户端用大序列号去取消息的时候，低序列号的消息可能还没写入，导致丢消息","like_count":1},{"had_liked":false,"id":204776,"user_name":"tm1234","can_delete":false,"product_type":"c1","uid":1947612,"ip_address":"","ucode":"4042321C713186","user_header":"","comment_is_top":false,"comment_ctime":1586456967,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586456967","product_id":100034901,"comment_content":"请问老师 离线存储是不是意味着每条消息会在索引表和离线表中各存一次，也就是说有数据重复呢？可不可以让离线消息直接重用索引表呢？","like_count":0,"discussions":[{"author":{"id":1445123,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/03/e59341b4.jpg","nickname":"亚","note":"","ucode":"CDF4DFC3F3619A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243157,"discussion_content":"老师在文章中说了，离线表中还可能会存信令，也就是用户操作信息，例如删除某条信息。这个在索引表中是不太好存的，因为是针对某个用户的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587525063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200595,"user_name":"missa","can_delete":false,"product_type":"c1","uid":1033417,"ip_address":"","ucode":"485CB229C4C556","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/c9/90c8a53e.jpg","comment_is_top":false,"comment_ctime":1585622163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585622163","product_id":100034901,"comment_content":"离线消息的表怎么设计还是不太明白，它和消息的索引表有什么不同？","like_count":1},{"had_liked":false,"id":200573,"user_name":"小凉子","can_delete":false,"product_type":"c1","uid":1649728,"ip_address":"","ucode":"85737CD74B0BCD","user_header":"","comment_is_top":false,"comment_ctime":1585619860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585619860","product_id":100034901,"comment_content":"有个疑问想请教老师：<br>针对离线消息，老师都是提到用户上线是进行服务端下推，然后用户再按需下拉。为什么没有当用户登录上线时，通过http请求携带版本号向服务端获取离线消息，就是说只用拉的方式获取离线消息？","like_count":0},{"had_liked":false,"id":183422,"user_name":"yangzi","can_delete":false,"product_type":"c1","uid":1589251,"ip_address":"","ucode":"83E02FD4C4AC08","user_header":"https://static001.geekbang.org/account/avatar/00/18/40/03/525a1e78.jpg","comment_is_top":false,"comment_ctime":1583036374,"is_pvip":false,"replies":[{"id":"72291","content":"其实这里讲的多终端消息同步就包括离线消息的同步，消1，2，3这种自增序号解决不了丢消息的问题，一种解决方案是在接收端维护起一个链表式结构，每条下推的消息都会携带上一条消息的版本和当前这条消息的版本（版本是用户维度，维护在服务端），接收端需要能够将这些版本都串联起来，否则就需要从断开的位置重新发起同步。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1584085505,"ip_address":"","comment_id":183422,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583036374","product_id":100034901,"comment_content":"老师好，看了您的课程，有个问题：多终端消息同步和离线消息机制该如何搭配使用？这两个的功能类似。感觉离线消息更靠谱一些，因为它有ack，而多终端同步一旦客户端收到的消息不全，比如发送1、2、3，接收端收到1、3，拿3同步消息，同步也就会遗漏消息。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485684,"discussion_content":"其实这里讲的多终端消息同步就包括离线消息的同步，消1，2，3这种自增序号解决不了丢消息的问题，一种解决方案是在接收端维护起一个链表式结构，每条下推的消息都会携带上一条消息的版本和当前这条消息的版本（版本是用户维度，维护在服务端），接收端需要能够将这些版本都串联起来，否则就需要从断开的位置重新发起同步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584085505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158466,"user_name":"分清云淡","can_delete":false,"product_type":"c1","uid":1269873,"ip_address":"","ucode":"7045AE6BF72D31","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","comment_is_top":false,"comment_ctime":1575378024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575378024","product_id":100034901,"comment_content":"p2p的方式可以用来同步离线消息到多个设备上么？既然服务端有在线设备列表","like_count":0},{"had_liked":false,"id":150097,"user_name":"vearne","can_delete":false,"product_type":"c1","uid":1006602,"ip_address":"","ucode":"5FA7FE48D96A52","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/0a/1bd98d4b.jpg","comment_is_top":false,"comment_ctime":1573461780,"is_pvip":false,"replies":[{"id":"57909","content":"延迟加载能够一定程度缓解突发峰值流量，但对于持续高流量缓降作用有限。可以从提升写入能力角度去考虑，比如写合并。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1573562903,"ip_address":"","comment_id":150097,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573461780","product_id":100034901,"comment_content":"延迟加载也是一个办法吧","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474063,"discussion_content":"延迟加载能够一定程度缓解突发峰值流量，但对于持续高流量缓降作用有限。可以从提升写入能力角度去考虑，比如写合并。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573562903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148538,"user_name":"GeekAmI","can_delete":false,"product_type":"c1","uid":1005030,"ip_address":"","ucode":"232C0B6DFB9F56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","comment_is_top":false,"comment_ctime":1573027229,"is_pvip":false,"replies":[{"id":"57216","content":"多终端漫游目前也是有比较成熟的解决方案呀，技术上并不存在问题。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1573037537,"ip_address":"","comment_id":148538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573027229","product_id":100034901,"comment_content":"多端漫游，感觉是为了解决一个问题，而引入很多问题的解决方案。<br>让不用手动端到端同步聊天记录，岂不是更好吗[Facepalm][Facepalm][Facepalm]","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473523,"discussion_content":"多终端漫游目前也是有比较成熟的解决方案呀，技术上并不存在问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573037537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148459,"user_name":"GeekAmI","can_delete":false,"product_type":"c1","uid":1005030,"ip_address":"","ucode":"232C0B6DFB9F56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","comment_is_top":false,"comment_ctime":1573011023,"is_pvip":false,"replies":[{"id":"57215","content":"1. mac和手机同时登陆能够同步离线消息这个特性应该上了没多久吧，目前也仅仅是同步一段时间的离线消息，并不是能完全同步所有消息的。<br>2. 支持一台设备同步到另一台的前提是需要人工干预，不是自动的，实际上是把一台设备的消息打包发送给另一台。<br>并不是说这种实现方式不好，看个人的需求程度。如果你希望能够随时随地通过任意终端都能看到所有的历史聊天，那微信目前的方案可能存在一定的问题。<br>","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1573037481,"ip_address":"","comment_id":148459,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1573011023","product_id":100034901,"comment_content":"&quot;但并不是所有的即时消息 App 都支持这个特性，比如微信虽然支持多端登录，但不知道出于什么考虑并不能在多端同步历史消息，这可能也是微信为数不多被诟病的一个小问题吧。&quot;<br>1. 如果2台设备(mac和手机)都登录的情况下，消息会同步的；<br>2. 支持从一台设备上把历史聊天消息无损的同步到另一台设备。<br>我认为微信的方案即不复杂，也完美的解决了问题，很好啊<br>希望老师解答下，微信的这种方案缺陷是？不太明白","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473499,"discussion_content":"1. mac和手机同时登陆能够同步离线消息这个特性应该上了没多久吧，目前也仅仅是同步一段时间的离线消息，并不是能完全同步所有消息的。\n2. 支持一台设备同步到另一台的前提是需要人工干预，不是自动的，实际上是把一台设备的消息打包发送给另一台。\n并不是说这种实现方式不好，看个人的需求程度。如果你希望能够随时随地通过任意终端都能看到所有的历史聊天，那微信目前的方案可能存在一定的问题。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573037481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640700,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/fc/9a5fb5c5.jpg","nickname":"小王同学","note":"","ucode":"87C39D384F8991","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45382,"discussion_content":"“支持从一台设备上把历史聊天消息无损的同步到另一台设备”，我觉得一个是浪费时间，另一个是有点麻烦，我要在一台设备上获得二维码，另一设备去扫码才能开始同步，非常不方便其实。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573031604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640700,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/fc/9a5fb5c5.jpg","nickname":"小王同学","note":"","ucode":"87C39D384F8991","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45377,"discussion_content":"但是QQ就能没有这个问题，我在PC端和手机端都能看到之前的聊天记录，不用换设备","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573030946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640700,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/fc/9a5fb5c5.jpg","nickname":"小王同学","note":"","ucode":"87C39D384F8991","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45374,"discussion_content":"我的理解是，因为我在用Mac端登录微信回复信息，同时手机设备可以同步看到我回复的信息，但Mac端不会保留我微信的聊天记录，因为我发现第二天打开电脑，我之前回复的信息Mac微信端是看不见的，想查找之前的聊天记录我只能到手机上去看，所以工作起来有时其实不是很方便。你觉得呢兄弟~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573030799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1005030,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","nickname":"GeekAmI","note":"","ucode":"232C0B6DFB9F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1640700,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/fc/9a5fb5c5.jpg","nickname":"小王同学","note":"","ucode":"87C39D384F8991","race_medal":0,"user_type":8,"is_pvip":false},"discussion":{"id":46016,"discussion_content":"设置里可以设置退出保存聊天记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573111223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45374,"ip_address":""},"score":46016,"extra":""}]}]},{"had_liked":false,"id":138453,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1570251434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570251434","product_id":100034901,"comment_content":"课后思考题：<br>分页获取，用户上线时，只返回最新一页的联系人列表。针对联系人的聊天记录，同样也只返回最新的一页消息列表。用户持续下拉更新 联系人列表&#47;消息列表 时，再获取上一页 联系人列表&#47;消息列表 返回。","like_count":0},{"had_liked":false,"id":135029,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1568982285,"is_pvip":false,"replies":[{"id":"52006","content":"返回的header标识告知客户端这个消息是一个压缩过的打包消息，客户端接收到之后对body解压就可以啦。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569236347,"ip_address":"","comment_id":135029,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568982285","product_id":100034901,"comment_content":"老师，关于服务端消息打包压缩，用的是啥方法呢，比如从api拉取离线消息20条，这个怎么进行打包压缩返回给客户端，客户端怎么处理？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468007,"discussion_content":"返回的header标识告知客户端这个消息是一个压缩过的打包消息，客户端接收到之后对body解压就可以啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569236347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326338,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","nickname":"东东🎈","note":"","ucode":"D1BBE24CF76426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19901,"discussion_content":"需要采用gzip 压缩吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569236581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134755,"user_name":"Geek_912fa9","can_delete":false,"product_type":"c1","uid":1651029,"ip_address":"","ucode":"F81EA1027B67D0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sqVKmfHJyWKeCCWfOIoeKWvrX9DLIKc910YntKoGXbmgr20CP2ZTFC1S9dR2XYPZxiaP2uANBTm84a9BvU42Zzg/132","comment_is_top":false,"comment_ctime":1568909036,"is_pvip":true,"replies":[{"id":"51738","content":"离线消息不多的情况下，建议打包压缩后一次性推送，如果消息很多，分批也是可以的。离线消息的下推和在线消息的下推不冲突，可以并行的，接收端根据携带的版本号比对来更新收到的最新版本号就可以，一般都是收到一条端上判断后就进行一次更新。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568953089,"ip_address":"","comment_id":134755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568909036","product_id":100034901,"comment_content":"老师，用户上线时，离线消息的推送是一次性的，还是分批次下发到客户端的？如果是分批次推送的话，该用户在接收离线消息的过程中收到了其他用户发来的新消息，是否需要更新当前最新版本号，或者还是等到离线消息都推送完了，再判断是否需要更新。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467888,"discussion_content":"离线消息不多的情况下，建议打包压缩后一次性推送，如果消息很多，分批也是可以的。离线消息的下推和在线消息的下推不冲突，可以并行的，接收端根据携带的版本号比对来更新收到的最新版本号就可以，一般都是收到一条端上判断后就进行一次更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568953089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134531,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1568859417,"is_pvip":false,"replies":[{"id":"51596","content":"推拉结合没问题的，历史消息的存储如果后续请求量增加的话，最好有会话和最近联系人两个维度，”空间换时间“冗余一点，这样查询联系人的时候性能好一些。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568878573,"ip_address":"","comment_id":134531,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568859417","product_id":100034901,"comment_content":"老师我们im采用账号纬度的消息存储，对于离线消息同步采用设备纬度推拉结合方式，当设备上线时，客户端会收到服务端推送的一条消息，里面携带了最新的消息版本号，之后客户端采用拉的方式入参为这个版本号获取版本号之前的消息，实现增量同步，消息保留一周，历史消息只能通过主动查询了，请问下我们这种实现方式还有什么需要完善考量的吗。🙏","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467791,"discussion_content":"推拉结合没问题的，历史消息的存储如果后续请求量增加的话，最好有会话和最近联系人两个维度，”空间换时间“冗余一点，这样查询联系人的时候性能好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568878573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134492,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1568855608,"is_pvip":false,"replies":[{"id":"51595","content":"是的，离线库包括所有应该同步给这个用户设备的消息和信令。如果不考虑消息多终端同步的情况是没问题的，类似目前微信的机制，应该就只是有一个离线库。对于多终端消息同步的场景，比如一个新设备要查看和某人的所有消息，这个时候离线库针对接收人的设计就不太方便进行查询了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568878352,"ip_address":"","comment_id":134492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568855608","product_id":100034901,"comment_content":"老师 离线库是包含了一个人所有的消息吧 包括自己发的聊天消息 应收的聊天消息 和 应收的信令消息 上线时从这个库拉取就好 好像这时就不用利用收发箱的数据了啊","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467771,"discussion_content":"是的，离线库包括所有应该同步给这个用户设备的消息和信令。如果不考虑消息多终端同步的情况是没问题的，类似目前微信的机制，应该就只是有一个离线库。对于多终端消息同步的场景，比如一个新设备要查看和某人的所有消息，这个时候离线库针对接收人的设计就不太方便进行查询了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568878352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134296,"user_name":"Geek_a2849d","can_delete":false,"product_type":"c1","uid":1183791,"ip_address":"","ucode":"B2EE30752C836E","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/2f/cdd0b5d1.jpg","comment_is_top":false,"comment_ctime":1568796695,"is_pvip":false,"replies":[{"id":"51485","content":"也是可以的，递增id的问题是如何保证任何情况下这个id能够连续递增，否则可能不太好做消息连续性检查。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568805654,"ip_address":"","comment_id":134296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568796695","product_id":100034901,"comment_content":"老师你好，我们在拉取离线消息的时候并没有单独的版本号服务去维护版本号，而是直接通过递增的消息id去替代这个版本号 然后比对消息id去获取离线消息 这样设计是否合理呢？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467695,"discussion_content":"也是可以的，递增id的问题是如何保证任何情况下这个id能够连续递增，否则可能不太好做消息连续性检查。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568805654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134007,"user_name":"儿戏","can_delete":false,"product_type":"c1","uid":1133809,"ip_address":"","ucode":"02956B19F65C7A","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/f1/8dc266ee.jpg","comment_is_top":false,"comment_ctime":1568716573,"is_pvip":false,"replies":[{"id":"51496","content":"看具体业务场景吧，http轮询实现比较简单，但是资源消耗会多一些，如果有一定的研发能力，可以考虑基于mqtt进行简单的改造来实现，另外，websocket也是一个不错的选择。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568807318,"ip_address":"","comment_id":134007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568716573","product_id":100034901,"comment_content":"老师，我想问下客户端与服务端的通信用哪种方式比较好,http轮询还是websocket,还是有别的更好的方式？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467579,"discussion_content":"看具体业务场景吧，http轮询实现比较简单，但是资源消耗会多一些，如果有一定的研发能力，可以考虑基于mqtt进行简单的改造来实现，另外，websocket也是一个不错的选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568807318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133781,"user_name":"🐾","can_delete":false,"product_type":"c1","uid":1087256,"ip_address":"","ucode":"D0AD0260351C31","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/18/a5218104.jpg","comment_is_top":false,"comment_ctime":1568655567,"is_pvip":false,"replies":[{"id":"51490","content":"有的信令不是消息维度的，比如删除某一个会话，或者删除所有消息等等，这些信令不适合存储在索引表里。另外，索引表是会话维度的，而获取离线消息实际上是需要用户维度的所有消息，所以通过索引表来获取离线消息会比较麻烦和低效。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568806233,"ip_address":"","comment_id":133781,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568655567","product_id":100034901,"comment_content":"袁老师好，这里有个疑问，不明白为什么需要离线消息表？即时通讯系统里会有哪些操作信令是无法在索引表中标记的？像常见的删除和撤回两个信令，其实都是可以通过索引表来实现：<br><br>1、如果用户A只是删除了与某一联系人B的某一条聊天消息，程序的流程是，先在本地客户端删除该消息，再把该消息的删除状态发送回服务端，服务端收到后，在消息索引表找到这条消息，并标记该消息为删除状态，同时修改该消息对应的版本号，然后返回给客户端这个新版本号，客户端同步修改被删除消息的版本号。<br>后来用户A在另一设备登陆，打开与联系人B的会话界面，会触发拉取消息记录的操作（目的是同步消息），因为此时用户A与联系人B的消息版本号在新登陆设备要比服务端的小（被删除的消息的版本号是最后更新的），所以拉取的消息记录包含了被删除的消息，客户端检测到该消息被删除，同步消息状态和版本号至本地客户端，然后聊天界面控制不显示被删除的消息。<br><br>2、对于撤回消息信令，其流程跟删除消息信令差不多，只是除了要标记该消息的撤回状态和修改版本号外，还需要同步修改该消息的接收方对应的消息索引表记录，修改撤回状态和版本号。消息发送方和接收方拉取消息记录是和删除信令的判断一样。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467505,"discussion_content":"有的信令不是消息维度的，比如删除某一个会话，或者删除所有消息等等，这些信令不适合存储在索引表里。另外，索引表是会话维度的，而获取离线消息实际上是需要用户维度的所有消息，所以通过索引表来获取离线消息会比较麻烦和低效。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568806233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133722,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1568641118,"is_pvip":false,"replies":[{"id":"51488","content":"业务上能接受的话是可以的呀，微博消息箱早期也是没有离线消息buffer的，逐步演进后后慢慢加起来的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568806002,"ip_address":"","comment_id":133722,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568641118","product_id":100034901,"comment_content":"老师 我们做im时没有专门设置一个离线数据库 是直接根据客户端的时间戳从收发索引表里查的 当然 这会漏掉您说的信令消息 但是 并没有觉得漏掉信令消息是问题 因为 信令消息一般都是改群成员和个人信息 我们在登录时做一次整体同步就好了。其他的信令消息也就只有删除消息这个场景，如果要做的好的话确实需要做离线消息，但是这个对一些产品定位低点的好像不太重要。另外，我们以前做过一个版本，是把聊天消息和信令消息都作为普通消息记到消息索引表里，这样不需要离线消息库了。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467485,"discussion_content":"业务上能接受的话是可以的呀，微博消息箱早期也是没有离线消息buffer的，逐步演进后后慢慢加起来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568806002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133704,"user_name":"钢","can_delete":false,"product_type":"c1","uid":1106184,"ip_address":"","ucode":"A49848BF63A579","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/08/3dc76043.jpg","comment_is_top":false,"comment_ctime":1568639206,"is_pvip":false,"replies":[{"id":"51487","content":"哈哈，你这个想法不错，有点类似迅雷的p2p下载了，个人感觉理论上也不是行不通，就是实现起来会比较麻烦一些，相对于稳定的服务端来说p2p的个人网络还是会差一些。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568805933,"ip_address":"","comment_id":133704,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568639206","product_id":100034901,"comment_content":"老师，我有个想法，如果是多个终端在同一局域网，是不是只要同步一个终端，别外终端就在这个已经同步的终端设备进行数据的获取。这样流量就大大节省，当然，这种实现在业务不值得推荐哈😄","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467479,"discussion_content":"哈哈，你这个想法不错，有点类似迅雷的p2p下载了，个人感觉理论上也不是行不通，就是实现起来会比较麻烦一些，相对于稳定的服务端来说p2p的个人网络还是会差一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568805933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133583,"user_name":"一路向北","can_delete":false,"product_type":"c1","uid":1376654,"ip_address":"","ucode":"54D8F1687AE1ED","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/8e/48e7c474.jpg","comment_is_top":false,"comment_ctime":1568614808,"is_pvip":false,"replies":[{"id":"51305","content":"如之前的回答，多终端消息漫游的情况，这个时候可能推送的不仅仅是消息，还可能是一些操作的信令，这些信令一般不会进行持久化，如果只是获取消息可能会丢掉这些信令。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568629143,"ip_address":"","comment_id":133583,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1568614808","product_id":100034901,"comment_content":"多终端漫游可不可以这样呢？<br>在前面提到，为了保证消息的时序，采用全局自增序列，我建议把这个序列号存入服务端和客户端的消息表中。当用户上线时，将本设备最新的序列号发送给服务端，服务端将这个序列号与自己表中的数据比较，大于这个序列号的所有消息都是此设备需要接收的消息，这样也不需要单独维护离线消息","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467434,"discussion_content":"如之前的回答，多终端消息漫游的情况，这个时候可能推送的不仅仅是消息，还可能是一些操作的信令，这些信令一般不会进行持久化，如果只是获取消息可能会丢掉这些信令。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568629143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376654,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/8e/48e7c474.jpg","nickname":"一路向北","note":"","ucode":"54D8F1687AE1ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13058,"discussion_content":"所以，我觉得信令可以作为消息的一个字段来存储","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568637444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376654,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/8e/48e7c474.jpg","nickname":"一路向北","note":"","ucode":"54D8F1687AE1ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13057,"discussion_content":"为什么不把信令持久化呢？我们并不能确定一个用户能够拥有多少设备，如果某个用户经常使用两个设备，忽然开始使用第三个设备，很久之前的信令能否保存？能否在第三个设备上有效执行呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568637407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133554,"user_name":"寒窗剪月","can_delete":false,"product_type":"c1","uid":1645315,"ip_address":"","ucode":"1E871DEDA29FB9","user_header":"https://static001.geekbang.org/account/avatar/00/19/1b/03/1199ed5a.jpg","comment_is_top":false,"comment_ctime":1568604355,"is_pvip":false,"replies":[{"id":"51304","content":"嗯，推拉结合的方式是没问题的。但是也考虑下需要多终端消息漫游的情况，这个时候可能推送的不仅仅是消息，还可能是一些操作的信令，这些信令一般不会进行持久化，如果业务上要求这些信令不能丢失的话，拉取模式可能就会有问题。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568629036,"ip_address":"","comment_id":133554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568604355","product_id":100034901,"comment_content":"解决用户的离线消息比过多上线时消息推送数据量太大的问题，我们可以采用离线消息分页功能，默认只返回一定数目的未读消息。客户端同时做好消息的缝隙记录。用户滑动到消息缝隙的位置的时候再拉取相应位置的内容。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467426,"discussion_content":"嗯，推拉结合的方式是没问题的。但是也考虑下需要多终端消息漫游的情况，这个时候可能推送的不仅仅是消息，还可能是一些操作的信令，这些信令一般不会进行持久化，如果业务上要求这些信令不能丢失的话，拉取模式可能就会有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568629036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133552,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1568603446,"is_pvip":false,"replies":[{"id":"51303","content":"是的，折中考虑资源开销和实时性、以及不丢信令的要求，推拉结合是一种不错的获取离线消息的方式。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568628927,"ip_address":"","comment_id":133552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568603446","product_id":100034901,"comment_content":"      阐述一下我学完后的个人观点吧：大家探讨交流一下-毕竟这块其实没有唯一的答案，老师记得分享老师自己觉得合适的方案就好^_^<br>      这就像查购物订单一样：FIFO其实蛮合适的，我们最关心的都是最新的数据；点击历史的时候再做传输，内存中只保留最新的部分，点击历史再传输历史数据，这应当是目前最主流的方式且使用最多的方式吧：只显示最新的几条，翻阅的时候再显示历史-减少一次性的数据传输率。<br>       其实不同客户端一次性传输的量是不同的：我们很少会在移动端做大量的历史查询，这个度的把握其实是需要在实际场景摸索的；屏幕不一样，一次性看到的量不一样，使用的数据系统不同策略可能同样有所不同，这个学生的一点薄见。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467425,"discussion_content":"是的，折中考虑资源开销和实时性、以及不丢信令的要求，推拉结合是一种不错的获取离线消息的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568628927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}