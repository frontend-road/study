{"id":740819,"title":"第 16 章 集合(2)","content":"<h2 id=\"nav_point_295\">16.5　<code>HashMap&lt;K, V&gt;</code> 与 <code>BTreeMap&lt;K, V&gt;</code></h2>\n<p><code>Map</code> 是键-值对［称为<strong>条目</strong>（entry）］的集合。任何两个条目都不会有相同的键，并且这些条目会始终按某种数据结构进行组织，从而使你可以通过键在 <code>Map</code> 中高效地查找对应的值。简而言之，<code>Map</code> 就是一个查找表。</p>\n<p>Rust 提供了两种 <code>Map</code> 类型：<code>HashMap&lt;K, V&gt;</code> 和 <code>BTreeMap&lt;K, V&gt;</code>。这两种类型共享许多相同的方法，区别在于它们如何组织条目以便进行快速查找。</p>\n<p><code>HashMap</code> 会将键和值存储在哈希表中，因此它需要一个实现了 <code>Hash</code> 和 <code>Eq</code> 的键类型 <code>K</code>，即用来求哈希与判断相等性的标准库特型。</p>\n<p>图 16-4 展示了 <code>HashMap</code> 在内存中的排列方式。深灰色区域表示未使用。所有键、值和缓存的哈希码都存储在一个分配在堆上的表中。添加条目最终会迫使 <code>HashMap</code> 分配一个更大的表并将所有数据移入其中。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00867.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-4：内存中的 <code>HashMap</code></strong></p>\n<p><code>BTreeMap</code> 会在树结构中按键的顺序存储条目，因此它需要一个实现了 <code>Ord</code> 的键类型 <code>K</code>。图 16-5 展示了一个 <code>BTreeMap</code>。同样，深灰色区域表示未使用的备用容量。</p>\n<p><code>BTreeMap</code> 中存储条目的单元称为<strong>节点</strong>。<code>BTreeMap</code> 中的大多数节点仅包含键-值对。非叶节点（比如图 16-5 中所示的根节点）中也有一些空间用于存储指向子节点的指针。<code>(20, 'q')</code> 和 <code>(30, 'r')</code> 之间的指针会指向包含 <code>20</code> 和 <code>30</code> 之间所有键的子节点。添加条目通常需要将节点的一些现有条目向右平移，以保持它们的顺序，并且偶尔需要创建新节点。</p><!-- [[[read_end]]] -->\n<p>为了适合页面大小，图 16-5 已略作简化。例如，真正的 <code>BTreeMap</code> 节点会有 11 个条目的空间，而不是 4 个。</p>\n<p>Rust 标准库采用了 B 树而不是平衡二叉树，因为 B 树在现代硬件上速度更快。两相对比，二叉树固然在每次搜索时的比较次数较少，但 B 树具有更好的<strong>局部性</strong>（也就是说，内存访问被分组在一起，而不是分散在整个堆中）。这使得 CPU 缓存未命中的情况更为罕见。这会带来显著的速度提升。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00868.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-5：内存中的 BTreeMap</strong></p>\n<p>下面是创建 <code>Map</code> 的几种方法。</p>\n<blockquote>\n<p><code>HashMap::new()</code>（新建）和 <code>BTreeMap::new()</code>（新建）</p>\n</blockquote>\n<p>创建新的空 <code>Map</code>。</p>\n<blockquote>\n<p><code>iter.collect()</code>（收集）</p>\n</blockquote>\n<p>可用于从键-值对创建和填充新的 <code>HashMap</code> 或 <code>BTreeMap</code>。<code>iter</code> 必须是 <code>Iterator&lt;Item=(K, V)&gt;</code> 类型的。</p>\n<blockquote>\n<p><code>HashMap::with_capacity(n)</code>（自带容量）</p>\n</blockquote>\n<p>创建一个新的空 <code>HashMap</code>，其中至少有 <code>n</code> 个条目的空间。与向量一样，<code>HashMap</code> 会将数据存储在分配在堆上的单块内存中，因此它们有容量及其相关方法 <code>hash_map.capacity()</code>、<code>hash_map.reserve(additional)</code> 和 <code>hash_map.shrink_to_fit()</code>。<code>BTreeMap</code> 则没有这些。</p>\n<p><code>HashMap</code> 和 <code>BTreeMap</code> 用于处理键和值的核心方法是一样的。</p>\n<blockquote>\n<p><code>map.len()</code>（长度）</p>\n</blockquote>\n<p>返回条目数。</p>\n<blockquote>\n<p><code>map.is_empty()</code>（为空？）</p>\n</blockquote>\n<p>如果 <code>map</code> 没有条目，则返回 <code>true</code>。</p>\n<blockquote>\n<p><code>map.contains_key(&amp;key)</code>（包含 <code>key</code>？）</p>\n</blockquote>\n<p>如果 <code>map</code> 具有给定 <code>key</code> 的条目，则返回 <code>true</code>。</p>\n<blockquote>\n<p><code>map.get(&amp;key)</code>（按 <code>key</code> 获取）</p>\n</blockquote>\n<p>在 <code>map</code> 中搜索具有给定 <code>key</code> 的条目。如果找到匹配的条目，就返回 <code>Some(r)</code>，其中 <code>r</code> 是对相应值的引用。如果没找到，则返回 <code>None</code>。</p>\n<blockquote>\n<p><code>map.get_mut(&amp;key)</code>（按 <code>key</code> 获取，可变版）</p>\n</blockquote>\n<p>与 <code>map.get(&amp;key)</code> 类似，但此方法会返回对值的可变引用。</p>\n<p>一般来说，<code>Map</code> 允许对其存储的值进行可变访问，但不允许对键进行可变访问。你可以随意修改这些值，但键属于 <code>Map</code> 本身，需要确保它们不会改变，因为条目是根据对应的键来组织的。对键进行就地修改是错误的。</p>\n<blockquote>\n<p><code>map.insert(key, value)</code>（插入）</p>\n</blockquote>\n<p>将条目 <code>(key, value)</code> 插入 <code>map</code> 并返回旧值（如果有的话）。返回类型是 <code>Option&lt;V&gt;</code>。如果 <code>Map</code> 中已有 <code>key</code> 条目，则新插入的 <code>value</code> 会覆盖旧值。</p>\n<blockquote>\n<p><code>map.extend(iterable)</code>（用 <code>iterable</code> 扩展）</p>\n</blockquote>\n<p>遍历 <code>iterable</code> 中的 <code>(K, V)</code> 项并将这些键和值逐个插入 <code>map</code> 中。</p>\n<blockquote>\n<p><code>map.append(&amp;mut map2)</code>（从 <code>map2</code> 追加）</p>\n</blockquote>\n<p>将所有条目从 <code>map2</code> 移动到 <code>map</code> 中。之后，<code>map2</code> 会变空。</p>\n<blockquote>\n<p><code>map.remove(&amp;key)</code>（按 <code>key</code> 移除值）</p>\n</blockquote>\n<p>从 <code>map</code> 中查找并移除具有给定 <code>key</code> 的任何条目，如果存在，就返回刚刚移除的值。返回类型是 <code>Option&lt;V&gt;</code>。</p>\n<blockquote>\n<p><code>map.remove_entry(&amp;key)</code>（按 <code>key</code> 移除条目）</p>\n</blockquote>\n<p>从 <code>map</code> 中查找并移除具有给定 <code>key</code> 的任何条目，返回刚刚移除的键和值（如果有的话）。返回类型是 <code>Option&lt;(K, V)&gt;</code>。</p>\n<blockquote>\n<p><code>map.retain(test)</code>（留下）</p>\n</blockquote>\n<p>移除所有未通过给定测试的元素。<code>test</code> 参数是实现了 <code>FnMut(&amp;K, &amp;mut V) -&gt; bool</code> 的函数或闭包。对于 <code>map</code> 中的每个元素，都会调用 <code>test(&amp;key, &amp;mut value)</code>，如果此函数或闭包返回 <code>false</code>，则从 <code>map</code> 中移除并丢弃该元素。</p>\n<p>除了性能上有些许区别，此方法和下面的写法很像。</p>\n<pre class=\"code-rows\"><code>map = map.into_iter().filter(test).collect();</code></pre>\n<blockquote>\n<p><code>map.clear()</code>（清空）</p>\n</blockquote>\n<p>移除所有条目。</p>\n<p>也可以使用方括号来查询 <code>Map</code>，比如 <code>map[&amp;key]</code>。也就是说，<code>Map</code> 实现了内置特型 <code>Index</code>。但是，如果给定 <code>key</code> 还没有条目（就像越界数组访问），则会出现 panic，因此只有在要查找的条目肯定已填充过时才应使用此语法。</p>\n<p><code>.contains_key()</code>、<code>.get()</code>、<code>.get_mut()</code> 和 <code>.remove()</code> 的 <code>key</code> 参数不必具有确切的类型 <code>&amp;K</code>。这些方法对可以从 <code>K</code> 借用来的类型来说是通用的。可以在 <code>HashMap&lt;String, Fish&gt;</code> 上调用 <code>fish_map.contains_key(\"conger\")</code>，即便 <code>\"conger\"</code> 不是确切的 <code>String</code> 类型也没问题，因为 <code>String</code> 实现了 <code>Borrow&lt;&amp;str&gt;</code>。有关详细信息，请参阅 13.8 节。</p>\n<p>因为 <code>BTreeMap&lt;K, V&gt;</code> 会始终保持其条目是根据键排序的，所以它支持一些额外的操作。</p>\n<blockquote>\n<p><code>btree_map.split_off(&amp;key)</code>（拆分出）</p>\n</blockquote>\n<p>把 <code>btree_map</code> 一分为二。将键小于 <code>key</code> 的条目留在 <code>btree_map</code> 中。返回包含其他条目的新 <code>BTreeMap&lt;K, V&gt;</code>。</p>\n<h3 id=\"nav_point_296\">16.5.1　条目</h3>\n<p><code>HashMap</code> 和 <code>BTreeMap</code> 都有其对应的 <code>Entry</code>（条目）类型。条目的作用旨在消除冗余的 <code>Map</code> 查找。例如，下面是一些获取或创建学生记录的代码：</p>\n<pre class=\"code-rows\"><code>// 已经有关于此学生的记录了吗？\nif !student_map.contains_key(name) {\n    // 没有：创建一个\n    student_map.insert(name.to_string(), Student::new());\n}\n// 现在，肯定存在一条记录了\nlet record = student_map.get_mut(name).unwrap();\n...</code></pre>\n<p>这固然可以正常工作，但它会访问 <code>student_map</code> 两次或 3 次，每次都进行同样的查找。</p>\n<p>对于这些条目，我们应该只进行一次查找，生成一个 <code>Entry</code> 值，然后将其用于所有后续操作。下面这个单行代码等效于上一段代码，但它只会执行一次查找：</p>\n<pre class=\"code-rows\"><code>let record = student_map.entry(name.to_string()).or_insert_with(Student::new);</code></pre>\n<p><code>student_map.entry(name.to_string())</code> 返回的 <code>Entry</code> 值就像对 <code>Map</code> 中某个位置的可变引用，该位置要么由键-值对<strong>占用</strong>着，要么是<strong>空</strong>的（意味着那里还没有条目）。如果为空，那么条目的 <code>.or_insert_with()</code> 方法就会插入一个新的 <code>Student</code>。<code>Entry</code> 的大多数用法也是这样的：小而美。</p>\n<p>所有 <code>Entry</code> 值都是由同一个方法创建的。</p>\n<blockquote>\n<p><code>map.entry(key)</code>（按 <code>key</code> 取条目）</p>\n</blockquote>\n<p>返回给定 <code>key</code> 的 <code>Entry</code>。如果 <code>Map</code> 中没有这样的键，则返回一个空的 <code>Entry</code>。</p>\n<p>此方法会通过可变引用获取其 <code>self</code> 参数并返回与其生命周期一致的 <code>Entry</code>：</p>\n<pre class=\"code-rows\"><code>pub fn entry&lt;'a&gt;(&amp;'a mut self, key: K) -&gt; Entry&lt;'a, K, V&gt;</code></pre>\n<p><code>Entry</code> 类型有一个生命周期参数 <code>'a</code>，因为它实际上是一种奇特的对 <code>Map</code> 的可变引用。只要 <code>Entry</code> 存在，它就拥有对此 <code>Map</code> 的独占访问权。</p>\n<p>通过 5.3.5 节，我们已经了解了如何在类型中存储引用以及这会如何影响生命周期。现在我们正在从用户的视角来看待它。<code>Entry</code> 就是一例。</p>\n<p>遗憾的是，如果 <code>Map</code> 具有 <code>String</code> 型的键，则无法将 <code>&amp;str</code> 类型的引用传给此方法。在这种情况下，<code>.entry()</code> 方法需要一个真正的 <code>String</code> 型的值。</p>\n<p><code>Entry</code> 值提供了以下 3 个方法来处理空条目。</p>\n<blockquote>\n<p><code>map.entry(key).or_insert(value)</code>（取条目或插入）</p>\n</blockquote>\n<p>确保 <code>map</code> 包含具有给定 <code>key</code> 的条目，如果需要，就插入具有给定 <code>value</code> 的新条目。此方法会返回对新值或现有值的可变引用。</p>\n<p>假设我们需要统计选票。可以这样写：</p>\n<pre class=\"code-rows\"><code>let mut vote_counts: HashMap&lt;String, usize&gt; = HashMap::new();\nfor name in ballots {\n    let count = vote_counts.entry(name).or_insert(0);\n    *count += 1;\n}</code></pre>\n<p><code>.or_insert()</code> 会返回一个可变引用，所以 <code>count</code> 的类型是 <code>&amp;mut usize</code>。</p>\n<blockquote>\n<p><code>map.entry(key).or_default()</code>（取条目或插入默认值）</p>\n</blockquote>\n<p>确保 <code>map</code> 包含具有给定键的条目，如果需要，就插入一个具有 <code>Default::default()</code> 返回值的新条目。这仅适用于实现了 <code>Default</code> 的类型。与 <code>or_insert</code> 类似，此方法会返回对新值或现有值的可变引用。</p>\n<blockquote>\n<p><code>map.entry(key).or_insert_with(default_fn)</code>（取条目或借助 <code>default_fn</code> 插入）</p>\n</blockquote>\n<p>与前两个方法类似，不过当需要创建一个新条目时，此方法会调用 <code>default_fn()</code> 来生成默认值。如果 <code>map</code> 中已经有了 <code>key</code> 条目，则不会调用 <code>default_fn</code>。</p>\n<p>假设我们想知道哪些词出现在了哪些文件中。可以这样写：</p>\n<pre class=\"code-rows\"><code>// 对于每个单词，这个`Map`包含一组曾出现过此单词的文件\nlet mut word_occurrence: HashMap&lt;String, HashSet&lt;String&gt;&gt; =\n    HashMap::new();\nfor file in files {\n    for word in read_words(file)? {\n        let set = word_occurrence\n            .entry(word)\n            .or_insert_with(HashSet::new);\n        set.insert(file.clone());\n    }\n}</code></pre>\n<p><code>Entry</code> 还提供了一个仅修改现有字段的便捷方法。</p>\n<blockquote>\n<p><code>map.entry(key).and_modify(closure)</code>（取条目并修改）</p>\n</blockquote>\n<p>如果存在具有键 <code>key</code> 的条目，则调用 <code>closure</code>，并传入对该值的可变引用。此方法会返回 <code>Entry</code>，因此可以与其他方法做链式调用。</p>\n<p>例如，可以使用此方法来计算字符串中单词出现的次数：</p>\n<pre class=\"code-rows\"><code>// 这个`Map`包含给定字符串的所有单词以及单词的出现次数\nlet mut word_frequency: HashMap&lt;&amp;str, u32&gt; = HashMap::new();\nfor c in text.split_whitespace() {\n    word_frequency.entry(c)\n        .and_modify(|count| *count += 1)\n        .or_insert(1);\n}</code></pre>\n<p><code>Entry</code> 类型是为 <code>HashMap</code> 专门定义的一个枚举（<code>BTreeMap</code> 也类似）：</p>\n<pre class=\"code-rows\"><code>// (in std::collections::hash_map)\npub enum Entry&lt;'a, K, V&gt; {\n    Occupied(OccupiedEntry&lt;'a, K, V&gt;),\n    Vacant(VacantEntry&lt;'a, K, V&gt;)\n}</code></pre>\n<p><code>OccupiedEntry</code> 类型和 <code>VacantEntry</code> 类型都有一些无须重复查找即可插入、移除和访问条目的方法。可以在在线文档中找到这些方法。这些额外的方法有时可用于消除一两次冗余查找，不过 <code>.or_insert()</code> 和 <code>.or_insert_with()</code> 已经涵盖了几种常见情况。</p>\n<h3 id=\"nav_point_297\">16.5.2　对 <code>Map</code> 进行迭代</h3>\n<p>以下几个方法可以对 <code>Map</code> 进行迭代。</p>\n<ul>\n<li>按值迭代（<code>for (k, v) in map</code>）以生成 <code>(K, V)</code> 对。这会消耗 <code>Map</code>。</li>\n<li>按共享引用迭代（<code>for (k, v) in &amp;map</code>）以生成 <code>(&amp;K, &amp;V)</code> 对。</li>\n<li>按可变引用迭代（<code>for (k, v) in &amp;mut map</code>）以生成 <code>(&amp;K, &amp;mut V)</code> 对。（同样，无法对存储在 <code>Map</code> 中的键进行可变访问，因为这些条目是通过它们的键进行组织的。）</li>\n</ul>\n<p>与向量类似，<code>Map</code> 也有 <code>.iter()</code> 方法和 <code>.iter_mut()</code> 方法，它们会返回针对“条目引用”的迭代器，可用来迭代 <code>&amp;map</code> 或 <code>&amp;mut map</code>。此外，还有以下迭代方法。</p>\n<blockquote>\n<p><code>map.keys()</code>（所有键的迭代器）</p>\n</blockquote>\n<p>返回只有“键引用”的迭代器。</p>\n<blockquote>\n<p><code>map.values()</code>（所有值的迭代器）</p>\n</blockquote>\n<p>返回只有“值引用”的迭代器。</p>\n<blockquote>\n<p><code>map.values_mut()</code>（所有值的可变迭代器）</p>\n</blockquote>\n<p>返回只有“值可变引用”的迭代器。</p>\n<blockquote>\n<p><code>map.into_iter()</code>（转为迭代器）、<code>map.into_keys()</code>（转为键迭代器）和 <code>map.into_values()</code>（转为值迭代器）</p>\n</blockquote>\n<p>消耗此 <code>Map</code>，分别返回遍历键值元组 <code>(K, V)</code>、键或值的迭代器。</p>\n<p>所有 <code>HashMap</code> 迭代器都会以任意顺序访问 <code>Map</code> 的条目，而 <code>BTreeMap</code> 迭代器会按 <code>key</code> 的顺序访问它们。</p>\n<h2 id=\"nav_point_298\">16.6　<code>HashSet&lt;T&gt;</code> 与 <code>BTreeSet&lt;T&gt;</code></h2>\n<p><code>Set</code> 是用于快速进行元素存在性测试的集合：</p>\n<pre class=\"code-rows\"><code>let b1 = large_vector.contains(&amp;\"needle\");    // 慢，会检查每一个元素\nlet b2 = large_hash_set.contains(&amp;\"needle\");  // 快，会按哈希查找</code></pre>\n<p><code>Set</code> 中永远不会包含相同值的多个副本。</p>\n<p><code>Map</code> 和 <code>Set</code> 有一些不同的方法，但在幕后，<code>Set</code> 就像一个只有键（而非键-值对）的 <code>Map</code>。事实上，Rust 的两个 <code>Set</code> 类型 <code>HashSet&lt;T&gt;</code> 和 <code>BTreeSet&lt;T&gt;</code> 都是通过对 <code>HashMap&lt;T, ()&gt;</code> 和 <code>BTreeMap&lt;T, ()&gt;</code> 的浅层包装实现的。</p>\n<blockquote>\n<p><code>HashSet::new()</code>（新建）和 <code>BTreeSet::new()</code>（新建）</p>\n</blockquote>\n<p>创建新 <code>Set</code>。</p>\n<blockquote>\n<p><code>iter.collect()</code>（收集）</p>\n</blockquote>\n<p>可用于从任意迭代器创建出新 <code>Set</code>。如果 <code>iter</code> 多次生成了同一个值，则重复项将被丢弃。</p>\n<blockquote>\n<p><code>HashSet::with_capacity(n)</code>（自带容量）</p>\n</blockquote>\n<p>创建一个至少有 <code>n</code> 个值空间的空 <code>HashSet</code>。</p>\n<p><code>HashSet&lt;T&gt;</code> 和 <code>BTreeSet&lt;T&gt;</code> 有以下几个公共的基本方法。</p>\n<blockquote>\n<p><code>set.len()</code>（长度）</p>\n</blockquote>\n<p>返回 <code>set</code> 中值的数量。</p>\n<blockquote>\n<p><code>set.is_empty()</code>（为空？）</p>\n</blockquote>\n<p>如果 <code>set</code> 不包含任何元素，就返回 <code>true</code>。</p>\n<blockquote>\n<p><code>set.contains(&amp;value)</code>（包含）</p>\n</blockquote>\n<p>如果 <code>set</code> 包含给定 <code>value</code>，就返回 <code>true</code>。</p>\n<blockquote>\n<p><code>set.insert(value)</code>（插入）</p>\n</blockquote>\n<p>向 <code>set</code> 中添加一个 <code>value</code>。如果新增了一个值，就返回 <code>true</code>；如果它先前已是此 <code>set</code> 的成员，则返回 <code>false</code>。</p>\n<blockquote>\n<p><code>set.remove(&amp;value)</code>（移除）</p>\n</blockquote>\n<p>从 <code>set</code> 中移除一个 <code>value</code>。如果移除了一个值，就返回 <code>true</code>；如果它之前不是此 <code>set</code> 的成员，则返回 <code>false</code>。</p>\n<blockquote>\n<p><code>set.retain(test)</code>（留下）</p>\n</blockquote>\n<p>移除所有未通过给定测试的元素。<code>test</code> 参数是实现了 <code>FnMut(&amp;T) -&gt; bool</code> 的函数或闭包。对于 <code>set</code> 中的每个元素，此方法都会调用 <code>test(&amp;value)</code>，如果它返回 <code>false</code>，则该元素将被从此 <code>set</code> 中移除并丢弃。</p>\n<p>除了性能上略有差异，此方法和下面的写法很像。</p>\n<pre class=\"code-rows\"><code>set = set.into_iter().filter(test).collect();</code></pre>\n<p>与 <code>Map</code> 一样，通过引用查找值的方法对于可以从 <code>T</code> 借用来的类型都是通用的。有关详细信息，请参阅 13.8 节。</p>\n<h3 id=\"nav_point_299\">16.6.1　对 <code>Set</code> 进行迭代</h3>\n<p>以下两个方法可以迭代 <code>Set</code>。</p>\n<ul>\n<li>按值迭代（<code>for v in set</code>）会生成 <code>Set</code> 的成员并消耗掉此 <code>Set</code>。</li>\n<li>按共享引用（<code>for v in &amp;set</code>）迭代会生成对 <code>Set</code> 成员的共享引用。</li>\n</ul>\n<p>不支持通过可变引用迭代 <code>Set</code>。无法获取对存储在 <code>Set</code> 中的值的可变引用。</p>\n<blockquote>\n<p><code>set.iter()</code>（迭代器）</p>\n</blockquote>\n<p>返回 <code>set</code> 中成员引用的迭代器。</p>\n<p>与 <code>HashMap</code> 迭代器类似，<code>HashSet</code> 迭代器会以任意顺序生成它们的值。<code>BTreeSet</code> 迭代器会按顺序生成值，就像一个排好序的向量。</p>\n<h3 id=\"nav_point_300\">16.6.2　当相等的值不完全相同时</h3>\n<p><code>Set</code> 有一些奇怪的方法，只有当你关心“相等”的值之间的差异时才需要使用这些方法。</p>\n<p>这种差异确实经常存在。例如，两个内容相同的 <code>String</code> 值会将它们的字符存储在内存中的不同位置：</p>\n<pre class=\"code-rows\"><code>let s1 = \"hello\".to_string();\nlet s2 = \"hello\".to_string();\nprintln!(\"{:p}\", &amp;s1 as &amp;str);  // 0x7f8b32060008\nprintln!(\"{:p}\", &amp;s2 as &amp;str);  // 0x7f8b32060010</code></pre>\n<p>通常，我们不必在乎这种差异。</p>\n<p>但如果确实需要关心这两个 <code>String</code> 的存储位置，就可以用以下方法访问存储在 <code>Set</code> 中的实际值。如果 <code>set</code> 不包含匹配值，则每个方法都会返回一个为 <code>None</code> 的 <code>Option</code>。</p>\n<blockquote>\n<p><code>set.get(&amp;value)</code>（取值）</p>\n</blockquote>\n<p>返回对等于 <code>value</code> 的 <code>set</code> 成员的共享引用（如果有的话）。返回类型是 <code>Option&lt;&amp;T&gt;</code>。</p>\n<blockquote>\n<p><code>set.take(&amp;value)</code>（拿出值）</p>\n</blockquote>\n<p>与 <code>set.remove(&amp;value)</code> 类似，但此方法会返回所移除的值（如果有的话）。返回类型是 <code>Option&lt;T&gt;</code>。</p>\n<blockquote>\n<p><code>set.replace(value)</code>（替换为）</p>\n</blockquote>\n<p>与 <code>set.insert(value)</code> 类似，但如果 <code>set</code> 已经包含一个等于 <code>value</code> 的值，那么此方法就会替代并返回原来的值。返回类型是 <code>Option&lt;T&gt;</code>。</p>\n<h3 id=\"nav_point_301\">16.6.3　针对整个 <code>Set</code> 的运算</h3>\n<p>迄今为止，我们看到的大多数 <code>set</code> 方法专注于单个 <code>Set</code> 中的单个值。<code>Set</code> 还有一些对整个 <code>Set</code> 进行运算的方法。</p>\n<blockquote>\n<p><code>set1.intersection(&amp;set2)</code>（交集）</p>\n</blockquote>\n<p>返回同时出现在 <code>set1</code> 和 <code>set2</code> 中的值的迭代器。</p>\n<p>如果想打印同时参加脑外科和火箭科学课程的所有学生的姓名，可以这样写：</p>\n<pre class=\"code-rows\"><code>for student in &amp;brain_class {\n    if rocket_class.contains(student) {\n        println!(\"{}\", student);\n    }\n}</code></pre>\n<p>或者，再精简一些：</p>\n<pre class=\"code-rows\"><code>for student in brain_class.intersection(&amp;rocket_class) {\n    println!(\"{}\", student);\n}</code></pre>\n<p>令人惊讶的是，有一个运算符能实现同样的效果。</p>\n<p><code>&amp;set1 &amp; &amp;set2</code> 会返回一个新 <code>Set</code>，该 <code>Set</code> 是 <code>set1</code> 和 <code>set2</code> 的交集。这是把“二进制按位与”运算符应用在了两个引用之间。这样就会找到同时存在于 <code>set1</code> <strong>和</strong> <code>set2</code> 中的值。</p>\n<pre class=\"code-rows\"><code>let overachievers = &amp;brain_class &amp; &amp;rocket_class;</code></pre>\n<blockquote>\n<p><code>set1.union(&amp;set2)</code>（并集）</p>\n</blockquote>\n<p>返回存在于 <code>set1</code> 或 <code>set2</code> 中或者同时存在于两者中的值的迭代器。</p>\n<p><code>&amp;set1 | &amp;set2</code> 会返回包含所有这些值的新 <code>Set</code>。它会找出所有存在于 <code>set1</code> <strong>或</strong> <code>set2</code> 中的值。</p>\n<blockquote>\n<p><code>set1.difference(&amp;set2)</code>（差集）</p>\n</blockquote>\n<p>返回存在于 <code>set1</code> 但不在于 <code>set2</code> 中的值的迭代器。</p>\n<p><code>&amp;set1 - &amp;set2</code> 会返回包含所有此类值的新 <code>Set</code>。</p>\n<blockquote>\n<p><code>set1.symmetric_difference(&amp;set2)</code>（对称差集，异或）</p>\n</blockquote>\n<p>返回存在于 <code>set1</code> 或 <code>set2</code> 中但不同时存在于两者中的迭代器。</p>\n<p><code>&amp;set1 ^ &amp;set2</code> 会返回包含所有此类值的新 <code>Set</code>。</p>\n<p>以下是测试 <code>Set</code> 之间关系的 3 个方法。</p>\n<blockquote>\n<p><code>set1.is_disjoint(set2)</code>（有交集？）</p>\n</blockquote>\n<p>如果 <code>set1</code> 和 <code>set2</code> 没有共同的值，就返回 <code>true</code>——它们之间的交集为空。</p>\n<blockquote>\n<p><code>set1.is_subset(set2)</code>（是子集？）</p>\n</blockquote>\n<p>如果 <code>set1</code> 是 <code>set2</code> 的子集，就返回 <code>true</code>。也就是说，<code>set1</code> 中的所有值都在 <code>set2</code> 中。</p>\n<blockquote>\n<p><code>set1.is_superset(set2)</code>（是超集？）</p>\n</blockquote>\n<p>与上一个方法相反：如果 <code>set1</code> 是 <code>set2</code> 的超集，就返回 <code>true</code>。</p>\n<p><code>Set</code> 还支持使用 <code>==</code> 和 <code>!=</code> 进行相等性测试。如果两个 <code>Set</code> 包含完全相同的一组值，那它们就是相等的。</p>\n<h2 id=\"nav_point_302\">16.7　哈希</h2>\n<p><code>std::hash::Hash</code> 是可哈希类型的标准库特型。<code>HashMap</code> 的键和 <code>HashSet</code> 的元素都必须实现 <code>Hash</code> 和 <code>Eq</code>。</p>\n<p>大多数实现了 <code>Eq</code> 的内置类型也会实现 <code>Hash</code>。整数、<code>char</code> 和 <code>String</code> 都是可哈希的。对元组、数组、切片和向量来说，只要它们的元素是可哈希的，它们自身就是可哈希的。</p>\n<p>标准库的一个设计原则是，无论将值存储在何处或如何指向它，都应具有相同的哈希码。因此，引用与其引用的值具有相同的哈希码，而 <code>Box</code> 与其封装的值也具有相同的哈希码。向量 <code>vec</code> 与包含其所有数据的切片 <code>&amp;vec[..]</code> 具有相同的哈希码。<code>String</code> 与具有相同字符的 <code>&amp;str</code> 具有相同的哈希码。</p>\n<p>默认情况下，结构体和枚举没有实现 <code>Hash</code>，但可以派生一个实现：</p>\n<pre class=\"code-rows\"><code>/// 大英博物馆藏品中某件物品的ID号\n#[derive(Clone, PartialEq, Eq, Hash)]\nenum MuseumNumber {\n    ...\n}</code></pre>\n<p>只要此类型的字段都是可哈希的，就可以这样用。</p>\n<p>如果为一个类型手动实现了 <code>PartialEq</code>，那么也应该手动实现 <code>Hash</code>。假设我们有一个代表无价历史宝藏的类型：</p>\n<pre class=\"code-rows\"><code>struct Artifact {\n    id: MuseumNumber,\n    name: String,\n    cultures: Vec&lt;Culture&gt;,\n    date: RoughTime,\n    ...\n}</code></pre>\n<p>如果两个 <code>Artifact</code> 具有相同的 ID，那么就认为它们是相等的：</p>\n<pre class=\"code-rows\"><code>impl PartialEq for Artifact {\n    fn eq(&amp;self, other: &amp;Artifact) -&gt; bool {\n        self.id == other.id\n    }\n}\n\nimpl Eq for Artifact {}</code></pre>\n<p>由于我们仅是根据这些收藏品的 ID 来比较它们，因此也必须以相同的方式对这些收藏品进行哈希处理：</p>\n<pre class=\"code-rows\"><code>use std::hash::;\n\nimpl Hash for Artifact {\n    fn hash&lt;H: Hasher&gt;(&amp;self, hasher: &amp;mut H) {\n        // 把哈希工作委托给藏品编号\n        self.id.hash(hasher);\n    }\n}</code></pre>\n<p>（否则，<code>HashSet&lt;Artifact&gt;</code> 将无法正常工作。与所有哈希表一样，它要求如果 <code>a == b</code>，则必然 <code>hash(a) == hash(b)</code>。）</p>\n<p>这允许我们创建一个 <code>Artifact</code> 的 <code>HashSet</code>：</p>\n<pre class=\"code-rows\"><code>let mut collection = HashSet::&lt;Artifact&gt;::new();</code></pre>\n<p>如上述代码的前一段代码所示，即使要手动实现 <code>Hash</code>，也不需要了解任何有关哈希算法的知识。<code>.hash()</code> 会接收一个表示哈希算法的 <code>Hasher</code> 引用作为参数。你只需将与 <code>==</code> 运算符相关的所有数据提供给这个 <code>Hasher</code> 即可。<code>Hasher</code> 会根据你提供的任何内容计算哈希码。</p>\n<h2 id=\"nav_point_303\">16.8　使用自定义哈希算法</h2>\n<p><code>hash</code> 方法是泛型的，因此 16.7 节展示的 <code>Hash</code> 实现可以将数据提供给实现了 <code>Hasher</code> 的任何类型。这就是 Rust 支持可替换哈希算法的方式。</p>\n<p>第三个特型 <code>std::hash::BuildHasher</code> 是表示哈希算法初始状态的类型的特型。每个 <code>Hasher</code> 都是单次使用的，就像迭代器一样：用过一次就扔掉了。而 <code>BuildHasher</code> 是可重用的。</p>\n<p>每个 <code>HashMap</code> 都包含一个 <code>BuildHasher</code>，每次需要计算哈希码时都会用到。<code>BuildHasher</code> 值包含哈希算法每次运行时所需的键、初始状态或其他参数。</p>\n<p>计算哈希码的完整协议如下所示：</p>\n<pre class=\"code-rows\"><code>use std::hash::;\n\nfn compute_hash&lt;B, T&gt;(builder: &amp;B, value: &amp;T) -&gt; u64\n    where B: BuildHasher, T: Hash\n{\n    let mut hasher = builder.build_hasher();  // 1. 开始此算法\n    value.hash(&amp;mut hasher);                  // 2. 填入数据\n    hasher.finish()                           // 3. 结束，生成u64\n}</code></pre>\n<p><code>HashMap</code> 每次需要计算哈希码时都会调用这 3 个方法。所有的方法都是可内联的，所以速度非常快。</p>\n<p>Rust 的默认哈希算法是著名的 SipHash-1-3 算法。SipHash 的速度很快，而且非常擅长减少哈希冲突。事实上，它也是一个加密算法：目前还没有已知的有效方法能刻意生成与 SipHash-1-3 冲突的值。只要每个哈希表使用不同且无法预测的密钥，Rust 就可以安全地抵御一种称为 HashDoS 的拒绝服务攻击，在这种攻击中，攻击者会故意使用哈希冲突来触发服务器的最坏性能。</p>\n<p>不过，也许你的应用程序不需要此算法。如果要存储诸如整数或非常短的字符串之类的小型键，则可以实现更快的哈希函数，但代价是要牺牲 HashDoS 的安全性。<code>fnv</code> crate 实现了这样的一个算法，即 Fowler-Noll-Vo (FNV) 哈希。要尝试此算法，请将如下内容添加到你的 Cargo.toml 中：</p>\n<pre class=\"code-rows\"><code>[dependencies]\nfnv = \"1.0\"</code></pre>\n<p>然后从 <code>fnv</code> 中导入 <code>Map</code> 类型和 <code>Set</code> 类型：</p>\n<pre class=\"code-rows\"><code>use fnv::;</code></pre>\n<p>可以使用这两种类型作为 <code>HashMap</code> 和 <code>HashSet</code> 的无缝替代品。浏览一下 <code>fnv</code> 源代码，就会发现它们是如何定义的：</p>\n<pre class=\"code-rows\"><code>/// 使用默认FNV哈希器的`HashMap`\npub type FnvHashMap&lt;K, V&gt; = HashMap&lt;K, V, FnvBuildHasher&gt;;\n\n/// 使用默认FNV哈希器的`HashSet`\npub type FnvHashSet&lt;T&gt; = HashSet&lt;T, FnvBuildHasher&gt;;</code></pre>\n<p>标准的 <code>HashMap</code> 集合和 <code>HashSet</code> 集合会接受一个可选的额外类型参数来指定哈希算法，<code>FnvHashMap</code> 和 <code>FnvHashSet</code> 是 <code>HashMap</code> 和 <code>HashSet</code> 的泛型类型别名，用于为那个参数指定一个 FNV 哈希器。</p>\n<h2 id=\"nav_point_304\">16.9　在标准集合之外</h2>\n<p>在 Rust 中创建一个新的自定义集合类型和在其他语言中非常相似。你可以通过组合语言提供的部件（结构体和枚举、标准集合、<code>Option</code>、<code>Box</code> 等）来组织数据。有关示例，请参阅 10.1.4 节定义的 <code>BinaryTree&lt;T&gt;</code> 类型。</p>\n<p>如果你习惯于在 C++ 中实现数据结构，使用裸指针、手动内存管理、定位放置（placement）<code>new</code> 和显式析构函数调用来获得最佳性能，那么你无疑会发现这在安全的 Rust 中处处受限。所有这些工具本质上都是不安全的。可以在 Rust 中使用它们，但前提是要使用不安全的代码。第 22 章展示了如何通过不安全的代码实现它们，其中包括一个示例，该示例使用了一些不安全的代码来实现安全的自定义集合。</p>\n<p>现在，我们将沐浴在标准集合及其安全、高效 API 的和煦阳光中。与 Rust 标准库中的许多 API 一样，这些 API 旨在让你尽可能少写一点儿 <code>unsafe</code> 代码。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 16 章 集合(1)","id":740818},"right":{"article_title":"第 17 章 字符串与文本(1)","id":740820}},"comments":[]}