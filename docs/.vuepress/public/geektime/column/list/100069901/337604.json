{"id":337604,"title":"04 | Raft协议：etcd如何实现高可用、数据强一致的？","content":"<p>你好，我是唐聪。</p><p>在前面的etcd读写流程学习中，我和你多次提到了etcd是基于Raft协议实现高可用、数据强一致性的。</p><p>那么etcd是如何基于Raft来实现高可用、数据强一致性的呢？</p><p>这节课我们就以上一节中的hello写请求为案例，深入分析etcd在遇到Leader节点crash等异常后，Follower节点如何快速感知到异常，并高效选举出新的Leader，对外提供高可用服务的。</p><p>同时，我将通过一个日志复制整体流程图，为你介绍etcd如何保障各节点数据一致性，并介绍Raft算法为了确保数据一致性、完整性，对Leader选举和日志复制所增加的一系列安全规则。希望通过这节课，让你了解etcd在节点故障、网络分区等异常场景下是如何基于Raft算法实现高可用、数据强一致的。</p><h2>如何避免单点故障</h2><p>在介绍Raft算法之前，我们首先了解下它的诞生背景，Raft解决了分布式系统什么痛点呢？</p><p>首先我们回想下，早期我们使用的数据存储服务，它们往往是部署在单节点上的。但是单节点存在单点故障，一宕机就整个服务不可用，对业务影响非常大。</p><p>随后，为了解决单点问题，软件系统工程师引入了数据复制技术，实现多副本。通过数据复制方案，一方面我们可以提高服务可用性，避免单点故障。另一方面，多副本可以提升读吞吐量、甚至就近部署在业务所在的地理位置，降低访问延迟。</p><!-- [[[read_end]]] --><p><strong>多副本复制是如何实现的呢？</strong></p><p>多副本常用的技术方案主要有主从复制和去中心化复制。主从复制，又分为全同步复制、异步复制、半同步复制，比如MySQL/Redis单机主备版就基于主从复制实现的。</p><p><strong>全同步复制</strong>是指主收到一个写请求后，必须等待全部从节点确认返回后，才能返回给客户端成功。因此如果一个从节点故障，整个系统就会不可用。这种方案为了保证多副本的一致性，而牺牲了可用性，一般使用不多。</p><p><strong>异步复制</strong>是指主收到一个写请求后，可及时返回给client，异步将请求转发给各个副本，若还未将请求转发到副本前就故障了，则可能导致数据丢失，但是可用性是最高的。</p><p><strong>半同步复制</strong>介于全同步复制、异步复制之间，它是指主收到一个写请求后，至少有一个副本接收数据后，就可以返回给客户端成功，在数据一致性、可用性上实现了平衡和取舍。</p><p>跟主从复制相反的就是<strong>去中心化复制</strong>，它是指在一个n副本节点集群中，任意节点都可接受写请求，但一个成功的写入需要w个节点确认，读取也必须查询至少r个节点。</p><p>你可以根据实际业务场景对数据一致性的敏感度，设置合适w/r参数。比如你希望每次写入后，任意client都能读取到新值，如果n是3个副本，你可以将w和r设置为2，这样当你读两个节点时候，必有一个节点含有最近写入的新值，这种读我们称之为法定票数读（quorum read）。</p><p>AWS的Dynamo系统就是基于去中心化的复制算法实现的。它的优点是节点角色都是平等的，降低运维复杂度，可用性更高。但是缺陷是去中心化复制，势必会导致各种写入冲突，业务需要关注冲突处理。</p><p>从以上分析中，为了解决单点故障，从而引入了多副本。但基于复制算法实现的数据库，为了保证服务可用性，大多数提供的是最终一致性，总而言之，不管是主从复制还是异步复制，都存在一定的缺陷。</p><p><strong>如何解决以上复制算法的困境呢？</strong></p><p>答案就是共识算法，它最早是基于复制状态机背景下提出来的。 下图是复制状态机的结构（引用自Raft paper）， 它由共识模块、日志模块、状态机组成。通过共识模块保证各个节点日志的一致性，然后各个节点基于同样的日志、顺序执行指令，最终各个复制状态机的结果实现一致。</p><p><img src=\"https://static001.geekbang.org/resource/image/3y/eb/3yy3fbc1ab564e3af9ac9223db1435eb.png?wh=605*319\" alt=\"\"></p><p>共识算法的祖师爷是Paxos， 但是由于它过于复杂，难于理解，工程实践上也较难落地，导致在工程界落地较慢。standford大学的Diego提出的Raft算法正是为了可理解性、易实现而诞生的，它通过问题分解，将复杂的共识问题拆分成三个子问题，分别是：</p><ul>\n<li>Leader选举，Leader故障后集群能快速选出新Leader；</li>\n<li>日志复制， 集群只有Leader能写入日志， Leader负责复制日志到Follower节点，并强制Follower节点与自己保持相同；</li>\n<li>安全性，一个任期内集群只能产生一个Leader、已提交的日志条目在发生Leader选举时，一定会存在更高任期的新Leader日志中、各个节点的状态机应用的任意位置的日志条目内容应一样等。</li>\n</ul><p>下面我以实际场景为案例，分别和你深入讨论这三个子问题，看看Raft是如何解决这三个问题，以及在etcd中的应用实现。</p><h2>Leader选举</h2><p>当etcd server收到client发起的put hello写请求后，KV模块会向Raft模块提交一个put提案，我们知道只有集群Leader才能处理写提案，如果此时集群中无Leader， 整个请求就会超时。</p><p>那么Leader是怎么诞生的呢？Leader crash之后其他节点如何竞选呢？</p><p>首先在Raft协议中它定义了集群中的如下节点状态，任何时刻，每个节点肯定处于其中一个状态：</p><ul>\n<li>Follower，跟随者， 同步从Leader收到的日志，etcd启动的时候默认为此状态；</li>\n<li>Candidate，竞选者，可以发起Leader选举；</li>\n<li>Leader，集群领导者， 唯一性，拥有同步日志的特权，需定时广播心跳给Follower节点，以维持领导者身份。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/a5/09/a5a210eec289d8e4e363255906391009.png?wh=1808*978\" alt=\"\"></p><p>上图是节点状态变化关系图，当Follower节点接收Leader节点心跳消息超时后，它会转变成Candidate节点，并可发起竞选Leader投票，若获得集群多数节点的支持后，它就可转变成Leader节点。</p><p>下面我以Leader crash场景为案例，给你详细介绍一下etcd Leader选举原理。</p><p>假设集群总共3个节点，A节点为Leader，B、C节点为Follower。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/59/a20ba5b17de79d6ce8c78a712a364359.png?wh=1920*942\" alt=\"\"></p><p>如上Leader选举图左边部分所示， 正常情况下，Leader节点会按照心跳间隔时间，定时广播心跳消息（MsgHeartbeat消息）给Follower节点，以维持Leader身份。 Follower收到后回复心跳应答包消息（MsgHeartbeatResp消息）给Leader。</p><p>细心的你可能注意到上图中的Leader节点下方有一个任期号（term）， 它具有什么样的作用呢？</p><p>这是因为Raft将时间划分成一个个任期，任期用连续的整数表示，每个任期从一次选举开始，赢得选举的节点在该任期内充当Leader的职责，随着时间的消逝，集群可能会发生新的选举，任期号也会单调递增。</p><p>通过任期号，可以比较各个节点的数据新旧、识别过期的Leader等，它在Raft算法中充当逻辑时钟，发挥着重要作用。</p><p>了解完正常情况下Leader维持身份的原理后，我们再看异常情况下，也就Leader crash后，etcd是如何自愈的呢？</p><p>如上Leader选举图右边部分所示，当Leader节点异常后，Follower节点会接收Leader的心跳消息超时，当超时时间大于竞选超时时间后，它们会进入Candidate状态。</p><p>这里要提醒下你，etcd默认心跳间隔时间（heartbeat-interval）是100ms， 默认竞选超时时间（election timeout）是1000ms， 你需要根据实际部署环境、业务场景适当调优，否则就很可能会频繁发生Leader选举切换，导致服务稳定性下降，后面我们实践篇会再详细介绍。</p><p>进入Candidate状态的节点，会立即发起选举流程，自增任期号，投票给自己，并向其他节点发送竞选Leader投票消息（MsgVote）。</p><p>C节点收到Follower B节点竞选Leader消息后，这时候可能会出现如下两种情况：</p><ul>\n<li>第一种情况是C节点判断B节点的数据至少和自己一样新、B节点任期号大于C当前任期号、并且C未投票给其他候选者，就可投票给B。这时B节点获得了集群多数节点支持，于是成为了新的Leader。</li>\n<li>第二种情况是，恰好C也心跳超时超过竞选时间了，它也发起了选举，并投票给了自己，那么它将拒绝投票给B，这时谁也无法获取集群多数派支持，只能等待竞选超时，开启新一轮选举。Raft为了优化选票被瓜分导致选举失败的问题，引入了随机数，每个节点等待发起选举的时间点不一致，优雅的解决了潜在的竞选活锁，同时易于理解。</li>\n</ul><p>Leader选出来后，它什么时候又会变成Follower状态呢？ 从上面的状态转换关系图中你可以看到，如果现有Leader发现了新的Leader任期号，那么它就需要转换到Follower节点。A节点crash后，再次启动成为Follower，假设因为网络问题无法连通B、C节点，这时候根据状态图，我们知道它将不停自增任期号，发起选举。等A节点网络异常恢复后，那么现有Leader收到了新的任期号，就会触发新一轮Leader选举，影响服务的可用性。</p><p>然而A节点的数据是远远落后B、C的，是无法获得集群Leader地位的，发起的选举无效且对集群稳定性有伤害。</p><p>那如何避免以上场景中的无效的选举呢？</p><p>在etcd 3.4中，etcd引入了一个PreVote参数（默认false），可以用来启用PreCandidate状态解决此问题，如下图所示。Follower在转换成Candidate状态前，先进入PreCandidate状态，不自增任期号， 发起预投票。若获得集群多数节点认可，确定有概率成为Leader才能进入Candidate状态，发起选举流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/06/169ae84055byya38b616d2e71cfb9706.png?wh=1920*971\" alt=\"\"></p><p>因A节点数据落后较多，预投票请求无法获得多数节点认可，因此它就不会进入Candidate状态，导致集群重新选举。</p><p>这就是Raft Leader选举核心原理，使用心跳机制维持Leader身份、触发Leader选举，etcd基于它实现了高可用，只要集群一半以上节点存活、可相互通信，Leader宕机后，就能快速选举出新的Leader，继续对外提供服务。</p><h2>日志复制</h2><p>假设在上面的Leader选举流程中，B成为了新的Leader，它收到put提案后，它是如何将日志同步给Follower节点的呢？ 什么时候它可以确定一个日志条目为已提交，通知etcdserver模块应用日志条目指令到状态机呢？</p><p>这就涉及到Raft日志复制原理，为了帮助你理解日志复制的原理，下面我给你画了一幅Leader收到put请求后，向Follower节点复制日志的整体流程图，简称流程图，在图中我用序号给你标识了核心流程。</p><p>我将结合流程图、后面的Raft的日志图和你简要分析Leader B收到put hello为world的请求后，是如何将此请求同步给其他Follower节点的。</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/83/a57a990cff7ca0254368d6351ae5b983.png?wh=1920*1327\" alt=\"\"></p><p>首先Leader收到client的请求后，etcdserver的KV模块会向Raft模块提交一个put hello为world提案消息（流程图中的序号2流程），  它的消息类型是MsgProp。</p><p>Leader的Raft模块获取到MsgProp提案消息后，为此提案生成一个日志条目，追加到未持久化、不稳定的Raft日志中，随后会遍历集群Follower列表和进度信息，为每个Follower生成追加（MsgApp）类型的RPC消息，此消息中包含待复制给Follower的日志条目。</p><p>这里就出现两个疑问了。第一，Leader是如何知道从哪个索引位置发送日志条目给Follower，以及Follower已复制的日志最大索引是多少呢？第二，日志条目什么时候才会追加到稳定的Raft日志中呢？Raft模块负责持久化吗？</p><p>首先我来给你介绍下什么是Raft日志。下图是Raft日志复制过程中的日志细节图，简称日志图1。</p><p>在日志图中，最上方的是日志条目序号/索引，日志由有序号标识的一个个条目组成，每个日志条目内容保存了Leader任期号和提案内容。最开始的时候，A节点是Leader，任期号为1，A节点crash后，B节点通过选举成为新的Leader， 任期号为2。</p><p>日志图1描述的是hello日志条目未提交前的各节点Raft日志状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/87/3dd2b6042e6e0cc86f96f24764b7f587.png?wh=1920*1003\" alt=\"\"></p><p>我们现在就可以来回答第一个疑问了。Leader会维护两个核心字段来追踪各个Follower的进度信息，一个字段是NextIndex， 它表示Leader发送给Follower节点的下一个日志条目索引。一个字段是MatchIndex， 它表示Follower节点已复制的最大日志条目的索引，比如上面的日志图1中C节点的已复制最大日志条目索引为5，A节点为4。</p><p>我们再看第二个疑问。etcd Raft模块设计实现上抽象了网络、存储、日志等模块，它本身并不会进行网络、存储相关的操作，上层应用需结合自己业务场景选择内置的模块或自定义实现网络、存储、日志等模块。</p><p>上层应用通过Raft模块的输出接口（如Ready结构），获取到待持久化的日志条目和待发送给Peer节点的消息后（如上面的MsgApp日志消息），需持久化日志条目到自定义的WAL模块，通过自定义的网络模块将消息发送给Peer节点。</p><p>日志条目持久化到稳定存储中后，这时候你就可以将日志条目追加到稳定的Raft日志中。即便这个日志是内存存储，节点重启时也不会丢失任何日志条目，因为WAL模块已持久化此日志条目，可通过它重建Raft日志。</p><p>etcd Raft模块提供了一个内置的内存存储（MemoryStorage）模块实现，etcd使用的就是它，Raft日志条目保存在内存中。网络模块并未提供内置的实现，etcd基于HTTP协议实现了peer节点间的网络通信，并根据消息类型，支持选择pipeline、stream等模式发送，显著提高了网络吞吐量、降低了延时。</p><p>解答完以上两个疑问后，我们继续分析etcd是如何与Raft模块交互，获取待持久化的日志条目和发送给peer节点的消息。</p><p>正如刚刚讲到的，Raft模块输入是Msg消息，输出是一个Ready结构，它包含待持久化的日志条目、发送给peer节点的消息、已提交的日志条目内容、线性查询结果等Raft输出核心信息。</p><p>etcdserver模块通过channel从Raft模块获取到Ready结构后（流程图中的序号3流程），因B节点是Leader，它首先会通过基于HTTP协议的网络模块将追加日志条目消息（MsgApp）广播给Follower，并同时将待持久化的日志条目持久化到WAL文件中（流程图中的序号4流程），最后将日志条目追加到稳定的Raft日志存储中（流程图中的序号5流程）。</p><p>各个Follower收到追加日志条目（MsgApp）消息，并通过安全检查后，它会持久化消息到WAL日志中，并将消息追加到Raft日志存储，随后会向Leader回复一个应答追加日志条目（MsgAppResp）的消息，告知Leader当前已复制的日志最大索引（流程图中的序号6流程）。</p><p>Leader收到应答追加日志条目（MsgAppResp）消息后，会将Follower回复的已复制日志最大索引更新到跟踪Follower进展的Match Index字段，如下面的日志图2中的Follower C MatchIndex为6，Follower A为5，日志图2描述的是hello日志条目提交后的各节点Raft日志状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/63/ebbf739a94f9300a85f21da7e55f1e63.png?wh=1920*994\" alt=\"\"></p><p>最后Leader根据Follower的MatchIndex信息，计算出一个位置，如果这个位置已经被一半以上节点持久化，那么这个位置之前的日志条目都可以被标记为已提交。</p><p>在我们这个案例中日志图2里6号索引位置之前的日志条目已被多数节点复制，那么他们状态都可被设置为已提交。Leader可通过在发送心跳消息（MsgHeartbeat）给Follower节点时，告知它已经提交的日志索引位置。</p><p>最后各个节点的etcdserver模块，可通过channel从Raft模块获取到已提交的日志条目（流程图中的序号7流程），应用日志条目内容到存储状态机（流程图中的序号8流程），返回结果给client。</p><p>通过以上流程，Leader就完成了同步日志条目给Follower的任务，一个日志条目被确定为已提交的前提是，它需要被Leader同步到一半以上节点上。以上就是etcd Raft日志复制的核心原理。</p><h2>安全性</h2><p>介绍完Leader选举和日志复制后，最后我们再来看看Raft是如何保证安全性的。</p><p>如果在上面的日志图2中，Leader B在应用日志指令put hello为world到状态机，并返回给client成功后，突然crash了，那么Follower A和C是否都有资格选举成为Leader呢？</p><p>从日志图2中我们可以看到，如果A成为了Leader那么就会导致数据丢失，因为它并未含有刚刚client已经写入成功的put hello为world指令。</p><p>Raft算法如何确保面对这类问题时不丢数据和各节点数据一致性呢？</p><p>这就是Raft的第三个子问题需要解决的。Raft通过给选举和日志复制增加一系列规则，来实现Raft算法的安全性。</p><h3>选举规则</h3><p>当节点收到选举投票的时候，需检查候选者的最后一条日志中的任期号，若小于自己则拒绝投票。如果任期号相同，日志却比自己短，也拒绝为其投票。</p><p>比如在日志图2中，Folllower A和C任期号相同，但是Follower C的数据比Follower A要长，那么在选举的时候，Follower C将拒绝投票给A， 因为它的数据不是最新的。</p><p>同时，对于一个给定的任期号，最多只会有一个leader被选举出来，leader的诞生需获得集群一半以上的节点支持。每个节点在同一个任期内只能为一个节点投票，节点需要将投票信息持久化，防止异常重启后再投票给其他节点。</p><p>通过以上规则就可防止日志图2中的Follower A节点成为Leader。</p><h3>日志复制规则</h3><p>在日志图2中，Leader B返回给client成功后若突然crash了，此时可能还并未将6号日志条目已提交的消息通知到Follower A和C，那么如何确保6号日志条目不被新Leader删除呢？ 同时在etcd集群运行过程中，Leader节点若频繁发生crash后，可能会导致Follower节点与Leader节点日志条目冲突，如何保证各个节点的同Raft日志位置含有同样的日志条目？</p><p>以上各类异常场景的安全性是通过Raft算法中的Leader完全特性和只附加原则、日志匹配等安全机制来保证的。</p><p><strong>Leader完全特性</strong>是指如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有Leader中。</p><p>Leader只能追加日志条目，不能删除已持久化的日志条目（<strong>只附加原则</strong>），因此Follower C成为新Leader后，会将前任的6号日志条目复制到A节点。</p><p>为了保证各个节点日志一致性，Raft算法在追加日志的时候，引入了一致性检查。Leader在发送追加日志RPC消息时，会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。Follower节点会检查相同索引位置的任期号是否与Leader一致，一致才能追加，这就是<strong>日志匹配特性</strong>。它本质上是一种归纳法，一开始日志空满足匹配特性，随后每增加一个日志条目时，都要求上一个日志条目信息与Leader一致，那么最终整个日志集肯定是一致的。</p><p>通过以上的Leader选举限制、Leader完全特性、只附加原则、日志匹配等安全特性，Raft就实现了一个可严格通过数学反证法、归纳法证明的高可用、一致性算法，为etcd的安全性保驾护航。</p><h2>小结</h2><p>最后我们来小结下今天的内容。我从如何避免单点故障说起，给你介绍了分布式系统中实现多副本技术的一系列方案，从主从复制到去中心化复制、再到状态机、共识算法，让你了解了各个方案的优缺点，以及主流存储产品的选择。</p><p>Raft虽然诞生晚，但它却是共识算法里面在工程界应用最广泛的。它将一个复杂问题拆分成三个子问题，分别是Leader选举、日志复制和安全性。</p><p>Raft通过心跳机制、随机化等实现了Leader选举，只要集群半数以上节点存活可相互通信，etcd就可对外提供高可用服务。</p><p>Raft日志复制确保了etcd多节点间的数据一致性，我通过一个etcd日志复制整体流程图为你详细介绍了etcd写请求从提交到Raft模块，到被应用到状态机执行的各个流程，剖析了日志复制的核心原理，即一个日志条目只有被Leader同步到一半以上节点上，此日志条目才能称之为成功复制、已提交。Raft的安全性，通过对Leader选举和日志复制增加一系列规则，保证了整个集群的一致性、完整性。</p><h2>思考题</h2><p>好了，这节课到这里也就结束了，最后我给你留了一个思考题。</p><p>哪些场景会出现Follower日志与Leader冲突，我们知道etcd WAL模块只能持续追加日志条目，那冲突后Follower是如何删除无效的日志条目呢？</p><p>感谢你阅读，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h2>03思考题答案</h2><p>在上一节课中，我给大家留了一个思考题：expensive request是否影响写请求性能。要搞懂这个问题，我们得回顾下etcd读写性能优化历史。</p><p>在etcd 3.0中，线性读请求需要走一遍Raft协议持久化到WAL日志中，因此读性能非常差，写请求肯定也会被影响。</p><p>在etcd 3.1中，引入了ReadIndex机制提升读性能，读请求无需再持久化到WAL中。</p><p>在etcd 3.2中,  优化思路转移到了MVCC/boltdb模块，boltdb的事务锁由粗粒度的互斥锁，优化成读写锁，实现“N reads or 1 write”的并行，同时引入了buffer来提升吞吐量。问题就出在这个buffer，读事务会加读锁，写事务结束时要升级锁更新buffer，但是expensive request导致读事务长时间持有锁，最终导致写请求超时。</p><p>在etcd 3.4中，实现了全并发读，创建读事务的时候会全量拷贝buffer, 读写事务不再因为buffer阻塞，大大缓解了expensive request对etcd性能的影响。尤其是Kubernetes List Pod等资源场景来说，etcd稳定性显著提升。在后面的实践篇中，我会和你再次深入讨论以上问题。</p>","neighbors":{"left":{"article_title":"03 | 基础架构：etcd一个写请求是如何执行的？","id":336766},"right":{"article_title":"05 | 鉴权：如何保护你的数据安全？","id":338524}},"comments":[{"had_liked":false,"id":279445,"user_name":"科精","can_delete":false,"product_type":"c1","uid":1808339,"ip_address":"","ucode":"338E135702DD7B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/97/d3/239aa4d5.jpg","comment_is_top":false,"comment_ctime":1613788917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"280786663157","product_id":100069901,"comment_content":"Raft分布式算法，打开连接玩1分钟就能学会<br>http:&#47;&#47;kailing.pub&#47;raft&#47;index.html","like_count":66},{"had_liked":false,"id":276608,"user_name":"mckee","can_delete":false,"product_type":"c1","uid":1066511,"ip_address":"","ucode":"E4DEBB462B93A1","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/0f/f6cfc659.jpg","comment_is_top":false,"comment_ctime":1612030767,"is_pvip":false,"replies":[{"id":"100535","content":"怒赞，优秀，还需要补充下为什么WAL模块只能通过追加日志，那它是如何删除已持久化的废弃日志条目呢？","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1612248098,"ip_address":"","comment_id":276608,"utype":1}],"discussion_count":1,"race_medal":0,"score":"104691245871","product_id":100069901,"comment_content":"思考题：<br>1.哪些场景会出现 Follower 日志与 Leader 冲突？<br>leader崩溃的情况下可能(如老的leader可能还没有完全复制所有的日志条目)，如果leader和follower出现持续崩溃会加剧这个现象。follower可能会丢失一些在新的leader中有的日志条目，他也可能拥有一些leader没有的日志条目，或者两者都发生。<br>2.follower如何删除无效日志？<br>leader处理不一致是通过强制follower直接复制自己的日志来解决了。因此在follower中的冲突的日志条目会被leader的日志覆盖。leader会记录follower的日志复制进度nextIndex，如果follower在追加日志时一致性检查失败，就会拒绝请求，此时leader就会减小 nextIndex 值并进行重试，最终在某个位置让follower跟leader一致。<br>","like_count":25,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514769,"discussion_content":"怒赞，优秀，还需要补充下为什么WAL模块只能通过追加日志，那它是如何删除已持久化的废弃日志条目呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612248098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275858,"user_name":"blentle","can_delete":false,"product_type":"c1","uid":1064679,"ip_address":"","ucode":"AC092609A4942A","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e7/261711a5.jpg","comment_is_top":false,"comment_ctime":1611708587,"is_pvip":false,"replies":[{"id":"100093","content":"你所说的这个日志完整度相对较高的节点，投票时有竞选规则安全限制，如果它的节点比较新会拒绝投票，至于最终先发起选举的节点能否赢得选举，要看其他节点数据情况，如果多数节点的数据比它新，那么先发起选举的节点就无法获得多数选票，如果5个节点中，只有一个节点数据比较长，那的确会被覆盖，但是这是安全的，说明这个数据并未被集群节点多数确认","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611710756,"ip_address":"","comment_id":275858,"utype":1}],"discussion_count":1,"race_medal":0,"score":"104690923691","product_id":100069901,"comment_content":"老师，如果一个日志完整度相对较高的节点因为自己随机时间比其他节点的长，没能最先发起竞选，其他节点当上leader后同步自己的日志岂不是冲突了？","like_count":25,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514505,"discussion_content":"你所说的这个日志完整度相对较高的节点，投票时有竞选规则安全限制，如果它的节点比较新会拒绝投票，至于最终先发起选举的节点能否赢得选举，要看其他节点数据情况，如果多数节点的数据比它新，那么先发起选举的节点就无法获得多数选票，如果5个节点中，只有一个节点数据比较长，那的确会被覆盖，但是这是安全的，说明这个数据并未被集群节点多数确认","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611710756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276203,"user_name":"jeffery","can_delete":false,"product_type":"c1","uid":1219972,"ip_address":"","ucode":"35E2DAA386FB86","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/84/171b2221.jpg","comment_is_top":false,"comment_ctime":1611829609,"is_pvip":false,"replies":[{"id":"100279","content":"感谢你的认可，有收获就好，数据不一致原因和高可用运维最佳实践，实践篇都有，稍等，一起学下去，加油，保证让你收获满满","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611845398,"ip_address":"","comment_id":276203,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53151437161","product_id":100069901,"comment_content":"讲的太好了、图文并貌、形象生动、raft这章就够本了！老师问下.es 也用raft！为啥会出现数据不一致性？部署etcd高可用有运维有最佳实践建议吗？谢谢老师","like_count":12,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514628,"discussion_content":"感谢你的认可，有收获就好，数据不一致原因和高可用运维最佳实践，实践篇都有，稍等，一起学下去，加油，保证让你收获满满","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611845398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2243398,"avatar":"https://static001.geekbang.org/account/avatar/00/22/3b/46/3701e908.jpg","nickname":"Coder","note":"","ucode":"170190542A5A9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346019,"discussion_content":"同感👍👍","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1611839689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276007,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1611742580,"is_pvip":false,"replies":[{"id":"100283","content":"好问题，第一个问题不能说是数据丢失，正如你所说的，可能存在一个新日志条目，这些异常重启后的follower中没有，因为异常的follower数达到了法定数，那么这个新日志条目肯定没同步到多数节点上，因此是合理的。<br>第二个问题，看落后数据程度，通过内存中的raft log和快照文件追赶，因篇幅关系，未介绍日志压缩和快照，后面我根据情况是否单独加餐篇。如果提交过程中，不能达到法定数，这时会超时，依赖客户端重试<br>第三个问题，描述可以更详细点吗，没太懂，按我初步理解回答下，其他节点收到此日志条目后会持久化，选出leader也有此条记录，新老leader如果数据有冲突，以新leader为准<br>","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611846716,"ip_address":"","comment_id":276007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35971480948","product_id":100069901,"comment_content":"关于选举过程和节点崩溃后恢复有几个问题请教老师：<br>1. 如果多数follower崩溃后重启恢复（比如极端情况只剩下Leader其它follower同时重启），根据选举规则是不是会出现重启follower占多数投票给了一个数据不是最新的节点而导致数据丢失。我理解这种情况不满足法定票算法前提，所以是无法保障数据一致的。<br>2. 对于少数节点崩溃恢复后，它是如何追上leader的最新数据的呢？比如对于日志复制过程，leader完成自身的WAL及raft日志然后发送MsgApp，但是其它follower没有来得及发送MsgResp就崩溃了，那么这条raft日志其实没有得到法定票数的提交信息，raft模块应该通过什么方式来让follower恢复这份数据，让它能够最终在恢复的节点得到法定票数提交，然后应用到上层状态机？<br>3.  如果在写数据过程中leader崩溃了。比如在leader完成自身WAL并发送MsgApp后崩溃了，本次写提案没有完成，重新选leader之后新leader有这次写记录的log，它会怎么恢复数据？<br><br>谢谢老师","like_count":8,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514565,"discussion_content":"好问题，第一个问题不能说是数据丢失，正如你所说的，可能存在一个新日志条目，这些异常重启后的follower中没有，因为异常的follower数达到了法定数，那么这个新日志条目肯定没同步到多数节点上，因此是合理的。\n第二个问题，看落后数据程度，通过内存中的raft log和快照文件追赶，因篇幅关系，未介绍日志压缩和快照，后面我根据情况是否单独加餐篇。如果提交过程中，不能达到法定数，这时会超时，依赖客户端重试\n第三个问题，描述可以更详细点吗，没太懂，按我初步理解回答下，其他节点收到此日志条目后会持久化，选出leader也有此条记录，新老leader如果数据有冲突，以新leader为准\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611846716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276310,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1611883981,"is_pvip":false,"replies":[{"id":"100295","content":"首先在raft中并没有什么数据结构来保存提案状态，leader只维护了一个committed index, 它表示这个index之前的日志条目已被成功同步到了大多数follower节点。当原leader crash后，其他follower节点选举出新leader, 按照raft安全性原则，它是不能删除前任leader的任何日志条目，因leader crash前这条日志条目已经被持久化到了多数follower节点上，那么follower节点选举出新leader后，它含有这条日志条目，并且多数节点已经同步了，那么对新leader而言，它的状态就是已提交，可以直接提交给状态机模块执行。对client而言，虽然写请求超时了，但最终它的提案是成功执行的，client需要自己确保幂等性，也就是写超时后，你的提交可能是成功的。","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611888882,"ip_address":"","comment_id":276310,"utype":1}],"discussion_count":5,"race_medal":0,"score":"18791753165","product_id":100069901,"comment_content":"谢谢老师的回答，关于第三个问题，“3. 如果在写数据过程中leader崩溃了。比如在leader完成自身WAL并发送MsgApp后崩溃了，本次写提案没有完成，重新选leader之后新leader有这次写记录的log，它会怎么恢复数据？” 我详细描述下，请老师帮忙解答下：<br>1. Leader收到用户put请求后，完成自己的WAL日志及raft日志持久化后发送MsgApp到其它follower节点。<br>2. 其它follower节点接收到MsgApp后也完成自己的WAL及raft日志操作。<br>3. 此时Leader节点崩溃了，follower节点无法发送自己日志MsgAppResp给已经崩溃的Leader。此时集群开始新一轮选举并选出一个Leader<br>4. 新的Leader接收过之前的put提案并在日志中找到它，新的Leader如何恢复这条提案到提交状态？新的leader是不是在日志中看到这条没有完成提案后重新在做一轮提案？<br><br>谢谢老师<br>","like_count":4,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514657,"discussion_content":"首先在raft中并没有什么数据结构来保存提案状态，leader只维护了一个committed index, 它表示这个index之前的日志条目已被成功同步到了大多数follower节点。当原leader crash后，其他follower节点选举出新leader, 按照raft安全性原则，它是不能删除前任leader的任何日志条目，因leader crash前这条日志条目已经被持久化到了多数follower节点上，那么follower节点选举出新leader后，它含有这条日志条目，并且多数节点已经同步了，那么对新leader而言，它的状态就是已提交，可以直接提交给状态机模块执行。对client而言，虽然写请求超时了，但最终它的提案是成功执行的，client需要自己确保幂等性，也就是写超时后，你的提交可能是成功的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611888882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1229952,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c4/80/264d711e.jpg","nickname":"kun","note":"","ucode":"92E67740AE52ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551466,"discussion_content":"如果此时client不重试，那不是说明有脏数据残留了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645021285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":514657,"ip_address":""},"score":551466,"extra":""}]},{"author":{"id":1795546,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epCnxicMqCiah8lIOZM9oy0VNeWpmv0U8c3kIAgMcntWQPn514jfN6n0LL3VlJqQypQJG3icbUSsTKFQ/132","nickname":"Geek_18a705","note":"","ucode":"41B325020A8E12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578540,"discussion_content":"新leader当选后， 包含了这条还没有被前任leader commit的log，一旦当选，会立即broadcast append, 当收到大多数节点的MsgAppResp 后， 尝试更新commit ID, 这条没被前任leader commit的log 也就被新lead commit了，不知道理解是否正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656883024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381474,"discussion_content":"新leader不能删除原leader的日志，但是新leader有可能没有同步原leader的最新日志，那原leader的最新日志是会被删除的？这种情况下，客户端是超时断开，并且没有执行成功，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625069913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":551188,"discussion_content":"不会发生的。raft算法保证选举的leader要包含集群里最新的数据，否则，不会被选为leader。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644921136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381474,"ip_address":""},"score":551188,"extra":""}]}]},{"had_liked":false,"id":276342,"user_name":"Index","can_delete":false,"product_type":"c1","uid":1078909,"ip_address":"","ucode":"815A1A62F846CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/7d/04c95885.jpg","comment_is_top":false,"comment_ctime":1611890248,"is_pvip":false,"replies":[{"id":"100311","content":"嗯，etcd特别依赖磁盘I&#47;O性能，日志条目需要同步持久化到磁盘，当心跳间隔是100ms,选举超时是1s, 如果fsync 日志条目WAL耗时不稳定、波动很大、超过1秒，那集群就会频繁选举。","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611932522,"ip_address":"","comment_id":276342,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14496792136","product_id":100069901,"comment_content":"关于etcd的raft实现源码有个问题<br>func ExampleNode() {<br>\tc := &amp;Config{}<br>\tn := StartNode(c, nil)<br>\tdefer n.Stop()<br><br>\t&#47;&#47; stuff to n happens in other goroutines<br><br>\t&#47;&#47; the last known state<br>\tvar prev pb.HardState<br>\tfor {<br>\t\t&#47;&#47; Ready blocks until there is new state ready.<br>\t\trd := &lt;-n.Ready()<br>\t\tif !isHardStateEqual(prev, rd.HardState) {<br>\t\t\tsaveStateToDisk(rd.HardState)<br>\t\t\tprev = rd.HardState<br>\t\t}<br><br>\t\tsaveToDisk(rd.Entries)<br>\t\tgo applyToStore(rd.CommittedEntries)<br>\t\tsendMessages(rd.Messages)<br>\t}<br>}<br><br>网络，存储都是用户自己实现的，如果这里在处理存储和发送消息很慢，这样不会影响到心跳吗？比如心跳默认是1s，那如果处理存储和网络的时间经常超过1s，岂不是心跳就时常超时，集群经常处于选举的状态吗？求解答","like_count":3,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514671,"discussion_content":"嗯，etcd特别依赖磁盘I/O性能，日志条目需要同步持久化到磁盘，当心跳间隔是100ms,选举超时是1s, 如果fsync 日志条目WAL耗时不稳定、波动很大、超过1秒，那集群就会频繁选举。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611932522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078909,"avatar":"https://static001.geekbang.org/account/avatar/00/10/76/7d/04c95885.jpg","nickname":"Index","note":"","ucode":"815A1A62F846CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346641,"discussion_content":"纠正问题的一个描述，心跳间隔100ms，选举超时1s，不是心跳1s间隔。是老师说的那个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612010352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275861,"user_name":"春风","can_delete":false,"product_type":"c1","uid":1103971,"ip_address":"","ucode":"76947E35A76C67","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/63/e4c28138.jpg","comment_is_top":false,"comment_ctime":1611709440,"is_pvip":false,"replies":[{"id":"100095","content":"感谢反馈，是我描述不严谨，让你误会了，在上文中老的Leader A crash后，重启会变成Follower节点，已完善描述，谢谢你","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611715253,"ip_address":"","comment_id":275861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14496611328","product_id":100069901,"comment_content":"假如老的 Leader A 因为网络问题无法连通 B、C 节点，这时候根据状态图，我们知道它将不停自增任期号，发起选举。等 A 节点网络异常恢复后，那么现有 Leader 收到了新的任期号，就会触发新一轮 Leader 选举，影响服务的可用性。<br><br>老师，这里没太懂，A不是本身是leader吗，为什么还要发起选举？","like_count":3,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514507,"discussion_content":"感谢反馈，是我描述不严谨，让你误会了，在上文中老的Leader A crash后，重启会变成Follower节点，已完善描述，谢谢你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611715253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275829,"user_name":"云原生工程师","can_delete":false,"product_type":"c1","uid":2243294,"ip_address":"","ucode":"40CB692F21D3BC","user_header":"https://static001.geekbang.org/account/avatar/00/22/3a/de/e5c30589.jpg","comment_is_top":false,"comment_ctime":1611680168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14496582056","product_id":100069901,"comment_content":"日志复制流程图很赞，清晰易懂","like_count":3},{"had_liked":false,"id":296990,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1623251693,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10213186285","product_id":100069901,"comment_content":"raft log 和 WAL是同一东西吗","like_count":2},{"had_liked":false,"id":281156,"user_name":"types","can_delete":false,"product_type":"c1","uid":2449777,"ip_address":"","ucode":"8B50927EF1804F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDUJyeq54fiaXAgF62tNeocO3lHsKT4mygEcNoZLnibg6ONKicMgCgUHSfgW8hrMUXlwpNSzR8MHZwg/132","comment_is_top":false,"comment_ctime":1614601230,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10204535822","product_id":100069901,"comment_content":"选举规则当节点收到选举投票的时候，需检查候选者的最后一条日志中的任期号，若小于自己则拒绝投票。如果任期号相同，日志却比自己短，也拒绝为其投票。<br><br>请问“日志比自己短” 是指什么状态下的日志 ，是commited还是？<br>如果不是commited， B（leader）AppMsg 给A和C后crash， A收到了， C没收到。 这个时候C会不会成为leader，导致数据丢失","like_count":2,"discussions":[{"author":{"id":1752348,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jA97yib7VetXc4iclOg2gGfZu1fO7efyib2mKeqvIxDdmgLqukusyFzPrbIQeZYR0WDJUicRakgVGroaYC7aWGFrEw/132","nickname":"Turing","note":"","ucode":"F88679276D4841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388882,"discussion_content":"当前最大的日志index, 包含commited和未committed.   c不会成为leader, 不满足半数.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629026975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275849,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1611707119,"is_pvip":true,"replies":[{"id":"100198","content":"嗯，主从复制我个人认为最大的缺点还是数据一致性，Raft的保证一致性背后的核心数学原理其实是抽屉原理，你可以详细了解下，不管是集群选举还是数据复制，都要求一半以上节点确认","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611747344,"ip_address":"","comment_id":275849,"utype":1}],"discussion_count":5,"race_medal":0,"score":"10201641711","product_id":100069901,"comment_content":"主从复制缺点是因为主节点崩溃后，没有选主机制（是否可以考虑redis的哨兵选主）呢？还是因为数据一致性呢（raft保持强一致性的话，也是通过某些机制保证强一致性（主节点读或者ReadIndex））","like_count":2,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514500,"discussion_content":"嗯，主从复制我个人认为最大的缺点还是数据一致性，Raft的保证一致性背后的核心数学原理其实是抽屉原理，你可以详细了解下，不管是集群选举还是数据复制，都要求一半以上节点确认","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611747344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066772,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxQXM5O1ONNia62e2dySKTRjPYQOic2IF3gT0HIGuYE6zia2p0DWOJyCIiavtUfNUkictUyBMqWibQtwEg/132","nickname":"老潘","note":"","ucode":"50D5370145320C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345417,"discussion_content":"我的哨兵机制不能解决分布式的问题，因为哨兵自己就是单点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611719000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1807943,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","nickname":"出卖灵魂的教练Kerry","note":"","ucode":"8C64517DA556FE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1066772,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxQXM5O1ONNia62e2dySKTRjPYQOic2IF3gT0HIGuYE6zia2p0DWOJyCIiavtUfNUkictUyBMqWibQtwEg/132","nickname":"老潘","note":"","ucode":"50D5370145320C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345469,"discussion_content":"哨兵集群。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611724262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345417,"ip_address":""},"score":345469,"extra":""},{"author":{"id":1066772,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxQXM5O1ONNia62e2dySKTRjPYQOic2IF3gT0HIGuYE6zia2p0DWOJyCIiavtUfNUkictUyBMqWibQtwEg/132","nickname":"老潘","note":"","ucode":"50D5370145320C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1807943,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","nickname":"出卖灵魂的教练Kerry","note":"","ucode":"8C64517DA556FE","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":345483,"discussion_content":"我是这么理解的，集群哨兵也只是一个升级版本的keeplived。通过第3方探测方式引入，第3方会增加除服务本身之外的故障几率，以及脑裂等问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611726789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345469,"ip_address":""},"score":345483,"extra":""},{"author":{"id":1807943,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","nickname":"出卖灵魂的教练Kerry","note":"","ucode":"8C64517DA556FE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1066772,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxQXM5O1ONNia62e2dySKTRjPYQOic2IF3gT0HIGuYE6zia2p0DWOJyCIiavtUfNUkictUyBMqWibQtwEg/132","nickname":"老潘","note":"","ucode":"50D5370145320C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345555,"discussion_content":"哨兵是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611740655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345483,"ip_address":""},"score":345555,"extra":""}]}]},{"had_liked":false,"id":331925,"user_name":"erge","can_delete":false,"product_type":"c1","uid":2672238,"ip_address":"","ucode":"FAE16C190A3E23","user_header":"https://static001.geekbang.org/account/avatar/00/28/c6/6e/49aff2bd.jpg","comment_is_top":false,"comment_ctime":1642902896,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5937870192","product_id":100069901,"comment_content":"老师好，peer节点是什么呢","like_count":1},{"had_liked":false,"id":324353,"user_name":"HelloBug","can_delete":false,"product_type":"c1","uid":1249598,"ip_address":"","ucode":"E61A4AD5C2F724","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/3e/925aa996.jpg","comment_is_top":false,"comment_ctime":1638401842,"is_pvip":true,"replies":[{"id":"119297","content":"嗯，有些术语的确可以更友好点，推荐先简单看看etcd源码（3.3&#47;3.4版本），跟着02和03大致走读下，这样你会更加清晰","user_name":"作者回复","user_name_real":"编辑","uid":"1009582","ctime":1640241591,"ip_address":"","comment_id":324353,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5933369138","product_id":100069901,"comment_content":"老师在讲解流程的时候，会说raft模块，kvserver模块，这些都好理解。但又会说etcd发送什么消息，或者etcdserver怎么怎么样，具体是什么模块呢？我之前以为这两者不指哪个模块，就是etcd的框架代码，但是这篇文章里又看到etcdserver模块，着实不知道怎么理解了","like_count":1,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541048,"discussion_content":"嗯，有些术语的确可以更友好点，推荐先简单看看etcd源码（3.3/3.4版本），跟着02和03大致走读下，这样你会更加清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640241591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544516,"discussion_content":"嗯，对于初学者，确实有点乱了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641543872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319993,"user_name":"励研冰","can_delete":false,"product_type":"c1","uid":1106394,"ip_address":"","ucode":"FCBC8266018FA0","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/da/d7f591a7.jpg","comment_is_top":false,"comment_ctime":1636030353,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5930997649","product_id":100069901,"comment_content":"等 A 节点网络异常恢复后，那么现有 Leader 收到了新的任期号，就会触发新一轮 Leader 选举，影响服务的可用性。<br>上文说到leader选举收到选举票之后会跟自己的现在的任期号对比，且要比自己的数据新，那发起选票之后B跟C收到投票请求任期号可能比自己的要大，但是数据应该没有比B跟C的大吧，所以这时候B告诉A现在自己是leader让A直接成为follower 就行了，为什么会重新选举呢？","like_count":1,"discussions":[{"author":{"id":2012886,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b6/d6/3b1fbf9b.jpg","nickname":"2018","note":"","ucode":"436D1F4CA63CB9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564876,"discussion_content":"A会在重新选举的过程中,收到来自B的（自己是leader的消息）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650347371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1934783,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/85/bf/c1f2a140.jpg","nickname":"江小江","note":"","ucode":"E208D9A9EAEEF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543992,"discussion_content":"我也是这样想的，发现有人和我想的一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641375963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284425,"user_name":"Geek_aaa517","can_delete":false,"product_type":"c1","uid":1640853,"ip_address":"","ucode":"F73BABFFD22970","user_header":"","comment_is_top":false,"comment_ctime":1616240062,"is_pvip":false,"replies":[{"id":"103455","content":"WAL日志是用来持久化raft日志条目和相关集群元数据信息的，可防止节点发生重启、crash后，对应的已提交日志条目丢失等异常情况，一般情况下，它是将数据持久化到磁盘中。<br>Raft日志记录了节点过去一段时间内收到的写请求，如put&#47;del&#47;txn操作等，一般是通过一个内存数组来存储最近一系列日志条目。当Follower节点落后Leader较小时，就可以通过Leader内存中维护的日志条目信息, 将落后的日志条目发送给它，最终各个节点应用一样的日志条目内容，来确保各个节点数据一致性。<br>etcd节点重启后，可通过WAL日志来重建部分raft日志条目。","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1616653488,"ip_address":"","comment_id":284425,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5911207358","product_id":100069901,"comment_content":"raft日志跟wal日志没太搞明白，分别是什么作用呢","like_count":1,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517345,"discussion_content":"WAL日志是用来持久化raft日志条目和相关集群元数据信息的，可防止节点发生重启、crash后，对应的已提交日志条目丢失等异常情况，一般情况下，它是将数据持久化到磁盘中。\nRaft日志记录了节点过去一段时间内收到的写请求，如put/del/txn操作等，一般是通过一个内存数组来存储最近一系列日志条目。当Follower节点落后Leader较小时，就可以通过Leader内存中维护的日志条目信息, 将落后的日志条目发送给它，最终各个节点应用一样的日志条目内容，来确保各个节点数据一致性。\netcd节点重启后，可通过WAL日志来重建部分raft日志条目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616653488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127786,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/6a/8ab55564.jpg","nickname":"AlphaLiu","note":"","ucode":"B75A4C82E7DC03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365707,"discussion_content":"那etcd节点重启后，将重建多少raft日志条目呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617869843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279778,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1613961722,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5908929018","product_id":100069901,"comment_content":"老师，您好请教一写问题：<br>1. 如果一个集群有3个节点, 则Leader会维护3组 (NextIndex, MatchIndex)吗?<br>2. 由于每个节点都可以变为Leader, 是否也意味着Follower也会同步更新这两个变量的值呢?<br>3. 假设当前任期号是1，此时Leader crash了，进行选举理论上这次任期号是2，但此次选举失败了，再下一次选举成功时会使用任期号3还是任期号2？<br><br>","like_count":1},{"had_liked":false,"id":278873,"user_name":"u","can_delete":false,"product_type":"c1","uid":1140276,"ip_address":"","ucode":"88FA7BA089807C","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/34/0508d9e4.jpg","comment_is_top":false,"comment_ctime":1613405125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5908372421","product_id":100069901,"comment_content":"厉害了，不过之前没接触过相关知识，看的有点吃力，找了一篇通俗易懂的补了下基础，为后面的课程做准备，分享一下：https:&#47;&#47;blog.csdn.net&#47;wangxuelei036&#47;article&#47;details&#47;108894053","like_count":1},{"had_liked":false,"id":277551,"user_name":"谢小路","can_delete":false,"product_type":"c1","uid":1035064,"ip_address":"","ucode":"C9FE2EB10DC105","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/38/4c9cfdf4.jpg","comment_is_top":false,"comment_ctime":1612453633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907420929","product_id":100069901,"comment_content":"行吧。raft 动画版。http:&#47;&#47;thesecretlivesofdata.com&#47;raft&#47;","like_count":1},{"had_liked":false,"id":353714,"user_name":"阿基米德","can_delete":false,"product_type":"c1","uid":2048922,"ip_address":"广东","ucode":"E4168E1A55E621","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/KjXNw3FNfsJhktyGDNEpQdicnaR0MZCiaQwGg3icQXUGVzqsRHL1FfxO87FX0VNzcl858AUjWPaABmogsWNFa8OGw/132","comment_is_top":false,"comment_ctime":1659691477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659691477","product_id":100069901,"comment_content":"如果etcd集群有5个节点，分别是a,b,c,d,e节点，a是leader，a将一条新数据x=5刷盘到wal之后，只给b节点发去了追加日志的消息，然后a宕机了。重新选举，b有可能成为新一任的leader吗？b成为leader之后，它日志文件中的x=5这条数据会被删除还是会同步到其他follower节点，因为这条x=5的数据在上一个leader的任期内是还没有写入到大多数节点的？如果不删除x=5，算不算是脏数据，因为写入这条数据的客户端肯定超时报错了","like_count":0},{"had_liked":false,"id":353618,"user_name":"陈麒文","can_delete":false,"product_type":"c1","uid":2187256,"ip_address":"福建","ucode":"41475885FA5AD5","user_header":"https://static001.geekbang.org/account/avatar/00/21/5f/f8/1d16434b.jpg","comment_is_top":false,"comment_ctime":1659606681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659606681","product_id":100069901,"comment_content":"那个图1和图2各个节点的符号标识是什么意思，比如x&lt;-1,y&lt;-2,money&lt;-10 a&lt;-1","like_count":0},{"had_liked":false,"id":351960,"user_name":"清茗","can_delete":false,"product_type":"c1","uid":2524009,"ip_address":"","ucode":"F16F9BFBB7C31F","user_header":"https://static001.geekbang.org/account/avatar/00/26/83/69/fda7d5f5.jpg","comment_is_top":false,"comment_ctime":1658308110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658308110","product_id":100069901,"comment_content":"小白看了四章了，感觉看着很吃力","like_count":0},{"had_liked":false,"id":349805,"user_name":"农村合作社","can_delete":false,"product_type":"c1","uid":2184028,"ip_address":"","ucode":"E05CC3F3502B74","user_header":"https://static001.geekbang.org/account/avatar/00/21/53/5c/6d846d99.jpg","comment_is_top":false,"comment_ctime":1656335324,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656335324","product_id":100069901,"comment_content":"“如果在上面的日志图 2 中，Leader B 在应用日志指令 put hello 为 world 到状态机，并返回给 client 成功后，突然 crash 了，那么 Follower A 和 C 是否都有资格选举成为 Leader 呢？”<br><br>返回给client 是最后一步吗？从上面节选的片段看，好像不是？","like_count":0},{"had_liked":false,"id":348584,"user_name":"Hugh","can_delete":false,"product_type":"c1","uid":2285931,"ip_address":"","ucode":"77434E01E1D715","user_header":"https://static001.geekbang.org/account/avatar/00/22/e1/6b/74a8b7d8.jpg","comment_is_top":false,"comment_ctime":1655215249,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655215249","product_id":100069901,"comment_content":"关于日志复制这部分，想请教几个问题：<br>1. 文中有提到稳定和不稳定的raft log，怎么定义“稳定”呢？<br>2. 文中提到，leader向followers发送追加日志的RPC时，follower会将消息内容持久化到WAL以及raft log中，然后响应leader表示自己已完成复制（已复制进log，未提交），如果leader收到了大部分follower的成功响应，则认为此次提交是安全的，并把该日志设置为已提交，并在未来的心跳RPC中把已提交索引同步给所有的follower。这里假设一种情况：leader将日志设置为已提交，并回复了客户端success的响应，此时leader宕机了，那么所有的follower都不知道最新的这条日志被提交了，那未来这条日志还会被写进状态机吗？依据是什么？<br>3. 再回到2中的这个例子，假设leader给follower发送追加日志RPC（我们把这次日志叫做X）时，只有一个follower A完成了复制并追加raft log中，其他follower都失败了，此时leader突然宕机了，且A最先超时并转变为candidate发起了选举请求且成功获选成为leader，那么这条日志X最终会被复制给所有的节点吗（我在https:&#47;&#47;raft.github.io&#47; 这个网站用动画模拟了一下，答案是肯定的）？如果会被复制，是不是和客户端的认知就不一致了，因为客户端认为此次的put请求是失败的<br>我参考了raft论文和这篇课程，没找到具体的答案，辛苦老师帮忙解答一下","like_count":0},{"had_liked":false,"id":334829,"user_name":"蓝莓侠","can_delete":false,"product_type":"c1","uid":1620722,"ip_address":"","ucode":"2E02AC43D21103","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDRPejHodutia9Ud8UZLY8g5lTkKXgf3J104c0jM9aFfAGNoUdxkRLnnWRc5Kd3jIeN3EqXxKFT0g/132","comment_is_top":false,"comment_ctime":1645149343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645149343","product_id":100069901,"comment_content":"假设一个etcd一开始有3个节点 a,b,c，其中a是leader，一个put请求t，提交到了 a,b 节点，返回客户端成功；然后3个节点都断电crash，然后只有 c 重启提供服务，一段时间后，a重启，这个t的日志，使用什么机制同步到c，是a发送给c吗？还是由c同步日志给a的时候，发现上一个term任期中a未提交的日志t，然后同步拉取到c？","like_count":0},{"had_liked":false,"id":326504,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1639544103,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639544103","product_id":100069901,"comment_content":"老师，为什么最开始会追加到不稳定raft日志中呢？","like_count":1},{"had_liked":false,"id":324873,"user_name":"cc","can_delete":false,"product_type":"c1","uid":2759767,"ip_address":"","ucode":"A1144504EA9B00","user_header":"","comment_is_top":false,"comment_ctime":1638697540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638697540","product_id":100069901,"comment_content":"如何理解选举过程和日志复制过程中的「大多数」？<br>- 在选举过程中，candidate 需要获取「大多数」节点的投票，才能成为 leader；<br>- 在日志复制过程中，如果日志条目已经被「大多数」节点持久化，leader 将该日志条目设为 committed<br><br>选举过程中的「大多数」：是指一半以上的节点，如果只有 2 个节点，依然能够完成选举过程，因为发起选举的 candidate 首先投票给自己，自己的一票也算数，这里的「大多数」是指所有节点的大多数。<br><br>日志复制过程中的「大多数」：是指一半以上的 follower 节点，如果只有 2 个节点，是无法提交日志的；因为 leader 不会首先提交日志，这里的「大多数」是指 follower 节点数的大多数。<br><br>不知上述理解是否正确？","like_count":0},{"had_liked":false,"id":324863,"user_name":"cc","can_delete":false,"product_type":"c1","uid":2759767,"ip_address":"","ucode":"A1144504EA9B00","user_header":"","comment_is_top":false,"comment_ctime":1638692852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638692852","product_id":100069901,"comment_content":"对思考题的答案提问: etcd 是读多写少的场景, 为什么是创建读事务时全量拷贝 buffer, 而不是创建写事务之时? ","like_count":0},{"had_liked":false,"id":324323,"user_name":"HelloBug","can_delete":false,"product_type":"c1","uid":1249598,"ip_address":"","ucode":"E61A4AD5C2F724","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/3e/925aa996.jpg","comment_is_top":false,"comment_ctime":1638370090,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638370090","product_id":100069901,"comment_content":"只要有一个节点进入candidate状态，集群就会重新发起选举吗？","like_count":0},{"had_liked":false,"id":324322,"user_name":"HelloBug","can_delete":false,"product_type":"c1","uid":1249598,"ip_address":"","ucode":"E61A4AD5C2F724","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/3e/925aa996.jpg","comment_is_top":false,"comment_ctime":1638370013,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638370013","product_id":100069901,"comment_content":"老师，你好，Leader选举部分讲到A节点在网络恢复之后，会发起新一轮的Leader选举，此时因为A的数据落后较多，不会成为新的Leader，这样会破坏集群的稳定性。A发起选举之后，其他所有节点都会重新发起选举吗？如果不会，而是A也变成了Follower，那PreCandidate的开销和A主动发起选举就是一样的吧？","like_count":0},{"had_liked":false,"id":320101,"user_name":"fei","can_delete":false,"product_type":"c1","uid":2126331,"ip_address":"","ucode":"36D802EB42FEF3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOUjOGRlYNY1TDZpso7LQEhMyqmgUqEW3sm5xWTHqhU5rUol8NeEOxLMQA5ib09Y8Yg97ziaqsKduA/132","comment_is_top":false,"comment_ctime":1636082126,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1636082126","product_id":100069901,"comment_content":"raft日志复制中，提到了三种日志：<br>一是“未持久化、不稳定的 Raft 日志”。这个日志在流程图中没有画出来。<br>二是WAL日志。这是持久化的日志。<br>三是提交的日志。流程图中就是存储状态机。<br>这样总结是否正确？<br><br>在讲“日志复制规则”时，下面这句话实在读不通：<br>“Leader 在发送追加日志 RPC 消息时，会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。”<br>能够更正一下。<br>","like_count":0},{"had_liked":false,"id":312993,"user_name":"吴展","can_delete":false,"product_type":"c1","uid":1083545,"ip_address":"","ucode":"F7537C0570F212","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/99/6945c324.jpg","comment_is_top":false,"comment_ctime":1632190860,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1632190860","product_id":100069901,"comment_content":"如果B没有把新的msg复制到A和C前（或大部分节点），它会给client回应成功吗？我觉得不会，但文中描述看是会的。困惑，希望帮忙解答","like_count":0,"discussions":[{"author":{"id":1033630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/9e/d6fce09c.jpg","nickname":"暴走的🐌","note":"","ucode":"804381D877E53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549932,"discussion_content":"注意：领导节点提交的前提是大多数跟随节点都同意了这个提案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644302480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/9e/d6fce09c.jpg","nickname":"暴走的🐌","note":"","ucode":"804381D877E53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549931,"discussion_content":"领导节点提交了，才会给client端返回成功","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644302297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309692,"user_name":"whale song","can_delete":false,"product_type":"c1","uid":2712306,"ip_address":"","ucode":"73DC6AE6D7213C","user_header":"https://static001.geekbang.org/account/avatar/00/29/62/f2/2f7cfd4d.jpg","comment_is_top":false,"comment_ctime":1630306556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630306556","product_id":100069901,"comment_content":"老师，想请问一下，假如raft模块中，一条日志已经提交了，但在回复客户端之前leader挂掉的情况。这种情况下这条日志按照raft算法规则，会在后续新leader选出之后提交然后应用；然后对于客户端来说，相当于此次请求失败，然后可能会有重试的情况。那么这种情况下是如何保证幂等性的呀","like_count":0},{"had_liked":false,"id":307870,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1897833,"ip_address":"","ucode":"CAAD4D2F285890","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f5/69/84987a60.jpg","comment_is_top":false,"comment_ctime":1629287571,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629287571","product_id":100069901,"comment_content":"原文：“A 节点 crash 后，再次启动成为 Follower，假设因为网络问题无法连通 B、C 节点，这时候根据状态图，我们知道它将不停自增任期号，发起选举。”<br>请问A节点为什么会不停地自增任期号呢。按照我的理解，A节点会选自己成为主节点，所以任期号会+1,并且就这么一直保持不变才对。 ","like_count":0},{"had_liked":false,"id":300268,"user_name":"慢动作","can_delete":false,"product_type":"c1","uid":1133945,"ip_address":"","ucode":"62C944F4A4D8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","comment_is_top":false,"comment_ctime":1625069485,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1625069485","product_id":100069901,"comment_content":"日志复制流程，只有当leader把日志复制到大多数follower后，client才会收到成功反馈，这发生在6之后？如果56之间leader宕机了，客户端是超时断开，该次请求是不确定状态吗，日志也许只是在少部分follower持久化了，如果一个没有该日志的follower选举成功，就会抹掉这条日志，反之则提交成功？因此不删除日志是指在leader的状态下不会删除，但是你变成了follower，那日志还是会被删除的？","like_count":0,"discussions":[{"author":{"id":1752348,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jA97yib7VetXc4iclOg2gGfZu1fO7efyib2mKeqvIxDdmgLqukusyFzPrbIQeZYR0WDJUicRakgVGroaYC7aWGFrEw/132","nickname":"Turing","note":"","ucode":"F88679276D4841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388883,"discussion_content":"少部分持久化, 没有达到半数, 可以当做无效. client重试.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629027163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297014,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1623284123,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623284123","product_id":100069901,"comment_content":"Leader 完全特性是由选举规则来保证的吗","like_count":0},{"had_liked":false,"id":297010,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1623282655,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623282655","product_id":100069901,"comment_content":"文中说“Leader 会维护两个核心字段来追踪各个 Follower 的进度信息，一个字段是 NextIndex， 它表示 Leader 发送给 Follower 节点的下一个日志条目索引。一个字段是 MatchIndex， 它表示 Follower 节点已复制的最大日志条目的索引”。<br><br>我的问题是，这两个字段是每个节点都会同步吗？如果不同步新选出来的leader怎么维护这两字段？","like_count":0},{"had_liked":false,"id":296960,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1623240581,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623240581","product_id":100069901,"comment_content":"老师，啥叫数据的完整性？能举个数据不完整的例子吗","like_count":0},{"had_liked":false,"id":295980,"user_name":"HD","can_delete":false,"product_type":"c1","uid":1088303,"ip_address":"","ucode":"3F61B901BB9245","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/2f/db466c67.jpg","comment_is_top":false,"comment_ctime":1622689814,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1622689814","product_id":100069901,"comment_content":"想请教一下老师这个问题“总而言之，不管是主从复制还是异步复制，都存在一定的缺陷。”，复制算法相对于共识算法的缺陷具体是什么？","like_count":0,"discussions":[{"author":{"id":1266482,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","nickname":"batman","note":"","ucode":"73C30ACFC0D612","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378546,"discussion_content":"数据复制有延迟，不能保证数据的强一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623284230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293942,"user_name":"Geek_a754be","can_delete":false,"product_type":"c1","uid":2437733,"ip_address":"","ucode":"A18C3752E2C1C8","user_header":"","comment_is_top":false,"comment_ctime":1621638095,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1621638095","product_id":100069901,"comment_content":"想请教一下老师如果发生网络分区，两个区中都选举出了leader，并且都成功commited了日志，当网络恢复时，重新选举之后的已提交日志是如何处理的呢？新leader会同步老leader的日志吗？老leader再回滚？","like_count":0,"discussions":[{"author":{"id":2027659,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f0/8b/a806789b.jpg","nickname":"int8","note":"","ucode":"EDE812592B8C06","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377959,"discussion_content":"即使发生了网络分区，也不会在一个term选出多个leader","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622979647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293835,"user_name":"Geek_a754be","can_delete":false,"product_type":"c1","uid":2437733,"ip_address":"","ucode":"A18C3752E2C1C8","user_header":"","comment_is_top":false,"comment_ctime":1621572139,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1621572139","product_id":100069901,"comment_content":"老师我想不明白一个问题。<br>既然leaderB crash了它的日志6没有同步到A和C，那样A和C没有最新的日志应该不能当选leader吧。","like_count":0,"discussions":[{"author":{"id":1032462,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c1/0e/5f2751d6.jpg","nickname":"弹簧振子","note":"","ucode":"140FA869F9A659","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377920,"discussion_content":"如果日志6没有同步到A和C，那该日志就没有写成功，client也是可感知到这一点的，因此不影响A和C重新当选leader。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622964349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283808,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1615944493,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1615944493","product_id":100069901,"comment_content":"老师你好，有5个节点，老的Leader和一个组成一个分区，另外三个组成一个分区并选举出一个Leader。有两个Leader对外提供服务，这种怎么处理呢？","like_count":0,"discussions":[{"author":{"id":1752348,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jA97yib7VetXc4iclOg2gGfZu1fO7efyib2mKeqvIxDdmgLqukusyFzPrbIQeZYR0WDJUicRakgVGroaYC7aWGFrEw/132","nickname":"Turing","note":"","ucode":"F88679276D4841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388886,"discussion_content":"不可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629027289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279300,"user_name":"Index","can_delete":false,"product_type":"c1","uid":1078909,"ip_address":"","ucode":"815A1A62F846CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/7d/04c95885.jpg","comment_is_top":false,"comment_ctime":1613712867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613712867","product_id":100069901,"comment_content":"还有一个疑问，在node的主循环run函数里是状态机状态处理的主逻辑。for 循环里的select是随机的，如果propc或者recvc、readyc的消息处理过多，是否会干扰心跳包的发送？每个channel的处理是随机的，这里有没有考虑处理优先级的必要？<br><br>func (n *node) run(r *raft) {<br>\tvar propc chan raftpb.Message<br>\tvar readyc chan Ready<br><br>\tlead := None<br>\tprevSoftSt := r.softState()<br>\tprevHardSt := r.HardState<br>\tprevSnapi := r.raftLog.snapshot.Index<br><br>\tfor {<br>\t\trd := newReady(r, prevSoftSt, prevHardSt, prevSnapi)<br>\t\tif rd.containsUpdates() {<br>\t\t\treadyc = n.readyc<br>\t\t} else {<br>\t\t\treadyc = nil<br>\t\t}<br><br>\t\tif rd.SoftState != nil &amp;&amp; lead != rd.SoftState.Lead {<br>\t\t\tlog.Printf(&quot;raft: leader changed from %#x to %#x&quot;, lead, rd.SoftState.Lead)<br>\t\t\tlead = rd.SoftState.Lead<br>\t\t\tif r.hasLeader() {<br>\t\t\t\tpropc = n.propc<br>\t\t\t} else {<br>\t\t\t\tpropc = nil<br>\t\t\t}<br>\t\t}<br><br>\t\tselect {<br>\t\t&#47;&#47; TODO: maybe buffer the config propose if there exists one (the way<br>\t\t&#47;&#47; described in raft dissertation)<br>\t\t&#47;&#47; Currently it is dropped in Step silently.<br>\t\tcase m := &lt;-propc:<br>\t\t\tm.From = r.id<br>\t\t\tr.Step(m)<br>\t\tcase m := &lt;-n.recvc:<br>\t\t\tr.Step(m) &#47;&#47; raft never returns an error<br>\t\tcase c := &lt;-n.compactc:<br>\t\t\tr.compact(c.index, c.nodes, c.data)<br>\t\tcase cc := &lt;-n.confc:<br>\t\t\tif cc.NodeID == None {<br>\t\t\t\tr.resetPendingConf()<br>\t\t\t\tbreak<br>\t\t\t}<br>\t\t\tswitch cc.Type {<br>\t\t\tcase raftpb.ConfChangeAddNode:<br>\t\t\t\tr.addNode(cc.NodeID)<br>\t\t\tcase raftpb.ConfChangeRemoveNode:<br>\t\t\t\tr.removeNode(cc.NodeID)<br>\t\t\tdefault:<br>\t\t\t\tpanic(&quot;unexpected conf type&quot;)<br>\t\t\t}<br>\t\tcase &lt;-n.tickc:<br>\t\t\tr.tick()<br>\t\tcase readyc &lt;- rd:<br>\t\t\tif rd.SoftState != nil {<br>\t\t\t\tprevSoftSt = rd.SoftState<br>\t\t\t}<br>\t\t\tif !IsEmptyHardState(rd.HardState) {<br>\t\t\t\tprevHardSt = rd.HardState<br>\t\t\t}<br>\t\t\tif !IsEmptySnap(rd.Snapshot) {<br>\t\t\t\tprevSnapi = rd.Snapshot.Index<br>\t\t\t}<br>\t\t\t&#47;&#47; TODO(yichengq): we assume that all committed config<br>\t\t\t&#47;&#47; entries will be applied to make things easy for now.<br>\t\t\t&#47;&#47; TODO(yichengq): it may have race because applied is set<br>\t\t\t&#47;&#47; before entries are applied.<br>\t\t\tr.raftLog.resetNextEnts()<br>\t\t\tr.raftLog.resetUnstable()<br>\t\t\tr.msgs = nil<br>\t\tcase &lt;-n.done:<br>\t\t\treturn<br>\t\t}<br>}","like_count":0},{"had_liked":false,"id":277597,"user_name":"Buffalo","can_delete":false,"product_type":"c1","uid":1198446,"ip_address":"","ucode":"A066E048EBDA33","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBLNWibggjw6BHRvG4FoZuQeNtMwCFUepzp36u8u9kf9K2ibcEnoMn876WNAeib7JgIUvK9UPxWeenyQ/132","comment_is_top":false,"comment_ctime":1612488247,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1612488247","product_id":100069901,"comment_content":"大佬请教个问题，ETCD舍弃了CAP的哪个？以前我以为是舍弃了强一致性，保证可用性、分区容错性。但是今天我迷茫了。","like_count":0,"discussions":[{"author":{"id":2437733,"avatar":"","nickname":"Geek_a754be","note":"","ucode":"A18C3752E2C1C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375417,"discussion_content":"我理解舍弃的A，是一个CP系统","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621638180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2437733,"avatar":"","nickname":"Geek_a754be","note":"","ucode":"A18C3752E2C1C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551190,"discussion_content":"明显是安全性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644921414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375417,"ip_address":""},"score":551190,"extra":""}]}]},{"had_liked":false,"id":276375,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1611904407,"is_pvip":false,"replies":[{"id":"100335","content":"是的，follower收到leader发送到的MsgApp消息后，通过一系列安全检查后，首先持久化到自己wal中，然后再回复给leader MsgAppResp消息的，并追加到稳定的raft log中。所以老leader crash后，此follower raft log中已经含有相关提案对应的日志条目，若此follower可以赢得选举，成为新leader，那么leader crash前提交的提案，就会被它复制给集群所有节点。","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1612000809,"ip_address":"","comment_id":276375,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1611904407","product_id":100069901,"comment_content":"请问唐老师，我理解follower上的WAL和稳定raft日志是通过接收leader的MsgApp消息来更新的。那如果leader是在发送MsgApp之后接收MsgResp之前崩溃，选举完成的新集群如何知道一个日志条目已经被多数follower持久化了呢？是不是选举后集群中的新leader和follower是不是根据自己raft模块中的提案日志来确定的？谢谢","like_count":1,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514681,"discussion_content":"是的，follower收到leader发送到的MsgApp消息后，通过一系列安全检查后，首先持久化到自己wal中，然后再回复给leader MsgAppResp消息的，并追加到稳定的raft log中。所以老leader crash后，此follower raft log中已经含有相关提案对应的日志条目，若此follower可以赢得选举，成为新leader，那么leader crash前提交的提案，就会被它复制给集群所有节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612000809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2449777,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDUJyeq54fiaXAgF62tNeocO3lHsKT4mygEcNoZLnibg6ONKicMgCgUHSfgW8hrMUXlwpNSzR8MHZwg/132","nickname":"types","note":"","ucode":"8B50927EF1804F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352272,"discussion_content":"收到MsgApp的Follower 是否一定可以成为新的leader","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614670473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275986,"user_name":"左耳朵猫","can_delete":false,"product_type":"c1","uid":1698192,"ip_address":"","ucode":"C79FCDD9B61303","user_header":"https://static001.geekbang.org/account/avatar/00/19/e9/90/2932d464.jpg","comment_is_top":false,"comment_ctime":1611737295,"is_pvip":false,"replies":[{"id":"100195","content":"嗯，晚上更新到04","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611740812,"ip_address":"","comment_id":275986,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611737295","product_id":100069901,"comment_content":"额 老师 上节课的思考题答案呢.,是xpensive read会导致频繁升级读写锁.导致写请求往后推迟,然后就超时了.吗","like_count":0,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514557,"discussion_content":"嗯，晚上更新到04","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611740812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275919,"user_name":"Simon","can_delete":false,"product_type":"c1","uid":1068163,"ip_address":"","ucode":"107606167D23E8","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/83/7788fc66.jpg","comment_is_top":false,"comment_ctime":1611717916,"is_pvip":true,"replies":[{"id":"100197","content":"是的，笔误，已修正，谢谢","user_name":"作者回复","user_name_real":"唐聪","uid":"1009582","ctime":1611747190,"ip_address":"","comment_id":275919,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1611717916","product_id":100069901,"comment_content":"在日志图 2 中，Follower B 返回给 client 成功后若突然 crash 了，此时可能还并未将 6 号日志条目已提交的消息通知到 Follower A 和 C<br><br>老师, 这里的Follower B是不是Leader B啊?","like_count":0,"discussions":[{"author":{"id":1009582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/ae/37b492db.jpg","nickname":"唐聪","note":"","ucode":"99CB061EDF35EA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514530,"discussion_content":"是的，笔误，已修正，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611747190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083545,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/99/6945c324.jpg","nickname":"吴展","note":"","ucode":"F7537C0570F212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395024,"discussion_content":"如果B没有成功通知到A和C，会给client发成功吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632190933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}