{"id":211388,"title":"04 | 连接池：别让连接池帮了倒忙","content":"<p>你好，我是朱晔。今天，我们来聊聊使用连接池需要注意的问题。</p><p>在上一讲，我们学习了使用线程池需要注意的问题。今天，我再与你说说另一种很重要的池化技术，即连接池。</p><p>我先和你说说连接池的结构。连接池一般对外提供获得连接、归还连接的接口给客户端使用，并暴露最小空闲连接数、最大连接数等可配置参数，在内部则实现连接建立、连接心跳保持、连接管理、空闲连接回收、连接可用性检测等功能。连接池的结构示意图，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/16/7e/1685d9db2602e1de8483de171af6fd7e.png?wh=1772*1058\" alt=\"\"></p><p>业务项目中经常会用到的连接池，主要是数据库连接池、Redis连接池和HTTP连接池。所以，今天我就以这三种连接池为例，和你聊聊使用和配置连接池容易出错的地方。</p><h2>注意鉴别客户端SDK是否基于连接池</h2><p>在使用三方客户端进行网络通信时，我们首先要确定客户端SDK是否是基于连接池技术实现的。我们知道，TCP是面向连接的基于字节流的协议：</p><ul>\n<li>面向连接，意味着连接需要先创建再使用，创建连接的三次握手有一定开销；</li>\n<li>基于字节流，意味着字节是发送数据的最小单元，TCP协议本身无法区分哪几个字节是完整的消息体，也无法感知是否有多个客户端在使用同一个TCP连接，TCP只是一个读写数据的管道。</li>\n</ul><p>如果客户端SDK没有使用连接池，而直接是TCP连接，那么就需要考虑每次建立TCP连接的开销，<strong>并且因为TCP基于字节流，在多线程的情况下对同一连接进行复用，可能会产生线程安全问题</strong>。</p><!-- [[[read_end]]] --><p>我们先看一下涉及TCP连接的客户端SDK，对外提供API的三种方式。在面对各种三方客户端的时候，只有先识别出其属于哪一种，才能理清楚使用方式。</p><ul>\n<li>连接池和连接分离的API：有一个XXXPool类负责连接池实现，先从其获得连接XXXConnection，然后用获得的连接进行服务端请求，完成后使用者需要归还连接。通常，XXXPool是线程安全的，可以并发获取和归还连接，而XXXConnection是非线程安全的。对应到连接池的结构示意图中，XXXPool就是右边连接池那个框，左边的客户端是我们自己的代码。</li>\n<li>内部带有连接池的API：对外提供一个XXXClient类，通过这个类可以直接进行服务端请求；这个类内部维护了连接池，SDK使用者无需考虑连接的获取和归还问题。一般而言，XXXClient是线程安全的。对应到连接池的结构示意图中，整个API就是蓝色框包裹的部分。</li>\n<li>非连接池的API：一般命名为XXXConnection，以区分其是基于连接池还是单连接的，而不建议命名为XXXClient或直接是XXX。直接连接方式的API基于单一连接，每次使用都需要创建和断开连接，性能一般，且通常不是线程安全的。对应到连接池的结构示意图中，这种形式相当于没有右边连接池那个框，客户端直接连接服务端创建连接。</li>\n</ul><p>虽然上面提到了SDK一般的命名习惯，但不排除有一些客户端特立独行，因此在使用三方SDK时，一定要先查看官方文档了解其最佳实践，或是在类似Stackoverflow的网站搜索XXX threadsafe/singleton字样看看大家的回复，也可以一层一层往下看源码，直到定位到原始Socket来判断Socket和客户端API的对应关系。</p><p>明确了SDK连接池的实现方式后，我们就大概知道了使用SDK的最佳实践：</p><ul>\n<li>如果是分离方式，那么连接池本身一般是线程安全的，可以复用。每次使用需要从连接池获取连接，使用后归还，归还的工作由使用者负责。</li>\n<li>如果是内置连接池，SDK会负责连接的获取和归还，使用的时候直接复用客户端。</li>\n<li>如果SDK没有实现连接池（大多数中间件、数据库的客户端SDK都会支持连接池），那通常不是线程安全的，而且短连接的方式性能不会很高，使用的时候需要考虑是否自己封装一个连接池。</li>\n</ul><p>接下来，我就以Java中用于操作Redis最常见的库Jedis为例，从源码角度分析下Jedis类到底属于哪种类型的API，直接在多线程环境下复用一个连接会产生什么问题，以及如何用最佳实践来修复这个问题。</p><p>首先，向Redis初始化2组数据，Key=a、Value=1，Key=b、Value=2：</p><pre><code>@PostConstruct\npublic void init() {\n    try (Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379)) {\n        Assert.isTrue(&quot;OK&quot;.equals(jedis.set(&quot;a&quot;, &quot;1&quot;)), &quot;set a = 1 return OK&quot;);\n        Assert.isTrue(&quot;OK&quot;.equals(jedis.set(&quot;b&quot;, &quot;2&quot;)), &quot;set b = 2 return OK&quot;);\n    }\n}\n</code></pre><p>然后，启动两个线程，共享操作同一个Jedis实例，每一个线程循环1000次，分别读取Key为a和b的Value，判断是否分别为1和2：</p><pre><code>Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);\nnew Thread(() -&gt; {\n    for (int i = 0; i &lt; 1000; i++) {\n        String result = jedis.get(&quot;a&quot;);\n        if (!result.equals(&quot;1&quot;)) {\n            log.warn(&quot;Expect a to be 1 but found {}&quot;, result);\n            return;\n        }\n    }\n}).start();\nnew Thread(() -&gt; {\n    for (int i = 0; i &lt; 1000; i++) {\n        String result = jedis.get(&quot;b&quot;);\n        if (!result.equals(&quot;2&quot;)) {\n            log.warn(&quot;Expect b to be 2 but found {}&quot;, result);\n            return;\n        }\n    }\n}).start();\nTimeUnit.SECONDS.sleep(5);\n</code></pre><p>执行程序多次，可以看到日志中出现了各种奇怪的异常信息，有的是读取Key为b的Value读取到了1，有的是流非正常结束，还有的是连接关闭异常：</p><pre><code>//错误1\n[14:56:19.069] [Thread-28] [WARN ] [.t.c.c.redis.JedisMisreuseController:45  ] - Expect b to be 2 but found 1\n//错误2\nredis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream.\n\tat redis.clients.jedis.util.RedisInputStream.ensureFill(RedisInputStream.java:202)\n\tat redis.clients.jedis.util.RedisInputStream.readLine(RedisInputStream.java:50)\n\tat redis.clients.jedis.Protocol.processError(Protocol.java:114)\n\tat redis.clients.jedis.Protocol.process(Protocol.java:166)\n\tat redis.clients.jedis.Protocol.read(Protocol.java:220)\n\tat redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:318)\n\tat redis.clients.jedis.Connection.getBinaryBulkReply(Connection.java:255)\n\tat redis.clients.jedis.Connection.getBulkReply(Connection.java:245)\n\tat redis.clients.jedis.Jedis.get(Jedis.java:181)\n\tat org.geekbang.time.commonmistakes.connectionpool.redis.JedisMisreuseController.lambda$wrong$1(JedisMisreuseController.java:43)\n\tat java.lang.Thread.run(Thread.java:748)\n//错误3\njava.io.IOException: Socket Closed\n\tat java.net.AbstractPlainSocketImpl.getOutputStream(AbstractPlainSocketImpl.java:440)\n\tat java.net.Socket$3.run(Socket.java:954)\n\tat java.net.Socket$3.run(Socket.java:952)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.Socket.getOutputStream(Socket.java:951)\n\tat redis.clients.jedis.Connection.connect(Connection.java:200)\n\t... 7 more\n</code></pre><p>让我们分析一下Jedis类的源码，搞清楚其中缘由吧。</p><pre><code>public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands,\n    AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands, ModuleCommands {\n}\npublic class BinaryJedis implements BasicCommands, BinaryJedisCommands, MultiKeyBinaryCommands,\n    AdvancedBinaryJedisCommands, BinaryScriptingCommands, Closeable {\n\tprotected Client client = null;\n      ...\n}\n\npublic class Client extends BinaryClient implements Commands {\n}\npublic class BinaryClient extends Connection {\n}\npublic class Connection implements Closeable {\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n}\n</code></pre><p>可以看到，Jedis继承了BinaryJedis，BinaryJedis中保存了单个Client的实例，Client最终继承了Connection，Connection中保存了单个Socket的实例，和Socket对应的两个读写流。因此，一个Jedis对应一个Socket连接。类图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/0f/e72120b1f6daf4a951e75c05b9191a0f.png?wh=1326*1164\" alt=\"\"></p><p>BinaryClient封装了各种Redis命令，其最终会调用基类Connection的方法，使用Protocol类发送命令。看一下Protocol类的sendCommand方法的源码，可以发现其发送命令时是直接操作RedisOutputStream写入字节。</p><p>我们在多线程环境下复用Jedis对象，其实就是在复用RedisOutputStream。<strong>如果多个线程在执行操作，那么既无法确保整条命令以一个原子操作写入Socket，也无法确保写入后、读取前没有其他数据写到远端</strong>：</p><pre><code>private static void sendCommand(final RedisOutputStream os, final byte[] command,\n\t  final byte[]... args) {\n\ttry {\n\t  os.write(ASTERISK_BYTE);\n\t  os.writeIntCrLf(args.length + 1);\n\t  os.write(DOLLAR_BYTE);\n\t  os.writeIntCrLf(command.length);\n\t  os.write(command);\n\t  os.writeCrLf();\n\n\n\t  for (final byte[] arg : args) {\n\t    os.write(DOLLAR_BYTE);\n\t    os.writeIntCrLf(arg.length);\n\t    os.write(arg);\n\t    os.writeCrLf();\n\t  }\n\t} catch (IOException e) {\n\t  throw new JedisConnectionException(e);\n\t}\n}\n</code></pre><p>看到这里我们也可以理解了，为啥多线程情况下使用Jedis对象操作Redis会出现各种奇怪的问题。</p><p>比如，写操作互相干扰，多条命令相互穿插的话，必然不是合法的Redis命令，那么Redis会关闭客户端连接，导致连接断开；又比如，线程1和2先后写入了get a和get b操作的请求，Redis也返回了值1和2，但是线程2先读取了数据1就会出现数据错乱的问题。</p><p>修复方式是，使用Jedis提供的另一个线程安全的类JedisPool来获得Jedis的实例。JedisPool可以声明为static在多个线程之间共享，扮演连接池的角色。使用时，按需使用try-with-resources模式从JedisPool获得和归还Jedis实例。</p><pre><code>private static JedisPool jedisPool = new JedisPool(&quot;127.0.0.1&quot;, 6379);\n\nnew Thread(() -&gt; {\n    try (Jedis jedis = jedisPool.getResource()) {\n        for (int i = 0; i &lt; 1000; i++) {\n            String result = jedis.get(&quot;a&quot;);\n            if (!result.equals(&quot;1&quot;)) {\n                log.warn(&quot;Expect a to be 1 but found {}&quot;, result);\n                return;\n            }\n        }\n    }\n}).start();\nnew Thread(() -&gt; {\n    try (Jedis jedis = jedisPool.getResource()) {\n        for (int i = 0; i &lt; 1000; i++) {\n            String result = jedis.get(&quot;b&quot;);\n            if (!result.equals(&quot;2&quot;)) {\n                log.warn(&quot;Expect b to be 2 but found {}&quot;, result);\n                return;\n            }\n        }\n    }\n}).start();\n</code></pre><p>这样修复后，代码不再有线程安全问题了。此外，我们最好通过shutdownhook，在程序退出之前关闭JedisPool：</p><pre><code>@PostConstruct\npublic void init() {\n    Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {\n        jedisPool.close();\n    }));\n}\n</code></pre><p>看一下Jedis类close方法的实现可以发现，如果Jedis是从连接池获取的话，那么close方法会调用连接池的return方法归还连接：</p><pre><code>public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands,\n    AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands, ModuleCommands {\n  protected JedisPoolAbstract dataSource = null;\n\n\n  @Override\n  public void close() {\n    if (dataSource != null) {\n      JedisPoolAbstract pool = this.dataSource;\n      this.dataSource = null;\n      if (client.isBroken()) {\n        pool.returnBrokenResource(this);\n      } else {\n        pool.returnResource(this);\n      }\n    } else {\n      super.close();\n    }\n  }\n}\n</code></pre><p>如果不是，则直接关闭连接，其最终调用Connection类的disconnect方法来关闭TCP连接：</p><pre><code>public void disconnect() {\n  if (isConnected()) {\n    try {\n      outputStream.flush();\n      socket.close();\n    } catch (IOException ex) {\n      broken = true;\n      throw new JedisConnectionException(ex);\n    } finally {\n      IOUtils.closeQuietly(socket);\n    }\n  }\n}\n</code></pre><p>可以看到，Jedis可以独立使用，也可以配合连接池使用，这个连接池就是JedisPool。我们再看看JedisPool的实现。</p><pre><code>public class JedisPool extends JedisPoolAbstract {\n@Override\n  public Jedis getResource() {\n    Jedis jedis = super.getResource();\n    jedis.setDataSource(this);\n    return jedis;\n  }\n\n  @Override\n  protected void returnResource(final Jedis resource) {\n    if (resource != null) {\n      try {\n        resource.resetState();\n        returnResourceObject(resource);\n      } catch (Exception e) {\n        returnBrokenResource(resource);\n        throw new JedisException(&quot;Resource is returned to the pool as broken&quot;, e);\n      }\n    }\n  }\n}\n\npublic class JedisPoolAbstract extends Pool&lt;Jedis&gt; {\n}\n\npublic abstract class Pool&lt;T&gt; implements Closeable {\n  protected GenericObjectPool&lt;T&gt; internalPool;\n}\n</code></pre><p>JedisPool的getResource方法在拿到Jedis对象后，将自己设置为了连接池。连接池JedisPool，继承了JedisPoolAbstract，而后者继承了抽象类Pool，Pool内部维护了Apache Common的通用池GenericObjectPool。JedisPool的连接池就是基于GenericObjectPool的。</p><p>看到这里我们了解了，Jedis的API实现是我们说的三种类型中的第一种，也就是连接池和连接分离的API，JedisPool是线程安全的连接池，Jedis是非线程安全的单一连接。知道了原理之后，我们再使用Jedis就胸有成竹了。</p><h2>使用连接池务必确保复用</h2><p>在介绍<a href=\"https://time.geekbang.org/column/article/210337\">线程池</a>的时候我们强调过，<strong>池一定是用来复用的，否则其使用代价会比每次创建单一对象更大。对连接池来说更是如此，原因如下：</strong></p><ul>\n<li>创建连接池的时候很可能一次性创建了多个连接，大多数连接池考虑到性能，会在初始化的时候维护一定数量的最小连接（毕竟初始化连接池的过程一般是一次性的），可以直接使用。如果每次使用连接池都按需创建连接池，那么很可能你只用到一个连接，但是创建了N个连接。</li>\n<li>连接池一般会有一些管理模块，也就是连接池的结构示意图中的绿色部分。举个例子，大多数的连接池都有闲置超时的概念。连接池会检测连接的闲置时间，定期回收闲置的连接，把活跃连接数降到最低（闲置）连接的配置值，减轻服务端的压力。一般情况下，闲置连接由独立线程管理，启动了空闲检测的连接池相当于还会启动一个线程。此外，有些连接池还需要独立线程负责连接保活等功能。因此，启动一个连接池相当于启动了N个线程。</li>\n</ul><p>除了使用代价，连接池不释放，还可能会引起线程泄露。接下来，我就以Apache HttpClient为例，和你说说连接池不复用的问题。</p><p>首先，创建一个CloseableHttpClient，设置使用PoolingHttpClientConnectionManager连接池并启用空闲连接驱逐策略，最大空闲时间为60秒，然后使用这个连接来请求一个会返回OK字符串的服务端接口：</p><pre><code>@GetMapping(&quot;wrong1&quot;)\npublic String wrong1() {\n    CloseableHttpClient client = HttpClients.custom()\n            .setConnectionManager(new PoolingHttpClientConnectionManager())\n            .evictIdleConnections(60, TimeUnit.SECONDS).build();\n    try (CloseableHttpResponse response = client.execute(new HttpGet(&quot;http://127.0.0.1:45678/httpclientnotreuse/test&quot;))) {\n        return EntityUtils.toString(response.getEntity());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return null;\n}\n</code></pre><p>访问这个接口几次后查看应用线程情况，可以看到有大量叫作Connection evictor的线程，且这些线程不会销毁：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/10/33a2389c20653e97b8157897d06c1510.png?wh=2142*664\" alt=\"\"></p><p>对这个接口进行几秒的压测（压测使用wrk，1个并发1个连接）可以看到，已经建立了三千多个TCP连接到45678端口（其中有1个是压测客户端到Tomcat的连接，大部分都是HttpClient到Tomcat的连接）：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/f2/54a71ee9a7bbbd5e121b12fe6289aff2.png?wh=592*122\" alt=\"\"></p><p>好在有了空闲连接回收的策略，60秒之后连接处于CLOSE_WAIT状态，最终彻底关闭。</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/77/8ea5f53e6510d76cf447c23fb15daa77.png?wh=1868*198\" alt=\"\"></p><p>这2点证明，CloseableHttpClient属于第二种模式，即内部带有连接池的API，其背后是连接池，最佳实践一定是复用。</p><p>复用方式很简单，你可以把CloseableHttpClient声明为static，只创建一次，并且在JVM关闭之前通过addShutdownHook钩子关闭连接池，在使用的时候直接使用CloseableHttpClient即可，无需每次都创建。</p><p>首先，定义一个right接口来实现服务端接口调用：</p><pre><code>private static CloseableHttpClient httpClient = null;\nstatic {\n    //当然，也可以把CloseableHttpClient定义为Bean，然后在@PreDestroy标记的方法内close这个HttpClient\n    httpClient = HttpClients.custom().setMaxConnPerRoute(1).setMaxConnTotal(1).evictIdleConnections(60, TimeUnit.SECONDS).build();\n    Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {\n        try {\n            httpClient.close();\n        } catch (IOException ignored) {\n        }\n    }));\n}\n\n@GetMapping(&quot;right&quot;)\npublic String right() {\n    try (CloseableHttpResponse response = httpClient.execute(new HttpGet(&quot;http://127.0.0.1:45678/httpclientnotreuse/test&quot;))) {\n        return EntityUtils.toString(response.getEntity());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return null;\n}\n</code></pre><p>然后，重新定义一个wrong2接口，修复之前按需创建CloseableHttpClient的代码，每次用完之后确保连接池可以关闭：</p><pre><code>@GetMapping(&quot;wrong2&quot;)\npublic String wrong2() {\n    try (CloseableHttpClient client = HttpClients.custom()\n            .setConnectionManager(new PoolingHttpClientConnectionManager())\n            .evictIdleConnections(60, TimeUnit.SECONDS).build();\n         CloseableHttpResponse response = client.execute(new HttpGet(&quot;http://127.0.0.1:45678/httpclientnotreuse/test&quot;))) {\n            return EntityUtils.toString(response.getEntity());\n        } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return null;\n}\n</code></pre><p>使用wrk对wrong2和right两个接口分别压测60秒，可以看到两种使用方式性能上的差异，每次创建连接池的QPS是337，而复用连接池的QPS是2022：</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/2d/b79fb99cf8a5c3a17e60b0850544472d.png?wh=1246*688\" alt=\"\"></p><p>如此大的性能差异显然是因为TCP连接的复用。你可能注意到了，刚才定义连接池时，我将最大连接数设置为1。所以，复用连接池方式复用的始终应该是同一个连接，而新建连接池方式应该是每次都会创建新的TCP连接。</p><p>接下来，我们通过网络抓包工具Wireshark来证实这一点。</p><p>如果调用wrong2接口每次创建新的连接池来发起HTTP请求，从Wireshark可以看到，每次请求服务端45678的客户端端口都是新的。这里我发起了三次请求，程序通过HttpClient访问服务端45678的客户端端口号，分别是51677、51679和51681：</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/35/7b8f651755cef0c05ecb08727d315e35.png?wh=2196*1556\" alt=\"\"></p><p>也就是说，每次都是新的TCP连接，放开HTTP这个过滤条件也可以看到完整的TCP握手、挥手的过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/48/0d/4815c0edd21d5bf0cae8c0c3e578960d.png?wh=2146*1503\" alt=\"\"></p><p>而复用连接池方式的接口right的表现就完全不同了。可以看到，第二次HTTP请求#41的客户端端口61468和第一次连接#23的端口是一样的，Wireshark也提示了整个TCP会话中，当前#41请求是第二次请求，前一次是#23，后面一次是#75：</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/2c/2cbada9be98ce33321b29d38adb09f2c.png?wh=1708*1560\" alt=\"\"></p><p>只有TCP连接闲置超过60秒后才会断开，连接池会新建连接。你可以尝试通过Wireshark观察这一过程。</p><p>接下来，我们就继续聊聊连接池的配置问题。</p><h2>连接池的配置不是一成不变的</h2><p>为方便根据容量规划设置连接处的属性，连接池提供了许多参数，包括最小（闲置）连接、最大连接、闲置连接生存时间、连接生存时间等。其中，最重要的参数是最大连接数，它决定了连接池能使用的连接数量上限，达到上限后，新来的请求需要等待其他请求释放连接。</p><p>但，<strong>最大连接数不是设置得越大越好</strong>。如果设置得太大，不仅仅是客户端需要耗费过多的资源维护连接，更重要的是由于服务端对应的是多个客户端，每一个客户端都保持大量的连接，会给服务端带来更大的压力。这个压力又不仅仅是内存压力，可以想一下如果服务端的网络模型是一个TCP连接一个线程，那么几千个连接意味着几千个线程，如此多的线程会造成大量的线程切换开销。</p><p>当然，<strong>连接池最大连接数设置得太小，很可能会因为获取连接的等待时间太长，导致吞吐量低下，甚至超时无法获取连接</strong>。</p><p>接下来，我们就模拟下压力增大导致数据库连接池打满的情况，来实践下如何确认连接池的使用情况，以及有针对性地进行参数优化。</p><p>首先，定义一个用户注册方法，通过@Transactional注解为方法开启事务。其中包含了500毫秒的休眠，一个数据库事务对应一个TCP连接，所以500多毫秒的时间都会占用数据库连接：</p><pre><code>@Transactional\npublic User register(){\n    User user=new User();\n    user.setName(&quot;new-user-&quot;+System.currentTimeMillis());\n    userRepository.save(user);\n    try {\n        TimeUnit.MILLISECONDS.sleep(500);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return user;\n}\n</code></pre><p>随后，修改配置文件启用register-mbeans，使Hikari连接池能通过JMX MBean注册连接池相关统计信息，方便观察连接池：</p><pre><code>spring.datasource.hikari.register-mbeans=true\n</code></pre><p>启动程序并通过JConsole连接进程后，可以看到默认情况下最大连接数为10：</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/94/7b8e5aff5a3ef6ade1d8027c20c92f94.png?wh=1846*996\" alt=\"\"></p><p>使用wrk对应用进行压测，可以看到连接数一下子从0到了10，有20个线程在等待获取连接：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/ef/b22169b8d8bbfabbb8b93ece11a1f9ef.png?wh=2310*1454\" alt=\"\"></p><p>不久就出现了无法获取数据库连接的异常，如下所示：</p><pre><code>[15:37:56.156] [http-nio-45678-exec-15] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.DataAccessResourceFailureException: unable to obtain isolated JDBC connection; nested exception is org.hibernate.exception.JDBCConnectionException: unable to obtain isolated JDBC connection] with root cause\njava.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30000ms.\n</code></pre><p>从异常信息中可以看到，数据库连接池是HikariPool，解决方式很简单，修改一下配置文件，调整数据库连接池最大连接参数到50即可。</p><pre><code>spring.datasource.hikari.maximum-pool-size=50\n</code></pre><p>然后，再观察一下这个参数是否适合当前压力，满足需求的同时也不占用过多资源。从监控来看这个调整是合理的，有一半的富余资源，再也没有线程需要等待连接了：</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/31/d24f23f05d49378a10a857cd8b9ef031.png?wh=2120*1466\" alt=\"\"></p><p>在这个Demo里，我知道压测大概能对应使用25左右的并发连接，所以直接把连接池最大连接设置为了50。在真实情况下，只要数据库可以承受，你可以选择在遇到连接超限的时候先设置一个足够大的连接数，然后观察最终应用的并发，再按照实际并发数留出一半的余量来设置最终的最大连接。</p><p>其实，看到错误日志后再调整已经有点儿晚了。更合适的做法是，<strong>对类似数据库连接池的重要资源进行持续检测，并设置一半的使用量作为报警阈值，出现预警后及时扩容</strong>。</p><p>在这里我是为了演示，才通过JConsole查看参数配置后的效果，生产上需要把相关数据对接到指标监控体系中持续监测。</p><p><strong>这里要强调的是，修改配置参数务必验证是否生效，并且在监控系统中确认参数是否生效、是否合理。之所以要“强调”，是因为这里有坑</strong>。</p><p>我之前就遇到过这样一个事故。应用准备针对大促活动进行扩容，把数据库配置文件中Druid连接池最大连接数maxActive从50提高到了100，修改后并没有通过监控验证，结果大促当天应用因为连接池连接数不够爆了。</p><p>经排查发现，当时修改的连接数并没有生效。原因是，应用虽然一开始使用的是Druid连接池，但后来框架升级了，把连接池替换为了Hikari实现，原来的那些配置其实都是无效的，修改后的参数配置当然也不会生效。</p><p>所以说，对连接池进行调参，一定要眼见为实。</p><h2>重点回顾</h2><p>今天，我以三种业务代码最常用的Redis连接池、HTTP连接池、数据库连接池为例，和你探讨了有关连接池实现方式、使用姿势和参数配置的三大问题。</p><p>客户端SDK实现连接池的方式，包括池和连接分离、内部带有连接池和非连接池三种。要正确使用连接池，就必须首先鉴别连接池的实现方式。比如，Jedis的API实现的是池和连接分离的方式，而Apache HttpClient是内置连接池的API。</p><p>对于使用姿势其实就是两点，一是确保连接池是复用的，二是尽可能在程序退出之前显式关闭连接池释放资源。连接池设计的初衷就是为了保持一定量的连接，这样连接可以随取随用。从连接池获取连接虽然很快，但连接池的初始化会比较慢，需要做一些管理模块的初始化以及初始最小闲置连接。一旦连接池不是复用的，那么其性能会比随时创建单一连接更差。</p><p>最后，连接池参数配置中，最重要的是最大连接数，许多高并发应用往往因为最大连接数不够导致性能问题。但，最大连接数不是设置得越大越好，够用就好。需要注意的是，针对数据库连接池、HTTP连接池、Redis连接池等重要连接池，务必建立完善的监控和报警机制，根据容量规划及时调整参数配置。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>有了连接池之后，获取连接是从连接池获取，没有足够连接时连接池会创建连接。这时，获取连接操作往往有两个超时时间：一个是从连接池获取连接的最长等待时间，通常叫作请求连接超时connectRequestTimeout或连接等待超时connectWaitTimeout；一个是连接池新建TCP连接三次握手的连接超时，通常叫作连接超时connectTimeout。针对JedisPool、Apache HttpClient和Hikari数据库连接池，你知道如何设置这2个参数吗？</li>\n<li>对于带有连接池的SDK的使用姿势，最主要的是鉴别其内部是否实现了连接池，如果实现了连接池要尽量复用Client。对于NoSQL中的MongoDB来说，使用MongoDB Java驱动时，MongoClient类应该是每次都创建还是复用呢？你能否在<a href=\"https://mongodb.github.io/mongo-java-driver/3.12/\">官方文档</a>中找到答案呢？</li>\n</ol><p>关于连接池，你还遇到过什么坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"03 | 线程池：业务代码最常用也最容易犯错的组件","id":210337},"right":{"article_title":"05 | HTTP调用：你考虑到超时、重试、并发了吗？","id":213273}},"comments":[{"had_liked":false,"id":188320,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1584339541,"is_pvip":true,"replies":[{"id":"72684","content":"<br>假设我们希望设置连接超时5s，获取连接超时10s：<br><br>hikari两个参数设置方式：<br>spring.datasource.hikari.connection-timeout=10000<br>spring.datasource.url=jdbc:mysql:&#47;&#47;localhost:6657&#47;common_mistakes?connectTimeout=5000&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;rewriteBatchedStatements=true<br><br>jedis两个参数设置：<br>JedisPoolConfig config = new JedisPoolConfig();<br>        config.setMaxWaitMillis(10000);<br>        try (JedisPool jedisPool = new JedisPool(config, &quot;127.0.0.1&quot;, 6379, 5000);<br>             Jedis jedis = jedisPool.getResource()) {<br>            return jedis.set(&quot;test&quot;, &quot;test&quot;);<br>        }<br><br>httpclient两个参数设置：<br>RequestConfig requestConfig = RequestConfig.custom()<br>                .setConnectTimeout(5000)<br>                .setConnectionRequestTimeout(10000)<br>                .build();<br>        HttpGet httpGet = new HttpGet(&quot;http:&#47;&#47;127.0.0.1:45678&#47;twotimeoutconfig&#47;test&quot;);<br>        httpGet.setConfig(requestConfig);<br>        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {...","user_name":"作者回复","comment_id":188320,"uid":"1001470","ip_address":"","utype":1,"ctime":1584347115,"user_name_real":"朱晔"}],"discussion_count":5,"race_medal":0,"score":"9.2233722918421996e+18","product_id":100047701,"comment_content":"实操性比较强，收获满满！！！<br>自从spring boot 2.x版本后，有较大的改动：<br>\t默认的redis的链接池从JedisPool变成了LettucePool，Lettuce主要利用netty实现与redis的同步和异步通信。所以更安全和性能更好；<br>\t默认的数据库连接池也变更为HikariCP，HiKariCP 号称是业界跑得最快的数据库连接池，HiKariCP 官方网站解释了其性能之所以如此之高的秘密。微观上 HiKariCP 程序编译出的字节码执行效率更高，站在字节码的角度去优化 Java 代码，HiKariCP 的作者对性能的执着可见一斑，不过遗憾的是他并没有详细解释都做了哪些优化。而宏观上主要是和两个数据结构有关，一个是 FastList，另一个是 ConcurrentBag。<br>\tFastList是对Java List的增强，HiKariCP作者认为Java SDK的List在其使用场景下比较慢，因此在SDK提供的List（ArrayList的remove）的基础上做了增强；<br>\tConcurrentBag是对Java并发集合的增强， 通过 ThreadLocal 做一次预分配，避免直接竞争共享资源，非常适合池化资源的分配。<br>试着回答下课后的问题：<br>第一个问题：<br>\tJedisPool的设置：<br>\t\t获取链接超时：maxWait<br>\t\tTCP超时：JedisPool中有一个soTimeout的属性，在链接的时候,使用socket.setSoTimeout(soTimeout)控制的。<br>\tHikariCP的设置：<br>\t\t获取链接超时：connectionTimeout。 This property controls the maximum number of milliseconds that a client (that&#39;s you) will wait for a connection from \t\t\t\tthe pool. If this time is exceeded without a connection becoming available, a SQLException will be thrown. Lowest acceptable connection \t\t\ttimeout is 250ms. Default: 30000 (30 seconds)<br>\t\tTCP超时：数据的库的wait_timeout属性吧<br>\tApache HttpClient设置：<br>\t\t获取链接超时：connectionRequestTimeout<br>\t\t建立链接超时：connectionTimeout<br>\t\t等待响应超时：socketTimeout<br><br>第二个问题就不回答了，因为到目前为止，还没有在生产使用过Mongo，😂😂😂😂<br><br>上面有些参数感觉说的不对，请老师指点","like_count":59,"discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205845,"discussion_content":"收到，谢谢老师，那我的应该就HikariCP的TCP链接超时有问题，应该是在url后面跟上connectTimeout，谢谢老师，🙏🙏\n再次整理下数据库部分的超时：\n\n配置文件（从资源池获取链接时间）\nconnectionTimeout：表示从数据库连接池DataSource中获取链接超时。\n\nurl后面可以跟下面两个属性：\nconnectTimeout：表示的是数据库驱动(mysql-connector-java)与mysql服务器建立TCP连接的超时时间。\nsocketTimeout：是通过TCP连接发送数据(在这里就是要执行的sql)后，等待响应的超时时间。\n\n程序或者配置文件设定：\nstatement timeout：socket timeout统一限制了所有SQL执行的最大耗时，有的时候，我们希望为不同的SQL指定不同的最大超时时间。这可以通过statement timeout来完成。\nStatement对象提供了一个setQueryTimeout方法(其子类PreparedStatement继承了这个方法)，单位是秒，默认值为0，也就是 不超时。\n\n程序设定：\n transaction timeout：在事务的情况下，可能需要执行多个sql，整个事务设置超时时间。\n\n\n","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1584349910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487374,"discussion_content":"\n假设我们希望设置连接超时5s，获取连接超时10s：\n\nhikari两个参数设置方式：\nspring.datasource.hikari.connection-timeout=10000\nspring.datasource.url=jdbc:mysql://localhost:6657/common_mistakes?connectTimeout=5000&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;rewriteBatchedStatements=true\n\njedis两个参数设置：\nJedisPoolConfig config = new JedisPoolConfig();\n        config.setMaxWaitMillis(10000);\n        try (JedisPool jedisPool = new JedisPool(config, &amp;quot;127.0.0.1&amp;quot;, 6379, 5000);\n             Jedis jedis = jedisPool.getResource()) {\n            return jedis.set(&amp;quot;test&amp;quot;, &amp;quot;test&amp;quot;);\n        }\n\nhttpclient两个参数设置：\nRequestConfig requestConfig = RequestConfig.custom()\n                .setConnectTimeout(5000)\n                .setConnectionRequestTimeout(10000)\n                .build();\n        HttpGet httpGet = new HttpGet(&amp;quot;http://127.0.0.1:45678/twotimeoutconfig/test&amp;quot;);\n        httpGet.setConfig(requestConfig);\n        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584347115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209327,"discussion_content":"请问statement timeout可以在配置文件中配置？该怎么做呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584627514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":209541,"discussion_content":"你说的配置文件是spring的吗？那个我没有试过，mybaties的文件是可以的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584633747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":209327,"ip_address":""},"score":209541,"extra":""}]},{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367023,"discussion_content":"有没有lettuce的相关配置分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618237327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187537,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":true,"comment_ctime":1584154316,"is_pvip":false,"replies":[{"id":"72364","content":"自己封装必要不大，然后如果需要走http的话用jolokia，或者使用prometheus的jmx_exporter以agent方式暴露mbeans，https:&#47;&#47;github.com&#47;prometheus&#47;jmx_exporter","user_name":"作者回复","comment_id":187537,"uid":"1001470","ip_address":"","utype":1,"ctime":1584157790,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"9.2233721801729004e+18","product_id":100047701,"comment_content":"请问对于连接池的监控，是把监控系统直连JMX，监控、修改操作都走连接池已经实现好的JMX比较好？还是自己做一层封装，对外暴露接口，以编程方式获取、设置参数比较好？","like_count":34,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487136,"discussion_content":"自己封装必要不大，然后如果需要走http的话用jolokia，或者使用prometheus的jmx_exporter以agent方式暴露mbeans，https://github.com/prometheus/jmx_exporter","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584157790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188136,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":true,"comment_ctime":1584323636,"is_pvip":false,"replies":[{"id":"72675","content":"总结的不错","user_name":"作者回复","comment_id":188136,"uid":"1001470","ip_address":"","utype":1,"ctime":1584330528,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"9.2233720856836997e+18","product_id":100047701,"comment_content":"个人总结：<br>1. 池化技术的核心在于，在鱼塘养好一群鱼，需要的时候就从里面拿一条，用完再放回去。而不是自己生产一条鱼，然后用完就销毁。从而减少了开销。<br>2. 大多已经实现的连接池，都是有线程安全处理的。通常比个人创建管理连接更加安全。<br>3. 使用了连接池技术，就要保证连接池能够被有效复用。频繁创建连接池比频繁创建链接更加耗费资源。<br>4. 连接池的参数配置要根据实际情况，并不存在多多益善<br>5. 连接池的主要好处：（1）减少资源消耗，（2）利用现有的线城安全实现，（3）提升并发量","like_count":11,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487346,"discussion_content":"总结的不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584330528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102228,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/94/6c73ab00.jpg","nickname":"叶落","note":"","ucode":"F836A8144518BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302936,"discussion_content":"啥叫把鱼用完再放回去，请解释下，谢谢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599093743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187627,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1584176763,"is_pvip":false,"replies":[{"id":"72408","content":"优雅关闭总是更好的","user_name":"作者回复","comment_id":187627,"uid":"1001470","ip_address":"","utype":1,"ctime":1584182390,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"35943915131","product_id":100047701,"comment_content":"退出程序前为什么要关闭连接池啊，程序都结束了连接不就释放了么","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487170,"discussion_content":"优雅关闭总是更好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584182390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107666,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","nickname":"z","note":"","ucode":"CDB0BE8562ECB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360642,"discussion_content":"主要是为了减少被调用方的资源消耗吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616497702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965236,"avatar":"","nickname":"Geek_c703f7","note":"","ucode":"0D49860F83534E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237819,"discussion_content":"优雅关闭的前提是不是不能用kill -9 pid ? 但如果kill pid我遇到过杀不死进程的情况，请教老师业内标准做法是怎样的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587189243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187488,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1584143457,"is_pvip":false,"replies":[{"id":"72451","content":"如有收货，欢迎转发","user_name":"作者回复","comment_id":187488,"uid":"1001470","ip_address":"","utype":1,"ctime":1584241321,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"35943881825","product_id":100047701,"comment_content":"干货满满，还需要慢慢消化一下","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487120,"discussion_content":"如有收货，欢迎转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584241321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188254,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1584331870,"is_pvip":false,"replies":[{"id":"72682","content":"回答一下Hikari的配置，其ConnectionTimeout是从连接池获取数据库连接的超时，不是和MySQL建立连接的超时，后者需要设置JDBC连接字符串中的connectTimeout属性。对于Hikari的JavaConfig配置这2个参数的方式是：<br><br>@Bean<br>    public DataSource dataSource(){<br>        HikariConfig hikariConfig = new HikariConfig();<br>        hikariConfig.setConnectionTimeout(2400);<br>        hikariConfig.setJdbcUrl(&quot;jdbc:mysql:&#47;&#47;localhost:6658&#47;common_mistakes&quot;);<br>        hikariConfig.addDataSourceProperty(&quot;connectTimeout&quot;, &quot;1200&quot;);<br>        HikariDataSource dataSource = new HikariDataSource(hikariConfig);<br>        return dataSource;<br>    }","user_name":"作者回复","comment_id":188254,"uid":"1001470","ip_address":"","utype":1,"ctime":1584343121,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"23059168350","product_id":100047701,"comment_content":"hikari具体配置项为application.yml 中 spring.datasource.hikari.connection-timeout<br>点进去可以发现是 HikariDataSource 类，继承了HikariConfig。<br>点进HikariConfig可看出 connectionTimeout不允许小于250毫秒，小于250ms会被强制重置为30秒。<br>参数connectionTimeout定义是并未赋初始值的原始类型long，初始值应该是0L；<br>所以，个人判断，默认的connectionTimeout数值就是30秒。<br>如有纰漏，欢迎指正<br><br>","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487364,"discussion_content":"回答一下Hikari的配置，其ConnectionTimeout是从连接池获取数据库连接的超时，不是和MySQL建立连接的超时，后者需要设置JDBC连接字符串中的connectTimeout属性。对于Hikari的JavaConfig配置这2个参数的方式是：\n\n@Bean\n    public DataSource dataSource(){\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setConnectionTimeout(2400);\n        hikariConfig.setJdbcUrl(&amp;quot;jdbc:mysql://localhost:6658/common_mistakes&amp;quot;);\n        hikariConfig.addDataSourceProperty(&amp;quot;connectTimeout&amp;quot;, &amp;quot;1200&amp;quot;);\n        HikariDataSource dataSource = new HikariDataSource(hikariConfig);\n        return dataSource;\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584343121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206119,"discussion_content":"对于其他组件的配置可以看一下我对Darren问题的回复","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584367617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":206405,"discussion_content":"👌","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584403983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206119,"ip_address":""},"score":206405,"extra":""}]}]},{"had_liked":false,"id":188156,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1584325424,"is_pvip":false,"replies":[{"id":"72677","content":"是的","user_name":"作者回复","comment_id":188156,"uid":"1001470","ip_address":"","utype":1,"ctime":1584330565,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"23059161904","product_id":100047701,"comment_content":"课后题2：<br>受限于本人英文水平，无奈与使用谷歌翻译阅读文档。从文档中得知，MongoClient 对象的正确使用姿势应该是：使用 MongoClients.create()（或者其他有参） 方法创建，并再整个应用程序中使用它。文档内容如下：<br><br>MongoClient （从3.7版本开始）<br>一个MongoClient实例表示到数据库连接池; MongoClient即使有多个线程，您也只需要一个类的实例。<br><br>重要<br>通常，您只MongoClient为给定的MongoDB部署创建一个实例（例如独立实例，副本集或分片群集），并在整个应用程序中使用它。但是，如果您确实创建了多个实例：<br>所有资源使用限制（例如，最大连接数等）适用于每个MongoClient实例。<br>要处置实例，请致电MongoClient.close()以清理资源。<br><br>","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487351,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584330565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284036,"discussion_content":"最后这句「请致电MongoClient.close()」，真实暴露了机器翻译(눈_눈)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592436262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284075,"discussion_content":"要不是机器翻译我都懒得粘全文，直接描述重点就完事了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592441742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284036,"ip_address":""},"score":284075,"extra":""}]}]},{"had_liked":false,"id":195807,"user_name":"justin","can_delete":false,"product_type":"c1","uid":1178721,"ip_address":"","ucode":"8EEB37B7914975","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/61/241b5c75.jpg","comment_is_top":false,"comment_ctime":1585216163,"is_pvip":false,"replies":[{"id":"74314","content":"1、其实本文说的点不是复用连接，而是复用连接池，也就是CloseableHttpClient，一个TCP连接同时自然无法实现多个HTTP请求的复用<br>2、文中设置为1只是举例，实际应用的时候显然应该设置一个合理的最大值，不能是1。扩大MaxConnPerRoute和MaxConnTotal之后qps降低，这个有没有实际的性能数据？你是怎么测试的呢？","user_name":"作者回复","comment_id":195807,"uid":"1001470","ip_address":"","utype":1,"ctime":1585218592,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"18765085347","product_id":100047701,"comment_content":"老师你好，看了这篇文章感觉收获满满，然后关于上面的CloseableHttpClient有个几个疑问：<br>1、复用同一个tcp连接的时候比每次都创建一个新的tcp连接的QPS高很多，当有大量http请求服务端时，每个http连接都共用同一个tcp连接时，这种情况下不会造成其中一些http请求的响应速度变慢吗。<br>2、<br>httpClient = HttpClients.custom().setMaxConnPerRoute(1).setMaxConnTotal(1).evictIdleConnections(60, TimeUnit.SECONDS).build();<br>当我尝试去扩大setMaxConnTotal这个最大连接数时，qps反而降低了。如果线上有上千qps的话，设置连接数为1就可以了吗。<br>","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489160,"discussion_content":"1、其实本文说的点不是复用连接，而是复用连接池，也就是CloseableHttpClient，一个TCP连接同时自然无法实现多个HTTP请求的复用\n2、文中设置为1只是举例，实际应用的时候显然应该设置一个合理的最大值，不能是1。扩大MaxConnPerRoute和MaxConnTotal之后qps降低，这个有没有实际的性能数据？你是怎么测试的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585218592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178721,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/61/241b5c75.jpg","nickname":"justin","note":"","ucode":"8EEB37B7914975","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214837,"discussion_content":"谢谢老师的回复。\n1、对于第一个疑问，right和wrong2的qps差距比较大，有个原因是不是因为CloseableHttpClient请求的是本地接口，几乎没有网络延迟和业务执行时间。因为如果只有一个连接池，一个http请求应该要等前面一个http四次挥手后才能进行复用的是吗。我尝试把CloseableHttpClient要请求的接口延迟20ms返回。这时候right和wrong2的qps就差不多了。\nHttpClients.custom().setMaxConnPerRoute(5).setMaxConnTotal(5).evictIdleConnections(60, TimeUnit.SECONDS).build(); 即使加大了right的最大连接数测试数据也是一样的\n\nlinjunchengdeMacBook-Pro:wrk linjuncheng$ ./wrk -t10 -c100 -d30s http://127.0.0.1:8080/http/right\nRunning 30s test @ http://127.0.0.1:8080/http/right\n  10 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    25.71ms    7.20ms 263.30ms   99.74%\n    Req/Sec    37.17      8.76    50.00     85.00%\n  1167 requests in 30.09s, 131.26KB read\n  Socket errors: connect 0, read 0, write 0, timeout 11\nRequests/sec:     38.78\nTransfer/sec:      4.36KB\nlinjunchengdeMacBook-Pro:wrk linjuncheng$ ./wrk -t10 -c100 -d30s http://127.0.0.1:8080/http/wrong2\nRunning 30s test @ http://127.0.0.1:8080/http/wrong2\n  10 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    27.15ms    3.41ms  84.78ms   94.25%\n    Req/Sec    35.96      6.69    40.00     77.85%\n  1106 requests in 30.08s, 124.41KB read\n  Socket errors: connect 0, read 0, write 0, timeout 11\nRequests/sec:     36.76\nTransfer/sec:      4.14KB\nlinjunchengdeMacBook-Pro:wrk linjuncheng$ \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585236092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187551,"user_name":"Husiun","can_delete":false,"product_type":"c1","uid":1448664,"ip_address":"","ucode":"F783484743BFE4","user_header":"https://static001.geekbang.org/account/avatar/00/16/1a/d8/9ae1bdb9.jpg","comment_is_top":false,"comment_ctime":1584156802,"is_pvip":false,"replies":[{"id":"72365","content":"有收货就好","user_name":"作者回复","comment_id":187551,"uid":"1001470","ip_address":"","utype":1,"ctime":1584157816,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"18764025986","product_id":100047701,"comment_content":"每次更新都是第一时间打开，每一课都干货满满，必须给老师赞一个，http那个平时研究不多还需要好好消化一下。","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487144,"discussion_content":"有收货就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584157816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187496,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1584147213,"is_pvip":false,"replies":[{"id":"72357","content":"可以都放到一个Thread，放到多个的话会并行执行，只要不是太多问题不大。或者用Spring的话还可以使用@PreDestroy来实现资源释放。","user_name":"作者回复","comment_id":187496,"uid":"1001470","ip_address":"","utype":1,"ctime":1584150766,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"18764016397","product_id":100047701,"comment_content":"干货很多，收获很大。问老师一个问题，使用hook来关闭连接池的时候，都会创建一个线程，那如果有多个连接池，每个连接池都有一个线程来调用hook，这样做是否有点奢侈，有没有更优的办法？","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487122,"discussion_content":"可以都放到一个Thread，放到多个的话会并行执行，只要不是太多问题不大。或者用Spring的话还可以使用@PreDestroy来实现资源释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584150766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036052,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","nickname":"Wiggle Wiggle","note":"","ucode":"EFE746551BA998","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204319,"discussion_content":"你可以用一个集合收集所有pool的引用，然后在一个hook里面遍历集合把所有pool关上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584154066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203207,"user_name":"boyxie","can_delete":false,"product_type":"c1","uid":1018342,"ip_address":"","ucode":"FD55E5C569AC58","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/e6/ab403ccb.jpg","comment_is_top":false,"comment_ctime":1586156202,"is_pvip":false,"replies":[{"id":"75967","content":"这个问题我们也遇到过，看下此文你就明白咋回事了：https:&#47;&#47;www.elietio.xyz&#47;2019&#47;12&#47;keepAlive%E8%A7%A3%E5%86%B3druid%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5socket%20timeout%2015%E5%88%86%E9%92%9F.html<br>","user_name":"作者回复","comment_id":203207,"uid":"1001470","ip_address":"","utype":1,"ctime":1586180801,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"14471058090","product_id":100047701,"comment_content":"数据库连接池Druid 在数据库连接被网络中断后，需要15分钟的重连时间，这个超时时间为什么要这么久？总结网上的资料大致是获取连接的时候会去 testConnectionInternal，由于底层socket被断开，会一直被阻塞直到抛异常，老师可以帮忙分析一下吗？","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490798,"discussion_content":"这个问题我们也遇到过，看下此文你就明白咋回事了：https://www.elietio.xyz/2019/12/keepAlive%E8%A7%A3%E5%86%B3druid%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5socket%20timeout%2015%E5%88%86%E9%92%9F.html\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586180801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3f/23/8ff389d2.jpg","nickname":"郁方林","note":"","ucode":"8ABEAFDA815DDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376551,"discussion_content":"今天点击发现链接失效了, 补一个新的连接 https://www.elietio.xyz/posts/fd295ff1.html","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622186841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1130275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3f/23/8ff389d2.jpg","nickname":"郁方林","note":"","ucode":"8ABEAFDA815DDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381582,"discussion_content":"给老哥赞一个，感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625132795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376551,"ip_address":""},"score":381582,"extra":""}]}]},{"had_liked":false,"id":188140,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1584323971,"is_pvip":false,"replies":[{"id":"72676","content":"具体配置参数是什么呢?","user_name":"作者回复","comment_id":188140,"uid":"1001470","ip_address":"","utype":1,"ctime":1584330543,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14469225859","product_id":100047701,"comment_content":"课后题1：<br>Hikari 可以再Spring的配置文件中配置各项参数。","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487347,"discussion_content":"具体配置参数是什么呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584330543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225088,"user_name":"Outside","can_delete":false,"product_type":"c1","uid":1179898,"ip_address":"","ucode":"E04CA55407FF37","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/fa/5863be21.jpg","comment_is_top":false,"comment_ctime":1591636320,"is_pvip":false,"replies":[{"id":"82884","content":"是不是之前做实验的时候server.tomcat.max-threads=1没有改过来呢？","user_name":"作者回复","comment_id":225088,"uid":"1001470","ip_address":"","utype":1,"ctime":1591673424,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10181570912","product_id":100047701,"comment_content":"请教一下老师，执行完 wrong2之后，<br>client.execute阻塞住了是什么原因<br>线程dump如下<br>client.execute &quot;http-nio-8088-exec-1&quot; #28 daemon prio=5 os_prio=31 tid=0x00007fecb09d2000 nid=0x9a03 runnable [0x000070000d121000]<br>   java.lang.Thread.State: RUNNABLE<br>\tat java.net.SocketInputStream.socketRead0(Native Method)<br>\tat java.net.SocketInputStream.socketRead(SocketInputStream.java:116)<br>\tat java.net.SocketInputStream.read(SocketInputStream.java:171)<br>\tat java.net.SocketInputStream.read(SocketInputStream.java:141)<br>\tat org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)<br>\tat org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)<br>\tat org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)<br>\tat org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)<br>\tat org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)<br>\tat org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)<br>\tat org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)<br>\tat org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)<br>\tat org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)<br>\tat org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)<br>\tat org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)<br>\tat org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)<br>\tat org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)<br>\tat org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)<br>\tat org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)<br>\tat org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)<br>\t<br>\t<br><br>尝试用新启一个webserver，<br>用client.execute执行这个新的get请求，可以得到返回<br>这是什么原因呢","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497724,"discussion_content":"是不是之前做实验的时候server.tomcat.max-threads=1没有改过来呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591673424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202644,"user_name":"DZZ","can_delete":false,"product_type":"c1","uid":1516167,"ip_address":"","ucode":"C8E4C4B089BCE2","user_header":"https://static001.geekbang.org/account/avatar/00/17/22/87/e7bd2acf.jpg","comment_is_top":false,"comment_ctime":1586038003,"is_pvip":true,"replies":[{"id":"75730","content":"如果是不同的db但还是一个mongo集群还是用一个，除非你的应用真的是连接了多个mongo的集群","user_name":"作者回复","comment_id":202644,"uid":"1001470","ip_address":"","utype":1,"ctime":1586046941,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"10175972595","product_id":100047701,"comment_content":"如果一个应用里使用了多个mongo库，那么是否应该创建多个mongoclient去对应每一个库的使用？<br>举个例子：1个应用需要连接3个不同mongo库，那么该如何正确去使用mongoclient呢","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490642,"discussion_content":"如果是不同的db但还是一个mongo集群还是用一个，除非你的应用真的是连接了多个mongo的集群","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586046941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1516167,"avatar":"https://static001.geekbang.org/account/avatar/00/17/22/87/e7bd2acf.jpg","nickname":"DZZ","note":"","ucode":"C8E4C4B089BCE2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221691,"discussion_content":"应用的确是连接了多个集群。目前应用偶尔有gc过高的问题，定位到是使用这个mongoclient有关，但是具体原因一直没弄明白。看了老师这件讲的，感觉很有可能就是使用时重复创建了多个连接池，待后续工作时去检查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586048260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196722,"user_name":"z小俊、Arno","can_delete":false,"product_type":"c1","uid":1301304,"ip_address":"","ucode":"312B3DDCF15102","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/38/7ab139a3.jpg","comment_is_top":false,"comment_ctime":1585306990,"is_pvip":false,"replies":[{"id":"74453","content":"后面加餐中我们需要打成jar包运行程序，这个项目中这么多main类，需要指定一个我们需要的main入口","user_name":"作者回复","comment_id":196722,"uid":"1001470","ip_address":"","utype":1,"ctime":1585311137,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"10175241582","product_id":100047701,"comment_content":"老师，说一个与本节无关的问题哈，你的git代码里面这一行，我不明白它的含义。。<br><br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;&#47;groupId&gt;<br>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#47;artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;mainClass&gt;org.geekbang.time.commonmistakes.troubleshootingtools.jdktool.CommonMistakesApplication<br>                    &lt;&#47;mainClass&gt;<br>                &lt;&#47;configuration&gt;<br>            &lt;&#47;plugin&gt;<br>        &lt;&#47;plugins&gt;<br><br><br>这儿的 ：<br>&lt;mainClass&gt;org.geekbang.time.commonmistakes.troubleshootingtools.jdktool.CommonMistakesApplication<br>                    &lt;&#47;mainClass&gt;<br><br>有什么作用啊？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489368,"discussion_content":"后面加餐中我们需要打成jar包运行程序，这个项目中这么多main类，需要指定一个我们需要的main入口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585311137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301304,"avatar":"https://static001.geekbang.org/account/avatar/00/13/db/38/7ab139a3.jpg","nickname":"z小俊、Arno","note":"","ucode":"312B3DDCF15102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215281,"discussion_content":"明白啦！ 只指定一个有main方法的class作为mainclass","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585312048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191806,"user_name":"刘善良~","can_delete":false,"product_type":"c1","uid":1904989,"ip_address":"","ucode":"585690B7BC72C8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/11/5d/25328b33.jpg","comment_is_top":false,"comment_ctime":1584798020,"is_pvip":false,"replies":[{"id":"73469","content":"音频可以倍速的","user_name":"作者回复","comment_id":191806,"uid":"1001470","ip_address":"","utype":1,"ctime":1584801365,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10174732612","product_id":100047701,"comment_content":"有文档 资料 ,还是语音 要是 能倍速 播放 最好了,睡觉听,坐地铁听","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488261,"discussion_content":"音频可以倍速的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584801365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190673,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1584680361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174614953","product_id":100047701,"comment_content":"jconsole观察连接数的时候为啥我这里没有图形的方式呢？","like_count":2},{"had_liked":false,"id":188644,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1584395364,"is_pvip":false,"replies":[{"id":"72756","content":"优雅关闭总是好的，特别是涉及到服务端的tcp连接","user_name":"作者回复","comment_id":188644,"uid":"1001470","ip_address":"","utype":1,"ctime":1584403805,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10174329956","product_id":100047701,"comment_content":"进程都kill了，相关的资源应该自动释放吧，比如启动的线程和连接。jvm环境都没了，依赖的基础都没了","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487475,"discussion_content":"优雅关闭总是好的，特别是涉及到服务端的tcp连接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584403805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188629,"user_name":"匿名","can_delete":false,"product_type":"c1","uid":1265774,"ip_address":"","ucode":"BAA596254FE0EB","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/6e/8bd276a5.jpg","comment_is_top":false,"comment_ctime":1584376041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174310633","product_id":100047701,"comment_content":"辛苦！老师","like_count":2},{"had_liked":false,"id":187819,"user_name":"袁素芬","can_delete":false,"product_type":"c1","uid":1856206,"ip_address":"","ucode":"78E3DC78479915","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epSmVn8QDuJVtwibpiaskLecwICcbNfoKbPlQgMhQBRuz67icFd2aibhNdGiaeR4D3wTmVc6yPL8c3HMAw/132","comment_is_top":false,"comment_ctime":1584252942,"is_pvip":false,"replies":[{"id":"72490","content":"<br>：）","user_name":"作者回复","comment_id":187819,"uid":"1001470","ip_address":"","utype":1,"ctime":1584260984,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10174187534","product_id":100047701,"comment_content":"辛苦老师","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487253,"discussion_content":"\n：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584260984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187611,"user_name":"陈天柱","can_delete":false,"product_type":"c1","uid":1696225,"ip_address":"","ucode":"917BFDC845760D","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/e1/441df85d.jpg","comment_is_top":false,"comment_ctime":1584171715,"is_pvip":false,"replies":[{"id":"72409","content":"没错，官方文档里面是这么说的：<br><br>Typically you only create one MongoClient instance for a given MongoDB deployment (e.g. standalone, replica set, or a sharded cluster) and use it across your application. However, if you do create multiple instances:<br>All resource usage limits (e.g. max connections, etc.) apply per MongoClient instance.<br>To dispose of an instance, call MongoClient.close() to clean up resources.<br><br>其实复用不等于在任何情况下就只用一个，HttpClient也是同样的道理","user_name":"作者回复","comment_id":187611,"uid":"1001470","ip_address":"","utype":1,"ctime":1584182913,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10174106307","product_id":100047701,"comment_content":"看了今天老师的连接池文章后，才注意到jedisPool与redisTemplate的区别正是老师提到的连接池client是否内置池的区别，赞一个！针对课后的第二个问题，去查阅了MongoClient的源码，发现MongoClient的父类Mongo内置了ServerSessionPool池，所以MongoClient应该属于老师说的内置池那种实现，因此每次创建MongoClient都必须复用，不知道老师，我的理解对不对？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487164,"discussion_content":"没错，官方文档里面是这么说的：\n\nTypically you only create one MongoClient instance for a given MongoDB deployment (e.g. standalone, replica set, or a sharded cluster) and use it across your application. However, if you do create multiple instances:\nAll resource usage limits (e.g. max connections, etc.) apply per MongoClient instance.\nTo dispose of an instance, call MongoClient.close() to clean up resources.\n\n其实复用不等于在任何情况下就只用一个，HttpClient也是同样的道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584182913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218915,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1589897762,"is_pvip":false,"replies":[{"id":"80878","content":"服务端来说，单线程是服务端处理（IO和执行命令）模型（不过最新的Redis已不是单线程处理IO），单线程确保足够简单避免线程安全问题的同时也能同时处理大量客户端并发，这是两个概念；客户端来说连接池可以复用连接，这肯定是需要的","user_name":"作者回复","comment_id":218915,"uid":"1001470","ip_address":"","utype":1,"ctime":1589898503,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5884865058","product_id":100047701,"comment_content":"老师我想请教一下<br><br>在单机Redis情况下<br><br>既然Redis是**单线程串行处理任务的**，那么客户端再使用Redis线程池是否有必要？<br><br>和全局一个链接的区别在哪里呢？<br><br>","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495623,"discussion_content":"服务端来说，单线程是服务端处理（IO和执行命令）模型（不过最新的Redis已不是单线程处理IO），单线程确保足够简单避免线程安全问题的同时也能同时处理大量客户端并发，这是两个概念；客户端来说连接池可以复用连接，这肯定是需要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589898503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190347,"user_name":"小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1584631173,"is_pvip":false,"replies":[{"id":"73217","content":"你可以看下它源码实现，sqlserver client我不清楚","user_name":"作者回复","comment_id":190347,"uid":"1001470","ip_address":"","utype":1,"ctime":1584664856,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"5879598469","product_id":100047701,"comment_content":"老师，我们用多个线程共用同一个sqlserver数据库连接connection写数据，没发现有问题啊。我们测试了几百万条数据的。是因为sqlserver做了处理吗？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487957,"discussion_content":"你可以看下它源码实现，sqlserver client我不清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584664856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048396,"avatar":"","nickname":"桃子爱西瓜","note":"","ucode":"D6B3404CF0D254","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575751,"discussion_content":"内部连接池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655089270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190297,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1584627661,"is_pvip":true,"replies":[{"id":"73197","content":"对象池抽象API，一般框架内用，用于复用昂贵对象，比如网络连接等","user_name":"作者回复","comment_id":190297,"uid":"1001470","ip_address":"","utype":1,"ctime":1584628814,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"5879594957","product_id":100047701,"comment_content":"老师，我想问一下就是我看apache comons pool中有对象池的概念，一般使用来是做什么的呢？不知道什么业务可以使用，是方便复用一些创建比较长的对象吗？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487941,"discussion_content":"对象池抽象API，一般框架内用，用于复用昂贵对象，比如网络连接等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584628814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209373,"discussion_content":"了解了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584628969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188785,"user_name":"eazonshaw","can_delete":false,"product_type":"c1","uid":1493784,"ip_address":"","ucode":"423952F7CEF475","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/18/4877c08b.jpg","comment_is_top":false,"comment_ctime":1584415671,"is_pvip":false,"replies":[{"id":"72819","content":"wrong2的截图已经替换了，晚上会更新<br><br>right的#75图上看不到，图太长了，不过截图已经可以连接复用了","user_name":"作者回复","comment_id":188785,"uid":"1001470","ip_address":"","utype":1,"ctime":1584418855,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5879382967","product_id":100047701,"comment_content":"老师，感觉文章对网络抓包工具 Wireshark 的截图信息不是很完整，right接口的#75也没有看到，这一块看着有点懵。可以详细说明下调用wrong2和right的区别吗？谢谢。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487523,"discussion_content":"wrong2的截图已经替换了，晚上会更新\n\nright的#75图上看不到，图太长了，不过截图已经可以连接复用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584418855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188643,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1584395005,"is_pvip":false,"replies":[{"id":"72758","content":"3、可以找一下spring boot auto configuration类，看看其自动配置是否符合需求<br>4、这可能还有一个设计问题，理论上微服务应该只能访问自己domain的数据库，给其他微服务提供数据只能以接口提供；当然资源有限的情况下混用数据库实例的话，一般连接数量不会成为明显瓶颈，有瓶颈的话可能要考虑实例拆分了。","user_name":"作者回复","comment_id":188643,"uid":"1001470","ip_address":"","utype":1,"ctime":1584404263,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5879362301","product_id":100047701,"comment_content":"几个疑问:第一个:demo中的&#47;right接口，是不是也算有问题的，仅仅方便对比效果而已，这让请求串行了吧。第二个:http client还有一套连接剔除机制，demo里没讲到。第三个:spring boot客户端工具，默认设置的一些配置，有需要注意的地方吗？第四个:连接数监控，什么情况代表着有问题,有时候一个数据库资源，被多个微服务公用，怎么划分配额。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487474,"discussion_content":"3、可以找一下spring boot auto configuration类，看看其自动配置是否符合需求\n4、这可能还有一个设计问题，理论上微服务应该只能访问自己domain的数据库，给其他微服务提供数据只能以接口提供；当然资源有限的情况下混用数据库实例的话，一般连接数量不会成为明显瓶颈，有瓶颈的话可能要考虑实例拆分了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584404263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188372,"user_name":"LittleFatz","can_delete":false,"product_type":"c1","uid":1052722,"ip_address":"","ucode":"C374FBE3D63FDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/32/9256dc82.jpg","comment_is_top":false,"comment_ctime":1584345784,"is_pvip":false,"replies":[{"id":"72688","content":"你这个问题非常好，看的很仔细。<br>主要还是这个图太长了，我这里不好贴。<br>你提到的35、37和42可能是握手和挥手，最前面有三次握手+更新窗口大小四个TCP，最后面有挥手四个TCP，看到的这些其实还是一个请求的。<br>你可以使用wireshark来调试一下wrong2接口，看看是不是每次都换了端口。","user_name":"作者回复","comment_id":188372,"uid":"1001470","ip_address":"","utype":1,"ctime":1584349280,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5879313080","product_id":100047701,"comment_content":"请教老师一个问题，在wrong2的wireshark截图里，除了#39使用端口60686外，#37、#35和#42都使用了这个端口，单从截图而言，貌似无法证明每次request都使用了新的端口发送请求。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487390,"discussion_content":"你这个问题非常好，看的很仔细。\n主要还是这个图太长了，我这里不好贴。\n你提到的35、37和42可能是握手和挥手，最前面有三次握手+更新窗口大小四个TCP，最后面有挥手四个TCP，看到的这些其实还是一个请求的。\n你可以使用wireshark来调试一下wrong2接口，看看是不是每次都换了端口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584349280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187564,"user_name":"吴国帅","can_delete":false,"product_type":"c1","uid":1638035,"ip_address":"","ucode":"D2EBC0308CC361","user_header":"https://static001.geekbang.org/account/avatar/00/18/fe/93/8999259d.jpg","comment_is_top":false,"comment_ctime":1584158377,"is_pvip":false,"replies":[{"id":"72452","content":"如有收货，欢迎转发","user_name":"作者回复","comment_id":187564,"uid":"1001470","ip_address":"","utype":1,"ctime":1584241326,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5879125673","product_id":100047701,"comment_content":"哈哈哈 实名推荐 老哥牛逼","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487148,"discussion_content":"如有收货，欢迎转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584241326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187539,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1584154625,"is_pvip":false,"replies":[{"id":"72363","content":"1. 是的，这两个参数需要分清楚功能<br>2. <br><br>Typically you only create one MongoClient instance for a given MongoDB deployment (e.g. standalone, replica set, or a sharded cluster) and use it across your application. However, if you do create multiple instances:<br><br>All resource usage limits (e.g. max connections, etc.) apply per MongoClient instance.<br><br>To dispose of an instance, call MongoClient.close() to clean up resources.","user_name":"作者回复","comment_id":187539,"uid":"1001470","ip_address":"","utype":1,"ctime":1584156900,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"5879121921","product_id":100047701,"comment_content":"对于问题1，第一个参数是客户端与连接池交互的关键参数，这个参数的取值与客户端的需求紧密相关。第二个参数是连接池与服务器交互的关键参数，这个参数的取值应该参考服务器的一般情况。<br><br>对于问题2，应该复用，为什么？因为我踩过坑……短时间内新建大量client撑爆了mongo……","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487138,"discussion_content":"1. 是的，这两个参数需要分清楚功能\n2. \n\nTypically you only create one MongoClient instance for a given MongoDB deployment (e.g. standalone, replica set, or a sharded cluster) and use it across your application. However, if you do create multiple instances:\n\nAll resource usage limits (e.g. max connections, etc.) apply per MongoClient instance.\n\nTo dispose of an instance, call MongoClient.close() to clean up resources.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584156900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206698,"discussion_content":"不需要，HikariDataSource是一个Bean，Spring会确保程序退出的时候调用close方法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584430475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438330,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmEzU09AJVlKcHx9DgsJEocic7F6VicfyP0VicS8v7S2cQTeiaGd1x3cpbJGHMJXibILiboSVTNiaM3P81Q/132","nickname":"老乔","note":"","ucode":"7C99C643979831","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206542,"discussion_content":"老师，hikari连接池，怎么保证在这个微服务(spring boot)关闭时，这个连接池也正常(优雅)释放(服务端连接)？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584413354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352063,"user_name":"dudu-benny","can_delete":false,"product_type":"c1","uid":1683951,"ip_address":"","ucode":"026ECAC9AFDE0D","user_header":"https://static001.geekbang.org/account/avatar/00/19/b1/ef/2356b51e.jpg","comment_is_top":false,"comment_ctime":1658371252,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658371252","product_id":100047701,"comment_content":"A MongoDB client with internal connection pooling. For most applications, you should have one MongoClient instance for the entire JVM.<br><br>The following are equivalent, and all connect to the local database running on the default port:<br><br> MongoClient mongoClient1 = new MongoClient();<br> MongoClient mongoClient1 = new MongoClient(&quot;localhost&quot;);<br> MongoClient mongoClient2 = new MongoClient(&quot;localhost&quot;, 27017);<br> MongoClient mongoClient4 = new MongoClient(new ServerAddress(&quot;localhost&quot;));<br> MongoClient mongoClient5 = new MongoClient(new ServerAddress(&quot;localhost&quot;), MongoClientOptions.builder().build());<br> 可以看出mongoClient利用的是池化技术进行操作，再重MongoClientOptions的参数也可以发现getConnectTimeout(),getHeartbeatConnectTimeout()等参数推测 MongoClient 类应该是每次复用链接的","like_count":0},{"had_liked":false,"id":325465,"user_name":"梅子黄时雨","can_delete":false,"product_type":"c1","uid":1015938,"ip_address":"","ucode":"9F788D09C2E9E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/82/3c21b30c.jpg","comment_is_top":false,"comment_ctime":1638965720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638965720","product_id":100047701,"comment_content":"在使用第三方提供的sdk 时要确认下是否用了连接池。","like_count":0},{"had_liked":false,"id":312819,"user_name":"余明宸","can_delete":false,"product_type":"c1","uid":2023637,"ip_address":"","ucode":"C337279B7F6473","user_header":"","comment_is_top":false,"comment_ctime":1632039631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632039631","product_id":100047701,"comment_content":"The MongoClient instance represents a pool of connections to the database; you will only need one instance of class MongoClient even with multiple threads.<br><br>官方文档给出的最佳实践是，MongoClient是一个连接池，只需要单例即可。","like_count":0},{"had_liked":false,"id":296190,"user_name":"silas","can_delete":false,"product_type":"c1","uid":1553046,"ip_address":"","ucode":"EEFF1E8ED00EE6","user_header":"https://static001.geekbang.org/account/avatar/00/17/b2/96/a524ebf6.jpg","comment_is_top":false,"comment_ctime":1622798172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622798172","product_id":100047701,"comment_content":"买了很多课，老师的课真的是物超所值。迟来的评论。。","like_count":0},{"had_liked":false,"id":268561,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1608257991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608257991","product_id":100047701,"comment_content":"这篇文章学起来有点艰难，跟生产实际结合得很近，属于大多数人都会用到，但是也只是用用，不出问题还好，除了问题又束手无策，之前也很少看到哪本书或者课程上有专门讲这部分的，了解了两个实用的监测工具。这篇课程和留言都值得反复看几遍好好揣摩","like_count":0},{"had_liked":false,"id":262146,"user_name":"MindController","can_delete":false,"product_type":"c1","uid":1159113,"ip_address":"","ucode":"3B9CECCD12CF6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/c9/d9c72c60.jpg","comment_is_top":false,"comment_ctime":1605622433,"is_pvip":false,"replies":[{"id":"95135","content":"没事","user_name":"作者回复","comment_id":262146,"uid":"1001470","ip_address":"","utype":1,"ctime":1605665642,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1605622433","product_id":100047701,"comment_content":"干货实在太多，谢谢老师","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509704,"discussion_content":"没事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605665642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250610,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1601170921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601170921","product_id":100047701,"comment_content":"对于数据库连接池是有自动验验证pool中连接是否可用的机制，但是httpclient的连接池却没有，比如常见的connect reset by peer异常，目前我是通过catch异常重试来实现，不知道老师有没有好方法","like_count":0},{"had_liked":false,"id":248842,"user_name":"Sruby","can_delete":false,"product_type":"c1","uid":1016232,"ip_address":"","ucode":"A7D1B93F41DA0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","comment_is_top":false,"comment_ctime":1600331782,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1600331782","product_id":100047701,"comment_content":"复用方式很简单，你可以把 CloseableHttpClient 声明为 static，只创建一次，并且在 JVM 关闭之前通过 addShutdownHook 钩子关闭连接池，在使用的时候直接使用 CloseableHttpClient 即可，无需每次都创建。<br>--------------------------<br>CloseableHttpClient实现了Closeable，在jvm退出的时候会自动销毁连接吧。","like_count":0,"discussions":[{"author":{"id":1016232,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/81/a8/559afe8b.jpg","nickname":"Sruby","note":"","ucode":"A7D1B93F41DA0F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307479,"discussion_content":"查询了更多资料发现，最佳实践还是通过钩子来销毁，jvm正常退出才会处理closeable的资源，异常退出则不会。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600664342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245841,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1599092596,"is_pvip":false,"replies":[{"id":"90406","content":"如果在shutdownhook里优雅关闭线程池，显然更好，但是需要设置超时","user_name":"作者回复","comment_id":245841,"uid":"1001470","ip_address":"","utype":1,"ctime":1599104860,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"1599092596","product_id":100047701,"comment_content":"老师，使用jdk的线程池，需要给jdk的线程池注册一个钩子函数以用于优雅退出吗？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504991,"discussion_content":"如果在shutdownhook里优雅关闭线程池，显然更好，但是需要设置超时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599104860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242182,"user_name":"小钳子","can_delete":false,"product_type":"c1","uid":1651085,"ip_address":"","ucode":"E60214AB3E7E99","user_header":"https://static001.geekbang.org/account/avatar/00/19/31/8d/d6367617.jpg","comment_is_top":false,"comment_ctime":1597631026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597631026","product_id":100047701,"comment_content":"springboot2.0.9。启动显示使用的hikari。但是按老师的方法添加hikari到jmx后没有看到hikari。反而看到了druid。请问这是啥情况","like_count":0},{"had_liked":false,"id":231251,"user_name":"DZZ","can_delete":false,"product_type":"c1","uid":1516167,"ip_address":"","ucode":"C8E4C4B089BCE2","user_header":"https://static001.geekbang.org/account/avatar/00/17/22/87/e7bd2acf.jpg","comment_is_top":false,"comment_ctime":1593614798,"is_pvip":true,"replies":[{"id":"85413","content":"我没有深究过，但我并不认为会，即使闲置链接不释放，也不会无限增加更多闲置链接引起内存问题，链接总数是连接池控制的","user_name":"作者回复","comment_id":231251,"uid":"1001470","ip_address":"","utype":1,"ctime":1593654756,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1593614798","product_id":100047701,"comment_content":"Mongoclient在使用的时候，如果没有设置MaxConnectionIdleTime，默认是0。会导致连接一直不释放资源，造成应用内存使用上升进而触发g c的时候才释放。是否应该适当配置这个参数用于在不关闭mongoclient的情况下是否连接资源？或者有没有单独的释放连接池内线程的方法？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500217,"discussion_content":"我没有深究过，但我并不认为会，即使闲置链接不释放，也不会无限增加更多闲置链接引起内存问题，链接总数是连接池控制的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593654756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220628,"user_name":"春暖花开","can_delete":false,"product_type":"c1","uid":1215253,"ip_address":"","ucode":"8B7D3BA1C1DD1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/15/5278f52a.jpg","comment_is_top":false,"comment_ctime":1590300021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590300021","product_id":100047701,"comment_content":"老师讲的很实用，点个赞<br>","like_count":0},{"had_liked":false,"id":216639,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1589299935,"is_pvip":false,"replies":[{"id":"80148","content":"手绘","user_name":"作者回复","comment_id":216639,"uid":"1001470","ip_address":"","utype":1,"ctime":1589324519,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1589299935","product_id":100047701,"comment_content":"老师好，jedis的类图是用什么插件生成的吗？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494891,"discussion_content":"手绘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589324519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211035,"user_name":"包包爸爸","can_delete":false,"product_type":"c1","uid":1305227,"ip_address":"","ucode":"EBBB1663B41650","user_header":"https://static001.geekbang.org/account/avatar/00/13/ea/8b/5fe54e19.jpg","comment_is_top":false,"comment_ctime":1587884262,"is_pvip":false,"replies":[{"id":"78496","content":"：）","user_name":"作者回复","comment_id":211035,"uid":"1001470","ip_address":"","utype":1,"ctime":1587887772,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1587884262","product_id":100047701,"comment_content":"哈哈哈，比喻有意思，只是不太可能呀，鱼拿出来用，一般不就是吃了么，放不回去了哈哈哈","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493175,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587887772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205363,"user_name":"梦想注定丶孤独","can_delete":false,"product_type":"c1","uid":1222688,"ip_address":"","ucode":"0E51E368DE53F2","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/20/6798446a.jpg","comment_is_top":false,"comment_ctime":1586598585,"is_pvip":false,"replies":[{"id":"76716","content":"websocket我不熟，websocket是一个协议，肯定有不同的框架不同的实现，还是需要阅读框架的文档和源码来判断","user_name":"作者回复","comment_id":205363,"uid":"1001470","ip_address":"","utype":1,"ctime":1586604713,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"1586598585","product_id":100047701,"comment_content":"老师，websocket有自带连接池吗，如果没有，需要配置连接池吗","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491462,"discussion_content":"websocket我不熟，websocket是一个协议，肯定有不同的框架不同的实现，还是需要阅读框架的文档和源码来判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586604713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203982,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1586315262,"is_pvip":true,"replies":[{"id":"76275","content":"是","user_name":"作者回复","comment_id":203982,"uid":"1001470","ip_address":"","utype":1,"ctime":1586324383,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1586315262","product_id":100047701,"comment_content":"总算有时间来好好学习这门课，因为我所在项目组业务被砍了，目前待分配中，哭泣。<br><br>但是，刚好可以好好学习老师的这门课。这节课讲的虽然是各种连接池，我也使用过这几个连接池，但都是遇到问题采取发现，去采取一定的措施，没有去做更多的思考。<br><br>其实，老师的讲解，我还是那个总结：源码之下无秘密。只要你有心去阅读源码，分析原理，还有什么能难倒你呢。同样的道理，就可以很好地用在课后习题上。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491028,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586324383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203859,"user_name":"Xg huang","can_delete":false,"product_type":"c1","uid":1016995,"ip_address":"","ucode":"9680FA95DE3553","user_header":"","comment_is_top":false,"comment_ctime":1586276392,"is_pvip":false,"replies":[{"id":"76199","content":"可以再仔细看一下文章，如果CloseableHttpClient不是定义为单例声明周期和应用相同，而是每次都new出来使用的话，需要释放","user_name":"作者回复","comment_id":203859,"uid":"1001470","ip_address":"","utype":1,"ctime":1586303076,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"1586276392","product_id":100047701,"comment_content":"请教一下老师和各位同学， wrong1 和 wrong2具体是什么区别？<br><br>wrong1 中这个部分并无放进try 中， 但client 有， 这样应该可以正确回收资源吧？ <br><br>CloseableHttpClient client = HttpClients.custom()<br>                .setConnectionManager(new PoolingHttpClientConnectionManager())<br>                .evictIdleConnections(60, TimeUnit.SECONDS).build();<br><br>","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490983,"discussion_content":"可以再仔细看一下文章，如果CloseableHttpClient不是定义为单例声明周期和应用相同，而是每次都new出来使用的话，需要释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586303076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590689,"discussion_content":"两个错误例子都没有复用连接池，但是第二个用完后释放了，比第一个好点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666006123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201348,"user_name":"Thravus","can_delete":false,"product_type":"c1","uid":1056378,"ip_address":"","ucode":"C22B64FA9AAB55","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIhDXG8oeMaicibpPa6yccXTzGaFvQQhrOLd8knjz50hYEFA01txBFib65VKXh5fzfTFEFddbksQDgFg/132","comment_is_top":false,"comment_ctime":1585754133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585754133","product_id":100047701,"comment_content":"收获颇丰，从原理到应用","like_count":0},{"had_liked":false,"id":200405,"user_name":"梁铁山","can_delete":false,"product_type":"c1","uid":1233214,"ip_address":"","ucode":"36249D99DD8D5D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/3e/77c6ba5e.jpg","comment_is_top":false,"comment_ctime":1585580583,"is_pvip":false,"replies":[{"id":"74994","content":"觉得有用可以分转发分享","user_name":"作者回复","comment_id":200405,"uid":"1001470","ip_address":"","utype":1,"ctime":1585616538,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1585580583","product_id":100047701,"comment_content":"最近刚好要做代码重构，看了本节内容，赶紧去看了下自己以前写的代码，发现了不少问题，感谢感谢！虽然刚看了5节课，但是恨不能立马全部看完，知识点满满的，所以也期待老师能否更新快一点 【笑脸】【抱拳】！！！","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490016,"discussion_content":"觉得有用可以分转发分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585616538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200247,"user_name":"大橘为重","can_delete":false,"product_type":"c1","uid":1106152,"ip_address":"","ucode":"96479F205B8384","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/e8/66439469.jpg","comment_is_top":false,"comment_ctime":1585562455,"is_pvip":true,"replies":[{"id":"74995","content":"加油","user_name":"作者回复","comment_id":200247,"uid":"1001470","ip_address":"","utype":1,"ctime":1585616575,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1585562455","product_id":100047701,"comment_content":"好课程！虽然每次都需要花费很长的时间来阅读理解，但是感悟挺多的，但是离学以致用还是有一段距离，但是至少有个观念，赞","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489971,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585616575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198235,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1585421632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585421632","product_id":100047701,"comment_content":"很喜欢老师分析方式","like_count":0},{"had_liked":false,"id":193789,"user_name":"Farewell丶","can_delete":false,"product_type":"c1","uid":1179565,"ip_address":"","ucode":"A0D69893C5375C","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","comment_is_top":false,"comment_ctime":1584964202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584964202","product_id":100047701,"comment_content":"The MongoClient instance represents a pool of connections to the database; you will only need one instance of class MongoClient even with multiple threads.","like_count":0},{"had_liked":false,"id":188943,"user_name":"嘿，小伙儿","can_delete":false,"product_type":"c1","uid":1905273,"ip_address":"","ucode":"3CA13E580351F1","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/79/ed838d0a.jpg","comment_is_top":false,"comment_ctime":1584437070,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584437070","product_id":100047701,"comment_content":"下载源码后, 运行docker 会在mysql卡住,  等待一下午了,  大家都好用吗?<br><br>$ docker-compose up<br>common-mistakes-redis-3 is up-to-date<br>common-mistakes-rabbitmq is up-to-date<br>Starting es03 ...<br>Starting es03                    ... done<br>Starting es01                    ... done<br>Creating common-mistakes-mysql57 ...<br>","like_count":0,"discussions":[{"author":{"id":1301304,"avatar":"https://static001.geekbang.org/account/avatar/00/13/db/38/7ab139a3.jpg","nickname":"z小俊、Arno","note":"","ucode":"312B3DDCF15102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215246,"discussion_content":"我很顺利亚\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585307043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188241,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1584330397,"is_pvip":false,"replies":[{"id":"72679","content":"是的，要关闭的话也应该在程序shutdown的时候去关闭","user_name":"作者回复","comment_id":188241,"uid":"1001470","ip_address":"","utype":1,"ctime":1584337139,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"1584330397","product_id":100047701,"comment_content":"看了一下mongDB官方文档，应该是第二种类型的，连接池的维护管理都是mongDB自己进行，用户不用手动去关闭，要手动的话也可以调用close()方法","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487361,"discussion_content":"是的，要关闭的话也应该在程序shutdown的时候去关闭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584337139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}