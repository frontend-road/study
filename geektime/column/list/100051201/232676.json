{"id":232676,"title":"04 | 零拷贝：如何高效地传输文件？","content":"<p>你好，我是陶辉。</p><p>上一讲我们谈到，当索引的大小超过内存时，就会用磁盘存放索引。磁盘的读写速度远慢于内存，所以才针对磁盘设计了减少读写次数的B树索引。</p><p><strong>磁盘是主机中最慢的硬件之一，常常是性能瓶颈，所以优化它能获得立竿见影的效果。</strong></p><p>因此，针对磁盘的优化技术层出不穷，比如零拷贝、直接IO、异步IO等等。这些优化技术为了降低操作时延、提升系统的吞吐量，围绕着内核中的磁盘高速缓存（也叫PageCache），去减少CPU和磁盘设备的工作量。</p><p>这些磁盘优化技术和策略虽然很有效，但是理解它们并不容易。只有搞懂内核操作磁盘的流程，灵活正确地使用，才能有效地优化磁盘性能。</p><p>这一讲，我们就通过解决“如何高效地传输文件”这个问题，来分析下磁盘是如何工作的，并且通过优化传输文件的性能，带你学习现在热门的零拷贝、异步IO与直接IO这些磁盘优化技术。</p><h2>你会如何实现文件传输？</h2><p>服务器提供文件传输功能，需要将磁盘上的文件读取出来，通过网络协议发送到客户端。如果需要你自己编码实现这个文件传输功能，你会怎么实现呢？</p><p>通常，你会选择最直接的方法：从网络请求中找出文件在磁盘中的路径后，如果这个文件比较大，假设有320MB，可以在内存中分配32KB的缓冲区，再把文件分成一万份，每份只有32KB，这样，从文件的起始位置读入32KB到缓冲区，再通过网络API把这32KB发送到客户端。接着重复一万次，直到把完整的文件都发送完毕。如下图所示：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/65/ee/6593f66902b337ec666551fe2c6f5bee.jpg?wh=3509*1970\" alt=\"\"></p><p>不过这个方案性能并不好，主要有两个原因。</p><p>首先，它至少<strong>经历了4万次用户态与内核态的上下文切换。</strong>因为每处理32KB的消息，就需要一次read调用和一次write调用，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。可见，每处理32KB，就有4次上下文切换，重复1万次后就有4万次切换。</p><p>上下文切换的成本并不小，虽然一次切换仅消耗几十纳秒到几微秒，但高并发服务会放大这类时间的消耗。</p><p>其次，这个方案做了<strong>4万次内存拷贝，对320MB文件拷贝的字节数也翻了4倍，到了1280MB。</strong>很显然，过多的内存拷贝无谓地消耗了CPU资源，降低了系统的并发处理能力。</p><p>所以要想提升传输文件的性能，需要从<strong>降低上下文切换的频率和内存拷贝次数</strong>两个方向入手。</p><h2>零拷贝如何提升文件传输性能？</h2><p>首先，我们来看如何降低上下文切换的频率。</p><p>为什么读取磁盘文件时，一定要做上下文切换呢？这是因为，读取磁盘或者操作网卡都由操作系统内核完成。内核负责管理系统上的所有进程，它的权限最高，工作环境与用户进程完全不同。只要我们的代码执行read或者write这样的系统调用，一定会发生2次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p><p>因此，如果想减少上下文切换次数，就一定要减少系统调用的次数。解决方案就是把read、write两次系统调用合并成一次，在内核中完成磁盘与网卡的数据交换。</p><p>其次，我们应该考虑如何减少内存拷贝次数。</p><p>每周期中的4次内存拷贝，其中与物理设备相关的2次拷贝是必不可少的，包括：把磁盘内容拷贝到内存，以及把内存拷贝到网卡。但另外2次与用户缓冲区相关的拷贝动作都不是必需的，因为在把磁盘文件发到网络的场景中，<strong>用户缓冲区没有必须存在的理由</strong>。</p><p>如果内核在读取文件后，直接把PageCache中的内容拷贝到Socket缓冲区，待到网卡发送完毕后，再通知进程，这样就只有2次上下文切换，和3次内存拷贝。</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/a1/bf80b6f858d5cb49f600a28f853e89a1.jpg?wh=3517*1995\" alt=\"\"></p><p>如果网卡支持SG-DMA（The Scatter-Gather Direct Memory Access）技术，还可以再去除Socket缓冲区的拷贝，这样一共只有2次内存拷贝。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/77/0afb2003d8aebaee763d22dda691ca77.jpg?wh=3514*1959\" alt=\"\"></p><p><strong>实际上，这就是零拷贝技术。</strong></p><p>它是操作系统提供的新函数，同时接收文件描述符和TCP socket作为输入参数，这样执行时就可以完全在内核态完成内存拷贝，既减少了内存拷贝次数，也降低了上下文切换次数。</p><p>而且，零拷贝取消了用户缓冲区后，不只降低了用户内存的消耗，还通过最大化利用socket缓冲区中的内存，间接地再一次减少了系统调用的次数，从而带来了大幅减少上下文切换次数的机会！</p><p>你可以回忆下，没用零拷贝时，为了传输320MB的文件，在用户缓冲区分配了32KB的内存，把文件分成1万份传送，然而，<strong>这32KB是怎么来的？</strong>为什么不是32MB或者32字节呢？这是因为，在没有零拷贝的情况下，我们希望内存的利用率最高。如果用户缓冲区过大，它就无法一次性把消息全拷贝给socket缓冲区；如果用户缓冲区过小，则会导致过多的read/write系统调用。</p><p>那用户缓冲区为什么不与socket缓冲区大小一致呢？这是因为，<strong>socket缓冲区的可用空间是动态变化的</strong>，它既用于TCP滑动窗口，也用于应用缓冲区，还受到整个系统内存的影响（我在《Web协议详解与抓包实战》第5部分课程对此有详细介绍，这里不再赘述）。尤其在长肥网络中，它的变化范围特别大。</p><p><strong>零拷贝使我们不必关心socket缓冲区的大小。</strong>比如，调用零拷贝发送方法时，尽可以把发送字节数设为文件的所有未发送字节数，例如320MB，也许此时socket缓冲区大小为1.4MB，那么一次性就会发送1.4MB到客户端，而不是只有32KB。这意味着对于1.4MB的1次零拷贝，仅带来2次上下文切换，而不使用零拷贝且用户缓冲区为32KB时，经历了176次（4 * 1.4MB/32KB）上下文切换。</p><p>综合上述各种优点，<strong>零拷贝可以把性能提升至少一倍以上！</strong>对文章开头提到的320MB文件的传输，当socket缓冲区在1.4MB左右时，只需要4百多次上下文切换，以及4百多次内存拷贝，拷贝的数据量也仅有640MB，这样，不只请求时延会降低，处理每个请求消耗的CPU资源也会更少，从而支持更多的并发请求。</p><p>此外，零拷贝还使用了PageCache技术，通过它，零拷贝可以进一步提升性能，我们接下来看看PageCache是如何做到这一点的。</p><h2>PageCache，磁盘高速缓存</h2><p>回顾上文中的几张图，你会发现，读取文件时，是先把磁盘文件拷贝到PageCache上，再拷贝到进程中。为什么这样做呢？有两个原因所致。</p><p>第一，由于磁盘比内存的速度慢许多，所以我们应该想办法把读写磁盘替换成读写内存，比如把磁盘中的数据复制到内存中，就可以用读内存替换读磁盘。但是，内存空间远比磁盘要小，内存中注定只能复制一小部分磁盘中的数据。</p><p>选择哪些数据复制到内存呢？通常，刚被访问的数据在短时间内再次被访问的概率很高（这也叫“时间局部性”原理），用PageCache缓存最近访问的数据，当空间不足时淘汰最久未被访问的缓存（即LRU算法）。读磁盘时优先到PageCache中找一找，如果数据存在便直接返回，这便大大提升了读磁盘的性能。</p><p>第二，读取磁盘数据时，需要先找到数据所在的位置，对于机械磁盘来说，就是旋转磁头到数据所在的扇区，再开始顺序读取数据。其中，旋转磁头耗时很长，为了降低它的影响，PageCache使用了<strong>预读功能</strong>。</p><p>也就是说，虽然read方法只读取了0-32KB的字节，但内核会把其后的32-64KB也读取到PageCache，这后32KB读取的成本很低。如果在32-64KB淘汰出PageCache前，进程读取到它了，收益就非常大。这一讲的传输文件场景中这是必然发生的。</p><p>从这两点可以看到PageCache的优点，它在90%以上场景下都会提升磁盘性能，<strong>但在某些情况下，PageCache会不起作用，甚至由于多做了一次内存拷贝，造成性能的降低。</strong>在这些场景中，使用了PageCache的零拷贝也会损失性能。</p><p>具体是什么场景呢？就是在传输大文件的时候。比如，你有很多GB级的文件需要传输，每当用户访问这些大文件时，内核就会把它们载入到PageCache中，这些大文件很快会把有限的PageCache占满。</p><p>然而，由于文件太大，文件中某一部分内容被再次访问到的概率其实非常低。这带来了2个问题：首先，由于PageCache长期被大文件占据，热点小文件就无法充分使用PageCache，它们读起来变慢了；其次，PageCache中的大文件没有享受到缓存的好处，但却耗费CPU（或者DMA）多拷贝到PageCache一次。</p><p>所以，高并发场景下，为了防止PageCache被大文件占满后不再对小文件产生作用，<strong>大文件不应使用PageCache，进而也不应使用零拷贝技术处理。</strong></p><h2>异步IO + 直接IO</h2><p>高并发场景处理大文件时，应当使用异步IO和直接IO来替换零拷贝技术。</p><p>仍然回到本讲开头的例子，当调用read方法读取文件时，实际上read方法会在磁盘寻址过程中阻塞等待，导致进程无法并发地处理其他任务，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/4e/9ef6fcb7da58a007f8f4e3e67442df4e.jpg?wh=3933*2550\" alt=\"\"></p><p>异步IO（异步IO既可以处理网络IO，也可以处理磁盘IO，这里我们只关注磁盘IO）可以解决阻塞问题。它把读操作分为两部分，前半部分向内核发起读请求，但<strong>不等待数据就位就立刻返回</strong>，此时进程可以并发地处理其他任务。当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的通知，再去处理数据，这是异步IO的后半部分。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/15/f3/15d33cf599d11b3188253912b21e4ef3.jpg?wh=4040*2172\" alt=\"\"></p><p>从图中可以看到，异步IO并没有拷贝到PageCache中，这其实是异步IO实现上的缺陷。经过PageCache的IO我们称为缓存IO，它与虚拟内存系统耦合太紧，导致异步IO从诞生起到现在都不支持缓存IO。</p><p>绕过PageCache的IO是个新物种，我们把它称为直接IO。对于磁盘，异步IO只支持直接IO。</p><p>直接IO的应用场景并不多，主要有两种：第一，应用程序已经实现了磁盘文件的缓存，不需要PageCache再次缓存，引发额外的性能消耗。比如MySQL等数据库就使用直接IO；第二，高并发下传输大文件，我们上文提到过，大文件难以命中PageCache缓存，又带来额外的内存拷贝，同时还挤占了小文件使用PageCache时需要的内存，因此，这时应该使用直接IO。</p><p>当然，直接IO也有一定的缺点。除了缓存外，内核（IO调度算法）会试图缓存尽量多的连续IO在PageCache中，最后<strong>合并</strong>成一个更大的IO再发给磁盘，这样可以减少磁盘的寻址操作；另外，内核也会<strong>预读</strong>后续的IO放在PageCache中，减少磁盘操作。直接IO绕过了PageCache，所以无法享受这些性能提升。</p><p>有了直接IO后，异步IO就可以无阻塞地读取文件了。现在，大文件由异步IO和直接IO处理，小文件则交由零拷贝处理，至于判断文件大小的阈值可以灵活配置（参见Nginx的directio指令）。</p><h2>小结</h2><p>基于用户缓冲区传输文件时，过多的内存拷贝与上下文切换次数会降低性能。零拷贝技术在内核中完成内存拷贝，天然降低了内存拷贝次数。它通过一次系统调用合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。尤其是，由于拷贝在内核中完成，它可以最大化使用socket缓冲区的可用空间，从而提高了一次系统调用中处理的数据量，进一步降低了上下文切换次数。</p><p>零拷贝技术基于PageCache，而PageCache缓存了最近访问过的数据，提升了访问缓存数据的性能，同时，为了解决机械磁盘寻址慢的问题，它还协助IO调度算法实现了IO合并与预读（这也是顺序读比随机读性能好的原因），这进一步提升了零拷贝的性能。几乎所有操作系统都支持零拷贝，如果应用场景就是把文件发送到网络中，那么我们应当选择使用了零拷贝的解决方案。</p><p>不过，零拷贝有一个缺点，就是不允许进程对文件内容作一些加工再发送，比如数据压缩后再发送。另外，当PageCache引发负作用时，也不能使用零拷贝，此时可以用异步IO+直接IO替换。我们通常会设定一个文件大小阈值，针对大文件使用异步IO和直接IO，而对小文件使用零拷贝。</p><p>事实上PageCache对写操作也有很大的性能提升，因为write方法在写入内存中的PageCache后就会返回，速度非常快，由内核负责异步地把PageCache刷新到磁盘中，这里不再展开。</p><p>这一讲我们从零拷贝出发，看到了文件传输场景中内核在幕后所做的工作。这里面的性能优化技术，要么减少了磁盘的工作量（比如PageCache缓存），要么减少了CPU的工作量（比如直接IO），要么提高了内存的利用率（比如零拷贝）。你在学习其他磁盘IO优化技术时，可以延着这三个优化方向前进，看看究竟如何降低时延、提高并发能力。</p><h2>思考题</h2><p>最后，留给你一个思考题，异步IO一定不会阻塞进程吗？如果阻塞了进程，该如何解决呢？欢迎你在留言区与大家一起探讨。</p><p>感谢阅读，如果你觉得这节课对你有一些启发，也欢迎把它分享给你的朋友。</p>","comments":[{"had_liked":false,"id":214404,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1588741157,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"186272334885","product_id":100051201,"comment_content":"我觉得有两种情况：<br>1、如果这里的异步IO指的是传统的异步阻塞IO，比如select，epoll等。这种情况下是可能阻塞进程的，在内核通知用户进程数据准备好了以后，用户进程发起read调用，此时内核拷贝数据期间，进程实际上是阻塞的。<br>解决方案：可以在内核完成拷贝后再通知用户进程，或者使用mmap方式，用户态和内核实际上是同一块内存就不存在拷贝了。<br>2、如果这里的异步IO指的是Linux内核2.6版本之后的AIO，那么不太可能阻塞进程，除非系统内核之后一直调度不到该进程（比如其他任务不断的抢占式或绑定内核运行）。<br>解决方案：可以使用绑定内核的运行机制阻值其他高优先级进程或中断进行抢占。<br>只能想到这么多了，希望看看其他大佬的答案。","like_count":43,"discussions":[{"author":{"id":1517814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/28/f6/7fa61d68.jpg","nickname":"郭郭","note":"","ucode":"E358C980AB9555","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259593,"discussion_content":"IO大致可以分为四种，分别为同步阻塞、同步非阻塞、异步阻塞、异步非阻塞。在同步阻塞模式中，应用程序调用系统调用而阻塞，直到系统调用完成才会返回。同步非阻塞模式是，譬如设置read为非阻塞模式，这种调用缺点就是可能不会立马能读到数据，需要不断重复读取。异步阻塞模式，阻塞通知模式达到异步IO的目的，主要使用select系统调用来判断io描述符是否活跃。最后一种AIO，可以说是真正达到异步模式，和Windows下IOCP差不多。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588781776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1517814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/28/f6/7fa61d68.jpg","nickname":"郭郭","note":"","ucode":"E358C980AB9555","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259656,"discussion_content":"你总结的很到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588809566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259593,"ip_address":""},"score":259656,"extra":""},{"author":{"id":1041744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/50/29af37cf.jpg","nickname":"Fff","note":"","ucode":"2D1E13AF02449C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1517814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/28/f6/7fa61d68.jpg","nickname":"郭郭","note":"","ucode":"E358C980AB9555","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263378,"discussion_content":"Select这些叫IO多路复用，本质也是同步的模式，不存在异步阻塞这种说法吧…","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1589203913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259593,"ip_address":""},"score":263378,"extra":""},{"author":{"id":1062222,"avatar":"https://static001.geekbang.org/account/avatar/00/10/35/4e/d4f70f29.jpg","nickname":"fengbeihong","note":"","ucode":"E18892C9D471A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1041744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/50/29af37cf.jpg","nickname":"Fff","note":"","ucode":"2D1E13AF02449C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267265,"discussion_content":"多路复用的概念不和读写IO混在一起吧，多路复用的epoll一般和同步非阻塞IO一起使用，就是个事件通知，事件到了再来由IO方法操作","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589622394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263378,"ip_address":""},"score":267265,"extra":""}]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282992,"discussion_content":"同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O这5种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592140048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214835,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1588828151,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"104668043255","product_id":100051201,"comment_content":"今日得到<br>服务器提供文件传输功能，首先从磁盘读取文件，然后通过网络协议发送给客户端。最直接的办法是根据客户端的请求从磁盘上找到文件位置，然后从磁盘把部分文件（一般文件比较大时，需要对文件进行切分）读入到缓冲区，然后再通过网络把数据发送给客户端。<br>方法的不足<br>1.上下文切换<br>该方案在一次收发过程中涉及到 4 次用户态和内核态的上下文切换，没处理缓冲区大小的数据需要一次 read 调用和一次 write 调用，每次调用都需要从用户态切换到内核态，然后等内核态完成任务后，再切回用户态。因为文件比较大，读取次数比较多，所以上下文切换的成本不容小觑<br><br>2.多次内存拷贝<br>磁盘 -&gt; PageCache<br>PageCache -&gt; 用户缓冲区<br>用户缓冲区 -&gt; Socket 缓冲区<br>Socket 缓冲区 -&gt; 网卡<br>因为涉及到多次内存拷贝，消耗过多的 CPU 资源，降低系统并发处理能力<br>想要优化传输文件的性能，需要从降低上下文切换的频率和内存拷贝次数入手<br><br>零拷贝<br>降低上下文切换频率<br>读取磁盘文件的上下文切换是一定会做的，因为读取磁盘和操作网卡都是由操作系统内核完成。所以我们在执行 read 或 write 这种系统调用时，一定会经过 2 次上下文切换：先从用户态切换到内核态，当内核态任务完成后，再切换回用户态交由进程代码执行<br>所以，要想降低上下文切换频率的要点就是减少系统调用的次数。解决办法是把 read 和 write 两次系统调用合并为一次（可以通过 sendfile 一次系统调用完成），在内核态中完成磁盘与网卡的数据交换操作<br><br>减少内存拷贝次数<br>一次收发过程中有两次与物理设备相关的内存拷贝是必不可少的：把磁盘的数据拷贝到内存；把内存的数据拷贝到网卡。而与用户缓冲区相关的内存拷贝不是必须的<br><br>综上所述，可以在内核读取文件后，直接把 PageCache 中的数据拷贝到 socket 缓冲区中，这样就只有 2 次上下文切换 和 3 次内存拷贝。如果网卡支持 SG-DMA 技术，还可以把拷贝到 socket 缓冲区的步骤给省略掉<br><br>PageCache 磁盘高速缓存<br>根据时间局部性原理（刚被访问到的数据在短时间被再次访问的概率高），通常将最近访问的数据放到 PageCache 中，当空间不足时通过 LRU 算法或变种算法淘汰最久未被访问的数据<br>PageCache 还提供预读功能<br><br>但 PageChache 不适应传输大文件的场景，大文件容易把 PageCache 占满，而且由于文件太大，文件中某一个部分被再次访问的概率低。这样会导致大文件在 PageCache 中没有享受到缓存的优势，同时也因为 PageCache 被大文件占据，影响其他热点小文件的缓存<br><br>异步 IO 可以把读操作分为两部分，前半部分向内核发起读请求，但不用等待数据就位就返回，然后可以继续处理其他任务。当内核把磁盘中的数据拷贝到进程缓冲区后，会通知进程去处理数据。异步 IO 是不会阻塞用户进程的<br>对于磁盘，异步 IO 只支持直接 IO<br><br>直接 IO<br>直接 IO 是应用程序绕过 PageCache，即不经过内核缓冲区，直接访问磁盘中的数据，从而减少了内核缓存与用户程序之间的数据拷贝<br>应用场景<br>1.应用程序已经自己实现了磁盘文件的缓存，不需要 PageCache 再次进行缓存，引发额外的性能消耗<br>2.高并发下传输大文件，因为大文件难以命中 PageCache 缓存，又会影响其他热点小文件的缓存<br><br>直接 IO 的不足<br>因为直接 IO 不适用 PageCache 缓存，所以享受不到内核针对 PageCache 做的一些优化，比如内核会试图缓存更多的连续 IO 在 PageCache 中，然后合并成一个更大的 IO 后发给磁盘，可以减少磁盘的寻址操作；另外，内核还会进行数据的预读，把数据缓存到 PageCache 中，较少磁盘操作<br><br>方法论<br>1.大文件交给异步 IO 和直接 IO 处理，小文件交给零拷贝处理<br>文件传输的性能优化思路<br>1.减少磁盘的工作量（PageCache 技术）<br>2.提高内存的利用率（零拷贝）<br>3.较少 CPU 的工作量（直接 IO）<br><br>案例<br>Kafka 的高性能的原因就包括使用了零拷贝技术和 PageCache 缓存","like_count":24,"discussions":[{"author":{"id":2045574,"avatar":"","nickname":"Geek_5db703","note":"","ucode":"C3439EA5B919C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285613,"discussion_content":"但是kafka 传输大文件啊。。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592894406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215871,"user_name":"上校","can_delete":false,"product_type":"c1","uid":1069548,"ip_address":"","ucode":"DEE1CEE9E4C680","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/ec/3d51d5e6.jpg","comment_is_top":false,"comment_ctime":1589122728,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"96078403240","product_id":100051201,"comment_content":"陶辉老师，你好，可不可以对应的知识点给些代码的参考呢？开源项目哪里用到了？或者github有对应的实现？","like_count":22,"discussions":[{"author":{"id":1116630,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","nickname":"码农Kevin亮","note":"","ucode":"D34562461CA0A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342656,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610766686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039544,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/b8/31c7e110.jpg","nickname":"LVM_23","note":"","ucode":"5E54F9DB582E9F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311711,"discussion_content":"太对了，光是看完。 只是知道有这个知识点存在，但是怎么运用起来，挠头了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602470347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897395,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","nickname":"一凡","note":"","ucode":"5E9BE33452AF3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292475,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595239398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232067,"user_name":"luo_byby","can_delete":false,"product_type":"c1","uid":2052546,"ip_address":"","ucode":"D8D906B2CEBFB8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/51/c2/30ab2473.jpg","comment_is_top":false,"comment_ctime":1593848430,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40248554094","product_id":100051201,"comment_content":"linux上的跳过PageCache的方式有：<br>1. mmap<br>2. open(&quot;&quot;, O_DIRECT)","like_count":9,"discussions":[{"author":{"id":2350246,"avatar":"https://static001.geekbang.org/account/avatar/00/23/dc/a6/6c2728b9.jpg","nickname":"乔克叔叔","note":"","ucode":"31F524DC1E1498","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572192,"discussion_content":"哥 mmap就是pagecache","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652630226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214402,"user_name":"Bitstream","can_delete":false,"product_type":"c1","uid":1434089,"ip_address":"","ucode":"51FB631A70B52C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/e9/29b62c57.jpg","comment_is_top":false,"comment_ctime":1588740132,"is_pvip":false,"replies":[{"id":"79393","content":"你好Bitstream，谢谢你的反馈，我会继续按照这个思路写后续的几讲","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588760702,"ip_address":"","comment_id":214402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35948478500","product_id":100051201,"comment_content":"到现在一共更了5讲，除了开篇，每讲都是干货。不是因为不知道老师讲的知识点，而是您讲的很系统，以场景带理论，学习起来很高效。","like_count":8,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494044,"discussion_content":"你好Bitstream，谢谢你的反馈，我会继续按照这个思路写后续的几讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588760702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215118,"user_name":"Ken","can_delete":false,"product_type":"c1","uid":1120761,"ip_address":"","ucode":"9F829156E855C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/f9/62ae32d7.jpg","comment_is_top":false,"comment_ctime":1588907908,"is_pvip":false,"replies":[{"id":"90983","content":"谢谢ken的分享","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817694,"ip_address":"","comment_id":215118,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31653678980","product_id":100051201,"comment_content":"长肥网络定义<br><br>一个具有大带宽时延乘积的网络也被称之为长胖网络（long fat network，简写为LFN，经常发音为“elephen”）。根据RFC 1072中的定义，如果一个网络的带宽时延乘积显著大于105比特（12500字节），该网络被认为是长肥网络。","like_count":7,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494321,"discussion_content":"谢谢ken的分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216802,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1202243,"ip_address":"","ucode":"AE0634E9585A98","user_header":"https://static001.geekbang.org/account/avatar/00/12/58/43/1a2c9328.jpg","comment_is_top":false,"comment_ctime":1589346023,"is_pvip":false,"replies":[{"id":"80258","content":"对的！其实，当下的操作系统对SSD磁盘的支持还不够，当SSD广泛应用时，文件系统还需要跟上，还得获得很大的性能提升","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589416400,"ip_address":"","comment_id":216802,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27359149799","product_id":100051201,"comment_content":"第二，读取磁盘数据时，需要先找到数据所在的位置，对于机械磁盘来说，就是旋转磁头到数据所在的扇区，再开始顺序读取数据。其中，旋转磁头耗时很长，为了降低它的影响，PageCache 使用了预读功能<br>那是不是使用SSD这类固态硬盘（不用旋转磁头），PageCache就没有很大的影响？","like_count":6,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494950,"discussion_content":"对的！其实，当下的操作系统对SSD磁盘的支持还不够，当SSD广泛应用时，文件系统还需要跟上，还得获得很大的性能提升","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589416400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179184,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/30/c9b568c3.jpg","nickname":"NullPointer","note":"","ucode":"83B7DA926A0411","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288518,"discussion_content":"我也在想SSD这种情况应该预读的效果不明显","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593769640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226556,"user_name":"benny","can_delete":false,"product_type":"c1","uid":1123043,"ip_address":"","ucode":"E2F30AF0C808D9","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","comment_is_top":false,"comment_ctime":1592140262,"is_pvip":false,"replies":[{"id":"90790","content":"应用场景不一样，直接IO更底层点，mmap还需要保证内存与磁盘的数据一致性。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599642255,"ip_address":"","comment_id":226556,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18772009446","product_id":100051201,"comment_content":"mmap的系统调用，可以直接将磁盘和内存映射，省去了从内核态copy到用户态，看起来要比直接IO更加高效","like_count":4,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498284,"discussion_content":"应用场景不一样，直接IO更底层点，mmap还需要保证内存与磁盘的数据一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599642255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033578,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","nickname":"白不吃","note":"","ucode":"F019914D8819C2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545255,"discussion_content":"您不提，我还以为直接IO就是mmap内存映射...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641888476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214800,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1588821876,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18768691060","product_id":100051201,"comment_content":"疑惑点<br>1.在介绍零拷贝时，降低上下文切换频率提到的将 read 和 write 两次系统调用合并为一次是通过 sendfile 实现吗？<br>2.异步 IO 没有使用 PageCache，因为与虚拟内存系统耦合太紧，这块没有看明白<br><br>思考题<br>异步 IO 一定不会阻塞进程吗？如果阻塞了进程，该如何解决？<br>这个问题我觉得要看怎么定义异步 IO<br>Posix 对异步 IO 的定义为：异步 IO 操作不引起请求进程阻塞。老师在文中对异步 IO 的定义也类似，当内核把磁盘中的数据拷贝到进程缓冲区后，会通知进程去处理数据，所以按照这样的定义，异步 IO 不会阻塞进程<br><br>《UNIX网络编程》这本书把 IO 模型分成了5类<br>1.阻塞 IO<br>2.非阻塞 IO<br>3.IO 复用（select 和 poll）<br>4.信号驱动<br>5.异步 IO（Posix.1 的 aio 系统函数）<br><br>一篇介绍IO模型的文章<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;RiWEVd9IvG0Vlbz6Swn5bg<br><br>如果把信号驱动的 IO 模型也看成异步 IO，因为用户进程在调用 sigaction 后，会继续执行其他任务，这里是非阻塞的，内核会在数据准备好时通知用户进程，然后由用户进程发起 recvfrom 的系统调用，把数据从内核缓冲区拷贝到用户空间，此时用户进程是阻塞的<br><br>所以还是看如何定义异步 IO，至于那些伪异步 IO，怎么解决，我觉得解决办法就一个，就是等内核把数据准备好后，自己把数据从内核缓冲区复制到用户空间，然后通知用户进程进行数据的处理","like_count":4,"discussions":[{"author":{"id":1373602,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f5/a2/8a470344.jpg","nickname":"Run_dream","note":"","ucode":"1BD4AAFCE72B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265825,"discussion_content":"可以参考这篇文章：\nhttps://www.cnblogs.com/zlcxbb/p/6411568.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589442888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214573,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1588767170,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14473669058","product_id":100051201,"comment_content":"请教您个问题，陶老师。我们有个业务要上传二百多个文件，用户量是几十万，这种情形下怎么很好的控制(或估量)文件传输所占用的带宽呢？","like_count":3,"discussions":[{"author":{"id":1033578,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","nickname":"白不吃","note":"","ucode":"F019914D8819C2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545256,"discussion_content":"没有提到频率，多久传输2百多个文件，文件大小是多少，和用户量有什么直接关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641888549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214426,"user_name":"亦知码蚁","can_delete":false,"product_type":"c1","uid":1238245,"ip_address":"","ucode":"400344A6E1207F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","comment_is_top":false,"comment_ctime":1588746418,"is_pvip":false,"replies":[{"id":"79394","content":"你好问题大师，谢谢你的提醒，图上的文字错啦，我马上联系编辑小姐姐更正！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588760857,"ip_address":"","comment_id":214426,"utype":1}],"discussion_count":6,"race_medal":0,"score":"14473648306","product_id":100051201,"comment_content":"从图中可以看到，异步 IO 并没有拷贝到 PageCache 中，这其实是异步 IO 实现上的缺陷。经过 PageCache 的 IO 我们称为缓存 IO，它与虚拟内存系统耦合太紧，导致异步 IO 从诞生起到现在都不支持缓存 IO。<br>陶老师 我在异步IO图中，看到的是把磁盘数据拷贝到PageCache，是图错了嘛，如果是直接IO的话，是直接拷贝到用户进程缓存区嘛，这个过程就是绕过了内核态嘛","like_count":3,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494051,"discussion_content":"你好问题大师，谢谢你的提醒，图上的文字错啦，我马上联系编辑小姐姐更正！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588760857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259051,"discussion_content":"老师回答了，回复我一下啊，要不然没提醒我看不到😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588756052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":259056,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588756471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259051,"ip_address":""},"score":259056,"extra":""}]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259050,"discussion_content":"这个问题，我也看到了，图上画的是 从磁盘缓存区拷贝数据到 PageCache 了。 等待老师的回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588755933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":259111,"discussion_content":"老师说图错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588761106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259050,"ip_address":""},"score":259111,"extra":""},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259127,"discussion_content":"Ok,再去看下图","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588762778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259111,"ip_address":""},"score":259127,"extra":""}]}]},{"had_liked":false,"id":299187,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1624504255,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10214438847","product_id":100051201,"comment_content":"补充说明下 Scatter-gather DMA：<br>----------------------------------------------------------<br>Scatter-gather DMA方式是与block DMA方式相对应的一种DMA方式。在DMA传输数据的过程中，要求源物理地址和目标物理地址必须是连续的。但是在某些计算机体系中，如IA架构，连续的存储器地址在物理上不一定是连续的，所以DMA传输要分成多次完成。如果在传输完一块物理上连续的数据后引起一次中断，然后再由主机进行下一块物理上连续的数据传输，那么这种方式就为block DMA方式。Scatter-gather DMA方式则不同，它使用一个链表描述物理上不连续的存储空间，然后把链表首地址告诉DMA master。DMA master在传输完一块物理连续的数据后，不用发起中断，而是根据链表来传输下一块物理上连续的数据，直到传输完毕后再发起一次中断。很显然，scatter-gather DMA方式比block DMA方式效率高。","like_count":2},{"had_liked":false,"id":215033,"user_name":"C家族铁粉","can_delete":false,"product_type":"c1","uid":1135908,"ip_address":"","ucode":"296C843B33F5E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/24/c6100ac6.jpg","comment_is_top":false,"comment_ctime":1588894101,"is_pvip":false,"replies":[{"id":"79622","content":"没有啦，我思维中的知识是网状的，文字是线性的，你在线性阅读中能够坚持下去，最后还原为树状、网状知识，其实要求挺高的。之前我的行文枝节太多，很难让多数读者坚持下来，是编辑小姐姐对我各种指导，集中炮火攻击一点，才有现在比较通顺流畅的文章，^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588926159,"ip_address":"","comment_id":215033,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10178828693","product_id":100051201,"comment_content":"看到陶辉老师在部落里说，最开始文章有6000字，后来不停删删删，变成了现在的版本，太可惜了，删减掉的部分可以考虑放到其他地方供读者阅读啊。","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494283,"discussion_content":"没有啦，我思维中的知识是网状的，文字是线性的，你在线性阅读中能够坚持下去，最后还原为树状、网状知识，其实要求挺高的。之前我的行文枝节太多，很难让多数读者坚持下来，是编辑小姐姐对我各种指导，集中炮火攻击一点，才有现在比较通顺流畅的文章，^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588926159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214357,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1588729347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178663939","product_id":100051201,"comment_content":"有异步阻塞IO，取决于进程在IO读取点时候在做什么","like_count":2},{"had_liked":false,"id":347094,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1653710769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5948678065","product_id":100051201,"comment_content":"这个是读取文件发送到网络的优化，那把内存中的数据写到文件有没有优化的方法呢？","like_count":1},{"had_liked":false,"id":295973,"user_name":"嘻嘻","can_delete":false,"product_type":"c1","uid":1325931,"ip_address":"","ucode":"E1EB75DD1C05E0","user_header":"","comment_is_top":false,"comment_ctime":1622687573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5917654869","product_id":100051201,"comment_content":"老师有一点不解，为何大文件pagecache命中率不高？再次访问频率比小文件低呢？","like_count":1},{"had_liked":false,"id":260088,"user_name":"烟雨登","can_delete":false,"product_type":"c1","uid":1140792,"ip_address":"","ucode":"8F5E1AEE46273C","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/38/62dad61c.jpg","comment_is_top":false,"comment_ctime":1604922541,"is_pvip":false,"replies":[{"id":"94567","content":"是的，同时由于文件多数都是顺序访问的，因此对于GB级的大文件，某1MB被再次访问到的机率，对于LRU淘汰的PageCache来说，要小于小文件。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1605012893,"ip_address":"","comment_id":260088,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899889837","product_id":100051201,"comment_content":"“由于文件太大，文件中某一部分内容被再次访问到的概率其实非常低“<br>这个不能理解，我理解大文件也是能享受到pagecache带来的优势吧，毕竟是预读了一部分，即使是大文件预读的那部分，下次还是会读到吧。这里真正的影响是把pagecache沾满，影响其他文件把？","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509104,"discussion_content":"是的，同时由于文件多数都是顺序访问的，因此对于GB级的大文件，某1MB被再次访问到的机率，对于LRU淘汰的PageCache来说，要小于小文件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605012893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238571,"user_name":"鱼","can_delete":false,"product_type":"c1","uid":1487584,"ip_address":"","ucode":"89EC9CE3AD0281","user_header":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","comment_is_top":false,"comment_ctime":1596201093,"is_pvip":false,"replies":[{"id":"88278","content":"这个功能默认是不开启的，毕竟直接IO下无法使用电梯算法合并IO，减少机械磁盘的磁盘旋转时间。但是由于InnoDB等引擎都有自己的缓存，PageCache作为缓存的必要性并不大，对于Solaris AMD系统更是会降低MySQL性能，可以通过innodb_flush_method = O_DIRECT来开启直接IO功能提升性能","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1596421441,"ip_address":"","comment_id":238571,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5891168389","product_id":100051201,"comment_content":"MySQL在写redo log和bin log的时候都使用了PageCache。请问老师说的MySQL使用直接IO绕过PageCache是指MySQL的哪一部分逻辑？","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502792,"discussion_content":"这个功能默认是不开启的，毕竟直接IO下无法使用电梯算法合并IO，减少机械磁盘的磁盘旋转时间。但是由于InnoDB等引擎都有自己的缓存，PageCache作为缓存的必要性并不大，对于Solaris AMD系统更是会降低MySQL性能，可以通过innodb_flush_method = O_DIRECT来开启直接IO功能提升性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596421441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1487584,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","nickname":"鱼","note":"","ucode":"89EC9CE3AD0281","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342976,"discussion_content":"我自己来解答一下吧，MySQL优化读写性能时确实使用了直接IO代替系统内核提供的PageCache（BufferIO），比如写请求不直接更改记录而是写入到ChangeBuffer（BufferPool的一部分）中。由于这类缓存的模式最大的问题就是丢失数据，所以一般结合WAL使用，写入redo log这部分就是写入系统文件，这部分还是系统内核的逻辑就用到了PageCache。也是由于这部分只写入了PageCache，没有落盘，导致MySQL可能会丢失数据，解决办法就是设置innodb_flush_log_at_trx_commit设置为1，每次写日志都落盘。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610888696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230983,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1593560000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888527296","product_id":100051201,"comment_content":"老师你好，文中关于“这 32KB 是怎么来的？”的解释，只是说了不能过大也不能过小，而且也是受时间窗口的影响，但是还是缺少一个推算过程，老师能否再深入解释下？感谢！","like_count":1},{"had_liked":false,"id":216355,"user_name":"唐朝首都","can_delete":false,"product_type":"c1","uid":1081233,"ip_address":"","ucode":"F72655AE0AE4CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/91/962eba1a.jpg","comment_is_top":false,"comment_ctime":1589246017,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5884213313","product_id":100051201,"comment_content":"如果按照文中的异步IO的话，应该不会阻塞进程，因为内核已经将数据复制到用户进程的指定内存中，这样不会存在阻塞在IO操作上的情况。","like_count":1},{"had_liked":false,"id":216188,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1589202972,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5884170268","product_id":100051201,"comment_content":"在隔壁的性能高手工程课中看到过这样一个案例, 在使用非阻塞io时,在往内存写入数据时,如果此时该地址对应的物理内存块正在往磁盘刷数据,并且由于磁盘繁忙,该io请求一直得不到调度时就会被阻塞,因为 (根据页面写入稳定的机制，如果页面处于 OS 回写状态，则对该页面的 write() 必须等待回写完成。这是为了避免将部分全新的页面保留到磁盘（会导致数据不一致），来确保磁盘数据的一致性。) 链接https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;190753","like_count":1},{"had_liked":false,"id":214586,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1588769102,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883736398","product_id":100051201,"comment_content":"直接IO还是需要4次内核态用户态切换吗","like_count":1,"discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259960,"discussion_content":"直接IO只是堆外内存（也就是操作系统直接管理的内存），还是需要4次切换的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588833317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214501,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1588758688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883725984","product_id":100051201,"comment_content":"真的是每篇都是干货，买对了。","like_count":1},{"had_liked":false,"id":214311,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1588721674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883688970","product_id":100051201,"comment_content":"课后思考题:<br>我觉得异步IO还是会阻塞进程，在图中的时序图中，当进程收到IO处理完毕的通知后，进程需要进行IO处理，这个时候需要从内核态复制数据到用户态，这个过程是阻塞的。<br>解决方法:我只想到一个思路，不知道是否可行，如果能够异步IO能把数据复制到用户态之后再通知，那就是真正的异步非阻塞了。<br><br>希望老师和同学们指正交流。","like_count":1},{"had_liked":false,"id":361005,"user_name":"小Y","can_delete":false,"product_type":"c1","uid":1739621,"ip_address":"广东","ucode":"24A43BB71805F8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8b/65/0f1f9a10.jpg","comment_is_top":false,"comment_ctime":1667108405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667108405","product_id":100051201,"comment_content":"“绕过 PageCache 的 IO 是个新物种，我们把它称为直接 IO。对于磁盘，异步 IO 只支持直接 IO。”<br>我记得在 学习其他课程，容器技术的时候，做磁盘性能测试，有提到linux内核多少版本之上 支持了磁盘异步IO，不知是否理解有误？","like_count":0},{"had_liked":false,"id":360297,"user_name":"Geek8815","can_delete":false,"product_type":"c1","uid":2028944,"ip_address":"上海","ucode":"D5102AFFA20E7E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/90/2caa07d0.jpg","comment_is_top":false,"comment_ctime":1666409728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666409728","product_id":100051201,"comment_content":"sendfile难道不是只有2次上下文切花就行了？为啥会有400次？","like_count":0},{"had_liked":false,"id":357381,"user_name":"wangshun","can_delete":false,"product_type":"c1","uid":1940467,"ip_address":"河南","ucode":"F775F35B3E2A58","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9b/f3/4646e652.jpg","comment_is_top":false,"comment_ctime":1663213013,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663213013","product_id":100051201,"comment_content":"采用零拷贝方式传输大文件时，为什么会导致大文件耗费CPU多拷贝一次？是因为预读取的内容不够填满发送缓冲区引起的部分内容重复读取吗？","like_count":0},{"had_liked":false,"id":353347,"user_name":"hillcat","can_delete":false,"product_type":"c1","uid":1633032,"ip_address":"北京","ucode":"A4BA5255C53DD6","user_header":"https://static001.geekbang.org/account/avatar/00/18/eb/08/68386ded.jpg","comment_is_top":false,"comment_ctime":1659393972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659393972","product_id":100051201,"comment_content":"有没有0拷贝的代码示例？","like_count":0},{"had_liked":false,"id":345577,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1652410183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652410183","product_id":100051201,"comment_content":"综合上述各种优点，零拷贝可以把性能提升至少一倍以上！对文章开头提到的 320MB 文件的传输，当 socket 缓冲区在 1.4MB 左右时，只需要 4 百多次上下文切换<br>为什么采用零拷贝后，还存在4百多次上下文切换？ 这个意思是指应用程序还需要调用4百多次内核函数吗？？","like_count":0},{"had_liked":false,"id":345576,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1652409954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652409954","product_id":100051201,"comment_content":"综合上述各种优点，零拷贝可以把性能提升至少一倍以上！对文章开头提到的 320MB 文件的传输，当 socket 缓冲区在 1.4MB 左右时，只需要 4 百多次上下文切换","like_count":0},{"had_liked":false,"id":345575,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1652409950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652409950","product_id":100051201,"comment_content":"综合上述各种优点，零拷贝可以把性能提升至少一倍以上！对文章开头提到的 320MB 文件的传输，当 socket 缓冲区在 1.4MB 左右时，只需要 4 百多次上下文切换","like_count":0},{"had_liked":false,"id":330267,"user_name":"白不吃","can_delete":false,"product_type":"c1","uid":1033578,"ip_address":"","ucode":"F019914D8819C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","comment_is_top":false,"comment_ctime":1641888324,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1641888324","product_id":100051201,"comment_content":"因为数据不在应用程序内存中，无法对数据进行处理，只能直接发送。但是比如Java语言，NIO中引入了直接内存，数据可以直接存放到JVM之外的内存中，这种情况算不算可以对数据进行处理的零拷贝？","like_count":0},{"had_liked":false,"id":301082,"user_name":"Fis.","can_delete":false,"product_type":"c1","uid":1711895,"ip_address":"","ucode":"6168F5A759C069","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1f/17/f2a69e62.jpg","comment_is_top":false,"comment_ctime":1625531116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625531116","product_id":100051201,"comment_content":"零拷贝不需要用到用户缓存。异步IO是跳过pageache，直接使用的用户缓存吗？","like_count":0},{"had_liked":false,"id":298612,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1624237357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624237357","product_id":100051201,"comment_content":"为什么大文件传输无法享受到pagecache带来的好处。文件传输时的pagecache带来的好处不是对顺序存储的数据的预读效果吗？难道小文件能享受到大文件就无法享受了吗？","like_count":0},{"had_liked":false,"id":289308,"user_name":"不能用真名字","can_delete":false,"product_type":"c1","uid":1084486,"ip_address":"","ucode":"83464DF743520A","user_header":"https://static001.geekbang.org/account/avatar/00/10/8c/46/7b973ee2.jpg","comment_is_top":false,"comment_ctime":1618974809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618974809","product_id":100051201,"comment_content":"<br>老师是这个问题：“最后，留给你一个思考题，异步 IO 一定不会阻塞进程吗？如果阻塞了进程，该如何解决呢？”老师，就是这个问题；下一课“协程”里有一个描述是“缓冲IO会阻塞，所以多线程+携程解决”，但是AIO是directIO不会缓冲、并且用了eventfd+epoll，难道还会有可能阻塞么？希望您能给一个答案，供我校正自己，感谢","like_count":0},{"had_liked":false,"id":289157,"user_name":"不能用真名字","can_delete":false,"product_type":"c1","uid":1084486,"ip_address":"","ucode":"83464DF743520A","user_header":"https://static001.geekbang.org/account/avatar/00/10/8c/46/7b973ee2.jpg","comment_is_top":false,"comment_ctime":1618897370,"is_pvip":false,"replies":[{"id":"104955","content":"哪道题啊？极客时间的答题系统里，答错了不是有正确答案，以及我给的原因吗？","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1618968629,"ip_address":"","comment_id":289157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618897370","product_id":100051201,"comment_content":"老师，感觉课后题大家答的都不对啊，能给一下答案么？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518835,"discussion_content":"哪道题啊？极客时间的答题系统里，答错了不是有正确答案，以及我给的原因吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618968629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263508,"user_name":"陌上桑","can_delete":false,"product_type":"c1","uid":1232369,"ip_address":"","ucode":"E29A2D298BFE09","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/f1/9616295e.jpg","comment_is_top":false,"comment_ctime":1606144515,"is_pvip":false,"replies":[{"id":"95634","content":"有的，参考：https:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man7&#47;aio.7.html","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1606201797,"ip_address":"","comment_id":263508,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606144515","product_id":100051201,"comment_content":"Lilux  有实现异步IO吗好多书上都是讲没有实现异步IO.只是在我们获取IO状态的时候可以非阻塞或者使用IO多路复用这样的技术。但是这些都是同步的，最终需要用户进程发送Read或者write这样的系统调用写到<br>内核缓冲区","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510219,"discussion_content":"有的，参考：https://man7.org/linux/man-pages/man7/aio.7.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606201797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261427,"user_name":"边际革命","can_delete":false,"product_type":"c1","uid":1124665,"ip_address":"","ucode":"EC15C0AE4D487A","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/39/be9d2e88.jpg","comment_is_top":false,"comment_ctime":1605332710,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605332710","product_id":100051201,"comment_content":"受益匪浅","like_count":0},{"had_liked":false,"id":255090,"user_name":"Geek_78d3bb","can_delete":false,"product_type":"c1","uid":2254690,"ip_address":"","ucode":"1B43733075E132","user_header":"","comment_is_top":false,"comment_ctime":1603265038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603265038","product_id":100051201,"comment_content":"mmap的本质就是进程可以访问内核态的页缓存,减少了一次内核态到用户态的拷贝.<br>sendfile的本质是网络DMA直接读取内核页缓存,减少了一次内核页缓存到socket 缓冲区的拷贝.<br>零拷贝参见：https:&#47;&#47;blog.csdn.net&#47;fdsafwagdagadg6576&#47;article&#47;details&#47;107584821.<br>内存其他部分参见：https:&#47;&#47;blog.csdn.net&#47;fdsafwagdagadg6576&#47;article&#47;details&#47;107738416","like_count":0},{"had_liked":false,"id":253775,"user_name":" 尿布","can_delete":false,"product_type":"c1","uid":1476323,"ip_address":"","ucode":"D1C8BDA7540962","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/e3/a31f6869.jpg","comment_is_top":false,"comment_ctime":1602864119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602864119","product_id":100051201,"comment_content":"真的是让我获益匪浅","like_count":0},{"had_liked":false,"id":242074,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1597584759,"is_pvip":false,"replies":[{"id":"90268","content":"是的，谢谢Gavin的纠正，现代CPU都在使用DMA","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1598945067,"ip_address":"","comment_id":242074,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597584759","product_id":100051201,"comment_content":"然而，由于文件太大，文件中某一部分内容被再次访问到的概率其实非常低。这带来了 2 个问题：首先，由于 PageCache 长期被大文件占据，热点小文件就无法充分使用 PageCache，它们读起来变慢了；其次，PageCache 中的大文件没有享受到缓存的好处，但却耗费 CPU 多拷贝到 PageCache 一次。<br><br>老师，将文件内容从磁盘拷贝到pagecache是dma，不是cpu吧？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503915,"discussion_content":"是的，谢谢Gavin的纠正，现代CPU都在使用DMA","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598945067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238992,"user_name":"王坤祥","can_delete":false,"product_type":"c1","uid":1003327,"ip_address":"","ucode":"FB988B9F381A33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","comment_is_top":false,"comment_ctime":1596411628,"is_pvip":false,"replies":[{"id":"88421","content":"由于日志拥有强烈的时序特性，所以通过PageCache，写文件时可以使磁头仅向一个方向旋转；而且，PageCache中的热点文件并不多，所以PageCache的命中率不低，所以可以使用零拷贝。第27讲有涉及。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1596522786,"ip_address":"","comment_id":238992,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596411628","product_id":100051201,"comment_content":"陶老师，Kafka读取patition中的日志消息算是读取大文件吗？<br>如果是的话，<br>我之前了解到Kafka用到了零拷贝。既然读取大文件零拷贝没有优势，为什么Kafka里用到了零拷贝呢？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502928,"discussion_content":"由于日志拥有强烈的时序特性，所以通过PageCache，写文件时可以使磁头仅向一个方向旋转；而且，PageCache中的热点文件并不多，所以PageCache的命中率不低，所以可以使用零拷贝。第27讲有涉及。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596522786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233502,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1594344218,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1594344218","product_id":100051201,"comment_content":"文件读写时，已经有了pagecache，解决内存和磁盘速度不一致的情况。为何文件读写还需要一个buffer，比如bufferedinputstream，不是多余嘛","like_count":0,"discussions":[{"author":{"id":1902220,"avatar":"","nickname":"Geek_9d0e04","note":"","ucode":"F5560CE5BDB125","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299746,"discussion_content":"pagecache是磁盘控制器的文件缓存，而bufferedinputstream是用户态的缓存，可以减少上下文切换次数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597805671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231787,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1593769715,"is_pvip":false,"replies":[{"id":"90752","content":"磁盘空间分布不均衡，从业务应用上解决比较好。<br>单块磁盘与多块磁盘，它们的Latency相似，但总的IOPS和Throughput会有很大的差别，无论是HDD还是SSD。所以选择多块磁盘时，主要是为了并发。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599616507,"ip_address":"","comment_id":231787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593769715","product_id":100051201,"comment_content":"老师问个问题：服务器如果有多块磁盘，那么对那些分区比较少的Topic来说，是不是会导致磁盘空间分布不均衡呢？还有选择服务器的磁盘时，选择多块磁盘和单块磁盘有什么区别呢？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500438,"discussion_content":"磁盘空间分布不均衡，从业务应用上解决比较好。\n单块磁盘与多块磁盘，它们的Latency相似，但总的IOPS和Throughput会有很大的差别，无论是HDD还是SSD。所以选择多块磁盘时，主要是为了并发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599616507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229888,"user_name":"千岁寒","can_delete":false,"product_type":"c1","uid":1043771,"ip_address":"","ucode":"58D4F1347F6058","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/3b/daa0ff2d.jpg","comment_is_top":false,"comment_ctime":1593177845,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593177845","product_id":100051201,"comment_content":"写的挺好，每篇都是干货，这篇有点跟不上了。<br>同步异步IO这块，理解起来还是比较费力的。","like_count":0},{"had_liked":false,"id":229189,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1592919987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592919987","product_id":100051201,"comment_content":"真的是佩服加摩拜，外加nbplus。真的是干货，整页都是笔记！！！","like_count":0},{"had_liked":false,"id":228468,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1592704702,"is_pvip":false,"replies":[{"id":"90788","content":"对的！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599642096,"ip_address":"","comment_id":228468,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1592704702","product_id":100051201,"comment_content":"有个疑问，老师总结的pagecache有三个好处，预读功能，再次访问缓存功能和合并IO功能，这些好处小文件都可以充分利用。而大文件被再次访问的概率低，那就是无法利用再次访问缓存功能吧，其他两个好处还是可以利用的吧？？如果存在大文件短时间再次访问的场景，三个好处，大文件都能利用吧？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499048,"discussion_content":"对的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599642096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1902220,"avatar":"","nickname":"Geek_9d0e04","note":"","ucode":"F5560CE5BDB125","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299747,"discussion_content":"大文件会挤占小文件使用pagecache的机会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597805715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224670,"user_name":"贝氏倭狐猴","can_delete":false,"product_type":"c1","uid":1100690,"ip_address":"","ucode":"0A89A70C48629C","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/92/cfc1cfd3.jpg","comment_is_top":false,"comment_ctime":1591502206,"is_pvip":false,"replies":[{"id":"82760","content":"可以更换SSD磁盘","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1591578769,"ip_address":"","comment_id":224670,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591502206","product_id":100051201,"comment_content":"请问Kafka Server利用了pagecache，所以Kafka Server就是同步io，那如何保证Kafka server的效率呢？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497562,"discussion_content":"可以更换SSD磁盘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591578769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100690,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/92/cfc1cfd3.jpg","nickname":"贝氏倭狐猴","note":"","ucode":"0A89A70C48629C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285228,"discussion_content":"忽然想到page cache的read before和write after在消息队列这种顺序读写的情形下也可以提高性能。SSD磁盘似乎不是那么需要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592786642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218436,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589801808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589801808","product_id":100051201,"comment_content":"Linux下真正的异步IO是不会阻塞的。但是select和epoll还是会阻塞的，毕竟需要等待系统的事件通知。","like_count":0},{"had_liked":false,"id":216769,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1589339684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589339684","product_id":100051201,"comment_content":"抱着读书破万卷的思路来学习的，还是在某些方面等到了更好的融合；软件的如何合理软硬结合优化才是真正的优化。<br>异步不一定绝对的不会阻塞；比较暴力的方式就是强杀-应急的方式，更合理的方式应当是量上进行调整，资源是有限的再好的方式也挡不住异常的量。这其实就是要求每次操作之前想清楚再做，如果异常我们应当怎么去处理，然后再下手操作。","like_count":0},{"had_liked":false,"id":216010,"user_name":"不重要","can_delete":false,"product_type":"c1","uid":1983655,"ip_address":"","ucode":"4E3EAABE68F956","user_header":"https://static001.geekbang.org/account/avatar/00/1e/44/a7/11668a40.jpg","comment_is_top":false,"comment_ctime":1589167480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589167480","product_id":100051201,"comment_content":"老师，拷贝模式下，我还是没有看懂32K这个缓冲大小是以什么标准作为定量的？","like_count":0},{"had_liked":false,"id":215955,"user_name":"慢动作","can_delete":false,"product_type":"c1","uid":1133945,"ip_address":"","ucode":"62C944F4A4D8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","comment_is_top":false,"comment_ctime":1589158996,"is_pvip":true,"replies":[{"id":"90973","content":"1、分多次也无法避免，因为pagecache会按照LRU淘汰策略；<br>2、对的。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599816542,"ip_address":"","comment_id":215955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589158996","product_id":100051201,"comment_content":"大文件太大会导致pagecache被占满，好处是可以减少读取上下文切换，那分多次读入pagecache可以避免这个问题？异步直接io一次是读取大量数据到用户空间，但发送时还是得按照socket缓冲区情况分很多次发送？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494621,"discussion_content":"1、分多次也无法避免，因为pagecache会按照LRU淘汰策略；\n2、对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599816542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214782,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1588818370,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1588818370","product_id":100051201,"comment_content":"异步IO可能会阻塞进程，我理解的是内核向磁盘发送完读请求之后，才返回到调用方。可以采用多线程读文件的方式来解决？类似于Netty处理网络数据采用的reactive方式。","like_count":0,"discussions":[{"author":{"id":1525522,"avatar":"https://static001.geekbang.org/account/avatar/00/17/47/12/2c47bf36.jpg","nickname":"Geek_2b3614","note":"","ucode":"6208AB2C5FD4C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273746,"discussion_content":"Reactor是同步非阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590496835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1150927,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","nickname":"那时刻","note":"","ucode":"B0D150856C3A4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1525522,"avatar":"https://static001.geekbang.org/account/avatar/00/17/47/12/2c47bf36.jpg","nickname":"Geek_2b3614","note":"","ucode":"6208AB2C5FD4C0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273799,"discussion_content":"奥奥，感谢指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590501387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273746,"ip_address":""},"score":273799,"extra":""}]}]},{"had_liked":false,"id":214587,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1588769293,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588769293","product_id":100051201,"comment_content":"windows的IOCP才是真正的异步IO吧，linux现在的AIO应该不能做到真正的不阻塞吧","like_count":0,"discussions":[{"author":{"id":1118627,"avatar":"https://static001.geekbang.org/account/avatar/00/11/11/a3/7a2405ca.jpg","nickname":"rfyiamcool","note":"","ucode":"65FCBF05B13893","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281175,"discussion_content":"内核的aio只能使用直接io，场景还是有限的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591686424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214478,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1588755313,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1588755313","product_id":100051201,"comment_content":"PageCache 中的大文件没有享受到缓存的好处，但却耗费 CPU 多拷贝到 PageCache 一次<br>--------------------------------------<br>为什么说多拷贝一次 到 PageCache 呢？ 不是都是会从磁盘拷贝数据到内核态呢？ 只是 零拷贝会把数据拷贝到 PageCache 中；不使用 零拷贝 也会把数据拷贝到内核态其他地方，总的来说不都是一次数据拷贝吗？","like_count":0,"discussions":[{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262945,"discussion_content":"直接io是直接拷贝到用户空间吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589158417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":262962,"discussion_content":"对的，直接从磁盘缓冲区拷贝到用户进程空间，之前老师有个图是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589159017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262945,"ip_address":""},"score":262962,"extra":""}]}]}]}