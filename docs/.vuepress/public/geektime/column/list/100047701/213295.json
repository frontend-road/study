{"id":213295,"title":"06 | 20%的业务代码的Spring声明式事务，可能都没处理正确","content":"<p>你好，我是朱晔。今天，我来和你聊聊业务代码中与数据库事务相关的坑。</p><p>Spring针对Java Transaction API (JTA)、JDBC、Hibernate和Java Persistence API (JPA)等事务API，实现了一致的编程模型，而Spring的声明式事务功能更是提供了极其方便的事务配置方式，配合Spring Boot的自动配置，大多数Spring Boot项目只需要在方法上标记@Transactional注解，即可一键开启方法的事务性配置。</p><p>据我观察，大多数业务开发同学都有事务的概念，也知道如果整体考虑多个数据库操作要么成功要么失败时，需要通过数据库事务来实现多个操作的一致性和原子性。但，在使用上大多仅限于为方法标记@Transactional，不会去关注事务是否有效、出错后事务是否正确回滚，也不会考虑复杂的业务代码中涉及多个子业务逻辑时，怎么正确处理事务。</p><p>事务没有被正确处理，一般来说不会过于影响正常流程，也不容易在测试阶段被发现。但当系统越来越复杂、压力越来越大之后，就会带来大量的数据不一致问题，随后就是大量的人工介入查看和修复数据。</p><p>所以说，一个成熟的业务系统和一个基本可用能完成功能的业务系统，在事务处理细节上的差异非常大。要确保事务的配置符合业务功能的需求，往往不仅仅是技术问题，还涉及产品流程和架构设计的问题。今天这一讲的标题“20%的业务代码的Spring声明式事务，可能都没处理正确”中，20%这个数字在我看来还是比较保守的。</p><!-- [[[read_end]]] --><p>我今天要分享的内容，就是帮助你在技术问题上理清思路，避免因为事务处理不当让业务逻辑的实现产生大量偶发Bug。</p><h2>小心Spring的事务可能没有生效</h2><p>在使用@Transactional注解开启声明式事务时， 第一个最容易忽略的问题是，很可能事务并没有生效。</p><p>实现下面的Demo需要一些基础类，首先定义一个具有ID和姓名属性的UserEntity，也就是一个包含两个字段的用户表：</p><pre><code>@Entity\n@Data\npublic class UserEntity {\n    @Id\n    @GeneratedValue(strategy = AUTO)\n    private Long id;\n    private String name;\n\n    public UserEntity() { }\n\n    public UserEntity(String name) {\n        this.name = name;\n    }\n}\n</code></pre><p>为了方便理解，我使用Spring JPA做数据库访问，实现这样一个Repository，新增一个根据用户名查询所有数据的方法：</p><pre><code>@Repository\npublic interface UserRepository extends JpaRepository&lt;UserEntity, Long&gt; {\n    List&lt;UserEntity&gt; findByName(String name);\n}\n</code></pre><p>定义一个UserService类，负责业务逻辑处理。如果不清楚@Transactional的实现方式，只考虑代码逻辑的话，这段代码看起来没有问题。</p><p>定义一个入口方法createUserWrong1来调用另一个私有方法createUserPrivate，私有方法上标记了@Transactional注解。当传入的用户名包含test关键字时判断为用户名不合法，抛出异常，让用户创建操作失败，期望事务可以回滚：</p><pre><code>@Service\n@Slf4j\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n\n    //一个公共方法供Controller调用，内部调用事务性的私有方法\n    public int createUserWrong1(String name) {\n        try {\n            this.createUserPrivate(new UserEntity(name));\n        } catch (Exception ex) {\n            log.error(&quot;create user failed because {}&quot;, ex.getMessage());\n        }\n        return userRepository.findByName(name).size();\n    }\n\n    //标记了@Transactional的private方法\n    @Transactional\n    private void createUserPrivate(UserEntity entity) {\n        userRepository.save(entity);\n        if (entity.getName().contains(&quot;test&quot;))\n            throw new RuntimeException(&quot;invalid username!&quot;);\n    }\n\n    //根据用户名查询用户数\n    public int getUserCount(String name) {\n        return userRepository.findByName(name).size();\n    }\n}\n</code></pre><p>下面是Controller的实现，只是调用一下刚才定义的UserService中的入口方法createUserWrong1。</p><pre><code>@Autowired\nprivate UserService userService;\n\n\n@GetMapping(&quot;wrong1&quot;)\npublic int wrong1(@RequestParam(&quot;name&quot;) String name) {\n    return userService.createUserWrong1(name);\n}\n</code></pre><p>调用接口后发现，即便用户名不合法，用户也能创建成功。刷新浏览器，多次发现有十几个的非法用户注册。</p><p>这里给出@Transactional生效原则1，<strong>除非特殊配置（比如使用AspectJ静态织入实现AOP），否则只有定义在public方法上的@Transactional才能生效</strong>。原因是，Spring默认通过动态代理的方式实现AOP，对目标方法进行增强，private方法无法代理到，Spring自然也无法动态增强事务处理逻辑。</p><p>你可能会说，修复方式很简单，把标记了事务注解的createUserPrivate方法改为public即可。在UserService中再建一个入口方法createUserWrong2，来调用这个public方法再次尝试：</p><pre><code>public int createUserWrong2(String name) {\n    try {\n        this.createUserPublic(new UserEntity(name));\n    } catch (Exception ex) {\n        log.error(&quot;create user failed because {}&quot;, ex.getMessage());\n    }\n\treturn userRepository.findByName(name).size();\n}\n\n//标记了@Transactional的public方法\n@Transactional\npublic void createUserPublic(UserEntity entity) {\n    userRepository.save(entity);\n    if (entity.getName().contains(&quot;test&quot;))\n        throw new RuntimeException(&quot;invalid username!&quot;);\n}\n</code></pre><p>测试发现，调用新的createUserWrong2方法事务同样不生效。这里，我给出@Transactional生效原则2，<strong>必须通过代理过的类从外部调用目标方法才能生效</strong>。</p><p>Spring通过AOP技术对方法进行增强，要调用增强过的方法必然是调用代理后的对象。我们尝试修改下UserService的代码，注入一个self，然后再通过self实例调用标记有@Transactional注解的createUserPublic方法。设置断点可以看到，self是由Spring通过CGLIB方式增强过的类：</p><ul>\n<li>CGLIB通过继承方式实现代理类，private方法在子类不可见，自然也就无法进行事务增强；</li>\n<li>this指针代表对象自己，Spring不可能注入this，所以通过this访问方法必然不是代理。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/b0/6c/b077c033fa394353309fbb4f8368e46c.png?wh=2146*1248\" alt=\"\"></p><p>把this改为self后测试发现，在Controller中调用createUserRight方法可以验证事务是生效的，非法的用户注册操作可以回滚。</p><p>虽然在UserService内部注入自己调用自己的createUserPublic可以正确实现事务，但更合理的实现方式是，让Controller直接调用之前定义的UserService的createUserPublic方法，因为注入自己调用自己很奇怪，也不符合分层实现的规范：</p><pre><code>@GetMapping(&quot;right2&quot;)\npublic int right2(@RequestParam(&quot;name&quot;) String name) {\n    try {\n        userService.createUserPublic(new UserEntity(name));\n    } catch (Exception ex) {\n        log.error(&quot;create user failed because {}&quot;, ex.getMessage());\n    }\n    return userService.getUserCount(name);\n}\n</code></pre><p>我们再通过一张图来回顾下this自调用、通过self调用，以及在Controller中调用UserService三种实现的区别：</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/70/c43ea620b0b611ae194f8438506d7570.png?wh=1860*866\" alt=\"\"></p><p>通过this自调用，没有机会走到Spring的代理类；后两种改进方案调用的是Spring注入的UserService，通过代理调用才有机会对createUserPublic方法进行动态增强。</p><p>这里，我还有一个小技巧，<strong>强烈建议你在开发时打开相关的Debug日志，以方便了解Spring事务实现的细节，并及时判断事务的执行情况</strong>。</p><p>我们的Demo代码使用JPA进行数据库访问，可以这么开启Debug日志：</p><pre><code>logging.level.org.springframework.orm.jpa=DEBUG\n</code></pre><p>开启日志后，我们再比较下在UserService中通过this调用和在Controller中通过注入的UserService Bean调用createUserPublic区别。很明显，this调用因为没有走代理，事务没有在createUserPublic方法上生效，只在Repository的save方法层面生效：</p><pre><code>//在UserService中通过this调用public的createUserPublic\n[10:10:19.913] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.springframework.data.jpa.repository.support.SimpleJpaRepository.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT\n//在Controller中通过注入的UserService Bean调用createUserPublic\n[10:10:47.750] [http-nio-45678-exec-6] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo1.UserService.createUserPublic]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT\n</code></pre><p>你可能还会考虑一个问题，这种实现在Controller里处理了异常显得有点繁琐，还不如直接把createUserWrong2方法加上@Transactional注解，然后在Controller中直接调用这个方法。这样一来，既能从外部（Controller中）调用UserService中的方法，方法又是public的能够被动态代理AOP增强。</p><p>你可以试一下这种方法，但很容易就会踩第二个坑，即因为没有正确处理异常，导致事务即便生效也不一定能回滚。</p><h2>事务即便生效也不一定能回滚</h2><p>通过AOP实现事务处理可以理解为，使用try…catch…来包裹标记了@Transactional注解的方法，<strong>当方法出现了异常并且满足一定条件的时候</strong>，在catch里面我们可以设置事务回滚，没有异常则直接提交事务。</p><p>这里的“一定条件”，主要包括两点。</p><p>第一，<strong>只有异常传播出了标记了@Transactional注解的方法，事务才能回滚</strong>。在Spring的TransactionAspectSupport里有个 invokeWithinTransaction方法，里面就是处理事务的逻辑。可以看到，只有捕获到异常才能进行后续事务处理：</p><pre><code>try {\n   // This is an around advice: Invoke the next interceptor in the chain.\n   // This will normally result in a target object being invoked.\n   retVal = invocation.proceedWithInvocation();\n}\ncatch (Throwable ex) {\n   // target invocation exception\n   completeTransactionAfterThrowing(txInfo, ex);\n   throw ex;\n}\nfinally {\n   cleanupTransactionInfo(txInfo);\n}\n</code></pre><p>第二，<strong>默认情况下，出现RuntimeException（非受检异常）或Error的时候，Spring才会回滚事务</strong>。</p><p>打开Spring的DefaultTransactionAttribute类能看到如下代码块，可以发现相关证据，通过注释也能看到Spring这么做的原因，大概的意思是受检异常一般是业务异常，或者说是类似另一种方法的返回值，出现这样的异常可能业务还能完成，所以不会主动回滚；而Error或RuntimeException代表了非预期的结果，应该回滚：</p><pre><code>/**\n * The default behavior is as with EJB: rollback on unchecked exception\n * ({@link RuntimeException}), assuming an unexpected outcome outside of any\n * business rules. Additionally, we also attempt to rollback on {@link Error} which\n * is clearly an unexpected outcome as well. By contrast, a checked exception is\n * considered a business exception and therefore a regular expected outcome of the\n * transactional business method, i.e. a kind of alternative return value which\n * still allows for regular completion of resource operations.\n * &lt;p&gt;This is largely consistent with TransactionTemplate's default behavior,\n * except that TransactionTemplate also rolls back on undeclared checked exceptions\n * (a corner case). For declarative transactions, we expect checked exceptions to be\n * intentionally declared as business exceptions, leading to a commit by default.\n * @see org.springframework.transaction.support.TransactionTemplate#execute\n */\n@Override\npublic boolean rollbackOn(Throwable ex) {\n   return (ex instanceof RuntimeException || ex instanceof Error);\n}\n</code></pre><p>接下来，我和你分享2个反例。</p><p>重新实现一下UserService中的注册用户操作：</p><ul>\n<li>在createUserWrong1方法中会抛出一个RuntimeException，但由于方法内catch了所有异常，异常无法从方法传播出去，事务自然无法回滚。</li>\n<li>在createUserWrong2方法中，注册用户的同时会有一次otherTask文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为otherTask方法抛出的是受检异常，createUserWrong2传播出去的也是受检异常，事务同样不会回滚。</li>\n</ul><pre><code>@Service\n@Slf4j\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    //异常无法传播出方法，导致事务无法回滚\n    @Transactional\n    public void createUserWrong1(String name) {\n        try {\n            userRepository.save(new UserEntity(name));\n            throw new RuntimeException(&quot;error&quot;);\n        } catch (Exception ex) {\n            log.error(&quot;create user failed&quot;, ex);\n        }\n    }\n\n    //即使出了受检异常也无法让事务回滚\n    @Transactional\n    public void createUserWrong2(String name) throws IOException {\n        userRepository.save(new UserEntity(name));\n        otherTask();\n    }\n\n    //因为文件不存在，一定会抛出一个IOException\n    private void otherTask() throws IOException {\n        Files.readAllLines(Paths.get(&quot;file-that-not-exist&quot;));\n    }\n}\n</code></pre><p>Controller中的实现，仅仅是调用UserService的createUserWrong1和createUserWrong2方法，这里就贴出实现了。这2个方法的实现和调用，虽然完全避开了事务不生效的坑，但因为异常处理不当，导致程序没有如我们期望的文件操作出现异常时回滚事务。</p><p>现在，我们来看下修复方式，以及如何通过日志来验证是否修复成功。针对这2种情况，对应的修复方法如下。</p><p>第一，如果你希望自己捕获异常进行处理的话，也没关系，可以手动设置让当前事务处于回滚状态：</p><pre><code>@Transactional\npublic void createUserRight1(String name) {\n    try {\n        userRepository.save(new UserEntity(name));\n        throw new RuntimeException(&quot;error&quot;);\n    } catch (Exception ex) {\n        log.error(&quot;create user failed&quot;, ex);\n        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n    }\n}\n</code></pre><p>运行后可以在日志中看到Rolling back字样，确认事务回滚了。同时，我们还注意到“Transactional code has requested rollback”的提示，表明手动请求回滚：</p><pre><code>[22:14:49.352] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :698 ] - Transactional code has requested rollback\n[22:14:49.353] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :834 ] - Initiating transaction rollback\n[22:14:49.353] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :555 ] - Rolling back JPA transaction on EntityManager [SessionImpl(1906719643&lt;open&gt;)]\n</code></pre><p>第二，在注解中声明，期望遇到所有的Exception都回滚事务（来突破默认不回滚受检异常的限制）：</p><pre><code>@Transactional(rollbackFor = Exception.class)\npublic void createUserRight2(String name) throws IOException {\n    userRepository.save(new UserEntity(name));\n    otherTask();\n}\n</code></pre><p>运行后，同样可以在日志中看到回滚的提示：</p><pre><code>[22:10:47.980] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :834 ] - Initiating transaction rollback\n[22:10:47.981] [http-nio-45678-exec-4] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :555 ] - Rolling back JPA transaction on EntityManager [SessionImpl(1419329213&lt;open&gt;)]\n</code></pre><p>在这个例子中，我们展现的是一个复杂的业务逻辑，其中有数据库操作、IO操作，在IO操作出现问题时希望让数据库事务也回滚，以确保逻辑的一致性。在有些业务逻辑中，可能会包含多次数据库操作，我们不一定希望将两次操作作为一个事务来处理，这时候就需要仔细考虑事务传播的配置了，否则也可能踩坑。</p><h2>请确认事务传播配置是否符合自己的业务逻辑</h2><p>有这么一个场景：一个用户注册的操作，会插入一个主用户到用户表，还会注册一个关联的子用户。我们希望将子用户注册的数据库操作作为一个独立事务来处理，即使失败也不会影响主流程，即不影响主用户的注册。</p><p>接下来，我们模拟一个实现类似业务逻辑的UserService：</p><pre><code>@Autowired\nprivate UserRepository userRepository;\n\n@Autowired\nprivate SubUserService subUserService;\n\n@Transactional\npublic void createUserWrong(UserEntity entity) {\n    createMainUser(entity);\n    subUserService.createSubUserWithExceptionWrong(entity);\n}\n\nprivate void createMainUser(UserEntity entity) {\n    userRepository.save(entity);\n    log.info(&quot;createMainUser finish&quot;);\n}\n</code></pre><p>SubUserService的createSubUserWithExceptionWrong实现正如其名，因为最后我们抛出了一个运行时异常，错误原因是用户状态无效，所以子用户的注册肯定是失败的。我们期望子用户的注册作为一个事务单独回滚，不影响主用户的注册，这样的逻辑可以实现吗？</p><pre><code>@Service\n@Slf4j\npublic class SubUserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Transactional\n    public void createSubUserWithExceptionWrong(UserEntity entity) {\n        log.info(&quot;createSubUserWithExceptionWrong start&quot;);\n        userRepository.save(entity);\n        throw new RuntimeException(&quot;invalid status&quot;);\n    }\n}\n</code></pre><p>我们在Controller里实现一段测试代码，调用UserService：</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic int wrong(@RequestParam(&quot;name&quot;) String name) {\n    try {\n        userService.createUserWrong(new UserEntity(name));\n    } catch (Exception ex) {\n        log.error(&quot;createUserWrong failed, reason:{}&quot;, ex.getMessage());\n    }\n    return userService.getUserCount(name);\n}\n</code></pre><p>调用后可以在日志中发现如下信息，很明显事务回滚了，最后Controller打出了创建子用户抛出的运行时异常：</p><pre><code>[22:50:42.866] [http-nio-45678-exec-8] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :555 ] - Rolling back JPA transaction on EntityManager [SessionImpl(103972212&lt;open&gt;)]\n[22:50:42.869] [http-nio-45678-exec-8] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :620 ] - Closing JPA EntityManager [SessionImpl(103972212&lt;open&gt;)] after transaction\n[22:50:42.869] [http-nio-45678-exec-8] [ERROR] [t.d.TransactionPropagationController:23  ] - createUserWrong failed, reason:invalid status\n</code></pre><p>你马上就会意识到，不对呀，因为运行时异常逃出了@Transactional注解标记的createUserWrong方法，Spring当然会回滚事务了。如果我们希望主方法不回滚，应该把子方法抛出的异常捕获了。</p><p>也就是这么改，把subUserService.createSubUserWithExceptionWrong包裹上catch，这样外层主方法就不会出现异常了：</p><pre><code>@Transactional\npublic void createUserWrong2(UserEntity entity) {\n    createMainUser(entity);\n    try{\n        subUserService.createSubUserWithExceptionWrong(entity);\n    } catch (Exception ex) {\n        // 虽然捕获了异常，但是因为没有开启新事务，而当前事务因为异常已经被标记为rollback了，所以最终还是会回滚。\n        log.error(&quot;create sub user error:{}&quot;, ex.getMessage());\n    }\n}\n</code></pre><p>运行程序后可以看到如下日志：</p><pre><code>[22:57:21.722] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.UserService.createUserWrong2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT\n[22:57:21.739] [http-nio-45678-exec-3] [INFO ] [t.c.transaction.demo3.SubUserService:19  ] - createSubUserWithExceptionWrong start\n[22:57:21.739] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :356 ] - Found thread-bound EntityManager [SessionImpl(1794007607&lt;open&gt;)] for JPA transaction\n[22:57:21.739] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :471 ] - Participating in existing transaction\n[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :843 ] - Participating transaction failed - marking existing transaction as rollback-only\n[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :580 ] - Setting JPA transaction on EntityManager [SessionImpl(1794007607&lt;open&gt;)] rollback-only\n[22:57:21.740] [http-nio-45678-exec-3] [ERROR] [.g.t.c.transaction.demo3.UserService:37  ] - create sub user error:invalid status\n[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :741 ] - Initiating transaction commit\n[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :529 ] - Committing JPA transaction on EntityManager [SessionImpl(1794007607&lt;open&gt;)]\n[22:57:21.743] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :620 ] - Closing JPA EntityManager [SessionImpl(1794007607&lt;open&gt;)] after transaction\n[22:57:21.743] [http-nio-45678-exec-3] [ERROR] [t.d.TransactionPropagationController:33  ] - createUserWrong2 failed, reason:Transaction silently rolled back because it has been marked as rollback-only\norg.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only\n...\n</code></pre><p>需要注意以下几点：</p><ul>\n<li>如第1行所示，对createUserWrong2方法开启了异常处理；</li>\n<li>如第5行所示，子方法因为出现了运行时异常，标记当前事务为回滚；</li>\n<li>如第7行所示，主方法的确捕获了异常打印出了create sub user error字样；</li>\n<li>如第9行所示，主方法提交了事务；</li>\n<li>奇怪的是，如第11行和12行所示，<strong>Controller里出现了一个UnexpectedRollbackException，异常描述提示最终这个事务回滚了，而且是静默回滚的</strong>。之所以说是静默，是因为createUserWrong2方法本身并没有出异常，只不过提交后发现子方法已经把当前事务设置为了回滚，无法完成提交。</li>\n</ul><p>这挺反直觉的。<strong>我们之前说，出了异常事务不一定回滚，这里说的却是不出异常，事务也不一定可以提交</strong>。原因是，主方法注册主用户的逻辑和子方法注册子用户的逻辑是同一个事务，子逻辑标记了事务需要回滚，主逻辑自然也不能提交了。</p><p>看到这里，修复方式就很明确了，想办法让子逻辑在独立事务中运行，也就是改一下SubUserService注册子用户的方法，为注解加上propagation = Propagation.REQUIRES_NEW来设置REQUIRES_NEW方式的事务传播策略，也就是执行到这个方法时需要开启新的事务，并挂起当前事务：</p><pre><code>@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void createSubUserWithExceptionRight(UserEntity entity) {\n    log.info(&quot;createSubUserWithExceptionRight start&quot;);\n    userRepository.save(entity);\n    throw new RuntimeException(&quot;invalid status&quot;);\n}\n</code></pre><p>主方法没什么变化，同样需要捕获异常，防止异常漏出去导致主事务回滚，重新命名为createUserRight：</p><pre><code>@Transactional\npublic void createUserRight(UserEntity entity) {\n    createMainUser(entity);\n    try{\n        subUserService.createSubUserWithExceptionRight(entity);\n    } catch (Exception ex) {\n        // 捕获异常，防止主方法回滚\n        log.error(&quot;create sub user error:{}&quot;, ex.getMessage());\n    }\n}\n</code></pre><p>改造后，重新运行程序可以看到如下的关键日志：</p><ul>\n<li>第1行日志提示我们针对createUserRight方法开启了主方法的事务；</li>\n<li>第2行日志提示创建主用户完成；</li>\n<li>第3行日志可以看到主事务挂起了，开启了一个新的事务，针对createSubUserWithExceptionRight方案，也就是我们的创建子用户的逻辑；</li>\n<li>第4行日志提示子方法事务回滚；</li>\n<li>第5行日志提示子方法事务完成，继续主方法之前挂起的事务；</li>\n<li>第6行日志提示主方法捕获到了子方法的异常；</li>\n<li>第8行日志提示主方法的事务提交了，随后我们在Controller里没看到静默回滚的异常。</li>\n</ul><pre><code>[23:17:20.935] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.UserService.createUserRight]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT\n[23:17:21.079] [http-nio-45678-exec-1] [INFO ] [.g.t.c.transaction.demo3.UserService:55  ] - createMainUser finish\n[23:17:21.082] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :420 ] - Suspending current transaction, creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.SubUserService.createSubUserWithExceptionRight]\n[23:17:21.153] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :834 ] - Initiating transaction rollback\n[23:17:21.160] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :1009] - Resuming suspended transaction after completion of inner transaction\n[23:17:21.161] [http-nio-45678-exec-1] [ERROR] [.g.t.c.transaction.demo3.UserService:49  ] - create sub user error:invalid status\n[23:17:21.161] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :741 ] - Initiating transaction commit\n[23:17:21.161] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :529 ] - Committing JPA transaction on EntityManager [SessionImpl(396441411&lt;open&gt;)]\n</code></pre><p>运行测试程序看到如下结果，getUserCount得到的用户数量为1，代表只有一个用户也就是主用户注册完成了，符合预期：</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/f8/3bd9c32b5144025f1a2de5b4ec436ff8.png?wh=1188*216\" alt=\"\"></p><h2>重点回顾</h2><p>今天，我针对业务代码中最常见的使用数据库事务的方式，即Spring声明式事务，与你总结了使用上可能遇到的三类坑，包括：</p><p>第一，因为配置不正确，导致方法上的事务没生效。我们务必确认调用@Transactional注解标记的方法是public的，并且是通过Spring注入的Bean进行调用的。</p><p>第二，因为异常处理不正确，导致事务虽然生效但出现异常时没回滚。Spring默认只会对标记@Transactional注解的方法出现了RuntimeException和Error的时候回滚，如果我们的方法捕获了异常，那么需要通过手动编码处理事务回滚。如果希望Spring针对其他异常也可以回滚，那么可以相应配置@Transactional注解的rollbackFor和noRollbackFor属性来覆盖其默认设置。</p><p>第三，如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么我们需要考虑进一步细化配置事务传播方式，也就是@Transactional注解的Propagation属性。</p><p>可见，正确配置事务可以提高业务项目的健壮性。但，又因为健壮性问题往往体现在异常情况或一些细节处理上，很难在主流程的运行和测试中发现，导致业务代码的事务处理逻辑往往容易被忽略，因此<strong>我在代码审查环节一直很关注事务是否正确处理</strong>。</p><p>如果你无法确认事务是否真正生效，是否按照预期的逻辑进行，可以尝试打开Spring的部分Debug日志，通过事务的运作细节来验证。也建议你在单元测试时尽量覆盖多的异常场景，这样在重构时，也能及时发现因为方法的调用方式、异常处理逻辑的调整，导致的事务失效问题。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>考虑到Demo的简洁，文中所有数据访问使用的都是Spring Data JPA。国内大多数互联网业务项目是使用MyBatis进行数据访问的，使用MyBatis配合Spring的声明式事务也同样需要注意文中提到的这些点。你可以尝试把今天的Demo改为MyBatis做数据访问实现，看看日志中是否可以体现出这些坑。</li>\n<li>在第一节中我们提到，如果要针对private方法启用事务，动态代理方式的AOP不可行，需要使用静态织入方式的AOP，也就是在编译期间织入事务增强代码，可以配置Spring框架使用AspectJ来实现AOP。你能否参阅Spring的文档“<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-aspectj\">Using @Transactional with AspectJ</a>”试试呢？注意：AspectJ配合lombok使用，还可能会踩一些坑。</li>\n</ol><p>有关数据库事务，你还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"05 | HTTP调用：你考虑到超时、重试、并发了吗？","id":213273},"right":{"article_title":"答疑篇：代码篇思考题集锦（一）","id":260695}},"comments":[{"had_liked":false,"id":193686,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1584948692,"is_pvip":true,"replies":[{"id":"73770","content":"👍🏻","user_name":"作者回复","comment_id":193686,"uid":"1001470","ip_address":"","utype":1,"ctime":1584953381,"user_name_real":"朱晔"}],"discussion_count":8,"race_medal":0,"score":"229218215380","product_id":100047701,"comment_content":"AspectJ与lombok，都是字节码层面进行增强，在一起使用时会有问题，根据AspectJ维护者Andy Clement的当前答案是由于ECJ（Eclipse Compiler for Java）软件包存在问题在AspectJ编译器基础结构中包含和重命名。<br>解决问题可以参考下面连接：<br>http:&#47;&#47;aspectj.2085585.n4.nabble.com&#47;AspectJ-with-Lombok-td4651540.html<br>https:&#47;&#47;stackoverflow.com&#47;questions&#47;41910007&#47;lombok-and-aspectj<br><br>分享一个使用lombok的坑：<br>之前为了set赋值方便，在VO或者DTO上使用了@Accessors(chain=true)，这样就可以链式赋值，但是在动态通过内省获取set方法进行赋值时，是获取不到对应的set方法，因为默认的set方法返回值是void，但是加了@Accessors(chain=true)之后，set方法的返回值变成了this，这样通过内省就获取到对应的set方法了，通过去掉@Accessors(chain=true)即可实现，通过内省动态给属性赋值。","like_count":54,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488620,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584953381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903371,"avatar":"","nickname":"简单点","note":"","ucode":"2750A770D004D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282551,"discussion_content":"菜鸟弱弱的问一下内省是什么意思啊？求教","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592014729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1903371,"avatar":"","nickname":"简单点","note":"","ucode":"2750A770D004D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282566,"discussion_content":"内省就是低级别反射，你可以网上搜索下，这块的内容很多的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592017305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282551,"ip_address":""},"score":282566,"extra":""},{"author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":379040,"discussion_content":"此处的内省对应的英文是什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623637740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282566,"ip_address":""},"score":379040,"extra":""},{"author":{"id":1968721,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/unkzY52hVDjTmZJGNkrBR75tFs4XTGBoYYcOYkIcPvHlQrLibwc94aBfj1uWiawoKeEMwHbkvgThXZarfoP8Dzag/132","nickname":"她","note":"","ucode":"FAC6851866C9C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005290,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/ea/32608c44.jpg","nickname":"giteebravo","note":"","ucode":"C087E8D6B5A98B","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":406080,"discussion_content":"Google呀~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634698038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379040,"ip_address":""},"score":406080,"extra":""}]},{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544364,"discussion_content":"秒啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641483068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294243,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595837842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2039388,"avatar":"","nickname":"李松","note":"","ucode":"28572BCFD696E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283692,"discussion_content":"我一般通过builder来赋值的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592327068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191268,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1584759948,"is_pvip":false,"replies":[{"id":"73372","content":"这个问题很好，首先JDK动态代理肯定是不行的只能是public，理论上CGLIB方式的代理是可以代理protected方法的，不过如果支持，那么意味着事务可能会因为切换代理实现方式表现不同，大大增加出现Bug的可能性，我觉得为了一致性所以Spring考虑只支持public，这是最好的。","user_name":"作者回复","comment_id":191268,"uid":"1001470","ip_address":"","utype":1,"ctime":1584764178,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"177678419084","product_id":100047701,"comment_content":"否则只有定义在 public 方法上的 @Transactional 才能生效。这里一定要用public吗，用protected不行吗，protected在子类中应该也可见啊，是因为包不同吗","like_count":42,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212867,"discussion_content":"是，但是Spring统一限制了：\n\nAbstractFallbackTransactionAttributeSource：\n\n@Nullable\n\tprotected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {\n\t\t// Don&#39;t allow no-public methods as required.\n\t\tif (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {\n\t\t\treturn null;\n\t\t}\n}","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1585026054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":368099,"discussion_content":"还是源码出真知啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618566423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212867,"ip_address":""},"score":368099,"extra":""}]},{"author":{"id":1112651,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/4b/c385f755.jpg","nickname":"向前走","note":"","ucode":"8956E92DCEFB60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211756,"discussion_content":"JDK动态代码肯定不行只能是public，是因为JDK动态代理是基于接口实现,而接口默认就是public的,老师,是这个意思么？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584886272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488144,"discussion_content":"这个问题很好，首先JDK动态代理肯定是不行的只能是public，理论上CGLIB方式的代理是可以代理protected方法的，不过如果支持，那么意味着事务可能会因为切换代理实现方式表现不同，大大增加出现Bug的可能性，我觉得为了一致性所以Spring考虑只支持public，这是最好的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584764178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192858,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1584876178,"is_pvip":false,"replies":[{"id":"73733","content":"你说的隔离级别应该是指READ_UNCOMMITTED。我不认为这是很好的解决方案，子方法内需要依赖的数据来自父方法，可以方法传值，而不是用这种隔离级别。","user_name":"作者回复","comment_id":192858,"uid":"1001470","ip_address":"","utype":1,"ctime":1584931999,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"169088600722","product_id":100047701,"comment_content":"我还遇到一个坑，就是子方法使用了REQUIRES_NEW，但是业务逻辑需要的数据是来源于父方法的，也就是父方法还没提交，子方法获取不到。当时的解决方法是把事务隔离级别改成RC，现在回想起来，不知道这种解决方法是否正确？","like_count":39,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488476,"discussion_content":"你说的隔离级别应该是指READ_UNCOMMITTED。我不认为这是很好的解决方案，子方法内需要依赖的数据来自父方法，可以方法传值，而不是用这种隔离级别。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584931999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198735,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1585466147,"is_pvip":false,"replies":[{"id":"74730","content":"没错","user_name":"作者回复","comment_id":198735,"uid":"1001470","ip_address":"","utype":1,"ctime":1585469612,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"100369713955","product_id":100047701,"comment_content":"Spring默认事务采用动态代理方式实现。因此只能对public进行增强（考虑到CGLib和JDKProxy兼容，protected也不支持）。在使用动态代理增强时，方法内调用也可以考虑采用AopContext.currentProxy()获取当前代理类。","like_count":24,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489746,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585469612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192854,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1584875896,"is_pvip":false,"replies":[{"id":"73594","content":"1、容易上手简单<br>2、国内BAT大厂对于Mybatis的使用量大，影响力大<br>3、国内大部分项目还是面向表结构的编程，从下到上的思考方式而非OOP的思考方式","user_name":"作者回复","comment_id":192854,"uid":"1001470","ip_address":"","utype":1,"ctime":1584879982,"user_name_real":"朱晔"}],"discussion_count":8,"race_medal":0,"score":"100369123704","product_id":100047701,"comment_content":"老师，可以问一下为啥国内大多数公司使用MyBatis呢？是为了更加接近SQL吗？难倒国外业务不会遇到复杂的场景吗？","like_count":24,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488475,"discussion_content":"1、容易上手简单\n2、国内BAT大厂对于Mybatis的使用量大，影响力大\n3、国内大部分项目还是面向表结构的编程，从下到上的思考方式而非OOP的思考方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584879982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657925,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4c/45/1042c1fd.jpg","nickname":"淡忘如风","note":"","ucode":"464DBE34300A6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302289,"discussion_content":"需求改动较大，sql好改。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598868853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364873,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d3/89/6f5c09bc.jpg","nickname":"姚俊","note":"","ucode":"2ABE42AC97B528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257747,"discussion_content":"jpa偏向ddd的思维方式，其实配合cqrs模式个人认为是很好的组合，只是国内用的人不多","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588602755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080812,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7d/ec/ccd30c1d.jpg","nickname":"WangBo","note":"","ucode":"8BFCC4E2639175","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319819,"discussion_content":"我理解用MyBatis和是否面向OOP关系不大，JPA有其学习理解门槛和局限性。我们用JdbcTemplate，但我们是先设计API，然后才设计DB Schema。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604128366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103187,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d5/53/a95eb9b0.jpg","nickname":"kanon","note":"","ucode":"50A5FBF318EC28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215200,"discussion_content":"国外人少用户少，用jpa难优化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585300648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381341,"discussion_content":"并不是 一个简单返利，复杂sql的性能问题，。。jpa 没有mybatis直接。。。目前 有哪个to C的系统 底层全都是jpa搞的。。搞到一半 基本要重写了。。这玩意底层hibernate。13年那会hibernate就活了一阵子不到1年多就沉底熄灭了。。这会又死灰复燃了。一句话，如果单纯内部系统，OK，可以，但是反过来一句话， 如果不涉及到事物直接mongo好不好？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625018432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016860,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/1c/7997352e.jpg","nickname":"gogogo","note":"","ucode":"EB19D75BB7100E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270233,"discussion_content":"理论知识跟不上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589986540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549364,"avatar":"","nickname":"Geek_3b1096","note":"","ucode":"A6BD92B79B3632","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217171,"discussion_content":"对我也想知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585523824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191415,"user_name":"九时四","can_delete":false,"product_type":"c1","uid":1670963,"ip_address":"","ucode":"92DCC2DF3DD15C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zGUSFibP0OGFW9a3QSic1DZLr5B4kPoNmt3RibzLNYSOxN3mUZibBMkGHpwcYPFYWJ7v61wsMvyIKzpBuQJWD2hVOg/132","comment_is_top":false,"comment_ctime":1584771768,"is_pvip":false,"replies":[{"id":"73379","content":"如果要通过数据库来实现锁，那么加锁解锁，需要是单独的事务，不能跟业务的sql事务混合在一起，加锁和业务在一个事务里了，锁就没用了，因为每个事务里，都认为自己拿到了锁。","user_name":"作者回复","comment_id":191415,"uid":"1001470","ip_address":"","utype":1,"ctime":1584778220,"user_name_real":"朱晔"}],"discussion_count":8,"race_medal":0,"score":"83189150392","product_id":100047701,"comment_content":"老师您好，有个数据库事务和spring事务的问题想请教下（我是一个入职半年的菜鸟）。<br>业务场景：为了实现同一个时间的多个请求，只有一个请求生效，在数据库字段上加了一个字段（signature_lock）标识锁状态。（没有使用redis锁之类的中间件，只讨论数据库事务和Spring的事务，以下的请求理解为同时请求）<br><br>1.在数据库层面，通过sql语句直接操作数据库，数据库事务隔离级别为可重复读：<br><br>-- 请求1<br>show VARIABLES like &#39;tx_isolation&#39;;<br>START TRANSACTION;<br>select * from subscribe_info where id = 29;<br>-- update语句只有一个请求可以执行，另一个请求在等待<br>update trade_deal_subscribe_info set signature_lock =1 where id = 1 and signature_lock = 0;<br>commit;<br><br>-- 请求2<br>show VARIABLES like &#39;tx_isolation&#39;;<br>START TRANSACTION;<br>select * from trade_deal_subscribe_info where id = 29;<br>-- update语句只有一个请求可以执行，另一个请求在等待<br>update subscribe_info set signature_lock =1 where id = 1 and signature_lock = 0;<br>commit;<br><br>两个请求中只有一个可以执行成功update语句，将signature_lock更新为1。<br><br><br><br>2.在代码层面按照在数据库层面的逻辑，service层的伪代码如下：<br>public void test(ParamDto paramDto) {<br> &#47;&#47;取数据<br> Data data = getByParamDto(paramDto);<br> &#47;&#47; 尝试加锁,返回1表示加锁成功<br> Integer lockStatus = lockData(paramDto);<br> &#47;&#47; 加锁失败直接返回<br> if(!Objects.equals(1,lockStatus)){<br>  return;<br> }<br> try{<br>   &#47;&#47; 处理业务代码，大概2到3秒 <br>   handle();<br> }catch(Exception e){<br> <br> } finally{<br>   &#47;&#47; 释放锁<br>   releaseLock(paramDto);<br> }<br>}<br><br><br>按照这样的方式，在方法上面不加注解的情况下，执行结果与在写sql的结果是一致的，两个请求只有一个可以执行成功；加上@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED)之后，两个请求都可以拿到锁。<br><br>疑问是，Spring的事务和数据库的事务有什么关系，加上事务注解后，为什么和数据库的结果不一致。","like_count":19,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488168,"discussion_content":"如果要通过数据库来实现锁，那么加锁解锁，需要是单独的事务，不能跟业务的sql事务混合在一起，加锁和业务在一个事务里了，锁就没用了，因为每个事务里，都认为自己拿到了锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584778220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2002210,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","nickname":"tongzi","note":"","ucode":"7349A6E42EDF17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270691,"discussion_content":"因为加了事务注解，当第二次请求过来时，第一次请求的事务是没有提交的；应该是和隔离级别有关系，导致第二次请求同时过来，对第一次修改的数据不可见。所以也拿到了锁；个人拙见","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590037753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220981,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erkQ49YqAySHOlynF8fC7Z65ic0icmWYKVJFicAiam4RFcyzZK5IqWI9KYaicaEqw3B24ibaKSicqTOdwDzQ/132","nickname":"KLOOOP","note":"","ucode":"1BBF897219786F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325116,"discussion_content":"还是只有一个请求会拿到锁，第一个请求拿到锁，第二个请求加锁时会被阻塞直到第一个请求事务提交。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605238359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1327997,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/YqF3S64vHV7cuGIQLczgj4hgOxZlHEN7X48nIShQIiaN1cU4VsE9ia4VVmTibVKzMfRG7ibgibKOPJfA5S1SrYZNDyA/132","nickname":"InfoQ_aae1c4db19b4","note":"","ucode":"481665EAB720F5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588634,"discussion_content":"加了事务注解且隔离级别是rr情况下，会有这个问题，可以了解下mvcc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663919730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582661,"discussion_content":"跟事务隔离级别一毛钱关系都没有，在你业务方法的入口加锁即可。同一时间只有一个请求可以获取锁，获得到锁的请求一定要先查询数据库判断你的lock是否被更新（这一步很重要），如果没有被更新则执行更新操作，然后提交事务，再释放锁。（一定要先提交事务再释放锁，很多人估计把释放锁的代码写在事务里面。如果这样写，就会造成 锁被释放掉，但是事务还没提交，下一个请求又可以获得锁，获得锁之后查询数据库看看记录是否被更新，因为上一个请求释放了锁，但是事务没有提交，所以之后的请求都会认为记录没有被更新，这样就会造成多次update）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659582141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972713,"avatar":"","nickname":"Geek_9efcc0","note":"","ucode":"9F0CCD5DEDB1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243367,"discussion_content":"看懵了，能解释下？？? ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587536335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2002210,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","nickname":"tongzi","note":"","ucode":"7349A6E42EDF17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1972713,"avatar":"","nickname":"Geek_9efcc0","note":"","ucode":"9F0CCD5DEDB1BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270690,"discussion_content":"因为加了事务注解，当第二次请求过来时，第一次请求的事务是没有提交的；应该是和隔离级别有关系，导致第二次请求同时过来，对第一次修改的数据不可见。所以也拿到了锁；个人拙见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590037741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243367,"ip_address":""},"score":270690,"extra":""},{"author":{"id":1896790,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYBNJLrkN0msjRcXFBVWw4PRUbpr9v0ZMxbuQxSCB4eT4BjERILIAUZYFlFicAgBz52WK2icT6oJ26WkuvoeUoCg/132","nickname":"Geek_c32feb","note":"","ucode":"CDE5E2B549D12E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2002210,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","nickname":"tongzi","note":"","ucode":"7349A6E42EDF17","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277078,"discussion_content":"是的，没加事务注解之前发一条sql语句就是一个单独的事务，你加了注解这个方法里面所有的sql语句都在一个事务里面，一个请求加锁更新了，另一个同时过来被锁阻塞。但是你更新完后数据没有commit，我再来加锁的时候还是可以用成功的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590995357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":270690,"ip_address":""},"score":277078,"extra":""}]}]},{"had_liked":false,"id":205083,"user_name":"火很大先生","can_delete":false,"product_type":"c1","uid":1242070,"ip_address":"","ucode":"80746AFCEF5FE7","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/d6/5d55c315.jpg","comment_is_top":false,"comment_ctime":1586523472,"is_pvip":false,"replies":[{"id":"76672","content":"需要明确几点：<br>1、我觉得这个事务最终是回滚的，你看到的这个查询有值，并不代表数据库有值<br>2、这个查询有值的原因是因为在一个事务内，此时事务并没有回滚，事务要到离开了这个createUserRight方法才会回滚（回想一下AOP原理）<br>3、在一个事务内肯定可以看到事务之前做的修改","user_name":"作者回复","comment_id":205083,"uid":"1001470","ip_address":"","utype":1,"ctime":1586565097,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"53126131024","product_id":100047701,"comment_content":"    @Transactional<br>    public int createUserRight(String name) throws IOException {<br>        try {<br>            userRepository.save(new UserEntity(name));<br>            throw new RuntimeException(&quot;error&quot;);<br>        } catch (Exception ex) {<br>            log.error(&quot;create user failed because {}&quot;, ex.getMessage());<br>            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();<br>        }<br>        return userRepository.findByName(name).size();<br>    }<br>请教老师，我这种写法，控制台打出了Initiating transaction rollback 但是数据库还是存上了数据，没有回滚，是因为findByName 这个查询语句的默认commit给提交了吗","like_count":12,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491383,"discussion_content":"需要明确几点：\n1、我觉得这个事务最终是回滚的，你看到的这个查询有值，并不代表数据库有值\n2、这个查询有值的原因是因为在一个事务内，此时事务并没有回滚，事务要到离开了这个createUserRight方法才会回滚（回想一下AOP原理）\n3、在一个事务内肯定可以看到事务之前做的修改","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586565097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195281,"user_name":"阿里斯托芬","can_delete":false,"product_type":"c1","uid":1228350,"ip_address":"","ucode":"5FB99020992974","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/3e/1de66fbc.jpg","comment_is_top":false,"comment_ctime":1585153043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53124760595","product_id":100047701,"comment_content":"我觉得这个文章里面应该顺带讲一下 AopContext.currentProxy()","like_count":12},{"had_liked":false,"id":195696,"user_name":"雅然风懿","can_delete":false,"product_type":"c1","uid":1007242,"ip_address":"","ucode":"32ED4550305D0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/8a/0c1f9635.jpg","comment_is_top":false,"comment_ctime":1585212517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27355016293","product_id":100047701,"comment_content":"学习了，我得回去检查我的事务代码了","like_count":6},{"had_liked":false,"id":195655,"user_name":"王刚","can_delete":false,"product_type":"c1","uid":1103821,"ip_address":"","ucode":"4763CC9A937C38","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/cd/6ebfc468.jpg","comment_is_top":false,"comment_ctime":1585209794,"is_pvip":true,"replies":[{"id":"74308","content":"是啊，所以我们才需要设置    @Transactional(rollbackFor = Exception.class)<br>来不仅仅回滚RuntimeException","user_name":"作者回复","comment_id":195655,"uid":"1001470","ip_address":"","utype":1,"ctime":1585213633,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"27355013570","product_id":100047701,"comment_content":"老师问个问题，您说得@Transactional事物回滚，只有是RuntimeException 或error时，才会回滚；<br>但是我在做测试时，发现@Transactional有一个rollbackFor属性，该属性可以指定什么异常回滚，如果@Transactional 不指定rollbackFor，默认得是RuntimeException？","like_count":6,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489139,"discussion_content":"是啊，所以我们才需要设置    @Transactional(rollbackFor = Exception.class)\n来不仅仅回滚RuntimeException","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585213633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215798,"discussion_content":"阿里的开发规范就是建议@Transactional(rollbackFor = Exception.class)，这样的抛出业务异常也会回滚数据","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585384233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194198,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1585036799,"is_pvip":false,"replies":[{"id":"73979","content":"理论上NESTED显然是比两个独立都事务好，NESTED因为JPA Hibernate不支持，所以这里没有采用这种方式（而且对于本例而言，主用户创建在先，如果先出异常的话后面也不会到子用户的逻辑，所以问题不大），抽空我再传一个例子上去：<br><br>https:&#47;&#47;github.com&#47;JosephZhu1983&#47;java-common-mistakes&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;org&#47;geekbang&#47;time&#47;commonmistakes&#47;transaction&#47;nested","user_name":"作者回复","comment_id":194198,"uid":"1001470","ip_address":"","utype":1,"ctime":1585040548,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"27354840575","product_id":100047701,"comment_content":"老师，创建主子用户那个业务，应该是子用户创建失败不影响主用户，但是主用户失败应该子用户也要回滚吧？如果是这样，那传播机制是不是应该用Propagation.NESTED","like_count":6,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488780,"discussion_content":"理论上NESTED显然是比两个独立都事务好，NESTED因为JPA Hibernate不支持，所以这里没有采用这种方式（而且对于本例而言，主用户创建在先，如果先出异常的话后面也不会到子用户的逻辑，所以问题不大），抽空我再传一个例子上去：\n\nhttps://github.com/JosephZhu1983/java-common-mistakes/tree/master/src/main/java/org/geekbang/time/commonmistakes/transaction/nested","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585040548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062451,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/33/67904e86.jpg","nickname":"James","note":"","ucode":"886D1A102C1588","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308664,"discussion_content":"最好还是用 NESTED, 如果用了 REQUIRED_NEW，在主子用户操作完之后有异常时，主会回滚，但子不会回滚，这样子就成了脏数据","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601024018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384451,"discussion_content":"理论上NESTED显然是比两个独立都事务好。老师的这句话，哪位老哥能解释一下，为什么NESTED要比两个独立事务好呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626597832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1272026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/da/5bcb83b1.jpg","nickname":"白晨","note":"","ucode":"6D6171B8ECEDDD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":560067,"discussion_content":"我理解是这两者其实算是一个行为来着，所以肯定嵌套在一起更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649153010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384451,"ip_address":""},"score":560067,"extra":""}]}]},{"had_liked":false,"id":205011,"user_name":"Yanni","can_delete":false,"product_type":"c1","uid":1904077,"ip_address":"","ucode":"D24219F0AB8EC3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0d/cd/9264c4aa.jpg","comment_is_top":false,"comment_ctime":1586507558,"is_pvip":false,"replies":[{"id":"76622","content":"能否分析一下原因给大家分享一下？","user_name":"作者回复","comment_id":205011,"uid":"1001470","ip_address":"","utype":1,"ctime":1586515295,"user_name_real":"朱晔"}],"discussion_count":5,"race_medal":0,"score":"23061344038","product_id":100047701,"comment_content":"要注意，@Transactional 与 @Async注解不能同时在一个方法上使用, 这样会导致事物不生效。","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491350,"discussion_content":"能否分析一下原因给大家分享一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586515295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1904077,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/cd/9264c4aa.jpg","nickname":"Yanni","note":"","ucode":"D24219F0AB8EC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229675,"discussion_content":"1、Spring 实现这两个注解的方式都是通过AOP。\n2、在实现时，Async注解强制覆盖AOP的order为最小值（它认为Async应该是执行的AOP链中的第一个advisor -- https://jira.spring.io/browse/SPR-7147），而且order不可配置。\n3、但是在实现Transactional注解时，却没有覆盖order，这意味着它仍然为默认的Integer.MAX_VALUE，order可配置。所以异步切面会先于事务切面执行。\n4、假设@Transactional能先于Async切面执行，但由于spring事务管理依赖的是ThreadLocal，所以在开启的异步线程里面感知不到事务，说细点就是在Spring开启事务之后，会设置一个连接到当前线程，但这个时候又开启了一个新线程，执行实际的SQL代码时，通过ThreadLocal获取不到连接就会开启新连接，也不会设置autoCommit，所以这个函数整体将没有事务。","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1586681449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1062451,"avatar":"https://static001.geekbang.org/account/avatar/00/10/36/33/67904e86.jpg","nickname":"James","note":"","ucode":"886D1A102C1588","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1904077,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/cd/9264c4aa.jpg","nickname":"Yanni","note":"","ucode":"D24219F0AB8EC3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308672,"discussion_content":"请问有参考代码吗，我尝试了之后发现事务是生效的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601025916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":229675,"ip_address":""},"score":308672,"extra":""}]},{"author":{"id":1480717,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/0d/fb77a32c.jpg","nickname":"Tim","note":"","ucode":"3AAA9FD3D8DDDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408974,"discussion_content":"https://www.cnblogs.com/jpfss/p/10273129.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635347946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235986,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/12/a35259b1.jpg","nickname":"Robot1030","note":"","ucode":"C58668846AF272","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301086,"discussion_content":"我尝试了下，是可以生效的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598404388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197268,"user_name":"magic","can_delete":false,"product_type":"c1","uid":1024556,"ip_address":"","ucode":"A1BCF486381749","user_header":"","comment_is_top":false,"comment_ctime":1585366165,"is_pvip":false,"replies":[{"id":"74569","content":"实现步骤这里帖不下，可以参考 https:&#47;&#47;www.cnblogs.com&#47;lovecindywang&#47;p&#47;9749658.html 『使用AspectJ静态织入进行改造』一节，自己做一下测试","user_name":"作者回复","comment_id":197268,"uid":"1001470","ip_address":"","utype":1,"ctime":1585373315,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"23060202645","product_id":100047701,"comment_content":"老师能补充下对私有方法事务的代码示例吗？","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489487,"discussion_content":"实现步骤这里帖不下，可以参考 https://www.cnblogs.com/lovecindywang/p/9749658.html 『使用AspectJ静态织入进行改造』一节，自己做一下测试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585373315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193719,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1584954008,"is_pvip":false,"replies":[{"id":"73776","content":"生效，但是出异常的并不是save本身，所以Spring无法回滚","user_name":"作者回复","comment_id":193719,"uid":"1001470","ip_address":"","utype":1,"ctime":1584959131,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"23059790488","product_id":100047701,"comment_content":"很明显，this 调用因为没有走代理，事务没有在 createUserPublic 方法上生效，只在 Repository 的 save 方法层面生效。<br>createUserPublic这个方法不是本来就一个save操作吗，既然save层面生效了，那这个方法的事务难道不也就生效了吗？","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488635,"discussion_content":"生效，但是出异常的并不是save本身，所以Spring无法回滚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584959131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195720,"user_name":"张珮磊想静静","can_delete":false,"product_type":"c1","uid":1084732,"ip_address":"","ucode":"2E582ED7BB178E","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/3c/9025c2ca.jpg","comment_is_top":false,"comment_ctime":1585213913,"is_pvip":true,"replies":[{"id":"74309","content":"可以搜索一下分布式事务的解决方案","user_name":"作者回复","comment_id":195720,"uid":"1001470","ip_address":"","utype":1,"ctime":1585215069,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"18765083097","product_id":100047701,"comment_content":"如果一个事务里面操作了不同的数据库，回滚操作是不是就得自己写补偿的重试了？","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489152,"discussion_content":"可以搜索一下分布式事务的解决方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585215069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368101,"discussion_content":"搜索一下MySQL XA 分布式事务，MySQL 实现了 2PC 事务的提交，可以在一个应用中操作不同的数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618566824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193630,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1584936812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764805996","product_id":100047701,"comment_content":"Spring的坑，看来还需要多读些源码啊。","like_count":4},{"had_liked":false,"id":191881,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1584802454,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18764671638","product_id":100047701,"comment_content":"很多注解貌似都是需要public才能生效比如：@cacheable @async","like_count":5,"discussions":[{"author":{"id":1197260,"avatar":"https://static001.geekbang.org/account/avatar/00/12/44/cc/3e62d111.jpg","nickname":"justd","note":"","ucode":"A8857900C9FA18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215781,"discussion_content":"因为动态代理的原因么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585382783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1197260,"avatar":"https://static001.geekbang.org/account/avatar/00/12/44/cc/3e62d111.jpg","nickname":"justd","note":"","ucode":"A8857900C9FA18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215825,"discussion_content":"对，你的头像很别致呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585388090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215781,"ip_address":""},"score":215825,"extra":""},{"author":{"id":1616166,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a9/26/da3113a3.jpg","nickname":"飞鱼","note":"","ucode":"0F5F441B173FB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220630,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585909325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215825,"ip_address":""},"score":220630,"extra":""}]}]},{"had_liked":false,"id":225710,"user_name":"nimil","can_delete":false,"product_type":"c1","uid":1197925,"ip_address":"","ucode":"19933068972746","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/65/cce8eb34.jpg","comment_is_top":false,"comment_ctime":1591838234,"is_pvip":false,"replies":[{"id":"83172","content":"的确，这也是一种坑","user_name":"作者回复","comment_id":225710,"uid":"1001470","ip_address":"","utype":1,"ctime":1591840763,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"14476740122","product_id":100047701,"comment_content":"前几天还真出现了个事务不生效的问题，于是对着文章仔细review了一下代码，发现也没文中说的那些毛病，最后排查到是事务管理器只配置了一个数据库，而我是在另一个数据库进行的数据操作，所以事务不生效了，最后添加另一个数据库的事务管理器事务就生效了","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497958,"discussion_content":"的确，这也是一种坑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591840763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341238,"discussion_content":"哈哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610358077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203682,"user_name":"COLDLY","can_delete":false,"product_type":"c1","uid":1248467,"ip_address":"","ucode":"B16257B2D83CC0","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/d3/0be6ae81.jpg","comment_is_top":false,"comment_ctime":1586254257,"is_pvip":false,"replies":[{"id":"76111","content":"1、一个select对于数据库来说也是事务，隐式事务也是事务，读也需要考虑事务隔离性<br>2、加事务你是指@Transactional？如果方法里面没有什么其他操作不建议加，就保持autocommit好了，加了可能还会autocommit=0、select、commit、autocommit=1，增加无谓的交互","user_name":"作者回复","comment_id":203682,"uid":"1001470","ip_address":"","utype":1,"ctime":1586256658,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"14471156145","product_id":100047701,"comment_content":"请问如果仅是select语句，需要加事务吗","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490932,"discussion_content":"1、一个select对于数据库来说也是事务，隐式事务也是事务，读也需要考虑事务隔离性\n2、加事务你是指@Transactional？如果方法里面没有什么其他操作不建议加，就保持autocommit好了，加了可能还会autocommit=0、select、commit、autocommit=1，增加无谓的交互","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586256658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368102,"discussion_content":"MySQL通过MVCC多版本并发控制机制来保证多个事务读写同一行数据的并发问题。底层是基于undo log版本链+ReadView机制实现的，可以了解一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618567040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193977,"user_name":"小李讲源码","can_delete":false,"product_type":"c1","uid":1107484,"ip_address":"","ucode":"2573037D7C82C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","comment_is_top":false,"comment_ctime":1585009819,"is_pvip":true,"replies":[{"id":"73864","content":"👍🏻","user_name":"作者回复","comment_id":193977,"uid":"1001470","ip_address":"","utype":1,"ctime":1585011784,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"14469911707","product_id":100047701,"comment_content":"看完了老师讲的这篇文章，发现自己用@Transation的时候，也只是为了用而用，并不看它的真实效果，就会导致以后的数据不正确，有脏数据。今天把案例中的代码敲一遍，然后再看自己项目中的用法是否正确。","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488718,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585011784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368103,"discussion_content":"今天重新梳理了事务相关的内容，并且把@Transactional注解从加载到使用的整个源码过程都分析了一遍，然后再结合老师的文章，现在真的是豁然开朗了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618567140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275322,"user_name":"冉野","can_delete":false,"product_type":"c1","uid":1137353,"ip_address":"","ucode":"2CAEA424996876","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/c9/933ee0a8.jpg","comment_is_top":false,"comment_ctime":1611471360,"is_pvip":false,"replies":[{"id":"99973","content":"Spring中使用ThreadLocal来设计TransactionSynchronizationManager类，实现了事务管理与数据访问服务的解耦，同时也保证了多线程环境下connection的线程安全问题","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1611557692,"ip_address":"","comment_id":275322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10201405952","product_id":100047701,"comment_content":"可是为什么 在subUserService.createSubUserWithExceptionRight(entity);改成 new Thread()线程执行，事务就不会回滚了呢，还提示 SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3f669b54] was not registered for synchronization because synchronization is not active和<br>JDBC Connection [HikariProxyConnection@1155028039 wrapping com.mysql.jdbc.JDBC4Connection@4f6fcbb3] will not be managed by Spring<br> 还请老师和同学们帮解答一下<br>","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514310,"discussion_content":"Spring中使用ThreadLocal来设计TransactionSynchronizationManager类，实现了事务管理与数据访问服务的解耦，同时也保证了多线程环境下connection的线程安全问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611557692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252811,"user_name":"Mr wind","can_delete":false,"product_type":"c1","uid":1217874,"ip_address":"","ucode":"484F02D1962239","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","comment_is_top":false,"comment_ctime":1602492255,"is_pvip":false,"replies":[{"id":"92399","content":"如果整体需要一致性那么可以考虑是否部分可以最终一致性，也就是部分流程异步化，最终一致，当然了你要确保异步化的这个流程和主流程有事务性，比如可以采用事务消息或者本地事务表","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1602503477,"ip_address":"","comment_id":252811,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10192426847","product_id":100047701,"comment_content":"期待老师的回答，假如是在一个长流程的操作里，比如查询表1，更新表2，查询表3，更新表3...类似这种业务里数据量又大，各个表之间有业务关联都需要更新，耗时很长。这种情况应该加事务吗？如果加在流程顶部肯定会是长事务非常不好。感觉这种情况是否只有从业务角度来改变，不知道老师怎么看。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506880,"discussion_content":"如果整体需要一致性那么可以考虑是否部分可以最终一致性，也就是部分流程异步化，最终一致，当然了你要确保异步化的这个流程和主流程有事务性，比如可以采用事务消息或者本地事务表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602503477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311900,"discussion_content":"老师真敬业啊，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602515616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223682,"user_name":"郑先生","can_delete":false,"product_type":"c1","uid":1992424,"ip_address":"","ucode":"AA0BA751C4F132","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep3sqfTQey7eKYgGibLnAvaNj9k8gVvIYKVADicOA3DxmXZcDrAkeM8iaJLruiblmEVUr3q2LOVLvYicTw/132","comment_is_top":false,"comment_ctime":1591155141,"is_pvip":false,"replies":[{"id":"82392","content":"会回滚，源码参考<br><br>RuleBasedTransactionAttribute.rollbackOn<br><br>@Override<br>\tpublic boolean rollbackOn(Throwable ex) {<br>\t\tif (logger.isTraceEnabled()) {<br>\t\t\tlogger.trace(&quot;Applying rules to determine whether transaction should rollback on &quot; + ex);<br>\t\t}<br><br>\t\tRollbackRuleAttribute winner = null;<br>\t\tint deepest = Integer.MAX_VALUE;<br><br>\t\tif (this.rollbackRules != null) {<br>\t\t\tfor (RollbackRuleAttribute rule : this.rollbackRules) {<br>\t\t\t\tint depth = rule.getDepth(ex);<br>\t\t\t\tif (depth &gt;= 0 &amp;&amp; depth &lt; deepest) {<br>\t\t\t\t\tdeepest = depth;<br>\t\t\t\t\twinner = rule;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br><br>\t\tif (logger.isTraceEnabled()) {<br>\t\t\tlogger.trace(&quot;Winning rollback rule is: &quot; + winner);<br>\t\t}<br><br>\t\t&#47;&#47; User superclass behavior (rollback on unchecked) if no rule matches.<br>\t\tif (winner == null) {<br>\t\t\tlogger.trace(&quot;No relevant rollback rule found: applying default rules&quot;);<br>\t\t\treturn super.rollbackOn(ex);<br>\t\t}<br><br>\t\treturn !(winner instanceof NoRollbackRuleAttribute);<br>\t}","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591168665,"ip_address":"","comment_id":223682,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10181089733","product_id":100047701,"comment_content":"有个问题 默认只回滚RuntimeException和Error的异常，按照异常继承关系：Error和Exception都继承自Throwable，如果指定rollbackFor=Exception.class，那不是Error的异常不会回滚了？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497212,"discussion_content":"会回滚，源码参考\n\nRuleBasedTransactionAttribute.rollbackOn\n\n@Override\n\tpublic boolean rollbackOn(Throwable ex) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(&amp;quot;Applying rules to determine whether transaction should rollback on &amp;quot; + ex);\n\t\t}\n\n\t\tRollbackRuleAttribute winner = null;\n\t\tint deepest = Integer.MAX_VALUE;\n\n\t\tif (this.rollbackRules != null) {\n\t\t\tfor (RollbackRuleAttribute rule : this.rollbackRules) {\n\t\t\t\tint depth = rule.getDepth(ex);\n\t\t\t\tif (depth &amp;gt;= 0 &amp;amp;&amp;amp; depth &amp;lt; deepest) {\n\t\t\t\t\tdeepest = depth;\n\t\t\t\t\twinner = rule;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(&amp;quot;Winning rollback rule is: &amp;quot; + winner);\n\t\t}\n\n\t\t// User superclass behavior (rollback on unchecked) if no rule matches.\n\t\tif (winner == null) {\n\t\t\tlogger.trace(&amp;quot;No relevant rollback rule found: applying default rules&amp;quot;);\n\t\t\treturn super.rollbackOn(ex);\n\t\t}\n\n\t\treturn !(winner instanceof NoRollbackRuleAttribute);\n\t}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591168665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368108,"discussion_content":"就是我们设置了匹配规则，如果满足了，比如我们的抛出的异常的父类是Exception.class，那么就会返回true。如果没有匹配的话，那么winner就是null，就会走默认的逻辑，也就是判断是否是RuntimeException还是Error。\n\n所以 Error 的异常也是会捕获到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618567621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368106,"discussion_content":"好问题，可以好好地研究一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618567423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219467,"user_name":"tongzi","can_delete":false,"product_type":"c1","uid":2002210,"ip_address":"","ucode":"7349A6E42EDF17","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","comment_is_top":false,"comment_ctime":1590028578,"is_pvip":false,"replies":[{"id":"81082","content":"不会有问题，不设置默认就是使用数据库设置的隔离级别，如果你设置了就使用你设置的隔离级别","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590046383,"ip_address":"","comment_id":219467,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179963170","product_id":100047701,"comment_content":"【问题】<br>1、员工导入（新手机号），第一次会导入失败，再导入才会成功<br>【具体场景】<br>导入excel，解析成员工数据4条，先去注册生成t_user表，生成基本信息<br>然后在调用，bandCorp，和公司绑定，生成t_corp_user表<br>但是在调用bandCorp时，需要先去校验这个手机号，是否在t_user表生成数据<br>【解决】<br>发现由于事务注解引起的bug，importUserList（导入员工方法）加了事务注解，registerUser没有加事务注解<br>bandCorp加了事务注解，bandCorp传播级别为Propagation.REQUIRES_NEW，新开了事务<br>由于线上数据库为可重复读，qa数据库为读已提交，导致数据的不可见，校验失败<br><br>老师您好，我这边有个问题，看见springboot的事务隔离级别是default，默认采用数据库的<br>隔离级别，如果要是springboot的事务隔离级别，和mysql采用不同的隔离级别，是否会导致什么问题？（比如springboot手动设置为  可重复读，而数据库为读已提交）","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495815,"discussion_content":"不会有问题，不设置默认就是使用数据库设置的隔离级别，如果你设置了就使用你设置的隔离级别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590046383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204175,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1586346758,"is_pvip":true,"replies":[{"id":"76387","content":"我不知道你这两个任务哪个是主任务，假设写入nas是主任务，写入数据库只是记录状态，并且前者又慢，这种最合理的做法是：<br>1、数据库插入任务记录<br>2、启一个job来处理任务，开始处理的时候更新为处理中<br>3、如果是处理中则查nas更新结果<br>4、如果没成功或未处理则清理nas+写数据<br>5、成功后更新任务状态为成功<br>6、失败维持处理中即可，等待job下一次调度<br>","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586389223,"ip_address":"","comment_id":204175,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10176281350","product_id":100047701,"comment_content":"老师，有个问题，请教下：一个操作，里面涉及往nas盘写数据和数据库更新数据，当二者都成功才OK，但是会出现写入nas盘成功但是写入数据库失败的情况，这种如何回滚，nas盘的数据这时候不是有效的了，如何回滚清理","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491097,"discussion_content":"我不知道你这两个任务哪个是主任务，假设写入nas是主任务，写入数据库只是记录状态，并且前者又慢，这种最合理的做法是：\n1、数据库插入任务记录\n2、启一个job来处理任务，开始处理的时候更新为处理中\n3、如果是处理中则查nas更新结果\n4、如果没成功或未处理则清理nas+写数据\n5、成功后更新任务状态为成功\n6、失败维持处理中即可，等待job下一次调度\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586389223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228670,"discussion_content":"我的方案是用于重任务的，你这种轻任务的方案也比较简单，把上传和更新路径都放在一个事务里，传失败了出异常让事务回滚，让用户重试即可，传失败是小概率事件，可以考虑不清nas，或者做一个定时任务，从数据库捞出所有图片地址，然后逐一检查nas定期清理废图","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586568900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227220,"discussion_content":"谢谢老师解答，但是这两个操作是发生在一个接口层面，比如上传头像接口，头像放在nas盘，db存储路径，nas盘头像访问走cdn，因为我们这里cdn同名不同步，故头像名每次更新都不一样才能同步，接口层面这种情况，老师提的这种方案是不是代价有点大？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586478907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199324,"user_name":"The One","can_delete":false,"product_type":"c1","uid":1319368,"ip_address":"","ucode":"D3438E31543332","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/c8/33828cfc.jpg","comment_is_top":false,"comment_ctime":1585486790,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175421382","product_id":100047701,"comment_content":"我用的spring boot2.2.3，发现创建用户和子用户这个静默回滚例子没有复现，即没有标注需要开启新事物这个注解，仅仅try catch之后就可以了，有其他同学试了吗？求告知","like_count":2},{"had_liked":false,"id":199234,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1585483354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175417946","product_id":100047701,"comment_content":"开发中，真的碰到过。","like_count":2},{"had_liked":false,"id":198469,"user_name":"Geek_fb74a8","can_delete":false,"product_type":"c1","uid":1926523,"ip_address":"","ucode":"802A47B46697B7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mZrw2nVk1Aw8eYh5GPWpI9OHVBhXdFpMZx9mDyAHJuSZlpXCfKcOUxSUTewtibW8KBb0d9ftNl9F0n6ptudxBwQ/132","comment_is_top":false,"comment_ctime":1585452909,"is_pvip":false,"replies":[{"id":"74687","content":"还是根据需求 如果需要出异常都回滚 那么service层不捕获异常 如果希望精细化处理异常那么就考虑自己手动根据需求提交或回滚事务 在后续异常一文也会提到写点","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585457036,"ip_address":"","comment_id":198469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175387501","product_id":100047701,"comment_content":"老师，实际开发中是不是一般都将异常交给Controller层来处理或者由拦截器统一处理异常，从而保证需要事务支持的方法在执行过程中发生异常时能够保证回滚？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489710,"discussion_content":"还是根据需求 如果需要出异常都回滚 那么service层不捕获异常 如果希望精细化处理异常那么就考虑自己手动根据需求提交或回滚事务 在后续异常一文也会提到写点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585457036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191658,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1584787396,"is_pvip":false,"replies":[{"id":"73461","content":"spring的代码是非常复杂的，理不清思路也很正常，遇到不明白的原理可以先网上搜索一下类似源码剖析的文章，再自己去源码里面看","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584794654,"ip_address":"","comment_id":191658,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10174721988","product_id":100047701,"comment_content":"本节的三个坑，老师总结得很到位，我也理解原理了。但是让我自己看源码，就理不清思绪了。不知道从哪条线哪个类入手。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488218,"discussion_content":"spring的代码是非常复杂的，理不清思路也很正常，遇到不明白的原理可以先网上搜索一下类似源码剖析的文章，再自己去源码里面看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584794654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368104,"discussion_content":"从TransactionInterceptor的invoke方法开始看，这个是一个方法的拦截器，对于调用的方法带有@Transactional会被拦截器拦截，进入到这里，然后你在打断点去分析内部的原理。最终底层就是基于JDBC提供的API来实现的事务的提交、回滚等操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618567264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191066,"user_name":"Jialin","can_delete":false,"product_type":"c1","uid":1112955,"ip_address":"","ucode":"12583269732A75","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/7b/2d4b38fb.jpg","comment_is_top":false,"comment_ctime":1584721517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174656109","product_id":100047701,"comment_content":"这节spring事务操作非常实用，减少开发踩坑，好好研究","like_count":2},{"had_liked":false,"id":240397,"user_name":"小胡子","can_delete":false,"product_type":"c1","uid":1018182,"ip_address":"","ucode":"79FEC6400D25DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/46/0b7828a1.jpg","comment_is_top":false,"comment_ctime":1596887922,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5891855218","product_id":100047701,"comment_content":" spring aop中所有类this调用方法都存在这样的问题，通过注入自身bean确实也能解决，但是确实也不雅，从依赖角度来看确实挺怪的，但是service类中确实存在调用自身的，请问怎么才能优雅的解决掉呢","like_count":1,"discussions":[{"author":{"id":1225974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/f6/e39d5af1.jpg","nickname":"钱米","note":"","ucode":"07AA44C6A40D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389102,"discussion_content":"不能简单的就用controller调用service，不然controller中有太多业务逻辑。涉及到多层调用时，可以考虑职责划分、代码分层结构，ddd思想考虑。而不是代码堆叠，面向过程编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629118759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3f/23/8ff389d2.jpg","nickname":"郁方林","note":"","ucode":"8ABEAFDA815DDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376912,"discussion_content":"1. 把this改为上层调用, 比如service调用service改成controller调用service, 必要的情况service之间加上事务传播机制\n2. AopContext.currentProxy() 可以获取当前的代理对象后调用service的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622424320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238786,"user_name":"🎓Dream-seeker","can_delete":false,"product_type":"c1","uid":2100403,"ip_address":"","ucode":"3C8477DE9DD766","user_header":"https://static001.geekbang.org/account/avatar/00/20/0c/b3/7e13920b.jpg","comment_is_top":false,"comment_ctime":1596296162,"is_pvip":false,"replies":[{"id":"88198","content":"可以再理解一下aop原理，异常超出方法边界即可","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1596334222,"ip_address":"","comment_id":238786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891263458","product_id":100047701,"comment_content":"在catch代码块中再抛出异常，应该也是可以回滚事物的吧","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502850,"discussion_content":"可以再理解一下aop原理，异常超出方法边界即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596334222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221422,"user_name":"track6688","can_delete":false,"product_type":"c1","uid":1088040,"ip_address":"","ucode":"0A9E893F8FD379","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/28/03613c22.jpg","comment_is_top":false,"comment_ctime":1590496982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885464278","product_id":100047701,"comment_content":"老师都很认真做好这个专栏，学到很多东西","like_count":1},{"had_liked":false,"id":211845,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1588030759,"is_pvip":false,"replies":[{"id":"78740","content":"不错","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588040726,"ip_address":"","comment_id":211845,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5882998055","product_id":100047701,"comment_content":"总结:<br>① 事务不生效的情况，事务注解加在private方法上、事务方法中调用的是内部this调用的方法而不是self    <br>②事务生效却出异常不回滚的情况，事务异常没有被传播出注解方法而是被捕获了、被事务注解的方法抛出的是受检异常导致不回滚<br>③主方法提交，子方法出错不提交的做法:<br>子方法上注解加上 propagation = Propagation.REQUIRES_NEW 来设置 REQUIRES_NEW 方式的事务传播策略，也就是执行到这个方法时需要开启新的事务，并挂起当前事务","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493380,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588040726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400896,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/40/e1139eb1.jpg","nickname":"松松17333870526","note":"","ucode":"93696276C88584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271333,"discussion_content":"这位大哥，您说的 第二条是这样不，第一种情况：异常被try catch捕获了，没有传播出去被注解方法捕获到，第二种情况：虽然抛出了异常，但是抛出的是受检的，事务也不会回滚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590118581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205221,"user_name":"f","can_delete":false,"product_type":"c1","uid":1396147,"ip_address":"","ucode":"686BD6C21FE02B","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/b3/85828cc4.jpg","comment_is_top":false,"comment_ctime":1586573073,"is_pvip":false,"replies":[{"id":"76704","content":"👍🏻","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586588761,"ip_address":"","comment_id":205221,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881540369","product_id":100047701,"comment_content":"第三遍看 又有收获","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491425,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586588761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197529,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1585383913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880351209","product_id":100047701,"comment_content":"第二个题使用手动控制事务的方式也可以让private的方法事务生效<br>   @Autowired<br>    private PlatformTransactionManager platformTransactionManager;<br>    @Autowired<br>    private TransactionDefinition transactionDefinition;<br><br>public int createUserWrong1(String name)  {<br>        TransactionStatus transactionStatus = platformTransactionManager.getTransaction(transactionDefinition);<br>        try {<br>            this.createUserPrivate(new UserEntity(name));<br>            platformTransactionManager.commit(transactionStatus);<br>        } catch (Exception ex) {<br>            platformTransactionManager.rollback(transactionStatus);<br>            log.error(&quot;create user failed because {}&quot;, ex.getMessage());<br>        }<br>        return userRepository.findByName(name).size();<br>    }","like_count":1},{"had_liked":false,"id":194999,"user_name":"Geek_538da7","can_delete":false,"product_type":"c1","uid":1915071,"ip_address":"","ucode":"6FA9A33BD9914D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lEHwYUoH248Ca8sdgmB0DHhYZV6HycDyia9BiaF0AK7JAYvhkztwugIBDpm3sKb8BGPicIwWyUHnicFLdbuJ4YtS3g/132","comment_is_top":false,"comment_ctime":1585126316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880093612","product_id":100047701,"comment_content":"自己使用Transactiom时只注意到aop代理问题，抛异常使事务生效。从没有考虑过事务传播，今天学到了很多知识","like_count":1},{"had_liked":false,"id":192604,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1584862992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879830288","product_id":100047701,"comment_content":"学习到了，这几个坑，","like_count":1},{"had_liked":false,"id":192524,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1584857180,"is_pvip":false,"discussion_count":4,"race_medal":1,"score":"5879824476","product_id":100047701,"comment_content":"工作中的业务场景没用到事务，但老师说的这些坑，我也不清楚，先学习了","like_count":1,"discussions":[{"author":{"id":1000037,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/65/f444ea39.jpg","nickname":"grandcool","note":"","ucode":"7545E76CE3FEFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213076,"discussion_content":"老铁，哪里都能看到你，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585048158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1000037,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/42/65/f444ea39.jpg","nickname":"grandcool","note":"","ucode":"7545E76CE3FEFC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213084,"discussion_content":"哈哈，专栏买的多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585049096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213076,"ip_address":""},"score":213084,"extra":""}]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232092,"discussion_content":"++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586852355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549364,"avatar":"","nickname":"Geek_3b1096","note":"","ucode":"A6BD92B79B3632","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217169,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585523564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191506,"user_name":"mz","can_delete":false,"product_type":"c1","uid":1003581,"ip_address":"","ucode":"1D714C23F78446","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/MlmSR4YXUfrNlZdMv7bv1ic64HaxxVKcVtaxjzhXCvNC4XByICCmYUTprhOESzIV8p59N6DnSJ7HywfvGr5nicgA/132","comment_is_top":false,"comment_ctime":1584778114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879745410","product_id":100047701,"comment_content":"看完了，我滚去检查代码了。😄","like_count":1},{"had_liked":false,"id":191228,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1584756662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879723958","product_id":100047701,"comment_content":"AspectJ 配合 lombok，需要使用 aspectj 插件的就地编织功能，大致会修改 pom.xml 配置如下：<br><br>                    &lt;showWeaveInfo&#47;&gt;<br>                    &lt;forceAjcCompile&gt;true&lt;&#47;forceAjcCompile&gt;<br>                    &lt;sources&#47;&gt;<br>                    &lt;weaveDirectories&gt;<br>                        &lt;weaveDirectory&gt;${project.build.directory}&#47;classes&lt;&#47;weaveDirectory&gt;<br>                    &lt;&#47;weaveDirectories&gt;","like_count":1},{"had_liked":false,"id":191194,"user_name":"傲宇","can_delete":false,"product_type":"c1","uid":1339446,"ip_address":"","ucode":"92BBE2C6494B26","user_header":"https://static001.geekbang.org/account/avatar/00/14/70/36/197927f5.jpg","comment_is_top":false,"comment_ctime":1584753620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879720916","product_id":100047701,"comment_content":"Spring事务的用法感觉已经是spring用户的常识性问题了，但奈何还是有人会犯。<br>我给出一个神奇的例子：我公司有一个同事，在controller调用多个service的事务方法，当后面的业务失败前面的业务方法自然就产生出不少的脏数据。","like_count":1},{"had_liked":false,"id":348866,"user_name":"豆豆大魔王","can_delete":false,"product_type":"c1","uid":1594276,"ip_address":"","ucode":"38D40A8AC9766A","user_header":"https://static001.geekbang.org/account/avatar/00/18/53/a4/8b233a80.jpg","comment_is_top":false,"comment_ctime":1655473281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655473281","product_id":100047701,"comment_content":"老师，同时配置了声明式事务和编程式事务会同时生效吗","like_count":0},{"had_liked":false,"id":346167,"user_name":"otakuhuang","can_delete":false,"product_type":"c1","uid":1541263,"ip_address":"","ucode":"283641975339AD","user_header":"https://static001.geekbang.org/account/avatar/00/17/84/8f/a305cc1e.jpg","comment_is_top":false,"comment_ctime":1652864099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652864099","product_id":100047701,"comment_content":"第一个思考题，主子用户那段错误代码我把 Spring Data JPA 改为 MyBatis 后，控制台输出如下：<br>```<br>Creating a new SqlSession<br>Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2a2f3033]<br>JDBC Connection [HikariProxyConnection@2142775818 wrapping conn0: url=jdbc:h2:mem:mybatis user=SA] will be managed by Spring<br>Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2a2f3033]<br>createMainUser finish<br>createSubUserWithExceptionWrong start<br>Fetched SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2a2f3033] from current transaction<br>Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2a2f3033]<br>Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2a2f3033]<br>Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2a2f3033]<br>createUserWrong failed, reason: invalid status<br>```<br>第 1、2 行，MyBatis 在连接时创建了一个叫做 SqlSession 的东东，然后事务注册到在这里面。倒数几行看到，由于出现了错误，SqlSession 整个被 rollback 了，所以无论是主还是子都没存到表里。<br>然后正确的：<br>```<br>Transaction synchronization suspending SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@28741757]<br>createSubUserWithExceptionRight start<br>Creating a new SqlSession<br>```<br>在子方法中又新建了一个 SqlSession，跟 JPA 的情况是一样的，所以这个 SqlSession 被 rollback 不会影响到主的 SqlSession。<br>但 SqlSession 是啥不是很懂，还要多学学。","like_count":0},{"had_liked":false,"id":333356,"user_name":"Geek_ac6cf1","can_delete":false,"product_type":"c1","uid":2902172,"ip_address":"","ucode":"C5ADBD4A580A03","user_header":"","comment_is_top":false,"comment_ctime":1644309371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644309371","product_id":100047701,"comment_content":"1.Transactional注解需要使用在pulic修饰的方法上才能生效，因为是通过AOP代理实现的。<br>2.Transactional事务存在默认的异常回滚情况，处理业务时需要考虑默认回滚情况是否包含自己的业务需求。<br>3.Transactional存在事务的传播性，需要根据业务调整Propagation属性。","like_count":0},{"had_liked":false,"id":322707,"user_name":"纵不朽","can_delete":false,"product_type":"c1","uid":1877862,"ip_address":"","ucode":"DB2CA2C46B2EF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","comment_is_top":false,"comment_ctime":1637561453,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637561453","product_id":100047701,"comment_content":"如果父类FService的公共A方法加了事务注解，子类SonService没有重写这个方法。实际运行时其他类把SonService注入进来，调用SonService.A(); 这样A方法处于事务中吗","like_count":0},{"had_liked":false,"id":316467,"user_name":"皇家救星","can_delete":false,"product_type":"c1","uid":1326106,"ip_address":"","ucode":"89F1274A3835FE","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/1a/1806ef25.jpg","comment_is_top":false,"comment_ctime":1634320133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634320133","product_id":100047701,"comment_content":"如果一个方法没写@Transactional 注解（类上也没写），调用时默认的事务传播是怎么样的呢？嵌套事务，还是新建事务，或者无事务？","like_count":0},{"had_liked":false,"id":313258,"user_name":"向博士后进军","can_delete":false,"product_type":"c1","uid":1903452,"ip_address":"","ucode":"CFDC3CF31C582D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0b/5c/9734702d.jpg","comment_is_top":false,"comment_ctime":1632356156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632356156","product_id":100047701,"comment_content":"老师，为什么在方法中try catch后，有时候不回滚呢","like_count":0},{"had_liked":false,"id":295790,"user_name":"麦德漂","can_delete":false,"product_type":"c1","uid":2088674,"ip_address":"","ucode":"18CF51FAF94949","user_header":"https://static001.geekbang.org/account/avatar/00/1f/de/e2/b42256d2.jpg","comment_is_top":false,"comment_ctime":1622599730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622599730","product_id":100047701,"comment_content":"主要还是是否被代理(拦截处理)的问题，被代理的话不要自己把异常吃掉，再一个就是传播机制的理解使用。","like_count":0},{"had_liked":false,"id":292391,"user_name":"新","can_delete":false,"product_type":"c1","uid":2104236,"ip_address":"","ucode":"A6B569A9A968ED","user_header":"https://static001.geekbang.org/account/avatar/00/20/1b/ac/ba2516f8.jpg","comment_is_top":false,"comment_ctime":1620803829,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620803829","product_id":100047701,"comment_content":"老师请问，事务方法里面用this调用当前Service的其它方法，事务方法和其它方法里都有Dao的插入方法，这样事务会生效么？我试过会生效，但是不太理解原因，this并不是代理对象，为什么仍然会生效呢？","like_count":0,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377942,"discussion_content":"如何验证事务生效的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622975156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284712,"user_name":"kyl","can_delete":false,"product_type":"c1","uid":1406090,"ip_address":"","ucode":"DBDFD0FEB5A135","user_header":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","comment_is_top":false,"comment_ctime":1616425709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616425709","product_id":100047701,"comment_content":"二刷又有新收获","like_count":0},{"had_liked":false,"id":271050,"user_name":"述为","can_delete":false,"product_type":"c1","uid":1238965,"ip_address":"","ucode":"E62AEC705AEDC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/b5/c08b71e1.jpg","comment_is_top":false,"comment_ctime":1609382440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609382440","product_id":100047701,"comment_content":"醍醐灌顶，感谢作者，入行近三年，原来一直都是在得过且过","like_count":0},{"had_liked":false,"id":269340,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1608617191,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1608617191","product_id":100047701,"comment_content":"老师 this为啥是当前对象呢？我理解应该是调用这个方法的对象，也就是运行的对象。感觉运行的对象是容器中的代理对象啊","like_count":0,"discussions":[{"author":{"id":1225974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/f6/e39d5af1.jpg","nickname":"钱米","note":"","ucode":"07AA44C6A40D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389103,"discussion_content":"this写在了被调用的方法内，所以说this是被调用方法所在类的这个对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629118994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368110,"discussion_content":" A类实例a被注入后，public方法被代理，用invoke调用，但是invoke中用到的this.method调用的其实是target的method方法。换而言之，动态代理永远只能代理一层方法，如果方法内还是this引导的方法则无法代理，但是如果是static的方法就不存在这个问题。\n\n这个是引用的别人说的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618567874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268631,"user_name":"李浩然","can_delete":false,"product_type":"c1","uid":2330739,"ip_address":"","ucode":"8467A210DC0B7A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJfyOHapA4aYyichD5mfPicyX9cxVfYLexuZhYoc7VQOrRFL7SvKxevmb0VorVkcRZVRd8pO5KF5niag/132","comment_is_top":false,"comment_ctime":1608279239,"is_pvip":false,"replies":[{"id":"97618","content":"帮忙多转发，大家都反馈收获不错，但是课程销量不高，希望更多人看到","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1608543477,"ip_address":"","comment_id":268631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608279239","product_id":100047701,"comment_content":"写的很好","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511993,"discussion_content":"帮忙多转发，大家都反馈收获不错，但是课程销量不高，希望更多人看到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608543477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268352,"user_name":"东谷大菠萝","can_delete":false,"product_type":"c1","uid":2007690,"ip_address":"","ucode":"057FF5437438D8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a2/8a/31fcaf13.jpg","comment_is_top":false,"comment_ctime":1608166903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608166903","product_id":100047701,"comment_content":"老师，那个子用户的操作能不能放在异步线程里呢？<br><br>1.执行主用户插入<br>2.异步插入子用户<br><br>如果主用户抛异常那么子用户不插入（符合业务逻辑），如果主用户插入成功，子用户在异步线程，不论成功与否都和主线程无关。","like_count":0},{"had_liked":false,"id":266120,"user_name":"浅、","can_delete":false,"product_type":"c1","uid":2133762,"ip_address":"","ucode":"9D359E82DA35EA","user_header":"https://static001.geekbang.org/account/avatar/00/20/8f/02/77e4c777.jpg","comment_is_top":false,"comment_ctime":1607176618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607176618","product_id":100047701,"comment_content":"毕业近一年半遇到事务的几个问题：<br>1.this调用<br>2.rollback only<br>3.独立和继承事务嵌套时因提交顺序不一致导致预期结果异常<br>4.集群环境下获取oracle行锁处理不当导致死锁<br>5.事务中使用的oracle存储过程中的commit导致事务提前被提交。<br>事务的问题平常不重视，等出了问题，从几个g的日志里面定位到问题点，就是对业务和架构的了解程度的考验了。","like_count":0},{"had_liked":false,"id":259801,"user_name":"Asura","can_delete":false,"product_type":"c1","uid":2004166,"ip_address":"","ucode":"E865D7FAFCF9B1","user_header":"https://static001.geekbang.org/account/avatar/00/1e/94/c6/a7c9f304.jpg","comment_is_top":false,"comment_ctime":1604840853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604840853","product_id":100047701,"comment_content":"目前有个需求 通过报表导入修改商品库存  我是用try catch 及Propagation.REQUIRES_NEW实现记录失败导入记录 并且手动回滚失败导入 成功的不变  如果商品很多这种for循环不断开启新事务会有什么问题呢 望老师解答","like_count":0},{"had_liked":false,"id":241195,"user_name":"Pluto","can_delete":false,"product_type":"c1","uid":1940113,"ip_address":"","ucode":"D541993BC94A45","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/91/3bd41811.jpg","comment_is_top":false,"comment_ctime":1597212947,"is_pvip":true,"replies":[{"id":"89127","content":"cglib也只能是app public，保持和动态代理一致性","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1597220511,"ip_address":"","comment_id":241195,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597212947","product_id":100047701,"comment_content":"老师，您举的第一个例子，这个类没有实现接口， 默认不是使用 cglib 来生成代理吗","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503671,"discussion_content":"cglib也只能是app public，保持和动态代理一致性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597220511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237463,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1595838306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595838306","product_id":100047701,"comment_content":"太强了。事务传播那里，还有课后第二个问题还没在实际中用到。<br>其他的刚好之前有遇到过。<br>还有事务注解中调用异步注解方法好像也会有问题，异步方法变为同步方法<br>AopContext.currentProxy()调用异步方法就能生效。","like_count":0},{"had_liked":false,"id":219901,"user_name":"tongzi","can_delete":false,"product_type":"c1","uid":2002210,"ip_address":"","ucode":"7349A6E42EDF17","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8d/22/0bf540be.jpg","comment_is_top":false,"comment_ctime":1590115743,"is_pvip":false,"replies":[{"id":"81170","content":"你的描述中场景描述的是表，解决描述的是方法，说实话我看不太懂你这个场景，这样的问题我很难回答，你可以做一个demo帖到github，给出具体的问题。如果你觉得这是事务隔离导致的可见性问题，那么为何不把这些操作都纳入一个事务呢？","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590119102,"ip_address":"","comment_id":219901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590115743","product_id":100047701,"comment_content":"【问题】<br>1、员工导入（新手机号），第一次会导入失败，再导入才会成功<br>【具体场景】<br>导入excel，解析成员工数据4条，先去注册生成t_user表，生成基本信息<br>然后在调用，bandCorp，和公司绑定，生成t_corp_user表<br>但是在调用bandCorp时，需要先去校验这个手机号，是否在t_user表生成数据<br>【解决】<br>发现由于事务注解引起的bug，importUserList（导入员工方法）加了事务注解，registerUser没有加事务注解<br>bandCorp加了事务注解，bandCorp传播级别为Propagation.REQUIRES_NEW，新开了事务<br>由于线上数据库为可重复读，qa数据库为读已提交，导致数据的不可见，校验失败<br><br>老师你好，感谢回答这个问题；<br>还有个疑问是，当时临时解决的办法是，将最外层的importUserList（导入员工方法事务去除）；<br>我们可不可以手动将importUserList方法的@Transactional，隔离级别设置读已提交，来解决这个问题？<br>这种业务场景怎么解决比较好？谢谢老师","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495984,"discussion_content":"你的描述中场景描述的是表，解决描述的是方法，说实话我看不太懂你这个场景，这样的问题我很难回答，你可以做一个demo帖到github，给出具体的问题。如果你觉得这是事务隔离导致的可见性问题，那么为何不把这些操作都纳入一个事务呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590119102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211897,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1588036683,"is_pvip":false,"replies":[{"id":"78735","content":"可以先根据日志排查一下，有问题的话帖一下完整的日志","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588040316,"ip_address":"","comment_id":211897,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1588036683","product_id":100047701,"comment_content":"    @Autowired(required=false)<br>    private UserMapper userMapper;<br><br>    @Autowired<br>    private UserService self;<br><br><br>    public int createUserWrong1(String name) {<br>        try {<br>            self.createUserPrivate(new User(name));<br>        } catch (Exception ex) {<br>            logger.error(&quot;create user failed because {}&quot;, ex.getMessage());<br>        }<br>        return userMapper.getByName(name).size();<br>    }<br><br>    @Transactional<br>    public void createUserPrivate(User user) {<br>        userMapper.addUser(user);<br>        if (user.getName().contains(&quot;test&quot;))<br>            throw new RuntimeException(&quot;invalid username!&quot;);<br>    }<br>----------------------------------------------<br>将this换位self了，但是事务依然没有生效，http:&#47;&#47;localhost:8080&#47;user&#47;wrong1?name=test访问后，数据库还是插入了test这条记录呢？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493392,"discussion_content":"可以先根据日志排查一下，有问题的话帖一下完整的日志","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588040316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250928,"discussion_content":"OK","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588050416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250771,"discussion_content":"搞定了，是特么idea的缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588039250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208222,"user_name":"盛夏流年","can_delete":false,"product_type":"c1","uid":1492295,"ip_address":"","ucode":"8D08F56BF95485","user_header":"https://static001.geekbang.org/account/avatar/00/16/c5/47/094ed41b.jpg","comment_is_top":false,"comment_ctime":1587304006,"is_pvip":true,"replies":[{"id":"77821","content":"如果对你有帮助欢迎点赞转发","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587347060,"ip_address":"","comment_id":208222,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587304006","product_id":100047701,"comment_content":"如果早一点看到这篇文章，就不会在一个项目里面连踩多个坑了……😂","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492380,"discussion_content":"如果对你有帮助欢迎点赞转发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587347060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207257,"user_name":"攻城狮MK","can_delete":false,"product_type":"c1","uid":1299404,"ip_address":"","ucode":"D418DEF46E0A04","user_header":"https://static001.geekbang.org/account/avatar/00/13/d3/cc/e3a54a6b.jpg","comment_is_top":false,"comment_ctime":1587038497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587038497","product_id":100047701,"comment_content":"补充一个点，如果某方法的定义不能使用jdk动态代理和cglib动态代理，依然可以从外层方法开启事务传播进来进行事务管理，比如非public+final修饰的方法，虽然很极端……","like_count":0},{"had_liked":false,"id":206380,"user_name":"HadesFX","can_delete":false,"product_type":"c1","uid":1052835,"ip_address":"","ucode":"221590B6D85266","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/a3/25e48834.jpg","comment_is_top":false,"comment_ctime":1586850452,"is_pvip":false,"replies":[{"id":"77107","content":"报什么错","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586863022,"ip_address":"","comment_id":206380,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1586850452","product_id":100047701,"comment_content":"注入self时，启动项目会报错，老师这是为什么那，貌似是无法注入本身","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491769,"discussion_content":"报什么错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586863022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250710,"discussion_content":"我倒是没有出错，但是事务依然没有生效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588036534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203158,"user_name":"Geek_mh","can_delete":false,"product_type":"c1","uid":1904660,"ip_address":"","ucode":"D3D72282535926","user_header":"","comment_is_top":false,"comment_ctime":1586145853,"is_pvip":false,"replies":[{"id":"75960","content":"默认肯定是本地事务，除非你使用其他库","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586174600,"ip_address":"","comment_id":203158,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586145853","product_id":100047701,"comment_content":"老师，想确认下，@Transactional  这对于多服务器集群模式的服务来说，是不适用的吧？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490785,"discussion_content":"默认肯定是本地事务，除非你使用其他库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586174600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203157,"user_name":"Geek_mh","can_delete":false,"product_type":"c1","uid":1904660,"ip_address":"","ucode":"D3D72282535926","user_header":"","comment_is_top":false,"comment_ctime":1586145702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586145702","product_id":100047701,"comment_content":"@Transactional这种Spring事务对于多台服务器集群模式的服务来说，应该不适用吧？","like_count":0},{"had_liked":false,"id":202724,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1586058213,"is_pvip":false,"replies":[{"id":"75748","content":"👍🏻","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586065180,"ip_address":"","comment_id":202724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586058213","product_id":100047701,"comment_content":"实战中之前也不太懂，现在学到了很多，回去检查代码了","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490662,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586065180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201548,"user_name":"另至","can_delete":false,"product_type":"c1","uid":1073651,"ip_address":"","ucode":"B2CAC3B17A2FA1","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f3/584d3b46.jpg","comment_is_top":false,"comment_ctime":1585802627,"is_pvip":false,"replies":[{"id":"75387","content":"哈哈，以后需要注意了","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585807494,"ip_address":"","comment_id":201548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585802627","product_id":100047701,"comment_content":"受益匪浅，我就是写个@Transactional就万事大吉的那个~","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490362,"discussion_content":"哈哈，以后需要注意了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585807494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199420,"user_name":"The One","can_delete":false,"product_type":"c1","uid":1319368,"ip_address":"","ucode":"D3438E31543332","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/c8/33828cfc.jpg","comment_is_top":false,"comment_ctime":1585488717,"is_pvip":true,"replies":[{"id":"74777","content":"好","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585527509,"ip_address":"","comment_id":199420,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585488717","product_id":100047701,"comment_content":"抱歉，打扰了，上个留言没注意到，subservice需要开启一个子事务，多读了两边明白了，打扰老师了。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489831,"discussion_content":"好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585527509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294251,"discussion_content":"很熟悉的名字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595840151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}