{"id":741037,"title":"第 13 章 Linux系统管理技巧(3)","content":"<h2 id=\"nav_point_276\">13.8 Linux系统日志</h2>\n<p>日志记录了系统每天发生的各种各样的事情，比如监测系统状况、排查系统故障等。你可以通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。日志的主要功能是审计和监测，还可以实时地监测系统状态，监测和追踪侵入者等。</p>\n<h3 id=\"nav_point_277\">13.8.1 /var/log/messages</h3>\n<p>阿铭常查看的日志文件为 /var/log/messages，它是核心系统日志文件，包含了系统启动时的引导消息，以及系统运行时的其他状态消息。I/O错误、网络错误和其他系统错误都会记录到这个文件中。其他信息，比如某个人的身份切换为root，以及用户自定义安装的软件（如Apache）的日志也会在这里列出。</p>\n<p>通常情况下，/var/log/messages是做故障诊断时首先要查看的文件。那你肯定会说，这么多日志都记录到这个文件中，如果服务器上有很多服务，岂不是这个文件很快就会写得很大？没错，但是系统有一个日志轮询的机制，每星期切换一个日志，切换后的日志名字类似于messages-20200301，会存放在 /var/log/ 目录下面，连同messages一共有5个这样的日志文件。这里的20200301就是日期，它表示日志切割的年月日。这是通过logrotate工具的控制来实现的，它的配置文件是 /etc/logrotate.conf（如果没有特殊需求，请不要修改这个配置文件），如下所示：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code># cat /etc/logrotate.conf\n# see \"man logrotate\" for details\n# rotate log files weekly\nweekly\n\n# keep 4 weeks worth of backlogs\nrotate 4\n\n# create new (empty) log files after rotating old ones\ncreate\n\n# use date as a suffix of the rotated file\ndateext\n\n# uncomment this if you want your log files compressed\n#compress\n\n# RPM packages drop log rotation information into this directory\ninclude /etc/logrotate.d\n\n# system-specific logs may be also be configured here.</code></pre>\n<p>这个配置文件里面的内容还是很容易明白的，都带有解释。除了logrotate.conf外，在 /etc/logrotate.d/下面还有一些子配置文件，如下所示：</p>\n<pre class=\"code-rows\"><code># ls /etc/logrotate.d\nbootlog btmp chrony dnf sssd syslog up2date wtmp.\n# cat /etc/logrotate.d/syslog\n/var/log/cron\n/var/log/maillog\n/var/log/messages\n/var/log/secure\n/var/log/spooler\n{\n missingok\n sharedscripts\n postrotate\n /usr/bin/systemctl kill -s HUP rsyslog.service &gt;/dev/null 2&gt;&amp;1 || true\n endscript\n}</code></pre>\n<p>其中syslog就是messages日志相关的配置文件了。/var/log/messages是由<code>rsyslogd</code>这个守护进程产生的，其服务为rsyslog.service，如果停止这个服务则系统不会产生 /var/log/messages，所以这个服务不要停止。<code>rsyslog</code>服务的配置文件为 /etc/rsyslog.conf，这个文件定义了日志的级别。若没有特殊需求，这个配置文件是不需要修改的，详细内容阿铭不再阐述。如果你感兴趣，请使用命令<code>man rsyslog.conf</code>获得更多关于它的信息。</p>\n<h3 id=\"nav_point_278\">13.8.2 <code>dmesg</code></h3>\n<p>除了关注/var/log/messages外，你还应该多关注一下<code>dmesg</code>这个命令，它可以显示硬件（如，磁盘、网卡等）相关信息。如果你的某个硬件有问题（比如网卡），用这个命令也是可以看到的：</p>\n<pre class=\"code-rows\"><code># dmesg |tail\n[ 8.671924] RAPL PMU: hw unit of domain pp0-core 2^-0 Joules\n[ 8.671925] RAPL PMU: hw unit of domain package 2^-0 Joules\n[ 8.671926] RAPL PMU: hw unit of domain dram 2^-0 Joules\n[ 8.671927] RAPL PMU: hw unit of domain pp1-gpu 2^-0 Joules\n[ 10.555690] NET: Registered protocol family 40\n[ 14.545496] IPv6: ADDRCONF(NETDEV_UP): ens33: link is not ready\n[ 14.551791] e1000: ens33 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: None\n[ 14.557466] IPv6: ADDRCONF(NETDEV_UP): ens33: link is not ready\n[ 14.557477] IPv6: ADDRCONF(NETDEV_CHANGE): ens33: link becomes ready\n[ 4202.922934] hrtimer: interrupt took 19983639 ns</code></pre>\n<h3 id=\"nav_point_279\">13.8.3 安全日志</h3>\n<p>关于安全方面的日志，阿铭简单介绍几个命令或者日志。</p>\n<p><code>last</code>命令用来查看登录Linux的历史信息，具体用法如下：</p>\n<pre class=\"code-rows\"><code># last |head\nroot pts/1 192.168.72.128 Fri Jun 26 17:41 still logged in\nroot pts/0 192.168.72.1 Fri Jun 26 15:46 still logged in\nreboot system boot 4.18.0-147.3.1.e Fri Jun 26 15:41 still running\nroot pts/3 192.168.72.1 Fri Jun 26 15:33 - 15:40 (00:06)\nroot pts/2 192.168.72.1 Fri Jun 26 15:30 - 15:40 (00:10)\nroot pts/0 192.168.72.1 Fri Jun 26 15:13 - 15:40 (00:27)\nroot pts/2 192.168.72.1 Fri Jun 26 15:07 - 15:13 (00:05)\nroot pts/1 192.168.72.1 Fri Jun 26 09:39 - 15:40 (06:01)\nroot pts/0 192.168.120.106 Fri Jun 26 08:54 - 15:08 (06:14)\nroot tty1 Fri Jun 26 08:33 - 15:40 (07:07)</code></pre>\n<p>上例中，从左至右依次为用户名称、登录终端、登录客户端IP、登录日期及时长。<code>last</code>命令输出的信息实际上是读取了二进制日志文件 /var/log/wtmp，只是这个文件不能直接使用cat、Vim、head、tail等工具查看。</p>\n<p>另外/var/log/secure也是和登录信息有关的日志文件。该日志文件记录验证和授权等方面的信息，比如ssh登录系统成功或者失败时，相关的信息都会记录在这个日志里。</p>\n<p>最后，阿铭建议你以后在日常的管理工作中，要养成多看日志的习惯，尤其是一些应用软件的日志。比如Nginx、MySQL、PHP（后续内容会讲到）等常用的软件，看它们的错误日志，可以帮助你排查问题以及监控它们的运行状况是否良好。</p>\n<h2 id=\"nav_point_280\">13.9 <code>xargs</code>与<code>exec</code></h2>\n<p><code>xargs</code>和<code>exec</code>可以实现相同的功能，<code>exec</code>主要是和<code>find</code>一起配合使用，而<code>xargs</code>比<code>exec</code>的用处更多。</p>\n<h3 id=\"nav_point_281\">13.9.1 <code>xargs</code>应用</h3>\n<p>阿铭平时也经常使用<code>xargs</code>，很方便。在前面的例子中阿铭曾经使用过这个命令，现在就来详细介绍一下：</p>\n<pre class=\"code-rows\"><code># echo \"121212121212\" &gt; 123.txt\n# ls 123.txt | xargs cat\n121212121212</code></pre>\n<p>上例表示把管道符前面的输出作为<code>xargs</code>后面的命令的输入。它的好处在于可以把原本两步或者多步才能完成的任务仅用一步完成。<code>xargs</code>常常和<code>find</code>命令一起使用，比如查找当前目录创建时间大于10天的文件，然后再删除，如下所示：</p>\n<pre class=\"code-rows\"><code># find . -mtime +10 |xargs rm</code></pre>\n<p>这种应用是最为常见的。<code>xargs</code>后面的<code>rm</code>也可以加选项，当为目录时，就需要加<code>-r</code>选项了。<code>xargs</code>还有一个神奇的功能，比如我现在要查找当前目录下所有后缀为.txt的文件，然后把这些文件变成.txt_bak。正常情况下必须写脚本才能实现，但是使用<code>xargs</code>就能一步完成，如下所示：</p>\n<pre class=\"code-rows\"><code># mkdir test\n# cd test\n# touch 1.txt 2.txt 3.txt 4.txt 5.txt\n# ls\n1.txt 2.txt 3.txt 4.txt 5.txt\n# ls *.txt |xargs -n1 -i{} mv {} {}_bak\n# ls\n1.txt_bak 2.txt_bak 3.txt_bak 4.txt_bak 5.txt_bak</code></pre>\n<p>上例中，<code>xargs -n1 -i{}</code>类似于<code>for</code>循环，<code>-n1</code>表示逐个对象进行处理，<code>-i{}</code>表示用<code>{}</code>取代前面的对象，<code>mv {} {}_bak</code>相当于<code>mv 1.txt 1.txt_bak</code>。刚开始接触这个命令时，你也许觉得难以理解，多练习一下就会熟悉了。阿铭建议你记住这个应用，非常实用。</p>\n<h3 id=\"nav_point_282\">13.9.2 <code>exec</code>应用</h3>\n<p>使用<code>find</code>命令时，阿铭经常使用<code>-exec</code>选项，它可以达到和<code>xargs</code>同样的效果。比如查找当前目录创建时间大于10天的文件并删除，如下所示：</p>\n<pre class=\"code-rows\"><code># find . -mtime +10 -exec rm -rf {} \\;</code></pre>\n<p>这个命令中也是用<code>{}</code>替代前面<code>find</code>出来的文件。后面的<code>\\</code>作为<code>;</code>的转义符，否则shell会把分号作为该行命令的结尾。</p>\n<p><code>-exec</code>同样可以实现上面批量更改文件名的需求，如下所示：</p>\n<pre class=\"code-rows\"><code># ls\n1.txt_bak 2.txt_bak 3.txt_bak 4.txt_bak 5.txt_bak\n# find ./*_bak -exec mv {} {}_bak \\;\n# ls\n1.txt_bak_bak 2.txt_bak_bak 3.txt_bak_bak 4.txt_bak_bak 5.txt_bak_bak</code></pre>\n<h2 id=\"nav_point_283\">13.10 screen工具介绍</h2>\n<p>有时我们要执行一个命令或者脚本，需要几小时甚至几天，在这个过程中，如果中途断网或出现其他意外情况怎么办？当然，你可以把命令或者脚本放到后台运行，不过也不保险。下面阿铭就介绍两种方法来避免这类状况发生。</p>\n<h3 id=\"nav_point_284\">13.10.1 使用<code>nohup</code></h3>\n<p>首先写一个sleep.sh脚本，然后把它放到后台执行，如下所示：</p>\n<pre class=\"code-rows\"><code># vim /usr/local/sbin/sleep.sh // 内容如下\n#! /bin/bash\nsleep 1000\n[root@localhost ~]# nohup sh /usr/local/sbin/sleep.sh &amp;\n[1] 19997</code></pre>\n<p>上例中，直接在sleep.sh后面加<code>&amp;</code>虽然可以在后台运行，但是当退出该终端时，这个脚本很有可能也会退出。所以在前面加上<code>nohup</code>就没有问题了，执行后会在当前目录下生成一个<code>nohup</code>的文件，该脚本所有相关的输出信息都会写到nohup文件里。它的作用就是防止进程意外中断。</p>\n<h3 id=\"nav_point_285\">13.10.2 screen工具的使用</h3>\n<p>简单来说，screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的SSH连接窗口一样。下面阿铭介绍screen的一个简单应用。</p>\n<p>首先打开一个会话，直接输入<code>screen</code>命令，然后回车进入screen会话窗口。如果你的系统中没有<code>screen</code>命令，请用命令<code>yum install -y epel-release; yum install -y screen</code>安装。它的使用也很简单，直接输入如下命令，就可以进入一个虚拟终端：</p>\n<pre class=\"code-rows\"><code># screen</code></pre>\n<p>接着查看已经打开的screen会话，如下所示：</p>\n<pre class=\"code-rows\"><code># screen -ls\nThere is a screen on:\n 5567.pts-1.aminglinux-123 (Attached)\n1 Socket in /run/screen/S-root.</code></pre>\n<p>然后按Ctrl+A键，再按d退出该screen会话（只是退出，并没有结束，结束screen会话要按Ctrl+D键或者输入<code>exit</code>）。退出后如果还想再次登录某个screen会话，可以使用命令<code>sreen -r [screen 编号]</code>，这个编号就是上例中那个5567。如果当前只打开了一个screen会话，后面的编号是可以省略的。当你有某个需要长时间运行的命令,或者脚本时，就打开一个screen会话，然后运行该任务，按Ctrl+A键，再按d退出会话。这样不影响终端窗口上的任何操作。</p>\n<h2 id=\"nav_point_286\">13.11 课后习题</h2>\n<p>(1) 如何查看当前Linux系统有几颗物理CPU以及每颗CPU的核数？</p>\n<p>(2) 查看系统负载有两个常用的命令，是哪两个？查看到的结果中<code>load average</code>后面的3个数值表示什么含义呢？</p>\n<p>(3) <code>vmstat r, b, si, so, bi, bo</code>这几列表示什么含义呢？</p>\n<p>(4) Linux系统里，你知道如何区分<code>buffer</code>和<code>cache</code>吗？</p>\n<p>(5) 使用<code>top</code>查看系统资源占用情况时，哪一列表示内存占用呢？</p>\n<p>(6) 如何实时查看网卡流量？如何查看历史网卡流量？</p>\n<p>(7) 如何查看当前系统都有哪些进程？</p>\n<p>(8) 用<code>ps</code>命令查看系统进程时，有一列为<code>STAT</code>，如果当前进程的<code>stat</code>为<code>Ss</code>表示什么含义？如果为<code>Z</code>又表示什么含义？</p>\n<p>(9) 如何查看系统都开启了哪些端口？</p>\n<p>(10) 如何查看网络连接状况？</p>\n<p>(11) 如果想修改IP，需要编辑哪个配置文件？修改完配置文件后，如何重启网卡使配置生效？</p>\n<p>(12) 能否给一个网卡配置多个IP？如果能，怎么配置？</p>\n<p>(13) 如何查看某个网卡是否连接着交换机？</p>\n<p>(14) 如何查看当前主机的主机名？如何修改主机名？如果想重启后修改依旧生效，需要修改哪个配置文件呢？</p>\n<p>(15) 设置DNS需要修改哪个配置文件？</p>\n<p>(16) 使用iptables写一条规则，把来源IP为192.168.1.11访问本机80端口的包拒绝。</p>\n<p>(17) 如何把iptable的规则保存到一个文件中做？如何恢复？</p>\n<p>(18) 如何备份某个用户的任务计划？</p>\n<p>(19) 任务计划格式中，前面5个数字分别表示什么含义？</p>\n<p>(20) 怎样才能把系统中不用的服务关掉？</p>\n<p>(21) 如何让某个服务（假如服务名为<code>nginx</code>）只在3、5两个运行级别开启（其他级别关闭）？</p>\n<p>(22) <code>rsync</code>的同步命令中，下面两种方式有什么不同呢？</p>\n<pre class=\"code-rows\"><code>rsync -av /dira/ ip:/dirb/\nrsync -av /dira/ ip::dirb</code></pre>\n<p>(23) 使用<code>rsync</code>同步数据时，如果要同步的源中有软连接，如何把软连接的目标文件或者目录同步？</p>\n<p>(24) 某个账号登录Linux后，系统会在哪些日志文件中记录相关信息？</p>\n<p>(25) 网卡或者硬盘有问题时，我们可以通过哪个命令查看相关信息？</p>\n<p>(26) 分别使用<code>xargs</code>和<code>exec，</code>把当前目录下所有后缀名为.txt的文件的权限修改为<code>777</code>。</p>\n<p>(27) 有一个脚本的运行时间可能超过2天，如何做才能使其不间断地运行，并随时观察该脚本运行时的输出信息？</p>\n<p>(28) 在Linux系统下如何按照下列要求抓包：只过滤出访问HTTP服务的、目标IP为192.168.0.111的包，一共抓1000个包，并且保存到1.cap文件中。</p>\n<p>(29) 使用<code>rsync</code>同步数据时，如何过滤出所有后缀名为.txt的文件？</p>\n<p>(30) 使用<code>rsync</code>同步数据时，如果目标文件比源文件还新，则忽略该文件，如何做？</p>\n<p>(31) 在Linux命令行模式下如果想要访问某个网站，并且该网站域名还没有解析，如何做？</p>\n<p>(32) 自定义解析域名时，我们可以编辑哪个文件？一个IP是否可以对应多个域名？一个域名z是否对应多个IP？</p>\n<p>(33) 我们可以使用哪个命令查看系统的历史负载（比如说两天前的）？</p>\n<p>(34) 在Linux下如何指定DNS服务器来解析某个域名？</p>\n<p>(35) 使用<code>rsync</code>同步数据时，假如我们采用的是ssh方式，并且目标机器的sshd端口并不是默认的22端口，那我们如何做？</p>\n<p>(36) <code>rsync</code>同步时，如何删除目标数据多出来的数据，即源上不存在，但目标却存在的文件或者目录？</p>\n<p>(37) 使用<code>free</code>查看内存使用情况时，哪个数值表示真正可用的内存量？</p>\n<p>(38) 有一天你突然发现公司网站访问速度变得非常慢，你该怎么办呢？（提示：服务器可以登录，你可以从系统负载和网卡流量入手。）</p>\n<p>(39) <code>rsync</code>使用服务模式时，如果我们指定了一个密码文件，那么这个密码文件的权限应该设置成多少？</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 13 章 Linux系统管理技巧(2)","id":741036},"right":{"article_title":"第 14 章 LNMP环境配置(1)","id":741038}},"comments":[]}