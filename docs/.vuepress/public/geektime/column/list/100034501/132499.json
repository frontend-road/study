{"id":132499,"title":"07 | 分支管理：Facebook的策略，适合我的团队吗？","content":"<p>你好，我是葛俊。今天，我来跟你聊聊研发过程中的Git代码分支管理和发布策略。</p><p>在前面两篇文章中，我们讨论了持续开发、持续集成和持续部署的整个上线流程。这条流水线针对的是分支，因此代码的分支管理便是基础。能否找到适合自己团队的分支管理策略，就是决定代码质量，以及发布顺畅的一个重要因素。</p><p>Facebook有几千名开发人员同时工作在一个大代码仓，每天会有一两千个代码提交入仓 ，但仍能顺利地进行开发，并发布高质量的产品。平心而论，Facebook的工程水平的确很高，与他们的分支管理息息相关。</p><p>所以在今天这篇文章中，我会先与你详细介绍Facebook的分支管理策略，以及背后的原因；然后，与你介绍其他的常见分支管理策略；最后，向你推荐如何选择适合自己的分支策略。</p><h2>Facebook的分支管理和发布策略</h2><p>Facebook的分支管理策略，是一种基于主干的开发方式，也叫作Trunk-based。在这种方式中，用于开发的长期分支只有一个，而用于发布的分支可以有多个。</p><p>首先，我们先看看这个长期存在的开发分支。</p><h3>开发分支</h3><p>这个长期存在的开发分支，一般被叫作trunk或者master。为方便讨论，我们统一称它为master。也就是说，所有的开发人员基于master分支进行开发，提交也直接push到这个分支上。</p><!-- [[[read_end]]] --><p>在主干开发方式下，根据是否允许存在短期的功能分支（Feature Branch)，又分为两个子类别：主干开发有功能分支和主干开发无功能分支。Facebook做得比较纯粹，在主代码仓中，基本上禁止功能分支。</p><p>另外，在代码合并回master的时候，又有rebase和merge两种选择。Facebook选择的是rebase（关于这样选择的原因，我会在后面与你详细介绍）。所以，Facebook的整个开发模式非常简单，步骤大概如下。</p><p>第一步，获取最新代码。</p><pre><code>git checkout master\ngit fetch\ngit rebase origin/master\n</code></pre><p>第二步，本地开发，然后执行</p><pre><code>git add \ngit commit\n</code></pre><p>产生本地提交。</p><p>第三步，推送到主代码仓的master分支。</p><pre><code>git fetch\ngit rebase origin/master\ngit push\n</code></pre><p>在rebase的时候，如果有冲突就先解决冲突，然后使用</p><pre><code>git add\ngit rebase --continue\n</code></pre><p>更新自己的提交，最后重复步骤3，也就是重新尝试推送代码到主代码仓。</p><p>看到这里，你可能对这种简单的分支方式有以下两个问题。</p><p><strong>问题1</strong>：如果功能比较大，一个代码提交不合适，怎么办？</p><p>解决办法：这种情况下，第二步本地开发的时候可以产生多个提交，最后在第三步一次性推送到主仓的master分支。</p><p><strong>问题2</strong>：如果需要多人协同一个较大的功能，怎么办？</p><p>解决办法：这种情况下，Facebook采用的是使用代码原子性、功能开关、API版本等方法，让开发人员把功能拆小尽快合并到master分支。</p><p>比如，一个后端开发者和一个前端开发者合作一个功能，他们的互动涉及10个API接口，其中两个是在已有接口上做改动，另外8个是新增接口。</p><p>这两名开发者的合作方式是：</p><ul>\n<li>第一，后端开发者把这10个接口的编码工作，以至少10个单独的提交来完成。强调“至少”，是因为有些接口的编码工作可能比较大，需要不止一个提交来完成。</li>\n<li>第二，对已有API的改动，如果只涉及增加API参数，情况就比较简单，只需要在现有API上进行。但如果牵涉到删除或者修改API参数，就要给这个API添加一个新版本，避免被旧版本阻塞入库。</li>\n<li>第三，在实现功能的过程中，如果某个功能暂时还不能暴露给用户，就用功能开关把它关闭。</li>\n</ul><p>这就保证了，在不使用功能分支的情况下，这两个开发者可以直接在master分支上合作，并能够不被阻塞地尽快提交代码。当然了，这种合作方式，可以扩展到更多的开发者。</p><p>以上就是开发分支的情况。接下来，我再与你讲述发布分支和策略。</p><h3>发布分支</h3><p>基于主干开发模式中，在需要发布的时候会从master拉出一条发布分支，进行测试、稳定。在发布分支发现问题后，先在master上修复，然后cherry-pick到发布分支上。分支上线之后，如果需要长期存在，比如产品线性质的产品，就保留。如果不需要长期存在，比如SaaS产品，就直接删除。Facebook采用的方式是后者。</p><p>具体来说，部署包括3种：有每周一次的全量代码部署、每天两次的日部署，以及每天不定次数的热修复部署。日部署和热修复部署类似，我们下面详细介绍周部署和热修复部署。</p><p>每次<strong>周部署</strong>代码的时候，流程如下所示。</p><p>第一步，从master上拉出一个发布分支。</p><pre><code>git checkout -b release-date-* origin/master\n</code></pre><p>第二步，在发布分支进行各种验证。</p><p>第三步，如果验证发现问题，开发者提交代码到master，然后用cherry-pick命令把修复合并到发布分支上：</p><pre><code>git cherry-pick &lt;fix-sha1&gt; # fix-sha1 是修复提交的commit ID\n</code></pre><p>接着继续回到第二步验证。</p><p>验证通过就发布当前分支。这个发布分支就成为当前生产线上运行版本对应的分支，我们称之为当前生产分支，同时将上一次发布时使用的生产分支存档或者删除。</p><p>在进行<strong>热修复部署</strong>时，从当前生产分支中拉出一个热修复分支，进行验证和修复。具体步骤为：</p><p>第一步，拉出一个热修复分支。</p><pre><code>git checkout -b hotfix-date-* release-date-*\n</code></pre><p>第二步，开发人员提交热修复到master，然后cherry-pick修复提交到热修复分支上。</p><pre><code>git cherry-pick &lt;fix-sha1&gt;\n</code></pre><p>第三步，进行各种验证。</p><p>第四步，验证中发现问题，回到第二步重新修复验证。验证通过就发布当前热修复分支，同时将这个热修复分支设置为当前的生产分支，后面如果有新的热修复，就从这个分支拉取。</p><p>这里有一张图片，描述了每周五拉取周部署分支，以及从周部署分支上拉取分支进行热修复部署的流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/58/0c79327f4a163fd800984346a7e76258.jpg?wh=2474*1344\" alt=\"\"></p><center><span class=\"reference\">图1 Facebook的代码分支管理和部署流程</span></center><p>以上就是Facebook的代码分支管理和部署流程。</p><p><strong>需要注意的是</strong>，这里描述的部署流程是Facebook转到持续部署之前采用的。但考虑到非常多的公司还没有达到持续部署的成熟度，所以这种持续交付的方式，对我们更有参考价值。</p><h2>Facebook分支管理策略的背后原因</h2><p>Facebook采用主干分支模式，最大的好处是可以把持续集成、持续交付做到极致，从而尽量提高master分支的代码质量。</p><p>解释这一好处之前，我想请你先看看下面这3个措施有什么共同效果：</p><ul>\n<li>几千名开发者同时工作在同一条主干；</li>\n<li>不使用功能分支，直接在master上开发；</li>\n<li>必须要使用rebase才能入库，不能使用merge。</li>\n</ul><p>其实，它们的共同效果就是：必须尽早将代码合入master分支，否则就需要花费相当长的时间去解决合并冲突。所以每个开发人员，都会尽量把代码进行原子性拆分，写好一部分就赶快合并入库。</p><p>我曾经有过一个有趣的经历。一天下午，我和旁边的同事在改动同一个API接口，实现两个不同的功能。我们关系很好，也都清楚对方在做什么，于是一边开玩笑一边像在比赛一样，看谁先写好代码完成自测入主库。结果是我赢了，他后来花了十分钟很小心地去解决冲突。</p><p>Facebook使用主干分支模式的好处，主要可以总结为以下两点：</p><ul>\n<li>能够<strong>促进开发人员把代码频繁入主仓进行集成检验</strong>。而这，正是持续集成的精髓。与之相对应的是，很多20名开发者的小团队，采用的也是共主干开发方式，但使用了功能分支，让大家在功能分支上进行开发，之后再merge回主仓。结果是，大家常常拖到产品上线前才把功能分支合并回主干，导致最后关头出现大量问题。</li>\n<li>能够<strong>确保线性的代码提交历史</strong>，给流程自动化提供最大方便。不要小看“线性”，它对自动化定位问题意义非凡，使得我们可以从当前有问题的提交回溯，找到历史上第一个有问题的提交。更棒的是，我们还可以使用折半查找（也叫作二分查找）的办法，用O(LogN)的时间找到那个有问题的提交。</li>\n</ul><p>比如，在一个代码仓中，有C000 ~ C120 的线性提交历史。我们知道一个测试在提交C100处都是通过的，但是在C120出了问题。我们可以依次checkout C101、C102，直到C120，每次checkout之后运行测试，总能找到第一个让测试失败的提交。</p><p>或者更进一步，我们可以先尝试C100和C120中间的提交C110。如果测试在那里通过了，证明问题提交在C111和C120之间，继续检查C115；否则就证明问题提交在C101和C110之间，继续检查C105。这就大大减少了检查次数。而这，正是软件算法中经典的折半查找。</p><p>事实上，Git本身就提供了一个命令git bisect支持折半查找。比如，在刚才的例子中，如果运行测试的命令行是 runtest.sh。那么，我们可以使用下面的命令来自动化这个定位流程：</p><pre><code>&gt; git checkout master # 使用最新提交的代码 \n&gt; git bisect start\n&gt; git bisect bad HEAD # 告知 git bisect，当前commit是有问题的提交\n&gt; git bisect good C100 # 告知 git bisect，C100是没有问题的提交\n&gt; git bisect run bash runtest.sh # 开始运行自动化折半查找\n...\nCxxx is the first bad commit  # 查找到第一个问题提交\n...\nbisect run success\n&gt; git bisect reset # 结束git bisect。回到初始的HEAD\n</code></pre><p>很方便吧。而如果历史不是线性的，也就是说如果提交使用了merge，那么我们就不能方便地定位出第一个问题提交了，更别说是折半查找了。</p><p>这种快速定位问题的能力，可以给CI/CD带来巨大好处。在持续交付过程中，我们常常没有足够的资源对每一个提交都进行检查。比如前面提过，Facebook的持续交付流水线就是每隔一段时间，对代码仓最后一个提交运行流水线的检查。如果发现问题，就可以通过上面这种方法自动化地找到问题提交，并自动产生Bug工单，分配给提交者。</p><h2>其他主要分支方式</h2><p>除了主干开发的分支管理策略，还有3种常用方式：</p><ul>\n<li><a href=\"https://nvie.com/posts/a-successful-git-branching-model/\">Git-flow</a>工作流；</li>\n<li><a href=\"https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-forking.md\">Fork-merge</a> 工作流；</li>\n<li>灵活的<a href=\"https://help.aliyun.com/document_detail/59315.html?spm=a2c4g.11186623.2.14.1fe1341epVSgj0\">功能分支组合成发布分支</a>。</li>\n</ul><p>我在文中给出了链接供你参考。接下来，我们具体看看这几种方式。</p><h3>Git-flow 工作流</h3><p>Git-flow工作流有两个长期分支：一个是master，包含可以部署到生产环境的代码；另一个是develop，是一个用来集成代码的分支，开发新功能、新发布，都从develop里拉分支。此外，它还有3种短期分支，分别是新功能分支、发布分支、热修复分支，根据需要创建，当完成了自己的任务后就会被删除。</p><p>Git-flow工作流的特点是规定很清晰，对各种开发任务都有明确的规定和步骤。比如：</p><ul>\n<li>开发新功能时，从develop分支拉出一个前缀为feature-的新功能分支，在本地开发，并推送到远端中心仓库，完成之后合并入develop分支，并删除该功能分支。</li>\n<li>发布新版本时，从develop分支拉出一个前缀为release-的发布分支，部署到测试、类生产等环境进行验证。发现问题后直接在发布分支上修复，测试通过之后，把release分支合并到master和develop分支。在master分支上打tag，并删除该发布分支。</li>\n</ul><p>这种工作流，在前几年非常流行。它的好处是流程清晰，但缺点是：</p><ul>\n<li>流程复杂，学习成本高。</li>\n<li>容易出错，容易出现忘记合并到某个分支的情况。不过可以使用脚本自动化来解决。</li>\n<li>不方便进行持续集成。</li>\n<li>有太多的代码分支合并，解决冲突成本比较高。</li>\n</ul><h3>Fork-merge</h3><p>Fork-merge是在GitHub、GitLab流行之后产生的，具体做法是：每个开发人员在代码仓服务器上有一个“个人”代码仓。这个“个人”代码仓实际上就是主代码仓的一个clone。开发者对主代码仓贡献代码的步骤如下：</p><ol>\n<li>开发者产生一个主代码仓的fork，成为自己的个人代码仓；</li>\n<li>开发者在本地clone个人代码仓；</li>\n<li>开发者在本地开发，并把代码推送到自己的个人代码仓；</li>\n<li>开发者通过web界面，向主代码仓作者提出Pull request；</li>\n<li>主代码仓的管理者在自己的开发机器上，取得开发者的提交，验证通过之后再推送到主代码仓。</li>\n</ol><p>看起来步骤繁琐，但实际上和主干开发方式很相似，也有一个长期的开发分支，就是主仓的master分支。不同之处在于，它提供了一种对主分支更严格、更方便的权限管理方式，即只有主仓管理者有权限推送代码。同时，主仓不需要有功能分支，功能分支可以存在fork仓中。所以，主仓干净便于管理。</p><p>这种方式对开源项目比较方便，但缺点是步骤繁琐，不太适用于公司内部。</p><h3>灵活的功能分支组合成发布分支</h3><p>除了上述方式之外，还有一种非常灵活，但对工具自动化要求很高的分支方式，即基于功能分支灵活产生发布分支的方式。这种方式的典型代表是阿里云效的“分支模式”。</p><p>具体方法是大量使用工具对分支的管理进行自动化，开发人员在web界面上自助产生针对功能的分支。编码完成后，通过web界面对分支组合、验证，并上线，上线之后分支再自动合入主库。</p><p>这种方式的好处是：</p><ul>\n<li>方便基于功能进行开发。也就是说，开发者可以针对每个功能产生一个分支进行开发。</li>\n<li>灵活，也就是能够方便地对功能进行组合，发布到对应环境上测试。出了问题，可以方便地添加或者删除功能。</li>\n</ul><p>但这种方式的问题是，对工具的依赖比较高，没有一个系统的工具来自动化的话，基本做不起来。另外，这种方式会大量封装底层的实现，使开发人员不知道底层发生的问题，一旦出现问题就不太容易解决。</p><h2>哪一种分支管理策略更适合我的团队呢？</h2><p>要找到适合自己团队的分支管理策略，我们先来对比下上面提到的几种方式的优缺点吧。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/2e/ccdcf41da5c0f016e90cb7d38f178e2e.jpg?wh=2474*1126\" alt=\"\"></p><center><span class=\"reference\">图2 几种常用的代码分支管理策略对比</span></center><p>另外，要找到合适的代码分支管理策略，你还可以参考以下3个问题，根据答案帮助你进行选择。</p><p>问题1：如果提供功能分支让成员共享，在哪里建立这个分支？</p><blockquote>\n<p>如果团队不大，可以允许在主仓创建功能分支，不过注意定时删除不用的分支，避免影响Git的性能。如果团队比较大，可以考虑使用Fork-merge方式，在上面提到的“个人代码仓”里创建功能分支，从而避免污染主仓。</p>\n</blockquote><p>问题2：要不要使用Merge Commit?</p><blockquote>\n<p>代码在合并到主干的时候，可以选择rebase或者merge。使用rebase的好处是上边提到的方便定位问题。而使用merge的好处是，可以清晰地在分支里看到一个功能的所有提交，不像在rebase中，一个功能的提交往往是分散的。</p>\n</blockquote><p>问题3：团队成熟度如何?</p><blockquote>\n<p>单分支开发集成早，质量比较好，但对团队成员和流程自动化要求高。所以，如果你的团队比较小，或者比较成熟的话，可以考虑使用单分支，否则可以选择多分支开发模式，但要想办法把集成提前，同时逐步向单主干分支过渡。</p>\n</blockquote><p><strong>总结来说，尽量减少长期分支的数量，代码尽早合并回主仓，方便使用CI/CD等方法保证主仓代码提交的质量，是选择分支策略的基本出发点。</strong></p><h2>小结</h2><p>首先，我分享了Facebook使用的单主干开发分支，以及通过临时发布分支进行部署的分支管理策略和部署方式。然后，我与你介绍了几种常见的分支管理策略，并给出了推荐的选择方法。</p><p>在Facebook工作时，我们一直使用这种主干分支开发方式。它强迫我们把代码进行原子化，尽量确保每一个提交都尽快合入master，并保证代码质量。一开始我不是很习惯，但习惯后我发现它的确很棒。</p><p>首先，因为你和你的合作开发者都需要尽快把代码拆小、入仓，这就帮助我们提高了功能模块化的能力。其次，因为master里面的提交一般都比较健康，并且是比较新的代码，所以很少会被不稳定的因素阻塞。最后，线性提交历史对开发者的日常工作也很有帮助。我们在开发的时候，常常会碰到一个本来工作得好好的API，在拉取到最新代码之后出现了问题。这时，我就可以使用这种方法找到第一个造成问题的提交，从而方便定位和解决问题。</p><p>一个流程设计、实施得好，对产品来说可以提高质量，对团队来说可以提高效能，对个人来说可以帮助成长。这就是一举三得。</p><h2>思考题</h2><ol>\n<li>产品线性质的产品开发，以及SaaS产品开发，在选择分支管理策略时有不同的考量。你觉得哪种分支管理方式更适合二者呢？</li>\n<li>你知道trunk-based里面“trunk”的意思吗？</li>\n</ol><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再见！</p>","neighbors":{"left":{"article_title":"06 | 代码入库到产品上线：Facebook如何使用CI/CD满足业务要求？","id":131673},"right":{"article_title":"08 | DevOps、SRE的共性：应用全栈思路打通开发和运维","id":132539}},"comments":[{"had_liked":false,"id":133123,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1568367380,"is_pvip":true,"replies":[{"id":"50982","content":"Git的却很强大，很方便。确实也需要投入时间学习。我2010年初始Git的时候，找一个Git老手讨教，他非常热心地给我讲了一个半小时，我还是迷迷糊糊。不过现在想起来还是很感激他 ：）<br><br>这个链接是一个有趣的图形化Git学习工具。你可以看看：http:&#47;&#47;git-school.github.io&#47;visualizing-git&#47;#cherry-pick","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1568422533,"ip_address":"","comment_id":133123,"utype":1}],"discussion_count":2,"race_medal":1,"score":"57402942228","product_id":100034501,"comment_content":"看完这篇后，最大的感受就是Git是个宝库，之前对它的使用还停留在表面，我要去找本书系统学习一下。","like_count":14,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467261,"discussion_content":"Git的却很强大，很方便。确实也需要投入时间学习。我2010年初始Git的时候，找一个Git老手讨教，他非常热心地给我讲了一个半小时，我还是迷迷糊糊。不过现在想起来还是很感激他 ：）\n\n这个链接是一个有趣的图形化Git学习工具。你可以看看：http://git-school.github.io/visualizing-git/#cherry-pick","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568422533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1044785,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f1/31/5001390b.jpg","nickname":"Lonely绿豆蛙","note":"","ucode":"0862179B614974","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318572,"discussion_content":"不会说的是蒋鑫老师吧~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603783438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132814,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1568245936,"is_pvip":false,"replies":[{"id":"50889","content":"是统一管理的。这个系统叫GateKeeper。推荐你看看这个，有很多细节：https:&#47;&#47;www.quora.com&#47;How-does-Facebooks-Gatekeeper-service-work","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1568253203,"ip_address":"","comment_id":132814,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31633017008","product_id":100034501,"comment_content":"想问一下老师，Facebook的开关是配置系统统一管理的吧？那么多功能分支，都靠开关管理，如何做好多个配置开关有效快速管理？","like_count":7,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467132,"discussion_content":"是统一管理的。这个系统叫GateKeeper。推荐你看看这个，有很多细节：https://www.quora.com/How-does-Facebooks-Gatekeeper-service-work","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568253203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024486,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","nickname":"旭东(Frank)","note":"","ucode":"176FA629800062","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19866,"discussion_content":"这个地址还被墙了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569232513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1504934,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f6/a6/19ff9596.jpg","nickname":"猫少","note":"","ucode":"84A96E797EEF7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1024486,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","nickname":"旭东(Frank)","note":"","ucode":"176FA629800062","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38264,"discussion_content":"东哥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571753762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":19866,"ip_address":""},"score":38264,"extra":""}]}]},{"had_liked":false,"id":131612,"user_name":"phobal","can_delete":false,"product_type":"c1","uid":1007533,"ip_address":"","ucode":"A8CF6D7817D985","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/ad/9c310977.jpg","comment_is_top":false,"comment_ctime":1567825226,"is_pvip":false,"replies":[{"id":"50267","content":"如果B的功能还没有准备好给用户使用，可以使用功能开关隐藏。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1567829225,"ip_address":"","comment_id":131612,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23042661706","product_id":100034501,"comment_content":"像 Facebook 这种主干（master）开发模式，每个人的代码每天都会合入到 master，实际中经常会有这样的情况：A、B 两个 feature 同时在进行，但上线时间不同，A 先上，那基于这种模式，A 上的话就会带入 B 的代码，难道 A 上的时候再基于上一个稳定版本 tag 再 cheery-pick A 的所有功能代码到测试分支？","like_count":5,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466537,"discussion_content":"如果B的功能还没有准备好给用户使用，可以使用功能开关隐藏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567829225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131387,"user_name":"Johnson","can_delete":false,"product_type":"c1","uid":1225037,"ip_address":"","ucode":"55B582953E49F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/b1/4d/10c75b34.jpg","comment_is_top":false,"comment_ctime":1567735720,"is_pvip":false,"replies":[{"id":"49940","content":"&gt; 听起来trunk-base这种方式基本和集中式的svn和perforce是一个思路，那疑问就是为啥不直接用perforce,收费？学习成本？需要额外的运维投入？<br><br>非常好的问题。我觉得至少有以下几个好处：<br>1. 分布式的好处，使得开发人员在本地操作速度快。<br>2. 分布式的另一个好处。虽然我在文章中没有写，使用的频率也不是很高，但是开发人员的个人repo是可以互相推送代码进行合作的，不经过统一的中央repo。<br>3. Git开源。事实上，2015年左右，Facebook每天有太多的commits，所以Git的性能逐渐不能满足。于是Facebook尝试修改Git的代码。不过因为Git社区觉得Git代码仓不应该超级大，所以没有合作成功。最终Facebook从Git转向了Mercurial（hg）。ht是另一个类似Git的分布式代码仓管理系统。hg也是开源，Facebook通过提高hg解决的commits太多的问题。这就是使用开源的好处。这里强调一下，虽然Facebook从Git转到了hg，但是今天文章中讨论的分支策略对hg也是有效的。<br>4. Git免费<br>5. 在进行周部署，日部署、热修复部署中各种分支处理，Git的比svn，perforce强大。这一点因为我对Perfoce不是特别熟悉，不是100%确定。<br><br>&gt; trunk-base针对pull request的方式还有一个疑问，怎么做pre checkin的code review来控制入库代码的质量？<br>我能想到的好像还是集中式的那种checkin必须使用固定的工具，这个工具会去自动获取这个提交的code review，如果没有就不允许checkin.<br><br>这个的确是一种方式。比如使用Phabricator进行Code Review的时候，Phabricator对外提供接口。在开发者尝试push代码到Git Server的时候，Git Server可以会去Phabricator检查用户的commit有没有通过Code Review。<br><br>另外一个方式是让代码审查工具，比如Phabricator，Gerrit，在Code Review通过之后，代替开发者Push commit。<br><br>","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1567785209,"ip_address":"","comment_id":131387,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23042572200","product_id":100034501,"comment_content":"听起来trunk-base这种方式基本和集中式的svn和perforce是一个思路，那疑问就是为啥不直接用perforce,收费？学习成本？需要额外的运维投入？<br>trunk-base针对pull request的方式还有一个疑问，怎么做pre checkin的code review来控制入库代码的质量？<br>我能想到的好像还是集中式的那种checkin必须使用固定的工具，这个工具会去自动获取这个提交的code review，如果没有就不允许checkin.","like_count":5,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466427,"discussion_content":"&amp;gt; 听起来trunk-base这种方式基本和集中式的svn和perforce是一个思路，那疑问就是为啥不直接用perforce,收费？学习成本？需要额外的运维投入？\n\n非常好的问题。我觉得至少有以下几个好处：\n1. 分布式的好处，使得开发人员在本地操作速度快。\n2. 分布式的另一个好处。虽然我在文章中没有写，使用的频率也不是很高，但是开发人员的个人repo是可以互相推送代码进行合作的，不经过统一的中央repo。\n3. Git开源。事实上，2015年左右，Facebook每天有太多的commits，所以Git的性能逐渐不能满足。于是Facebook尝试修改Git的代码。不过因为Git社区觉得Git代码仓不应该超级大，所以没有合作成功。最终Facebook从Git转向了Mercurial（hg）。ht是另一个类似Git的分布式代码仓管理系统。hg也是开源，Facebook通过提高hg解决的commits太多的问题。这就是使用开源的好处。这里强调一下，虽然Facebook从Git转到了hg，但是今天文章中讨论的分支策略对hg也是有效的。\n4. Git免费\n5. 在进行周部署，日部署、热修复部署中各种分支处理，Git的比svn，perforce强大。这一点因为我对Perfoce不是特别熟悉，不是100%确定。\n\n&amp;gt; trunk-base针对pull request的方式还有一个疑问，怎么做pre checkin的code review来控制入库代码的质量？\n我能想到的好像还是集中式的那种checkin必须使用固定的工具，这个工具会去自动获取这个提交的code review，如果没有就不允许checkin.\n\n这个的确是一种方式。比如使用Phabricator进行Code Review的时候，Phabricator对外提供接口。在开发者尝试push代码到Git Server的时候，Git Server可以会去Phabricator检查用户的commit有没有通过Code Review。\n\n另外一个方式是让代码审查工具，比如Phabricator，Gerrit，在Code Review通过之后，代替开发者Push commit。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567785209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225037,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b1/4d/10c75b34.jpg","nickname":"Johnson","note":"","ucode":"55B582953E49F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8099,"discussion_content":"没有回答么？欢迎大家踊跃交流想法，不知道各家都是怎么做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567777745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1225037,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b1/4d/10c75b34.jpg","nickname":"Johnson","note":"","ucode":"55B582953E49F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8124,"discussion_content":"欢迎大家讨论！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567785386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8099,"ip_address":""},"score":8124,"extra":""},{"author":{"id":1044785,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f1/31/5001390b.jpg","nickname":"Lonely绿豆蛙","note":"","ucode":"0862179B614974","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":318480,"discussion_content":"阿里为最新发布的Git 2.29贡献的特性中，就有一部分可以支持集中式工作流，希望老师分析一下~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603763531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8124,"ip_address":""},"score":318480,"extra":""}]}]},{"had_liked":false,"id":166351,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1567144,"ip_address":"","ucode":"3FB96CE1640C8D","user_header":"https://static001.geekbang.org/account/avatar/00/17/e9/a8/8fc92fcc.jpg","comment_is_top":false,"comment_ctime":1577438383,"is_pvip":false,"replies":[{"id":"65397","content":"几个标准:<br>1. 提交不要超过一个功能。如果是bug fix的话可以有几个类似的fix放到一起（因为提交太小也不好）。<br>2. 如果功能较大，提交应该是一个功能的子功能<br>3. 这个提交需要能够入master库后不会break master。也就是说，该提交在入master之后，上可以从这个提交的位置发布一个产品。当然可能会有Bug，但是不能出现功能不能用的情况。要么功能实现完成，要么用户看不到。<br><br>另外大小上来说，并没有严格规定多少文件多少行。但是要让代码审查者审查起来不能太困难。<br>","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1578148244,"ip_address":"","comment_id":166351,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14462340271","product_id":100034501,"comment_content":"facebook 的原子化提交这块，开发是以什么标准拆分，确保原子性的。老师能否帮忙介绍下。谢谢","like_count":3,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479489,"discussion_content":"几个标准:\n1. 提交不要超过一个功能。如果是bug fix的话可以有几个类似的fix放到一起（因为提交太小也不好）。\n2. 如果功能较大，提交应该是一个功能的子功能\n3. 这个提交需要能够入master库后不会break master。也就是说，该提交在入master之后，上可以从这个提交的位置发布一个产品。当然可能会有Bug，但是不能出现功能不能用的情况。要么功能实现完成，要么用户看不到。\n\n另外大小上来说，并没有严格规定多少文件多少行。但是要让代码审查者审查起来不能太困难。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578148244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133126,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1568370078,"is_pvip":true,"replies":[{"id":"50981","content":"👍👍👍","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1568421818,"ip_address":"","comment_id":133126,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14453271966","product_id":100034501,"comment_content":"全栈是趋势，这是不可避免的。<br>全栈不意味着所有事情都亲力亲为，从个人发展的角度来说，肯定还是需要先在某个方向上做专做精，然后对项目涉及的其他方面由浅入深的逐渐熟悉。在读圣贤书的同时，也要知窗外事。","like_count":3,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467263,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568421818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175284,"user_name":"GeekJ","can_delete":false,"product_type":"c1","uid":1681569,"ip_address":"","ucode":"834F26FC04F8B1","user_header":"","comment_is_top":false,"comment_ctime":1580642520,"is_pvip":false,"replies":[{"id":"69038","content":"1&#47; 保证cherry-pick质量保证有以下几条：<br><br>1. cherry-pick需要把依赖提交链一起cherry-pick。比如需要cherry-pick 提交A改动了文件f。A之前的提交B改动了f的相同部分。那么，B也要被遗弃cherry-pick。同时，B的依赖提交也要cherry-pick。<br>2. master上提交的原子性。这样可以保证上述的依赖提交可以相对安全的cherry-pick而不会产生未完成的功能暴露给用户<br>3. 自动化测试。<br><br>采用从master分支上cherry-pick的主要原因是确保master的健康。发布分支相对稳定，所以在上面直接修复的话，fix会错过很多最新的master上的相关修改，所以稳定性会差一些。而在master上先修复可以确保master随时可用，master更像source of truth，这是大量开发人员能够共主干的前提。<br><br>2&#47; cherry-pick 操作是自动化的。工具部门提供Web界面让开发人员输入commit ID，工具自动辨别其他需要cherry-pick的commit链。开发人员确认之后工具自动cherry-pick。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1581532336,"ip_address":"","comment_id":175284,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10170577112","product_id":100034501,"comment_content":"从上面文章中获取，您的cherry-pick 策略都是在master上进行修复，然后cherry-pick 至周部署分支或热修复分支。<br>针对这个场景，我有以下几个问题<br>1. master分支每天有很多提交，其分支代码与周部署分支&amp;热修复分支很大可能已经不一致了，如何保证cherry-pick质量？为什么不是从待发布分支 cherry-pick 至 master 分支呢？<br>2. cherry-pick 操作是自动化，还是手动的？","like_count":2,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482676,"discussion_content":"1/ 保证cherry-pick质量保证有以下几条：\n\n1. cherry-pick需要把依赖提交链一起cherry-pick。比如需要cherry-pick 提交A改动了文件f。A之前的提交B改动了f的相同部分。那么，B也要被遗弃cherry-pick。同时，B的依赖提交也要cherry-pick。\n2. master上提交的原子性。这样可以保证上述的依赖提交可以相对安全的cherry-pick而不会产生未完成的功能暴露给用户\n3. 自动化测试。\n\n采用从master分支上cherry-pick的主要原因是确保master的健康。发布分支相对稳定，所以在上面直接修复的话，fix会错过很多最新的master上的相关修改，所以稳定性会差一些。而在master上先修复可以确保master随时可用，master更像source of truth，这是大量开发人员能够共主干的前提。\n\n2/ cherry-pick 操作是自动化的。工具部门提供Web界面让开发人员输入commit ID，工具自动辨别其他需要cherry-pick的commit链。开发人员确认之后工具自动cherry-pick。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581532336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1381325,"avatar":"https://static001.geekbang.org/account/avatar/00/15/13/cd/a1429abe.jpg","nickname":"快手阿修","note":"","ucode":"D9E1B87B0EAA9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301993,"discussion_content":"所以这里的热修复，实际上仅仅不只是修复。同时把这一段时间在master上集成的与修复部分相关的新功能也拿过来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598751450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131342,"user_name":"李双","can_delete":false,"product_type":"c1","uid":1063119,"ip_address":"","ucode":"5148D07BDDBB46","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/cf/f2c7d021.jpg","comment_is_top":false,"comment_ctime":1567728281,"is_pvip":false,"replies":[{"id":"49941","content":"对的。这种方式是发布周期与功能解耦。版本火车一列一列发出去。功能开发者自己决定把commit搭乘哪一列。办不上的话，没办法，等下一列。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1567785324,"ip_address":"","comment_id":131342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157662873","product_id":100034501,"comment_content":"各种分支管理策略，学习！问下，基于base开发的这种方式，是不是根据时间线，截止某一时间点（或者某个版本号之前的），代码验证过了，就可以上线了，而不是根据业务功能的先后紧急！","like_count":2,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466399,"discussion_content":"对的。这种方式是发布周期与功能解耦。版本火车一列一列发出去。功能开发者自己决定把commit搭乘哪一列。办不上的话，没办法，等下一列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567785324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248503,"user_name":"小齐","can_delete":false,"product_type":"c1","uid":1243526,"ip_address":"","ucode":"1C5E08BB6BCE44","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/86/272fc86f.jpg","comment_is_top":false,"comment_ctime":1600182124,"is_pvip":false,"replies":[{"id":"91537","content":"你是对的。我当时写的应该是在解决`git cherry-pick` conflict时的操作。我联系编辑修正一下。谢谢你指出错误之处！","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1600751033,"ip_address":"","comment_id":248503,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895149420","product_id":100034501,"comment_content":"rebase 的时候冲突为啥是 git add &amp; git commit 而不是 git add &amp; git rebase --continue","like_count":1,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505668,"discussion_content":"你是对的。我当时写的应该是在解决`git cherry-pick` conflict时的操作。我联系编辑修正一下。谢谢你指出错误之处！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600751033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146725,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1572620842,"is_pvip":false,"replies":[{"id":"56724","content":"git 很好玩的！对提高个人效能很有用。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1572661254,"ip_address":"","comment_id":146725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867588138","product_id":100034501,"comment_content":"学习了。<br><br>以前就我一个人用git时，只能在官网（https:&#47;&#47;git-scm.com&#47;book&#47;zh&#47;v2）看看文档。<br>很多命令都不知道在什么场景下使用。<br>之前看耗子书关于分支管理的文章，也是云里雾里，很多命令不知道为什么那么用。<br><br>现在新工作环境中，由于需要跟别人协作，用的git命令也是越来越多了。<br>现在再来看老师的这篇文章，就不再吃力了。<br><br>我现在很喜欢git rebase 和 git cherry-pick。<br>我也很努力的保持分支线性，看上去好看。😄<br>之前很小的提交都是用git merge -no-ff来合并的。<br><br>总之，这个东西是熟来生巧。","like_count":1,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472997,"discussion_content":"git 很好玩的！对提高个人效能很有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572661254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346457,"user_name":"果粒橙","can_delete":false,"product_type":"c1","uid":2574410,"ip_address":"","ucode":"0DF819D90F75AA","user_header":"","comment_is_top":false,"comment_ctime":1653147112,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653147112","product_id":100034501,"comment_content":"Git-flow 工作流，功能或者修复合并时，容易出现忘记合并到某个分支的情况。不过可以使用脚本自动化来解决。请教一下怎么自动化解决？有具体方法么？","like_count":0},{"had_liked":false,"id":338914,"user_name":"K先生","can_delete":false,"product_type":"c1","uid":2948742,"ip_address":"","ucode":"33BD27746B7A77","user_header":"https://static001.geekbang.org/account/avatar/00/2c/fe/86/61bc225d.jpg","comment_is_top":false,"comment_ctime":1647786513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647786513","product_id":100034501,"comment_content":"请教老师，模式一：主干分支，无功能分支，几千人的开发团队，如何做好，万一有人一提交，功能就不可用的问题，是在提交的时候就做质量门禁么？感觉此方法对人的要求非常高","like_count":1},{"had_liked":false,"id":325228,"user_name":"静水潜流，润物无声","can_delete":false,"product_type":"c1","uid":1460672,"ip_address":"","ucode":"BA6B9636DAEA2A","user_header":"https://wx.qlogo.cn/mmopen/vi_32/ibXbRJ3yOT48IHc6mayIRxibutDz2bWHxBdicNoeJBG9EG6AXpuRMhtBRmjpFvmGPBIAYNrnq6nP9okwk5oU36GSA/132","comment_is_top":false,"comment_ctime":1638870743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638870743","product_id":100034501,"comment_content":"请教老师两个问题：<br>1、feature 分支与本地分支是只是叫法上的区别吗？实际在git里面是指一个意思？<br><br>2、分支让实际上就是为了方便分布全球不同local的team渐进式集成不同功能到同一代码文件，不知道这种理解是否正确。","like_count":0},{"had_liked":false,"id":288310,"user_name":"小慧","can_delete":false,"product_type":"c1","uid":1719248,"ip_address":"","ucode":"E204674778B5F5","user_header":"https://static001.geekbang.org/account/avatar/00/1a/3b/d0/a6da72a7.jpg","comment_is_top":false,"comment_ctime":1618403430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618403430","product_id":100034501,"comment_content":"主仓库以master为主，建立功能分支。功能分支开发完成合并到测试分支，比如sit  uat  ，有bug直接在功能分支修改，再合并到测试分支验证。测试通过把功能分支合并到master分支，进行生产发布。这是哪个模式呢？","like_count":0},{"had_liked":false,"id":254911,"user_name":"bidinggong","can_delete":false,"product_type":"c1","uid":1898806,"ip_address":"","ucode":"789A1FBA8408F3","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f9/36/f44b633e.jpg","comment_is_top":false,"comment_ctime":1603211130,"is_pvip":true,"replies":[{"id":"93376","content":"trunk-based 开发流程实现起来有些门槛，但是效果真的好。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1603673572,"ip_address":"","comment_id":254911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603211130","product_id":100034501,"comment_content":"Facebook一直使用这种主干分支开发方式。它强迫我们把代码进行原子化，尽量确保每一个提交都尽快合入 master，并保证代码质量。实际应用后才会发现它的确很棒。","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507555,"discussion_content":"trunk-based 开发流程实现起来有些门槛，但是效果真的好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603673572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205715,"user_name":"文中","can_delete":false,"product_type":"c1","uid":1086090,"ip_address":"","ucode":"44C48F126034DC","user_header":"https://static001.geekbang.org/account/avatar/00/10/92/8a/e86a8db7.jpg","comment_is_top":false,"comment_ctime":1586706999,"is_pvip":false,"replies":[{"id":"77962","content":"在Facebook一般的做法是被依赖这的代码先提交，并附有测试。这些代码暂时用功能开关对用户关闭，只对测试和开发者打开。然后依赖者就可以基于这个代码进行本地测试、然后check-in。这样就避免了需要同时check-in。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1587402393,"ip_address":"","comment_id":205715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586706999","product_id":100034501,"comment_content":"文中提到的 FB 的实践，对提交的新代码质量、新代码的测试覆盖、已有的测试覆盖率的要求都很高。对于大型的项目，还需要上下游统一写集成测试用例才能完成。怎么能保证不同业务系统的业务代码和测试代码能同时或在很短的间隔内都完成提交呢？","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491567,"discussion_content":"在Facebook一般的做法是被依赖这的代码先提交，并附有测试。这些代码暂时用功能开关对用户关闭，只对测试和开发者打开。然后依赖者就可以基于这个代码进行本地测试、然后check-in。这样就避免了需要同时check-in。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587402393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194488,"user_name":"Ian","can_delete":false,"product_type":"c1","uid":1018466,"ip_address":"","ucode":"ADB84045BCB323","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/62/1ce50dc3.jpg","comment_is_top":false,"comment_ctime":1585062134,"is_pvip":false,"replies":[{"id":"75906","content":"不好意思回复的有点晚。最近特别忙。<br><br>原因是这样的：持续集成的最基本、也是最关键的点就是每个提交都尽快入库和其他人的代码集成。而一旦使用了功能分支，就不可避免出现延迟集成的情况。Git-flow使用了功能分支，所以持续集成做不好。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1586140479,"ip_address":"","comment_id":194488,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585062134","product_id":100034501,"comment_content":"老师你好，请问一下Git-flow工作流，你提到不方便持续集成，这个点能展开说明一下吗？不太明白为什么不方便持续集成呢？谢谢。","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488831,"discussion_content":"不好意思回复的有点晚。最近特别忙。\n\n原因是这样的：持续集成的最基本、也是最关键的点就是每个提交都尽快入库和其他人的代码集成。而一旦使用了功能分支，就不可避免出现延迟集成的情况。Git-flow使用了功能分支，所以持续集成做不好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586140479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194141,"user_name":"墨灵","can_delete":false,"product_type":"c1","uid":1409700,"ip_address":"","ucode":"185D70CA20BEEE","user_header":"https://static001.geekbang.org/account/avatar/00/15/82/a4/a92c6eca.jpg","comment_is_top":false,"comment_ctime":1585030306,"is_pvip":false,"replies":[{"id":"75899","content":"希望这个专栏能给你一些启发。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1586139572,"ip_address":"","comment_id":194141,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585030306","product_id":100034501,"comment_content":"看了大厂的最佳实践，不得不感叹我司的产品管理这块的确是做得太粗糙了，可以完善的点还有很多，自己以前对git的了解也不够深入。","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488768,"discussion_content":"希望这个专栏能给你一些启发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586139572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153299,"user_name":"tk","can_delete":false,"product_type":"c1","uid":1302583,"ip_address":"","ucode":"E9786FB4008095","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/37/a78abe7e.jpg","comment_is_top":false,"comment_ctime":1574212888,"is_pvip":false,"replies":[{"id":"59282","content":"会持续开发新的功能吗？如果可以的话，推荐一个分支，使用功能开关控制。如果不行，就只能使用多个发布分支。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1574429411,"ip_address":"","comment_id":153299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574212888","product_id":100034501,"comment_content":"有没有toB的分支模型建议，多客户，核心功能相同，但是多个客户可能有不同的功能集合或者定制","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475114,"discussion_content":"会持续开发新的功能吗？如果可以的话，推荐一个分支，使用功能开关控制。如果不行，就只能使用多个发布分支。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574429411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151783,"user_name":"Robin","can_delete":false,"product_type":"c1","uid":1034715,"ip_address":"","ucode":"90456CA1930825","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c9/db/b7b3acf3.jpg","comment_is_top":false,"comment_ctime":1573790927,"is_pvip":false,"replies":[{"id":"58770","content":"有Code Review呀，请参考第5篇文章以及第12，13篇。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1574132528,"ip_address":"","comment_id":151783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573790927","product_id":100034501,"comment_content":"facebook 的 Trunk-based 模式感觉没有 code review 流程介入呀，开发者直接push到master就测试上线了吗？","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474614,"discussion_content":"有Code Review呀，请参考第5篇文章以及第12，13篇。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574132528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133800,"user_name":"无名路人","can_delete":false,"product_type":"c1","uid":1250152,"ip_address":"","ucode":"BDAA6CB082383D","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/68/859713ae.jpg","comment_is_top":false,"comment_ctime":1568675967,"is_pvip":false,"replies":[{"id":"52174","content":"因为它可以确保线性的代码提交历史，从而容易定位问题。请参考本文中的&quot;能够确保线性的代码提交历史&quot;部分。<br>","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1569394549,"ip_address":"","comment_id":133800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568675967","product_id":100034501,"comment_content":"老师，为什么用的是rebase而不是merge","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467510,"discussion_content":"因为它可以确保线性的代码提交历史，从而容易定位问题。请参考本文中的&amp;quot;能够确保线性的代码提交历史&amp;quot;部分。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569394549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133715,"user_name":"高倩","can_delete":false,"product_type":"c1","uid":1165965,"ip_address":"","ucode":"CE8E14E771B799","user_header":"https://static001.geekbang.org/account/avatar/00/11/ca/8d/4ebf66a6.jpg","comment_is_top":false,"comment_ctime":1568640621,"is_pvip":false,"replies":[{"id":"52173","content":"DevOps，测试左移，测试右移都是比较有效的办法。后面的文章，会有比较详细的介绍，敬请期待。","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1569394431,"ip_address":"","comment_id":133715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568640621","product_id":100034501,"comment_content":"主干开发模式，对于开发的拆分能力要求很高，同时从测试的角度，又怎么确保整个项目和产品功能的完整性呢？","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467482,"discussion_content":"DevOps，测试左移，测试右移都是比较有效的办法。后面的文章，会有比较详细的介绍，敬请期待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569394431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131679,"user_name":"Dump","can_delete":false,"product_type":"c1","uid":1027751,"ip_address":"","ucode":"CE00A9B209EF88","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/a7/6d3a5d44.jpg","comment_is_top":false,"comment_ctime":1567844293,"is_pvip":false,"replies":[{"id":"50489","content":"前边描述的各种原则，在移动端后端都是一致的，比如说持续开发，持续集成，持续交付等。<br><br>就拿在iOS的Facebook APP 的开发做例子。首先他们也是采用单主干的开发分支模式。要求代码提交的原子性，以及master分支上代码的线性历史。在持续集成方面。他们也是使用的Phabricator作为历程和质量控制中心，进行各种各样的代码入库前检查。在持续交付方面。他们也是采用了和后端类似的方式，每隔一定时间进行一次全量的构建和验证。<br><br>当然，也会有一些差别。我在后面的文章中会找机会详细描述。<br><br>感谢你的提问！","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1568033750,"ip_address":"","comment_id":131679,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567844293","product_id":100034501,"comment_content":"老师能不能讲讲移动端的开发管理，看了几篇都是后端的集成和发布流程","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466570,"discussion_content":"前边描述的各种原则，在移动端后端都是一致的，比如说持续开发，持续集成，持续交付等。\n\n就拿在iOS的Facebook APP 的开发做例子。首先他们也是采用单主干的开发分支模式。要求代码提交的原子性，以及master分支上代码的线性历史。在持续集成方面。他们也是使用的Phabricator作为历程和质量控制中心，进行各种各样的代码入库前检查。在持续交付方面。他们也是采用了和后端类似的方式，每隔一定时间进行一次全量的构建和验证。\n\n当然，也会有一些差别。我在后面的文章中会找机会详细描述。\n\n感谢你的提问！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568033750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2052316,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/50/dc/e8270e4f.jpg","nickname":"xiaozhi239","note":"","ucode":"A03D1C5D3D9CF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302654,"discussion_content":"Google手机app也是类似的，持续开发到单主干上，有一系列的自动测试保证主干不出大问题，每天自动拉出一个alpha release branch，自动测试，自动推送到测试者手机。每周自动拉出一个线上branch，自动测试，自动推送到PlayStore","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598996319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131536,"user_name":"囧囧冰淇淋","can_delete":false,"product_type":"c1","uid":1083868,"ip_address":"","ucode":"ED1417FE9851B5","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/dc/3c4bc06b.jpg","comment_is_top":false,"comment_ctime":1567785827,"is_pvip":false,"replies":[{"id":"49968","content":"对大家有用，让大家觉研发有趣，感觉写文章越来越有趣了XD","user_name":"作者回复","user_name_real":"葛俊 Jason","uid":"1030244","ctime":1567788145,"ip_address":"","comment_id":131536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567785827","product_id":100034501,"comment_content":"看到今天，感觉研发和代码越来越有趣了XD","like_count":0,"discussions":[{"author":{"id":1030244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/64/43a83f69.jpg","nickname":"葛俊 Jason","note":"","ucode":"4ECC8F8F64F473","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466508,"discussion_content":"对大家有用，让大家觉研发有趣，感觉写文章越来越有趣了XD","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567788145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}