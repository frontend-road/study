{"id":129751,"title":"04 | ACK机制：如何保证消息的可靠投递？","content":"<p>你好，我是袁武林。</p><p>在第一节的课程中，我们说到了即时消息系统中的四个重要特性，实时性、可靠性、一致性、安全性。</p><p>上一节课我们从如何保证消息实时性方面，了解了业界常用的一些方式以及背后具体的原理。那么今天我们接着来讲一讲，在即时消息的系统架构设计里，如何来保证消息的可靠投递。</p><p>首先，我们来了解一下，什么是消息的可靠投递？</p><p>站在使用者的角度来看，消息的可靠投递主要是指：消息在发送接收过程中，能够做到不丢消息、消息不重复两点。</p><p>这两个特性对于用户来讲都是非常影响体验的。我们先说一下不丢消息。</p><p>试想一下，你把辛辛苦苦攒到的零花钱打赏给了中意的“主播小姐姐”，但由于系统或者网络的问题，这条对你来说至关重要的打赏消息并没有成功投递给“主播小姐姐”，自然也就没有后续小姐姐和你一对一的互动环节了，想想是不是很悲剧？</p><p>消息重复也不用多说，谁也不愿意浪费时间在查看一遍又一遍的重复内容上。</p><p>那么在一般的IM系统的设计中，究竟是如何解决这两大难题的呢？下面我们结合一些简单的案例，来看一看“不丢消息”“消息不重复”这些能力，在技术上到底是怎么实现的。</p><h2>消息丢失有哪几种情况？</h2><p>我们以最常见的“服务端路由中转”类型的IM系统为例（非P2P），这里解释一下，所谓的“服务端路由中转”是指：一条消息从用户A发出后，需要先经过IM服务器来进行中转，然后再由IM服务器推送给用户B，这个也是目前最常见的IM系统的消息分发类型。</p><!-- [[[read_end]]] --><p>我们可以把它和少数P2P类型区别一下，P2P类型的消息投递是直接由用户A的网络发送到用户B的网络，不经过服务端路由。</p><p>那么，我们来假设一个场景：用户A给用户B发送一条消息。接下来我们看看哪些环节可能存在丢消息的风险？</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/28/5b2ee576e22ac109121714aaaaec3528.png?wh=1024*768\" alt=\"\"></p><p>参考上面时序图，发消息大概整体上分为两部分：</p><ul>\n<li>用户A发送消息到IM服务器，服务器将消息暂存，然后返回成功的结果给发送方A（步骤1、2、3）；</li>\n<li>IM服务器接着再将暂存的用户A发出的消息，推送给接收方用户B（步骤4）。</li>\n</ul><p>其中可能丢失消息的场景有下面这些。</p><p>在第一部分中。步骤1、2、3都可能存在失败的情况。</p><p>由于用户A发消息是一个“请求”和“响应”的过程，如果用户A在把消息发送到IM服务器的过程中，由于网络不通等原因失败了；或者IM服务器接收到消息进行服务端存储时失败了；或者用户A等待IM服务器一定的超时时间，但IM服务器一直没有返回结果，那么这些情况用户A都会被提示发送失败。</p><p>接下来，他可以通过重试等方式来弥补，注意这里可能会导致发送重复消息的问题。</p><p>比如：客户端在超时时间内没有收到响应然后重试，但实际上，请求可能已经在服务端成功处理了，只是响应慢了，因此这种情况需要服务端有去重逻辑，一般发送端针对同一条重试消息有一个唯一的ID，便于服务端去重使用。</p><p>在第二部分中。消息在IM服务器存储完后，响应用户A告知消息发送成功了，然后IM服务器把消息推送给用户B的在线设备。</p><p>在推送的准备阶段或者把消息写入到内核缓冲区后，如果服务端出现掉电，也会导致消息不能成功推送给用户B。</p><p>这种情况实际上由于连接的IM服务器可能已经无法正常运转，需要通过后期的补救措施来解决丢消息的问题，后续会详细讲到，这里先暂且不讨论。</p><p>即使我们的消息成功通过TCP连接给到用户B的设备，但如果用户B的设备在接收后的处理过程出现问题，也会导致消息丢失。比如：用户B的设备在把消息写入本地DB时，出现异常导致没能成功入库，这种情况下，由于网络层面实际上已经成功投递了，但用户B却看不到消息。所以比较难处理。</p><p>上面两种情况都可能导致消息丢失，那么怎么避免这些异常情况下丢消息的问题呢？<br>\n一般我们会用下面这些相应的解决方案：</p><ol>\n<li>\n<p>针对第一部分，我们通过客户端A的超时重发和IM服务器的去重机制，基本就可以解决问题；</p>\n</li>\n<li>\n<p>针对第二部分，业界一般参考TCP协议的ACK机制，实现一套业务层的ACK协议。</p>\n</li>\n</ol><h2>解决丢失的方案：业务层ACK机制</h2><p>我们先解释一下ACK，ACK全称 Acknowledge，是确认的意思。在TCP协议中，默认提供了ACK机制，通过一个协议自带的标准的ACK数据包，来对通信方接收的数据进行确认，告知通信发送方已经确认成功接收了数据。</p><p>那么，业务层ACK机制也是类似，解决的是：IM服务推送后如何确认消息是否成功送达接收方。具体实现如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/7e/a4e3c1cfb27aa32e1c42891f3c14eb7e.png?wh=1024*768\" alt=\"\"></p><p>IM服务器在推送消息时，携带一个标识SID（安全标识符，类似TCP的sequenceId），推送出消息后会将当前消息添加到“待ACK消息列表”，客户端B成功接收完消息后，会给IM服务器回一个业务层的ACK包，包中携带有本条接收消息的SID，IM服务器接收后，会从“待ACK消息列表”记录中删除此条消息，本次推送才算真正结束。</p><h3>ACK机制中的消息重传</h3><p>如果消息推给用户B的过程中丢失了怎么办？比如：</p><ul>\n<li>B网络实际已经不可达，但IM服务器还没有感知到；</li>\n<li>用户B的设备还没从内核缓冲区取完数据就崩溃了；</li>\n<li>消息在中间网络途中被某些中间设备丢掉了，TCP层还一直重传不成功等。</li>\n</ul><p>以上的问题都会导致用户B接收不到消息。</p><p>解决这个问题的常用策略其实也是参考了TCP协议的重传机制。类似的，IM服务器的“等待ACK队列”一般都会维护一个超时计时器，一定时间内如果没有收到用户B回的ACK包，会从“等待ACK队列”中重新取出那条消息进行重推。</p><h3>消息重复推送的问题</h3><p>刚才提到，对于推送的消息，如果在一定时间内没有收到ACK包，就会触发服务端的重传。收不到ACK的情况有两种，除了推送的消息真正丢失导致用户B不回ACK外，还可能是用户B回的ACK包本身丢了。</p><p>对于第二种情况，ACK包丢失导致的服务端重传，可能会让接收方收到重复推送的消息。</p><p>针对这种情况，一般的解决方案是：服务端推送消息时携带一个Sequence ID，Sequence ID在本次连接会话中需要唯一，针对同一条重推的消息Sequence ID不变，接收方根据这个唯一的Sequence ID来进行业务层的去重，这样经过去重后，对于用户B来说，看到的还是接收到一条消息，不影响使用体验。</p><h2>这样真的就不会丢消息了吗？</h2><p>细心的你可能发现，通过“ACK+超时重传+去重”的组合机制，能解决大部分用户在线时消息推送丢失的问题，那是不是就能完全覆盖所有丢消息的场景呢？</p><p>设想一下，假设一台IM服务器在推送出消息后，由于硬件原因宕机了，这种情况下，如果这条消息真的丢了，由于负责的IM服务器宕机了无法触发重传，导致接收方B收不到这条消息。</p><p>这就存在一个问题，当用户B再次重连上线后，可能并不知道之前有一条消息丢失的情况。对于这种重传失效的情况该如何处理？</p><h3>补救措施：消息完整性检查</h3><p>针对服务器宕机可能导致的重传失效的问题我们来分析一下，这里的问题在于：服务器机器宕机，重传这条路走不通了。</p><p>那如果在用户B在重新上线时，让服务端有能力进行完整性检查，发现用户B“有消息丢失”的情况，就可以重新同步或者修复丢失的数据。</p><p>比较常见的消息完整性检查的实现机制有“时间戳比对”，具体的实现如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/c6/149af9b46ff04769d8957efaac84e1c6.png?wh=1024*768\" alt=\"\"></p><p>下面我们来看一下“时间戳机制”是如何对消息进行完整性检查的，我用这个例子来解释一下这个过程。</p><ul>\n<li>IM服务器给接收方B推送msg1，顺便带上一个最新的时间戳timestamp1，接收方B收到msg1后，更新本地最新消息的时间戳为timestamp1。</li>\n<li>IM服务器推送第二条消息msg2，带上一个当前最新的时间戳timestamp2，msg2在推送过程中由于某种原因接收方B和IM服务器连接断开，导致msg2没有成功送达到接收方B。</li>\n<li>用户B重新连上线，携带本地最新的时间戳timestamp1，IM服务器将用户B暂存的消息中时间戳大于timestamp1的所有消息返回给用户B，其中就包括之前没有成功的msg2。</li>\n<li>用户B收到msg2后，更新本地最新消息的时间戳为timestamp2。</li>\n</ul><p>通过上面的时间戳机制，用户B可以成功地让丢失的msg2进行补偿发送。</p><p>需要说明的是，由于时间戳可能存在多机器时钟不同步的问题，所以可能存在一定的偏差，导致数据获取上不够精确。所以在实际的实现上，也可以使用全局的自增序列作为版本号来代替。</p><h2>小结</h2><p>保证消息的可靠投递是IM系统设计中至关重要的一个环节，“不丢消息”“消息不重复”对用户体验的影响较大，我们可以通过以下手段来确保消息下推的可靠性。</p><ul>\n<li>大部分场景和实际实现中，通过业务层的ACK确认和重传机制，能解决大部分推送过程中消息丢失的情况。</li>\n<li>通过客户端的去重机制，屏蔽掉重传过程中可能导致消息重复的问题，从而不影响用户体验。</li>\n<li>针对重传消息不可达的特殊场景，我们还可以通过“兜底”的完整性检查机制来及时发现消息丢失的情况并进行补推修复，消息完整性检查可以通过时间戳比对，或者全局自增序列等方式来实现。</li>\n</ul><p>最后，给你留一个思考题：<strong>有了TCP协议本身的ACK机制，为什么还需要业务层的ACK机制？</strong></p><p>你可以给我留言，我们一起讨论，感谢你的收听，我们下期再见。</p>","neighbors":{"left":{"article_title":"03 | 轮询与长连接：如何解决消息的实时到达问题？","id":128942},"right":{"article_title":"05 | 消息序号生成器：如何保证你的消息不会乱序？","id":131899}},"comments":[{"had_liked":false,"id":130883,"user_name":"王棕生","can_delete":false,"product_type":"c1","uid":1337944,"ip_address":"","ucode":"901BD0447A871E","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","comment_is_top":false,"comment_ctime":1567564221,"is_pvip":false,"replies":[{"id":"49162","content":"👍，嗯，即使数据成功发送到接收方设备了，tcp层再把数据交给应用层时也可能出现异常情况，比如存储客户端的本地db失败，导致消息在业务层实际是没成功收到的。这种情况下，可以通过业务层的ack来提供保障，客户端只有都执行成功才会回ack给服务端。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567597563,"ip_address":"","comment_id":130883,"utype":1}],"discussion_count":5,"race_medal":0,"score":"435359261117","product_id":100034901,"comment_content":"有了 TCP 协议本身的 ACK 机制为什么还需要业务层的ACK 机制？<br>答：这个问题从操作系统(linux&#47;windows&#47;android&#47;ios)实现TCP协议的原理角度来说明更合适： <br>     1  操作系统在TCP发送端创建了一个TCP发送缓冲区，在接收端创建了一个TCP接收缓冲区；<br>     2  在发送端应用层程序调用send()方法成功后，实际是将数据写入了TCP发送缓冲区；<br>     3  根据TCP协议的规定，在TCP连接良好的情况下，TCP发送缓冲区的数据是“有序的可靠的”到达TCP接收缓冲区，然后回调接收方应用层程序来通知数据到达；<br>     4  但是在TCP连接断开的时候，在TCP的发送缓冲区和TCP的接收缓冲区中可能还有数据，那么操作系统如何处理呢？ <br>           首先，对于TCP发送缓冲区中还未发送的数据，操作系统不会通知应用层程序进行处理（试想一下：send()函数已经返回成功了，后面再告诉你失败，这样的系统如何设计？太复杂了...），通常的处理手段就是直接回收TCP发送缓存区及其socket资源；<br>           对于TCP接收方来说，在还未监测到TCP连接断开的时候，因为TCP接收缓冲区不再写入数据了，所以会有足够的时间进行处理，但若未来得及处理就发现了连接断开，仍然会为了及时释放资源，直接回收TCP接收缓存区和对应的socket资源。<br><br>总结一下就是： 发送方的应用层程序，调用send()方法返回成功的时候，数据实际是写入到了TCP的发送缓冲区，而非已经被接收方的应用层程序处理。怎么办呢？只能借助于应用层的ACK机制。","like_count":102,"discussions":[{"author":{"id":1444145,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/31/535d60bc.jpg","nickname":"RuBy","note":"","ucode":"C677C3358CB295","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7667,"discussion_content":"懂了~说白了就是tcp的ack并不能确认在业务层面上找个消息确实投递成功","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1567606518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1618781,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b3/5d/a97e5045.jpg","nickname":"小宽宽与他的白日梦","note":"","ucode":"C16F595EE4E11A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9358,"discussion_content":"明白了。\n请问如果双方都断开了，缓冲区里还有数据，操作系统的回收是什么执行了什么操作？把消息销毁扔掉了吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568160663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466174,"discussion_content":"👍，嗯，即使数据成功发送到接收方设备了，tcp层再把数据交给应用层时也可能出现异常情况，比如存储客户端的本地db失败，导致消息在业务层实际是没成功收到的。这种情况下，可以通过业务层的ack来提供保障，客户端只有都执行成功才会回ack给服务端。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567597563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2790767,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/95/6f/612c1ba8.jpg","nickname":"累累累累累了","note":"","ucode":"1623A8EE0F7BDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592172,"discussion_content":"nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667184614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1150086,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8c/86/7ebf0053.jpg","nickname":"锅ke24","note":"","ucode":"74DA5ADA00921A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414735,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636880579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130836,"user_name":"小可","can_delete":false,"product_type":"c1","uid":1006735,"ip_address":"","ucode":"8834AF621FA67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","comment_is_top":false,"comment_ctime":1567558585,"is_pvip":false,"replies":[{"id":"49132","content":"👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567596296,"ip_address":"","comment_id":130836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"160481348537","product_id":100034901,"comment_content":"两个ack的作用不同，tcp的ack表征网络层消息是否送达；业务层ack是真正的业务消息是否送达和是否正确处理，达到不丢消息，消息不重复的目的，即我们要保证的消息可靠性","like_count":37,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466146,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132321,"user_name":"影随","can_delete":false,"product_type":"c1","uid":1088169,"ip_address":"","ucode":"48BC4CFCAD3C2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/a9/ae10f6cd.jpg","comment_is_top":false,"comment_ctime":1568084036,"is_pvip":false,"replies":[{"id":"50657","content":"是的，如果只是时间戳或者“只是有序但不连续的序号”的话，是只能保证消息的时序性，不能保证消息的连续性。这种情况可以通过版本号机制来解决，通过两个版本号组成的链表（推送的每条消息携带前一条消息的版本号和当前这条消息的版本号）来检测消息的连续性和时序性。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568129342,"ip_address":"","comment_id":132321,"utype":1}],"discussion_count":3,"race_medal":0,"score":"83172462660","product_id":100034901,"comment_content":"老师您好，服务A向客户端B发送消息，第一次发送msg1，timestamp假设为 01（简写），序号为 01，这条消息因为某种原因，未存储时间戳和序号01，也未发送ack通知。A第二次发送msg2，timestamp为 02，序号为02，它做了存储，保存了最新的时间戳和序号。A第三次发送 msg3，此时B宕机了。 等B重启时，向A发送最新的时间戳和序号 02， 那么A发送大于02序号的消息，即 msg3， 那么 msg1如何保证不丢失呢？  ","like_count":19,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466876,"discussion_content":"是的，如果只是时间戳或者“只是有序但不连续的序号”的话，是只能保证消息的时序性，不能保证消息的连续性。这种情况可以通过版本号机制来解决，通过两个版本号组成的链表（推送的每条消息携带前一条消息的版本号和当前这条消息的版本号）来检测消息的连续性和时序性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568129342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204366,"discussion_content":"通过连续性的校验，可以解决这个问题。\n1. 如果服务端正常运行(没有宕机)，服务端可以持续重试发送没收到的消息（如msg1）。2. 如果服务端宕机了，客户端可以请求补发连续区间中没收到的消息，以及客户端当前最新时间戳之后的消息。这个可能是一个递推的过程，比如msg2, msg3都没有发送成功，客户端在收到msg4时，会记录msg3（上一条消息）没收到，然后请求服务端补发msg3。msg3收到后，又会发现msg2没收到，从而继续向服务端补推msg2的消息。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1584162805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":318171,"discussion_content":"如果msg1压根就没写入db呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603672316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204366,"ip_address":""},"score":318171,"extra":""}]}]},{"had_liked":false,"id":130864,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1567561319,"is_pvip":false,"replies":[{"id":"49156","content":"A. 接收方本地去重只需要针对本机已经接收到的存在的消息来做就可以了，服务端接收时实际上已经会做一次存储层的去重了，只会存在没有回ack的消息导致接收方重复接收的情况，这种两次之间一般时间间隔都比较短的。<br>B. 如果低序号的消息还没到，由于没有收到客户端的ack服务端会有超时重传机制会重传这条低序号的消息，另外即使这个时候用户关机不等那条消息了，再次上线时，采用版本号机制的话客户端也是可以知道消息不完整，可以触发服务端进行重推。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567597205,"ip_address":"","comment_id":130864,"utype":1}],"discussion_count":4,"race_medal":0,"score":"35927299687","product_id":100034901,"comment_content":"1、回答老师的问题：TCP层的ACK只是TCP包分片的ACK，并不能代表整个应用层的消息得到应答。理论上操作系统的TCP栈肯定是知道整个TCP消息得到对方的ACK了，但是操作系统好像并没提供这种接口。发送成功的接口返回成功通常都表示为操作系统发送成功了，至于链路上有没有问题就不知道了。<br>2、向老师请教下其他问题，恳请解答。<br>A、如果接收方本地保存了所有曾经接收过的消息id，接收方是很方便去重，但是，如果用户clear了本地消息该怎么办，是要一直存储所有已经接收的消息id吗<br>B、对于防范服务器宕机的时间戳机制，其实本质是序号，但是网络传输并不能保证服务器按序号发送的消息，低序号的就一定先于高序号的被接收方接收。所以如果高序号的已经被接收方处理且应答，而某个低序号的消息还没得到接收方应答的场景，通过序号保证完整性貌似不可取。","like_count":8,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466163,"discussion_content":"A. 接收方本地去重只需要针对本机已经接收到的存在的消息来做就可以了，服务端接收时实际上已经会做一次存储层的去重了，只会存在没有回ack的消息导致接收方重复接收的情况，这种两次之间一般时间间隔都比较短的。\nB. 如果低序号的消息还没到，由于没有收到客户端的ack服务端会有超时重传机制会重传这条低序号的消息，另外即使这个时候用户关机不等那条消息了，再次上线时，采用版本号机制的话客户端也是可以知道消息不完整，可以触发服务端进行重推。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567597205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/de/84abadd8.jpg","nickname":"staywild","note":"","ucode":"01BF93EF2F2341","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38232,"discussion_content":"B的问题不存在吧，如果是同一个tcp连接，tcp会保证先发的包先提交给应用层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571748144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1548814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a2/0e/62f10b10.jpg","nickname":"朱朱","note":"","ucode":"CE56C6773736D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8330,"discussion_content":"如果服务端未收到低版本ACK，重传用户界面会出现新消息，但显示在己读消息上面，如果放高时序下面，消息就乱了，这时更新用戶序号用还是高序号不更新，还是怎么处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567920867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1548814,"avatar":"https://static001.geekbang.org/account/avatar/00/17/a2/0e/62f10b10.jpg","nickname":"朱朱","note":"","ucode":"CE56C6773736D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8328,"discussion_content":"这个也是我的疑惑，感觉没讲清楚，高序号用户先收，他在次上线带过去是高序号，如果知道自己低版本未收到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567920574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139412,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1570628546,"is_pvip":true,"replies":[{"id":"53918","content":"一般可以通过业务层的多个字段一起来排重：比如接收方uid和内容，发送时间等，不需要客户端额外生成一个字段。去重实现上可以通过上面字段组合成生成一个hash然后根据消息收到的时间加上一个比较短的过期时间来写入到一个中央存储里。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1570712458,"ip_address":"","comment_id":139412,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27340432322","product_id":100034901,"comment_content":"老师 从客户端到服务端，服务端要对客户端发送的消息去重， 用哪个字段呀。 这个字段应该是客户端发送消息由客户端产生的吧。 那如何能保证这个字段全局唯一，而不是客户端A 产生了和客户端B 同样的这个字段？ 去重的步骤是什么呢？ 是去数据库查找是否有这个字段的内容嘛？","like_count":6,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469932,"discussion_content":"一般可以通过业务层的多个字段一起来排重：比如接收方uid和内容，发送时间等，不需要客户端额外生成一个字段。去重实现上可以通过上面字段组合成生成一个hash然后根据消息收到的时间加上一个比较短的过期时间来写入到一个中央存储里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570712458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024994,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/e2/5cb4f43f.jpg","nickname":"laolinshi","note":"","ucode":"269B879389D7D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558516,"discussion_content":"用户A给用户B发送了三遍“重要的事情请注意”的消息，按照老师说的去重方法来过滤消息的话，那用户B就直接收到一条“重要的事情请注意”的消息了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648363239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131629,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/6d/10a6cc99.jpg","nickname":"土豆鸡块_o0","note":"","ucode":"1003C0074B722E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332716,"discussion_content":"去重这块没想明白，老师能再详细讲下逻辑吗？过期时间该怎么使用？每次消息都要通过重排，然后通过hash判断下是否为重传消息吗？这样感觉很浪费IO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607323237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137413,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1569734357,"is_pvip":false,"replies":[{"id":"53262","content":"是的，对于重试不可能保证一定会成功，这些情况一般会以服务端中真实处理为准，通过多终端消息同步机制来让客户端有机会重新同步状态。比如发消息服务端处理成功，但是客户端接收响应超时&#39;这种情况，服务端在成功处理完后会给发送方的发送设备推送当前消息的版本号，如果发送方设备没收到这个版本号，下次上线时会重新同步服务端的状态，用服务端消息进行覆盖。对于你说的第二种情况也比较简单，接收方b需要对重复接收的消息进行去重处理就可以了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1570270029,"ip_address":"","comment_id":137413,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23044570837","product_id":100034901,"comment_content":"老师，您好！<br><br>文中提到：用户 A 等待 IM 服务器返回超时，用户 A 被提示发送失败。但可以通过重试等方式来弥补。<br><br>我有个疑问：客户端在超时时间内没有收到响应然后重试，但实际上，请求已经在服务端成功处理了。这时用户 A 和 IM 服务器的状态就不一致了，用户 A 看到的是发送失败，而 IM 服务器却是处理成功的。<br><br>同样的，IM 服务器在等待​ ACK 通知也存在这样的问题：IM 服务器在有限的重试次数内，一直没收到 ACK 通知，而消息却成功推送给了用户 B，IM 服务器和用户 B 的状态也不一致了。<br><br>在有限的重试次数内（线上不可能无限重试吧？），无法得到确定的返回结果，导致客户端和服务端的状态不一致，如何解决这个问题吖？<br>​","like_count":5,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469078,"discussion_content":"是的，对于重试不可能保证一定会成功，这些情况一般会以服务端中真实处理为准，通过多终端消息同步机制来让客户端有机会重新同步状态。比如发消息服务端处理成功，但是客户端接收响应超时&amp;#39;这种情况，服务端在成功处理完后会给发送方的发送设备推送当前消息的版本号，如果发送方设备没收到这个版本号，下次上线时会重新同步服务端的状态，用服务端消息进行覆盖。对于你说的第二种情况也比较简单，接收方b需要对重复接收的消息进行去重处理就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570270029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131003,"user_name":"隰有荷","can_delete":false,"product_type":"c1","uid":1357944,"ip_address":"","ucode":"2BE9A32AB28963","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/78/2828195b.jpg","comment_is_top":false,"comment_ctime":1567595417,"is_pvip":false,"replies":[{"id":"49183","content":"用户上线的时候携带本地最新一条消息的时间戳给服务端，服务端从离线缓存里取比这个时间戳大的消息发给客户端就行了呀","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567598368,"ip_address":"","comment_id":131003,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23042431897","product_id":100034901,"comment_content":"您好，我在读到在消息完整性检查那里时有些疑惑，如果服务端将msg2发出之后，服务端和客户端断链，导致客户端无法接收消息，那么重新连接之后，是可以发送时间戳检测进行重传的。<br>但是，如果在服务端存储了发送方客户端发送的消息后，正准备将该消息推送给接收方客户端时发生宕机，那么当接收方客户端和服务端重新连接之后，服务端该如何知道自己要将之前存储的消息发送给接收方的客户端呢？","like_count":5,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466238,"discussion_content":"用户上线的时候携带本地最新一条消息的时间戳给服务端，服务端从离线缓存里取比这个时间戳大的消息发给客户端就行了呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567598368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583643,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2a/1b/9b8d5fb4.jpg","nickname":"callme大帅","note":"","ucode":"F8EA15943082B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548402,"discussion_content":"我看我们im系统是，客户端socket在线，如果有消息未返ack给服务端，服务端会存在ack待推送队列，用户上线推给他。如果客户端不在线，服务端就不会主动推，交给用户主动拉取。用户下次连接上socket，进来同步会话，主动拉取离线会话(带一条消息)。进入私聊后再主动分页拉取离线消息(这里用书签来区分拉本地sqlite还是远端)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643184107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130889,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1567565712,"is_pvip":false,"replies":[{"id":"49166","content":"👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567597756,"ip_address":"","comment_id":130889,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23042402192","product_id":100034901,"comment_content":"保证消息不丢失的做法：<br>1、发送消息阶段通过客户端的发送重试机制，和服务端的去重，保证发送时消息不丢失不重复<br>2、服务端推送阶段通过ACK确认机制和客户端去重保证推送时消息不丢失不重复<br>3、最后使用时间戳的同步机制来保证消息的完整性，这个应该要在服务端无法触发重推消息时才进行的一个操作","like_count":5,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466177,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567597756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145872,"user_name":"L","can_delete":false,"product_type":"c1","uid":1237556,"ip_address":"","ucode":"0BDC32D02DB267","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/34/0c2c1200.jpg","comment_is_top":false,"comment_ctime":1572397794,"is_pvip":false,"replies":[{"id":"56366","content":"嗯，是个好问题，如果上线时不携带时间戳或者版本号这种情况服务端默认会返回最新的n条消息给端上，后续旧消息用户再通过翻页来触发自动拉取。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1572438750,"ip_address":"","comment_id":145872,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14457299682","product_id":100034901,"comment_content":"老师你好，关于完整性检查我有个问题。<br>下次会话时用户重装了软件&#47;清空缓存&#47;甚至更换了设备导致本地没有上次会话的时间戳了，这时候岂不是无法获取丢失的那些消息？","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472608,"discussion_content":"嗯，是个好问题，如果上线时不携带时间戳或者版本号这种情况服务端默认会返回最新的n条消息给端上，后续旧消息用户再通过翻页来触发自动拉取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572438750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037540,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qgbQytfwErGXuIZaRzA28iagmfnZDHKMYIGwZ7sJ6NAicVicDewic8S266eA9L4wO2q1y4XwcMGE6urK9L6vuQBpMA/132","nickname":"Geek_6e6dba","note":"","ucode":"E7B1A5DC90760D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283699,"discussion_content":"未读数应该是单独维护的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592340126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237556,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/34/0c2c1200.jpg","nickname":"L","note":"","ucode":"0BDC32D02DB267","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41517,"discussion_content":"但仍然要告诉用户有多少条未读消息吧？实现这是否只能通过存储用户与其他用户会话的最后时间戳，推送消息时从表中读取出这个字段，然后去计算未读消息数？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572444175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132867,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1568255244,"is_pvip":false,"replies":[{"id":"50939","content":"👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568288083,"ip_address":"","comment_id":132867,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14453157132","product_id":100034901,"comment_content":"思考题：TCP和业务层做在的维度不一样，故虽然两者的ACK机制原理一样，但不能相互替代。TCP的ACK完成只能说明数据包已经正确传输完毕，但不代表数据包里的数据已经被正确处理完毕。业务层的ACK就是来保证数据包里的数据正确处理完毕的。TCP的ACK完成是业务层ACK的前提，业务层ACK完成是业务规则上的保证。","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467152,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568288083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131042,"user_name":"RuBy","can_delete":false,"product_type":"c1","uid":1444145,"ip_address":"","ucode":"C677C3358CB295","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/31/535d60bc.jpg","comment_is_top":false,"comment_ctime":1567606948,"is_pvip":false,"replies":[{"id":"49532","content":"看量级吧，我们自己的场景里mysql和hbase做为永久存储，pika作为离线消息的buffer存储 没有碰到瓶颈。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567683514,"ip_address":"","comment_id":131042,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14452508836","product_id":100034901,"comment_content":"老师，请问消息落地的话传统的redis+mysql是否会有性能瓶颈？是否会考虑leveldb（racksdb）这种持久化kv存储呢？","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466261,"discussion_content":"看量级吧，我们自己的场景里mysql和hbase做为永久存储，pika作为离线消息的buffer存储 没有碰到瓶颈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567683514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332678,"discussion_content":"同问 hbase是用存储什么消息？ 我猜…hbase存全量的历史消息,mysql存近期的历史消息？不知道对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607307388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068542,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","nickname":"威","note":"","ucode":"C921CDCB22B9A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327528,"discussion_content":"请问老师的Hbase是用来存储什么数据呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605857555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136623,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1569484276,"is_pvip":false,"replies":[{"id":"52549","content":"消息ID要求全局唯一且时间相关，这个时间相关的精度是可以自行控制的，比如说是毫秒级有序还是秒级有序，通过内存级资源是能够实现每秒百万级发号能力的。我了解到的，类似微信这种IM，不需要支持多终端消息同步的场景，不需要通过拉取来对消息进行排序，所以实际上这个消息ID全局有序的必要性就很小了，只需要保证每个人的维度消息有序就可以，所以发号可以做到人维度。整体实现上也不需要时间相关了，只需要保证序号递增就能在接收端进行排序。腾讯整体据对外的分享，是采用多机房Set架构，其中包括海外机房，每个用户消息发送只会到所属的Set，然后通过多机房同步工具进行同步，所以消息发送方面延迟控制上应该也是有保障的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569577990,"ip_address":"","comment_id":136623,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159418868","product_id":100034901,"comment_content":"消息ID要求全局唯一且时间趋势递增吗？如果是这样，像微信和QQ这样体量的系统，要构建一个多大的消息序列集群才能满足需求？另外，微信和QQ的消息序列集群是全球唯一一个，还是多个集群并行部署？如果是全球唯一1个集群，跨半球的消息发送会不会延时很大，如果是多个集群，又如何保证时间趋势递增？","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468732,"discussion_content":"消息ID要求全局唯一且时间相关，这个时间相关的精度是可以自行控制的，比如说是毫秒级有序还是秒级有序，通过内存级资源是能够实现每秒百万级发号能力的。我了解到的，类似微信这种IM，不需要支持多终端消息同步的场景，不需要通过拉取来对消息进行排序，所以实际上这个消息ID全局有序的必要性就很小了，只需要保证每个人的维度消息有序就可以，所以发号可以做到人维度。整体实现上也不需要时间相关了，只需要保证序号递增就能在接收端进行排序。腾讯整体据对外的分享，是采用多机房Set架构，其中包括海外机房，每个用户消息发送只会到所属的Set，然后通过多机房同步工具进行同步，所以消息发送方面延迟控制上应该也是有保障的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569577990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131905,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1646622,"ip_address":"","ucode":"F5A45F009175FA","user_header":"https://static001.geekbang.org/account/avatar/00/19/20/1e/23e6109f.jpg","comment_is_top":false,"comment_ctime":1567959845,"is_pvip":false,"replies":[{"id":"50508","content":"1. 会有重试次数，毕竟即使收不到还有离线消息来补充。<br>重试多次仍然失败服务端可以主动断连来避免资源消耗。<br>2. 一般等着服务端重推就好了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568036424,"ip_address":"","comment_id":131905,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157894437","product_id":100034901,"comment_content":"有2个问题<br>1 服务端发消息给客户端，没收到ack重试有最大次数吗？是像tcp那样一直重试直到收到ack吗？<br><br>如果客户端有bug导致处理消息一直失败，是否会导致服务端一直在重试，然后队列就满了。<br><br>2 收到消息后处理失败了要怎么处理，是不做等待服务端重发吗？","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466674,"discussion_content":"1. 会有重试次数，毕竟即使收不到还有离线消息来补充。\n重试多次仍然失败服务端可以主动断连来避免资源消耗。\n2. 一般等着服务端重推就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568036424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131029,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1567603205,"is_pvip":true,"replies":[{"id":"49529","content":"首先这里要能让客户端知道有一条消息msg1还没到，所以单纯使用时间戳可能是不够的，时间戳只能代表时序，并不能判断出完整性，所以可能还需要配合连续的序号来实现感知（比如每次建连，服务端针对这条连接的所有推送从0开始自增，随消息一起下推）。至于你说的类似tcp的重传机制，这个理论上是可以这么实现的，就是复杂度上会高一些。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567683282,"ip_address":"","comment_id":131029,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157537797","product_id":100034901,"comment_content":"老师您好，我想问下服务端IM先后推送两条消息msg0、msg1、msg2到客户端B，如果msg0、msg2先到达，此时客户端B应该不会更新到msg2的发送时间戳吧，而是等待msg1到达。如果此时陆续msg3、msg4消息到达，msg1还没到达，客户端是否也可像tcp一样，发送3个msg0消息到服务端IM，而不需要等待超时就让IM服务端立即重发msg1，这样可以降低延时，等到msg1到达客户端B后，可以直接将时间戳更新至最新到达消息的时间戳吧，而不是msg1的时间戳，不知道的理解的对不对，老师有时间看看","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466255,"discussion_content":"首先这里要能让客户端知道有一条消息msg1还没到，所以单纯使用时间戳可能是不够的，时间戳只能代表时序，并不能判断出完整性，所以可能还需要配合连续的序号来实现感知（比如每次建连，服务端针对这条连接的所有推送从0开始自增，随消息一起下推）。至于你说的类似tcp的重传机制，这个理论上是可以这么实现的，就是复杂度上会高一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567683282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130821,"user_name":"长江","can_delete":false,"product_type":"c1","uid":1185226,"ip_address":"","ucode":"F71EB246C82783","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/ca/9f57577b.jpg","comment_is_top":false,"comment_ctime":1567556989,"is_pvip":false,"replies":[{"id":"49130","content":"1没问题哈，对于2的话如果出现接收端进程崩溃，一般这个时候接收端APP也是处于不可用状态了，这种情况实际上也没法通过这个ACK机制来避免丢消息。可以在用户再次上线时进行完整性检查的确认，如果有消息没有被正确接收，再由服务补推。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567596277,"ip_address":"","comment_id":130821,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10157491581","product_id":100034901,"comment_content":"有了 TCP 协议本身的 ACK 机制为什么还需要业务层的 ACK 机制？<br>1.TCP属于传输层，而IM服务属于应用层，TCP的ACK只能保证传输层的可靠性，即A端到B端的可靠性，但是不能保证数据能够被应用层正确可靠处理，比如应用层里面的业务逻辑导致消息处理失败了，TCP层是不知道的。<br>2.TCP虽然是可靠性传输协议，但是如果传输过程中，假如数据报文还没被接收端接收完毕，接收端进程服务崩溃了，而用户又不再立刻启动这个应用程序，这也会导致消息丢失的吧。<br>所以不能只依靠TCP的ACK机制的。","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466143,"discussion_content":"1没问题哈，对于2的话如果出现接收端进程崩溃，一般这个时候接收端APP也是处于不可用状态了，这种情况实际上也没法通过这个ACK机制来避免丢消息。可以在用户再次上线时进行完整性检查的确认，如果有消息没有被正确接收，再由服务补推。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337944,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","nickname":"王棕生","note":"","ucode":"901BD0447A871E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7558,"discussion_content":"阁下所说&#34;比如应用层里面的业务逻辑导致消息处理失败了，TCP层是不知道的&#34;, ...... TCP层是不知道，而且也不需要知道，因为TCP层不是 MQ，没有必要知道，只需要知道消息已经给了应用层程序即可。\n\n还有“而用户又不再立刻启动这个应用程序，这也会导致消息丢失的吧”..... 即时用户立刻启动了这个应用程序，消息也是会丢失的，了解一下 操作系统的进程原理就知道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567564456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1211987,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/53/c29c2fc9.jpg","nickname":"sdjdd","note":"","ucode":"512F2338DFF793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1337944,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","nickname":"王棕生","note":"","ucode":"901BD0447A871E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7632,"discussion_content":"在下不懂操作系统原理，想请阁下解答一下发送方是如何知道消息已经给了接收方的应用层程序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567591712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7558,"ip_address":""},"score":7632,"extra":""},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211987,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/53/c29c2fc9.jpg","nickname":"sdjdd","note":"","ucode":"512F2338DFF793","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7707,"discussion_content":"这个问题比较复杂，一般来说，是位于中间的 服务器 提供相应的机制，确保消息可靠投递给接收方后，再发送应用层确认给发送方的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567647420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7632,"ip_address":""},"score":7707,"extra":""}]}]},{"had_liked":false,"id":130773,"user_name":"段先森","can_delete":false,"product_type":"c1","uid":1310788,"ip_address":"","ucode":"90251BB8BF8DDB","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/44/d5cf762b.jpg","comment_is_top":false,"comment_ctime":1567532654,"is_pvip":false,"replies":[{"id":"49114","content":"如果只是离线消息暂存的话，可以用pika或者redis，如果是消息的永久存储还是落db比较好。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567595428,"ip_address":"","comment_id":130773,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157467246","product_id":100034901,"comment_content":"想问一下老师，一般来说对于直播的业务场景，消息存储这个环节用什么MQ会比较好些","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466116,"discussion_content":"如果只是离线消息暂存的话，可以用pika或者redis，如果是消息的永久存储还是落db比较好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567595428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232161,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1593877142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888844438","product_id":100034901,"comment_content":"对于TCP协议不怎么了解,看到这篇文章,我脑海里蹦现的是mq的消息可靠性,感觉是如出一辙.  从客户端发送方保证消息发送成功,根据消息服务端的返回响应来做重试方式.  服务端的可靠性:无非就是保证消息能持久化成功,类比这里的写入到db.  同步双写方式;  消费方的可靠性,就是利用消息的幂等处理与提交消费进度,偏移量.与这里的时间戳或者全局唯一的顺序id,真的很像...       rocketmq为了保证消息的可靠性,事务消息的发送,服务端的主从架构高可用,同步双写;  消费方的幂等处理加上手动提交消费进度.服务端宕机后,也会有对应的故障机制去根据消费偏移量去恢复消息.      老师这两方面的内容应该是相通的吧.  ","like_count":1},{"had_liked":false,"id":209798,"user_name":"LiG❄️","can_delete":false,"product_type":"c1","uid":1357566,"ip_address":"","ucode":"0FE01F25ADD1F9","user_header":"https://static001.geekbang.org/account/avatar/00/14/b6/fe/c5d7f0dc.jpg","comment_is_top":false,"comment_ctime":1587617315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882584611","product_id":100034901,"comment_content":"新学习中，请问老师对于消息完整性检查 ，在什么时机下构建消息链表比较合适呢？例如：（1）服务端收到某个会话消息时，怎样获取这个会话上一条消息呢（特别是高并发情况下，确保获取的就是上一条消息）？（2）客户端做检查时，存在已收到的消息、新接收的消息，以什么条件去服务端拉取离线消息比较合适呢？还望老师解惑","like_count":1},{"had_liked":false,"id":201667,"user_name":"chjxbt","can_delete":false,"product_type":"c1","uid":1485031,"ip_address":"","ucode":"FDE1D416A7BFB8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9TicPMurialE1rG8zxZtiaChTlRv2ZHmUBCcbe9Dk8puSPBLmWRJRVQm7eom160dzz6NujqxszSjPg/132","comment_is_top":false,"comment_ctime":1585818104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880785400","product_id":100034901,"comment_content":"有个疑问请教老师：<br>1、针对群聊，多个用户接收到消息后，进行ack回包，如果这时有一个用户回包失败，但是根据你的设计，待 ACK 消息列表，如果只保存消息id，不保存用户id，那就不清楚到底哪个用户回包成功哪个失败，然后针对失败的重发？待 ACK 消息列表是否同一条消息分别标记不同用户，相当于保存了一条消息多个用户的ack数据？","like_count":1},{"had_liked":false,"id":193970,"user_name":"聪","can_delete":false,"product_type":"c1","uid":1009831,"ip_address":"","ucode":"9D672A8580A945","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/a7/c3fd1fd9.jpg","comment_is_top":false,"comment_ctime":1585009053,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5879976349","product_id":100034901,"comment_content":"去重可以用一个redis cluster去存所有出现的sequence ID。","like_count":1,"discussions":[{"author":{"id":1009831,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/68/a7/c3fd1fd9.jpg","nickname":"聪","note":"","ucode":"9D672A8580A945","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288652,"discussion_content":"哦我知道我们想的不一样的地方了。一般去重的需求不是一次性的，是要求这些keys存在一段时间 然后客户发很多请求来去重。所以必须要有个地方存这些keys。redis这种缓存很合适，redis也支持bloomfilter 但是坏处就是有误差。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593832599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1140328,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/68/fe556f2f.jpg","nickname":"刘剑","note":"","ucode":"B530AE58C05788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269026,"discussion_content":"一个去重就引入一个redis,未免还是有些重了，blockqueue或者布隆算法，或者其他一些数据结构就能处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589857910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1009831,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/68/a7/c3fd1fd9.jpg","nickname":"聪","note":"","ucode":"9D672A8580A945","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1140328,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/68/fe556f2f.jpg","nickname":"刘剑","note":"","ucode":"B530AE58C05788","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288651,"discussion_content":"blocking queue怎么去处理？数据量大时候必须要用独立的redis集群去存。不是因为简单而就是重。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593832331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269026,"ip_address":""},"score":288651,"extra":""}]}]},{"had_liked":false,"id":187561,"user_name":"芒果少侠","can_delete":false,"product_type":"c1","uid":1350159,"ip_address":"","ucode":"98D0BBB52BB80F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","comment_is_top":false,"comment_ctime":1584158139,"is_pvip":true,"replies":[{"id":"72531","content":"是的👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1584279733,"ip_address":"","comment_id":187561,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879125435","product_id":100034901,"comment_content":"TCP层的ACK机制只能确保传输层（或者说网络传输上）消息传递没有丢失，并不能从“业务层”角度确保消息已经完全正确投递和展示。网络包到达客户端后，可能会出现解析失败，落db失败的情况。","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487147,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584279733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161030,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1576095269,"is_pvip":false,"replies":[{"id":"63282","content":"离线消息可以采取批量方式进行下推。文中有提到时间戳只能保证时序性，要确保消息不丢还需要进一步采取链表校验方式来验证一致性。对于时间戳方式客户端可以简单按时间戳进行排序。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1577363603,"ip_address":"","comment_id":161030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871062565","product_id":100034901,"comment_content":"如果客户端B离线了一段时间，当重连的时候服务器端已经积累了大量B的消息，比如999+条聊天记录，那么服务器端要逐条推送并且逐一更新时间戳么？还是可以批量推送，批量推送又如何保证客户端B的时间戳是最后一条的？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477580,"discussion_content":"离线消息可以采取批量方式进行下推。文中有提到时间戳只能保证时序性，要确保消息不丢还需要进一步采取链表校验方式来验证一致性。对于时间戳方式客户端可以简单按时间戳进行排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577363603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158582,"user_name":"铱","can_delete":false,"product_type":"c1","uid":1043880,"ip_address":"","ucode":"ED558329AAFD54","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJI35InfGaliaSwAmOyk0kPV6n41icaYLcqRzrAA4hpRGRyictPgmabXY3lyQBtECTpibl6cYIsUrS1KA/132","comment_is_top":false,"comment_ctime":1575420866,"is_pvip":true,"replies":[{"id":"60945","content":"sid是一个在一个长连接的会话期间内连续且有序的id，它的作用除了让客户端识别消息的顺序还能让客户端识别消息是否有丢失的情况。而timestamp可以认为是一个全局的用于跨多次长连接的消息排序的。所以不推荐sid来直接代替。<br><br>另外还可以让客户端通过链表的方式来识别消息的顺序性，这样就可以让每条消息都只需要携带一个uuid就能解决排序和丢失识别的问题了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1575627761,"ip_address":"","comment_id":158582,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870388162","product_id":100034901,"comment_content":"老师有个问题请教您，如果在说到服务端发送消息到客户端时为了保证消息重复发送客户端时客户端能够识别重复需要带上一个当前会话范围唯一的sid，同时为了防止服务端发送消息和客户端接收消息步调不一致需要传送一个timestamp（也可用全局顺序号代替，这样的话是否可以直接让sid为一个全局顺序号，从而替代上面所提到sid+timestamp的功能？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476773,"discussion_content":"sid是一个在一个长连接的会话期间内连续且有序的id，它的作用除了让客户端识别消息的顺序还能让客户端识别消息是否有丢失的情况。而timestamp可以认为是一个全局的用于跨多次长连接的消息排序的。所以不推荐sid来直接代替。\n\n另外还可以让客户端通过链表的方式来识别消息的顺序性，这样就可以让每条消息都只需要携带一个uuid就能解决排序和丢失识别的问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575627761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139410,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1570628270,"is_pvip":true,"replies":[{"id":"53917","content":"因为对于消息推送来说，服务端实际上把消息推出之后业务层面是不需要客户端再返回数据的，所以需要增加了一个ack机制来提示已经确认接收。但是对于客户端的发送消息来说，一般业务上都是需要服务端响应这个请求来告知是否发送成功等，所以这个response就代表了服务端肯定接收到数据并且处理了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1570712243,"ip_address":"","comment_id":139410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865595566","product_id":100034901,"comment_content":"老师 为什么服务器需要维护一个ack列表呀，它为啥不能像client发送端那样 发送之后等待回应， 如果没收到， 在重发？<br>或者 client发送端为啥不维护一个ack列表， 而是发送后等待回应，没回应再重发","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469931,"discussion_content":"因为对于消息推送来说，服务端实际上把消息推出之后业务层面是不需要客户端再返回数据的，所以需要增加了一个ack机制来提示已经确认接收。但是对于客户端的发送消息来说，一般业务上都是需要服务端响应这个请求来告知是否发送成功等，所以这个response就代表了服务端肯定接收到数据并且处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570712243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135065,"user_name":"风尘","can_delete":false,"product_type":"c1","uid":1050005,"ip_address":"","ucode":"C6DC76ABFC282B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZjLcrj0O1D0EnDmbvROsYjic6cqiciabYMGUzYL3O90egkmgvAVT6WqBUKodCgyAy0hSuibxiaibRI2Ew/132","comment_is_top":false,"comment_ctime":1568995147,"is_pvip":false,"replies":[{"id":"52008","content":"是的，单纯的时间戳只能解决时序性问题，并不能解决丢消息的问题，这个可以采用链表式版本号方式或者保证连续递增序号推送。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569236497,"ip_address":"","comment_id":135065,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863962443","product_id":100034901,"comment_content":"用户B，只用一个时间戳的话，是否会出现这样的问题：<br>服务器给用户B 推送两条消息：消息1，消息2。用户B 收到了消息2，未收到消息1，然后下线了。<br>重新上线之后，由于记录了消息2 的时间戳，用于跟服务端比较，服务端只会推比消息2 更晚的消息。<br>消息1 就丢失了。","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468027,"discussion_content":"是的，单纯的时间戳只能解决时序性问题，并不能解决丢消息的问题，这个可以采用链表式版本号方式或者保证连续递增序号推送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569236497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134904,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1568949017,"is_pvip":false,"replies":[{"id":"51741","content":"每次下推都需要重开定时器的，一般重启几次仍然失败就放弃不推了。超时这个一般我们是几十秒，太长了也没必要，太短的话会出现重复推送比较多。重推都是针对单条消息的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568954005,"ip_address":"","comment_id":134904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863916313","product_id":100034901,"comment_content":"老师，服务端消息重发，是需要单独开一个定时器是吧，多少秒一次合适呢？一次拉取多少条消息进行重发呢？谢谢","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467950,"discussion_content":"每次下推都需要重开定时器的，一般重启几次仍然失败就放弃不推了。超时这个一般我们是几十秒，太长了也没必要，太短的话会出现重复推送比较多。重推都是针对单条消息的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568954005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131696,"user_name":"钢","can_delete":false,"product_type":"c1","uid":1106184,"ip_address":"","ucode":"A49848BF63A579","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/08/3dc76043.jpg","comment_is_top":false,"comment_ctime":1567853245,"is_pvip":false,"replies":[{"id":"50495","content":"对，一般至少会缓存到离线消息的buffer中。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568035145,"ip_address":"","comment_id":131696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862820541","product_id":100034901,"comment_content":"如果客户端一直连接不上，IM服务器会怎么处理，缓存一段时间的数据?","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466575,"discussion_content":"对，一般至少会缓存到离线消息的buffer中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568035145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131055,"user_name":"卫江","can_delete":false,"product_type":"c1","uid":1101226,"ip_address":"","ucode":"DE2F7A6916F1A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","comment_is_top":false,"comment_ctime":1567611209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862578505","product_id":100034901,"comment_content":"Tcp的ack机制可以保证通过tcp传输的数据被对端内核接受并放入对应的socket接受缓存区里面，但是接下来进程读取缓存区以及进行逻辑处理可能会出现问题，所以需要应用层的ack机制保证数据包被进程读取并正确的处理。","like_count":1},{"had_liked":false,"id":131032,"user_name":"阳阳","can_delete":false,"product_type":"c1","uid":1605341,"ip_address":"","ucode":"078DD80E0ADD38","user_header":"https://static001.geekbang.org/account/avatar/00/18/7e/dd/8098a7e0.jpg","comment_is_top":false,"comment_ctime":1567605637,"is_pvip":true,"replies":[{"id":"49530","content":"留言没完整哈，如果是重复接收的问题，需要客户端来进行去重的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567683358,"ip_address":"","comment_id":131032,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862572933","product_id":100034901,"comment_content":"请问一下老师：如果im服务器发给用户的第一条消息，用户b没有给业务层ack，但是im服务器紧接着又收到了第二条消息往用户b发送，此时用户b返回了正常ack。那么第一条消息在超时的时候会从队列里拿出来重传，假设用户b收到且返回ack成功，这个时候第一条消息","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466256,"discussion_content":"留言没完整哈，如果是重复接收的问题，需要客户端来进行去重的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567683358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131002,"user_name":"我行我素","can_delete":false,"product_type":"c1","uid":1224678,"ip_address":"","ucode":"4C69542FAB0671","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg","comment_is_top":false,"comment_ctime":1567595272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862562568","product_id":100034901,"comment_content":"tcp ack只能保证消息的可达性；业务层面的ack才是保证业务的正确性","like_count":1},{"had_liked":false,"id":357267,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"陕西","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1663126368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663126368","product_id":100034901,"comment_content":"保证消息的可靠投递是 IM 系统设计中至关重要的一个环节，“不丢消息”“消息不重复”对用户体验的影响较大，我们可以通过以下手段来确保消息下推的可靠性。<br>大部分场景和实际实现中，通过业务层的 ACK 确认和重传机制，能解决大部分推送过程中消息丢失的情况。<br>通过客户端的去重机制，屏蔽掉重传过程中可能导致消息重复的问题，从而不影响用户体验。<br>针对重传消息不可达的特殊场景，我们还可以通过“兜底”的完整性检查机制来及时发现消息丢失的情况并进行补推修复，消息完整性检查可以通过时间戳比对，或者全局自增序列等方式来实现。","like_count":0},{"had_liked":false,"id":351761,"user_name":"rikey","can_delete":false,"product_type":"c1","uid":2874133,"ip_address":"","ucode":"87391F61E1F659","user_header":"https://static001.geekbang.org/account/avatar/00/2b/db/15/47cc6edf.jpg","comment_is_top":false,"comment_ctime":1658160089,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658160089","product_id":100034901,"comment_content":"如果服务器宕机，要做好灾备呀，参考kafka，一条消息投递后，写入多个副本才算成功。一台宕机，其他可以直接接上","like_count":0},{"had_liked":false,"id":345143,"user_name":"竹真","can_delete":false,"product_type":"c1","uid":1333642,"ip_address":"","ucode":"451C7393CBCA80","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/8a/82587883.jpg","comment_is_top":false,"comment_ctime":1652076578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652076578","product_id":100034901,"comment_content":"“用户 B 重新连上线，携带本地最新的时间戳 timestamp1，IM 服务器将用户 B 暂存的消息中时间戳大于 timestamp1 的所有消息返回给用户 B，其中就包括之前没有成功的 msg2” 针对这句话我有个疑问，用户b重新连接之后会主动请求服务端吗？还有就是前文讲到了待ack队列，服务恢复后，把队列中的消息重试发送一次可以保证消息不丢吗？","like_count":0},{"had_liked":false,"id":333164,"user_name":"Stklose","can_delete":false,"product_type":"c1","uid":1019259,"ip_address":"","ucode":"A4E4BEE7D661CC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiaFLicTlefCnibAJ8sVFtLTAuKbvW3bPH3aqfxxCalXxDZNY2PgkhxYnguzjXU5Yh4Lw/132","comment_is_top":false,"comment_ctime":1644148249,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644148249","product_id":100034901,"comment_content":"对于ack与seqid设计，这里不考虑使用im会话中唯一msgid标识，而引入额外的seqid作为ack处理有什么考虑吗？","like_count":0},{"had_liked":false,"id":321448,"user_name":"锅ke24","can_delete":false,"product_type":"c1","uid":1150086,"ip_address":"","ucode":"74DA5ADA00921A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8c/86/7ebf0053.jpg","comment_is_top":false,"comment_ctime":1636880876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636880876","product_id":100034901,"comment_content":"优秀的留言收藏不了呀！tcp 属于传输层，其 ack 机制不能保证把数据交给应用层，即业务层。所以需要业务层的 ack 机制。","like_count":0},{"had_liked":false,"id":290523,"user_name":"新","can_delete":false,"product_type":"c1","uid":1031478,"ip_address":"","ucode":"47F56863DE9F0F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/36/f50ab7ec.jpg","comment_is_top":false,"comment_ctime":1619599928,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619599928","product_id":100034901,"comment_content":"文章中给出的第一部分，A发送消息给IM服务使用的是什么协议？看起来这部分的处理不也是一种业务层面的ACK机制吗？","like_count":0},{"had_liked":false,"id":285257,"user_name":"Geek4329","can_delete":false,"product_type":"c1","uid":2028951,"ip_address":"","ucode":"D6FB8D1B2D5DAC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/97/9a7ee7b3.jpg","comment_is_top":false,"comment_ctime":1616700495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616700495","product_id":100034901,"comment_content":"通过消息ID连续性判断丢失由客户端发起重试，和ACK由服务端发起重试，应该不能共用，但是客户端发起重试的前提是有一条ID不连续的新消息，如果没有这个新消息，客户端就不知道丢失消息，那么是不是客户端这种重试方式是不行的呢","like_count":0},{"had_liked":false,"id":285256,"user_name":"Geek4329","can_delete":false,"product_type":"c1","uid":2028951,"ip_address":"","ucode":"D6FB8D1B2D5DAC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/97/9a7ee7b3.jpg","comment_is_top":false,"comment_ctime":1616699943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616699943","product_id":100034901,"comment_content":"如果消息的ID在会话级别是连续递增的，是不是可以由客户端通过ID连续性检验消息是否丢失，如果发现不连续，直接请求缺少的消息ID，这样不比ACK的方式简单很多吗","like_count":0},{"had_liked":false,"id":267377,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1607698771,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607698771","product_id":100034901,"comment_content":"有了 TCP 协议本身的 ACK 机制，为什么还需要业务层的 ACK 机制？<br>因为这是消息消费的两个阶段，送达和处理，tcp保证的消息送达用户，而业务层ack保证消息被处理，没有业务层ack是不完整的","like_count":0},{"had_liked":false,"id":234762,"user_name":"MadleS_F","can_delete":false,"product_type":"c1","uid":1670997,"ip_address":"","ucode":"D6B6C29F576B7A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoV9IsMsiawicpaaTXqhPzqH2mA5HUKUSyJ5fbUhoqTKhNRxJ5dibhs5bkTqCSqcuolZT7sam2sn8sBA/132","comment_is_top":false,"comment_ctime":1594789444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594789444","product_id":100034901,"comment_content":"老师，问个问题:<br>在有兜底的情况下,为什么我们还需要ACK？<br>在各端都完善的情况下，如：<br>服务端有去重、验证完整性策略<br>客户端有去重、存储当前msg版本的情况下。<br>感觉业务ACK机制似乎没有存在的必要了啊？<br>举个没有ACK回执的例子：<br>服务器给用户B推送msg1,并追加当前消息时间戳或版本号，那么会有如下几种情况:<br>1.服务器推送未成功,用户B未接收到消息.那么这时候用户B本地的时间戳或版本号应该不会改变，<br>当用户B重新连线推送本地时间戳，服务器进行完整性验证后即能推送丢失的信息给B，哪怕有重复，只要用户B做好去重机制，也能保证消息的完整性。<br>2.服务器推送成功，用户B持久化等处理失败,这时候用户B的时间戳或版本号同样也应该不会改变。<br>3.服务器推送成功，用户B处理成功，并改变本地时间戳或版本号。这时候哪怕不ACK，用户B下次重连的时候版本号都是最新的，服务器也能知道用户B的版本是完整的啊。<br>所以在各端都完善的情况下业务ACK是否会显得有些多余？因为消息完整性校验就能保证消息不丢了。为什么还要增加ACK呢？","like_count":0},{"had_liked":false,"id":215077,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1588901009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588901009","product_id":100034901,"comment_content":"有了 TCP 协议本身的 ACK 机制，为什么还需要业务层的 ACK 机制？<br><br>一个是保障网络可靠性，一个是保障业务可靠性","like_count":0},{"had_liked":false,"id":202374,"user_name":"Jonah","can_delete":false,"product_type":"c1","uid":1079507,"ip_address":"","ucode":"2C4799BD2FF0DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/d3/1dc40aa2.jpg","comment_is_top":false,"comment_ctime":1585979319,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585979319","product_id":100034901,"comment_content":"TCP消息只能保证消息投递的可靠性，并不能保证消息被消费的准确性，例如Client接收到消息后，业务逻辑处理阶段失败了，此时TCP的ACK是成功的，但是消息没入库。所以业务的ACK是为了保证业务逻辑处理成功。","like_count":0},{"had_liked":false,"id":196329,"user_name":"wl_power","can_delete":false,"product_type":"c1","uid":1508477,"ip_address":"","ucode":"ABDBC6A18A1E7A","user_header":"https://static001.geekbang.org/account/avatar/00/17/04/7d/75be729a.jpg","comment_is_top":false,"comment_ctime":1585273164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585273164","product_id":100034901,"comment_content":"老师你好：请问下，检查消息完整性使用时间戳会因为多台im服务器时间可能不一致而导致客服端获取消息丢失之类的吗，还是说我理解有问题","like_count":0},{"had_liked":false,"id":188948,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1584437929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584437929","product_id":100034901,"comment_content":"收获很大，都是干货","like_count":0},{"had_liked":false,"id":181013,"user_name":"javaworker","can_delete":false,"product_type":"c1","uid":1056209,"ip_address":"","ucode":"ABF9DDDBD3BDBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/d1/f427b83e.jpg","comment_is_top":false,"comment_ctime":1582459533,"is_pvip":true,"replies":[{"id":"72289","content":"您这里指的IM端和业务端是指的IM服务端和接收消息的手机端吗？ IM服务端去重是避免针对发送方同样内容的消息由于重试等原因存储多次并且生成多条消息，接收端去重只能解决同一条消息不重，不能解决同样内容的两条消息不重。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1584085083,"ip_address":"","comment_id":181013,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582459533","product_id":100034901,"comment_content":"老师，为什么业务端有对sequenceId的去重，IM端还要有去重呐？IM端不去重也可以吧，反正最终发到业务端有去重啊","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484888,"discussion_content":"您这里指的IM端和业务端是指的IM服务端和接收消息的手机端吗？ IM服务端去重是避免针对发送方同样内容的消息由于重试等原因存储多次并且生成多条消息，接收端去重只能解决同一条消息不重，不能解决同样内容的两条消息不重。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584085083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155951,"user_name":"HELSING","can_delete":false,"product_type":"c1","uid":1183964,"ip_address":"","ucode":"7F33BFCAA8219B","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/dc/fc9efd01.jpg","comment_is_top":false,"comment_ctime":1574781539,"is_pvip":false,"replies":[{"id":"60937","content":"是的，ack一般都需要设置次数限制避免由于对端异常导致无法正常回ack包，线上的经验一般是2-3次就可以了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1575626055,"ip_address":"","comment_id":155951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574781539","product_id":100034901,"comment_content":"ack 重传需要设置重传次数吗？比如接收端业务逻辑有异常，每次处理都抛异常，那服务端要怎么处理？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475936,"discussion_content":"是的，ack一般都需要设置次数限制避免由于对端异常导致无法正常回ack包，线上的经验一般是2-3次就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575626055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154895,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1574593591,"is_pvip":true,"replies":[{"id":"59888","content":"👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1574771994,"ip_address":"","comment_id":154895,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574593591","product_id":100034901,"comment_content":"tcp保证的是网络传输，业务层保证的是消息处理阶段，这两个在不同的层级","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475608,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574771994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147192,"user_name":"唯我天棋","can_delete":false,"product_type":"c1","uid":1015960,"ip_address":"","ucode":"B925246C92727A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/98/5591d99d.jpg","comment_is_top":false,"comment_ctime":1572835376,"is_pvip":true,"replies":[{"id":"57198","content":"是的，传输层可靠不代表业务层可靠。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1573034943,"ip_address":"","comment_id":147192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572835376","product_id":100034901,"comment_content":"tcp的ack只保证网络传输过程中的消息可靠达到。但是，在业务场景上网络传输只是其中的一个步骤，所以，不能保证。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473191,"discussion_content":"是的，传输层可靠不代表业务层可靠。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573034943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141823,"user_name":"五点半先生","can_delete":false,"product_type":"c1","uid":1408320,"ip_address":"","ucode":"CE820DFE00D0AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/7d/40/2a0ac40f.jpg","comment_is_top":false,"comment_ctime":1571231417,"is_pvip":false,"replies":[{"id":"54993","content":"单聊和群聊一般存储实现上不太一样，群聊一般采用读扩散的方式，群聊内容只存储一份。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571403595,"ip_address":"","comment_id":141823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571231417","product_id":100034901,"comment_content":"单聊消息是不可以认为是一种特殊的群聊，存储方式是不是一样的","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470900,"discussion_content":"单聊和群聊一般存储实现上不太一样，群聊一般采用读扩散的方式，群聊内容只存储一份。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571403595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136282,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1569403005,"is_pvip":false,"replies":[{"id":"52238","content":"这种情况默认只获取最新的部分消息，然后再早的消息可以通过“用时拉取”的方式来获取，是推拉结合的方式。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569413100,"ip_address":"","comment_id":136282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569403005","product_id":100034901,"comment_content":"评论里有人提到如果客户端清空所有消息，再次上线时如何进行消息完整性检查？是要把所有的历史消息都拉取一遍吗？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468541,"discussion_content":"这种情况默认只获取最新的部分消息，然后再早的消息可以通过“用时拉取”的方式来获取，是推拉结合的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569413100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134956,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1568962364,"is_pvip":false,"replies":[{"id":"51781","content":"重推和netty本身没关系哈，在推消息前，先把这条消息放入本地或者中央的存储里（如果收到ack会remove掉这条消息）。然后通过ScheduledExecutorService来对这条消息增加一个timer。timer触发时去检查这条消息是否有ack，如果没有就触发重推。大概的核心代码如下：<br><br>&#47;&#47;before write to channel<br>addMsgToAckBuffer(channel, wesyncMessage);<br><br><br>&#47;&#47;addMsgToAckBuffer 细节<br>private ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(...);<br> executorService.schedule(() -&gt; {<br> boolean isAcked = checkAndResend(channel, msg, tryTimes);<br>});<br><br>重推是由timer自动触发的，一次推送会对应一次重推（多条消息打包下推也是一次推送）。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568968073,"ip_address":"","comment_id":134956,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568962364","product_id":100034901,"comment_content":"老师，您说的下推的时候启动定时器，是在哪个位置启动呢？因为下推都是在异步进行操作，netty的话用的哪个方法呢，还有如果是高并发的场景，消息来的很快，那么待ack列表里面可能会有消息积压，所以想问下重推的时候是每次从待ack列表里面取一条消息进行重推吗？谢谢","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467976,"discussion_content":"重推和netty本身没关系哈，在推消息前，先把这条消息放入本地或者中央的存储里（如果收到ack会remove掉这条消息）。然后通过ScheduledExecutorService来对这条消息增加一个timer。timer触发时去检查这条消息是否有ack，如果没有就触发重推。大概的核心代码如下：\n\n//before write to channel\naddMsgToAckBuffer(channel, wesyncMessage);\n\n\n//addMsgToAckBuffer 细节\nprivate ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(...);\n executorService.schedule(() -&amp;gt; {\n boolean isAcked = checkAndResend(channel, msg, tryTimes);\n});\n\n重推是由timer自动触发的，一次推送会对应一次重推（多条消息打包下推也是一次推送）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568968073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134590,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1568874749,"is_pvip":false,"replies":[{"id":"51644","content":"待ack列表个人感觉没必要落地存储，可以放在网关机本地内存中，比如使用netty的话，可以放在channel cache里就可以，如果担心重启丢消息的话，也可以放在中央的资源里，比如redis里的zset结构中。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568891906,"ip_address":"","comment_id":134590,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568874749","product_id":100034901,"comment_content":"老师，关于群聊ack，用户发一条群消息，如果群里面在线有100人，那么这条消息会异步插入100条到待ack列表，然后进行推送，客户端收到后进行ack，否则服务端进行重传，还需要考虑多个群的情况，所以想问下，这个待ack列表是怎么设计的，比如用MySQL的话，字段怎么设计呢，后面需要考虑分表吗？谢谢","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467819,"discussion_content":"待ack列表个人感觉没必要落地存储，可以放在网关机本地内存中，比如使用netty的话，可以放在channel cache里就可以，如果担心重启丢消息的话，也可以放在中央的资源里，比如redis里的zset结构中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568891906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134483,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1568854517,"is_pvip":false,"replies":[{"id":"51594","content":"是的，对于IM服务器来说，没必要区分是发送过程丢失还是ack回包丢失（实际上也没法区分），重推去重就可以。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568877874,"ip_address":"","comment_id":134483,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568854517","product_id":100034901,"comment_content":"其实没有收到请求响应都能视为丢失吧，无论是im服务器还是客户端应该都可以使用唯一ID做幂等去重，丢失的内容尽管重发就好了吧","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467765,"discussion_content":"是的，对于IM服务器来说，没必要区分是发送过程丢失还是ack回包丢失（实际上也没法区分），重推去重就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568877874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451391,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","nickname":"曾轼麟","note":"","ucode":"D418371AC11270","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16252,"discussion_content":"老师那这个唯一ID要怎么分配？之前研究过雪花算法，但是感觉在客户端APP的情况下雪花算法不太现实，那是使用UUID吗？UUID会不会有碰撞的情况，而且UUID没法保证顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568879503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132692,"user_name":"=","can_delete":false,"product_type":"c1","uid":1509275,"ip_address":"","ucode":"8CDFDA26B049C6","user_header":"https://static001.geekbang.org/account/avatar/00/17/07/9b/a62348fd.jpg","comment_is_top":false,"comment_ctime":1568194582,"is_pvip":false,"replies":[{"id":"50859","content":"待ack消息列表的话放在channel cache的一个ConcurrentHashMap就可以吧，单聊消息内容可以和列表放一起，群聊的话为了节省内存可以把内容放到redis里，重推的时候再去取。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568202041,"ip_address":"","comment_id":132692,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568194582","product_id":100034901,"comment_content":"老师，请问一个问题，就是消息缓存采用JDK什么消息队列比较好呢? 场景:服务端消息推送到客户端-重发、移除（客户端已经反馈收到了）","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467074,"discussion_content":"待ack消息列表的话放在channel cache的一个ConcurrentHashMap就可以吧，单聊消息内容可以和列表放一起，群聊的话为了节省内存可以把内容放到redis里，重推的时候再去取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568202041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132674,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1568190276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568190276","product_id":100034901,"comment_content":"消息系统复杂程度堪比TCP协议栈啊","like_count":0},{"had_liked":false,"id":132463,"user_name":"鹿小6","can_delete":false,"product_type":"c1","uid":1197368,"ip_address":"","ucode":"94511AE7C89269","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/38/0f948866.jpg","comment_is_top":false,"comment_ctime":1568127334,"is_pvip":false,"replies":[{"id":"50847","content":"时间戳只能拉取更新的数据不能用来作为去重使用，由服务器下发的连接维度的连续自增的seqID是可以用来去重和判断消息连续性的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568199031,"ip_address":"","comment_id":132463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568127334","product_id":100034901,"comment_content":"去重机制里的Sequence ID 和 时间戳比对法 是否可以二选一呢？感觉二者作用相似，都类似于offset","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466951,"discussion_content":"时间戳只能拉取更新的数据不能用来作为去重使用，由服务器下发的连接维度的连续自增的seqID是可以用来去重和判断消息连续性的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568199031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132424,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1568118700,"is_pvip":true,"replies":[{"id":"50662","content":"接收方判断服务端下发的消息是否重复的话可以通过全局唯一的消息id来进行判重，判重的话只要求这个id是唯一就可以，当然如果能做成“时间相关而且唯一”的id话更好，既能去重也能排序用。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568130108,"ip_address":"","comment_id":132424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568118700","product_id":100034901,"comment_content":"两条消息认为是重复消息，通过sequenceId是否相同来判断，那这个sequenceID的生成规则是什么？如何保证两条重复消息的sequenceID相同？<br>","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466930,"discussion_content":"接收方判断服务端下发的消息是否重复的话可以通过全局唯一的消息id来进行判重，判重的话只要求这个id是唯一就可以，当然如果能做成“时间相关而且唯一”的id话更好，既能去重也能排序用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568130108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132422,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1568118601,"is_pvip":true,"replies":[{"id":"50661","content":"服务端判断发送方消息重复的话主要通过发送方uid和发送内容进行比对；接收方判断服务端下发的消息是否重复的话可以通过全局唯一的消息id来进行判重。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568130000,"ip_address":"","comment_id":132422,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568118601","product_id":100034901,"comment_content":"怎么判断是否是重复的消息呢？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466928,"discussion_content":"服务端判断发送方消息重复的话主要通过发送方uid和发送内容进行比对；接收方判断服务端下发的消息是否重复的话可以通过全局唯一的消息id来进行判重。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568130000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132314,"user_name":"影随","can_delete":false,"product_type":"c1","uid":1088169,"ip_address":"","ucode":"48BC4CFCAD3C2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/a9/ae10f6cd.jpg","comment_is_top":false,"comment_ctime":1568082446,"is_pvip":false,"replies":[{"id":"50656","content":"是的，自己做的话需要集成5大安卓厂商的sdk，目前没法绕过厂商来搞，可以期待一下工信部主导的“统一推送联盟”的“推必达”产品，除了网络信令可以依托电信信令来进行系统推送。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568129142,"ip_address":"","comment_id":132314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568082446","product_id":100034901,"comment_content":"老师您好，如果我们要自己去实现类似极光等第三方消息推送的话，是不是要去实现各个手机厂商的系统级客户端通讯呢？ 能不能绕过手机厂商去做离线消息推送 ？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466873,"discussion_content":"是的，自己做的话需要集成5大安卓厂商的sdk，目前没法绕过厂商来搞，可以期待一下工信部主导的“统一推送联盟”的“推必达”产品，除了网络信令可以依托电信信令来进行系统推送。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568129142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131527,"user_name":"YidWang","can_delete":false,"product_type":"c1","uid":1619756,"ip_address":"","ucode":"C91A9117EC3540","user_header":"https://static001.geekbang.org/account/avatar/00/18/b7/2c/e1682683.jpg","comment_is_top":false,"comment_ctime":1567781667,"is_pvip":false,"replies":[{"id":"50326","content":"链路长不是问题呀，只要这个 时间相关的序号 可以一直跟着消息落db的话。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567842141,"ip_address":"","comment_id":131527,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567781667","product_id":100034901,"comment_content":"我认为时间戳做这件事 不正确，链路交互太长 失败率太高！","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466504,"discussion_content":"链路长不是问题呀，只要这个 时间相关的序号 可以一直跟着消息落db的话。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567842141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1618781,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b3/5d/a97e5045.jpg","nickname":"小宽宽与他的白日梦","note":"","ucode":"C16F595EE4E11A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9361,"discussion_content":"我们的做法是？在redis中存储一个未接收的列表。用户断线重连时，会使用http的方式。来拉取用户未接收的消息。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568161148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131477,"user_name":"Chao","can_delete":false,"product_type":"c1","uid":1108745,"ip_address":"","ucode":"DD7742F5537521","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/09/ba5f0135.jpg","comment_is_top":false,"comment_ctime":1567761256,"is_pvip":false,"replies":[{"id":"49876","content":"tcp的ack只能保证连接层的“不丢数据”和“不乱序”，但数据在接收时给到应用层的时候还可能出现丢失的情况。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567770432,"ip_address":"","comment_id":131477,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567761256","product_id":100034901,"comment_content":"tcp ack 。只保证分组的数据完整，不保证客户端传输的完整","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466473,"discussion_content":"tcp的ack只能保证连接层的“不丢数据”和“不乱序”，但数据在接收时给到应用层的时候还可能出现丢失的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567770432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131304,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1567698237,"is_pvip":false,"replies":[{"id":"49864","content":"比如群里有用户A、B、C，这三个用户分别连接到IM服务器，A往群里发送一条消息，B和C的连接的网关机分别下推这一条消息，并且将这条消息分别加入到B和C的“待ACK列表”，如果B接收后处理成功然后回了ACK，B的网关机收到ACK就会从“待ACK列表”删除这条消息；如果C接收后客户端本地db写入失败，这时C的客户端就不会回ACK，C的网关机一段时间后没有接收到这条消息的ACK，就会触发超时重传，重新发送这条消息给C的客户端。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567768840,"ip_address":"","comment_id":131304,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1567698237","product_id":100034901,"comment_content":"在线群聊ack没有懂，老师能举个实例吗，比如在线群消息客户端插入失败然后怎么处理呢？谢谢","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466380,"discussion_content":"比如群里有用户A、B、C，这三个用户分别连接到IM服务器，A往群里发送一条消息，B和C的连接的网关机分别下推这一条消息，并且将这条消息分别加入到B和C的“待ACK列表”，如果B接收后处理成功然后回了ACK，B的网关机收到ACK就会从“待ACK列表”删除这条消息；如果C接收后客户端本地db写入失败，这时C的客户端就不会回ACK，C的网关机一段时间后没有接收到这条消息的ACK，就会触发超时重传，重新发送这条消息给C的客户端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567768840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326338,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","nickname":"东东🎈","note":"","ucode":"D1BBE24CF76426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8085,"discussion_content":"老师，我们的业务是千人群，然后每天有一个群有几万条消息，这个ack会不会很频繁？\n还有我们采用的是读扩散，因为这种模式下，分页拉取，消息会断层，所以每次离线上线再进群就会先清空本地数据库这个群的消息，后续线上操作全部走服务端拉取，存储本地，离线再上线就又会清空本地数据库，不知道这样设计会不会出现大问题？谢谢","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567774948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1111899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","nickname":"时隐时现","note":"","ucode":"DA4D622FF84920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1326338,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","nickname":"东东🎈","note":"","ucode":"D1BBE24CF76426","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21338,"discussion_content":"希望专栏作者能解答一下 多谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569469046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8085,"ip_address":""},"score":21338,"extra":""}]}]},{"had_liked":false,"id":131269,"user_name":"Geek_37e993","can_delete":false,"product_type":"c1","uid":1645048,"ip_address":"","ucode":"0E87EFA4B0D5F0","user_header":"","comment_is_top":false,"comment_ctime":1567687279,"is_pvip":false,"replies":[{"id":"49862","content":"这个和服务端没有收到ack进行从“待ack列表”取出未ack的消息进行重推是类似处理思路。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567768451,"ip_address":"","comment_id":131269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567687279","product_id":100034901,"comment_content":"设想一下，假设一台 IM 服务器在推送出消息后，由于硬件原因宕机了，这种情况下，如果这条消息真的丢了，由于负责的 IM 服务器宕机了无法触发重传，导致接收方 B 收不到这条消息。<br><br>这就存在一个问题，当用户 B 再次重连上线后，可能并不知道之前有一条消息丢失的情况。对于这种重传失效的情况该如何处理？<br><br><br><br>对这一段有个疑问，是不是可以这么处理，服务器没有收到ack就不把消息状态改为发送成功，这样服务器重启后，依然会推送未发送成功的消息","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466360,"discussion_content":"这个和服务端没有收到ack进行从“待ack列表”取出未ack的消息进行重推是类似处理思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567768451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131237,"user_name":"一路向北","can_delete":false,"product_type":"c1","uid":1376654,"ip_address":"","ucode":"54D8F1687AE1ED","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/8e/48e7c474.jpg","comment_is_top":false,"comment_ctime":1567676806,"is_pvip":false,"replies":[{"id":"49543","content":"嗯，实际上确实是可以这么做的。发送时只写缓存然后响应，来提升发送性能。不过一般推送用户B会在落地完DB后。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567684403,"ip_address":"","comment_id":131237,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567676806","product_id":100034901,"comment_content":"我有个想法，关于服务端消息暂存。当服务端接收到消息后，先存到redis中（因为redis缓存速度比DB快），一旦存入redis成功，就同时反馈用户A，和推送用户B。然后再将消息从redis中通过异步操作存到DB中。这样对提升服务器性能有真正的帮助吗？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466345,"discussion_content":"嗯，实际上确实是可以这么做的。发送时只写缓存然后响应，来提升发送性能。不过一般推送用户B会在落地完DB后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567684403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376654,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/8e/48e7c474.jpg","nickname":"一路向北","note":"","ucode":"54D8F1687AE1ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7949,"discussion_content":"您说的在落地DB后再推送用户B，是因为要带上消息ID吧？如果我有一个可靠的方法，能够在redis存储的时候产生唯一可靠的ID，此ID也会写入DB中的ID字段，应该没问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567736765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131184,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1567665843,"is_pvip":false,"replies":[{"id":"49539","content":"1. ack不是和某一条消息绑定的，是和某一个人要接收的消息绑定的，是某一个连接维度的。<br>2. 可以只拉取联系人第一页中的群的第一页的消息。<br>3. 一般是读扩散。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567684247,"ip_address":"","comment_id":131184,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567665843","product_id":100034901,"comment_content":"比如群里面5个人，一条群消息，如果只被3个人ack了，那这条消息还可以在等待ack队列里面进行重推？<br>还有消息完整性检查是推还是拉，有什么区别？<br>如果拉的话，是上线就分页一次拉取每个群的最新100条的话，群多的话会不会影响性能？<br>假如一个群，每天上万条消息，采用读扩散还是写扩散呢？<br>谢谢，老师解答","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466326,"discussion_content":"1. ack不是和某一条消息绑定的，是和某一个人要接收的消息绑定的，是某一个连接维度的。\n2. 可以只拉取联系人第一页中的群的第一页的消息。\n3. 一般是读扩散。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567684247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131104,"user_name":"FF","can_delete":false,"product_type":"c1","uid":1001615,"ip_address":"","ucode":"26349F32B406D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/8f/7ecd4eed.jpg","comment_is_top":false,"comment_ctime":1567644536,"is_pvip":false,"replies":[{"id":"49538","content":"1. 一般尝试重推几次，还是失败的话就放弃。因为等用户再次上线是还是能够通过离线消息获取到的。<br>2. 服务端只能用来防止同一个用户的同一条消息发送多次的去重，对于推送过程中由于没有收到ack导致的接收重复需要接收端来做本地的去重，接收方去重和不保存用户消息不冲突。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567684051,"ip_address":"","comment_id":131104,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567644536","product_id":100034901,"comment_content":"几个问题。问题一，IM 服务器和接收端 B 之前的网络如果是硬件类的故障，长时间连不上，这种情况下 IM 服务器是重推到成功为止吗 ？如果受影响的 B 是大范围，像支付宝之前的光缆被挖断，那 IM 服务器的压力不是特别大吗 ？考虑重推 N 次失败后不再重推，告诉用户重发这种方案如何呢 ？<br><br><br>问题二，无论在 B 端还是消息存储服务器，为了达到去重这个目的，消息一般存储多久呢 ？这个期限如何界定 ？微信说他不保存用户消息，他又是如何做到去重的呢 ？<br><br>盼复，感谢 。<br><br>","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466287,"discussion_content":"1. 一般尝试重推几次，还是失败的话就放弃。因为等用户再次上线是还是能够通过离线消息获取到的。\n2. 服务端只能用来防止同一个用户的同一条消息发送多次的去重，对于推送过程中由于没有收到ack导致的接收重复需要接收端来做本地的去重，接收方去重和不保存用户消息不冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567684051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131069,"user_name":"小胡子","can_delete":false,"product_type":"c1","uid":1018182,"ip_address":"","ucode":"79FEC6400D25DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/46/0b7828a1.jpg","comment_is_top":false,"comment_ctime":1567630319,"is_pvip":false,"replies":[{"id":"49536","content":"ack本身对服务端来说开销还好呀，大部分消息到达率是很高的，所以一般只是从本地内存的”待ack列表“删除接收到ack对应的那条记录就行。如果确实对这个很敏感，也可以把ack逻辑独立到另外的服务去处理。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567683742,"ip_address":"","comment_id":131069,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567630319","product_id":100034901,"comment_content":"应用层增加这么复杂的ack机制时，感觉影响推送服务的性能，这时应该有哪些优化手段","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466271,"discussion_content":"ack本身对服务端来说开销还好呀，大部分消息到达率是很高的，所以一般只是从本地内存的”待ack列表“删除接收到ack对应的那条记录就行。如果确实对这个很敏感，也可以把ack逻辑独立到另外的服务去处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567683742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042354,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/b2/334bc992.jpg","nickname":"AlfredLover","note":"","ucode":"A3A998F362CC37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412938,"discussion_content":"我也觉得有点重。ack是通过应用层定时任务去读取&#34;待ack列表&#34;去重试？成功之后需要更新数据库状态？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636336478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131035,"user_name":"阳阳","can_delete":false,"product_type":"c1","uid":1605341,"ip_address":"","ucode":"078DD80E0ADD38","user_header":"https://static001.geekbang.org/account/avatar/00/18/7e/dd/8098a7e0.jpg","comment_is_top":false,"comment_ctime":1567605842,"is_pvip":true,"replies":[{"id":"49531","content":"对于普通的聊天场景这个没关系，客户端接收到之后可以再进行一次页面上的排序就可以。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567683437,"ip_address":"","comment_id":131035,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567605842","product_id":100034901,"comment_content":"请问一下老师：假如im服务器给用户b发送第一条消息，用户b没有返回业务ack，在超时时间到达之前，im服务器又收到了第二条消息，往用户b发送，假设用户b收到，且ack返回成功，接着im服务器超时时间到达，从重传队列里拿出第一条消息重新发送，用户b接收成功且返回成功ack，那么第一条消息岂不是在第二条消息后收到？这个有什么办法解决？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466258,"discussion_content":"对于普通的聊天场景这个没关系，客户端接收到之后可以再进行一次页面上的排序就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567683437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068542,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","nickname":"威","note":"","ucode":"C921CDCB22B9A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341778,"discussion_content":"如果好像老师答复的那样，不就会出现一些幽灵一样的消息，第二条消息先显示出来，然后第一条消息突然展示在第二条消息前面？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610521076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130925,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1567577795,"is_pvip":false,"replies":[{"id":"49171","content":"是一样的，对于接受方来说，单聊消息和群聊消息都是一条消息。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567598123,"ip_address":"","comment_id":130925,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567577795","product_id":100034901,"comment_content":"群聊ack怎么重试？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466198,"discussion_content":"是一样的，对于接受方来说，单聊消息和群聊消息都是一条消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567598123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326338,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","nickname":"东东🎈","note":"","ucode":"D1BBE24CF76426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7696,"discussion_content":"比如群里面5个人，一条群消息，如果只被3个人ack了，那这条消息还可以在等待ack队列里面进行重推？\n还有消息完整性检查是推还是拉，有什么区别？\n如果拉的话，是上线就分页一次拉取每个群的最新100条的话，群多的话会不会影响性能？\n假如一个群，每天上万条消息，采用读扩散还是写扩散呢？\n谢谢，老师解答","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567642995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130894,"user_name":"牛顿的烈焰激光剑","can_delete":false,"product_type":"c1","uid":1042022,"ip_address":"","ucode":"C57018C65DAFB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e6/66/fbbf0bb1.jpg","comment_is_top":false,"comment_ctime":1567567021,"is_pvip":false,"replies":[{"id":"49167","content":"嗯嗯，是这样的，TCP只能保证网络传输层的可靠，并不能保证业务层也成功处理了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567597812,"ip_address":"","comment_id":130894,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567567021","product_id":100034901,"comment_content":"对问题的思考：<br><br>TCP 层的 ACK 机制作用的范围仅在于单次信息传输，但是无法保证业务层的良好体验（即使是简单的业务也是由多条消息复合而成）。通俗点说就是网络环境太复杂，一定要有后手准备。以前我们开发过一款和服务器端交互的小游戏，由于没有在业务级别设置良好的 ACK 机制，导致测试阶段的体验就已经很差，这也是一大教训。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466181,"discussion_content":"嗯嗯，是这样的，TCP只能保证网络传输层的可靠，并不能保证业务层也成功处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567597812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130886,"user_name":"陈天天天天....","can_delete":false,"product_type":"c1","uid":1483319,"ip_address":"","ucode":"A25837AA474A80","user_header":"https://static001.geekbang.org/account/avatar/00/16/a2/37/310b1a6c.jpg","comment_is_top":false,"comment_ctime":1567564520,"is_pvip":false,"replies":[{"id":"49165","content":"可以考虑tcp的delay-ack机制哈，短时间如果还有其他数据要发送的时候可以打包一起回。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567597732,"ip_address":"","comment_id":130886,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567564520","product_id":100034901,"comment_content":"Ack看上去是一种保证接收的手段，但也考虑到如果消息特别多的情况下，Ack会不会成为服务端的一种负担呢？有没有一些技巧减少ack消息量的手段？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466175,"discussion_content":"可以考虑tcp的delay-ack机制哈，短时间如果还有其他数据要发送的时候可以打包一起回。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567597732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7708,"discussion_content":"意思是参考 tcp 的 delay-ack 机制实现业务层面的 delay-ack 么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567647728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130862,"user_name":"东东🎈","can_delete":false,"product_type":"c1","uid":1326338,"ip_address":"","ucode":"D1BBE24CF76426","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/02/ecdb4e66.jpg","comment_is_top":false,"comment_ctime":1567561126,"is_pvip":false,"replies":[{"id":"49142","content":"对于第一个问题，可以对离线消息进行分页下推，或者只拉取最新的x条消息，后续的由客户端真正查看时再从服务端按需拉取，这种属于推拉结合了。有新消息来没问题的哈，都是走的一个连接，只是需要客户端来进行按时间戳排序了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567596597,"ip_address":"","comment_id":130862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567561126","product_id":100034901,"comment_content":"关于消息完整性检查，客户端重连后通过本地收到的最新消息去服务端拉取所有大于timestamp1的消息下发到本地进行补救，但是这个所有如果有几万条消息怎么处理，比如用户几天没有在线，还有这个时候又有新消息怎么处理？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466161,"discussion_content":"对于第一个问题，可以对离线消息进行分页下推，或者只拉取最新的x条消息，后续的由客户端真正查看时再从服务端按需拉取，这种属于推拉结合了。有新消息来没问题的哈，都是走的一个连接，只是需要客户端来进行按时间戳排序了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130846,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1567559272,"is_pvip":false,"replies":[{"id":"49136","content":"tcp层只能保证传输层的可靠性，并不能真正保证业务层的成功接收。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567596369,"ip_address":"","comment_id":130846,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567559272","product_id":100034901,"comment_content":"Tcp的话，当网关接入点宕机的话可能会丢失之前传输的序列。应用层控制可以自定义，增加一些可靠机制，比如超时时间控制，传输回放而不依赖tcp","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466152,"discussion_content":"tcp层只能保证传输层的可靠性，并不能真正保证业务层的成功接收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130811,"user_name":"恰同学少年","can_delete":false,"product_type":"c1","uid":1494856,"ip_address":"","ucode":"AFA497A2172E52","user_header":"https://static001.geekbang.org/account/avatar/00/16/cf/48/032d6dfc.jpg","comment_is_top":false,"comment_ctime":1567556217,"is_pvip":false,"replies":[{"id":"49127","content":"是这样的，👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567596123,"ip_address":"","comment_id":130811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567556217","product_id":100034901,"comment_content":"TCP的ACK跟业务消息并不是一一对应的，同样的消息第一次发与第二次发，TCP分的包大小大是不一样的，这样业务消息就很难跟TCP的小包对应起来，涉及到重发，重连，去重等场景，问题只会变得更复杂。<br><br>还有一个就是传输不一定要使用TCP协议，如果耦合在一起，更换传输协议时，业务层要重写相当一部分。<br><br>还有一个TCP保证传输完整，保证业务完整需要我们自己做。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466141,"discussion_content":"是这样的，👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130808,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1567555704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567555704","product_id":100034901,"comment_content":"假设服务器推送消息也是一个“请求”和“响应”的过程，","like_count":0},{"had_liked":false,"id":130792,"user_name":"Geek_发现","can_delete":false,"product_type":"c1","uid":1643741,"ip_address":"","ucode":"39C23F2D574A09","user_header":"https://static001.geekbang.org/account/avatar/00/19/14/dd/17892edc.jpg","comment_is_top":false,"comment_ctime":1567553666,"is_pvip":false,"replies":[{"id":"49125","content":"嗯，即使tcp的ack没问题，tcp层再把数据交给应用层时也可能出现异常情况，比如存储客户端的本地db失败，导致消息在业务层实际是没成功收到的。这种情况下，可以通过业务层的ack来提供保障，客户端只有都执行成功才会回ack给服务端。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567596053,"ip_address":"","comment_id":130792,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1567553666","product_id":100034901,"comment_content":"说一下我的回答吧:业务层的ack机制是参考tcp的ack机制，不过业务层的特殊在于服务器发送信息给客户，这就必须要求信息的可靠性，唯一性，并且发送顺序也要做控制。同时，对于顺序的控制业务逻辑层有两种方式，时间戳和全局性ID。综上，业务层自己做ack的控制可以依照自己的业务逻辑，达到更加灵活和高效。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466130,"discussion_content":"嗯，即使tcp的ack没问题，tcp层再把数据交给应用层时也可能出现异常情况，比如存储客户端的本地db失败，导致消息在业务层实际是没成功收到的。这种情况下，可以通过业务层的ack来提供保障，客户端只有都执行成功才会回ack给服务端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337944,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","nickname":"王棕生","note":"","ucode":"901BD0447A871E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7560,"discussion_content":"我认为ack的目的就是为了消息的可靠性，与高效和灵活无关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567564693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1643741,"avatar":"https://static001.geekbang.org/account/avatar/00/19/14/dd/17892edc.jpg","nickname":"Geek_发现","note":"","ucode":"39C23F2D574A09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1337944,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","nickname":"王棕生","note":"","ucode":"901BD0447A871E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7570,"discussion_content":"业务层ack是建立在tcp的ack基础之上的，只是业务可以灵活选择和控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567569325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7560,"ip_address":""},"score":7570,"extra":""}]},{"author":{"id":1337944,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","nickname":"王棕生","note":"","ucode":"901BD0447A871E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7559,"discussion_content":"难道TCP的序列号和确认号机制不灵活不高效吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567564536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130789,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1567552857,"is_pvip":false,"replies":[{"id":"49122","content":"第三方推送实际上也是依赖的手机厂商维护系统级的和客户端的长连来实现的，所以实际上也是会有ACK机制的。只不过这个机制厂商不会暴露给使用方。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567595874,"ip_address":"","comment_id":130789,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567552857","product_id":100034901,"comment_content":"用户在线的情况下可以用ack确认机制，如果不在线的时候，需要用到第三方推送通知的时候呢，ack确认机制还能有效么？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466128,"discussion_content":"第三方推送实际上也是依赖的手机厂商维护系统级的和客户端的长连来实现的，所以实际上也是会有ACK机制的。只不过这个机制厂商不会暴露给使用方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567595874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130787,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1567552110,"is_pvip":false,"replies":[{"id":"49119","content":"客户端超时重传和TCP的ACK没关系哈，服务端的超时重传主要是处理推送消息后客户端没有回业务层ACK的情况，因为这种情况可能是推送的消息丢失。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567595787,"ip_address":"","comment_id":130787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567552110","product_id":100034901,"comment_content":"客户端的超时重传就是TCP的ACK机制？还是要在业务层做处理啊。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466126,"discussion_content":"客户端超时重传和TCP的ACK没关系哈，服务端的超时重传主要是处理推送消息后客户端没有回业务层ACK的情况，因为这种情况可能是推送的消息丢失。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567595787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130776,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1110299,"ip_address":"","ucode":"327552B5924389","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/1b/d3165de8.jpg","comment_is_top":false,"comment_ctime":1567535616,"is_pvip":false,"replies":[{"id":"49115","content":"超时重传一般几十秒就可以，太短可能会推重，太长实时性也会有影响。你指的滑动窗口大小是指初始化拥塞窗口吗？这个默认可以调大一些，比如10或者20。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567595628,"ip_address":"","comment_id":130776,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567535616","product_id":100034901,"comment_content":"嗯，超时重传的时间是怎么定义的？还有就是滑动窗口大小，你们预设值是多少？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466118,"discussion_content":"超时重传一般几十秒就可以，太短可能会推重，太长实时性也会有影响。你指的滑动窗口大小是指初始化拥塞窗口吗？这个默认可以调大一些，比如10或者20。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567595628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}