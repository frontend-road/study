{"id":98998,"title":"12 | 面向对象（下）：如何实现一个搜索引擎？","content":"<p>你好，我是景霄。这节课，我们来实现一个 Python 的搜索引擎（search engine）。</p><p>承接上文，今天这节课的主要目的是，带你模拟敏捷开发过程中的迭代开发流程，巩固面向对象的程序设计思想。</p><p>我们将从最简单最直接的搜索做起，一步步优化，这其中，我不会涉及到过多的超纲算法，但不可避免会介绍一些现代搜索引擎中的基础概念，例如语料（corpus）、倒序索引（inverted index）等。</p><p>如果你对这方面本身有些了解，自然可以轻松理解；即使你之前完全没接触过搜索引擎，也不用过分担心，我会力求简洁清晰，降低学习难度。同时，我希望你把更多的精力放在面向对象的建模思路上。</p><h2>“高大上”的搜索引擎</h2><p>引擎一词尤如其名，听起来非常酷炫。搜索引擎，则是新世纪初期互联网发展最重要的入口之一，依托搜索引擎，中国和美国分别诞生了百度、谷歌等巨型公司。</p><p>搜索引擎极大地方便了互联网生活，也成为上网必不可少的刚需工具。依托搜索引擎发展起来的互联网广告，则成了硅谷和中国巨头的核心商业模式；而搜索本身，也在持续进步着， Facebook 和微信也一直有意向在自家社交产品架设搜索平台。</p><p>关于搜索引擎的价值我不必多说了，今天我们主要来看一下搜索引擎的核心构成。</p><!-- [[[read_end]]] --><p>听Google的朋友说，他们入职培训的时候，有一门课程叫做 The life of a query，内容是讲用户在浏览器中键入一串文字，按下回车后发生了什么。今天我也按照这个思路，来简单介绍下。</p><p>我们知道，<strong>一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组成</strong>。</p><p>搜索器，通俗来讲就是我们常提到的爬虫（scrawler），它能在互联网上大量爬取各类网站的内容，送给索引器。索引器拿到网页和内容后，会对内容进行处理，形成索引（index），存储于内部的数据库等待检索。</p><p>最后的用户接口很好理解，是指网页和 App 前端界面，例如百度和谷歌的搜索页面。用户通过用户接口，向搜索引擎发出询问（query），询问解析后送达检索器；检索器高效检索后，再将结果返回给用户。</p><p>爬虫知识不是我们今天学习的重点，这里我就不做深入介绍了。我们假设搜索样本存在于本地磁盘上。</p><p>为了方便，我们只提供五个文件的检索，内容我放在了下面这段代码中：</p><pre><code># 1.txt\nI have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.\n\n# 2.txt\nI have a dream that one day down in Alabama, with its vicious racists, . . . one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.\n\n# 3.txt\nI have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.\n\n# 4.txt\nThis is our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. . . .\n\n# 5.txt\nAnd when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: &quot;Free at last! Free at last! Thank God Almighty, we are free at last!&quot;\n</code></pre><p>我们先来定义 SearchEngineBase 基类。这里我先给出了具体的代码，你不必着急操作，还是那句话，跟着节奏慢慢学，再难的东西也可以啃得下来。</p><pre><code>class SearchEngineBase(object):\n    def __init__(self):\n        pass\n\n    def add_corpus(self, file_path):\n        with open(file_path, 'r') as fin:\n            text = fin.read()\n        self.process_corpus(file_path, text)\n\n    def process_corpus(self, id, text):\n        raise Exception('process_corpus not implemented.')\n\n    def search(self, query):\n        raise Exception('search not implemented.')\n\ndef main(search_engine):\n    for file_path in ['1.txt', '2.txt', '3.txt', '4.txt', '5.txt']:\n        search_engine.add_corpus(file_path)\n\n    while True:\n        query = input()\n        results = search_engine.search(query)\n        print('found {} result(s):'.format(len(results)))\n        for result in results:\n            print(result)\n</code></pre><p>SearchEngineBase 可以被继承，继承的类分别代表不同的算法引擎。每一个引擎都应该实现 process_corpus()和search()两个函数，对应我们刚刚提到的索引器和检索器。main()函数提供搜索器和用户接口，于是一个简单的包装界面就有了。</p><p>具体来看这段代码，其中，</p><ul>\n<li>add_corpus() 函数负责读取文件内容，将文件路径作为 ID，连同内容一起送到 process_corpus 中。</li>\n<li>process_corpus  需要对内容进行处理，然后文件路径为 ID  ，将处理后的内容存下来。处理后的内容，就叫做索引（index）。</li>\n<li>search  则给定一个询问，处理询问，再通过索引检索，然后返回。</li>\n</ul><p>好，理解这些概念后，接下来，我们实现一个最基本的可以工作的搜索引擎，代码如下：</p><pre><code>class SimpleEngine(SearchEngineBase):\n    def __init__(self):\n        super(SimpleEngine, self).__init__()\n        self.__id_to_texts = {}\n\n    def process_corpus(self, id, text):\n        self.__id_to_texts[id] = text\n\n    def search(self, query):\n        results = []\n        for id, text in self.__id_to_texts.items():\n            if query in text:\n                results.append(id)\n        return results\n\nsearch_engine = SimpleEngine()\nmain(search_engine)\n\n\n########## 输出 ##########\n\n\nsimple\nfound 0 result(s):\nlittle\nfound 2 result(s):\n1.txt\n2.txt\n</code></pre><p>你可能很惊讶，只需要短短十来行代码居然就可以了吗？</p><p>没错，正是如此，这段代码我们拆开来看一下：</p><p>SimpleEngine 实现了一个继承 SearchEngineBase 的子类，继承并实现了 process_corpus 和 search 接口，同时，也顺手继承了 add_corpus 函数（当然你想重写也是可行的），因此我们可以在 main() 函数中直接调取。</p><p>在我们新的构造函数中，<code>self.__id_to_texts = {}</code> 初始化了自己的私有变量，也就是这个用来存储文件名到文件内容的字典。</p><p>process_corpus() 函数则非常直白地将文件内容插入到字典中。这里注意，ID 需要是唯一的，不然相同ID的新内容会覆盖掉旧的内容。</p><p>search 直接枚举字典，从中找到要搜索的字符串。如果能够找到，则将 ID 放到结果列表中，最后返回。</p><p>你看，是不是非常简单呢？这个过程始终贯穿着面向对象的思想，这里我为你梳理成了几个问题，你可以自己思考一下，当成是一个小复习。</p><ul>\n<li>现在你对父类子类的构造函数调用顺序和方法应该更清楚了吧？</li>\n<li>继承的时候，函数是如何重写的？</li>\n<li>基类是如何充当接口作用的（你可以自行删掉子类中的重写函数，抑或是修改一下函数的参数，看一下会报什么错）？</li>\n<li>方法和变量之间又如何衔接起来的呢？</li>\n</ul><p>好的，我们重新回到搜索引擎这个话题。</p><p>相信你也能看得出来，这种实现方式简单，但显然是一种很低效的方式：每次索引后需要占用大量空间，因为索引函数并没有做任何事情；每次检索需要占用大量时间，因为所有索引库的文件都要被重新搜索一遍。如果把语料的信息量视为 n，那么这里的时间复杂度和空间复杂度都应该是 O(n) 级别的。</p><p>而且，还有一个问题：这里的 query 只能是一个词，或者是连起来的几个词。如果你想要搜索多个词，它们又分散在文章的不同位置，我们的简单引擎就无能为力了。</p><p>这时应该怎么优化呢？</p><p>最直接的一个想法，就是把语料分词，看成一个个的词汇，这样就只需要对每篇文章存储它所有词汇的 set 即可。根据齐夫定律（Zipf’s law，<a href=\"https://en.wikipedia.org/wiki/Zipf%27s_law\">https://en.wikipedia.org/wiki/Zipf%27s_law</a>），在自然语言的语料库里，一个单词出现的频率与它在频率表里的排名成反比，呈现幂律分布。因此，语料分词的做法可以大大提升我们的存储和搜索效率。</p><p>那具体该如何实现呢？</p><h2>Bag of Words 和 Inverted Index</h2><p>我们先来实现一个名叫 Bag of Words 的搜索模型。请看下面的代码：</p><pre><code>import re\n\nclass BOWEngine(SearchEngineBase):\n    def __init__(self):\n        super(BOWEngine, self).__init__()\n        self.__id_to_words = {}\n\n    def process_corpus(self, id, text):\n        self.__id_to_words[id] = self.parse_text_to_words(text)\n\n    def search(self, query):\n        query_words = self.parse_text_to_words(query)\n        results = []\n        for id, words in self.__id_to_words.items():\n            if self.query_match(query_words, words):\n                results.append(id)\n        return results\n    \n    @staticmethod\n    def query_match(query_words, words):\n        for query_word in query_words:\n            if query_word not in words:\n                return False\n        return True\n\n    @staticmethod\n    def parse_text_to_words(text):\n        # 使用正则表达式去除标点符号和换行符\n        text = re.sub(r'[^\\w ]', ' ', text)\n        # 转为小写\n        text = text.lower()\n        # 生成所有单词的列表\n        word_list = text.split(' ')\n        # 去除空白单词\n        word_list = filter(None, word_list)\n        # 返回单词的 set\n        return set(word_list)\n\nsearch_engine = BOWEngine()\nmain(search_engine)\n\n\n########## 输出 ##########\n\n\ni have a dream\nfound 3 result(s):\n1.txt\n2.txt\n3.txt\nfreedom children\nfound 1 result(s):\n5.txt\n</code></pre><p>你应该发现，代码开始变得稍微复杂些了。</p><p>这里我们先来理解一个概念，BOW Model，即 <a href=\"https://en.wikipedia.org/wiki/Bag-of-words_model\">Bag of Words Model</a>，中文叫做词袋模型。这是 NLP 领域最常见最简单的模型之一。</p><p>假设一个文本，不考虑语法、句法、段落，也不考虑词汇出现的顺序，只将这个文本看成这些词汇的集合。于是相应的，我们把 id_to_texts 替换成 id_to_words，这样就只需要存这些单词，而不是全部文章，也不需要考虑顺序。</p><p>其中，process_corpus() 函数调用类静态函数 parse_text_to_words，将文章打碎形成词袋，放入 set 之后再放到字典中。</p><p>search() 函数则稍微复杂一些。这里我们假设，想得到的结果，是所有的搜索关键词都要出现在同一篇文章中。那么，我们需要同样打碎 query 得到一个 set，然后把 set 中的每一个词，和我们的索引中每一篇文章进行核对，看一下要找的词是否在其中。而这个过程由静态函数 query_match 负责。</p><p>你可以回顾一下上节课学到的静态函数，我们看到，这两个函数都是没有状态的，它们不涉及对象的私有变量（没有 self 作为参数），相同的输入能够得到完全相同的输出结果。因此设置为静态，可以方便其他的类来使用。</p><p>可是，即使这样做，每次查询时依然需要遍历所有ID，虽然比起 Simple 模型已经节约了大量时间，但是互联网上有上亿个页面，每次都全部遍历的代价还是太大了。到这时，又该如何优化呢？</p><p>你可能想到了，我们每次查询的 query 的单词量不会很多，一般也就几个、最多十几个的样子。那可不可以从这里下手呢？</p><p>再有，词袋模型并不考虑单词间的顺序，但有些人希望单词按顺序出现，或者希望搜索的单词在文中离得近一些，这种情况下词袋模型现任就无能为力了。</p><p>针对这两点，我们还能做得更好吗？显然是可以的，请看接下来的这段代码。</p><pre><code>import re\n\nclass BOWInvertedIndexEngine(SearchEngineBase):\n    def __init__(self):\n        super(BOWInvertedIndexEngine, self).__init__()\n        self.inverted_index = {}\n\n    def process_corpus(self, id, text):\n        words = self.parse_text_to_words(text)\n        for word in words:\n            if word not in self.inverted_index:\n                self.inverted_index[word] = []\n            self.inverted_index[word].append(id)\n\n    def search(self, query):\n        query_words = list(self.parse_text_to_words(query))\n        query_words_index = list()\n        for query_word in query_words:\n            query_words_index.append(0)\n        \n        # 如果某一个查询单词的倒序索引为空，我们就立刻返回\n        for query_word in query_words:\n            if query_word not in self.inverted_index:\n                return []\n        \n        result = []\n        while True:\n            \n            # 首先，获得当前状态下所有倒序索引的 index\n            current_ids = []\n            \n            for idx, query_word in enumerate(query_words):\n                current_index = query_words_index[idx]\n                current_inverted_list = self.inverted_index[query_word]\n                \n                # 已经遍历到了某一个倒序索引的末尾，结束 search\n                if current_index &gt;= len(current_inverted_list):\n                    return result\n\n                current_ids.append(current_inverted_list[current_index])\n\n            # 然后，如果 current_ids 的所有元素都一样，那么表明这个单词在这个元素对应的文档中都出现了\n            if all(x == current_ids[0] for x in current_ids):\n                result.append(current_ids[0])\n                query_words_index = [x + 1 for x in query_words_index]\n                continue\n            \n            # 如果不是，我们就把最小的元素加一\n            min_val = min(current_ids)\n            min_val_pos = current_ids.index(min_val)\n            query_words_index[min_val_pos] += 1\n\n    @staticmethod\n    def parse_text_to_words(text):\n        # 使用正则表达式去除标点符号和换行符\n        text = re.sub(r'[^\\w ]', ' ', text)\n        # 转为小写\n        text = text.lower()\n        # 生成所有单词的列表\n        word_list = text.split(' ')\n        # 去除空白单词\n        word_list = filter(None, word_list)\n        # 返回单词的 set\n        return set(word_list)\n\nsearch_engine = BOWInvertedIndexEngine()\nmain(search_engine)\n\n\n########## 输出 ##########\n\n\nlittle\nfound 2 result(s):\n1.txt\n2.txt\nlittle vicious\nfound 1 result(s):\n2.txt\n</code></pre><p>首先我要强调一下，<strong>这次的算法并不需要你完全理解</strong>，这里的实现有一些超出了本章知识点。但希望你不要因此退缩，这个例子会告诉你，面向对象编程是如何把算法复杂性隔离开来，而保留接口和其他的代码不变。</p><p>我们接着来看这段代码。你可以看到，新模型继续使用之前的接口，仍然只在 <code>__init__()</code>、<code>process_corpus()</code>和<code>search()</code>三个函数进行修改。</p><p>这其实也是大公司里团队协作的一种方式，<strong>在合理的分层设计后，每一层的逻辑只需要处理好分内的事情即可</strong>。在迭代升级我们的搜索引擎内核时， main 函数、用户接口没有任何改变。当然，如果公司招了新的前端工程师，要对用户接口部分进行修改，新人也不需要过分担心后台的事情，只要做好数据交互就可以了。</p><p>继续看代码，你可能注意到了开头的Inverted Index。Inverted Index Model，即倒序索引，是非常有名的搜索引擎方法，接下来我简单介绍一下。</p><p>倒序索引，一如其名，也就是说这次反过来，我们保留的是 word -&gt; id 的字典。于是情况就豁然开朗了，在 search 时，我们只需要把想要的 query_word 的几个倒序索引单独拎出来，然后从这几个列表中找共有的元素，那些共有的元素，即 ID，就是我们想要的查询结果。这样，我们就避免了将所有的 index 过一遍的尴尬。</p><p>process_corpus 建立倒序索引。注意，这里的代码都是非常精简的。在工业界领域，需要一个 unique ID 生成器，来对每一篇文章标记上不同的 ID，倒序索引也应该按照这个 unique_id 来进行排序。</p><p>至于search() 函数，你大概了解它做的事情即可。它会根据 query_words 拿到所有的倒序索引，如果拿不到，就表示有的 query word 不存在于任何文章中，直接返回空；拿到之后，运行一个“合并K个有序数组”的算法，从中拿到我们想要的 ID，并返回。</p><blockquote>\n<p>注意，这里用到的算法并不是最优的，最优的写法需要用最小堆来存储 index。这是一道有名的 leetcode hard 题，有兴趣请参考：<a href=\"https://blog.csdn.net/qqxx6661/article/details/77814794\">https://blog.csdn.net/qqxx6661/article/details/77814794</a>）</p>\n</blockquote><p>遍历的问题解决了，那第二个问题，如果我们想要实现搜索单词按顺序出现，或者希望搜索的单词在文中离得近一些呢？</p><p>我们需要在 Inverted Index 上，对于每篇文章也保留单词的位置信息，这样一来，在合并操作的时候处理一下就可以了。</p><p>倒序索引我就介绍到这里了，如果你感兴趣可以自行查阅资料。还是那句话，我们的重点是面向对象的抽象，别忘了体会这一思想。</p><h2>LRU 和多重继承</h2><p>到这一步，终于，你的搜索引擎上线了，有了越来越多的访问量（QPS）。欣喜骄傲的同时，你却发现服务器有些“不堪重负”了。经过一段时间的调研，你发现大量重复性搜索占据了 90% 以上的流量，于是，你想到了一个大杀器——给搜索引擎加一个缓存。</p><p>所以，最后这部分，我就来讲讲缓存和多重继承的内容。</p><pre><code>import pylru\n\nclass LRUCache(object):\n    def __init__(self, size=32):\n        self.cache = pylru.lrucache(size)\n    \n    def has(self, key):\n        return key in self.cache\n    \n    def get(self, key):\n        return self.cache[key]\n    \n    def set(self, key, value):\n        self.cache[key] = value\n\nclass BOWInvertedIndexEngineWithCache(BOWInvertedIndexEngine, LRUCache):\n    def __init__(self):\n        super(BOWInvertedIndexEngineWithCache, self).__init__()\n        LRUCache.__init__(self)\n    \n    def search(self, query):\n        if self.has(query):\n            print('cache hit!')\n            return self.get(query)\n        \n        result = super(BOWInvertedIndexEngineWithCache, self).search(query)\n        self.set(query, result)\n        \n        return result\n\nsearch_engine = BOWInvertedIndexEngineWithCache()\nmain(search_engine)\n\n\n########## 输出 ##########\n\n\nlittle\nfound 2 result(s):\n1.txt\n2.txt\nlittle\ncache hit!\nfound 2 result(s):\n1.txt\n2.txt\n</code></pre><p>它的代码很简单，LRUCache 定义了一个缓存类，你可以通过继承这个类来调用其方法。LRU 缓存是一种很经典的缓存（同时，LRU的实现也是硅谷大厂常考的算法面试题，这里为了简单，我直接使用 pylru 这个包），它符合自然界的局部性原理，可以保留最近使用过的对象，而逐渐淘汰掉很久没有被用过的对象。</p><p>因此，这里的缓存使用起来也很简单，调用 has() 函数判断是否在缓存中，如果在，调用 get 函数直接返回结果；如果不在，送入后台计算结果，然后再塞入缓存。</p><p>我们可以看到，BOWInvertedIndexEngineWithCache 类，多重继承了两个类。首先，你需要注意的是构造函数（上节课的思考题，你思考了吗？）。多重继承有两种初始化方法，我们分别来看一下。</p><p>第一种方法，用下面这行代码，直接初始化该类的第一个父类：</p><pre><code>super(BOWInvertedIndexEngineWithCache, self).__init__()\n</code></pre><p>不过使用这种方法时，要求继承链的最顶层父类必须要继承 object。</p><p>第二种方法，对于多重继承，如果有多个构造函数需要调用， 我们必须用传统的方法<code>LRUCache.__init__(self)</code> 。</p><p>其次，你应该注意，search() 函数被子类 BOWInvertedIndexEngineWithCache 再次重载，但是我还需要调用 BOWInvertedIndexEngine 的 search() 函数，这时该怎么办呢？请看下面这行代码：</p><pre><code>super(BOWInvertedIndexEngineWithCache, self).search(query)\n</code></pre><p>我们可以强行调用被覆盖的父类的函数。</p><p>这样一来，我们就简洁地实现了缓存，而且还是在不影响 BOWInvertedIndexEngine 代码的情况下。这部分内容希望你多读几遍，自己揣摩清楚，通过这个例子多多体会继承的优势。</p><h2>总结</h2><p>今天这节课是面向对象的实战应用，相比起前面的理论知识，内容其实不那么友好。不过，若你能静下心来，仔细学习，理清楚整个过程的要点，对你理解面向对象必将有所裨益。比如，你可以根据下面两个问题，来检验今天这节课的收获。</p><ul>\n<li>你能把这节课所有的类的属性和函数抽取出来，自己在纸上画一遍继承关系吗？</li>\n<li>迭代开发流程是怎样的？</li>\n</ul><p>其实于我而言，通过构造搜索引擎这么一个例子来讲面向对象，也是颇费了一番功夫。这其中虽然涉及一些搜索引擎的专业知识和算法，但篇幅有限，也只能算是抛砖引玉，你若有所收获，我便欣然满足。</p><h2>思考题</h2><p>最后给你留一道思考题。私有变量能被继承吗？如果不能，你想继承应该怎么去做呢？欢迎留言与我分享、讨论，也欢迎你把这篇文章分享给你的同事、朋友，一起交流与进步。</p>","neighbors":{"left":{"article_title":"11 | 面向对象（上）：从生活中的类比说起","id":98658},"right":{"article_title":"13 | 搭建积木：Python 模块化","id":99275}},"comments":[{"had_liked":false,"id":101890,"user_name":"Jingxiao","can_delete":false,"product_type":"c1","uid":1259521,"ip_address":"","ucode":"EB966BB87132F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","comment_is_top":true,"comment_ctime":1560031499,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"9.2233721500839997e+18","product_id":100026901,"comment_content":"思考题答案：<br>John Si 的评论说的很对，如果想要强行访问父类的私有类型，做法是 self._ParentClass__var，这是非常不推荐的 hacky method。以下是示范代码：<br>class A:<br>    __a = 1<br><br>class B(A):<br>    pass<br><br>b = B()<br>print(b._A__a)","like_count":26,"discussions":[{"author":{"id":1650748,"avatar":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","nickname":"盘胧","note":"","ucode":"5386CC4C92ECC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293863,"discussion_content":"大家都是成年人，实际上哪有啥私有变量对吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595690541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1524904,"avatar":"https://static001.geekbang.org/account/avatar/00/17/44/a8/0ce75c8c.jpg","nickname":"Skrpy","note":"","ucode":"BB6CB4E9AA1712","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378469,"discussion_content":"哈哈哈，太卷了，不hacky一点都不够突出😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623237955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1919541,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","nickname":"完美坚持","note":"","ucode":"AE0261D8DDEF64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309916,"discussion_content":"为什么不推荐使用这种所谓的hacky method，还有为什么叫他是hacky method？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601514852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100892,"user_name":"益达","can_delete":false,"product_type":"c1","uid":1229123,"ip_address":"","ucode":"AFE48F453851B2","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/43/50c4cd22.jpg","comment_is_top":false,"comment_ctime":1559665120,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"315092277728","product_id":100026901,"comment_content":"看不懂不睡觉","like_count":73,"discussions":[{"author":{"id":1988192,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/56/60/3dd85c9f.jpg","nickname":"冻咚","note":"","ucode":"28DC03716D5C3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283374,"discussion_content":"对于BOW的难点，其实认真想一下画面就能理解：\n比如输入 “word_1 word_2“ : 这两个词在第一次for循环，都能在1.txt中找到，所以current_ids 中有有两个1.txt -> (1.txt, 1.txt)，直接加入result，因为他们都存在于同一个文档。\n（下面我们需要判断这两个词是否继续存在与其他剩余文档）\n我们先将query_words_index每个元素+1，是因为我们不再考虑1.txt了，而是考虑2.txt，3.txt等等剩余文档。\n如果 word_1 通过查找发现存在2.txt中，但是word_2存在3.txt，current_ids 中的元素都不同 -> (2.txt, 3.txt )。所以我们进行“# 如果不是，我们就把最小的元素加一”注释后的代码，其中min(2.txt, 3.txt) = 2.txt， 我们把最小的txt序号+1，就代表我们不考虑2.txt，直接让word_1到3.txt中查找如果存在的话。\n返回的判断条件就是txt序号+1过后的大小已经大于这个单词存在的文档数量了，直接返回result。\n","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1592248938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1694202,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d9/fa/e94bc037.jpg","nickname":"Geek_sylvester","note":"","ucode":"84669E65EA928E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34414,"discussion_content":"昨晚十一点翻到你的评论，然后我四点才睡的觉","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1571197489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/96/d5/23fecf33.jpg","nickname":"Hy","note":"","ucode":"F912E8A8D97591","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271269,"discussion_content":"朋友你好，请问睡了吗，超过72小时看不懂就睡吧，健康第一","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590112318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1523071,"avatar":"https://static001.geekbang.org/account/avatar/00/17/3d/7f/6256435b.jpg","nickname":"解晓东","note":"","ucode":"0ECB8F444E8C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560249,"discussion_content":"睡了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649237776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2628251,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1a/9b/aa3b16f5.jpg","nickname":"海棠","note":"","ucode":"9416069D151314","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540548,"discussion_content":"麻了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640079463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033169,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/d1/bdf895bf.jpg","nickname":"penng","note":"","ucode":"6087CFCB0AC434","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537288,"discussion_content":"已经放弃。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639020122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1440141,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f9/8d/751607fc.jpg","nickname":"rhyme","note":"","ucode":"F103E5B61B6D84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41671,"discussion_content":"今天看不懂明天继续","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572485980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488020,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","nickname":"追风筝的人","note":"","ucode":"2993D60F94C396","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38303,"discussion_content":"看不懂 。。。睡觉💤","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571757723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101155,"user_name":"Wing·三金","can_delete":false,"product_type":"c1","uid":1341402,"ip_address":"","ucode":"6B9F5822C3717F","user_header":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","comment_is_top":false,"comment_ctime":1559728641,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"272142668289","product_id":100026901,"comment_content":"思考题：子类继承父类私有变量的方法<br>- 通过定义 get&#47;set 函数来间接操作私有变量<br>- 通过 实例名._父类名__私有变量名 来直接调用，所以事实上 python 并不直接私有变量<br><br># 主要知识点<br><br>- 搜索引擎的四个组成部分<br>- 迭代开发的流程<br>- 类的继承与父类函数的强行调用<br>- 词袋模型 + 逆序索引 + 合并有序数组 = 优化检索速度 + 考虑单词顺序与间隔<br>- pylru 的基本用法<br>- 多重继承的初始化规则<br><br># 搜索引擎<br><br>- 搜索器：相当于爬虫<br>- 索引器：为每个文件&#47;网页建立唯一的索引<br>- 检索器：高效地检索并返回匹配的文件&#47;网页<br>- 用户接口：输入框和结果返回界面<br><br># 迭代开发的流程<br><br>- 构建一个通用的基本框架<br>- 从最简单的情况考虑起，搭建一个能运行的极简版本<br>- 按照实际需要不断对具体的实现过程进行优化：如在本讲的例子中，先考虑了单个搜索词 + 小搜索量的情况，构建了 ver 1；然后考虑了多个搜索词，构建了词袋的 ver 2；再考虑了大搜索量，构建了词袋 + 逆序索引的 ver 3（提了 搜索词排序与间隔 情况下的处理思路）；最后考虑了负载与重复性搜索问题，构建了使用 LRU 缓存策略的 ver 4<br>- 如果回过头来看最初的框架，还能发现 add_corpus 的方法并不适用于文件较大的情况，结合前面第六讲的内容可以做些改进；以及 main 函数直接用了 for 循环来找所有的文件，实际使用时用的是诸如 os.walk 的方法","like_count":63,"discussions":[{"author":{"id":1546115,"avatar":"https://static001.geekbang.org/account/avatar/00/17/97/83/a9559709.jpg","nickname":"LHJ_Stan","note":"","ucode":"27364BE7ED795E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269922,"discussion_content":"赞赞赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589963012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101537,"user_name":"","can_delete":false,"product_type":"c1","uid":1322330,"ip_address":"","ucode":"FA2983C5AD320C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/5a/cc637589.jpg","comment_is_top":false,"comment_ctime":1559865294,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"207718295502","product_id":100026901,"comment_content":"这篇文章就值回票价了。","like_count":49,"discussions":[{"author":{"id":1501818,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ea/7a/d857723d.jpg","nickname":"Vfeelit","note":"","ucode":"F3FF2B069F347F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341343,"discussion_content":"值个x啊  最水的一门课程 没有之一 能不能退票 能不能转卖，建议开通二手转卖  我第一时间出掉 垃圾","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610380691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101761,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1559963661,"is_pvip":false,"replies":[{"id":"36710","content":"👍","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1560030906,"ip_address":"","comment_id":101761,"utype":1}],"discussion_count":2,"race_medal":0,"score":"181948590093","product_id":100026901,"comment_content":"和面向对象无关的关键词整理：<br>1.一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组成。<br>2.Bag of Words Model，词袋模型。<br>3.Inverted Index Model，倒序索引。<br>4.语料corpus分词，齐夫定律。<br>5.合并 K 个有序数组。<br>6.LRU缓存。<br>难点消化：4，5，6<br>思考题：<br>Python并没有真正的私有化支持，但可用下划线得到伪私有：<br>（1）_xxx      &quot;单下划线 &quot; 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量，需通过类提供的接口进行访问；<br>（2）__xxx    类中的私有变量&#47;方法名，只有类对象自己能访问，连子类对象也不能访问到这个数据。<br>（3）__xxx__ 魔法函数，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 __init__() 代表类的构造函数。","like_count":42,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453105,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560030906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268778,"avatar":"","nickname":"sky","note":"","ucode":"6D31488C0DAFCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561088309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104572,"user_name":"风居住的街","can_delete":false,"product_type":"c1","uid":1542673,"ip_address":"","ucode":"0075A7FB66F797","user_header":"https://static001.geekbang.org/account/avatar/00/17/8a/11/8e9fc7e7.jpg","comment_is_top":false,"comment_ctime":1560777665,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"83165156289","product_id":100026901,"comment_content":"Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx","like_count":19,"discussions":[{"author":{"id":1144834,"avatar":"https://static001.geekbang.org/account/avatar/00/11/78/02/eeb3ce7f.jpg","nickname":"Little何","note":"","ucode":"0CC4D21D61EAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218334,"discussion_content":"优秀。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585649202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202247,"user_name":"shiziwen","can_delete":false,"product_type":"c1","uid":1016917,"ip_address":"","ucode":"ADADC770D82D66","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/55/1e40bd61.jpg","comment_is_top":false,"comment_ctime":1585932472,"is_pvip":false,"replies":[{"id":"75931","content":"super().__init__() 只能调用第一个父类的构造函数，但对于多重继承，如果你想调用其他父类的构造函数，则必须指定。","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1586150304,"ip_address":"","comment_id":202247,"utype":1}],"discussion_count":5,"race_medal":0,"score":"70305409208","product_id":100026901,"comment_content":"第二种方法，对于多重继承，如果有多个构造函数需要调用， 我们必须用传统的方法LRUCache.__init__(self) 。<br><br>这里的两句话没有很明白，LRUCache为什么必须使用第二种方法？<br><br><br>","like_count":16,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490539,"discussion_content":"super().__init__() 只能调用第一个父类的构造函数，但对于多重继承，如果你想调用其他父类的构造函数，则必须指定。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586150304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1191529,"avatar":"","nickname":"karofsky","note":"","ucode":"4AFBEDE22F9652","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331577,"discussion_content":"我的理解：上节课是钻石继承，BC的父亲都是A，但是这个里面的BOWInvertedIndexEngineWithCache分别继承自SearchEngineBase和LRUCache，只要在SearchEngineBase的初始化函数里面也加上super().__init()__就可以顺着继承链找到LRUCache了，也就省去了单独初始化LRUCache的那行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606904459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206365,"avatar":"https://static001.geekbang.org/account/avatar/00/12/68/5d/1ccee378.jpg","nickname":"茫农","note":"","ucode":"71F7143644C9CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319322,"discussion_content":"我python3.7测试的 super().__init() 是会调多个父类的初始化方法的呀，是版本问题？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603983955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2330232,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8e/78/e64fc5c5.jpg","nickname":"Zhou Gong","note":"","ucode":"4A1C587FF8BDBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1206365,"avatar":"https://static001.geekbang.org/account/avatar/00/12/68/5d/1ccee378.jpg","nickname":"茫农","note":"","ucode":"71F7143644C9CB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327688,"discussion_content":"我则是这么认为的，上一节课程里面的思考题就是通过super()来调用多个父类的初始化方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605915028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319322,"ip_address":""},"score":327688,"extra":""}]},{"author":{"id":1016917,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/55/1e40bd61.jpg","nickname":"shiziwen","note":"","ucode":"ADADC770D82D66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223252,"discussion_content":"多谢，现在彻底明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586193375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130959,"user_name":"chuan_chen","can_delete":false,"product_type":"c1","uid":1198311,"ip_address":"","ucode":"D76D2B17F69ADD","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/e7/da93cbec.jpg","comment_is_top":false,"comment_ctime":1567584041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61697126185","product_id":100026901,"comment_content":"感觉这篇好难。。。","like_count":14},{"had_liked":false,"id":101080,"user_name":"John Si","can_delete":false,"product_type":"c1","uid":1526611,"ip_address":"","ucode":"705B90724A4BD4","user_header":"https://static001.geekbang.org/account/avatar/00/17/4b/53/67c08006.jpg","comment_is_top":false,"comment_ctime":1559711033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40214416697","product_id":100026901,"comment_content":"关于思考题,子类不能继承父类私有属性，只可透过self._Parent__varname去读取该私有属性的值，或在父类创建方法返回私有属性的值，然后子类调用父类方法去取得该私有属性的值<br><br>class Animal():<br>    <br>    def __init__(self, sex, height, weight):<br>        self.__sex = sex<br>        self.height = height<br>        self.weight = weight<br>        <br>    def say_hello(self):<br>        raise &#39;say hello not implemented&#39;<br>        <br>    def get_sex(self):<br>        print(&#39;Achieve sex information for parent method: {}&#39;.format(self.__sex))<br>        <br>class Person(Animal):<br>    <br>    def __init__(self,name,age):<br>        super().__init__(&#39;M&#39;,172,70)<br>        self.name = name<br>        self.age = age<br>        <br>    def say_hello(self):<br>        print(&#39;Hello, {}, age: {}, weight:{}&#39;.format(self.name, self.age, self.weight))<br>        print(&#39;Sex: {}&#39;.format(self._Animal__sex))<br>        <br><br>john = Person(&#39;John&#39;,35)<br>john.say_hello()<br>john.get_sex()<br><br>========================<br>Hello, John, age: 35, weight:70<br>Sex: M<br>Achieve sex information for parent method: M<br><br>","like_count":9},{"had_liked":false,"id":120438,"user_name":"zhuanghua","can_delete":false,"product_type":"c1","uid":1607006,"ip_address":"","ucode":"9C27B5539AC0B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rsQcAfBYSwPWRNTSv0ax21faoBic53FxKiaEEbx6CibuXlzL4g6nzEftdMFjWUGNf17RwwOHso8YoiaE5Fg1GNtmbg/132","comment_is_top":false,"comment_ctime":1564895232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35924633600","product_id":100026901,"comment_content":"Python 3 中继承写法 super().__init__()<br>Python 2 中继承写法 super(子类名, self).__init__()，且在父类定义时要在括号内指定 object。","like_count":8},{"had_liked":false,"id":101121,"user_name":"我是传奇","can_delete":false,"product_type":"c1","uid":1357543,"ip_address":"","ucode":"0019CECC4B701B","user_header":"https://static001.geekbang.org/account/avatar/00/14/b6/e7/460a6870.jpg","comment_is_top":false,"comment_ctime":1559721278,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31624492350","product_id":100026901,"comment_content":"图不错","like_count":7,"discussions":[{"author":{"id":1087877,"avatar":"https://static001.geekbang.org/account/avatar/00/10/99/85/12a7cc69.jpg","nickname":"Linsto","note":"","ucode":"AE3797AB0521DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363715,"discussion_content":": ) * N","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617268461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192916,"user_name":"头像我老婆","can_delete":false,"product_type":"c1","uid":1248397,"ip_address":"","ucode":"251F60D969AB23","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8d/5293d44d.jpg","comment_is_top":false,"comment_ctime":1584878799,"is_pvip":false,"replies":[{"id":"75938","content":"事实上，你的例子（菱形继承）中确实会出现这个问题，但是如果你再读仔细一些，我的代码等价于：<br><br>class A():<br>    def __init__(self):<br>        print(&#39;enter A&#39;)<br>        print(&#39;leave A&#39;)<br><br>class B(A):<br>    def __init__(self):<br>        print(&#39;enter B&#39;)<br>        super().__init__()<br>        print(&#39;leave B&#39;)<br><br>class C():<br>    def __init__(self):<br>        print(&#39;enter C&#39;)<br>        # super().__init__()<br>        print(&#39;leave C&#39;)<br><br>class D(B, C):<br>    def __init__(self):<br>        print(&#39;enter D&#39;)<br>        super(D, self).__init__()<br>        C.__init__(self)<br>        print(&#39;leave D&#39;)<br><br>D()<br><br>输出：<br>enter D<br>enter B<br>enter A<br>leave A<br>leave B<br>enter C<br>leave C<br>leave D<br><br>不会出现重复 init","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1586151406,"ip_address":"","comment_id":192916,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27354682575","product_id":100026901,"comment_content":"class BOWInvertedIndexEngineWithCache(BOWInvertedIndexEngine, LRUCache): <br>                  def __init__(self): <br>                       super(BOWInvertedIndexEngineWithCache, self).__init__() <br>                       LRUCache.__init__(self)<br>老师，这里这2种调用父类构造方法不应该是二选一吗，如果这样写的话LRUCache的构造方法会被调用2次<br>class A():<br>    def __init__(self):<br>        print(&#39;enter A&#39;)<br>        print(&#39;leave A&#39;)<br><br>class B(A):<br>    def __init__(self):<br>        print(&#39;enter B&#39;)<br>        super().__init__()<br>        print(&#39;leave B&#39;)<br><br>class C(A):<br>    def __init__(self):<br>        print(&#39;enter C&#39;)<br>        super().__init__()<br>        print(&#39;leave C&#39;)<br><br>class D(B, C):<br>    def __init__(self):<br>        print(&#39;enter D&#39;)<br>        super(D,self).__init__()<br>        C.__init__(self)<br>        print(&#39;leave D&#39;)<br><br>D()<br>输出结果：<br>enter D<br>enter B<br>enter C<br>enter A<br>leave A<br>leave C<br>leave B<br>enter C<br>enter A<br>leave A<br>leave C<br>leave D","like_count":6,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488481,"discussion_content":"事实上，你的例子（菱形继承）中确实会出现这个问题，但是如果你再读仔细一些，我的代码等价于：\n\nclass A():\n    def __init__(self):\n        print(&amp;#39;enter A&amp;#39;)\n        print(&amp;#39;leave A&amp;#39;)\n\nclass B(A):\n    def __init__(self):\n        print(&amp;#39;enter B&amp;#39;)\n        super().__init__()\n        print(&amp;#39;leave B&amp;#39;)\n\nclass C():\n    def __init__(self):\n        print(&amp;#39;enter C&amp;#39;)\n        # super().__init__()\n        print(&amp;#39;leave C&amp;#39;)\n\nclass D(B, C):\n    def __init__(self):\n        print(&amp;#39;enter D&amp;#39;)\n        super(D, self).__init__()\n        C.__init__(self)\n        print(&amp;#39;leave D&amp;#39;)\n\nD()\n\n输出：\nenter D\nenter B\nenter A\nleave A\nleave B\nenter C\nleave C\nleave D\n\n不会出现重复 init","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586151406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1922661,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/56/65/fa4437d7.jpg","nickname":"Wonderfulpeng","note":"","ucode":"1BA9AB30B52159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374537,"discussion_content":"老师的解答是正确的 因为这里给出的是菱形的继承 而实际这里的lru或者是老师给你重新打的C这个类并没有和B构成菱形继承，因此必须单独调用C这个类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621238118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016917,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/55/1e40bd61.jpg","nickname":"shiziwen","note":"","ucode":"ADADC770D82D66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220957,"discussion_content":"不知道老师是不是不经常看评论，我这里也不是很明白，为什么“第二种方法，对于多重继承，如果有多个构造函数需要调用， 我们必须用传统的方法LRUCache.__init__(self) 。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585932617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212647,"user_name":"及時行樂","can_delete":false,"product_type":"c1","uid":1895499,"ip_address":"","ucode":"2FD0E0BB8327DE","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ec/4b/442dd5f1.jpg","comment_is_top":false,"comment_ctime":1588169551,"is_pvip":false,"replies":[{"id":"79956","content":"哈哈谢谢支持","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1589179168,"ip_address":"","comment_id":212647,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23063006031","product_id":100026901,"comment_content":"看到这，我发现我五十元买的课程简直血赚！！！看条评论说看不懂不睡觉，建议你善良删除，我直接被你搞的睡衣全无，感觉能战到天亮","like_count":5,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493573,"discussion_content":"哈哈谢谢支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589179168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1922298,"avatar":"","nickname":"patience","note":"","ucode":"46BEA083F550A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281577,"discussion_content":"看到最后反向索引的search方法，就看不懂了，一点招没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591768938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101063,"user_name":"Danpier","can_delete":false,"product_type":"c1","uid":1463474,"ip_address":"","ucode":"11E208FDE34961","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/b2/5ea0b709.jpg","comment_is_top":false,"comment_ctime":1559707885,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23034544365","product_id":100026901,"comment_content":"BOWInvertedIndexEngine search函数后半部分少了缩进，第40行开始","like_count":5,"discussions":[{"author":{"id":1117023,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0b/5f/2cc4060c.jpg","nickname":"子豪sirius","note":"","ucode":"E8D08D2D33E785","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19165,"discussion_content":"是这样啊，怪不得这段有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569145453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119980,"user_name":"一只眼看世界","can_delete":false,"product_type":"c1","uid":1590236,"ip_address":"","ucode":"D221841AE5103F","user_header":"https://static001.geekbang.org/account/avatar/00/18/43/dc/4f70c936.jpg","comment_is_top":false,"comment_ctime":1564743440,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18744612624","product_id":100026901,"comment_content":"        query_list = []<br>        for word in query_words:<br>            if word in self.inverted_index:<br>                query_list.append(self.inverted_index[word])<br>        # 取集合的交集<br>        result = set(reduce(lambda x, y: set(x) &amp; set(y), query_list))<br>        return result<br>用交集会省去N行代码的判断","like_count":4,"discussions":[{"author":{"id":2027617,"avatar":"","nickname":"Geek_e2c610","note":"","ucode":"A4E4FF065EB966","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280299,"discussion_content":"能想到reduce求集合的交我服了you","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591523760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101297,"user_name":"陆洋","can_delete":false,"product_type":"c1","uid":1078556,"ip_address":"","ucode":"F5D82385EAD25C","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/1c/0238b794.jpg","comment_is_top":false,"comment_ctime":1559779817,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"18739649001","product_id":100026901,"comment_content":"是search（）又被重载了，不是query（）","like_count":4},{"had_liked":false,"id":101061,"user_name":"tux","can_delete":false,"product_type":"c1","uid":1477811,"ip_address":"","ucode":"BB7202009FC885","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/b3/a74a7125.jpg","comment_is_top":false,"comment_ctime":1559707152,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18739576336","product_id":100026901,"comment_content":"运行文中代码，始终在运行状态!<br><br>修改了一处：<br>class SearchEngineBase(object):<br>\t...<br>    def add_corpus(self, file_path):<br>        with open(&#39;文件的目录&#39; + file_path, &#39;r&#39;) as fin:  #修改了此处<br>            text = fin.read()<br>            print(&#39;text:&#39;, text)   #能打印出内容<br>\t\t\t<br>\t\t\t<br>不修改代码，报FileNotFoundError。去查资料，应该用全路径。 总有个想先看到反馈结果的 强迫症。","like_count":4,"discussions":[{"author":{"id":1591293,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","nickname":"Cy23","note":"","ucode":"8DC561C5151758","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288203,"discussion_content":"知道了，等待你输入查询内容呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593676377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105603,"user_name":"闲人","can_delete":false,"product_type":"c1","uid":1546492,"ip_address":"","ucode":"F04C0463C6BB5F","user_header":"https://static001.geekbang.org/account/avatar/00/17/98/fc/b1d22b7e.jpg","comment_is_top":false,"comment_ctime":1561039851,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"14445941739","product_id":100026901,"comment_content":"BOWInvertedIndexEngine类的search函数中：<br>query_words_index = list()<br>for query_word in query_words:<br>    query_words_index.append(0)<br>这一段没看明白：<br>query_words_index是一个全为0的列表？<br>有什么作用？","like_count":3,"discussions":[{"author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38947,"discussion_content":"是这样的，这个就是作者提高的合并n个有序数组，每个query_word对应一个文件名的列表，query_word_index里面存的就是每个quert_word当前列表的索引，初始值都为0，先把所有列表的索引为0文件名取出放到一个列表里，如果文件名一致就放到结果的列表里，否则找出最小的文件名，找出其在列表的索引即第几个query_word，然后将它的query_word_index + 1,下次就取出它的索引为1的文件名来和其query_word所对应文件名列表的索引为0的文件名比较","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571852300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1072619,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5d/eb/4b8d754a.jpg","nickname":"安仔","note":"","ucode":"820264F1FD98A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":215390,"discussion_content":"好拗口，依然没懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585320499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":38947,"ip_address":""},"score":215390,"extra":""}]},{"author":{"id":1546492,"avatar":"https://static001.geekbang.org/account/avatar/00/17/98/fc/b1d22b7e.jpg","nickname":"闲人","note":"","ucode":"F04C0463C6BB5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130,"discussion_content":"我好像有点明白了，如果我要搜索两个单词，比如little dream，那么query_words_index就应该是[0, 0]，倒序索引中应该是这样的{&#34;little&#34;: [1.txt, 2.txt], &#34;dream&#34;: [1.txt, 2.txt, 3.txt]}，所以，query_words_index[idx]表示的意思是，当idx=0的时候，表示little对应的1.txt，当idx=1的时候，表示dream对应的1.txt。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561130738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2073526,"avatar":"","nickname":"笑笑521","note":"","ucode":"74567804FCE7EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295464,"discussion_content":"第一反应和第二反应都是是不是写错了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596200638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268778,"avatar":"","nickname":"sky","note":"","ucode":"6D31488C0DAFCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87,"discussion_content":"我也觉得这段有问题， 不明白倒序索引。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561088215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100900,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1559674752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14444576640","product_id":100026901,"comment_content":"按照我之前的理解，Python是没有严格的private变量的。子类确实无法直接访问父类&quot;self.__var&quot;变量，但是可以通过&quot;self._Superclass__var&quot;访问。要想比较好地访问或者修改这些变量，可以像JAVA一样写getter和setter吧？<br>另外我有两个问题：<br>1. 一些手册中说python的多重继承非常混乱不可靠，尤其涉及很多重载的时候，因此需要避免，或者采用composition的方式。实际工程中是否会有这样的考虑呢？<br>2. 以搜索引擎为例，如何规划各个类以及函数的功能，是否是 设计模式 方面的知识呢？","like_count":3},{"had_liked":false,"id":151521,"user_name":"quanxyun","can_delete":false,"product_type":"c1","uid":1044206,"ip_address":"","ucode":"EAC58374105C8C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/ee/1cd89270.jpg","comment_is_top":false,"comment_ctime":1573735799,"is_pvip":false,"replies":[{"id":"63100","content":"👍","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1577251508,"ip_address":"","comment_id":151521,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163670391","product_id":100026901,"comment_content":"Python并没有真正的私有化支持，但可用下划线得到伪私有：<br>（1）_xxx &quot;单下划线 &quot; 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量，需通过类提供的接口进行访问；<br>（2）__xxx 类中的私有变量&#47;方法名，只有类对象自己能访问，连子类对象也不能访问到这个数据。<br>（3）__xxx__ 魔法函数，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 __init__() 代表类的构造函数。","like_count":2,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474513,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577251508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141737,"user_name":"old Z","can_delete":false,"product_type":"c1","uid":1694776,"ip_address":"","ucode":"BEE1423C265A97","user_header":"https://static001.geekbang.org/account/avatar/00/19/dc/38/719040a4.jpg","comment_is_top":false,"comment_ctime":1571216395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10161150987","product_id":100026901,"comment_content":"开始也看不太懂for循环后面的操作，最后调试了一段时间发现while true中的for循环做了很多次，这个次数根据用户输入来定，做这么多循环位感觉只是为了得到搜索结果的个数和list，自我感觉不是很利于理解，而且循环次数过多，如果用户输入过多，势必会造成时间的巨大消耗。所以我根据自己的想法，只通过一次for循环，代码如下：<br>class OLDZBOWInvertedIndexEngine(SearchEngineBase):<br>    def __init__(self):<br>        super(OLDZBOWInvertedIndexEngine, self).__init__()<br>        self.inverted_index = {}<br><br>    def process_corpus(self, id, text):<br>        # set<br>        words = self.parse_text_to_words(text)<br>        for word in words:<br>            if word not in self.inverted_index:<br>                self.inverted_index[word] = []<br>            self.inverted_index[word].append(id)<br><br>    def search(self, query):<br><br>        query_words = list(self.parse_text_to_words(query))<br>        query_words_index = list()<br>        for query_word in query_words:<br>            query_words_index.append(0)<br>        for query_word in query_words:<br>            if query_word not in self.inverted_index:<br>                return []<br>        while True:<br>            input_inverted_list=[]<br>            for idx, query_word in enumerate(query_words):<br><br>                current_inverted_list = self.inverted_index[query_word]<br>                input_inverted_list.append(current_inverted_list)<br><br>            result=self.l_output_same(input_inverted_list)<br>            return result<br><br>    # 对L中的元素进行计数，将最多的元素输出<br>    @staticmethod<br>    def l_output_same(L):<br>        L_ALL = []<br>        L_SAME = []<br>        for l in L:<br>            L_ALL += l<br>        count_dict = Counter(L_ALL)<br>        count_dict_sort = sorted(count_dict.items(), key=lambda x: x[1], reverse=True)<br>        max_count = count_dict_sort[0][1]<br>        for id, count in count_dict_sort:<br>            if count == max_count:<br>                L_SAME.append(id)<br>        return L_SAME<br><br>具体时间和老师的相比我没有测试，只是觉得我这个方法可能更利于新手理解吧，有不对的地方欢迎指出，代码中省略了parse_text_to_words(text)这个函数，因为字数太多发不了评论，需要的自己加上测试","like_count":2},{"had_liked":false,"id":137768,"user_name":"自由民","can_delete":false,"product_type":"c1","uid":1346236,"ip_address":"","ucode":"435C67531697F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","comment_is_top":false,"comment_ctime":1569840679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10159775271","product_id":100026901,"comment_content":"小结:<br>①用super函数，先运行父类构造函数，再运行子类的构造函数。<br>②集成的时候，父类里抛出异常，如果子类不实现，就会出现异常。<br>③子类实现父类的函数需按同样的函数名和参数列表来实现。<br>④变量在构造函数中声明，其它方法可以使用。变量定义为私有的(__变量名)则非成员方法不能访问。<br>静态函数没有状态，不涉及对象的私有变量，相同的输入能得到完全相同的输出结果。静态的，方便其他的类来使用。<br>在合理分层设计后，每一层的逻辑只需要处理好份内的事情即可。<br>迭代开发的流程，先定义基类，规划好接口，在根据需要进一步完善，通过继承基类添加功能或修改设计。这个时候就不用修改调用该功能的代码了。<br>思考题:私有变量不能被继承，要继承可以定义为静态变量。<br>类的继承关系见github主页里的图片文件<br>课程的练习代码: https:&#47;&#47;github.com&#47;zwdnet&#47;PythonPractice","like_count":2},{"had_liked":false,"id":101123,"user_name":"海生","can_delete":false,"product_type":"c1","uid":1119247,"ip_address":"","ucode":"27E459D96E9E55","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/0f/91f0194d.jpg","comment_is_top":false,"comment_ctime":1559721998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10149656590","product_id":100026901,"comment_content":"可不可以讲解一些开源的框架什么的，python 这边深度学习框架很多。这些框架的代码很优秀，也是语言的核心技术运用最多的地方。","like_count":2},{"had_liked":false,"id":322204,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1519491,"ip_address":"","ucode":"4F835D75186356","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/83/81e146e4.jpg","comment_is_top":false,"comment_ctime":1637234772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5932202068","product_id":100026901,"comment_content":"倒排索引的这段查找逻辑开始没看懂，自己用注释模拟过了一遍思路，看懂了！<br><br>        result = []<br>        while True:<br>            current_ids = []<br>            # 查询词示例： &#39;hello&#39;,&#39;world&#39;<br>            # 倒排索引内容示例{&#39;hello&#39;:[&#39;1.txt&#39;,&#39;2.txt&#39;,&#39;4.txt&#39;,&#39;6.txt&#39;,&#39;7.txt&#39;] , &#39;world&#39;:[&#39;3.txt&#39;,&#39;4.txt&#39;,&#39;5.txt&#39;]}<br>            for idx, query_word in enumerate(query_words): # 2个查询词，因此下方的循环体中注释两次值用逗号分隔<br>                # idx: 0,1<br>                # query_word: &#39;hello&#39;,&#39;world&#39;<br>                current_index = query_words_index[idx]  # current_index: 0,0 =&gt; 1,0 =&gt; 2,0 =&gt; 2,1 =&gt; 3,2 =&gt; 3,3<br>                current_inverted_list = self.inverted_index[query_word]<br>                # hello: [&#39;1.txt&#39;,&#39;2.txt&#39;,&#39;4.txt&#39;,&#39;6.txt&#39;,&#39;7.txt&#39;]<br>                # world: [&#39;3.txt&#39;,&#39;4.txt&#39;,&#39;5.txt&#39;]<br><br>                # 已经遍历到了某一个倒序索引的末尾，结束 search<br>                if current_index &gt;= len(current_inverted_list):  # condition: F,F =&gt; F,F =&gt; F,F =&gt; F,F =&gt; F,F =&gt;F,T<br>                    return result                                # T:return [&#39;4.txt&#39;] 这里程序返回并结束<br><br>                current_ids.append(current_inverted_list[current_index])<br>                # current_ids: 1.txt,3.txt =&gt; 2.txt,3.txt =&gt; 4.txt,3.txt =&gt; 4.txt,4.txt =&gt; 6.txt,5.txt<br><br>            # 然后，如果 current_ids 的所有元素都一样，那么表明这个单词在这个元素对应的文档中都出现了<br>            if all(x == current_ids[0] for x in current_ids):     # condition: F =&gt; F =&gt; F =&gt; T &gt; F<br>                result.append(current_ids[0])<br>                query_words_index = [x + 1 for x in query_words_index]  # T:3,2<br>                continue<br>            <br>            # 如果不是，我们就把最小的元素加一<br>            min_val = min(current_ids)                  # min_val: 1.txt =&gt; 2.txt =&gt; 3.txt =&gt; T =&gt; 5.txt<br>            min_val_pos = current_ids.index(min_val)    # min_val_pos: 0 =&gt; 0 =&gt; 1 =&gt; T =&gt; 1<br>            query_words_index[min_val_pos] += 1         # query_words_index: 1,0 =&gt; 2,0 =&gt; 2,1 =&gt; T =&gt; 3,3<br><br>","like_count":1},{"had_liked":false,"id":315799,"user_name":"rs勿忘初心","can_delete":false,"product_type":"c1","uid":1519200,"ip_address":"","ucode":"557D1ECD757195","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/60/4fa1f3bd.jpg","comment_is_top":false,"comment_ctime":1634004055,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5928971351","product_id":100026901,"comment_content":"Python：类的继承，调用父类的属性和方法基础详解，可以参考：https:&#47;&#47;blog.csdn.net&#47;yilulvxing&#47;article&#47;details&#47;85374142","like_count":1},{"had_liked":false,"id":309207,"user_name":"Geek_f6bfca","can_delete":false,"product_type":"c1","uid":1664242,"ip_address":"","ucode":"94C85F1FC21ABB","user_header":"","comment_is_top":false,"comment_ctime":1629985651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924952947","product_id":100026901,"comment_content":"# 一.父类<br>class SearchEngineBase(object):# 父类<br>    def __init__(self):# 构造函数，传递参数<br>        pass<br><br>    # 以下是需要实现的方法<br>    # 1.读取文件内容<br>    def add_corpus(self, file_path):<br>        with open(file_path,&#39;r&#39;,encoding=&#39;utf-8&#39;) as file:<br>            context = file.read()<br>        self.process_corpus(file_path, context) # 调用类内部的方法 process_corpus<br><br>    # 2.处理文件内容<br>    # 如果父类实例化后调用 process_corpus 方法则会报错，该处理方式强制要求子类重写父类函数来覆盖父类原有函数,所以这里什么功能都没有<br>    # id 等同于 file_path<br>    def process_corpus(self, id, text):<br>        raise Exception(&#39;process corpus not implement&#39;)<br><br>    # 3.输入需要检索的单词<br>    def search(self, query):<br>        raise Exception(&#39;search corpus not implement&#39;)<br><br># 二.子类<br>class SimpleSearchEngine(SearchEngineBase):<br>    def __init__(self):<br>        super().__init__() # 对继承自父类的属性初始化<br>        self.__id_to_text = {} # 增加初始化变量，设定为空字典，用来储存文件地址、内容<br><br>    # 父类中该方法是个空，只能在实例化后报错，所以我在子类中重写该方法，以实现真正的目的<br>    def process_corpus(self, id, text):<br>        self.__id_to_text[id] = text<br><br>    def search(self, query):<br>        results = []<br>        for id, text in self.__id_to_text.items():<br>            if query in text:<br>                results.append(id)<br><br>        return results<br><br># 三.主函数<br># search_engine 实例<br>def main():<br>    search_engine = SimpleSearchEngine()<br>    for file_path in [&#39;1.txt&#39;, &#39;2.txt&#39;, &#39;3.txt&#39;, &#39;4.txt&#39;, &#39;5.txt&#39;]:<br>        search_engine.add_corpus(file_path)<br><br>    while True:<br>        query = input(f&#39;Input your word：&#39;)<br>        results = search_engine.search(query)<br>        print(f&#39;found {len(results)} results.&#39;)<br>        for result in results:<br>            print(result)<br><br><br># search_engine = SimpleSearchEngine()<br>main()<br><br>","like_count":1},{"had_liked":false,"id":196885,"user_name":"安仔","can_delete":false,"product_type":"c1","uid":1072619,"ip_address":"","ucode":"820264F1FD98A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/eb/4b8d754a.jpg","comment_is_top":false,"comment_ctime":1585321022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880288318","product_id":100026901,"comment_content":"老师能不能把 BOWInvertedIndexEngine 里面的算法逻辑讲清楚呀，这样会逼死一些强迫症的，虽然您说不需要清楚这其中的算法细节","like_count":1},{"had_liked":false,"id":126925,"user_name":"🇨🇳","can_delete":false,"product_type":"c1","uid":1306115,"ip_address":"","ucode":"D6C5E9CA44D082","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/03/09926387.jpg","comment_is_top":false,"comment_ctime":1566522025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5861489321","product_id":100026901,"comment_content":"您好，请问继承object和不继承用法区别是什么呢？概念上还是有点模糊","like_count":1},{"had_liked":false,"id":120683,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1564973216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859940512","product_id":100026901,"comment_content":"思考题：父类的私有变量不能直接被子类继承，可以在父类中定义一个访问私有变量的方法，然后让子类来继承该方法，这样就可以间接地访问父类的私有变量了。测试程序如下：<br>#私有变量继承测试<br><br>class A:<br>    def __init__(self):<br>        self.__a1 =&#39;This is a1&#39;<br>        self.b1 = &#39;This is b1&#39;<br><br>    def getPrivate(self):<br>        return self.__a1<br><br>class B(A):<br>    def __init__(self):<br>        super().__init__()<br>        #print(self.__a1) 不能直接访问父类的私有变量<br>        print(self.getPrivate()) #通过继续父类的方法来间接访问父类的私有变量<br>        print(self.b1)<br><br>b = B()<br>","like_count":1},{"had_liked":false,"id":118655,"user_name":"江南皮革厂研发中心保安队长","can_delete":false,"product_type":"c1","uid":1099584,"ip_address":"","ucode":"231419643A5CC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/40/66a203cd.jpg","comment_is_top":false,"comment_ctime":1564407620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859374916","product_id":100026901,"comment_content":"学了两年python，看过视频课程，书籍，语法什么的可以说是滚瓜烂熟了，但是看了老师今天这节课，才知道什么叫学而不思则罔。","like_count":1},{"had_liked":false,"id":105581,"user_name":"WANG","can_delete":false,"product_type":"c1","uid":1014839,"ip_address":"","ucode":"40795CDD7734F8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/37/a747c9f2.jpg","comment_is_top":false,"comment_ctime":1561035709,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"5856003005","product_id":100026901,"comment_content":"老师，您好，有个疑问，您在讲 BOW Model时，<br>class BOWInvertedIndexEngine(SearchEngineBase):<br>\tdef __init__(self):<br>        super(BOWInvertedIndexEngine, self).__init__()<br>        self.inverted_index = {}<br><br><br>    def search(self, query):<br>        query_words = list(self.parse_text_to_words(query))<br>        query_words_index = list()<br>        for query_word in query_words:<br>            query_words_index.append(0)<br><br><br> query_words_index.append(0) 为啥要添加 0,  应该是 query_word 吧?","like_count":1,"discussions":[{"author":{"id":1519491,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2f/83/81e146e4.jpg","nickname":"大海","note":"","ucode":"4F835D75186356","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531116,"discussion_content":"就是定义每个查询关键词在倒排索引中各自的查找索引值，初始为0，换一种写法更好懂\n        query_words_index = [0 for i in range(len(query_words))]\n        #query_words_index = list()\n        #for query_word in query_words:\n        #    query_words_index.append(0)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637235139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268778,"avatar":"","nickname":"sky","note":"","ucode":"6D31488C0DAFCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85,"discussion_content":"         for query_word in query_words:\n            query_words_index.append(query_word)    # -> 这个改成query_word 也不对， 应该是0 , 添加索引，从0 开始。。。。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561088069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268778,"avatar":"","nickname":"sky","note":"","ucode":"6D31488C0DAFCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83,"discussion_content":"倒序索引 好像是有问题，但是又找不到问题所在。。。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561087919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014839,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7c/37/a747c9f2.jpg","nickname":"WANG","note":"","ucode":"40795CDD7734F8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1268778,"avatar":"","nickname":"sky","note":"","ucode":"6D31488C0DAFCC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97,"discussion_content":"我通过打断点调试明白了，那个确实没写错，就是0，你打断点试试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561097569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83,"ip_address":""},"score":97,"extra":""}]}]},{"had_liked":false,"id":101153,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1559728076,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5854695372","product_id":100026901,"comment_content":"今天内容有点多。对于课后留题，在没有写代码测试时候，觉得是不能继承的。<br>但是在写了以下代码后，好像私有变量是可以继承的，代码如下，请老师指点<br>class A():<br><br>    _privateVar = &quot;privateVariable&quot;<br><br>    def getPrivateVar(self):<br>        return self._privateVar<br><br>class B(A):<br>    def printVar(self):<br>        print(self._privateVar)<br>        print(self.getPrivateVar())<br>        self._privateVar = &quot;modify&quot;<br>        print(self._privateVar)<br><br>b = B()<br><br>b.printVar()<br><br>运行结果：<br>privateVariable<br>privateVariable<br>modify","like_count":1,"discussions":[{"author":{"id":2027617,"avatar":"","nickname":"Geek_e2c610","note":"","ucode":"A4E4FF065EB966","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280294,"discussion_content":"你少打了一个下划线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591523296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101097,"user_name":"tux","can_delete":false,"product_type":"c1","uid":1477811,"ip_address":"","ucode":"BB7202009FC885","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/b3/a74a7125.jpg","comment_is_top":false,"comment_ctime":1559716910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854684206","product_id":100026901,"comment_content":"运行文中代码，始终在运行状态 --&gt; 因为：query = input() 需要输入内容。 这个自己让自己很尴尬呀<br>def main(search_engine):<br>\t...<br>    while True:<br>        query = input()<br>\t\t\t","like_count":1},{"had_liked":false,"id":357698,"user_name":"Geek_216fd5","can_delete":false,"product_type":"c1","uid":1602049,"ip_address":"北京","ucode":"EA6804E9E974B3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLb5UK2u6RyS48ia8H2lUSlUyQEaBiclDlqpbQUWqTWeuf3Djl3ruHRN3U37GXYuWAfAW5d1xkm6F7w/132","comment_is_top":false,"comment_ctime":1663572601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663572601","product_id":100026901,"comment_content":"看了一个礼拜，终于看懂了。<br>其他部分代码还比较简单，最难懂的是下面这段：<br>while True: <br># 首先，获得当前状态下所有倒序索引的 index current_ids = [] for idx, query_word in enumerate(query_words): current_index = query_words_index[idx] current_inverted_list = self.inverted_index[query_word] # 已经遍历到了某一个倒序索引的末尾，结束 search if current_index &gt;= len(current_inverted_list): return result current_ids.append(current_inverted_list[current_index]) # 然后，如果 current_ids 的所有元素都一样，那么表明这个单词在这个元素对应的文档中都出现了 if all(x == current_ids[0] for x in current_ids): result.append(current_ids[0]) query_words_index = [x + 1 for x in query_words_index] continue # 如果不是，我们就把最小的元素加一 min_val = min(current_ids) min_val_pos = current_ids.index(min_val) query_words_index[min_val_pos] += 1<br>这段主要是实现如下功能：<br>self.inverted_index 是倒序索引集合，即 <br>self.inverted_index={<br>    &quot;little&quot;: [&#39;1.txt&#39;, &#39;2.txt&#39;]<br>    &quot;ring&quot;:[&#39;5.txt&#39;]<br>    ....<br>}<br>当用户在终端输入检索词 little,ring 时，程序就会根据这个检索词得到得到 [&#39;1.txt&#39;, &#39;2.txt&#39;]和[&#39;5.txt&#39;]这两个 list，最后将这两个 list 求交集（不知列表是否有交集概念，^_^），并将结果返回。上述整个 while 循环体都是在求“交集”的过程。核心就是那个 current_ids 变量名。具体如下：<br>1. 获取检索词答案，如 little --&gt; [&#39;1.txt&#39;, &#39;2.txt&#39;], ring--&gt;[&#39;5.txt&#39;]<br>2. 创建一个“指针”功能的 list：query_words_index[a,b],这个 list 里的每个元素对应的 list 的索引值。这么说可能拗口，简单的说就是 query_words_index[a=0] --&gt; little_answer[0]<br>    query_words_index[a=1] --&gt; little_answer[1]<br>    query_words_index[b=0] --&gt; ring_answer[0]<br>3. 每次从每个 query_word_anwser 里取出一个元素，组成 current_ids。比如<br>[little --&gt;&quot;1.txt&quot;, ring--&gt;&quot;5.txt&quot;]，如果这些元素全部相同，比如都是‘1.txt’，则‘1.txt’就是交集的成员。<br>4. 通过一遍遍的循环找到全部交集的成员组成交集返回即可<br><br>现在有一个疑问：这种得到交集的方法是否是某种算法 ？请各位大神指点。<br><br>","like_count":0},{"had_liked":false,"id":343345,"user_name":"Geek_145846","can_delete":false,"product_type":"c1","uid":2530478,"ip_address":"","ucode":"1DA77D13A8F19E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAlkIjytYG8MqOtDf7n7pF3rXJnoMNL9ebRXluPvGh2e2A9TxyMoQxPyYQ1dInAFIeltwo8zuvhg/132","comment_is_top":false,"comment_ctime":1650791599,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650791599","product_id":100026901,"comment_content":"为什么<br>self.parse_text_to_words(text)<br><br>前面有个self","like_count":0},{"had_liked":false,"id":340306,"user_name":"三年二班邱小东","can_delete":false,"product_type":"c1","uid":2922136,"ip_address":"","ucode":"909B49C63C8EC6","user_header":"https://static001.geekbang.org/account/avatar/00/2c/96/98/89b96cda.jpg","comment_is_top":false,"comment_ctime":1648733080,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648733080","product_id":100026901,"comment_content":"老师，请问静态函数没有状态是做何解？","like_count":0},{"had_liked":false,"id":325250,"user_name":"哇塞","can_delete":false,"product_type":"c1","uid":2639609,"ip_address":"","ucode":"C7340DD79BF02E","user_header":"","comment_is_top":false,"comment_ctime":1638878854,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638878854","product_id":100026901,"comment_content":"老师好 我把子类中print语句放在了显式调用父类构造方法后面，执行打印的顺序是父-&gt;子，这样我就理解成：父类的构造函数  -&gt; 子类的构造函数，效果和文章不一样，我这点没理解很疑惑。希望老师解答一下！<br>","like_count":0},{"had_liked":false,"id":308911,"user_name":"苏苏","can_delete":false,"product_type":"c1","uid":1136433,"ip_address":"","ucode":"5FFD7F3B0F7F7A","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/31/da42b783.jpg","comment_is_top":false,"comment_ctime":1629858468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629858468","product_id":100026901,"comment_content":"result = super(BOWInvertedIndexEngineWithCache, self).search(query)<br><br>这句代码， 是否可以改为 BOWInvertedIndexEngine.search(query)","like_count":0},{"had_liked":false,"id":308898,"user_name":"JabariH","can_delete":false,"product_type":"c1","uid":1983181,"ip_address":"","ucode":"F7CC3390CDB6AA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/42/cd/09b568fc.jpg","comment_is_top":false,"comment_ctime":1629855366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629855366","product_id":100026901,"comment_content":"讲的太棒了！","like_count":0},{"had_liked":false,"id":299655,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":2317044,"ip_address":"","ucode":"232FB93BDC5C93","user_header":"https://static001.geekbang.org/account/avatar/00/23/5a/f4/077903da.jpg","comment_is_top":false,"comment_ctime":1624784135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624784135","product_id":100026901,"comment_content":"    def search(self, query):<br>        query_words = list(self.parse_text_to_words(query))<br>        query_words_index = list()<br><br> <br>        # 实际上是查找所有单词的一个存在文件，直接使用set即可完成逻辑<br>        # 获取交集即可<br>        results = set()<br>        for idx, query_word in enumerate(query_words):<br>            # 获取每一个单词的存在逻辑<br>            if idx == 0:<br>                results = set(self.inverted_index[query_word])<br>            results = results.intersection(self.inverted_index[query_word])<br>        return results<br>这里建议作者可以更新一下代码~<br>","like_count":0},{"had_liked":false,"id":283451,"user_name":"奥卡姆剃刀","can_delete":false,"product_type":"c1","uid":1143983,"ip_address":"","ucode":"BF71372CA50EDC","user_header":"https://static001.geekbang.org/account/avatar/00/11/74/af/6f39dcf8.jpg","comment_is_top":false,"comment_ctime":1615788144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615788144","product_id":100026901,"comment_content":"这篇关于搜索引擎的讲解确实不错，力挺！！  此外，关于Pyhon继承、调用父类的属性和方法，可以参考这篇文章，案例写的也不错，：https:&#47;&#47;blog.csdn.net&#47;yilulvxing&#47;article&#47;details&#47;85374142","like_count":0},{"had_liked":false,"id":278496,"user_name":"jacke","can_delete":false,"product_type":"c1","uid":1161209,"ip_address":"","ucode":"05F355E1FF88C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f9/a8f26b10.jpg","comment_is_top":false,"comment_ctime":1612975256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612975256","product_id":100026901,"comment_content":"感觉和merge k sorted list 关系不大,应该是找出 sorted list 里面的的交集？","like_count":0},{"had_liked":false,"id":275914,"user_name":"江玉环","can_delete":false,"product_type":"c1","uid":1962641,"ip_address":"","ucode":"963034E086145E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqlowuQ39YeoQDkVr4ial0BtxzyX3FzsuFq8KHqpmWgCgKs8OjotlZwfRgL2ccKricT6n7ZEUWuCxtw/132","comment_is_top":false,"comment_ctime":1611717319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611717319","product_id":100026901,"comment_content":"举手：为啥都能看懂，自己动手写不出来呢！","like_count":0},{"had_liked":false,"id":267775,"user_name":"方磊（胖大海）","can_delete":false,"product_type":"c1","uid":1044333,"ip_address":"","ucode":"C8E2ABC0A04460","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ef/6d/978bab34.jpg","comment_is_top":false,"comment_ctime":1607924897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607924897","product_id":100026901,"comment_content":"老师，这个算法有个bug，如果加载的文件不是从1-5的排序加载进去，例如按23451这样的顺序加载。可能导致找到的索引缺失，因为我们这边用了取最小的索引内容的索引+1去判断是否超过了数组界限，所以我建议在文件加载的时候再增加文件名顺序调整的逻辑，这个bug就可以解决。<br>def main(search_engine):<br>    # 搜索器模拟<br>    file_paths = [<br>        &#39;&#47;Users&#47;pangdahai&#47;Downloads&#47;2.txt&#39;,<br>        &#39;&#47;Users&#47;pangdahai&#47;Downloads&#47;3.txt&#39;,<br>        &#39;&#47;Users&#47;pangdahai&#47;Downloads&#47;4.txt&#39;,<br>        &#39;&#47;Users&#47;pangdahai&#47;Downloads&#47;5.txt&#39;,<br>        &#39;&#47;Users&#47;pangdahai&#47;Downloads&#47;1.txt&#39;<br>    ]<br>    # 为了防止后续索引建立不是按顺序完成<br>    file_paths = sorted(file_paths, reverse=False)<br>    <br>    for file_path in file_paths:<br>        search_engine.add_corpus(file_path)","like_count":0},{"had_liked":false,"id":262233,"user_name":"绿箭侠","can_delete":false,"product_type":"c1","uid":1528536,"ip_address":"","ucode":"B994F558A98E29","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/d8/123a4981.jpg","comment_is_top":false,"comment_ctime":1605669576,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605669576","product_id":100026901,"comment_content":"BOWInvertedIndexEngine  search方法捋了半个多小时，终于明白了，智商税！！！","like_count":0,"discussions":[{"author":{"id":2369413,"avatar":"https://static001.geekbang.org/account/avatar/00/24/27/85/ddeeaf30.jpg","nickname":"dived","note":"","ucode":"141916A3BAF5A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374096,"discussion_content":"羡慕年轻人 半小时就可以看懂了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621000461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261563,"user_name":"星星在线","can_delete":false,"product_type":"c1","uid":1527721,"ip_address":"","ucode":"C2EE7A8CB54E20","user_header":"https://static001.geekbang.org/account/avatar/00/17/4f/a9/0279cee8.jpg","comment_is_top":false,"comment_ctime":1605422628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605422628","product_id":100026901,"comment_content":"有一个问题，Python3当中是可以使用super(). __init__()，来调用父类构造函数。如果是单继承很好理解，但是多重继承用这种方式是调用了哪个父类的呢。还有一个问题，多重继承的调用顺序，如果两个父类中有同名函数，子类中self. xxx()调用的是哪一个父类的？","like_count":0},{"had_liked":false,"id":242797,"user_name":"raito4","can_delete":false,"product_type":"c1","uid":1714189,"ip_address":"","ucode":"7F307F9988D4A8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/28/0d/9d10e756.jpg","comment_is_top":false,"comment_ctime":1597844652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597844652","product_id":100026901,"comment_content":"受益匪浅","like_count":0},{"had_liked":false,"id":226159,"user_name":"daowuli_chihai","can_delete":false,"product_type":"c1","uid":2017371,"ip_address":"","ucode":"13E5DD278D8E95","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIiaeebUYxl7e1b8DhQGz7v6uibGcytfL8iaTke1S6NwSVxicOy5iaLGbRn2aZtxZy8vVnF6j3fjtxDEbQ/132","comment_is_top":false,"comment_ctime":1591965920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591965920","product_id":100026901,"comment_content":"百度搜到 esc 或  enter 切换 jupyter notebook 模式<br>平台不熟悉，不小心切换到命令模式，运行代码 看到【*】, 浪费不少时间","like_count":0},{"had_liked":false,"id":205916,"user_name":"人与路","can_delete":false,"product_type":"c1","uid":1618121,"ip_address":"","ucode":"CB59BFE36BF34A","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/c9/dfdc4ed8.jpg","comment_is_top":false,"comment_ctime":1586756422,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586756422","product_id":100026901,"comment_content":"景老师好，请教您一个问题，具体的，在您给出的第一个例程中，子类调用父类的初始化时使用了&quot;super(SimpleEngine, self).__init__()&quot;这样的写法，我自己尝试了“super().__init__()”的写法，在您的例程中效果是一致的。请问以上两者在任何情况都是等价的吗，即可以不用写super的参数？另外，父类的__init__()只有一个参数self，为何能super能够传&quot;SimpleEngine, self&quot;两个参数过去？望抽空解答一下，谢谢！","like_count":0,"discussions":[{"author":{"id":1018685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/3d/0c3a2fd4.jpg","nickname":"偶尔复活下","note":"","ucode":"18B1D525CD50D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295736,"discussion_content":"python2和3的不同语法 效果一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596323686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197661,"user_name":"徐旭","can_delete":false,"product_type":"c1","uid":1814806,"ip_address":"","ucode":"1D3091D15373E5","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b1/16/dd11930c.jpg","comment_is_top":false,"comment_ctime":1585390220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585390220","product_id":100026901,"comment_content":"小小搜索引擎不简单","like_count":0},{"had_liked":false,"id":195442,"user_name":"pan xi er","can_delete":false,"product_type":"c1","uid":1564961,"ip_address":"","ucode":"15D3FB11F3A77C","user_header":"https://static001.geekbang.org/account/avatar/00/17/e1/21/63472854.jpg","comment_is_top":false,"comment_ctime":1585188291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585188291","product_id":100026901,"comment_content":"为什么我试了not in后面不管是字典还是集合都得相等才可以，只有是字符串的才可以，所以这些代码都需要转换下才能正确运行吧？","like_count":0},{"had_liked":false,"id":151626,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573764353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573764353","product_id":100026901,"comment_content":"只看懂了面向对象的内容：<br>定义好接口，在实践中不断迭代实现以满足现实的功能。接口的稳定性是给调用者以良好界面。实现的不断迭代是为了满足不断变化的需求。这种设计兼顾了稳定和灵活，是非常好的trade off。但在实践中把握接口的粒度近乎艺术，现实中大量代码不是缺乏良好的抽象，就是过度定义了一堆没用的接口，或者兼而有之。","like_count":0},{"had_liked":false,"id":150520,"user_name":"hotdog5225","can_delete":false,"product_type":"c1","uid":1632462,"ip_address":"","ucode":"3FC53FEDBEE34A","user_header":"https://static001.geekbang.org/account/avatar/00/18/e8/ce/b5576a7f.jpg","comment_is_top":false,"comment_ctime":1573549073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573549073","product_id":100026901,"comment_content":"获取query拉链的使用前几节课讲的知识是不是可以这么写?<br>result_set = reduce(lambda x, y: x &amp; y , [set(self.inverted_index[query]) for query in query_words])<br>return list(result_set)<br>这样更好理解一些？","like_count":0},{"had_liked":false,"id":143701,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1571758277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571758277","product_id":100026901,"comment_content":"不能继承父类私有属性","like_count":0},{"had_liked":false,"id":142095,"user_name":"Freshman","can_delete":false,"product_type":"c1","uid":1662439,"ip_address":"","ucode":"5F4709AF68795C","user_header":"https://static001.geekbang.org/account/avatar/00/19/5d/e7/c72fb013.jpg","comment_is_top":false,"comment_ctime":1571293910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571293910","product_id":100026901,"comment_content":"封面好评","like_count":0},{"had_liked":false,"id":141569,"user_name":"Geek_sylvester","can_delete":false,"product_type":"c1","uid":1694202,"ip_address":"","ucode":"84669E65EA928E","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/fa/e94bc037.jpg","comment_is_top":false,"comment_ctime":1571192686,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571192686","product_id":100026901,"comment_content":"为什么同样的代码，我的搜索只会把1.txt加入语料库中，搜索不到2.txt和其他的内容","like_count":0,"discussions":[{"author":{"id":1297523,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/73/9c41a7ee.jpg","nickname":"雷蒙德张","note":"","ucode":"0104F5818EA7F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229533,"discussion_content":"我也遇到一样的问题，我是把所有的实例代码都加入了一个python文件中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586662427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140310,"user_name":"mashagua","can_delete":false,"product_type":"c1","uid":1058332,"ip_address":"","ucode":"E32265BA93B6AE","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/1c/2fed04cb.jpg","comment_is_top":false,"comment_ctime":1570874525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570874525","product_id":100026901,"comment_content":"你好，老师，这种 super(BOWEngine, self).__init___调用自身的是什么意思，能帮忙解释一下吗","like_count":0},{"had_liked":false,"id":140303,"user_name":"mashagua","can_delete":false,"product_type":"c1","uid":1058332,"ip_address":"","ucode":"E32265BA93B6AE","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/1c/2fed04cb.jpg","comment_is_top":false,"comment_ctime":1570873915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570873915","product_id":100026901,"comment_content":"这里面的继承每次都是先继承自身的__init__函数是什么意思？","like_count":0},{"had_liked":false,"id":118742,"user_name":"Geek_869754","can_delete":false,"product_type":"c1","uid":1508236,"ip_address":"","ucode":"A9E86C84F07CEF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7dnQChbGicibNMEC9pdCh1TdZPTSXibfculxHTjfBWEibKHfl5VpiaibfE4TC1kEhkV5GibUnweQ56pVLLkNNoDedbLDQ/132","comment_is_top":false,"comment_ctime":1564444740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564444740","product_id":100026901,"comment_content":"请问老师的github链接是多少？","like_count":0},{"had_liked":false,"id":111807,"user_name":"飞艺","can_delete":false,"product_type":"c1","uid":1542985,"ip_address":"","ucode":"6C75B3164888DC","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/49/ada4fa04.jpg","comment_is_top":false,"comment_ctime":1562606799,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562606799","product_id":100026901,"comment_content":"BOWInvertedIndexEngine类的search函数中：<br>query_words_index = list()<br>for query_word in query_words:<br>query_words_index.append(0)<br>这一段没看明白：<br>query_words_index是一个全为0的列表？<br>有什么作用？","like_count":0,"discussions":[{"author":{"id":1519491,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2f/83/81e146e4.jpg","nickname":"大海","note":"","ucode":"4F835D75186356","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531119,"discussion_content":"就是定义每个查询关键词在倒排索引中各自的查找索引值，初始为0，换一种写法更好懂\n        query_words_index = [0 for i in range(len(query_words))]\n        #query_words_index = list()\n        #for query_word in query_words:\n        # query_words_index.append(0)\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637235596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109832,"user_name":"我心飞扬","can_delete":false,"product_type":"c1","uid":1149164,"ip_address":"","ucode":"E41155122C9A1F","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/ec/1460179b.jpg","comment_is_top":false,"comment_ctime":1562118376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562118376","product_id":100026901,"comment_content":"请问 super(BOWEngine, self).__init_...<br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;98998<br>父类中的__init__是pass的为什么这里还需要调用一次，子类必须调用一下父类的init吗","like_count":0},{"had_liked":false,"id":107083,"user_name":"响雨","can_delete":false,"product_type":"c1","uid":1581705,"ip_address":"","ucode":"C5FB3A3BC68F92","user_header":"https://static001.geekbang.org/account/avatar/00/18/22/89/73397ccb.jpg","comment_is_top":false,"comment_ctime":1561456055,"is_pvip":false,"replies":[{"id":"48240","content":"嗯嗯","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1567141559,"ip_address":"","comment_id":107083,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561456055","product_id":100026901,"comment_content":"私有属性不可以被继承，但是可以创建一个普通的方法，在方法中操作私有属性。因为普通的方法是可以操作的。","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455359,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567141559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105951,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1561111183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561111183","product_id":100026901,"comment_content":"展示的优化过程非常赞, 只是在倒序索引, 如果没有添加对单词顺序的考虑, 直接用集合会更好些吧<br><br>class BOWIIEngine(SearchEngineBase):<br>    &#39;&#39;&#39;<br>    Bag of Words Inverted Index<br>    单词按顺序出现，或者希望搜索的单词在文中离得近一些<br>    &#39;&#39;&#39;<br><br>    def __init__(self):<br>        super().__init__()<br>        self.inverted_index = {}<br><br>    def process_corpus(self, id, text):<br>        words = self.parse_text_to_words(text)<br>        for w in words:<br>            if w not in self.inverted_index:<br>                self.inverted_index[w] = set()<br>            self.inverted_index[w].add(id)<br><br>    def search(self, query):<br>        qws = list(self.parse_text_to_words(query))<br>        for qw in qws:<br>            if qw not in self.inverted_index:<br>                return []<br>        results = []<br>        for qw in qws:<br>            results.append(self.inverted_index[qw])<br><br>        return reduce(lambda x, y: x.intersection(y), results)<br><br>    @staticmethod<br>    def parse_text_to_words(text):<br>        text = re.sub(r&#39;[^\\w]&#39;, &#39; &#39;, text)<br>        text = text.lower()<br>        words = text.split(&#39; &#39;)<br>        words = filter(None, words)<br>        return set(words)<br>","like_count":0},{"had_liked":false,"id":105573,"user_name":"Monroe  He","can_delete":false,"product_type":"c1","uid":1348219,"ip_address":"","ucode":"D04ECB2EF2E0DA","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/7b/8c7e3e61.jpg","comment_is_top":false,"comment_ctime":1561033788,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561033788","product_id":100026901,"comment_content":"思考题：私有变量不能被继承<br>可以通过调用继承的父类的共有方法，间接的访问父类的私有方法、属性","like_count":0},{"had_liked":false,"id":105454,"user_name":"taoist","can_delete":false,"product_type":"c1","uid":1195004,"ip_address":"","ucode":"D70AFE25CD8F10","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/fc/04a75cd0.jpg","comment_is_top":false,"comment_ctime":1561003683,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561003683","product_id":100026901,"comment_content":"python3 在functools 模块里 引入了装饰器 lru_cache<br>可以直接 导入并使用<br>from functools import lru_cache<br><br> @lru_cache()<br> def search(self, query):<br>    pass","like_count":0},{"had_liked":false,"id":104792,"user_name":"Aspirin","can_delete":false,"product_type":"c1","uid":1141751,"ip_address":"","ucode":"858B551CF0C2F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/6b/f7/3a3b82c2.jpg","comment_is_top":false,"comment_ctime":1560839073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560839073","product_id":100026901,"comment_content":"感谢作者，这一节质量很高，不仅讲解了面向对象编程基本知识，更是通过实践展示了如何应用这些思想，更可喜的是附带科普了基本的搜索引擎理论和实现原理。","like_count":0},{"had_liked":false,"id":103965,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1560575337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560575337","product_id":100026901,"comment_content":"老师你好，遇到一个简单的问题，就是我照着敲代码，1.txt 那些放在和main（）所在的.py文件同级目录，然后运行代码，报错。 F:\\project\\Advanced_python\\py3_interpreter\\Scripts\\python.exe F:&#47;project&#47;Advanced_python&#47;searchEngine&#47;SearchEngineBase.py<br>Traceback (most recent call last):<br>  File &quot;F:&#47;project&#47;Advanced_python&#47;searchEngine&#47;SearchEngineBase.py&quot;, line 74, in &lt;module&gt;<br>    main(search_engine)<br>  File &quot;F:&#47;project&#47;Advanced_python&#47;searchEngine&#47;SearchEngineBase.py&quot;, line 46, in main<br>    searchEngine.add_corpus(file_path)<br>  File &quot;F:&#47;project&#47;Advanced_python&#47;searchEngine&#47;SearchEngineBase.py&quot;, line 33, in add_corpus<br>    with open(file_path, &#39;r&#39;) as fin:<br>FileNotFoundError: [Errno 2] No such file or directory: &#39;1.txt&#39;<br><br>Process finished with exit code 1  这是什么原因呢","like_count":0},{"had_liked":false,"id":102619,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1560265194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560265194","product_id":100026901,"comment_content":"哇 这么精彩  周末打算手敲一遍代码，再看几遍，，；。学过一点NLP 知识，感觉后面可以做点什么出来啊，期待老师的实战部分。","like_count":0},{"had_liked":false,"id":102014,"user_name":"yshan","can_delete":false,"product_type":"c1","uid":1136788,"ip_address":"","ucode":"A2ECDCDA52B8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/94/c8bc2b59.jpg","comment_is_top":false,"comment_ctime":1560100682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560100682","product_id":100026901,"comment_content":"需要多看看几遍，慢慢理解","like_count":0},{"had_liked":false,"id":102013,"user_name":"可乐泡枸杞","can_delete":false,"product_type":"c1","uid":1308516,"ip_address":"","ucode":"C709B781DF0456","user_header":"https://static001.geekbang.org/account/avatar/00/13/f7/64/03d8154f.jpg","comment_is_top":false,"comment_ctime":1560100403,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1560100403","product_id":100026901,"comment_content":"我就是那个想看反馈结果了。。。果然报了FileNotFoundError: [Errno 2] No such file or directory: &#39;1.txt&#39;错误。。。老师第一个搜索引擎就进行不下去了。。","like_count":0,"discussions":[{"author":{"id":1581705,"avatar":"https://static001.geekbang.org/account/avatar/00/18/22/89/73397ccb.jpg","nickname":"响雨","note":"","ucode":"C5FB3A3BC68F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340,"discussion_content":"你先把5个文件建好再运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561456553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101954,"user_name":"春之绿野","can_delete":false,"product_type":"c1","uid":1057216,"ip_address":"","ucode":"296003F7D2B086","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/c0/38816c31.jpg","comment_is_top":false,"comment_ctime":1560071568,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1560071568","product_id":100026901,"comment_content":"私有变量不能访问吧，可以通过父类的方法去访问。","like_count":0},{"had_liked":false,"id":101762,"user_name":"Claywoow","can_delete":false,"product_type":"c1","uid":1524797,"ip_address":"","ucode":"1F1C70BCE33536","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/3d/35d6670d.jpg","comment_is_top":false,"comment_ctime":1559963848,"is_pvip":false,"replies":[{"id":"36709","content":"metaclass 作为独立的一章会出现在进阶课程中，敬请期待","user_name":"作者回复","user_name_real":"高山流水","uid":"1513504","ctime":1560030882,"ip_address":"","comment_id":101762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559963848","product_id":100026901,"comment_content":"老师可以拓展一下元类吗，它是面向对象编程中一个重要的类型吗？","like_count":0,"discussions":[{"author":{"id":1513504,"avatar":"https://static001.geekbang.org/account/avatar/00/17/18/20/75ea3b20.jpg","nickname":"高山流水","note":"","ucode":"71E513B5937481","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453106,"discussion_content":"metaclass 作为独立的一章会出现在进阶课程中，敬请期待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560030882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101644,"user_name":"朱小豪","can_delete":false,"product_type":"c1","uid":1311234,"ip_address":"","ucode":"9177EF1DDFF346","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/02/1080b30c.jpg","comment_is_top":false,"comment_ctime":1559898676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559898676","product_id":100026901,"comment_content":"确实得看第二遍，书读百遍其义自见","like_count":0},{"had_liked":false,"id":101599,"user_name":"lipan","can_delete":false,"product_type":"c1","uid":1347460,"ip_address":"","ucode":"76E2CEEE454017","user_header":"https://static001.geekbang.org/account/avatar/00/14/8f/84/2c2d8c47.jpg","comment_is_top":false,"comment_ctime":1559878925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559878925","product_id":100026901,"comment_content":"既能通过搜索引擎的例子学习Pyhton的继承方法，也能看到令人赏心悦目的图片，我蛮喜欢的","like_count":0},{"had_liked":false,"id":101359,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1559788241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559788241","product_id":100026901,"comment_content":"class A(object):<br>    def __init__(self):<br>        self.__a_private_param = &#39;我是父类私有变量&#39;<br>        self.a_param = &#39;我是父类变量&#39;<br><br>    def getPrivateParam(self):<br>        return self.__a_private_param<br><br>class B(A):<br>    def __init__(self):<br>        super(B, self).__init__()<br>        # B.private_param = self.__a_private_param 不能继承，标志a<br>        B.param = self.a_param<br><br>    def getPrivateParam(self):<br>        return super(B, self).getPrivateParam()<br><br>obj_a = A()<br>print(obj_a.getPrivateParam())<br>obj_b = B()<br>print(obj_b.param)<br>print(obj_b.getPrivateParam())<br>=======<br>我是父类私有变量<br>我是父类变量<br>我是父类私有变量<br>运行标志a时出错，而注释掉便能正常运行。说明私有类不能直接继承。","like_count":0},{"had_liked":false,"id":101101,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1559717901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559717901","product_id":100026901,"comment_content":"“集成的时候，函数是如何重写的？” 是不是继承写成了集成了？","like_count":0},{"had_liked":false,"id":101071,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1559709058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559709058","product_id":100026901,"comment_content":"思考题：<br>本质上来讲是父类的私有属性是可以继承的，因为python的私有只是伪私有，只是用了“改名机制”而已，你用self.__var去访问当然是会报错无此属性，如果你用改名机制的原则在原来属性前面加上一个下划线加父类名是可以访问的到的。看例子：<br>class A:<br>    __name = &#39;scar&#39;<br>    def __init__(self,city):<br>        self.city=city<br>        self.__password=&#39;xxxxxx&#39;<br>    def change_password(self,password):<br>        self.__password = password<br>        <br>class AA(A):<br>    pass<br><br>s=AA(&#39;hangzhou&#39;)<br><br>print(s.__dict__)<br>{&#39;city&#39;: &#39;hangzhou&#39;, &#39;_A__password&#39;: &#39;xxxxxx&#39;}<br><br>s.change_password(&#39;333333&#39;)<br>print(s._A__password)<br>&#39;333333&#39;<br><br>当然python这个私有属性的改名机制是保护装置，意味着多了层保护，不要尝试直接去读取私有属性是python程序员好的行为规范。如果要去访问则通过父类的公用方法的接口去访问。","like_count":0},{"had_liked":false,"id":101053,"user_name":"lllong33","can_delete":false,"product_type":"c1","uid":1528751,"ip_address":"","ucode":"5D012385994C3D","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","comment_is_top":false,"comment_ctime":1559706550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559706550","product_id":100026901,"comment_content":"收藏，值得反复阅读。<br>问题解答：私有变量和方法可以通过 obj._className__field 访问。<br>继承可以通过<br>```python<br>通过访问公有方法（从父类继承）来访问父类私有属性时却形成了，子类可以继承父类私有属性。<br># encoding = utf-8<br><br>class Person(object):<br><br>    def __init__(self, name, age):<br>        self.name = name<br>        self.__age = age        # 定义私有变量 __age<br>        print(self.__age)       # 创建子类对象时，__age仍被赋值<br><br>    def get___age(self):         # 定义获取 __age 的公有方法<br>        return self.__age<br><br>    def set___age(self, age):    # 定义设置 __age 的共有方法<br>        self.__age = age<br><br><br>class Student(Person):<br><br>    pass                        # Student没有显式定义任何属性和方法<br><br><br>tom = Student(&quot;tom&quot;, 18)<br>print(&quot;tom年龄：&quot; + str(tom.get___age()))<br>tom.set___age(20)<br>print(&quot;tom年龄：&quot; + str(tom.get___age()))<br>```","like_count":0},{"had_liked":false,"id":101040,"user_name":"GentleCP","can_delete":false,"product_type":"c1","uid":1525440,"ip_address":"","ucode":"BB1EE3720D44F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/c0/01292b08.jpg","comment_is_top":false,"comment_ctime":1559704538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559704538","product_id":100026901,"comment_content":"私有变量只能被该类的函数调用，不能被子类继承，子类如果想访问私有变量需在父类设定一个方法用于返回私有变量类似于get。如果变量只想被类本身和子类访问可以定义保护变量（以单下划线开头）","like_count":0},{"had_liked":false,"id":101038,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1559704221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559704221","product_id":100026901,"comment_content":"这个太棒了，如果能结合设计模式讲一讲，就更好了","like_count":0},{"had_liked":false,"id":101012,"user_name":"夜路破晓","can_delete":false,"product_type":"c1","uid":1353577,"ip_address":"","ucode":"9B875F94B759B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3hZfficKPGCq2kjFBu9SgaMjibJTEl7iaW1ta6pZNyiaWP8XEsNpunlnsiaOtBpWTXfT5BvRP3qNByml6p9rtBvqewg/132","comment_is_top":false,"comment_ctime":1559700696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559700696","product_id":100026901,"comment_content":"大地母亲在忽悠着你！<br>结合上篇多看几遍。代码是其次的，感觉更重要的是思路。","like_count":0},{"had_liked":false,"id":100999,"user_name":"Adam","can_delete":false,"product_type":"c1","uid":1305633,"ip_address":"","ucode":"338BA720880E4F","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/21/b0fe1bfd.jpg","comment_is_top":false,"comment_ctime":1559699297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559699297","product_id":100026901,"comment_content":"ES中索引也是倒排实现的，","like_count":0},{"had_liked":false,"id":100984,"user_name":"","can_delete":false,"product_type":"c1","uid":1322330,"ip_address":"","ucode":"FA2983C5AD320C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/5a/cc637589.jpg","comment_is_top":false,"comment_ctime":1559698018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559698018","product_id":100026901,"comment_content":"看到这章惊喜了，下班了慢慢看。😊","like_count":0},{"had_liked":false,"id":100972,"user_name":"leixin","can_delete":false,"product_type":"c1","uid":1318291,"ip_address":"","ucode":"9885DF5FB2E136","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/szNEybCR1Al4p6eDyT8atNjen7ZY9cBJSXOQl1EnrTM2efiaHlPtL7X44JeibXs9qEFLWv6HJWBwq5tVlNahGDGQ/132","comment_is_top":false,"comment_ctime":1559697333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559697333","product_id":100026901,"comment_content":"接三楼:个人理解，多继承不再被多继承就问题不大，另外多继承最好不写相同名称的属性和方法。写混入名称要规范明了，用控制好的混入还是可以用的。","like_count":0},{"had_liked":false,"id":100911,"user_name":"随风の","can_delete":false,"product_type":"c1","uid":1307306,"ip_address":"","ucode":"50C25386889CC9","user_header":"https://static001.geekbang.org/account/avatar/00/13/f2/aa/47f2e37d.jpg","comment_is_top":false,"comment_ctime":1559688332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559688332","product_id":100026901,"comment_content":"父类的私有属性不能被子类继承，但可以在子类继承父类的公有方法中调用父类的私有属性","like_count":0}]}