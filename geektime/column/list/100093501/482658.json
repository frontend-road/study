{"id":482658,"title":"37｜代码操练：怎么实现一个TCP服务器？（中）","content":"<p>你好，我是Tony Bai。</p><p>上一讲中，我们讲解了解决Go语言学习“最后一公里”的实用思路，那就是“理解问题” -&gt; “技术预研与储备” -&gt; “设计与实现”的三角循环，并且我们也完成了“理解问题”和“技术预研与储备”这两个环节，按照“三角循环”中的思路，这一讲我们应该针对实际问题进行一轮设计与实现了。</p><p>今天，我们的目标是实现一个基于TCP的自定义应用层协议的通信服务端，要完成这一目标，我们需要建立协议的抽象、实现协议的打包与解包、服务端的组装、验证与优化等工作。一步一步来，我们先在程序世界建立一个对上一讲中自定义应用层协议的抽象。</p><h2>建立对协议的抽象</h2><p>程序是对现实世界的抽象。对于现实世界的自定义应用协议规范，我们需要在程序世界建立起对这份协议的抽象。在进行抽象之前，我们先建立这次实现要用的源码项目tcp-server-demo1，建立的步骤如下：</p><pre><code class=\"language-plain\">$mkdir tcp-server-demo1\n$cd tcp-server-demo1\n$go mod init github.com/bigwhite/tcp-server-demo1\ngo: creating new go.mod: module github.com/bigwhite/tcp-server-demo1\n</code></pre><!-- [[[read_end]]] --><p>为了方便学习，我这里再将上一讲中的自定义协议规范贴出来对照参考：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/21/70b43197100a790f3a78db50997c1d21.jpg?wh=1980x1080\" alt=\"\"></p><h3>深入协议字段</h3><p>上一讲，我们没有深入到协议规范中对协议的各个字段进行讲解，但在建立抽象之前，我们有必要了解一下各个字段的具体含义。</p><p>这是一个高度简化的、基于二进制模式定义的协议。二进制模式定义的特点，就是采用长度字段标识独立数据包的边界。</p><p>在这个协议规范中，我们看到：请求包和应答包的第一个字段（totalLength）都是包的总长度，它就是用来标识包边界的那个字段，也是在应用层用于“分割包”的最重要字段。</p><p>请求包与应答包的第二个字段也一样，都是commandID，这个字段用于标识包类型，这里我们定义四种包类型：</p><ul>\n<li>连接请求包（值为0x01）</li>\n<li>消息请求包（值为0x02）</li>\n<li>连接响应包（值为0x81）</li>\n<li>消息响应包（值为0x82）</li>\n</ul><p>换为对应的代码就是：</p><pre><code class=\"language-plain\">const (\n    CommandConn   = iota + 0x01 // 0x01，连接请求包\n    CommandSubmit               // 0x02，消息请求包\n)\n\nconst (\n    CommandConnAck   = iota + 0x81 // 0x81，连接请求的响应包\n    CommandSubmitAck               // 0x82，消息请求的响应包\n)\n</code></pre><p>请求包与应答包的第三个字段都是ID，ID是每个连接上请求包的消息流水号，顺序累加，步长为1，循环使用，多用来请求发送方后匹配响应包，所以要求一对请求与响应消息的流水号必须相同。</p><p>请求包与响应包唯一的不同之处，就在于最后一个字段：请求包定义了有效载荷（payload），这个字段承载了应用层需要的业务数据；而响应包则定义了请求包的响应状态字段（result），这里其实简化了响应状态字段的取值，成功的响应用0表示，如果是失败的响应，无论失败原因是什么，我们都用1来表示。</p><p>明确了应用层协议的各个字段定义之后，我们接下来就看看如何建立起对这个协议的抽象。</p><h3>建立Frame和Packet抽象</h3><p>首先我们要知道，TCP连接上的数据是一个没有边界的字节流，但在业务层眼中，没有字节流，只有各种协议消息。因此，无论是从客户端到服务端，还是从服务端到客户端，业务层在连接上看到的都应该是一个挨着一个的协议消息流。</p><p>现在我们建立第一个抽象：<strong>Frame</strong>。每个Frame表示一个协议消息，这样在业务层眼中，连接上的字节流就是由一个接着一个Frame组成的，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/96/34/962d1839064759e3180a78d168700034.jpg?wh=1920x1080\" alt=\"\"></p><p>我们的自定义协议就封装在这一个个的Frame中。协议规定了将Frame分割开来的方法，那就是利用每个Frame开始处的totalLength，每个Frame由一个totalLength和Frame的负载（payload）构成，比如你可以看看下图中左侧的Frame结构：</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/cf/cdcc981fdc752dea66f4ba01f7da91cf.jpg?wh=1980x1080\" alt=\"\"></p><p>这样，我们通过Frame header: totalLength就可以将Frame之间隔离开来。</p><p>在这个基础上，我们建立协议的第二个抽象：<strong>Packet</strong>。我们将Frame payload定义为一个Packet。上图右侧展示的就是Packet的结构。</p><p>Packet就是业务层真正需要的消息，每个Packet由Packet头和Packet Body部分组成。Packet头就是commandID，用于标识这个消息的类型；而ID和payload（packet payload）或result字段组成了Packet的Body部分，对业务层有价值的数据都包含在Packet Body部分。</p><p>那么到这里，我们就通过Frame和Packet两个类型结构，完成了程序世界对我们私有协议规范的抽象。接下来，我们要做的就是基于Frame和Packet这两个概念，实现对我们私有协议的解包与打包操作。</p><h2>协议的解包与打包</h2><p>所谓协议的<strong>解包（decode）</strong>，就是指识别TCP连接上的字节流，将一组字节“转换”成一个特定类型的协议消息结构，然后这个消息结构会被业务处理逻辑使用。</p><p>而<strong>打包（encode）</strong>刚刚好相反，是指将一个特定类型的消息结构转换为一组字节，然后这组字节数据会被放在连接上发送出去。</p><p>具体到我们这个自定义协议上，解包就是指<code>字节流 -&gt; Frame</code>，打包是指 <code>Frame -&gt; 字节流</code>。你可以看一下针对这个协议的服务端解包与打包的流程图：</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/2b/2be4e8b5b2f3c973199be6dc8f454c2b.jpg?wh=1980x1080\" alt=\"\"></p><p>我们看到，TCP流数据先后经过frame decode和packet decode，得到应用层所需的packet数据，而业务层回复的响应，则先后经过packet的encode与frame的encode，写入TCP数据流中。</p><p>到这里，我们实际上已经完成了协议抽象的设计与解包打包原理的设计过程了。接下来，我们先来看看私有协议部分的相关代码实现。</p><h3>Frame的实现</h3><p>前面说过，协议部分最重要的两个抽象是Frame和Packet，于是我们就在项目中建立frame包与packet包，分别与两个协议抽象对应。frame包的职责是提供识别TCP流边界的编解码器，我们可以很容易为这样的编解码器，定义出一个统一的接口类型StreamFrameCodec：</p><pre><code class=\"language-plain\">// tcp-server-demo1/frame/frame.go\n\ntype FramePayload []byte\n\ntype StreamFrameCodec interface {\n    Encode(io.Writer, FramePayload) error   // data -&gt; frame，并写入io.Writer\n    Decode(io.Reader) (FramePayload, error) // 从io.Reader中提取frame payload，并返回给上层\n}\n</code></pre><p>StreamFrameCodec接口类型有两个方法Encode与Decode。Encode方法用于将输入的Frame payload编码为一个Frame，然后写入io.Writer所代表的输出（outbound）TCP流中。而Decode方法正好相反，它从代表输入（inbound）TCP流的io.Reader中读取一个完整Frame，并将得到的Frame payload解析出来并返回。</p><p>这里，我们给出一个针对我们协议的StreamFrameCodec接口的实现：</p><pre><code class=\"language-plain\">// tcp-server-demo1/frame/frame.go\n\nvar ErrShortWrite = errors.New(\"short write\")\nvar ErrShortRead = errors.New(\"short read\")\n\ntype myFrameCodec struct{}\n\nfunc NewMyFrameCodec() StreamFrameCodec {\n    return &amp;myFrameCodec{}\n}\n\nfunc (p *myFrameCodec) Encode(w io.Writer, framePayload FramePayload) error {\n    var f = framePayload\n    var totalLen int32 = int32(len(framePayload)) + 4\n\n    err := binary.Write(w, binary.BigEndian, &amp;totalLen)\n    if err != nil {\n        return err\n    }\n\n    n, err := w.Write([]byte(f)) // write the frame payload to outbound stream\n    if err != nil {\n        return err\n    }\n  \n    if n != len(framePayload) {\n        return ErrShortWrite\n    }\n\n    return nil\n}\n\nfunc (p *myFrameCodec) Decode(r io.Reader) (FramePayload, error) {\n    var totalLen int32\n    err := binary.Read(r, binary.BigEndian, &amp;totalLen)\n    if err != nil {\n        return nil, err\n    }\n\n    buf := make([]byte, totalLen-4)\n    n, err := io.ReadFull(r, buf)\n    if err != nil {\n        return nil, err\n    }\n  \n    if n != int(totalLen-4) {\n        return nil, ErrShortRead\n    }\n\n    return FramePayload(buf), nil\n}\n</code></pre><p>在在这段实现中，有三点事项需要我们注意：</p><ul>\n<li>网络字节序使用大端字节序（BigEndian），因此无论是Encode还是Decode，我们都是用binary.BigEndian；</li>\n<li>binary.Read或Write会根据参数的宽度，读取或写入对应的字节个数的字节，这里totalLen使用int32，那么Read或Write只会操作数据流中的4个字节；</li>\n<li>这里没有设置网络I/O操作的Deadline，io.ReadFull一般会读满你所需的字节数，除非遇到EOF或ErrUnexpectedEOF。</li>\n</ul><p>在工程实践中，保证打包与解包正确的最有效方式就是<strong>编写单元测试</strong>，StreamFrameCodec接口的Decode和Encode方法的参数都是接口类型，这让我们可以很容易为StreamFrameCodec接口的实现编写测试用例。下面是我为myFrameCodec编写了两个测试用例：</p><pre><code class=\"language-plain\">// tcp-server-demo1/frame/frame_test.go\n\nfunc TestEncode(t *testing.T) {\n    codec := NewMyFrameCodec()\n    buf := make([]byte, 0, 128)\n    rw := bytes.NewBuffer(buf)\n\n    err := codec.Encode(rw, []byte(\"hello\"))\n    if err != nil {\n        t.Errorf(\"want nil, actual %s\", err.Error())\n    }\n\n    // 验证Encode的正确性\n    var totalLen int32\n    err = binary.Read(rw, binary.BigEndian, &amp;totalLen)\n    if err != nil {\n        t.Errorf(\"want nil, actual %s\", err.Error())\n    }\n\n    if totalLen != 9 {\n        t.Errorf(\"want 9, actual %d\", totalLen)\n    }\n\n    left := rw.Bytes()\n    if string(left) != \"hello\" {\n        t.Errorf(\"want hello, actual %s\", string(left))\n    }\n}\n\nfunc TestDecode(t *testing.T) {\n    codec := NewMyFrameCodec()\n    data := []byte{0x0, 0x0, 0x0, 0x9, 'h', 'e', 'l', 'l', 'o'}\n\n    payload, err := codec.Decode(bytes.NewReader(data))\n    if err != nil {\n        t.Errorf(\"want nil, actual %s\", err.Error())\n    }\n\n    if string(payload) != \"hello\" {\n        t.Errorf(\"want hello, actual %s\", string(payload))\n    }\n}\n</code></pre><p>我们看到，测试Encode方法，我们其实不需要建立真实的网络连接，只要用一个满足io.Writer的bytes.Buffer实例“冒充”真实网络连接就可以了，同时bytes.Buffer类型也实现了io.Reader接口，我们可以很方便地从中读取出Encode后的内容，并进行校验比对。</p><p>为了提升测试覆盖率，我们还需要尽可能让测试覆盖到所有可测的错误执行分支上。这里，我模拟了Read或Write出错的情况，让执行流进入到Decode或Encode方法的错误分支中：</p><pre><code class=\"language-plain\">type ReturnErrorWriter struct {\n    W  io.Writer\n    Wn int // 第几次调用Write返回错误\n    wc int // 写操作次数计数\n}\n\nfunc (w *ReturnErrorWriter) Write(p []byte) (n int, err error) {\n    w.wc++\n    if w.wc &gt;= w.Wn {\n        return 0, errors.New(\"write error\")\n    }\n    return w.W.Write(p)\n}\n\ntype ReturnErrorReader struct {\n    R  io.Reader\n    Rn int // 第几次调用Read返回错误\n    rc int // 读操作次数计数\n}\n\nfunc (r *ReturnErrorReader) Read(p []byte) (n int, err error) {\n    r.rc++\n    if r.rc &gt;= r.Rn {\n        return 0, errors.New(\"read error\")\n    }\n    return r.R.Read(p)\n}\n\nfunc TestEncodeWithWriteFail(t *testing.T) {\n    codec := NewMyFrameCodec()\n    buf := make([]byte, 0, 128)\n    w := bytes.NewBuffer(buf)\n\n    // 模拟binary.Write返回错误\n    err := codec.Encode(&amp;ReturnErrorWriter{\n        W:  w,\n        Wn: 1,\n    }, []byte(\"hello\"))\n    if err == nil {\n        t.Errorf(\"want non-nil, actual nil\")\n    }\n\n    // 模拟w.Write返回错误\n    err = codec.Encode(&amp;ReturnErrorWriter{\n        W:  w,\n        Wn: 2,\n    }, []byte(\"hello\"))\n    if err == nil {\n        t.Errorf(\"want non-nil, actual nil\")\n    }\n}\n\nfunc TestDecodeWithReadFail(t *testing.T) {\n    codec := NewMyFrameCodec()\n    data := []byte{0x0, 0x0, 0x0, 0x9, 'h', 'e', 'l', 'l', 'o'}\n\n    // 模拟binary.Read返回错误\n    _, err := codec.Decode(&amp;ReturnErrorReader{\n        R:  bytes.NewReader(data),\n        Rn: 1,\n    })\n    if err == nil {\n        t.Errorf(\"want non-nil, actual nil\")\n    }\n\n    // 模拟io.ReadFull返回错误\n    _, err = codec.Decode(&amp;ReturnErrorReader{\n        R:  bytes.NewReader(data),\n        Rn: 2,\n    })\n    if err == nil {\n        t.Errorf(\"want non-nil, actual nil\")\n    }\n}\n</code></pre><p>为了实现错误分支的测试，我们在测试代码源文件中创建了两个类型：ReturnErrorWriter和ReturnErrorReader，它们分别实现了io.Writer与io.Reader。</p><p>我们可以控制在第几次调用这两个类型的Write或Read方法时，返回错误，这样就可以让Encode或Decode方法按照我们的意图，进入到不同错误分支中去。有了这两个用例，我们的frame包的测试覆盖率（通过go test -cover .可以查看）就可以达到90%以上了。</p><h3>Packet的实现</h3><p>接下来，我们再看看Packet这个抽象的实现。和Frame不同，Packet有多种类型（这里只定义了Conn、submit、connack、submit ack)。所以我们要先抽象一下这些类型需要遵循的共同接口：</p><pre><code class=\"language-plain\">// tcp-server-demo1/packet/packet.go\n\ntype Packet interface {\n    Decode([]byte) error     // []byte -&gt; struct\n    Encode() ([]byte, error) //  struct -&gt; []byte\n}\n</code></pre><p>其中，Decode是将一段字节流数据解码为一个Packet类型，可能是conn，可能是submit等，具体我们要根据解码出来的commandID判断。而Encode则是将一个Packet类型编码为一段字节流数据。</p><p>考虑到篇幅与复杂性，我们这里只完成submit和submitack类型的Packet接口实现，省略了conn流程，也省略conn以及connack类型的实现，你可以课后自己思考一下有conn流程时代码应该如何调整。</p><pre><code class=\"language-plain\">// tcp-server-demo1/packet/packet.go\n\ntype Submit struct {\n    ID      string\n    Payload []byte\n}\n\nfunc (s *Submit) Decode(pktBody []byte) error {\n    s.ID = string(pktBody[:8])\n    s.Payload = pktBody[8:]\n    return nil\n}\n\nfunc (s *Submit) Encode() ([]byte, error) {\n    return bytes.Join([][]byte{[]byte(s.ID[:8]), s.Payload}, nil), nil\n}\n\ntype SubmitAck struct {\n    ID     string\n    Result uint8\n}\n\nfunc (s *SubmitAck) Decode(pktBody []byte) error {\n    s.ID = string(pktBody[0:8])\n    s.Result = uint8(pktBody[8])\n    return nil\n}\n\nfunc (s *SubmitAck) Encode() ([]byte, error) {\n    return bytes.Join([][]byte{[]byte(s.ID[:8]), []byte{s.Result}}, nil), nil\n}\n</code></pre><p>这里各种类型的编解码被调用的前提，是明确数据流是什么类型的，因此我们需要在包级提供一个导出的函数Decode，这个函数负责从字节流中解析出对应的类型（根据commandID），并调用对应类型的Decode方法：</p><pre><code class=\"language-plain\">// tcp-server-demo1/packet/packet.go\n\nfunc Decode(packet []byte) (Packet, error) {\n\tcommandID := packet[0]\n\tpktBody := packet[1:]\n\n\tswitch commandID {\n\tcase CommandConn:\n\t\treturn nil, nil\n\tcase CommandConnAck:\n\t\treturn nil, nil\n\tcase CommandSubmit:\n\t\ts := Submit{}\n\t\terr := s.Decode(pktBody)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &amp;s, nil\n\tcase CommandSubmitAck:\n\t\ts := SubmitAck{}\n\t\terr := s.Decode(pktBody)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &amp;s, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown commandID [%d]\", commandID)\n\t}\n}\n</code></pre><p>同样，我们也需要包级的Encode函数，根据传入的packet类型调用对应的Encode方法实现对象的编码：</p><pre><code class=\"language-plain\">// tcp-server-demo1/packet/packet.go\n\nfunc Encode(p Packet) ([]byte, error) {\n\tvar commandID uint8\n\tvar pktBody []byte\n\tvar err error\n\n\tswitch t := p.(type) {\n\tcase *Submit:\n\t\tcommandID = CommandSubmit\n\t\tpktBody, err = p.Encode()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase *SubmitAck:\n\t\tcommandID = CommandSubmitAck\n\t\tpktBody, err = p.Encode()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown type [%s]\", t)\n\t}\n\treturn bytes.Join([][]byte{[]byte{commandID}, pktBody}, nil), nil\n}\n</code></pre><p>不过，对packet包中各个类型的Encode和Decode方法的测试，与frame包的相似，这里我就把为packet包编写单元测试的任务就交给你自己完成了，如果有什么问题欢迎在留言区留言。</p><p>好了，万事俱备，只欠东风！下面我们就来编写服务端的程序结构，将tcp conn与Frame、Packet连接起来。</p><h2>服务端的组装</h2><p>在上一讲中，我们按照每个连接一个Goroutine的模型，给出了典型Go网络服务端程序的结构，这里我们就以这个结构为基础，将Frame、Packet加进来，形成我们的第一版服务端实现：</p><pre><code class=\"language-plain\">// tcp-server-demo1/cmd/server/main.go\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/bigwhite/tcp-server-demo1/frame\"\n\t\"github.com/bigwhite/tcp-server-demo1/packet\"\n)\n\nfunc handlePacket(framePayload []byte) (ackFramePayload []byte, err error) {\n\tvar p packet.Packet\n\tp, err = packet.Decode(framePayload)\n\tif err != nil {\n\t\tfmt.Println(\"handleConn: packet decode error:\", err)\n\t\treturn\n\t}\n\n\tswitch p.(type) {\n\tcase *packet.Submit:\n\t\tsubmit := p.(*packet.Submit)\n\t\tfmt.Printf(\"recv submit: id = %s, payload=%s\\n\", submit.ID, string(submit.Payload))\n\t\tsubmitAck := &amp;packet.SubmitAck{\n\t\t\tID:     submit.ID,\n\t\t\tResult: 0,\n\t\t}\n\t\tackFramePayload, err = packet.Encode(submitAck)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"handleConn: packet encode error:\", err)\n\t\t\treturn nil, err\n\t\t}\n\t\treturn ackFramePayload, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown packet type\")\n\t}\n}\n\nfunc handleConn(c net.Conn) {\n\tdefer c.Close()\n\tframeCodec := frame.NewMyFrameCodec()\n\n\tfor {\n\t\t// decode the frame to get the payload\n\t\tframePayload, err := frameCodec.Decode(c)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"handleConn: frame decode error:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// do something with the packet\n\t\tackFramePayload, err := handlePacket(framePayload)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"handleConn: handle packet error:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// write ack frame to the connection\n\t\terr = frameCodec.Encode(c, ackFramePayload)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"handleConn: frame encode error:\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tl, err := net.Listen(\"tcp\", \":8888\")\n\tif err != nil {\n\t\tfmt.Println(\"listen error:\", err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"accept error:\", err)\n\t\t\tbreak\n\t\t}\n\t\t// start a new goroutine to handle the new connection.\n\t\tgo handleConn(c)\n\t}\n}\n</code></pre><p>这个程序的逻辑非常清晰，服务端程序监听8888端口，并在每次调用Accept方法后得到一个新连接，服务端程序将这个新连接交到一个新的Goroutine中处理。</p><p>新Goroutine的主函数为handleConn，有了Packet和Frame这两个抽象的加持，这个函数同样拥有清晰的代码调用结构：</p><pre><code class=\"language-plain\">// handleConn的调用结构\n\nread frame from conn\n    -&gt;frame decode\n\t    -&gt; handle packet\n\t\t    -&gt; packet decode\n\t\t    -&gt; packet(ack) encode\n    -&gt;frame(ack) encode\nwrite ack frame to conn\n</code></pre><p>到这里，一个基于TCP的自定义应用层协议的经典阻塞式的服务端就完成了。不过这里的服务端依旧是一个简化的实现，比如我们这里没有考虑支持优雅退出、没有捕捉某个链接上出现的可能导致整个程序退出的panic等，这些我也想作为作业留给你。</p><p>接下来，我们就来验证一下这个服务端实现是否能正常工作。</p><h2>验证测试</h2><p>要验证服务端的实现是否可以正常工作，我们需要实现一个自定义应用层协议的客户端。这里，我们同样基于frame、packet两个包，实现了一个自定义应用层协议的客户端。下面是客户端的main函数：</p><pre><code class=\"language-plain\">// tcp-server-demo1/cmd/client/main.go\nfunc main() {\n    var wg sync.WaitGroup\n    var num int = 5\n\n    wg.Add(5)\n\n    for i := 0; i &lt; num; i++ {\n        go func(i int) {\n            defer wg.Done()\n            startClient(i)\n        }(i + 1)\n    }\n    wg.Wait()\n}\n</code></pre><p>我们看到，客户端启动了5个Goroutine，模拟5个并发连接。startClient函数是每个连接的主处理函数，我们来看一下：</p><pre><code class=\"language-plain\">func startClient(i int) {\n    quit := make(chan struct{})\n    done := make(chan struct{})\n    conn, err := net.Dial(\"tcp\", \":8888\")\n    if err != nil {\n        fmt.Println(\"dial error:\", err)\n        return\n    }\n    defer conn.Close()\n    fmt.Printf(\"[client %d]: dial ok\", i)\n\n    // 生成payload\n    rng, err := codename.DefaultRNG()\n    if err != nil {\n        panic(err)\n    }\n\n    frameCodec := frame.NewMyFrameCodec()\n    var counter int\n\n    go func() {\n        // handle ack\n        for {\n            select {\n            case &lt;-quit:\n                done &lt;- struct{}{}\n                return\n            default:\n            }\n\n            conn.SetReadDeadline(time.Now().Add(time.Second * 5))\n            ackFramePayLoad, err := frameCodec.Decode(conn)\n            if err != nil {\n                if e, ok := err.(net.Error); ok {\n                    if e.Timeout() {\n                        continue\n                    }\n                }\n                panic(err)\n            }\n\n            p, err := packet.Decode(ackFramePayLoad)\n            submitAck, ok := p.(*packet.SubmitAck)\n            if !ok {\n                panic(\"not submitack\")\n            }\n            fmt.Printf(\"[client %d]: the result of submit ack[%s] is %d\\n\", i, submitAck.ID, submitAck.Result)\n        }\n    }()\n\n    for {\n        // send submit\n        counter++\n        id := fmt.Sprintf(\"%08d\", counter) // 8 byte string\n        payload := codename.Generate(rng, 4)\n        s := &amp;packet.Submit{\n            ID:      id,\n            Payload: []byte(payload),\n        }\n\n        framePayload, err := packet.Encode(s)\n        if err != nil {\n            panic(err)\n        }\n\n        fmt.Printf(\"[client %d]: send submit id = %s, payload=%s, frame length = %d\\n\",\n            i, s.ID, s.Payload, len(framePayload)+4)\n\n        err = frameCodec.Encode(conn, framePayload)\n        if err != nil {\n            panic(err)\n        }\n\n        time.Sleep(1 * time.Second)\n        if counter &gt;= 10 {\n            quit &lt;- struct{}{}\n            &lt;-done\n            fmt.Printf(\"[client %d]: exit ok\", i)\n            return\n        }\n    }\n}\n</code></pre><p>关于startClient函数，我们需要简单说明几点。</p><p>首先，startClient函数启动了两个Goroutine，一个负责向服务端发送submit消息请求，另外一个Goroutine则负责读取服务端返回的响应；</p><p>其次，客户端发送的submit请求的负载（payload）是由第三方包github.com/lucasepe/codename负责生成的，这个包会生成一些对人类可读的随机字符串，比如：firm-iron、 moving-colleen、game-nova这样的字符串；</p><p>另外，负责读取服务端返回响应的Goroutine，使用SetReadDeadline方法设置了读超时，这主要是考虑该Goroutine可以在收到退出通知时，能及时从Read阻塞中跳出来。</p><p>好了，现在我们就来构建和运行一下这两个程序。</p><p>我在tcp-server-demo1目录下提供了Makefile，如果你使用的是Linux或macOS操作系统，可以直接敲入make构建两个程序，如果你是在Windows下构建，可以直接敲入下面的go build命令构建：</p><pre><code class=\"language-plain\">$make\ngo build github.com/bigwhite/tcp-server-demo1/cmd/server\ngo build github.com/bigwhite/tcp-server-demo1/cmd/client\n</code></pre><p>构建成功后，我们先来启动server程序：</p><pre><code class=\"language-plain\">$./server\nserver start ok(on *.8888)\n</code></pre><p>然后，我们启动client程序，启动后client程序便会向服务端建立5条连接，并发送submit请求，client端的部分日志如下：</p><pre><code class=\"language-plain\">$./client\n[client 5]: dial ok\n[client 1]: dial ok\n[client 5]: send submit id = 00000001, payload=credible-deathstrike-33e1, frame length = 38\n[client 3]: dial ok\n[client 1]: send submit id = 00000001, payload=helped-lester-8f15, frame length = 31\n[client 4]: dial ok\n[client 4]: send submit id = 00000001, payload=strong-timeslip-07fa, frame length = 33\n[client 3]: send submit id = 00000001, payload=wondrous-expediter-136e, frame length = 36\n[client 5]: the result of submit ack[00000001] is 0\n[client 1]: the result of submit ack[00000001] is 0\n[client 3]: the result of submit ack[00000001] is 0\n[client 2]: dial ok\n... ...\n[client 3]: send submit id = 00000010, payload=bright-monster-badoon-5719, frame length = 39\n[client 4]: send submit id = 00000010, payload=crucial-wallop-ec2d, frame length = 32\n[client 2]: send submit id = 00000010, payload=pro-caliban-c803, frame length = 29\n[client 1]: send submit id = 00000010, payload=legible-shredder-3d81, frame length = 34\n[client 5]: send submit id = 00000010, payload=settled-iron-monger-bf78, frame length = 37\n[client 3]: the result of submit ack[00000010] is 0\n[client 4]: the result of submit ack[00000010] is 0\n[client 1]: the result of submit ack[00000010] is 0\n[client 2]: the result of submit ack[00000010] is 0\n[client 5]: the result of submit ack[00000010] is 0\n[client 4]: exit ok\n[client 1]: exit ok\n[client 3]: exit ok\n[client 5]: exit ok\n[client 2]: exit ok\n</code></pre><p>client在每条连接上发送10个submit请求后退出。这期间服务端会输出如下日志：</p><pre><code class=\"language-plain\">recv submit: id = 00000001, payload=credible-deathstrike-33e1\nrecv submit: id = 00000001, payload=helped-lester-8f15\nrecv submit: id = 00000001, payload=wondrous-expediter-136e\nrecv submit: id = 00000001, payload=strong-timeslip-07fa\nrecv submit: id = 00000001, payload=delicate-leatherneck-4b12\nrecv submit: id = 00000002, payload=certain-deadpool-779d\nrecv submit: id = 00000002, payload=clever-vapor-25ce\nrecv submit: id = 00000002, payload=causal-guardian-4f84\nrecv submit: id = 00000002, payload=noted-tombstone-1b3e\n... ...\nrecv submit: id = 00000010, payload=settled-iron-monger-bf78\nrecv submit: id = 00000010, payload=pro-caliban-c803\nrecv submit: id = 00000010, payload=legible-shredder-3d81\nhandleConn: frame decode error: EOF\nhandleConn: frame decode error: EOF\nhandleConn: frame decode error: EOF\nhandleConn: frame decode error: EOF\nhandleConn: frame decode error: EOF\n</code></pre><p>从结果来看，我们实现的这一版服务端运行正常！</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>在上一讲完成对socket编程模型、网络I/O操作的技术预研后，这一讲我们正式进入基于TCP的自定义应用层协议的通信服务端的设计与实现环节。</p><p>在这一环节中，我们首先建立了对协议的抽象，这是实现通信服务端的基石。我们使用Frame的概念来表示TCP字节流中的每一个协议消息，这使得在业务层的视角下，连接上的字节流就是由一个接着一个Frame组成的。接下来，我们又建立了第二个抽象Packet，来表示业务层真正需要的消息。</p><p>在这两个抽象的基础上，我们实现了frame与packet各自的打包与解包，整个实现是低耦合的，我们可以在对frame编写测试用例时体会到这一点。</p><p>最后，我们把上一讲提到的、一个Goroutine负责处理一个连接的典型Go网络服务端程序结构与frame、packet的实现组装到一起，就实现了我们的第一版服务端。之后，我们还编写了客户端模拟器对这个服务端的实现做了验证。</p><p>这个服务端采用的是Go经典阻塞I/O的编程模型，你是不是已经感受到了这种模型在开发阶段带来的好处了呢！</p><h2>思考题</h2><p>在这讲的中间部分，我已经把作业留给你了：</p><ol>\n<li>为packet包编写单元测试；</li>\n<li>为我们的服务端增加优雅退出机制，以及捕捉某个链接上出现的可能导致整个程序退出的panic。</li>\n</ol><h3><a href=\"https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/37\">项目的源代码在这里！</a></h3>","comments":[{"had_liked":false,"id":347911,"user_name":"Aeins","can_delete":false,"product_type":"c1","uid":1045910,"ip_address":"","ucode":"D5BF220767541D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","comment_is_top":false,"comment_ctime":1654575995,"is_pvip":false,"replies":[{"id":126809,"content":"问题很棒！\n\n这里逐一回答一下：\n1、2：网络字节序是TCP&#47;IP中规定好的一种数据表示格式,它与具体的CPU类型、操作系统等无关,从而可以保证数据在不同主机之间传输时能够被正确解释。\n3. 按照每个连接一个 Goroutine 的模型，不是并发写，不存在你说的问题。\n4.  go doc io.ReadFull一下，一般情况下，ReadFull都会读出你想要的长度的数据。你遇到错误时，ReadFull返回什么error呢。 \n [upd]： 发现问题了。是client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1654610362,"ip_address":"","comment_id":347911,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"几点疑问\n\n1. 协议处理程序保证使用相同的字节序的情况下，有必要一定用大端序吗，改成小端序，也能成功。\n\n2. TCP 保证顺序交付的，不指定字节序，顺序处理数据流可以吗。这时会有字节序问题吗，如果协议栈都使用同一种字节序呢。（我认为字节序和程序使用的字节序有关，如果每个程序都使用同一种字节序，那应该就不存在字节序问题了，比如本程序，收发都用相同的字节序处理，不知道这个结论对不对）\n\n3. 协议头和协议体，分两次写入的，会不会有并发安全问题，为什么？这里应该没做到上节课说的，一次写入一个“业务包”吧。\n\n4. 多次运行 client，错误偶发。有时 io.ReadFull 读不满数据，有时读取的数据长度不对，会是哪些原因导致的呢？","like_count":7},{"had_liked":false,"id":333960,"user_name":"左耳朵东","can_delete":false,"product_type":"c1","uid":1160678,"ip_address":"","ucode":"60134ACF12BB52","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","comment_is_top":false,"comment_ctime":1644639288,"is_pvip":false,"replies":[{"id":122064,"content":"这里的确没必要。但是如果handle ack的goroutine在退出前需要执行一些清理工作，那么done就有必要了。否则可能会出现handle ack的goroutine没有执行完清理工作，send goroutine就退出的进而导致main goroutine退出前某handle ack的goroutine都没有执行完清理工作。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1644763211,"ip_address":"","comment_id":333960,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"client 代码中的 done chan 好像没必要吧，去掉它也能正常退出","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575145,"discussion_content":"问题很棒！\n\n这里逐一回答一下：\n1、2：网络字节序是TCP/IP中规定好的一种数据表示格式,它与具体的CPU类型、操作系统等无关,从而可以保证数据在不同主机之间传输时能够被正确解释。\n3. 按照每个连接一个 Goroutine 的模型，不是并发写，不存在你说的问题。\n4.  go doc io.ReadFull一下，一般情况下，ReadFull都会读出你想要的长度的数据。你遇到错误时，ReadFull返回什么error呢。 \n [upd]： 发现问题了。是client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654610362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352901,"user_name":"枫","can_delete":false,"product_type":"c1","uid":3043622,"ip_address":"陕西","ucode":"2850902F61B46C","user_header":"https://static001.geekbang.org/account/avatar/00/2e/71/26/773e6dcb.jpg","comment_is_top":false,"comment_ctime":1659000395,"is_pvip":false,"replies":[{"id":128374,"content":"如果没有从quit中收到值，是会轮询啊。不过每次轮询的间隔是5s，程序会先在socket上做阻塞读，直到超时。超时后就回到for开始处，这也给了goroutine一个优雅退出的机会。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1659104237,"ip_address":"陕西","comment_id":352901,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"&#47;&#47;\nselect {\n\t\tcase &lt;-quit:\n\t\t\tdone &lt;- struct{}{}\n\t\t\treturn\n\t\tdefault:\n}\n老师，client中读取服务端返回响应的这个goroutine中，这段select的作用不是很理解，如果没有从quit中收到值就会一直轮询，但是从quit中收到值又会return，那下面的代码不是一直都没有机会执行了吗","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581992,"discussion_content":"如果没有从quit中收到值，是会轮询啊。不过每次轮询的间隔是5s，程序会先在socket上做阻塞读，直到超时。超时后就回到for开始处，这也给了goroutine一个优雅退出的机会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659104237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002201,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","nickname":"Mew151","note":"","ucode":"D4793F5874F345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590189,"discussion_content":" select 走到了 default 分支，是会继续往下走的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665576769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345145,"user_name":"晚枫","can_delete":false,"product_type":"c1","uid":1315439,"ip_address":"","ucode":"B0EF439E28BF35","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfYfHAvhZmsKiauxPAt9T2D7ntiaZrP8mial07CAdWiaCEJMawZwficjL3PFvZl35WM7D6ibcYf6miaERJQ/132","comment_is_top":false,"comment_ctime":1652077582,"is_pvip":false,"replies":[{"id":125996,"content":"字节序是针对size&gt;=2个字节的整型数而言的。payload对于该协议来说只是一个“字节序列”。协议的任务就是解析出payload，然后交给上层处理。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652147847,"ip_address":"","comment_id":345145,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"为什么totalLen指定了字节序，payload不需要指定吗？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571229,"discussion_content":"字节序是针对size&gt;=2个字节的整型数而言的。payload对于该协议来说只是一个“字节序列”。协议的任务就是解析出payload，然后交给上层处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652147847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315439,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfYfHAvhZmsKiauxPAt9T2D7ntiaZrP8mial07CAdWiaCEJMawZwficjL3PFvZl35WM7D6ibcYf6miaERJQ/132","nickname":"晚枫","note":"","ucode":"B0EF439E28BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571657,"discussion_content":"多谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652331588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332278,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1643154125,"is_pvip":false,"replies":[{"id":121506,"content":"👍 ","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361508,"ip_address":"","comment_id":332278,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"还是老师实现的代码优雅，我们项目的这块代码是刚开始学 Go 时实现的，只能说可以用。但对比老师的实现，我觉得我们的代码可以好好优化一下了。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548773,"discussion_content":"👍 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643361508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365118,"user_name":"张尘","can_delete":false,"product_type":"c1","uid":1069524,"ip_address":"北京","ucode":"67A404FA68B7DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/d4/ca703443.jpg","comment_is_top":false,"comment_ctime":1672128719,"is_pvip":false,"replies":[{"id":132979,"content":"可以直接使用[]byte类型，这里定义FramePayload更多为了强调其是frame的payload，仅此而已。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1672201500,"ip_address":"北京","comment_id":365118,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"白老师好, 本节课受益颇多, 有点疑问, 还望有时间能够帮忙解答下:\nframeCodec.Decode返回值是自定义数据结构FramePayload\npacket.Decode的入参是[]byte\nclient&#47;server 代码中直接将FramePayload当做[]byte使用\n\nframeCodec.Decode为什么要返回自定义数据结构FramePayload而不是[]byte呢? 是因为FramePayload的结构可能改变吗? FramePayload可能不是[]byte吗? FramePayload可能包含Packet之外的其它数据吗?\n可是如果FramePayload的结构改变, 那client&#47;server 的代码中直接将FramePayload当做[]byte的用法不是就有问题了吗?","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548773,"discussion_content":"👍 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643361508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363139,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"辽宁","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1669282406,"is_pvip":false,"replies":[{"id":132083,"content":"“直接使用 framePayload ” 也没有问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669491424,"ip_address":"辽宁","comment_id":363139,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"有个小疑问：\nfunc (p *myFrameCodec) Encode(w io.Writer, framePayload FramePayload) error { \n  var f = framePayload\n  ...\n}\nvar f = framePayload 这个地方有必要重新定义一个 f 吗，直接使用 framePayload 会有什么问题？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594865,"discussion_content":"“直接使用 framePayload ” 也没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669491424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361290,"user_name":"农民园丁","can_delete":false,"product_type":"c1","uid":1155913,"ip_address":"北京","ucode":"6A91EBBC9DCE6C","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/49/4a488f4c.jpg","comment_is_top":false,"comment_ctime":1667387111,"is_pvip":false,"replies":[{"id":131599,"content":"net.Conn可以理解为io.Reader这个接口类型的方法集合的超集，也就是说所有实现了net.Conn的类型，也都实现了io.Reader接口类型。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1667818103,"ip_address":"北京","comment_id":361290,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请问老师，framePayload, err := frameCodec.Decode(c)\n以上代码中&quot;c&quot;是net.Conn 类型，\n而frameCodec.Decode(io.Reader)的输入参数是io.Reader,\n这两个为什么可以不一样？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594865,"discussion_content":"“直接使用 framePayload ” 也没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669491424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348982,"user_name":"Geek_25f93f","can_delete":false,"product_type":"c1","uid":2917509,"ip_address":"","ucode":"D5932373E8EEA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/5JKZO1Ziax3Ky03noshpVNyEvZw0pUwjLcHrHRo1XNPKXdmCE88homb6ltA15CdVRnjzjgGs3Ex42CaDbeYzNuQ/132","comment_is_top":false,"comment_ctime":1655621871,"is_pvip":false,"replies":[{"id":127025,"content":"你指的是TestEncodeWithWriteFail这个unit test? 这个测试就是为了测试Encode失败的情况。只有err == nil的情况下，才不符合我们的预期。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1655702843,"ip_address":"","comment_id":348982,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，单元测试的代码是不是有点问题，就判断条件是if err == nil","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592952,"discussion_content":"net.Conn可以理解为io.Reader这个接口类型的方法集合的超集，也就是说所有实现了net.Conn的类型，也都实现了io.Reader接口类型。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667818103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348186,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654829552,"is_pvip":false,"replies":[{"id":126864,"content":"return语句最后的nil是代表err=nil，就是一切ok，没有报错。Encode函数的原型，最后一个返回值是一个error类型。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654835054,"ip_address":"","comment_id":348186,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"\n&#47;&#47; tcp-server-demo1&#47;packet&#47;packet.go\n\nfunc Encode(p Packet) ([]byte, error) {\n  var commandID uint8\n  var pktBody []byte\n  var err error\n\n  switch t := p.(type) {\n  case *Submit:\n    commandID = CommandSubmit\n    pktBody, err = p.Encode()\n    if err != nil {\n      return nil, err\n    }\n  case *SubmitAck:\n    commandID = CommandSubmitAck\n    pktBody, err = p.Encode()\n    if err != nil {\n      return nil, err\n    }\n  default:\n    return nil, fmt.Errorf(&quot;unknown type [%s]&quot;, t)\n  }\n  return bytes.Join([][]byte{[]byte{commandID}, pktBody}, nil), nil\n}\n老师，这段代码的最后的 return bytes.Join(), nil这个在什么情况下回运行到呢?不是很理解","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575443,"discussion_content":"return语句最后的nil是代表err=nil，就是一切ok，没有报错。Encode函数的原型，最后一个返回值是一个error类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654835054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1313498,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","nickname":"qiutian","note":"","ucode":"99658A8E342498","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":575459,"discussion_content":"哦，我懂了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654848704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":575443,"ip_address":"","group_id":0},"score":575459,"extra":""}]}]},{"had_liked":false,"id":347911,"user_name":"Aeins","can_delete":false,"product_type":"c1","uid":1045910,"ip_address":"","ucode":"D5BF220767541D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","comment_is_top":false,"comment_ctime":1654575995,"is_pvip":false,"replies":[{"id":126809,"content":"问题很棒！\n\n这里逐一回答一下：\n1、2：网络字节序是TCP&#47;IP中规定好的一种数据表示格式,它与具体的CPU类型、操作系统等无关,从而可以保证数据在不同主机之间传输时能够被正确解释。\n3. 按照每个连接一个 Goroutine 的模型，不是并发写，不存在你说的问题。\n4.  go doc io.ReadFull一下，一般情况下，ReadFull都会读出你想要的长度的数据。你遇到错误时，ReadFull返回什么error呢。 \n [upd]： 发现问题了。是client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1654610362,"ip_address":"","comment_id":347911,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"几点疑问\n\n1. 协议处理程序保证使用相同的字节序的情况下，有必要一定用大端序吗，改成小端序，也能成功。\n\n2. TCP 保证顺序交付的，不指定字节序，顺序处理数据流可以吗。这时会有字节序问题吗，如果协议栈都使用同一种字节序呢。（我认为字节序和程序使用的字节序有关，如果每个程序都使用同一种字节序，那应该就不存在字节序问题了，比如本程序，收发都用相同的字节序处理，不知道这个结论对不对）\n\n3. 协议头和协议体，分两次写入的，会不会有并发安全问题，为什么？这里应该没做到上节课说的，一次写入一个“业务包”吧。\n\n4. 多次运行 client，错误偶发。有时 io.ReadFull 读不满数据，有时读取的数据长度不对，会是哪些原因导致的呢？","like_count":7,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575145,"discussion_content":"问题很棒！\n\n这里逐一回答一下：\n1、2：网络字节序是TCP/IP中规定好的一种数据表示格式,它与具体的CPU类型、操作系统等无关,从而可以保证数据在不同主机之间传输时能够被正确解释。\n3. 按照每个连接一个 Goroutine 的模型，不是并发写，不存在你说的问题。\n4.  go doc io.ReadFull一下，一般情况下，ReadFull都会读出你想要的长度的数据。你遇到错误时，ReadFull返回什么error呢。 \n [upd]： 发现问题了。是client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654610362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333960,"user_name":"左耳朵东","can_delete":false,"product_type":"c1","uid":1160678,"ip_address":"","ucode":"60134ACF12BB52","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","comment_is_top":false,"comment_ctime":1644639288,"is_pvip":false,"replies":[{"id":122064,"content":"这里的确没必要。但是如果handle ack的goroutine在退出前需要执行一些清理工作，那么done就有必要了。否则可能会出现handle ack的goroutine没有执行完清理工作，send goroutine就退出的进而导致main goroutine退出前某handle ack的goroutine都没有执行完清理工作。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1644763211,"ip_address":"","comment_id":333960,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"client 代码中的 done chan 好像没必要吧，去掉它也能正常退出","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550867,"discussion_content":"这里的确没必要。但是如果handle ack的goroutine在退出前需要执行一些清理工作，那么done就有必要了。否则可能会出现handle ack的goroutine没有执行完清理工作，send goroutine就退出的进而导致main goroutine退出前某handle ack的goroutine都没有执行完清理工作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644763212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1160678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","nickname":"左耳朵东","note":"","ucode":"60134ACF12BB52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551271,"discussion_content":"谢谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644971207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550867,"ip_address":"","group_id":0},"score":551271,"extra":""}]}]},{"had_liked":false,"id":352901,"user_name":"枫","can_delete":false,"product_type":"c1","uid":3043622,"ip_address":"陕西","ucode":"2850902F61B46C","user_header":"https://static001.geekbang.org/account/avatar/00/2e/71/26/773e6dcb.jpg","comment_is_top":false,"comment_ctime":1659000395,"is_pvip":false,"replies":[{"id":128374,"content":"如果没有从quit中收到值，是会轮询啊。不过每次轮询的间隔是5s，程序会先在socket上做阻塞读，直到超时。超时后就回到for开始处，这也给了goroutine一个优雅退出的机会。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1659104237,"ip_address":"陕西","comment_id":352901,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"&#47;&#47;\nselect {\n\t\tcase &lt;-quit:\n\t\t\tdone &lt;- struct{}{}\n\t\t\treturn\n\t\tdefault:\n}\n老师，client中读取服务端返回响应的这个goroutine中，这段select的作用不是很理解，如果没有从quit中收到值就会一直轮询，但是从quit中收到值又会return，那下面的代码不是一直都没有机会执行了吗","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550867,"discussion_content":"这里的确没必要。但是如果handle ack的goroutine在退出前需要执行一些清理工作，那么done就有必要了。否则可能会出现handle ack的goroutine没有执行完清理工作，send goroutine就退出的进而导致main goroutine退出前某handle ack的goroutine都没有执行完清理工作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644763212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1160678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","nickname":"左耳朵东","note":"","ucode":"60134ACF12BB52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551271,"discussion_content":"谢谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644971207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550867,"ip_address":"","group_id":0},"score":551271,"extra":""}]}]},{"had_liked":false,"id":345145,"user_name":"晚枫","can_delete":false,"product_type":"c1","uid":1315439,"ip_address":"","ucode":"B0EF439E28BF35","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfYfHAvhZmsKiauxPAt9T2D7ntiaZrP8mial07CAdWiaCEJMawZwficjL3PFvZl35WM7D6ibcYf6miaERJQ/132","comment_is_top":false,"comment_ctime":1652077582,"is_pvip":false,"replies":[{"id":125996,"content":"字节序是针对size&gt;=2个字节的整型数而言的。payload对于该协议来说只是一个“字节序列”。协议的任务就是解析出payload，然后交给上层处理。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652147847,"ip_address":"","comment_id":345145,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"为什么totalLen指定了字节序，payload不需要指定吗？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581992,"discussion_content":"如果没有从quit中收到值，是会轮询啊。不过每次轮询的间隔是5s，程序会先在socket上做阻塞读，直到超时。超时后就回到for开始处，这也给了goroutine一个优雅退出的机会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659104237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002201,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","nickname":"Mew151","note":"","ucode":"D4793F5874F345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590189,"discussion_content":" select 走到了 default 分支，是会继续往下走的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665576769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332278,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1643154125,"is_pvip":false,"replies":[{"id":121506,"content":"👍 ","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361508,"ip_address":"","comment_id":332278,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"还是老师实现的代码优雅，我们项目的这块代码是刚开始学 Go 时实现的，只能说可以用。但对比老师的实现，我觉得我们的代码可以好好优化一下了。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571229,"discussion_content":"字节序是针对size&gt;=2个字节的整型数而言的。payload对于该协议来说只是一个“字节序列”。协议的任务就是解析出payload，然后交给上层处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652147847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315439,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfYfHAvhZmsKiauxPAt9T2D7ntiaZrP8mial07CAdWiaCEJMawZwficjL3PFvZl35WM7D6ibcYf6miaERJQ/132","nickname":"晚枫","note":"","ucode":"B0EF439E28BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571657,"discussion_content":"多谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652331588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365118,"user_name":"张尘","can_delete":false,"product_type":"c1","uid":1069524,"ip_address":"北京","ucode":"67A404FA68B7DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/d4/ca703443.jpg","comment_is_top":false,"comment_ctime":1672128719,"is_pvip":false,"replies":[{"id":132979,"content":"可以直接使用[]byte类型，这里定义FramePayload更多为了强调其是frame的payload，仅此而已。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1672201500,"ip_address":"北京","comment_id":365118,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"白老师好, 本节课受益颇多, 有点疑问, 还望有时间能够帮忙解答下:\nframeCodec.Decode返回值是自定义数据结构FramePayload\npacket.Decode的入参是[]byte\nclient&#47;server 代码中直接将FramePayload当做[]byte使用\n\nframeCodec.Decode为什么要返回自定义数据结构FramePayload而不是[]byte呢? 是因为FramePayload的结构可能改变吗? FramePayload可能不是[]byte吗? FramePayload可能包含Packet之外的其它数据吗?\n可是如果FramePayload的结构改变, 那client&#47;server 的代码中直接将FramePayload当做[]byte的用法不是就有问题了吗?","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597742,"discussion_content":"可以直接使用[]byte类型，这里定义FramePayload更多为了强调其是frame的payload，仅此而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672201500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363139,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"辽宁","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1669282406,"is_pvip":false,"replies":[{"id":132083,"content":"“直接使用 framePayload ” 也没有问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669491424,"ip_address":"辽宁","comment_id":363139,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"有个小疑问：\nfunc (p *myFrameCodec) Encode(w io.Writer, framePayload FramePayload) error { \n  var f = framePayload\n  ...\n}\nvar f = framePayload 这个地方有必要重新定义一个 f 吗，直接使用 framePayload 会有什么问题？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597742,"discussion_content":"可以直接使用[]byte类型，这里定义FramePayload更多为了强调其是frame的payload，仅此而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672201500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361290,"user_name":"农民园丁","can_delete":false,"product_type":"c1","uid":1155913,"ip_address":"北京","ucode":"6A91EBBC9DCE6C","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/49/4a488f4c.jpg","comment_is_top":false,"comment_ctime":1667387111,"is_pvip":false,"replies":[{"id":131599,"content":"net.Conn可以理解为io.Reader这个接口类型的方法集合的超集，也就是说所有实现了net.Conn的类型，也都实现了io.Reader接口类型。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1667818103,"ip_address":"北京","comment_id":361290,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请问老师，framePayload, err := frameCodec.Decode(c)\n以上代码中&quot;c&quot;是net.Conn 类型，\n而frameCodec.Decode(io.Reader)的输入参数是io.Reader,\n这两个为什么可以不一样？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592952,"discussion_content":"net.Conn可以理解为io.Reader这个接口类型的方法集合的超集，也就是说所有实现了net.Conn的类型，也都实现了io.Reader接口类型。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667818103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348982,"user_name":"Geek_25f93f","can_delete":false,"product_type":"c1","uid":2917509,"ip_address":"","ucode":"D5932373E8EEA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/5JKZO1Ziax3Ky03noshpVNyEvZw0pUwjLcHrHRo1XNPKXdmCE88homb6ltA15CdVRnjzjgGs3Ex42CaDbeYzNuQ/132","comment_is_top":false,"comment_ctime":1655621871,"is_pvip":false,"replies":[{"id":127025,"content":"你指的是TestEncodeWithWriteFail这个unit test? 这个测试就是为了测试Encode失败的情况。只有err == nil的情况下，才不符合我们的预期。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1655702843,"ip_address":"","comment_id":348982,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，单元测试的代码是不是有点问题，就判断条件是if err == nil","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576610,"discussion_content":"你指的是TestEncodeWithWriteFail这个unit test? 这个测试就是为了测试Encode失败的情况。只有err == nil的情况下，才不符合我们的预期。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655702843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348186,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654829552,"is_pvip":false,"replies":[{"id":126864,"content":"return语句最后的nil是代表err=nil，就是一切ok，没有报错。Encode函数的原型，最后一个返回值是一个error类型。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654835054,"ip_address":"","comment_id":348186,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"\n&#47;&#47; tcp-server-demo1&#47;packet&#47;packet.go\n\nfunc Encode(p Packet) ([]byte, error) {\n  var commandID uint8\n  var pktBody []byte\n  var err error\n\n  switch t := p.(type) {\n  case *Submit:\n    commandID = CommandSubmit\n    pktBody, err = p.Encode()\n    if err != nil {\n      return nil, err\n    }\n  case *SubmitAck:\n    commandID = CommandSubmitAck\n    pktBody, err = p.Encode()\n    if err != nil {\n      return nil, err\n    }\n  default:\n    return nil, fmt.Errorf(&quot;unknown type [%s]&quot;, t)\n  }\n  return bytes.Join([][]byte{[]byte{commandID}, pktBody}, nil), nil\n}\n老师，这段代码的最后的 return bytes.Join(), nil这个在什么情况下回运行到呢?不是很理解","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576610,"discussion_content":"你指的是TestEncodeWithWriteFail这个unit test? 这个测试就是为了测试Encode失败的情况。只有err == nil的情况下，才不符合我们的预期。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655702843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332390,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1643196727,"is_pvip":false,"replies":[{"id":121503,"content":"对的，conn流程一般有一个身份验证的过程。考虑到篇幅，文中没有加conn和connack，如果加上，篇幅就要超出许多。想想思路就好，如果要实现，可以自定义一个conn消息体，然后练练手。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361321,"ip_address":"","comment_id":332390,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，Conn 和 ConnAck 要实现的话，请问从业务中来讲，一般会需要发送一些什么 Payload 呢？我看这里的例子没有他们也可以正常运行整个流程，是类似 需要认证的系统中的登录账号和密码 的这种内容吗？","like_count":1},{"had_liked":false,"id":332290,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1643161595,"is_pvip":false,"replies":[{"id":121616,"content":"我觉得更多是对通信两端交互模式的抽象。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643543012,"ip_address":"","comment_id":332290,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，一些rpc框架学习 http2 的stream概念，在connection与协议之间加了一个stream层， 这块主要抽象了啥，很想听一下老师的看法。 ","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548770,"discussion_content":"对的，conn流程一般有一个身份验证的过程。考虑到篇幅，文中没有加conn和connack，如果加上，篇幅就要超出许多。想想思路就好，如果要实现，可以自定义一个conn消息体，然后练练手。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643361321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383797,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699666136,"is_pvip":false,"replies":[{"id":139984,"content":"1. 网络字节序默认大端。但没有“本地磁盘”这种说法，只有本地字节序(或主机字节序)这种说法，只与cpu采用的字节序有关。x86 cpu都是小端，以前的sun sparc处理器是大端。arm默认小端，但也支持大端。\n2. 目前没有官方命名规范来区分该类型具体是变量，还是结构体接口类型。如有需求，这个可以公司&#47;组织内部自己定义。很难标准化。\n3. 建议回看一下讲常量和iota那一讲。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699826920,"ip_address":"辽宁","comment_id":383797,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师这节课学完了，主要还是有一下几点困惑，烦请解答\n1.关于大端小端小问题\n网络字节是不是都是大端\n而本地的的比如磁盘这种 默认的是小端\n\n2. 关于命名规范\ngo语言通过大小写区分public和internel权限\n那么这里我怎么通过命名去区分该类型具体是变量，还是结构体接口类型呢\n有什么具体规范没有，因为之前接触的语言都是通过大小写区分变量和结构体固有次一问\n我看代码里很多参数 都是以短字符命名，我接触到语言命名都是尽可能长，以做到望文知义，\n以短字符命名这个符合go的编码规范吗\n\n3. const 类型推断\n\nconst (\n\tCommonConn  = iota + 0x01\n\tCommonSumbit\n)\n\nconst (\n\tCommonConnAck  = iota + 0x81\n\tCommonSumbitAck\n)\n\n编译器是如何识别它的具体类型的，因为这个字段最终会被encode所以有次一问 万一编译器识别成int型那编码就是失败了\n我把它简单重构了一下\n\nconst (\n\tCommonConn uint8 = iota + 0x01\n\tCommonSumbit\n)\n\nconst (\n\tCommonConnAck uint8 = iota + 0x81\n\tCommonSumbitAck\n)","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631607,"discussion_content":"1. 网络字节序默认大端。但没有“本地磁盘”这种说法，只有本地字节序(或主机字节序)这种说法，只与cpu采用的字节序有关。x86 cpu都是小端，以前的sun sparc处理器是大端。arm默认小端，但也支持大端。\n2. 目前没有官方命名规范来区分该类型具体是变量，还是结构体接口类型。如有需求，这个可以公司/组织内部自己定义。很难标准化。\n3. 建议回看一下讲常量和iota那一讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699826920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373305,"user_name":"Geek_1cc6d1","can_delete":false,"product_type":"c1","uid":1850248,"ip_address":"北京","ucode":"3E083616DD0742","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZCyXaP2gbxwFHxvtnyaaF2Pyy5KkSMsk9kh7SJl8icp1CD6wicb6VJibiblGibbpDo6IuHrdST6AnWQg/132","comment_is_top":false,"comment_ctime":1682383282,"is_pvip":false,"replies":[{"id":136357,"content":"每个包单元的总长是totallength，而totallength字段本身长度是固定的，这样就可以算出包单元的剩余大小。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1682400548,"ip_address":"北京","comment_id":373305,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"怎么根据totalLength拆包的？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631607,"discussion_content":"1. 网络字节序默认大端。但没有“本地磁盘”这种说法，只有本地字节序(或主机字节序)这种说法，只与cpu采用的字节序有关。x86 cpu都是小端，以前的sun sparc处理器是大端。arm默认小端，但也支持大端。\n2. 目前没有官方命名规范来区分该类型具体是变量，还是结构体接口类型。如有需求，这个可以公司/组织内部自己定义。很难标准化。\n3. 建议回看一下讲常量和iota那一讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699826920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370019,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"广东","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1678265090,"is_pvip":false,"replies":[{"id":134927,"content":"睡觉这种，哪种设计更合理，还是要看需求上下文吧，这里仅仅是一个demo。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678432569,"ip_address":"北京","comment_id":370019,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"frame encode 的方法将数据编码与发送耦合在一起，在外界调用的时候无法直观的感受到消息发送，建议可以做下合理拆分，对体验消息发送与接收更容易理解","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615696,"discussion_content":"每个包单元的总长是totallength，而totallength字段本身长度是固定的，这样就可以算出包单元的剩余大小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682400548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366726,"user_name":"zhu见见","can_delete":false,"product_type":"c1","uid":1141494,"ip_address":"重庆","ucode":"22F745AA60503D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erwcUXd1YciaE2VmCRZUjbm0hscIAwvXJOQtibK2aor2DrmxxPszsfecZ11dibniakRSkMYrhp8ibsHWoA/132","comment_is_top":false,"comment_ctime":1674117640,"is_pvip":false,"replies":[{"id":133608,"content":"看一下本讲的评论区的类似的问题的答复吧。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1674123480,"ip_address":"北京","comment_id":366726,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"done 这个chan的意义是啥呢？为了让startClient 晚于内部的go func 执行完吗？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608411,"discussion_content":"睡觉这种，哪种设计更合理，还是要看需求上下文吧，这里仅仅是一个demo。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678432569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358186,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":1070670,"ip_address":"辽宁","ucode":"ED9970F7E66080","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/4e/9291fac0.jpg","comment_is_top":false,"comment_ctime":1664011373,"is_pvip":false,"replies":[{"id":130368,"content":"这块的f可以不用，直接用framePayload应该没有问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1664113750,"ip_address":"辽宁","comment_id":358186,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"func (p *myFrameCodec) Encode(w io.Writer, framePayload FramePayload) error { \nvar f = framePayload \nvar totalLen int32 = int32(len(framePayload)) + 4 \n...\n}\n以上方法的第二行处有个疑问：\n\n为什么要额外创建一个方法参数 framePayload 的拷贝 f 呢？直接使用 framePayload 传入 w.Write() 方法会有什么问题吗？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600230,"discussion_content":"看一下本讲的评论区的类似的问题的答复吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674123481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350125,"user_name":"中年编程人员","can_delete":false,"product_type":"c1","uid":1979090,"ip_address":"","ucode":"8692C6FA9B0ED3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/x3gOkI2Dl1Gb3WRic44roicJMILgHfdFRic8nfR7oh0asf0KONEj7U2or6YHMmCcyibskvVE5Pjypz2ALGwBXRyMPA/132","comment_is_top":false,"comment_ctime":1656583591,"is_pvip":false,"replies":[{"id":127394,"content":"加上totalLen自身的长度啊：用4个字节表示totalLen。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1656598819,"ip_address":"","comment_id":350125,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师你好，frame中，var totalLen int32 = int32(len(framePayload)) + 4；这个totalLen为啥要加4呢？？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588793,"discussion_content":"这块的f可以不用，直接用framePayload应该没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664113750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347968,"user_name":"南方虚心竹","can_delete":false,"product_type":"c1","uid":1598063,"ip_address":"","ucode":"1816A2C9BA82B3","user_header":"https://static001.geekbang.org/account/avatar/00/18/62/6f/8fb1a57b.jpg","comment_is_top":false,"comment_ctime":1654614627,"is_pvip":false,"replies":[{"id":126858,"content":"的确是问题。但不是这里的问题。是demo中client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654828176,"ip_address":"","comment_id":347968,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"frame.go:  \n\nfunc (p *myFrameCodec) Decode(r io.Reader) (FramePayload, error) {\n    ...\n    buf := make([]byte, totalLen-4)   &#47;&#47; 这行在运行的时候在跑的时候会panic \n   ...\n}\n&#47;&#47; panic: runtime error: makeslice: len out of range\n打印出来是一个很大的负数\n\n大概率会panic，小概率会pass，感觉是多线程下出现的问题\n\n求老师解答一下\n","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578246,"discussion_content":"加上totalLen自身的长度啊：用4个字节表示totalLen。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656598819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347966,"user_name":"南方虚心竹","can_delete":false,"product_type":"c1","uid":1598063,"ip_address":"","ucode":"1816A2C9BA82B3","user_header":"https://static001.geekbang.org/account/avatar/00/18/62/6f/8fb1a57b.jpg","comment_is_top":false,"comment_ctime":1654613509,"is_pvip":false,"replies":[{"id":126852,"content":"pktBody[:8] 和 pktBody[0:8] 是等价的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654762919,"ip_address":"","comment_id":347966,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"packet.go 中 Submit 映射的Decode方法 \n第二行中使用 s.ID = string(pktBody[:8])  写法在运行client的时候和会出现 \npanic: runtime error: makeslice: len out of range\n修改为老师git当中的s.ID = string(pktBody[0:8]) 后可以正常运行。（我的环境是MacOS12-intelCPU）\n\n想请教下老师这里的 pktBody[:8] 和 pktBody[0:8] 不是等价的吗？\n\n&#47;&#47; 附上文章中的代码\nfunc (s *Submit) Decode(pktBody []byte) error { \n    s.ID = string(pktBody[:8]) \n    s.Payload = pktBody[8:] \n    return nil\n}","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575427,"discussion_content":"的确是问题。但不是这里的问题。是demo中client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654828176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332390,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1643196727,"is_pvip":false,"replies":[{"id":121503,"content":"对的，conn流程一般有一个身份验证的过程。考虑到篇幅，文中没有加conn和connack，如果加上，篇幅就要超出许多。想想思路就好，如果要实现，可以自定义一个conn消息体，然后练练手。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361321,"ip_address":"","comment_id":332390,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，Conn 和 ConnAck 要实现的话，请问从业务中来讲，一般会需要发送一些什么 Payload 呢？我看这里的例子没有他们也可以正常运行整个流程，是类似 需要认证的系统中的登录账号和密码 的这种内容吗？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548770,"discussion_content":"对的，conn流程一般有一个身份验证的过程。考虑到篇幅，文中没有加conn和connack，如果加上，篇幅就要超出许多。想想思路就好，如果要实现，可以自定义一个conn消息体，然后练练手。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643361321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332290,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1643161595,"is_pvip":false,"replies":[{"id":121616,"content":"我觉得更多是对通信两端交互模式的抽象。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643543012,"ip_address":"","comment_id":332290,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，一些rpc框架学习 http2 的stream概念，在connection与协议之间加了一个stream层， 这块主要抽象了啥，很想听一下老师的看法。 ","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549077,"discussion_content":"我觉得更多是对通信两端交互模式的抽象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643543013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548666,"discussion_content":"猜测是下游的多个请求可以共用一个到上游的连接，以节省重复建立连接的开销和减少到上游的连接数量。好奇在go里有什么优雅的实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643300147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383797,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699666136,"is_pvip":false,"replies":[{"id":139984,"content":"1. 网络字节序默认大端。但没有“本地磁盘”这种说法，只有本地字节序(或主机字节序)这种说法，只与cpu采用的字节序有关。x86 cpu都是小端，以前的sun sparc处理器是大端。arm默认小端，但也支持大端。\n2. 目前没有官方命名规范来区分该类型具体是变量，还是结构体接口类型。如有需求，这个可以公司&#47;组织内部自己定义。很难标准化。\n3. 建议回看一下讲常量和iota那一讲。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699826920,"ip_address":"辽宁","comment_id":383797,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师这节课学完了，主要还是有一下几点困惑，烦请解答\n1.关于大端小端小问题\n网络字节是不是都是大端\n而本地的的比如磁盘这种 默认的是小端\n\n2. 关于命名规范\ngo语言通过大小写区分public和internel权限\n那么这里我怎么通过命名去区分该类型具体是变量，还是结构体接口类型呢\n有什么具体规范没有，因为之前接触的语言都是通过大小写区分变量和结构体固有次一问\n我看代码里很多参数 都是以短字符命名，我接触到语言命名都是尽可能长，以做到望文知义，\n以短字符命名这个符合go的编码规范吗\n\n3. const 类型推断\n\nconst (\n\tCommonConn  = iota + 0x01\n\tCommonSumbit\n)\n\nconst (\n\tCommonConnAck  = iota + 0x81\n\tCommonSumbitAck\n)\n\n编译器是如何识别它的具体类型的，因为这个字段最终会被encode所以有次一问 万一编译器识别成int型那编码就是失败了\n我把它简单重构了一下\n\nconst (\n\tCommonConn uint8 = iota + 0x01\n\tCommonSumbit\n)\n\nconst (\n\tCommonConnAck uint8 = iota + 0x81\n\tCommonSumbitAck\n)","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549077,"discussion_content":"我觉得更多是对通信两端交互模式的抽象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643543013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548666,"discussion_content":"猜测是下游的多个请求可以共用一个到上游的连接，以节省重复建立连接的开销和减少到上游的连接数量。好奇在go里有什么优雅的实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643300147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373305,"user_name":"Geek_1cc6d1","can_delete":false,"product_type":"c1","uid":1850248,"ip_address":"北京","ucode":"3E083616DD0742","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZCyXaP2gbxwFHxvtnyaaF2Pyy5KkSMsk9kh7SJl8icp1CD6wicb6VJibiblGibbpDo6IuHrdST6AnWQg/132","comment_is_top":false,"comment_ctime":1682383282,"is_pvip":false,"replies":[{"id":136357,"content":"每个包单元的总长是totallength，而totallength字段本身长度是固定的，这样就可以算出包单元的剩余大小。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1682400548,"ip_address":"北京","comment_id":373305,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"怎么根据totalLength拆包的？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615696,"discussion_content":"每个包单元的总长是totallength，而totallength字段本身长度是固定的，这样就可以算出包单元的剩余大小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682400548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370019,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"广东","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1678265090,"is_pvip":false,"replies":[{"id":134927,"content":"睡觉这种，哪种设计更合理，还是要看需求上下文吧，这里仅仅是一个demo。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678432569,"ip_address":"北京","comment_id":370019,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"frame encode 的方法将数据编码与发送耦合在一起，在外界调用的时候无法直观的感受到消息发送，建议可以做下合理拆分，对体验消息发送与接收更容易理解","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608411,"discussion_content":"睡觉这种，哪种设计更合理，还是要看需求上下文吧，这里仅仅是一个demo。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678432569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366726,"user_name":"zhu见见","can_delete":false,"product_type":"c1","uid":1141494,"ip_address":"重庆","ucode":"22F745AA60503D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erwcUXd1YciaE2VmCRZUjbm0hscIAwvXJOQtibK2aor2DrmxxPszsfecZ11dibniakRSkMYrhp8ibsHWoA/132","comment_is_top":false,"comment_ctime":1674117640,"is_pvip":false,"replies":[{"id":133608,"content":"看一下本讲的评论区的类似的问题的答复吧。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1674123480,"ip_address":"北京","comment_id":366726,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"done 这个chan的意义是啥呢？为了让startClient 晚于内部的go func 执行完吗？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600230,"discussion_content":"看一下本讲的评论区的类似的问题的答复吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674123481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358186,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":1070670,"ip_address":"辽宁","ucode":"ED9970F7E66080","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/4e/9291fac0.jpg","comment_is_top":false,"comment_ctime":1664011373,"is_pvip":false,"replies":[{"id":130368,"content":"这块的f可以不用，直接用framePayload应该没有问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1664113750,"ip_address":"辽宁","comment_id":358186,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"func (p *myFrameCodec) Encode(w io.Writer, framePayload FramePayload) error { \nvar f = framePayload \nvar totalLen int32 = int32(len(framePayload)) + 4 \n...\n}\n以上方法的第二行处有个疑问：\n\n为什么要额外创建一个方法参数 framePayload 的拷贝 f 呢？直接使用 framePayload 传入 w.Write() 方法会有什么问题吗？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588793,"discussion_content":"这块的f可以不用，直接用framePayload应该没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664113750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350125,"user_name":"中年编程人员","can_delete":false,"product_type":"c1","uid":1979090,"ip_address":"","ucode":"8692C6FA9B0ED3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/x3gOkI2Dl1Gb3WRic44roicJMILgHfdFRic8nfR7oh0asf0KONEj7U2or6YHMmCcyibskvVE5Pjypz2ALGwBXRyMPA/132","comment_is_top":false,"comment_ctime":1656583591,"is_pvip":false,"replies":[{"id":127394,"content":"加上totalLen自身的长度啊：用4个字节表示totalLen。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1656598819,"ip_address":"","comment_id":350125,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师你好，frame中，var totalLen int32 = int32(len(framePayload)) + 4；这个totalLen为啥要加4呢？？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578246,"discussion_content":"加上totalLen自身的长度啊：用4个字节表示totalLen。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656598819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347968,"user_name":"南方虚心竹","can_delete":false,"product_type":"c1","uid":1598063,"ip_address":"","ucode":"1816A2C9BA82B3","user_header":"https://static001.geekbang.org/account/avatar/00/18/62/6f/8fb1a57b.jpg","comment_is_top":false,"comment_ctime":1654614627,"is_pvip":false,"replies":[{"id":126858,"content":"的确是问题。但不是这里的问题。是demo中client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654828176,"ip_address":"","comment_id":347968,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"frame.go:  \n\nfunc (p *myFrameCodec) Decode(r io.Reader) (FramePayload, error) {\n    ...\n    buf := make([]byte, totalLen-4)   &#47;&#47; 这行在运行的时候在跑的时候会panic \n   ...\n}\n&#47;&#47; panic: runtime error: makeslice: len out of range\n打印出来是一个很大的负数\n\n大概率会panic，小概率会pass，感觉是多线程下出现的问题\n\n求老师解答一下\n","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575427,"discussion_content":"的确是问题。但不是这里的问题。是demo中client的SetReadDeadline设置为1s，太短了。已改，请pull最新demo代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654828176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347966,"user_name":"南方虚心竹","can_delete":false,"product_type":"c1","uid":1598063,"ip_address":"","ucode":"1816A2C9BA82B3","user_header":"https://static001.geekbang.org/account/avatar/00/18/62/6f/8fb1a57b.jpg","comment_is_top":false,"comment_ctime":1654613509,"is_pvip":false,"replies":[{"id":126852,"content":"pktBody[:8] 和 pktBody[0:8] 是等价的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654762919,"ip_address":"","comment_id":347966,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"packet.go 中 Submit 映射的Decode方法 \n第二行中使用 s.ID = string(pktBody[:8])  写法在运行client的时候和会出现 \npanic: runtime error: makeslice: len out of range\n修改为老师git当中的s.ID = string(pktBody[0:8]) 后可以正常运行。（我的环境是MacOS12-intelCPU）\n\n想请教下老师这里的 pktBody[:8] 和 pktBody[0:8] 不是等价的吗？\n\n&#47;&#47; 附上文章中的代码\nfunc (s *Submit) Decode(pktBody []byte) error { \n    s.ID = string(pktBody[:8]) \n    s.Payload = pktBody[8:] \n    return nil\n}","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575347,"discussion_content":"pktBody[:8] 和 pktBody[0:8] 是等价的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654762919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343688,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1650982958,"is_pvip":false,"replies":[{"id":125492,"content":"0x0、0x9都是以16进制数表示的byte值啊。byte本质上就是uint8(type byte = uint8)，一个整型数而已。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1651049096,"ip_address":"","comment_id":343688,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"请问 data := []byte{0x0, 0x0, 0x0, 0x9, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;} 中的0x0, 0x0, 0x0, 0x9代表的是什么意思","like_count":0},{"had_liked":false,"id":337042,"user_name":"酒醒何处","can_delete":false,"product_type":"c1","uid":2839701,"ip_address":"","ucode":"2F890DD0BEB0F0","user_header":"","comment_is_top":false,"comment_ctime":1646563726,"is_pvip":false,"replies":[{"id":123240,"content":"看的真细致！👍 感谢指出笔误，后续让编辑老师改一下。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646722894,"ip_address":"","comment_id":337042,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"CommandConnAck = iota + 0x80 &#47;&#47; 0x81，连接请求的响应包\n这儿应该是：\nCommandConnAck = iota + 0x81 &#47;&#47; 0x81，连接请求的响应包","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568037,"discussion_content":"0x0、0x9都是以16进制数表示的byte值啊。byte本质上就是uint8(type byte = uint8)，一个整型数而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651049096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2839499,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/qCv5IcP1lkO2jicrTic9KicycZXZ7WylG49GZHJCibuFQfBlJMsCpVHARuaLxIB23f3enRL4ls6EOr9wxu40K0Hl8Q/132","nickname":"tcyi","note":"","ucode":"043F49F99D7037","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625794,"discussion_content":"我也有这个疑问，调用codec.Encode(rw, []byte(&#34;hello&#34;))，我输出fmt.Println(rw.Bytes()) 打印的是 [0 0 0 9 104 101 108 108 111]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692192767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568390,"discussion_content":"啊，我的意思是这里为啥要占四个值，是因为需要加上totalLength自身的4个字节吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651124824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336552,"user_name":"顷","can_delete":false,"product_type":"c1","uid":1132878,"ip_address":"","ucode":"096B6859C1FA80","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/4e/8798cd01.jpg","comment_is_top":false,"comment_ctime":1646210283,"is_pvip":true,"replies":[{"id":123105,"content":"Makefile在本专栏中不会展开说了。一方面，Makefile与Go并非紧耦合，也并非必须，只是构建辅助工具的一种。另一方面，本专栏中使用的Makefile的内容都是最简单的，一般只有一个target，容易理解，不需要展开大家应该都能理解。\n\n学习过程中，有有关makefile的问题，可以在留言区提出，我尽力解答。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1646469688,"ip_address":"","comment_id":336552,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，Makefile的相关知识考虑在加餐要说下吗","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555022,"discussion_content":"看的真细致！👍 感谢指出笔误，后续让编辑老师改一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646722894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332417,"user_name":"陈东","can_delete":false,"product_type":"c1","uid":2213995,"ip_address":"","ucode":"FCDE6D237CC621","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ge7uhlEVxicQT73YuomDPrVKI8UmhqxKWrhtO5GMNlFjrHWfd3HAjgaSribR4Pzorw8yalYGYqJI4VPvUyPzicSKg/132","comment_is_top":false,"comment_ctime":1643242454,"is_pvip":true,"replies":[{"id":121504,"content":"这个需要后续和编辑老师商量一下。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361383,"ip_address":"","comment_id":332417,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师能加餐一节单元测试吗？查很多资料，没有学到测试的入门。谢谢。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554567,"discussion_content":"Makefile在本专栏中不会展开说了。一方面，Makefile与Go并非紧耦合，也并非必须，只是构建辅助工具的一种。另一方面，本专栏中使用的Makefile的内容都是最简单的，一般只有一个target，容易理解，不需要展开大家应该都能理解。\n\n学习过程中，有有关makefile的问题，可以在留言区提出，我尽力解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646469688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343688,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1650982958,"is_pvip":false,"replies":[{"id":125492,"content":"0x0、0x9都是以16进制数表示的byte值啊。byte本质上就是uint8(type byte = uint8)，一个整型数而已。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1651049096,"ip_address":"","comment_id":343688,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"请问 data := []byte{0x0, 0x0, 0x0, 0x9, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;} 中的0x0, 0x0, 0x0, 0x9代表的是什么意思","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568037,"discussion_content":"0x0、0x9都是以16进制数表示的byte值啊。byte本质上就是uint8(type byte = uint8)，一个整型数而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651049096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2839499,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/qCv5IcP1lkO2jicrTic9KicycZXZ7WylG49GZHJCibuFQfBlJMsCpVHARuaLxIB23f3enRL4ls6EOr9wxu40K0Hl8Q/132","nickname":"tcyi","note":"","ucode":"043F49F99D7037","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625794,"discussion_content":"我也有这个疑问，调用codec.Encode(rw, []byte(&#34;hello&#34;))，我输出fmt.Println(rw.Bytes()) 打印的是 [0 0 0 9 104 101 108 108 111]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692192767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568390,"discussion_content":"啊，我的意思是这里为啥要占四个值，是因为需要加上totalLength自身的4个字节吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651124824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337042,"user_name":"酒醒何处","can_delete":false,"product_type":"c1","uid":2839701,"ip_address":"","ucode":"2F890DD0BEB0F0","user_header":"","comment_is_top":false,"comment_ctime":1646563726,"is_pvip":false,"replies":[{"id":123240,"content":"看的真细致！👍 感谢指出笔误，后续让编辑老师改一下。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646722894,"ip_address":"","comment_id":337042,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"CommandConnAck = iota + 0x80 &#47;&#47; 0x81，连接请求的响应包\n这儿应该是：\nCommandConnAck = iota + 0x81 &#47;&#47; 0x81，连接请求的响应包","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555022,"discussion_content":"看的真细致！👍 感谢指出笔误，后续让编辑老师改一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646722894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336552,"user_name":"顷","can_delete":false,"product_type":"c1","uid":1132878,"ip_address":"","ucode":"096B6859C1FA80","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/4e/8798cd01.jpg","comment_is_top":false,"comment_ctime":1646210283,"is_pvip":true,"replies":[{"id":123105,"content":"Makefile在本专栏中不会展开说了。一方面，Makefile与Go并非紧耦合，也并非必须，只是构建辅助工具的一种。另一方面，本专栏中使用的Makefile的内容都是最简单的，一般只有一个target，容易理解，不需要展开大家应该都能理解。\n\n学习过程中，有有关makefile的问题，可以在留言区提出，我尽力解答。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1646469688,"ip_address":"","comment_id":336552,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师，Makefile的相关知识考虑在加餐要说下吗","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554567,"discussion_content":"Makefile在本专栏中不会展开说了。一方面，Makefile与Go并非紧耦合，也并非必须，只是构建辅助工具的一种。另一方面，本专栏中使用的Makefile的内容都是最简单的，一般只有一个target，容易理解，不需要展开大家应该都能理解。\n\n学习过程中，有有关makefile的问题，可以在留言区提出，我尽力解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646469688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332417,"user_name":"陈东","can_delete":false,"product_type":"c1","uid":2213995,"ip_address":"","ucode":"FCDE6D237CC621","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ge7uhlEVxicQT73YuomDPrVKI8UmhqxKWrhtO5GMNlFjrHWfd3HAjgaSribR4Pzorw8yalYGYqJI4VPvUyPzicSKg/132","comment_is_top":false,"comment_ctime":1643242454,"is_pvip":true,"replies":[{"id":121504,"content":"这个需要后续和编辑老师商量一下。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361383,"ip_address":"","comment_id":332417,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师能加餐一节单元测试吗？查很多资料，没有学到测试的入门。谢谢。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548771,"discussion_content":"这个需要后续和编辑老师商量一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643361384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550925,"discussion_content":"关于单元测试的入门推荐学习郑晔老师在极客时间的3个专栏（学习如何写对测试友好的代码）\n1. 软件设计之美\n2. 代码之丑\n3. 程序员的测试课\n专栏中老师推荐了非常好的书籍：\n《代码整洁之道》\n《修改代码的艺术》\n学习 TDD 时还可以参考这两本书\n《Java 测试驱动开发》\n《测试驱动开发的艺术》\n\n提示：注意区分单元测试与集成测试\n存在以下任何一个情形都不是单元测试：（见《修改代码的艺术》）\n\n访问了数据库\n有网络通信\n访问了文件系统\n不与其他任何单元测试同时运行\n必须配置好环境后才能运行\n\n——《测试驱动开发的艺术》","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1644814118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}