{"id":652748,"title":"20｜AutoProxyCreator：如何自动添加动态代理？","content":"<p>你好，我是郭屹，今天我们继续手写MiniSpring，这也是AOP正文部分的最后一节。今天我们将完成一个有模有样的AOP解决方案。</p><h2>问题的引出</h2><p>前面，我们已经实现了通过动态代理技术在运行时进行逻辑增强，并引入了Pointcut，实现了代理方法的通配形式。到现在，AOP的功能貌似已经基本实现了，但目前还有一个较大的问题，具体是什么问题呢？我们查看aplicationContext.xml里的这段配置文件来一探究竟。</p><pre><code class=\"language-xml\">&lt;bean id=\"realaction\" class=\"com.test.service.Action1\" /&gt;\n&lt;bean id=\"action\" class=\"com.minis.aop.ProxyFactoryBean\"&gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"interceptorName\" value=\"advisor\" /&gt;\n&nbsp; &nbsp; &lt;property type=\"java.lang.Object\" name=\"target\" ref=\"realaction\"/&gt;\t\n&lt;/bean&gt;\n</code></pre><p>看这个配置文件可以发现，在ProxyFactoryBean的配置中，有个Object类型的属性：target。在这里我们的赋值ref是realactionbean，对应Action1这个类。也就是说，给Action1这个Bean动态地插入逻辑，达成AOP的目标。<br>\n在这里，一次AOP的配置对应一个目标对象，如果整个系统就只需要为一个对象进行增强操作，这自然没有问题，配置一下倒也不会很麻烦，但在一个稍微有规模的系统中，我们有成百上千的目标对象，在这种情况下一个个地去配置则无异于一场灾难。</p><!-- [[[read_end]]] --><p>一个实用的AOP解决方案，应该可以<strong>用一个简单的匹配规则代理多个目标对象</strong>。这是我们这节课需要解决的问题。</p><h2>匹配多个目标对象的思路</h2><p>在上节课，我们其实处理过类似的问题，就是当时我们的目标方法只能是一个固定的方法名doAction()，我们就提出了Pointcut这个概念，用一个模式来通配方法名，如 <code>do*</code>、<code>do*Action</code> 之类的字符串模式。</p><p>Pointcut这个概念解决了一个目标对象内部多个方法的匹配问题。这个办法也能给我们灵感，我们就借鉴这个思路，用类似的手段来解决匹配多个目标对象的问题。</p><p>因此，我们想象中当解决方案实现之后，应该是这么配置的。</p><pre><code class=\"language-plain\">&lt;bean id=\"genaralProxy\" class=\"GeneralProxy\" &gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"pattern\" value=\"action*\" /&gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"interceptorName\" value=\"advisor\" /&gt;\n&lt;/bean&gt;\n</code></pre><p>上面的配置里有一个通用的ProxyBean，它用一个模式串pattern来匹配目标对象，作为例子这里就是 <code>action*</code>，表示所有名字以action开头的对象都是目标对象。</p><p>这个想法好像成立，但是我们知道，IoC容器内部所有的Bean是相互独立且平等的，这个GeneralProxy也就是一个普通的Bean。那么作为一个普通的Bean，它怎么能影响到别的Bean呢？它如何能做到给别的Bean动态创建代理呢？这个办法有这样一个关键的难点。</p><p>我们反过来思考，如果能找个办法让这个General Proxy影响到别的Bean，再根据规则决定给这些Bean加上动态代理（这一点我们之前就实现过了），是不是就可以了？</p><p>那么在哪个时序点能做这个事情呢？我们再回顾一下Bean的创建过程：第一步，IoC容器扫描配置文件，加载Bean的定义。第二步，通过getBean()这个方法创建Bean实例，这一步又分成几个子步骤：</p><ol>\n<li>创建Bean的毛坯实例；</li>\n<li>填充Properties；</li>\n<li>执行postProcessBeforeInitialization；</li>\n<li>调用init-method方法；</li>\n<li>执行postProcessAfterInitialization。</li>\n</ol><p>后三个子步骤，实际上都是在每一个Bean实例创建好之后可以进行的后期处理。那么我们就可以利用这个时序，把自动生成代理这件事情交给后期处理来完成。在我们的IoC容器里，有一个现成的机制，叫<strong>BeanPostProcessor</strong>，它能在每一个Bean创建的时候进行后期修饰，也就是上面的3和5两个子步骤其实都是调用的BeanPostProcessor里面的方法。所以现在就比较清晰了，我们考虑用BeanPostProcessor实现自动生成目标对象代理。</p><h2>利用BeanPostProcessor自动创建代理</h2><p>创建动态代理的核心是<strong>把传进来的Bean包装成一个ProxyFactoryBean</strong>，改头换面变成一个动态的代理，里面包含了真正的业务对象，这一点我们已经在前面的工作中做好了。现在是要自动创建这个动态代理，它的核心就是通过BeanPostProcessor来为每一个Bean自动完成创建动态代理的工作。</p><p>我们用一个BeanNameAutoProxyCreator类实现这个功能，顾名思义，这个类就是根据Bean的名字匹配来自动创建动态代理的，你可以看一下相关代码。</p><pre><code class=\"language-java\">package com.minis.aop.framework.autoproxy;\npublic class BeanNameAutoProxyCreator implements BeanPostProcessor{\n    String pattern; //代理对象名称模式，如action*\n    private BeanFactory beanFactory;\n    private AopProxyFactory aopProxyFactory;\n    private String interceptorName;\n    private PointcutAdvisor advisor;\n    public BeanNameAutoProxyCreator() {\n        this.aopProxyFactory = new DefaultAopProxyFactory();\n    }\n    //核心方法。在bean实例化之后，init-method调用之前执行这个步骤。\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (isMatch(beanName, this.pattern)) {\n            ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean(); //创建以恶ProxyFactoryBean\n            proxyFactoryBean.setTarget(bean);\n            proxyFactoryBean.setBeanFactory(beanFactory);\n            proxyFactoryBean.setAopProxyFactory(aopProxyFactory);\n            proxyFactoryBean.setInterceptorName(interceptorName);\n            return proxyFactoryBean;\n        }\n        else {\n            return bean;\n        }\n    }\n    protected boolean isMatch(String beanName, String mappedName) {\n        return PatternMatchUtils.simpleMatch(mappedName, beanName);\n    }\n}\n</code></pre><p>通过代码可以知道，在postProcessBeforeInitialization方法中，判断了Bean的名称是否符合给定的规则，也就是isMatch(beanName, this.pattern)这个方法。往下追究一下，发现这个isMatch()就是直接调用的PatternMatchUtils.simpleMatch()，跟上一节课的通配方法名一样。所以如果Bean的名称匹配上了，那我们就用和以前创建动态代理一样的办法来自动生成代理。</p><pre><code class=\"language-java\">ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();\nproxyFactoryBean.setTarget(bean);\nproxyFactoryBean.setBeanFactory(beanFactory);\nproxyFactoryBean.setAopProxyFactory(aopProxyFactory);\nproxyFactoryBean.setInterceptorName(interceptorName);\n</code></pre><p>这里我们还是用到了ProxyFactoryBean，跟以前一样，只不过这里是经过了BeanPostProcessor。因此，按照IoC容器的规则，这一切不再是手工的了，而是对每一个符合规则Bean都会这样做一次动态代理，就可以完成我们的工作了。</p><p>现在我们只要把这个BeanPostProcessor配置到XML文件里就可以了。</p><pre><code class=\"language-plain\">&lt;bean id=\"autoProxyCreator\" class=\"com.minis.aop.framework.autoproxy.BeanNameAutoProxyCreator\" &gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"pattern\" value=\"action*\" /&gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"interceptorName\" value=\"advisor\" /&gt;\n&lt;/bean&gt;\n</code></pre><p>IoC容器扫描配置文件的时候，会把所有的BeanPostProcessor对象加载到Factory中生效，每一个Bean都会过一遍手。</p><h2>getBean方法的修改</h2><p>工具准备好了，这个BeanPostProcessor会自动创建动态代理。为了使用这个Processor，对应的AbstractBeanFactory类里的getBean()方法需要同步修改。你可以看一下修改后getBean的实现。</p><pre><code class=\"language-java\">    public Object getBean(String beanName) throws BeansException{\n      Object singleton = this.getSingleton(beanName);\n      if (singleton == null) {\n         singleton = this.earlySingletonObjects.get(beanName);\n         if (singleton == null) {\n            BeanDefinition bd = beanDefinitionMap.get(beanName);\n            if (bd != null) {\n               singleton=createBean(bd);\n               this.registerBean(beanName, singleton);\n               if (singleton instanceof BeanFactoryAware) {\n                  ((BeanFactoryAware) singleton).setBeanFactory(this);\n               }\n               //用beanpostprocessor进行后期处理\n               //step 1 : postProcessBeforeInitialization调用processor相关方法\n               singleton = applyBeanPostProcessorsBeforeInitialization(singleton, beanName);\n               //step 2 : init-method\n               if (bd.getInitMethodName() != null &amp;&amp; !bd.getInitMethodName().equals(\"\")) {\n                  invokeInitMethod(bd, singleton);\n               }\n               //step 3 : postProcessAfterInitialization\n               applyBeanPostProcessorsAfterInitialization(singleton, beanName);\n               this.removeSingleton(beanName);\n               this.registerBean(beanName, singleton);\n            }\n            else {\n               return null;\n            }\n         }\n      }\n      else {\n      }\n      //process Factory Bean\n      if (singleton instanceof FactoryBean) {\n         return this.getObjectForBeanInstance(singleton, beanName);\n      }\n      else {\n      }\n      return singleton;\n   }\n</code></pre><p>上述代码中主要修改这一行：</p><pre><code class=\"language-java\">singleton = applyBeanPostProcessorsBeforeInitialization(singleton, beanName);\n</code></pre><p>代码里会调用Processor的postProcessBeforeInitialization方法，并返回singleton。这一段代码的功能是如果这个Bean的名称符合某种规则，就会自动创建Factory Bean，这个Factory Bean里面会包含一个动态代理对象用来返回自定义的实例。</p><p>于是，getBean的时候，除了创建Bean实例，还会用BeanPostProcessor进行后期处理，对满足规则的Bean进行包装，改头换面成为一个Factory Bean。</p><h2>测试</h2><p>到这里，我们就完成自动创建动态代理的工作了，简单测试一下。</p><p>修改applicationContext.xml配置文件，增加一些配置。</p><pre><code class=\"language-xml\">&lt;bean id=\"autoProxyCreator\" class=\"com.minis.aop.framework.autoproxy.BeanNameAutoProxyCreator\" &gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"pattern\" value=\"action*\" /&gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"interceptorName\" value=\"advisor\" /&gt;\n&lt;/bean&gt;\n\t\n&lt;bean id=\"action\" class=\"com.test.service.Action1\" /&gt;&nbsp;\n&lt;bean id=\"action2\" class=\"com.test.service.Action2\" /&gt;&nbsp;\n\t\n&lt;bena id=\"beforeAdvice\" class=\"com.test.service.MyBeforeAdvice\" /&gt;\n&lt;bean id=\"advisor\" class=\"com.minis.aop.NameMatchMethodPointcutAdvisor\"&gt;\n&nbsp; &nbsp; &lt;property type=\"com.minis.aop.Advice\" name=\"advice\" ref=\"beforeAdvice\"/&gt;\n&nbsp; &nbsp; &lt;property type=\"String\" name=\"mappedName\" value=\"do*\"/&gt;\n&lt;/bean&gt;\n</code></pre><p>这里我们配置了两个Bean，BeanPostProcessor和Advisor。</p><p>相应地，controller层的HelloWorldBean增加一段代码。</p><pre><code class=\"language-plain\">@Autowired\nIAction action;\n\t\n@RequestMapping(\"/testaop\")\npublic void doTestAop(HttpServletRequest request, HttpServletResponse response) {\n\taction.doAction();\n}\n@RequestMapping(\"/testaop2\")\npublic void doTestAop2(HttpServletRequest request, HttpServletResponse response) {\n\taction.doSomething();\n}\t\n\n@Autowired\nIAction action2;\n\n@RequestMapping(\"/testaop3\")\npublic void doTestAop3(HttpServletRequest request, HttpServletResponse response) {\n\taction2.doAction();\n}\n@RequestMapping(\"/testaop4\")\npublic void doTestAop4(HttpServletRequest request, HttpServletResponse response) {\n\taction2.doSomething();\n}\n</code></pre><p>这里，我们用到了这两个Bean，action和action2，每个Bean里面都有doAction()和doSomething()两个方法。</p><p>通过配置文件可以看到，在Processor的Pattern配置里，通配 <code>action*</code> 可以匹配所有以action开头的Bean。在Advisor的MappedName配置里，通配 <code>do*</code>，就可以匹配所有以do开头的方法。</p><p>运行一下，就可以看到效果了。这两个Bean里的两个方法都加上了增强，说明系统在调用这些Bean的方法时自动插入了逻辑。</p><h2>小结</h2><p>这节课，我们对匹配Bean的办法进行了扩展，使系统可以按照某个规则来匹配某些Bean，这样就不用一个Bean一个Bean地配置动态代理了。</p><p>实现的思路是利用Bean的时序，使用一个BeanPostProcessor进行后期处理。这个Processor接收一个模式串，而这个模式也是可以由用户配置在外部文件里的，然后提供isMatch() 方法，支持根据名称进行模式匹配。具体的字符串匹配工作，和上节课一样，也是采用从前到后的扫描技术，分节段进行校验。匹配上之后，还是利用以前的ProxyFactoryBean创建动态代理。这里要理解一点，就是系统会自动把应用程序员配置的业务Bean改头换面，让它变成一个Factory Bean，里面包含的是业务Bean的动态代理。</p><p>这个方案能用是因为之前IoC容器里提供的这个BeanPostProcessor机制，所以这里我们再次看到了IoC容器的强大之处。</p><p>到这里，我们的AOP方案就完成了。这是基于JDK的方案，对于理解AOP原理很有帮助。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a>。</p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。AOP经常用来处理数据库事务，如何用我们现在的AOP架构实现简单的事务处理呢？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","neighbors":{"left":{"article_title":"19｜Pointcut ：如何批量匹配代理方法？","id":651649},"right":{"article_title":"21｜再回首： 如何实现Spring AOP?","id":653063}},"comments":[{"had_liked":false,"id":373463,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":true,"comment_ctime":1682523528,"is_pvip":false,"replies":[{"id":136392,"content":"github上每一节的代码都是可运行的。文稿是写重点，会有漏掉细节。感谢你的补充。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1682563304,"ip_address":"澳大利亚","comment_id":373463,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"这节课的代码能够做到不需要在beans.xml中额外专门配置来生成代理对象，已经接近spring的雏形了。但是按照之前的代码是跑不起来的，需要对之前的BeanPostProcessor的逻辑修改一下，应该是老师之前讲漏了的部分。主要工作在修改AbstractAutowireCapableBeanFactory类将属性中的beanPostProcessors改为面向接口的列表，其次是修改ClassPathXmlApplicationContext#registerBeanPostProcessors让其可以在配置文件中读到注册的BeanPostProcessors并注册到容器中。最后将我们之前用到的AutowiredAnnotationBeanPostProcessor注册到容器中管理就能够自动发现了。\n代码修改可以参考：https:&#47;&#47;github.com&#47;horseLk&#47;mini-spring&#47;commit&#47;7186afebeaf30d622d79b4111970945abca97701","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616053,"discussion_content":"github上每一节的代码都是可运行的。文稿是写重点，会有漏掉细节。感谢你的补充。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682563304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373469,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1682552137,"is_pvip":false,"replies":[{"id":136393,"content":"Peter总是很用心细致。\nJoin point跟Pointcut不是一回事,它是指在类中的位置，如是方法上？是构造器上？是属性上？pointcut是条件，如哪些符合条件的方法上加上增强。\n流程你得理一下源代码，这些概念之间并没有流程。\n口头讲课确实有一些随意，不那么精确，”实现”一词呢，因为advisor里面包了一个advice，就那么说了，不是代码意义上的“实现”。形象地说，advice是饭（真正的业务增强逻辑），advisor是碗筷（装饭给人吃的工具），人不能直接用嘴巴啃饭，要用一个工具把饭吃到嘴里。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1682563970,"ip_address":"澳大利亚","comment_id":373469,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"问题放在第20课，但问题是关于第19课的：\nQ1：Join Point和Pointcut的区别是什么？两个看起来是一回事啊。\nQ2：流程方面，Interceptor先拦截，拦截以后再进行增强操作。换一种说法，先是Interceptor工作，然后是Join Point、Pointcut、advice这些登场，对吗？\nQ3：19课的总结部分，是这样说的：“Advisor：通知者，它实现了 Advice”。19课的留言解答有这样一句话“advisor则是一个管理类，它包了一个advice，还能寻找到符合条件的方法名进行增强”。 留言的解释很不错，但总结部分，“实现了 Advice”，个人感觉这个措辞不是很合理啊，怎么是“实现”？这个词容易让人理解为接口与实现类的关系。","like_count":5,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616054,"discussion_content":"Peter总是很用心细致。\nJoin point跟Pointcut不是一回事,它是指在类中的位置，如是方法上？是构造器上？是属性上？pointcut是条件，如哪些符合条件的方法上加上增强。\n流程你得理一下源代码，这些概念之间并没有流程。\n口头讲课确实有一些随意，不那么精确，”实现”一词呢，因为advisor里面包了一个advice，就那么说了，不是代码意义上的“实现”。形象地说，advice是饭（真正的业务增强逻辑），advisor是碗筷（装饭给人吃的工具），人不能直接用嘴巴啃饭，要用一个工具把饭吃到嘴里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682563970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376861,"user_name":"__@Wong","can_delete":false,"product_type":"c1","uid":1422756,"ip_address":"广东","ucode":"A54A5FC672F23D","user_header":"https://static001.geekbang.org/account/avatar/00/15/b5/a4/67d6e3cb.jpg","comment_is_top":false,"comment_ctime":1687599712,"is_pvip":false,"replies":[{"id":137385,"content":"是","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1687734340,"ip_address":"澳大利亚","comment_id":376861,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"补充一个点，这里需要保证AutowiredAnnotationBeanPostProcessor和BeanNameAutoProxyCreator两个BeanPostProcessor的优先级，AutowiredAnnotationBeanPostProcessor要在之前哦，在xml文件里面AutowiredAnnotationBeanPostProcessor的bean要放前面。","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621869,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687734340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2459923,"avatar":"https://static001.geekbang.org/account/avatar/00/25/89/13/0d3c5008.jpg","nickname":"最好不过","note":"","ucode":"C7DBCD08402DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644036,"discussion_content":"不用啊，在Controller注入bean的时候，获取action的bean，这个时候已经是经过代理加强之后的bean了。\n1. 在初始化父容器的时候，将action的bean初始化的时候已经经过BeanNameAutoProxyCreator代理加强了。\n2.在HelloWorldBean里通过Autowired注入的时候，获取action的bean是从第一步中得到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714911045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373461,"user_name":"Geek_320730","can_delete":false,"product_type":"c1","uid":3035552,"ip_address":"北京","ucode":"CF7E6C8E91D2C4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/XWv3mvIFORNgRk9wF8QLb9aXfh1Uz1hADtUmlFwQJVxIzhBf8HWc4QqU7iaTzj8wB5p5QJLRAvlQNrOqXtrg1Og/132","comment_is_top":false,"comment_ctime":1682522333,"is_pvip":false,"replies":[{"id":136391,"content":"你这个bean嵌套代理的补充很好。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1682563200,"ip_address":"澳大利亚","comment_id":373461,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"可以定义一个注解@Transaction并实现一个MethodMatcher，根据有没有这个注解来判断方法是否匹配，匹配的话，在方法执行前，手动开启事务，方法结束后，手动提交事务，有异常的话回滚事务。那事务方法调用事务方法的时候不知道会不会报错。。。\n\n另外遇到Bean可以一直嵌套代理的问题，比如上一章手动配置的action,本身就是一个ProxyFactoryBean了，但是他的名字依然符合本章的action*的匹配规则，这样就又加了一层代理，注入的时候就会失败。需要在获取类的时候判断一下类型递归返回，或者在bean匹配规则的时候做一下类型判断，如果本身是个ProxyFactoryBean了，就不做操作返回。","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616052,"discussion_content":"你这个bean嵌套代理的补充很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682563200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376702,"user_name":"__@Wong","can_delete":false,"product_type":"c1","uid":1422756,"ip_address":"广东","ucode":"A54A5FC672F23D","user_header":"https://static001.geekbang.org/account/avatar/00/15/b5/a4/67d6e3cb.jpg","comment_is_top":false,"comment_ctime":1687248222,"is_pvip":false,"replies":[{"id":137330,"content":"不会有问题的。因为getBean()也改写了：\nAbstractBeanFactory的getBean():\n\t\t\t&#47;&#47;beanpostprocessor\n\t\t\t&#47;&#47;step 1 : postProcessBeforeInitialization\n\t\t\tsingleton = applyBeanPostProcessorsBeforeInitialization(singleton, beanName);\t\t\n\t\t\t&#47;&#47;这一步将bean改头换面成proxyfactorybean\t\t\n","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1687305871,"ip_address":"澳大利亚","comment_id":376702,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"将原有的bean替换成代理后的bean那里，如果遇到循环引用会有问题吧， 引用的还是旧的bean。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621531,"discussion_content":"不会有问题的。因为getBean()也改写了：\nAbstractBeanFactory的getBean():\n\t\t\t//beanpostprocessor\n\t\t\t//step 1 : postProcessBeforeInitialization\n\t\t\tsingleton = applyBeanPostProcessorsBeforeInitialization(singleton, beanName);\t\t\n\t\t\t//这一步将bean改头换面成proxyfactorybean\t\t\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687305871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1422756,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b5/a4/67d6e3cb.jpg","nickname":"__@Wong","note":"","ucode":"A54A5FC672F23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621756,"discussion_content":"step1这里把bean指向的对象改了，但是earlySingletonObjects和singletons两个map里面该beanName保存的对象还是指向的原来的bean, 如果被循环引用了是从singletons获取该bean, 还是指向的原来的bean哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687599546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375328,"user_name":"__Alucard","can_delete":false,"product_type":"c1","uid":2625245,"ip_address":"浙江","ucode":"8766ECCC8C7283","user_header":"https://static001.geekbang.org/account/avatar/00/28/0e/dd/4d468ad7.jpg","comment_is_top":false,"comment_ctime":1685342027,"is_pvip":false,"replies":[{"id":136984,"content":"恭喜，多谢。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685403372,"ip_address":"澳大利亚","comment_id":375328,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"完结撒花，谢谢指导","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619655,"discussion_content":"恭喜，多谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685403372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375327,"user_name":"__Alucard","can_delete":false,"product_type":"c1","uid":2625245,"ip_address":"浙江","ucode":"8766ECCC8C7283","user_header":"https://static001.geekbang.org/account/avatar/00/28/0e/dd/4d468ad7.jpg","comment_is_top":false,"comment_ctime":1685341571,"is_pvip":false,"replies":[{"id":136986,"content":"你讲的问题讲到点上了。我只能说Spring目前的方案就是挺合适的方案，我自己想不出别的合适的办法。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685403553,"ip_address":"澳大利亚","comment_id":375327,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"动态代理失效的根本原因是@Autowired注解解析的时候，取到的spring bean还是没代理的对象； 我的临时解决方案是 在BeanNameAutoProxyCreator的postProcessBeforeInitialization手动把创建后的动态代理对象注入进spring ioc中， beanFactory.registerBean(beanName,proxyFactoryBean);  但是这样会导致BeanFactory又对外暴露了注册bean的接口，void registerBean(String beanName, Object obj);明显不合适，这个有没有更好的办法","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619657,"discussion_content":"你讲的问题讲到点上了。我只能说Spring目前的方案就是挺合适的方案，我自己想不出别的合适的办法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685403553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2402779,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a9/db/db6f9f17.jpg","nickname":"光锥1066","note":"","ucode":"986DFB3C469695","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":626985,"discussion_content":"目前的方案是怎么样的呢？保证BeanPostProcessor的加载顺序吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693561515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":619657,"ip_address":"浙江","group_id":0},"score":626985,"extra":""}]}]},{"had_liked":false,"id":373677,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1683001426,"is_pvip":false,"replies":[{"id":136442,"content":"我检查一下，多谢提醒。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1683034931,"ip_address":"澳大利亚","comment_id":373677,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师你好，怎么github上面这块framework这个包下面有部分代码是重复的呢？建议可以来个代码结构的总结","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616636,"discussion_content":"我检查一下，多谢提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683034931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392193,"user_name":"dirtychill","can_delete":false,"product_type":"c1","uid":3866578,"ip_address":"江苏","ucode":"4D3172C60E522A","user_header":"https://static001.geekbang.org/account/avatar/00/3a/ff/d2/c1f5334d.jpg","comment_is_top":false,"comment_ctime":1720236691,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"一步步录入代码完成，可运行的，利用lombok简化了代码，便于学习，可能还有一些bug或者一些扩展，可以来维护https:&#47;&#47;github.com&#47;DirtyBit64&#47;Mini-Spring","like_count":0},{"had_liked":false,"id":389506,"user_name":"Geek_28bb47","can_delete":false,"product_type":"c1","uid":3173602,"ip_address":"陕西","ucode":"86F5DCFFDDB723","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BBaAkryVSFImaoWL5QcRbSpB8IfUbUZGfzGH4xUz0qicJGU1vREvcFedgWAXJlYX9ibkzG3BlnJEQDzejZ5ibLCGA/132","comment_is_top":false,"comment_ctime":1712757040,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"已学完，https:&#47;&#47;github.com&#47;ykexc&#47;minispring，每节课对应一个分支，欢迎大家来参考，感觉懂了一点，还需要看完spring源码再继续品味。","like_count":0},{"had_liked":false,"id":378355,"user_name":"天敌","can_delete":false,"product_type":"c1","uid":1059944,"ip_address":"四川","ucode":"CD29A622197197","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/68/c299bc71.jpg","comment_is_top":false,"comment_ctime":1690127729,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师，关于使用 Proxy.newProxyInstance 生成的对象在进行 xml 中 ref 的属性绑定过程中，由于生成的代理对象并没有继承被代理对象的类，导致进行赋值时\nIllegalArgumentException: argument type mismatch\n这个问题，应该如何解决呢？","like_count":0}]}