{"id":77083,"title":"26 | 备库为什么会延迟好几个小时？","content":"<p>在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都能够追上来。</p><p>但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。</p><p>这就涉及到今天我要给你介绍的话题：备库并行复制能力。</p><p>为了便于你理解，我们再一起看一下第24篇文章<a href=\"https://time.geekbang.org/column/article/76446\">《MySQL是怎么保证主备一致的？》</a>的主备流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png?wh=1142*856\" alt=\"\"></p><center><span class=\"reference\">图1 主备流程图</span></center><p>谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。</p><p>在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。</p><p>而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p><!-- [[[read_end]]] --><p>在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重的主备延迟问题。</p><p>从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说MySQL多线程复制的演进过程。</p><p>其实说到底，所有的多线程复制机制，都是要把图1中只有一个线程的sql_thread，拆成多个线程，也就是都符合下面的这个模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png?wh=1142*856\" alt=\"\"></p><center><span class=\"reference\">图2 多线程模型</span></center><p>图2中，coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。</p><p>接下来，你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个事务分给worker_1，第二个事务发给worker_2呢？</p><p>其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。</p><p>接下来，请你再设想一下另外一个问题：同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p><p>答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。</p><p>所以，coordinator在分发的时候，需要满足以下这两个基本要求：</p><ol>\n<li>\n<p>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</p>\n</li>\n<li>\n<p>同一个事务不能被拆开，必须放到同一个worker中。</p>\n</li>\n</ol><p>各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策略。</p><h1>MySQL 5.5版本的并行复制策略</h1><p>官方MySQL 5.5版本是不支持并行复制的。但是，在2012年的时候，我自己服务的业务出现了严重的主备延迟，原因就是备库只有单线程复制。然后，我就先后写了两个版本的并行策略。</p><p>这里，我给你介绍一下这两个版本的并行策略，即按表分发策略和按行分发策略，以帮助你理解MySQL官方版本并行复制策略的迭代。</p><h3>按表分发策略</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。</p><p>当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图3所示，就是按表分发的规则。</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/76/8b6976fedd6e644022d4026581fb8d76.png?wh=1142*856\" alt=\"\"></p><center><span class=\"reference\">图3 按表并行复制程模型</span></center><p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><p>在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p><p>图3中，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，有1个事务涉及到db2.t2表；hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数据。</p><p>假设在图中的情况下，coordinator从中转日志中读入一个新事务T，这个事务修改的行涉及到表t1和t3。</p><p>现在我们用事务T的分配流程，来看一下分配规则。</p><ol>\n<li>\n<p>由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事务要修改同一个表的数据，这种情况我们说事务T和worker_1是冲突的。</p>\n</li>\n<li>\n<p>按照这个逻辑，顺序判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突。</p>\n</li>\n<li>\n<p>事务T跟多于一个worker冲突，coordinator线程就进入等待。</p>\n</li>\n<li>\n<p>每个worker继续执行，同时修改hash_table。假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉。</p>\n</li>\n<li>\n<p>这样coordinator会发现跟事务T冲突的worker只有worker_1了，因此就把它分配给worker_1。</p>\n</li>\n<li>\n<p>coordinator继续读下一个中转日志，继续分配事务。</p>\n</li>\n</ol><p>也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：</p><ol>\n<li>\n<p>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</p>\n</li>\n<li>\n<p>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关系的worker只剩下1个；</p>\n</li>\n<li>\n<p>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。</p>\n</li>\n</ol><p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了。</p><h3>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须是row。</p><p>这时候，我们判断一个事务T和worker是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p><p>按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+唯一键的值”。</p><p>但是，这个“唯一键”只有主键id还是不够的，我们还需要考虑下面这种场景，表t1中除了主键，还有唯一索引a：</p><pre><code>CREATE TABLE `t1` (\n  `id` int(11) NOT NULL,\n  `a` int(11) DEFAULT NULL,\n  `b` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `a` (`a`)\n) ENGINE=InnoDB;\n\ninsert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);\n</code></pre><p>假设，接下来我们要在主库执行这两个事务：</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/78/f19916e27b8ff28e87ed3ad9f5473378.png?wh=937*149\" alt=\"\"></p><center><span class=\"reference\">图4 唯一键冲突示例</span></center><p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能session B的语句先执行。这时候id=1的行的a的值还是1，就会报唯一键冲突。</p><p>因此，基于行的策略，事务hash表中还需要考虑唯一键，即key应该是“库名+表名+索引a的名字+a的值”。</p><p>比如，在上面这个例子中，我要在表t1上执行update t1 set a=1 where id=2语句，在binlog里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p><p>因此，coordinator在解析这个语句的binlog的时候，这个事务的hash表就有三个项:</p><ol>\n<li>\n<p>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里value=2是因为修改前后的行id值不变，出现了两次。</p>\n</li>\n<li>\n<p>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表a=2的行。</p>\n</li>\n<li>\n<p>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表a=1的行。</p>\n</li>\n</ol><p>可见，<strong>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</strong>你可能也发现了，这两个方案其实都有一些约束条件：</p><ol>\n<li>\n<p>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必须是row；</p>\n</li>\n<li>\n<p>表必须有主键；</p>\n</li>\n<li>\n<p>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。</p>\n</li>\n</ol><p>但，好在这三条约束规则，本来就是DBA之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。</p><p>对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p><ol>\n<li>\n<p>耗费内存。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。</p>\n</li>\n<li>\n<p>耗费CPU。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。</p>\n</li>\n</ol><p>所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过10万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p><ol>\n<li>\n<p>coordinator暂时先hold住这个事务；</p>\n</li>\n<li>\n<p>等待所有worker都执行完成，变成空队列；</p>\n</li>\n<li>\n<p>coordinator直接执行这个事务；</p>\n</li>\n<li>\n<p>恢复并行模式。</p>\n</li>\n</ol><p>读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。</p><h1>MySQL 5.6版本的并行复制策略</h1><p>官方MySQL5.6版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的hash表里，key就是数据库名。</p><p>这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。</p><p>相比于按表和按行分发，这个策略有两个优势：</p><ol>\n<li>\n<p>构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况。</p>\n</li>\n<li>\n<p>不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。</p>\n</li>\n</ol><p>但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p><p>理论上你可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。</p><h1>MariaDB的并行复制策略</h1><p>在<a href=\"https://time.geekbang.org/column/article/76161\">第23篇文章</a>中，我给你介绍了redo log组提交(group commit)优化， 而MariaDB的并行复制策略利用的就是这个特性：</p><ol>\n<li>\n<p>能够在同一组里提交的事务，一定不会修改同一行；</p>\n</li>\n<li>\n<p>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</p>\n</li>\n</ol><p>在实现上，MariaDB是这么做的：</p><ol>\n<li>\n<p>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</p>\n</li>\n<li>\n<p>commit_id直接写到binlog里面；</p>\n</li>\n<li>\n<p>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</p>\n</li>\n<li>\n<p>这一组全部执行完成后，coordinator再去取下一批。</p>\n</li>\n</ol><p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析binlog，并拆分到worker”上。而MariaDB的这个策略，目标是“模拟主库的并行模式”。</p><p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p><p>如图5所示，假设了三组事务在主库的执行情况，你可以看到在trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/c3/8fec5fb48d6095aecc80016826efbfc3.png?wh=1142*856\" alt=\"\"></p><center><span class=\"reference\">图5 主库并行事务</span></center><p>而按照MariaDB的并行复制策略，备库上的执行效果如图6所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/22/8ac3799c1ff2f9833619a1624ca3e622.png?wh=1142*856\" alt=\"\"></p><center><span class=\"reference\">图6 MariaDB 并行复制，备库并行效果</span></center><p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p><p>另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，只有一个worker线程在工作，是对资源的浪费。</p><p>不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p><h1>MySQL 5.7的并行复制策略</h1><p>在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数slave-parallel-type来控制并行复制策略：</p><ol>\n<li>\n<p>配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；</p>\n</li>\n<li>\n<p>配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL 5.7这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。</p>\n</li>\n</ol><p>你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？</p><p>答案是，不能。</p><p>因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的worker，就会出现备库跟主库不一致的情况。</p><p>而上面提到的MariaDB这个策略的核心，是“所有处于commit”状态的事务可以并行。事务处于commit状态，表示已经通过了锁冲突的检验了。</p><p>这时候，你可以再回顾一下两阶段提交，我把前面<a href=\"https://time.geekbang.org/column/article/76161\">第23篇文章</a>中介绍过的两阶段提交过程图贴过来。</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png?wh=1142*1522\" alt=\"\"></p><center><span class=\"reference\">图7 两阶段提交细化过程图</span></center><p>其实，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突的检验了。</p><p>因此，MySQL 5.7并行复制策略的思想是：</p><ol>\n<li>\n<p>同时处于prepare状态的事务，在备库执行时是可以并行的；</p>\n</li>\n<li>\n<p>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。</p>\n</li>\n</ol><p>我在第23篇文章，讲binlog的组提交的时候，介绍过两个参数：</p><ol>\n<li>\n<p>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</p>\n</li>\n<li>\n<p>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</p>\n</li>\n</ol><p>这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL 5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了备库复制的并行度。</p><p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p><h1>MySQL 5.7.22的并行复制策略</h1><p>在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于WRITESET的并行复制。</p><p>相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p><ol>\n<li>\n<p>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略。</p>\n</li>\n<li>\n<p>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行。</p>\n</li>\n<li>\n<p>WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</p>\n</li>\n</ol><p>当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个hash值。</p><p>你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不过，MySQL官方的这个实现还是有很大的优势：</p><ol>\n<li>\n<p>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容（event里的行数据），节省了很多计算量；</p>\n</li>\n<li>\n<p>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</p>\n</li>\n<li>\n<p>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。</p>\n</li>\n</ol><p>因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。</p><p>当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化为单线程模型。</p><h1>小结</h1><p>在今天这篇文章中，我和你介绍了MySQL的各种多线程复制策略。</p><p>为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值越来越大。</p><p>在介绍完每个并行复制策略后，我还和你分享了不同策略的优缺点：</p><ul>\n<li>如果你是DBA，就需要根据不同的业务场景，选择不同的策略；</li>\n<li>如果是你业务开发人员，也希望你能从中获取灵感用到平时的开发工作中。</li>\n</ul><p>从这些分析中，你也会发现大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。</p><p>官方MySQL5.7版本新增的备库并行策略，修改了binlog的内容，也就是说binlog协议并不是向上兼容的，在主备切换、版本升级的时候需要把这个因素也考虑进去。</p><p>最后，我给你留下一个思考题吧。</p><p>假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主库搭建一个相同版本的备库。</p><p>这时候，你为了更快地让备库追上主库，要开并行复制。在binlog-transaction-dependency-tracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择哪一个呢？</p><p>你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？</p><p>你可以把你的答案和分析写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>上期的问题是，什么情况下，备库的主备延迟会表现为一个45度的线段？评论区有不少同学的回复都说到了重点：备库的同步在这段时间完全被堵住了。</p><p>产生这种现象典型的场景主要包括两种：</p><ul>\n<li>一种是大事务（包括大表DDL、一个事务操作很多行）；</li>\n<li>还有一种情况比较隐蔽，就是备库起了一个长事务，比如</li>\n</ul><pre><code>begin; \nselect * from t limit 1;\n</code></pre><p>然后就不动了。</p><p>这时候主库对表t做了一个加字段操作，即使这个表很小，这个DDL在备库应用的时候也会被堵住，也不能看到这个现象。</p><p>评论区还有同学说是不是主库多线程、从库单线程，备库跟不上主库的更新节奏导致的？今天这篇文章，我们刚好讲的是并行复制。所以，你知道了，这种情况会导致主备延迟，但不会表现为这种标准的呈45度的直线。</p><p>评论区留言点赞板：</p><blockquote>\n<p>@易翔 、 @万勇、@老杨同志 等同学的回复都提到了我们上面说的场景；</p>\n</blockquote><blockquote>\n<p>@Max 同学提了一个很不错的问题。主备关系里面，备库主动连接，之后的binlog发送是主库主动推送的。之所以这么设计也是为了效率和实时性考虑，毕竟靠备库轮询，会有时间差。</p>\n</blockquote><p></p>","comments":[{"had_liked":false,"id":58687,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":true,"comment_ctime":1547175471,"is_pvip":false,"replies":[{"id":"21216","content":"👍，你比我回复得详细，顶起","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547178695,"ip_address":"","comment_id":58687,"utype":1}],"discussion_count":5,"race_medal":0,"score":"9.2233725065533993e+18","product_id":100020801,"comment_content":"尝试回答 慧鑫coming 的问题。<br>老师图片的步骤有下面5步<br>1 redo log prepare write<br>2 binlog write<br>3 redo log prepare fsync<br>4 binlog fsync<br>5 redo log commit write<br><br>1)如果更新通一条记录是有锁的，只能一个事务执行，其他事务等待锁。<br><br>2)第4步的时候会因为下面两个参数，等其他没有锁冲突的事务，一起刷盘，此时一起执行的事务拥有相同的commit_id<br>binlog_group_commit_sync_delay<br>binlog_group_commit_sync_no_delay_count<br><br>3)执行步骤5后，释放锁，等待锁的事务开始执行。<br><br>所以对同一行更新的事务，不可能拥有相同的commit_id","like_count":110,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436174,"discussion_content":"👍，你比我回复得详细，顶起","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547178695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691436,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/2c/be133cdf.jpg","nickname":"tank","note":"","ucode":"256553A4C09ABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316711,"discussion_content":"[root@centos7-mysql5 ~]# mysqlbinlog -vv /data/mysql_log/binlog.000130 --start-position=2014116   --stop-position=2014627\n# at 2014116\n#201022 23:29:47 server id 3306  end_log_pos 2014181 CRC32 0xaff15d6c   GTID    last_committed=2194     sequence_number=2195         rbr_only=yes\n/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;\nSET @@SESSION.GTID_NEXT= &#39;c5714948-edc3-11ea-990b-000c29f0ee9b:55954&#39;/*!*/;\n# at 2014181\n#201022 23:29:41 server id 3306  end_log_pos 2014258 CRC32 0xda15f77b   Query   thread_id=1115  exec_time=0     error_code=0\nSET TIMESTAMP=1603423781/*!*/;\nSET @@session.pseudo_thread_id=1115/*!*/;\nSET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;\nSET @@session.sql_mode=1436549152/*!*/;\nSET @@session.auto_increment_increment=2, @@session.auto_increment_offset=1/*!*/;\n/*!\\C utf8 *//*!*/;\nSET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;\nSET @@session.lc_time_names=0/*!*/;\nSET @@session.collation_database=DEFAULT/*!*/;\nBEGIN\n/*!*/;\n# at 2014258\n#201022 23:29:41 server id 3306  end_log_pos 2014315 CRC32 0x41a95e75   Rows_query\n# update t_iso set d=d+1 where id=0\n# at 2014315\n#201022 23:29:41 server id 3306  end_log_pos 2014365 CRC32 0x80d7b705   Table_map: `test`.`t_iso` mapped to number 165\n# at 2014365\n#201022 23:29:41 server id 3306  end_log_pos 2014427 CRC32 0xb048cac9   Update_rows: table id 165 flags: STMT_END_F\n\n#201022 23:29:44 server id 3306  end_log_pos 2014484 CRC32 0x453a0d33   Rows_query\n# update t_iso set d=d+2 where id=0\n# at 2014484\n#201022 23:29:44 server id 3306  end_log_pos 2014534 CRC32 0x2527a2ca   Table_map: `test`.`t_iso` mapped to number 165\n# at 2014534\n#201022 23:29:44 server id 3306  end_log_pos 2014596 CRC32 0x28d61a11   Update_rows: table id 165 flags: STMT_END_F\n#201022 23:29:47 server id 3306  end_log_pos 2014627 CRC32 0x3a8264c6   Xid = 366367\nCOMMIT/*!*/;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603443795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691436,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/2c/be133cdf.jpg","nickname":"tank","note":"","ucode":"256553A4C09ABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316555,"discussion_content":"老师，为什么我RR/RC隔离级别测试同一个事务2次更新同一行都成功了，而且是同一个commit_id?\n\nCREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);\n\nroot@localhost:[test] 23:29:34>begin;\nroot@localhost:[test] 23:29:36>update t_iso set d=d+1 where id=0;\nroot@localhost:[test] 23:29:41>update t_iso set d=d+2 where id=0;\nroot@localhost:[test] 23:29:44>commit;\nQuery OK, 0 rows affected (0.00 sec)\n由于无法截图，show binlog events in &#39;binlog.000130&#39; from 2014116 limit 9;  结果如下：\nroot@localhost:[test] 23:54:39>show binlog events in &#39;binlog.000130&#39; from 2014116 limit 9;\nbinlog.000130 | 2014116 | Gtid           |      3306 |     2014181 | SET @@SESSION.GTID_NEXT= &#39;c5714948-edc3-11ea-990b-000c29f0ee9b:55954&#39;\nbinlog.000130 | 2014181 | Query          |      3306 |     2014258 | BEGIN\nbinlog.000130 | 2014258 | Rows_query     |      3306 |     2014315 | # update t_iso set d=d+1 where id=0\nbinlog.000130 | 2014484 | Table_map      |      3306 |     2014534 | table_id: 165 (test.t_iso)\nbinlog.000130 | 2014365 | Update_rows    |      3306 |     2014427 | table_id: 165 flags: STMT_END_F\nbinlog.000130 | 2014427 | Rows_query     |      3306 |     2014484 | # update t_iso set d=d+2 where id=0\nbinlog.000130 | 2014484 | Table_map      |      3306 |     2014534 | table_id: 165 (test.t_iso)\nbinlog.000130 | 2014534 | Update_rows    |      3306 |     2014596 | table_id: 165 flags: STMT_END_F\nbinlog.000130 | 2014596 | Xid            |      3306 |     2014627 | COMMIT /* xid=366367 */","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603425353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1970443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx1V1QAxC4NHaxYZGyuibBN8lcURJWc5nrnO4yic1kxnDemYV2FJGialf47kYX9qtDnZZOfe1SJeLicg/132","nickname":"lleft","note":"","ucode":"D573EB509455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1691436,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/2c/be133cdf.jpg","nickname":"tank","note":"","ucode":"256553A4C09ABF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375176,"discussion_content":"对同一行更新的不同事务，不是一个事务里面多条SQL更新同一行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621501788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316555,"ip_address":""},"score":375176,"extra":""},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1691436,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/2c/be133cdf.jpg","nickname":"tank","note":"","ucode":"256553A4C09ABF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561417,"discussion_content":"锁的可重入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649638521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316555,"ip_address":""},"score":561417,"extra":""}]}]},{"had_liked":false,"id":58692,"user_name":"长杰","can_delete":false,"product_type":"c1","uid":1312212,"ip_address":"","ucode":"DD52C9494005F7","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/d4/e06bf86d.jpg","comment_is_top":true,"comment_ctime":1547176658,"is_pvip":false,"replies":[{"id":"21217","content":"应该是说，它迟早要commit，但是两个worker是两个线程，没办法约好“同时提交”，这样就有可能出现一个先提交一个后提交。<br>这两个提交之间的时间差，就能被用户看到“一半事务”，好问题<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547178902,"ip_address":"","comment_id":58692,"utype":1}],"discussion_count":12,"race_medal":0,"score":"9.2233722488553001e+18","product_id":100020801,"comment_content":"举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新语句被分到不同 worker 的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。<br><br>老师这块不太明白，备库有查询会看到更新了一半的结果，t1的worker执行完了更新会commit吗？如果不commit，备库查询应该看不到吧？如果commit，就破坏了事物的原子性，肯定是有问题的。","like_count":50,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436175,"discussion_content":"应该是说，它迟早要commit，但是两个worker是两个线程，没办法约好“同时提交”，这样就有可能出现一个先提交一个后提交。\n这两个提交之间的时间差，就能被用户看到“一半事务”，好问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547178902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277036,"discussion_content":"并行复制的最小粒度应该是事务吧？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590986968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2377275,"avatar":"https://static001.geekbang.org/account/avatar/00/24/46/3b/ac4b8ab0.jpg","nickname":"Stream上的帧","note":"","ucode":"325FBEFF80BD91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336896,"discussion_content":"按事务不能分发，如果两个事务更新同一行，此时就会出现顺序的不确定性，进而导致主备的数据不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608726622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277036,"ip_address":""},"score":336896,"extra":""},{"author":{"id":1633316,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ec/24/6bceb24c.jpg","nickname":"孝孝孝孝孝康","note":"","ucode":"0B475582C30D25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2377275,"avatar":"https://static001.geekbang.org/account/avatar/00/24/46/3b/ac4b8ab0.jpg","nickname":"Stream上的帧","note":"","ucode":"325FBEFF80BD91","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553791,"discussion_content":"利用组提交，不可能存在修改同一行的2个事务吧？另一个事务应该获取不到锁阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646096478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336896,"ip_address":""},"score":553791,"extra":""}]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9747,"discussion_content":"大佬你这么一问我也纳闷了，我以为从binlog读过来的数据也会有mvcc支持快照读。。。这么说是没有的喽","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568211409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1044546,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f0/42/7728d4f5.jpg","nickname":"艿艿","note":"","ucode":"8F727AB7A7F6B2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38936,"discussion_content":"从库有延迟，这就注定了是个不准确的数据源了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571848029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9747,"ip_address":""},"score":38936,"extra":""}]},{"author":{"id":1586404,"avatar":"https://static001.geekbang.org/account/avatar/00/18/34/e4/4450c053.jpg","nickname":"四味糖","note":"","ucode":"6648BACBF1CFEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359864,"discussion_content":"两个worker要保证一起提交那就是分布式事务了，现在mysql不支持吧，TiDB是分布式的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616308782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186929,"discussion_content":"我很诧异是为啥不直接把主库的语句送过来执行啊？类似于写两个库，只是写备库的操作是主库做的，这样不就可以做到和主库一样吗？不过这样的话，备库的机器性能要高于主库才合理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582721461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1904762,"avatar":"","nickname":"刘明明","note":"","ucode":"202F0552168DF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284851,"discussion_content":"binlog是statement格式，就是相当执行主库的语句。这种方式也要考虑让它并发写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592660720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186929,"ip_address":""},"score":284851,"extra":""},{"author":{"id":2377275,"avatar":"https://static001.geekbang.org/account/avatar/00/24/46/3b/ac4b8ab0.jpg","nickname":"Stream上的帧","note":"","ucode":"325FBEFF80BD91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336901,"discussion_content":"单线程的处理就是你说的那种处理方式，追求更加极致的性能吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608726745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186929,"ip_address":""},"score":336901,"extra":""},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2377275,"avatar":"https://static001.geekbang.org/account/avatar/00/24/46/3b/ac4b8ab0.jpg","nickname":"Stream上的帧","note":"","ucode":"325FBEFF80BD91","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338438,"discussion_content":"对，多线程的确会有问题。我觉得可以考虑事物进行打包就还好了，不过也要考虑值覆盖顺序不一致带来的数据不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609291348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336901,"ip_address":""},"score":338438,"extra":""}]}]},{"had_liked":false,"id":60753,"user_name":"jike","can_delete":false,"product_type":"c1","uid":1304913,"ip_address":"","ucode":"83CB61A1F0FFA1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKAerblVqBONYuFvJN6EVhjeGuFSvbrS73sHOhm1OhwJFg05o266icOibdhdks1bAwn2kcpltnEmibIA/132","comment_is_top":true,"comment_ctime":1547542927,"is_pvip":false,"replies":[{"id":"21672","content":"是有可能binlog event写入顺序不同的，好问题","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547552002,"ip_address":"","comment_id":60753,"utype":1}],"discussion_count":6,"race_medal":0,"score":"9.2233721629564006e+18","product_id":100020801,"comment_content":"老师您好，开启并行复制后，事务是按照组来提交的，从库也是根据commit_id来回放，如果从库也开启binlog的话，那是不是存在主从的binlog  event写入顺序不一致的情况呢？","like_count":30,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436609,"discussion_content":"是有可能binlog event写入顺序不同的，好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547552002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306224,"discussion_content":"多线程提升性能导致顺序不同，各种策略保证了最终结果是一致的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600223412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167325,"discussion_content":"虽然组事务提交的写入顺序不同，但是不影响数据的先后顺序。主备数据还是一致的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581477864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2389270,"avatar":"https://static001.geekbang.org/account/avatar/00/24/75/16/6e28bf17.jpg","nickname":"初晨","note":"","ucode":"C5D95D13E49127","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590307,"discussion_content":"可能出现顺序不一致，但最终保证一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665649673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320050,"avatar":"https://static001.geekbang.org/account/avatar/00/14/24/72/9e2a651c.jpg","nickname":"家有邹太","note":"","ucode":"5636BD37EB1A99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395169,"discussion_content":"有个commit_order参数可以控制备库按照主库提交的顺序进行提交。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632269117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1320050,"avatar":"https://static001.geekbang.org/account/avatar/00/14/24/72/9e2a651c.jpg","nickname":"家有邹太","note":"","ucode":"5636BD37EB1A99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537750,"discussion_content":"commit_order 也不是控制按照主库提交顺序的。只是按照同时处于“prepare阶段”的事务，都并行执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639152097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395169,"ip_address":""},"score":537750,"extra":""}]}]},{"had_liked":false,"id":58988,"user_name":"HuaMax","can_delete":false,"product_type":"c1","uid":1118488,"ip_address":"","ucode":"2E78DE1AF098AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/18/8cee35f9.jpg","comment_is_top":false,"comment_ctime":1547266333,"is_pvip":false,"replies":[{"id":"21349","content":"准确👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547269179,"ip_address":"","comment_id":58988,"utype":1}],"discussion_count":6,"race_medal":0,"score":"353734584605","product_id":100020801,"comment_content":"课后题。关键点在于主库单线程，针对三种不同的策略，COMMIT_ORDER：没有同时到达redo log的prepare 状态的事务，备库退化为单线程；WRITESET：通过对比更新的事务是否存在冲突的行，可以并发执行；WRITE_SESSION：在WRITESET的基础上增加了线程的约束，则退化为单线程。综上，应选择WRITESET策略","like_count":83,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436267,"discussion_content":"准确👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547269179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2166073,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k3YD3y3BzGDSdrwRJyJY4BXsNJibfM4uzOdDVKIAlFApR2FZCLg2ibrZtJ4vuahA3LHLW9GKzH5CMGqCDhWjhZqg/132","nickname":"戒酒的李白","note":"","ucode":"744E1A22761647","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408938,"discussion_content":"大佬牛逼，分析很透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635345173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111175,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/87/644c0c5d.jpg","nickname":"俊伟","note":"","ucode":"7905B4F25637F4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261843,"discussion_content":"一个线程对同一行肯定是顺序修改的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589013940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186970,"discussion_content":"我想问的是线程约束有啥意义啊？应该是同一行的修改必须顺序一致才有意义啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582722665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2036333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6ZM5RHVBe8pVGoibpPHVM5TZTbqS4u4ckiaHoItk1LIhTfCEYbH7LYiaWJDvTiaga34MQQ3xicIZ0vsAkoSKRvY8F3A/132","nickname":"Geek_b4bb35","note":"","ucode":"257EE15A137445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373926,"discussion_content":"在保证最终一致性的情况下，业务侧也可能会根据不同事务在客户端显示的优先级来要求顺序性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620916818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186970,"ip_address":""},"score":373926,"extra":""},{"author":{"id":2389270,"avatar":"https://static001.geekbang.org/account/avatar/00/24/75/16/6e28bf17.jpg","nickname":"初晨","note":"","ucode":"C5D95D13E49127","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590310,"discussion_content":"这里存在这样的情况，避免出现唯一键冲突。 表t id 主键，a是唯一键。sessionA  更改id=1,a=1 ，设置a=6 ;session B 更改id=2 a=2 设置a=1 。 这里先A后B是没有问题的，若B先执行，就会出现唯一键冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665649951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186970,"ip_address":"陕西"},"score":590310,"extra":""}]}]},{"had_liked":false,"id":59560,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1547385589,"is_pvip":false,"replies":[{"id":"21416","content":"这几篇偏深，但确实是大家在使用的时候需要了解的，<br>到30篇后面的文章会偏应用哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547394206,"ip_address":"","comment_id":59560,"utype":1}],"discussion_count":15,"race_medal":1,"score":"212000783093","product_id":100020801,"comment_content":"我是做java的，看老师的这个专栏，确实挺吃力的，老师专栏的干货太多了，下面的留言也是相当有水平，质量都很高，互动也好，应该是好多DBA吧，做java的我，看的头大","like_count":50,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436355,"discussion_content":"这几篇偏深，但确实是大家在使用的时候需要了解的，\n到30篇后面的文章会偏应用哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547394206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1044546,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f0/42/7728d4f5.jpg","nickname":"艿艿","note":"","ucode":"8F727AB7A7F6B2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38766,"discussion_content":"同泪流满面。。。\n\n属于，看完文章，老师好牛逼。\n看到评论，自己是个智障儿童。","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1571831813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1044546,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f0/42/7728d4f5.jpg","nickname":"艿艿","note":"","ucode":"8F727AB7A7F6B2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":353524,"discussion_content":"感觉评论区好多留级的.不是我们新生能比的.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615169787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":38766,"ip_address":""},"score":353524,"extra":""}]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295988,"discussion_content":"我感觉也可以，做业务的能够了解原理还是好的，楼主这么说可能是看其他中间件的源码原理少一些，mysql的很多玩法，中间件是通用的，建议看下redis mq相关的原理，会发现，其实差不多啦，无非是一些细节的规定啥的 有所区别。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1596422069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1110677,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/95/538d0348.jpg","nickname":"wrp000000","note":"","ucode":"4860119F2276FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305447,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599923830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295988,"ip_address":""},"score":305447,"extra":""}]},{"author":{"id":1120596,"avatar":"https://static001.geekbang.org/account/avatar/00/11/19/54/4341f5b7.jpg","nickname":"敏敏","note":"","ucode":"28C8E8899F74D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23720,"discussion_content":"我感觉理解起来还好吧，我也是做Java的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1569862180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257299,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/53/f17cfee2.jpg","nickname":"Z","note":"","ucode":"8E56D0618F1B76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377541,"discussion_content":"理解起来还行，就是记不住，说不出来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622704115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4c/43/150c70c2.jpg","nickname":"陈松Plus","note":"","ucode":"0074BDECFA3D1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334233,"discussion_content":"同是java，泪流满面～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607774039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2726571,"avatar":"https://static001.geekbang.org/account/avatar/00/29/9a/ab/12b2dc2c.jpg","nickname":"荒海飞沫","note":"","ucode":"B152C65A78C3D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401077,"discussion_content":"俺也一样，不过多看几遍，多动手实操应该会好点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633533077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1586404,"avatar":"https://static001.geekbang.org/account/avatar/00/18/34/e4/4450c053.jpg","nickname":"四味糖","note":"","ucode":"6648BACBF1CFEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359868,"discussion_content":"phper表示老师讲的通俗易懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616309107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207410,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","nickname":"紫日","note":"","ucode":"73A8DEE323AC19","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313853,"discussion_content":"同感，买了好久，感觉看不进去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603099433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1590610,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","nickname":"帝江","note":"","ucode":"93CBA4E4D05DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207410,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","nickname":"紫日","note":"","ucode":"73A8DEE323AC19","race_medal":4,"user_type":1,"is_pvip":true},"discussion":{"id":353523,"discussion_content":"我是php.一起加油.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615169742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313853,"ip_address":""},"score":353523,"extra":""}]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306225,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600223639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167329,"discussion_content":"我是做C#的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581477946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96785,"discussion_content":"通道众人啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577092719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59397,"user_name":"某、人","can_delete":false,"product_type":"c1","uid":1308784,"ip_address":"","ucode":"ADB42AA12A11C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/70/f3a33a14.jpg","comment_is_top":false,"comment_ctime":1547363052,"is_pvip":false,"replies":[{"id":"21414","content":"上面的描述部分，writeset的多线程复制流程里面，这段需要修改下：<br>『2.把binlog_cache flush到binlog文件中,根据表名、主键和唯一键(如果有)生成hash值(writeset),保存到hash表中<br>【判断这三个事务的writeset是否有冲突,如果没有冲突,则视为同组,如果有冲突,则视为不同组.<br>并把把组员编号以及组的编号写进binlog文件中】』<br>上面中括号这段要去掉，<br>判断writeset之间是否可以并行这个逻辑，是在备库的coordinator线程做的。<br><br>----<br>1. 在多线程并发的时候，Seconds_behind_master很不准，后面会介绍别的判断方法；<br>2. 是的,备库有记录，就是show slave status 里面的Relay_Log_File 和 Relay_Log_Pos 这两个值表示的，好问题<br>3.  ”加入到组是在binlog cache flush到binlog文件之前做的,如果此时有事务正在flush,未sync,则后面的事务必须等待“ 这句话是对的，但是我没看出这个跟前面提的两个延迟参数作用的关系^_^","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547376900,"ip_address":"","comment_id":59397,"utype":1}],"discussion_count":5,"race_medal":0,"score":"113216512748","product_id":100020801,"comment_content":"总结下多线程复制的流程,有不对之处请老师指出:<br>双1,配置为logical_clock,假设有三个事务并发执行也已经执行完成(都处于prepare阶段)<br>1.三个事务把redo log从redo log buffer写到fs page cache中<br>2.把binlog_cache flush到binlog文件中,最先进入flush队列的为leader,<br>其它两个事务为follower.把组员编号以及组的编号写进binlog文件中(三个事务为同一组).<br>3.三个事务的redo log做fsync,binlog做fsync.<br>4.dump线程从binlog文件里把binlog event发送给从库<br>5.I&#47;O线程接收到binlog event,写到relay log中<br>6.sql thread读取relay log,判断出这三个事务是处于同一个组,<br>则把这三个事务的event打包发送给三个空闲的worker线程(如果有)并执行。<br><br>配置为writeset的多线程复制流程:<br>1.三个事务把redo log从redo log buffer写到fs page cache中<br>2.把binlog_cache flush到binlog文件中,根据表名、主键和唯一键(如果有)生成hash值(writeset),保存到hash表中<br>判断这三个事务的writeset是否有冲突,如果没有冲突,则视为同组,如果有冲突,则视为不同组.<br>并把把组员编号以及组的编号写进binlog文件中<br>(不过一个组的事务个数也不是无限大,由参数binlog_transaction_dependency_history_size决定组内最多事务数)<br>3.然后做redo log和binlog的fsync<br>4.dump线程从binlog文件里把binlog event发送给从库<br>5.I&#47;O线程接收到binlog event,写到relay log中<br>6.sql thread读取relay log,如果是同一个组的事务,则把事务分配到不同的worker线程去应用relay log.<br>不同组的事务,需要等到上一个组的事务全部执行完成,才能分配worker线程应用relay log.<br><br>老师我有几个问题想请教下:<br>1.在备库是单线程下,second_behind_master是通过计算T3-T1得到,<br>在多线程的情况下,是怎么计算出second_behind_master的值？用的是哪一个事务的时间戳?<br>2.多线程复制下,如果从库宕机了,是不是从库有一个记录表记录那些事务已经应用完成,<br>恢复的时候,只需要恢复未应用的事务.<br>3.binlog延迟sync的两个参数,是延迟已经flush未sync时间。意思是让事务组占用flush时间更长,<br>之后的事务有更多的时间,从binlog cache进入到flush队列,使得组员变多,起到从库并发的目的<br>因为我理解的是加入到组是在binlog cache flush到binlog文件之前做的,如果此时有事务正在flush,<br>未sync,则后面的事务必须等待。不知道理解得对不<br><br><br><br>","like_count":27,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436334,"discussion_content":"上面的描述部分，writeset的多线程复制流程里面，这段需要修改下：\n『2.把binlog_cache flush到binlog文件中,根据表名、主键和唯一键(如果有)生成hash值(writeset),保存到hash表中\n【判断这三个事务的writeset是否有冲突,如果没有冲突,则视为同组,如果有冲突,则视为不同组.\n并把把组员编号以及组的编号写进binlog文件中】』\n上面中括号这段要去掉，\n判断writeset之间是否可以并行这个逻辑，是在备库的coordinator线程做的。\n\n----\n1. 在多线程并发的时候，Seconds_behind_master很不准，后面会介绍别的判断方法；\n2. 是的,备库有记录，就是show slave status 里面的Relay_Log_File 和 Relay_Log_Pos 这两个值表示的，好问题\n3.  ”加入到组是在binlog cache flush到binlog文件之前做的,如果此时有事务正在flush,未sync,则后面的事务必须等待“ 这句话是对的，但是我没看出这个跟前面提的两个延迟参数作用的关系^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547376900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2389270,"avatar":"https://static001.geekbang.org/account/avatar/00/24/75/16/6e28bf17.jpg","nickname":"初晨","note":"","ucode":"C5D95D13E49127","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590312,"discussion_content":"你这样，显得我们很呆呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665650322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2252648,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5f/68/8e4407c7.jpg","nickname":"💡","note":"","ucode":"8AB762A8CDFEF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388871,"discussion_content":"请问下&#34;如果此时有事务正在flush,未sync,则后面的事务必须等待&#34; 怎么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629022414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1227366,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ba/66/7d9f45e7.jpg","nickname":"太空牛仔","note":"","ucode":"0205635C3854AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2252648,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5f/68/8e4407c7.jpg","nickname":"💡","note":"","ucode":"8AB762A8CDFEF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543529,"discussion_content":"我的理解是 binlog cache是按线程分配 也就是说事务在flush阶段是单线程处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641196141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":388871,"ip_address":""},"score":543529,"extra":""},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2252648,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5f/68/8e4407c7.jpg","nickname":"💡","note":"","ucode":"8AB762A8CDFEF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587832,"discussion_content":"文件只有一个而且是顺序写，加锁做同步，通过组提交将这个步骤拆分多个阶段，每个阶段独享一把锁，从而提高并发；有点netty不同handler各个线程异步串行的味道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663313036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":388871,"ip_address":"广东"},"score":587832,"extra":""}]}]},{"had_liked":false,"id":58649,"user_name":"慧鑫coming","can_delete":false,"product_type":"c1","uid":1324385,"ip_address":"","ucode":"7BAC9CA255630E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE4LYb3jrH63ZV98Zpc8DompwDgb1O3nffMoZCmiaibauRyEFv6NDNsST9RWxZExvMLMWb50zaanoQ/132","comment_is_top":false,"comment_ctime":1547166453,"is_pvip":false,"replies":[{"id":"21200","content":"好问题<br>不过这个是不可能的哈，对同一行的修改，第一个拿到行锁的事务还没提交前，另外两个会被行锁堵住的，这两个进入不了commit状态。所以这三个的commit_id不会相同的😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547176178,"ip_address":"","comment_id":58649,"utype":1}],"discussion_count":4,"race_medal":0,"score":"113216316149","product_id":100020801,"comment_content":"老师，有个问题，mariadb的并行策略，当同一组中有3个事务，它们都对同一行同一字段值进行更改，而它们的commit_id相同，可以在从库并行执行，那么3者的先后顺序是怎么保证不影响该行该字段的最终结果与主库一致？","like_count":26,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436150,"discussion_content":"好问题\n不过这个是不可能的哈，对同一行的修改，第一个拿到行锁的事务还没提交前，另外两个会被行锁堵住的，这两个进入不了commit状态。所以这三个的commit_id不会相同的😆","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1547176178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":3167302,"avatar":"","nickname":"Geek_eabafe","note":"","ucode":"4D94487320B33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588162,"discussion_content":"老师，这里的commit_id是组提交时，涉及的事务分配同一个commit_id吧，它受时间或者事务累计个数有关，就算后两个被堵住，后续执行完也是有可能一个组提交的吧？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663581283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":436150,"ip_address":"北京"},"score":588162,"extra":""},{"author":{"id":2389270,"avatar":"https://static001.geekbang.org/account/avatar/00/24/75/16/6e28bf17.jpg","nickname":"初晨","note":"","ucode":"C5D95D13E49127","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3167302,"avatar":"","nickname":"Geek_eabafe","note":"","ucode":"4D94487320B33B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590314,"discussion_content":"持有锁的事务提交时才会释放锁，即使设置了binlog组提交的参数，这里也是等待其他没有锁冲突的事务；一起执行的事务才拥有相同的commit_id；后续释放锁，等待锁的事务执行，这里是分配其他commit_id。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665651424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":588162,"ip_address":"陕西"},"score":590314,"extra":""}]},{"author":{"id":1667987,"avatar":"https://static001.geekbang.org/account/avatar/00/19/73/93/0a3a1e5b.jpg","nickname":"Ryan","note":"","ucode":"95BBBEE5B23878","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223894,"discussion_content":"我也在想 更新同一行 怎么可能同时获取到锁 拥有相同到commit_id","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586260693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74533,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1552230674,"is_pvip":false,"replies":[{"id":"28798","content":"👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1553339740,"ip_address":"","comment_id":74533,"utype":1}],"discussion_count":1,"race_medal":0,"score":"78861642002","product_id":100020801,"comment_content":"学习完这篇写下自己的理解，老师有空帮忙看下哦，备库一般会延迟分钟级别，比如主库压力比较大的时候，备库有可能会延迟小时级别，为此mysql官方提供了多种多线程复制策略<br>1、5.6基于库的多线程复制策略，使用hash数据库名作为key，value为多少个事务修改此数据库，使用hash来分配多线程，如果一个新事务加入进来，如果有冲突的hash，分配给此线程，如果没有冲突分配给空闲的线程，感觉实现的思路使用队列+线程池，如果线程池中没有空闲的线程，就在队列中增加事务，如果队列满，分发器阻塞，不解析binlog，分发器是生产者，线程池是消费者，基于库的多线程复制有如下优点①构造 hash 值的时候很快，只需要库名；线程的hash项也很少②binlog不需要强制指定row，statement也可以拿到库名。缺点：①如果只有一个库单线程复制，可以将其热点表分布到多个库中（不推荐使用），如果多个库的热点程度不同也会使其单线程复制。<br>2、基于表的多线程复制（非官方，老师实现），hash数据库名+表名作为key，value为多少个事务修改此数据表，同一个事务的多张表，在同一个线程进行处理，防止违反原子性，优点对同一个库多个热点表可以同时复制，多表负载效果很好，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，会使用单线程复制。<br>3、基于行的多线程复制，key必须是“库名 + 表名 + 唯一键的值“也需考虑唯一主键，防止唯一主键冲突（cpu的多线程调度，顺序不固定），value为修改前后key的次数，约束①表必须有主键②不能有外键③binlog格式row（表复制也一样）缺点：①大事务耗cpu②hash项多。优化可以设置阈值，如果事务修改的行大于特定值，使用单线程复制（老师自己实现）。mysql官网基于行的多线程复制，表示的是对于事务涉及更新的每一行，计算出每一行的 hash保存在writeset中，优点，①是有mysql主库写入binlog中，不需要解析 binlog 内容（event 里的行数据），节省计算量②binlog格式没要求，可以使用statement③无需扫描整个事务的binlog省内存，mysql5.7.22的多线程复制实现方式。<br>4、mysql5.7的多线程复制实现方式，借助于处于redo prepare到commit状态下的事务可以并行，因为执行器找引擎拿数据时，事务如果锁冲突会阻塞，无法到写redo log这一步，可以使用binlog故意延迟fsync，防止频繁写磁盘操作，不会丢失数据（redo prepar+完整的binlog事务才能提交，否则回滚），使其在备库多线程复制，主备延迟低，，但是这样有一点不好，语句的响应时间变长，感觉mysql官网故意延迟redo的fsync，在binlog write的时候（因为事务的binlog要写完整，时间较长），使其能批量提交，减少iops，感觉很巧妙","like_count":18,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442590,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553339740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61513,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1547711110,"is_pvip":false,"replies":[{"id":"21872","content":"可以这么理解，每个事务都有两个数字表示它在执行提交阶段的时间范围, 构成区间(c1, c2).<br>如果两个事务的区间有交集，就是可以并行的。<br>这里c1是事务启动的时候，当前系统里最大的commit_id；<br>一个事务提交的时候，commit_id+1.","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547740671,"ip_address":"","comment_id":61513,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48792351366","product_id":100020801,"comment_content":"老师您好：<br>关于COMMIT_ORDER的并行复制方案，从库根据 commit_id来判断“处于prepare和commit状态的事务”。这里我有个很大的疑惑：commit_id是什么时候加入到binlog的，又是在什么时候递增的？？<br>（<br>对于我这个问题的进一步解释：<br>既然commit_id是要被写入到binlog的，那么commit_id毫无疑问就是在write binlog阶段写入的。<br><br>我们知道redolog是组提交的，如果只是按照redolog的组提交方式生成commit_id，那么这个commit_id包含的并行事务数量并不够多！因为在binlog write阶段，又有事务进入到redolog prepare阶段，他们之间的commit_id是不一样的，但是他们是可以并行的。<br><br>所以commit_id什么时候递增？这个是非常关键的，我也很疑惑，commit_id到底是根据什么条件递增的？？<br>）","like_count":11,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436895,"discussion_content":"可以这么理解，每个事务都有两个数字表示它在执行提交阶段的时间范围, 构成区间(c1, c2).\n如果两个事务的区间有交集，就是可以并行的。\n这里c1是事务启动的时候，当前系统里最大的commit_id；\n一个事务提交的时候，commit_id+1.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547740671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348326,"discussion_content":"c2 是什么 ？ 是 ，commit_id+1？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612513278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65060,"user_name":"J!","can_delete":false,"product_type":"c1","uid":1305003,"ip_address":"","ucode":"71C946119B59D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/e9/ab/37903736.jpg","comment_is_top":false,"comment_ctime":1549015062,"is_pvip":false,"replies":[{"id":"23065","content":"进入prepare 的时候就给这个事务分配 commitid，这个commitid就是当前系统最大的一个commitid","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549038647,"ip_address":"","comment_id":65060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35908753430","product_id":100020801,"comment_content":"同时处于 prepare 状态的事务，在备库执行时是可以并行.复制的，是这个prepare 就可以生成了改组的commited Id吗<br><br>极客时间版权所有: https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;77083","like_count":8,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438303,"discussion_content":"进入prepare 的时候就给这个事务分配 commitid，这个commitid就是当前系统最大的一个commitid","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549038647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58864,"user_name":"生活在别处","can_delete":false,"product_type":"c1","uid":1096441,"ip_address":"","ucode":"E7F60026F2737A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/f9/351e4fc0.jpg","comment_is_top":false,"comment_ctime":1547216560,"is_pvip":false,"replies":[{"id":"21309","content":"是说，不需要解析出binlog里面的行信息。你提的对，我加个说明进去","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547228396,"ip_address":"","comment_id":58864,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35906954928","product_id":100020801,"comment_content":"writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容，节省了很多计算量；矛盾吧？不解析binlog怎么知道是同一个写集合？","like_count":8,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436238,"discussion_content":"是说，不需要解析出binlog里面的行信息。你提的对，我加个说明进去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547228396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2166073,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k3YD3y3BzGDSdrwRJyJY4BXsNJibfM4uzOdDVKIAlFApR2FZCLg2ibrZtJ4vuahA3LHLW9GKzH5CMGqCDhWjhZqg/132","nickname":"戒酒的李白","note":"","ucode":"744E1A22761647","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409229,"discussion_content":"严谨","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635396354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363110,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cc/a6/b0490e97.jpg","nickname":"Tsong","note":"","ucode":"CF0259824E6D53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294670,"discussion_content":"也是依靠  last_committed来判断得。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595952649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75270,"user_name":"轻歌赋","can_delete":false,"product_type":"c1","uid":1251574,"ip_address":"","ucode":"22F62446208805","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg","comment_is_top":false,"comment_ctime":1552371984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27322175760","product_id":100020801,"comment_content":"1，3会导致备库仍然单线程执行<br>1是因为没有任何事务时间线是一致的<br>3是因为单线程执行的事务的先后关系必然不会有重叠的情况，在多线程上面为了保证顺序自然只能一个个过，就成了单线程","like_count":6},{"had_liked":false,"id":63841,"user_name":"牛牛","can_delete":false,"product_type":"c1","uid":1194626,"ip_address":"","ucode":"CFCE68B4F92209","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg","comment_is_top":false,"comment_ctime":1548552438,"is_pvip":false,"replies":[{"id":"23032","content":"1. delete 300条 ， sleep 500ms已经是很克制的操作了，单线程吗？如果还是单线程，那延迟应该不是这个操作导致的<br><br>2. 这都是很小的压力，不会读取慢才对","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549004939,"ip_address":"","comment_id":63841,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27318356214","product_id":100020801,"comment_content":"老师、请教两个问题～<br>1. 我在job里按主键删除线上表数据的时候、造成了主从延迟、delete from table where id in...<br><br>id是主键、每次delete 300条、sleep 500ms、这种延迟可能是什么造成的呢？300条应该不算大事务？还是说快速的数据删除导致了索引重建？<br><br>2. 如果一个表快速往里写数据、每次300条、sleep 1s、这个库上的读取会慢吗？<br><br>多谢老师🙏～","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437730,"discussion_content":"1. delete 300条 ， sleep 500ms已经是很克制的操作了，单线程吗？如果还是单线程，那延迟应该不是这个操作导致的\n\n2. 这都是很小的压力，不会读取慢才对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549004939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587834,"discussion_content":"单线程没必要sleep吧。太克制了....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663314491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85046,"user_name":"xy🥝","can_delete":false,"product_type":"c1","uid":1029430,"ip_address":"","ucode":"DA1EC0789071F0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/36/d444d19e.jpg","comment_is_top":false,"comment_ctime":1554966530,"is_pvip":false,"replies":[{"id":"31598","content":"主要还是从库的apply线程不够快。。","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1555724968,"ip_address":"","comment_id":85046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23029803010","product_id":100020801,"comment_content":"林老师好，问一个最近遇到的问题。有一台5.7版本的MySQL数据库，在开启多线程复制（4）的时候，跑了两天后，然后三个从库同时卡住了，按照MySQL 1864报错，手动调大了三个从库slave_pending_jobs_size_max的参数之后就恢复了，之前在5.6上没有遇到过这个问题。这里的原理还没想明白，官档上在这里描述的不是很详细，求指导一下。","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446540,"discussion_content":"主要还是从库的apply线程不够快。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555724968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68128,"user_name":"胡楚坚","can_delete":false,"product_type":"c1","uid":1120212,"ip_address":"","ucode":"225883EDF35BED","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/d4/d7a4e6f5.jpg","comment_is_top":false,"comment_ctime":1550420863,"is_pvip":false,"replies":[{"id":"24132","content":"一个事务只能发给一个worker的，<br><br>长杰评论的那个问题，讨论的是如果分成两个事务，然后约定一起提交，这个是做不到的（或者说实现起来很复杂）","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550452752,"ip_address":"","comment_id":68128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18730290047","product_id":100020801,"comment_content":"老师，关于留言板中置顶留言长杰的问题：一个事务更新了两张表的数据，然后两个更新语句分给了两个worker。这问题我有点不明白，因为看完专栏我的认知是一个事务只会给一个worker执行，这样就不会有先后commit问题。请问老师是我看漏了什么吗？这种情况应该会出现在哪种策略？","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439528,"discussion_content":"一个事务只能发给一个worker的，\n\n长杰评论的那个问题，讨论的是如果分成两个事务，然后约定一起提交，这个是做不到的（或者说实现起来很复杂）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550452752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129551,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1567153272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452055160","product_id":100020801,"comment_content":"说实话，这一篇文章我在按表复制和按行复制这一段还是清晰的，但是到了并行复制就不是很清晰了。在MySQL5.7.22新增了binlog-transaction-dependency-tracking，用来控制是都使用并行复制策略，分为commit_order，writeset和writeset_session。如果需要备库赶快追上主库，那么就需要更快的并行复制策略，在这里我选择设置为writeset，为什么，因为writeset不需要解析binlog的内容，直接并发执行处理冲突，而commit_order需要在prepare阶段和commit阶段判断是否可以并行，这样会退化成单线程，再并行复制，writeset_session还要在writeset的基础上多一个约束，要保证先后顺序，保证过先后顺序就会退化成单线程！","like_count":3},{"had_liked":false,"id":65059,"user_name":"J!","can_delete":false,"product_type":"c1","uid":1305003,"ip_address":"","ucode":"71C946119B59D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/e9/ab/37903736.jpg","comment_is_top":false,"comment_ctime":1549015007,"is_pvip":false,"replies":[{"id":"23064","content":"事务提交的时候","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549038415,"ip_address":"","comment_id":65059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433916895","product_id":100020801,"comment_content":"5.7 版本的基于组提交的并行复制。last_commitid 是在什么时候生成的？","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438302,"discussion_content":"事务提交的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549038415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65051,"user_name":"alias cd=rm -rf","can_delete":false,"product_type":"c1","uid":1318325,"ip_address":"","ucode":"E7B27D76305B75","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/b5/971261fd.jpg","comment_is_top":false,"comment_ctime":1549012800,"is_pvip":false,"replies":[{"id":"23068","content":"对的，👍<br><br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549038887,"ip_address":"","comment_id":65051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433914688","product_id":100020801,"comment_content":"老师您好：<br><br>思考题答案的猜测：建议采用 WRITESET。<br>WRITESET_SESSION：因为主库是单线程插入，如果采用WRITESET_SESSION，那么会退化成单线程主从复制。<br>COMMIT_ORDER：因为是追历史数据，所以会退化成单线程。","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438297,"discussion_content":"对的，👍\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549038887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63317,"user_name":"IceGeek17","can_delete":false,"product_type":"c1","uid":1103101,"ip_address":"","ucode":"1B42D7260449B4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/fd/43802282.jpg","comment_is_top":false,"comment_ctime":1548321027,"is_pvip":false,"replies":[{"id":"22414","content":"看完分享你的心得哈 👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548322400,"ip_address":"","comment_id":63317,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433222915","product_id":100020801,"comment_content":"好文，总结对比不同的并行策略，讲的深入浅出，看完豁然开朗。有看源代码的冲动。","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437545,"discussion_content":"看完分享你的心得哈 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548322400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61506,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1547709338,"is_pvip":false,"replies":[{"id":"21861","content":"我也建议尽量少使用外键，我自己理解的几个原因吧<br>1. 这个关系应该维护在开发系统的逻辑中，放在数据库里面，比较隐蔽，容易忘记<br>2. 外键约束可能会导致有些更新失败<br>3. 外键约束（尤其是级联更新）容易出现非预期的结果","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547709781,"ip_address":"","comment_id":61506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14432611226","product_id":100020801,"comment_content":"老师您好：<br>今天的内容中写到：“外键约束”会导致并行复制退化为单线程。<br>这个地方我就突然联想到，在业务中，类似于“外键”这种关系是一定存在的。但是一般在设计表的时候，比如：表A的某个唯一键是表B的外键。并不会真正”显示”的在数据库表中创建外键关系。（查询的时候，查询出A的这个唯一键，然后再根据这个唯一键查询表B的数据，并不会有真正的外键关系，一次性查出所有关联数据）<br>这是为什么呢？","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436890,"discussion_content":"我也建议尽量少使用外键，我自己理解的几个原因吧\n1. 这个关系应该维护在开发系统的逻辑中，放在数据库里面，比较隐蔽，容易忘记\n2. 外键约束可能会导致有些更新失败\n3. 外键约束（尤其是级联更新）容易出现非预期的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547709781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58938,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1547257644,"is_pvip":false,"replies":[{"id":"21347","content":"啊 不是不是<br>备库并行复制跟semi-sync没关系的。<br>并不是说“让所有的事务处于prepare状态，然后中间要等备库执行”<br><br><br>“处于prepare状态的事务，可以并行” 在实现上是，主库在写binlog的时候会给这些binlog里面记commit_id和sequence_no，来说明事务之间在主库上并行prepare的状态；<br><br>备库是通过解析binlog拿到 commit_id 和 sequence_no，来决定要怎么并发的。<br><br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547269063,"ip_address":"","comment_id":58938,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14432159532","product_id":100020801,"comment_content":"MySQL 5.7并行复制那里没有看懂。问题有点多请见谅哈。<br>文中提到处于prepare状态的事务，可以并行。<br>那说明，主库commit之前，就要把binlog同步到从库了吧？ (问题1)<br>还提到了prepare状态和commit状态的事务，可以并行。<br>我想象中的同步的步骤是，一组事务（其中有还没commit的，也有已经commit的）的binlog被从库获取到，并行执行sql的同时再后去下一组事务。但下一组事务在上一组执行完之前，不会执行。所以就是这样的流程 ： 同步binlog-&gt;执行，同时同步新binlog-&gt;等待执行完-&gt;执行，同时同步新binlog。<br>是这样吗（问题2）<br>可为什么从库会看到prepare和commit的两种事务，而不全是prepared？(问题3)<br>隐约觉得这似乎涉及到了异步&#47;半同步，AFTER_COMMIT&#47;AFTER_SYNC的内容了，后面会有详细介绍嘛？(问题4)<br><br>","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436253,"discussion_content":"啊 不是不是\n备库并行复制跟semi-sync没关系的。\n并不是说“让所有的事务处于prepare状态，然后中间要等备库执行”\n\n\n“处于prepare状态的事务，可以并行” 在实现上是，主库在写binlog的时候会给这些binlog里面记commit_id和sequence_no，来说明事务之间在主库上并行prepare的状态；\n\n备库是通过解析binlog拿到 commit_id 和 sequence_no，来决定要怎么并发的。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547269063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537753,"discussion_content":"其实意思就是类似mariadb的并行策略。如果mysql没有延迟binlog sync的数量，那么，一次的组提交可能事务就比较少。但是在从库并行执行的时候，还是要一组执行完再并行下一组。所以，如果主库延迟binlog sync，那么每次组提交的事务就更多，在从库符合并行条件的事务数量也变多了，这样即使还是一组并行完，在并行下一组的策略。效果、性能都会比mariadb实现的更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639152831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171731,"user_name":"longhaiqwe","can_delete":false,"product_type":"c1","uid":1061318,"ip_address":"","ucode":"A5AEE950A7AF35","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/c6/27225119.jpg","comment_is_top":false,"comment_ctime":1579002540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168937132","product_id":100020801,"comment_content":"&quot;能够在同一组里提交的事务，一定不会修改同一行&quot;<br>这句话不是很理解，如果innodb_flush_log_at_trx_commit=0的话，那么redo log buffer里面就可能会有很多已经commit了的事务，那么它们有可能会修改同一行啊？<br>请老师释疑问，谢谢","like_count":2},{"had_liked":false,"id":115469,"user_name":"miracle","can_delete":false,"product_type":"c1","uid":1276137,"ip_address":"","ucode":"FD7074F1062AE9","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg","comment_is_top":false,"comment_ctime":1563594810,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10153529402","product_id":100020801,"comment_content":"请教一个问题，看了三遍还是没明白 文中说的 MariaDB 的并行复制策略 主库上可以一组事务 committing 的同时另一组事务在 running 为什么在从库上就必须要等到 committing 结束之后另一组才能 running呢 希望老师有空能解答下这个问题","like_count":2,"discussions":[{"author":{"id":1458200,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/18/cc3804e2.jpg","nickname":"沈洪彬","note":"","ucode":"F9911236D0BA1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100435,"discussion_content":"主库上是锁控制并发，所以主上可能另外事物只是等待锁。\n 从库上是通过分发控制并发，策略是执行完一组之后才会执行下一组。所以从库上等待锁之前的步骤也没做，比如:加载数据到buffer_pool 之类的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577259999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1276137,"avatar":"https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg","nickname":"miracle","note":"","ucode":"FD7074F1062AE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1458200,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/18/cc3804e2.jpg","nickname":"沈洪彬","note":"","ucode":"F9911236D0BA1C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101660,"discussion_content":"所以从库上等待锁之前的步骤也没做，比如:加载数据到buffer_pool 之类的。\n这些没做是为了加速串行执行效率吗还是？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577288999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100435,"ip_address":""},"score":101660,"extra":""}]}]},{"had_liked":false,"id":110388,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1562246982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10152181574","product_id":100020801,"comment_content":"原文：<br>这时候主库对表 t 做了一个加字段操作，即使这个表很小，这个 DDL 在备库应用的时候也会被堵住，也〖不能〗看到这个现象。<br><br>老师，应该是也能看到这个现象吧","like_count":2},{"had_liked":false,"id":59043,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1547285460,"is_pvip":false,"replies":[{"id":"21370","content":"serializable隔离级别确实用得很少（我没有见过在生产上使用的哈）","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547293084,"ip_address":"","comment_id":59043,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10137220052","product_id":100020801,"comment_content":"丁老师你好，问个题外问题，mysql已经通过gap锁解决了在rr级别下的幻读问题，那么serializable隔离级别目前还有什么用途，一般文章上说的，serializable 主要是为了解决幻读，谢谢回答。","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436282,"discussion_content":"serializable隔离级别确实用得很少（我没有见过在生产上使用的哈）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547293084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1798004,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/74/a8567e21.jpg","nickname":"awesome","note":"","ucode":"46175C176DF410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582814,"discussion_content":"在RR隔离级别下，如果一个事务从头到尾就只有快照读，那么MVCC解决了幻读的问题。如果一个事务从头到尾只有当前读，那么通过间隙锁和临建锁也解决了幻读问题。但是如果一个事务既有快照读也有当前读，那么MVCC就解决不了幻读问题。这时候serializable登场了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659688187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293877,"avatar":"https://static001.geekbang.org/account/avatar/00/13/be/35/dd79037e.jpg","nickname":"a...Z","note":"","ucode":"5A5A44903785FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":120913,"discussion_content":"gap 无法完全解决rr级别的幻读问题，只是解决了当前读和当前读到事务提交时这个过程的幻读问题啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578304393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1293877,"avatar":"https://static001.geekbang.org/account/avatar/00/13/be/35/dd79037e.jpg","nickname":"a...Z","note":"","ucode":"5A5A44903785FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167339,"discussion_content":"不是吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581478704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":120913,"ip_address":""},"score":167339,"extra":""}]}]},{"had_liked":false,"id":58859,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1547215372,"is_pvip":false,"replies":[{"id":"21310","content":"跟最开始介绍的策略一样，update的writeset里， 每一个唯一索引就对应两个hash值<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547233226,"ip_address":"","comment_id":58859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10137149964","product_id":100020801,"comment_content":"文中提到：5.7.22的并行复制中，对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。这是不是只适用于row格式的binlog啊？因为update 最终也是拆成了delete和insert。。。另外，如果是statement格式的binlog，那么唯一索引的update语句应该也需要多增加一个hash值了吧？","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436236,"discussion_content":"跟最开始介绍的策略一样，update的writeset里， 每一个唯一索引就对应两个hash值\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547233226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58685,"user_name":"你有资格吗？","can_delete":false,"product_type":"c1","uid":1233534,"ip_address":"","ucode":"4758C5A190BABB","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/7e/bd8c372a.jpg","comment_is_top":false,"comment_ctime":1547174994,"is_pvip":false,"replies":[{"id":"21215","content":"看到你的用户名，我吓了一跳😅","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547178599,"ip_address":"","comment_id":58685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10137109586","product_id":100020801,"comment_content":"打卡","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436172,"discussion_content":"看到你的用户名，我吓了一跳😅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547178599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260994,"user_name":"吾乃大神","can_delete":false,"product_type":"c1","uid":1320247,"ip_address":"","ucode":"8D14359AD04A09","user_header":"https://static001.geekbang.org/account/avatar/00/14/25/37/fe05351b.jpg","comment_is_top":false,"comment_ctime":1605169581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5900136877","product_id":100020801,"comment_content":"学习老师的专栏真是久旱遇甘露，满满的全是干货。每看一篇都是收获，对之前碰到的MySQL问题都是醍醐灌顶解析，突然觉得CRUD这么多年真的全CRUD了。同时也学了其他的专栏，没有对比就没有伤害，这就最好专栏没有之一。","like_count":1},{"had_liked":false,"id":181520,"user_name":"悠悠小竹子","can_delete":false,"product_type":"c1","uid":1061786,"ip_address":"","ucode":"A5E6731D28EBF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/9a/a323b2f1.jpg","comment_is_top":false,"comment_ctime":1582554241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877521537","product_id":100020801,"comment_content":"对于热点行的更新有什么好的解决方案吗？","like_count":1},{"had_liked":false,"id":120324,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1564830931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859798227","product_id":100020801,"comment_content":"原理基本能明白，不过细节基本都在刷新自己的认知，万幸遇到如此牛逼的老师。<br>一个生产的快一个消费的慢，延迟何止几个小时，恐怕此生都赶不上。","like_count":1},{"had_liked":false,"id":83665,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1554693416,"is_pvip":false,"replies":[{"id":"32455","content":"这里没有矛盾哈。图6中，画在同一组的，就表示可以并行执行。也就是说，图6中，123是并行执行，然后456并行，然后789并行","user_name":"作者回复","user_name_real":"Jing～","uid":"1059377","ctime":1556593738,"ip_address":"","comment_id":83665,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5849660712","product_id":100020801,"comment_content":"老师 我觉得图6好像有问题啊，在图5中,主库trx1,trx2,trx3是同一组里面的事务，他们拥有相同的commit_id，他们到备库里面需要被分到不同的worker里面去执行，但是图6里面，trx1,trx2,trx3还依然在一组里面？这是不是矛盾了？","like_count":1,"discussions":[{"author":{"id":1059377,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2a/31/9edbf8a6.jpg","nickname":"贾静","note":"","ucode":"081E70CC01F6B8","race_medal":0,"user_type":8,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446120,"discussion_content":"这里没有矛盾哈。图6中，画在同一组的，就表示可以并行执行。也就是说，图6中，123是并行执行，然后456并行，然后789并行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556593738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18974,"discussion_content":"既然能在同一组commit，就是说明在主库这几个事务彼此没有冲突，然后从库重放时分配到不同worker里是再自然不过的事情了，本来就是一组的事务就要分配到不同worker....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569123850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64770,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1548903786,"is_pvip":false,"replies":[{"id":"22943","content":"这个描述应该是主要考虑在有主键的时候，可以通过row里面的信息取出主键直接定位记录。<br><br>你说的这些其实劣势确实也是存在的 😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548935091,"ip_address":"","comment_id":64770,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5843871082","product_id":100020801,"comment_content":"Furthermore, given that changes are propagated and applied in row-based format, this means that they are received in an optimized and compact format, and likely reducing the number of IO operations required when compared to the originating member.<br>这个是官档上对MGR的一段解读，我的疑问是：<br>为何row-base replication在从库回放时会节省大量IO？<br>候选答案：<br>1、省去了sql解析，直接调用do_command<br>2、？？<br>可是row复制有其他可能存在的劣势，比如单个大dml会被解析成多个dml_event进行重放，万一该表没有主键或唯一索引，只能采用二级索引或者全表扫描(开启hash_scan也可以)，所以，官档上直接说会减少大量IO是不是有点太武断了","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438168,"discussion_content":"这个描述应该是主要考虑在有主键的时候，可以通过row里面的信息取出主键直接定位记录。\n\n你说的这些其实劣势确实也是存在的 😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548935091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2439786,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3a/6a/61645df6.jpg","nickname":"小唐Eden","note":"","ucode":"13644850F7BEC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590333,"discussion_content":"MGR强制约束表中必须包含主键","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665663420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61089,"user_name":"亢星东","can_delete":false,"product_type":"c1","uid":1303322,"ip_address":"","ucode":"5E4063E83B2BB9","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/1a/061e77b6.jpg","comment_is_top":false,"comment_ctime":1547618513,"is_pvip":false,"replies":[{"id":"21760","content":"这个是要结合业务的，比如要删除100万行，改成100个事务，每个事务删除1万行，这样的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547621976,"ip_address":"","comment_id":61089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842585809","product_id":100020801,"comment_content":"老师好，如何将大事务拆成小事务","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436739,"discussion_content":"这个是要结合业务的，比如要删除100万行，改成100个事务，每个事务删除1万行，这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547621976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60937,"user_name":"道","can_delete":false,"product_type":"c1","uid":1100869,"ip_address":"","ucode":"B17CA7372C21C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/45/73a0f7f8.jpg","comment_is_top":false,"comment_ctime":1547597013,"is_pvip":false,"replies":[{"id":"21730","content":"因为这两个worker没办法“约好一起提交”，这个是属于两个线程了<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547605220,"ip_address":"","comment_id":60937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842564309","product_id":100020801,"comment_content":"老师，这段不太理解：“举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新语句被分到不同 worker 的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。”备库上的查询属于另外一个事务，按照可重复读隔离级别，这个查询不应该看到另外一个事务“更新了一半的结果”啊。即便是这两条更新语句被分到不同 worker ，也应该保证事务的原子性啊，难道是技术上有困难吗？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436674,"discussion_content":"因为这两个worker没办法“约好一起提交”，这个是属于两个线程了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547605220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60582,"user_name":"天使之剑","can_delete":false,"product_type":"c1","uid":1306842,"ip_address":"","ucode":"69B2D109AE282F","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/da/74bbb9e6.jpg","comment_is_top":false,"comment_ctime":1547516007,"is_pvip":false,"replies":[{"id":"21619","content":"还是用gtid集合判断吧😓","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547526363,"ip_address":"","comment_id":60582,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842483303","product_id":100020801,"comment_content":"mysql 5.7并行复制有一个bug，是seconds_behind_master记录并不准确，显示为0，但是实际并不为0，能不能解释一下为什么？并且有没有其他地方可以读到准确的值呢","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436550,"discussion_content":"还是用gtid集合判断吧😓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547526363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58739,"user_name":"锅子","can_delete":false,"product_type":"c1","uid":1323048,"ip_address":"","ucode":"4A9143AFB07FF2","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/28/6e019a7a.jpg","comment_is_top":false,"comment_ctime":1547187403,"is_pvip":false,"replies":[{"id":"21229","content":"那就是以slave_parallel_type=database为准了","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547190275,"ip_address":"","comment_id":58739,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842154699","product_id":100020801,"comment_content":"老师好，由一个疑问，在MySQL5.7.22中，slave_parallel_type=database，而binlog_transaction_dependency_tracking=commit_order，这2个参数会不会冲突呢？如果会以哪个策略为准呢？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436194,"discussion_content":"那就是以slave_parallel_type=database为准了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547190275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58705,"user_name":"倪大人","can_delete":false,"product_type":"c1","uid":1193052,"ip_address":"","ucode":"4798D69F3E86FB","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/5c/6b4757a0.jpg","comment_is_top":false,"comment_ctime":1547179552,"is_pvip":false,"replies":[{"id":"21224","content":"我也没想到有什么场景必须得用WRITESET_SESSION","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547180339,"ip_address":"","comment_id":58705,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5842146848","product_id":100020801,"comment_content":"啊突然发现前面理解错了<br>求问下老师，WRITESET_SESSION什么时候会需要呀，就是什么时候需要“主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序”","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436180,"discussion_content":"我也没想到有什么场景必须得用WRITESET_SESSION","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547180339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1458200,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/18/cc3804e2.jpg","nickname":"沈洪彬","note":"","ucode":"F9911236D0BA1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100439,"discussion_content":"可能有一些业务需要，可能代码没写到一个事物里面，但是程序执行的之后顺序执行的。必须向更新a表状态，然后更新b表状态之类的。不按照这个可能会有瞬间状态不对或者报错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577260738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359570,"user_name":"初晨","can_delete":false,"product_type":"c1","uid":2389270,"ip_address":"陕西","ucode":"C5D95D13E49127","user_header":"https://static001.geekbang.org/account/avatar/00/24/75/16/6e28bf17.jpg","comment_is_top":false,"comment_ctime":1665648737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665648737","product_id":100020801,"comment_content":"思考题：","like_count":0},{"had_liked":false,"id":347172,"user_name":"LWD","can_delete":false,"product_type":"c1","uid":1986739,"ip_address":"","ucode":"DDA444DB113C01","user_header":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","comment_is_top":false,"comment_ctime":1653791986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653791986","product_id":100020801,"comment_content":"按行分发策略有bug。实际使用会有很多问题。比如间隙锁的顺序要怎么保证？A锁住区间[1,2,3]。B插入2被阻塞住。结果从库解析的时候先执行B然后执行A。此时就会有问题。。。。除非解析的时候有专门对这种情况进行处理","like_count":0},{"had_liked":false,"id":342290,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1650172851,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650172851","product_id":100020801,"comment_content":"mysql 5.6版本之前 仅支持从库单线程处理binlog日志，写速度低于主库的写速度，容易导致主从延迟。<br>mysql 5.6版本及之后 开始支持从库的多线程并行复制能力。但多线程执行复制也是有条件限制的。<br>1.同一个事务中的语句必须在一个线程中执行。<br>2.不同事务中存在数据冲突的语句也必须在一个线程中执行。<br>官方提供了 将sql按库分到不同线程执行的方式 以及  利用redo log 组提交 (group commit) 优化的特性将主库中可以并行的语句在从库中并行执行。","like_count":0},{"had_liked":false,"id":339190,"user_name":"张福顺","can_delete":false,"product_type":"c1","uid":1213423,"ip_address":"","ucode":"42EC3D0CF544AF","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/ef/7b34560d.jpg","comment_is_top":false,"comment_ctime":1647960858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647960858","product_id":100020801,"comment_content":"老师，请问5.7的并行复制如果有DDL语句会使用onlineDDL嘛，这么理解是否可以通过开启并行复制降低因为DDL引起的主从延迟","like_count":0},{"had_liked":false,"id":330426,"user_name":"mushan","can_delete":false,"product_type":"c1","uid":2756810,"ip_address":"","ucode":"B57CCB0A1FA653","user_header":"","comment_is_top":false,"comment_ctime":1641974548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641974548","product_id":100020801,"comment_content":"“MariaDB 这个策略的核心，是“所有处于 commit”状态的事务可以并行”<br>“MySQL 5.7 并行复制策略的思想是：同时处于 prepare 状态的事务，在备库执行时是可以并行的；处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的”<br>MariaDB和5.7并行复制策略的这两者的区别还是没太明白，在实现上不都是备库根据commit id来确定是否可以分发到不同worker并行应用吗？难道只是binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count延迟fsync的优化？","like_count":0},{"had_liked":false,"id":329164,"user_name":"清风","can_delete":false,"product_type":"c1","uid":2317711,"ip_address":"","ucode":"62490AD4F949BB","user_header":"https://static001.geekbang.org/account/avatar/00/23/5d/8f/498d9ea5.jpg","comment_is_top":false,"comment_ctime":1641191904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641191904","product_id":100020801,"comment_content":"主库单线程，因此COMMIT_ORDER策略下，串行执行事务和更新redo log，也就没有其他redo log同时为prepare状态的事务，只有一个worker在工作，备库退化为单线程；WRITESET策略，其对比更新的事务是否存在冲突的行决定事务可以并发执行，因此不受主库单线程影响，备库可以并行复制；WRITE_SESSION策略，新增执行顺序约束，由于主库单线程导致事务串行执行，因此备库也会退还为单线程","like_count":0},{"had_liked":false,"id":324989,"user_name":"Dunk","can_delete":false,"product_type":"c1","uid":1691447,"ip_address":"","ucode":"A8F5AB98382719","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","comment_is_top":false,"comment_ctime":1638772445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638772445","product_id":100020801,"comment_content":"## 解答思路<br><br>单线程插入也就意味着不存在多个并发事务的redolog处于prepare或commit状态，如果使用`COMMIT_ORDER`参数来进行快速复制就得不偿失，达不到快速并行复制的效果；而对于`WRITESET`参数来说，这是一种基于按行分发的并行复制策略，这种方式所得到的并行度是比较好的；如果使用`WRITESET_SESSION`参数因为多加了一个约束条件也就意味着这种方式的并行复制策略的并发度是有一定的损失的。综合上述分析，针对这个问题采用`WRITESET`参数的并发复制策略是更好一些的。<br><br>采用`COMMIT_ORDER`的方案会出现的现象是备库永远不会追上主库，如果要保持两者的一致性，这必须停掉服务来进行同步操作，然而这样做是极其不可取的。<br><br>采用`WRITE_SESSION`的方案有点类似于`COMMIT_ORDER`的，这种方案也是会产生永远无法追上主库的问题。<br>以上为个人拙见！","like_count":0},{"had_liked":false,"id":322144,"user_name":"山鬼谣","can_delete":false,"product_type":"c1","uid":1543162,"ip_address":"","ucode":"E25F498B85A01B","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","comment_is_top":false,"comment_ctime":1637205302,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1637205302","product_id":100020801,"comment_content":"“能够在同一组里提交的事务，一定不会修改同一行”为什么吗？评论里似乎都没有这个疑问？看这文章的都是DBA吗？作为开发，不是很理解这句话~ <br>先别说同组了，我一个事务里面，执行两个update来修改同一行，这种算不算修改了同一行？","like_count":0,"discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537754,"discussion_content":"还记得binlog之前还有一个binlog cache吗？binlog cache是每个线程独有的，它们最终会写到同一个binlog文件。在组提交的时候，每个线程都有自己的 binlog cache，主库能并发线程，在binlog组提交里，包含的就是通过了锁冲突的事务。\n组提交包含多个事务，这些事务会有锁冲突吗？显然不会。如果两个事务有锁冲突，那其中之一个事务，肯定要等另一个事务提交了，释放了锁之后才执行。那么，他们就不可能在同一个组里了。\n“同一个事务多次update同一行。”和“能够在同一组里提交的事务，一定不会修改同一行”这两句话并不矛盾。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639153726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310893,"user_name":"廖晶₁₃₉₀₈₄₈₆₁₄₂","can_delete":false,"product_type":"c1","uid":2070832,"ip_address":"","ucode":"2331549830E0DE","user_header":"https://static001.geekbang.org/account/avatar/00/1f/99/30/9e542e5a.jpg","comment_is_top":false,"comment_ctime":1630974507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630974507","product_id":100020801,"comment_content":"老师，MariaDB 的并行复制策略，怎么判断一组全部已经完成呢？","like_count":0},{"had_liked":false,"id":298402,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1624084069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624084069","product_id":100020801,"comment_content":"老师，这个有什么用吗？感觉只需要唯一索引就够了。只要知道当前正在修改哪行就好了啊。下一个事务在修改相同行的时候，如果冲突就进入与之冲突的work。<br><br>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。","like_count":0},{"had_liked":false,"id":295502,"user_name":"余光强","can_delete":false,"product_type":"c1","uid":2634522,"ip_address":"","ucode":"54FE11650387B6","user_header":"https://static001.geekbang.org/account/avatar/00/28/33/1a/bc405145.jpg","comment_is_top":false,"comment_ctime":1622453135,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1622453135","product_id":100020801,"comment_content":"老师，如果为了解决主从延迟，通过中间件转发，主库和从库同时收到一样row数据，主库和从库同时收到，就不用binlog同步","like_count":0,"discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537755,"discussion_content":"这个保证不了主从一致啊。你将请求通过中间件分发，保证不了哪个服务器成功，哪个服务器失败。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639153975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283362,"user_name":"Murphy","can_delete":false,"product_type":"c1","uid":1652747,"ip_address":"","ucode":"094C807F1DFA33","user_header":"https://static001.geekbang.org/account/avatar/00/19/38/0b/5070e8df.jpg","comment_is_top":false,"comment_ctime":1615729190,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1615729190","product_id":100020801,"comment_content":"开启并行复制后，从库上同一个表的插入也不是有序的了？那主键是不是就变成随机写了？","like_count":0,"discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537756,"discussion_content":"有可能。不过如果是row格式的binlog，它记录了主库数据行的完整变化，所以，所有字段的变化都是一致的。但，随机写还是有可能发生的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639154075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274388,"user_name":"贺子","can_delete":false,"product_type":"c1","uid":2076283,"ip_address":"","ucode":"A64DC9D9CF7CCD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ae/7b/47200692.jpg","comment_is_top":false,"comment_ctime":1610986225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610986225","product_id":100020801,"comment_content":"老师请问，5.7.22以后，设置了writeset的方式并行复制，那么没交集的事务是允许并行复制的，但是不一定会并行复制对吧？那么从库是怎么具体来规划并行复制呢？是单位时间内来判断中继日志中所有可以并行执行的事务，然后并行执行吗？","like_count":0},{"had_liked":false,"id":255845,"user_name":"tank","can_delete":false,"product_type":"c1","uid":1691436,"ip_address":"","ucode":"256553A4C09ABF","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/2c/be133cdf.jpg","comment_is_top":false,"comment_ctime":1603442442,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603442442","product_id":100020801,"comment_content":"老师，为什么我RR&#47;RC隔离级别测试同一个事务2次更新同一行都成功了，是同一个commit_id(xid)?<br>那这样不是和同一组可以并行复制冲突了吗?<br><br>CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);<br><br>root@localhost:[test] 23:29:34&gt;begin;<br>root@localhost:[test] 23:29:36&gt;update t_iso set d=d+1 where id=0;<br>root@localhost:[test] 23:29:41&gt;update t_iso set d=d+2 where id=0;<br>root@localhost:[test] 23:29:44&gt;commit;<br>Query OK, 0 rows affected (0.00 sec)<br>由于无法截图，show binlog events in &#39;binlog.000130&#39; from 2014116 limit 9; 结果如下：<br>root@localhost:[test] 23:54:39&gt;show binlog events in &#39;binlog.000130&#39; from 2014116 limit 9;<br>binlog.000130 | 2014116 | Gtid | 3306 | 2014181 | SET @@SESSION.GTID_NEXT= &#39;c5714948-edc3-11ea-990b-000c29f0ee9b:55954&#39;<br>binlog.000130 | 2014181 | Query | 3306 | 2014258 | BEGIN<br>binlog.000130 | 2014258 | Rows_query | 3306 | 2014315 | # update t_iso set d=d+1 where id=0<br>binlog.000130 | 2014484 | Table_map | 3306 | 2014534 | table_id: 165 (test.t_iso)<br>binlog.000130 | 2014365 | Update_rows | 3306 | 2014427 | table_id: 165 flags: STMT_END_F<br>binlog.000130 | 2014427 | Rows_query | 3306 | 2014484 | # update t_iso set d=d+2 where id=0<br>binlog.000130 | 2014484 | Table_map | 3306 | 2014534 | table_id: 165 (test.t_iso)<br>binlog.000130 | 2014534 | Update_rows | 3306 | 2014596 | table_id: 165 flags: STMT_END_F<br>binlog.000130 | 2014596 | Xid | 3306 | 2014627 | COMMIT &#47;* xid=366367 *&#47;","like_count":0,"discussions":[{"author":{"id":1691436,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/2c/be133cdf.jpg","nickname":"tank","note":"","ucode":"256553A4C09ABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316726,"discussion_content":"[root@centos7-mysql5 ~]# mysqlbinlog -vv /data/mysql_log/binlog.000130 --start-position=2014116   --stop-position=2014627\n# at 2014116\n#201022 23:29:47 server id 3306  end_log_pos 2014181 CRC32 0xaff15d6c   GTID    last_committed=2194     sequence_number=2195         rbr_only=yes\n/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;\nSET @@SESSION.GTID_NEXT= &#39;c5714948-edc3-11ea-990b-000c29f0ee9b:55954&#39;/*!*/;\n# at 2014181\n#201022 23:29:41 server id 3306  end_log_pos 2014258 CRC32 0xda15f77b   Query   thread_id=1115  exec_time=0     error_code=0\nSET TIMESTAMP=1603423781/*!*/;\nSET @@session.pseudo_thread_id=1115/*!*/;\nSET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;\nSET @@session.sql_mode=1436549152/*!*/;\nSET @@session.auto_increment_increment=2, @@session.auto_increment_offset=1/*!*/;\n/*!\\C utf8 *//*!*/;\nSET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;\nSET @@session.lc_time_names=0/*!*/;\nSET @@session.collation_database=DEFAULT/*!*/;\nBEGIN\n/*!*/;\n# at 2014258\n#201022 23:29:41 server id 3306  end_log_pos 2014315 CRC32 0x41a95e75   Rows_query\n# update t_iso set d=d+1 where id=0\n# at 2014315\n#201022 23:29:41 server id 3306  end_log_pos 2014365 CRC32 0x80d7b705   Table_map: `test`.`t_iso` mapped to number 165\n# at 2014365\n#201022 23:29:41 server id 3306  end_log_pos 2014427 CRC32 0xb048cac9   Update_rows: table id 165 flags: STMT_END_F\n\n#201022 23:29:44 server id 3306  end_log_pos 2014484 CRC32 0x453a0d33   Rows_query\n# update t_iso set d=d+2 where id=0\n# at 2014484\n#201022 23:29:44 server id 3306  end_log_pos 2014534 CRC32 0x2527a2ca   Table_map: `test`.`t_iso` mapped to number 165\n# at 2014534\n#201022 23:29:44 server id 3306  end_log_pos 2014596 CRC32 0x28d61a11   Update_rows: table id 165 flags: STMT_END_F\n\n#201022 23:29:47 server id 3306  end_log_pos 2014627 CRC32 0x3a8264c6   Xid = 366367\nCOMMIT/*!*/;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603446077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254307,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603099113,"is_pvip":true,"discussion_count":1,"race_medal":4,"score":"1603099113","product_id":100020801,"comment_content":"在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务，大事物怎么拆分成小事物，怎么保证小事物间同步？","like_count":0,"discussions":[{"author":{"id":1691436,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/2c/be133cdf.jpg","nickname":"tank","note":"","ucode":"256553A4C09ABF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316728,"discussion_content":"比如删除历史数据，考虑一次删除1000行，可以参考：\ndelimiter $$\ncreate procedure t_del()\nbegin\nset @i = 1;\nwhile @i > 0 do\ndelete from t limit 1000;\nselect  row_count() into @i;\nend while;\nend $$\ndelimiter ;\ncall t_del();","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603446244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247297,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1599652107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599652107","product_id":100020801,"comment_content":"课后问题：<br>选择WRITESET<br><br>原因：因为主库是单线程写入，无并发写，因此组提交机制并不能带来并发度的提高。而策略三要保证同一线程事务写入次序，结果就是备库也退化为单线程执行了","like_count":0},{"had_liked":false,"id":242664,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1538554,"ip_address":"","ucode":"C3744C5164F30F","user_header":"https://static001.geekbang.org/account/avatar/00/17/79/fa/48b481fe.jpg","comment_is_top":false,"comment_ctime":1597806263,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597806263","product_id":100020801,"comment_content":"老师您好，最近我遇到了一个问题百思不得其解。<br>我们的项目是主从结构的（MySQL版本是5.7），每张表都是几千万数据，我们有的同事在主表上查询，查询的数据也就几百万条，然后把这几百万条数据批量导出到本地。然后运维的同事就过来说不能这样批量导出，会造成长时间的主备延时。<br>这种导出操作没有涉及事务，也没有更新，修改（应该不会写入binlog日志把）。为啥会造成长时间主备延时呀？","like_count":0,"discussions":[{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378525,"discussion_content":"m下，有解麻烦同步下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623254814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228412,"user_name":"刘明明","can_delete":false,"product_type":"c1","uid":1904762,"ip_address":"","ucode":"202F0552168DF5","user_header":"","comment_is_top":false,"comment_ctime":1592661363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592661363","product_id":100020801,"comment_content":"因此，MySQL 5.7 并行复制策略的思想是：同时处于 prepare 状态的事务，在备库执行时是可以并行的；处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。<br><br>这里不太明白，binlog中会有redo log的prepare状态吗，两阶段提交binlog里就涉及write和fsync, 那binlog写到文件里不都是commit状态，怎么会有repare到commit的中间状态，不懂？？？","like_count":0},{"had_liked":false,"id":221090,"user_name":"九山的芷兰。","can_delete":false,"product_type":"c1","uid":1339082,"ip_address":"","ucode":"28BA9773F617B9","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/ca/66fbd7b3.jpg","comment_is_top":false,"comment_ctime":1590403043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590403043","product_id":100020801,"comment_content":"mysql 5.7 的 slave-parallel-type 配置为 LOGICAL_CLOCK，与 mysql 5.7.22 是不是只是&quot;模拟了主库的并行模式&quot;，并没有实现“真正的模拟主库并发度”这个目标？","like_count":0},{"had_liked":false,"id":221046,"user_name":"Geek_fb333","can_delete":false,"product_type":"c1","uid":2011553,"ip_address":"","ucode":"F0904774D027A3","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b1/a1/b1fd3903.jpg","comment_is_top":false,"comment_ctime":1590391179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590391179","product_id":100020801,"comment_content":"线上建议开并行复制吗","like_count":0},{"had_liked":false,"id":220440,"user_name":"注意力$","can_delete":false,"product_type":"c1","uid":1142316,"ip_address":"","ucode":"7FB3399A1EAB72","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/2c/e2f3cfc0.jpg","comment_is_top":false,"comment_ctime":1590242463,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1590242463","product_id":100020801,"comment_content":"老师，主备 在 binlog-transaction-dependency-tracking 参数 可以不一致来 让备库追上主库吗","like_count":0},{"had_liked":false,"id":217446,"user_name":"星期八","can_delete":false,"product_type":"c1","uid":1440429,"ip_address":"","ucode":"D8C66E7F61B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/15/fa/ad/3fa02ac7.jpg","comment_is_top":false,"comment_ctime":1589506435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589506435","product_id":100020801,"comment_content":"老师：writeset_session中的事务的先后顺序，怎么保证，是根据begin时间还是commit时间呢？","like_count":0},{"had_liked":false,"id":208261,"user_name":"LH","can_delete":false,"product_type":"c1","uid":1211178,"ip_address":"","ucode":"819B9B2409E834","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/2a/7d8b5943.jpg","comment_is_top":false,"comment_ctime":1587309668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587309668","product_id":100020801,"comment_content":"造成主备延迟的因素<br>1，备用机硬件垃圾<br>2，无节制压迫备用机<br>3，主库并行大于备库<br>4，主库大事务提交","like_count":0},{"had_liked":false,"id":203733,"user_name":"Ryan","can_delete":false,"product_type":"c1","uid":1667987,"ip_address":"","ucode":"95BBBEE5B23878","user_header":"https://static001.geekbang.org/account/avatar/00/19/73/93/0a3a1e5b.jpg","comment_is_top":false,"comment_ctime":1586260611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586260611","product_id":100020801,"comment_content":"WRITESET","like_count":0},{"had_liked":false,"id":182190,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1582726941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582726941","product_id":100020801,"comment_content":"回答问题 选择 WRITESET。<br>由于主库是单线程执行，没有同时处于prepare状态的事务，如果选择COMMIT_ORDEE，备库也是单线程执行。 也不需要选择WRITESET_<br>_SESSION，因为刚刚搭建的备库，暂时没用用户访问，不需要考虑同步中的数据一致性，只要保证最终一致性就行。等追上主库后再根据具体业务改成COMMIT_ORDER 或 WRITESET_SESSION","like_count":0},{"had_liked":false,"id":164799,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1577092910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577092910","product_id":100020801,"comment_content":"弱弱地问下老师，作为一个Java程序员对于本节的课程需要学习到什么程度呢？例如对于『按行复制』的策略，hash中村中的数据的格式没有理解等这些问题。感谢老师","like_count":0},{"had_liked":false,"id":164795,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1577092551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577092551","product_id":100020801,"comment_content":"阅读了两个遍，加上对之前的内容查阅，也算对本集的课程从大体上有了一个了解，当中的细节还是存在疑问","like_count":0},{"had_liked":false,"id":156571,"user_name":"jian","can_delete":false,"product_type":"c1","uid":1185102,"ip_address":"","ucode":"21CDBBB8000F0C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/4e/4636a81d.jpg","comment_is_top":false,"comment_ctime":1574915621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574915621","product_id":100020801,"comment_content":"&quot;要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。&quot;请问老师，什么必须是row，如果是有表名，主键和唯一索引的statement，为什么不能？望指点，谢谢","like_count":0},{"had_liked":false,"id":153430,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1574234488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574234488","product_id":100020801,"comment_content":"我是做后端开发的，感觉这个有点像备库延迟有点像生产者消费者模型，主库可以当成生成者，备库可以当成消费者，生产者在多线程地生产数据，而消费者却用单线程来消费数据，所以说慢也是正常的，解决的方法就是尽可能给消费者设置多个线程。","like_count":0},{"had_liked":false,"id":141116,"user_name":"法半夏","can_delete":false,"product_type":"c1","uid":1613732,"ip_address":"","ucode":"18BFBCD9191C19","user_header":"https://static001.geekbang.org/account/avatar/00/18/9f/a4/e015abbe.jpg","comment_is_top":false,"comment_ctime":1571116991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571116991","product_id":100020801,"comment_content":"老师好，我目前在维护一个老旧系统，使用mysql5.1，业务高峰时复制延迟达到5000+，iostat结果硬盘使用率达到99%，io吞吐量每秒在10Mb左右，并没有达到瓶颈，读写请求每秒在6，700左右，iowait确很高。我有点困惑单线程复制为什么会产生io性能问题呢？希望老师解惑一下，期待老师的回复…","like_count":0},{"had_liked":false,"id":135362,"user_name":"李鑫磊","can_delete":false,"product_type":"c1","uid":1101615,"ip_address":"","ucode":"D06517CFCEEE00","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/2f/4f89f22a.jpg","comment_is_top":false,"comment_ctime":1569138284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569138284","product_id":100020801,"comment_content":"备库的复制不是基于 binlog，难道 binlog 中也有能看到 prepare 和 commit 这个两个阶段？如果看不到的话，从库怎么能看到这组提交中的事务是 prepare 的还是 commit 的？5.7 对 MariaDB 的优化又从何说起呢？","like_count":0},{"had_liked":false,"id":135099,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1569025392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569025392","product_id":100020801,"comment_content":"我曾经主5.1 从5.7  从库总是exepos 不对，而数据又是对的，估计就是binlog  不一样引发的。","like_count":0},{"had_liked":false,"id":126002,"user_name":"一只羊","can_delete":false,"product_type":"c1","uid":1303375,"ip_address":"","ucode":"6A3ADF7DA30DA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/4f/4709b019.jpg","comment_is_top":false,"comment_ctime":1566291489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566291489","product_id":100020801,"comment_content":"“当然为了唯一标识，这个 hash 值是通过 库名 + 表名 + 索引名 + 值” 计算出来的。 如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。”<br><br>有个问题想请教一下：一个事务为什么会有多个hash跟它对应？按理说一个 hash 一个事务才合理啊。","like_count":0},{"had_liked":false,"id":106753,"user_name":"Jason_鹏","can_delete":false,"product_type":"c1","uid":1179329,"ip_address":"","ucode":"4A3DCAAC531724","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/c1/6c99fff4.jpg","comment_is_top":false,"comment_ctime":1561383505,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561383505","product_id":100020801,"comment_content":"之前线上遇到主从延时1s的case，反馈给DBA，他答复到是因为从库开了并行复制的策略，他把并行复制关了主从延迟就恢复正常了，很不理解关了并行复制岂不是更慢了么？为啥还会因为开启并行复制会影响主从延时的","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167343,"discussion_content":"是不是配置了错误的参数导致策略不正常了。比如延时或者积累一定事务数提交之类的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581479116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98961,"user_name":"ping","can_delete":false,"product_type":"c1","uid":1303688,"ip_address":"","ucode":"B60EF3B90D827E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJR5k5ThxFPZyew0UKNaq89utnIEQia2CiaxMOvacibGnbuZNpSiaaGTlRLWhmegxagELnIXfNveRxLfw/132","comment_is_top":false,"comment_ctime":1559120656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559120656","product_id":100020801,"comment_content":"我遇到头大问题，清指教。情况描述： 一主一从，版本：官方  5.7.25 ；硬件：8c 16g ssd, 业务不忙，从库尚未有应用连接；复制采用mts,从库 延时越来越大,繁忙的库没有遇到这种情况；从库线程发现：一个 system user一直处于   System lock 状态；sql_thread线程状态：Waiting for dependent transaction to commit<br>主要参数，主库：binlog_group_commit_sync_delay     =3000  binlog_group_commit_sync_no_delay_count=20 ；从库：slave_parallel_workers  = 4          <br>slave_parallel_type                = LOGICAL_CLOCK  <br>slave_preserve_commit_order        = 1<br>master_info_repository             = table<br>relay_log_info_repository          = table<br>relay_log_recovery                 = 1<br>log_slave_updates                  = 1 <br>log_bin                            = mysql_bin<br>binlog_format                      = row<br>binlog_group_commit_sync_delay     =3000<br>binlog_group_commit_sync_no_delay_count=20<br><br>暂时解决，从库操作：关闭binlog很快数据就同步了，<br>反复试了多次 貌似 关闭 slave_preserve_commit_order 也可以解决问题<br>binlog_group_commit_sync_delay     =0<br>binlog_group_commit_sync_no_delay_count=0<br>一直被困扰，请指教<br><br><br><br><br>","like_count":0},{"had_liked":false,"id":96519,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1558439684,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1558439684","product_id":100020801,"comment_content":"请问老师，如果备库执行relay log的语句出错了会怎么处理。<br>备库会不会停止复制，等待失败的transaction被处理？还是会略过出错数据继续呢？<br><br>谢谢老师！","like_count":0,"discussions":[{"author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354324,"discussion_content":"我用8.0试了一下，会停止复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615276628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93352,"user_name":"Godson","can_delete":false,"product_type":"c1","uid":1248384,"ip_address":"","ucode":"3DBA34ADC0FC4A","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/80/2eea0e0d.jpg","comment_is_top":false,"comment_ctime":1557455316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557455316","product_id":100020801,"comment_content":"遇到一个线上问题，DB机器的主从延迟较高，最多的时候达到了1秒，DBA选择关闭了从库的多线程复制，主从延迟降低到几乎为0，只是偶尔有尖刺（效果很明显）。疑问：多线程复制是为了降低主从延迟而出现的，为何关闭了反而延迟降低，猜想：是不是因为从库执行relayLog跟不上主库的速度，所以延迟比较高，还是因为其他原因？从库如果回执主库性能没有瓶颈的话，似乎并行复制打开的意义也不是很大。","like_count":0},{"had_liked":false,"id":83575,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1554655870,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554655870","product_id":100020801,"comment_content":"key=hash_func(db1+t1+“PRIMARY”+2）<br>文章中 更新 where id = 1 和 where id = 2<br>那为啥这里 “PRIMARY”+2  而不是 “PRIMARY”+1呢，或者2个都有呢","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167344,"discussion_content":"里面的那个2是Id值为2。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581479164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80978,"user_name":"xm","can_delete":false,"product_type":"c1","uid":1254296,"ip_address":"","ucode":"9A08EB6F201D74","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/98/bd96932f.jpg","comment_is_top":false,"comment_ctime":1553768257,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1553768257","product_id":100020801,"comment_content":"有了小疑问，如果上了主从复制了，主库的任何索引（除了主键索引）是不是都可以去掉啦😄","like_count":0,"discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167346,"discussion_content":"当然不是了。主从复制和索引有啥必然关系吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581479220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62764,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1548151075,"is_pvip":false,"replies":[{"id":"22220","content":"semi-sync在第28篇会提到，但是也不是大篇幅介绍<br><br>后面可能也不会大篇幅专门介绍了，你说下你的问题哈。","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548172794,"ip_address":"","comment_id":62764,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548151075","product_id":100020801,"comment_content":"老师，semisync啥时候讲下，昨天面试被问到一脸懵逼","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437341,"discussion_content":"semi-sync在第28篇会提到，但是也不是大篇幅介绍\n\n后面可能也不会大篇幅专门介绍了，你说下你的问题哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548172794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60862,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1547564118,"is_pvip":false,"replies":[{"id":"21687","content":"就是两阶段提交里的，写redo 的第一阶段","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547568097,"ip_address":"","comment_id":60862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547564118","product_id":100020801,"comment_content":"“不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁<br>冲突的检验了。”这句话不怎么理解。事务获取锁是在执行到对应的语句才做检查的，redo log在事务当中，应该也是一条条操作语句写的吧？难道写完了，才会进入到prepare阶段？这个prepare阶段是指事务已经完全扫描执行完所有事务操作，准备写入到redo log文件的阶段?","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436647,"discussion_content":"就是两阶段提交里的，写redo 的第一阶段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547568097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60717,"user_name":"牧鱼","can_delete":false,"product_type":"c1","uid":1360250,"ip_address":"","ucode":"0EB8FDD7A4BB2E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erFY9H3mxyTpZ9gxAmdeKic565hicicDZmv7cjswd8hdernmxib0chdQrlDNKUZQ8AticQCgDdgVEmJNuA/132","comment_is_top":false,"comment_ctime":1547536118,"is_pvip":false,"replies":[{"id":"21669","content":"1. 不会有一半事务呀，是什么场景下发现的？<br>2. 说函数入口可能不会做哈，因为很多原理涉及到不止一个函数入口，我觉得还是说原理本身好些哦<br>不过如果你对某一个点想了解函数实现的话，可以在评论区发出来","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547551904,"ip_address":"","comment_id":60717,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547536118","product_id":100020801,"comment_content":"老师好，看评论区，提到一个一半事务的问题，这个问题可是很大的问题呢，怎么避免这种问题出现呢？mysql这边有什么应对措施吗？另外，能否说明一下每一块知识部分源码入口函数呢？能够让大家更深入理解mysql内部到底是怎么实现的，形成一个主线的知识体系。也就是知其然，还要知其所以然。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436596,"discussion_content":"1. 不会有一半事务呀，是什么场景下发现的？\n2. 说函数入口可能不会做哈，因为很多原理涉及到不止一个函数入口，我觉得还是说原理本身好些哦\n不过如果你对某一个点想了解函数实现的话，可以在评论区发出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547551904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60305,"user_name":"小超","can_delete":false,"product_type":"c1","uid":1068004,"ip_address":"","ucode":"FCC8B303A16E70","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/e4/0219e7c8.jpg","comment_is_top":false,"comment_ctime":1547456639,"is_pvip":false,"replies":[{"id":"21558","content":"对，commit_id 会写到binlog里面，而commit_id 体现了主库“同时进入redo log prepare 和 commit ”这个状态","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547484039,"ip_address":"","comment_id":60305,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547456639","product_id":100020801,"comment_content":"老师，从库不是只根据binlog来做相应的操作么，这个并行复制策略根据事务相同commit_id判断好理解，但是根据同时进入redo log prepare 和 commit 来判断这个怎么理解？事务提交的时候，其他事务的redo log处于prepare的状态事务的某个标识也会记录到每一个事务的binlog中么？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436471,"discussion_content":"对，commit_id 会写到binlog里面，而commit_id 体现了主库“同时进入redo log prepare 和 commit ”这个状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547484039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59724,"user_name":"张先先森森森","can_delete":false,"product_type":"c1","uid":1304393,"ip_address":"","ucode":"6DF6E4FA5E3968","user_header":"","comment_is_top":false,"comment_ctime":1547422632,"is_pvip":false,"replies":[{"id":"21483","content":"备库是要只用于查询；<br>更新事务只发给主库，只读事务还是可以发给备库的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547432531,"ip_address":"","comment_id":59724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547422632","product_id":100020801,"comment_content":"备库不是仅用于查询么？begin的话，不是会在主库执行么？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436385,"discussion_content":"备库是要只用于查询；\n更新事务只发给主库，只读事务还是可以发给备库的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547432531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59614,"user_name":"itzzy","can_delete":false,"product_type":"c1","uid":1058553,"ip_address":"","ucode":"25C4B6F6FDE945","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/f9/2a7d80a3.jpg","comment_is_top":false,"comment_ctime":1547392490,"is_pvip":false,"replies":[{"id":"21420","content":"报错的原因发我看下<br><br>还有，5.7支持密码过期的功能，看看是不是这个原因导致的？","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547397055,"ip_address":"","comment_id":59614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547392490","product_id":100020801,"comment_content":"老师好，mac上本机使用mysql遇到一个问题，安装时重置过root的密码，有一段时间没有使用本地的mysql，前几天使用发现又要重置密码，在网上找资料解决了，但是还是不知道为啥会出现这种情况，希望老师看到解答下，感谢~","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436366,"discussion_content":"报错的原因发我看下\n\n还有，5.7支持密码过期的功能，看看是不是这个原因导致的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547397055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59060,"user_name":"天使之剑","can_delete":false,"product_type":"c1","uid":1306842,"ip_address":"","ucode":"69B2D109AE282F","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/da/74bbb9e6.jpg","comment_is_top":false,"comment_ctime":1547289046,"is_pvip":false,"replies":[{"id":"21372","content":"“记录并不准备” ？","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547293142,"ip_address":"","comment_id":59060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547289046","product_id":100020801,"comment_content":"mysql 5.7并行复制有一个bug，是seconds_behind_master记录并不准备，显示为0，但是实际并不为0，能不能解释一下为什么？并且有没有其他地方可以读到准确的值呢","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436289,"discussion_content":"“记录并不准备” ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547293142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58850,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1547212569,"is_pvip":false,"replies":[{"id":"21311","content":"主库上可以同时running 的事务在备库上不可以并行。<br><br>这个不对呀，比如两个线程可以同时running，有两种情况：<br>1. 两个更新不同的行，这样在备库就可以并行；<br>2. 更新同一行，一个在执行，一个在锁等待，都是running，这种在备库就不能并行","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547233320,"ip_address":"","comment_id":58850,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547212569","product_id":100020801,"comment_content":"老师您好，有个问题想半天：主库上可以同时running 的事务在备库上不可以并行。最后认为innodb是单线程执行多客户端发来的存储命令的，不知这样理解对不对？请老师解答。","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436233,"discussion_content":"主库上可以同时running 的事务在备库上不可以并行。\n\n这个不对呀，比如两个线程可以同时running，有两种情况：\n1. 两个更新不同的行，这样在备库就可以并行；\n2. 更新同一行，一个在执行，一个在锁等待，都是running，这种在备库就不能并行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547233320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58770,"user_name":"库淘淘","can_delete":false,"product_type":"c1","uid":1310240,"ip_address":"","ucode":"90813B0C46E978","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqibSwKPg7hiapc49qoM4dibhM3fYANPjfltF2ibBZ3dHX2hibjg5EIIcziahrmjO5R2XrcRibvU39TQS7jg/132","comment_is_top":false,"comment_ctime":1547190401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547190401","product_id":100020801,"comment_content":"我认为还是要采用writeset 模式 由于是单线程插入了很多数据，\r<br>参数commit_order 是对多线程效果比较好，对于这种情况，性能几乎没有什么提升\r<br>参数writeset_session 是为了保证同session事务的顺序性，性能上也没有什么提升","like_count":0},{"had_liked":false,"id":58720,"user_name":"郭刚","can_delete":false,"product_type":"c1","uid":1292032,"ip_address":"","ucode":"22CB8ECE8E3DCA","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/00/12149f4e.jpg","comment_is_top":false,"comment_ctime":1547183112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547183112","product_id":100020801,"comment_content":"MySQL的分支版本MariaDB,Oracle,percona如何选型呢？","like_count":0},{"had_liked":false,"id":58708,"user_name":"滔滔","can_delete":false,"product_type":"c1","uid":1303342,"ip_address":"","ucode":"6968B5771AF79D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/2e/77ad18f4.jpg","comment_is_top":false,"comment_ctime":1547180356,"is_pvip":false,"replies":[{"id":"21226","content":"不是，就是看order by","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547184525,"ip_address":"","comment_id":58708,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547180356","product_id":100020801,"comment_content":"老师，想请教您一个问题，看到网上有一段话&quot;使用倒序索引可以提升order by desc的性能&quot;，想问一下这是否还要看具体的范围查询语句是&lt;还是&gt;，如果是&gt;使用倒序索引可以提升order by desc的性能，但是如果是&lt;应该使用默认升序索引会更快，是这样么？🤔","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436182,"discussion_content":"不是，就是看order by","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547184525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58704,"user_name":"万勇","can_delete":false,"product_type":"c1","uid":1309092,"ip_address":"","ucode":"BC9E0918DF4516","user_header":"https://static001.geekbang.org/account/avatar/00/13/f9/a4/f0b92135.jpg","comment_is_top":false,"comment_ctime":1547179076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547179076","product_id":100020801,"comment_content":"1.如果是多张表分别插入数据，我觉得选用commit_order值，每个表按照顺序插入数据分批提交，备库的worker线程可以并行执行不同的表。<br>2.如果是单表顺序插入大量数据，我觉得选用wirteset_session值，备库要保证执行的顺序。<br>3.如果是多张表无序的插入数据，我觉得选用writeset值，两个事务没有操作一张表，可以并行运行。","like_count":0},{"had_liked":false,"id":58703,"user_name":"倪大人","can_delete":false,"product_type":"c1","uid":1193052,"ip_address":"","ucode":"4798D69F3E86FB","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/5c/6b4757a0.jpg","comment_is_top":false,"comment_ctime":1547178846,"is_pvip":false,"replies":[{"id":"21221","content":"第二部分不是很准确，要再重新理解下哈😆<br><br>（不过看你后面的评论，应该是get到点了）","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547179710,"ip_address":"","comment_id":58703,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547178846","product_id":100020801,"comment_content":"作业题：<br>“主库单线程插入了很多数据” =&gt; 不适合用COMMIT_ORDER，因为每组提交的事务都只包含一个事务，如果用COMMIT_ORDER就相当于备库一直串行执行，并且还得等每个事务提交之后才能取下一批执行，会慢一些。<br><br>而WRITESET_SESSION相比WRITESET，按我的理解就是为了解决文里举的“唯一索引a”这个例子的情况，所以结论是：如果表有唯一索引就选WRITESET，没有就选WRITESET_SESSION。<br><br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436179,"discussion_content":"第二部分不是很准确，要再重新理解下哈😆\n\n（不过看你后面的评论，应该是get到点了）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547179710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58695,"user_name":"郭江伟","can_delete":false,"product_type":"c1","uid":1313994,"ip_address":"","ucode":"613D638619B5A2","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/ca/6173350b.jpg","comment_is_top":false,"comment_ctime":1547177112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547177112","product_id":100020801,"comment_content":"如果单线程插入很多数据，从库开并行复制，binlog-transaction-dependency-tracking只能用writeset，理由是：<br>commit_order 参数按照同时进入prepare 和commit 来判断是否是否可以并行，这里是单线程，在一个commit成功返回前不会有下一个事务<br>write_session 意思是主库上同一个线程执行的事务，在从库执行的时候需要保证先后顺序；当主库是单线程做了很多事务时，即使从库将事务分发到多个worker，从库仍然是串行执行","like_count":0},{"had_liked":false,"id":58655,"user_name":"skyoo","can_delete":false,"product_type":"c1","uid":1302503,"ip_address":"","ucode":"EBC0528BA02DD7","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/e7/4ce5ed27.jpg","comment_is_top":false,"comment_ctime":1547167620,"is_pvip":false,"replies":[{"id":"21202","content":"我也是^_^","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1547176201,"ip_address":"","comment_id":58655,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547167620","product_id":100020801,"comment_content":"越来越喜欢看评论区啦 ","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436152,"discussion_content":"我也是^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547176201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}