{"id":471138,"title":"27｜即学即练：跟踪函数调用链，理解代码更直观","content":"<p>你好，我是Tony Bai。</p><p>时间过得真快！转眼间我们已经完成了这门课基础篇Go语法部分的学习。在这一部分中，我们从变量声明开始，一直学到了Go函数与方法的设计，不知道你掌握得怎么样呢？基础篇的重点是<strong>对Go基础语法部分的理解</strong>，只有理解透了，我们才能在动手实践的环节运用自如。</p><p>同时，基础篇也是整个课程篇幅最多的部分，想必学到这里，你差不多也进入了一个“疲劳期”。为了给你的大脑“充充电”，我在这一讲，也就是基础篇的最后一讲中安排了一个小实战项目，适当放松一下，也希望你在实现这个实战项目的过程中，能对基础篇所学的内容做一个回顾与总结，夯实一下Go的语法基础。</p><h2>引子</h2><p>在前面的<a href=\"https://time.geekbang.org/column/article/464273\">第23讲</a>中，我曾留过这样的一道思考题：“除了捕捉panic、延迟释放资源外，我们日常编码中还有哪些使用defer的小技巧呢？”</p><p>这个思考题得到了同学们的热烈响应，有同学在留言区提到：<strong>使用defer可以跟踪函数的执行过程</strong>。没错！这的确是defer的一个常见的使用技巧，很多Go教程在讲解defer时也会经常使用这个用途举例。那么，我们具体是怎么用defer来实现函数执行过程的跟踪呢？这里，我给出了一个最简单的实现：</p><pre><code class=\"language-plain\">// trace.go\npackage main\n  \nfunc Trace(name string) func() {\n    println(\"enter:\", name)\n    return func() {\n        println(\"exit:\", name)\n    }\n}\n\nfunc foo() {\n    defer Trace(\"foo\")()\n    bar()\n}\n\nfunc bar() {\n    defer Trace(\"bar\")()\n}\n\nfunc main() {\n    defer Trace(\"main\")()\n    foo()\n}\n</code></pre><!-- [[[read_end]]] --><p>在讲解这段代码的原理之前，我们先看一下这段代码的执行结果，直观感受一下什么是<strong>函数调用跟踪</strong>：</p><pre><code class=\"language-plain\">enter: main\nenter: foo\nenter: bar\nexit: bar\nexit: foo\nexit: main\n</code></pre><p>我们看到，这个Go程序的函数调用的全过程一目了然地展现在了我们面前：程序按<code>main -&gt; foo -&gt; bar</code>的函数调用次序执行，代码在函数的入口与出口处分别输出了跟踪日志。</p><p>那这段代码是怎么做到的呢？我们简要分析一下。</p><p>在这段实现中，我们在每个函数的入口处都使用defer设置了一个deferred函数。根据<a href=\"https://time.geekbang.org/column/article/464273\">第23讲</a>中讲解的defer的运作机制，Go会在defer设置deferred函数时对defer后面的表达式进行求值。</p><p>我们以foo函数中的<code>defer Trace(\"foo\")()</code>这行代码为例，Go会对defer后面的表达式<code>Trace(\"foo\")()</code>进行求值。由于这个表达式包含一个函数调用<code>Trace(\"foo\")</code>，所以这个函数会被执行。</p><p>上面的Trace函数只接受一个参数，˙这个参数代表函数名，Trace会首先打印进入某函数的日志，比如：<code>“enter: foo”</code>。然后返回一个闭包函数，这个闭包函数一旦被执行，就会输出离开某函数的日志。在foo函数中，这个由Trace函数返回的闭包函数就被设置为了deferred函数，于是当foo函数返回后，这个闭包函数就会被执行，输出<code>“exit: foo”</code>的日志。</p><p>搞清楚上面跟踪函数调用链的实现原理后，我们再来看看这个实现。我们会发现这里还是有一些<strong>“瑕疵”</strong>，也就是离我们期望的“跟踪函数调用链”的实现还有一些不足之处。这里我列举了几点：</p><ul>\n<li>调用Trace时需手动显式传入要跟踪的函数名；</li>\n<li>如果是并发应用，不同Goroutine中函数链跟踪混在一起无法分辨；</li>\n<li>输出的跟踪结果缺少层次感，调用关系不易识别；</li>\n<li>对要跟踪的函数，需手动调用Trace函数。</li>\n</ul><p>那么，这一讲我们的任务就是逐一分析并解决上面提出的这几点问题进行，经过逐步地代码演进，最终<strong>实现一个自动注入跟踪代码，并输出有层次感的函数调用链跟踪命令行工具</strong>。</p><p>好，下面我们先来解决第一个问题。</p><h2>自动获取所跟踪函数的函数名</h2><p>要解决“调用Trace时需要手动显式传入要跟踪的函数名”的问题，也就是要让我们的Trace函数能够自动获取到它跟踪函数的函数名信息。我们以跟踪foo为例，看看这样做能给我们带来什么好处。</p><p>在手动显式传入的情况下，我们需要用下面这个代码对foo进行跟踪：</p><pre><code class=\"language-plain\">defer Trace(\"foo\")()\n</code></pre><p>一旦实现了自动获取函数名，所有支持函数调用链跟踪的函数都只需使用下面调用形式的Trace函数就可以了：</p><pre><code class=\"language-plain\">defer Trace()()\n</code></pre><p>这种一致的Trace函数调用方式也为后续的自动向代码中注入Trace函数奠定了基础。那么如何实现Trace函数对它跟踪函数名的自动获取呢？我们需要借助Go标准库runtime包的帮助。</p><p>这里，我给出了新版Trace函数的实现以及它的使用方法，我们先看一下：</p><pre><code class=\"language-plain\">// trace1/trace.go\n\nfunc Trace() func() {\n    pc, _, _, ok := runtime.Caller(1)\n    if !ok {\n        panic(\"not found caller\")\n    }\n\n    fn := runtime.FuncForPC(pc)\n    name := fn.Name()\n\n    println(\"enter:\", name)\n    return func() { println(\"exit:\", name) }\n}\n\nfunc foo() {\n    defer Trace()()\n    bar()\n}\n\nfunc bar() {\n    defer Trace()()\n}\n\nfunc main() {\n    defer Trace()()\n    foo()\n}\n</code></pre><p>在这一版Trace函数中，我们通过runtime.Caller函数获得当前Goroutine的函数调用栈上的信息，runtime.Caller的参数标识的是要获取的是哪一个栈帧的信息。当参数为0时，返回的是Caller函数的调用者的函数信息，在这里就是Trace函数。但我们需要的是Trace函数的调用者的信息，于是我们传入1。</p><p>Caller函数有四个返回值：第一个返回值代表的是程序计数（pc）；第二个和第三个参数代表对应函数所在的源文件名以及所在行数，这里我们暂时不需要；最后一个参数代表是否能成功获取这些信息，如果获取失败，我们抛出panic。</p><p>接下来，我们通过runtime.FuncForPC函数和程序计数器（PC）得到被跟踪函数的函数名称。我们运行一下改造后代码：</p><pre><code class=\"language-plain\">enter: main.main\nenter: main.foo\nenter: main.bar\nexit: main.bar\nexit: main.foo\nexit: main.main\n</code></pre><p>我们看到，runtime.FuncForPC返回的名称中不仅仅包含函数名，还包含了被跟踪函数所在的包名。也就是说，我们第一个问题已经圆满解决了。</p><p>接下来，我们来解决第二个问题，也就是当程序中有多Goroutine时，Trace输出的跟踪信息混杂在一起难以分辨的问题。</p><h2>增加Goroutine标识</h2><p>上面的Trace函数在面对只有一个Goroutine的时候，还是可以支撑的，但当程序中并发运行多个Goroutine的时候，多个函数调用链的出入口信息输出就会混杂在一起，无法分辨。</p><p>那么，接下来我们还继续对Trace函数进行改造，让它支持多Goroutine函数调用链的跟踪。我们的方案就是<strong>在输出的函数出入口信息时，带上一个在程序每次执行时能唯一区分Goroutine的Goroutine ID</strong>。</p><p>到这里，你可能会说，Goroutine也没有ID信息啊！的确如此，Go核心团队为了避免<a href=\"https://groups.google.com/g/golang-nuts/c/0HGyCOrhuuI/m/BjkXjGkMJrgJ\">Goroutine ID的滥用</a>，故意没有将Goroutine ID暴露给开发者。但在Go标准库的h2_bundle.go中，我们却发现了一个获取Goroutine ID的标准方法，看下面代码：</p><pre><code class=\"language-plain\">// $GOROOT/src/net/http/h2_bundle.go\nvar http2goroutineSpace = []byte(\"goroutine \")\n\nfunc http2curGoroutineID() uint64 {\n    bp := http2littleBuf.Get().(*[]byte)\n    defer http2littleBuf.Put(bp)\n    b := *bp\n    b = b[:runtime.Stack(b, false)]\n    // Parse the 4707 out of \"goroutine 4707 [\"\n    b = bytes.TrimPrefix(b, http2goroutineSpace)\n    i := bytes.IndexByte(b, ' ')\n    if i &lt; 0 {\n        panic(fmt.Sprintf(\"No space found in %q\", b))\n    }\n    b = b[:i]\n    n, err := http2parseUintBytes(b, 10, 64)\n    if err != nil {\n        panic(fmt.Sprintf(\"Failed to parse goroutine ID out of %q: %v\", b, err))\n    }\n    return n\n}\n</code></pre><p>不过，由于http2curGoroutineID不是一个导出函数，我们无法直接使用。我们可以把它复制出来改造一下：</p><pre><code class=\"language-plain\">// trace2/trace.go\nvar goroutineSpace = []byte(\"goroutine \")\n\nfunc curGoroutineID() uint64 {\n    b := make([]byte, 64)\n    b = b[:runtime.Stack(b, false)]\n    // Parse the 4707 out of \"goroutine 4707 [\"\n    b = bytes.TrimPrefix(b, goroutineSpace)\n    i := bytes.IndexByte(b, ' ')\n    if i &lt; 0 {\n        panic(fmt.Sprintf(\"No space found in %q\", b))\n    }\n    b = b[:i]\n    n, err := strconv.ParseUint(string(b), 10, 64)\n    if err != nil {\n        panic(fmt.Sprintf(\"Failed to parse goroutine ID out of %q: %v\", b, err))\n    }\n    return n\n}\n</code></pre><p>这里，我们改造了两个地方。一个地方是通过直接创建一个byte切片赋值给b，替代原http2curGoroutineID函数中从一个pool池获取byte切片的方式，另外一个是使用strconv.ParseUint替代了原先的http2parseUintBytes。改造后，我们就可以直接使用curGoroutineID函数来获取Goroutine的ID信息了。</p><p>好，接下来，我们在Trace函数中添加Goroutine ID信息的输出：</p><pre><code class=\"language-plain\">// trace2/trace.go\nfunc Trace() func() {\n    pc, _, _, ok := runtime.Caller(1)\n    if !ok {\n        panic(\"not found caller\")\n    }\n\n    fn := runtime.FuncForPC(pc)\n    name := fn.Name()\n\n    gid := curGoroutineID()\n    fmt.Printf(\"g[%05d]: enter: [%s]\\n\", gid, name)\n    return func() { fmt.Printf(\"g[%05d]: exit: [%s]\\n\", gid, name) }\n}\n</code></pre><p>从上面代码看到，我们在出入口输出的跟踪信息中加入了Goroutine ID信息，我们输出的Goroutine ID为5位数字，如果ID值不足5位，则左补零，这一切都是Printf函数的格式控制字符串“%05d”帮助我们实现的。这样对齐Goroutine ID的位数，为的是输出信息格式的一致性更好。如果你的Go程序中Goroutine的数量超过了5位数可以表示的数值范围，也可以自行调整控制字符串。</p><p>接下来，我们也要对示例进行一些调整，将这个程序由单Goroutine改为多Goroutine并发的，这样才能验证支持多Goroutine的新版Trace函数是否好用：</p><pre><code class=\"language-plain\">// trace2/trace.go\nfunc A1() {\n    defer Trace()()\n    B1()\n}\n\nfunc B1() {\n    defer Trace()()\n    C1()\n}\n\nfunc C1() {\n    defer Trace()()\n    D()\n}\n\nfunc D() {\n    defer Trace()()\n}\n\nfunc A2() {\n    defer Trace()()\n    B2()\n}\nfunc B2() {\n    defer Trace()()\n    C2()\n}\nfunc C2() {\n    defer Trace()()\n    D()\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    wg.Add(1)\n    go func() {\n        A2()\n        wg.Done()\n    }()\n\n    A1()\n    wg.Wait()\n}\n</code></pre><p>新示例程序共有两个Goroutine，main groutine的调用链为<code>A1 -&gt; B1 -&gt; C1 -&gt; D</code>，而另外一个Goroutine的函数调用链为<code>A2 -&gt; B2 -&gt; C2 -&gt; D</code>。我们来看一下这个程序的执行结果是否和原代码中两个Goroutine的调用链一致：</p><pre><code class=\"language-plain\">g[00001]: enter: [main.A1]\ng[00001]: enter: [main.B1]\ng[00018]: enter: [main.A2]\ng[00001]: enter: [main.C1]\ng[00001]: enter: [main.D]\ng[00001]: exit: [main.D]\ng[00001]: exit: [main.C1]\ng[00001]: exit: [main.B1]\ng[00001]: exit: [main.A1]\ng[00018]: enter: [main.B2]\ng[00018]: enter: [main.C2]\ng[00018]: enter: [main.D]\ng[00018]: exit: [main.D]\ng[00018]: exit: [main.C2]\ng[00018]: exit: [main.B2]\ng[00018]: exit: [main.A2]\n</code></pre><p>我们看到，新示例程序输出了带有Goroutine ID的出入口跟踪信息，通过Goroutine ID我们可以快速确认某一行输出是属于哪个Goroutine的。</p><p>但由于Go运行时对Goroutine调度顺序的不确定性，各个Goroutine的输出还是会存在交织在一起的问题，这会给你查看某个Goroutine的函数调用链跟踪信息带来阻碍。这里我提供一个<strong>小技巧</strong>：你可以将程序的输出重定向到一个本地文件中，然后通过Goroutine ID过滤出（可使用grep工具）你想查看的groutine的全部函数跟踪信息。</p><p>到这里，我们就实现了输出带有Goroutine ID的函数跟踪信息，不过，你是不是也觉得输出的函数调用链信息还是不够美观，缺少层次感，体验依旧不那么优秀呢？至少我是这么觉得的。所以下面我们就来美化一下信息的输出形式。</p><h2>让输出的跟踪信息更具层次感</h2><p>对于程序员来说，缩进是最能体现出“层次感”的方法，如果我们将上面示例中Goroutine 00001的函数调用跟踪信息以下面的形式展示出来，函数的调用顺序是不是更加一目了然了呢？</p><pre><code class=\"language-plain\">g[00001]:    -&gt;main.A1\ng[00001]:        -&gt;main.B1\ng[00001]:            -&gt;main.C1\ng[00001]:                -&gt;main.D\ng[00001]:                &lt;-main.D\ng[00001]:            &lt;-main.C1\ng[00001]:        &lt;-main.B1\ng[00001]:    &lt;-main.A1\n</code></pre><p>那么我们就以这个形式为目标，考虑如何实现输出这种带缩进的函数调用跟踪信息。我们还是直接上代码吧：</p><pre><code class=\"language-plain\">// trace3/trace.go\n\nfunc printTrace(id uint64, name, arrow string, indent int) {\n    indents := \"\"\n    for i := 0; i &lt; indent; i++ {\n        indents += \"    \"\n    }\n    fmt.Printf(\"g[%05d]:%s%s%s\\n\", id, indents, arrow, name)\n}\n\nvar mu sync.Mutex\nvar m = make(map[uint64]int)\n\nfunc Trace() func() {\n    pc, _, _, ok := runtime.Caller(1)\n    if !ok {\n        panic(\"not found caller\")\n    }\n\n    fn := runtime.FuncForPC(pc)\n    name := fn.Name()\n    gid := curGoroutineID()\n\n    mu.Lock()\n    indents := m[gid]    // 获取当前gid对应的缩进层次\n    m[gid] = indents + 1 // 缩进层次+1后存入map\n    mu.Unlock()\n    printTrace(gid, name, \"-&gt;\", indents+1)\n    return func() {\n        mu.Lock()\n        indents := m[gid]    // 获取当前gid对应的缩进层次\n        m[gid] = indents - 1 // 缩进层次-1后存入map\n        mu.Unlock()\n        printTrace(gid, name, \"&lt;-\", indents)\n    }\n}\n</code></pre><p>在上面这段代码中，我们使用了一个map类型变量m来保存每个Goroutine当前的缩进信息：m的key为Goroutine的ID，值为缩进的层次。然后，考虑到Trace函数可能在并发环境中运行，根据我们在<a href=\"https://time.geekbang.org/column/article/446032\">第16讲</a>中提到的“map不支持并发写”的注意事项，我们增加了一个sync.Mutex实例mu用于同步对m的写操作。</p><p>这样，对于一个Goroutine来说，每次刚进入一个函数调用，我们就在输出入口跟踪信息之前，将缩进层次加一，并输出入口跟踪信息，加一后的缩进层次值也保存到map中。然后，在函数退出前，我们取出当前缩进层次值并输出出口跟踪信息，之后再将缩进层次减一后保存到map中。</p><p>除了增加缩进层次信息外，在这一版的Trace函数实现中，我们也把输出出入口跟踪信息的操作提取到了一个独立的函数printTrace中，这个函数会根据传入的Goroutine ID、函数名、箭头类型与缩进层次值，按预定的格式拼接跟踪信息并输出。</p><p>运行新版示例代码，我们会得到下面的结果：</p><pre><code class=\"language-plain\">g[00001]:    -&gt;main.A1\ng[00001]:        -&gt;main.B1\ng[00001]:            -&gt;main.C1\ng[00001]:                -&gt;main.D\ng[00001]:                &lt;-main.D\ng[00001]:            &lt;-main.C1\ng[00001]:        &lt;-main.B1\ng[00001]:    &lt;-main.A1\ng[00018]:    -&gt;main.A2\ng[00018]:        -&gt;main.B2\ng[00018]:            -&gt;main.C2\ng[00018]:                -&gt;main.D\ng[00018]:                &lt;-main.D\ng[00018]:            &lt;-main.C2\ng[00018]:        &lt;-main.B2\ng[00018]:    &lt;-main.A2\n</code></pre><p>显然，通过这种带有缩进层次的函数调用跟踪信息，我们可以更容易地识别某个Goroutine的函数调用关系。</p><p>到这里，我们的函数调用链跟踪已经支持了多Goroutine，并且可以输出有层次感的跟踪信息了，但对于Trace特性的使用者而言，他们依然需要手工在自己的函数中添加对Trace函数的调用。那么我们是否可以将Trace特性自动注入特定项目下的各个源码文件中呢？接下来我们继续来改进我们的Trace工具。</p><h2>利用代码生成自动注入Trace函数</h2><p>要实现向目标代码中的函数/方法自动注入Trace函数，我们首先要做的就是将上面Trace函数相关的代码打包到一个module中以方便其他module导入。下面我们就先来看看将Trace函数放入一个独立的module中的步骤。</p><h3>将Trace函数放入一个独立的module中</h3><p>我们创建一个名为instrument_trace的目录，进入这个目录后，通过go mod init命令创建一个名为github.com/bigwhite/instrument_trace的module：</p><pre><code class=\"language-plain\">$mkdir instrument_trace\n$cd instrument_trace\n$go mod init github.com/bigwhite/instrument_trace\ngo: creating new go.mod: module github.com/bigwhite/instrument_trace\n</code></pre><p>接下来，我们将最新版的trace.go放入到该目录下，将包名改为trace，并仅保留Trace函数、Trace使用的函数以及包级变量，其他函数一律删除掉。这样，一个独立的trace包就提取完毕了。</p><p><strong>作为trace包的作者，我们有义务告诉大家如何使用trace包。</strong>在Go中，通常我们会用一个example_test.go文件来编写使用trace包的演示代码，下面就是我们为trace包提供的example_test.go文件：</p><pre><code class=\"language-plain\">// instrument_trace/example_test.go\npackage trace_test\n  \nimport (\n    trace \"github.com/bigwhite/instrument_trace\"\n)\n\nfunc a() {\n    defer trace.Trace()()\n    b()\n}\n\nfunc b() {\n    defer trace.Trace()()\n    c()\n}\n\nfunc c() {\n    defer trace.Trace()()\n    d()\n}\n\nfunc d() {\n    defer trace.Trace()()\n}\n\nfunc ExampleTrace() {\n    a()\n    // Output:\n    // g[00001]:    -&gt;github.com/bigwhite/instrument_trace_test.a\n    // g[00001]:        -&gt;github.com/bigwhite/instrument_trace_test.b\n    // g[00001]:            -&gt;github.com/bigwhite/instrument_trace_test.c\n    // g[00001]:                -&gt;github.com/bigwhite/instrument_trace_test.d\n    // g[00001]:                &lt;-github.com/bigwhite/instrument_trace_test.d\n    // g[00001]:            &lt;-github.com/bigwhite/instrument_trace_test.c\n    // g[00001]:        &lt;-github.com/bigwhite/instrument_trace_test.b\n    // g[00001]:    &lt;-github.com/bigwhite/instrument_trace_test.a\n}\n</code></pre><p>在example_test.go文件中，我们用ExampleXXX形式的函数表示一个示例，go test命令会扫描example_test.go中的以Example为前缀的函数并执行这些函数。</p><p>每个ExampleXXX函数需要包含预期的输出，就像上面ExampleTrace函数尾部那样，我们在一大段注释中提供这个函数执行后的预期输出，预期输出的内容从<code>// Output:</code>的下一行开始。go test会将ExampleTrace的输出与预期输出对比，如果不一致，会报测试错误。从这一点，我们可以看出example_test.go也是trace包单元测试的一部分。</p><p>现在Trace函数已经被放入到独立的包中了，接下来我们就来看看如何将它自动注入到要跟踪的函数中去。</p><h3>自动注入Trace函数</h3><p>现在，我们在instrument_trace module下面增加一个命令行工具，这个工具可以以一个Go源文件为单位，自动向这个Go源文件中的所有函数注入Trace函数。</p><p>我们再根据<a href=\"https://time.geekbang.org/column/article/429143\">05讲</a>中介绍的带有可执行文件的Go项目布局，在instrument_trace module中增加cmd/instrument目录，这个工具的main包就放在这个目录下，而真正实现自动注入Trace函数的代码呢，被我们放在了instrumenter目录下。</p><p>下面是变化后的instrument_trace module的目录结构：</p><pre><code class=\"language-plain\">$tree ./instrument_trace -F\n./instrument_trace\n├── Makefile\n├── cmd/\n│&nbsp;&nbsp; └── instrument/\n│&nbsp;&nbsp;     └── main.go  # instrument命令行工具的main包\n├── example_test.go\n├── go.mod\n├── go.sum\n├── instrumenter/    # 自动注入逻辑的相关结构\n│&nbsp;&nbsp; ├── ast/\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── ast.go\n│&nbsp;&nbsp; └── instrumenter.go\n└── trace.go\n</code></pre><p>我们先来看一下cmd/instrument/main.go源码，然后自上而下沿着main函数的调用逻辑逐一看一下这个功能的实现。下面是main.go的源码：</p><pre><code class=\"language-plain\">//  instrument_trace/cmd/instrument/main.go\n\n... ...\n\nvar (\n    wrote bool\n)\n\nfunc init() {\n    flag.BoolVar(&amp;wrote, \"w\", false, \"write result to (source) file instead of stdout\")\n}\n\nfunc usage() {\n    fmt.Println(\"instrument [-w] xxx.go\")\n    flag.PrintDefaults()\n}\n\nfunc main() {\n    fmt.Println(os.Args)\n    flag.Usage = usage\n    flag.Parse() // 解析命令行参数\n\n    if len(os.Args) &lt; 2 { // 对命令行参数个数进行校验\n        usage()\n        return\n    }\n\n    var file string\n    if len(os.Args) == 3 {\n        file = os.Args[2]\n    }\n\n    if len(os.Args) == 2 {\n        file = os.Args[1]\n    }\n    if filepath.Ext(file) != \".go\" { // 对源文件扩展名进行校验\n        usage()\n        return\n    }\n\n    var ins instrumenter.Instrumenter // 声明instrumenter.Instrumenter接口类型变量\n    \n    // 创建以ast方式实现Instrumenter接口的ast.instrumenter实例\n    ins = ast.New(\"github.com/bigwhite/instrument_trace\", \"trace\", \"Trace\") \n    newSrc, err := ins.Instrument(file) // 向Go源文件所有函数注入Trace函数\n    if err != nil {\n        panic(err)\n    }\n\n    if newSrc == nil {\n        // add nothing to the source file. no change\n        fmt.Printf(\"no trace added for %s\\n\", file)\n        return\n    }\n\n    if !wrote {\n        fmt.Println(string(newSrc))  // 将生成的新代码内容输出到stdout上\n        return\n    }\n\n    // 将生成的新代码内容写回原Go源文件\n    if err = ioutil.WriteFile(file, newSrc, 0666); err != nil {\n        fmt.Printf(\"write %s error: %v\\n\", file, err)\n        return\n    }\n    fmt.Printf(\"instrument trace for %s ok\\n\", file)\n}\n</code></pre><p>作为命令行工具，instrument使用标准库的flag包实现对命令行参数（这里是-w）的解析，通过os.Args获取待注入的Go源文件路径。在完成对命令行参数个数与值的校验后，instrument程序声明了一个instrumenter.Instrumenter接口类型变量ins，然后创建了一个实现了Instrumenter接口类型的ast.instrumenter类型的实例，并赋值给变量ins。</p><p>instrumenter.Instrumenter接口类型的声明放在了instrumenter/instrumenter.go中：</p><pre><code class=\"language-plain\">type Instrumenter interface {\n    Instrument(string) ([]byte, error)\n}\n</code></pre><p>这里我们看到，这个接口类型的方法列表中只有一个方法Instrument，这个方法接受一个Go源文件路径，返回注入了Trace函数的新源文件内容以及一个error类型值，作为错误状态标识。我们之所以要抽象出一个接口类型，考虑的就是注入Trace函数的实现方法不一，为后续的扩展做好预留。</p><p>在这个例子中，我们默认提供了一种自动注入Trace函数的实现，那就是ast.instrumenter，它注入Trace的实现原理是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/a8/5be0efb3920c39cd9f252af0b26e7ca8.jpg?wh=1980x1080\" alt=\"\"></p><p>从原理图中我们可以清楚地看到，在这一实现方案中，我们先将传入的Go源码转换为<strong>抽象语法树</strong>。</p><p>在计算机科学中，抽象语法树（abstract syntax tree，AST）是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。因为Go语言是开源编程语言，所以它的抽象语法树的操作包也和语言一起开放给了Go开发人员，我们可以基于Go标准库以及<a href=\"https://golang.org/x/tools\">Go实验工具库</a>提供的ast相关包，快速地构建基于AST的应用，这里的ast.instrumenter就是一个应用AST的典型例子。</p><p>一旦我们通过ast相关包解析Go源码得到相应的抽象语法树后，我们便可以操作这棵语法树，并按我们的逻辑在语法树中注入我们的Trace函数，最后我们再将修改后的抽象语法树转换为Go源码，就完成了整个自动注入的工作了。</p><p>了解了原理后，我们再看一下具体的代码实现。下面是ast.instrumenter的Instructment方法的代码：</p><pre><code class=\"language-plain\">// instrument_trace/instrumenter/ast/ast.go\n\nfunc (a instrumenter) Instrument(filename string) ([]byte, error) {\n    fset := token.NewFileSet()\n    curAST, err := parser.ParseFile(fset, filename, nil, parser.ParseComments) // 解析Go源码，得到AST\n    if err != nil {\n        return nil, fmt.Errorf(\"error parsing %s: %w\", filename, err)\n    }\n\n    if !hasFuncDecl(curAST) { // 如果整个源码都不包含函数声明，则无需注入操作，直接返回。\n        return nil, nil\n    }\n\n    // 在AST上添加包导入语句\n    astutil.AddImport(fset, curAST, a.traceImport)\n\n    // 向AST上的所有函数注入Trace函数\n    a.addDeferTraceIntoFuncDecls(curAST)\n\n    buf := &amp;bytes.Buffer{}\n    err = format.Node(buf, fset, curAST) // 将修改后的AST转换回Go源码\n    if err != nil {\n        return nil, fmt.Errorf(\"error formatting new code: %w\", err)\n    }\n    return buf.Bytes(), nil // 返回转换后的Go源码\n}\n</code></pre><p>通过代码，我们看到Instrument方法的基本步骤与上面原理图大同小异。Instrument首先通过go/paser的ParserFile函数对传入的Go源文件中的源码进行解析，并得到对应的抽象语法树AST，然后向AST中导入Trace函数所在的包，并向这个AST的所有函数声明注入Trace函数调用。</p><p>实际的注入操作发生在instrumenter的addDeferTraceIntoFuncDecls方法中，我们来看一下这个方法的实现：</p><pre><code class=\"language-plain\">// instrument_trace/instrumenter/ast/ast.go\n\nfunc (a instrumenter) addDeferTraceIntoFuncDecls(f *ast.File) {\n    for _, decl := range f.Decls { // 遍历所有声明语句\n        fd, ok := decl.(*ast.FuncDecl) // 类型断言：是否为函数声明\n        if ok { \n            // 如果是函数声明，则注入跟踪设施\n            a.addDeferStmt(fd)\n        }\n    }\n}\n</code></pre><p>这个方法的逻辑十分清晰，就是遍历语法树上所有声明语句，如果是函数声明，就调用instrumenter的addDeferStmt方法进行注入，如果不是，就直接返回。addDeferStmt方法的实现如下：</p><pre><code class=\"language-plain\">// instrument_trace/instrumenter/ast/ast.go\n\nfunc (a instrumenter) addDeferStmt(fd *ast.FuncDecl) (added bool) {\n    stmts := fd.Body.List\n\n    // 判断\"defer trace.Trace()()\"语句是否已经存在\n    for _, stmt := range stmts {\n        ds, ok := stmt.(*ast.DeferStmt)\n        if !ok {\n            // 如果不是defer语句，则继续for循环\n            continue\n        }\n\n        // 如果是defer语句，则要进一步判断是否是defer trace.Trace()()\n        ce, ok := ds.Call.Fun.(*ast.CallExpr)\n        if !ok {\n            continue\n        }\n\n        se, ok := ce.Fun.(*ast.SelectorExpr)\n        if !ok {\n            continue\n        }\n\n        x, ok := se.X.(*ast.Ident)\n        if !ok {\n            continue\n        }\n        if (x.Name == a.tracePkg) &amp;&amp; (se.Sel.Name == a.traceFunc) {\n            // defer trace.Trace()()已存在，返回\n            return false\n        }\n    }\n\n    // 没有找到\"defer trace.Trace()()\"，注入一个新的跟踪语句\n    // 在AST上构造一个defer trace.Trace()()\n    ds := &amp;ast.DeferStmt{\n        Call: &amp;ast.CallExpr{\n            Fun: &amp;ast.CallExpr{\n                Fun: &amp;ast.SelectorExpr{\n                    X: &amp;ast.Ident{\n                        Name: a.tracePkg,\n                    },\n                    Sel: &amp;ast.Ident{\n                        Name: a.traceFunc,\n                    },\n                },\n            },\n        },\n    }\n\n    newList := make([]ast.Stmt, len(stmts)+1)\n    copy(newList[1:], stmts)\n    newList[0] = ds // 注入新构造的defer语句\n    fd.Body.List = newList\n    return true\n}\n</code></pre><p>虽然addDeferStmt函数体略长，但逻辑也很清晰，就是先判断函数是否已经注入了Trace，如果有，则略过；如果没有，就构造一个Trace语句节点，并将它插入到AST中。</p><p>Instrument的最后一步就是将注入Trace后的AST重新转换为Go代码，这就是我们期望得到的带有Trace特性的Go代码了。</p><h3>利用instrument工具注入跟踪代码</h3><p>有了instrument工具后，我们再来看看如何使用这个工具，在目标Go源文件中自动注入跟踪设施。</p><p>这里，我在instrument_trace项目的examples目录下建立了一个名为demo的项目，我们就来看看如何使用instrument工具为demo项目下的demo.go文件自动注入跟踪设施。demo.go文件内容很简单：</p><pre><code class=\"language-plain\">// instrument_trace/examples/demo/demo.go\n\npackage main\n\nfunc foo() {\n    bar()\n}\n\nfunc bar() {\n}\n\nfunc main() {\n    foo()\n}\n</code></pre><p>我们首先构建一下instrument_trace下的instrument工具：</p><pre><code class=\"language-plain\">$cd instrument_trace\n$go build github.com/bigwhite/instrument_trace/cmd/instrument\n$instrument version \n[instrument version]\ninstrument [-w] xxx.go\n  -w\twrite result to (source) file instead of stdout\n</code></pre><p>接下来，我们使用instrument工具向examples/demo/demo.go源文件中的函数自动注入跟踪设施：</p><pre><code class=\"language-plain\">$instrument -w  examples/demo/demo.go\n[instrument -w examples/demo/demo.go]\ninstrument trace for examples/demo/demo.go ok\n</code></pre><p>注入后的demo.go文件变为了下面这个样子：</p><pre><code class=\"language-plain\">// instrument_trace/examples/demo/demo.go\n\npackage main\n  \nimport \"github.com/bigwhite/instrument_trace\"\n\nfunc foo() {\n    defer trace.Trace()()\n    bar()\n}\n\nfunc bar() {\n    defer trace.Trace()()\n}\n\nfunc main() {\n    defer trace.Trace()()\n    foo()\n}\n</code></pre><p>此时，如果我们再对已注入Trace函数的demo.go执行一次instrument命令，由于instrument会判断demo.go各个函数已经注入了Trace，demo.go的内容将保持不变。</p><p>由于github.com/bigwhite/instrument_trace并没有真正上传到github.com上，所以如果你要运行demo.go，我们可以为它配置一个下面这样的go.mod：</p><pre><code class=\"language-plain\">\n\n// instrument_trace/examples/demo/go.mod\n\nmodule demo\n\ngo 1.17\n\nrequire github.com/bigwhite/instrument_trace v1.0.0\n\nreplace github.com/bigwhite/instrument_trace v1.0.0 =&gt; ../../\n</code></pre><p>这样运行demo.go就不会遇到障碍了：</p><pre><code class=\"language-plain\">$go run demo.go\ng[00001]:    -&gt;main.main\ng[00001]:        -&gt;main.foo\ng[00001]:            -&gt;main.bar\ng[00001]:            &lt;-main.bar\ng[00001]:        &lt;-main.foo\ng[00001]:    &lt;-main.main\n</code></pre><h2>小结</h2><p>到这里，我们已经实现了这节课开始时设定的目标：实现一个自动注入跟踪代码并输出有层次感的函数调用链跟踪命令行工具。</p><p>回顾一下这个工具的实现思路：我们先基于defer实现了一个最简单的函数跟踪机制，然后针对这个最简单的实现提出若干问题，接下来我们逐一把这些问题解决掉了，最终将第一版相对粗糙的代码实现演进重构为一个相对完善的命令行工具。</p><p>关于这个实战项目，有两点注意事项要和你交代清楚：</p><p>第一，在代码中注入函数调用跟踪代码仅适用于日常调试代码和阅读理解代码时使用，被注入了跟踪设施的代码是不适合上生产环境的；</p><p>第二，我在这里使用到了Go核心团队不推荐使用的Goroutine id，这也是由这个实战项目的性质所决定的。如果你的代码是上生产，我建议还是尽量听从Go核心团队的建议，<strong>不要依赖Goroutine ID</strong>。</p><h2>思考题</h2><p>通过instrument命令行工具对Go源文件进行注入后，defer trace.Trace()()就会成为Go源码的一部分被编译进最终的可执行文件中。我们在小结中也提到了，开启了Trace的代码不要上生产环境，这样我们在构建上生产的应用之前需要手工删掉这些Trace代码，操作起来十分繁琐易错。</p><p>所以，这里我想请你为Trace增加一个开关功能，有了这个开关后，日常开发调试过程中编译出的程序中的Trace是起作用的，但为生产环境编译出的可执行程序中虽然也包含Trace，但Trace不会真正起作用（提示：使用build tag）。</p><p>欢迎你把这节课分享给更多对Go语言感兴趣的朋友。我是Tony Bai，我们下节课见。</p><h4><a href=\"https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/27/instrument_trace\">这个项目的源码在这里！</a></h4>","neighbors":{"left":{"article_title":"26｜方法：如何用类型嵌入模拟实现“继承”？","id":467225},"right":{"article_title":"用户故事｜罗杰：我的Go语言学习之路","id":472588}},"comments":[{"had_liked":false,"id":327859,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1640332045,"is_pvip":true,"replies":[{"id":"120355","content":"go原生不支持注解功能。官方对此原因没有任何说明。go支持struct tag，一定程度具备了annotation的性质。","user_name":"作者回复","comment_id":327859,"uid":"1026224","ip_address":"","utype":1,"ctime":1641894670,"user_name_real":"编辑"}],"discussion_count":4,"race_medal":0,"score":"23115168525","product_id":100093501,"comment_content":"老师，问个小白的问题哈，就是Java和Python都支持注解增加能力，不会修改源代码。<br>我看您这节课的最终版本，就是工具修改源代码，那么go有没有类似Java和Python那种注解的增强能力？如果没有，那么是因为什么原因不支持呀？","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545289,"discussion_content":"go原生不支持注解功能。官方对此原因没有任何说明。go支持struct tag，一定程度具备了annotation的性质。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641894670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545614,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642002910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545289,"ip_address":""},"score":545614,"extra":""}]},{"author":{"id":1447496,"avatar":"https://static001.geekbang.org/account/avatar/00/16/16/48/01567df1.jpg","nickname":"郑泽洲","note":"","ucode":"EA1B540A040875","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553220,"discussion_content":"动态语言和静态语言风格上的区别吧。Java和Python那种注解的增强能力是虚拟机支持的，用中间码就是这好处。golang都是直接编译成机器码的，不动代码的情况下支持注解有困难。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1645771398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1447496,"avatar":"https://static001.geekbang.org/account/avatar/00/16/16/48/01567df1.jpg","nickname":"郑泽洲","note":"","ucode":"EA1B540A040875","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":553245,"discussion_content":"给大佬👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645781718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553220,"ip_address":""},"score":553245,"extra":""}]}]},{"had_liked":false,"id":327725,"user_name":"木木","can_delete":false,"product_type":"c1","uid":2704565,"ip_address":"","ucode":"86820F26A27308","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/b5/7eba5a0e.jpg","comment_is_top":false,"comment_ctime":1640252401,"is_pvip":false,"replies":[{"id":"120343","content":"waitgroup是go标准库sync包提供的一个功能特性，常用用于等待一组子goroutine的退出。可以看看go官方相关文档以及文档中的用法。","user_name":"作者回复","comment_id":327725,"uid":"1026224","ip_address":"","utype":1,"ctime":1641889889,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"18820121585","product_id":100093501,"comment_content":"感谢，这节课觉得学到了很多。有个问题，在文中演示如何获得 Goroutine ID的trace例程里，waitGroup的作用是什么？我本来以为是像信号量一样的同步手段，但是想了一想发现并不是，因为wait在A1（）之后。如果wait在A1（）之前的话，可以保证让A2先执行完再执行A1。文中这种在A1（）之后wait（）的原因是什么？","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545264,"discussion_content":"waitgroup是go标准库sync包提供的一个功能特性，常用用于等待一组子goroutine的退出。可以看看go官方相关文档以及文档中的用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641889889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570342,"discussion_content":"盲猜发展到一定程度，go就支持注解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651737875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327622,"user_name":"Geralt","can_delete":false,"product_type":"c1","uid":1184102,"ip_address":"","ucode":"2F31ED777D06A0","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","comment_is_top":false,"comment_ctime":1640203301,"is_pvip":true,"replies":[{"id":"120341","content":"都用build tag了，应该就不需要shouldprint了吧。","user_name":"作者回复","comment_id":327622,"uid":"1026224","ip_address":"","utype":1,"ctime":1641889411,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"18820072485","product_id":100093501,"comment_content":"思考题的一个思路：<br>在instrument_trace目录下新建一个config目录，里面有dev.go和prod.go两个文件：<br>dev.go<br>&#47;&#47;go:build dev<br>package config<br><br>const ShouldPrint = true<br>------<br>prod.go<br><br>&#47;&#47;go:build prod<br>package config<br><br>const ShouldPrint = false<br><br>------<br><br>修改Trace()函数，在方法体内先判断ShouldPrint的值，若为false则返回一个空的匿名函数。<br><br>通过go build -tags dev(prod) 可以指定config目录下哪个文件参与编译。","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545259,"discussion_content":"都用build tag了，应该就不需要shouldprint了吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641889411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545270,"discussion_content":"是的，有点画蛇添足了，谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641890679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545259,"ip_address":""},"score":545270,"extra":""}]}]},{"had_liked":false,"id":327522,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1640160725,"is_pvip":true,"replies":[{"id":"120337","content":"👍","user_name":"作者回复","comment_id":327522,"uid":"1026224","ip_address":"","utype":1,"ctime":1641886392,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":1,"score":"18820029909","product_id":100093501,"comment_content":"就喜欢这种实战，可以把前面的知识点都串起来，对于加深理解很有帮助~","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545246,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641886392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327745,"user_name":"木木","can_delete":false,"product_type":"c1","uid":2704565,"ip_address":"","ucode":"86820F26A27308","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/b5/7eba5a0e.jpg","comment_is_top":false,"comment_ctime":1640264501,"is_pvip":false,"replies":[{"id":"120342","content":"这不能怪你，因为这里使用了接口的类型断言(type assert)语法，可以先看看第28讲后，再回来看这段代码。","user_name":"作者回复","comment_id":327745,"uid":"1026224","ip_address":"","utype":1,"ctime":1641889740,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"14525166389","product_id":100093501,"comment_content":"一个问题：老师代码里好几处用到了类似 fd, ok :=decl.(*ast.FuncDecl) 这种写法，看了一下，ast是package，FuncDecl是一个struct，decl是一个ast.Decl类型的变量，给我搞晕了。请问等号右边的意思是什么？ ","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545262,"discussion_content":"这不能怪你，因为这里使用了接口的类型断言(type assert)语法，可以先看看第28讲后，再回来看这段代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641889740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133041,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/f1/bd61dbb1.jpg","nickname":"Ransang","note":"","ucode":"DB67566A627DF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543686,"discussion_content":"类型断言 switch那节有讲过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641270516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327500,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1640151874,"is_pvip":true,"replies":[{"id":"120336","content":"1. go的map类型如果发现多个goroutine尝试对其进行写操作，但没有加锁，就可能抛出panic <br>2. 思路不错，但我对ssa ir了解不多，如果你对ssa ir很了解，建议你尝试一下，有成果后也可以分享出来。","user_name":"作者回复","comment_id":327500,"uid":"1026224","ip_address":"","utype":1,"ctime":1641886334,"user_name_real":"编辑"}],"discussion_count":7,"race_medal":0,"score":"14525053762","product_id":100093501,"comment_content":"一些疑问：<br><br>1. 在输出带缩进的跟踪信息时，用一个map保存了不同goroutine的当前缩进。但似乎每个goroutine都只会访问自己的id对应的kv，不存在不同的goroutine访问同一个key的情况。这种情况下能否不加锁呢？<br><br>2. 在其他语言的生态中，实现无侵入的链路跟踪通常都是在语言的中间表示上做文章，比如JVM字节码或是LLVM IR。查了下go似乎也有自己的一种ssa ir，那么是否有可能也在这种ir上做做文章？","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545245,"discussion_content":"1. go的map类型如果发现多个goroutine尝试对其进行写操作，但没有加锁，就可能抛出panic \n2. 思路不错，但我对ssa ir了解不多，如果你对ssa ir很了解，建议你尝试一下，有成果后也可以分享出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641886334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2831263,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/33/9f/b7f6087a.jpg","nickname":"阿白","note":"","ucode":"118CEDC8373CE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540777,"discussion_content":"不能不加锁访问，map源码里只要在读写会设置map底层结构体的一个标志位，后续的读写操作都会检查这个标志位来判断并发读写，而不是通过检测多个goroutine读写同一个key来判断并发读写的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640165363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2831263,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/33/9f/b7f6087a.jpg","nickname":"阿白","note":"","ucode":"118CEDC8373CE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540867,"discussion_content":"那这个map好像有点弱哦，明明想访问的数据在逻辑上都是相互独立的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640185853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":540777,"ip_address":""},"score":540867,"extra":""},{"author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":540922,"discussion_content":"但是map本身是共享的，所以你说的所谓的“在逻辑上都是相互独立”的说法是不对的。map作为一个经常使用到的数据结构，大多数场景下都是不需要并发安全的。如果需要并发安全的map，可以自行实现或者使用开源库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640202347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":540867,"ip_address":""},"score":540922,"extra":""},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1184102,"avatar":"https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg","nickname":"Geralt","note":"","ucode":"2F31ED777D06A0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":540945,"discussion_content":"那不用map用数组是不是可以不加锁呢？也是共享了一个数组，但读写的都是数组中不同的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640221257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":540922,"ip_address":""},"score":540945,"extra":""}]}]},{"had_liked":false,"id":345213,"user_name":"路边的猪","can_delete":false,"product_type":"c1","uid":2057354,"ip_address":"","ucode":"92F7C082E44FC4","user_header":"https://static001.geekbang.org/account/avatar/00/1f/64/8a/bc8cb43c.jpg","comment_is_top":false,"comment_ctime":1652115541,"is_pvip":true,"replies":[{"id":"126054","content":"嗯，不错的思路。","user_name":"作者回复","comment_id":345213,"uid":"1026224","ip_address":"","utype":1,"ctime":1652190351,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10242050133","product_id":100093501,"comment_content":"var mgroup = make(map[uint64]int)<br>var mutex sync.Mutex<br><br>func Trace() func() {<br>\tpc, _, _, ok := runtime.Caller(1)<br>\tif !ok {<br>\t\tfmt.Println(&quot;报错&quot;)<br>\t}<br>\tfuncccc := runtime.FuncForPC(pc)<br>\tfunname := funcccc.Name()<br>\tgid := curGoroutineID()<br><br>\tmutex.Lock()<br>\tindex := mgroup[gid]<br>\tmgroup[gid] = index + 1<br>\tmutex.Unlock()<br>\ts := &quot;&quot;<br>\tfor i := 0; i &lt;= index; i++ {<br>\t\ts = s + &quot;    &quot;<br>\t}<br>\tfmt.Printf(&quot;g[%05d]:%s-&gt; enter:%s\\n&quot;, gid, s, funname)<br>\treturn func() {<br>\t\tfmt.Printf(&quot;g[%05d]:%s&lt;- exit :%s\\n&quot;, gid, s, funname)<br>\t}<br>}<br><br>利用defer后面的表达式在入栈时求值这一特性，用一个缩紧变量就行了，闭包中的 indents -1 有点多此一举吧？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571385,"discussion_content":"嗯，不错的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652190351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348656,"user_name":"KingOfDark","can_delete":false,"product_type":"c1","uid":2790875,"ip_address":"","ucode":"F13D3A1287495B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kHoDdV15McW26tMCNnU8GSsUib9UWboAjVSe4nop5nPVt7qZNcUicCic3W50uaDHj0ibupXQtpvOUG4YaomBqHicVmg/132","comment_is_top":false,"comment_ctime":1655282234,"is_pvip":false,"replies":[{"id":"126992","content":"1. 关于go增量编译，可以了解一下 https:&#47;&#47;tonybai.com&#47;2022&#47;03&#47;21&#47;go-native-support-incremental-build <br>2. 第一个思路✅。第二种思路维护起来过于麻烦了。","user_name":"作者回复","comment_id":348656,"uid":"1026224","ip_address":"","utype":1,"ctime":1655342658,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"5950249530","product_id":100093501,"comment_content":"1. 对于go build的编译过程，有点疑问，就比如这里编译 go build demo.go ，会把依赖的包也都给重新编译吗？ 还是说依赖包的都是提前编译好的（或者说只会有一次编译，之后不会重新编译了，只需要在链接即可？）<br><br>2. 对于思考题的使用build tags，有两种思路：<br>第一种思路，是 trace.go 有两个版本（文件名可以分别为 dev_trace.go， prod_trace.go），dev 版本的trace 是正常的打印逻辑，prod 版本直接返回空函数体<br>第二种思路，是 要编译&#47;追踪的go源文件有两个版本，一个带有trace函数，一个不带trace函数（这个方法好像用不到 build tag 了，但是这样好像把defer的开销也省去了）<br>","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576176,"discussion_content":"1. 关于go增量编译，可以了解一下 https://tonybai.com/2022/03/21/go-native-support-incremental-build \n2. 第一个思路✅。第二种思路维护起来过于麻烦了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655342658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156153,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a4/39/a3e452cd.jpg","nickname":"a115","note":"","ucode":"0C733004371E29","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576744,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655774749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327910,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1640356415,"is_pvip":false,"replies":[{"id":"120399","content":"1. 这里所谓的foo函数返回后，指的是defer函数被执行，deferred函数即是那个闭包函数。<br>2.pc是程序计数器，冯 ·诺伊曼计算机体系结构中的一个寄存器。可以自行google或baidu一下。<br>3. go build后，instrument程序会出现在当前目录下。<br>4. 最大原因还是避免被滥用。避免写出强依赖goroutine id的代码。因为强依赖goroutine将导致代码不好移植，同时也会导致并发模型复杂化。<br>5. 提示里有，使用build tag。关于build tag用法，可以参考go官方文档。","user_name":"作者回复","comment_id":327910,"uid":"1026224","ip_address":"","utype":1,"ctime":1641994761,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5935323711","product_id":100093501,"comment_content":"感谢大白老师，这一讲的内容很有启发性。有几个小疑问，劳烦有时间回复一下：<br><br>1. 文中说：“于是当 foo 函数返回后，这个闭包函数就会被执行。” 我想的是，这里是不是 foo 函数返回之前，闭包函数就会被执行呢？   foo 函数返回后，是不是代表这个函数已经执行完毕了？<br><br>2. 第一个返回值代表的是程序计数（pc)。我打印pc变量，出来的是类似： 17343465、17343241、17343369······，这个计数究竟是什么呢，内存地址吗？<br><br>3. 文中的这两步操作：$go build github.com&#47;bigwhite&#47;instrument_trace&#47;cmd&#47;instrument<br>                               $instrument version<br>我的理解是编译生成了可执行二进制文件后，需要放到 类似 bin目录中，才能全局 执行 “instrument version” 命令吧？ 感觉老师这里还少了一步操作。<br><br>4. 不建议使用 Goroutine ID的最大原因是什么？ 文中链接中的讨论组内容没有仔细看完。<br><br>5. 课后问题的比较优越的实现方案是什么？想听到老师的答案。<br><br>ps：问题有点多，但是确实属于我这节课看完后的疑惑，谢谢老师解答。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545547,"discussion_content":"1. 这里所谓的foo函数返回后，指的是defer函数被执行，deferred函数即是那个闭包函数。\n2.pc是程序计数器，冯 ·诺伊曼计算机体系结构中的一个寄存器。可以自行google或baidu一下。\n3. go build后，instrument程序会出现在当前目录下。\n4. 最大原因还是避免被滥用。避免写出强依赖goroutine id的代码。因为强依赖goroutine将导致代码不好移植，同时也会导致并发模型复杂化。\n5. 提示里有，使用build tag。关于build tag用法，可以参考go官方文档。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641994761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327525,"user_name":"左耳朵东","can_delete":false,"product_type":"c1","uid":1160678,"ip_address":"","ucode":"60134ACF12BB52","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","comment_is_top":false,"comment_ctime":1640161506,"is_pvip":false,"replies":[{"id":"120338","content":"demo下的go.mod中内容是否正确？","user_name":"作者回复","comment_id":327525,"uid":"1026224","ip_address":"","utype":1,"ctime":1641888374,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"5935128802","product_id":100093501,"comment_content":"我生成的 demo.go 文件和老师一样，但执行的时候为什么报错：<br>examples\\demo\\demo.go:3:8: imported and not used: &quot;instrument_trace&quot;<br>examples\\demo\\demo.go:6:8: undefined: trace<br>examples\\demo\\demo.go:11:8: undefined: trace<br>examples\\demo\\demo.go:15:8: undefined: trace","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545251,"discussion_content":"demo下的go.mod中内容是否正确？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641888374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1313498,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","nickname":"qiutian","note":"","ucode":"99658A8E342498","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575089,"discussion_content":"我也遇到了这个问题，我发现是我的trace.go文件的第一行的包名写错了，应该是package trace，这样在demo.go中才会识别的到，否则demo.go中的trace.Trace()()这个是找不到trace包的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654588975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541397,"discussion_content":"感觉是你instrument_trace项目目录下的go.mod文件中的module声明有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640355155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327508,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1640156655,"is_pvip":true,"replies":[{"id":"120398","content":"不建议使用。","user_name":"作者回复","comment_id":327508,"uid":"1026224","ip_address":"","utype":1,"ctime":1641994136,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5935123951","product_id":100093501,"comment_content":"老师，还有其他方式获取Goroutine ID？还是不建议使用Goroutine ID？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545545,"discussion_content":"不建议使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641994136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327481,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1640144038,"is_pvip":false,"replies":[{"id":"120372","content":"嗯，可以对比一下两种方法哪个更适合。","user_name":"作者回复","comment_id":327481,"uid":"1026224","ip_address":"","utype":1,"ctime":1641957162,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":2,"score":"5935111334","product_id":100093501,"comment_content":"干货满满，这节的代码最好手动码出来，亲自好好感受一下。我们线上的环境基本上都是环境变量控制，go build 倒是从来没有使用过，这个也可以尝试一下。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545431,"discussion_content":"嗯，可以对比一下两种方法哪个更适合。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641957162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359676,"user_name":"pythonbug","can_delete":false,"product_type":"c1","uid":1487274,"ip_address":"辽宁","ucode":"1A70CA92FFF8EB","user_header":"https://wx.qlogo.cn/mmopen/vi_32/wgMMrp1hvSB3E30KqZvMsj3KQdAI3T1uQM77LT7hZ65nVSjPGRg3AbUOyiahnssA6AIT5PAkyHFmlTBzUH9gdyQ/132","comment_is_top":false,"comment_ctime":1665741308,"is_pvip":true,"replies":[{"id":"130859","content":"第23讲 讲defer时说过一点：“defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的。”<br><br>这一讲，defer Trace(&quot;main&quot;)() &lt;=&gt; defer f()，而f其实是Trace(&quot;main&quot;)的返回值，在注册deferred函数时，会对Trace(&quot;main&quot;)进行求值，求值结果为一个闭包函数。结果就是：这个闭包函数被注册到 deferred 函数栈中了。","user_name":"作者回复","comment_id":359676,"uid":"1026224","ip_address":"辽宁","utype":1,"ctime":1665836642,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1665741308","product_id":100093501,"comment_content":"老师好，我一开始就没看懂。。。就是Trace(name string)这个作为deferred函数，为啥会先执行println。不是应该等函数执行后，再执行里面的内容么。难道是因为Trace(name string)这个函数的返回值是一个闭包函数，所以不一样吗","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590522,"discussion_content":"第23讲 讲defer时说过一点：“defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的。”\n\n这一讲，defer Trace(&#34;main&#34;)() &lt;=&gt; defer f()，而f其实是Trace(&#34;main&#34;)的返回值，在注册deferred函数时，会对Trace(&#34;main&#34;)进行求值，求值结果为一个闭包函数。结果就是：这个闭包函数被注册到 deferred 函数栈中了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665836643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1487274,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/wgMMrp1hvSB3E30KqZvMsj3KQdAI3T1uQM77LT7hZ65nVSjPGRg3AbUOyiahnssA6AIT5PAkyHFmlTBzUH9gdyQ/132","nickname":"pythonbug","note":"","ucode":"1A70CA92FFF8EB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":590573,"discussion_content":"感谢大佬，明白了，多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665895280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":590522,"ip_address":"江苏"},"score":590573,"extra":""}]}]},{"had_liked":false,"id":355017,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"北京","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1660982686,"is_pvip":true,"replies":[{"id":"129212","content":"👍","user_name":"作者回复","comment_id":355017,"uid":"1026224","ip_address":"北京","utype":1,"ctime":1661135549,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1660982686","product_id":100093501,"comment_content":"打卡","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584785,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661135549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343651,"user_name":"Geek_as","can_delete":false,"product_type":"c1","uid":1534500,"ip_address":"","ucode":"AB7B70DBC2B5F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","comment_is_top":false,"comment_ctime":1650966783,"is_pvip":true,"replies":[{"id":"125493","content":"runtime层面对map并发读写的检测是整体的，不会考虑goroutine是否各自访问自己的数据。","user_name":"作者回复","comment_id":343651,"uid":"1026224","ip_address":"","utype":1,"ctime":1651050554,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1650966783","product_id":100093501,"comment_content":"老师，我觉得那个map加锁好像不需要，map的确是不支持并发写，但我觉得这个并发写，应该是不支持多个gorunine对同一个key写，但是现在这个项目，每个gorunine是对属于自己的key进行操作，即每个key任何时刻最多只会被一个gorunine写，不存在并发问题","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568039,"discussion_content":"runtime层面对map并发读写的检测是整体的，不会考虑goroutine是否各自访问自己的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651050555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338895,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1647779744,"is_pvip":true,"replies":[{"id":"123917","content":"在我的初衷里，生产环境是不应该开启该Trace的，该Trace更多是在日常dev&#47;debug&#47;read source code时使用。可以通过go build -tag方式开启和关闭Trace。","user_name":"作者回复","comment_id":338895,"uid":"1026224","ip_address":"","utype":1,"ctime":1647904596,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1647779744","product_id":100093501,"comment_content":"在日志里面加锁也不是一个好的方案吧","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557618,"discussion_content":"在我的初衷里，生产环境是不应该开启该Trace的，该Trace更多是在日常dev/debug/read source code时使用。可以通过go build -tag方式开启和关闭Trace。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647904596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336662,"user_name":"二刀田","can_delete":false,"product_type":"c1","uid":1360554,"ip_address":"","ucode":"1854DA6F1017E5","user_header":"https://static001.geekbang.org/account/avatar/00/14/c2/aa/fbff810a.jpg","comment_is_top":false,"comment_ctime":1646278360,"is_pvip":true,"replies":[{"id":"123104","content":"👍","user_name":"作者回复","comment_id":336662,"uid":"1026224","ip_address":"","utype":1,"ctime":1646469337,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1646278360","product_id":100093501,"comment_content":"看完这章，有种酣畅淋漓的感觉","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554566,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646469337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335893,"user_name":"顷","can_delete":false,"product_type":"c1","uid":1132878,"ip_address":"","ucode":"096B6859C1FA80","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/4e/8798cd01.jpg","comment_is_top":false,"comment_ctime":1645758940,"is_pvip":true,"replies":[{"id":"122778","content":"你是用go 1.17，并在终端命令行中跑的么？还是在一些IDE中运行的？","user_name":"作者回复","comment_id":335893,"uid":"1026224","ip_address":"","utype":1,"ctime":1645837851,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"1645758940","product_id":100093501,"comment_content":"老师我1.17  第一个例子跑出来为啥是<br>enter： foo<br>enter： bar<br>exit:  bar<br>exit:  foo<br>enter： main","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553301,"discussion_content":"你是用go 1.17，并在终端命令行中跑的么？还是在一些IDE中运行的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645837851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1132878,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/4e/8798cd01.jpg","nickname":"顷","note":"","ucode":"096B6859C1FA80","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":553573,"discussion_content":"检查了几遍，发现是有一行是调用defer Trace(&#34;main&#34;)   而不是defer Trace(&#34;main&#34;)（）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645968336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553301,"ip_address":""},"score":553573,"extra":""},{"author":{"id":1132878,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/4e/8798cd01.jpg","nickname":"顷","note":"","ucode":"096B6859C1FA80","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":553578,"discussion_content":"思考题：我建立了一个trace_dev.go  一个trace_prod.go ,为什么重写的demo.go \n文件提示import github.com/xxx/instrument_trace 包仅含测试文件 运行不了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645969996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553301,"ip_address":""},"score":553578,"extra":""}]}]},{"had_liked":false,"id":334263,"user_name":"Geek_2337af","can_delete":false,"product_type":"c1","uid":2847330,"ip_address":"","ucode":"54B135EB7E70F1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep7c7UKsjRiclaAqD9vMHSUXayzrvRhvic3Lm6ibX82L3DibJnCCtDmB3OfxbuVjetpT6Qa8IuwqZCWlw/132","comment_is_top":false,"comment_ctime":1644833395,"is_pvip":false,"replies":[{"id":"122150","content":"好问题！如果是像用go build xxx&#47;yyy 构建main包，那么go build会生成名为yyy的可执行文件。如果main包下面有很多源文件，也是可以这么构建的。<br> ","user_name":"作者回复","comment_id":334263,"uid":"1026224","ip_address":"","utype":1,"ctime":1644917898,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644833395","product_id":100093501,"comment_content":"老师解读一下go build github.com&#47;bigwhite&#47;instrument_trace&#47;cmd&#47;instrument，这样是整个包构建的吗，然后生成的文件名默认是包名instrument，如果instrument包里面还有main.go依赖的源码文件，还这样这样构建可以吗","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551178,"discussion_content":"好问题！如果是像用go build xxx/yyy 构建main包，那么go build会生成名为yyy的可执行文件。如果main包下面有很多源文件，也是可以这么构建的。\n ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644917898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330484,"user_name":"lemon","can_delete":false,"product_type":"c1","uid":2323716,"ip_address":"","ucode":"47626025C55E5E","user_header":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","comment_is_top":false,"comment_ctime":1641993093,"is_pvip":false,"replies":[{"id":"121544","content":"什么os？用.&#47;instrument呢？","user_name":"作者回复","comment_id":330484,"uid":"1026224","ip_address":"","utype":1,"ctime":1643443054,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1641993093","product_id":100093501,"comment_content":"老师，我这边按照步骤写完代码build之后显示command not found: instrument，这是为什么呀，从GitHub上clone下来老师您的代码build之后也不行...很奇怪","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548909,"discussion_content":"什么os？用./instrument呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643443054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329706,"user_name":"hcyycb","can_delete":false,"product_type":"c1","uid":1226968,"ip_address":"","ucode":"77FF6CA41F9E66","user_header":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","comment_is_top":false,"comment_ctime":1641483471,"is_pvip":true,"replies":[{"id":"120482","content":"我按照你的思路修改了一下并运行example_test.go，得到结果:<br><br>g[00001]:    -&gt;instrument_trace_test.a<br>g[00001]:        -&gt;instrument_trace_test.b<br>g[00001]:            -&gt;instrument_trace_test.c<br>g[00001]:                -&gt;instrument_trace_test.d<br>g[00001]:                &lt;-instrument_trace_test.d<br>g[00001]:            &lt;-instrument_trace_test.c<br>g[00001]:        &lt;-instrument_trace_test.b<br>g[00001]:    &lt;-instrument_trace_test.a<br><br>macos go 1.17<br><br>没有遇到你所提到的情况。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1642041958,"ip_address":"","comment_id":329706,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1641483471","product_id":100093501,"comment_content":"跟练模拟 instrument_trace 的练习。<br>我在 go mod init 的时候，省略了“github.com&#47;bigwhite&#47;” 。<br>直接用 go mod init instrument_trace,<br>输出的结果是：<br>g[00001]:    -&gt;command-line-arguments_test.a<br>获取不到报名。本来的期望值应该是：<br>g[00001]:    -&gt;instrument_trace_test.a<br><br>不知有没有同学遇到相似的报错经历？<br>","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545701,"discussion_content":"我按照你的思路修改了一下并运行example_test.go，得到结果:\n\ng[00001]:    -&gt;instrument_trace_test.a\ng[00001]:        -&gt;instrument_trace_test.b\ng[00001]:            -&gt;instrument_trace_test.c\ng[00001]:                -&gt;instrument_trace_test.d\ng[00001]:                &lt;-instrument_trace_test.d\ng[00001]:            &lt;-instrument_trace_test.c\ng[00001]:        &lt;-instrument_trace_test.b\ng[00001]:    &lt;-instrument_trace_test.a\n\nmacos go 1.17\n\n没有遇到你所提到的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642041958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545953,"discussion_content":"谢谢老师。我这里的出错的原因是用了vscode里的终端运行。如果用系统自带的终端运行测试程序，是可以得到课程里的实验结果的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642089947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545701,"ip_address":""},"score":545953,"extra":""}]},{"author":{"id":1045910,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","nickname":"Aeins","note":"","ucode":"D5BF220767541D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574317,"discussion_content":"猜测你是这么执行测试文件的： go test example_test.go\n如下命令执行就没问题： go test","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653974329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329029,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1641036652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641036652","product_id":100093501,"comment_content":"抽象语法树看上去很厉害啊！","like_count":0},{"had_liked":false,"id":328067,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1640513129,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1640513129","product_id":100093501,"comment_content":"有点好奇的是，ide debug能调试goroutine吗？只能输出日志来查看吗","like_count":0}]}