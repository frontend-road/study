{"id":107396,"title":"23 | 如何优化垃圾回收机制？","content":"<p>你好，我是刘超。</p><p>我们知道，在Java开发中，开发人员是无需过度关注对象的回收与释放的，JVM的垃圾回收机制可以减轻不少工作量。但完全交由JVM回收对象，也会增加回收性能的不确定性。在一些特殊的业务场景下，不合适的垃圾回收算法以及策略，都有可能导致系统性能下降。</p><p><span class=\"orange\">面对不同的业务场景，垃圾回收的调优策略也不一样。</span>例如，在对内存要求苛刻的情况下，需要提高对象的回收效率；在CPU使用率高的情况下，需要降低高并发时垃圾回收的频率。可以说，垃圾回收的调优是一项必备技能。</p><p>这讲我们就把这项技能的学习进行拆分，看看回收（后面简称GC）的算法有哪些，体现GC算法好坏的指标有哪些，又如何根据自己的业务场景对GC策略进行调优？</p><h2>垃圾回收机制</h2><p>掌握GC算法之前，我们需要先弄清楚3个问题。第一，回收发生在哪里？第二，对象在什么时候可以被回收？第三，如何回收这些对象？</p><h3>1. 回收发生在哪里？</h3><p>JVM的内存区域中，程序计数器、虚拟机栈和本地方法栈这3个区域是线程私有的，随着线程的创建而创建，销毁而销毁；栈中的栈帧随着方法的进入和退出进行入栈和出栈操作，每个栈帧中分配多少内存基本是在类结构确定下来的时候就已知的，因此这三个区域的内存分配和回收都具有确定性。</p><!-- [[[read_end]]] --><p>那么垃圾回收的重点就是关注堆和方法区中的内存了，堆中的回收主要是对象的回收，方法区的回收主要是废弃常量和无用的类的回收。</p><h3>2. 对象在什么时候可以被回收？</h3><p>那JVM又是怎样判断一个对象是可以被回收的呢？<span class=\"orange\">一般一个对象不再被引用，就代表该对象可以被回收。</span>目前有以下两种算法可以判断该对象是否可以被回收。</p><p><strong>引用计数算法：</strong>这种算法是通过一个对象的引用计数器来判断该对象是否被引用了。每当对象被引用，引用计数器就会加1；每当引用失效，计数器就会减1。当对象的引用计数器的值为0时，就说明该对象不再被引用，可以被回收了。这里强调一点，虽然引用计数算法的实现简单，判断效率也很高，但它存在着对象之间相互循环引用的问题。</p><p><strong>可达性分析算法：</strong>GC  Roots  是该算法的基础，GC Roots是所有对象的根对象，在JVM加载时，会创建一些普通对象引用正常对象。这些对象作为正常对象的起始点，在垃圾回收时，会从这些GC Roots开始向下搜索，当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可用的。目前HotSpot虚拟机采用的就是这种算法。</p><p>以上两种算法都是通过引用来判断对象是否可以被回收。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种：</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/0a/5c671c5ae73cbb8bc14b38d9e871530a.jpg?wh=1358*488\" alt=\"\"></p><h3>3. 如何回收这些对象？</h3><p>了解完Java程序中对象的回收条件，那么垃圾回收线程又是如何回收这些对象的呢？JVM垃圾回收遵循以下两个特性。</p><p><strong>自动性：</strong>Java提供了一个系统级的线程来跟踪每一块分配出去的内存空间，当JVM处于空闲循环时，垃圾收集器线程会自动检查每一块分配出去的内存空间，然后自动回收每一块空闲的内存块。</p><p><strong>不可预期性：</strong>一旦一个对象没有被引用了，该对象是否立刻被回收呢？答案是不可预期的。我们很难确定一个没有被引用的对象是不是会被立刻回收掉，因为有可能当程序结束后，这个对象仍在内存中。</p><p>垃圾回收线程在JVM中是自动执行的，Java程序无法强制执行。我们唯一能做的就是通过调用System.gc方法来\"建议\"执行垃圾收集器，但是否可执行，什么时候执行？仍然不可预期。</p><h2>GC算法</h2><p>JVM提供了不同的回收算法来实现这一套回收机制，通常垃圾收集器的回收算法可以分为以下几种：</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/b9/3f4316c41d4ffb27e5a36db5f2641db9.jpg?wh=1314*404\" alt=\"\"></p><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，JDK1.7 update14 之后Hotspot虚拟机所有的回收器整理如下（以下为服务端垃圾收集器）：</p><p><img src=\"https://static001.geekbang.org/resource/image/28/74/2824581e7c94a3a94b2b0abb1d348974.jpg?wh=1896*702\" alt=\"\"></p><p>其实在JVM规范中并没有明确GC的运作方式，各个厂商可以采用不同的方式实现垃圾收集器。<span class=\"orange\">我们可以通过JVM工具查询当前JVM使用的垃圾收集器类型，</span>首先通过ps命令查询出进程ID，再通过jmap -heap ID查询出JVM的配置信息，其中就包括垃圾收集器的设置类型。</p><p><img src=\"https://static001.geekbang.org/resource/image/95/97/953dc139ff9035b41d06d4a400395e97.png?wh=476*627\" alt=\"\"></p><h2>GC性能衡量指标</h2><p>一个垃圾收集器在不同场景下表现出的性能也不一样，那么如何评价一个垃圾收集器的性能好坏呢？我们可以借助一些指标。</p><p><strong>吞吐量：</strong>这里的吞吐量是指应用程序所花费的时间和系统总运行时间的比值。我们可以按照这个公式来计算GC的吞吐量：系统总运行时间=应用程序耗时+GC耗时。如果系统运行了100分钟，GC耗时1分钟，则系统吞吐量为99%。<span class=\"orange\">GC的吞吐量一般不能低于95%。</span></p><p><strong>停顿时间：</strong>指垃圾收集器正在运行时，应用程序的暂停时间。对于串行回收器而言，停顿时间可能会比较长；而使用并发回收器，由于垃圾收集器和应用程序交替运行，程序的停顿时间就会变短，但其效率很可能不如独占垃圾收集器，系统的吞吐量也很可能会降低。</p><p><strong>垃圾回收频率：</strong>多久发生一次指垃圾回收呢？通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿时间。所以我们只要适当地增大堆内存空间，保证正常的垃圾回收频率即可。</p><h2>查看&amp;分析GC日志</h2><p>已知了性能衡量指标，现在我们需要通过工具查询GC相关日志，统计各项指标的信息。首先，我们需要通过JVM参数预先设置GC日志，通常有以下几种JVM参数设置：</p><pre><code>-XX:+PrintGC 输出GC日志\n-XX:+PrintGCDetails 输出GC的详细日志\n-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）\n-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）\n-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息\n-Xloggc:../logs/gc.log 日志文件的输出路径\n</code></pre><p>这里使用如下参数来打印日志：</p><pre><code>-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs\n</code></pre><p>打印后的日志为：</p><p><img src=\"https://static001.geekbang.org/resource/image/58/58/58d74b6e3e68edf9b595287686b42b58.png?wh=1333*319\" alt=\"\"></p><p>上图是运行很短时间的GC日志，如果是长时间的GC日志，我们很难通过文本形式去查看整体的GC性能。此时，我们可以通过<a href=\"https://sourceforge.net/projects/gcviewer/\">GCViewer</a>工具打开日志文件，图形化界面查看整体的GC性能，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/69/79/69db951663299d342aad572d911b0279.jpeg?wh=1928*1048\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/f9/37/f95d5db87d20068085b6d67cd6822d37.png?wh=1928*1048\" alt=\"\"></p><p>通过工具，我们可以看到吞吐量、停顿时间以及GC的频率，从而可以非常直观地了解到GC的性能情况。</p><p>这里我再推荐一个比较好用的GC日志分析工具，<a href=\"https://www.gceasy.io/index.jsp\">GCeasy</a>是一款非常直观的GC日志分析工具，我们可以将日志文件压缩之后，上传到GCeasy官网即可看到非常清楚的GC日志分析结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/22/ab3119a73f313d20a4aa0cee02e84022.jpeg?wh=1190*405\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/ef/27/ef85b02537b9c970d55d3bbd5a3e3427.jpeg?wh=1197*820\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/71/95/71e8f8922bc7045a7b52e5a6dff82595.jpeg?wh=1173*700\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/83/be/834d779d27afbee8c70219c1628f0bbe.jpeg?wh=1190*810\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/83/ba/830069547013fdcbbb74c1e9b75a77ba.jpeg?wh=1199*631\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/63/8e/638ede71247b855b50e04a25564f268e.jpeg?wh=1215*192\" alt=\"\"></p><h2>GC调优策略</h2><p>找出问题后，就可以进行调优了，下面介绍几种常用的GC调优策略。</p><h3>1. 降低Minor GC频率</h3><p>通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此我们可以通过增大新生代空间来降低Minor GC的频率。</p><p>可能你会有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但不会增加单次Minor GC的时间吗？如果单次Minor GC的时间增加，那也很难达到我们期待的优化效果呀。</p><p>我们知道，单次Minor  GC时间是由两部分组成：T1（扫描新生代）和T2（复制存活对象）。假设一个对象在Eden区的存活时间为500ms，Minor  GC的时间间隔是300ms，那么正常情况下，Minor  GC的时间为 ：T1+T2。</p><p>当我们增大新生代空间，Minor  GC的时间间隔可能会扩大到600ms，此时一个存活500ms的对象就会在Eden区中被回收掉，此时就不存在复制存活对象了，所以再发生Minor  GC的时间为：两次扫描新生代，即2T1。</p><p><span class=\"orange\">可见，扩容后，Minor GC时增加了T1，但省去了T2的时间。</span>通常在虚拟机中，复制对象的成本要远高于扫描成本。</p><p>如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加Minor  GC的时间。如果堆中的短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。因此，单次Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小。</p><h3>2. 降低Full GC的频率</h3><p>通常情况下，由于堆内存空间不足或老年代对象太多，会触发Full GC，频繁的Full  GC会带来上下文切换，增加系统的性能开销。我们可以使用哪些方法来降低Full GC的频率呢？</p><p><strong>减少创建大对象：</strong>在平常的业务场景中，我们习惯一次性从数据库中查询出一个大对象用于web端显示。例如，我之前碰到过一个一次性查询出60个字段的业务操作，这种大对象如果超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过Minor GC之后也会进入到老年代。这种大对象很容易产生较多的Full GC。</p><p>我们可以将这种大对象拆解出来，首次只查询一些比较重要的字段，如果还需要其它字段辅助查看，再通过第二次查询显示剩余的字段。</p><p><strong>增大堆内存空间：</strong>在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低Full GC的频率。</p><h3>选择合适的GC回收器</h3><p>假设我们有这样一个需求，要求每次操作的响应时间必须在500ms以内。这个时候我们一般会选择响应速度较快的GC回收器，CMS（Concurrent Mark Sweep）回收器和G1回收器都是不错的选择。</p><p>而当我们的需求对系统吞吐量有要求时，就可以选择Parallel Scavenge回收器来提高系统的吞吐量。</p><h2>总结</h2><p>今天的内容比较多，最后再强调几个重点。</p><p>垃圾收集器的种类很多，我们可以将其分成两种类型，一种是响应速度快，一种是吞吐量高。通常情况下，CMS和G1回收器的响应速度快，Parallel Scavenge回收器的吞吐量高。</p><p>在JDK1.8环境下，默认使用的是Parallel Scavenge（年轻代）+Serial Old（老年代）垃圾收集器，你可以通过文中介绍的查询JVM的GC默认配置方法进行查看。</p><p>通常情况，JVM是默认垃圾回收优化的，在没有性能衡量标准的前提下，尽量避免修改GC的一些性能配置参数。如果一定要改，那就必须基于大量的测试结果或线上的具体性能来进行调整。</p><h2>思考题</h2><p><span class=\"orange\">以上我们讲到了CMS和G1回收器，你知道G1是如何实现更好的GC性能的吗？</span></p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","comments":[{"had_liked":false,"id":113406,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1562997906,"is_pvip":false,"replies":[{"id":"41791","content":"赞，Region这块 Jxin讲解的通俗易懂。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563329983,"ip_address":"","comment_id":113406,"utype":1}],"discussion_count":4,"race_medal":0,"score":"212016395410","product_id":100028001,"comment_content":"1.7及前的都还好说，毕竟大部分开发都拜读过&lt;深入理解jvm&gt;。<br>回归整体，记得有点模糊了，如果有错误还请老师指正。首先cms在1.9已经被标记为废弃，主要原因在于标记清除下的悬浮内存，导致内存空间碎片化，进而导致fullGC的发生。不过其并行执行垃圾回收的性能还是值得认可的，至少1.9后主推的G1在常规情况下也是不如它的效率好的。接下来，说下G1，拼G1的堆内存结构比较特殊，虽然也有年代划分，但从物理角度上却不一样。G1将整块内存分配成若干个同等大小的reg。新生代（两个sub区加ed区）和老年代各自由不同数量的reg组成。垃圾回收的算法应该算是标记整理。所以其规避了cms内存碎片化的问题，大大降低了fullGC的频率。所以它虽然常态性能略输于cms但却没有cms特殊情况下的极端性能问题，总体更稳定。值得一提的是G1中各代的内存区域里reg间不一定是连续的，所以对于cpu缓存加载机制并不是特别友好，而且大对象占据超过一个reg时还带来内存浪费的问题。所以总的来说1.8可以用G1但得考虑场景，首先这个内存空间要大，保证每个reg尽量大，以减少内存浪费，保守估计8g以上用g1。实际公司很少会去升级jdk版本，大部分都是1.8，好在oracle一些1.9 10 11 12的特性都有以补丁的方式落到1.8。所以1.8还是比较安全实用的，虽然我们公司还是1.7，推不动哈。","like_count":50,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458206,"discussion_content":"赞，Region这块 Jxin讲解的通俗易懂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563329983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182440,"discussion_content":"老哥 问个面试题 创建一个100M的数组，程序OOM，但是分析日志发现 堆内存还大于100M，造成这个问题有哪些情况","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582425400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1097943,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJB6qS9nxicvToSX4fTrDNv7OVBtsrfr6VwLjPLcwZS8ibicczM15qVx473KgrYQg0TIFeibXD0RgK6WQ/132","nickname":"传志","note":"","ucode":"2B0F67BCFCB3D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237450,"discussion_content":"数组存储需要连续的内存空间，堆内存大于100m但可能不是连续的内存空间","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1587141949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":182440,"ip_address":""},"score":237450,"extra":""}]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182650,"discussion_content":"这问题本身就有点奇怪。oom从来不局限与堆内存，堆内存的oom只是oom的一种出发场景。其他场景还有：虚拟机栈和本地方法栈oom，方法区常量池的oom，以及直接内存的oom。 同时1.8前的jdk在docker容器中会有点问题。假定申请了2g堆空间，但实际只拿到1g的宿主机内存分配，进而虽然堆空间还有内存。但依旧申请不到。 靠记忆蛮回答，不确定对错，最好自己再验证下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582444946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113533,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1563071147,"is_pvip":false,"replies":[{"id":"41376","content":"Liam提出的这两个问题非常好。<br>1、不管什么GC，都会发送stop the world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关系，Serial、PartNew、Parallel Scavenge收集器无论是串行还是并行，都会挂起用户线程，而CMS和G1在并发标记时，是不会挂起用户线程，但其他时候一样会挂起用户线程，stop the world的时间相对来说小很多了。<br><br>2、major gc很多参考资料指的是等价于full gc，我们也可以发现很多性能监测工具中只有minor gc和full gc。<br>一般情况下，一次full gc将会对年轻代、老年代以及元空间、堆外内存进行垃圾回收。而触发Full GC的原因有很多：<br>a、当年轻代晋升到老年代的对象大小比目前老年代剩余的空间大小还要大时，此时会触发Full GC；<br>b、当老年代的空间使用率超过某阈值时，此时会触发Full GC;<br>c、当元空间不足时（JDK1.7永久代不足），也会触发Full GC;<br>d、当调用System.gc()也会安排一次Full GC;<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563091972,"ip_address":"","comment_id":113533,"utype":1}],"discussion_count":2,"race_medal":0,"score":"186246664875","product_id":100028001,"comment_content":"1 minor gc是否会导致stop the world？<br>2 major gc什么时候会发生，它和full gc的区别是什么？","like_count":44,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458263,"discussion_content":"Liam提出的这两个问题非常好。\n1、不管什么GC，都会发送stop the world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关系，Serial、PartNew、Parallel Scavenge收集器无论是串行还是并行，都会挂起用户线程，而CMS和G1在并发标记时，是不会挂起用户线程，但其他时候一样会挂起用户线程，stop the world的时间相对来说小很多了。\n\n2、major gc很多参考资料指的是等价于full gc，我们也可以发现很多性能监测工具中只有minor gc和full gc。\n一般情况下，一次full gc将会对年轻代、老年代以及元空间、堆外内存进行垃圾回收。而触发Full GC的原因有很多：\na、当年轻代晋升到老年代的对象大小比目前老年代剩余的空间大小还要大时，此时会触发Full GC；\nb、当老年代的空间使用率超过某阈值时，此时会触发Full GC;\nc、当元空间不足时（JDK1.7永久代不足），也会触发Full GC;\nd、当调用System.gc()也会安排一次Full GC;\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563091972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1515294,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1f/1e/35897c64.jpg","nickname":"。","note":"","ucode":"9B546734C73CFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333864,"discussion_content":"mark一下老师的答案～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607655575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113336,"user_name":"我又不乱来","can_delete":false,"product_type":"c1","uid":1221356,"ip_address":"","ucode":"737405E2339A8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/ec/205fd50c.jpg","comment_is_top":false,"comment_ctime":1562978157,"is_pvip":false,"replies":[{"id":"41409","content":"在Java语言里，可作为GC Root对象的包括如下几种： 1. Java虚拟机栈中的引用的对象 ； 2. 方法区中的类静态属性引用的对象 ； 3. 方法区中的常量引用的对象 ； 4. 本地方法栈中JNI的引用的对象。<br><br>我们知道，垃圾回收一般是回收堆和方法区的对象，而堆中的对象在正常情况下，一般是通过常量、全局变量、静态变量等间接引用堆中的对象，所以这些可以作为GC Root。<br><br>在任何上述的GCRoot中，有引用可以指向时，我们称之为对象可达。<br><br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563155011,"ip_address":"","comment_id":113336,"utype":1}],"discussion_count":2,"race_medal":0,"score":"83167356781","product_id":100028001,"comment_content":"超哥，我建议可以分享一下那些对象可以作为gc root的对象，为什么这些对象可以做为gc root对象？","like_count":19,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458174,"discussion_content":"在Java语言里，可作为GC Root对象的包括如下几种： 1. Java虚拟机栈中的引用的对象 ； 2. 方法区中的类静态属性引用的对象 ； 3. 方法区中的常量引用的对象 ； 4. 本地方法栈中JNI的引用的对象。\n\n我们知道，垃圾回收一般是回收堆和方法区的对象，而堆中的对象在正常情况下，一般是通过常量、全局变量、静态变量等间接引用堆中的对象，所以这些可以作为GC Root。\n\n在任何上述的GCRoot中，有引用可以指向时，我们称之为对象可达。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563155011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","nickname":"曾泽浩","note":"","ucode":"A7E5CF9E1571A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332488,"discussion_content":"老师，可以用具体的例子分析一下吗？用一个具体的类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607238594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113407,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1562998345,"is_pvip":false,"replies":[{"id":"41431","content":"赞。<br><br>理解G1中的几个重要概念：Region、SATB、RSet以及Pause Prediction Model，能更好的理解G1相对CMS的一些具体优势在哪里了。<br><br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563157775,"ip_address":"","comment_id":113407,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70282475081","product_id":100028001,"comment_content":"G1与CMS的优势在于以下几点：<br>1、并行与并发：G1能够更充分利用多CPU、多核环境运行<br>2、分代收集：G1虽然也用了分代概念，但相比其他收集器需要配合不同收集协同工作，但G1收集器能够独立管理整个堆<br>3、空间管理：与CMS的标记一清理算法不同，G1从整体上基于标记一整理算法，将整个Java堆划分为多个大小相等的独立区域（Region）,这种算法能够在运行过程中不产生内存碎片<br>4、可预测的停顿：降低停顿时间是G1和CMS共同目标，但是G1追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集器上的时间不得超过N毫秒。","like_count":17,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458207,"discussion_content":"赞。\n\n理解G1中的几个重要概念：Region、SATB、RSet以及Pause Prediction Model，能更好的理解G1相对CMS的一些具体优势在哪里了。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563157775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1977,"discussion_content":"老师好棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563158778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153000,"user_name":"FelixFly","can_delete":false,"product_type":"c1","uid":1160461,"ip_address":"","ucode":"1D39A7C3D0E31F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","comment_is_top":false,"comment_ctime":1574138257,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"53113745809","product_id":100028001,"comment_content":"在 JDK1.8 环境下，默认使用的是 Parallel Scavenge（年轻代）+Serial Old（老年代）垃圾收集器。老师，这个地方你写错了吧，用jinfo -flags 进程ID打印出-XX:+UseParallelGC是使用的这个，这个在官方文档说的是-XX:+UseParallelGC启用，-XX:+UseParallelOldGC这个会自动启用，应该为Parallel Scavenge（年轻代）+Parallel Old（老年代）垃圾收集器<br>官网参数说明（查看的是linux下的）<br>-XX:+UseParallelGC<br>Enables the use of the parallel scavenge garbage collector (also known as the throughput collector) to improve the performance of your application by leveraging multiple processors.<br><br>By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM. If it is enabled, then the -XX:+UseParallelOldGC option is automatically enabled, unless you explicitly disable it.","like_count":13,"discussions":[{"author":{"id":1257945,"avatar":"https://static001.geekbang.org/account/avatar/00/13/31/d9/1a748694.jpg","nickname":"不是党员","note":"","ucode":"1C8DD42D693FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411074,"discussion_content":"咋现在还没改过来。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635843944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928441,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","nickname":"Geek_299a34","note":"","ucode":"79AECE06F08E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316007,"discussion_content":"咋现在还没改过来。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603347898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1564213,"avatar":"","nickname":"dingdongfm","note":"","ucode":"7D17D2BC392A66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62362,"discussion_content":"你说的是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574837026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53305,"discussion_content":"你说的对，这里应该讲错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574158504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113797,"user_name":"别忘微笑","can_delete":false,"product_type":"c1","uid":1333380,"ip_address":"","ucode":"855266F40976E7","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/84/fd5031e5.jpg","comment_is_top":false,"comment_ctime":1563158124,"is_pvip":false,"replies":[{"id":"41621","content":"需要根据具体的业务来分析，正常小对象且请求平缓的应用服务中，几天一次较为正常。如果有大量大对象创建或者承受高并发场景的服务，Full GC可能会更频繁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563245189,"ip_address":"","comment_id":113797,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40217863788","product_id":100028001,"comment_content":"超哥，一个web应用，多久一次Full GC才算正常呢","like_count":9,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458391,"discussion_content":"需要根据具体的业务来分析，正常小对象且请求平缓的应用服务中，几天一次较为正常。如果有大量大对象创建或者承受高并发场景的服务，Full GC可能会更频繁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563245189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251835,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oiboHpgukqib2ASXeU0H7W1ibgRMqyrNE5KaWicicPEDy0ia8YdoneZAtvW0EFIiaqZJp2OS4dnweOgXaJ5EjJicicEqic5A/132","nickname":"覃钰栋","note":"","ucode":"19080C463658EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379875,"discussion_content":"目前生产环境1个小时一次，不知道怎么排查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624199865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120586,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1564933308,"is_pvip":false,"replies":[{"id":"44505","content":"运行XX:+UseConcMarkSweepGC命令，默认会指定年轻代和老年代的垃圾收集器，分别为ParNewGC和ConcMarkSweepGC两种收集器。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565060235,"ip_address":"","comment_id":120586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449835196","product_id":100028001,"comment_content":"老师好，我有两个问题想问一下。1.比如说看到jvm的参数，-XX:+UseConcMarkSweepGC，这个参数是单独指定了老年代的收集器呢，还是年轻代、老年代都指定了？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461395,"discussion_content":"运行XX:+UseConcMarkSweepGC命令，默认会指定年轻代和老年代的垃圾收集器，分别为ParNewGC和ConcMarkSweepGC两种收集器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565060235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132746,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568211625,"is_pvip":false,"replies":[{"id":"50987","content":"标记可以回收的对象，然后在垃圾回收时将对象回收","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568423265,"ip_address":"","comment_id":132746,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10158146217","product_id":100028001,"comment_content":"很棒，很清晰的讲明白了什么是垃圾？有几种收集垃圾的方式？有几种具体的垃圾收集器？<br>请问老师收集垃圾具体是一个什么原理？标记对应的内存可用了，还是将对应的数据都一个个清空了？<br>","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467103,"discussion_content":"标记可以回收的对象，然后在垃圾回收时将对象回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568423265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521451,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/2b/b32f1d66.jpg","nickname":"Ball","note":"","ucode":"1EE949E68D84CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338151,"discussion_content":"好像哪里都能看到你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609203541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117079,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1563964022,"is_pvip":false,"replies":[{"id":"43106","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564109297,"ip_address":"","comment_id":117079,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10153898614","product_id":100028001,"comment_content":"超哥 我想问下，相同的方法多次执行，再没有JIT编译的前提下，每一次执行都会进行一次解释执行莫？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459809,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564109297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115506,"user_name":"N","can_delete":false,"product_type":"c1","uid":1133657,"ip_address":"","ucode":"3791619172D64F","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/59/c75cb36d.jpg","comment_is_top":false,"comment_ctime":1563607679,"is_pvip":false,"replies":[{"id":"42363","content":"设置的并发标记线程数量是多少呢？可以通过-XX:ConcGCThreads尝试适当调整这个数量，为服务器CPU核数的1&#47;4，可以提高并发标记的效率。<br><br>由于JVM 垃圾回收和内存分配这块的调优错综复杂，需要我们再结合服务器上跑的相关的业务以及GC日志逐步调优。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563761894,"ip_address":"","comment_id":115506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10153542271","product_id":100028001,"comment_content":"老师您好，公司ES服务器设置最大最小堆内存26个G，G1GC,  XX:MaxGCPauseMillis =500，一段时间内old gc 都会稳定在500ms以内，但每天总会有1-2次old gc 时间很长，大概3000ms.请问该如何优化呢？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459137,"discussion_content":"设置的并发标记线程数量是多少呢？可以通过-XX:ConcGCThreads尝试适当调整这个数量，为服务器CPU核数的1/4，可以提高并发标记的效率。\n\n由于JVM 垃圾回收和内存分配这块的调优错综复杂，需要我们再结合服务器上跑的相关的业务以及GC日志逐步调优。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563761894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113326,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1562954856,"is_pvip":false,"replies":[{"id":"41817","content":"我们可以通过jstat -gc pid interval查看每次GC之后，具体的每一个分区的内存使用率变化情况。我们可以通过查看JVM设置参数来查看具体的垃圾收集器的设置参数，使用的方式有很多，例如jcmd  pid VM.flags可以查看到相关的设置参数。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563346465,"ip_address":"","comment_id":113326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152889448","product_id":100028001,"comment_content":"老师看完有两个疑问，第一这么查看minor gc回收之后 eden区存活对象的多少，第二 jmap -heap pid在图中只能看年轻代parallel gc看不到老年代的是什么垃圾回收器    对于提问 cms垃圾回收器还是分老年代和年轻代回收分多个阶段有和程序并行的阶段也有stop the world阶段 回收一整块老年代时间比较久，而 gc把年轻代和老年代也有划分，不过拆成一个region了，对region的回收成本低，而且会判断那些region回收的对象更多，而且cms要经过多次full gc才可能把不用的内存归还给操作系统  而g1只需要一次full gc就可以","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458169,"discussion_content":"我们可以通过jstat -gc pid interval查看每次GC之后，具体的每一个分区的内存使用率变化情况。我们可以通过查看JVM设置参数来查看具体的垃圾收集器的设置参数，使用的方式有很多，例如jcmd  pid VM.flags可以查看到相关的设置参数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563346465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191782,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1584796468,"is_pvip":false,"replies":[{"id":"74186","content":"出现“Concurrent Mode Failure”，我们可以使用多种方式来解决，例如将CMS触发的阈值调低，提前触发CMS GC，释放老年代内存空间，满足新生代对象提升到老年代，或应用服务直接分配大对象到老年代。我们也可以尝试调大年轻代和老年代的大小，满足对应对象的分配空间。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585139179,"ip_address":"","comment_id":191782,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5879763764","product_id":100028001,"comment_content":"CMS 收集器 有一个浮动垃圾概念， 可能出现“Concurrent Mode Failure”  导致Full GC， 能否解决一下本质原因？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488256,"discussion_content":"出现“Concurrent Mode Failure”，我们可以使用多种方式来解决，例如将CMS触发的阈值调低，提前触发CMS GC，释放老年代内存空间，满足新生代对象提升到老年代，或应用服务直接分配大对象到老年代。我们也可以尝试调大年轻代和老年代的大小，满足对应对象的分配空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585139179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179085,"user_name":"阿卧","can_delete":false,"product_type":"c1","uid":1229566,"ip_address":"","ucode":"68C0CC25E57707","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/fe/038a076e.jpg","comment_is_top":false,"comment_ctime":1581910803,"is_pvip":false,"replies":[{"id":"70516","content":"CMS只会回收老年代和永久代（元数据区）的对象。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1582721332,"ip_address":"","comment_id":179085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5876878099","product_id":100028001,"comment_content":"cms回收器只能在老年代使用吗。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484083,"discussion_content":"CMS只会回收老年代和永久代（元数据区）的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582721332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120588,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1564933422,"is_pvip":false,"replies":[{"id":"44506","content":"我觉得前者会被后者覆盖，可以自己试试，然后通过指令查询相关的生效参数。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565060349,"ip_address":"","comment_id":120588,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859900718","product_id":100028001,"comment_content":"第二个问题就是，比如说我指定了：-XX:+UseConcMarkSweepGC，也指定了：-XX:+UseParallelOldGC，那么年轻代、老年代分别是用了什么垃圾回收器呢？麻烦老师解答一下，谢谢！","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461396,"discussion_content":"我觉得前者会被后者覆盖，可以自己试试，然后通过指令查询相关的生效参数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565060349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113811,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1563160040,"is_pvip":false,"replies":[{"id":"41818","content":"具体存活的对象是在随时变化的，很难追踪，目前只能通过各个区域的大小来分析GC效率。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563346581,"ip_address":"","comment_id":113811,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5858127336","product_id":100028001,"comment_content":"老师，查看minor gc存活对象的命令是什么呢","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458395,"discussion_content":"具体存活的对象是在随时变化的，很难追踪，目前只能通过各个区域的大小来分析GC效率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563346581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344281,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","nickname":"Evan","note":"","ucode":"B877ABD0CF4661","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210983,"discussion_content":"因为在新生代Eden区，很快就回收， Minor GC是动态的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584796721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113470,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1563024761,"is_pvip":false,"replies":[{"id":"41379","content":"是标记整理算法。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563092599,"ip_address":"","comment_id":113470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857992057","product_id":100028001,"comment_content":"老师好!Serial Old不是标记整理算法么?Serial new是复制吧。我记得年轻代都是采用复制的，老年代除了CMS是标记清除(存在内存碎片)别的好像都是标记整理整理吧。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458236,"discussion_content":"是标记整理算法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563092599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349714,"user_name":"Policy","can_delete":false,"product_type":"c1","uid":1170858,"ip_address":"","ucode":"AF3EC50BDA92F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLmxBGkh4RfIaiakV14ErYFsic0dfQgtZrD5hicVJQn5T5AQ95aqhibBoQVs02OWuFOTWMV1TAYkpX2rw/132","comment_is_top":false,"comment_ctime":1656251818,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656251818","product_id":100028001,"comment_content":"老师，这个没懂：所以再发生 Minor  GC 的时间为：两次扫描新生代，即 2T1。是因为时间间隔长了一倍，所以扫描对象的数量多了一倍？","like_count":0},{"had_liked":false,"id":348161,"user_name":"🦄","can_delete":false,"product_type":"c1","uid":1570384,"ip_address":"","ucode":"DEC8C891DC1E16","user_header":"https://static001.geekbang.org/account/avatar/00/17/f6/50/34f89402.jpg","comment_is_top":false,"comment_ctime":1654788167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654788167","product_id":100028001,"comment_content":"我们用的是parallel old垃圾收集器，这个Full GC的触发条件可以配置么？ 老年代内存不停的增加，有没有可能年轻带最后一次回收导致JVM做Fullgc，整个内存不够导致应用直接挂掉呀，我发现了这种现象，就是一直不做fullgc，然后最后做的那一次应用挂了，这种怎么排查问题呀","like_count":0},{"had_liked":false,"id":340060,"user_name":"杨雪宁","can_delete":false,"product_type":"c1","uid":1183419,"ip_address":"","ucode":"827BE74F104598","user_header":"https://static001.geekbang.org/account/avatar/00/12/0e/bb/358c293c.jpg","comment_is_top":false,"comment_ctime":1648562712,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648562712","product_id":100028001,"comment_content":"老师，一直有个疑问，有说CMS适用于10G以内的内存，这个说法对吗？","like_count":0},{"had_liked":false,"id":309044,"user_name":"远方","can_delete":false,"product_type":"c1","uid":1922583,"ip_address":"","ucode":"0E2FCC59EDCAD4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELVtQAW8IIDLKcn36XM9noEfKuAKpJQrwruJzXeibDfmibIiawicj5vaoflct0LuTAiaKcmCY3gK9MknEw/132","comment_is_top":false,"comment_ctime":1629903707,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629903707","product_id":100028001,"comment_content":"堆外内存只有在full gc的时候才会回收忙吗？ ygc的时候会回收堆外内存么？ 超哥","like_count":0},{"had_liked":false,"id":301877,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625929863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625929863","product_id":100028001,"comment_content":"像替换架构组件这个问题，如何去推动并且规避人际风险呢？","like_count":0},{"had_liked":false,"id":284554,"user_name":"刚好","can_delete":false,"product_type":"c1","uid":1584204,"ip_address":"","ucode":"05447FCF4D85B0","user_header":"https://static001.geekbang.org/account/avatar/00/18/2c/4c/0eb5d084.jpg","comment_is_top":false,"comment_ctime":1616334448,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616334448","product_id":100028001,"comment_content":"老师，请问对象超过多大会被直接放到老年代，请问这个阈值如何设置","like_count":0,"discussions":[{"author":{"id":1619438,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b5/ee/f56aebe6.jpg","nickname":"猩猩","note":"","ucode":"748E447BA89B03","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371146,"discussion_content":"-XX:PretenureSizeThreshold=10240  字节单位，仅供参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619664331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270706,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609225003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609225003","product_id":100028001,"comment_content":"可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。<br>这里的T1 不会随着扩容后Minor GC的频率变小而跟着改变吗?<br>扩容后两个T1,说明600ms进行了两次扫描,那么扫描仍然还是300ms一次.但是GC频率却变成了600ms一次.","like_count":0},{"had_liked":false,"id":245644,"user_name":"Java垒墙工程师","can_delete":false,"product_type":"c1","uid":1937062,"ip_address":"","ucode":"E76AE44A9C76AE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","comment_is_top":false,"comment_ctime":1599015694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599015694","product_id":100028001,"comment_content":"老师你好，fullGC几天一次比较正常，那MinorGC呢？多久一次算正常？","like_count":0},{"had_liked":false,"id":227123,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592292928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592292928","product_id":100028001,"comment_content":"1.  jdk1.8采用的是Parallel Scavenge+Serial old当作默认垃圾收集器吗？那哪个版本用的G1?<br>2. G1主要采用的是将堆内存分为多个相同大小的region，利用 Region Set进行对象引用收集，维护了一个优先列表，当进行垃圾回收时，根据停断时间，选择最优的region进行垃圾回收，特点是1）并发、并行；2）分代收集；3）空间整理；4）可预测的停顿时间","like_count":0},{"had_liked":false,"id":206858,"user_name":"HeGuang","can_delete":false,"product_type":"c1","uid":1256762,"ip_address":"","ucode":"2B938BCB4B82FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/3a/ffa02c6d.jpg","comment_is_top":false,"comment_ctime":1586945695,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586945695","product_id":100028001,"comment_content":"当我们增大新生代空间，Minor  GC 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 Eden 区中被回收掉，此时就不存在复制存活对象了，所以再发生 Minor  GC 的时间为：两次扫描新生代，即 2T1。<br><br>这里为什么说增大 eden 区后就不存在复制存活对象了，求解惑？","like_count":0,"discussions":[{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247124,"discussion_content":"Minor GC 时，会标记-复制 Eden 区的对象，向 Survivor 区复制，加大新生代区域，Minor GC 执行的频率就会下降，而存活期短的对象，在 Minor GC 执行时，已经处于可释放的状态，自然就不会被复制。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587798649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191759,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1584794833,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584794833","product_id":100028001,"comment_content":"CMS 收集器 （Concurrent Mark Sweep） 基于“标记-清除”， 有空间碎片生产，如果分配大家对象可能产生Full GC 对CPU资源比较敏感、容易总体噬吐量降低。 浮动垃圾，会导致Full GC<br><br>G1  有Region 并生与并发、分代收集、空间整合。相对CMS停顿更小， 毫秒级","like_count":0},{"had_liked":false,"id":183782,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1583133739,"is_pvip":false,"replies":[{"id":"71175","content":"没有找到三个数字，你使用的GCViewer是什么版本？","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1583154028,"ip_address":"","comment_id":183782,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1583133739","product_id":100028001,"comment_content":"老师，GCViewer中&quot;Event Details&quot;里面的75th, 95th, 99th 是啥意思，没理解。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485776,"discussion_content":"没有找到三个数字，你使用的GCViewer是什么版本？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583154028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052859,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","nickname":"Demon.Lee","note":"","ucode":"7F0E5493A8E345","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193822,"discussion_content":"老师，我用的是mac版，1.37-SNAPSHOT, 截图链接: https://pan.baidu.com/s/1hESk2DGjdLcoNMyUzLgHyw 提取码: y8my","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583162421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175635,"user_name":"大象蚂蚁","can_delete":false,"product_type":"c1","uid":1255382,"ip_address":"","ucode":"0066D9CD979C39","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/d6/30456009.jpg","comment_is_top":false,"comment_ctime":1580786687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580786687","product_id":100028001,"comment_content":"老师讲得很细，也通俗易懂，赞！","like_count":0},{"had_liked":false,"id":167691,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1577894057,"is_pvip":false,"replies":[{"id":"65927","content":"是的，可以手动设置实践下，看看测试的结果","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1578484176,"ip_address":"","comment_id":167691,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577894057","product_id":100028001,"comment_content":"初始化堆大小和最大堆大小的区别是什么啊？如果设置的初始化堆大小&lt;最大堆大小，那么堆的使用容量达到了初始化大小时候，会自动扩容吗？？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479949,"discussion_content":"是的，可以手动设置实践下，看看测试的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578484176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166546,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1577495016,"is_pvip":false,"replies":[{"id":"65934","content":"赞","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1578487464,"ip_address":"","comment_id":166546,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577495016","product_id":100028001,"comment_content":"cms执行垃圾回收的过程:初始标记、并发标记、重新并行标记、执行回收，这就意味着标记了多少垃圾就回收多少，直到回收完为止，典型的标记整理&#47;清除算法<br>g1回收器的过程类似:初始标记、并发标记、最终标记、选择回收。最后这个选择回收就很有意思，在规定的停顿时间内，我如果回收不完，我就选择性的回收呗。所以这也就是g1为什么能够被1.9当成默认收集器的原因吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479537,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578487464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156240,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1574841755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574841755","product_id":100028001,"comment_content":"-XX:+UseParNewGC 1.8中有效。","like_count":0},{"had_liked":false,"id":131888,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1567950908,"is_pvip":false,"replies":[{"id":"50700","content":"是标记和整理的过程","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568166522,"ip_address":"","comment_id":131888,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1567950908","product_id":100028001,"comment_content":"老师。我翻阅了&lt;深入理解java虚拟机&gt;。里面提到了，Serial Old的老年代回收算法是：标记整理。不是标记清除。我查阅了oracle官网，看到的答案也是：mark-compact。应该就是标记整理","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466667,"discussion_content":"是标记和整理的过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568166522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131361,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1567730667,"is_pvip":false,"replies":[{"id":"50603","content":"可以进入Oracle官网查看技术文档。链接中只是一部分<br>https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;technotes&#47;guides&#47;vm&#47;gctuning&#47;index.html","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568086748,"ip_address":"","comment_id":131361,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1567730667","product_id":100028001,"comment_content":"老师。介绍这些垃圾回收器的官方网站，您有吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466410,"discussion_content":"可以进入Oracle官网查看技术文档。链接中只是一部分\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568086748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131243,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1567677746,"is_pvip":false,"replies":[{"id":"50217","content":"可以校验下参数是否配置正确，连接的是否是IDE进程。我们也可以打开gc日志查看具体的信息，不太可能是GC easy的问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567827041,"ip_address":"","comment_id":131243,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1567677746","product_id":100028001,"comment_content":"老师，我今天监控了一下Idea的启动。然后把Idea启动的gc日志输出到log文件，上传到GC easy了。我年轻代设置的明明是-Xmn2048m，但是GC easy显示的年轻代还是之前的旧值1g，也就是1024。我又用visualVM监控了一下，visualVM显示的就是2048了，这是怎么回事呢?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466348,"discussion_content":"可以校验下参数是否配置正确，连接的是否是IDE进程。我们也可以打开gc日志查看具体的信息，不太可能是GC easy的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567827041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126830,"user_name":"努力奋斗的Pisces","can_delete":false,"product_type":"c1","uid":1336441,"ip_address":"","ucode":"AD4F8909CF190A","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/79/f1e1ca76.jpg","comment_is_top":false,"comment_ctime":1566486643,"is_pvip":true,"replies":[{"id":"47069","content":"对的，在后面的答疑课堂中详细讲到了G1","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566610707,"ip_address":"","comment_id":126830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566486643","product_id":100028001,"comment_content":"G1已经没有分代可言了","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464188,"discussion_content":"对的，在后面的答疑课堂中详细讲到了G1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566610707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113658,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1563106991,"is_pvip":false,"replies":[{"id":"41411","content":"serial old是标记清除算法，parallel old是标记整理算法。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563155690,"ip_address":"","comment_id":113658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563106991","product_id":100028001,"comment_content":"老师你的垃圾回收器serial old 和 parallel old都是标记整理算法吧，而图片上写的是标记清除算法？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458334,"discussion_content":"serial old是标记清除算法，parallel old是标记整理算法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563155690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}