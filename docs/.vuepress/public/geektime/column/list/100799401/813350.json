{"id":813350,"title":"22｜MySQL子查询优化策略","content":"<p>你好，我是俊达。</p><p>这一讲，我们来讨论子查询的一些优化策略。子查询是SQL很重要的一个能力，平时也不少见。</p><h2>子查询的一个例子</h2><p>早期MySQL（5.5以及更早的版本）对子查询的支持比较弱，使用子查询时容易遇到性能问题。</p><p>在13讲的思考题中，就有一个执行了几天都没有完成的SQL。</p><pre><code class=\"language-plain\">Command: Query \nTime: 184551 \nState: Sending data \nInfo: select item_id, sum(sold) as sold \n      from stat_item_detail \n      where item_id in (\n           select item_id \n           from stat_item_detail \n           where gmt_create &gt;= '2019-10-05 08:59:00') \n      group by item_id\n</code></pre><p>上面这个SQL语句并不复杂，我们来构建一个测试表，准备一些数据，并做一些测试。使用下面这段SQL创建表，并写入100万行数据。</p><pre><code class=\"language-plain\">create table stat_item_detail(\n    id int not null auto_increment,\n    item_id int not null,\n    sold int not null,\n    gmt_create datetime not null,\n    padding varchar(4000),\n    primary key(id),\n    key idx_item_id(item_id),\n    key idx_gmt_create(gmt_create)\n) engine=innodb;\n\n\ncreate view digit \n  as select 0 as a union all select 1 union all select 2 union all select 3 \n     union all select 4  union all select 5 union all select 6 \n     union all select 7  union all select 8 union all select 9 ;\n\ncreate view numbers_1m AS \nselect ((((a.a * 10 + b.a)*10 + c.a)*10 + d.a)*10+e.a)*10+f.a as n\nfrom digit a, digit b, digit c, digit d, digit e, digit f;\n\ninsert into stat_item_detail(item_id, sold, gmt_create, padding)\nselect n + 1000000 - n % 2 as item_id, \n    n % 100 - n%100%2,  \n    date_add('2024-06-01 00:00:00', interval n minute) as gmt_create,\n    rpad('x', 1000, 'abcdefg ') as padding\nfrom numbers_1m;\n</code></pre><!-- [[[read_end]]] --><p>当时用的还是MySQL 5.1和5.5的版本。我们先来看一下在5.5中这个SQL的执行计划。</p><pre><code class=\"language-plain\">mysql&gt; explain select item_id, sum(sold) as sold \n      from stat_item_detail \n      where item_id in (\n           select item_id \n           from stat_item_detail \n           where Gmt_create &gt;= '2026-04-26 10:30:00') \n      group by item_id;\n\n+----+--------------------+------------------+----------------+----------------------------+-------------+---------+------+---------+-------------+\n| id | select_type        | table            | type           | possible_keys              | key         | key_len | ref  | rows    | Extra       |\n+----+--------------------+------------------+----------------+----------------------------+-------------+---------+------+---------+-------------+\n|  1 | PRIMARY            | stat_item_detail | index          | NULL                       | idx_item_id | 4       | NULL | 1000029 | Using where |\n|  2 | DEPENDENT SUBQUERY | stat_item_detail | index_subquery | idx_item_id,idx_gmt_create | idx_item_id | 4       | func |       1 | Using where |\n+----+--------------------+------------------+----------------+----------------------------+-------------+---------+------+---------+-------------+\n</code></pre><p>从上面的这个执行计划可以看到，这个SQL在执行时，先全量扫描索引idx_item_id，每得到一个item_id后，执行相关子查询（DEPENDENT SUBQUERY）select 1 from stat_item_detail where gmt_create &gt;= ‘2026-04-26 10:30:00’ and item_id = primary.item_id。当主查询中表中的数据量很大的时候，子查询执行的次数也会很多，因此SQL的性能非常差。</p><p>在我的测试环境中，执行这个SQL需要45秒左右。</p><pre><code class=\"language-plain\">mysql&gt; select item_id, sum(sold) as sold\n          from stat_item_detail\n          where item_id in (\n               select item_id\n               from stat_item_detail\n               where Gmt_create &gt;= '2026-04-26 10:30:00')\n          group by item_id;\n+---------+------+\n| item_id | sold |\n+---------+------+\n| 1999990 |  180 |\n| 1999992 |  184 |\n| 1999994 |  188 |\n| 1999996 |  192 |\n| 1999998 |  196 |\n+---------+------+\n5 rows in set (44.64 sec)\n</code></pre><p>那么将IN改成exists后，是否能提升性能呢？我们来试一下，可以看到执行时间和使用IN基本一样。</p><pre><code class=\"language-plain\">mysql&gt; select item_id, sum(sold) as sold\nfrom stat_item_detail t1\nwhere exists (\n    select 1\n    from stat_item_detail\n    where gmt_create &gt;= '2026-04-26 10:30:00'\n\tand item_id = t1.item_id )\ngroup by item_id;\n\n+---------+------+\n| item_id | sold |\n+---------+------+\n| 1999990 |  180 |\n| 1999992 |  184 |\n| 1999994 |  188 |\n| 1999996 |  192 |\n| 1999998 |  196 |\n+---------+------+\n5 rows in set (44.71 sec)\n</code></pre><p>实际上，你会发现，不管是使用IN还是Exists，执行计划都是一样的。</p><pre><code class=\"language-plain\">mysql&gt; explain select item_id, sum(sold) as sold\n     from stat_item_detail t1\n     where exists (\n         select 1\n         from stat_item_detail\n         where gmt_create &gt;= '2026-04-26 10:30:00'\n         and item_id = t1.item_id )\n     group by item_id;\n+----+--------------------+------------------+-------+----------------------------+-------------+---------+----------------+---------+-------------+\n| id | select_type        | table            | type  | possible_keys              | key         | key_len | ref            | rows    | Extra       |\n+----+--------------------+------------------+-------+----------------------------+-------------+---------+----------------+---------+-------------+\n|  1 | PRIMARY            | t1               | index | NULL                       | idx_item_id | 4       | NULL           | 1000029 | Using where |\n|  2 | DEPENDENT SUBQUERY | stat_item_detail | ref   | idx_item_id,idx_gmt_create | idx_item_id | 4       | rep.t1.item_id |       1 | Using where |\n+----+--------------------+------------------+-------+----------------------------+-------------+---------+----------------+---------+-------------+\n</code></pre><p>观察这个SQL最终返回的数据实际上并不多，因为子查询select item_id from stat_item_detail where gmt_create &gt;= '2026-04-26 10:30:00’只需要返回最近写入的数据。</p><p>那么是不是可以先执行子查询呢？我们尝试改写一下SQL。改写后，查询的效率提高了很多，但是查询的结果有点问题了。</p><pre><code class=\"language-plain\">mysql&gt; select t1.item_id, sum(t1.sold) as sold\n     from stat_item_detail t1, stat_item_detail t2\n     where t1.item_id = t2.item_id\n     and t2.gmt_create &gt;= '2026-04-26 10:30:00'\n     group by t1.item_id;\n+---------+------+\n| item_id | sold |\n+---------+------+\n| 1999990 |  360 |\n| 1999992 |  368 |\n| 1999994 |  376 |\n| 1999996 |  384 |\n| 1999998 |  392 |\n+---------+------+\n5 rows in set (0.00 sec)\n</code></pre><p>问题出在哪里呢？因为子查询中，item_id不是唯一的。改成普通的表连接后，数据有重复。因此我们需要对数据做一个去重。</p><pre><code class=\"language-plain\">select item_id, sum(sold) from (\n    select distinct t1.item_id, t1.sold as sold, t2.sold as sold2\n    from stat_item_detail t1, stat_item_detail t2\n    where t1.item_id = t2.item_id\n    and t2.gmt_create &gt;= '2026-04-26 10:30:00'\n) t group by item_id;\n+---------+-----------+\n| item_id | sum(sold) |\n+---------+-----------+\n| 1999990 |        90 |\n| 1999992 |        92 |\n| 1999994 |        94 |\n| 1999996 |        96 |\n| 1999998 |        98 |\n+---------+-----------+\n5 rows in set (0.00 sec)\n</code></pre><p>但是，这样去重后，数据还是不对。因为主表中item_id是允许重复的，我们只需要对子查询中的item_id去重。将SQL改成下面这个样子，查询结果终于正确了，SQL的效率也还不错。</p><pre><code class=\"language-plain\">mysql&gt; select t1.item_id, sum(t1.sold) as sold\nfrom stat_item_detail t1, (\n  select distinct item_id \n  from stat_item_detail t2\n  where t2.gmt_create &gt;= '2026-04-26 10:30:00') t22\nwhere t1.item_id = t22.item_id\ngroup by t1.item_id;\n+---------+------+\n| item_id | sold |\n+---------+------+\n| 1999990 |  180 |\n| 1999992 |  184 |\n| 1999994 |  188 |\n| 1999996 |  192 |\n| 1999998 |  196 |\n+---------+------+\n5 rows in set (0.00 sec)\n</code></pre><p>实际上，我们还可以使用另外一种方法来去重，也就是按主表的主键字段来去重。</p><pre><code class=\"language-plain\">select item_id, sum(sold) from (\n    select distinct t1.id,  t1.item_id, t1.sold as sold\n    from stat_item_detail t1, stat_item_detail t2\n    where t1.item_id = t2.item_id\n    and t2.gmt_create &gt;= '2026-04-26 10:30:00'\n) t group by item_id;\n\n+---------+-----------+\n| item_id | sum(sold) |\n+---------+-----------+\n| 1999990 |       180 |\n| 1999992 |       184 |\n| 1999994 |       188 |\n| 1999996 |       192 |\n| 1999998 |       196 |\n+---------+-----------+\n5 rows in set (0.00 sec)\n</code></pre><h2>MySQL的半连接（SEMIJOIN）优化</h2><p>MySQL 5.6开始引入了半连接转换，对于前面例子中的SQL，优化器会自动进行查询转换，不需要再手动改写SQL了。在MySQL 5.6和5.7中，还不会对exists做半连接优化。从MySQL 8.0.16开始，优化器对exists子查询也会进行半连接转换。</p><p>在8.0的环境中执行这个SQL，MySQL自动把查询转换成了半连接。</p><pre><code class=\"language-plain\">mysql&gt; explain select item_id, sum(sold) as sold \n      from stat_item_detail \n      where item_id in (\n           select item_id \n           from stat_item_detail \n           where Gmt_create &gt;= '2026-04-26 10:30:00') \n      group by item_id;\n\n+----+--------------+------------------+-------+----------------------------+----------------+---------+---------------------+------+----------+-----------------------+\n| id | select_type  | table            | type  | possible_keys              | key            | key_len | ref                 | rows | filtered | Extra                 |\n+----+--------------+------------------+-------+----------------------------+----------------+---------+---------------------+------+----------+-----------------------+\n|  1 | SIMPLE       | &lt;subquery2&gt;      | ALL   | NULL                       | NULL           | NULL    | NULL                | NULL |   100.00 | Using temporary       |\n|  1 | SIMPLE       | stat_item_detail | ref   | idx_item_id                | idx_item_id    | 4       | &lt;subquery2&gt;.item_id |    1 |   100.00 | NULL                  |\n|  2 | MATERIALIZED | stat_item_detail | range | idx_item_id,idx_gmt_create | idx_gmt_create | 5       | NULL                |   10 |   100.00 | Using index condition |\n+----+--------------+------------------+-------+----------------------------+----------------+---------+---------------------+------+----------+-----------------------+\n</code></pre><p>上面的这个执行计划，实际上和我们的第一种手动改写的方式类似。</p><pre><code class=\"language-plain\">mysql&gt; select t1.item_id, sum(t1.sold) as sold\nfrom stat_item_detail t1, (\n  select distinct item_id \n  from stat_item_detail t2\n  where t2.gmt_create &gt;= '2026-04-26 10:30:00') t22\nwhere t1.item_id = t22.item_id\ngroup by t1.item_id;\n\n+----+-------------+------------+-------+----------------------------+----------------+---------+-------------+------+----------+----------------------------------------+\n| id | select_type | table      | type  | possible_keys              | key            | key_len | ref         | rows | filtered | Extra                                  |\n+----+-------------+------------+-------+----------------------------+----------------+---------+-------------+------+----------+----------------------------------------+\n|  1 | PRIMARY     | &lt;derived2&gt; | ALL   | NULL                       | NULL           | NULL    | NULL        |   10 |   100.00 | Using temporary                        |\n|  1 | PRIMARY     | t1         | ref   | idx_item_id                | idx_item_id    | 4       | t22.item_id |    1 |   100.00 | NULL                                   |\n|  2 | DERIVED     | t2         | range | idx_item_id,idx_gmt_create | idx_gmt_create | 5       | NULL        |   10 |   100.00 | Using index condition; Using temporary |\n+----+-------------+------------+-------+----------------------------+----------------+---------+-------------+------+----------+----------------------------------------+\n</code></pre><p>当然，能进行半连接转换的SQL，需要满足一些基本的条件。</p><ol>\n<li>\n<p>子查询没有使用UNION。</p>\n</li>\n<li>\n<p>子查询没有使用Having。</p>\n</li>\n<li>\n<p>子查询没有使用聚合函数（如avg、sum等）。</p>\n</li>\n<li>\n<p>子查询中不允许使用limit。</p>\n</li>\n<li>\n<p>主查询和子查询没有使用STRAIGHT_JOIN。</p>\n</li>\n<li>\n<p>主查询中表的数量和子查询中表的数量相加不超过MySQL允许的最大表连接数量。MySQL最多允许61表的连接。</p>\n</li>\n</ol><p>子查询中可以使用distinct、order by、group by这些关键词，实际上子查询中的这些关键词会被优化器忽略掉（前提是没有同时使用了聚合函数）。</p><p>如果子查询满足了上面这些条件，优化器会自动查询转换，将子查询转换为半连接。优化器会根据语句的具体情况，选择合适策略来执行半连接。这些策略分别是pullout、duplicate weedout、first match、loose scan、materialization。</p><ul>\n<li>\n<p>Pullout：直接将子查询提到外层，改写成表连接。</p>\n</li>\n<li>\n<p>Duplicate weedout：如果子查询中的数据可能存在重复，MySQL会对结果数据进行去重。</p>\n</li>\n<li>\n<p>First Match：执行表连接时，对于驱动表中的每一行记录，只需要匹配子查询的第一条记录就返回。</p>\n</li>\n<li>\n<p>Loose Scan：利用子查询中索引的有序性，获取关联条件的唯一值。</p>\n</li>\n<li>\n<p>Materialization：将子查询的结果存储在临时表，临时表再和父表进行关联。</p>\n</li>\n</ul><p>参数optimizer_switch中有一些选项用来控制是否开启某个半连接策略，我整理成了下面这个表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/50/9d5e62743caf6f6724f37dcda5218050.png?wh=1920x879\" alt=\"图片\"></p><p>优化器会计算这些半连接策略的成本，从中选择成本最低的执行计划。</p><p>接下来我用一些具体的例子来说明这些执行策略的使用场景。</p><p>先根据下面的SQL，创建几个测试表，准备一些测试数据。</p><pre><code class=\"language-plain\">CREATE TABLE t_parent (\n  id int not null auto_increment,\n  a int,\n  b int ,\n  c int ,\n  padding varchar(2000),\n  primary key(id),\n  KEY idx_a (a)\n) ENGINE=InnoDB;\n\nCREATE TABLE t_subq (\n  id int not null auto_increment,\n  a int ,\n  b int ,\n  c int ,\n  d int ,\n  padding varchar(2000),\n  primary key(id),\n  UNIQUE KEY uk_cb (c,b),\n  KEY idx_abc (a,b,c)\n) ENGINE=InnoDB;\n\ninsert into t_parent(a,b,c) values \n(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(null,0,0),(2,2,2);\n\ninsert into t_subq (a,b,c,d) values\n(1,1,1,1),(2,2,2,2),(3,3,3,3),(2,4,4,2);\n</code></pre><h3>Pullout</h3><p>如果子查询中，表上的唯一索引或主键能保证数据的唯一性，就可以直接将子查询转换为表连接，不用做其他额外的处理，这种转换就叫做Pullout，下面的查询演示了这种情况。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from t_parent where a in (\n    select b from t_subq where c = 1);\n\n+----+-------------+----------+------+---------------+-------+---------+--------------+------+----------+--------------------------+\n| id | select_type | table    | type | possible_keys | key   | key_len | ref          | rows | filtered | Extra                    |\n+----+-------------+----------+------+---------------+-------+---------+--------------+------+----------+--------------------------+\n|  1 | SIMPLE      | t_subq   | ref  | uk_cb         | uk_cb | 5       | const        |    1 |   100.00 | Using where; Using index |\n|  1 | SIMPLE      | t_parent | ref  | idx_a         | idx_a | 5       | rep.t_subq.b |    1 |   100.00 | NULL                     |\n+----+-------------+----------+------+---------------+-------+---------+--------------+------+----------+--------------------------+\n</code></pre><p>由于子查询内的ty表上有唯一索引uk_cb(c,b)，在c=1的情况下，b是唯一的，所以直接将子查询转换成了表连接。</p><p>执行show warnings后，可以看到SQL已经被改写成了普通的表连接。</p><pre><code class=\"language-plain\">mysql&gt; show warnings\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select `rep`.`t_parent`.`id` AS `id`,`rep`.`t_parent`.`a` AS `a`,`rep`.`t_parent`.`b` AS `b`,`rep`.`t_parent`.`c` AS `c`,`rep`.`t_parent`.`padding` AS `padding` from `rep`.`t_subq` join `rep`.`t_parent` where ((`rep`.`t_parent`.`a` = `rep`.`t_subq`.`b`) and (`rep`.`t_subq`.`c` = 1))\n</code></pre><h3>Duplicate Weedout</h3><p>如果子查询中的数据有可能出现重复值，那么将子查询转换为表连接时，需要对子查询的数据进行去重，这种情况为Duplicate Weedout，下面是一个例子：</p><pre><code class=\"language-plain\">mysql&gt;  explain  select * from t_parent where a in (\n  select d from t_subq where a in (1,3));\n+----+-------------+----------+-------+---------------+---------+---------+--------------+------+----------+-----------------------------------------------------+\n| id | select_type | table    | type  | possible_keys | key     | key_len | ref          | rows | filtered | Extra                                               |\n+----+-------------+----------+-------+---------------+---------+---------+--------------+------+----------+-----------------------------------------------------+\n|  1 | SIMPLE      | t_subq   | range | idx_abc       | idx_abc | 5       | NULL         |    2 |   100.00 | Using index condition; Using where; Start temporary |\n|  1 | SIMPLE      | t_parent | ref   | idx_a         | idx_a   | 5       | rep.t_subq.d |    1 |   100.00 | End temporary                                       |\n+----+-------------+----------+-------+---------------+---------+---------+--------------+------+----------+-----------------------------------------------------+\n</code></pre><p>注意到执行计划中，select_type列显示SIMPLE，说明子查询已经被转换成表连接了。Extra列中的Start temporary和End temporary说明使用了临时表来对数据进行去重。这里会使用t_parent表的主键字段来去重。</p><p>执行show warnings可以看到转换后的查询使用了semi join。</p><pre><code class=\"language-plain\">mysql&gt; show warnings\\G\n*************************** 1. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select `rep`.`t_parent`.`id` AS `id`,`rep`.`t_parent`.`a` AS `a`,`rep`.`t_parent`.`b` AS `b`,`rep`.`t_parent`.`c` AS `c`,`rep`.`t_parent`.`padding` AS `padding` from `rep`.`t_parent` semi join (`rep`.`t_subq`) where ((`rep`.`t_parent`.`a` = `rep`.`t_subq`.`d`) and (`rep`.`t_subq`.`a` in (1,3)))\n1 row in set (0.00 sec)\n</code></pre><h3>First match</h3><p>子查询转换为半连接后，如果优化器选择以原先的主查询作为驱动表，还可以使用First match策略。First match的意思是，对于驱动表的每一行数据，关联子查询中的表时，只关联到1行数据就返回，这样就不需要对子查询中的数据进行去重处理了。下面是使用First match的一个例子：</p><pre><code class=\"language-plain\">mysql&gt; explain select * from t_parent where c in (select c from t_subq);\n+----+-------------+----------+------+---------------+-------+---------+----------------+------+----------+-----------------------------------+\n| id | select_type | table    | type | possible_keys | key   | key_len | ref            | rows | filtered | Extra                             |\n+----+-------------+----------+------+---------------+-------+---------+----------------+------+----------+-----------------------------------+\n|  1 | SIMPLE      | t_parent | ALL  | NULL          | NULL  | NULL    | NULL           |    7 |   100.00 | Using where                       |\n|  1 | SIMPLE      | t_subq   | ref  | uk_cb         | uk_cb | 5       | rep.t_parent.c |    1 |   100.00 | Using index; FirstMatch(t_parent) |\n+----+-------------+----------+------+---------------+-------+---------+----------------+------+----------+-----------------------------------+\n</code></pre><p>注意到上面的执行计划中，Extra列显示的FirstMatch(t_parent)。First Match和Duplicate Weedout的一个主要的区别是<strong>表连接的顺序不一样</strong>。如果以子查询中的表作为驱动表，就无法使用First Match策略了。</p><h3>LooseScan</h3><p>LooseScan策略会利用子查询中表上的索引来获取到一组唯一的值，再跟主查询中的表进行连接。下面是使用LooseScan的一个例子：</p><pre><code class=\"language-plain\">mysql&gt; explain  select * from t_parent where a in (select a from t_subq);\n+----+-------------+----------+-------+---------------+---------+---------+--------------+------+----------+-------------------------------------+\n| id | select_type | table    | type  | possible_keys | key     | key_len | ref          | rows | filtered | Extra                               |\n+----+-------------+----------+-------+---------------+---------+---------+--------------+------+----------+-------------------------------------+\n|  1 | SIMPLE      | t_subq   | index | idx_abc       | idx_abc | 15      | NULL         |    4 |   100.00 | Using where; Using index; LooseScan |\n|  1 | SIMPLE      | t_parent | ref   | idx_a         | idx_a   | 5       | rep.t_subq.a |    1 |   100.00 | NULL                                |\n+----+-------------+----------+-------+---------------+---------+---------+--------------+------+----------+-------------------------------------+\n</code></pre><p>注意到上面的执行计划Extra中显示的LooseScan，使用了t_subq表上的索引idx_abc获取到a的一系列唯一值，这种方式和索引跳跃扫描（index skip scan）有一些相似之处。使用LooseScan策略时，以子查询中的表作为驱动表。</p><h3>Materialize with deduplication</h3><p>在Materialize with deduplication这种策略下，子查询被物化（Materialize）成一个临时表，生成临时表的时候会同时对数据进行去重。去重后的临时表再和原先主查询中的表进行连接。下面就是使用这种策略的一个例子：</p><pre><code class=\"language-plain\">mysql&gt; explain  select * from t_parent where a in (select d from t_subq where a in (2));\n+----+--------------+-------------+------+---------------+---------+---------+---------------+------+----------+-------------+\n| id | select_type  | table       | type | possible_keys | key     | key_len | ref           | rows | filtered | Extra       |\n+----+--------------+-------------+------+---------------+---------+---------+---------------+------+----------+-------------+\n|  1 | SIMPLE       | &lt;subquery2&gt; | ALL  | NULL          | NULL    | NULL    | NULL          | NULL |   100.00 | Using where |\n|  1 | SIMPLE       | t_parent    | ref  | idx_a         | idx_a   | 5       | &lt;subquery2&gt;.d |    1 |   100.00 | NULL        |\n|  2 | MATERIALIZED | t_subq      | ref  | idx_abc       | idx_abc | 5       | const         |    2 |   100.00 | NULL        |\n+----+--------------+-------------+------+---------------+---------+---------+---------------+------+----------+-------------+\n</code></pre><p>注意到上面执行计划中ID为2的查询单元，select_type为MATERIALIZED，这是基于子查询中的表t_subq产生的临时表。</p><h3>半连接策略的执行成本</h3><p>使用Pullout策略时，子查询中需要有主键或唯一索引来保证数据的唯一性。使用LooseScan策略时，也需要子查询中有索引。其他几种策略，对子查询中的索引没有要求。</p><p>那么在执行一个具体的子查询时，优化器是怎么来选择半连接策略的呢？实际上在这里，优化器主要也是基于成本来选择执行策略。每一种半连接转换策略都有相应的成本计算方式。我们可以使用优化器跟踪，来看一下子查询策略的选择过程。</p><pre><code class=\"language-plain\">mysql&gt; set optimizer_trace='enabled=on';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; explain select item_id, sum(sold) as sold\n           from stat_item_detail\n           where item_id in (\n                select item_id\n                from stat_item_detail\n                where gmt_create &gt;= '2026-04-26 10:30:00')\n           group by item_id;\n\n+----+--------------+------------------+-------+----------------------------+----------------+---------+---------------------+------+----------+-----------------------+\n| id | select_type  | table            | type  | possible_keys              | key            | key_len | ref                 | rows | filtered | Extra                 |\n+----+--------------+------------------+-------+----------------------------+----------------+---------+---------------------+------+----------+-----------------------+\n|  1 | SIMPLE       | &lt;subquery2&gt;      | ALL   | NULL                       | NULL           | NULL    | NULL                | NULL |   100.00 | Using temporary       |\n|  1 | SIMPLE       | stat_item_detail | ref   | idx_item_id                | idx_item_id    | 4       | &lt;subquery2&gt;.item_id |    1 |   100.00 | NULL                  |\n|  2 | MATERIALIZED | stat_item_detail | range | idx_item_id,idx_gmt_create | idx_gmt_create | 5       | NULL                |   10 |   100.00 | Using index condition |\n+----+--------------+------------------+-------+----------------------------+----------------+---------+---------------------+------+----------+-----------------------+\n    \nmysql&gt; select * from information_schema.optimizer_trace\\G\n</code></pre><ul>\n<li>LooseScan</li>\n</ul><p>子查询中没有合适的索引可以用来执行LooseScan策略。</p><ul>\n<li>MaterializeScan的成本</li>\n</ul><p>MaterializeScan的成本主要是创建临时表的成本，以及往临时表写入数据的成本。需要写入临时表的记录通过访问索引idx_gmt_create得到，需要写入10行记录。</p><pre><code class=\"language-plain\">\"execution_plan_for_potential_materialization\": {\n  \"steps\": [\n    {\n      \"considered_execution_plans\": [\n        {\n          \"plan_prefix\": [\n          ],\n          \"table\": \"`stat_item_detail`\",\n          \"best_access_path\": {\n            \"considered_access_paths\": [\n              {\n                \"access_type\": \"ref\",\n                \"index\": \"idx_item_id\",\n                \"usable\": false,\n                \"chosen\": false\n              },\n              {\n                \"rows_to_scan\": 10,\n                \"filtering_effect\": [\n                ],\n                \"final_filtering_effect\": 1,\n                \"access_type\": \"range\",\n                \"range_details\": {\n                  \"used_index\": \"idx_gmt_create\"\n                },\n                \"resulting_rows\": 10,\n                \"cost\": 12.5992,\n                \"chosen\": true\n              }\n            ]\n          },\n          \"condition_filtering_pct\": 100,\n          \"rows_for_plan\": 10,\n          \"cost_for_plan\": 12.5992,\n          \"sort_cost\": 10,\n          \"new_cost_for_plan\": 22.5992,\n          \"chosen\": true\n        }\n      ]\n    }\n  ]\n}\n</code></pre><p>再关联主表，得到执行计划的总成本为35.6627。</p><pre><code class=\"language-plain\">{\n  \"strategy\": \"MaterializeScan\",\n  \"recalculate_access_paths_and_cost\": {\n    \"tables\": [\n      {\n        \"table\": \"`stat_item_detail`\",\n        \"best_access_path\": {\n          \"considered_access_paths\": [\n            {\n              \"access_type\": \"ref\",\n              \"index\": \"idx_item_id\",\n              \"rows\": 1.88804,\n              \"cost\": 20.0634,\n              \"chosen\": true\n            },\n            {\n              \"access_type\": \"scan\",\n              \"cost\": 159249,\n              \"rows\": 903690,\n              \"chosen\": false,\n              \"cause\": \"cost\"\n            }\n          ]\n        }\n      }\n    ]\n  },\n  \"cost\": 35.6627,\n  \"rows\": 1.88804,\n  \"duplicate_tables_left\": true,\n  \"chosen\": true\n}\n</code></pre><ul>\n<li>DuplicatesWeedout的成本</li>\n</ul><p>DuplicatesWeedout的成本，由正常的表连接成本和去重成本组成，去重的成本为创建临时表的成本加上往临时表中写入数据的成本。从优化器跟踪可以看到，使用DuplicatesWeedout策略时，查询的总成本为37.4387，超过了Materialize的成本，因此没有选择这个策略。</p><pre><code class=\"language-plain\">{\n  \"strategy\": \"DuplicatesWeedout\",\n  \"cost\": 37.4387,\n  \"rows\": 18.8804,\n  \"duplicate_tables_left\": false,\n  \"chosen\": false\n}\n</code></pre><ul>\n<li>主查询作为驱动表的成本</li>\n</ul><p>使用FirstMatch时，以原先的主查询作为驱动表，访问主表时，需要全表扫描，成本超过了之前Materialize的成本，因此也没有选择这个执行计划。</p><pre><code class=\"language-plain\"> {\n  \"plan_prefix\": [\n  ],\n  \"table\": \"`stat_item_detail`\",\n  \"best_access_path\": {\n    \"considered_access_paths\": [\n      {\n        \"access_type\": \"ref\",\n        \"index\": \"idx_item_id\",\n        \"usable\": false,\n        \"chosen\": false\n      },\n      {\n        \"rows_to_scan\": 903690,\n        \"filtering_effect\": [\n        ],\n        \"final_filtering_effect\": 1,\n        \"access_type\": \"scan\",\n        \"resulting_rows\": 903690,\n        \"cost\": 159249,\n        \"chosen\": true,\n        \"use_tmp_table\": true\n      }\n    ]\n  },\n  \"condition_filtering_pct\": 100,\n  \"rows_for_plan\": 903690,\n  \"cost_for_plan\": 159249,\n  \"semijoin_strategy_choice\": [\n  ],\n  \"pruned_by_cost\": true\n}\n</code></pre><h2>反连接（ANTI Join）简介</h2><p>按官方文档的说法，MySQL 8.0.17开始，对于满足半连接转换条件的not in、not exists查询，MySQL还会使用反查询（ANTI Join）转换。</p><p>但是在我的测试中，not in的执行计划中仍旧是相关子查询（DEPENDENT SUBQUERY）。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from t_parent \n    where b not in (\n        select b from t_subq where b is not null\n    );\n+----+--------------------+----------+-------+---------------+-------+---------+------+------+----------+--------------------------+\n| id | select_type        | table    | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                    |\n+----+--------------------+----------+-------+---------------+-------+---------+------+------+----------+--------------------------+\n|  1 | PRIMARY            | t_parent | ALL   | NULL          | NULL  | NULL    | NULL |    7 |   100.00 | Using where              |\n|  2 | DEPENDENT SUBQUERY | t_subq   | index | NULL          | uk_cb | 10      | NULL |    3 |    66.67 | Using where; Using index |\n+----+--------------------+----------+-------+---------------+-------+---------+------+------+----------+--------------------------+\n</code></pre><p>给主查询的not in字段加上not null条件后，查询才转换成了反连接。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from t_parent \n    where not exists (\n        select 1 from t_subq where a=t_parent.a) \n    and a is not null;\n+----+-------------+----------+-------+---------------+---------+---------+----------------+------+----------+--------------------------------------+\n| id | select_type | table    | type  | possible_keys | key     | key_len | ref            | rows | filtered | Extra                                |\n+----+-------------+----------+-------+---------------+---------+---------+----------------+------+----------+--------------------------------------+\n|  1 | SIMPLE      | t_parent | range | idx_a         | idx_a   | 5       | NULL           |    6 |   100.00 | Using index condition                |\n|  1 | SIMPLE      | t_subq   | ref   | idx_abc       | idx_abc | 5       | rep.t_parent.a |    1 |   100.00 | Using where; Not exists; Using index |\n+----+-------------+----------+-------+---------------+---------+---------+----------------+------+----------+--------------------------------------+\n\nmysql&gt; show warnings\\G\n*************************** 2. row ***************************\n  Level: Note\n   Code: 1003\nMessage: /* select#1 */ select `rep`.`t_parent`.`id` AS `id`,\n     `rep`.`t_parent`.`a` AS `a`,`rep`.`t_parent`.`b` AS `b`,\n     `rep`.`t_parent`.`c` AS `c`,`rep`.`t_parent`.`padding` AS `padding` \nfrom `rep`.`t_parent` anti join (`rep`.`t_subq`) \non((`rep`.`t_subq`.`a` = `rep`.`t_parent`.`a`)) \nwhere (`rep`.`t_parent`.`a` is not null)\n</code></pre><p>关于反连接，有一点需要注意，就是not in和not exists并不完全等价。如果子查询中存在NULL值，那么not in不会返回任何数据。</p><p>我们来执行一个简单的测试，子表t_subq写入一条null的数据。</p><pre><code class=\"language-plain\">mysql&gt; insert into t_subq values(5,null, 0,0,0,null);\nQuery OK, 1 row affected (0.25 sec)\n\nmysql&gt; select * from t_parent;\n+----+------+------+------+---------+\n| id | a    | b    | c    | padding |\n+----+------+------+------+---------+\n|  1 |    1 |    1 |    1 | NULL    |\n|  2 |    2 |    2 |    2 | NULL    |\n|  3 |    3 |    3 |    3 | NULL    |\n|  4 |    4 |    4 |    4 | NULL    |\n|  5 |    5 |    5 |    5 | NULL    |\n|  6 | NULL |    0 |    0 | NULL    |\n|  7 |    2 |    2 |    2 | NULL    |\n+----+------+------+------+---------+\n7 rows in set (0.00 sec)\n\nmysql&gt; select * from t_subq;\n+----+------+------+------+------+---------+\n| id | a    | b    | c    | d    | padding |\n+----+------+------+------+------+---------+\n|  1 |    1 |    1 |    1 |    1 | NULL    |\n|  2 |    2 |    2 |    2 |    2 | NULL    |\n|  3 |    3 |    3 |    3 |    3 | NULL    |\n|  4 |    2 |    4 |    4 |    2 | NULL    |\n|  5 | NULL |    0 |    0 |    0 | NULL    |\n+----+------+------+------+------+---------+\n</code></pre><p>使用not in时，查询没有返回任何数据。这一点是使用not in时需要注意的。这是由not in和null的语意决定的，不光是MySQL，在其他数据库中也是一样的。</p><pre><code class=\"language-plain\">mysql&gt; select * from t_parent where a not in (select a from t_subq);\nEmpty set (0.01 sec)\n</code></pre><p>使用not exists时，可以查询到数据。</p><pre><code class=\"language-plain\">mysql&gt; select * from t_parent where not exists (\n    select 1 from t_subq where a=t_parent.a);\n+----+------+------+------+---------+\n| id | a    | b    | c    | padding |\n+----+------+------+------+---------+\n|  4 |    4 |    4 |    4 | NULL    |\n|  5 |    5 |    5 |    5 | NULL    |\n|  6 | NULL |    0 |    0 | NULL    |\n+----+------+------+------+---------+\n</code></pre><p>子查询中需要增加not null条件，not in才能查询到数据。但是和not exists返回的数据还是有一点不同，就是not exists查询返回了主表中关联字段为null的数据。</p><pre><code class=\"language-plain\">mysql&gt; select * from t_parent where a not in (\n   select a from t_subq where a is not null);\n+----+------+------+------+---------+\n| id | a    | b    | c    | padding |\n+----+------+------+------+---------+\n|  4 |    4 |    4 |    4 | NULL    |\n|  5 |    5 |    5 |    5 | NULL    |\n+----+------+------+------+---------+\n</code></pre><h2>无法使用半连接优化的子查询</h2><p>MySQL中，子查询可以出现在语句的不同部分。子查询可以出现在Where条件中，一般以exists、not exists、in、not in的形式出现，这种情况前面我们已经做了一些讨论了。子查询还可以出现在SELECT的字段列表中，或者出现在FROM子句中，FROM子句中的子查询一般也称为派生表。</p><p>有些情况下，MySQL无法使用半连接转换来自动优化子查询，比如当子查询出现在select的列表中，或者子查询中使用了聚合函数。这些情况下，你可能需要手动改写SQL，来优化性能。</p><p>我们来举几个例子。先创建一个测试表，写入一些数据。</p><pre><code class=\"language-plain\">create table emp_salary(\n    id int not null auto_increment,\n\temp_id int not null,\n\tdept_id int not null,\n\tsalary int not null,\n\tpadding varchar(2000),\n\tprimary key(id),\n\tkey idx_emp_id(emp_id),\n\tkey idx_dept_id(dept_id)\n) engine=innodb;\n\ninsert into emp_salary(emp_id, dept_id, salary, padding)\nselect 100000 + n, n % 10, 10000 + (n * n) % 10000, rpad('A', 1000, 'ABCD') \nfrom numbers;\n</code></pre><p>下面这个SQL，子查询中使用了聚合函数，优化器无法使用半连接转换。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from emp_salary t1\nwhere salary &gt; (select avg(salary) \n                from emp_salary \n                where dept_id = t1.dept_id)\n\n+----+--------------------+------------+------+---------------+-------------+---------+-----------------+------+----------+-------------+\n| id | select_type        | table      | type | possible_keys | key         | key_len | ref             | rows | filtered | Extra       |\n+----+--------------------+------------+------+---------------+-------------+---------+-----------------+------+----------+-------------+\n|  1 | PRIMARY            | t1         | ALL  | NULL          | NULL        | NULL    | NULL            | 9295 |   100.00 | Using where |\n|  2 | DEPENDENT SUBQUERY | emp_salary | ref  | idx_dept_id   | idx_dept_id | 4       | test.t1.dept_id |  929 |   100.00 | NULL        |\n+----+--------------------+------------+------+---------------+-------------+---------+-----------------+------+----------+-------------+\n</code></pre><p>在我的测试环境中，执行这个SQL需要大约执行9秒，原因主要是子查询执行的次数比较多。</p><p>类似的，下面这个SQL也需要执行9秒。</p><pre><code class=\"language-plain\">mysql&gt; explain select * from (\n    select t1.emp_id, t1.dept_id, t1.salary, \n        (select avg(salary) \n         from emp_salary where dept_id = t1.dept_id\n        ) as dept_avg_salary\n    from emp_salary t1 ) t\nwhere salary &gt; dept_avg_salary;\n\n+----+--------------------+------------+------+---------------+-------------+---------+-----------------+------+----------+-------------+\n| id | select_type        | table      | type | possible_keys | key         | key_len | ref             | rows | filtered | Extra       |\n+----+--------------------+------------+------+---------------+-------------+---------+-----------------+------+----------+-------------+\n|  1 | PRIMARY            | &lt;derived2&gt; | ALL  | NULL          | NULL        | NULL    | NULL            | 9295 |    33.33 | Using where |\n|  2 | DERIVED            | t1         | ALL  | NULL          | NULL        | NULL    | NULL            | 9295 |   100.00 | NULL        |\n|  3 | DEPENDENT SUBQUERY | emp_salary | ref  | idx_dept_id   | idx_dept_id | 4       | test.t1.dept_id |  929 |   100.00 | NULL        |\n+----+--------------------+------------+------+---------------+-------------+---------+-----------------+------+----------+-------------+\n</code></pre><p>对于这样的SQL，我们可以尝试改写，将相关子查询改成不相关子查询，这样可以减少子查询的执行次数。</p><pre><code class=\"language-plain\">mysql&gt; select t1.* \nfrom emp_salary t1,  (\n    select dept_id, avg(salary) as avg_salary \n    from emp_salary \n    group by dept_id ) t2\nwhere t1.dept_id = t2.dept_id\nand t1.salary &gt; t2.avg_salary;\n\n+----+-------------+------------+-------+---------------+-------------+---------+-----------------+------+----------+--------------------------+\n| id | select_type | table      | type  | possible_keys | key         | key_len | ref             | rows | filtered | Extra                    |\n+----+-------------+------------+-------+---------------+-------------+---------+-----------------+------+----------+--------------------------+\n|  1 | PRIMARY     | t1         | ALL   | idx_dept_id   | NULL        | NULL    | NULL            | 9295 |   100.00 | NULL                     |\n|  1 | PRIMARY     | &lt;derived2&gt; | ref   | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 4       | test.t1.dept_id |   92 |    33.33 | Using where; Using index |\n|  2 | DERIVED     | emp_salary | index | idx_dept_id   | idx_dept_id | 4       | NULL            | 9295 |   100.00 | NULL                     |\n+----+-------------+------------+-------+---------------+-------------+---------+-----------------+------+----------+--------------------------+\n</code></pre><p>按上面这个方式改写后，SQL的执行效率提升了很多倍。你也可以到自己的环境中验证一下。还可以对比一下这几个SQL在慢日志中的Rows_examined指标。</p><h2>总结</h2><p>MySQL 8.0增强了子查询的优化能力，对很多简单的子查询，优化器可以自动处理。如果你在子查询中使用了聚合函数，或者在select字段中使用了子查询，可能需要进行手动的优化。使用not in时，要注意子查询中不要出现null的数据，这会导致查询不到任何数据。</p><h2>思考题</h2><p>这一讲中，我提供了两种手动改写子查询的思路。</p><p>思路1：</p><pre><code class=\"language-plain\">mysql&gt; select t1.item_id, sum(t1.sold) as sold\nfrom stat_item_detail t1, (\n  select distinct item_id \n  from stat_item_detail t2\n  where t2.gmt_create &gt;= '2026-04-26 10:30:00') t22\nwhere t1.item_id = t22.item_id\ngroup by t1.item_id;\n</code></pre><p>思路2：</p><pre><code class=\"language-plain\">select item_id, sum(sold) from (\n    select distinct t1.id,  t1.item_id, t1.sold as sold\n    from stat_item_detail t1, stat_item_detail t2\n    where t1.item_id = t2.item_id\n    and t2.gmt_create &gt;= '2026-04-26 10:30:00'\n) t group by item_id;\n</code></pre><p>请问这两种改写方式，分别对应了MySQL半连接转换中的哪一个策略？</p><p>期待你的思考，欢迎你在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见！</p>","neighbors":{"left":{"article_title":"21｜表连接如何执行？","id":813345},"right":{"article_title":"23｜10+ SQL执行性能不佳的真实案例（上）","id":813361}},"comments":[{"had_liked":false,"id":394906,"user_name":"叶明","can_delete":false,"product_type":"c1","uid":1412429,"ip_address":"江苏","ucode":"D0B4B7660DA766","user_header":"https://static001.geekbang.org/account/avatar/00/15/8d/4d/992070e8.jpg","comment_is_top":false,"comment_ctime":1728718697,"is_pvip":false,"replies":[{"id":143399,"content":"👍👍\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1728886802,"ip_address":"浙江","comment_id":394906,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"思路1\n+----+-------------+------------+------------+-------+----------------------------------------+\n| id | select_type | table      | partitions | type  | Extra                                  |\n+----+-------------+------------+------------+-------+----------------------------------------+\n|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL   | Using temporary                        |\n|  1 | PRIMARY     | t1         | NULL       | ref   | NULL                                   |\n|  2 | DERIVED     | t2         | NULL       | range | Using index condition; Using temporary |\n+----+-------------+------------+------------+-------+----------------------------------------+\n\n\n第一种改写方式对应半连接转换中的 Materialize with deduplication 策略，\n从 distinct item_id 的语义和执行计划中 Extra 列中的 Using temporary，再通过执行计划的执行顺序可知，先生成一个内存临时表，将 item_id 列设置为唯一键，\n然后范围扫描索引 idx_gmt_create ，将满足查询条件的 item_id 插入到表中。插入完成后，用该临时表与表 stat_item_detail 进行 join 操作。\n这个过程与 materialize with deduplication 策略的过程一样——先将子查询物化成一个临时表，然后对临时表中的记录进行去重操作，最后将去重后的临时表与原主查询中的表进行关联查询。\n\n\n思路2\n+----+-------------+------------+------------+-------+----------------------------------------+\n| id | select_type | table      | partitions | type  | Extra                                  |\n+----+-------------+------------+------------+-------+----------------------------------------+\n|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL   | Using temporary                        |\n|  2 | DERIVED     | t2         | NULL       | range | Using index condition; Using temporary |\n|  2 | DERIVED     | t1         | NULL       | ref   | NULL                                   |\n+----+-------------+------------+------------+-------+----------------------------------------+\n\n第二种改写方式对应半连接转换中的 Duplicate Weedout 策略，使用到了内存临时表，并用主键来去重。","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652410,"discussion_content":"👍👍\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728886802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394883,"user_name":"陈星宇(2.11)","can_delete":false,"product_type":"c1","uid":1450562,"ip_address":"四川","ucode":"970E48260B7924","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/42/11674804.jpg","comment_is_top":false,"comment_ctime":1728650509,"is_pvip":false,"replies":[{"id":143388,"content":"MySQL 5.6就开始支持semijoin了，不过8.0中支持的场景更多。\n5.6，5.7不会自动转换exists，8.0开始支持exists的转换。\n\n这是5.7 semijoin的官方文档：https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;5.7&#47;en&#47;semijoins.html","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1728714979,"ip_address":"浙江","comment_id":394883,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"这些策略分别是 pullout、duplicate weedout、first match、loose scan、materialization。 这些是8.0才有吗？在5.7里很少看到。","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652334,"discussion_content":"MySQL 5.6就开始支持semijoin了，不过8.0中支持的场景更多。\n5.6，5.7不会自动转换exists，8.0开始支持exists的转换。\n\n这是5.7 semijoin的官方文档：https://dev.mysql.com/doc/refman/5.7/en/semijoins.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728714979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394882,"user_name":"陈星宇(2.11)","can_delete":false,"product_type":"c1","uid":1450562,"ip_address":"四川","ucode":"970E48260B7924","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/42/11674804.jpg","comment_is_top":false,"comment_ctime":1728650435,"is_pvip":false,"replies":[{"id":143387,"content":"这个执行计划是先从 ID为1的获取一行数据，再驱动相关子查询。\n\n使用explain extended + show warnings，能看到转换后的SQL：\n\nselect `rep`.`stat_item_detail`.`item_id` AS `item_id`,sum(`rep`.`stat_item_detail`.`sold`) AS `sold` \nfrom `rep`.`stat_item_detail` \nwhere &lt;in_optimizer&gt;(\n    `rep`.`stat_item_detail`.`item_id`, &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`rep`.`stat_item_detail`.`item_id`) in stat_item_detail on idx_item_id \n\twhere ((`rep`.`stat_item_detail`.`gmt_create` &gt;= &#39;2026-04-26 10:30:00&#39;) \n\tand (&lt;cache&gt;(`rep`.`stat_item_detail`.`item_id`) = `rep`.`stat_item_detail`.`item_id`))))) \ngroup by `rep`.`stat_item_detail`.`item_id`。\n\n这是5.5中的执行计划。在8.0里，我试了下，如果关闭semijoin优化，执行计划有点不一样，\n\nmysql&gt; explain select item_id, sum(sold) as sold from stat_item_detail where item_id in (\n   select item_id from stat_item_detail where Gmt_create &gt;= &#39;2026-04-26 10:30:00&#39;) group by item_id;\n+----+-------------+------------------+-------+----------------------------+----------------+---------+--------+\n| id | select_type | table            | type  | possible_keys              | key            | key_len | rows   |\n+----+-------------+------------------+-------+----------------------------+----------------+---------+--------+\n|  1 | PRIMARY     | stat_item_detail | index | idx_item_id                | idx_item_id    | 4       | 903690 |\n|  2 | SUBQUERY    | stat_item_detail | range | idx_item_id,idx_gmt_create | idx_gmt_create | 5       |     10 |\n+----+-------------+------------------+-------+----------------------------+----------------+---------+--------+\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1728714627,"ip_address":"浙江","comment_id":394882,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"mysql&gt; explain select item_id, sum(sold) as sold \n      from stat_item_detail \n      where item_id in (\n           select item_id \n           from stat_item_detail \n           where Gmt_create &gt;= &#39;2026-04-26 10:30:00&#39;) \n      group by item_id;\n\n+----+--------------------+------------------+----------------+----------------------------+-------------+---------+------+---------+-------------+\n| id | select_type        | table            | type           | possible_keys              | key         | key_len | ref  | rows    | Extra       |\n+----+--------------------+------------------+----------------+----------------------------+-------------+---------+------+---------+-------------+\n|  1 | PRIMARY            | stat_item_detail | index          | NULL                       | idx_item_id | 4       | NULL | 1000029 | Using where |\n|  2 | DEPENDENT SUBQUERY | stat_item_detail | index_subquery | idx_item_id,idx_gmt_create | idx_item_id | 4       | func |       1 | Using where |\n+----+--------------------+------------------+----------------+----------------------------+-------------+---------+------+---------+-------------+\n执行不是按id从大到小执行吗？感觉子查询应该走时间字段的索引，这里是不是有问题，有点没理解。\n“从上面的这个执行计划可以看到，这个 SQL 在执行时，先全量扫描索引 idx_item_id，每得到一个 item_id 后，执行相关子查询（DEPENDENT SUBQUERY）select 1 from stat_item_detail where gmt_create &gt;= ‘2026-04-26 10:30:00’ and item_id = primary.item_id。当主查询中表中的数据量很大的时候，子查询执行的次数也会很多，因此 SQL 的性能非常差。”","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652333,"discussion_content":"这个执行计划是先从 ID为1的获取一行数据，再驱动相关子查询。\n\n使用explain extended + show warnings，能看到转换后的SQL：\n\nselect `rep`.`stat_item_detail`.`item_id` AS `item_id`,sum(`rep`.`stat_item_detail`.`sold`) AS `sold` \nfrom `rep`.`stat_item_detail` \nwhere &lt;in_optimizer&gt;(\n    `rep`.`stat_item_detail`.`item_id`, &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`rep`.`stat_item_detail`.`item_id`) in stat_item_detail on idx_item_id \n\twhere ((`rep`.`stat_item_detail`.`gmt_create` &gt;= &#39;2026-04-26 10:30:00&#39;) \n\tand (&lt;cache&gt;(`rep`.`stat_item_detail`.`item_id`) = `rep`.`stat_item_detail`.`item_id`))))) \ngroup by `rep`.`stat_item_detail`.`item_id`。\n\n这是5.5中的执行计划。在8.0里，我试了下，如果关闭semijoin优化，执行计划有点不一样，\n\nmysql&gt; explain select item_id, sum(sold) as sold from stat_item_detail where item_id in (\n   select item_id from stat_item_detail where Gmt_create &gt;= &#39;2026-04-26 10:30:00&#39;) group by item_id;\n+----+-------------+------------------+-------+----------------------------+----------------+---------+--------+\n| id | select_type | table            | type  | possible_keys              | key            | key_len | rows   |\n+----+-------------+------------------+-------+----------------------------+----------------+---------+--------+\n|  1 | PRIMARY     | stat_item_detail | index | idx_item_id                | idx_item_id    | 4       | 903690 |\n|  2 | SUBQUERY    | stat_item_detail | range | idx_item_id,idx_gmt_create | idx_gmt_create | 5       |     10 |\n+----+-------------+------------------+-------+----------------------------+----------------+---------+--------+\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1728714627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}