{"id":258191,"title":"11 | 如何理解正则的匹配原理以及优化原则？","content":"<p>你好，我是伟忠，这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。</p><p>这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。</p><h2>有穷状态自动机</h2><p>正则之所以能够处理复杂文本，就是因为采用了<strong>有穷状态自动机（</strong><strong>finite automaton）。</strong>那什么是有穷自动机呢？有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。自动机是指系统可以根据相应的条件，在不同的状态下进行转移。从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。</p><p>有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的NFA 和POSIX NFA。</p><pre><code>DFA：确定性有穷自动机（Deterministic finite automaton）\nNFA：非确定性有穷自动机（Non-deterministic finite automaton）\n</code></pre><p>接下来我们来通过一些示例，来详细看下正则表达式的匹配过程。</p><h2>正则的匹配过程</h2><p>在使用到编程语言时，我们经常会“编译”一下正则表达式，来提升效率，比如在 Python3 中它是下面这样的：</p><!-- [[[read_end]]] --><pre><code>&gt;&gt;&gt; import re\n&gt;&gt;&gt; reg = re.compile(r'a(?:bb)+a')\n&gt;&gt;&gt; reg.findall('abbbba')\n['abbbba']\n</code></pre><p>这个编译的过程，其实就是生成自动机的过程，正则引擎会拿着这个自动机去和字符串进行匹配。生成的自动机可能是这样的（下图是使用<a href=\"https://regexper.com/#a%28%3F%3Abb%29%2Ba\">Regexper工具</a>生成，再次加工得到的）。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/4f/e3e052fac55209937cfd20ab5117f24f.png?wh=1188*328\" alt=\"\"></p><p>在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 a(bb)+a 在匹配了字符 abb 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称NFA）。</p><p><strong>NFA和DFA是可以相互转化的，</strong>当我们把上面的状态表示成下面这样，就是一台DFA状态机了，因为在 s0-s4 这几个状态，每个状态都需要特定的输入，才能发生状态变化。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/f7/c7e756e33fd5ce6156e35d8ec66e2df7.png?wh=1242*424\" alt=\"\"></p><p>那这两种状态机的工作方式到底有什么不同呢？我们接着往下看。</p><h3>DFA&amp; NFA 工作机制</h3><p>下面我通过一个示例，来简单说明 <strong>NFA 与 DFA 引擎工作方式的区别</strong>：</p><pre><code>字符串：we study on jikeshijian app\n正则：jike(zhushou|shijian|shixi)\n</code></pre><p>NFA引擎的工作方式是，先看正则，再看文本，而且以正则为主导。正则中的第一个字符是j，NFA引擎在字符串中查找 j，接着匹配其后是否为 i ，如果是 i 则继续，这样一直找到 jike。</p><pre><code>regex: jike(zhushou|shijian|shixi)\n          ^\ntext: we study on jikeshijian app\n                     ^\n</code></pre><p>我们再根据正则看文本后面是不是 z，发现不是，此时 zhushou 分支淘汰。</p><pre><code>regex: jike(zhushou|shijian|shixi)\n            ^\n         淘汰此分支(zhushou)\ntext: we study on jikeshijian app\n                      ^\n</code></pre><p>我们接着看其它的分支，看文本部分是不是 s，直到 shijian 整个匹配上。shijian 在匹配过程中如果不失败，就不会看后面的 shixi 分支。当匹配上了 shijian 后，整个文本匹配完毕，也不会再看 shixi 分支。</p><p>假设这里文本改一下，把 jikeshijian 变成 jikeshixi，正则 shi<strong>j</strong>ian 的 j 匹配不上时shixi 的 x，会接着使用正则 shixi 来进行匹配，重新从 s 开始（NFA引擎会记住这里）。</p><pre><code>第二个分支匹配失败\nregex: jike(zhushou|shijian|shixi)\n                       ^\n                  淘汰此分支(正则j匹配不上文本x)\ntext: we study on jikeshixi app\n                         ^\n\n再次尝试第三个分支\nregex: jike(zhushou|shijian|shixi)\n                            ^\ntext: we study on jikeshixi app\n                      ^\n</code></pre><p>也就是说， NFA 是以正则为主导，反复测试字符串，这样字符串中同一部分，有可能被反复测试很多次。</p><p>而 DFA 不是这样的，DFA 会先看文本，再看正则表达式，是以文本为主导的。在具体匹配过程中，DFA 会从 we 中的 w 开始依次查找 j，定位到 j ，这个字符后面是 i。所以我们接着看正则部分是否有 i ，如果正则后面是个 i ，那就以同样的方式，匹配到后面的 ke。</p><pre><code>text: we study on jikeshijian app\n                     ^\nregex: jike(zhushou|shijian|shixi)\n          ^\n</code></pre><p>继续进行匹配，文本 e 后面是字符 s ，DFA 接着看正则表达式部分，此时 zhushou 分支被淘汰，开头是s的分支 shijian 和 shixi 符合要求。</p><pre><code>text: we study on jikeshijian app\n                      ^\nregex: jike(zhushou|shijian|shixi)\n            ^       ^       ^\n           淘汰     符合    符合\n</code></pre><p>然后 DFA 依次检查字符串，检测到 shijian 中的 j 时，只有 shijian 分支符合，淘汰 shixi，接着看分别文本后面的 ian，和正则比较，匹配成功。</p><pre><code>text: we study on jikeshijian app\n                         ^\nregex: jike(zhushou|shijian|shixi)\n                       ^       ^\n                      符合     淘汰\n</code></pre><p>从这个示例你可以看到，DFA 和 NFA 两种引擎的工作方式完全不同。NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导，先看文本，再看正则表达式。</p><p>一般来说，DFA 引擎会更快一些，因为整个匹配过程中，字符串只看一遍，不会发生回溯，相同的字符不会被测试两次。也就是说DFA 引擎执行的时间一般是线性的。DFA 引擎可以确保匹配到可能的最长字符串。但由于 DFA 引擎只包含有限的状态，所以它没有反向引用功能；并且因为它不构造显示扩展，它也不支持捕获子组。</p><p>NFA  以表达式为主导，它的引擎是使用贪心匹配回溯算法实现。NFA  通过构造特定扩展，支持子组和反向引用。但由于 NFA 引擎会发生回溯，即它会对字符串中的同一部分，进行很多次对比。因此，在最坏情况下，它的执行速度可能非常慢。</p><h3>POSIX NFA 与 传统 NFA 区别</h3><p>因为传统的 NFA 引擎“急于”报告匹配结果，找到第一个匹配上的就返回了，所以可能会导致还有更长的匹配未被发现。比如使用正则 pos|posix 在文本 posix 中进行匹配，传统的 NFA 从文本中找到的是 pos，而不是 posix，而 POSIX NFA 找到的是 posix。</p><p><img src=\"https://static001.geekbang.org/resource/image/43/5f/4386yyd95dc71323098e9c6ae187645f.png?wh=1078*612\" alt=\"\"></p><p>POSIX NFA的应用很少，主要是 Unix/Linux 中的某些工具。POSIX NFA 引擎与传统的 NFA 引擎类似，但不同之处在于，POSIX NFA 在找到可能的最长匹配之前会继续回溯，也就是说它会尽可能找最长的，如果分支一样长，以最左边的为准（“The Longest-Leftmost”）。因此，POSIX NFA 引擎的速度要慢于传统的 NFA 引擎。</p><p>我们日常面对的，一般都是传统的NFA，所以通常都是最左侧的分支优先，在书写正则的时候务必要注意这一点。</p><p>下面是 DFA、传统NFA 以及 POSIX NFA 引擎的特点总结：</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/1a/f60e745b693a11d50e4c41b02f9f4c1a.jpg?wh=1390*577\" alt=\"\"></p><h2>回溯</h2><p>回溯是 NFA引擎才有的，并且只有在正则中出现<strong>量词</strong>或<strong>多选分支结构</strong>时，才可能会发生回溯。</p><p>比如我们使用正则 a+ab 来匹配 文本 aab 的时候，过程是这样的，a+是贪婪匹配，会占用掉文本中的两个 a，但正则接着又是 a，文本部分只剩下 b，只能通过回溯，让 a+ 吐出一个 a，再次尝试。</p><p>如果正则是使用 <code>.*ab</code> 去匹配一个比较长的字符串就更糟糕了，因为 <code>.*</code> 会吃掉整个字符串（不考虑换行，假设文本中没有换行），然后，你会发现正则中还有 ab 没匹配到内容，只能将 <code>.*</code> 匹配上的字符串吐出一个字符，再尝试，还不行，再吐出一个，不断尝试。<br>\n<img src=\"https://static001.geekbang.org/resource/image/f2/24/f2aac8643c053fd7fb010e18f9431624.jpg?wh=891*597\" alt=\"\"></p><p>所以在工作中，我们要尽量不用 <strong>.</strong>*  ，除非真的有必要，因为点能匹配的范围太广了，我们要尽可能精确。常见的解决方式有两种，比如要提取引号中的内容时，使用 “<strong>[^\"]+</strong>”，或者使用非贪婪的方式 “<strong>.+?</strong>”，来减少“匹配上的内容不断吐出，再次尝试”的过程。</p><p>我们再回头看一下之前讲解的店铺名匹配示例：</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/fb/ac99c68754d4e6c54d958970e9c3a5fb.png?wh=1082*854\" alt=\"\"></p><p>从<a href=\"https://regex101.com/r/Qbsm4g/1\">示例</a>我们可以看到，一个很短的字符串，NFA引擎尝试步骤达到了 9021 次，由于是贪婪匹配，第一个分支能匹配上 this is a cat 部分，接着后面的逗号匹配失败，使用第二个分支匹配，再次失败，此时贪婪匹配部分结束。NFA引擎接着用正则后面的 $ 来进行匹配，但此处不是文本结尾，匹配不上，发生回溯，吐出第一个分支匹配上的 t，使用第二个分支匹配 t 再试，还是匹配不上。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/28/10160dab5ccfcffb63abd79fc2299528.png?wh=1038*678\" alt=\"\"><br>\n我们继续回溯，第二个分支匹配上的 t 吐出，第一个分支匹配上的 a 也吐出，再用第二个分支匹配 a 再试，如此发生了大量的回溯。你可以使用 regex101.com 中的 Regex Debugger 来调试一下这个过程，加深你的理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/f2/0646f1d176e08cbeayyf005495e301f2.png?wh=1620*1082\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/1f/37/1f8860d7fd9f0bf88cc6b3be2e08e937.png?wh=1044*998\" alt=\"\"></p><p>我们来尝试优化一下，把第一个分支中的 A-Za-z 去掉，因为后面多选分支结构中重复了，我们再看一下正则尝试匹配的次数（<a href=\"https://regex101.com/r/Qbsm4g/2\">示例</a>），可以看到只尝试匹配了 57 次就结束了。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/79/a7438f0dc228edcb21fa69cd2fca8979.png?wh=1070*856\" alt=\"\"></p><p>所以一定要记住，不要在多选择分支中，出现重复的元素。到这里，你对之前文章提到的“回溯不可怕，我们要尽量减少回溯后的判断” 是不是有了进一步的理解呢？</p><p>另外，之前我们说的独占模式，你可以把它可以理解为贪婪模式的一种优化，它也会发生广义的回溯，但它不会吐出已经匹配上的字符。独占模式匹配到英文逗号那儿，不会吐出已经匹配上的字符，匹配就失败了，所以采用独占模式也能解决性能问题（<a href=\"https://regex101.com/r/Qbsm4g/3\">示例</a>）。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/bd/b12a4239a5ee7a1071e7752d19ba23bd.png?wh=1072*844\" alt=\"\"></p><p>但要提醒你的是，独占模式“不吐出已匹配字符”的特性，会使得一些场景不能使用它。另外，只有少数编程语言支持独占模式。</p><p>解决这个问题还有其它的方式，比如我们可以尝试移除多选分支选择结构，直接用中括号表示多选一（<a href=\"https://regex101.com/r/Qbsm4g/4\">示例</a>）。</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/07/7c2c0660cb4187fc7e9e9c60a827ce07.png?wh=1070*848\" alt=\"\"></p><p>我们会发现性能也是有显著提升（这里只是测试，真正使用的时候，重复的元素都应该去掉，另外这里也不需要保存子组）。</p><h2>优化建议</h2><p>学习了原理之后，有助于我们写出更好的正则。我们必须先保证正则的功能是正确的，然后再进行优化性能，下面我给了你一些优化的方法供你参考。</p><h3>1.测试性能的方法</h3><p>我们可以使用 ipython 来测试正则的性能，ipython 是一个 Python shell 增强交互工具，在 macOS/Windows/Linux 上都可以安装使用。在测试正则表达式时，它非常有用，比如下面通过一个示例，来测试在字符串中查找 abc 时的时间消耗。</p><pre><code>In [1]: import re\nIn [2]: x = '-' * 1000000 + 'abc'\nIn [3]: timeit re.search('abc', x)\n480 µs ± 8.06 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n</code></pre><p>另外，你也可以通过前面 regex101.com 查看正则和文本匹配的次数，来得知正则的性能信息。</p><h3>2.提前编译好正则</h3><p>编程语言中一般都有“编译”方法，我们可以使用这个方法提前将正则处理好，这样不用在每次使用的时候去反复构造自动机，从而可以提高正则匹配的性能。</p><pre><code>&gt;&gt;&gt; import re\n&gt;&gt;&gt; reg = re.compile(r'ab?c')  # 先编译好，再使用\n&gt;&gt;&gt; reg.findall('abc')\n['abc']\n\n&gt;&gt;&gt; re.findall(r'ab?c', 'abc')  # 正式使用不建议，但测试功能时较方便\n['abc']\n\n</code></pre><h3>3.尽量准确表示匹配范围</h3><p>比如我们要匹配引号里面的内容，除了写成 “.+?” 之外，我们可以写成 “<strong>[^\"]+</strong>”。使用 [^\"] 要比使用点号好很多，虽然使用的是贪婪模式，但它不会出现点号将引号匹配上，再吐出的问题。</p><h3>4.提取出公共部分</h3><p>通过上面对 NFA引擎的学习，相信你应该明白<code>(abcd|abxy)</code>这样的表达式，可以优化成<code>ab(cd|xy)</code>，因为 NFA 以正则为主导，会导致字符串中的某些部分重复匹配多次，影响效率。</p><p>因此我们会知道<code>th(?:is|at)</code>要比<code>this|that</code>要快一些，但从可读性上看，后者要好一些，这个就需要用的时候去权衡，也可以添加代码注释让代码更容易理解。</p><p>类似地，如果是锚点，比如<code>(^this|^that) is</code>这样的，锚点部分也应该独立出来，可以写成比如<code>^th(is|at) is</code>的形式，因为锚点部分也是需要尝试去匹配的，匹配次数要尽可能少。</p><h3>5.出现可能性大的放左边</h3><p>由于正则是从左到右看的，把出现概率大的放左边，域名中 .com 的使用是比 .net 多的，所以我们可以写成<code>\\.(?:com|net)\\b</code>，而不是<code>\\.(?:net|com)\\b</code>。</p><h3>6.只在必要时才使用子组</h3><p>在正则中，括号可以用于归组，但如果某部分后续不会再用到，就不需要保存成子组。通常的做法是，在写好正则后，把不需要保存子组的括号中加上 ?: 来表示只用于归组。如果保存成子组，正则引擎必须做一些额外工作来保存匹配到的内容，因为后面可能会用到，这会降低正则的匹配性能。</p><h3>7.警惕嵌套的子组重复</h3><p>如果一个组里面包含重复，接着这个组整体也可以重复，比如 <code>(.*)*</code> 这个正则，匹配的次数会呈指数级增长，所以尽量不要写这样的正则。</p><h3>8.避免不同分支重复匹配</h3><p>在多选分支选择中，要避免不同分支出现相同范围的情况，上面回溯的例子中，我们已经进行了比较详细的讲解。</p><h2>总结</h2><p>好了，今天的内容讲完了，我来带你总结回顾一下。</p><p>今天带你简单学习了有穷自动机的概念，自动机的具体实现称之为正则引擎。</p><p>我们学习了正则引擎的匹配原理，NFA 和 DFA 两种引擎的工作方式完全不同，NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导的，先看文本，再看正则表达式。POSIX NFA是指符合POSIX标准的NFA引擎，它会不断回溯，以确保找到最左侧最长匹配。</p><p>接着我们学习了测试正则表达式性能的方法，以及优化的一些方法，比如提前编译好正则，提取出公共部分，尽量准确地表示范围，必要时才使用子组等。</p><p>今天所讲的内容总结脑图如下，你可以回顾一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/0b/bddcyy348af2539aeedd72a7ebe5390b.png?wh=1522*1326\" alt=\"\"></p><h2>课后思考</h2><p>最后，我们来做一个小练习吧。通过今天学习的内容，这里有一个示例，要求匹配“由字母或数字组成的字符串，但第一个字符要是小写英文字母”，你能说一下针对这个示例，NFA引擎的匹配过程么？</p><pre><code>文本：a12\n正则：^(?=[a-z])[a-z0-9]+$\n</code></pre><p>好，今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，并把文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":233096,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1594216300,"is_pvip":true,"replies":[{"id":"86124","content":"没什么问题，环视只匹配位置，是零宽度的，区别就在于这儿。<br><br>元字符“^”和“$”匹配的只是位置，顺序环视“(?=[a-z])”只进行匹配，并不占有字符，也不将匹配的内容保存到最终的匹配结果，所以都是零宽度的。<br><br>匹配过程：<br><br>首先由元字符“^”取得控制权，从位置0开始匹配，“^”匹配的就是开始位置“位置0”，匹配成功，控制权交给顺序环视“(?=[a-z])”；<br><br>“(?=[a-z])”要求它所在位置右侧必须是字母才能匹配成功，零宽度的子表达式之间是不互斥的，即同一个位置可以同时由多个零宽度子表达式匹配，所以它也是从位置0尝试进行匹配，位置0的右侧是字符“a”，符合要求，匹配成功，控制权交给“[a-z0-9]+”；<br><br>因为“(?=[a-z])”只进行匹配，并不将匹配到的内容保存到最后结果，并且“(?=[a-z])”匹配成功的位置是位置0，所以“[a-z0-9]+”也是从位置0开始尝试匹配的，“[a-z0-9]+”首先尝试匹配“a”，匹配成功，继续尝试匹配，可以成功匹配接下来的“1”和“2”，此时已经匹配到位置3，位置3的右侧已没有字符，这时会把控制权交给“$”；<br><br>元字符“$”从位置3开始尝试匹配，它匹配的是结束位置，也就是“位置3”，匹配成功。<br><br>此时正则表达式匹配完成，报告匹配成功。匹配结果为“a12”，开始位置为0，结束位置为3。其中“^”匹配位置0，“(?=[a-z])”匹配位置0，“[a-z0-9]+”匹配字符串“a12”，“$”匹配位置3。<br><br>可以参考 https:&#47;&#47;blog.csdn.net&#47;lxcnn&#47;article&#47;details&#47;4304651","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1594313274,"ip_address":"","comment_id":233096,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40248921964","product_id":100053301,"comment_content":"看了一下这个匹配过程分为几步：<br>1: 拿到正则表达式的 开始符号 ^, 去匹配字符串的开始<br>2: 拿到正则的 (?=[a-z]) ，发现是一个环视，不进行看字符串<br>3: 解析环视中的 表达式为：[a-z]，和下一个字符串进行比较，发现找到了a符合要求<br>4: 继续取下一部分的正则为： [a-z0-9]+ ，和接下来的字符串进行比较，贪婪模式，匹配到字符串结尾<br>5: 取出正则的 $ 和字符串进行比较，判断是否是结尾","like_count":10,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500893,"discussion_content":"没什么问题，环视只匹配位置，是零宽度的，区别就在于这儿。\n\n元字符“^”和“$”匹配的只是位置，顺序环视“(?=[a-z])”只进行匹配，并不占有字符，也不将匹配的内容保存到最终的匹配结果，所以都是零宽度的。\n\n匹配过程：\n\n首先由元字符“^”取得控制权，从位置0开始匹配，“^”匹配的就是开始位置“位置0”，匹配成功，控制权交给顺序环视“(?=[a-z])”；\n\n“(?=[a-z])”要求它所在位置右侧必须是字母才能匹配成功，零宽度的子表达式之间是不互斥的，即同一个位置可以同时由多个零宽度子表达式匹配，所以它也是从位置0尝试进行匹配，位置0的右侧是字符“a”，符合要求，匹配成功，控制权交给“[a-z0-9]+”；\n\n因为“(?=[a-z])”只进行匹配，并不将匹配到的内容保存到最后结果，并且“(?=[a-z])”匹配成功的位置是位置0，所以“[a-z0-9]+”也是从位置0开始尝试匹配的，“[a-z0-9]+”首先尝试匹配“a”，匹配成功，继续尝试匹配，可以成功匹配接下来的“1”和“2”，此时已经匹配到位置3，位置3的右侧已没有字符，这时会把控制权交给“$”；\n\n元字符“$”从位置3开始尝试匹配，它匹配的是结束位置，也就是“位置3”，匹配成功。\n\n此时正则表达式匹配完成，报告匹配成功。匹配结果为“a12”，开始位置为0，结束位置为3。其中“^”匹配位置0，“(?=[a-z])”匹配位置0，“[a-z0-9]+”匹配字符串“a12”，“$”匹配位置3。\n\n可以参考 https://blog.csdn.net/lxcnn/article/details/4304651","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594313274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232976,"user_name":"Robot","can_delete":false,"product_type":"c1","uid":1181473,"ip_address":"","ucode":"7215462D5AC0FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/21/b3394aa2.jpg","comment_is_top":false,"comment_ctime":1594179900,"is_pvip":false,"replies":[{"id":"86125","content":"对的","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1594313356,"ip_address":"","comment_id":232976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10184114492","product_id":100053301,"comment_content":"文本：a12<br>正则：^(?=[a-z])[a-z0-9]+$<br><br>1、正则^先开始匹配到a12的开始位置<br>2、正则(?=[a-z])正向环视检查,开始位置之后的字符是否是a-z之一，匹配<br>3、正则[a-z0-9]+依次匹配a12,直到$匹配不上终止<br>4、回溯到$之前的位置，正则$开始匹配，匹配完成","like_count":2,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500832,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594313356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283140,"user_name":"charming-kamly","can_delete":false,"product_type":"c1","uid":1226457,"ip_address":"","ucode":"B68981240BCB2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/d9/09d9c35c.jpg","comment_is_top":false,"comment_ctime":1615572057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5910539353","product_id":100053301,"comment_content":"请教一下<br><br>1. POSIX NFA  和 第7篇文章中的 POSIX 流派 是否有关联？<br>2. DFA 和 NFA 分别出现时间是？","like_count":1},{"had_liked":false,"id":255908,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1603455431,"is_pvip":false,"replies":[{"id":"93646","content":"对的","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1603899451,"ip_address":"","comment_id":255908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5898422727","product_id":100053301,"comment_content":"提前编译好正则，提取出公共部分，尽量准确地表示范围，必要时才使用子组等。","like_count":1,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507871,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603899451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236067,"user_name":"Regina","can_delete":false,"product_type":"c1","uid":1135151,"ip_address":"","ucode":"2256559FB9A8D7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vTku9cFYPh2T8DSImQoPRLxgSibcVgCRYqMcEYibexxLkfn9IKhUSAasZ7QoB72SDWym31niah2y00ibRWdHibibib1wQ/132","comment_is_top":false,"comment_ctime":1595302198,"is_pvip":false,"replies":[{"id":"87488","content":"感谢指出，这里DFA部分，文本应该是 <br>we study on jikeshijian app","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1595519814,"ip_address":"","comment_id":236067,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5890269494","product_id":100053301,"comment_content":"<br>DFN引擎匹配那，为什么是shixi被淘汰而不是shijian<br>text: we study on jikeshixi app<br>                               ^<br>regex: jike(zhushou|shijian|shixi)<br>                              ^       ^<br>                           符合     淘汰","like_count":1,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501931,"discussion_content":"感谢指出，这里DFA部分，文本应该是 \nwe study on jikeshijian app","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595519814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233081,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1594212880,"is_pvip":true,"replies":[{"id":"86298","content":"你可以理解成NFA可以把匹配到的内容记下来，“扩展”可以理解成做了一些额外的工作。<br>原理部分最主要的是理解DFA的“文本主导”，NFA“正则主导”以及回溯相关的内容。","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1594451144,"ip_address":"","comment_id":233081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5889180176","product_id":100053301,"comment_content":"NFA  通过构造特定扩展，支持子组和反向引用<br>-----------------------------<br>这里的扩展是什么意思？ 指什么","like_count":1,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500884,"discussion_content":"你可以理解成NFA可以把匹配到的内容记下来，“扩展”可以理解成做了一些额外的工作。\n原理部分最主要的是理解DFA的“文本主导”，NFA“正则主导”以及回溯相关的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594451144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321408,"user_name":"洪涛","can_delete":false,"product_type":"c1","uid":1167229,"ip_address":"","ucode":"D25DB373E4500C","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/7d/1d6873aa.jpg","comment_is_top":false,"comment_ctime":1636858099,"is_pvip":true,"replies":[{"id":"118092","content":"就是bb重复多次的时候，状态机s3流转到s1不需要额外条件，“根据需要”去选择，具体是哪个，是不确定的","user_name":"作者回复","user_name_real":"编辑","uid":"1112089","ctime":1639002691,"ip_address":"","comment_id":321408,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636858099","product_id":100053301,"comment_content":"你可以理解成 a(bb)+a 在匹配了字符 abb 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。这句话还是没懂。。麻烦解释下","like_count":0,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537228,"discussion_content":"就是bb重复多次的时候，状态机s3流转到s1不需要额外条件，“根据需要”去选择，具体是哪个，是不确定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639002691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284519,"user_name":"charming-kamly","can_delete":false,"product_type":"c1","uid":1226457,"ip_address":"","ucode":"B68981240BCB2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/d9/09d9c35c.jpg","comment_is_top":false,"comment_ctime":1616314559,"is_pvip":false,"replies":[{"id":"103854","content":"文中有解释。<br>在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 a(bb)+a 在匹配了字符 abb 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称 NFA）。","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1617124731,"ip_address":"","comment_id":284519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616314559","product_id":100053301,"comment_content":"请教一下， 确定和非确定应该怎么理解？","like_count":0,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517375,"discussion_content":"文中有解释。\n在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 a(bb)+a 在匹配了字符 abb 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称 NFA）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617124731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279387,"user_name":"纵不朽","can_delete":false,"product_type":"c1","uid":1877862,"ip_address":"","ucode":"DB2CA2C46B2EF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu3MgZBAyyiavX2CMF2KRib791j3bBGiaQDzuQwBF2k6AKHANV2uTAAss2vVaeC7xcSYYD8vjmibRpTQ/132","comment_is_top":false,"comment_ctime":1613746148,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1613746148","product_id":100053301,"comment_content":"老师，a+ab这种匹配过程和回溯过程还能稍微理解一下，加了^$和分支后的匹配过程和回溯完全整不明白啊","like_count":0},{"had_liked":false,"id":268288,"user_name":"tgchj","can_delete":false,"product_type":"c1","uid":2304986,"ip_address":"","ucode":"718FF337877560","user_header":"","comment_is_top":false,"comment_ctime":1608125592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608125592","product_id":100053301,"comment_content":"老师，Golang 的正则引擎是NFA","like_count":0},{"had_liked":false,"id":256127,"user_name":"追风筝的人","can_delete":false,"product_type":"c1","uid":1488020,"ip_address":"","ucode":"2993D60F94C396","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg","comment_is_top":false,"comment_ctime":1603532557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603532557","product_id":100053301,"comment_content":"正则之所以能够处理复杂文本，就是因为采用了有穷状态自动机（finite automaton）。那什么是有穷自动机呢？有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。自动机是指系统可以根据相应的条件，在不同的状态下进行转移。从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。","like_count":0},{"had_liked":false,"id":252652,"user_name":"Sola","can_delete":false,"product_type":"c1","uid":1017996,"ip_address":"","ucode":"54C99A0399CD54","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/8c/e5814d3e.jpg","comment_is_top":false,"comment_ctime":1602421943,"is_pvip":false,"replies":[{"id":"92418","content":":-D","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1602549994,"ip_address":"","comment_id":252652,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602421943","product_id":100053301,"comment_content":"终于弄清楚为啥 环视又叫 「零宽度」了，就是想表达这个只是匹配位置，这里的「零宽度」 指的是不占用匹配宽度，匹配测试之后会退回到之前的位置。奇怪的命名增加了很多的理解成本","like_count":1,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506825,"discussion_content":":-D","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602549994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246871,"user_name":"劳码识途","can_delete":false,"product_type":"c1","uid":1598564,"ip_address":"","ucode":"7AEF4D9407F097","user_header":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","comment_is_top":false,"comment_ctime":1599497644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599497644","product_id":100053301,"comment_content":"因为DFA是以文本为主导，所以在记录状态的时候记录的是当前正则的位置，而且当前符合条件的正则位置可能不止一个，而一个子组匹配的文本可能也不止一种情况，所以无法做到反向引用和捕获子组<br>老师，不知道这么理解对不对？","like_count":0},{"had_liked":false,"id":236889,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1595578099,"is_pvip":false,"replies":[{"id":"87683","content":"NFA功能要多一些，复杂一些。<br>DFA简单，速度快","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1595815268,"ip_address":"","comment_id":236889,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595578099","product_id":100053301,"comment_content":"NFA 有 ε 的状态转移，但是 DFA 没有。","like_count":0,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502242,"discussion_content":"NFA功能要多一些，复杂一些。\nDFA简单，速度快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595815268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236402,"user_name":"简简单单","can_delete":false,"product_type":"c1","uid":1615572,"ip_address":"","ucode":"5DD625D84ED7D3","user_header":"https://static001.geekbang.org/account/avatar/00/18/a6/d4/f0207473.jpg","comment_is_top":false,"comment_ctime":1595407127,"is_pvip":false,"replies":[{"id":"87372","content":"对的，理解正确，在正则开头 和 在中括号里面第一个位置是含义不一样","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1595434437,"ip_address":"","comment_id":236402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595407127","product_id":100053301,"comment_content":"[^&quot;] : 在中括号中表示 非双引号的所有字符吗?<br>^&quot; : 在非中括号中表示 必须是行头, 且行头右侧第一个字符必须是个双引号吗 ?","like_count":0,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502043,"discussion_content":"对的，理解正确，在正则开头 和 在中括号里面第一个位置是含义不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595434437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235623,"user_name":"L","can_delete":false,"product_type":"c1","uid":1228268,"ip_address":"","ucode":"26BB686671F7D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/ec/cc7abf0b.jpg","comment_is_top":false,"comment_ctime":1595130753,"is_pvip":true,"replies":[{"id":"87496","content":"这个记下来了，后面有机会加餐看看","user_name":"作者回复","user_name_real":"伟忠","uid":"1112089","ctime":1595549628,"ip_address":"","comment_id":235623,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1595130753","product_id":100053301,"comment_content":"感觉最后要是能一起实现一个小型的正则引擎就好了","like_count":0,"discussions":[{"author":{"id":1112089,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","nickname":"伟忠","note":"","ucode":"FE77CF20ED6065","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501793,"discussion_content":"这个记下来了，后面有机会加餐看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595549628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228268,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bd/ec/cc7abf0b.jpg","nickname":"L","note":"","ucode":"26BB686671F7D4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293536,"discussion_content":"谢谢老师！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595570060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}