{"id":743474,"title":"17｜更大的框架：MiniSpring与MiniTomcat集成","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上节课我们实现了Context类的预加载，并引入server.xml和web.xml，分别对服务端和Servlet进行自定义配置。到目前为止我们的MiniTomcat已经是一个完整的小型Tomcat了。</p><p>考虑到在目前大部分的场景中，依托于Spring框架编写的项目大多使用Tomcat服务器进行启动，而我们之前已经完成过MiniSpring框架的构建，所以很自然地，我们就会想到<strong>将现有的MiniTomcat与之前完成的MiniSpring进行集成。</strong></p><p>从原理上来说，只要是按照Servlet规范实现的服务器，就可以将MiniSpring直接放在webapps目录下运行，不用做任何额外的工作。所以从道理上讲，MiniTomcat和MiniSpring的集成也是这样的。</p><p>不过，因为MiniTomcat毕竟是一个麻雀版的Tomcat，并没有完整地实现Servlet规范，所以现在这么直接绑在一起是不能顺利运行的，我们还需要做一点完善的工作。</p><p>我们先回顾一下，MiniSpring启动的时候，依赖Tomcat环境做什么事情。一切的起点都在web.xml文件中，里面定义了Listener、Filter和Servlet。为了让MiniSpring启动起来，我们要实现一个ContextLoaderListener，这个Listener的目的是启动MiniSpring的IoC容器。然后用一个DispatcherServlet来拦截一切路径，通过这个DispatcherServlet来使用MiniSpring的MVC。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/80/b7/8050b2159902d45ee645b41212489fb7.png?wh=1920x981\" alt=\"图片\"></p><p>但我们现在的MiniTomcat有局限性，所以需要做一些调整。</p><ol>\n<li>首先表现在对web.xml的解析中，Listener读不了初始化参数context-param，而且Servlet还配置不了url-pattern和init-param。</li>\n<li>还有我们的Listener接口不符合servlet规范，不支持ServletContextListener，所以MiniTomcat还不能通过Listener把MiniSpring启动起来。</li>\n<li>另外，以前在HttpProcessor里只是简单地判断路径，带有/servlet/路径的就认为是要调用一个后台的Servlet，这点也需要调整一下。同时Servlet的名字是直接从URI中截取的，现在应该改用查找url-pattern通过路径匹配某个Servlet了。</li>\n</ol><p>现在我们一起来动手改造。</p><h2>MiniSpring中的Bean</h2><p>以前在MiniSpring项目中，我们自己实现了@RequestMapping等Spring中的常用注解，并且利用注解在HelloWorldBean类中对接口进行了定义。这个bean也仍然是我们的实现目标，也就是说通过这个bean来验证MiniTomcat和MiniSpring的集成。之前bean的代码主体如下：</p><pre><code class=\"language-java\">package com.test.controller;\npublic class HelloWorldBean {\n    @Autowired\n    BaseService baseservice;\n    @Autowired\n    UserService userService;\n    \n    @RequestMapping(\"/test2\")\n    public void doTest2(HttpServletRequest request, HttpServletResponse response) {\n       String str = \"test 2, hello world!\";\n       try {\n          response.getWriter().write(str);\n       } catch (IOException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n       }\n    }\n    @RequestMapping(\"/test5\")\n    public ModelAndView doTest5(User user) {\n       ModelAndView mav = new ModelAndView(\"test\",\"msg\",user.getName());\n       return mav;\n    }\n    \n    @Autowired\n    IAction action;\n    @RequestMapping(\"/testaop2\")\n    public void doTestAop2(HttpServletRequest request, HttpServletResponse response) {\n       action.doSomething();\n       \n       String str = \"test aop 2, hello world!\";\n       try {\n          response.getWriter().write(str);\n       } catch (IOException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n       }\n    }  \n}\n</code></pre><p>之前我们通常是采用嵌入式的方式使Spring业务项目与Tomcat结合在一起，即项目中内嵌一个Tomcat的Web服务器，这是因为Tomcat本身提供了内嵌这一种模式。</p><p>而目前这种内嵌模式我们还没有实现，我们实现的是依托于MiniTomcat项目本身，将业务服务代码打包成App的形式，在项目中运行。这个时候MiniTomcat是一个独立运行的容器，管理多个webapp。</p><p>在后续集成过程中，我们会将MiniSpring这一项目整体编译，然后通过类似Servlet调用方式，例如 <code>http://localhost:8080/app/test2</code> 进行接口测试。</p><h2>项目结构</h2><p>这节课我们把所有的ClassLoader移到/loader目录下，然后使用server.xml和web.xml分别管理Host启动配置与Servlet加载配置，这也是我们这节课的重点，你可以看一下参考目录。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ conf\n│ &nbsp;├─ server.xml\n├─ src\n│ &nbsp;├─ main\n│ &nbsp;│ &nbsp;├─ java\n│ &nbsp;│ &nbsp;│ &nbsp;├─ com\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ minit\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ connector\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ http\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ DefaultHeaders.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpConnector.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpHeader.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpProcessor.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpRequestImpl.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpRequestLine.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpResponseImpl.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ServletProcessor.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ SocketInputStream.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StatisResourceProcessor.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpRequestFacade.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HttpResponseFacade.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ core\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ApplicationFilterChain.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ApplicationFilterConfig.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ContainerBase.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ContainerListenerDef.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ FilterDef.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ FilterMap.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardContext.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardContextValve.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardHost.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardHostValve.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardPipeline.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardServletConfig.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardServletContext.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardWrapper.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardWrapperValve.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ loader\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ CommonClassLoader.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ CommonLoader.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ WebappClassLoader.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ WebappLoader.resources.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ logger\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Constants.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ FileLogger.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ LoggerBase.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ SystemErrLogger.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ SystemOutLogger.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ session\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardSession.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StandardSessionFacade.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ startup\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ BootStrap.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ util\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ CookieTools.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ StringManager.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ URLDecoder.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ valves\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ AccessLogValve.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ValveBase.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Connector.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Container.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ContainerEvent.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ContainerListener.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Context.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ InstanceEvent.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ InstanceListener.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Loader.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Logger.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Pipeline.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Request.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Response.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Session.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ SessionEvent.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ SessionListener.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Valve.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ ValveContext.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ Wrapper.class\n│ &nbsp;│ &nbsp;├─ resources\n│ &nbsp;├─ test\n│ &nbsp;│ &nbsp;├─ java\n│ &nbsp;│ &nbsp;│ &nbsp;├─ test\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ HelloServlet.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ TestFilter.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ TestListener.class\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ TestServlet.class\n│ &nbsp;│ &nbsp;├─ resources\n├─ webapps\n│ &nbsp;├─ app-minispring\n│ &nbsp;│ &nbsp;├─ WEB-INF\n│ &nbsp;│ &nbsp;│ &nbsp;├─ lib\n│ &nbsp;│ &nbsp;│ &nbsp;├─ classes\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ com\n│ &nbsp;│ &nbsp;│ &nbsp;│  │  ├─ minis\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│  ├─ test\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ applicationContext.xml\n│ &nbsp;│ &nbsp;│ &nbsp;├─ minisMVC-servlet.xml\n│ &nbsp;│ &nbsp;│ &nbsp;├─ web.xml\n├─ pom.xml\n</code></pre><p>其中app-minispring下的代码是我们从minis最终代码中编译得到的，都放置在WEB-INF/classes/com目录下，这里就不再依次列出了。</p><h2>调整web.xml的解析</h2><p>我们知道，一个应用的启动，依赖于解析web.xml，从这个XML配置文件中指定要启动的Listener和Servlet。我们的目标是通过Listener启动minis的IoC，随后所有的调用都通过DispatcherServlet，转发到应用内部进行处理。</p><p>接下来我们先看看一个标准的web.xml具备哪些元素。</p><pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app version=\"3.0\"\n         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;applicationContext.xml&lt;/param-value&gt;\n    &lt;/context-param&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;com.minis.web.context.ContextLoaderListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;minisMVC&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.minis.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;minisMVC-servlet.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;minisMVC&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;\n</code></pre><p>参考目前我们对web.xml的解析可以发现，<code>&lt;context-param&gt;</code>、<code>&lt;servlet&gt;</code> 标签下的 <code>&lt;init-param&gt;</code> 与 <code>&lt;servlet-mapping&gt;</code> 标签都没有解析，所以这是我们要增加的解析部分。</p><p>一个web.xml代表一个应用的配置，对应的容器是Context，所以我们要先在StandardContext中的start()方法内进行改造。</p><pre><code class=\"language-java\">    public void start(){\n        Logger logger = new FileLogger();\n        setLogger(logger);\n        \n        //scan web.xml\n        String file = System.getProperty(\"minit.base\") + File.separator + \n               this.docbase + File.separator + \"WEB-INF\" + File.separator + \"web.xml\";\n        \n        SAXReader reader = new SAXReader();\n        Document document;\n       try {\n          document = reader.read(file);\n          Element root = document.getRootElement();\n          // 解析context-param\n          List&lt;Element&gt; contextParams = root.elements(\"context-param\");\n          for (Element contextParam : contextParams) {\n             Element element = contextParam.element(\"param-name\");\n             String paramName = element.getText();\n             Element paramValueElement = contextParam.element(\"param-value\");\n             String paramValue = paramValueElement.getText();\n             initParametersMap.put(paramName, paramValue);\n          }\n          servletContext = new StandardServletContext(this.docbase, initParametersMap);\n            \n          //解析servlet\n          List&lt;Element&gt; servlets = root.elements(\"servlet\");\n            for (Element servlet : servlets) {\n                Element servletname = servlet.element(\"servlet-name\");\n                String servletnamestr = servletname.getText();\n                Element servletclass = servlet.element(\"servlet-class\");\n                String servletclassstr = servletclass.getText();\n                //解析init-param\n             Element servletInitParamElement = servlet.element(\"init-param\");\n             Element servletInitParamNameElement = servletInitParamElement.element(\"param-name\");\n             String servletInitParamName = servletInitParamNameElement.getText();\n             Element servletInitParamValueElement = servletInitParamElement.element(\"param-value\");\n             String servletInitParamValue = servletInitParamValueElement.getText();\n             Map&lt;String, String&gt; servletInitParamMap = new ConcurrentHashMap&lt;&gt;();\n             servletInitParamMap.put(servletInitParamName, servletInitParamValue);\n             servletInitParametersMap.put(servletclassstr, servletInitParamMap);\n                Element loadonstartup = servlet.element(\"load-on-startup\");\n                String loadonstartupstr = null;\n                if (loadonstartup != null) {\n                   loadonstartupstr = loadonstartup.getText();\n                }\n                \n                System.out.println(\"servlet \" + servletnamestr + servletclassstr);\n                this.servletClsMap.put(servletnamestr, servletclassstr);\n                if (loadonstartupstr != null) {\n                   getWrapper(servletnamestr);\n                }\n                \n            }\n          // 解析servlet-mapping\n          List&lt;Element&gt; servletMappings = root.elements(\"servlet-mapping\");\n          for (Element servletMapping : servletMappings) {\n             Element servletname = servletMapping.element(\"servlet-name\");\n             String servletnamestr = servletname.getText();\n             Element servletclass = servletMapping.element(\"url-pattern\");\n             String urlPatternStr = servletclass.getText();\n             servletMappingMap.put(urlPatternStr, servletnamestr);\n          }\n       } catch (DocumentException e) {\n          e.printStackTrace();\n       }\n        System.out.println(\"Context started.........\");\n }  \n</code></pre><p>上面的代码列出了对 <code>&lt;context-param&gt;</code>、<code>&lt;servlet&gt;</code> 标签下的 <code>&lt;init-param&gt;</code> 与 <code>&lt;servlet-mapping&gt;</code> 标签的解析，我们分别定义initParametersMap、servletInitParamMap、servletMappingMap三个Map数据结构，来存储解析的数据。后续的程序就可以从这里获取到这些配置信息了。</p><p>然后我们再来看看Listener，我们已经说过，Listener是Tomcat和Spring的初始结合点，那么MiniSpring也是在这里与MiniTomcat进行第一次接触的。MiniSpring遵从了Servlet的规范，所以为了让我们的Minit能顺利运行MiniSpring，我们也要适配Servlet规范，支持ServletContextListener。</p><p>我们将StandardContext里用到自定义ContainerListener的地方全部替换成ServletContextListener，ServletContextListener是javax.servlet包中定义的接口。所以我们可以启动MiniSpring的ContextLoaderListener，进而启动Minis的IoC。</p><p>你可以看一下MiniSpring里对ServletContextListener的contextInitialized方法的实现。</p><pre><code class=\"language-java\">@Override\npublic void contextInitialized(ServletContextEvent event) {\n    initWebApplicationContext(event.getServletContext());\n}\n</code></pre><p>在代码实现中，initWebApplicationContext传入了一个ServletContext类型的参数，因此在MiniTomcat中我们需要考虑做一个ServletContext接口的实现类。</p><p>在MiniTomcat中定义了StandardServletContext，你可以看一下代码的主体部分。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardServletContext implements ServletContext {\n    private Map&lt;String, String&gt; initParametersMap = new ConcurrentHashMap&lt;&gt;();\n    private Map&lt;String, Object&gt; attributeMap = new ConcurrentHashMap&lt;&gt;();\n    private String docbase;\n    public StandardServletContext() {\n    }\n    public StandardServletContext(String docbase, Map&lt;String, String&gt; initParametersMap) {\n        this.initParametersMap = initParametersMap;\n        this.docbase = docbase;\n    }\n    @Override\n    public URL getResource(String s) throws MalformedURLException {\n        try {\n            URLStreamHandler urlStreamHandler = null;\n            File classPath = new File(System.getProperty(\"minit.base\"));\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            repository = repository + this.docbase + File.separator;\n            repository = repository + \"WEB-INF\" + File.separator;\n            return new URL(null, repository + s, urlStreamHandler);\n        } catch (IOException e) {\n            throw new MalformedURLException(e.getMessage());\n        }\n    }\n    @Override\n    public String getInitParameter(String s) {\n        return initParametersMap.get(s);\n    }\n    @Override\n    public Object getAttribute(String s) {\n        return this.attributeMap.get(s);\n    }\n    @Override\n    public void setAttribute(String s, Object o) {\n        this.attributeMap.put(s, o);\n    }\n}\n\n</code></pre><p>为了遵从规范，需要定义的方法比较多，但我们的实际需求只是简单地将它们运行起来，以此来说明原理，我们只需要实现getResource、getInitParameter、getAttribute、setAttribute就可以了，其他的暂时用不到。后续MiniSpring启动时调用的ServletContext，其内部就是调用MiniTomcat的StandardServletContext。<br>\n同理，在MiniToimcat的StandardWrapper里，需要调用loadServlet加载应用的Servlet，在web.xml中我们配置了DispatcherServlet。因而在loadServlet中，有一行 <code>servlet.init(null)</code>，此时我们需要进行一定的改造，传入具体的ServletConfig实现，里面包含一个Servlet的元信息，如名字、初始化参数、上下文context等。</p><p>所以我们在MiniTomcat中也就要实现一个StandardServletConfig。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardServletConfig implements ServletConfig {\n    private Map&lt;String, String&gt; servletInitParamMap = new ConcurrentHashMap&lt;&gt;();\n    private ServletContext servletContext;\n    private String servletName;\n    public StandardServletConfig(String servletName, ServletContext servletContext, Map&lt;String, String&gt; servletInitParamMap) {\n        this.servletInitParamMap = servletInitParamMap;\n        this.servletContext = servletContext;\n        this.servletName = servletName;\n    }\n    @Override\n    public String getServletName() {\n        return servletName;\n    }\n    @Override\n    public ServletContext getServletContext() {\n        return this.servletContext;\n    }\n    @Override\n    public String getInitParameter(String s) {\n        return servletInitParamMap.get(s);\n    }\n    @Override\n    public Enumeration&lt;String&gt; getInitParameterNames() {\n        return null;\n    }\n}\n</code></pre><p>这个时候StandardWrapper里的loadServlet方法需要改造一下。</p><pre><code class=\"language-java\">public Servlet loadServlet() throws ServletException {\n    // Call the initialization method of this servlet\n    try {\n      servlet.init(new StandardServletConfig(servletClass,\n            standardContext.getServletContext(),\n            standardContext.getServletInitParametersMap().get(servletClass)));\n    }\n    catch (Throwable f) {\n      throw new ServletException(\"Failed initialize servlet.\");\n    }\n}\n</code></pre><p>主要改动在于在调用servlet的init()时，将原来传入的null，改为了传入一个ServletConfig，通过这个方法的调用，我们就可以加载MiniSpring中的DispatcherServlet。注意了，这也是系统中唯一一个Servlet。</p><p>还有一处需要改动，就是我们之前调用应用的Servlet，会以路径中最后一个分隔符（/）为界，最后面一段字符串代表Servlet的名称。而我们现在调用MiniSpring的时候，则是考虑最后路径为@RequestMapping注解里配置的值，而这个时候这个值并不是Servlet的名称，其实整个系统现在只有一个Servlet，也就是DispatcherServlet，其他的都被MiniSpring封装了。因此在MiniTomcat里，解析请求路径的StandardContextValve类里的invoke方法也需要调整。</p><p>你可以看一下这个方法调整之后的样子。</p><pre><code class=\"language-java\">package com.minit.core;\nfinal class StandardContextValve extends ValveBase {\n    public void invoke(Request request, Response response, ValveContext valveContext)\n        throws IOException, ServletException {\n        System.out.println(\"StandardContextValve invoke()\");\n        StandardWrapper servletWrapper = null;\n        String uri = ((HttpRequestImpl)request).getUri();\n        //通过uri拿到pattern\n        String servletPattern = uri.substring(uri.lastIndexOf(\"/\"));\n        //通过pattern找到合适的servlet名\n        String servletName = this.urlMatch(servletPattern);\n        StandardContext context = (StandardContext)getContainer();\n        \n        servletWrapper = (StandardWrapper)context.getWrapper(servletName); \n        try {\n           System.out.println(\"Call service()\");\n           servletWrapper.invoke(request, response);\n        }\n        catch (Exception e) {\n           System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n           System.out.println(e.toString());\n        }\n    }\n    //简单的匹配规则，以url-pattern开头继任为匹配上\n    private String urlMatch(String urlPattern) {\n       Map&lt;String, String&gt; servletMappingMap = standardContext.getServletMappingMap();\n       Set&lt;String&gt; keySet = servletMappingMap.keySet();\n       for (Map.Entry&lt;String, String&gt; entry : servletMappingMap.entrySet()) {\n          String key = entry.getKey();\n          if (urlPattern.startsWith(key)) {\n             return entry.getValue();\n          }\n       }\n       return null;\n    }\n}\n</code></pre><p>关键的改动在于我们解析了ServletMapping，并要求ServletMapping中定义的ServletName与Servlet标签匹配。这里如果我们指定url-pattern为斜杠（/），表示不做任何拦截。</p><p>因此在invoke方法中，我们获取到了最后一段字符串，类似 <code>”/test2“</code> 这种，就是调用到Minis的DispatcherServlet中，之后代码逻辑都转到MiniSpring中去处理了。</p><p>在这些主要的改动调整完毕后，我们编译部署，你可以看一下运行目录。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ conf\n│ &nbsp;├─ server.xml\n├─ classes\n│ &nbsp;├─ com\n│ &nbsp;│ &nbsp;├─ minit\n│ &nbsp;│ &nbsp;│ &nbsp;├─ connector\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ http\n│ &nbsp;│ &nbsp;│ &nbsp;├─ core\n│ &nbsp;│ &nbsp;│ &nbsp;├─ loader\n│ &nbsp;│ &nbsp;│ &nbsp;├─ logger\n│ &nbsp;│ &nbsp;│ &nbsp;├─ session\n│ &nbsp;│ &nbsp;│ &nbsp;├─ startup\n│ &nbsp;│ &nbsp;│ &nbsp;├─ util\n│ &nbsp;│ &nbsp;│ &nbsp;├─ valves\n├─ lib\n├─ logs\n├─ webapps\n│ &nbsp;├─ app-minispring\n│ &nbsp;│ &nbsp;├─ WEB-INF\n│ &nbsp;│ &nbsp;│ &nbsp;├─ lib\n│ &nbsp;│ &nbsp;│ &nbsp;├─ classes\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ com\n│ &nbsp;│ &nbsp;│ &nbsp;│  │  ├─ minis\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;│  ├─ test\n│ &nbsp;│ &nbsp;│ &nbsp;│ &nbsp;├─ applicationContext.xml\n│ &nbsp;│ &nbsp;│ &nbsp;├─ minisMVC-servlet.xml\n│ &nbsp;│ &nbsp;│ &nbsp;├─ web.xml\n├─ startup.bat\n</code></pre><p>startup.bat是启动程序，直接双击startup.bat启动MiniTomcat和MiniSpring。你从控制台的输出中就能看到IoC和MVC分别启动了。</p><h2>测试</h2><p>在浏览器地址栏上输入 <code>http://localhost:8080/app-minispring/test2</code>，可以看到浏览器页面上输出 <code>”test2，hello world!“</code>，这样就表示MiniSpring顺利地在MiniTomcat中运行起来了。</p><h2>小结</h2><p>这节课我们将MiniSpring与MiniTomcat进行集成，构成了一个更大的框架。我们采取的方案是将MiniTomcat作为独立服务器启动，然后把MiniSpring作为一个应用装载在MiniTomcat里。</p><p>为了能够集成，我们做的改造工作是按照规范解析web.xml，增加context-param、servlet-mapping、init-param的解析。然后我们实现了ServletContextListener接口，通过Listener MiniTomcat和MiniSpring有了一个最初的结合点。后面我们又实现了ServletConfig，以便初始化DispatcherServlet，同时也不再是通过/servlet/目录来判断是否是一个servlet了，而是通过servlet mapping去获得的。</p><p>总之只要符合Servlet规范，就能将Tomcat和Spring集成起来。</p><p>这节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter17\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter17</a></p><h2>思考题</h2><p>学完了这节课的内容，你来思考一个问题：我们现在集成后的MiniTomcat + MiniSpring跟实际的Tomcat+Spring结构上还有一些什么区别？你可以举例说明。</p><p>欢迎你把你的想法分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":386691,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1705364955,"is_pvip":false,"replies":[{"id":141003,"content":"Q1，遵守规范对servlet程序员是很容易的，extends HttpServlet就可以了，简单来讲就是写在doPost(), doGet()中。\nQ2，Tomcat本身支持两种方式，一种是独立服务器，一种是embedded，一般用SpringBoot来 搭建一个项目，里面的Tomcat是embedded模式的。MiniTomcat实现的是独立服务器模式，从软件结构讲我个人喜欢这种模式，觉得embedded模式有违软件的标准架构。\nQ3，MiniSpring被当成了MiniTomcat的一个应用中的基础框架，提供一个Listener启动，一个servlet进行拦截。\nQ4，静态部分简化处理了，在Processor中如果路径是&#47;resources&#47;则认为是静态的\nQ5, 正常应用还是跟以前一样，没有变化。因为集成MiniSpring是当成一个webapp对待的。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1705536109,"ip_address":"澳大利亚","comment_id":386691,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：从编码角度怎么遵守servlet规范？\n写出符合servlet规范的servlet，需要怎么做？查看规范文档，照着文档写吗？还是继承某个已经存在的符合规范的接口？\n\nQ2：以前开发的项目中spring与tomcat是什么关系？\n本课程中，spring是作为一个webapp，放到tomcat的应用目录中；用户请求是先到tomcat，tomcat再转发给spring；而且spring是tomcat负责启动的。总之，tomcat好像是spring的管理者。\n\n比较早的时候，还没有使用springBoot的时候，用IDE创建一个项目，直接创建的是spring项目，直接感觉到的是spring MVC，并没有感觉到tomcat的存在，但需要配置tomcat。 此种情况下，tomcat和spring是什么关系？还是我们本专栏的关系吗？即tomcat管理spring？\n\n现在的开发中，IDE一般都是用Idea，然后使用springBoot创建项目，直接创建的也是spring项目，也没有感觉到tomcat的存在，甚至感觉不到spring的存在。不过还是需要配置tomcat。 此种情况下，springBoot和tomcat、spring是什么样的关系？\n\nQ3：miniSpring相当于原来的servlet处理部分吗？？\n本课之前，servlet由miniT的servlet部分处理。本课集成minis以后，原来的servlet处理部分就没有了，由minis处理。这样的话，minis相当于接管了原来的servlet处理部分，相当于一个大的servlet。是这样吗？\n\nQ4：集成mins以后，原来的静态处理部分由谁处理？\n本课之前，一部分是处理servelt，另外一部分是处理静态文本文件。集成minis以后，处理静态文本文件部分是谁处理？\n\nQ5：集成minis以后，正常的应用怎么办？\nMinit集成了minis,那其他web应用怎么办？原来是把应用放在webapp目录下面，那现在怎么办？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636048,"discussion_content":"Q1，遵守规范对servlet程序员是很容易的，extends HttpServlet就可以了，简单来讲就是写在doPost(), doGet()中。\nQ2，Tomcat本身支持两种方式，一种是独立服务器，一种是embedded，一般用SpringBoot来 搭建一个项目，里面的Tomcat是embedded模式的。MiniTomcat实现的是独立服务器模式，从软件结构讲我个人喜欢这种模式，觉得embedded模式有违软件的标准架构。\nQ3，MiniSpring被当成了MiniTomcat的一个应用中的基础框架，提供一个Listener启动，一个servlet进行拦截。\nQ4，静态部分简化处理了，在Processor中如果路径是/resources/则认为是静态的\nQ5, 正常应用还是跟以前一样，没有变化。因为集成MiniSpring是当成一个webapp对待的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705536109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}