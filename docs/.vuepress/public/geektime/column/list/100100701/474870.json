{"id":474870,"title":"大咖助阵｜LMOS：用面向对象的思想开发 C 语言程序","content":"<p>你好，我是LMOS。</p><p>在“ LMOS 说 C 语言”的上篇里，我向你分享了C语言的起源，它与UNIX操作系统的联系，以及与C语言简单和困难相关的语言特性。今天我想和你聊聊，既然C语言是一把锋利但考验使用者技巧的瑞士军刀，我们可以拿它做什么，又怎么才能把它用好。</p><h2><strong>C</strong> <strong>语言能干什么？</strong></h2><p>对于“C语言能干什么”这个问题，我的回答是：C语言能干一切其他语言能干的事。</p><p>C语言自身的特性使得它能完全操作计算机所有的资源，因此它<strong>生来就是开发操作系统等底层核心软件的</strong>。不仅仅是开发操作系统，还有一些数据库和一些其他高级编程语言的编译器、解析器等。C语言简单的语法，被C++、Java、Go、JS 等语言效仿。其实从C语言的语言特性就可以看出来，它属于高级语言中的低级语言，又是低级语言中的高级语言，能适应一切底层开发。</p><p>然而，C语言既然能做一切底层开发，就一定能做一切上层开发，只是对开发者的能力要求远高于Java、Go这些高级语言。其实，所有的高级语言都有共同的目标，就是降低开发者的学习使用成本和心智负担，从而降低软件的开发和维护成本。比如，Java用虚拟机实现了一次编译处处运行，用垃圾内存回收机制解决了程序员使用内存的困难，不用时刻担心内存没有释放。这些归根结底是为了降低软件开发成本。</p><!-- [[[read_end]]] --><p>对于“C语言能干一切其他语言能干的事”这句话，你可能还有这样的疑问：C语言是一门面向过程的编程语言，而在工程应用中，我们多使用面向对象的编程方式。用C语言来做现代大型软件项目，是不是不太现实？</p><p>确实，由于C语言函数之间的强耦合和内存的低级控制特性，在用它开发大型工程项目时，如果不设计好架构和相关的编码规则，将会给项目的开发、协同和后期维护带来很多困难。但是，C语言是一门面向过程的编程语言，并不意味着我们不能用它来实现面向对象的编程方式。接下来，我就具体讲讲，怎么用面向对象的思想开发C语言程序。</p><h2>面向过程和面向对象的两种思想</h2><p>我先带你回顾下面向过程和面向对象这两种思想，以及一些容易混淆的相关概念。</p><p>对于计算过程的不同认识，产生了不同的计算模型。基于计算模型进行分类，我们可以将语言分为命令式、函数式、面向过程、面向对象四大类。如果从程序的本质上来看，可以进一步归纳为两种：命令式语言和说明式语言。</p><p>面向过程是命令式语言的主要实现手段，而面向对象是当前应用编程领域中最常用的语言类型。但是，无论从语言定义还是数据抽象发展来看，面向对象都是面向过程的衍生。</p><p>命令式这个词太过于学术化了，其实我们常见的编程语言，从汇编到 C 再到C++、 Java，都是命令式语言。命令式语言在很大程度上受到了“冯·诺依曼”计算体系的影响。这个体系又以“存储”和“处理”为核心，其中存储被抽象为<strong>内存</strong>，处理被抽象为<strong>运算指令和语句</strong>。于是，命令式的核心就是<strong>通过运算去改变内存（数据）</strong>。</p><p>听到这里，你应该能把这些概念的关系理清楚了：面向过程/面向对象这些概念，和命令式并不在同一个维度上。前者是运算类型，表现为语言；后者着重表达的则是程序设计和开发的方法。</p><p>C语言和C++都是命令式语言，不过C语言是面向过程的语言，C++是面向对象的语言，那么面向过程和面向对象有什么区别呢？其实它们大同小异，只不过是“思考问题的方式”不同。为了方便你理解，这里我用“吃饭”来类比。</p><p>过程是对每个功能或者动作的精确实现。用“吃饭”来举例子：吃饭这个“功能”，包含怎么吃，吃多少。小猫能吃饭，人也能吃饭，但二者吃饭的“过程”肯定有区别。这个逻辑可以用下面的代码来描述：</p><pre><code class=\"language-c++\">void cateat(cat* v) {\n  // 吃饭；\n  return;\n}\nvoid peopleeat(people* v) {\n  // 吃饭；\n  return;\n}\nint main(int argc, char const *argv[]) {\n  cateat(cat);\n  peopleeat(people);\n  return 0;\n}\n</code></pre><p>至于“面向对象”里的“对象”，可以这么理解：猫和人分别是两个对象，这两个对象都包含吃饭这个动作。对于人，会调用人的吃饭动作的函数；而对于猫，则会调用属于猫的吃饭动作。代码如下：</p><pre><code class=\"language-c++\">class Cat {  // 对象猫；\n public: \n  void eat();\n};\nvoid Cat::eat(void) {\n  // 猫吃饭；\n  return;\n}\nclass People {  // 对象人；\n public: \n  void eat();\n};\nvoid People::eat(void) {\n  // 人吃饭；\n  return;\n}\nint main(int argc, char const *argv[]) {\n  Cat c;\n  People p;\n  c.eat(); // 调用猫对象的吃饭动作；\n  p.eat(); // 调用人对象的吃饭动作；\n  return 0;\n}\n</code></pre><p>我们可以看到，面向过程和面向对象的思考方式截然不同。面向过程，是对每个不同动物的吃饭过程进行精确描述。而面向对象的思考方式却不同：认为猫和人是两个不同的对象，都有吃饭的动作，各自对吃饭这个动作进行封装和实现。最后，用对象自己调用自己的方法，完成相应的吃饭动作。</p><p>但仔细思考一下，猫和人其实都属于哺乳动物，哺乳动物间还是有一些共性的。那么，如何表示这种父子范畴关系呢？答案就是<strong>在封装的基础上进行继承操作</strong>。</p><p>这是因为，如果仅仅是把属性和方法封装成对象，这个意义还不是很大。封装是为了继承，继承是为了解耦和复用。当然，随着工程复杂度的发展，人们发现传统的单/多继承又会带来额外的复杂度，于是就又有了组合优于继承的思想，这里就不展开了。接下来让我们看看，怎么用 C 语言来实现封装和继承这两种面向对象编程的特性。</p><h2><strong>基于</strong> <strong>C</strong> <strong>语言的面向对象编程</strong></h2><p>首先，请一定要记住：面向对象是一种编程思想，并非特定语言（如C++、Java）实现的功能。C++、Java这些语言只是用语言的文法对这种思想进行规约，达到方便或者强制编程人员用面向对象的思想实现自己的代码逻辑的目的。</p><p>所以，我们不仅能用C++、Java这些“面向对象的编程语言”实现面向对象编程，用C或者汇编也可以实现，只是后者没有提供类似C++、Java中，可用于实现面向对象的语法糖而已。下面，我们就一起用 C 来实现面向对象的编程方法。</p><h3><strong>封装</strong></h3><p>我们首先用C语言来实现封装。封装是面向对象中最基础的思想，即把一些属性和方法组织在一起，形成一个对象。</p><p>接下来，我会用我的课程<a href=\"https://time.geekbang.org/column/intro/100078401?tab=catalog\">《操作系统实战45讲》</a>中的Cosmos的锁实现为实例，剖析用C语言来实现封装的方法。在操作系统中，用锁的模块很多，进程模块要用锁，内存模块也要用锁，它们对锁的要求也有不同。现在我们来封装最基本的锁，代码如下：</p><pre><code class=\"language-c++\">typedef struct SPINLOCK {\n  volatile U32 Lock; // int 类型，0 表示解锁，1 表示加锁；\n} SpinLock;\n// 加锁；\nvoid HalSpinLock(SpinLock *lock) {\n  __asm__ __volatile__(\n    \"1：lock; xchg %0, %1\\n\"\n    \"cmpl $0, %0\\n\"\n    \"jnz 2f\\n\"\n    \".section .spinlock.text,\"\"\\\"ax\\\"\"\n    \"2：cmpl $0, %1\\n\"\n    \"jne 2b\\n\"\n    \"jmp 1b\\n\"\n    \".previous\\n\"\n    :: \"r\"(1), \"m\"(*lock));\n  return;\n}\n// 解锁；\nvoid HalUnSpinLock(SpinLock *lock) {\n  __asm__ __volatile__(\n    \"movl   $0, %0\\n\"\n    :: \"m\"(*lock));\n  return;\n}\n</code></pre><p>上面的代码中，我们定义了一个SpinLock数据结构，并且围绕这个结构写好了两个函数，一个加锁，一个解锁。其中，代码是用嵌入汇编实现的，这里我们不用管它们的实现，只需明白它们能加锁和解锁就行了。</p><p>不过，仅仅是这样还体现不出封装的意义，我们继续修改代码：</p><pre><code class=\"language-c++\">typedef struct MLOCK {\n  SpinLock Locks;  // 锁；\n  UInt Count;  // 计数器；\n  void (*MLocked)(MLock* Lock);  // 加锁函数指针；\n  void (*MUnLock)(MLock* Lock);  // 解锁函数指针；\n} MLock; \n// 初始化；\nvoid MLockInit(MLock* init) {\n  SpinLockInit(&amp;init-&gt;Locks);\n  init-&gt;Count = 0;\n  init-&gt;MLocked = KrlMmLocked;\n  init-&gt;MUnLock = KrlMmUnLock;\n  return;\n}\n// 加锁；\nvoid KrlMmLocked(MLock* lock) {\n  HalSpinLock(&amp;lock-&gt;Locks);  // 调用基类加锁函数；\n  lock-&gt;Count++;\n  return;\n}\n// 解锁；\nvoid KrlMmUnLock(MLock* lock) {\n  HalUnSpinLock(&amp;lock-&gt;Locks);  // 调用基类解锁函数；\n  lock-&gt;Count--;\n  return;\n}\nMLock Lock;  // 定义一个 Lock 对象；\nMLockInit(&amp;Lock);  // 初始化对象；\nLock.MLocked(&amp;Lock);  // 调用对象方法；\nLock.MUnLock(&amp;Lock);\n</code></pre><p>上述代码中，MLock结构中的SpinLock相当于基类，并且扩展封装了一个计数器和两个成员方法，形成了新的MLock锁。</p><p>MLock锁封装了底层锁的实现机制，使用者不用考虑底层实现，在任何需要使用MLock的地方，只要定义一个MLock类型的对象，并对其初始化，需要的时候调用其中对应的方法就行了。你看，是不是有点C++的味道了？只是C++用语法糖包装了这些实现细节，而C语言的语法上没有 <code>new</code> ，没有 <code>class</code> ，也没有构造函数。但是C语言有 <code>struct</code> ，有函数指针，可以自己写初始化函数。</p><h3><strong>继承</strong></h3><p>在面向对象的编程思想中，把属性和方法封装成一个个对象是为了继承。若非如此，就失去了封装对象的意义。上面的MLock只是封装加上简单的继承，下面我们来看看复杂点的继承。</p><p>在操作系统中，内存管理需要很多数据结构（如果你想深入了解这些，可以看看我在极客时间的课程<a href=\"https://time.geekbang.org/column/intro/100078401?tab=catalog\">《操作系统实战45讲》</a>），内存管理的各种数据结构都需要锁来避免程序并发运行带来的破坏性结果。下面，我用其中几个结构作为实例，示范一下“继承”这个概念。</p><p>先来看这段代码：</p><pre><code class=\"language-c++\">// 物理地址块头链；\ntypedef struct PABHLIST {\n  MLock Lock;  // 锁对象；\n  U32  Status;\n  UInt Order;\n  UInt InOrderPmsadNR;\n  UInt FreePmsadNR;\n  UInt PmsadNR;\n  UInt AllocCount;\n  UInt FreeCount;\n  List FreeLists;\n  List AllocLists;\n  List OveLists;\n} PABHList;\n// 内存拆分合并结构；\ntypedef struct MSPLITMER {\n  MLock Lock;  // 锁对象；\n  U32  Status;\n  UInt MaxSMNR;\n  UInt PhySMNR;\n  UInt PreSMNR;\n  UInt SPlitNR;\n  UInt MerNR;\n  PABHList PAddrBlockArr[MSPLMER_ARR_LMAX];\n  PABHList OnePAddrBlock;\n} MSPlitMer;\n// 内存节点；\ntypedef struct MNode {\n  List Lists;\n  MLock Lock;  // 锁对象；\n  UInt Status;\n  UInt Flags;\n  UInt NodeID;\n  UInt CPUID;\n  Addr NodeMemAddrStart;\n  Addr NodeMemAddrEnd;\n  PHYMSPaceArea* PMSAreaPtr;\n  U64 PMSAreaNR;\n  U64 NodeMemSize;\n  Addr NodeMemResvAddrStart;\n  Addr NodeMemResvAddrEnd;\n  U64 NodeMemResvSize;\n  MArea MAreaArr[MEMAREA_MAX];\n  PMSADDireArr PMSADDir;\n} MNode;\n</code></pre><p>上面的三个数据结构，都需要用锁来保护其自身数据的完整体，避免并发访问带来的各种问题。要访问，先加锁，一旦加锁别人就无法访问了，这样就能保证数据是安全访问的，不会读取到状态不一致的数据。</p><p>你可能想问：难道我们要每种数据结构都写一套加锁、解锁的代码吗？当然不是。我们只需要在其他结构里包括这个MLock就行了，相当于继承MLock类。这样，我们就可以访问结构时先调用MLock中的加锁操作。例如：</p><pre><code class=\"language-c++\">MNode node;\nMnodeInit(&amp;node);\n\nnode.Lock.MLocked(&amp;node.Lock);\nnode.PMSAreaNR++;\nnode.Lock.MUnLock(&amp;node.Lock);\n</code></pre><p>从这段代码中我们看到，操作MNode中的数据，首先会调用MNode下的Lock中的加锁操作，然而这个Lock对象是继承于MLock类的。</p><p>由此我们可以发现，任何数据结构只要包含（继承）MLock类，就可以具有锁的功能了，而不用知道锁是如何实现的。并且，我们如果需要移植代码到不同的机器上，只用改动MLock中SpinLock的实现，就好了。这种高内聚，低耦合的状态，正是衡量软件工程设计是否优良的重要指标。</p><p>我们在工作中，不仅仅是要追求代码运行正常与否，更要在这个基础之上追求代码的可读性、可维护性、软件架构的优雅性。正如我们看到的这样，面向过程和面向对象是两种不同的编程设计思想。我们可以取其优势以用之，把这两种思想融会贯通，这样就能用面向过程的编程语言实现面向对象的编程方法。这就像剑法大成的独孤求败一样，已经不在乎用什么剑了。在他眼里，草木竹石均可为剑，以至于能达到更高的境界，“无剑胜有剑”。</p><h2>重点回顾</h2><p>今天的分享就到这里了，最后我来给你总结一下。</p><ol>\n<li>首先，我们了解了C语言能干什么：从操作系统到编译器，从数据库到应用软件，C语言都可以非常高效地实现它们。</li>\n<li>然后，我们对比了面向过程和面向对象这两种不同编程思想的“思考方式”。</li>\n<li>既然面向对象是一种编程思想，那么用 C 语言这种面向过程的编程语言也可以实现。最后，我们通过大量的实例，实现了面向对象的封装和继承特性。</li>\n</ol><h2>写在最后</h2><p>C语言是一把利剑，用好了威力无穷。如果想最大程度地发挥它的威力，我们还需要把它跟工程实践相结合，可以尝试用C语言开发一个工程，比如操作系统、数据库等。</p><p>今天我举的实例仅仅是一个数据结构，如果稍微扩展一下思维，你就会发现：一个C语言模块文件就是一个对象类，其中的数据结构和函数就是这个对象类的成员数据和成员方法。在<a href=\"https://time.geekbang.org/column/intro/100078401?tab=catalog\">《操作系统实战45讲》</a>这门课中，我带同学们实现了一个基于 x86 平台的 64 位多进程的操作系统——Cosmos。Cosmos中的CPU类、MMU类、List类、RBTree类、Atomic类、Queue类等，都是用C语言基于面向对象的思想实现的。总之，如果你想看到更多C语言在操作系统中应用的案例，我在这门课里等你。</p><p>感谢你看到这里，如果今天的内容让你有所收获，欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"大咖助阵｜LMOS：为什么说 C 语言是一把瑞士军刀？","id":470130},"right":{"article_title":"大咖助阵｜罗剑锋：为什么 NGINX 是 C 编程的经典范本？","id":476646}},"comments":[{"had_liked":false,"id":329287,"user_name":"=","can_delete":false,"product_type":"c1","uid":2600127,"ip_address":"","ucode":"104232A8292220","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","comment_is_top":false,"comment_ctime":1641268138,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23116104618","product_id":100100701,"comment_content":"读完这篇文章后，最好的描述就是“捅破窗户纸”。<br>这学期，因为学校课程的原因，看了许多内核代码，内核代码中基于C语言的封装、继承特别多，这种继承在数据结构上体现得非常明显，数据结构A会继承数据结构B，数据结构A又会被其他数据结构继承……<br>虽然大一时学过C语言，但是面对内核代码中繁多的数据结构继承依然感觉不适应，经过一个学期对内核代码的阅读，对基于C语言的封装与继承算是习惯了，但也只是一种感性的认知，感觉和它隔了一层窗户纸，但自己始终捅不破这层窗户纸。今天看了这篇文章后，最大的感叹就是“原来是这样”，真有一种自己琢磨了许久终于对一件事物有了些浅薄的认识，一位前辈直接鞭辟入里，把最本质、最深入的内容直接扒开来展示给你的感觉。","like_count":6,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543918,"discussion_content":"哈哈，好","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641351861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329964,"user_name":"白花风信子","can_delete":false,"product_type":"c1","uid":2850941,"ip_address":"","ucode":"89CA70180EA326","user_header":"https://static001.geekbang.org/account/avatar/00/2b/80/7d/51914d34.jpg","comment_is_top":false,"comment_ctime":1641702953,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10231637545","product_id":100100701,"comment_content":"老师好哇！读完后对C中简单实现面向对象的操作有了一些具体的了解，但是我还有几个问题希望老师能帮忙解答一下QAQ。<br>1. “你可能想问：难道我们要每种数据结构都写一套加锁、解锁的代码吗？当然不是。我们只需要在其他结构里包括这个 MLock 就行了，相当于继承 MLock 类。” 老师这段话的意思是在struct里面包含另外的struct就能实现继承的功能，但是在面向对象里面，这样的操作应该是has-a，而继承是is-a。请问has-a和is-a的实质是类似的吗？这种has-a和is-a的区分只是在设计思想上的区别嘛？<br>2. 关于封装和继承的访问权限，只是由编译器设置的访问权限嘛？<br>3. 关于多态的实现，应该就是虚函数表叭，但是C语言按上面的继承方式实现起来好像就是直接在struct里面添加新的函数了？","like_count":2,"discussions":[{"author":{"id":2440338,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3c/92/81fa306d.jpg","nickname":"张Dave","note":"","ucode":"0E8B6FDEB7505B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555296,"discussion_content":"struct里面添加的，是函数的指针。应该和虚函数表类似？都是跳转地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646839048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2885057,"avatar":"","nickname":"sudo","note":"","ucode":"59B8FC9F43AF69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547231,"discussion_content":"确实，这篇文章里面讲的内容是一种设计方法，利用struct实现类似c++的面向对象，从使用上看确实能达到，但本质是不一样的，文章结尾应该要声明一下，像访问权限就没有，但通过其它方法也能做到，只不过需要更多的代码量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642592178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333001,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1916166,"ip_address":"","ucode":"D7569E54C924D0","user_header":"","comment_is_top":false,"comment_ctime":1643950641,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643950641","product_id":100100701,"comment_content":"面向对象是一种编程思想，C需要也可以实现，就是麻烦一点。","like_count":0}]}