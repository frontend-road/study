{"id":253300,"title":"12 | PMQ 2.0的设计解析（中）","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geektime-distributed\">https://gitee.com/geektime-geekbang/geektime-distributed</a></p>","comments":[{"had_liked":false,"id":229674,"user_name":"geekbang","can_delete":false,"product_type":"c3","uid":1121231,"ip_address":"","ucode":"ED660016CD014C","user_header":"","comment_is_top":false,"comment_ctime":1593096274,"is_pvip":false,"replies":[{"id":84832,"content":"对，现在新版本Kafka的消费偏移是支持存在Broker主题上，我记得最早是只能存在ZK上。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1593188627,"ip_address":"","comment_id":229674,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"波波老师，kafka消费偏移应该早就改成存在位移主题上了，不是在zookeeper上。","like_count":4,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499586,"discussion_content":"对，现在新版本Kafka的消费偏移是支持存在Broker主题上，我记得最早是只能存在ZK上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593188627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230160,"user_name":"ahern88","can_delete":false,"product_type":"c3","uid":2039707,"ip_address":"","ucode":"C59BBA928ECF41","user_header":"","comment_is_top":false,"comment_ctime":1593297115,"is_pvip":false,"replies":[{"id":85285,"content":"在消息中间件中引入反压机制，会把系统搞复杂，一般两边的速度匹配问题，主要依赖堆积监控+扩容等手段来解决。\n\n现在有一些反应式开发框架，比如https:&#47;&#47;projectreactor.io&#47;，是支持所谓反压机制的。这个门槛较高，适用于一些高级场景。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1593530053,"ip_address":"","comment_id":230160,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师，消费端的消费速度很难与生产端的生产速度一致，为了达到最优效果，猜测是不是要引入背压机制通过动态滑动窗口去消费？","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499790,"discussion_content":"在消息中间件中引入反压机制，会把系统搞复杂，一般两边的速度匹配问题，主要依赖堆积监控+扩容等手段来解决。\n\n现在有一些反应式开发框架，比如https://projectreactor.io/，是支持所谓反压机制的。这个门槛较高，适用于一些高级场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593530053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046552,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/18/3e5e7db3.jpg","nickname":"Lorgine","note":"","ucode":"DB64E85327A252","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287004,"discussion_content":"多线程消费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593344480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229607,"user_name":"Jxin","can_delete":false,"product_type":"c3","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1593072828,"is_pvip":false,"replies":[{"id":84917,"content":"1. 消费者拉消息和报心跳是两个独立功能，请求频率也完全不同，肯定不能合在一起。\n2. Broker是无状态的，如果Broker出问题，Nginx健康检查机制会将其剔除(PMQ采用公司内部的Nginx层进行负载均衡)","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1593268902,"ip_address":"","comment_id":229607,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"1.拉取消息的动作是否可以放到心跳中去。\n2.为什么心跳异常后只提到broker剔除消费者？毕竟异常情况也有broker异常的可能，这时候消费端应该重平衡，重新绑定一个broker可用的分区组吧？","like_count":2,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499558,"discussion_content":"1. 消费者拉消息和报心跳是两个独立功能，请求频率也完全不同，肯定不能合在一起。\n2. Broker是无状态的，如果Broker出问题，Nginx健康检查机制会将其剔除(PMQ采用公司内部的Nginx层进行负载均衡)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593268902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270657,"user_name":"小美伢","can_delete":false,"product_type":"c3","uid":2379248,"ip_address":"","ucode":"8CCB526481A077","user_header":"https://static001.geekbang.org/account/avatar/00/24/4d/f0/a5a8b0d3.jpg","comment_is_top":false,"comment_ctime":1609208399,"is_pvip":false,"replies":[{"id":98383,"content":"push模式的话，broker上有线程要负责去推消息的，如果consumer慢，broker上线程会被阻塞。用邮递员作比喻，相当于邮递员需要主动把信送到每个人家里，如果某个人接收慢(或者路上堵了)，可能把邮递员堵塞住，影响给其它人送邮件。\npull模式，broker上相当于只有消息数据，consumer端各自去broker上拉各自的消息，互不干扰，不会堵塞。用取邮件作类比，相当于每个人自己去邮局取邮件，各取各的，不会堵塞。\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1609597722,"ip_address":"","comment_id":270657,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"波波老师， 视频里提到push模式下，如果consumer比较慢时， broker会堵塞，所以pull模式比较好。\n可是在pull的模式下， 如果consumer 很慢， 没有处理完就不会去pull 新的， 那不是更会造成堵塞吗？","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512703,"discussion_content":"push模式的话，broker上有线程要负责去推消息的，如果consumer慢，broker上线程会被阻塞。用邮递员作比喻，相当于邮递员需要主动把信送到每个人家里，如果某个人接收慢(或者路上堵了)，可能把邮递员堵塞住，影响给其它人送邮件。\npull模式，broker上相当于只有消息数据，consumer端各自去broker上拉各自的消息，互不干扰，不会堵塞。用取邮件作类比，相当于每个人自己去邮局取邮件，各取各的，不会堵塞。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609597722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261057,"user_name":"tenyears","can_delete":false,"product_type":"c3","uid":1855229,"ip_address":"","ucode":"0CACA3D408FBBE","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4e/fd/bce64518.jpg","comment_is_top":false,"comment_ctime":1605185326,"is_pvip":false,"replies":[{"id":95018,"content":"两者相辅相成看，看我视频有助于理解总体架构设计，撸代码可以理解更多细节、提升实践能力。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1605537731,"ip_address":"","comment_id":261057,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"看了两遍没看懂，代码下下来跑了一遍，方才理解数据模型的设计，我是不是理解能力太差了😂","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509360,"discussion_content":"两者相辅相成看，看我视频有助于理解总体架构设计，撸代码可以理解更多细节、提升实践能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605537731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248974,"user_name":"tenyears","can_delete":false,"product_type":"c3","uid":1855229,"ip_address":"","ucode":"0CACA3D408FBBE","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4e/fd/bce64518.jpg","comment_is_top":false,"comment_ctime":1600393370,"is_pvip":false,"replies":[{"id":91435,"content":"不好意思，没有完全理解你的问题，Kafka怎么会只有一个Partition？首先有Topic，然后才有Partition。\n\n关于Kafka消费者偏移的存储，新版本的Kafka支持将消费者偏移提交到一个叫__consumer_offsets的Topic中，参考：\nhttps:&#47;&#47;stackoverflow.com&#47;questions&#47;41137281&#47;offsets-stored-in-zookeeper-or-kafka\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1600528150,"ip_address":"","comment_id":248974,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"如果Kafka 只有一个Partition，那么记录的是不是消费者组的偏移量","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505789,"discussion_content":"不好意思，没有完全理解你的问题，Kafka怎么会只有一个Partition？首先有Topic，然后才有Partition。\n\n关于Kafka消费者偏移的存储，新版本的Kafka支持将消费者偏移提交到一个叫__consumer_offsets的Topic中，参考：\nhttps://stackoverflow.com/questions/41137281/offsets-stored-in-zookeeper-or-kafka\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600528150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234258,"user_name":"高峰","can_delete":false,"product_type":"c3","uid":1046111,"ip_address":"","ucode":"2DFE77FE4970B8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/5f/85e82813.jpg","comment_is_top":false,"comment_ctime":1594631279,"is_pvip":false,"replies":[{"id":86551,"content":"消费偏移最终是存在服务端的(PMQ是在元数据库中)，不管怎么重平衡，也不管某个分区的消费者是否因为rebalance而变化，最终都要从服务端去获取对应的消费偏移。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1594745187,"ip_address":"","comment_id":234258,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"老师你好，如果一个消费实例我部署多份，都在消费一个topic时 ，有一个消费者实例挂了，过1-2小时重启又好了，针对这个消费者的消费offset 还有保留在上一次对不？ 如果又进行了rebalance 这个消费者消费的 分区 可能会发生变化 那么这个消费者的offset如何保持正确？","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501332,"discussion_content":"消费偏移最终是存在服务端的(PMQ是在元数据库中)，不管怎么重平衡，也不管某个分区的消费者是否因为rebalance而变化，最终都要从服务端去获取对应的消费偏移。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594745187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229806,"user_name":"何凌","can_delete":false,"product_type":"c3","uid":1139066,"ip_address":"","ucode":"659D0EA089AFA4","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/7a/ec7c1881.jpg","comment_is_top":false,"comment_ctime":1593151405,"is_pvip":false,"replies":[{"id":84919,"content":"你理解错了，和Kafka一样，PMQ的消费者是有状态的，一个消费者必须记住它消费的Partition的消费偏移量。\n\n有状态的就不能round robin。\n\n你再思考下。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1593269757,"ip_address":"","comment_id":229806,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"如果去掉partition一定要assign 给某一个consumer的要求是不是rebalance的问题就好解决了？这样consumer来拉消息的时候可以round robin的从partition取数据。partition一定要assign给某个consumer这条目前只知道要求同key按顺序消费的情况下有用，还有其他情况有用吗？","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499647,"discussion_content":"你理解错了，和Kafka一样，PMQ的消费者是有状态的，一个消费者必须记住它消费的Partition的消费偏移量。\n\n有状态的就不能round robin。\n\n你再思考下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593269757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229623,"user_name":"Lorgine","can_delete":false,"product_type":"c3","uid":1046552,"ip_address":"","ucode":"DB64E85327A252","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/18/3e5e7db3.jpg","comment_is_top":false,"comment_ctime":1593076030,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"Broker如果出现异常会由ng自动踢掉。","like_count":1},{"had_liked":false,"id":229622,"user_name":"Lorgine","can_delete":false,"product_type":"c3","uid":1046552,"ip_address":"","ucode":"DB64E85327A252","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/18/3e5e7db3.jpg","comment_is_top":false,"comment_ctime":1593075981,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100053601,"comment_content":"第一个问题，心跳是按照实例级别来的，一个实例只要有一个心跳线程即可，但是一个实例可能会有多个分区，实例上每个分区都要拉取的。第二心跳是以固定的频率上报的，而拉取频率不是固定的。所以不能合在一起。","like_count":1},{"had_liked":false,"id":312554,"user_name":"瞌睡的李先生","can_delete":false,"product_type":"c3","uid":2264685,"ip_address":"","ucode":"88480FAFB4F879","user_header":"https://static001.geekbang.org/account/avatar/00/22/8e/6d/f2354440.jpg","comment_is_top":false,"comment_ctime":1631862976,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100053601,"comment_content":"我认为broker推模式 + consumer动态扩容也是不错的选择","like_count":0}]}