{"id":80801,"title":"40 | insert语句的锁为什么这么多？","content":"<p>在上一篇文章中，我提到MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。</p><p>因此，insert语句是一个很轻量的操作。不过，这个结论对于“普通的insert语句”才有效。也就是说，还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。</p><p>那么，今天这篇文章，我们就一起来聊聊这个话题。</p><h1>insert … select 语句</h1><p>我们先从昨天的问题说起吧。表t和t2的表结构、初始化数据语句如下，今天的例子我们还是针对这两个表展开。</p><pre><code>CREATE TABLE `t` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `c` int(11) DEFAULT NULL,\n  `d` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `c` (`c`)\n) ENGINE=InnoDB;\n\ninsert into t values(null, 1,1);\ninsert into t values(null, 2,2);\ninsert into t values(null, 3,3);\ninsert into t values(null, 4,4);\n\ncreate table t2 like t\n</code></pre><p>现在，我们一起来看看为什么在可重复读隔离级别下，binlog_format=statement时执行：</p><pre><code>insert into t2(c,d) select c,d from t;\n</code></pre><p>这个语句时，需要对表t的所有行和间隙加锁呢？</p><p>其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/86/33e513ee55d5700dc67f32bcdafb9386.png?wh=931*104\" alt=\"\"></p><center><span class=\"reference\">图1 并发insert场景</span></center><p>实际的执行效果是，如果session B先执行，由于这个语句对表t主键索引加了(-∞,1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p><p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format=statement的情况下，binlog里面就记录了这样的语句序列：</p><!-- [[[read_end]]] --><pre><code>insert into t values(-1,-1,-1);\ninsert into t2(c,d) select c,d from t;\n</code></pre><p>这个语句到了备库执行，就会把id=-1这一行也写到表t2中，出现主备不一致。</p><h1>insert 循环写入</h1><p>当然了，执行insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p><p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p><p>此时，我们可以这么写这条SQL语句 ：</p><pre><code>insert into t2(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);\n</code></pre><p>这个语句的加锁范围，就是表t索引c上的(3,4]和(4,supremum]这两个next-key lock，以及主键索引上id=4这一行。</p><p>它的执行流程也比较简单，从表t中按照索引c倒序，扫描第一行，拿到结果写入到表t2中。</p><p>因此整条语句的扫描行数是1。</p><p>这个语句执行的慢查询日志（slow log），如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/74/3efdf8256309a44e23d93089459eda74.png?wh=932*85\" alt=\"\"></p><center><span class=\"reference\">图2 慢查询日志--将数据插入表t2</span></center><p>通过这个慢查询日志，我们看到Rows_examined=1，正好验证了执行这条语句的扫描行数为1。</p><p>那么，如果我们是要把这样的一行数据插入到表t中的话：</p><pre><code>insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);\n</code></pre><p>语句的执行流程是怎样的？扫描行数又是多少呢？</p><p>这时候，我们再看慢查询日志就会发现不对了。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/18/6f90b04c09188bff11dae6e788abb918.png?wh=925*76\" alt=\"\"></p><center><span class=\"reference\">图3 慢查询日志--将数据插入表t</span></center><p>可以看到，这时候的Rows_examined的值是5。</p><p>我在前面的文章中提到过，希望你都能够学会用explain的结果来“脑补”整条语句的执行过程。今天，我们就来一起试试。</p><p>如图4所示就是这条语句的explain结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/2a/d7270781ee3f216325b73bd53999b82a.png?wh=1390*168\" alt=\"\"></p><center><span class=\"reference\">图4 explain结果</span></center><p>从Extra字段可以看到“Using temporary”字样，表示这个语句用到了临时表。也就是说，执行过程中，需要把表t的内容读出来，写入临时表。</p><p>图中rows显示的是1，我们不妨先对这个语句的执行流程做一个猜测：如果说是把子查询的结果读出来（扫描1行），写入临时表，然后再从临时表读出来（扫描1行），写回表t中。那么，这个语句的扫描行数就应该是2，而不是5。</p><p>所以，这个猜测不对。实际上，Explain结果里的rows=1是因为受到了limit 1 的影响。</p><p>从另一个角度考虑的话，我们可以看看InnoDB扫描了多少行。如图5所示，是在执行这个语句前后查看Innodb_rows_read的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/d7/489281d8029e8f60979cb7c4494010d7.png?wh=1038*451\" alt=\"\"></p><center><span class=\"reference\">图5 查看 Innodb_rows_read变化</span></center><p>可以看到，这个语句执行前后，Innodb_rows_read的值增加了4。因为默认临时表是使用Memory引擎的，所以这4行查的都是表t，也就是说对表t做了全表扫描。</p><p>这样，我们就把整个执行过程理清楚了：</p><ol>\n<li>\n<p>创建临时表，表里有两个字段c和d。</p>\n</li>\n<li>\n<p>按照索引c扫描表t，依次取c=4、3、2、1，然后回表，读到c和d的值写入临时表。这时，Rows_examined=4。</p>\n</li>\n<li>\n<p>由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中。这时，Rows_examined的值加1，变成了5。</p>\n</li>\n</ol><p>也就是说，这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p><p>至于这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p><p>由于实现上这个语句没有在子查询中就直接使用limit 1，从而导致了这个语句的执行需要遍历整个表t。它的优化方法也比较简单，就是用前面介绍的方法，先insert into到临时表temp_t，这样就只需要扫描一行；然后再从表temp_t里面取出这行数据插入表t1。</p><p>当然，由于这个语句涉及的数据量很小，你可以考虑使用内存临时表来做这个优化。使用内存临时表优化时，语句序列的写法如下：</p><pre><code>create temporary table temp_t(c int,d int) engine=memory;\ninsert into temp_t  (select c+1, d from t force index(c) order by c desc limit 1);\ninsert into t select * from temp_t;\ndrop table temp_t;\n</code></pre><h1>insert 唯一键冲突</h1><p>前面的两个例子是使用insert … select的情况，接下来我要介绍的这个例子就是最常见的insert语句出现唯一键冲突的情况。</p><p>对于有唯一键的表，插入数据时出现唯一键冲突也是常见的情况了。我先给你举一个简单的唯一键冲突的例子。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/ca/83fb2d877932941b230d6b5be8cca6ca.png?wh=934*279\" alt=\"\"></p><center><span class=\"reference\">图6 唯一键冲突加锁</span></center><p>这个例子也是在可重复读（repeatable read）隔离级别下执行的。可以看到，session B要执行的insert语句进入了锁等待状态。</p><p>也就是说，session A执行的insert语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。我们前面说过，一个next-key lock就是由它右边界的值定义的。这时候，session A持有索引c上的(5,10]共享next-key lock（读锁）。</p><p>至于为什么要加这个读锁，其实我也没有找到合理的解释。从作用上来看，这样做可以避免这一行被别的事务删掉。</p><p>这里<a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html\">官方文档</a>有一个描述错误，认为如果冲突的是主键索引，就加记录锁，唯一索引才加next-key lock。但实际上，这两类索引冲突加的都是next-key lock。</p><blockquote>\n<p>备注：这个bug，是我在写这篇文章查阅文档时发现的，已经<a href=\"https://bugs.mysql.com/bug.php?id=93806\">发给官方</a>并被verified了。</p>\n</blockquote><p>有同学在前面文章的评论区问到，在有多个唯一索引的表中并发插入数据时，会出现死锁。但是，由于他没有提供复现方法或者现场，我也无法做分析。所以，我建议你在评论区发问题的时候，尽量同时附上复现方法，或者现场信息，这样我才好和你一起分析问题。</p><p>这里，我就先和你分享一个经典的死锁场景，如果你还遇到过其他唯一键冲突导致的死锁场景，也欢迎给我留言。</p><p><img src=\"https://static001.geekbang.org/resource/image/63/2d/63658eb26e7a03b49f123fceed94cd2d.png?wh=934*277\" alt=\"\"></p><center><span class=\"reference\">图7 唯一键冲突--死锁</span></center><p>在session A执行rollback语句回滚的时候，session C几乎同时发现死锁并返回。</p><p>这个死锁产生的逻辑是这样的：</p><ol>\n<li>\n<p>在T1时刻，启动session A，并执行insert语句，此时在索引c的c=5上加了记录锁。注意，这个索引是唯一索引，因此退化为记录锁（如果你的印象模糊了，可以回顾下<a href=\"https://time.geekbang.org/column/article/75659\">第21篇文章</a>介绍的加锁规则）。</p>\n</li>\n<li>\n<p>在T2时刻，session B要执行相同的insert语句，发现了唯一键冲突，加上读锁；同样地，session C也在索引c上，c=5这一个记录上，加了读锁。</p>\n</li>\n<li>\n<p>T3时刻，session A回滚。这时候，session B和session C都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁。</p>\n</li>\n</ol><p>这个流程的状态变化图如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/b8/3e0bf1a1241931c14360e73fd10032b8.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图8 状态变化图--死锁</span></center><h1>insert into … on duplicate key update</h1><p>上面这个例子是主键冲突后直接报错，如果是改写成</p><pre><code>insert into t values(11,10,10) on duplicate key update d=100; \n</code></pre><p>的话，就会给索引c上(5,10] 加一个排他的next-key lock（写锁）。</p><p><strong>insert into … on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</strong></p><p>注意，如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p><p>现在表t里面已经有了(1,1,1)和(2,2,2)这两行，我们再来看看下面这个语句执行的效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/02/5f384d6671c87a60e1ec7e490447d702.png?wh=767*230\" alt=\"\"></p><center><span class=\"reference\">图9 两个唯一键同时冲突</span></center><p>可以看到，主键id是先判断的，MySQL认为这个语句跟id=2这一行冲突，所以修改的是id=2的行。</p><p>需要注意的是，执行这条语句的affected rows返回的是2，很容易造成误解。实际上，真正更新的只有一行，只是在代码实现上，insert和update都认为自己成功了，update计数加了1， insert计数也加了1。</p><h1>小结</h1><p>今天这篇文章，我和你介绍了几种特殊情况下的insert语句。</p><p>insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。</p><p>而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化。</p><p>insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock(S锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p><p>最后，我给你留一个问题吧。</p><p>你平时在两个表之间拷贝数据用的是什么方法，有什么注意事项吗？在你的应用场景里，这个方法，相较于其他方法的优势是什么呢？</p><p>你可以把你的经验和分析写在评论区，我会在下一篇文章的末尾选取有趣的评论来和你一起分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>我们已经在文章中回答了上期问题。</p><p>有同学提到，如果在insert … select 执行期间有其他线程操作原表，会导致逻辑错误。其实，这是不会的，如果不加锁，就是快照读。</p><p>一条语句执行期间，它的一致性视图是不会修改的，所以即使有其他事务修改了原表的数据，也不会影响这条语句看到的数据。</p><p>评论区留言点赞板：</p><blockquote>\n<p>@长杰 同学回答得非常准确。</p>\n</blockquote><p></p>","neighbors":{"left":{"article_title":"39 | 自增主键为什么不是连续的？","id":80531},"right":{"article_title":"41 | 怎么最快地复制一张表？","id":81925}},"comments":[{"had_liked":false,"id":66978,"user_name":"huolang","can_delete":false,"product_type":"c1","uid":1346708,"ip_address":"","ucode":"FDC4A6B6151C5E","user_header":"https://static001.geekbang.org/account/avatar/00/14/8c/94/5282994c.jpg","comment_is_top":false,"comment_ctime":1550050426,"is_pvip":false,"replies":[{"id":"23782","content":"1. 是的<br>2. 这个我觉得是为了防止这个记录再被删除（不过这个理由不是很硬，我还没有找到其他解释<br>3. 互斥的，所以这两个语句都在等待。注意next-key lock是由间隙锁和记录锁组成的哦， 间隙锁加成功了的。好问题。<br>4. 还没有提交，但是这个记录已经作为最新记录写进去了，复习一下08篇哈","user_name":"作者回复","comment_id":66978,"uid":"1264162","ip_address":"","utype":1,"ctime":1550112317,"user_name_real":"林晓斌"}],"discussion_count":23,"race_medal":0,"score":"405276976250","product_id":100020801,"comment_content":"老师，死锁的例子，关于sessionA拿到的c=5的记录锁，sessionB和sessionC发现唯一键冲突会加上读锁我有几个疑惑：<br>1. sessionA拿到的c=5的记录锁是写锁吗？<br>2. 为什么sessionB和sessionC发现唯一键冲突会加上读锁？<br>3. 如果sessionA拿到c=5的记录所是写锁，那为什么sessionB和sessionC还能加c=5的读锁，写锁和读锁不应该是互斥的吗？<br>4.  sessionA还没有提交，为什么sessionB和sessionC能发现唯一键冲突？","like_count":94,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438998,"discussion_content":"1. 是的\n2. 这个我觉得是为了防止这个记录再被删除（不过这个理由不是很硬，我还没有找到其他解释\n3. 互斥的，所以这两个语句都在等待。注意next-key lock是由间隙锁和记录锁组成的哦， 间隙锁加成功了的。好问题。\n4. 还没有提交，但是这个记录已经作为最新记录写进去了，复习一下08篇哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550112317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213495,"avatar":"https://static001.geekbang.org/account/avatar/00/12/84/37/a13d867a.jpg","nickname":"zc","note":"","ucode":"07900D4B6A3135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143579,"discussion_content":"这里不能说成加上读锁，应该是判断数据是否能写入需要进行当前读，进行当前读需要先加读锁，然后就被写锁阻塞住了，最后session a回滚，b和c成功加上读锁，且读取判断是否可写入，得到的答案是可以，然后都进行锁升级，于是死锁了","likes_number":33,"is_delete":false,"is_hidden":false,"ctime":1579515199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1061402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/y5NFbibdKCFCg0lHKK5ERGOQWXYYK7jhnqm2BxQ6r7tWvXx8uDmibglweejDWU39BTmDSAtBJGj1ibOZK2uIHQyqg/132","nickname":"Mr_freezing37","note":"","ucode":"BB605A6FEDCEB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1213495,"avatar":"https://static001.geekbang.org/account/avatar/00/12/84/37/a13d867a.jpg","nickname":"zc","note":"","ucode":"07900D4B6A3135","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253143,"discussion_content":"如果是当前读-升级这个逻辑。\n两个session是并发关系，这个结果就不是必现。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588219613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143579,"ip_address":""},"score":253143,"extra":""},{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1061402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/y5NFbibdKCFCg0lHKK5ERGOQWXYYK7jhnqm2BxQ6r7tWvXx8uDmibglweejDWU39BTmDSAtBJGj1ibOZK2uIHQyqg/132","nickname":"Mr_freezing37","note":"","ucode":"BB605A6FEDCEB6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324374,"discussion_content":"不同意。我觉得必然出现的。\n因为session b的读锁和session c读锁在a释放写锁后同时拿到读锁。读锁不互斥，没理由不同时拿到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605096279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":253143,"ip_address":""},"score":324374,"extra":""},{"author":{"id":2566445,"avatar":"https://static001.geekbang.org/account/avatar/00/27/29/2d/39637017.jpg","nickname":"烟火","note":"","ucode":"2CE0BBFD5E6AC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1213495,"avatar":"https://static001.geekbang.org/account/avatar/00/12/84/37/a13d867a.jpg","nickname":"zc","note":"","ucode":"07900D4B6A3135","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372409,"discussion_content":"这里sesion A回滚后，B C的间隙锁范围变成(4,+无穷),然后都加读锁，然后死锁等待了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620309987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143579,"ip_address":""},"score":372409,"extra":""}]},{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361057,"discussion_content":"好像有点懂了  发生索引冲突加的next-key 这整个都是读锁，next-key 包括 gap lock 和 record lock  那对gap lock，  session B和session C 都先加读锁成功 ，然后加 c=5 这一行的读锁 因为 session A 对c=5加了写锁 所以 session B和session C  对 c=5  加读锁 等待，当 session A 回滚的时候，session B和session C  对 c=5  加读锁成功，然后session B和session C开始插入c=5写锁 ,都因为要等待对方释放 c=5 读锁而产生死锁","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1616589666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373664,"discussion_content":"不明白为啥B和C会有看到A的插入数据，造成冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620816831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361057,"ip_address":""},"score":373664,"extra":""},{"author":{"id":2064501,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/80/75/c00e3116.jpg","nickname":"niss","note":"","ucode":"7449D8B30EE0E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386339,"discussion_content":"c是唯一索引，插入数据需要先读数据，判断没有冲突再写。读的时候是当前读，所以可以看到A插入的数据。\n如果把c的唯一索引去掉，就不需要判断是否有冲突了，这时候session B和session C都可以执行成功","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1627538552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373664,"ip_address":""},"score":386339,"extra":""},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578388,"discussion_content":"你这还是不对      加行锁还分先加读再加写?    insert不直接加这一行的写锁了?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656692952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361057,"ip_address":""},"score":578388,"extra":""}]},{"author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280608,"discussion_content":"我认为是这样的：next-key-lock 先加的是间隙锁，再加行锁，加间隙锁是没问题的，加行锁的时候发现被堵塞了，当sessionArollback的时候，sessionB和SessionC插入都会被对方的间隙锁锁住，造成了死锁","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1591578128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325823,"discussion_content":"间隙锁是开区间的， sessionB和sessionC插入怎么会被对方的间隙锁锁住呢，这个点感觉说不通","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605439890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280608,"ip_address":""},"score":325823,"extra":""},{"author":{"id":2021212,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MdmRMTV2IwvQZF2IO0G0CFWbKxT9CIibmcdicS3J4SmrA4P1e36jCwyXZpia06ItwP4GibGnCrPJHicBbd5y9libTpiaA/132","nickname":"^_^","note":"","ucode":"301EE75D170771","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1466840,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/d8/3bc19bff.jpg","nickname":"恋在那时","note":"","ucode":"7F026B4B708C7D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348506,"discussion_content":"间隙锁是共享锁呀，你加我也可以加","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612604931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280608,"ip_address":""},"score":348506,"extra":""},{"author":{"id":1978838,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/31/d6/4bfaa08c.jpg","nickname":"阿川Arc","note":"","ucode":"4D990D6E3152A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370830,"discussion_content":"不是啊 他的意思应该是sessionB的插入操作被sessionC的间隙锁阻塞了，sessionC的插入被sessionB的间隙锁阻塞了。间隙锁跟插入行为是互斥的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619539428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325823,"ip_address":""},"score":370830,"extra":""}]},{"author":{"id":1397351,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","nickname":"zapup","note":"","ucode":"388D6BB5D7B137","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294079,"discussion_content":"问的真好","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595775782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2048666,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvIkMsUBo7glPEWJjpBEM7ice9nLySxsCibicZg2Uubuia27KZGXXYibPhMhIT6m1GVCIM1l1ILJnj74kwvOqqRSKjg/132","nickname":"强强","note":"","ucode":"86E0C8A6B5CF55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301385,"discussion_content":"当前读","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598511819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2048666,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvIkMsUBo7glPEWJjpBEM7ice9nLySxsCibicZg2Uubuia27KZGXXYibPhMhIT6m1GVCIM1l1ILJnj74kwvOqqRSKjg/132","nickname":"强强","note":"","ucode":"86E0C8A6B5CF55","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373641,"discussion_content":"当前读也读不到其他事务未提交的啊，那不成了脏读","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1620809645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301385,"ip_address":""},"score":373641,"extra":""},{"author":{"id":1710200,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VUnspzjpBcmEibUicMJoDpnvsElyX5R6Eia9pjNuP3MaD9iaJpBS4vZ4krzLIniaZucFVrKnfJ1VumLLZ8gRt9KnCLQ/132","nickname":"Geek_39958b","note":"","ucode":"500FC31A7627AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386998,"discussion_content":"其实是可以的，这里涉及到隐式锁。一般情况下，insert语句插入的数据是不需要生成内存锁的，一般通过隐式锁来控制。策略就是，插入的聚集索引记录包含了一个trx_id，然后其他事务要获取该记录的x锁或者s锁的时候，会判断trx_id是不是当前活跃事务。如果是帮该记录创建一个x锁，然后为自己创建一个锁，进入等待。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1627924382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373641,"ip_address":""},"score":386998,"extra":""},{"author":{"id":1922583,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELVtQAW8IIDLKcn36XM9noEfKuAKpJQrwruJzXeibDfmibIiawicj5vaoflct0LuTAiaKcmCY3gK9MknEw/132","nickname":"远方","note":"","ucode":"0E2FCC59EDCAD4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1710200,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VUnspzjpBcmEibUicMJoDpnvsElyX5R6Eia9pjNuP3MaD9iaJpBS4vZ4krzLIniaZucFVrKnfJ1VumLLZ8gRt9KnCLQ/132","nickname":"Geek_39958b","note":"","ucode":"500FC31A7627AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388680,"discussion_content":"那是先获取隐式锁了还是先检查主键了？ 我觉得应该是先获取锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628909154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":386998,"ip_address":""},"score":388680,"extra":""}]}]},{"had_liked":false,"id":73298,"user_name":"轻松的鱼","can_delete":false,"product_type":"c1","uid":1219198,"ip_address":"","ucode":"F4FF653209C47B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEl3fX9nvzUF26ekUIicp4sgA5jZ1mGvGMhIHkwJabbjt9h5uTLw5zzU1U6JZbCSpRXBNQwuejLJg/132","comment_is_top":false,"comment_ctime":1551853526,"is_pvip":false,"replies":[{"id":"28008","content":"对","user_name":"作者回复","comment_id":73298,"uid":"1264162","ip_address":"","utype":1,"ctime":1552724124,"user_name_real":"林晓斌"}],"discussion_count":11,"race_medal":0,"score":"259249891286","product_id":100020801,"comment_content":"老师好，想请教一下死锁的例子中：<br>1. 在 session A rollback 前，session B&#47;C 都因为唯一性冲突申请了 S Next-key lock，但是被 session A 的 X but not gap lock 阻塞；<br>2. 在 session A rollbak 后，session B&#47;C 顺利获得 S Next-key lock，并且都要继续进行插入，这时候我认为是因为插入意向锁（LOCK_INSERT_INTENTION）导致的死锁，因为插入意向锁会被 gap lock 阻塞，造成了相互等待。还没有进入到记录 X lock。<br>不知道我分析的对不对？","like_count":60,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442011,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552724124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373652,"discussion_content":"看到这里更迷糊了。。。老师也没有讲过意向锁啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620814514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351117,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2au3iaQvydOVeVY1vlSVeGia7SvrpWFVibdxdjKiafof3RhzFO9e8sxKIBxKXJQibRNpO9pCH2hmibkibsGv7YKF3yjEw/132","nickname":"秋一匹","note":"","ucode":"BEBDBF8C15C6BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328285,"discussion_content":"按现在的思路来说，并不是间隙锁阻塞插入意向锁导致的死锁。因为间隙锁是不包含5这条记录的。还是5上的记录锁（s）导致的死锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606118582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":3056474,"avatar":"","nickname":"Geek_f5618b","note":"","ucode":"FF7F8BF3A47B30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351117,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2au3iaQvydOVeVY1vlSVeGia7SvrpWFVibdxdjKiafof3RhzFO9e8sxKIBxKXJQibRNpO9pCH2hmibkibsGv7YKF3yjEw/132","nickname":"秋一匹","note":"","ucode":"BEBDBF8C15C6BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580636,"discussion_content":"A回滚后间隙锁扩大到正无穷","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658301676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328285,"ip_address":""},"score":580636,"extra":""},{"author":{"id":3189388,"avatar":"https://static001.geekbang.org/account/avatar/00/30/aa/8c/eaa0f576.jpg","nickname":".","note":"","ucode":"66FAAB07BD7B17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3056474,"avatar":"","nickname":"Geek_f5618b","note":"","ucode":"FF7F8BF3A47B30","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588983,"discussion_content":"为什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664286759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":580636,"ip_address":"湖北"},"score":588983,"extra":""}]},{"author":{"id":1024486,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","nickname":"旭东(Frank)","note":"","ucode":"176FA629800062","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78748,"discussion_content":"主键冲突也是一样的问题吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576003864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2736955,"avatar":"https://static001.geekbang.org/account/avatar/00/29/c3/3b/c9ae499f.jpg","nickname":"impwang","note":"","ucode":"149DF7CA8D56C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582326,"discussion_content":"这里插入意向锁怎么和gap锁构成死锁了？加锁流程是什么啊？有点晕了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659369435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2736955,"avatar":"https://static001.geekbang.org/account/avatar/00/29/c3/3b/c9ae499f.jpg","nickname":"impwang","note":"","ucode":"149DF7CA8D56C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588485,"discussion_content":"很多评论都是自己强套乱想的概念，推荐看下死锁日志就明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663782328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":582326,"ip_address":"广东"},"score":588485,"extra":""}]},{"author":{"id":1613760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/c0/86febfff.jpg","nickname":"Master","note":"","ucode":"79D0145B853C9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376100,"discussion_content":"再补充一下，意向锁是引擎自己加的，是在获取行锁之前去加，那么本课的例子，sessionA回滚，那么B和C尝试去操作，事先都在该冲突行获取了读锁，后面再各自想执行，就要加写锁了，那么就存在了冲突，此时是IX","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621955144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/c0/86febfff.jpg","nickname":"Master","note":"","ucode":"79D0145B853C9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376098,"discussion_content":"这里试着回答一下，意向锁上下文确实没有提到，但是通过老师的回复，我觉得得跳出本文，回到加锁这里，意向锁说白了就是为了更快的判定能不能加锁执行，因此在写操作上，innodb会通过事先尝试获取意向锁来进行加锁判断，毕竟是表级别的锁，再回到本文死锁那个case，觉得也是先获取意向锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621954667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1219198,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEl3fX9nvzUF26ekUIicp4sgA5jZ1mGvGMhIHkwJabbjt9h5uTLw5zzU1U6JZbCSpRXBNQwuejLJg/132","nickname":"轻松的鱼","note":"","ucode":"F4FF653209C47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1613760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/c0/86febfff.jpg","nickname":"Master","note":"","ucode":"79D0145B853C9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376204,"discussion_content":"插入意向锁是一种特殊的间隙锁，和意向锁是两个不同的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622014769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376098,"ip_address":""},"score":376204,"extra":""}]}]},{"had_liked":false,"id":67395,"user_name":"sonic","can_delete":false,"product_type":"c1","uid":1309000,"ip_address":"","ucode":"E59D298909E948","user_header":"https://static001.geekbang.org/account/avatar/00/13/f9/48/bf570bab.jpg","comment_is_top":false,"comment_ctime":1550139438,"is_pvip":false,"replies":[{"id":"23999","content":"可重复读隔离级别下，事务是可以看到自己刚刚修改的数据的 ，好问题","user_name":"作者回复","comment_id":67395,"uid":"1264162","ip_address":"","utype":1,"ctime":1550298458,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"194823667758","product_id":100020801,"comment_content":"你好，<br>我想问下文章中关于为什么需要创建临时表有这一句话：<br>如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。<br><br>我的疑问是：既然隔离级别是可重复读，照理来说新插入的的记录应该不会参与计算逻辑呀。","like_count":45,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439177,"discussion_content":"可重复读隔离级别下，事务是可以看到自己刚刚修改的数据的 ，好问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550298458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744257,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","nickname":"千锤百炼领悟之极限","note":"","ucode":"224B5CF2101716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589362,"discussion_content":"即使在可重复读隔离级别下，自己事务更新的结果还是要认的，当前读了解一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664767174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66826,"user_name":"夹心面包","can_delete":false,"product_type":"c1","uid":1301957,"ip_address":"","ucode":"002BBA49D83D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCscgdVibmoPyRLRaicvk6rjTJxePZ6VFHvGjUQvtfhCS6kO4OZ1AVibbhNGKlWZmpEFf2yA6ptsqHw/132","comment_is_top":false,"comment_ctime":1550026252,"is_pvip":false,"replies":[{"id":"23666","content":"👍，这两点都是很有用的建议","user_name":"作者回复","comment_id":66826,"uid":"1264162","ip_address":"","utype":1,"ctime":1550043549,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"194823554572","product_id":100020801,"comment_content":"<br>1 关于insert造成死锁的情况,我之前做过测试,事务1并非只有insert,delete和update都可能造成死锁问题,核心还是插入唯一值冲突导致的.我们线上的处理办法是 1 去掉唯一值检测 2减少重复值的插入 3降低并发线程数量<br>2 关于数据拷贝大表我建议采用pt-archiver,这个工具能自动控制频率和速度,效果很不错,提议在低峰期进行数据操作","like_count":45,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438933,"discussion_content":"👍，这两点都是很有用的建议","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550043549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069127,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/47/46da4585.jpg","nickname":"Fan()","note":"","ucode":"FED79EC7D78E91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309164,"discussion_content":"邓总好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601203327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70935,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1551229906,"is_pvip":false,"replies":[{"id":"25436","content":"是这样的，gap lock是无所谓S还是X的。<br>但是record lock 有。<br><br>Gap lock + 排他的record 就称作 排他的next-key lock 吧😄<br><br>","user_name":"作者回复","comment_id":70935,"uid":"1264162","ip_address":"","utype":1,"ctime":1551242843,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"134695216082","product_id":100020801,"comment_content":"老师您好：<br>关于文中的锁描述有所疑惑。<br><br>文中出现过 共享的next-key锁 和 排他的next-key锁。<br><br>我们知道next-key是由 gap lock 和 行锁组成的。<br><br>我一直以来的认知是 gap lock都是s锁，没有x锁。<br>而行锁有s锁和x锁。<br>比如 select………lock in share mode，行锁是s<br>锁。<br>比如select………for update，行锁就是x锁。<br>但是gap lock 始终是s锁。<br><br>文中直接描述next-key lock是排他的，总让我认为gap lock和行锁都是x锁。<br><br>不知道我理解得对不对？","like_count":31,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440907,"discussion_content":"是这样的，gap lock是无所谓S还是X的。\n但是record lock 有。\n\nGap lock + 排他的record 就称作 排他的next-key lock 吧😄\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551242843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179156,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg","nickname":"鲁班大师","note":"","ucode":"4F9615DF87B031","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251899,"discussion_content":"间隙锁是解决幻读问题的，不管属于读锁还是写锁，都会阻塞其他事务的写请求。从这个角度来看，也就是无所谓读锁还是写锁了。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588125077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67064,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1550065941,"is_pvip":false,"replies":[{"id":"23801","content":"👍","user_name":"作者回复","comment_id":67064,"uid":"1264162","ip_address":"","utype":1,"ctime":1550127544,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"126104117525","product_id":100020801,"comment_content":"课后问题：<br>      我用的最多还是insert into select 。如果数量比较大，会加上limit 100,000这种。并且看看后面的select条件是否走索引。缺点是会锁select的表。方法二：导出成excel，然后拼sql 成 insert into values(),(),()的形式。方法3，写类似淘宝调动的定时任务，任务的逻辑是查询100条记录，然后多个线程分到几个任务执行，比如是个线程，每个线程10条记录，插入后，在查询新的100条记录处理。<br>      ","like_count":29,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439038,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550127544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67707,"user_name":"Justin","can_delete":false,"product_type":"c1","uid":1305601,"ip_address":"","ucode":"D49723FEA66731","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/01/978d54af.jpg","comment_is_top":false,"comment_ctime":1550226433,"is_pvip":false,"replies":[{"id":"24011","content":"额，<br>这里我们要澄清一下哈<br>只有一个gap lock，就是 next key lock = gap lock + record lock；<br><br>我们说一个insert语句如果要插入一个间隙，而这个间隙上有gap lock的话，insert语句会被堵住，这个被堵住的效果，实现机制上是用插入意向锁和gap lock相互作用来实现的。<br>gap lock并不属于插入意向锁的一部分 ，就没有“插入意向锁的gal lock”这个概念哈","user_name":"作者回复","comment_id":67707,"uid":"1264162","ip_address":"","utype":1,"ctime":1550299441,"user_name_real":"林晓斌"}],"discussion_count":5,"race_medal":0,"score":"91744539649","product_id":100020801,"comment_content":"插入意向锁的gal lock和next key lock中的 gaplock互斥吗？","like_count":21,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439338,"discussion_content":"额，\n这里我们要澄清一下哈\n只有一个gap lock，就是 next key lock = gap lock + record lock；\n\n我们说一个insert语句如果要插入一个间隙，而这个间隙上有gap lock的话，insert语句会被堵住，这个被堵住的效果，实现机制上是用插入意向锁和gap lock相互作用来实现的。\ngap lock并不属于插入意向锁的一部分 ，就没有“插入意向锁的gal lock”这个概念哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550299441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202676,"discussion_content":"那插入意向锁是啥啊？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1583939497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1411040,"avatar":"https://static001.geekbang.org/account/avatar/00/15/87/e0/63e7d43d.jpg","nickname":"星空","note":"","ucode":"636A0A14608EF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388592,"discussion_content":"这句话 “而这个间隙上有gap lock的话，insert语句会被堵住”   不解，gap lock 就是间隙锁吧，不是说间隙锁是共享的吗，为什么会被间隙锁堵住","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628843288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2771089,"avatar":"","nickname":"Geek_126edf","note":"","ucode":"D5C8819DF40803","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1411040,"avatar":"https://static001.geekbang.org/account/avatar/00/15/87/e0/63e7d43d.jpg","nickname":"星空","note":"","ucode":"636A0A14608EF0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398603,"discussion_content":"我的理解，间隙锁是共享的，所以另一个线程也可以拿到间隙锁，但是他还是不能执行insert语句","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632820124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":388592,"ip_address":""},"score":398603,"extra":""},{"author":{"id":1341276,"avatar":"https://static001.geekbang.org/account/avatar/00/14/77/5c/8d53165e.jpg","nickname":"bingo","note":"","ucode":"DD96820EC8871D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1411040,"avatar":"https://static001.geekbang.org/account/avatar/00/15/87/e0/63e7d43d.jpg","nickname":"星空","note":"","ucode":"636A0A14608EF0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405441,"discussion_content":"间隙锁和间隙锁可以共存，和别的锁都会冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634566768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":388592,"ip_address":""},"score":405441,"extra":""}]}]},{"had_liked":false,"id":66898,"user_name":"一大只😴","can_delete":false,"product_type":"c1","uid":1310960,"ip_address":"","ucode":"92F3D2B7F63568","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/f0/08409e78.jpg","comment_is_top":false,"comment_ctime":1550039188,"is_pvip":false,"replies":[{"id":"23805","content":"“那这里的session B应该是加了个(22,25]的next-key lock，并没有因为是唯一键退化成记录锁” 由于insert主键冲突导致的锁，是不会退化的。<br><br>session B 加了next-key lock，<br>这样session C插入也要等待，然后等session B超时，释放了这个next-key lock，session C就可以执行了。<br>跟我们文中说的是一致的哦。<br><br><br>你这个验证挺合理的呀，<br><br>不会有因为“间隙非常小，所以将他当成记录锁”这种逻辑哈, a和a+1之间也是有间隙的😆。<br><br>不过这个是个好的实验和好问题👍","user_name":"作者回复","comment_id":66898,"uid":"1264162","ip_address":"","utype":1,"ctime":1550133640,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"78859450516","product_id":100020801,"comment_content":"老师，我想问下：insert 语句出现唯一键冲突，会加next-key lock，而产生死锁的例子中，同样也是唯一键冲突却只加了记录锁，然后我按照唯一键冲突中的两个例子试了试<br>1、比如t表中有两条记录(19,19,19)，(22,22,22)，这时候我再insert (22,22,22)造成了主键冲突，这时候加的就是(19,22]的next-key lock，这个insert为啥不是等值查询？<br>2、根据死锁的例子，我又在t表中准备插入一行<br>      session A :begin; insert into t values (25,25,25)<br>      session B :insert into t values (25,25,25)  这时候sessionB锁等待<br>      session C：insert into t values (24,24,24)  锁等待，等B锁等待超时，session C插入成功<br>      那这里的session B应该是加了个(22,25]的next-key lock，并没有因为是唯一键退化成记录锁<br>我想死锁的例子中t表已经有了(1,1,1),(2,2,2),(3,3,3),(4,4,4)4条记录，这时候insert (null,5,5)，是不是加的(4,5]这个next-key lock，由于是整型并且间隙非常小，所以将他当成记录锁？","like_count":18,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438965,"discussion_content":"“那这里的session B应该是加了个(22,25]的next-key lock，并没有因为是唯一键退化成记录锁” 由于insert主键冲突导致的锁，是不会退化的。\n\nsession B 加了next-key lock，\n这样session C插入也要等待，然后等session B超时，释放了这个next-key lock，session C就可以执行了。\n跟我们文中说的是一致的哦。\n\n\n你这个验证挺合理的呀，\n\n不会有因为“间隙非常小，所以将他当成记录锁”这种逻辑哈, a和a+1之间也是有间隙的😆。\n\n不过这个是个好的实验和好问题👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550133640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537709,"avatar":"https://static001.geekbang.org/account/avatar/00/17/76/ad/f192d95e.jpg","nickname":"？新！","note":"","ucode":"56E547E279A10A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376203,"discussion_content":"问题1  你要搞清楚，是主键的(19,22]还是 唯一索引的哦，实验的时候一定要保证好场景的隔离，别 重叠了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622014611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66950,"user_name":"roaming","can_delete":false,"product_type":"c1","uid":1039232,"ip_address":"","ucode":"2736679690AB81","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/80/6b7629d7.jpg","comment_is_top":false,"comment_ctime":1550046519,"is_pvip":false,"replies":[{"id":"23806","content":"看来是的了，<br><br>👍，很好的验证，我加到明天文章末尾说明","user_name":"作者回复","comment_id":66950,"uid":"1264162","ip_address":"","utype":1,"ctime":1550133674,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"53089654071","product_id":100020801,"comment_content":"MySQL8.0.12环境下，<br>执行insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);<br>slow log Rows_examined: 2<br>Innodb_rows_read 的值增加1<br><br>是不是MySQL8进行了优化，先把子查询的结果读出来，再写入临时表？","like_count":12,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438990,"discussion_content":"看来是的了，\n\n👍，很好的验证，我加到明天文章末尾说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550133674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83545,"user_name":"inrtyx","can_delete":false,"product_type":"c1","uid":1246178,"ip_address":"","ucode":"81CD18FF34ABAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","comment_is_top":false,"comment_ctime":1554645563,"is_pvip":true,"replies":[{"id":"30222","content":"要看需求，不过因为表情用的很多了，utf8mb4很常用了","user_name":"作者回复","comment_id":83545,"uid":"1264162","ip_address":"","utype":1,"ctime":1554652890,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"48799285819","product_id":100020801,"comment_content":"现在一般都用utf8mb4?","like_count":11,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446066,"discussion_content":"要看需求，不过因为表情用的很多了，utf8mb4很常用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554652890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67948,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1550333239,"is_pvip":false,"replies":[{"id":"24093","content":"你说的对，这里其实是“向左扫描”，加锁范围应该是(3,4] 和 (4, supremum]。<br>👍<br>","user_name":"作者回复","comment_id":67948,"uid":"1264162","ip_address":"","utype":1,"ctime":1550369367,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"48794973495","product_id":100020801,"comment_content":"老师好，文中提到：insert into t2(c,d) (select c+1, d from t force index(c) order by c desc limit 1)的加锁范围是表 t 索引 c 上的 (4,supremum] 这个 next-key lock 和主键索引上 id=4 这一行。<br>可是如果我把表t的id为3这行先删除，再执行这个insert...select，那么别的会话执行insert into t values(3,3,3)会被阻塞，这说明4之前也是有间隙锁的？<br>另外，select c+1, d from t force index(c) order by c desc limit 1 for update 是不是不能用作等值查询那样分析？因为如果算等值查询，根据优化1是没有间隙锁的。","like_count":11,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439435,"discussion_content":"你说的对，这里其实是“向左扫描”，加锁范围应该是(3,4] 和 (4, supremum]。\n👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550369367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67383,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1550137503,"is_pvip":false,"replies":[{"id":"23998","content":"1. 你说得对，👍细致，发起勘误了哈<br>2. 图7 这里说的唯一键冲突，就是发现“已经有一个c=5的行存在”，所以转为加next-key lock，没有单独的加行锁的逻辑哈","user_name":"作者回复","comment_id":67383,"uid":"1264162","ip_address":"","utype":1,"ctime":1550298429,"user_name_real":"林晓斌"}],"discussion_count":3,"race_medal":0,"score":"40204843167","product_id":100020801,"comment_content":"老师好，<br>图6下方“发生主键冲突的时候”是不是应该改为“发生唯一键冲突的时候”？因为c不是主键。<br>还有，图7下方：T2时刻session b 发现“唯一键冲突”，这里为啥不是锁冲突？因为如果没有锁冲突，仅有唯一键冲突，就对应图6的情况，这时加的是next-key lock，而不仅仅是记录锁了。","like_count":9,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439171,"discussion_content":"1. 你说得对，👍细致，发起勘误了哈\n2. 图7 这里说的唯一键冲突，就是发现“已经有一个c=5的行存在”，所以转为加next-key lock，没有单独的加行锁的逻辑哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550298429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373654,"discussion_content":"说出了我想问的问题：\n首先为啥B和C可以看到A没有提交的c=5这行呢？\n其次为啥不会出现唯一索引冲突的报错呢。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620815147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3007210,"avatar":"","nickname":"Geek_a1699c","note":"","ucode":"CF7DB00BE36B77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577844,"discussion_content":"1、当前读，所以可以看到\n2、这个我自己试验了，猜测应该是要先拿到写锁，然后再判断是否重复。拿写锁的时候就阻塞了，还没到重复检验报错那一步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656387337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373654,"ip_address":""},"score":577844,"extra":""}]}]},{"had_liked":false,"id":68566,"user_name":"王伯轩","can_delete":false,"product_type":"c1","uid":1108650,"ip_address":"","ucode":"546814BA7E5839","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/aa/cdd13ad2.jpg","comment_is_top":false,"comment_ctime":1550545108,"is_pvip":false,"replies":[{"id":"24323","content":"这就是压力太大了。。 一般伴随着ioutil很大，语句执行特别慢，别的语句就被堵着等锁，等超时就自己crash","user_name":"作者回复","comment_id":68566,"uid":"1264162","ip_address":"","utype":1,"ctime":1550551506,"user_name_real":"林晓斌"}],"discussion_count":4,"race_medal":0,"score":"35910283476","product_id":100020801,"comment_content":"老师你好,去年双11碰到了dbcrash掉的情况.至今没有找到答案,心里渗得慌.老师帮忙分析下.  <br>我是一个开发,关于db的知识更多是在应用和基本原理上面,实在是找不到原因. 我也搜了一些资料 感觉像是mysql的bug,不过在其buglist中没有找到完全一致的，当然也可能是我们业务也许导致库的压力大的原因.   <br>应用端看到的现象是db没有响应，应用需要访问db的线程全部僵死.db表现是hang住 , 当时的诊断日志如下，表面表现为一直获取不到latch锁（被一个insert线程持有不释放） https:&#47;&#47;note.youdao.com&#47;ynoteshare1&#47;index.html?id=1771445db3ff1e08cbdd8328ea6765a7&amp;type=note#&#47;  隔离级别是rr<br><br>同样的crash双11当天后面又出现了一次（哭死）,<br>都是重启数据库解决的,<br><br>后面应用层面做了一样优化,没有再crash过，优化主要如下：<br>1.减小读压力，去除一些不必要的查询，<br>2.优化前，有并发事务写和查询同一条数据记录，即事务a执行insert 尚未提交，事务b就来查询（快照读），优化后保证查询时insert事务已经提交","like_count":8,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439733,"discussion_content":"这就是压力太大了。。 一般伴随着ioutil很大，语句执行特别慢，别的语句就被堵着等锁，等超时就自己crash","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550551506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2171678,"avatar":"https://static001.geekbang.org/account/avatar/00/21/23/1e/cc62c8a8.jpg","nickname":"大桃子又好吃","note":"","ucode":"C84EBAB4B1DF15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309850,"discussion_content":"隔离级别为什么要用RR ?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601461849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101234,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/b2/807137b9.jpg","nickname":"北方易初","note":"","ucode":"C57FDBD37F43E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2171678,"avatar":"https://static001.geekbang.org/account/avatar/00/21/23/1e/cc62c8a8.jpg","nickname":"大桃子又好吃","note":"","ucode":"C84EBAB4B1DF15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579082,"discussion_content":"默认不是 RR吗？你给一个不用默认的理由 ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657167589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309850,"ip_address":""},"score":579082,"extra":""}]},{"author":{"id":1253416,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/28/14540c7c.jpg","nickname":"亮仔","note":"","ucode":"7EB5943F729221","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139500,"discussion_content":"你的隔离几笔是都未提交吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579277001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67628,"user_name":"Justin","can_delete":false,"product_type":"c1","uid":1305601,"ip_address":"","ucode":"D49723FEA66731","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/01/978d54af.jpg","comment_is_top":false,"comment_ctime":1550212780,"is_pvip":false,"replies":[{"id":"23959","content":"是说插入碰到唯一键冲突的时候才会哈","user_name":"作者回复","comment_id":67628,"uid":"1264162","ip_address":"","utype":1,"ctime":1550217913,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"35909951148","product_id":100020801,"comment_content":"为什么insert 还会使用到next key lock 呢 ，我记得我原来看的资料写的是插入使用的是插入意向锁啊","like_count":8,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439288,"discussion_content":"是说插入碰到唯一键冲突的时候才会哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550217913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67724,"user_name":"phpzheng","can_delete":false,"product_type":"c1","uid":1187120,"ip_address":"","ucode":"4C7F89AD84F4D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/30/3e280597.jpg","comment_is_top":false,"comment_ctime":1550232277,"is_pvip":false,"replies":[{"id":"24012","content":"insert以后<br>select last_insert_id,<br>再update，<br>只能这么做啦<br><br>如果要快一些，可能可以考虑减少交互，比如写成存储过程","user_name":"作者回复","comment_id":67724,"uid":"1264162","ip_address":"","utype":1,"ctime":1550299497,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"31615003349","product_id":100020801,"comment_content":"循环插入数据，然后拿着刚刚插入的主键id，更新数据。请问怎么提高这个情况的效率","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439345,"discussion_content":"insert以后\nselect last_insert_id,\n再update，\n只能这么做啦\n\n如果要快一些，可能可以考虑减少交互，比如写成存储过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550299497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81822,"user_name":"常超","can_delete":false,"product_type":"c1","uid":1138665,"ip_address":"","ucode":"4AE7743B4ADF20","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/e9/95ef44f3.jpg","comment_is_top":false,"comment_ctime":1554043339,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27323847115","product_id":100020801,"comment_content":"对这个SQL 执行过程的解释，<br>insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);<br><br>&gt;由于实现上这个语句没有在子查询中就直接使用 limit 1，从而导致了这个语句的执行需要遍历整个表 t。<br>没太看懂“由于”那句话，既然在子查询中有了limit 1，为什么不能只把最后一条记录插入临时表呢？<br>老师能在说明一下吗？","like_count":6,"discussions":[{"author":{"id":1644950,"avatar":"https://static001.geekbang.org/account/avatar/00/19/19/96/3b49b437.jpg","nickname":"郭某某","note":"","ucode":"5E53B60527DCDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292324,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595175409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67583,"user_name":"夹心面包","can_delete":false,"product_type":"c1","uid":1301957,"ip_address":"","ucode":"002BBA49D83D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCscgdVibmoPyRLRaicvk6rjTJxePZ6VFHvGjUQvtfhCS6kO4OZ1AVibbhNGKlWZmpEFf2yA6ptsqHw/132","comment_is_top":false,"comment_ctime":1550201793,"is_pvip":false,"replies":[{"id":"24009","content":"👍","user_name":"作者回复","comment_id":67583,"uid":"1264162","ip_address":"","utype":1,"ctime":1550299272,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"27320005569","product_id":100020801,"comment_content":"我来补充应用表空间迁移的场景<br>1  冷数据表的复制和迁移<br>2 大表数据的恢复,线上DDL操作失误,需要恢复时,利用备份+binlog进行恢复后,表空间迁移进行导入<br>对于热表数据的复制建议还是采用pt-archiver慢慢搞","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439260,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550299272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69878,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1550895451,"is_pvip":false,"replies":[{"id":"24918","content":"不是都会，是在要写入的时候，发现有主键冲突，才会加上这个next-key lock的锁","user_name":"作者回复","comment_id":69878,"uid":"1264162","ip_address":"","utype":1,"ctime":1550936934,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"23025731931","product_id":100020801,"comment_content":"老师，年后过来狂补课程了哈哈 ， 看到老师的bug留言已经被fix掉准备在最新版本发布了呢。 <br><br>这里我有一个疑问， 我之前以为只有更新的时候才会加锁， 参考前面的文章，innodb要先扫描表中数据，被扫描到的行要加锁 。<br><br>或者我们执行 select 的时候手动加上 排他锁 或者 共享锁，也会锁住。<br><br>这里老师讲到如果索引唯一键冲突， innodb为了做处理加了 next_key lock（S） 这个可以理解。<br><br>insert .. select 也是因为有 select 索引会加锁 也可以理解<br><br>问题 ：<br><br>图7那个死锁的案例， session A 的时候 只是执行了 insert 语句，执行 insert的时候也没有select之类的，为什么也会在索引c上加个锁， 是什么时候加的呢 ？？？ 是 insert 语句有索引的话都会给索引加锁么？？<br><br>","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440326,"discussion_content":"不是都会，是在要写入的时候，发现有主键冲突，才会加上这个next-key lock的锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550936934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117852,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0e/9c/2413fd6f.jpg","nickname":"ETLshow","note":"","ucode":"B57C574B3343CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559958,"discussion_content":"我现在还是奇怪这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649080806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69369,"user_name":"滔滔","can_delete":false,"product_type":"c1","uid":1303342,"ip_address":"","ucode":"6968B5771AF79D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/2e/77ad18f4.jpg","comment_is_top":false,"comment_ctime":1550729253,"is_pvip":false,"replies":[{"id":"24990","content":"不是，发现冲突直接加的就是写锁","user_name":"作者回复","comment_id":69369,"uid":"1264162","ip_address":"","utype":1,"ctime":1550997675,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"23025565733","product_id":100020801,"comment_content":"老师，有个问题insert into … on duplicate key update语句在发生冲突的时候是先加next key读锁，然后在执行后面的update语句时再给冲突记录加上写锁，从而把之前加的next key读锁变成了写锁，是这样的吗？","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440084,"discussion_content":"不是，发现冲突直接加的就是写锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550997675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68201,"user_name":"王伯轩","can_delete":false,"product_type":"c1","uid":1108650,"ip_address":"","ucode":"546814BA7E5839","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/aa/cdd13ad2.jpg","comment_is_top":false,"comment_ctime":1550456715,"is_pvip":false,"replies":[{"id":"24142","content":"这个系列里没讲到了<br><br>这种我碰到比较多的是io压力特别大，导致有的事务执行不下去，但是占着锁<br><br>然后其他事务就拿不到锁，有一个600计时，超过就crash了","user_name":"作者回复","comment_id":68201,"uid":"1264162","ip_address":"","utype":1,"ctime":1550463303,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"23025293195","product_id":100020801,"comment_content":"内存锁 大大计划讲下么,实际中碰到内存锁被持有后一直不释放导致db直接crash掉","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439563,"discussion_content":"这个系列里没讲到了\n\n这种我碰到比较多的是io压力特别大，导致有的事务执行不下去，但是占着锁\n\n然后其他事务就拿不到锁，有一个600计时，超过就crash了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550463303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67028,"user_name":"颜海航","can_delete":false,"product_type":"c1","uid":1308159,"ip_address":"","ucode":"5644F6328BF901","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/ff/523fb378.jpg","comment_is_top":false,"comment_ctime":1550057977,"is_pvip":false,"replies":[{"id":"23991","content":"这个是因为备库应用日志太慢，累积过多<br><br>但是这个情况应该不至于会导致数据库重启诶~，<br>MySQL常见的自己重启是io压力过大，可能会自己重启<br><br>你这个备库应用过慢可能也只是“被影响的效果”<br><br>可否贴一下errorloog","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550297426,"ip_address":"","comment_id":67028,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18729927161","product_id":100020801,"comment_content":"[Note] Multi-threaded slave: Coordinator has waited 8551 times hitting slave_pending_jobs_<br>size_max; current event size = 8198. 老师 我们数据库一直报这个错，然后数据库就进行crash recovery，是是什么状况。。","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439021,"discussion_content":"这个是因为备库应用日志太慢，累积过多\n\n但是这个情况应该不至于会导致数据库重启诶~，\nMySQL常见的自己重启是io压力过大，可能会自己重启\n\n你这个备库应用过慢可能也只是“被影响的效果”\n\n可否贴一下errorloog","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550297426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66879,"user_name":"滔滔","can_delete":false,"product_type":"c1","uid":1303342,"ip_address":"","ucode":"6968B5771AF79D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/2e/77ad18f4.jpg","comment_is_top":false,"comment_ctime":1550034232,"is_pvip":false,"replies":[{"id":"23779","content":"一般select ...lock in share mode就是共享锁；<br>select ... for update 和 IUD语句，就是排他锁。","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550110558,"ip_address":"","comment_id":66879,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18729903416","product_id":100020801,"comment_content":"老师您好，想问一下next key lock是gap锁和行锁的组合，但究竟是gap锁和共享锁还是排它锁的组合是不是要看具体的sql语句？具体哪些sql语句中的next key lock是由共享锁组成，哪些是由排它锁组成呢？🤔","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438956,"discussion_content":"一般select ...lock in share mode就是共享锁；\nselect ... for update 和 IUD语句，就是排他锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550110558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212914,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1588237501,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14473139389","product_id":100020801,"comment_content":"原文:至于为什么要加这个读锁，其实我也没有找到合理的解释。<br>理解:斗胆解释一下，不知对不对。<br>当要插入一条记录的时候，因为在并发环境下，同一时点可能会有多个session同时插入，假设当前表里没有这条数据，两个session在同一时点同时check数据是否存在，返回结果都是不存在，又同时插入该数据，这种情况下必须通过加锁来互斥","like_count":3},{"had_liked":false,"id":121982,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1565263387,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14450165275","product_id":100020801,"comment_content":"老师，也许问题有点傻，不过我还是想问一下。<br>锁，在计算机世界中是非常重要的，只要有并发必然会有锁，这个锁不像这把🔒，看的见也常见很容易理解。<br>1：锁，在计算机世界究竟是个什么东西？一种数据结构？一句计算机命令？一种同步机制？在JAVA中有许多锁的类，能产生锁的对象，实现锁的功能，但是它怎么锁的？我很好奇，没完全弄明白。<br>2：锁，是怎么实现的？是打个标记嘛？新来的线程一看有标记就等着，自己也打一个。JAVA中看到过用一个变量当锁，进入锁变量加一解锁变量减一，这样根据变量值就知道是否加锁了，MySQL也是如此吗？<br>3：锁，说加在索引上，这个加在索引上怎么加的呢？索引是一棵树，也是以一个对象的形式存在的吗？<br>总是听到这个锁那个锁的，我觉得没有理解锁的本质是啥，或者锁这个概念是操作系统世界的词，在操作系统层面更容易理解一些，在各种应用软件中就是一段代码，只是功能和现实中锁门的锁的功能相似而已。<br>4：有等待就有唤醒，唤醒就是唤醒线程嘛？这个唤醒就怎么唤醒呢？是从等待的队列中获取一个线程嘛？那他又怎么知道之前执行到哪？该怎么执行啦？","like_count":3,"discussions":[{"author":{"id":1997293,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/79/ed/4737a49b.jpg","nickname":"雪の雫·雨の音","note":"","ucode":"0693DA3939A321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273319,"discussion_content":"数据库的锁怎么实现的。。我就不清楚了，不过锁的实现无非三种方法，一种是软件层面的实现，一种是依赖于操作系统底层，还有一种就是利用硬件同步原语。估计MySQL肯定也是用这三种方法其中的一种或者几种实现的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590429305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1997293,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/79/ed/4737a49b.jpg","nickname":"雪の雫·雨の音","note":"","ucode":"0693DA3939A321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273318,"discussion_content":"在java中有的锁是通过硬件同步原语实现的，比如CAS，还有的是依赖于操作系统底层实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590429226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67686,"user_name":"Justin","can_delete":false,"product_type":"c1","uid":1305601,"ip_address":"","ucode":"D49723FEA66731","user_header":"https://static001.geekbang.org/account/avatar/00/13/ec/01/978d54af.jpg","comment_is_top":false,"comment_ctime":1550222808,"is_pvip":false,"replies":[{"id":"24010","content":"如果发生冲突，就不是插入在间隙里面，这里就还没到“插入意向锁”的逻辑哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550299324,"ip_address":"","comment_id":67686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14435124696","product_id":100020801,"comment_content":"那如果是冲突时 会加next key lock的话 间隙锁和插入意向锁不会冲突吗？","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439326,"discussion_content":"如果发生冲突，就不是插入在间隙里面，这里就还没到“插入意向锁”的逻辑哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550299324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66899,"user_name":"滔滔","can_delete":false,"product_type":"c1","uid":1303342,"ip_address":"","ucode":"6968B5771AF79D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/2e/77ad18f4.jpg","comment_is_top":false,"comment_ctime":1550039300,"is_pvip":false,"replies":[{"id":"23780","content":"好问题<br><br>这种情况下一般是造成锁等待，不会造成死锁吧 😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550110686,"ip_address":"","comment_id":66899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14434941188","product_id":100020801,"comment_content":"老师，之前提到的一个有趣的问题&quot;A、B两个用户，如果互相喜欢，则成为好友。设计上是有两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行顺序是这样的：<br>以A喜欢B为例：<br>1、先查询对方有没有喜欢自己（B有没有喜欢A）<br>select * from like where user_id = B and liker_id = A<br>2、如果有，则成为好友<br>insert into friend<br>3、没有，则只是喜欢关系<br>insert into like&quot;，这个问题中如果把select语句改成&quot;当前读&quot;，则当出现A,B两个人同时喜欢对方的情况下，是不是会出现由于&quot;当前读&quot;加的gap锁导致后面insert语句阻塞，从而发生死锁？","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438966,"discussion_content":"好问题\n\n这种情况下一般是造成锁等待，不会造成死锁吧 😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550110686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207493,"user_name":"红颜铭心","can_delete":false,"product_type":"c1","uid":1889026,"ip_address":"","ucode":"18F94E5444C71A","user_header":"","comment_is_top":false,"comment_ctime":1587093484,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10177028076","product_id":100020801,"comment_content":"1.SessionA写入记录 触发Unique Key的冲突检查，触发当前读，获取行记录next-key X lock，等值查询+唯一索引 优化降级C=5记录锁。<br>2.SessionB写入记录 触发Unique Key的冲突检查，冲突后获取(4,5]next-key S lock，被C=5的X Lock阻塞，(4,5)gap lock加锁成功，等待C=5读锁。<br>3.SessionC写入记录 触发Unique Key的冲突检查，冲突后获取(4,5]next-key S lock，被C=5的X Lock阻塞，(4,5)gap lock加锁成功，等待C=5读锁。<br>4.SessionA回滚后释放C=5记录锁，SessionB和C同时争抢到C=5读锁。<br>5.SessionB和C在执行插入操作，插入意向锁和读锁互斥，循环冲突死锁。<br>6.Unique Key检查逻辑:若插入记录的目标页在内存中，树搜索找到插入位置判断是否存在冲突;若不在内存页，需要将插入位置的目标页加载到内存再判断。","like_count":2,"discussions":[{"author":{"id":2057540,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqTFWQ9M0qy9XW5Ts8yr1wBFYvGMrXwmeufkuo0E8dF3uXFsmhQMBmWiaovurza3mtuib33qlUPNkgw/132","nickname":"Geek_eb32d1","note":"","ucode":"3306F694BA00BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330371,"discussion_content":"先赞后问\nunique key检查逻辑应该是需要加锁的吧，不然可能会出现两个事务都检查通过，同时插入的情况，请问这里mysql是通过什么方式避免的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606581396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76558,"user_name":"伟仔_Hoo","can_delete":false,"product_type":"c1","uid":1323341,"ip_address":"","ucode":"74945AEE48DD62","user_header":"https://static001.geekbang.org/account/avatar/00/14/31/4d/ea8ac77c.jpg","comment_is_top":false,"comment_ctime":1552632445,"is_pvip":false,"replies":[{"id":"27969","content":"session A的select语句没有加 for update 或者 lock in share mode ?","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1552694136,"ip_address":"","comment_id":76558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142567037","product_id":100020801,"comment_content":"老师，看到您的回复，当select c+1, d from t force index(c) order by c desc limit 1;这条语句单独执行是会在c索引上加(4,sup] 这个next key lock, 于是我进行了尝试<br>sessionA: <br>begin;<br>select c+1, d from t3 force index(c) order by c desc limit 1;<br>sessionB:<br>insert into t3 values(5, 5, 5);<br>结果是，sessionB插入成功，是不是我哪里理解错了？我的版本是5.7.23","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443354,"discussion_content":"session A的select语句没有加 for update 或者 lock in share mode ?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552694136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74262,"user_name":"Lilian","can_delete":false,"product_type":"c1","uid":1324238,"ip_address":"","ucode":"92F87DA351543A","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/ce/289dadb6.jpg","comment_is_top":false,"comment_ctime":1552147543,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10142082135","product_id":100020801,"comment_content":"老师，能帮忙看下这个死锁记录吗？对于duplicate key插入有什么阻止的好方法？LATEST DETECTED DEADLOCK<br>------------------------<br>190222  8:37:45<br>*** (1) TRANSACTION:<br>TRANSACTION 16FEC1AE, ACTIVE 0 sec inserting<br>mysql tables in use 1, locked 1<br>LOCK WAIT 6 lock struct(s), heap size 1248, 3 row lock(s)<br>MySQL thread id 169973, OS thread handle 0x2ba0fa040700, query id 41915315 10.45.133.181 W59FFHKU<br>INSERT INTO resource (<br>                        Id<br>                      , Name<br>                      , Date<br>                      , User<br>                    ) VALUES (99127, &#39;RS_2098185e367d11e9878202a98a7af318&#39;, &#39;&#39;, &#39;JR&#39;)<br>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 78 page no 71 n bits 160 index `PRIMARY` of table `resource` trx id 16FEC1AE lock_mode X insert intention waiting<br>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0<br> 0: len 8; hex 73757072656d756d; asc supremum;;<br>*** (2) TRANSACTION:<br>TRANSACTION 16FEC1AF, ACTIVE 0 sec inserting<br>mysql tables in use 1, locked 1<br>6 lock struct(s), heap size 1248, 3 row lock(s)<br>MySQL thread id 169996, OS thread handle 0x2ba0ffec2700, query id 41915317 10.45.133.181 W59FFHKU<br>INSERT INTO resource (<br>                        Id<br>                      , Name<br>                      , Date<br>                      , User<br>                    ) VALUES (99125, &#39;RS_2098b778367d11e9878202a98a7af318&#39;, &#39;&#39;, &#39;JR&#39;)<br>*** (2) HOLDS THE LOCK(S):<br>RECORD LOCKS space id 78 page no 71 n bits 160 index `PRIMARY` of table `resource` trx id 16FEC1AF lock mode S<br>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0<br> 0: len 8; hex 73757072656d756d; asc supremum;;<br>*** (2) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 78 page no 71 n bits 160 index `PRIMARY` of table `resource` trx id 16FEC1AF lock_mode X insert intention waiting<br>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0<br> 0: len 8; hex 73757072656d756d; asc supremum;;<br>*** WE ROLL BACK TRANSACTION (2)","like_count":2,"discussions":[{"author":{"id":1105854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/df/be/c6f8953f.jpg","nickname":"万事屋","note":"","ucode":"57C08B85373B0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575876,"discussion_content":"session改成RC应该可以吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655168684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2457512,"avatar":"","nickname":"Geek_d1a3d2","note":"","ucode":"08C95F1859767D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383276,"discussion_content":"我也碰到了，还没解决😭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626018530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74190,"user_name":"Lilian","can_delete":false,"product_type":"c1","uid":1324238,"ip_address":"","ucode":"92F87DA351543A","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/ce/289dadb6.jpg","comment_is_top":false,"comment_ctime":1552139503,"is_pvip":false,"replies":[{"id":"27144","content":"这个取决于业务需求，如果是明确会存在这样的情况，并且可以忽略，是可以这么用的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1552146625,"ip_address":"","comment_id":74190,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10142074095","product_id":100020801,"comment_content":"老师，重复主键插入冲突是否推荐insert ignore方法？","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442489,"discussion_content":"这个取决于业务需求，如果是明确会存在这样的情况，并且可以忽略，是可以这么用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552146625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400101,"discussion_content":"但是这样是不是把逻辑下层到SQL层了，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633165652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71437,"user_name":"张永志","can_delete":false,"product_type":"c1","uid":1208727,"ip_address":"","ucode":"E54B75EF3F63B3","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/97/f1a3d398.jpg","comment_is_top":false,"comment_ctime":1551342673,"is_pvip":false,"replies":[{"id":"25547","content":"是为了实现这个目的，是吧😀","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551349212,"ip_address":"","comment_id":71437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141277265","product_id":100020801,"comment_content":"对主键插入加读锁的个人理解，两个会话insert同样记录，在没有提交情况下，insert主键加读锁是为了避免第一个会话回滚后，第二个会话可以正常执行；第一个会话提交后，第二个会话再报错。","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441148,"discussion_content":"是为了实现这个目的，是吧😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551349212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290472,"user_name":"轻松的鱼","can_delete":false,"product_type":"c1","uid":1219198,"ip_address":"","ucode":"F4FF653209C47B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEl3fX9nvzUF26ekUIicp4sgA5jZ1mGvGMhIHkwJabbjt9h5uTLw5zzU1U6JZbCSpRXBNQwuejLJg/132","comment_is_top":false,"comment_ctime":1619579032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914546328","product_id":100020801,"comment_content":"insert into t2 select * from t，已知：RR 隔离级别时，会对 t 表所有记录加 S next key lock，是一个当前读。<br><br>但是加锁并不是一次性对所有记录加锁的，而是扫一行加一行（包括间隙），如果 t 表很大，当加锁只加到 id=100000 时，此时其他事务是可以对 id&lt;100000 的数据进行修改、插入、删除的。由于原事务对 t 表是个当前读，就能够读到其他事务修改的数据。这是不是属于逻辑错误？当然这里能保证binlog 的一致。<br><br>相反RC隔离级别，对 t 表记录是不加锁的，而且做的是快照读，确实没有逻辑问题，也不会有与 binlog 不一致的问题（因为RC隔离级别，statement格式压根不允许做修改数据的操作）。<br><br>所以最终问题是：<br>1. RR隔离级别，statement格式，insert into t2 select * from t，有没有逻辑问题？<br>2. RR隔离级别，row格式，为什么也要对 t 表记录加锁？为什么不能和RC隔离级别一样做快照读？<br>","like_count":1},{"had_liked":false,"id":225248,"user_name":"Bing","can_delete":false,"product_type":"c1","uid":1355177,"ip_address":"","ucode":"01C276F21AD2D6","user_header":"https://static001.geekbang.org/account/avatar/00/14/ad/a9/031a0cc1.jpg","comment_is_top":false,"comment_ctime":1591694318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886661614","product_id":100020801,"comment_content":"mvcc+next-key是否可以解决幻读呢？","like_count":1},{"had_liked":false,"id":206786,"user_name":"清风","can_delete":false,"product_type":"c1","uid":1129749,"ip_address":"","ucode":"59932E13FAF607","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/15/7f5fd6d3.jpg","comment_is_top":false,"comment_ctime":1586934714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881902010","product_id":100020801,"comment_content":"老师 我18年看的你文章，2020年了又来看一下。replace into 这个sql  也会出现唯一索引并发插入的到最后死锁的问题，这个问题应该和insert into 唯一索引冲突导致的问题应该是一致的","like_count":1},{"had_liked":false,"id":66974,"user_name":"skyoo","can_delete":false,"product_type":"c1","uid":1302503,"ip_address":"","ucode":"EBC0528BA02DD7","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/e7/4ce5ed27.jpg","comment_is_top":false,"comment_ctime":1550050123,"is_pvip":false,"replies":[{"id":"23781","content":"很好的验证👍<br>你再试试一个insert插入多行的例子，就完整了😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550111526,"ip_address":"","comment_id":66974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845017419","product_id":100020801,"comment_content":"mysql&gt; insert into t select null,5,5; 已经又4条记录<br>mysql&gt; select * from t;<br>| 1 | 1 | 1 |<br>| 2 | 2 | 100 |<br>| 3 | 3 | 3 |<br>| 4 | 4 | 4 |<br>| 5 | 5 | 5 |<br>+----+------+------+<br>5 rows in set (0.00 sec)<br><br>mysql&gt; select last_insert_id();<br>+------------------+<br>| last_insert_id() |<br>+------------------+<br>| 5 |<br>+------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select * from t2; 已经有三条记录<br>+----+------+------+<br>| id | c | d |<br>+----+------+------+<br>| 5 | 1 | NULL |<br>| 6 | 6 | 6 |<br>| 7 | 7 | 7 |<br>+----+------+------+<br>3 rows in set (0.01 sec)<br>mysql&gt; select last_insert_id(); 此处的自增ID 是否理解为 最近一次的 insert 操作的 获取的ID<br>+------------------+<br>| last_insert_id() |<br>+------------------+<br>| 5 |<br>+------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; insert into t2 select null,8,8;<br>Query OK, 1 row affected (0.01 sec)<br>Records: 1 Duplicates: 0 Warnings: 0<br><br>mysql&gt; select last_insert_id();<br>+------------------+<br>| last_insert_id() |<br>+------------------+<br>| 8 |<br>+------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select * from t2;<br>+----+------+------+<br>| id | c | d |<br>+----+------+------+<br>| 5 | 1 | NULL |<br>| 6 | 6 | 6 |<br>| 7 | 7 | 7 |<br>| 8 | 8 | 8 |<br>+----+------+------+<br>4 rows in set (0.00 sec)<br>mysql&gt; select last_insert_id(); 此处的自增ID 是否理解为 最近一次的 insert 操作的 获取的ID<br>+------------------+<br>| last_insert_id() |<br>+------------------+<br>| 8 |<br>+------------------+<br>1 row in set (0.00 sec)<br>上面的 ID 与那个表没有关系, 至于当前session insert 最新一次记录为准 <br>mysql&gt; select last_insert_id();<br>|                8 |<br>+------------------+<br>1 row in set (0.00 sec)<br>mysql&gt; insert into t2 select 19,19,19;<br>mysql&gt; select last_insert_id();<br>+------------------+<br>| last_insert_id() |<br>+------------------+<br>|                8 |<br>+------------------+<br>1 row in set (0.00 sec)<br>mysql&gt; insert into t2 select null,20,20;<br>Query OK, 1 row affected (0.01 sec)<br>Records: 1  Duplicates: 0  Warnings: 0<br><br>mysql&gt; select last_insert_id();<br>+------------------+<br>| last_insert_id() |<br>+------------------+<br>|               20 |<br>+------------------+<br>ID 除非为空的时候 才能获取到新的last_insert_id","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438997,"discussion_content":"很好的验证👍\n你再试试一个insert插入多行的例子，就完整了😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550111526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66972,"user_name":"郭烊千玺","can_delete":false,"product_type":"c1","uid":1302416,"ip_address":"","ucode":"15736D91964DA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/90/68408c1b.jpg","comment_is_top":false,"comment_ctime":1550050019,"is_pvip":false,"replies":[{"id":"25098","content":"确实不准 😅<br>一般很少有参考这三个值的逻辑","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551081201,"ip_address":"","comment_id":66972,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845017315","product_id":100020801,"comment_content":"有个问题想请教下大神  information_schema.tables  表里的这三个字段data_length  data_free  index_length的值准确吗，mysql内部是怎么计算每个表的这个三个值的？在没有碎片的情况下，实践上用du 命令统计的ibd的大小和这几个字段的值感觉差别很大，所以很想知道这几个字段的值得准确度如何，还是仅供参考，因为实践中可能需要知道是否有碎片，如果date_free值不准确，而盲目的alter table一下，表大的话代价很高啊 求回答啊 感觉这也是很多dba关心的一个问题","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438996,"discussion_content":"确实不准 😅\n一般很少有参考这三个值的逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551081201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360241,"user_name":"Mango君😊","can_delete":false,"product_type":"c1","uid":1114643,"ip_address":"广东","ucode":"FD47F4A4F2329A","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/13/78a2cbf4.jpg","comment_is_top":false,"comment_ctime":1666333884,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666333884","product_id":100020801,"comment_content":"老师，insert 唯一键冲突的例子中，第一个事务把 rollback 改成 commit 后，为什么不会死锁呢","like_count":0},{"had_liked":false,"id":359714,"user_name":"Geek_f265e1","can_delete":false,"product_type":"c1","uid":2319817,"ip_address":"四川","ucode":"3CD7E3A8347702","user_header":"","comment_is_top":false,"comment_ctime":1665801169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665801169","product_id":100020801,"comment_content":"提个问题，在dml中如果查找数据使用的二级索引，那么不管这个二级索引的数据是否会更新，都会加一个x锁。这里是出于什么考量要给他加一个x锁而不是s锁呢？","like_count":0},{"had_liked":false,"id":358423,"user_name":".","can_delete":false,"product_type":"c1","uid":3189388,"ip_address":"湖北","ucode":"66FAAB07BD7B17","user_header":"https://static001.geekbang.org/account/avatar/00/30/aa/8c/eaa0f576.jpg","comment_is_top":false,"comment_ctime":1664286589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664286589","product_id":100020801,"comment_content":"C是唯一索引，为什么sessionA持有的不是行锁10而是(5,10]?不应该退化吗？","like_count":0},{"had_liked":false,"id":356543,"user_name":"Geek_323a60","can_delete":false,"product_type":"c1","uid":2797976,"ip_address":"四川","ucode":"CDC276EC255411","user_header":"","comment_is_top":false,"comment_ctime":1662389217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662389217","product_id":100020801,"comment_content":"<br>insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1); 的分析中从 t 中读取全部的数据（一共 4 行）建立临时表。在执行 limit 1 时又读取了一行，为什么 innodb_rows_read 的值只增加了 4 而不是 5 呢？","like_count":0},{"had_liked":false,"id":354329,"user_name":"fourge","can_delete":false,"product_type":"c1","uid":1015184,"ip_address":"广东","ucode":"F3E3FFC4990358","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/90/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1660285427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660285427","product_id":100020801,"comment_content":"原来还有这么多的门道！","like_count":0},{"had_liked":false,"id":352845,"user_name":"董沛霖","can_delete":false,"product_type":"c1","uid":1460229,"ip_address":"陕西","ucode":"D223C52555C57F","user_header":"https://static001.geekbang.org/account/avatar/00/16/48/05/2ef4b9fb.jpg","comment_is_top":false,"comment_ctime":1658979002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658979002","product_id":100020801,"comment_content":"哦不对，我自己理解错了哈哈，打扰了","like_count":0},{"had_liked":false,"id":352839,"user_name":"董沛霖","can_delete":false,"product_type":"c1","uid":1460229,"ip_address":"","ucode":"D223C52555C57F","user_header":"https://static001.geekbang.org/account/avatar/00/16/48/05/2ef4b9fb.jpg","comment_is_top":false,"comment_ctime":1658977820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658977820","product_id":100020801,"comment_content":"老师您好，我觉得 &quot;insert 唯一键冲突 的图6中的例子&quot; 好像不太对，session B 的锁等待似乎不是由 session A 加在 index c 上的 next-key 锁导致的，而是由 session A 加在 primary key 上的 X 锁（supremum pseudo-record）导致的。<br>虽然我测试也得出了 &quot;两类索引冲突加的都是 next-key lock&quot; 这一结论，但在 session A 执行 &quot;insert into t values(10,10,10);&quot; 后再执行一个 &quot;insert into t values(13,13,13);&quot; 可能更严谨一些。","like_count":0},{"had_liked":false,"id":348643,"user_name":"李泰汛","can_delete":false,"product_type":"c1","uid":1880234,"ip_address":"","ucode":"379E06A90A30D9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZxgDrR65vd6wo2ibFQM3r0IdqlY0sG0ZOJAnMuhjVfJmib4ib3dbNlnz0MH4YmjV9ajQ6IXXiaVYRlg/132","comment_is_top":false,"comment_ctime":1655276095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655276095","product_id":100020801,"comment_content":"打扰一下，老师，Insert select 那个例子，加的应该不是 Next-key lock 吧，而是单纯的 gap lock (-∞, 1) 。因为表中都还没有记录，何来 Next-key lock 。","like_count":0},{"had_liked":false,"id":345331,"user_name":"幼稚园的小朋友","can_delete":false,"product_type":"c1","uid":2725596,"ip_address":"","ucode":"EF63C355BD58A7","user_header":"https://static001.geekbang.org/account/avatar/00/29/96/dc/8adf8971.jpg","comment_is_top":false,"comment_ctime":1652194127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652194127","product_id":100020801,"comment_content":"*** (1) TRANSACTION:<br><br>事务编号 835455303 活跃1s <br>TRANSACTION 835455303, ACTIVE 1 sec inserting<br>mysql tables in use 1, locked 1<br>LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1<br>MySQL thread id 4757995, OS thread handle 140065991382784, query id 6012480542 10.5.144.251 sp_center_user update<br>INSERT INTO t_bill_product_sp_0353 (bill_code, product_code, product_version, forecast_disp_site_code, sign_site_code , flow, template_code, service_point_code, status, version) VALUE<br>S (&#39;782624393196770&#39;, &#39;PRO_PDD_CALL&#39;, &#39;8&#39;, &#39;41210&#39;, &#39;30074&#39; , &#39;SIGN&#39;, &#39;PO-h201txin&#39;, &#39;SER_SIGN_CALL&#39;, 0, 1)<br>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 382 page no 6507 n bits 208 index uk_bill_flow_code of table `sp_center_00`.`t_bill_product_sp_0353` trx id 835455303 lock mode S waiting<br>Record lock, heap no 141 PHYSICAL RECORD: n_fields 5; compact format; info bits 0<br> 0: len 14; hex 3738323637353933313936373730; asc 78267593196770;;<br> 1: len 4; hex 5349474e; asc SIGN;;<br> 2: len 11; hex 504f2d683230317478696e; asc PO-h201txin;;<br> 3: len 13; hex 5345525f5349474e5f43414c4c; asc SER_SIGN_CALL;;<br> 4: len 8; hex 000000000003e531; asc        1;;","like_count":0},{"had_liked":false,"id":345330,"user_name":"幼稚园的小朋友","can_delete":false,"product_type":"c1","uid":2725596,"ip_address":"","ucode":"EF63C355BD58A7","user_header":"https://static001.geekbang.org/account/avatar/00/29/96/dc/8adf8971.jpg","comment_is_top":false,"comment_ctime":1652194114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652194114","product_id":100020801,"comment_content":"<br>老师 想请问下 这个死锁该怎么分析呢 环境是rc 为什么事务2会持有一把不是自己要插入的记录的记录锁呢*** (2) TRANSACTION:<br>TRANSACTION 835455263, ACTIVE 2 sec inserting<br>mysql tables in use 1, locked 1<br>3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 3<br>MySQL thread id 4764977, OS thread handle 140065988409088, query id 6012481814 10.5.144.218 sp_center_user update<br>INSERT INTO t_bill_product_sp_0353 (bill_code, product_code, product_version, forecast_disp_site_code, sign_site_code , flow, template_code, service_point_code, status, version) VALUE<br>S (&#39;782624393196770&#39;, &#39;PRO_PDD_CALL&#39;, &#39;8&#39;, &#39;41210&#39;, &#39;30074&#39; , &#39;DISPATCH&#39;, &#39;PO-skldaFsd32&#39;, &#39;SER_SIGN_CALL_PDD&#39;, 0, 1)<br><br><br>&#47;&#47; locks rec but not gap 记录锁  lock_mode X next-key锁  locks gap before rec 间隙锁 locks gap before rec insert intention 插入意向锁<br>&#47;&#47; 间隙锁<br>*** (2) HOLDS THE LOCK(S):<br>RECORD LOCKS space id 382 page no 6507 n bits 208 index uk_bill_flow_code of table `sp_center_00`.`t_bill_product_sp_0353` trx id 835455263 lock_mode X locks rec but not gap<br>Record lock, heap no 141 PHYSICAL RECORD: n_fields 5; compact format; info bits 0<br> 0: len 14; hex 3738323637353933313936373730; asc 78267593196770;;<br> 1: len 4; hex 5349474e; asc SIGN;;<br> 2: len 11; hex 504f2d683230317478696e; asc PO-h201txin;;<br> 3: len 13; hex 5345525f5349474e5f43414c4c; asc SER_SIGN_CALL;;<br> 4: len 8; hex 000000000003e531; asc        1;;<br><br>*** (2) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 382 page no 6507 n bits 208 index uk_bill_flow_code of table `sp_center_00`.`t_bill_product_sp_0353` trx id 835455263 lock_mode X locks gap before rec insert intention waiting<br>Record lock, heap no 141 PHYSICAL RECORD: n_fields 5; compact format; info bits 0<br> 0: len 14; hex 3738323637353933313936373730; asc 78267593196770;;<br> 1: len 4; hex 5349474e; asc SIGN;;<br> 2: len 11; hex 504f2d683230317478696e; asc PO-h201txin;;<br> 3: len 13; hex 5345525f5349474e5f43414c4c; asc SER_SIGN_CALL;;<br><br>太长了 老师 我分为两个","like_count":0},{"had_liked":false,"id":342105,"user_name":"Niverkk","can_delete":false,"product_type":"c1","uid":2179875,"ip_address":"","ucode":"F9220C10107E44","user_header":"https://static001.geekbang.org/account/avatar/00/21/43/23/d98fb8f7.jpg","comment_is_top":false,"comment_ctime":1650015182,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650015182","product_id":100020801,"comment_content":"老师，针对图1情况 其实相当于锁表了吧？","like_count":0},{"had_liked":false,"id":337970,"user_name":"Curiosity","can_delete":false,"product_type":"c1","uid":1879290,"ip_address":"","ucode":"A6732CAE6CBE8E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ac/fa/a32099e7.jpg","comment_is_top":false,"comment_ctime":1647188999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647188999","product_id":100020801,"comment_content":"死锁的例子，有些不明白，到底是先加的读锁，还是先加的意向锁，insert语句在插入之前需要先读判断，那么这个先读判断加的是什么锁呢，案例是在这个先读判断的位置锁住的么，评论中有提到意向锁，这个意向锁又是什么，完全不懂呀","like_count":0},{"had_liked":false,"id":336175,"user_name":"Geek_fb333","can_delete":false,"product_type":"c1","uid":2011553,"ip_address":"","ucode":"F0904774D027A3","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b1/a1/b1fd3903.jpg","comment_is_top":false,"comment_ctime":1645970440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645970440","product_id":100020801,"comment_content":"<br>create temporary table temp_t(c int,d int) engine=memory;<br>insert into temp_t  (select c+1, d from t force index(c) order by c desc limit 1);<br>insert into t select * from temp_t;<br>drop table temp_t;<br><br>用RR隔离级别 加for update 或者Serializable 隔离级别 就不会创建临时表了，","like_count":0},{"had_liked":false,"id":323289,"user_name":"Kaine","can_delete":false,"product_type":"c1","uid":2799936,"ip_address":"","ucode":"970FBF356F3F59","user_header":"https://static001.geekbang.org/account/avatar/00/2a/b9/40/e350862c.jpg","comment_is_top":false,"comment_ctime":1637821223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637821223","product_id":100020801,"comment_content":"老师您好，在图6的例子中，mysql版本8.0.21，sessionB执行的语句不会被阻塞。<br>我查看了资料是8.0.21解决了唯一索引间隙锁的bug。<br>这里是mysql将next-key lock 间隙锁退化成了行锁了吗？","like_count":0},{"had_liked":false,"id":322538,"user_name":"K","can_delete":false,"product_type":"c1","uid":1151163,"ip_address":"","ucode":"0ED6CDDE3A8F5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/90/bb/61dfc022.jpg","comment_is_top":false,"comment_ctime":1637474023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637474023","product_id":100020801,"comment_content":"老师，请教下innodb的change buffer 和Log buffer 区别，当有一条insert 语句，insert的数据是先放在change buffer，然后再放入Log buffer 吗","like_count":0},{"had_liked":false,"id":302883,"user_name":"muse","can_delete":false,"product_type":"c1","uid":2365071,"ip_address":"","ucode":"43B0C82639E39F","user_header":"https://static001.geekbang.org/account/avatar/00/24/16/8f/c1baee96.jpg","comment_is_top":false,"comment_ctime":1626421908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626421908","product_id":100020801,"comment_content":"插入意向锁不是gap锁的话是什么呢","like_count":0},{"had_liked":false,"id":283368,"user_name":"kiplove","can_delete":false,"product_type":"c1","uid":1143832,"ip_address":"","ucode":"50F038D52F015D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep0RT83ws2ELSs4vmzPv2fr2d5WE0T7CuGfp7HtcHXuiaQUwXNLLsRzkYCPYicI2CyuQPSdbfxaYExA/132","comment_is_top":false,"comment_ctime":1615730527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615730527","product_id":100020801,"comment_content":"老师，我试了一下INSERT INTO t(c,d) (SELECT c+1, d FROM t FORCE INDEX(c) ORDER BY c DESC LIMIT 1); 其他事务还是能在这个表上插入数据，而且执行前后SHOW STATUS LIKE &#39;%Innodb_rows_read%&#39;，变化只有一行。这个版本8.0.13","like_count":0},{"had_liked":false,"id":276832,"user_name":"Geek1560","can_delete":false,"product_type":"c1","uid":2028949,"ip_address":"","ucode":"5F27A28B8002E6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/95/a362f01b.jpg","comment_is_top":false,"comment_ctime":1612148639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612148639","product_id":100020801,"comment_content":"老师我想咨询下，对于联合唯一索引，在insert的时候都会加什么锁。","like_count":0},{"had_liked":false,"id":273409,"user_name":"尘","can_delete":false,"product_type":"c1","uid":1244251,"ip_address":"","ucode":"2C71FBCED5BFE6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/5b/caa6a2a6.jpg","comment_is_top":false,"comment_ctime":1610589906,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1610589906","product_id":100020801,"comment_content":"执行insert into t2(c,d) select c,d from t时，为什么对表t主键加锁的范围是(-∞,1]，而不是(-∞,当前主键的最大值]？","like_count":0},{"had_liked":false,"id":268489,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1135701,"ip_address":"","ucode":"734A561F363720","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","comment_is_top":false,"comment_ctime":1608215627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608215627","product_id":100020801,"comment_content":"老师，我想问一下，假如我们一次性要向数据库中插入几千条数据，有没有什么优化的方法？提高速度","like_count":0},{"had_liked":false,"id":259051,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1604623915,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604623915","product_id":100020801,"comment_content":"老师你好，为什么插入t和t2扫描次数不同呢？还是犯糊涂？","like_count":0},{"had_liked":false,"id":256842,"user_name":"Young","can_delete":false,"product_type":"c1","uid":1736553,"ip_address":"","ucode":"90422D17DF9C15","user_header":"https://static001.geekbang.org/account/avatar/00/1a/7f/69/f618b7a5.jpg","comment_is_top":false,"comment_ctime":1603764025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603764025","product_id":100020801,"comment_content":"老师，比如rpc接口我需要落10000条订单数据，订单数拆分多少进行批量插入合适呢?","like_count":0},{"had_liked":false,"id":256765,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1603724675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603724675","product_id":100020801,"comment_content":"老师好，在 insert 唯一键冲突 小节中，第一个示例，在我的本地环境上无法复现。也就是说，sessionB 可以直接执行成功，不会被堵塞。我的 MySQL 版本时 5.7.31 ，事务隔离级别为 RR。请问这个 bug 是被修复了吗？","like_count":0},{"had_liked":false,"id":254627,"user_name":"张卓","can_delete":false,"product_type":"c1","uid":1209049,"ip_address":"","ucode":"AD840AF264C32E","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/d9/488739d1.jpg","comment_is_top":false,"comment_ctime":1603159832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603159832","product_id":100020801,"comment_content":"insert 唯一键冲突造成的死锁在MySQL8.0.21中已经复现不出来了","like_count":0},{"had_liked":false,"id":243395,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1598086100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598086100","product_id":100020801,"comment_content":"表拷贝我这边常用的方法还是insert....select，如果表的数据特别大使用程序来控制每次插入的条数，使用多线程的方式将大表数据分成几块分片插入","like_count":0},{"had_liked":false,"id":208091,"user_name":"Tarn","can_delete":false,"product_type":"c1","uid":1112416,"ip_address":"","ucode":"A2717CB81DF84B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/60/8e0f0f17.jpg","comment_is_top":false,"comment_ctime":1587274500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587274500","product_id":100020801,"comment_content":"<br>insert into t2(c,d) select c,d from t; 老师，为啥这个子语句的select c d from t会加next key lock？不是说之后for update和lock in share mode 才会加锁吗？还是因为子语句中默认就加锁呀？","like_count":0},{"had_liked":false,"id":186856,"user_name":"天亮前说晚安","can_delete":false,"product_type":"c1","uid":1541014,"ip_address":"","ucode":"1D82EE562A7C71","user_header":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","comment_is_top":false,"comment_ctime":1583939410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583939410","product_id":100020801,"comment_content":"我就遇到死锁问题，场景是一个表有主键id、唯一索引字段、其他字段c。我想导入数据，所以开了一个线程池去做导入数据的活，线程池大小16，每导入一条数据，我就要判断表里是否有含有唯一字段的记录，如果有就其他字段c加1，否则就插入一条数据。数据库隔离级别读已提交，版本5.7.28。没搞明白怎么回事，求解答。","like_count":0},{"had_liked":false,"id":148218,"user_name":"Icy:S LYZ","can_delete":false,"product_type":"c1","uid":1683788,"ip_address":"","ucode":"73C983E11A43C2","user_header":"https://static001.geekbang.org/account/avatar/00/19/b1/4c/9f06f199.jpg","comment_is_top":false,"comment_ctime":1572959952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572959952","product_id":100020801,"comment_content":"老师，请教一个问题，如果唯一索引是varchar呢？会怎么加锁？","like_count":0},{"had_liked":false,"id":139611,"user_name":"mid_kingking","can_delete":false,"product_type":"c1","uid":1634591,"ip_address":"","ucode":"C46A173765C5D2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIO8fTPkx9hWIcK25lnRr2KG5BMR1ENvPEqEMGkiaUeiaKScOlClgqicGXFh0wC2z798CYwWicxUIyyKw/132","comment_is_top":false,"comment_ctime":1570690268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570690268","product_id":100020801,"comment_content":"想问一下老师，为何例子insert 唯一键冲突中的间隙锁是(5,10]，c是唯一索引，不应该退化为行锁么，而且c值是定值10","like_count":0},{"had_liked":false,"id":123092,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1565603615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565603615","product_id":100020801,"comment_content":"拷贝表   我一般是转储整个表的SQL文件    然后复制出SQL语句  然后切换表名   然后执行","like_count":0},{"had_liked":false,"id":105560,"user_name":"Jzzw","can_delete":false,"product_type":"c1","uid":1508208,"ip_address":"","ucode":"4B642AADF48BD6","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/70/01dc4853.jpg","comment_is_top":false,"comment_ctime":1561031487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561031487","product_id":100020801,"comment_content":"死锁的那个问题，session b和 session c 应该都是在申请意向写锁吧，session a释放掉写锁后，session b和c应该都可以申请到意向写锁，但是因为意向写锁和写锁也是互斥的，所以他们都在等着对方把意向写锁释放掉然后自己可以申请写锁，于是乎产生了死锁","like_count":0},{"had_liked":false,"id":104168,"user_name":"读书看报","can_delete":false,"product_type":"c1","uid":1306147,"ip_address":"","ucode":"3B4717314B52A9","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/23/b92b0811.jpg","comment_is_top":false,"comment_ctime":1560673397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560673397","product_id":100020801,"comment_content":"*** (1) TRANSACTION:<br>TRANSACTION 21795520, ACTIVE 21 sec inserting<br>mysql tables in use 1, locked 1<br>LOCK WAIT 7 lock struct(s), heap size 1136, 5 row lock(s), undo log entries 2<br>MySQL thread id 13257, OS thread handle <br>INSERT INTO baq_rygj_sp(id,mid) VALUES (<br>\t\t\t&#39;02911c3db73a4738839f5c06f5ce0c4a&#39;,&#39;099d0b0283ac4e4dad478de8fe5ab128&#39;)<br>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 2790 page no 7997 n bits 120 index PRIMARY of table `baq`.`baq_rygj_sp` trx id 21795520 lock_mode X locks gap before rec insert intention waiting<br>Record lock, heap no 4 PHYSICAL RECORD: n_fields 25; compact format; info bits 0<br> 0: len 30; hex 303239313464353064373862343332386263343338313339643136633038; asc 02914d50d78b4328bc438139d16c08; <br>*** (2) TRANSACTION:<br>TRANSACTION 21795516, ACTIVE 24 sec fetching rows, thread declared inside InnoDB 871<br>mysql tables in use 1, locked 1<br>2834 lock struct(s), heap size 254160, 99649 row lock(s)<br>MySQL thread id 13232, OS thread handle 108936, query id 75199918 IP USER updating<br>delete from baq_rygj_sp where mid=&#39;31a263af486549f89b95e552dcf45ca3&#39;<br>*** (2) HOLDS THE LOCK(S):<br>RECORD LOCKS space id 2790 page no 7997 n bits 120 index PRIMARY of table `baq`.`baq_rygj_sp` trx id 21795516 lock_mode X<br>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0<br> 0: len 8; hex 73757072656d756d; asc supremum;;<br>......省略<br>Record lock, heap no 4 PHYSICAL RECORD: n_fields 25; compact format; info bits 0<br> 0: len 30; hex 303239313464353064373862343332386263343338313339643136633038; asc 02914d50d78b4328bc438139d16c08; <br>......省略<br>*** (2) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 2790 page no 6662 n bits 120 index PRIMARY of table `baq`.`baq_rygj_sp` trx id 21795516 lock_mode X waiting<br>Record lock, heap no 48 PHYSICAL RECORD: n_fields 25; compact format; info bits 0<br> 0: len 30; hex 346163366131663536643236343734336139633935323763626133616163; asc 4ac6a1f56d264743a9c9527cba3aac; <br>*** WE ROLL BACK TRANSACTION (1)","like_count":0},{"had_liked":false,"id":104167,"user_name":"读书看报","can_delete":false,"product_type":"c1","uid":1306147,"ip_address":"","ucode":"3B4717314B52A9","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/23/b92b0811.jpg","comment_is_top":false,"comment_ctime":1560673150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560673150","product_id":100020801,"comment_content":"一条Delete语句，用的条件字段没有加索引，和Insert语句造成死锁;<br>delete由于条件字段没有建立索引，所以会对聚簇索引逐条扫描加Next-Key Lock ，Insert操作时会发现插入的间隙存在Gap锁，所以会加插入意向锁，并处于等待状态，可是死锁日志显示delete语句的事务也在等待一个 X锁，造成了死锁，不理解后面这段，我贴下日志，麻烦老师帮忙解答下疑问？","like_count":0},{"had_liked":false,"id":103706,"user_name":"Tunayoyo","can_delete":false,"product_type":"c1","uid":1447213,"ip_address":"","ucode":"E77AFDE575CE04","user_header":"https://static001.geekbang.org/account/avatar/00/16/15/2d/8447e8c8.jpg","comment_is_top":false,"comment_ctime":1560495457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560495457","product_id":100020801,"comment_content":"老师，insert into t2(c,d) select c,d from t;这句话的主键索引加锁范围怎么来的？<br>","like_count":0},{"had_liked":false,"id":101055,"user_name":"Leon廖","can_delete":false,"product_type":"c1","uid":1018550,"ip_address":"","ucode":"3BB340F2C8F00D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pftx8PrTibZqu39dxkicUdrXbaMe6v4rcoTzOoF9Z04OibIIDgbpRIrDS9lYBYc97QAscGp77vU6nN5uxRiceRER3Q/132","comment_is_top":false,"comment_ctime":1559706577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559706577","product_id":100020801,"comment_content":"碰到insert的死锁问题，想起来回来看看课程为什么duplicate-key错误为什么会锁区间，看来这里也无解。<br><br>图7的死锁问题，一开始rollback前T1,T2加上的是记录S锁<br>+-----------------+-------------+-----------+-----------+---------------+------------+------------+-----------+----------+-----------+<br>| lock_id         | lock_trx_id | lock_mode | lock_type | lock_table    | lock_index | lock_space | lock_page | lock_rec | lock_data |<br>+-----------------+-------------+-----------+-----------+---------------+------------+------------+-----------+----------+-----------+<br>| 1429539:155:4:6 | 1429539     | S         | RECORD    | `db80801`.`t` | c          |        155 |         4 |        6 | 5         |<br>| 1429537:155:4:6 | 1429537     | X         | RECORD    | `db80801`.`t` | c          |        155 |         4 |        6 | 5         |<br>| 1429538:155:4:6 | 1429538     | S         | RECORD    | `db80801`.`t` | c          |        155 |         4 |        6 | 5         |<br>+-----------------+-------------+-----------+-----------+---------------+------------+------------+-----------+----------+-----------+<br><br>rollback后，貌似Session B, Session C都拿到了(4,sup]的S Next-key lock<br>*** (2) HOLDS THE LOCK(S):<br>RECORD LOCKS space id 155 page no 4 n bits 72 index c of table `db80801`.`t` trx id 1429539 lock mode S<br>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0<br> 0: len 8; hex 73757072656d756d; asc supremum;;<br><br>不是很理解为什么要锁住(4,sup]这个区间？<br><br>另外如果把T3的rollback换成delete from t where where c=5;commit;<br>死锁就不会发生。也是有点费解","like_count":0},{"had_liked":false,"id":85942,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1555297535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555297535","product_id":100020801,"comment_content":"老师你好，死锁那个例子<br>由于sessionA还没有提交，而sessionB确能够检测到唯一键冲突。是因为当前读吗？","like_count":0},{"had_liked":false,"id":85755,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1555223857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555223857","product_id":100020801,"comment_content":"老师，发现文章中好像存在问题，<br>图7<br>“在 T2 时刻，session B 要执行相同的 insert 语句，发现了唯一键冲突，加上读锁；同样地，session C 也在索引 c 上，c=5 这一个记录上，加了读锁。”<br>由于session A 在索引C 加了 c=5的行锁，所以session B被堵住了，此时并没有发现唯一键冲突，也不会加行锁！！！因为语句被堵住了，根本没有执行，希望老师解答<br>","like_count":0},{"had_liked":false,"id":84322,"user_name":"亮的太阳","can_delete":false,"product_type":"c1","uid":1475752,"ip_address":"","ucode":"8BD77740812984","user_header":"https://static001.geekbang.org/account/avatar/00/16/84/a8/b0746eea.jpg","comment_is_top":false,"comment_ctime":1554826712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554826712","product_id":100020801,"comment_content":"由于实现上这个语句没有在子查询中就直接使用 limit 1<br><br>这句话什么意思啊，为什么会全表扫呢？","like_count":0},{"had_liked":false,"id":79458,"user_name":"瀛寰搜奇","can_delete":false,"product_type":"c1","uid":1181108,"ip_address":"","ucode":"E6EE9FCC5C264F","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/b4/506c2bb3.jpg","comment_is_top":false,"comment_ctime":1553486138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553486138","product_id":100020801,"comment_content":"老师，insert成功后会对该记录加排他锁，那么主键冲突的时候其他事务给这条记录加读锁为什么会成功？  俩锁不是不兼容吗","like_count":0},{"had_liked":false,"id":77738,"user_name":"Kuzhang","can_delete":false,"product_type":"c1","uid":1305570,"ip_address":"","ucode":"EAC381039D2F91","user_header":"https://static001.geekbang.org/account/avatar/00/13/eb/e2/db65ce49.jpg","comment_is_top":false,"comment_ctime":1552989485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552989485","product_id":100020801,"comment_content":"：）过年落下太多了，一直在补……<br><br>replace into...重复，删除重复数据，insert新数据；<br>insert...on duplicate key update...重复，update；<br><br>想请问一下，这两者有什么区别吗？<br><br>记得update原理好像就是 delete flag 记录+insert 新记录，这样算下来，这两者是不是基本没啥区别，也就语法不同而已了。。","like_count":0},{"had_liked":false,"id":77207,"user_name":"伟仔_Hoo","can_delete":false,"product_type":"c1","uid":1323341,"ip_address":"","ucode":"74945AEE48DD62","user_header":"https://static001.geekbang.org/account/avatar/00/14/31/4d/ea8ac77c.jpg","comment_is_top":false,"comment_ctime":1552886112,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1552886112","product_id":100020801,"comment_content":"老师，看到您的回复，当select c+1, d from t force index(c) order by c desc limit 1;这条语句单独执行是会在c索引上加(4,sup] 这个next key lock, 于是我进行了尝试<br>sessionA: <br>begin;<br>select c+1, d from t force index(c) order by c desc limit 1;<br>sessionB:<br>insert into t values(5, 5, 5);<br>结果是，sessionB插入成功，是不是我哪里理解错了？我的版本是5.7.23<br>作者回复: session A的select语句没有加 for update 或者 lock in share mode ?<br><br>老师，看到您的回复之后，我在session A加了lock in share mode, 然后在sessionB分别执行3次操作：<br>1.insert into t values(5, 5, 5); 结果锁等待超时。<br>2.update t set c=4 where c=4;也是锁等待超时。<br>3.update t set c=2 where c=2;执行成功。<br>但是不加lock in share mode的话：<br>1.insert into t values(5, 5, 5); 执行成功。<br>2.update t set c=4 where c=4;执行成功。<br>3.update t set c=2 where c=2;执行成功。<br>所以结论是，加了lock in share mode,c 索引加锁范围是(3,4]，(4, sup]；不加lock in share mode，c 索引不加锁，这样对吗？","like_count":0,"discussions":[{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10166,"discussion_content":"兄嘚，不加lock in share mode，那么select 查询走的就是MVVC快照读，不会加锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568269224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77100,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1065310,"ip_address":"","ucode":"E5D21F2A3359CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/5e/9d2953a3.jpg","comment_is_top":false,"comment_ctime":1552833659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552833659","product_id":100020801,"comment_content":"老师，请教一个死锁问题：<br>create table  t (<br>`id` int not null, <br>`c` int , <br>primary key(`id`),<br>unique key `c`(`c`)<br>)engine=innodb default charset=utf8;<br><br>RR隔离级别<br><br>insert into t value(1, 1);<br><br>session1:                                     <br>Time1:  begin;<br>Time2: select * from t where c=1 for update;<br>Time3: update t set id=id+1 where c=1;<br>Time4: <br>Time5: select * from where c=1 for update;<br><br>session2:<br>Time1:<br>Time2:<br>Time3:<br>Time4: select * from t where c=1 for update;<br>Time5:<br><br>session2在session1执行完update后，执行select...for update会等待。然后session1再执行select...for update（即Time5时刻执行的语句）后，session2返回Deadlock。<br><br>我的分析：<br>session1执行第一条select...for update应该会获得c=1的记录锁吧，然后update c=1,前面已拿到c=1的记录锁。<br>此时session2执行select...for update也要获取c=1的记录锁，等待。<br>最后session1执行select...for update，由于之前已经获取c=1的记录锁，可以执行。<br><br>但为什么实际上会出现死锁？出现死锁就是出现了锁等待闭环，session2中的select...for update应该已经获得一个把锁，不然不会出现锁等待闭环吧，没想明白获得了什么锁。<br>","like_count":0},{"had_liked":false,"id":74338,"user_name":"猫小妖的尾巴","can_delete":false,"product_type":"c1","uid":1309248,"ip_address":"","ucode":"250777C6DFC468","user_header":"https://static001.geekbang.org/account/avatar/00/13/fa/40/6f4949d3.jpg","comment_is_top":false,"comment_ctime":1552194435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552194435","product_id":100020801,"comment_content":"老师，我们的业务中有用到insert …on duplicate key update导致死锁的情况，表是有唯一索引，DBA那边的解释是有唯一索引的insert需要两把锁，事务1先申请X锁成功, 然后申请S锁, 但是事务2正在申请X锁, 与事务1的S锁冲突, 系统决定回滚事务2，然后我就改成先查询存在直接update不存在再用原来的逻辑，不过我感觉还是不太明白，你可以解释一下吗<br>","like_count":0},{"had_liked":false,"id":70118,"user_name":"滔滔","can_delete":false,"product_type":"c1","uid":1303342,"ip_address":"","ucode":"6968B5771AF79D","user_header":"https://static001.geekbang.org/account/avatar/00/13/e3/2e/77ad18f4.jpg","comment_is_top":false,"comment_ctime":1551000534,"is_pvip":false,"replies":[{"id":"25018","content":"(4,sup]<br><br>以防优化器不走索引，影响我们结论（比如数据量比较小的时候）","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551050488,"ip_address":"","comment_id":70118,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551000534","product_id":100020801,"comment_content":"老师，select c+1, d from t force index(c) order by c desc limit 1;这条语句如果单独执行，是会对表t进行全表加锁，还是只加(3,4],(4,sup]这两个next key锁。还有一个问题，这里为什么要加force index(c)，不加会是怎样的效果呢？🤔","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440447,"discussion_content":"(4,sup]\n\n以防优化器不走索引，影响我们结论（比如数据量比较小的时候）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551050488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67339,"user_name":"cyberbit","can_delete":false,"product_type":"c1","uid":1303197,"ip_address":"","ucode":"1BD53A25F5277F","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/9d/fbbd4611.jpg","comment_is_top":false,"comment_ctime":1550132259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550132259","product_id":100020801,"comment_content":"在表件迁移拷贝数据，用的pt-archiver工具做的，但是它不支持utf8mb4字符集，这个问题一直困扰我，不知道怎么解决。","like_count":0},{"had_liked":false,"id":67009,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1550055280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550055280","product_id":100020801,"comment_content":"老师威武。<br>终于追上更新了。","like_count":0},{"had_liked":false,"id":66813,"user_name":"K先生","can_delete":false,"product_type":"c1","uid":1145942,"ip_address":"","ucode":"D9D3ED28943334","user_header":"https://static001.geekbang.org/account/avatar/00/11/7c/56/c743bc9a.jpg","comment_is_top":false,"comment_ctime":1550024530,"is_pvip":false,"replies":[{"id":"23669","content":"show engine innodb status\\G<br>里面lastest deadlock那一段发来看下哈<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550047309,"ip_address":"","comment_id":66813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550024530","product_id":100020801,"comment_content":"表结构<br>CREATE TABLE `PushTask` (<br>  `Id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID，自增长&#39;,<br>  `DpId` varchar(100) NOT NULL DEFAULT &#39;&#39;,<br>  `DetailId` int(11) NOT NULL,<br>  `SceneType` tinyint(1) DEFAULT NULL,<br>  `DataId` int(11) DEFAULT NULL,<br>  `SendTime` datetime NOT NULL,<br>  `AddTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,<br>  `UpdateTime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,<br>  `Status` tinyint(1) DEFAULT &#39;0&#39;,<br>  `SendDate` date DEFAULT NULL,<br>  PRIMARY KEY (`Id`),<br>  UNIQUE KEY `IX_DpId_SendDate_DetailId` (`DpId`,`SendDate`,`DetailId`),<br>  KEY `IX_UpdateTime` (`UpdateTime`),<br>  KEY `IX_SendTime` (`SendTime`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br><br>请问老师，为啥insert ... ON DUPLICATE KEY UPDATE<br>        UpdateTime = now()的时候会出现死锁？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438924,"discussion_content":"show engine innodb status\\G\n里面lastest deadlock那一段发来看下哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550047309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}