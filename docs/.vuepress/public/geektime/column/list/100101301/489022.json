{"id":489022,"title":"31 | 消息驱动：如何通过 RabbitMQ 插件实现延迟消息？","content":"<p>你好，我是姚秋辰。</p><p>在平时网购的时候，你一定有过下单之后忘记付款的情况，等到再回过头想起要付款，发现订单已经被关闭了，很多网购流程里都有类似的“订单超时关闭”功能。相类似的功能还有“自动确认收货”，如果在一定时间内买家都没有点击确认收货按钮，那么系统会自动确认收货并且将订单款项打给卖家。</p><p>我举的这两个例子都有一个共同的特征，那就是业务逻辑会预设在未来的某一个时间点被触发。在早期我们经常会使用TTL+死信队列的方式来实现这种定时事件，通过设置一个正常的消息队列并使用TTL指定超时时间，如果队列中的消息超时了，它就会被DLX（死信交换机）转向死信队列。借助这种曲线救国的方式，你就可以通过MQ组件实现“定时消息”。</p><p>相比于TTL+DLX，RabbitMQ提供了一种更为优雅的方式来实现这类业务。在这节课中，我将带你使用RabbitMQ的延迟消息插件，实现延迟发放优惠券的场景。</p><p>那么首先，我们先来安装这个延迟消息插件吧。</p><h2>安装插件</h2><p>你需要先打开RabbitMQ官网并进入到<a href=\"https://www.rabbitmq.com/community-plugins.html\">插件下载页面</a>，在页面中定位到<strong>rabbitmq_delayed_message_exchange这个插件。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/b8/04/b8c1ee9769b005bb8eb3932b72yy7e04.png?wh=1914x352\" alt=\"图片\"></p><p>点击插件上的“Releases”链接，你可以看到适配不同RabbitMQ版本的延迟消息插件。我本地安装的的RabbitMQ版本是3.9.8，最新的延迟消息插件的版本是3.9.0，它可以适配3.9.X系列的RMQ组件，所以我建议你下载3.9.0版本对应的rabbitmq_delayed_message_exchange-3.9.0.ez安装包。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/60/c5/605281d670ff9f4ba66638f9b99d6bc5.png?wh=1850x742\" alt=\"图片\"></p><p>接下来，你需要把安装包的后缀名从.ez改成.zip，然后使用解压缩工具对安装包进行解压。再把解压后的文件复制到RabbitMQ安装路径下的plugins文件夹。以我的本地MAC环境为例，plugins目录位于/usr/local/Cellar/rabbitmq/3.9.8/plugins，你需要根据自己的操作系统和安装路径找到对应的目录。</p><p>然后，你需要执行下面这行rabbitmq-plugins命令，通过人工的方式启动rabbitmq_delayed_message_exchange插件。</p><pre><code class=\"language-json\">rabbitmq-plugins enable rabbitmq_delayed_message_exchange\n</code></pre><p>最后，你只需要重启一下RabbitMQ服务器，新安装的插件就可以生效了，接下来我们就可以通过代码落地延迟领劵业务了。</p><h2>实现延迟领券</h2><p>因为延迟消息队列和普通消息队列的类型不同，为了和之前的普通领券接口做个区分，我们今天要声明一个新的生产者和消费者，用来对接延迟消息队列。我先从生产者开始创建。</p><h3>创建生产者</h3><p>我们依然保持队形，将生产者方法写入CouponProducer这个类中，你可以参考一下下面的代码。</p><p>在这段代码中，有一个显而易见的不同之处，你会发现我没有直接将coupon对象传递给生产者，取而代之的是使用了MessageBuilder来构建消息对象，这样做的一个目的是<strong>传入一个特殊的header，那就是x-delay</strong>。它是延迟消息特有的参数，代表了你想让这个消息在Queue里延迟多久以后再被消费者处理，x-delay对应的单位是毫秒，我在代码中设置的延迟时间是10秒。</p><pre><code class=\"language-plain\">// 使用延迟消息发送\npublic void sendCouponInDelay(RequestCoupon coupon) {\n    log.info(\"sent: {}\", coupon);\n    streamBridge.send(EventConstant.ADD_COUPON_DELAY_EVENT,\n            MessageBuilder.withPayload(coupon)\n                    .setHeader(\"x-delay\", 10 * 1000)\n                    .build());\n}\n</code></pre><p>代码中的ADD_COUPON_DELAY_EVENT的值是addCouponDelay-out-0，它是我单独为延迟消息队列指定的function name。</p><p>接下来，我在CouponCustomerController类中声明了一个入口方法，用来对接生产者方法创建延迟消息。</p><pre><code class=\"language-plain\">@PostMapping(\"requestCouponDelayEvent\")\npublic void requestCouponDelayedEvent(@Valid @RequestBody RequestCoupon request) {\n    couponProducer.sendCouponInDelay(request);\n}\n</code></pre><p>生产者到这里就创建完了，接下来是消费者。</p><h3>声明消费者</h3><p>在消费者这一端，延迟消息和普通消息的实现方式并没有任何不同，你可以把下面这段朴实无华的代码加入到CouponConsumer类中。</p><pre><code class=\"language-plain\">@Bean\npublic Consumer&lt;RequestCoupon&gt; addCouponDelay() {\n    return request -&gt; {\n        log.info(\"received: {}\", request);\n        customerService.requestCoupon(request);\n    };\n}\n</code></pre><p>你需要留意一下消费者的方法名称，一定要保证这里的方法名和配置文件中的function name保持完全的一致。</p><p>消费者创建完成之后，我们最后还需要对配置文件做一些修改。</p><h3>修改配置文件</h3><p>这一步中我们需要做的就是把生产者和消费者添加到application.yml文件中，你可以参考下面这段代码。</p><pre><code class=\"language-plain\">spring:\n  cloud:\n    stream:\n      bindings:\n        # 延迟发券 - producer\n        addCouponDelay-out-0:\n          destination: request-coupon-delayed-topic\n          content-type: application/json\n          binder: my-rabbit\n        # 延迟发券 - Consumer\n        addCouponDelay-in-0:\n          destination: request-coupon-delayed-topic\n          content-type: application/json\n          # 消费组，同一个组内只能被消费一次\n          group: add-coupon-group\n          binder: my-rabbit\n          consumer:\n            # 如果最大尝试次数为1，即不重试\n            # 默认是做3次尝试\n            max-attempts: 1\n      function:\n        definition: addCoupon;deleteCoupon;addCouponDelay\n      rabbit:\n        bindings:\n          addCouponDelay-out-0:\n            producer:\n              delayed-exchange: true\n          addCouponDelay-in-0:\n            consumer:\n              delayed-exchange: true\n</code></pre><p>在这段代码里有几个关键点，我需要提醒你一下。</p><p>第一个是<strong>function name的统一</strong>。在spring.cloud.stream.function.definition中我添加了addCouponDelay作为functiona name，它和Consumer方法中声明的method name是一致的。</p><p>第二个关键点是<strong>绑定生产者消费者Topic</strong>。你会发现我在生产者和消费者端的destination属性中声明了一个全新的Topic，request-coupon-delayed-topic，这样做是为了重新创建一个带有x-delay-message功能的交换机。</p><p>第三个关键点是<strong>声明延迟消息功能</strong>。在bindings节点下面声明的生产者和消费者配置项中，我设置了delayed-exchange=true，这是延迟队列最为关键的一个属性。如果没有设置，那么系统将会创建一个普通的交换机，而不是具有延迟消费功能的交换机。</p><p>实现延迟消息功能所需要的全部操作就完成了，你可以启动项目并尝试发送几个请求，来验证消息是否会延迟消费。</p><p>如果你登录到RabbitMQ控制台查看交换机信息，你会发现我们今天声明的延迟消息交换机（request-coupon-delayed-topic）和第<a href=\"https://time.geekbang.org/column/article/487752?cid=100101301\">29节课</a>中声明的常规交换机（request-coupon-topic）之间的不同，延迟交换机的类型是x-delayed-message，并且带有DM功能标签，这代表当前交换机具备延迟消费功能。</p><p><img src=\"https://static001.geekbang.org/resource/image/30/a9/30d45ce899b5f131edc81dc718e12ca9.png?wh=701x65\" alt=\"图片\"></p><p>到这里，我们就了解了如何搭建一个延迟消息的场景，下面让我来带你回顾下本节重点吧。</p><h2>总结</h2><p>利用RabbitMQ搭建延迟消息的过程并不复杂，不过当项目中Topic多起来的时候，function name的配置很容易出错。当你和一个遵循“约定大于配置”的框架打交道的时候，经常会因为没有遵循一个不起眼的约定，导致功能不work，而且排查起来特别困难。可见事物总是相对的，约定大于配置的思想在提高开发效率的同时，也略微抬高了入门成本和异常排查的成本。</p><p>在使用rabbitMQ实现高并发业务场景的时候，我有几个经验跟你分享。</p><ul>\n<li><strong>Sharding</strong>: 数据库sharding方案相信你应该很熟悉了，我们在消息队列中同样也可以应用Sharding方案做消息分片。你可以通过官方提供的Sharding插件创建逻辑队列，并将消息转发到逻辑队列背后的shards队列。Sharding插件的底层原理和数据库Sharding方案类似，它创建了一种“x-modulus-hash”类型的交换机，通过Hash算法对routing key做哈希操作并取模，根据取模的结果做消息转发。具体内容可以参考我贴在文稿里的<a href=\"https://github.com/rabbitmq/rabbitmq-server/tree/master/deps/rabbitmq_sharding\">官方文档</a>。</li>\n<li><strong>一致性哈希</strong>：通过一致性哈希插件，我们可以声明一个x-consistent-hash类型的交换机，根据一定的规则对消息中的变量（通常是Routing Key）做一致性哈希计算，再根据计算结果对消息进行转发。如果你对一致性哈希并不了解，可以从网上学一学这个算法思想，它是一个比较常用的Routing规则。</li>\n<li><strong>持久化消息</strong>：如果你的队列对消息丢失的情况容忍度很低，那么你可以把队列声明成一个持久化队列，同时发送消息的时候也使用持久化消息。这样一来，不管是队列还是消息都会最终落盘保存。不过你要在一致性和可用性之间做好权衡，因为持久化消息是重量级消息体，必然对性能和吞吐量有一些影响。</li>\n</ul><h2>思考题</h2><p>生产者和消费者只是一个消息队列最普通的玩法，每个消息队列都有自己丰富的功能库，比如RabbitMQ就提供了各种强大的插件。你能打开文档中的<a href=\"https://github.com/rabbitmq/rabbitmq-server/tree/master/deps\">RabbitMQ插件页面</a>，深入了解几个感兴趣的插件功能，然后在评论区和大家分享吗？</p><p>好啦，这节课就结束啦。欢迎你把这节课分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们下节课再见！</p>","neighbors":{"left":{"article_title":"30 | 消息驱动：如何高效处理 Stream 中的异常？","id":488500},"right":{"article_title":"32 | Alibaba Seata 框架：什么是分布式事务？","id":489831}},"comments":[{"had_liked":false,"id":336655,"user_name":"招谁惹谁","can_delete":false,"product_type":"c1","uid":1014054,"ip_address":"","ucode":"F4B43C8C098E96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/26/9ac98036.jpg","comment_is_top":false,"comment_ctime":1646276683,"is_pvip":false,"replies":[{"id":"123088","content":"定时任务可以，不过时效性不如延迟消息好。每时没秒都有业务要处理，那定时任务要跑的像脱缰野狗一样频繁才行","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1646404603,"ip_address":"","comment_id":336655,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10236211275","product_id":100101301,"comment_content":"延时消息能取消吗？如果不能取消，业务上还要对超时的已付款的订单再兼容呀。这个是不是定时任务更好一些！","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554494,"discussion_content":"定时任务可以，不过时效性不如延迟消息好。每时没秒都有业务要处理，那定时任务要跑的像脱缰野狗一样频繁才行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646404604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336549,"user_name":"奔跑的蚂蚁","can_delete":false,"product_type":"c1","uid":2379253,"ip_address":"","ucode":"7348CA436144CB","user_header":"https://static001.geekbang.org/account/avatar/00/24/4d/f5/2e80aca6.jpg","comment_is_top":false,"comment_ctime":1646209685,"is_pvip":false,"replies":[{"id":"123089","content":"如果可达性不能保证，就用外部事务表控制幂等性。而且下单 -&gt; 支付 -&gt; 退款之间是串行，下单失败是不会生成支付连接的，如果资金链路auth阶段失败就在payment gateway这一层（比如网联）原路返回，不会生成成功交易记录；如果交易capture成功，通常上游支付链路就直接触发callback url了，这时你再背后在发送支付成功的event，在本地消费成功event或补偿job查询到交易底层状态前，不会触发退款。","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1646405058,"ip_address":"","comment_id":336549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646209685","product_id":100101301,"comment_content":"在电商中 会遇到 下单  -》支付  -》退款    消息的发送点不一样 ，消费点也不一样  怎么保证这个消费成功的顺序呢","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554495,"discussion_content":"如果可达性不能保证，就用外部事务表控制幂等性。而且下单 -&gt; 支付 -&gt; 退款之间是串行，下单失败是不会生成支付连接的，如果资金链路auth阶段失败就在payment gateway这一层（比如网联）原路返回，不会生成成功交易记录；如果交易capture成功，通常上游支付链路就直接触发callback url了，这时你再背后在发送支付成功的event，在本地消费成功event或补偿job查询到交易底层状态前，不会触发退款。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646405058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336291,"user_name":"inrtyx","can_delete":false,"product_type":"c1","uid":1246178,"ip_address":"","ucode":"81CD18FF34ABAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","comment_is_top":false,"comment_ctime":1646052939,"is_pvip":true,"replies":[{"id":"123084","content":"如果已经有了六脉神剑剑谱，为何还用学一阳指呢？","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1646404222,"ip_address":"","comment_id":336291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646052939","product_id":100101301,"comment_content":"除了mq还有其他方式推荐吗？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554490,"discussion_content":"如果已经有了六脉神剑剑谱，为何还用学一阳指呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646404222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336222,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1646014442,"is_pvip":true,"replies":[{"id":"123081","content":"很多公司的开源版和商用版功能有一些差别，比如这里提到的rocketmq（阿里前身的metaq），阿里系的惯用手法哈，你看它的sentinel也是的，开源版有些功能甚至要自己修改底层代码，但是商用版做到alicloud里的就相对完善","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1646403843,"ip_address":"","comment_id":336222,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646014442","product_id":100101301,"comment_content":"上家公司就遇到过实现任意延时时长消息问题，rabbitmq_delayed_message_exchange这个插件官方说的是有可能适合于生产使用(是性能还是稳定性的考虑、还是出于商业考虑)。为什么官方rabbitmq不推出新特性做支持，而要采用插件？ 目前已知rocketmq只支持队列级别消息，好像也没有进一步去开发任意延时市场消息的趋势，也是为了商业化么？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554487,"discussion_content":"很多公司的开源版和商用版功能有一些差别，比如这里提到的rocketmq（阿里前身的metaq），阿里系的惯用手法哈，你看它的sentinel也是的，开源版有些功能甚至要自己修改底层代码，但是商用版做到alicloud里的就相对完善","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646403843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}