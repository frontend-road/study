{"id":740779,"title":"第 15 章 编译器核心技术概览(2)","content":"<h2 id=\"nav_point_145\">15.4　AST 的转换与插件化架构</h2>\n<p>在上一节中，我们完成了模板 AST 的构造。本节，我们将讨论关于 AST 的转换。所谓 AST 的转换，指的是对 AST 进行一系列操作，将其转换为新的 AST 的过程。新的 AST 可以是原语言或原 DSL 的描述，也可以是其他语言或其他 DSL 的描述。例如，我们可以对模板 AST 进行操作，将其转换为 JavaScript AST。转换后的 AST 可以用于代码生成。这其实就是 Vue.js 的模板编译器将模板编译为渲染函数的过程，如图 15-21 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00630.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-21　模板编译器将模板编译为渲染函数的过程</strong></p>\n<p>其中 <code>transform</code> 函数就是用来完成 AST 转换工作的。</p>\n<h3 id=\"nav_point_146\">15.4.1　节点的访问</h3>\n<p>为了对 AST 进行转换，我们需要能访问 AST 的每一个节点，这样才有机会对特定节点进行修改、替换、删除等操作。由于 AST 是树型数据结构，所以我们需要编写一个深度优先的遍历算法，从而实现对 AST 中节点的访问。不过，在开始编写转换代码之前，我们有必要编写一个 <code>dump</code> 工具函数，用来打印当前 AST 中节点的信息，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function dump(node, indent = 0) {\n   // 节点的类型\n   const type = node.type\n   // 节点的描述，如果是根节点，则没有描述\n   // 如果是 Element 类型的节点，则使用 node.tag 作为节点的描述\n   // 如果是 Text 类型的节点，则使用 node.content 作为节点的描述\n   const desc = node.type === 'Root'\n     ? ''\n     : node.type === 'Element'\n       ? node.tag\n       : node.content\n<p>// 打印节点的类型和描述信息<br />\nconsole.log(<code>${'-'.repeat(indent)}$: $</code>)</p>\n<p>// 递归地打印子节点<br />\nif (node.children) {<br />\nnode.children.forEach(n =&gt; dump(n, indent + 2))<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>我们沿用上一节中给出的例子，看看使用 <code>dump</code> 函数会输出怎样的结果：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)\n console.log(dump(ast))\n</code></pre>\n<p>运行上面这段代码，将得到如下输出：</p>\n<pre class=\"code-rows\"><code> Root:\n --Element: div\n ----Element: p\n ------Text: Vue\n ----Element: p\n ------Text: Template\n</code></pre>\n<p>可以看到，<code>dump</code> 函数以清晰的格式来展示 AST 中的节点。在后续编写 AST 的转换代码时，我们将使用 <code>dump</code> 函数来展示转换后的结果。</p><!-- [[[read_end]]] -->\n<p>接下来，我们将着手实现对 AST 中节点的访问。访问节点的方式是，从 AST 根节点开始，进行深度优先遍历，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function traverseNode(ast) {\n   // 当前节点，ast 本身就是 Root 节点\n   const currentNode = ast\n   // 如果有子节点，则递归地调用 traverseNode 函数进行遍历\n   const children = currentNode.children\n   if (children) {\n     for (let i = 0; i &lt; children.length; i++) {\n       traverseNode(children[i])\n     }\n   }\n }\n</code></pre>\n<p><code>traverseNode</code> 函数用来以深度优先的方式遍历 AST，它的实现与 <code>dump</code> 函数几乎相同。有了 <code>traverseNdoe</code> 函数之后，我们即可实现对 AST 中节点的访问。例如，我们可以实现一个转换功能，将 AST 中所有 <code>p</code> 标签转换为 <code>h1</code> 标签，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function traverseNode(ast) {\n   // 当前节点，ast 本身就是 Root 节点\n   const currentNode = ast\n<p>// 对当前节点进行操作<br />\nif (currentNode.type === ‘Element’ &amp;&amp; currentNode.tag === ‘p’) {<br />\n// 将所有 p 标签转换为 h1 标签<br />\ncurrentNode.tag = ‘h1’<br />\n}</p>\n<p>// 如果有子节点，则递归地调用 traverseNode 函数进行遍历<br />\nconst children = currentNode.children<br />\nif (children) {<br />\nfor (let i = 0; i &lt; children.length; i++) {<br />\ntraverseNode(children[i])<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们通过检查当前节点的 <code>type</code> 属性和 <code>tag</code> 属性，来确保被操作的节点是 <code>p</code> 标签。接着，我们将符合条件的节点的 <code>tag</code> 属性值修改为 <code>'h1'</code>，从而实现 <code>p</code> 标签到 <code>h1</code> 标签的转换。我们可以使用 <code>dump</code> 函数打印转换后的 AST 的信息，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 封装 transform 函数，用来对 AST 进行转换\n function transform(ast) {\n   // 调用 traverseNode 完成转换\n   traverseNode(ast)\n   // 打印 AST 信息\n   console.log(dump(ast))\n }\n<p>const ast = parse(<code>&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;Vue&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;Template&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;</code>)<br />\ntransform(ast)<br />\n</code></pre></p>\n<p>运行上面这段代码，我们将得到如下输出：</p>\n<pre class=\"code-rows\"><code> Root:\n --Element: div\n ----Element: h1\n ------Text: Vue\n ----Element: h1\n ------Text: Template\n</code></pre>\n<p>可以看到，所有 <code>p</code> 标签都已经变成了 <code>h1</code> 标签。</p>\n<p>我们还可以对 AST 进行其他转换。例如，实现一个转换，将文本节点的内容重复两次：</p>\n<pre class=\"code-rows\"><code> function traverseNode(ast) {\n   // 当前节点，ast 本身就是 Root 节点\n   const currentNode = ast\n<p>// 对当前节点进行操作<br />\nif (currentNode.type === ‘Element’ &amp;&amp; currentNode.tag === ‘p’) {<br />\n// 将所有 p 标签转换为 h1 标签<br />\ncurrentNode.tag = ‘h1’<br />\n}</p>\n<p>// 如果节点的类型为 Text<br />\nif (currentNode.type === ‘Text’) {<br />\n// 重复其内容两次，这里我们使用了字符串的 repeat() 方法<br />\ncurrentNode.content = currentNode.content.repeat(2)<br />\n}</p>\n<p>// 如果有子节点，则递归地调用 traverseNode 函数进行遍历<br />\nconst children = currentNode.children<br />\nif (children) {<br />\nfor (let i = 0; i &lt; children.length; i++) {<br />\ntraverseNode(children[i])<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，我们增加了对文本类型节点的处理代码。一旦检查到当前节点的类型为 <code>Text</code>，则调用 <code>repeat(2)</code> 方法将文本节点的内容重复两次。最终，我们将得到如下输出：</p>\n<pre class=\"code-rows\"><code> Root:\n --Element: div\n ----Element: h1\n ------Text: VueVue\n ----Element: h1\n ------Text: TemplateTemplate\n</code></pre>\n<p>可以看到，文本节点的内容全部重复了两次。</p>\n<p>不过，随着功能的不断增加，<code>traverseNode</code> 函数将会变得越来越“臃肿”。这时，我们很自然地想到，能否对节点的操作和访问进行解耦呢？答案是“当然可以”，我们可以使用回调函数的机制来实现解耦，如下面 <code>traverseNode</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> // 接收第二个参数 context\n function traverseNode(ast, context) {\n   const currentNode = ast\n<p>// context.nodeTransforms 是一个数组，其中每一个元素都是一个函数<br />\nconst transforms = context.nodeTransforms<br />\nfor (let i = 0; i &lt; transforms.length; i++) {<br />\n// 将当前节点 currentNode 和 context 都传递给 nodeTransforms 中注册的回调函数<br />\ntransforms[i](currentNode, context)<br />\n}</p>\n<p>const children = currentNode.children<br />\nif (children) {<br />\nfor (let i = 0; i &lt; children.length; i++) {<br />\ntraverseNode(children[i], context)<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们首先为 <code>traverseNode</code> 函数增加了第二个参数 <code>context</code>。关于 <code>context</code> 的内容，下文会详细介绍。接着，我们把回调函数存储到 <code>transforms</code> 数组中，然后遍历该数组，并逐个调用注册在其中的回调函数。最后，我们将当前节点 <code>currentNode</code> 和 <code>context</code> 对象分别作为参数传递给回调函数。</p>\n<p>有了修改后的 <code>traverseNode</code> 函数，我们就可以如下所示使用它了：</p>\n<pre class=\"code-rows\"><code> function transform(ast) {\n   // 在 transform 函数内创建 context 对象\n   const context = {\n     // 注册 nodeTransforms 数组\n     nodeTransforms: [\n       transformElement, // transformElement 函数用来转换标签节点\n       transformText     // transformText 函数用来转换文本节点\n     ]\n   }\n   // 调用 traverseNode 完成转换\n   traverseNode(ast, context)\n   // 打印 AST 信息\n   console.log(dump(ast))\n }\n</code></pre>\n<p>其中，<code>transformElement</code> 函数和 <code>transformText</code> 函数的实现如下：</p>\n<pre class=\"code-rows\"><code> function transformElement(node) {\n   if (node.type === 'Element' &amp;&amp; node.tag === 'p') {\n     node.tag = 'h1'\n   }\n }\n<p>function transformText(node) {<br />\nif (node.type === ‘Text’) {<br />\nnode.content = node.content.repeat(2)<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>可以看到，解耦之后，节点操作封装到了 <code>transformElement</code> 和 <code>transformText</code> 这样的独立函数中。我们甚至可以编写任意多个类似的转换函数，只需要将它们注册到 <code>context.nodeTransforms</code> 中即可。这样就解决了功能增加所导致的 <code>traverseNode</code> 函数“臃肿”的问题。</p>\n<h3 id=\"nav_point_147\">15.4.2　转换上下文与节点操作</h3>\n<p>在上文中，我们将转换函数注册到 <code>context.nodeTransforms</code> 数组中。那么，为什么要使用 <code>context</code> 对象呢？直接定义一个数组不可以吗？为了搞清楚这个问题，就不得不提到关于上下文的知识。你可能或多或少听说过关于 Context（上下文）的内容，我们可以把 Context 看作程序在某个范围内的“全局变量”。实际上，上下文并不是一个具象的东西，它依赖于具体的使用场景。我们举几个例子来直观地感受一下。</p>\n<ul>\n<li>在编写 React 应用时，我们可以使用 <code>React.createContext</code> 函数创建一个上下文对象，该上下文对象允许我们将数据通过组件树一层层地传递下去。无论组件树的层级有多深，只要组件在这棵组件树的层级内，那么它就能够访问上下文对象中的数据。</li>\n<li>在编写 Vue.js 应用时，我们也可以通过 <code>provide</code>/<code>inject</code> 等能力，向一整棵组件树提供数据。这些数据可以称为上下文。</li>\n<li>在编写 Koa 应用时，中间件函数接收的 <code>context</code> 参数也是一种上下文对象，所有中间件都可以通过 <code>context</code> 来访问相同的数据。</li>\n</ul>\n<p>通过上述三个例子我们能够认识到，上下文对象其实就是程序在某个范围内的“全局变量”。换句话说，我们也可以把全局变量看作全局上下文。</p>\n<p>回到我们本节讲解的 <code>context.nodeTransforms</code> 数组，这里的 <code>context</code> 可以看作 AST 转换函数过程中的上下文数据。所有 AST 转换函数都可以通过 <code>context</code> 来共享数据。上下文对象中通常会维护程序的当前状态，例如当前转换的节点是哪一个？当前转换的节点的父节点是谁？甚至当前节点是父节点的第几个子节点？等等。这些信息对于编写复杂的转换函数非常有用。所以，接下来我们要做的就是构造转换上下文信息，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function transform(ast) {\n   const context = {\n     // 增加 currentNode，用来存储当前正在转换的节点\n     currentNode: null,\n     // 增加 childIndex，用来存储当前节点在父节点的 children 中的位置索引\n     childIndex: 0,\n     // 增加 parent，用来存储当前转换节点的父节点\n     parent: null,\n     nodeTransforms: [\n       transformElement,\n       transformText\n     ]\n   }\n<p>traverseNode(ast, context)<br />\nconsole.log(dump(ast))<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们为转换上下文对象扩展了一些重要信息。</p>\n<ul>\n<li><code>currentNode</code>：用来存储当前正在转换的节点。</li>\n<li><code>childIndex</code>：用来存储当前节点在父节点的 <code>children</code> 中的位置索引。</li>\n<li><code>parent</code>：用来存储当前转换节点的父节点。</li>\n</ul>\n<p>紧接着，我们需要在合适的地方设置转换上下文对象中的数据，如下面 <code>traverseNode</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function traverseNode(ast, context) {\n   // 设置当前转换的节点信息 context.currentNode\n   context.currentNode = ast\n<p>const transforms = context.nodeTransforms<br />\nfor (let i = 0; i &lt; transforms.length; i++) {<br />\ntransforms[i](context.currentNode, context)<br />\n}</p>\n<p>const children = context.currentNode.children<br />\nif (children) {<br />\nfor (let i = 0; i &lt; children.length; i++) {<br />\n// 递归地调用 traverseNode 转换子节点之前，将当前节点设置为父节点<br />\ncontext.parent = context.currentNode<br />\n// 设置位置索引<br />\ncontext.childIndex = i<br />\n// 递归地调用时，将 context 透传<br />\ntraverseNode(children[i], context)<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>观察上面这段代码，其关键点在于，在递归地调用 <code>traverseNode</code> 函数进行子节点的转换之前，我们必须设置 <code>context.parent</code> 和 <code>context.childIndex</code> 的值，这样才能保证在接下来的递归转换中，<code>context</code> 对象所存储的信息是正确的。</p>\n<p>有了上下文数据后，我们就可以实现节点替换功能了。什么是节点替换呢？在对 AST 进行转换的时候，我们可能希望把某些节点替换为其他类型的节点。例如，将所有文本节点替换成一个元素节点。为了完成节点替换，我们需要在上下文对象中添加 <code>context.replaceNode</code> 函数。该函数接收新的 AST 节点作为参数，并使用新节点替换当前正在转换的节点，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function transform(ast) {\n   const context = {\n     currentNode: null,\n     parent: null,\n     // 用于替换节点的函数，接收新节点作为参数\n     replaceNode(node) {\n       // 为了替换节点，我们需要修改 AST\n       // 找到当前节点在父节点的 children 中的位置：context.childIndex\n       // 然后使用新节点替换即可\n       context.parent.children[context.childIndex] = node\n       // 由于当前节点已经被新节点替换掉了，因此我们需要将 currentNode 更新为新节点\n       context.currentNode = node\n     },\n     nodeTransforms: [\n       transformElement,\n       transformText\n     ]\n   }\n<p>traverseNode(ast, context)<br />\nconsole.log(dump(ast))<br />\n}<br />\n</code></pre></p>\n<p>观察上面代码中的 <code>replaceNode</code> 函数。在该函数内，我们首先通过 <code>context.childIndex</code> 属性取得当前节点的位置索引，然后通过 <code>context.parent.children</code> 取得当前节点所在集合，最后配合使用 <code>context.childIndex</code> 与 <code>context.parent.children</code> 即可完成节点替换。另外，由于当前节点已经替换为新节点了，所以我们应该使用新节点更新 <code>context.currentNode</code> 属性的值。</p>\n<p>接下来，我们就可以在转换函数中使用 <code>replaceNode</code> 函数对 AST 中的节点进行替换了。如下面 <code>transformText</code> 函数的代码所示，它能够将文本节点转换为元素节点：</p>\n<pre class=\"code-rows\"><code> // 转换函数的第二个参数就是 context 对象\n function transformText(node, context) {\n   if (node.type === 'Text') {\n     // 如果当前转换的节点是文本节点，则调用 context.replaceNode 函数将其替换为元素节点\n     context.replaceNode({\n       type: 'Element',\n       tag: 'span'\n     })\n   }\n }\n</code></pre>\n<p>如上面的代码所示，转换函数的第二个参数就是 <code>context</code> 对象，所以我们可以在转换函数内部使用该对象上的任意属性或函数。在 <code>transformText</code> 函数内部，首先检查当前转换的节点是否是文本节点，如果是，则调用 <code>context.replaceNode</code> 函数将其替换为新的 <code>span</code> 标签节点。</p>\n<p>下面的例子用来验证节点替换功能：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)\n transform(ast)\n</code></pre>\n<p>运行上面这段代码，其转换前后的结果分别是：</p>\n<pre class=\"code-rows\"><code> // 转换前\n Root:\n --Element: div\n ----Element: p\n ------Text: VueVue\n ----Element: p\n ------Text: TemplateTemplate\n<p>// 转换后<br />\nRoot:<br />\n–Element: div<br />\n----Element: h1<br />\n------Element: span<br />\n----Element: h1<br />\n------Element: span<br />\n</code></pre></p>\n<p>可以看到，转换后的 AST 中的文本节点全部变为 <code>span</code> 标签节点了。</p>\n<p>除了替换节点，有时我们还希望移除当前访问的节点。我们可以通过实现 <code>context.removeNode</code> 函数来达到目的，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function transform(ast) {\n   const context = {\n     currentNode: null,\n     parent: null,\n     replaceNode(node) {\n       context.currentNode = node\n       context.parent.children[context.childIndex] = node\n     },\n     // 用于删除当前节点。\n     removeNode() {\n       if (context.parent) {\n         // 调用数组的 splice 方法，根据当前节点的索引删除当前节点\n         context.parent.children.splice(context.childIndex, 1)\n         // 将 context.currentNode 置空\n         context.currentNode = null\n       }\n     },\n     nodeTransforms: [\n       transformElement,\n       transformText\n     ]\n   }\n<p>traverseNode(ast, context)<br />\nconsole.log(dump(ast))<br />\n}<br />\n</code></pre></p>\n<p>移除当前访问的节点也非常简单，只需要取得其位置索引 <code>context.childIndex</code>，再调用数组的 <code>splice</code> 方法将其从所属的 <code>children</code> 列表中移除即可。另外，当节点被移除之后，不要忘记将 <code>context.currentNode</code> 的值置空。这里有一点需要注意，由于当前节点被移除了，所以后续的转换函数将不再需要处理该节点。因此，我们需要对 <code>traverseNode</code> 函数做一些调整，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function traverseNode(ast, context) {\n   context.currentNode = ast\n<p>const transforms = context.nodeTransforms<br />\nfor (let i = 0; i &lt; transforms.length; i++) {<br />\ntransforms[i](context.currentNode, context)<br />\n// 由于任何转换函数都可能移除当前节点，因此每个转换函数执行完毕后，<br />\n// 都应该检查当前节点是否已经被移除，如果被移除了，直接返回即可<br />\nif (!context.currentNode) return<br />\n}</p>\n<p>const children = context.currentNode.children<br />\nif (children) {<br />\nfor (let i = 0; i &lt; children.length; i++) {<br />\ncontext.parent = context.currentNode<br />\ncontext.childIndex = i<br />\ntraverseNode(children[i], context)<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在修改后的 <code>traverseNode</code> 函数中，我们增加了一行代码，用于检查 <code>context.currentNode</code> 是否存在。由于任何转换函数都可能移除当前访问的节点，所以每个转换函数执行完毕后，都应该检查当前访问的节点是否已经被移除，如果被某个转换函数移除了，则 <code>traverseNode</code> 直接返回即可，无须做后续的处理。</p>\n<p>有了 <code>context.removeNode</code> 函数之后，我们即可实现用于移除文本节点的转换函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function transformText(node, context) {\n   if (node.type === 'Text') {\n     // 如果是文本节点，直接调用 context.removeNode 函数将其移除即可\n     context.removeNode()\n   }\n }\n</code></pre>\n<p>配合上面的 <code>transformText</code> 转换函数，运行下面的用例：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)\n transform(ast)\n</code></pre>\n<p>转换前后输出结果是：</p>\n<pre class=\"code-rows\"><code> // 转换前\n Root:\n --Element: div\n ----Element: p\n ------Text: VueVue\n ----Element: p\n ------Text: TemplateTemplate\n<p>// 转换后<br />\nRoot:<br />\n–Element: div<br />\n----Element: h1<br />\n----Element: h1<br />\n</code></pre></p>\n<p>可以看到，在转换后的 AST 中，将不再有任何文本节点。</p>\n<h3 id=\"nav_point_148\">15.4.3　进入与退出</h3>\n<p>在转换 AST 节点的过程中，往往需要根据其子节点的情况来决定如何对当前节点进行转换。这就要求父节点的转换操作必须等待其所有子节点全部转换完毕后再执行。然而，我们目前设计的转换工作流并不支持这一能力。上文中介绍的转换工作流，是一种从根节点开始、顺序执行的工作流，如图 15-22 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00631.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-22　顺序执行工作流</strong></p>\n<p>从图 15-22 中可以看到，<code>Root</code> 根节点第一个被处理，节点层次越深，对它的处理将越靠后。这种顺序处理的工作流存在的问题是，当一个节点被处理时，意味着它的父节点已经被处理完毕了，并且我们无法再回过头重新处理父节点。</p>\n<p>更加理想的转换工作流应该如图 15-23 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00632.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 15-23　更加理想的转换工作流</strong></p>\n<p>由图 15-23 可知，对节点的访问分为两个阶段，即进入阶段和退出阶段。当转换函数处于进入阶段时，它会先进入父节点，再进入子节点。而当转换函数处于退出阶段时，则会先退出子节点，再退出父节点。这样，只要我们在退出节点阶段对当前访问的节点进行处理，就一定能够保证其子节点全部处理完毕。</p>\n<p>为了实现如图 15-23 所示的转换工作流，我们需要重新设计转换函数的能力，如下面 <code>traverseNode</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function traverseNode(ast, context) {\n   context.currentNode = ast\n   // 1. 增加退出阶段的回调函数数组\n   const exitFns = []\n   const transforms = context.nodeTransforms\n   for (let i = 0; i &lt; transforms.length; i++) {\n     // 2. 转换函数可以返回另外一个函数，该函数即作为退出阶段的回调函数\n     const onExit = transforms[i](context.currentNode, context)\n     if (onExit) {\n       // 将退出阶段的回调函数添加到 exitFns 数组中\n       exitFns.push(onExit)\n     }\n     if (!context.currentNode) return\n   }\n<p>const children = context.currentNode.children<br />\nif (children) {<br />\nfor (let i = 0; i &lt; children.length; i++) {<br />\ncontext.parent = context.currentNode<br />\ncontext.childIndex = i<br />\ntraverseNode(children[i], context)<br />\n}<br />\n}</p>\n<p>// 在节点处理的最后阶段执行缓存到 exitFns 中的回调函数<br />\n// 注意，这里我们要反序执行<br />\nlet i = exitFns.length<br />\nwhile (i–) {<br />\nexitFns<a href=\"\">i</a><br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们增加了一个数组 <code>exitFns</code>，用来存储由转换函数返回的回调函数。接着，在 <code>traverseNode</code> 函数的最后，执行这些缓存在 <code>exitFns</code> 数组中的回调函数。这样就保证了，<strong>当退出阶段的回调函数执行时，当前访问的节点的子节点已经全部处理过了</strong>。有了这些能力之后，我们在编写转换函数时，可以将转换逻辑编写在退出阶段的回调函数中，从而保证在对当前访问的节点进行转换之前，其子节点一定全部处理完毕了，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function transformElement(node, context) {\n   // 进入节点\n<p>// 返回一个会在退出节点时执行的回调函数<br />\nreturn () =&gt; {<br />\n// 在这里编写退出节点的逻辑，当这里的代码运行时，当前转换节点的子节点一定处理完毕了<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>另外还有一点需要注意，退出阶段的回调函数是反序执行的。这意味着，如果注册了多个转换函数，则它们的注册顺序将决定代码的执行结果。假设我们注册的两个转换函数分别是 <code>transformA</code> 和 <code>transformB</code>，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function transform(ast) {\n   const context = {\n     // 省略部分代码\n<pre><code> // 注册两个转换函数，transformA 先于 transformB\n nodeTransforms: [\n   transformA,\n   transformB\n ]\n</code></pre>\n<p>}</p>\n<p>traverseNode(ast, context)<br />\nconsole.log(dump(ast))<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，转换函数 <code>transformA</code> 先于 <code>transformB</code> 被注册。这意味着，在执行转换时，<code>transformA</code> 的“进入阶段”会先于 <code>transformB</code> 的“进入阶段”执行，而 <code>transformA</code> 的“退出阶段”将晚于 <code>transformB</code> 的“退出阶段”执行：</p>\n<pre class=\"code-rows\"><code> -- transformA 进入阶段执行\n ---- transformB 进入阶段执行\n ---- transformB 退出阶段执行\n -- transformA 退出阶段执行\n</code></pre>\n<p>这么设计的好处是，转换函数 <code>transformA</code> 将有机会等待 <code>transformB</code> 执行完毕后，再根据具体情况决定应该如何工作。</p>\n<p>如果将 <code>transformA</code> 与 <code>transformB</code> 的顺序调换，那么转换函数的执行顺序也将改变：</p>\n<pre class=\"code-rows\"><code> -- transformB 进入阶段执行\n ---- transformA 进入阶段执行\n ---- transformA 退出阶段执行\n -- transformB 退出阶段执行\n</code></pre>\n<p>由此可见，当把转换逻辑编写在转换函数的退出阶段时，不仅能够保证所有子节点全部处理完毕，还能够保证所有后续注册的转换函数执行完毕。</p>\n<h2 id=\"nav_point_149\">15.5　将模板 AST 转为 JavaScript AST</h2>\n<p>在上一节中，我们讨论了如何对 AST 进行转换，并实现了一个基本的插件架构，即通过注册自定义的转换函数实现对 AST 的操作。本节，我们将讨论如何将模板 AST 转换为 JavaScript AST，为后续讲解代码生成做铺垫。</p>\n<p>为什么要将模板 AST 转换为 JavaScript AST 呢？原因我们已经多次提到：我们需要将模板编译为渲染函数。而渲染函数是由 JavaScript 代码来描述的，因此，我们需要将模板 AST 转换为用于描述渲染函数的 JavaScript AST。</p>\n<p>以上一节给出的模板为例：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;\n</code></pre>\n<p>与这段模板等价的渲染函数是：</p>\n<pre class=\"code-rows\"><code> function render() {\n   return h('div', [\n     h('p', 'Vue'),\n     h('p', 'Template')\n   ])\n }\n</code></pre>\n<p>上面这段渲染函数的 JavaScript 代码所对应的 JavaScript AST 就是我们的转换目标。那么，它对应的 JavaScript AST 是什么样子的呢？与模板 AST 是模板的描述一样，JavaScript AST 是 JavaScript 代码的描述。所以，本质上我们需要设计一些数据结构来描述渲染函数的代码。</p>\n<p>首先，我们观察上面这段渲染函数的代码。它是一个函数声明，所以我们首先要描述 JavaScript 中的函数声明语句。一个函数声明语句由以下几部分组成。</p>\n<ul>\n<li><code>id</code>：函数名称，它是一个标识符 <code>Identifier</code>。</li>\n<li><code>params</code>：函数的参数，它是一个数组。</li>\n<li><code>body</code>：函数体，由于函数体可以包含多个语句，因此它也是一个数组。</li>\n</ul>\n<p>为了简化问题，这里我们不考虑箭头函数、生成器函数、async 函数等情况。那么，根据以上这些信息，我们就可以设计一个基本的数据结构来描述函数声明语句：</p>\n<pre class=\"code-rows\"><code> const FunctionDeclNode = {\n   type: 'FunctionDecl' // 代表该节点是函数声明\n   // 函数的名称是一个标识符，标识符本身也是一个节点\n   id: {\n     type: 'Identifier',\n     name: 'render' // name 用来存储标识符的名称，在这里它就是渲染函数的名称 render\n   },\n   params: [], // 参数，目前渲染函数还不需要参数，所以这里是一个空数组\n   // 渲染函数的函数体只有一个语句，即 return 语句\n   body: [\n     {\n       type: 'ReturnStatement',\n       return: null // 暂时留空，在后续讲解中补全\n     }\n   ]\n }\n</code></pre>\n<p>如上面的代码所示，我们使用一个对象来描述一个 JavaScript AST 节点。每个节点都具有 <code>type</code> 字段，该字段用来代表节点的类型。对于函数声明语句来说，它的类型是 <code>FunctionDecl</code>。接着，我们使用 <code>id</code> 字段来存储函数的名称。函数的名称应该是一个合法的标识符，因此 <code>id</code> 字段本身也是一个类型为 <code>Identifier</code> 的节点。当然，我们在设计 JavaScript AST 的时候，可以根据实际需要进行调整。例如，我们完全可以将 <code>id</code> 字段设计为一个字符串类型的值。这样做虽然不完全符合 JavaScript 的语义，但是能够满足我们的需求。对于函数的参数，我们使用 <code>params</code> 数组来存储。目前，我们设计的渲染函数还不需要参数，因此暂时设为空数组。最后，我们使用 <code>body</code> 字段来描述函数的函数体。一个函数的函数体内可以存在多个语句，所以我们使用一个数组来描述它。该数组内的每个元素都对应一条语句，对于渲染函数来说，目前它只有一个返回语句，所以我们使用一个类型为 <code>ReturnStatement</code> 的节点来描述该返回语句。</p>\n<p>介绍完函数声明语句的节点结构后，我们再来看一下渲染函数的返回值。渲染函数返回的是虚拟 DOM 节点，具体体现在 <code>h</code> 函数的调用。我们可以使用 <code>CallExpression</code> 类型的节点来描述函数调用语句，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const CallExp = {\n   type: 'CallExpression',\n   // 被调用函数的名称，它是一个标识符\n   callee: {\n     type: 'Identifier',\n     name: 'h'\n   },\n   // 参数\n   arguments: []\n }\n</code></pre>\n<p>类型为 <code>CallExpression</code> 的节点拥有两个属性。</p>\n<ul>\n<li><code>callee</code>：用来描述被调用函数的名称，它本身是一个标识符节点。</li>\n<li><code>arguments</code>：被调用函数的形式参数，多个参数的话用数组来描述。</li>\n</ul>\n<p>我们再次观察渲染函数的返回值：</p>\n<pre class=\"code-rows\"><code> function render() {\n   // h 函数的第一个参数是一个字符串字面量\n   // h 函数的第二个参数是一个数组\n   return h('div', [/*...*/])\n }\n</code></pre>\n<p>可以看到，最外层的 <code>h</code> 函数的第一个参数是一个字符串字面量，我们可以使用类型为 <code>StringLiteral</code> 的节点来描述它：</p>\n<pre class=\"code-rows\"><code> const Str = {\n   type: 'StringLiteral',\n   value: 'div'\n }\n</code></pre>\n<p>最外层的 <code>h</code> 函数的第二个参数是一个数组，我们可以使用类型为 <code>ArrayExpression</code> 的节点来描述它：</p>\n<pre class=\"code-rows\"><code> const Arr = {\n   type: 'ArrayExpression',\n   // 数组中的元素\n   elements: []\n }\n</code></pre>\n<p>使用上述 <code>CallExpression</code>、<code>StringLiteral</code>、<code>ArrayExpression</code> 等节点来填充渲染函数的返回值，其最终结果如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const FunctionDeclNode = {\n   type: 'FunctionDecl' // 代表该节点是函数声明\n   // 函数的名称是一个标识符，标识符本身也是一个节点\n   id: {\n     type: 'Identifier',\n     name: 'render' // name 用来存储标识符的名称，在这里它就是渲染函数的名称 render\n   },\n   params: [], // 参数，目前渲染函数还不需要参数，所以这里是一个空数组\n   // 渲染函数的函数体只有一个语句，即 return 语句\n   body: [\n     {\n       type: 'ReturnStatement',\n       // 最外层的 h 函数调用\n       return: {\n         type: 'CallExpression',\n         callee: { type: 'Identifier', name: 'h' },\n         arguments: [\n           // 第一个参数是字符串字面量 'div'\n           {\n             type: 'StringLiteral',\n             value: 'div'\n           },\n           // 第二个参数是一个数组\n           {\n             type: 'ArrayExpression',\n             elements: [\n               // 数组的第一个元素是 h 函数的调用\n               {\n                 type: 'CallExpression',\n                 callee: { type: 'Identifier', name: 'h' },\n                 arguments: [\n                   // 该 h 函数调用的第一个参数是字符串字面量\n                   { type: 'StringLiteral', value: 'p' },\n                   // 第二个参数也是一个字符串字面量\n                   { type: 'StringLiteral', value: 'Vue' },\n                 ]\n               },\n               // 数组的第二个元素也是 h 函数的调用\n               {\n                 type: 'CallExpression',\n                 callee: { type: 'Identifier', name: 'h' },\n                 arguments: [\n                   // 该 h 函数调用的第一个参数是字符串字面量\n                   { type: 'StringLiteral', value: 'p' },\n                   // 第二个参数也是一个字符串字面量\n                   { type: 'StringLiteral', value: 'Template' },\n                 ]\n               }\n             ]\n           }\n         ]\n       }\n     }\n   ]\n }\n</code></pre>\n<p>如上面这段 JavaScript AST 的代码所示，它是对渲染函数代码的完整描述。接下来我们的任务是，编写转换函数，将模板 AST 转换为上述 JavaScript AST。不过在开始之前，我们需要编写一些用来创建 JavaScript AST 节点的辅助函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 用来创建 StringLiteral 节点\n function createStringLiteral(value) {\n   return {\n     type: 'StringLiteral',\n     value\n   }\n }\n // 用来创建 Identifier 节点\n function createIdentifier(name) {\n   return {\n     type: 'Identifier',\n     name\n   }\n }\n // 用来创建 ArrayExpression 节点\n function createArrayExpression(elements) {\n   return {\n     type: 'ArrayExpression',\n     elements\n   }\n }\n // 用来创建 CallExpression 节点\n function createCallExpression(callee, arguments) {\n   return {\n     type: 'CallExpression',\n     callee: createIdentifier(callee),\n     arguments\n   }\n }\n</code></pre>\n<p>有了这些辅助函数，我们可以更容易地编写转换代码。</p>\n<p>为了把模板 AST 转换为 JavaScript AST，我们同样需要两个转换函数：<code>transformElement</code> 和 <code>transformText</code>，它们分别用来处理标签节点和文本节点。具体实现如下：</p>\n<pre class=\"code-rows\"><code> // 转换文本节点\n function transformText(node) {\n   // 如果不是文本节点，则什么都不做\n   if (node.type !== 'Text') {\n     return\n   }\n   // 文本节点对应的 JavaScript AST 节点其实就是一个字符串字面量，\n   // 因此只需要使用 node.content 创建一个 StringLiteral 类型的节点即可\n   // 最后将文本节点对应的 JavaScript AST 节点添加到 node.jsNode 属性下\n   node.jsNode = createStringLiteral(node.content)\n }\n<p>// 转换标签节点<br />\nfunction transformElement(node) {<br />\n// 将转换代码编写在退出阶段的回调函数中，<br />\n// 这样可以保证该标签节点的子节点全部被处理完毕<br />\nreturn () =&gt; {<br />\n// 如果被转换的节点不是元素节点，则什么都不做<br />\nif (node.type !== ‘Element’) {<br />\nreturn<br />\n}</p>\n<pre><code> // 1. 创建 h 函数调用语句,\n // h 函数调用的第一个参数是标签名称，因此我们以 node.tag 来创建一个字符串字面量节点\n // 作为第一个参数\n const callExp = createCallExpression('h', [\n   createStringLiteral(node.tag)\n ])\n // 2. 处理 h 函数调用的参数\n node.children.length === 1\n   // 如果当前标签节点只有一个子节点，则直接使用子节点的 jsNode 作为参数\n   ? callExp.arguments.push(node.children[0].jsNode)\n   // 如果当前标签节点有多个子节点，则创建一个 ArrayExpression 节点作为参数\n   : callExp.arguments.push(\n     // 数组的每个元素都是子节点的 jsNode\n     createArrayExpression(node.children.map(c =&amp;gt; c.jsNode))\n   )\n // 3. 将当前标签节点对应的 JavaScript AST 添加到 jsNode 属性下\n node.jsNode = callExp\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码及注释所示，总体实现并不复杂。有两点需要注意：</p>\n<ul>\n<li>在转换标签节点时，我们需要将转换逻辑编写在退出阶段的回调函数内，这样才能保证其子节点全部被处理完毕；</li>\n<li>无论是文本节点还是标签节点，它们转换后的 JavaScript AST 节点都存储在节点的 <code>node.jsNode</code> 属性下。</li>\n</ul>\n<p>使用上面两个转换函数即可完成标签节点和文本节点的转换，即把模板转换成 <code>h</code> 函数的调用。但是，转换后得到的 AST 只是用来描述渲染函数 <code>render</code> 的返回值的，所以我们最后一步要做的就是，补全 JavaScript AST，即把用来描述 <code>render</code> 函数本身的函数声明语句节点附加到 JavaScript AST 中。这需要我们编写 <code>transformRoot</code> 函数来实现对 <code>Root</code> 根节点的转换：</p>\n<pre class=\"code-rows\"><code> // 转换 Root 根节点\n function transformRoot(node) {\n   // 将逻辑编写在退出阶段的回调函数中，保证子节点全部被处理完毕\n   return () =&gt; {\n     // 如果不是根节点，则什么都不做\n     if (node.type !== 'Root') {\n       return\n     }\n     // node 是根节点，根节点的第一个子节点就是模板的根节点，\n     // 当然，这里我们暂时不考虑模板存在多个根节点的情况\n     const vnodeJSAST = node.children[0].jsNode\n     // 创建 render 函数的声明语句节点，将 vnodeJSAST 作为 render 函数体的返回语句\n     node.jsNode = {\n       type: 'FunctionDecl',\n       id: { type: 'Identifier', name: 'render' },\n       params: [],\n       body: [\n         {\n           type: 'ReturnStatement',\n           return: vnodeJSAST\n         }\n       ]\n     }\n   }\n }\n</code></pre>\n<p>经过这一步处理之后，模板 AST 将转换为对应的 JavaScript AST，并且可以通过根节点的 <code>node.jsNode</code> 来访问转换后的 JavaScript AST。下一节我们将讨论如何根据转换后得到的 JavaScript AST 生成渲染函数代码。</p>\n<h2 id=\"nav_point_150\">15.6　代码生成</h2>\n<p>在上一节中，我们完成了 JavaScript AST 的构造。本节，我们将讨论如何根据 JavaScript AST 生成渲染函数的代码，即代码生成。代码生成本质上是字符串拼接的艺术。我们需要访问 JavaScript AST 中的节点，为每一种类型的节点生成相符的 JavaScript 代码。</p>\n<p>本节，我们将实现 <code>generate</code> 函数来完成代码生成的任务。代码生成也是编译器的最后一步：</p>\n<pre class=\"code-rows\"><code> function compile(template) {\n   // 模板 AST\n   const ast = parse(template)\n   // 将模板 AST 转换为 JavaScript AST\n   transform(ast)\n   // 代码生成\n   const code = generate(ast.jsNode)\n<p>return code<br />\n}<br />\n</code></pre></p>\n<p>与 AST 转换一样，代码生成也需要上下文对象。该上下文对象用来维护代码生成过程中程序的运行状态，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function generate(node) {\n   const context = {\n     // 存储最终生成的渲染函数代码\n     code: '',\n     // 在生成代码时，通过调用 push 函数完成代码的拼接\n     push(code) {\n       context.code += code\n     }\n   }\n<p>// 调用 genNode 函数完成代码生成的工作，<br />\ngenNode(node, context)</p>\n<p>// 返回渲染函数代码<br />\nreturn context.code<br />\n}<br />\n</code></pre></p>\n<p>在上面这段 <code>generate</code> 函数的代码中，首先我们定义了上下文对象 <code>context</code>，它包含 <code>context.code</code> 属性，用来存储最终生成的渲染函数代码，还定义了 <code>context.push</code> 函数，用来完成代码拼接，接着调用 <code>genNode</code> 函数完成代码生成的工作，最后将最终生成的渲染函数代码返回。</p>\n<p>另外，我们希望最终生成的代码具有较强的可读性，因此我们应该考虑生成代码的格式，例如缩进和换行等。这就需要我们扩展 <code>context</code> 对象，为其增加用来完成换行和缩进的工具函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function generate(node) {\n   const context = {\n     code: '',\n     push(code) {\n       context.code += code\n     },\n     // 当前缩进的级别，初始值为 0，即没有缩进\n     currentIndent: 0,\n     // 该函数用来换行，即在代码字符串的后面追加 \\n 字符，\n     // 另外，换行时应该保留缩进，所以我们还要追加 currentIndent * 2 个空格字符\n     newline() {\n       context.code += '\\n' + `  `.repeat(context.currentIndent)\n     },\n     // 用来缩进，即让 currentIndent 自增后，调用换行函数\n     indent() {\n       context.currentIndent++\n       context.newline()\n     },\n     // 取消缩进，即让 currentIndent 自减后，调用换行函数\n     deIndent() {\n       context.currentIndent--\n       context.newline()\n     }\n   }\n<p>genNode(node, context)</p>\n<p>return context.code<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们增加了 <code>context.currentIndent</code> 属性，它代表缩进的级别，初始值为 <code>0</code>，代表没有缩进，还增加了 <code>context.newline()</code> 函数，每次调用该函数时，都会在代码字符串后面追加换行符 <code>\\n</code>。由于换行时需要保留缩进，所以我们还要追加 <code>context.currentIndent * 2</code> 个空格字符。这里我们假设缩进为两个空格字符，后续我们可以将其设计为可配置的。同时，我们还增加了 <code>context.indent()</code> 函数用来完成代码缩进，它的原理很简单，即让缩进级别 <code>context.currentIndent</code> 进行自增，再调用 <code>context.newline()</code> 函数。与之对应的 <code>context.deIndent()</code> 函数则用来取消缩进，即让缩进级别 <code>context.currentIndent</code> 进行自减，再调用 <code>context.newline()</code> 函数。</p>\n<p>有了这些基础能力之后，我们就可以开始编写 <code>genNode</code> 函数来完成代码生成的工作了。代码生成的原理其实很简单，只需要匹配各种类型的 JavaScript AST 节点，并调用对应的生成函数即可，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function genNode(node, context) {\n   switch (node.type) {\n     case 'FunctionDecl':\n       genFunctionDecl(node, context)\n       break\n     case 'ReturnStatement':\n       genReturnStatement(node, context)\n       break\n     case 'CallExpression':\n       genCallExpression(node, context)\n       break\n     case 'StringLiteral':\n       genStringLiteral(node, context)\n       break\n     case 'ArrayExpression':\n       genArrayExpression(node, context)\n       break\n   }\n }\n</code></pre>\n<p>在 <code>genNode</code> 函数内部，我们使用 <code>switch</code> 语句来匹配不同类型的节点，并调用与之对应的生成器函数。</p>\n<ul>\n<li>对于 <code>FunctionDecl</code> 节点，使用 <code>genFunctionDecl</code> 函数为该类型节点生成对应的 JavaScript 代码。</li>\n<li>对于 <code>ReturnStatement</code> 节点，使用 <code>genReturnStatement</code> 函数为该类型节点生成对应的 JavaScript 代码。</li>\n<li>对于 <code>CallExpression</code> 节点，使用 <code>genCallExpression</code> 函数为该类型节点生成对应的 JavaScript 代码。</li>\n<li>对于 <code>StringLiteral</code> 节点，使用 <code>genStringLiteral</code> 函数为该类型节点生成对应的 JavaScript 代码。</li>\n<li>对于 <code>ArrayExpression</code> 节点，使用 <code>genArrayExpression</code> 函数为该类型节点生成对应的 JavaScript 代码。</li>\n</ul>\n<p>由于我们目前只涉及这五种类型的 JavaScript 节点，所以现在的 <code>genNode</code> 函数足够完成上述案例。当然，如果后续需要增加节点类型，只需要在 <code>genNode</code> 函数中添加相应的处理分支即可。</p>\n<p>接下来，我们将逐步完善代码生成工作。首先，我们来实现函数声明语句的代码生成，即 <code>genFunctionDecl</code> 函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function genFunctionDecl(node, context) {\n   // 从 context 对象中取出工具函数\n   const { push, indent, deIndent } = context\n   // node.id 是一个标识符，用来描述函数的名称，即 node.id.name\n   push(`function $ `)\n   push(`(`)\n   // 调用 genNodeList 为函数的参数生成代码\n   genNodeList(node.params, context)\n   push(`) `)\n   push(`{`)\n   // 缩进\n   indent()\n   // 为函数体生成代码，这里递归地调用了 genNode 函数\n   node.body.forEach(n =&gt; genNode(n, context))\n   // 取消缩进\n   deIndent()\n   push(`}`)\n }\n</code></pre>\n<p><code>genFunctionDecl</code> 函数用来为函数声明类型的节点生成对应的 JavaScript 代码。以渲染函数的声明节点为例，它最终生成的代码将会是：</p>\n<pre class=\"code-rows\"><code> function render () {\n   ... 函数体\n }\n</code></pre>\n<p>另外我们注意到，在 <code>genFunctionDecl</code> 函数内部调用了 <code>genNodeList</code> 函数来为函数的参数生成对应的代码。它的实现如下：</p>\n<pre class=\"code-rows\"><code> function genNodeList(nodes, context) {\n   const { push } = context\n   for (let i = 0; i &lt; nodes.length; i++) {\n     const node = nodes[i]\n     genNode(node, context)\n     if (i &lt; nodes.length - 1) {\n       push(', ')\n     }\n   }\n }\n</code></pre>\n<p><code>genNodeList</code> 函数接收一个节点数组作为参数，并为每一个节点递归地调用 <code>genNode</code> 函数完成代码生成工作。这里要注意的一点是，每处理完一个节点，需要在生成的代码后面拼接逗号字符（<code>,</code>）。举例来说：</p>\n<pre class=\"code-rows\"><code> // 如果节点数组为\n const node = [节点 1， 节点 2， 节点 3]\n // 那么生成的代码将类似于\n '节点 1，节点 2，节点 3'\n // 如果在这段代码的前后分别添加圆括号，那么它将可用于函数的参数声明\n ('节点 1，节点 2，节点 3')\n // 如果在这段代码的前后分别添加方括号，那么它将是一个数组\n ['节点 1，节点 2，节点 3']\n</code></pre>\n<p>由上例可知，<code>genNodeList</code> 函数会在节点代码之间补充逗号字符。实际上，<code>genArrayExpression</code> 函数就利用了这个特点来实现对数组表达式的代码生成，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function genArrayExpression(node, context) {\n   const { push } = context\n   // 追加方括号\n   push('[')\n   // 调用 genNodeList 为数组元素生成代码\n   genNodeList(node.elements, context)\n   // 补全方括号\n   push(']')\n }\n</code></pre>\n<p>不过，由于目前渲染函数暂时没有接收任何参数，所以 <code>genNodeList</code> 函数不会为其生成任何代码。对于 <code>genFunctionDecl</code> 函数，另外需要注意的是，由于函数体本身也是一个节点数组，所以我们需要遍历它并递归地调用 <code>genNode</code> 函数生成代码。</p>\n<p>对于 <code>ReturnStatement</code> 和 <code>StringLiteral</code> 类型的节点来说，为它们生成代码很简单，如下所示：</p>\n<pre class=\"code-rows\"><code> function genReturnStatement(node, context) {\n   const { push } = context\n   // 追加 return 关键字和空格\n   push(`return `)\n   // 调用 genNode 函数递归地生成返回值代码\n   genNode(node.return, context)\n }\n<p>function genStringLiteral(node, context) {<br />\nconst { push } = context<br />\n// 对于字符串字面量，只需要追加与 node.value 对应的字符串即可<br />\npush(<code>'$'</code>)<br />\n}<br />\n</code></pre></p>\n<p>最后，只剩下 <code>genCallExpression</code> 函数了，它的实现如下：</p>\n<pre class=\"code-rows\"><code> function genCallExpression(node, context) {\n   const { push } = context\n   // 取得被调用函数名称和参数列表\n   const { callee, arguments: args } = node\n   // 生成函数调用代码\n   push(`$(`)\n   // 调用 genNodeList 生成参数代码\n   genNodeList(args, context)\n   // 补全括号\n   push(`)`)\n }\n</code></pre>\n<p>可以看到，在 <code>genCallExpression</code> 函数内，我们也用到了 <code>genNodeList</code> 函数来为函数调用时的参数生成对应的代码。配合上述生成器函数的实现，我们将得到符合预期的渲染函数代码。运行如下测试用例：</p>\n<pre class=\"code-rows\"><code> const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)\n transform(ast)\n const code = generate(ast.jsNode)\n</code></pre>\n<p>最终得到的代码字符串如下：</p>\n<pre class=\"code-rows\"><code> function render () {\n   return h('div', [h('p', 'Vue'), h('p', 'Template')])\n }\n</code></pre>\n<h2 id=\"nav_point_151\">15.7　总结</h2>\n<p>在本章中，我们首先讨论了 Vue.js 模板编译器的工作流程。Vue.js 的模板编译器用于把模板编译为渲染函数。它的工作流程大致分为三个步骤。</p>\n<p>(1) 分析模板，将其解析为模板 AST。</p>\n<p>(2) 将模板 AST 转换为用于描述渲染函数的 JavaScript AST。</p>\n<p>(3) 根据 JavaScript AST 生成渲染函数代码。</p>\n<p>接着，我们讨论了 <code>parser</code> 的实现原理，以及如何用有限状态自动机构造一个词法分析器。词法分析的过程就是状态机在不同状态之间迁移的过程。在此过程中，状态机会产生一个个 Token，形成一个 Token 列表。我们将使用该 Token 列表来构造用于描述模板的 AST。具体做法是，扫描 Token 列表并维护一个开始标签栈。每当扫描到一个开始标签节点，就将其压入栈顶。栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有 Token 扫描完毕后，即可构建出一棵树型 AST。</p>\n<p>然后，我们讨论了 AST 的转换与插件化架构。AST 是树型数据结构，为了访问 AST 中的节点，我们采用深度优先的方式对 AST 进行遍历。在遍历过程中，我们可以对 AST 节点进行各种操作，从而实现对 AST 的转换。为了解耦节点的访问和操作，我们设计了插件化架构，将节点的操作封装到独立的转换函数中。这些转换函数可以通过 <code>context.nodeTransforms</code> 来注册。这里的 <code>context</code> 称为转换上下文。上下文对象中通常会维护程序的当前状态，例如当前访问的节点、当前访问的节点的父节点、当前访问的节点的位置索引等信息。有了上下文对象及其包含的重要信息后，我们即可轻松地实现节点的替换、删除等能力。但有时，当前访问节点的转换工作依赖于其子节点的转换结果，所以为了优先完成子节点的转换，我们将整个转换过程分为“进入阶段”与“退出阶段”。每个转换函数都分两个阶段执行，这样就可以实现更加细粒度的转换控制。</p>\n<p>之后，我们讨论了如何将模板 AST 转换为用于描述渲染函数的 JavaScript AST。模板 AST 用来描述模板，类似地，JavaScript AST 用于描述 JavaScript 代码。只有把模板 AST 转换为 JavaScript AST 后，我们才能据此生成最终的渲染函数代码。</p>\n<p>最后，我们讨论了渲染函数代码的生成工作。代码生成是模板编译器的最后一步工作，生成的代码将作为组件的渲染函数。代码生成的过程就是字符串拼接的过程。我们需要为不同的 AST 节点编写对应的代码生成函数。为了让生成的代码具有更强的可读性，我们还讨论了如何对生成的代码进行缩进和换行。我们将用于缩进和换行的代码封装为工具函数，并且定义到代码生成过程中的上下文对象中。</p>\n<br style=\"page-break-after:always\" />","comments":[]}