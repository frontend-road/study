{"id":91550,"title":"12 | 进程数据结构（上）：项目多了就需要项目管理系统","content":"<p>前面两节，我们讲了如何使用系统调用，创建进程和线程。你是不是觉得进程和线程管理，还挺复杂的呢？如此复杂的体系，在内核里面应该如何管理呢？</p><p>有的进程只有一个线程，有的进程有多个线程，它们都需要由内核分配CPU来干活。可是CPU总共就这么几个，应该怎么管理，怎么调度呢？你是老板，这个事儿得你来操心。</p><p>首先，我们得明确，公司的项目售前售后人员，接来了这么多的项目，这是个好事儿。这些项目都通过办事大厅立了项的，有的需要整个项目组一起开发，有的是一个项目组分成多个小组并行开发。无论哪种模式，到你这个老板这里，都需要有一个项目管理体系，进行统一排期、统一管理和统一协调。这样，你才能对公司的业务了如指掌。</p><p>那具体应该怎么做呢？还记得咱们平时开发的时候，用的项目管理软件Jira吧？它的办法对我们来讲，就很有参考意义。</p><p>我们这么来看，其实，无论是一个大的项目组一起完成一个大的功能（单体应用模式），还是把一个大的功能拆成小的功能并行开发（微服务模式），这些都是开发组根据客户的需求来定的，项目经理没办法决定，但是从项目经理的角度来看，这些都是任务，需要同样关注进度、协调资源等等。</p><p>同样在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构<strong>task_struct</strong>进行管理。这个结构非常复杂，但你也不用怕，我们慢慢来解析。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/75/2d/75c4d28a9d2daa4acc1107832be84e2d.jpeg?wh=2206*1732\" alt=\"\"></p><p>接下来，我们沿着建立项目管理体系的思路，设想一下，<strong>Linux的任务管理都应该干些啥？</strong></p><p>首先，所有执行的项目应该有个项目列表吧，所以Linux内核也应该先弄一个<strong>链表</strong>，将所有的task_struct串起来。</p><pre><code>struct list_head\t\ttasks;\n</code></pre><p>接下来，我们来看每一个任务都应该包含哪些字段。</p><h2>任务ID</h2><p>每一个任务都应该有一个ID，作为这个任务的唯一标识。到时候排期啊、下发任务啊等等，都按ID来，就不会产生歧义。</p><p>task_struct里面涉及任务ID的，有下面几个：</p><pre><code>pid_t pid;\npid_t tgid;\nstruct task_struct *group_leader; \n</code></pre><p>你可能觉得奇怪，既然是ID，有一个就足以做唯一标识了，这个怎么看起来这么麻烦？这是因为，上面的进程和线程到了内核这里，统一变成了任务，这就带来两个问题。</p><p>第一个问题是，<strong>任务展示</strong>。</p><p>啥是任务展示呢？这么说吧，你作为老板，想了解的肯定是，公司都接了哪些项目，每个项目多少营收。什么项目执行是不是分了小组，每个小组是啥情况，这些细节，项目经理没必要全都展示给你看。</p><p>前面我们学习命令行的时候，知道ps命令可以展示出所有的进程。但是如果你是这个命令的实现者，到了内核，按照上面的任务列表把这些命令都显示出来，把所有的线程全都平摊开来显示给用户。用户肯定觉得既复杂又困惑。复杂在于，列表这么长；困惑在于，里面出现了很多并不是自己创建的线程。</p><p>第二个问题是，<strong>给任务下发指令</strong>。</p><p>如果客户突然给项目组提个新的需求，比如说，有的客户觉得项目已经完成，可以终止；再比如说，有的客户觉得项目做到一半没必要再进行下去了，可以中止，这时候应该给谁发指令？当然应该给整个项目组，而不是某个小组。我们不能让客户看到，不同的小组口径不一致。这就好比说，中止项目的指令到达一个小组，这个小组很开心就去休息了，同一个项目组的其他小组还干的热火朝天的。</p><p>Linux也一样，前面我们学习命令行的时候，知道可以通过kill来给进程发信号，通知进程退出。如果发给了其中一个线程，我们就不能只退出这个线程，而是应该退出整个进程。当然，有时候，我们希望只给某个线程发信号。</p><p>所以在内核中，它们虽然都是任务，但是应该加以区分。其中，pid是process id，tgid是thread group ID。</p><p>任何一个进程，如果只有主线程，那pid是自己，tgid是自己，group_leader指向的还是自己。</p><p>但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的pid，tgid就是进程的主线程的pid，group_leader指向的就是进程的主线程。</p><p>好了，有了tgid，我们就知道tast_struct代表的是一个进程还是代表一个线程了。</p><h2>信号处理</h2><p>这里既然提到了下发指令的问题，我就顺便提一下task_struct里面关于信号处理的字段。</p><pre><code>/* Signal handlers: */\nstruct signal_struct\t\t*signal;\nstruct sighand_struct\t\t*sighand;\nsigset_t\t\t\tblocked;\nsigset_t\t\t\treal_blocked;\nsigset_t\t\t\tsaved_sigmask;\nstruct sigpending\t\tpending;\nunsigned long\t\t\tsas_ss_sp;\nsize_t\t\t\t\tsas_ss_size;\nunsigned int\t\t\tsas_ss_flags;\n</code></pre><p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p><p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是sas_ss_xxx这三个变量的作用。</p><p>上面我说了下发信号的时候，需要区分进程和线程。从这里我们其实也能看出一些端倪。</p><p>task_struct里面有一个struct sigpending pending。如果我们进入struct signal_struct *signal去看的话，还有一个struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。</p><p>关于信号，你暂时了解到这里就够用了，后面我们会有单独的章节进行解读。</p><h2>任务状态</h2><p>作为一个项目经理，另外一个需要关注的是项目当前的状态。例如，在Jira里面，任务的运行就可以分成下面的状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/21/e0019fcd11ff1ba33a3389e285b6a121.jpg?wh=1678*993\" alt=\"\"></p><p>在task_struct里面，涉及任务状态的是下面这几个变量：</p><pre><code> volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */\n int exit_state;\n unsigned int flags;\n</code></pre><p>state（状态）可以取的值定义在include/linux/sched.h头文件中。</p><pre><code>/* Used in tsk-&gt;state: */\n#define TASK_RUNNING                    0\n#define TASK_INTERRUPTIBLE              1\n#define TASK_UNINTERRUPTIBLE            2\n#define __TASK_STOPPED                  4\n#define __TASK_TRACED                   8\n/* Used in tsk-&gt;exit_state: */\n#define EXIT_DEAD                       16\n#define EXIT_ZOMBIE                     32\n#define EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)\n/* Used in tsk-&gt;state again: */\n#define TASK_DEAD                       64\n#define TASK_WAKEKILL                   128\n#define TASK_WAKING                     256\n#define TASK_PARKED                     512\n#define TASK_NOLOAD                     1024\n#define TASK_NEW                        2048\n#define TASK_STATE_MAX                  4096\n</code></pre><p>从定义的数值很容易看出来，state是通过bitset的方式设置的，也就是说，当前是什么状态，哪一位就置一。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/88/e2fa348c67ce41ef730048ff9ca4c988.jpeg?wh=2050*2017\" alt=\"\"></p><p>TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片。</p><p>在运行中的进程，一旦要进行一些I/O操作，需要等待I/O完毕，这个时候会释放CPU，进入睡眠状态。</p><p>在Linux中，有两种睡眠状态。</p><p>一种是<strong>TASK_INTERRUPTIBLE</strong>，<strong>可中断的睡眠状态</strong>。这是一种浅睡眠的状态，也就是说，虽然在睡眠，等待I/O完成，但是这个时候一个信号来的时候，进程还是要被唤醒。只不过唤醒后，不是继续刚才的操作，而是进行信号处理。当然程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个I/O操作完成，直接退出；或者收到某些信息，继续等待。</p><p>另一种睡眠是<strong>TASK_UNINTERRUPTIBLE</strong>，<strong>不可中断的睡眠状态</strong>。这是一种深度睡眠状态，不可被信号唤醒，只能死等I/O操作完成。一旦I/O操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。你可能会说，我kill它呢？别忘了，kill本身也是一个信号，既然这个状态不可被信号唤醒，kill信号也被忽略了。除非重启电脑，没有其他办法。</p><p>因此，这其实是一个比较危险的事情，除非程序员极其有把握，不然还是不要设置成TASK_UNINTERRUPTIBLE。</p><p>于是，我们就有了一种新的进程睡眠状态，<strong>TASK_KILLABLE，可以终止的新睡眠状态</strong>。进程处于这种状态中，它的运行原理类似TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。</p><p>从定义可以看出，TASK_WAKEKILL用于在接收到致命信号时唤醒进程，而TASK_KILLABLE相当于这两位都设置了。</p><pre><code>#define TASK_KILLABLE           (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)\n</code></pre><p>TASK_STOPPED是在进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后进入该状态。</p><p>TASK_TRACED表示进程被debugger等进程监视，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</p><p>一旦一个进程要结束，先进入的是EXIT_ZOMBIE状态，但是这个时候它的父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程就成了僵尸进程。</p><p>EXIT_DEAD是进程的最终状态。</p><p>EXIT_ZOMBIE和EXIT_DEAD也可以用于exit_state。</p><p>上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，我们称为<strong>标志</strong>。放在flags字段中，这些字段都被定义成为<strong>宏</strong>，以PF开头。我这里举几个例子。</p><pre><code>#define PF_EXITING\t\t0x00000004\n#define PF_VCPU\t\t\t0x00000010\n#define PF_FORKNOEXEC\t\t0x00000040\n</code></pre><p><strong>PF_EXITING</strong>表示正在退出。当有这个flag的时候，在函数find_alive_thread中，找活着的线程，遇到有这个flag的，就直接跳过。</p><p><strong>PF_VCPU</strong>表示进程运行在虚拟CPU上。在函数account_system_time中，统计进程的系统运行时间，如果有这个flag，就调用account_guest_time，按照客户机的时间进行统计。</p><p><strong>PF_FORKNOEXEC</strong>表示fork完了，还没有exec。在_do_fork函数里面调用copy_process，这个时候把flag设置为PF_FORKNOEXEC。当exec中调用了load_elf_binary的时候，又把这个flag去掉。</p><h2>进程调度</h2><p>进程的状态切换往往涉及调度，下面这些字段都是用于调度的。为了让你理解task_struct进程管理的全貌，我先在这里列一下，咱们后面会有单独的章节讲解，这里你只要大概看一下里面的注释就好了。</p><pre><code>//是否在运行队列上\nint\t\t\t\ton_rq;\n//优先级\nint\t\t\t\tprio;\nint\t\t\t\tstatic_prio;\nint\t\t\t\tnormal_prio;\nunsigned int\t\t\trt_priority;\n//调度器类\nconst struct sched_class\t*sched_class;\n//调度实体\nstruct sched_entity\t\tse;\nstruct sched_rt_entity\t\trt;\nstruct sched_dl_entity\t\tdl;\n//调度策略\nunsigned int\t\t\tpolicy;\n//可以使用哪些CPU\nint\t\t\t\tnr_cpus_allowed;\ncpumask_t\t\t\tcpus_allowed;\nstruct sched_info\t\tsched_info;\n</code></pre><h2>总结时刻</h2><p>这一节，我们讲述了进程管理复杂的数据结构，我还是画一个图总结一下。这个图是进程管理task_struct的结构图。其中红色的部分是今天讲的部分，你可以对着这张图说出它们的含义。</p><p><img src=\"https://static001.geekbang.org/resource/image/01/e8/016ae7fb63f8b3fd0ca072cb9964e3e8.jpeg?wh=2098*2332\" alt=\"\"></p><h2>课堂练习</h2><p>这一节我们讲了任务的状态，你可以试着在代码里面搜索一下这些状态改变的地方是哪个函数，是什么时机，从而进一步理解任务的概念。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","comments":[{"had_liked":false,"id":88482,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1555927455,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"413872787871","product_id":100024701,"comment_content":"- 内核中进程, 线程统一为任务, 由 taks_struct 表示<br>- 通过链表串起 task_struct<br>- task_struct 中包含: 任务ID; 任务状态; 信号处理相关字段; 调度相关字段; 亲缘关系; 权限相关; 运行统计; 内存管理; 文件与文件系统; 内核栈;<br>- 任务 ID; 包含 pid, tgid 和 \\*group_leader<br>    - pid(process id, 线程的id); tgid(thread group id, 所属进程[主线程]的id); group_leader 指向 tgid 的结构体<br>    - 通过对比 pid 和 tgid 可判断是进程还是线程<br>- 信号处理, 包含阻塞暂不处理; 等待处理; 正在处理的信号<br>    - 信号处理函数默认使用用户态的函数栈, 也可以开辟新的栈专门用于信号处理, 由 sas_ss_xxx 指定<br>    - 通过 pending&#47;shared_pending 区分进程和线程的信号<br>- 任务状态; 包含 state; exit_state; flags<br>    - 准备运行状态 TASK_RUNNING<br>    - 睡眠状态：可中断; 不可中断; 可杀<br>        - 可中断 TASK_INTERRUPTIBLE, 收到信号要被唤醒<br>        - 不可中断 TASK_UNINTERRUPTIBLE, 收到信号不会被唤醒, 不能被kill, 只能重启<br>        - 可杀 TASK_KILLABLE, 可以响应致命信号, 由不可中断与 TASK_WAKEKILL 组合<br>    - 停止状态 TASK_STOPPED, 由信号 SIGSTOP, SIGTTIN, SIGTSTP 与 SIGTTOU 触发进入<br>    - 调试跟踪 TASK_TRACED， 被 debugger 等进程监视时进入<br>    - 结束状态(包含 exit_state)<br>        - EXIT_ZOMBIE, 父进程还没有 wait()<br>        - EXIT_DEAD, 最终状态<br>    - flags, 例如 PF_VCPU 表示运行在虚拟 CPU 上; PF_FORKNOEXEC \\_do_fork 函数里设置, exec 函数中清除<br>- 进程调度; 包含 是否在运行队列; 优先级; 调度策略; 可以使用那些 CPU 等信息.","like_count":97,"discussions":[{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389568,"discussion_content":"这些半角符号视觉效果有点灾难……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629341699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90830,"user_name":"唐稳","can_delete":false,"product_type":"c1","uid":1080853,"ip_address":"","ucode":"DCE325A0802FF2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/15/dd163405.jpg","comment_is_top":false,"comment_ctime":1556680438,"is_pvip":false,"replies":[{"id":"49500","content":"不在任何一个线程中，后面会详细解析信号处理的过程","user_name":"作者回复","comment_id":90830,"uid":"1001590","ip_address":"","utype":1,"ctime":1567676780,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"70276157174","product_id":100024701,"comment_content":"介绍的很详细，赞一个。<br>有个问题一直纠结，信号处理函数到底是在哪个线程中运行的？","like_count":16,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448680,"discussion_content":"不在任何一个线程中，后面会详细解析信号处理的过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567676780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1510495,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","nickname":"hello","note":"","ucode":"C6FC61A90F202B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5297,"discussion_content":"我也想问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566140665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88231,"user_name":"第十人","can_delete":false,"product_type":"c1","uid":1050878,"ip_address":"","ucode":"D0DC254CB2AC7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/fe/94185b25.jpg","comment_is_top":false,"comment_ctime":1555897269,"is_pvip":false,"replies":[{"id":"32051","content":"一个是id，一个是指针，只知道ID，不得一个个找么","user_name":"作者回复","comment_id":88231,"uid":"1001590","ip_address":"","utype":1,"ctime":1556197636,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"65980406709","product_id":100024701,"comment_content":"tgid和threadleader都是进程的主线程，那这两个参数不就重复了么？有其他的含义么？","like_count":15,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447774,"discussion_content":"一个是id，一个是指针，只知道ID，不得一个个找么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556197636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610552,"avatar":"https://static001.geekbang.org/account/avatar/00/18/93/38/71615300.jpg","nickname":"DayDayUp","note":"","ucode":"9C53659518AB74","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350987,"discussion_content":"一个是主线程的id，一直是指向这个主线程的指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614090296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125670,"user_name":"ECHOLOG","can_delete":false,"product_type":"c1","uid":1186004,"ip_address":"","ucode":"4350973F4D4FB0","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/d4/73260a43.jpg","comment_is_top":false,"comment_ctime":1566223980,"is_pvip":true,"replies":[{"id":"46258","content":"对的pthread_join","user_name":"作者回复","comment_id":125670,"uid":"1001590","ip_address":"","utype":1,"ctime":1566280180,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"53105831532","product_id":100024701,"comment_content":"举一反三一下，因为线程和进程都是task_struct表示的，所以有僵尸进程，那就有僵尸线程","like_count":13,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463654,"discussion_content":"对的pthread_join","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566280180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93741,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1557577295,"is_pvip":false,"replies":[{"id":"33891","content":"一个是id，一个是地址，有地址就能直接找到了","user_name":"作者回复","comment_id":93741,"uid":"1001590","ip_address":"","utype":1,"ctime":1557899953,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"40212282959","product_id":100024701,"comment_content":"任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己。<br><br>但是有多个线程就不一样了，pid是这个子线程，tgid和group_leader都是指向主线程。<br><br>好奇，tgid与group_leader不就相同作用吗？在上面的二种情况下，为什么需要二个相同功能的域？","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449753,"discussion_content":"一个是id，一个是地址，有地址就能直接找到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557899953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88327,"user_name":"Egos","can_delete":false,"product_type":"c1","uid":1071143,"ip_address":"","ucode":"9F0055B140E935","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/27/1188e017.jpg","comment_is_top":false,"comment_ctime":1555905123,"is_pvip":false,"replies":[{"id":"32048","content":"进程和线程在一起的链表","user_name":"作者回复","comment_id":88327,"uid":"1001590","ip_address":"","utype":1,"ctime":1556197338,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"35915643491","product_id":100024701,"comment_content":"看文章理解的task_struct 是Thread 的一个链表？","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447786,"discussion_content":"进程和线程在一起的链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556197338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1510495,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","nickname":"hello","note":"","ucode":"C6FC61A90F202B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5296,"discussion_content":"单线程的进程是独享一些资源的任务，多线程的进程是共享一部分资源的多个任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566140643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88797,"user_name":"一笔一画","can_delete":false,"product_type":"c1","uid":1495254,"ip_address":"","ucode":"2B9BC8ADF97106","user_header":"https://static001.geekbang.org/account/avatar/00/16/d0/d6/f335954b.jpg","comment_is_top":false,"comment_ctime":1556002304,"is_pvip":false,"replies":[{"id":"32038","content":"操作系统的理论是有多种模型的，多对一，一对一，多对多，Linux是一对一。","user_name":"作者回复","comment_id":88797,"uid":"1001590","ip_address":"","utype":1,"ctime":1556195929,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"31620773376","product_id":100024701,"comment_content":"老师，请教一下，之前看书上说用户进程和内核线程是多对多的模型？这个怎么理解，我们常用的发行版又是什么样的模型？","like_count":7,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447904,"discussion_content":"操作系统的理论是有多种模型的，多对一，一对一，多对多，Linux是一对一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556195929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88237,"user_name":"中翅Lzc","can_delete":false,"product_type":"c1","uid":1130926,"ip_address":"","ucode":"9CD64F54B8F003","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/F9wBsptrryHAiaicsqEHREIx2ib37EgBuSFOaEZtCZVN1vP5Irojx8zedDwia5m1OLZ6hTLO1cdGrAK2L1IiaqqvnfQ/132","comment_is_top":false,"comment_ctime":1555897917,"is_pvip":false,"replies":[{"id":"32050","content":"对的","user_name":"作者回复","comment_id":88237,"uid":"1001590","ip_address":"","utype":1,"ctime":1556197613,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"31620668989","product_id":100024701,"comment_content":"如果进程创建了其他多个线程，那么tpid就是主线程id，pid就是其他线程id了，两者肯定不相等啊","like_count":7,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447777,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556197613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88624,"user_name":"积微致知","can_delete":false,"product_type":"c1","uid":1476670,"ip_address":"","ucode":"34EDEAB1112122","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/3e/dd4fa2b6.jpg","comment_is_top":false,"comment_ctime":1555975351,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27325779127","product_id":100024701,"comment_content":"老师好，有个疑惑所有的task_struct为什么用链表串联起来而不是用数组?<br>数组在物理空间上必须要连续，而链表物理空间上可以不连续。","like_count":6,"discussions":[{"author":{"id":1167046,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","nickname":"sugar","note":"","ucode":"454538FF253B5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14357,"discussion_content":"一个task结束后就消失了，数组这种连续存储结构会出现空洞，链表不会。而数组相比链表的优势是随机读取，","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1568735805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389695,"avatar":"https://static001.geekbang.org/account/avatar/00/15/34/7f/6c99fc74.jpg","nickname":"大熊猫有宝贝","note":"","ucode":"765AC2CF55B9B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122948,"discussion_content":"使用数组需要提前分配固定大小的内存 这就意味着你限制了系统中可以存在的最大线程的数量 而用链表还有一个优势是更快的插入与删除 实际中也不需要连续内存来做这件事情","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578381762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88541,"user_name":"Dracula","can_delete":false,"product_type":"c1","uid":1081411,"ip_address":"","ucode":"35C54743F2C3DB","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/43/b7c56c58.jpg","comment_is_top":false,"comment_ctime":1555939093,"is_pvip":true,"replies":[{"id":"32043","content":"很多插入和删除","user_name":"作者回复","comment_id":88541,"uid":"1001590","ip_address":"","utype":1,"ctime":1556196120,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"27325742869","product_id":100024701,"comment_content":"老师好，有个疑惑所有的task_struct为什么用链表串联起来而不是用数组","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447822,"discussion_content":"很多插入和删除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556196120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272053,"user_name":"开心","can_delete":false,"product_type":"c1","uid":1517457,"ip_address":"","ucode":"C8E08E8724C7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","comment_is_top":false,"comment_ctime":1609919097,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23084755577","product_id":100024701,"comment_content":"1. list_head的结构：<br>struct list_head {<br>\tstruct list_head *prev;<br>\tstruct list_head *next;<br>}<br>2. task_struct结构中有一个成员变量task，其类型为list_head,通过task，把所有task_struct构成一个双向链表<br>struct task_struct {<br>\t...<br>\tstruct list_head task;<br>\t...<br>}<br>3. 但是会有一个问题，我们举个例子：假设现在有三个task_struct,其关联顺序为为 TSA &lt;-&gt; TSB &lt;-&gt; TSC。我们希望通过 TSA 找到他的下一个任务 TSB。<br>首先通过 TSA 找到其成员变量 task，然后通过 task 找到 next（TSB中的task），但是我们要的是TSB,我们只找到了TSB中的成员变量 task。<br>所以内核有一个宏定义：list_entry (ptr,type,member)，就是解决这个问题。使用list_entry可以通过task的地址找到它所在的 task_struct 的地址。<br>4. list_entry (ptr,type,member) 原理：<br>根据结构体中的一个成员变量地址导出包含这个成员变量mem的struct地址。<br>大概就是我们知道 task的地址，task变量的名称，task所处的结构体的类型（在这里就是task_struct），我们可以找到哪些变量中引用了task，同时通过变量名称，所处结构体类型筛选，得到所处结构体的地址","like_count":5},{"had_liked":false,"id":221774,"user_name":"jnh1983","can_delete":false,"product_type":"c1","uid":1258486,"ip_address":"","ucode":"D6CF456D25CB67","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL70jHXdicq1nGGrHibXQ4ticFqH7GicYS8iciaicbmCO9qJy0Y5Hrb88MPs9Srzn85cAyoMOibyDu9xIhwhg/132","comment_is_top":false,"comment_ctime":1590589598,"is_pvip":false,"replies":[{"id":"83062","content":"赞","user_name":"作者回复","comment_id":221774,"uid":"1001590","ip_address":"","utype":1,"ctime":1591784890,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"18770458782","product_id":100024701,"comment_content":"源码是：include&#47;linux&#47;sched.h<br><br>老师把代码归纳了一下，方便理解<br>","like_count":4,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496564,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591784890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235320,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/78/8a328299.jpg","nickname":"佳佳大魔王","note":"","ucode":"D5214903D85A0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294602,"discussion_content":"我是在这里看到的，linux/kernel/sched/sched.h\n楼主给的位置不知道为什么没有啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595939300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203830,"user_name":"herongwei","can_delete":false,"product_type":"c1","uid":1153928,"ip_address":"","ucode":"E4158BF7AD2E70","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/88/34c171f1.jpg","comment_is_top":false,"comment_ctime":1586271198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18766140382","product_id":100024701,"comment_content":"刘老师写的技术文章，如抽丝剥茧一般，值得反复阅读","like_count":4},{"had_liked":false,"id":92937,"user_name":"fangxuan","can_delete":false,"product_type":"c1","uid":1073369,"ip_address":"","ucode":"3870F2BF5679A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/d9/829ac53b.jpg","comment_is_top":false,"comment_ctime":1557365527,"is_pvip":false,"replies":[{"id":"49408","content":"一个。","user_name":"作者回复","comment_id":92937,"uid":"1001590","ip_address":"","utype":1,"ctime":1567656926,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":1,"score":"18737234711","product_id":100024701,"comment_content":"如果一个进程只有主线程，那么task_struct是一个还是两个？如果是一个还好，这个task_struct既代表进程也代表主线程;如果是两个，进程的pid,tgid都指向自己，那怎么知道主线程是谁？","like_count":5,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449431,"discussion_content":"一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567656926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93742,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1557577369,"is_pvip":false,"replies":[{"id":"33892","content":"对","user_name":"作者回复","comment_id":93742,"uid":"1001590","ip_address":"","utype":1,"ctime":1557899967,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10147511961","product_id":100024701,"comment_content":"应该是一个值，一个是指针用于快速访问吧。。","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449754,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557899967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90944,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1556754136,"is_pvip":false,"replies":[{"id":"32629","content":"不是的，和软硬中断没有关系，是信号到来的时候的处理机制问题","user_name":"作者回复","comment_id":90944,"uid":"1001590","ip_address":"","utype":1,"ctime":1556811789,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10146688728","product_id":100024701,"comment_content":"老师，可中断睡眠是不是对应软中断，不可中断睡眠对应硬中断，这几个对应关系能详细解释下嘛","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448737,"discussion_content":"不是的，和软硬中断没有关系，是信号到来的时候的处理机制问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556811789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89182,"user_name":"免费的人","can_delete":false,"product_type":"c1","uid":1032106,"ip_address":"","ucode":"2B12D8ED63C564","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/aa/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1556100450,"is_pvip":false,"replies":[{"id":"32023","content":"是的，想想插入删除","user_name":"作者回复","comment_id":89182,"uid":"1001590","ip_address":"","utype":1,"ctime":1556194440,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10146035042","product_id":100024701,"comment_content":"说用数组替换链表的人  你们问问题的时候思考过吗","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448043,"discussion_content":"是的，想想插入删除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556194440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88782,"user_name":"免费的人","can_delete":false,"product_type":"c1","uid":1032106,"ip_address":"","ucode":"2B12D8ED63C564","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/aa/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1555999441,"is_pvip":false,"replies":[{"id":"49570","content":"是的","user_name":"作者回复","comment_id":88782,"uid":"1001590","ip_address":"","utype":1,"ctime":1567688791,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"10145934033","product_id":100024701,"comment_content":"关于EXIT_ZOMBIE状态，如果父进程显式忽略子进程的退出信号的话，子进程退出时是不会进入该状态的吧。","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447899,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567688791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304401,"user_name":"马振","can_delete":false,"product_type":"c1","uid":1136329,"ip_address":"","ucode":"94234F533219C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/c9/7b3cd3e0.jpg","comment_is_top":false,"comment_ctime":1627387597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5922354893","product_id":100024701,"comment_content":"最近遇到了负载高的问题，负载指的是在运行中和不可中断中的进程，所有如果因为IO扥进程状态是不可中断，那就可能出现cpu和内存使用率都很低，但是负载很高的现象","like_count":1},{"had_liked":false,"id":218260,"user_name":"Brave Shine","can_delete":false,"product_type":"c1","uid":1222003,"ip_address":"","ucode":"CBB1BAF89DB936","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/73/3ddc7c77.jpg","comment_is_top":false,"comment_ctime":1589766702,"is_pvip":false,"replies":[{"id":"83089","content":"因为task还指向一些资源，我们一般说线程的时候，不包括这些被进程管理的资源","user_name":"作者回复","comment_id":218260,"uid":"1001590","ip_address":"","utype":1,"ctime":1591785959,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5884733998","product_id":100024701,"comment_content":"那其实可以理解为linux内核调度的是task，而task可以是单线程的进程或者多线程进程的线程，我总感觉有点绕，为啥不能直接理解成linux调度的是thread.","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495410,"discussion_content":"因为task还指向一些资源，我们一般说线程的时候，不包括这些被进程管理的资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591785959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196521,"user_name":"vsan","can_delete":false,"product_type":"c1","uid":1896461,"ip_address":"","ucode":"20D3C0BF575C9D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f0/0d/1ddba1aa.jpg","comment_is_top":false,"comment_ctime":1585289707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880257003","product_id":100024701,"comment_content":"超哥，每篇开头的配图很赞，符合意境，增色很多","like_count":1},{"had_liked":false,"id":180572,"user_name":"herongwei","can_delete":false,"product_type":"c1","uid":1153928,"ip_address":"","ucode":"E4158BF7AD2E70","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/88/34c171f1.jpg","comment_is_top":false,"comment_ctime":1582339814,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5877307110","product_id":100024701,"comment_content":"老师好，有个疑惑：<br>为什么一旦一个进程要结束，先进入的是 EXIT_ZOMBIE 状态呢？","like_count":1,"discussions":[{"author":{"id":1304195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","nickname":"raisecomer","note":"","ucode":"32EA488E46471F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361129,"discussion_content":"就拿task_struct来说吧，这个数据结构是占用内存的，当创建一个进程时，操作系统要分配内存，当进程退出后要回收这个内存空间，进程自己是不可能回收的，只能在结束以后由系统回收，此时就处于zombie状态，等待回收。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1616597305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2131643,"avatar":"https://static001.geekbang.org/account/avatar/00/20/86/bb/61c20514.jpg","nickname":"BIG-T👻","note":"","ucode":"B03F34D2E9EA62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348931,"discussion_content":"应该是在某些情况下因为子进程退出的时候，父进程需要获得子进程的一些信息，所以子进程的task_struct没有完全销毁，特别是pid号也没销毁，所以僵尸进程过多会占用系统资源。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1612779262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108632,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1561817534,"is_pvip":true,"replies":[{"id":"48822","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567499470,"ip_address":"","comment_id":108632,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5856784830","product_id":100024701,"comment_content":"目前理解的， 任务状态主要在TASK_RUNNING， TASK_INTERRUPTIBLE， TASK_UNINTERRUPTIBLE， TASK_KILLABLE间互相转换， 其他一些状态TASK_PARKED，TASK_NEW为了解决相关问题引入的。 学习笔记https:&#47;&#47;garlicspace.com&#47;2019&#47;06&#47;29&#47;linux任务状态定义&#47;","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456061,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567499470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91390,"user_name":"咖啡巧克力丶","can_delete":false,"product_type":"c1","uid":1241940,"ip_address":"","ucode":"C205E66058859B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/54/bcad6e64.jpg","comment_is_top":false,"comment_ctime":1557022019,"is_pvip":false,"replies":[{"id":"32856","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557154952,"ip_address":"","comment_id":91390,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851989315","product_id":100024701,"comment_content":"task_struct是个描述每个任务的结构体，任务有个链表，结点就是每个任务的task_struct   是这个意思吗","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448901,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557154952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351569,"user_name":"林义的奥妙","can_delete":false,"product_type":"c1","uid":1982685,"ip_address":"","ucode":"3BD27CC75D0919","user_header":"https://static001.geekbang.org/account/avatar/00/1e/40/dd/a79ca0f0.jpg","comment_is_top":false,"comment_ctime":1657939779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657939779","product_id":100024701,"comment_content":"task_struct在哪个位置可以看到它的源代码？","like_count":0},{"had_liked":false,"id":351251,"user_name":"| ~浑蛋~","can_delete":false,"product_type":"c1","uid":3024820,"ip_address":"","ucode":"B6904B44DFA805","user_header":"https://static001.geekbang.org/account/avatar/00/2e/27/b4/df65c0f7.jpg","comment_is_top":false,"comment_ctime":1657638473,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1657638473","product_id":100024701,"comment_content":"Java中创建的线程也对应操作系统的一个task吗？应该怎么使用ps命令把这些线程展示出来？","like_count":0},{"had_liked":false,"id":297597,"user_name":"ywz","can_delete":false,"product_type":"c1","uid":2401841,"ip_address":"","ucode":"A93F43B3506FA9","user_header":"https://static001.geekbang.org/account/avatar/00/24/a6/31/0242f7d6.jpg","comment_is_top":false,"comment_ctime":1623659689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623659689","product_id":100024701,"comment_content":"请问下多线程的程序有什么好的调试手段么？","like_count":0},{"had_liked":false,"id":283059,"user_name":"ltknow","can_delete":false,"product_type":"c1","uid":2009398,"ip_address":"","ucode":"8C1F0F36D374E7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a9/36/e49b9ccb.jpg","comment_is_top":false,"comment_ctime":1615534046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615534046","product_id":100024701,"comment_content":"说task_struct是通过链表链接起来的，其实是图这样的数据结构吧，*group_header是直接指向主线程的指针。","like_count":0},{"had_liked":false,"id":281148,"user_name":"佳伦","can_delete":false,"product_type":"c1","uid":1064508,"ip_address":"","ucode":"3AE8098B5BE716","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/3c/fc3ad983.jpg","comment_is_top":false,"comment_ctime":1614595250,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614595250","product_id":100024701,"comment_content":"没太看懂，TASK_RUNNING是准备运行状态，那运行状态怎么表示","like_count":0,"discussions":[{"author":{"id":2419538,"avatar":"","nickname":"Geek_3b5bba","note":"","ucode":"1EAA5464073906","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357308,"discussion_content":"只有分配了cpu的时候才是真正在运行了，TASK_RUNNING只是表明我可以运行了，快分给我CPU片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615783020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261952,"user_name":"Geek_49c513","can_delete":false,"product_type":"c1","uid":2321651,"ip_address":"","ucode":"99EE2D23BDBD91","user_header":"","comment_is_top":false,"comment_ctime":1605588632,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605588632","product_id":100024701,"comment_content":"进程管理结构图中补充namespace和cgroup相关的字段是不是更全:)","like_count":0,"discussions":[{"author":{"id":2131643,"avatar":"https://static001.geekbang.org/account/avatar/00/20/86/bb/61c20514.jpg","nickname":"BIG-T👻","note":"","ucode":"B03F34D2E9EA62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348930,"discussion_content":"涉及到namesapce和cgroup就很复杂了，《深入Linux内核架构》也只是稍微讲了下pid namespace","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612779103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248422,"user_name":"TinyCalf","can_delete":false,"product_type":"c1","uid":2137418,"ip_address":"","ucode":"0A3EF213359388","user_header":"https://static001.geekbang.org/account/avatar/00/20/9d/4a/09a5041e.jpg","comment_is_top":false,"comment_ctime":1600157272,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600157272","product_id":100024701,"comment_content":"我可不可以把这几节课中提到的 “线程”理解为linux的“轻量级进程”，如果不能那么这两者有什么具体的区别呢，我很想搞明白这块","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385220,"discussion_content":"应该是一样的，我发现有些调试工具比如QT Creator就是用LWT来表示线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626945045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232628,"user_name":"No ver","can_delete":false,"product_type":"c1","uid":1106465,"ip_address":"","ucode":"BD5FA90AAF07D8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/21/840410d8.jpg","comment_is_top":false,"comment_ctime":1594053613,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1594053613","product_id":100024701,"comment_content":"TASK_STOPPED状态不太理解，网上很多把它翻译为挂起状态？但是接收到SIGSTOP命令程序不是退出了吗？TASK_STOPPED之后会是TASK_DEAD吗","like_count":0,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324684,"discussion_content":"TASK_STOPPED只是进程停止状态，如果后面要退出则是Z，反之不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605151809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225847,"user_name":"羽","can_delete":false,"product_type":"c1","uid":1316367,"ip_address":"","ucode":"7E329FECE728E4","user_header":"https://static001.geekbang.org/account/avatar/00/14/16/0f/ebdcc4b7.jpg","comment_is_top":false,"comment_ctime":1591871904,"is_pvip":false,"replies":[{"id":"83465","content":"这个可以查一下c的语法","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1592186113,"ip_address":"","comment_id":225847,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591871904","product_id":100024701,"comment_content":"超哥 能解释一下为什么这个地方是volatile long state;  volatile的吗 ","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498017,"discussion_content":"这个可以查一下c的语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592186113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135105,"avatar":"https://static001.geekbang.org/account/avatar/00/11/52/01/c05a82db.jpg","nickname":"左思","note":"","ucode":"54D9DC97FB3B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297631,"discussion_content":"你可以百度下，linux内核中为什么不应该使用“volatile”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596988764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177398,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1581387964,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581387964","product_id":100024701,"comment_content":"day12简洁地展示出了进程调度的流程。用任务来统一管理进程和线程的确是好的系统设计思想，其后用pid和tgid的变量再来区分进程和线程。我猜使用链表的原因是为了便于删除和加入，因为线程的更替操作会很多，因此如果用数组的话，O(n)操作将非常耗时。另外，数组连续存储，进程栈8192KB的空间将会不太够","like_count":0},{"had_liked":false,"id":144436,"user_name":"jueyoq","can_delete":false,"product_type":"c1","uid":1129625,"ip_address":"","ucode":"5CD5A9CF9B5B1C","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/99/6080d269.jpg","comment_is_top":false,"comment_ctime":1571921352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571921352","product_id":100024701,"comment_content":"1. 进程的标示 pid&#47;tgid&#47;group_leader  是用来方便区分任务是线程还是进程,而区分二者的需求来自远多维度的展示任务与向进程或者线程发送信号<br>2. 进程的状态设定同样来源于两个需求, 监控统计任务的执行过程,以及调度任务。而任务的状态来自于处理任务的一般思路,创建一个任务,准备处理任务,处理任务,任务被搁置,任务被解决,同时为了可以更加细粒度的监控进程引入debug的状态。","like_count":0},{"had_liked":false,"id":139141,"user_name":"sinfool","can_delete":false,"product_type":"c1","uid":1165971,"ip_address":"","ucode":"AEA84CCBB2D89D","user_header":"https://static001.geekbang.org/account/avatar/00/11/ca/93/181b8e65.jpg","comment_is_top":false,"comment_ctime":1570553508,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1570553508","product_id":100024701,"comment_content":"‘通过pid==tgid来判断是线程还是进程&#39;这句话实在是不懂。如果是单线程，pid==tgid，没有问题；如果是多线程，当前线程如果是主线程，pid不是也等于tgid么？这怎么说？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385222,"discussion_content":"不是单线/多线程，而是通过这个条件判断task结构代表的是进程还是线程哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626945250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136055,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1569337012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569337012","product_id":100024701,"comment_content":"再次阅读,本章可以参考lkd(process management) 一起看","like_count":0},{"had_liked":false,"id":132668,"user_name":"计算机班陈公子","can_delete":false,"product_type":"c1","uid":1168448,"ip_address":"","ucode":"0D776A68CBA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/40/7401ecc1.jpg","comment_is_top":false,"comment_ctime":1568189164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568189164","product_id":100024701,"comment_content":"老师有个问题就是在进程状态变成zombie后，他在等父进程调用wait() 来回收自己的空间是么？所以在回收完他的空间后他就彻底进入了EXIT_DEAD状态是么？可是为什么top命令下的S 栏里面没有dead这个状态，而只有R,S,D,T,Z这五个？<br>另外在进程收到SIGTERM或者SIGKILL这样terminate类的信号时，进程也是进入了EXIT_DEAD状态么？ ","like_count":0},{"had_liked":false,"id":131849,"user_name":"jijun gao","can_delete":false,"product_type":"c1","uid":1171107,"ip_address":"","ucode":"D3CA160F9FDC23","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/a3/c4fcd3db.jpg","comment_is_top":false,"comment_ctime":1567936836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567936836","product_id":100024701,"comment_content":"打个卡：task_struct结构中，pid是线程id。从pid的名字来看，是process id， 即进程id. 此处，可以理解为，线程是轻量级的进程。tgid是线程所属进程的主线程id","like_count":0},{"had_liked":false,"id":123656,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1565741302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565741302","product_id":100024701,"comment_content":"进程的数据结构1 进程和线程，1.1有的进程只有一个线程，有的有1.2 多个线程，都需要内核分配CPU来干活。在内核里进程和线程统称任务，数据结构都是task_struct。1.3 linux的任务管理都做什么用，1.31首先要有个任务链表，struct list_head，把所有任务串起来1.32 都有一个任务id，pid全称processid，tgid全称task group id，之所以要有pid和tgid，一是任务展示，二是给任务发指令 是给进程发还是某一个线程发 有了pid和tgid，用两者是否相等，就能知道是线程还是进程2 信号处理 task_struct 里面也有涉及信号处理的字段 sigset_t blocked定义了信号阻塞暂不处理，sigpending pending 哪些信号尚等待处理，哪些信号正在通过sighand函数进行处理，信号处理函数默认使用用户态的函数栈 3 进程调度 优先级，调度类sched_class，调度策略，调度实体sched_entity，4任务状态 在task_struct类中，state属性 TASK_RUNNIng 表示处于即将运行的状态，时间片切换到这个进程，就会立刻运行，睡眠状态有3种，Task_interruptible，可中断的睡眠状态，浅睡眠状态，信号来的时候被唤醒，处理函数可以自己定义，task_uninterruputible，不可唤醒的睡眠状态，死等io操作，task_killabe收到致命信号可以被唤醒，task_track表示进程被其他进程监视，进程执行被调试进程所终止，一个进程结束要先进入exit_zomble状态，如果他的父进程还没有使用wait等系统调用获取终止信息，该进程就成了僵尸进程。exit_dead是进程的最终状态。调度还有一些标志以PF开头，pf_exiting表示正在退出，pf_vcpu表示运行在虚拟cpu上。","like_count":0},{"had_liked":false,"id":123170,"user_name":"...","can_delete":false,"product_type":"c1","uid":1142098,"ip_address":"","ucode":"9D73E00133C236","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/52/404912c3.jpg","comment_is_top":false,"comment_ctime":1565619431,"is_pvip":false,"replies":[{"id":"46310","content":"你是对的，是state","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566283534,"ip_address":"","comment_id":123170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565619431","product_id":100024701,"comment_content":"从定义的数值很容易看出来，flags 是通过 bitset 的方式设置的也就是说，当前是什么状态，哪一位就置一。 结合上下文发现是不是笔误，flags应该改成state","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462566,"discussion_content":"你是对的，是state","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566283534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116235,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1563805883,"is_pvip":false,"replies":[{"id":"46536","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566354840,"ip_address":"","comment_id":116235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563805883","product_id":100024701,"comment_content":"实在是不理解为什么那么多人问&quot;为什么用链表而不是数组...&quot;<br>补充: 本节讲的内容在sched.h里面, 思考题完全可以搜一下这个&quot;task-&gt;state&quot;","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459442,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566354840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107389,"user_name":"望天","can_delete":false,"product_type":"c1","uid":1545448,"ip_address":"","ucode":"EA82334BCE7564","user_header":"","comment_is_top":false,"comment_ctime":1561526138,"is_pvip":false,"replies":[{"id":"48854","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567501207,"ip_address":"","comment_id":107389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561526138","product_id":100024701,"comment_content":"该结构定义在&lt;include&#47;linux&#47;sched.h&gt;","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455496,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93178,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1557415066,"is_pvip":true,"replies":[{"id":"49405","content":"搜索函数名，很容易找到的，https:&#47;&#47;elixir.bootlin.com&#47;linux&#47;v4.13.16","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567656623,"ip_address":"","comment_id":93178,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557415066","product_id":100024701,"comment_content":"要是老师把对应源码位置给出就好了，有时候找不到，可以么","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449513,"discussion_content":"搜索函数名，很容易找到的，https://elixir.bootlin.com/linux/v4.13.16","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567656623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89377,"user_name":"TinnyFlames","can_delete":false,"product_type":"c1","uid":1234723,"ip_address":"","ucode":"0067EFC4210104","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/23/14b98ea5.jpg","comment_is_top":false,"comment_ctime":1556160574,"is_pvip":false,"replies":[{"id":"32018","content":"是链表啊","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556194281,"ip_address":"","comment_id":89377,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1556160574","product_id":100024701,"comment_content":"数组和链表虽然都是线性表的实现，但是就这个应用场景来说链表明显不合适。<br>首先数组的插入和删除是O(N)级别的，对于进程管理来说，明显插入和删除操作是主要需求，设想有大量的进程和线程在一个数组里，这时候有调度需求给他们挪位置画面就太美好了……而且对于很多调度算法来说，链表操作起来都非常方便快速。而数组的优点无非是随机访问和对CPU缓存机制更友好，但说实话我想不到这两个点在进程管理时有什么太大的好处<br>其次其他评论也指出了，数组是连续分配的内存空间，链表是离散的，从最大利用资源的角度来讲链表也是首选，因为一片连续的空间还是太奢侈了点，能见缝插针的链表要好的多<br>总体来讲，操作系统作为一种基础设施，性能是特别敏感的，选用链表而不用数组主要就是性能上的考量，无论空间上还是时间上。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448108,"discussion_content":"是链表啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556194281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202160,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/f0/f6155d5f.jpg","nickname":"新生\\","note":"","ucode":"212978C88E242E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3001,"discussion_content":"你的过程是对的， 结论写错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564104899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89171,"user_name":"庄小P","can_delete":false,"product_type":"c1","uid":1489063,"ip_address":"","ucode":"A71FA01F713790","user_header":"","comment_is_top":false,"comment_ctime":1556097297,"is_pvip":false,"replies":[{"id":"32024","content":"这个考虑了好久，加不加从哪个文件到哪个文件，后来想应该把代码当成原理和流程的佐证，而不是一本逐行解析代码的书，所以就没加，后面可以考虑加上","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556194526,"ip_address":"","comment_id":89171,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556097297","product_id":100024701,"comment_content":"老师，附上代码的能够能加上是哪个头文件那，想具体看看里面的某些东西","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448042,"discussion_content":"这个考虑了好久，加不加从哪个文件到哪个文件，后来想应该把代码当成原理和流程的佐证，而不是一本逐行解析代码的书，所以就没加，后面可以考虑加上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556194526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88949,"user_name":"tux","can_delete":false,"product_type":"c1","uid":1477811,"ip_address":"","ucode":"BB7202009FC885","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/b3/a74a7125.jpg","comment_is_top":false,"comment_ctime":1556031396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556031396","product_id":100024701,"comment_content":"需要多下一番努力(文章末尾:反复研读)","like_count":0},{"had_liked":false,"id":88918,"user_name":"逍觉迷遥","can_delete":false,"product_type":"c1","uid":1070782,"ip_address":"","ucode":"4287B0B6A23A25","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/be/d68998fa.jpg","comment_is_top":false,"comment_ctime":1556026566,"is_pvip":false,"replies":[{"id":"32026","content":"创建和删除进程，再创建再删除","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556195344,"ip_address":"","comment_id":88918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556026566","product_id":100024701,"comment_content":"请问老师，这里底层用链表来连接所有task_struct是出于什么考量呢？想了想没相处理由，发现数组也能吧。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447946,"discussion_content":"创建和删除进程，再创建再删除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556195344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88914,"user_name":"逍觉迷遥","can_delete":false,"product_type":"c1","uid":1070782,"ip_address":"","ucode":"4287B0B6A23A25","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/be/d68998fa.jpg","comment_is_top":false,"comment_ctime":1556026465,"is_pvip":false,"replies":[{"id":"32028","content":"pid和tgid","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556195392,"ip_address":"","comment_id":88914,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556026465","product_id":100024701,"comment_content":"进程和线程在底层核心用统一的数据结构task_struct来表示，其实可以根据一些字段来区别是哪一类型。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447944,"discussion_content":"pid和tgid","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556195392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88742,"user_name":"tiankonghewo","can_delete":false,"product_type":"c1","uid":1476427,"ip_address":"","ucode":"7A55A9C17DD9DF","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/4b/16ea3997.jpg","comment_is_top":false,"comment_ctime":1555988953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555988953","product_id":100024701,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":88345,"user_name":"dancer","can_delete":false,"product_type":"c1","uid":1019036,"ip_address":"","ucode":"B8D5641A3AC490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/9c/d48473ab.jpg","comment_is_top":false,"comment_ctime":1555908416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555908416","product_id":100024701,"comment_content":"day12打卡，把task_struct分为几类，容易理解记忆","like_count":0},{"had_liked":false,"id":88187,"user_name":"W.jyao","can_delete":false,"product_type":"c1","uid":1422582,"ip_address":"","ucode":"C57B3A78B6A795","user_header":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","comment_is_top":false,"comment_ctime":1555891941,"is_pvip":false,"replies":[{"id":"32055","content":"pid是当前task_struct的id，其实是线程的id了","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1556197845,"ip_address":"","comment_id":88187,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555891941","product_id":100024701,"comment_content":"根据文中所说，一个进程，如果只有主线程，那么tpid = pid，如果进程创建了其他线程，那么tpid就是主线程id，主线程不是就是当前进程？那么两个不应该还是相等？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447762,"discussion_content":"pid是当前task_struct的id，其实是线程的id了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556197845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}