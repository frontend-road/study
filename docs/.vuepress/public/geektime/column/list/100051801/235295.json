{"id":235295,"title":"04 | 编译阶段能做什么：属性和静态断言","content":"<p>你好，我是Chrono。</p><p>前面我讲了C++程序生命周期里的“编码阶段”和“预处理阶段”，它们的工作主要还是“文本编辑”，生成的是<strong>人类可识别的源码</strong>（source code）。而“编译阶段”就不一样了，它的目标是<strong>生成计算机可识别的机器码</strong>（machine instruction code）。</p><p>今天，我就带你来看看在这个阶段能做些什么事情。</p><h2>编译阶段编程</h2><p>编译是预处理之后的阶段，它的输入是（经过预处理的）C++源码，输出是<strong>二进制可执行文件</strong>（也可能是汇编文件、动态库或者静态库）。这个处理动作就是由编译器来执行的。</p><p>和预处理阶段一样，在这里你也可以“面向编译器编程”，用一些指令或者关键字让编译器按照你的想法去做一些事情。只不过，这时你要面对的是庞大的C++语法，而不是简单的文本替换，难度可以说是高了好几个数量级。</p><p>编译阶段的特殊性在于，它看到的都是C++语法实体，比如typedef、using、template、struct/class这些关键字定义的类型，而不是运行阶段的变量。所以，这时的编程思维方式与平常大不相同。我们熟悉的是CPU、内存、Socket，但要去理解编译器的运行机制、知道怎么把源码翻译成机器码，这可能就有点“强人所难”了。</p><!-- [[[read_end]]] --><p>比如说，让编译器递归计算斐波那契数列，这已经算是一个比较容易理解的编译阶段数值计算用法了：</p><pre><code>template&lt;int N&gt;\nstruct fib                   // 递归计算斐波那契数列\n{\n    static const int value =\n        fib&lt;N - 1&gt;::value + fib&lt;N - 2&gt;::value;\n};\n\ntemplate&lt;&gt;\nstruct fib&lt;0&gt;                // 模板特化计算fib&lt;0&gt;\n{\n    static const int value = 1;\n};\n\ntemplate&lt;&gt;\nstruct fib&lt;1&gt;               // 模板特化计算fib&lt;1&gt;\n{\n    static const int value = 1;\n};\n\n// 调用后输出2，3，5，8\ncout &lt;&lt; fib&lt;2&gt;::value &lt;&lt; endl;\ncout &lt;&lt; fib&lt;3&gt;::value &lt;&lt; endl;\ncout &lt;&lt; fib&lt;4&gt;::value &lt;&lt; endl;\ncout &lt;&lt; fib&lt;5&gt;::value &lt;&lt; endl;\n</code></pre><p>对于编译器来说，可以在一瞬间得到结果，但你要搞清楚它的执行过程，就得在大脑里把C++模板特化的过程走一遍。整个过程无法调试，完全要靠自己去推导，特别“累人”。（你也可以把编译器想象成是一种特殊的“虚拟机”，在上面跑的是只有编译器才能识别、处理的代码。）</p><p>简单的尚且如此，那些复杂的就更不用说了。所以，今天我就不去讲那些太过于“烧脑”的知识了，而是介绍两个比较容易理解的编译阶段技巧：属性和静态断言，让你能够立即用得上，效果也是“立竿见影”。</p><h2>属性（attribute）</h2><p>“预处理编程”<a href=\"https://time.geekbang.org/column/article/233711\">这一讲</a>提到的#include、#define都是预处理指令，是用来控制预处理器的。那么问题就来了，有没有用来控制编译器的“编译指令”呢？</p><p>虽然编译器非常聪明，但因为C++语言实在是太复杂了，偶尔它也会“自作聪明”或者“冒傻气”。如果有这么一个东西，让程序员来手动指示编译器这里该如何做、那里该如何做，就有可能会生成更高效的代码。</p><p>在C++11之前，标准里没有规定这样的东西，但GCC、VC等编译器发现这样做确实很有用，于是就实现出了自己“编译指令”，在GCC里是“__ attribute __”，在VC里是“__declspec”。不过因为它们不是标准，所以名字显得有点“怪异”。</p><p>到了C++11，标准委员会终于认识到了“编译指令”的好处，于是就把“民间”用法升级为“官方版本”，起了个正式的名字叫“<strong>属性</strong>”。你可以把它理解为给变量、函数、类等“贴”上一个编译阶段的“标签”，方便编译器识别处理。</p><p>“属性”没有新增关键字，而是用两对方括号的形式“[[…]]”，方括号的中间就是属性标签（看着是不是很像一张方方正正的便签条）。所以，它的用法很简单，比GCC、VC的都要简洁很多。</p><p>我举个简单的例子，你看一下就明白了：</p><pre><code>[[noreturn]]              // 属性标签\nint func(bool flag)       // 函数绝不会返回任何值\n{\n    throw std::runtime_error(&quot;XXX&quot;);\n}\n</code></pre><p>不过，在C++11里只定义了两个属性：“noreturn”和“carries_dependency”，它们基本上没什么大用处。</p><p>C++14的情况略微好了点，增加了一个比较实用的属性“deprecated”，用来标记不推荐使用的变量、函数或者类，也就是被“废弃”。</p><p>比如说，你原来写了一个函数old_func()，后来觉得不够好，就另外重写了一个完全不同的新函数。但是，那个老函数已经发布出去被不少人用了，立即删除不太可能，该怎么办呢？</p><p>这个时候，你就可以让“属性”发挥威力了。你可以给函数加上一个“deprecated”的编译期标签，再加上一些说明文字：</p><pre><code>[[deprecated(&quot;deadline:2020-12-31&quot;)]]      // C++14 or later\nint old_func();\n</code></pre><p>于是，任何用到这个函数的程序都会在编译时看到这个标签，报出一条警告：</p><pre><code>warning: ‘int old_func()’ is deprecated: deadline:2020-12-31 [-Wdeprecated-declarations]\n</code></pre><p>当然，程序还是能够正常编译的，但这种强制的警告形式会“提醒”用户旧接口已经被废弃了，应该尽快迁移到新接口。显然，这种形式要比毫无约束力的文档或者注释要好得多。</p><p>目前的C++17和C++20又增加了五六个新属性，比如fallthrough、likely，但我觉得，标准委员会的态度还是太“保守”了，在实际的开发中，这些真的是不够用。</p><p>好在“属性”也支持非标准扩展，允许以类似名字空间的方式使用编译器自己的一些“非官方”属性，比如，GCC的属性都在“gnu::”里。下面我就列出几个比较有用的（全部属性可参考<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html\">GCC文档</a>）。</p><ul>\n<li>deprecated：与C++14相同，但可以用在C++11里。</li>\n<li>unused：用于变量、类型、函数等，表示虽然暂时不用，但最好保留着，因为将来可能会用。</li>\n<li>constructor：函数会在main()函数之前执行，效果有点像是全局对象的<strong>构造</strong>函数。</li>\n<li>destructor：函数会在main()函数结束之后执行，有点像是全局对象的<strong>析构</strong>函数。</li>\n<li>always_inline：要求编译器强制内联函数，作用比inline关键字更强。</li>\n<li>hot：标记“热点”函数，要求编译器更积极地优化。</li>\n</ul><p>这几个属性的含义还是挺好理解的吧，我拿“unused”来举个例子。</p><p>在没有这个属性的时候，如果有暂时用不到的变量，我们只能用“(void) <em>var</em>;”的方式假装用一下，来“骗”过编译器，属于“不得已而为之”的做法。</p><p>那么现在，我们就可以用“unused”属性来清楚地告诉编译器：这个变量我暂时不用，请不要过度紧张，不要发出警告来烦我：</p><pre><code>[[gnu::unused]]      // 声明下面的变量暂不使用，不是错误\nint nouse;  \n</code></pre><p><a href=\"https://github.com/chronolaw/cpp_study/blob/master/section1/compile.cpp\">GitHub仓库</a>里的示例代码里还展示了其他属性的用法，你可以在课下参考。</p><h2>静态断言（static_assert）</h2><p>“属性”像是给编译器的一个“提示”“告知”，无法进行计算，还算不上是编程，而接下来要讲的“<strong>静态断言</strong>”，就有点编译阶段写程序的味道了。</p><p>你也许用过assert吧，它用来断言一个表达式必定为真。比如说，数字必须是正数，指针必须非空、函数必须返回true：</p><pre><code>assert(i &gt; 0 &amp;&amp; &quot;i must be greater than zero&quot;);\nassert(p != nullptr);\nassert(!str.empty());\n</code></pre><p>当程序（也就是CPU）运行到assert语句时，就会计算表达式的值，如果是false，就会输出错误消息，然后调用abort()终止程序的执行。</p><p>注意，assert虽然是一个宏，但在预处理阶段不生效，而是在运行阶段才起作用，所以又叫“<strong>动态断言</strong>”。</p><p>有了“动态断言”，那么相应的也就有“静态断言”，名字也很像，叫“<strong>static_assert</strong>”，不过它是一个专门的关键字，而不是宏。因为它只在编译时生效，运行阶段看不见，所以是“静态”的。</p><p>“静态断言”有什么用呢？</p><p>类比一下assert，你就可以理解了。它是编译阶段里检测各种条件的“断言”，编译器看到static_assert也会计算表达式的值，如果值是false，就会报错，导致编译失败。</p><p>比如说，这节课刚开始时的斐波拉契数列计算函数，可以用静态断言来保证模板参数必须大于等于零：</p><pre><code>template&lt;int N&gt;\nstruct fib\n{\n    static_assert(N &gt;= 0, &quot;N &gt;= 0&quot;);\n\n    static const int value =\n        fib&lt;N - 1&gt;::value + fib&lt;N - 2&gt;::value;\n};\n</code></pre><p>再比如说，要想保证我们的程序只在64位系统上运行，可以用静态断言在编译阶段检查long的大小，必须是8个字节（当然，你也可以换个思路用预处理编程来实现）。</p><pre><code>static_assert(\n  sizeof(long) &gt;= 8, &quot;must run on x64&quot;);\n  \nstatic_assert(\n  sizeof(int)  == 4, &quot;int must be 32bit&quot;);\n</code></pre><p>这里你一定要注意，static_assert运行在编译阶段，只能看到编译时的常数和类型，看不到运行时的变量、指针、内存数据等，是“静态”的，所以不要简单地把assert的习惯搬过来用。</p><p>比如，下面的代码想检查空指针，由于变量只能在运行阶段出现，而在编译阶段不存在，所以静态断言无法处理。</p><pre><code>char* p = nullptr;\nstatic_assert(p == nullptr, &quot;some error.&quot;);  // 错误用法\n</code></pre><p>说到这儿，你大概对static_assert的“编译计算”有点感性认识了吧。在用“静态断言”的时候，你就要在脑子里时刻“绷紧一根弦”，把自己代入编译器的角色，<strong>像编译器那样去思考</strong>，看看断言的表达式是不是能够在编译阶段算出结果。</p><p>不过这句话说起来容易做起来难，计算数字还好说，在泛型编程的时候，怎么检查模板类型呢？比如说，断言是整数而不是浮点数、断言是指针而不是引用、断言类型可拷贝可移动……</p><p>这些检查条件表面上看好像是“不言自明”的，但要把它们用C++语言给精确地表述出来，可就没那么简单了。所以，想要更好地发挥静态断言的威力，还要配合标准库里的“type_traits”，它提供了对应这些概念的各种编译期“函数”。</p><pre><code>// 假设T是一个模板参数，即template&lt;typename T&gt;\n\nstatic_assert(\n  is_integral&lt;T&gt;::value, &quot;int&quot;);\n\nstatic_assert(\n  is_pointer&lt;T&gt;::value, &quot;ptr&quot;);\n\nstatic_assert(\n  is_default_constructible&lt;T&gt;::value, &quot;constructible&quot;);\n\n</code></pre><p>你可能看到了，“static_assert”里的表达式样子很奇怪，既有模板符号“&lt;&gt;”，又有作用域符号“::”，与运行阶段的普通表达式大相径庭，初次见到这样的代码一定会吓一跳。</p><p>这也是没有办法的事情。因为C++本来不是为编译阶段编程所设计的。受语言的限制，编译阶段编程就只能“魔改”那些传统的语法要素了：把类当成函数，把模板参数当成函数参数，把“::”当成return返回值。说起来，倒是和“函数式编程”很神似，只是它运行在编译阶段。</p><p>由于“type_traits”已经初步涉及模板元编程的领域，不太好一下子解释清楚，所以，在这里我就不再深入介绍了，你可以课后再看看这方面的其他资料，或者是留言提问。</p><h2>小结</h2><p>好了，今天我和你聊了C++程序在编译阶段能够做哪些事情。</p><p>编译阶段的“主角”是编译器，它依据C++语法规则处理源码。在这个过程中，我们可以用一些手段来帮助编译器，让它听从我们的指挥，优化代码或者做静态检查，更好地为运行阶段服务。</p><p>但要当心，毕竟只有编译器才能真正了解C++程序，所以我们还是要充分信任它，不要过分干预它的工作，更不要有意与它作对。</p><p>我们来小结一下今天的要点。</p><ol>\n<li>“属性”相当于编译阶段的“标签”，用来标记变量、函数或者类，让编译器发出或者不发出警告，还能够手工指定代码的优化方式。</li>\n<li>官方属性很少，常用的只有“deprecated”。我们也可以使用非官方的属性，需要加上名字空间限定。</li>\n<li>static_assert是“静态断言”，在编译阶段计算常数和类型，如果断言失败就会导致编译错误。它也是迈向模板元编程的第一步。</li>\n<li>和运行阶段的“动态断言”一样，static_assert可以在编译阶段定义各种前置条件，充分利用C++静态类型语言的优势，让编译器执行各种检查，避免把隐患带到运行阶段。</li>\n</ol><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>预处理阶段可以自定义宏，但编译阶段不能自定义属性标签，这是为什么呢？</li>\n<li>你觉得，怎么用“静态断言”，才能更好地改善代码质量？</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎把它分享给你的朋友。我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/25/39/25232468a72b55a41bf7af90583ae239.jpg?wh=2284*3130\" alt=\"\"></p>","neighbors":{"left":{"article_title":"03 | 预处理阶段能做什么：宏定义和条件编译","id":233711},"right":{"article_title":"05 | 面向对象编程：怎样才能写出一个“好”的类？","id":235301}},"comments":[{"had_liked":false,"id":217172,"user_name":"yelin","can_delete":false,"product_type":"c1","uid":1416262,"ip_address":"","ucode":"4341B2F4C513FE","user_header":"https://static001.geekbang.org/account/avatar/00/15/9c/46/a2c1a99f.jpg","comment_is_top":false,"comment_ctime":1589430990,"is_pvip":false,"replies":[{"id":"80298","content":"模板元编程比较复杂，属于屠龙之术，这次我先不讲，如果感兴趣的同学多可以以后单独开一个课程。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589432253,"ip_address":"","comment_id":217172,"utype":1}],"discussion_count":4,"race_medal":0,"score":"130438449870","product_id":100051801,"comment_content":"斐布那契还可以这么玩，期待老师后面对于模版类的课程，我可能从来没都没学会过","like_count":30,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495062,"discussion_content":"模板元编程比较复杂，属于屠龙之术，这次我先不讲，如果感兴趣的同学多可以以后单独开一个课程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589432253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1807943,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","nickname":"出卖灵魂的教练Kerry","note":"","ucode":"8C64517DA556FE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266237,"discussion_content":"期待哦","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589473608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1619597,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","nickname":"dog_brother","note":"","ucode":"9F64D3C6D815FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368917,"discussion_content":"期待，想学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618881670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265913,"discussion_content":"开个课程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589454753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217133,"user_name":"Luca","can_delete":false,"product_type":"c1","uid":1205040,"ip_address":"","ucode":"0161C4DCB9ECF4","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/30/6f4b925c.jpg","comment_is_top":false,"comment_ctime":1589424286,"is_pvip":false,"replies":[{"id":"80299","content":"very nice。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589432270,"ip_address":"","comment_id":217133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"130438443166","product_id":100051801,"comment_content":"1. 因为属性标签都在编译器里内置，自定义的属性标签编译器无法识别。<br>2. 静态断言可以作为编译期的一种约定，配合错误提示能够更快发现编译期的错误。","like_count":30,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495050,"discussion_content":"very nice。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589432270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217049,"user_name":"逸清","can_delete":false,"product_type":"c1","uid":1996012,"ip_address":"","ucode":"B8EEFA299527EC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/74/ec/973fb3b7.jpg","comment_is_top":false,"comment_ctime":1589412770,"is_pvip":false,"replies":[{"id":"80261","content":"建议先学习一下标准库，了解里面的那些工具，现在开发很少有白手起家的了，用好工具，知道它们能解决哪些问题，写应用也就比较容易了。<br><br>比如string&#47;regex处理字符串、map&#47;set集合、线程库等等，跟着课程逐步学吧。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589417628,"ip_address":"","comment_id":217049,"utype":1}],"discussion_count":1,"race_medal":0,"score":"66013922210","product_id":100051801,"comment_content":"老师，自己C++基础知识还算了解，但代码写的太少，拿到一个需求无从下手，老师有没有比较好的方法或者适合练手的项目推荐？","like_count":15,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495021,"discussion_content":"建议先学习一下标准库，了解里面的那些工具，现在开发很少有白手起家的了，用好工具，知道它们能解决哪些问题，写应用也就比较容易了。\n\n比如string/regex处理字符串、map/set集合、线程库等等，跟着课程逐步学吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589417628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217042,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1589408679,"is_pvip":false,"replies":[{"id":"80262","content":"<br>1.是的，这些代码都是模板类，自然会由编译器去解析处理，最后出来的也是编译期数值，也就是静态常量，省去了运行期的技术成本，运行期直接用就行。<br><br>2.模板元编程和预处理编程有点像，由编译器来改变源码的形态，但它的规则更复杂，难以理解，你首先要了解泛型编程，之后才能尝试模板元编程。<br>对于80%的C++程序员来说，我不建议尝试模板元编程，可以参考第1讲。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589417801,"ip_address":"","comment_id":217042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44539081639","product_id":100051801,"comment_content":"看到老师的斐波那契数列实现，我还是挺惊讶的，代码虽都看得懂，但是从没想过这么写，我有两个问题想请教下： 1.按本节的主题，编译阶段能做什么，所以说后面的那几个斐波那契数列在编译器就有结果了吗？如果是这样的话，肯定是需要cpu压栈计算的，这和真实的运行期有哪些不同呢？2.模板编程在哪些场景下使用比较好？模板编程 和 编译 阶段 似乎关联更大些","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495020,"discussion_content":"\n1.是的，这些代码都是模板类，自然会由编译器去解析处理，最后出来的也是编译期数值，也就是静态常量，省去了运行期的技术成本，运行期直接用就行。\n\n2.模板元编程和预处理编程有点像，由编译器来改变源码的形态，但它的规则更复杂，难以理解，你首先要了解泛型编程，之后才能尝试模板元编程。\n对于80%的C++程序员来说，我不建议尝试模板元编程，可以参考第1讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589417801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219322,"user_name":"jxon-H","can_delete":false,"product_type":"c1","uid":1897700,"ip_address":"","ucode":"D491FAB6A07A4A","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/e4/e7471344.jpg","comment_is_top":false,"comment_ctime":1589988238,"is_pvip":false,"replies":[{"id":"81032","content":"有点过誉了，受之有愧。<br><br>因为C++比较复杂，所以我划出了四个生命周期，方便特性的归类和理解，不然混在一起很容易把思路弄乱。<br><br>C++需要在实践中学，要花的时间和精力还是挺多的，不过乐趣也自在其中。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590022375,"ip_address":"","comment_id":219322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40244693902","product_id":100051801,"comment_content":"第三次学习这节课的内容，感觉自己总算明白了罗老师的苦心。<br>与一般的C++课不同，罗老师完全不讲语法要素这些百度一大把，而是从工作的原理和本质去剖析C++。<br>我记得开课的第一讲，罗老师就这么说过，当时没啥体会，现在越发觉得这样的编排确实很高级。<br>虽然对于我这种没怎么用过C++的人来说，接受所有信息有点吃力，但反而使我开阔视野，学习C++的时候，不会被限制语法语义的规则上，你还可以和预处理器、编译器打交道，让你的代码更好的让人和机器读懂。<br>什么场景应该和预处理器沟通一下，什么时候和编译器沟通一下，这些都是高级的编程技巧。这些沟通也许是非必要的，但是掌握这些沟通技巧，在编程的时候将如鱼得水。<br>对C++的钻研还不够深，功力不够，没发对老师的思考题发表有营养的见解，就这么表达一下自己的感受吧。","like_count":9,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495764,"discussion_content":"有点过誉了，受之有愧。\n\n因为C++比较复杂，所以我划出了四个生命周期，方便特性的归类和理解，不然混在一起很容易把思路弄乱。\n\nC++需要在实践中学，要花的时间和精力还是挺多的，不过乐趣也自在其中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590022375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218724,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1589859770,"is_pvip":false,"replies":[{"id":"80827","content":"<br>1.课程都是预先录好的，所以不能及时回答，有问题写在留言里，我可以回复，还是希望自己思考得到答案。<br><br>2.静态断言的用处很多，判断32&#47;64只是个最简单的例子，只要能够在编译阶段计算出的结果就可以断言，不过这就需要对编译阶段有比较多的认识了。<br>不用着急，慢慢学C++，了解了泛型后再看静态断言可能就会好懂一些。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589863592,"ip_address":"","comment_id":218724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14474761658","product_id":100051801,"comment_content":"老师可以在每讲开始讲讲上一讲提到的问题吗？很多疑惑~<br>用“静态断言”，是不是在代码严格要求是32位系统或者64位系统的时候也比较有用呢？32位系统和64位系统本身有的类型所占字节数不同。","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495555,"discussion_content":"\n1.课程都是预先录好的，所以不能及时回答，有问题写在留言里，我可以回复，还是希望自己思考得到答案。\n\n2.静态断言的用处很多，判断32/64只是个最简单的例子，只要能够在编译阶段计算出的结果就可以断言，不过这就需要对编译阶段有比较多的认识了。\n不用着急，慢慢学C++，了解了泛型后再看静态断言可能就会好懂一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589863592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218524,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1589813885,"is_pvip":false,"replies":[{"id":"80782","content":"good","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589844898,"ip_address":"","comment_id":218524,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10179748477","product_id":100051801,"comment_content":"预处理可以自定义是直接将定义好的内容写到源码里，而标签不能自定义是因为编译器需要识别标签名","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495498,"discussion_content":"good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589844898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269041,"discussion_content":"老师可以在每讲开始讲讲上一讲提到的问题吗？很多疑惑~ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589859579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217498,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1589518019,"is_pvip":false,"replies":[{"id":"80483","content":"嗯，这也是我反复思考才得出的经验。<br>","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589539179,"ip_address":"","comment_id":217498,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179452611","product_id":100051801,"comment_content":"受语言的限制，编译阶段编程就只能“魔改”那些传统的语法要素了：把类当成函数，把模板参数当成函数参数，把“::”当成 return 返回值。<br><br>这个说法真形象，那些乱七八糟的语法一下就不面目可憎了。","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495168,"discussion_content":"嗯，这也是我反复思考才得出的经验。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589539179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217066,"user_name":"牙医","can_delete":false,"product_type":"c1","uid":1108159,"ip_address":"","ucode":"27791DFF11EF45","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/bf/39042a46.jpg","comment_is_top":false,"comment_ctime":1589415921,"is_pvip":false,"replies":[{"id":"80260","content":"模板元编程比较复杂，不会也没关系，用面向对象+泛型也可以写得很开心。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589417505,"ip_address":"","comment_id":217066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179350513","product_id":100051801,"comment_content":"模版元编程，劝退多少c++码农啊","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495029,"discussion_content":"模板元编程比较复杂，不会也没关系，用面向对象+泛型也可以写得很开心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589417505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217061,"user_name":"Carlos","can_delete":false,"product_type":"c1","uid":1898075,"ip_address":"","ucode":"F1B9951E9845D2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/5b/8e321b62.jpg","comment_is_top":false,"comment_ctime":1589415038,"is_pvip":false,"replies":[{"id":"80267","content":"<br>1.回答沾点边。实际上是因为属性标签必须要由编译器解释，而自定义标签编译器是不认识的，所以只能等编译器开发者去加，而不能是自己加。<br><br>2.说的比较好。<br>静态断言是一种对编译环境的“前提”“假设”，要求在编译阶段必须如何如何，可以结合第1讲的生命周期，考虑一下应该如何发挥它的作用。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589418389,"ip_address":"","comment_id":217061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179349630","product_id":100051801,"comment_content":"不得不说这节课让我回忆起了自己刚学会 vim macros 的感觉: 原来是我的想象力限制了 vim... 现在我想说: 原来是我的想象力限制了 c++...🧠<br><br>今天两个问题我都不是很懂, 希望老师指正. <br><br>1. 预处理阶段就是简单的文字替换, 编译阶段的属性标签应该需要编译器对这个标签进行 &quot;一系列&quot; 的配合, 过于复杂, 自己写容易翻车.<br>2. 要写简洁易懂的备注, 告诉别人为什么我要在这里终止编译对你进行提醒. ","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495028,"discussion_content":"\n1.回答沾点边。实际上是因为属性标签必须要由编译器解释，而自定义标签编译器是不认识的，所以只能等编译器开发者去加，而不能是自己加。\n\n2.说的比较好。\n静态断言是一种对编译环境的“前提”“假设”，要求在编译阶段必须如何如何，可以结合第1讲的生命周期，考虑一下应该如何发挥它的作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589418389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217355,"user_name":"Tedeer","can_delete":false,"product_type":"c1","uid":1693287,"ip_address":"","ucode":"7DD9837A38378D","user_header":"https://static001.geekbang.org/account/avatar/00/19/d6/67/5e0cac1b.jpg","comment_is_top":false,"comment_ctime":1589468742,"is_pvip":false,"replies":[{"id":"80411","content":"Android和Java不太熟，不是很了解。但我觉得，属性和断言都是源码级别的，如果反编译这些信息应该是看不见的。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589493169,"ip_address":"","comment_id":217355,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884436038","product_id":100051801,"comment_content":"老师，因为在做Android时，会做一些java层的反编译；很少做so库的反编译，我很好奇so反编译生成的代码还会有这些属性标签和断言吗？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495120,"discussion_content":"Android和Java不太熟，不是很了解。但我觉得，属性和断言都是源码级别的，如果反编译这些信息应该是看不见的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589493169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359150,"user_name":"Geek_3a0eeb","can_delete":false,"product_type":"c1","uid":2608601,"ip_address":"北京","ucode":"7C57D79CED4BC9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mticjmrhDj38u9rsnrgaclgAcFVYNlq1WjFrX1AnoMVwviaZxjWytcQG1iawv2SwwE0WzDpZPGicMAf00MKjYJ2BWQ/132","comment_is_top":false,"comment_ctime":1665290344,"is_pvip":false,"replies":[{"id":"130639","content":"assert可以当做是一种代码级别的注释，在调试开发的时候还是有用的，一般都是在debug版本生效。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1665355043,"ip_address":"北京","comment_id":359150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1665290344","product_id":100051801,"comment_content":"请问工程代码中会常用到断言吗？断言在win环境，vc的release是不能用的吧？在linux好像是debug和release都可以.","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589834,"discussion_content":"assert可以当做是一种代码级别的注释，在调试开发的时候还是有用的，一般都是在debug版本生效。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665355043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313433,"user_name":"于小咸","can_delete":false,"product_type":"c1","uid":1640946,"ip_address":"","ucode":"833D5E92016430","user_header":"https://static001.geekbang.org/account/avatar/00/19/09/f2/6ed195f4.jpg","comment_is_top":false,"comment_ctime":1632440745,"is_pvip":false,"replies":[{"id":"113534","content":"这里的编译期元函数实际上是结构体struct，并不是真正的函数，而且运算都是在编译期完成的，最后留在二进制文件里的都是最终的计算结果。<br><br>至于代码膨胀，我觉得现在不需要去特别关心，要注意80-20原则，可能我们在这里省了一点点，根本弥补不了其他地方的浪费。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1632469888,"ip_address":"","comment_id":313433,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632440745","product_id":100051801,"comment_content":"请问这样写斐波那契数列，会不会造成代码膨胀的问题呀？我理解对每一个数都会生成一个对应的函数","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527349,"discussion_content":"这里的编译期元函数实际上是结构体struct，并不是真正的函数，而且运算都是在编译期完成的，最后留在二进制文件里的都是最终的计算结果。\n\n至于代码膨胀，我觉得现在不需要去特别关心，要注意80-20原则，可能我们在这里省了一点点，根本弥补不了其他地方的浪费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632469888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308172,"user_name":"Geek_358817","can_delete":false,"product_type":"c1","uid":2695697,"ip_address":"","ucode":"9F499F6438FB7A","user_header":"https://static001.geekbang.org/account/avatar/00/29/22/11/cab6ca42.jpg","comment_is_top":false,"comment_ctime":1629439431,"is_pvip":false,"replies":[{"id":"111642","content":"great","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1629518000,"ip_address":"","comment_id":308172,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629439431","product_id":100051801,"comment_content":"assert做文档形式的 代码<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525415,"discussion_content":"great","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629518000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250857,"user_name":"承君此诺","can_delete":false,"product_type":"c1","uid":1159765,"ip_address":"","ucode":"1B25D59743C0AD","user_header":"https://static001.geekbang.org/account/avatar/00/11/b2/55/61b3e9e3.jpg","comment_is_top":false,"comment_ctime":1601262348,"is_pvip":false,"replies":[{"id":"91794","content":"目前的静态断言只能是error，暂时没有编译期的warning。<br><br>顺便再说一句，gcc好像可以用-W选项来控制如何输出告警，具体可以去查一下它的手册。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1601279651,"ip_address":"","comment_id":250857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601262348","product_id":100051801,"comment_content":"如何在编译期输出warning提示不是error。<br>如我用宏开关屏蔽了多种方案细节，某方案由于未足够测试等原因，不建议但允许使用。这时用静态断言就不合适了。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506313,"discussion_content":"目前的静态断言只能是error，暂时没有编译期的warning。\n\n顺便再说一句，gcc好像可以用-W选项来控制如何输出告警，具体可以去查一下它的手册。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601279651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245295,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1598886399,"is_pvip":true,"replies":[{"id":"90215","content":"说的挺好，编译阶段的属性和静态断言还需要多在实际中使用才能理解它的好处。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1598921804,"ip_address":"","comment_id":245295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598886399","product_id":100051801,"comment_content":"预处理阶段可以自定义宏，但编译阶段不能自定义属性标签，这是为什么呢？<br>编译阶段是编译为二进制代码，跟编译器打交道，如果自定义属性编译器也无法理解<br>预处理器是进行文本替换的<br><br>你觉得，怎么用“静态断言”，才能更好地改善代码质量？<br>比如对于平台的断言<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504836,"discussion_content":"说的挺好，编译阶段的属性和静态断言还需要多在实际中使用才能理解它的好处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598921804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223135,"user_name":"Eason Tai","can_delete":false,"product_type":"c1","uid":1200676,"ip_address":"","ucode":"4707577CC9C9E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/24/bd63c4de.jpg","comment_is_top":false,"comment_ctime":1591006793,"is_pvip":false,"replies":[{"id":"82265","content":"混合了宏定义和条件编译，实在是难以看懂。<br><br>可以直接gdb，看open到底是什么。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591059935,"ip_address":"","comment_id":223135,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591006793","product_id":100051801,"comment_content":"有一个问题：<br>比如，在 libc-headers&#47;fcntl.h 定义了 open，那么看到open函数是如何实现的呢？<br>```cpp<br>&#47;* Open FILE and return a new file descriptor for it, or -1 on error.<br>   OFLAG determines the type of access used.  If O_CREAT or O_TMPFILE is set<br>   in OFLAG, the third argument is taken as a `mode_t&#39;, the mode of the<br>   created file.<br><br>   This function is a cancellation point and therefore not marked with<br>   __THROW.  *&#47;<br>#ifndef __USE_FILE_OFFSET64<br>extern int open (const char *__file, int __oflag, ...) __nonnull ((1));<br>#else<br># ifdef __REDIRECT<br>extern int __REDIRECT (open, (const char *__file, int __oflag, ...), open64)<br>     __nonnull ((1));<br># else<br>#  define open open64<br># endif<br>#endif<br>#ifdef __USE_LARGEFILE64<br>extern int open64 (const char *__file, int __oflag, ...) __nonnull ((1));<br>#endif<br>```<br><br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497023,"discussion_content":"混合了宏定义和条件编译，实在是难以看懂。\n\n可以直接gdb，看open到底是什么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591059935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218178,"user_name":"～灯火阑珊","can_delete":false,"product_type":"c1","uid":2004985,"ip_address":"","ucode":"B26CB4EA188C7A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/97/f9/3fcc851c.jpg","comment_is_top":false,"comment_ctime":1589729067,"is_pvip":false,"replies":[{"id":"80697","content":"<br>1.这面试题太细节了，我也没有深究过，觉得这个题没什么意义。你的思路我觉得靠谱，可以展开来说。<br><br>2.在编译期断言各种条件，比如必须是64位平台，类型必须是指针，类型必须有某个成员函数，类型必须可以拷贝等等，需要有编译期的思维方式。<br><br>3.是相当于动态语言而言的，比如Python、php，变量类型是动态的。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589763606,"ip_address":"","comment_id":218178,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589729067","product_id":100051801,"comment_content":"1.之前碰过一道面试题问：C++ assert的断言是怎么实现的？ 如何编写跨平台的断言函数？. 我当时答的调用abort，感觉不好。这里不是可以从静态断言和动态断言两个方面答啊。老师对于这到面试题可不可以给点思路？<br> <br>2.文中&quot;static_assert 可以在编译阶段定义各种前置条件，充分利用 C++ 静态类型语言的优势&quot;, 这句没理解可以举个例子么？ 可以定义哪些前置条件啊？ 《C++ 是静态类型语言》这个怎么理解呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495370,"discussion_content":"\n1.这面试题太细节了，我也没有深究过，觉得这个题没什么意义。你的思路我觉得靠谱，可以展开来说。\n\n2.在编译期断言各种条件，比如必须是64位平台，类型必须是指针，类型必须有某个成员函数，类型必须可以拷贝等等，需要有编译期的思维方式。\n\n3.是相当于动态语言而言的，比如Python、php，变量类型是动态的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589763606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218012,"user_name":"silverhawk","can_delete":false,"product_type":"c1","uid":1018649,"ip_address":"","ucode":"BFBC8AF32868DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/19/a15d060d.jpg","comment_is_top":false,"comment_ctime":1589695046,"is_pvip":false,"replies":[{"id":"80633","content":"目前的C++11这块的确很弱，没办法，标准委员会效率就是低，不像公司那样无阻力大干快上。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589703354,"ip_address":"","comment_id":218012,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589695046","product_id":100051801,"comment_content":"属性这个，比起Java，python差好多，有了属性可以编译器静态的检查很多OO编程，比如override之类的对不对啊","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495323,"discussion_content":"目前的C++11这块的确很弱，没办法，标准委员会效率就是低，不像公司那样无阻力大干快上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589703354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217967,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1589684483,"is_pvip":false,"replies":[{"id":"80623","content":"说的很好。<br><br>不过后面的static_const不知道是什么，没这个关键字。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589688139,"ip_address":"","comment_id":217967,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1589684483","product_id":100051801,"comment_content":"1 预处理阶段的宏是我们自己来处理的，标签是编译器来处理，除非开发拓展编译器才需要或可以定义标签<br>2 static_assert 可以在编译时检查是否满足编译环境要求，不满足直接编译失败，static_const 也类似吧！<br><br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495310,"discussion_content":"说的很好。\n\n不过后面的static_const不知道是什么，没这个关键字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589688139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268396,"discussion_content":"static_cast就是普通的转型操作，是运行时的动作，但它的能力特意做了限制，避免任意转型出错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589768512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061517,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","nickname":"幻境之桥","note":"","ucode":"F9F4DD94CB554E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267947,"discussion_content":"不好意思手滑，我的意思是 static_cast \n这个本质上编译器是怎么处理的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589716271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217731,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1589598361,"is_pvip":false,"replies":[{"id":"80533","content":"<br>1.预处理器不需要理解宏，只是文本替换，而编译器必须要理解属性才能处理，自定义属性标签相当于是“外来语”，识别不了编译器就无法工作。<br><br>2.这个只是最基本的用法，随着对C++理解的深入，还可以对类型做各种静态检查。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589610800,"ip_address":"","comment_id":217731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589598361","product_id":100051801,"comment_content":"1. 预处理不受编译器控制，由预处理器负责，给予宏的自由度比较大；而属性标签是为了简化编译器工作，而非为了扩展；<br>2. 例如在编译阶段检查x64还得x86，跟常量运算有关的逻辑判断。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495243,"discussion_content":"\n1.预处理器不需要理解宏，只是文本替换，而编译器必须要理解属性才能处理，自定义属性标签相当于是“外来语”，识别不了编译器就无法工作。\n\n2.这个只是最基本的用法，随着对C++理解的深入，还可以对类型做各种静态检查。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589610800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217634,"user_name":"lxw","can_delete":false,"product_type":"c1","uid":1939757,"ip_address":"","ucode":"6CAFE1E0BE4997","user_header":"https://static001.geekbang.org/account/avatar/00/1d/99/2d/279c66d6.jpg","comment_is_top":false,"comment_ctime":1589552927,"is_pvip":false,"replies":[{"id":"80496","content":"我常用的就是vim，你可能不太习惯，其他的没用过，抱歉。<br><br>可以参考其他同学，用vs code，然后用插件远程登录Linux。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589583887,"ip_address":"","comment_id":217634,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1589552927","product_id":100051801,"comment_content":"希望老师推荐一款Ubuntu16.4下C++编辑器或IDE，谢谢🙏","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495198,"discussion_content":"我常用的就是vim，你可能不太习惯，其他的没用过，抱歉。\n\n可以参考其他同学，用vs code，然后用插件远程登录Linux。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589583887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2057037,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLsdGPnevLGGo7olu5mtwIphut7No31e4h7Cmf6qwuiblwL6O5YrEgnc1psU5mzVGxl9qEfu5bJfsA/132","nickname":"王建业","note":"","ucode":"0BC74E55D85243","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340827,"discussion_content":"linux下C++编辑器，可以用eclipse","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610171616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009464,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/38/3f617799.jpg","nickname":"张家聚","note":"","ucode":"5EC64E717CA570","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268779,"discussion_content":"尝试一下spacemacs？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589816914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217463,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1589508909,"is_pvip":false,"replies":[{"id":"80465","content":"没用过vs，不好帮你。<br><br>不过我觉得上网搜一下，应该是个常见的问题，有解决方案。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589513353,"ip_address":"","comment_id":217463,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1589508909","product_id":100051801,"comment_content":"在vs中使用 标记 deprecated 的方法 好像会报错<br>c4996<br>加上 宏可以解除报错 但也没有警告<br>不知道老师有没有办法","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495155,"discussion_content":"没用过vs，不好帮你。\n\n不过我觉得上网搜一下，应该是个常见的问题，有解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589513353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2710729,"avatar":"https://static001.geekbang.org/account/avatar/00/29/5c/c9/f1b053f2.jpg","nickname":"Family mission","note":"","ucode":"10D4D65520FE0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531883,"discussion_content":"这是设置的问题，vs把警告级别当错误来处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637457687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217287,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1589454890,"is_pvip":false,"replies":[{"id":"80325","content":"后面还有很多我在实际中的经验总结，可以慢慢看，有什么地方没讲到的也可以提，知无不言言无不尽。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589461200,"ip_address":"","comment_id":217287,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589454890","product_id":100051801,"comment_content":"学习了不少知识，期待老师能多讲讲C++ 一些在项目实战中 比较好用的方法。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495101,"discussion_content":"后面还有很多我在实际中的经验总结，可以慢慢看，有什么地方没讲到的也可以提，知无不言言无不尽。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589461200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217283,"user_name":"alioo","can_delete":false,"product_type":"c1","uid":1022507,"ip_address":"","ucode":"F36A38C1F5FFAB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","comment_is_top":false,"comment_ctime":1589453942,"is_pvip":false,"replies":[{"id":"80324","content":"注意，-E处理的是预处理阶段的宏，而template是编译阶段，这是两个完全不同的阶段。<br><br>编译阶段出来的结果直接就是二进制码了，是看不到源码的。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589461159,"ip_address":"","comment_id":217283,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1589453942","product_id":100051801,"comment_content":"老师好，我看前面的回答是说template是在编译阶段完成的，但是我使用g++ compile.cpp -E发现并没有像上一节的宏，宏直接就计算出值了，然而template却没有计算","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495100,"discussion_content":"注意，-E处理的是预处理阶段的宏，而template是编译阶段，这是两个完全不同的阶段。\n\n编译阶段出来的结果直接就是二进制码了，是看不到源码的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589461159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265978,"discussion_content":"可以参考一下我在部落里的文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589462469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022507,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","nickname":"alioo","note":"","ucode":"F36A38C1F5FFAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265971,"discussion_content":"感谢老师的回复，还有一点不解：如果编译期间就已经完成了计算，运行期就是一个固定值了，这么看template存在的价值就不大了。完全可以提前单独写个工具，把需要的提前计算出来，在需要使用的程序里去使用计算后的值就行了呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589461933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217261,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589450755,"is_pvip":false,"replies":[{"id":"80323","content":"great。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589461089,"ip_address":"","comment_id":217261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589450755","product_id":100051801,"comment_content":"1.标签内置在编译器内部，无法进行自定义。<br>2.断言在编译期间配合错误检查，能提前发现代码漏洞。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495092,"discussion_content":"great。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589461089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217231,"user_name":"Seven","can_delete":false,"product_type":"c1","uid":1656378,"ip_address":"","ucode":"6F502CDCAD7A79","user_header":"https://static001.geekbang.org/account/avatar/00/19/46/3a/35d9cc02.jpg","comment_is_top":false,"comment_ctime":1589444419,"is_pvip":false,"replies":[{"id":"80306","content":"所谓英雄所见略同。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589448465,"ip_address":"","comment_id":217231,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589444419","product_id":100051801,"comment_content":"属性名和Java中的相似","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495085,"discussion_content":"所谓英雄所见略同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589448465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217055,"user_name":"xianhai","can_delete":false,"product_type":"c1","uid":1073505,"ip_address":"","ucode":"906578663CEB3E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/61/677e8f92.jpg","comment_is_top":false,"comment_ctime":1589414186,"is_pvip":false,"replies":[{"id":"80268","content":"“-DNDEBUG”定义了一个宏，表示禁用assert断言，是我前期调试测试用的，现在在这里确实没什么用，你可以忽略它。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1589418599,"ip_address":"","comment_id":217055,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589414186","product_id":100051801,"comment_content":"看了老师的github代码，对这一行代码有点不理解 g++ compile.cpp -DNDEBUG -std=c++11 -o a.out;.&#47;a.out<br><br>似乎-DNDEBUG 没什么用？ NDEBUG既不是predefined macro， 在代码中也没有使用这个macro，在这里有什么作用呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495024,"discussion_content":"“-DNDEBUG”定义了一个宏，表示禁用assert断言，是我前期调试测试用的，现在在这里确实没什么用，你可以忽略它。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589418599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}