{"id":131899,"title":"05 | 消息序号生成器：如何保证你的消息不会乱序？","content":"<p>你好，我是袁武林。</p><p>前面几节课，我们较为系统地介绍了如何解决消息实时到达的问题，也对保证消息可靠投递实战中常用的方式进行了一一讲解。</p><p>那么，今天的课程我们继续一起聊一聊，IM系统设计中另一个比较复杂，但又非常重要的话题：消息收发的一致性。需要提醒的是，我们这里的讲到的一致性，一般来说是指消息的时序一致性。</p><h2>为什么消息的时序一致性很重要？</h2><p>对于聊天、直播互动等业务来说，消息的时序代表的是发送方的意见表述和接收方的语义逻辑理解，如果时序一致性不能保证，可能就会造成聊天语义不连贯、容易出现曲解和误会。</p><p>你可以想象一下，一个人说话颠三倒四，前言不搭后语的样子，就理解我们为什么要尤其注重消息的时序一致性了。</p><p>对于点对点的聊天场景，时序一致性需要保证接收方的接收顺序和发送方的发出顺序一致；而对于群组聊天，时序一致性保证的是群里所有接收人看到的消息展现顺序都一样。</p><h2>为什么保证消息的时序一致性很困难？</h2><p>从理论上来说，保持消息的时序一致性貌似并不难。理论上，我们想象的消息收发场景中，只有单一的发送方、单一的接收方。</p><p>如果发送方和接收方的消息收发都是单线程操作，并且和IM服务端都只有唯一的一个TCP连接，来进行消息传输，IM服务端也只有一个线程来处理消息接收和消息推送。这种场景下，消息的时序一致性是比较容易能得到保障的。</p><!-- [[[read_end]]] --><p>但在实际的后端工程实现上，由于单发送方、单接收方、单处理线程的模型吞吐量和效率都太低，基本上不太可能存在。</p><p>更多的场景下，我们可能需要面对的是多发送方、多接收方、服务端多线程并发处理的情况。所以，知道了难点，我们再来看一看究竟在后端的工程实现上，保证消息的时序一致都存在哪些难点。</p><p>消息的时序一致性其实是要求我们的消息具备“时序可比较性”，也就是消息相对某一个共同的“时序基准”可以来进行比较，<strong>所以，要保证消息的时序一致性的一个关键问题是：我们是否能找到这么一个时序基准，使得我们的消息具备“时序可比较性”。</strong></p><p><strong>在工程实现上，我们可以分成这样几步。</strong></p><ul>\n<li>首先是：如何找到时序基准。</li>\n<li>其次是：时序基准的可用性问题。</li>\n<li>最后是：有了时序基准，还有其他的误差吗，有什么办法可以减少这些误差？</li>\n</ul><h2>如何找到时序基准？</h2><p>下面我从消息收发的实际场景来分析一下，收发过程中如何找到一个全局的“时序基准”。在这里，我们来逐一分析一下。</p><p>首先，<strong>我们来看看发送方的本地序号和本地时钟是否可以作为“时序基准”？</strong></p><p>这里解释一下，所谓发送方的本地序号和本地时钟是指发送方在发送消息时连同消息再携带一个本地的时间戳或者本地维护的一个序号给到IM服务端，IM服务端再把这个时间戳或者序号和消息一起发送给消息接收方，消息接收方根据这个时间戳或者序号来进行消息的排序。</p><p>仔细分析一下，貌似发送方的本地序号或者本地时钟不适合用来作为接收方排序的“时序基准”，原因有下面几点。</p><ol>\n<li>\n<p>发送方时钟存在较大不稳定因素，用户可以随时调整时钟导致序号回退等问题。</p>\n</li>\n<li>\n<p>发送方本地序号如果重装应用会导致序号清零，也会导致序号回退的问题。</p>\n</li>\n<li>\n<p>类似“群聊消息”和“单用户的多点登录”这种多发送方场景，都存在：同一时钟的某一时间点，都可能有多条消息发给同一接收对象。比如同一个群里，多个人同时发言；或者同一个用户登录两台设备，两台设备同时给某一接收方发消息。多设备间由于存在时钟不同步的问题，并不能保证设备带上来的时间是准确的，可能存在群里的用户A先发言，B后发言，但由于用户A的手机时钟比用户B的慢了半分钟，如果以这个时间作为“时序基准”来进行排序，可能反而导致用户A的发言被认为是晚于用户B的。</p>\n</li>\n</ol><p>因此以发送方的本地时钟或者本地序号作为“时序基准”是不可靠的。那么，我们接下来看看<strong>IM服务器的本地时钟是否可以作为“时序基准”？</strong></p><p>这里也解释一下，IM服务器的本地时钟作为“时序基准”是指：发送方把消息提交给IM服务器后，IM服务器依据自身服务器的时钟生成一个时间戳，再把消息推送给接收方时携带这个时间戳，接收方依据这个时间戳来进行消息的排序。</p><p>我们分析一下，好像IM服务器的本地时钟作为接收方消息排序的“时序基准”也不太合适。</p><p>因为，在实际工程中，IM服务都是集群化部署，集群化部署也就是许多服务器同时部署任务。</p><p>虽然多台服务器通过NTP时间同步服务，能降低服务集群机器间的时钟差异到毫秒级别，但仍然还是存在一定的时钟误差，而且IM服务器规模相对比较大，时钟的统一性维护上也比较有挑战，整体时钟很难保持极低误差，因此一般也不能用IM服务器的本地时钟来作为消息的“时序基准”。</p><p><strong>既然单机本地化的时钟或者序号都存在问题，那么如果有一个全局的时钟或者序号是不是就能解决这个问题了呢？所有的消息的排序都依托于这个全局的序号，这样就不存在时钟不同步的问题了。那么最后，我们来看看IM服务端的全局序列是否可以作为“时序基准”？</strong></p><p>比如说如果有一个全局递增的序号生成器，应该就能避免多服务器时钟不同步的问题了，IM服务端就能通过这个序号生成器发出的序号，来作为消息排序的“时序基准”。</p><p>而且这种“全局序号生成器”可以通过多种方式来实现，常见的比如Redis的原子自增命令incr，DB自带的自增id，或者类似Twitter的snowflake算法、“时间相关”的分布式序号生成服务等。</p><h2>“时序基准”的可用性问题</h2><p>使用“全局序号生成器”发出的序号，来作为消息排序的“时序基准”，能解决每一条消息没有标准“生产日期”的问题。但如果是面向高并发和需要保证高可用的场景，还需要考虑这个“全局序号生成器”的可用性问题。</p><p>首先，类似Redis的原子自增和DB的自增id，都要求在主库上来执行“取号”操作，而主库基本都是单点部署，在可用性上的保障会相对较差，另外，针对高并发的取号操作这个单点的主库可能容易出现性能瓶颈。</p><p>而采用类似snowflake算法的时间相关的分布式“序号生成器”，虽然在发号性能上一般问题不大，但也存在一些问题。</p><p>一个是发出的号携带的时间精度有限，一般能到秒级或者毫秒级，比如微博的ID生成器就是精确到秒级的，另外由于这种服务大多都是集群化部署，携带的时间采用的服务器时间，也存在时钟不一致的问题（虽然时钟同步上比控制大量的IM服务器也相对容易一些）。</p><p><strong>由上可知，基于“全局序号生成器”仍然存在不少问题，那这样是不是说基于“全局序号生成器”生成的序号来对消息进行排序的做法不可行呢？</strong></p><p>我们从后端业务实现的角度，来具体分析一下。</p><p>从业务层面考虑，对于群聊和多点登录这种场景，没有必要保证全局的跨多个群的绝对时序性，只需要保证某一个群的消息有序即可。</p><p>这样的话，如果可以针对每一个群有独立一个“ID生成器”，能通过哈希规则把压力分散到多个主库实例上，大量降低多群共用一个“ID生成器”的并发压力。</p><p>对于大部分即时消息业务来说，产品层面可以接受消息时序上存在一定的细微误差，比如同一秒收到同一个群的多条消息，业务上是可以接受这一秒的多条消息，未严格按照“接收时的顺序”来排序的，实际上，这种细微误差对于用户来说，基本也是无感知的。</p><p>那么，对于依赖“分布式的时间相关的ID生成器”生成的序号来进行排序，如果时间精度业务上可以接受也是没问题的。</p><p>从之前微信对外的分享，我们可以了解到：微信的聊天和朋友圈的消息时序也是通过一个“递增”的版本号服务来进行实现的。不过这个版本号是每个用户独立空间的，保证递增，不保证连续。</p><p>微博的消息箱则是依赖“分布式的时间相关的ID生成器”来对私信、群聊等业务进行排序，目前的精度能保证秒间有序。</p><h2>“时序基准”之外的其他误差</h2><p>有了“时序基准”，是不是就能确保消息能按照“既定顺序”到达接收方呢？答案是并不一定能做到。原因在于下面两点。</p><ol>\n<li>\n<p>IM服务器都是集群化部署，每台服务器的机器性能存在差异，因此处理效率有差别，并不能保证先到的消息一定可以先推送到接收方，比如有的服务器处理得慢，或者刚好碰到一次GC，导致它接收的更早消息，反而比其他处理更快的机器更晚推送出去。</p>\n</li>\n<li>\n<p>IM服务端接收到发送方的消息后，之后相应的处理一般都是多线程进行处理的，比如“取序号”“暂存消息”“查询接收方连接信息”等，由于多线程处理流程，并不能保证先取到序号的消息能先到达接收方，这样的话对于多个接收方看到的消息顺序可能是不一致的。</p>\n</li>\n</ol><p>所以一般还需要端上能支持对消息的“本地整流”。我们来看一下本地整流。</p><h3>消息服务端包内整流</h3><p>虽然大部分情况下，聊天、直播互动等即时消息业务能接受“小误差的消息乱序”，但某些特定场景下，可能需要IM服务能保证绝对的时序。</p><p>比如发送方的某一个行为同时触发了多条消息，而且这多条消息在业务层面需要严格按照触发的时序来投递。</p><p>一个例子：用户A给用户B发送最后一条分手消息同时勾上了“取关对方”的选项，这个时候可能会同时产生“发消息”和“取关”两条消息，如果服务端处理时，把“取关”这条信令消息先做了处理，就可能导致那条“发出的消息”由于“取关”了，发送失败的情况。</p><p>对于这种情况，我们一般可以调整实现方式，在发送方对多个请求进行业务层合并，多条消息合并成一条；也可以让发送方通过单发送线程和单TCP连接能保证两条消息有序到达。</p><p>但即使IM服务端接收时有序，由于多线程处理的原因，真正处理或者下推时还是可能出现时序错乱的问题，解决这种“需要保证多条消息绝对有序性”可以通过IM服务端包内整流来实现。</p><p>比如：我们在实现离线推送时，在网关机启动后会自动订阅一个本IP的Topic，当用户上线时，网关机会告知业务层用户有上线操作，这时业务层会把这个用户的多条离线消息pub给这个用户连接的那个网关机订阅的Topic，当网关机收到这些消息后，再通过长连接推送给用户，整个过程大概是下图这样的。<br>\n<img src=\"https://static001.geekbang.org/resource/image/85/5f/85d6aa4b551a21c34ed6501ecf19445f.png?wh=1024*768\" alt=\"\"></p><p>但是很多时候会出现Redis队列组件的Sharding和网关机多线程消费处理导致乱序的情况，这样，如果一些信令（比如删除所有会话）的操作被乱序推送给客户端，可能就会造成端上的逻辑错误。</p><p>然后再说一下离线推送服务端整流的过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/b8/f97ce351151a86cd7cfb06d7f58513b8.png?wh=1024*768\" alt=\"\"></p><ul>\n<li>首先，生产者为每个消息包生成一个packageID，为包内的每条消息加个有序自增的seqId。</li>\n<li>其次，消费者根据每条消息的packageID和seqID进行整流，最终执行模块只有在<strong>一定超时时间内完整有序</strong>地收到所有消息才执行最终操作，否则将根据业务需要触发重试或者直接放弃操作。通过服务端整流，服务端包内整流大概就是图中这个样子，我们要做的是在最终服务器取到TCP连接后下推的时候，根据包的ID，对一定时间内的消息做一个整流和排序，这样即使服务端处理多条消息时出现乱序，仍然可以在最终推送给客户端时整流为有序的。</li>\n</ul><h3>消息接收端整流</h3><p>携带不同序号的消息到达接收端后，可能会出现“先产生的消息后到”“后产生的消息先到”等问题，消息接收端的整流就是解决这样的一个问题的。</p><p>消息客户端本地整流的方式可以根据具体业务的特点来实现，目前业界比较常见的实现方式比较简单，步骤如下：</p><ol>\n<li>\n<p>下推消息时，连同消息和序号一起推送给接收方；</p>\n</li>\n<li>\n<p>接收方收到消息后进行判定，如果当前消息序号大于前一条消息的序号就将当前消息追加在会话里；</p>\n</li>\n<li>\n<p>否则继续往前查找倒数第二条、第三条等，一直查找到恰好小于当前推送消息的那条消息，然后插入在其后展示。</p>\n</li>\n</ol><h2>小结</h2><p>今天我们讲到了在多发送方、多接收方、服务端多线程并发处理的情况下，保持消息时序一致的重要性及处理方法。</p><p>对于聊天、直播互动等即时消息的场景，保持消息的时序一致性能避免发送方的意见表述和接收方的语义理解出现偏差的情况。</p><p>对于如何保持消息的时序一致性的关键点在于需要找到一个时序基准来标识每一条消息的顺序。这个时序基准可以通过全局的序号生成器来确定，常见的实现方式包括<strong>支持单调自增序号的资源生成</strong>，或者<strong>分布式时间相关的ID生成服务生成</strong>，两种方式各有一些限制，不过，你都可以根据业务自身的特征来进行选择。</p><p>有了通过时序基准确定的消息序号，由于IM服务器差异和多线程处理的方式，不能保证先服务端的消息一定能先推到接收方，可以通过“服务端包内整流”机制来保证需要“严格有序”的批量消息的正确执行，或者接收方根据消息序号来进行消息本地整流，从而确保多接收方的最终一致性。</p><p>最后给你留一道思考题。<strong>在即时消息收发场景中，用于保证消息接收时序的序号生成器为什么可以不是全局递增的？</strong></p><p>以上就是今天课程的内容，欢迎你给我留言，我们可以在留言区一起讨论。感谢你的收听，我们下期再见。</p>","comments":[{"had_liked":false,"id":132415,"user_name":"深藏Blue","can_delete":false,"product_type":"c1","uid":1031616,"ip_address":"","ucode":"CBEBCBDA47281C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/c0/57b06721.jpg","comment_is_top":false,"comment_ctime":1568116120,"is_pvip":false,"replies":[{"id":"50660","content":"具体的量级是多少呀？消息使用场景是写多读少还是读多写少？量级小的话存储用mysql就可以，量级大的话也可以考虑hbase。nio框架用netty就可以，离线缓存buffer可以用redis或者pika，未读数放redis的hash里就可以。手机端mqtt改造一下或者直接json也可以，浏览器端就websocket + json就行。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568129944,"ip_address":"","comment_id":132415,"utype":1}],"discussion_count":5,"race_medal":0,"score":"177661775256","product_id":100034901,"comment_content":"最近遇到IM相关需求，好像是第一个收下这个专栏的极客er。请教栏主：能否指导下具体的技术选型？跪急！服务端主要由spring cloud系列开发，终端应用有  win  pc、安卓以及ios","like_count":40,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466925,"discussion_content":"具体的量级是多少呀？消息使用场景是写多读少还是读多写少？量级小的话存储用mysql就可以，量级大的话也可以考虑hbase。nio框架用netty就可以，离线缓存buffer可以用redis或者pika，未读数放redis的hash里就可以。手机端mqtt改造一下或者直接json也可以，浏览器端就websocket + json就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568129944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105014,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/76/8051e7f6.jpg","nickname":"蓝色街灯","note":"","ucode":"05C71812AAA122","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15840,"discussion_content":"用Websocket，服务端集群后怎么做高可用啊？ws是由状态的，某台服务器挂了后其上面的链接没发转移，不能像http那样做全局分布式session处理集群故障转移呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568855573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1285193,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9c/49/97b6060c.jpg","nickname":"凌翔","note":"","ucode":"9B72C54280EBDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1105014,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/76/8051e7f6.jpg","nickname":"蓝色街灯","note":"","ucode":"05C71812AAA122","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313098,"discussion_content":"某台ws挂掉，客户端需要心跳检测，然后重试连接，这个时候你的分布式算法可以找到健康的机器去处理ws，至于这期间未接受的可以按照上一节离线推送ack方案拉取回丢失的离线消息","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602941980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15840,"ip_address":""},"score":313098,"extra":""}]},{"author":{"id":1031616,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bd/c0/57b06721.jpg","nickname":"深藏Blue","note":"","ucode":"CBEBCBDA47281C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9293,"discussion_content":"\n由于具体业务场景涉及保密协议，不便多讲。类比简要描述一下：在一个直播间里，房主点击了某个按钮后，所有在该房间里面的其他用户的客户端里面同步点击同样的按钮，自动执行与房主一样的操作。换种类比就是：房主可以给其他用户客户端下命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568136647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031616,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bd/c0/57b06721.jpg","nickname":"深藏Blue","note":"","ucode":"CBEBCBDA47281C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9292,"discussion_content":"由于具体业务场景涉及保密协议，不便多讲。类比简要描述一下：在一个直播间里，房主点击了某个按钮后，所有在该房间里面的其他用户的客户端里面同步点击同样的按钮，自动执行与房主一样的操作。换种类比就是：房主可以给其他用户客户端下命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568136593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131395,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1567738399,"is_pvip":true,"replies":[{"id":"50621","content":"感谢您的建议，已增加了两张流程图来具体说明一下在离线消息推送过程中服务端整流的实现机制。","user_name":"编辑回复","user_name_real":"王惠","uid":"1640700","ctime":1568093564,"ip_address":"","comment_id":131395,"utype":2}],"discussion_count":7,"race_medal":0,"score":"147596626463","product_id":100034901,"comment_content":"希望老师多补充一些流程图或代码来帮助理解，光看文字因经验不足，有时很难想象理解，甚至会引发歧义。谢谢","like_count":35,"discussions":[{"author":{"id":1640700,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/fc/9a5fb5c5.jpg","nickname":"小王同学","note":"","ucode":"87C39D384F8991","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466431,"discussion_content":"感谢您的建议，已增加了两张流程图来具体说明一下在离线消息推送过程中服务端整流的实现机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568093564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102022,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/c6/0358a528.jpg","nickname":"Jin","note":"","ucode":"B298DB78C72769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21586,"discussion_content":"可以在详细说说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569502982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1187021,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","nickname":"Gojustforfun","note":"","ucode":"7513A40F27344F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8916,"discussion_content":"第一张图中，表示用户上线和消息下推的绿色箭头，方向反了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568100008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640700,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/fc/9a5fb5c5.jpg","nickname":"小王同学","note":"","ucode":"87C39D384F8991","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":1187021,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","nickname":"Gojustforfun","note":"","ucode":"7513A40F27344F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":8976,"discussion_content":"对不起，是编辑的问题，已更正。感谢您的指正，以后一定会多多注意！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568116144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8916,"ip_address":""},"score":8976,"extra":""}]},{"author":{"id":1379009,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0a/c1/2569cd2e.jpg","nickname":"Anvy","note":"","ucode":"9A4E007FAD935A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8816,"discussion_content":"可以更加落地表达就更好了 太多理论了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568075405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8403,"discussion_content":"图太少了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567997200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590892,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTImmLJCKerl9CI4sTpPDNCUgswp04ybsJ4J6mpJmMlHh43Iibp1RPOLam5PpOv2ZDGcjvGrY94lNRw/132","nickname":"Varphp","note":"","ucode":"889550391E3F75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8397,"discussion_content":"🤣我看完了  结果不知道具体咋搞才算好  有点懵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567995164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131511,"user_name":"王棕生","can_delete":false,"product_type":"c1","uid":1337944,"ip_address":"","ucode":"901BD0447A871E","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/58/f2c6d65b.jpg","comment_is_top":false,"comment_ctime":1567774105,"is_pvip":false,"replies":[{"id":"50318","content":"👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567841518,"ip_address":"","comment_id":131511,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83172152729","product_id":100034901,"comment_content":"问题： 在即时消息收发场景中，用于保证消息接收时序的序号生成器为什么可以不是全局递增的？<br>答： 这是由业务场景决定的，这个群的消息和另一个群的消息在逻辑上是完全隔离的，只要保证消息的序号在群这样的一个局部范围内是递增的即可； 当然如果可以做到全局递增最好，但是会浪费很多的资源，却没有带来更多的收益。<br><br>","like_count":20,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466493,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567841518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134955,"user_name":"javaworker","can_delete":false,"product_type":"c1","uid":1056209,"ip_address":"","ucode":"ABF9DDDBD3BDBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/d1/f427b83e.jpg","comment_is_top":false,"comment_ctime":1568962170,"is_pvip":true,"replies":[{"id":"51782","content":"1. 同一个接收人的消息个人感觉没必要用一个线程处理呀，这样还会让服务有状态，如果这个线程挂了后续消息处理的迁移啥的都会比较复杂。对于同一时间有多条消息发送给这个用户的情况，业务上实际也不需要严格区分这几条消息到底哪个先到服务端，只需要保证消息落地存储后时序性固定好就行。<br>2. 服务器集群规模太大的话依赖服务器时钟也是个问题，所以可以通过”全局的时间相关的序号生成器“来缓解。<br>3. 服务端整流一般用在离线消息处理的场景，因为这个时候会同时有很多条消息会推送给用户，需要保证时序性。比如一次离线消息的下推共用一个packageId，然后自增的针对每一条消息来绑定一个序号（0 1 2 3 ...)，这样下推网关根据packageId来有序收集所有消息，如果序号有缺失就知道有消息丢失了（但至少是有序的），这个时候可以根据业务需要来决定直接下推已收集消息还是放弃这一次离线下推。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568968831,"ip_address":"","comment_id":134955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48813602426","product_id":100034901,"comment_content":"老师，请教几个问题<br>1.您文中说消息通过网关后，IM后台都是并发处理，所以先发的消息有可能后到达。<br>我想问如果同时发给一个人的消息，也要IM后台并发处理吗？如果这样路由如何控制？比如其中一条消息丢了，我需要查问题，我如何能知道这条消息是路由到哪台机器哪个线程处理的？<br><br>2.您文中说IM时序基准以IM服务器的时间为准也不行，因为是集群部署。我公司现有IM系统，就是按照IM服务器的时间做的时序基准，比如A和B两个用户都给C发送消息，系统会按照C的userid按照一定路由规则，最终路由到一台消息服务器（比如叫msgserver.1），我们会拿msgserver.1的本地时间作为时序基准，客户端接收到消息后显示就按照msgserver.1的这个时间顺序显示。<br>我个人理解公司的IM系统从宏观上看多人的消息是并发处理的，但是针对到某个人其实是单线程处理的，这样好处就是系统设计简单一些，不会遇到您文中说的某台机器GC导致某条消息慢，自然也不会有服务端客户端整流的问题，因为单线程中某条消息慢，后面的消息也别想发出去，呵呵。<br>我想问公司这个处理消息的逻辑会有什么问题吗？还想问一下如果针对个人消息也并发处理，一般这个服务端整流的时间设置成多长合适？如果服务端整流收到9条消息，但是还有1条消息由于GC慢了点，整流服务器怎么知道少收了一条消息？从而在这个整流的时间周期中选择不发送？这种情况下IM系统处理消息的服务器又是怎么处理（它怎么知道整流失败，它又怎么知道要重新发送哪些消息）？","like_count":12,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467975,"discussion_content":"1. 同一个接收人的消息个人感觉没必要用一个线程处理呀，这样还会让服务有状态，如果这个线程挂了后续消息处理的迁移啥的都会比较复杂。对于同一时间有多条消息发送给这个用户的情况，业务上实际也不需要严格区分这几条消息到底哪个先到服务端，只需要保证消息落地存储后时序性固定好就行。\n2. 服务器集群规模太大的话依赖服务器时钟也是个问题，所以可以通过”全局的时间相关的序号生成器“来缓解。\n3. 服务端整流一般用在离线消息处理的场景，因为这个时候会同时有很多条消息会推送给用户，需要保证时序性。比如一次离线消息的下推共用一个packageId，然后自增的针对每一条消息来绑定一个序号（0 1 2 3 ...)，这样下推网关根据packageId来有序收集所有消息，如果序号有缺失就知道有消息丢失了（但至少是有序的），这个时候可以根据业务需要来决定直接下推已收集消息还是放弃这一次离线下推。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568968831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132904,"user_name":"javaworker","can_delete":false,"product_type":"c1","uid":1056209,"ip_address":"","ucode":"ABF9DDDBD3BDBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/d1/f427b83e.jpg","comment_is_top":false,"comment_ctime":1568268730,"is_pvip":true,"replies":[{"id":"50941","content":"1. 是的，在最终推送前收集整流。<br>2. 在线消息由于基本上不会有同时多条消息和信令一起发送的场景，所以这种在服务端就大量乱序的情况比较少，一般不需要进行整流，交给端上就可以了。<br>3. 基本上理解正确，服务端整流一般用在离线消息推送时，如果上线的这个用户有多条消息，会把这多条消息通过同一个packageID来归类，并且从0自增的给每一条消息打上标记，离线推送的网关机通过这个packageID和seqID来识别这些离线消息的顺序，待消息全部到达后，按照seqID顺序再下推这些消息。但是这里的seqID并不会给到接收端，这里的seqID只是服务端这单次离线消息下推用到的，和接收到没关系。正常的在线消息推送没有这么多并发的情况，没必要整流。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568288673,"ip_address":"","comment_id":132904,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35928007098","product_id":100034901,"comment_content":"老师，关于服务员消息整流和消息接收端整流<br>还有些不明白？<br>1.文中说的服务员消息整流是不是只能在网关整流吗？<br><br>2.在网关启动后订阅一个本IP的Topic，文中一直在说对离线消息整流，请问如果是在线消息需要服务端整流吗？<br><br>3.文中说每个消息包生成一个 packageID，意思是可以多条消息用一个包发送吗？packageID就是这个包的ID？您能简述下用户A给用户B发送一条消息，和用户A给用户B发送多条消息时，服务端和接收端都是怎么整流的吗？我理解当发送一条消息时，服务端当接收到一条消息后，会有个超时时间，比如2秒，2秒内没收到新消息的话，就把当前的消息发送出去，这时这个消息包中只有一条消息。当发送多条消息时，2秒内有新消息，就一直自增seqID，直到2秒内没收到消息，然后一起把这个消息包发出去，这时消息包可能有比如7条消息，每一条都按照seqID自增。  <br>当发送给接收端，接收端在按照每个消息包中seqID顺序显示消息。<br>按照我上面的理解，每个消息包之间的顺序怎么保证？是每个消息包packageID也有顺序吗？感觉如果按照我的理解在线发送多条消息会有延时啊，因为服务端一直在整流啊，整完在发送一个大包出去","like_count":8,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467169,"discussion_content":"1. 是的，在最终推送前收集整流。\n2. 在线消息由于基本上不会有同时多条消息和信令一起发送的场景，所以这种在服务端就大量乱序的情况比较少，一般不需要进行整流，交给端上就可以了。\n3. 基本上理解正确，服务端整流一般用在离线消息推送时，如果上线的这个用户有多条消息，会把这多条消息通过同一个packageID来归类，并且从0自增的给每一条消息打上标记，离线推送的网关机通过这个packageID和seqID来识别这些离线消息的顺序，待消息全部到达后，按照seqID顺序再下推这些消息。但是这里的seqID并不会给到接收端，这里的seqID只是服务端这单次离线消息下推用到的，和接收到没关系。正常的在线消息推送没有这么多并发的情况，没必要整流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568288673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c8/8f/e13a6552.jpg","nickname":"polk","note":"","ucode":"1B6E948BA4DFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53799,"discussion_content":"这个提问很好，看文章一脸懵逼，看这个基本懂了，老师你认真点啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574217503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131380,"user_name":"卫江","can_delete":false,"product_type":"c1","uid":1101226,"ip_address":"","ucode":"DE2F7A6916F1A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","comment_is_top":false,"comment_ctime":1567734269,"is_pvip":false,"replies":[{"id":"49867","content":"嗯，也考虑如果有“最近联系人列表”页的需求，需要按照多个群或者多个直播间的最新一条消息的产生先后来排序，这种情况可能还需要考虑使用其他属性来进行全局排序了（比如消息产生的时间戳）。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567769285,"ip_address":"","comment_id":131380,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27337538045","product_id":100034901,"comment_content":"问题：为什么不需要全局自增id？原因：因为没有全局排序的需求。而且全局自增id肯定有单点和性能问题。我们目前的需求有两点：单聊和群聊。单聊我们可以通过针对于会话id的自增id解决，群聊通过基于群id的自增id解决，这样就拥有了不错的扩展性，避免单点和性能问题，当然了如果群很大也许也有问题，同时这种方式也可以控制某个id生成服务出问题影响的范围。","like_count":7,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466423,"discussion_content":"嗯，也考虑如果有“最近联系人列表”页的需求，需要按照多个群或者多个直播间的最新一条消息的产生先后来排序，这种情况可能还需要考虑使用其他属性来进行全局排序了（比如消息产生的时间戳）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567769285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1327799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoro1y5n7l1Gq1vpzCRP9RJyNn5MuUz23PjYgSRbZ0aW0acUPufet09Pd5PFknB6ibtjXVZ3cQibevQ/132","nickname":"怪物老爷","note":"","ucode":"AFF9FBDA8E2F22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42618,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572709579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131636,"user_name":"Alpha","can_delete":false,"product_type":"c1","uid":1001861,"ip_address":"","ucode":"60CA15A25EC796","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","comment_is_top":false,"comment_ctime":1567829197,"is_pvip":false,"replies":[{"id":"50491","content":"比如离线消息推送时，用户的多条消息需要推送，这多条消息在服务端进行多线程处理时可能出现乱序的情况，通过在取离线消息时，给每条消息使用同一个packageId并自增一个seq，那么网关机在最终推送时，就可以根据这个packageId来进行一次整流，保证最终下推时消息的有序。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568035012,"ip_address":"","comment_id":131636,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18747698381","product_id":100034901,"comment_content":"生产者为每个消息包生成一个 packageID。<br>——请问这里的消息包是什么概念，是指多个消息的集合吗？如果是的话，什么场景下会将多个消息作为一个包一起发送呢？<br>或者指的是包含 一条消息 + 一条指令 的集合吗？","like_count":5,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466552,"discussion_content":"比如离线消息推送时，用户的多条消息需要推送，这多条消息在服务端进行多线程处理时可能出现乱序的情况，通过在取离线消息时，给每条消息使用同一个packageId并自增一个seq，那么网关机在最终推送时，就可以根据这个packageId来进行一次整流，保证最终下推时消息的有序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568035012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2356474,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f4/fa/9f695b88.jpg","nickname":"一天到晚想睡觉","note":"","ucode":"F6B7CDECF8A20F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372732,"discussion_content":"我是否可以理解为：最终在网关推送的时候每次也只推一条消息，只是整流后，这批消息是按顺序一个个推送的，最终在接收方还是得按“时序基准”来整合消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620445821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131862,"user_name":"一个爱编程的胖子","can_delete":false,"product_type":"c1","uid":1532821,"ip_address":"","ucode":"4AD6B27DAC096D","user_header":"https://static001.geekbang.org/account/avatar/00/17/63/95/43f5cc54.jpg","comment_is_top":false,"comment_ctime":1567940684,"is_pvip":false,"replies":[{"id":"50504","content":"加了两张流程图来说明一下服务端整流这一块的应用场景和过程，更新后再看下能不能理解。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568036157,"ip_address":"","comment_id":131862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14452842572","product_id":100034901,"comment_content":"可不可以适当添加一些代码示例。单纯的文字描述比较干","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466650,"discussion_content":"加了两张流程图来说明一下服务端整流这一块的应用场景和过程，更新后再看下能不能理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568036157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131315,"user_name":"北北、Pepper","can_delete":false,"product_type":"c1","uid":1259513,"ip_address":"","ucode":"46A74C52E68BC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/f9/f4428000.jpg","comment_is_top":false,"comment_ctime":1567702931,"is_pvip":false,"replies":[{"id":"49866","content":"是这样的，会话内的排序只需要保证会话内序号递增就可以。当然，如果有“最近联系人列表”这种需求，还需要考虑跨多个会话进行排序的情况，这个可能需要其他属性来协助全局排序了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567769166,"ip_address":"","comment_id":131315,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14452604819","product_id":100034901,"comment_content":"对老师提的问题，提出一下自己的想法。<br>因为实时通信里是会存在多个会话的，如果用于保证消息接收时序的序号生成器是全局递增的，即用于保证所有会话的接收时序，那么会存在可用性和性能瓶颈问题。<br>其次，正如老师提到的，从业务层面考虑，对用户来说，只要保证单个会话里消息的时序是正确的即可，因为不同的会话相关性一般不强，不需要保证严格的时序同步，所以针对不同的会话，单独维护一个时钟序号生成器即可。","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466385,"discussion_content":"是这样的，会话内的排序只需要保证会话内序号递增就可以。当然，如果有“最近联系人列表”这种需求，还需要考虑跨多个会话进行排序的情况，这个可能需要其他属性来协助全局排序了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567769166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136105,"user_name":"忘","can_delete":false,"product_type":"c1","uid":1001426,"ip_address":"","ucode":"F9D46E6A9E728B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/d2/024e8f0a.jpg","comment_is_top":false,"comment_ctime":1569366605,"is_pvip":false,"replies":[{"id":"52231","content":"没问题的，11篇开始会有一个简单的聊天系统的示例，可以边看边试试。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569411812,"ip_address":"","comment_id":136105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159301197","product_id":100034901,"comment_content":"袁老师，在课程的最后是不是有实战的项目？我对这个IM几乎是一点不会，能听懂大概的意思，具体的代码我一点没有接触过，听着和看着您和同学们讨论，我很希望我以后也可以能有提问能力，我现在是想提问不知道问什😂 😂 😂 ，希望可以在您这里能入门！😁 😁 😁 ","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468463,"discussion_content":"没问题的，11篇开始会有一个简单的聊天系统的示例，可以边看边试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569411812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132173,"user_name":"Cap","can_delete":false,"product_type":"c1","uid":1011516,"ip_address":"","ucode":"A4AAF9DA92003B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6f/3c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1568036107,"is_pvip":false,"replies":[{"id":"50652","content":"1. 一致性这个要看具体的应用场景呀，比如说只是关注在一个群里的聊天，当然因果一致性就够了，但IM产品里面类似“最近联系人”的需求，是需要把多个群和多个点对点进行时序倒排的，这个时候只是单个会话维度的因果时序是不够的。<br>2. 类似于离线消息的同步也不一定需要是顺序自增的呀，而且光是自增是不够的，自增只能保证时序性，不能保证同步时不丢消息。如果要在分布式场景下保证这个ID是“连续自增”实现上是非常困难的。如文中介绍，除了有序ID，还可以通过两个uuid组成的链表方式来保证同步时的顺序和不丢消息。<br>另外，全局唯一的“时间相关”的消息ID既可以用来去重，当然也可以用于客户端排序呀。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568128531,"ip_address":"","comment_id":132173,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10157970699","product_id":100034901,"comment_content":"对本文中提到的几个技术点有点其他不同的意见：<br>1. 关于一致性：文中提到时序一致性，是指的『顺序一致性 Sequential Consistency』？实际上消息场景中数据的一致性可以为更低要求的『因果一致性 Causal Consistency』。<br>2. 文中给的方案是以『时序基准』ID为主，『顺序ID』为辅来修正小范围的乱序。而消息场景中，应该是有三个不同的ID用于两个不同场景的消息处理：<br>    a. 消息ID：唯一性保证，主要用于去重。<br>    b. 同步顺序ID：本文还没提到消息的同步，对于读扩散或写扩散的消息同步，每次新消息拉取都是从最近一条消息的同步顺序ID往后拉取新消息；对于这个ID要求是在收件箱内自增的，任何依赖服务端时间戳来生成ID的规则都是错的。这个ID可以简单理解为队列中的位点。<br>    c. 会话顺序ID：这个是本文提到的顺序ID，这个ID不是辅助『时序基准』用的，而是用于保证会话中消息的『因果一致性』，为了让客户端能够对乱序接收的消息进行重排。","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466800,"discussion_content":"1. 一致性这个要看具体的应用场景呀，比如说只是关注在一个群里的聊天，当然因果一致性就够了，但IM产品里面类似“最近联系人”的需求，是需要把多个群和多个点对点进行时序倒排的，这个时候只是单个会话维度的因果时序是不够的。\n2. 类似于离线消息的同步也不一定需要是顺序自增的呀，而且光是自增是不够的，自增只能保证时序性，不能保证同步时不丢消息。如果要在分布式场景下保证这个ID是“连续自增”实现上是非常困难的。如文中介绍，除了有序ID，还可以通过两个uuid组成的链表方式来保证同步时的顺序和不丢消息。\n另外，全局唯一的“时间相关”的消息ID既可以用来去重，当然也可以用于客户端排序呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568128531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1011516,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6f/3c/abb7bfe3.jpg","nickname":"Cap","note":"","ucode":"A4AAF9DA92003B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9701,"discussion_content":"作者这是完全搞错了一致性的概念吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568206665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114345,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIEaKmtxSG7X58YRr3guYQHiavsqInUM8R02JMSW6LvjuEadF40JWFQ9T3mEfeKDuHCSJL1CbsGx2Q/132","nickname":"刘大","note":"","ucode":"910DB9A38A6E45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8822,"discussion_content":"bc的概念是重合的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568076882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131983,"user_name":"moooofly","can_delete":false,"product_type":"c1","uid":1008348,"ip_address":"","ucode":"4A20795C281B6F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","comment_is_top":false,"comment_ctime":1567999253,"is_pvip":false,"replies":[{"id":"50515","content":"添加了两张流程图来具体说明在离线消息推送过程中服务端整流的实现机制。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568037347,"ip_address":"","comment_id":131983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157933845","product_id":100034901,"comment_content":"老师能够提供一个示意图，在途中标明 packageID，seqID 和 xxxID 等都用在什么位置，感觉看过文章和留言问答后，都搞不清楚哪些 ID 用哪里了，多谢~","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466710,"discussion_content":"添加了两张流程图来具体说明在离线消息推送过程中服务端整流的实现机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568037347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131836,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1567931394,"is_pvip":false,"replies":[{"id":"50503","content":"多多交流~<br>这里讲的服务端整流可以参考离线消息的的推送，比如离线消息推送时，用户的多条消息需要推送，这多条消息在服务端进行多线程处理时可能出现乱序的情况，通过在取离线消息时，给每条消息使用同一个packageId并自增一个seq，那么网关机在最终推送时，就可以根据这个<br>packageId来进行一次整流，保证最终下推时消息的有序。<br><br>方案1的思路上没问题哈，考虑下很多IM场景，由于服务端一般是多层的架构，比如业务层，网关层，会涉及到多个进程的处理，中间的流转可能需要经过消息队列，这些过程也可能会导致乱序出现。<br><br>方案2的话主要是通用性上可能不是太好，需要区分消息类型啥的，处理逻辑也稍微复杂一些。<br><br>实际上，大部分IM场景有了接收端的整流是不太需要服务端整流的，除了服务端可能存在短时间内推送多条连续消息的情况才可能需要服务端进行整流。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568036084,"ip_address":"","comment_id":131836,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157865986","product_id":100034901,"comment_content":"多谢老师，受益良多。希望和老师多交流。<br>老师讲的防止业务执行错乱的整流方案，是通过package打包，类似逻辑集装箱，将包内消息有序处理，原理上很清晰，但落地实现比较困难，不太好掌握package的边界。究竟从哪个时机到哪个时机范围的消息归为一个包呢？也希望老师赐教个方法。<br><br>针对需要在业务上整流的问题，提出了三个自己可落地的方案，希望得到老师的指点，不知道究竟哪个可行。<br><br>方案一、客户端单线程单tcp连接保证消息有序到达，服务端采用GO协程对连接一对一服务，保证单客户端发来的消息被服务端有序执行，这个不采用java的线程池技术就是为了防止线程和socket建多对多交替并行处理导致无序问题，但是GO协程这样一对一服务的方式不知道并发能力如何，需要指点。这个我会试验下。<br><br>方案二、<br><br>对于IM，业务执行顺序应该着重关注成员变动（删除好友或取消关注也是一个聊天窗口的成员变动）操作之间的顺序，以及成员变动操作和聊天消息之间的有序处理，前者影响成员变动结果，后者影响聊天消息接收范围，其他的业务错误倒不是&#39;&#39;致命&#39;&#39;的，产品定位弱一些可以不关注。<br><br>因此，将消息分为聊天消息和信令消息<br><br>信令消息是包括群里加人、离群、删除好友，这种影响聊天消息接收范围的命令，产生信令消息的操作必须在线同步操作，直到服务端明确返回执行结果信息。但也真的可能出现服务端执行了，但客户端恰巧断线，这应该通过网络重连获取最新状态，以保证客户端的信息和服务端同步。<br><br>发信令消息时，消息体附带客户端当前需要服务端给ACK应答的聊天消息id列表，服务端处理信令消息时必须处理完所有前置聊天消息列表里的消息，否者算处理失败。<br><br>这样保证信令消息一定会在合适的顺序得到服务端的处理。<br><br>方案三 严格的链表式消息链<br><br>在发送消息时都要附带其上次向服务端发送的消息id，服务端必须按着链表顺序整流并按序处理，但是，网络上会随时丢消息，一个消息丢失导致后置消息全链无法处理，毕竟不是金融软件没必要这么做，体验不好。<br><br><br>","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466639,"discussion_content":"多多交流~\n这里讲的服务端整流可以参考离线消息的的推送，比如离线消息推送时，用户的多条消息需要推送，这多条消息在服务端进行多线程处理时可能出现乱序的情况，通过在取离线消息时，给每条消息使用同一个packageId并自增一个seq，那么网关机在最终推送时，就可以根据这个\npackageId来进行一次整流，保证最终下推时消息的有序。\n\n方案1的思路上没问题哈，考虑下很多IM场景，由于服务端一般是多层的架构，比如业务层，网关层，会涉及到多个进程的处理，中间的流转可能需要经过消息队列，这些过程也可能会导致乱序出现。\n\n方案2的话主要是通用性上可能不是太好，需要区分消息类型啥的，处理逻辑也稍微复杂一些。\n\n实际上，大部分IM场景有了接收端的整流是不太需要服务端整流的，除了服务端可能存在短时间内推送多条连续消息的情况才可能需要服务端进行整流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568036084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136368,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1569417525,"is_pvip":true,"replies":[{"id":"52527","content":"全局序号生成器不管是点对点还是群聊，不需要针对会话维度来创建，都是可以共用的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569571736,"ip_address":"","comment_id":136368,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864384821","product_id":100034901,"comment_content":"老师 不仅每个群要有一个全局序号生成器 每个点对点的聊天 比如a和b聊天也需要一个生成器 也就是每对聊天对象都有一个属于他俩的全局生成器","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468595,"discussion_content":"全局序号生成器不管是点对点还是群聊，不需要针对会话维度来创建，都是可以共用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569571736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132229,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1646622,"ip_address":"","ucode":"F5A45F009175FA","user_header":"https://static001.geekbang.org/account/avatar/00/19/20/1e/23e6109f.jpg","comment_is_top":false,"comment_ctime":1568047017,"is_pvip":false,"replies":[{"id":"50654","content":"1. 我们自己的实现目前是一条消息一个ack，当然也可以参考tcp的delay ack机制来减少ack。服务端还可以通过支持多条消息打包来减少ack，比如推送离线消息时进行多条消息打包下推。<br>2. 连续性也可以用两个版本号组成的链表（每条消息携带前一条消息的版本号和当前这条消息的版本号）来检测消息的连续性和时序性。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568128969,"ip_address":"","comment_id":132229,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863014313","product_id":100034901,"comment_content":"1.一般业界是做是每个消息都ack还是像tcp一样的批量ack？每个都ack会不会消息太多影响性能？<br>2.客户端整流，如果我希望客户端严格按照顺序处理消息，那就必须排序且保证排序后的消息连续，那雪花id是不连续的，我怎么判断整流后的消息是否连续呢？难道这种情况下就必须用自增id？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466831,"discussion_content":"1. 我们自己的实现目前是一条消息一个ack，当然也可以参考tcp的delay ack机制来减少ack。服务端还可以通过支持多条消息打包来减少ack，比如推送离线消息时进行多条消息打包下推。\n2. 连续性也可以用两个版本号组成的链表（每条消息携带前一条消息的版本号和当前这条消息的版本号）来检测消息的连续性和时序性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568128969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131788,"user_name":"clip","can_delete":false,"product_type":"c1","uid":1019244,"ip_address":"","ucode":"D0E142605A5BD5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/6c/0c2a26c7.jpg","comment_is_top":false,"comment_ctime":1567907202,"is_pvip":true,"replies":[{"id":"50498","content":"保证服务端推送是必须有序也是可以的，看具体的需求场景是否真的需要，另外实现成本也需要考虑。接收端整流也可以是如果乱序先不显示而是等一段时间，来尽量避免显示上的跳变。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568035486,"ip_address":"","comment_id":131788,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862874498","product_id":100034901,"comment_content":"如果我们应用场景就是 IM，消息接收端整流是不是可能导致收到消息之后也能又往上面插入了新消息？感觉这种体验可能不是很好。<br>是不是要采取另外的措施？<br>能想到的有：必须保证消息顺序下发，如果中间有比较耗时的消息可能先用一个占位符代替。自己发送的消息要等服务端确认后才真正进入消息流排序。","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466621,"discussion_content":"保证服务端推送是必须有序也是可以的，看具体的需求场景是否真的需要，另外实现成本也需要考虑。接收端整流也可以是如果乱序先不显示而是等一段时间，来尽量避免显示上的跳变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568035486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131786,"user_name":"clip","can_delete":false,"product_type":"c1","uid":1019244,"ip_address":"","ucode":"D0E142605A5BD5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/6c/0c2a26c7.jpg","comment_is_top":false,"comment_ctime":1567906934,"is_pvip":true,"replies":[{"id":"50497","content":"新补充了两个图，等更新了大家可以看一下哈~<br>比如离线消息推送时，用户的多条消息需要推送，这多条消息在服务端进行多线程处理时可能出现乱序的情况，通过在取离线消息时，给每条消息使用同一个packageId并自增一个seq，那么网关机在最终推送时，就可以根据这个packageId来进行一次整流，保证最终下推时消息的有序。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568035343,"ip_address":"","comment_id":131786,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5862874230","product_id":100034901,"comment_content":"服务端包内整流那块儿有点不理解。<br>这个 pkg 指的是类似举例的“最后一条消息和取关操作”那种打包在一起的事件吗？还是群纬度的那种一个群的算一个 pkg？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466619,"discussion_content":"新补充了两个图，等更新了大家可以看一下哈~\n比如离线消息推送时，用户的多条消息需要推送，这多条消息在服务端进行多线程处理时可能出现乱序的情况，通过在取离线消息时，给每条消息使用同一个packageId并自增一个seq，那么网关机在最终推送时，就可以根据这个packageId来进行一次整流，保证最终下推时消息的有序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568035343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1642766,"avatar":"https://static001.geekbang.org/account/avatar/00/19/11/0e/23d6a88f.jpg","nickname":"Shuai","note":"","ucode":"BE705668C66225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8458,"discussion_content":"我理解的pkg和xmpp里的节点类似","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568006805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131400,"user_name":"小祺","can_delete":false,"product_type":"c1","uid":1193548,"ip_address":"","ucode":"2819BCA9E71C9F","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4c/46c43cce.jpg","comment_is_top":false,"comment_ctime":1567739640,"is_pvip":false,"replies":[{"id":"49871","content":"如果只是消息推送的话，接收端的整流基本就ok了，但是通道里推送的不仅仅是消息，还有信令（比如删除某一个会话的信令），这种情况服务端整流能够减少消息和信令乱序推送到接收端后导致端上逻辑异常的问题。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567770007,"ip_address":"","comment_id":131400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862706936","product_id":100034901,"comment_content":"感觉消息接收端整流是必做的，那服务端的整流是不是就显得多余了？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466433,"discussion_content":"如果只是消息推送的话，接收端的整流基本就ok了，但是通道里推送的不仅仅是消息，还有信令（比如删除某一个会话的信令），这种情况服务端整流能够减少消息和信令乱序推送到接收端后导致端上逻辑异常的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567770007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131398,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1567739164,"is_pvip":false,"replies":[{"id":"49870","content":"单连接单线程的话TCP层的“有序接收”能够保证消息的有序到达。但这种模型的性能和可用性基本不能用在真实业务场景里。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567769753,"ip_address":"","comment_id":131398,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5862706460","product_id":100034901,"comment_content":"对于&quot;分手&quot;、&quot;取关&quot;的严格业务顺序场景，通过单线程单tcp连接能保证消息一定按着发送顺序到达服务器吗？socket.send有序发送两条消息A 和 B，由于链路故障是否可能导致服务器先接收到B后接收到A，我一直保持着业务层消息即使同一tcp连接上有序发送也有可能出现乱序到达，所以需要接收端在业务层重排的认知，但好像也确实没有证明。","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466432,"discussion_content":"单连接单线程的话TCP层的“有序接收”能够保证消息的有序到达。但这种模型的性能和可用性基本不能用在真实业务场景里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567769753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037540,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qgbQytfwErGXuIZaRzA28iagmfnZDHKMYIGwZ7sJ6NAicVicDewic8S266eA9L4wO2q1y4XwcMGE6urK9L6vuQBpMA/132","nickname":"Geek_6e6dba","note":"","ucode":"E7B1A5DC90760D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284008,"discussion_content":"既然单链接单线程的性能不可能被用在真实场景里面，那么就剩下一个选项了“在发送方对多个请求进行业务层合并，多条消息合并成一条”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592412086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259889,"discussion_content":"架构上有办法实现单用户的串行化，并发可以认为是每个用户一个串行的线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588827664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337225,"user_name":"风华จุ๊บ","can_delete":false,"product_type":"c1","uid":2019691,"ip_address":"","ucode":"A2F29212EE7A04","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d1/6b/777fedf2.jpg","comment_is_top":false,"comment_ctime":1646706461,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646706461","product_id":100034901,"comment_content":"消息的唯一id和消息时序号是否可用一个？","like_count":0},{"had_liked":false,"id":333181,"user_name":"Stklose","can_delete":false,"product_type":"c1","uid":1019259,"ip_address":"","ucode":"A4E4BEE7D661CC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiaFLicTlefCnibAJ8sVFtLTAuKbvW3bPH3aqfxxCalXxDZNY2PgkhxYnguzjXU5Yh4Lw/132","comment_is_top":false,"comment_ctime":1644170291,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644170291","product_id":100034901,"comment_content":"用户连续发送 msg1,msg2, 如果不通过长连接方式，走无状态服务，是否要带上自己seqID, 才能保证server侧或者对方设备侧的整流按发送序?","like_count":0},{"had_liked":false,"id":329892,"user_name":"非洲黑猴子","can_delete":false,"product_type":"c1","uid":2639724,"ip_address":"","ucode":"F5FEAC07D562E0","user_header":"https://static001.geekbang.org/account/avatar/00/28/47/6c/78184d19.jpg","comment_is_top":false,"comment_ctime":1641630308,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1641630308","product_id":100034901,"comment_content":"回答最后的问题：一个群的消息有序就好。因为很少有人舍近求远，同时跨两个以上的群互相对话😂😂 所以用不着，而且这样还省资源","like_count":0},{"had_liked":false,"id":303239,"user_name":"极客—月","can_delete":false,"product_type":"c1","uid":1318468,"ip_address":"","ucode":"EE12EEBF242B1D","user_header":"","comment_is_top":false,"comment_ctime":1626681670,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1626681670","product_id":100034901,"comment_content":"消息接收端整流，就是按照下推的序号排序吧？那里的三点的后两点看的有点绕","like_count":0},{"had_liked":false,"id":248895,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1600349424,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600349424","product_id":100034901,"comment_content":"我大概想到了方法，max_seq_id和 read_seq_id","like_count":0},{"had_liked":false,"id":248890,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1600347556,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600347556","product_id":100034901,"comment_content":"接收端整流适合消息内容一块下发的场景，出现空洞，应该还需要查询去补救吧？","like_count":0},{"had_liked":false,"id":248887,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1600347303,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600347303","product_id":100034901,"comment_content":"微信seqid，若果服务端整流，是否可以考虑在出现不连续的时候等待50ms，这个50ms就是为了旧seqid的数据写入成功，如果seqid从取到写入超过50ms就重新取一个重试？微信sync靠seqid来同步数据，老seq没写入的极端情况会丢数据，没想明白是怎么解决的。","like_count":0},{"had_liked":false,"id":248884,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1600346747,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600346747","product_id":100034901,"comment_content":"微信的sync协议，要求用seq去同步数据，seq不要求连续。不连续不是会出现后面的消息seqid先到用户，老的seqid还没写入数据的情况，这样不是会丢消息吗？这个问题想了很久，望老师赐教。 我自己的想法是seqid收到后不立马同步，等个50ms，控制取seq和写seq的时间在50ms以内，如果超过，就需要用取新seq重试。不知道这样是否可以","like_count":0},{"had_liked":false,"id":242588,"user_name":"微扰理论","can_delete":false,"product_type":"c1","uid":1107505,"ip_address":"","ucode":"55D0542FA602D9","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/31/5b8800fb.jpg","comment_is_top":false,"comment_ctime":1597769914,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597769914","product_id":100034901,"comment_content":"老师好 想问下为什么要在服务端做包内整流呀，感觉客户端做会不会更合理<br>服务端做的话，会占用本来就紧张的计算资源吗？","like_count":0},{"had_liked":false,"id":232272,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1593939733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593939733","product_id":100034901,"comment_content":"全局唯一对于IM服务的高可用,高并发有影响.只要保证局部即群内的顺序性就好了.","like_count":0},{"had_liked":false,"id":231750,"user_name":"Alan.J","can_delete":false,"product_type":"c1","uid":1149842,"ip_address":"","ucode":"902479E030DDF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8b/92/0f2ef83a.jpg","comment_is_top":false,"comment_ctime":1593764552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593764552","product_id":100034901,"comment_content":"严格有序的消息，我觉得上面的解决方案不完善，非离线情况下，首先服务端有序的消息发送到了多个IM服务器，分布式情况你要借助中间件处理？，如果消息达到有时差，导致序号2,3的消息先到IM服务端，序号1的晚到，这个等待消息到来做排序的的时间怎么设置处理？然后其次再说非离线情况下，你用接收端在整流，由于收到的消息时间不同的话，怎么去整流，等待个好几秒等有序的消息都到了再去排序？","like_count":0},{"had_liked":false,"id":231746,"user_name":"Alan.J","can_delete":false,"product_type":"c1","uid":1149842,"ip_address":"","ucode":"902479E030DDF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8b/92/0f2ef83a.jpg","comment_is_top":false,"comment_ctime":1593764006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593764006","product_id":100034901,"comment_content":"问题：<br>IM 服务器都是集群化部署，每台服务器的机器性能存在差异，因此处理效率有差别，并不能保证先到的消息一定可以先推送到接收方，比如有的服务器处理得慢，或者刚好碰到一次 GC，导致它接收的更早消息，反而比其他处理更快的机器更晚推送出去。<br>2.IM 服务端接收到发送方的消息后，之后相应的处理一般都是多线程进行处理的，比如“取序号”“暂存消息”“查询接收方连接信息”等，由于多线程处理流程，并不能保证先取到序号的消息能先到达接收方，这样的话对于多个接收方看到的消息顺序可能是不一致的。<br><br>关于这两个问题，上面老师你只说了，离线的服务端包整流，对吧<br>这种情况如果1，2，3条消息，真的出现了2，3，1的顺序到达，就收方，接收方整流？那么这个整流时间段怎么设置才比较合理呢，我不可能等个几秒中，就为了整流吧？那就会是先收到2，3，最后收到1这条消息了呀<br>","like_count":0},{"had_liked":false,"id":215800,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1589105277,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589105277","product_id":100034901,"comment_content":"我之前有的一种做法是，写操作串行化，同一个用户的mail操作都是在一个线程内串行的。当出现机器不可用的时候，会hash到另外一台机器上，这个时候就可能出现并发和乱序。一种方式是通过max_msg_id +1尝试去set，内容存在就尝试下一个位置。这种方式基本不会出现空洞。","like_count":0},{"had_liked":false,"id":208943,"user_name":"张树坤","can_delete":false,"product_type":"c1","uid":1351909,"ip_address":"","ucode":"E393719264E454","user_header":"https://static001.geekbang.org/account/avatar/00/14/a0/e5/8a24b548.jpg","comment_is_top":false,"comment_ctime":1587469089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587469089","product_id":100034901,"comment_content":"老师，如果采用消息链当时的话，如果有消息更新，客户端怎么能感知到是否有丢消息呢？消息完整性检查针对消息的更新和删除如何检查呢？","like_count":0},{"had_liked":false,"id":201791,"user_name":"steven","can_delete":false,"product_type":"c1","uid":1560619,"ip_address":"","ucode":"3F5231607CB40E","user_header":"https://static001.geekbang.org/account/avatar/00/17/d0/2b/c571c59f.jpg","comment_is_top":false,"comment_ctime":1585837716,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585837716","product_id":100034901,"comment_content":"老师，有一个问题，好像你的课程没有覆盖，就是粘包问题，这个好像课程并没有提出，但是最近我在业务中出现这个问题","like_count":0},{"had_liked":false,"id":201752,"user_name":"tm1234","can_delete":false,"product_type":"c1","uid":1947612,"ip_address":"","ucode":"4042321C713186","user_header":"","comment_is_top":false,"comment_ctime":1585833044,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585833044","product_id":100034901,"comment_content":"请问老师 能否介绍一下 Redis或者DB或snowflakes这些服务是怎么实现全局自增ID的呢？例如同一时间多个客户端都发出请求要生成id，这些服务怎么保证给买个请求生成不重复且严格递增的id呢？","like_count":0,"discussions":[{"author":{"id":2037540,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qgbQytfwErGXuIZaRzA28iagmfnZDHKMYIGwZ7sJ6NAicVicDewic8S266eA9L4wO2q1y4XwcMGE6urK9L6vuQBpMA/132","nickname":"Geek_6e6dba","note":"","ucode":"E7B1A5DC90760D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284009,"discussion_content":"snowflake生成的id并不是严格连续递增的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592412135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187312,"user_name":"小胡子","can_delete":false,"product_type":"c1","uid":1018182,"ip_address":"","ucode":"79FEC6400D25DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/46/0b7828a1.jpg","comment_is_top":false,"comment_ctime":1584082254,"is_pvip":false,"replies":[{"id":"72304","content":"一般序号生成器的性能是挺好的，实现上可以依托于redis等高性能存储中间件，差不多1-2ms的耗时。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1584087140,"ip_address":"","comment_id":187312,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584082254","product_id":100034901,"comment_content":"这样序号生成都是从服务端产生，那么每次发送消息时都需要先从服务端获取到序号，这个操作是不是会影响性能。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487069,"discussion_content":"一般序号生成器的性能是挺好的，实现上可以依托于redis等高性能存储中间件，差不多1-2ms的耗时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584087140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168096,"user_name":"Lxin,","can_delete":false,"product_type":"c1","uid":1121805,"ip_address":"","ucode":"8E0DEA77E56CF7","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/0d/2fc4c9ae.jpg","comment_is_top":false,"comment_ctime":1578013199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578013199","product_id":100034901,"comment_content":"拉取离线消息，是用循环调用http接口比较好还是利用长连通道推送比较好","like_count":0},{"had_liked":false,"id":165076,"user_name":"atom","can_delete":false,"product_type":"c1","uid":1379424,"ip_address":"","ucode":"2DB83DDD80B577","user_header":"https://static001.geekbang.org/account/avatar/00/15/0c/60/7f3b9f97.jpg","comment_is_top":false,"comment_ctime":1577156335,"is_pvip":false,"replies":[{"id":"63347","content":"对于客户端发送失败的可以单独存储，然后简单的通过客户端消息的本地时间来进行和其他消息的插入排序。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1577427257,"ip_address":"","comment_id":165076,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577156335","product_id":100034901,"comment_content":"对于客户端发送失败的消息，是没有服务端的序号的，如何和接受到的消息进行排序","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479013,"discussion_content":"对于客户端发送失败的可以单独存储，然后简单的通过客户端消息的本地时间来进行和其他消息的插入排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577427257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161747,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1576314544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576314544","product_id":100034901,"comment_content":"前两天还被问到，如果机器处理速度不同导致消息接收端收到消息时序错乱怎么办","like_count":0},{"had_liked":false,"id":155917,"user_name":"Kippa","can_delete":false,"product_type":"c1","uid":1128307,"ip_address":"","ucode":"3DA00B3655F93D","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/73/df7adf32.jpg","comment_is_top":false,"comment_ctime":1574778449,"is_pvip":false,"replies":[{"id":"60936","content":"一般来说，多个用户在发送消息时，由于各自本地时钟的差异以及消息从发送的客户端到达服务端的延时并不一致的问题，所以对于多个发送方并没有一个绝对的时间基准存在，这种情况实际上很难避免的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1575625950,"ip_address":"","comment_id":155917,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574778449","product_id":100034901,"comment_content":"老师您好，请教一个有关消息 ID 的问题。如果采用秒间有序的分布式消息 ID 生成器，一个会话中同一秒的消息可能是乱序的。那么如果同一秒内 A 和 B 对话产生了三条消息，A 向 B 发送消息 1，B 回复 A 消息 2，A 看完 2 后回复消息 3, 可能会出现消息 3 的 id 在消息 2 前面，请问应当如何避免这种情况呢？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475925,"discussion_content":"一般来说，多个用户在发送消息时，由于各自本地时钟的差异以及消息从发送的客户端到达服务端的延时并不一致的问题，所以对于多个发送方并没有一个绝对的时间基准存在，这种情况实际上很难避免的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575625950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153102,"user_name":"polk","can_delete":false,"product_type":"c1","uid":1165455,"ip_address":"","ucode":"1B6E948BA4DFAF","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/8f/e13a6552.jpg","comment_is_top":false,"comment_ctime":1574157938,"is_pvip":false,"replies":[{"id":"59882","content":"是的，包内整流主要用于离线消息下推，在线消息一般不需要。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1574771711,"ip_address":"","comment_id":153102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574157938","product_id":100034901,"comment_content":"离线消息通过包内整流，对于在线的消息，整流会增加耗时，就不需要做整流了吧？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475044,"discussion_content":"是的，包内整流主要用于离线消息下推，在线消息一般不需要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574771711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147976,"user_name":"唯我天棋","can_delete":false,"product_type":"c1","uid":1015960,"ip_address":"","ucode":"B925246C92727A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/98/5591d99d.jpg","comment_is_top":false,"comment_ctime":1572924570,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1572924570","product_id":100034901,"comment_content":"在即时消息收发场景中，用于保证消息接收时序的序号生成器为什么可以不是全局递增的？<br><br>1.全局递增，性能压力比较大。<br>2.全局的这个出问题，会导致整体不可用。高可用性比较差。","like_count":0},{"had_liked":false,"id":146050,"user_name":"wuhaka","can_delete":false,"product_type":"c1","uid":1717134,"ip_address":"","ucode":"7628FE50C69F4C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRn8Mcfib1laX6wddDlKRaSH8BjJESVNt1RD6iay3icbcyCcZib214Q93A8vZI9zarcuBianLUe06bwoQ/132","comment_is_top":false,"comment_ctime":1572424933,"is_pvip":false,"replies":[{"id":"56367","content":"一般在线的消息推送为了保证实时性不会在网关层整流，网关层整流比较多的用于离线消息的下推。所以针对在线消息还是需要客户端进行排序。<br>ui界面调整消息顺序这种看产品策略吧，也可以先直接按接收顺序append到后面，然后退出会话再次进入时再重新从本地db加载数据进行重排。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1572439112,"ip_address":"","comment_id":146050,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1572424933","product_id":100034901,"comment_content":"老师您好，我也正在做im业务针对您这节讲的时序性问题问两个问题：<br>1.既然在网关层做了整流，传输协议又基于tcp的话，客户端为什么会出现乱序？<br>2.假如您所说客户端出现乱序，那把后到达的消息插入到前面展示，在UI界面中间突然崩出一条消息，用户也可能无感知的，这在产品层面是很不好的设计，市面上主流IM没发现出现过这种场景。<br>","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472689,"discussion_content":"一般在线的消息推送为了保证实时性不会在网关层整流，网关层整流比较多的用于离线消息的下推。所以针对在线消息还是需要客户端进行排序。\nui界面调整消息顺序这种看产品策略吧，也可以先直接按接收顺序append到后面，然后退出会话再次进入时再重新从本地db加载数据进行重排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572439112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736802,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/80/62/d6cc3ceb.jpg","nickname":"Geek_quan","note":"","ucode":"1EAA4359E19CA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216625,"discussion_content":"问一下？最后您是怎么实现的呢？我这边也有您一样的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585470906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717134,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRn8Mcfib1laX6wddDlKRaSH8BjJESVNt1RD6iay3icbcyCcZib214Q93A8vZI9zarcuBianLUe06bwoQ/132","nickname":"wuhaka","note":"","ucode":"7628FE50C69F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41497,"discussion_content":"我觉得先append的方案产品层面应该不能接受，这会使用户非常困惑，既然在在线情况不会整流会存在乱序传入socket，那在这个业务场景下tcp保证顺序性的特点退化成了udp模式不能保证了，解决这个只能靠客户端整流，应用层实现tcp seq num那套，加上im业务各种场景复杂性非常高，因为一条消息未到达，先到的消息全部进入buffer，还要保证这条消息能稳定快速到达不然后面消息都等它看不见了，感觉实现起来难度很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572441314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136586,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1676713,"ip_address":"","ucode":"9140B30F643638","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsBRgibKxD2M0ibmgPqfcoaZOxmUrwCCGlex8xehyYeeTOEN2ibtQ5S6t30LoOKFvMR5KDm5gnU99PQ/132","comment_is_top":false,"comment_ctime":1569476494,"is_pvip":false,"replies":[{"id":"52531","content":"是的，msgid一般来说是全局序号生成器生成的，发出的号一个是要全局唯一，另外是时间相关。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569574626,"ip_address":"","comment_id":136586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569476494","product_id":100034901,"comment_content":"举手提问：消息表主键msgId是这个序号生成器生成的Id么？如果是，序号生成器生成的ID虽然可以不是全局递增的，是不是至少要保证全局唯一呢？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468712,"discussion_content":"是的，msgid一般来说是全局序号生成器生成的，发出的号一个是要全局唯一，另外是时间相关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569574626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136555,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1676713,"ip_address":"","ucode":"9140B30F643638","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsBRgibKxD2M0ibmgPqfcoaZOxmUrwCCGlex8xehyYeeTOEN2ibtQ5S6t30LoOKFvMR5KDm5gnU99PQ/132","comment_is_top":false,"comment_ctime":1569471618,"is_pvip":false,"replies":[{"id":"52530","content":"对于点对点消息，由于都是基于一条长连接来发送，基本不会存在这种情况。对于群聊来说，如果多人同一时间发言，确实会存在你说的这种情况，个人理解对于群聊的场景这种实际上不需要处理，产品层面大部分是能接收的。最终大家都以服务端的全局序号为准就可以了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569574479,"ip_address":"","comment_id":136555,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1569471618","product_id":100034901,"comment_content":"举手发问：发送方先后分别发送msg1和msg2，但是因为网络和服务器端处理效率不同，msg1后到达并且后处理。造成了msg1的全局唯一序号比msg2的全局唯一序号大。如果接收端按照全局唯一序号排序的话，那么msg2会排在msg1前面，导致了发送端消息顺序跟接受端顺序不一致。请问一下老师怎么解决呢？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468691,"discussion_content":"对于点对点消息，由于都是基于一条长连接来发送，基本不会存在这种情况。对于群聊来说，如果多人同一时间发言，确实会存在你说的这种情况，个人理解对于群聊的场景这种实际上不需要处理，产品层面大部分是能接收的。最终大家都以服务端的全局序号为准就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569574479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1676713,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsBRgibKxD2M0ibmgPqfcoaZOxmUrwCCGlex8xehyYeeTOEN2ibtQ5S6t30LoOKFvMR5KDm5gnU99PQ/132","nickname":"Michael","note":"","ucode":"9140B30F643638","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21762,"discussion_content":"看到其他同学的相同提问，老师已经说这个没法避免，而且也不影响业务！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569513689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135085,"user_name":"Bolor","can_delete":false,"product_type":"c1","uid":1314048,"ip_address":"","ucode":"536456A7D5FB0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/00/ed8ce979.jpg","comment_is_top":false,"comment_ctime":1569003534,"is_pvip":false,"replies":[{"id":"52009","content":"1. 第一个问题很难避免吧，实际上业务层面应该也是能接受的，我们只需要保证消息在存储后的顺序一致就可以了，存储前是“谁先到算谁的”。<br>2. 离线消息直接从存储里获取的问题在于离线消息是用户维度的，不是会话维度的，获取会比较麻烦，另外还有除消息外的信令需要离线下推的，这个存储会比较麻烦。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1569236671,"ip_address":"","comment_id":135085,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1569003534","product_id":100034901,"comment_content":"有两个问题咨询，希望老师给个答复<br>1、a用户发b用户消息，a到im服务器时由于多个服务接收，发送的消息被不同的服务接收，导致第一条在第二条消息或第三条消息后面，获得的序号错误，这种问题怎么避免呢？<br>2、离线消息能否在用户登录后用户主动拉取离线消息，有多少拉多少或分批拉取，并且所拿到的消息是有时序的，这样是不是避免了做服务端和接受端的整流呢？<br>谢谢！","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468040,"discussion_content":"1. 第一个问题很难避免吧，实际上业务层面应该也是能接受的，我们只需要保证消息在存储后的顺序一致就可以了，存储前是“谁先到算谁的”。\n2. 离线消息直接从存储里获取的问题在于离线消息是用户维度的，不是会话维度的，获取会比较麻烦，另外还有除消息外的信令需要离线下推的，这个存储会比较麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569236671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1676713,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsBRgibKxD2M0ibmgPqfcoaZOxmUrwCCGlex8xehyYeeTOEN2ibtQ5S6t30LoOKFvMR5KDm5gnU99PQ/132","nickname":"Michael","note":"","ucode":"9140B30F643638","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21389,"discussion_content":"我原来想的，离线推送的消息直接从索引表里面拿(基础篇02章里面讲的)。如果不是的话老师，可以展开讲一下离线消息是如何获取的么？然后，获取之后为什么要把这一匹消息单个什么处理，导致了他们的需要整流呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569475515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037540,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qgbQytfwErGXuIZaRzA28iagmfnZDHKMYIGwZ7sJ6NAicVicDewic8S266eA9L4wO2q1y4XwcMGE6urK9L6vuQBpMA/132","nickname":"Geek_6e6dba","note":"","ucode":"E7B1A5DC90760D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284022,"discussion_content":"“a用户发b用户消息，a到im服务器时由于多个服务接收，发送的消息被不同的服务接收” 应该不会这样吧？发给同一个接收方的消息应该用的同一个长连接，被同一个网关机处理请求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592419322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133989,"user_name":"罗帮奎","can_delete":false,"product_type":"c1","uid":1271773,"ip_address":"","ucode":"8598D116E1FC3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/67/dd/55aa6e07.jpg","comment_is_top":false,"comment_ctime":1568711848,"is_pvip":false,"replies":[{"id":"51495","content":"会有期中和期末的代码实战，演示一个简易的聊天系统。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568807219,"ip_address":"","comment_id":133989,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568711848","product_id":100034901,"comment_content":"后续会有IM相关代码么，如果有代码结合前面的课程内容，会有更深刻的理解","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467573,"discussion_content":"会有期中和期末的代码实战，演示一个简易的聊天系统。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568807219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132960,"user_name":"聪少","can_delete":false,"product_type":"c1","uid":1203563,"ip_address":"","ucode":"AB8301B752AC30","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/6b/3d42593f.jpg","comment_is_top":false,"comment_ctime":1568283801,"is_pvip":false,"replies":[{"id":"51287","content":"您说的ID是消息的版本号还是推送序号？ 可以通过“全局的序号生成器”来获取，版本号和推送序号可以不依赖本地时间。对于依赖发号器本地时钟的发号，可以通过NTP来保证时间的同步。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568622912,"ip_address":"","comment_id":132960,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568283801","product_id":100034901,"comment_content":"移动端推送一条消息是否需要带着这个ID，如果要带的话这个ID从哪里申请？ 远端申请也是有时间损耗的，本地申请时间可能被修改，期待大佬回复","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467193,"discussion_content":"您说的ID是消息的版本号还是推送序号？ 可以通过“全局的序号生成器”来获取，版本号和推送序号可以不依赖本地时间。对于依赖发号器本地时钟的发号，可以通过NTP来保证时间的同步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568622912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132690,"user_name":"鹿小6","can_delete":false,"product_type":"c1","uid":1197368,"ip_address":"","ucode":"94511AE7C89269","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/38/0f948866.jpg","comment_is_top":false,"comment_ctime":1568194293,"is_pvip":false,"replies":[{"id":"50858","content":"嗯，可以的，目前我们线上只有离线推送这一块用到了服务端整流。另外，这里的seqID和推送的seqID不是一个呀，这里的seqID只是当前这一个包的序号，推送时用不着这个。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568201643,"ip_address":"","comment_id":132690,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568194293","product_id":100034901,"comment_content":"packageID和seqID老师用的是离线推送为例，那如果没有离线呢？是不是这个包ID就没有必要了，只需要seqID，消费者根据seqID整流排序即可？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467072,"discussion_content":"嗯，可以的，目前我们线上只有离线推送这一块用到了服务端整流。另外，这里的seqID和推送的seqID不是一个呀，这里的seqID只是当前这一个包的序号，推送时用不着这个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568201643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132151,"user_name":"刘小兔bunny","can_delete":false,"product_type":"c1","uid":1649519,"ip_address":"","ucode":"22A04EEF6D6479","user_header":"https://static001.geekbang.org/account/avatar/00/19/2b/6f/c99d739d.jpg","comment_is_top":false,"comment_ctime":1568033364,"is_pvip":false,"replies":[{"id":"50521","content":"添加了两张流程图来具体说明在离线消息推送过程中服务端整流的实现机制，可以先看下更新。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568038024,"ip_address":"","comment_id":132151,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568033364","product_id":100034901,"comment_content":"希望可以做一些演示类的代码，纯文字表述比较浮于表面","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466790,"discussion_content":"添加了两张流程图来具体说明在离线消息推送过程中服务端整流的实现机制，可以先看下更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568038024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131667,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1010459,"ip_address":"","ucode":"4475AF1598FBFD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/1b/4b397b80.jpg","comment_is_top":false,"comment_ctime":1567841578,"is_pvip":false,"replies":[{"id":"50492","content":"packageId可以理解为一次需要保证时序的多条消息和信令的集合。比如，用户上线获取离线消息时需要推送多条消息，这多条消息就可以是一个packageId和多个不同的seqId。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1568035110,"ip_address":"","comment_id":131667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567841578","product_id":100034901,"comment_content":"文中提到的packageid+seqid整流，其中packageid就是根据业务场景设置，可能是用户维度，群聊维度吗","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466565,"discussion_content":"packageId可以理解为一次需要保证时序的多条消息和信令的集合。比如，用户上线获取离线消息时需要推送多条消息，这多条消息就可以是一个packageId和多个不同的seqId。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568035110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131629,"user_name":"一路向北","can_delete":false,"product_type":"c1","uid":1376654,"ip_address":"","ucode":"54D8F1687AE1ED","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/8e/48e7c474.jpg","comment_is_top":false,"comment_ctime":1567827955,"is_pvip":false,"replies":[{"id":"50329","content":"主要是多台服务器的时钟同步问题，集群越大差异性也越大。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567842433,"ip_address":"","comment_id":131629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567827955","product_id":100034901,"comment_content":"多台服务器，如果都使用北京标准时间，可不可以用服务端的时间戳呢？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466546,"discussion_content":"主要是多台服务器的时钟同步问题，集群越大差异性也越大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567842433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131584,"user_name":"小可","can_delete":false,"product_type":"c1","uid":1006735,"ip_address":"","ucode":"8834AF621FA67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","comment_is_top":false,"comment_ctime":1567818430,"is_pvip":false,"replies":[{"id":"50328","content":"这一篇讲的是时序性，时间戳或者序号大小的比较只解决时序问题，不能解决丢消息的问题。要保证消息不丢，序号不连续也是不行的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567842388,"ip_address":"","comment_id":131584,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567818430","product_id":100034901,"comment_content":"只要能保证发送到同一个接收端的取到的序号是自增的，就不需要全局自增<br>老师在消息接收端整流的环节有点疑问：<br>由于网络或者其他原因导致消息到达接受端的序号是1、2、5、4，按照您提到的处理规则，展现到回话里顺序是1、2、4、5，如果后面再来个消息3，已经找不到比它序号小的消息了，该如何展现？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466525,"discussion_content":"这一篇讲的是时序性，时间戳或者序号大小的比较只解决时序问题，不能解决丢消息的问题。要保证消息不丢，序号不连续也是不行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567842388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8228,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567843077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131520,"user_name":"煜","can_delete":false,"product_type":"c1","uid":1650785,"ip_address":"","ucode":"3C5A9A55A65FC9","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/61/50e24e09.jpg","comment_is_top":false,"comment_ctime":1567780014,"is_pvip":false,"replies":[{"id":"50325","content":"这个看需求，客户端接收到消息即使不连续一般也可以直接先显示，然后等前面的消息到了再在页面进行一次插入排序。也有的实现，如果接收到不连续的消息会尝试等待一个非常短的时间看前面的消息会不会到，如果还没到也一般会直接显示出来。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567841968,"ip_address":"","comment_id":131520,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567780014","product_id":100034901,"comment_content":"老师，我对您这句话感到疑惑，“最终执行模块只有在一定超时时间内完整有序地收到所有消息才执行最终操作”，服务端或者客户端收到一条消息，然后是等待后面来的消息进行排序呢还是直接就推送或显示呢？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466499,"discussion_content":"这个看需求，客户端接收到消息即使不连续一般也可以直接先显示，然后等前面的消息到了再在页面进行一次插入排序。也有的实现，如果接收到不连续的消息会尝试等待一个非常短的时间看前面的消息会不会到，如果还没到也一般会直接显示出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567841968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131504,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1567770204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567770204","product_id":100034901,"comment_content":"老师，帮忙解答一下我的这篇文章另个留言提的问题，谢谢","like_count":0},{"had_liked":false,"id":131474,"user_name":"Peiel","can_delete":false,"product_type":"c1","uid":1013762,"ip_address":"","ucode":"B10301B05B8507","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/02/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1567760910,"is_pvip":false,"replies":[{"id":"49875","content":"服务端整流用到的这个seqID和客户端本地排序使用的seqID是不相关的哈，服务端整流用到的这个seqID不会给到接收端。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567770355,"ip_address":"","comment_id":131474,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567760910","product_id":100034901,"comment_content":"老师您好，在讲包内整流的流程中，客户端本地整流的流程中，不需要使用服务端的 packageID 吗？只用到 seqID 来判断顺序就可以了吗?","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466471,"discussion_content":"服务端整流用到的这个seqID和客户端本地排序使用的seqID是不相关的哈，服务端整流用到的这个seqID不会给到接收端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567770355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131454,"user_name":"阳仔","can_delete":false,"product_type":"c1","uid":1046920,"ip_address":"","ucode":"79F73D85EDF3E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/88/cdda9e6f.jpg","comment_is_top":false,"comment_ctime":1567757358,"is_pvip":false,"replies":[{"id":"49874","content":"主要是时间精度不太够，只能做到秒间有序，所以排序上可能会有一定的误差。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567770263,"ip_address":"","comment_id":131454,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567757358","product_id":100034901,"comment_content":"snowflake 算法的时间相关的分布式“序号生成器”也存在一些问题？<br>这个是什么问题呢？可以提一下吗","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466462,"discussion_content":"主要是时间精度不太够，只能做到秒间有序，所以排序上可能会有一定的误差。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567770263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131383,"user_name":"阳阳","can_delete":false,"product_type":"c1","uid":1605341,"ip_address":"","ucode":"078DD80E0ADD38","user_header":"https://static001.geekbang.org/account/avatar/00/18/7e/dd/8098a7e0.jpg","comment_is_top":false,"comment_ctime":1567734697,"is_pvip":true,"replies":[{"id":"49868","content":"long型的话一般不太需要考虑长度限制的问题呀，以天为单位的话需要特殊处理跨天排序的情况，可能会比较麻烦。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567769536,"ip_address":"","comment_id":131383,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567734697","product_id":100034901,"comment_content":"老师您好，有一个疑惑：序号生成器是否也要考虑到数据范围问题？一直增长的话，总有一天会超过序号id字段定义的字段类型长度，是不是每个群一个序号生成器或者每个对话一个序号生成器，然后以天为前缀去增长？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466424,"discussion_content":"long型的话一般不太需要考虑长度限制的问题呀，以天为单位的话需要特殊处理跨天排序的情况，可能会比较麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567769536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131381,"user_name":"geekymv","can_delete":false,"product_type":"c1","uid":1075950,"ip_address":"","ucode":"B119ACE47B8C0C","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJTywPCdTDoRAaLBN20JfD50dQPic0B3OeUgYMHA3x7ptvF3iaCRTqrNZsF3Cz8TCibcwSsCichdOiallQ/0","comment_is_top":false,"comment_ctime":1567734381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567734381","product_id":100034901,"comment_content":"在即时消息收发场景中，用于保证消息接收时序的序号生成器为什么可以不是全局递增的？<br>答：从业务层面考虑，在直播间或群聊这种场景下 ，只要保证单个群里的消息有序即可，没有必要保证全局多个群的时序。可以针对每个群有个独立的ID生成器，比如使用redis的话，可以用 incr 群ID 来保证同一个群内消息序号递增。另外Redis Cluster是支持多主，使用群维度的ID生成器也可以降低服务器并发压力。","like_count":0},{"had_liked":false,"id":131314,"user_name":"段先森","can_delete":false,"product_type":"c1","uid":1310788,"ip_address":"","ucode":"90251BB8BF8DDB","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/44/d5cf762b.jpg","comment_is_top":false,"comment_ctime":1567702622,"is_pvip":false,"replies":[{"id":"49865","content":"对于群和直播间来说，处理上确实只需要消息ID在这个群或者直播间有序就可以了，但是也要考虑在“最近联系人列表”页需要按照多个群或者多个直播间的最新一条消息的产生先后来排序，这种情况可能还需要考虑使用其他属性来进行全局排序了（比如消息产生的时间戳）。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1567769011,"ip_address":"","comment_id":131314,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1567702622","product_id":100034901,"comment_content":"如果是直播这种场景，也就意味着只要保证同一个直播间的消息是ID递增的就可以了。是不是可以动态维护redis，有直播间创建就new一个，有直播间关闭就销毁一个。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466384,"discussion_content":"对于群和直播间来说，处理上确实只需要消息ID在这个群或者直播间有序就可以了，但是也要考虑在“最近联系人列表”页需要按照多个群或者多个直播间的最新一条消息的产生先后来排序，这种情况可能还需要考虑使用其他属性来进行全局排序了（比如消息产生的时间戳）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567769011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027781,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/c5/09c2dd48.jpg","nickname":"M$画像","note":"","ucode":"B7298F0CC7ADC8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7907,"discussion_content":"这样做代价有点大，不可行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567724565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1013762,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/02/abb7bfe3.jpg","nickname":"Peiel","note":"","ucode":"B10301B05B8507","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027781,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/c5/09c2dd48.jpg","nickname":"M$画像","note":"","ucode":"B7298F0CC7ADC8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":8014,"discussion_content":"代价主要体现在哪方面呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567757691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7907,"ip_address":""},"score":8014,"extra":""},{"author":{"id":1027781,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/c5/09c2dd48.jpg","nickname":"M$画像","note":"","ucode":"B7298F0CC7ADC8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1013762,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/02/abb7bfe3.jpg","nickname":"Peiel","note":"","ucode":"B10301B05B8507","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":11459,"discussion_content":"一个直播间一个redis实例。你一台机子能起多少个进程？你有多少个端口可用？进程比较贵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568383913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8014,"ip_address":""},"score":11459,"extra":""}]}]}]}