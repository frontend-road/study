{"id":169268,"title":"03 | 右值和移动究竟解决了什么问题？","content":"<p>你好，我是吴咏炜。</p><p>从上一讲智能指针开始，我们已经或多或少接触了移动语义。本讲我们就完整地讨论一下移动语义和相关的概念。移动语义是 C++11 里引入的一个重要概念；理解这个概念，是理解很多现代 C++ 里的优化的基础。</p><h2>值分左右</h2><p>我们常常会说，C++ 里有左值和右值。这话不完全对。标准里的定义实际更复杂，规定了下面这些值类别（value categories）：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/3c/18b692072537d4ce179d3857a8a0133c.png?wh=720*576\" alt=\"\"></p><p>我们先理解一下这些名词的字面含义：</p><ul>\n<li>一个 lvalue 是通常可以放在等号左边的表达式，左值</li>\n<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>\n<li>一个 glvalue 是 generalized lvalue，广义左值</li>\n<li>一个 xvalue 是 expiring value，将亡值</li>\n<li>一个 prvalue 是 pure rvalue，纯右值</li>\n</ul><p>还是有点晕，是吧？我们暂且抛开这些概念，只看其中两个：lvalue 和 prvalue。</p><p>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：</p><ul>\n<li>变量、函数或数据成员的名字</li>\n<li>返回左值引用的表达式，如 <code>++x</code>、<code>x = 1</code>、<code>cout &lt;&lt; ' '</code></li>\n<li>字符串字面量如 <code>\"hello world\"</code></li>\n</ul><p>在函数调用时，左值可以绑定到左值引用的参数，如 <code>T&amp;</code>。一个常量只能绑定到常左值引用，如 <code>const T&amp;</code>。</p><!-- [[[read_end]]] --><p>反之，纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般也称之为“临时对象”。最常见的情况有：</p><ul>\n<li>返回非引用类型的表达式，如 <code>x++</code>、<code>x + 1</code>、<code>make_shared&lt;int&gt;(42)</code></li>\n<li>除字符串字面量之外的字面量，如 <code>42</code>、<code>true</code></li>\n</ul><p>在 C++11 之前，右值可以绑定到常左值引用（const lvalue reference）的参数，如 <code>const T&amp;</code>，但不可以绑定到非常左值引用（non-const lvalue reference），如 <code>T&amp;</code>。从 C++11 开始，C++ 语言里多了一种引用类型——右值引用。右值引用的形式是 <code>T&amp;&amp;</code>，比左值引用多一个 <code>&amp;</code> 符号。跟左值引用一样，我们可以使用 <code>const</code> 和 <code>volatile</code> 来进行修饰，但最常见的情况是，我们不会用 <code>const</code> 和 <code>volatile</code> 来修饰右值。本专栏就属于这种情况。</p><p>引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能性。由于 C++ 有重载，我们就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为。回想一下，在上一讲中，我们就利用了重载，让 <code>smart_ptr</code> 的构造函数可以有不同的行为：</p><pre><code class=\"language-c++\">template &lt;typename U&gt;\nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    other.shared_count_-&gt;add_count();\n    shared_count_ =\n      other.shared_count_;\n  }\n}\ntemplate &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    shared_count_ =\n      other.shared_count_;\n    other.ptr_ = nullptr;\n  }\n}\n</code></pre><p>你可能会好奇，使用右值引用的第二个重载函数中的变量 <code>other</code> 算是左值还是右值呢？根据定义，<code>other</code> 是个变量的名字，变量有标识符、有地址，所以它还是一个左值——虽然它的类型是右值引用。</p><p>尤其重要的是，拿这个 <code>other</code> 去调用函数时，它匹配的也会是左值引用。也就是说，<strong>类型是右值引用的变量是一个左值！</strong>这点可能有点反直觉，但跟 C++ 的其他方面是一致的。毕竟对于一个右值引用的变量，你是可以取地址的，这点上它和左值完全一致。稍后我们再回到这个话题上来。</p><p>再看一下下面的代码：</p><pre><code class=\"language-c++\">smart_ptr&lt;shape&gt; ptr1{new circle()};\nsmart_ptr&lt;shape&gt; ptr2 = std::move(ptr1);\n</code></pre><p>第一个表达式里的 <code>new circle()</code> 就是一个纯右值；但对于指针，我们通常使用值传递，并不关心它是左值还是右值。</p><p>第二个表达式里的 <code>std::move(ptr)</code> 就有趣点了。它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在我们这儿 <code>std::move(ptr1)</code> 等价于 <code>static_cast&lt;smart_ptr&lt;shape&gt;&amp;&amp;&gt;(ptr1)</code>。因此，<code>std::move(ptr1)</code> 的结果是指向 <code>ptr1</code> 的一个右值引用，这样构造 <code>ptr2</code> 时就会选择上面第二个重载。</p><p>我们可以把 <code>std::move(ptr1)</code> 看作是一个有名字的右值。为了跟无名的纯右值 prvalue 相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue。我们用下面的图来表示会更清楚一点：</p><p><img src=\"https://static001.geekbang.org/resource/image/03/5a/036cc6865a9623a48918b504e408945a.png?wh=768*830\" alt=\"\"></p><p>另外请注意，“值类别”（value category）和“值类型”（value type）是两个看似相似、却毫不相干的术语。前者指的是上面这些左值、右值相关的概念，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。在 C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（<code>&amp;</code>）和指针（<code>*</code>）才是引用类型。在 Java 里，数字等原生类型是值类型，类则属于引用类型。在 Python 里，一切类型都是引用类型。</p><h2>生命周期和表达式类型</h2><p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。那临时对象（prvalue）呢？在这儿，C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生。我们先看一个没有生命周期延长的基本情况：</p><pre><code class=\"language-c++\">process_shape(circle(), triangle());\n</code></pre><p>在这儿，我们生成了临时对象，一个圆和一个三角形，它们会在 <code>process_shape</code> 执行完成并生成结果对象后被销毁。</p><p>我们插入一些实际的代码，就可以演示这一行为：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\npublic:\n  circle() { puts(\"circle()\"); }\n  ~circle() { puts(\"~circle()\"); }\n};\n\nclass triangle : public shape {\npublic:\n  triangle() { puts(\"triangle()\"); }\n  ~triangle() { puts(\"~triangle()\"); }\n};\n\nclass result {\npublic:\n  result() { puts(\"result()\"); }\n  ~result() { puts(\"~result()\"); }\n};\n\nresult\nprocess_shape(const shape&amp; shape1,\n              const shape&amp; shape2)\n{\n  puts(\"process_shape()\");\n  return result();\n}\n\nint main()\n{\n  puts(\"main()\");\n  process_shape(circle(), triangle());\n  puts(\"something else\");\n}\n</code></pre><p>输出结果可能会是（<code>circle</code> 和 <code>triangle</code> 的顺序在标准中没有规定）：</p><blockquote>\n<p><code>main()</code><br>\n<code>circle()</code><br>\n<code>triangle()</code><br>\n<code>process_shape()</code><br>\n<code>result()</code><br>\n<code>~result()</code><br>\n<code>~triangle()</code><br>\n<code>~circle()</code><br>\n<code>something else</code></p>\n</blockquote><p>目前我让 <code>process_shape</code> 也返回了一个结果，这是为了下一步演示的需要。你可以看到结果的临时对象最后生成、最先析构。</p><p>为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：</p><blockquote>\n<p>如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。</p>\n</blockquote><p>我们对上面的代码只要改一行就能演示这个效果。把 <code>process_shape</code> 那行改成：</p><pre><code class=\"language-c++\">result&amp;&amp; r = process_shape(\n  circle(), triangle());\n</code></pre><p>我们就能看到不同的结果了：</p><blockquote>\n<p><code>main()</code><br>\n<code>circle()</code><br>\n<code>triangle()</code><br>\n<code>process_shape()</code><br>\n<code>result()</code><br>\n<code>~triangle()</code><br>\n<code>~circle()</code><br>\n<code>something else</code><br>\n<code>~result()</code></p>\n</blockquote><p>现在 <code>result</code> 的生成还在原来的位置，但析构被延到了 <code>main</code> 的最后。</p><p>需要万分注意的是，这条生命期延长规则只对 prvalue 有效，而对 xvalue 无效。如果由于某种原因，prvalue 在绑定到引用以前已经变成了 xvalue，那生命期就不会延长。不注意这点的话，代码就可能会产生隐秘的 bug。比如，我们如果这样改一下代码，结果就不对了：</p><pre><code class=\"language-c++\">#include &lt;utility&gt;  // std::move\n…\nresult&amp;&amp; r = std::move(process_shape(\n  circle(), triangle()));\n</code></pre><p>这时的代码输出就回到了前一种情况。虽然执行到 something else 那儿我们仍然有一个有效的变量 <code>r</code>，但它指向的对象已经不存在了，对 <code>r</code> 的解引用是一个未定义行为。由于 <code>r</code> 指向的是栈空间，通常不会立即导致程序崩溃，而会在某些复杂的组合条件下才会引致问题……</p><p>对 C++ 的这条生命期延长规则，在后面讲到视图（view）的时候会十分有用。那时我们会看到，有些 C++ 的用法实际上会隐式地利用这条规则。</p><p>此外，参考资料 <span class=\"orange\">[5]</span> 中提到了一个有趣的事实：你可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响。</p><h2>移动的意义</h2><p>上面我们谈了一些语法知识。就跟学外语的语法一样，这些内容是比较枯燥的。虽然这些知识有时有用，但往往要回过头来看的时候才觉得。初学之时，更重要的是理解为什么，和熟练掌握基本的用法。</p><p>对于 <code>smart_ptr</code>，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销——在引用计数指针的场景下，这个开销并不大。移动构造和拷贝构造的差异仅在于：</p><ul>\n<li>少了一次 <code>other.shared_count_-&gt;add_count()</code> 的调用</li>\n<li>被移动的指针被清空，因而析构时也少了一次 <code>shared_count_-&gt;reduce_count()</code> 的调用</li>\n</ul><p>在使用容器类的情况下，移动更有意义。我们可以尝试分析一下下面这个假想的语句（假设 <code>name</code> 是 <code>string</code> 类型）：</p><pre><code class=\"language-c++\">string result =\n  string(\"Hello, \") + name + \".\";\n</code></pre><p>在 C++11 之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外开销，执行流程大致如下：</p><ol>\n<li>调用构造函数 <code>string(const char*)</code>，生成临时对象 1；<code>\"Hello, \"</code> 复制 1 次。</li>\n<li>调用 <code>operator+(const string&amp;, const string&amp;)</code>，生成临时对象 2；<code>\"Hello, \"</code> 复制 2 次，<code>name</code> 复制 1 次。</li>\n<li>调用 <code>operator+(const string&amp;, const char*)</code>，生成对象 3；<code>\"Hello, \"</code> 复制 3 次，<code>name</code> 复制 2 次，<code>\".\"</code> 复制 1 次。</li>\n<li>假设返回值优化能够生效（最佳情况），对象 3 可以直接在 <code>result</code> 里构造完成。</li>\n<li>临时对象 2 析构，释放指向 <code>string(\"Hello, \") + name</code> 的内存。</li>\n<li>临时对象 1 析构，释放指向 <code>string(\"Hello, \")</code> 的内存。</li>\n</ol><p>既然 C++ 是一门追求性能的语言，一个合格的 C++ 程序员会写：</p><pre><code class=\"language-c++\">string result = \"Hello, \";\nresult += name;\nresult += \".\";\n</code></pre><p>这样的话，只会调用构造函数一次和 <code>string::operator+=</code> 两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。但显然代码就啰嗦多了——尤其如果拼接的步骤比较多的话。从 C++11 开始，这不再是必须的。同样上面那个单行的语句，执行流程大致如下：</p><ol>\n<li>调用构造函数 <code>string(const char*)</code>，生成临时对象 1；<code>\"Hello, \"</code> 复制 1 次。</li>\n<li>调用 <code>operator+(string&amp;&amp;, const string&amp;)</code>，直接在临时对象 1 上面执行追加操作，并把结果移动到临时对象 2；<code>name</code> 复制 1 次。</li>\n<li>调用 <code>operator+(string&amp;&amp;, const char*)</code>，直接在临时对象 2 上面执行追加操作，并把结果移动到 <code>result</code>；<code>\".\"</code> 复制 1 次。</li>\n<li>临时对象 2 析构，内容已经为空，不需要释放任何内存。</li>\n<li>临时对象 1 析构，内容已经为空，不需要释放任何内存。</li>\n</ol><p>性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。程序员只需要牺牲一点点性能，就可以大大增加代码的可读性。而且，所谓的性能牺牲，也只是相对于优化得很好的 C 或 C++ 代码而言——这样的 C++ 代码的性能仍然完全可以超越 Python 类的语言的相应代码。</p><p>此外很关键的一点是，C++ 里的对象缺省都是值语义。在下面这样的代码里：</p><pre><code class=\"language-c++\">class A {\n  B b_;\n  C c_;\n};\n</code></pre><p>从实际内存布局的角度，很多语言——如 Java 和 Python——会在 <code>A</code> 对象里放 <code>B</code> 和 <code>C</code> 的指针（虽然这些语言里本身没有指针的概念）。而 C++ 则会直接把 <code>B</code> 和 <code>C</code> 对象放在 <code>A</code> 的内存空间里。这种行为既是优点也是缺点。说它是优点，是因为它保证了内存访问的局域性，而局域性在现代处理器架构上是绝对具有性能优势的。说它是缺点，是因为复制对象的开销大大增加：在 Java 类语言里复制的是指针，在 C++ 里是完整的对象。这就是为什么 C++ 需要移动语义这一优化，而 Java 类语言里则根本不需要这个概念。</p><p>一句话总结，移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。</p><p>所有的现代 C++ 的标准容器都针对移动进行了优化。</p><h2>如何实现移动？</h2><p>要让你设计的对象支持移动的话，通常需要下面几步：</p><ul>\n<li>你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝——如 <code>unique_ptr</code>）。</li>\n<li>你的对象应该有 <code>swap</code> 成员函数，支持和另外一个对象快速交换成员。</li>\n<li>在你的对象的名空间下，应当有一个全局的 <code>swap</code> 函数，调用成员函数 <code>swap</code> 来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的 <code>swap</code> 函数。</li>\n<li>实现通用的 <code>operator=</code>。</li>\n<li>上面各个函数如果不抛异常的话，应当标为 <code>noexcept</code>。这对移动构造函数尤为重要。</li>\n</ul><p>具体写法可以参考我们当前已经实现的 <code>smart_ptr</code>：</p><ul>\n<li><code>smart_ptr</code> 有拷贝构造和移动构造函数（虽然此处我们的模板构造函数严格来说不算拷贝或移动构造函数）。移动构造函数应当从另一个对象获取资源，清空其资源，并将其置为一个可析构的状态。</li>\n</ul><pre><code class=\"language-c++\">smart_ptr(const smart_ptr&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    other.shared_count_\n      -&gt;add_count();\n    shared_count_ =\n      other.shared_count_;\n  }\n}\ntemplate &lt;typename U&gt;\nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    other.shared_count_\n      -&gt;add_count();\n    shared_count_ =\n      other.shared_count_;\n  }\n}\ntemplate &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n{\n  ptr_ = other.ptr_;\n  if (ptr_) {\n    shared_count_ =\n      other.shared_count_;\n    other.ptr_ = nullptr;\n  }\n}\n</code></pre><ul>\n<li><code>smart_ptr</code> 有 <code>swap</code> 成员函数。</li>\n</ul><pre><code class=\"language-c++\">void swap(smart_ptr&amp; rhs) noexcept\n{\n  using std::swap;\n  swap(ptr_, rhs.ptr_);\n  swap(shared_count_,\n       rhs.shared_count_);\n}\n</code></pre><ul>\n<li>有支持 <code>smart_ptr</code> 的全局 <code>swap</code> 函数。</li>\n</ul><pre><code class=\"language-c++\">template &lt;typename T&gt;\nvoid swap(smart_ptr&lt;T&gt;&amp; lhs,\n          smart_ptr&lt;T&gt;&amp; rhs) noexcept\n{\n  lhs.swap(rhs);\n}\n</code></pre><ul>\n<li><code>smart_ptr</code> 有通用的 <code>operator=</code> 成员函数。注意为了避免让人吃惊，通常我们需要将其实现成对 <code>a = a;</code> 这样的写法安全。下面的写法算是个小技巧，对传递左值和右值都有效，而且规避了 <code>if (&amp;rhs != this)</code> 这样的判断。</li>\n</ul><pre><code class=\"language-c++\">  smart_ptr&amp;\n  operator=(smart_ptr rhs) noexcept\n  {\n    rhs.swap(*this);\n    return *this;\n  }\n</code></pre><h2>不要返回本地变量的引用</h2><p>有一种常见的 C++ 编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出任何奇怪的行为都是正常的。</p><p>在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 <code>std::move</code> 进行干预——使用 <code>std::move</code> 对于移动行为没有帮助，反而会影响返回值优化。</p><p>下面是个例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;  // std::cout/endl\n#include &lt;utility&gt;   // std::move\n\nusing namespace std;\n\nclass Obj {\npublic:\n  Obj()\n  {\n    cout &lt;&lt; \"Obj()\" &lt;&lt; endl;\n  }\n  Obj(const Obj&amp;)\n  {\n    cout &lt;&lt; \"Obj(const Obj&amp;)\"\n       &lt;&lt; endl;\n  }\n  Obj(Obj&amp;&amp;)\n  {\n    cout &lt;&lt; \"Obj(Obj&amp;&amp;)\" &lt;&lt; endl;\n  }\n};\n\nObj simple()\n{\n  Obj obj;\n  // 简单返回对象；一般有 NRVO\n  return obj;\n}\n\nObj simple_with_move()\n{\n  Obj obj;\n  // move 会禁止 NRVO\n  return std::move(obj);\n}\n\nObj complicated(int n)\n{\n  Obj obj1;\n  Obj obj2;\n  // 有分支，一般无 NRVO\n  if (n % 2 == 0) {\n    return obj1;\n  } else {\n    return obj2;\n  }\n}\n\nint main()\n{\n  cout &lt;&lt; \"*** 1 ***\" &lt;&lt; endl;\n  auto obj1 = simple();\n  cout &lt;&lt; \"*** 2 ***\" &lt;&lt; endl;\n  auto obj2 = simple_with_move();\n  cout &lt;&lt; \"*** 3 ***\" &lt;&lt; endl;\n  auto obj3 = complicated(42);\n}\n</code></pre><p>输出通常为：</p><blockquote>\n<p><code>*** 1 ***</code><br>\n<code>Obj()</code><br>\n<code>*** 2 ***</code><br>\n<code>Obj()</code><br>\n<code>Obj(Obj&amp;&amp;)</code><br>\n<code>*** 3 ***</code><br>\n<code>Obj()</code><br>\n<code>Obj()</code><br>\n<code>Obj(Obj&amp;&amp;)</code></p>\n</blockquote><p>也就是，用了 <code>std::move</code> 反而妨碍了返回值优化。</p><h2>引用坍缩和完美转发</h2><p>最后讲一个略复杂、但又不得不讲的话题，引用坍缩（又称“引用折叠”）。这个概念在泛型编程中是一定会碰到的。我们今天既然讲了左值和右值引用，也需要一起讲一下。</p><p>我们已经讲了对于一个实际的类型 <code>T</code>，它的左值引用是 <code>T&amp;</code>，右值引用是 <code>T&amp;&amp;</code>。那么：</p><ol>\n<li>是不是看到 <code>T&amp;</code>，就一定是个左值引用？</li>\n<li>是不是看到 <code>T&amp;&amp;</code>，就一定是个右值引用？</li>\n</ol><p>对于前者的回答是“是”，对于后者的回答为“否”。</p><p>关键在于，在有模板的代码里，对于类型参数的推导结果可能是引用。我们可以略过一些繁复的语法规则，要点是：</p><ul>\n<li>对于 <code>template &lt;typename T&gt; foo(T&amp;&amp;)</code> 这样的代码，如果传递过去的参数是左值，<code>T</code> 的推导结果是左值引用；如果传递过去的参数是右值，<code>T</code> 的推导结果是参数的类型本身。</li>\n<li>如果 <code>T</code> 是左值引用，那 <code>T&amp;&amp;</code> 的结果仍然是左值引用——即 <code>type&amp; &amp;&amp;</code> 坍缩成了 <code>type&amp;</code>。</li>\n<li>如果 <code>T</code> 是一个实际类型，那 <code>T&amp;&amp;</code> 的结果自然就是一个右值引用。</li>\n</ul><p>我们之前提到过，右值引用变量仍然会匹配到左值引用上去。下面的代码会验证这一行为：</p><pre><code class=\"language-c++\">void foo(const shape&amp;)\n{\n  puts(\"foo(const shape&amp;)\");\n}\n\nvoid foo(shape&amp;&amp;)\n{\n  puts(\"foo(shape&amp;&amp;)\");\n}\n\nvoid bar(const shape&amp; s)\n{\n  puts(\"bar(const shape&amp;)\");\n  foo(s);\n}\n\nvoid bar(shape&amp;&amp; s)\n{\n  puts(\"bar(shape&amp;&amp;)\");\n  foo(s);\n}\n\nint main()\n{\n  bar(circle());\n}\n</code></pre><p>输出为：</p><blockquote>\n<p><code>bar(shape&amp;&amp;)</code><br>\n<code>foo(const shape&amp;)</code></p>\n</blockquote><p>如果我们要让 <code>bar</code> 调用右值引用的那个 foo 的重载，我们必须写成：</p><pre><code class=\"language-c++\">foo(std::move(s));\n</code></pre><p>或：</p><pre><code class=\"language-c++\">foo(static_cast&lt;shape&amp;&amp;&gt;(s));\n</code></pre><p>可如果两个 <code>bar</code> 的重载除了调用 <code>foo</code> 的方式不一样，其他都差不多的话，我们为什么要提供两个不同的 <code>bar</code> 呢？</p><p>事实上，很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类别：左值的仍然是左值，右值的仍然是右值。这个功能在 C++ 标准库中已经提供了，叫 <code>std::forward</code>。它和 <code>std::move</code> 一样都是利用引用坍缩机制来实现。此处，我们不介绍其实现细节，而是重点展示其用法。我们可以把我们的两个 <code>bar</code> 函数简化成：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nvoid bar(T&amp;&amp; s)\n{\n  foo(std::forward&lt;T&gt;(s));\n}\n</code></pre><p>对于下面这样的代码：</p><pre><code class=\"language-c++\">circle temp;\nbar(temp);\nbar(circle());\n</code></pre><p>现在的输出是：</p><blockquote>\n<p><code>foo(const shape&amp;)</code><br>\n<code>foo(shape&amp;&amp;)</code></p>\n</blockquote><p>一切如预期一样。</p><p>因为在 <code>T</code> 是模板参数时，<code>T&amp;&amp;</code> 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。</p><h2>内容小结</h2><p>本讲介绍了 C++ 里的值类别，重点介绍了临时变量、右值引用、移动语义和实际的编程用法。由于这是 C++11 里的重点功能，你对于其基本用法需要牢牢掌握。</p><h2>课后思考</h2><p>留给你两道思考题：</p><ol>\n<li>请查看一下标准函数模板 <code>make_shared</code> 的声明，然后想一想，这个函数应该是怎样实现的。</li>\n<li>为什么 <code>smart_ptr::operator=</code> 对左值和右值都有效，而且不需要对等号两边是否引用同一对象进行判断？</li>\n</ol><p>欢迎留言和我交流你的看法，尤其是对第二个问题。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Value categories”. <a href=\"https://en.cppreference.com/w/cpp/language/value_category\">https://en.cppreference.com/w/cpp/language/value_category</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “值类别”. <a href=\"https://zh.cppreference.com/w/cpp/language/value_category\">https://zh.cppreference.com/w/cpp/language/value_category</a> </span></p><p><span class=\"reference\">[2] Anders Schau Knatten, “lvalues, rvalues, glvalues, prvalues, xvalues, help!”. <a href=\"https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalues-help/\">https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalues-help/</a> </span></p><p><span class=\"reference\">[3] Jeaye, “Value category cheat-sheet”. <a href=\"https://blog.jeaye.com/2017/03/19/xvalues/\">https://blog.jeaye.com/2017/03/19/xvalues/</a> </span></p><p><span class=\"reference\">[4] Thomas Becker, “C++ rvalue references explained”. <a href=\"http://thbecker.net/articles/rvalue_references/section_01.html\">http://thbecker.net/articles/rvalue_references/section_01.html</a> </span></p><p><span class=\"reference\">[5] Herb Sutter, “GotW #88: A candidate for the ‘most important const’”. <a href=\"https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\">https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/</a> </span></p>","comments":[{"had_liked":false,"id":158343,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575360441,"is_pvip":false,"replies":[{"id":60644,"content":"理解满分。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378121,"ip_address":"","comment_id":158343,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第二题：\n左值和右值都有效是因为构造参数时，如果是左值，就用拷贝构造构造函数，右值就用移动构造函数\n无论是左值还是右值，构造参数时直接生成新的智能指针，因此不需要判断","like_count":54},{"had_liked":false,"id":157942,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575287486,"is_pvip":false,"replies":[{"id":60518,"content":"是。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575289268,"ip_address":"","comment_id":157942,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请教下老师，字符串字面量是左值，是不是在C++中 字符串其实是const char[N]，其实是个常量表达式，在内存中有明确的地址。","like_count":26,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476690,"discussion_content":"理解满分。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575378121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736297,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","nickname":"Initiative Thinker","note":"","ucode":"A884396A1581EF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232150,"discussion_content":"不需要判断的关键是Swap吧，前面好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586856953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1736297,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","nickname":"Initiative Thinker","note":"","ucode":"A884396A1581EF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":232995,"discussion_content":"时间太久远了，我刚回看了一下，\nswap主要是规避了 if(&amp;rhs != this)这个判断。\n不需要判断是因为形参是值传递，肯定是需要构造新的对象的，这时候如果实参是左值就用拷贝构造，如果是右值就用移动构造。\n我觉得重点是区分一下左值、右值和左值信用、右值引用的概念。感觉你可能是没理解清楚","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1586882038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":232150,"ip_address":"","group_id":0},"score":232995,"extra":""}]}]},{"had_liked":false,"id":158228,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575354205,"is_pvip":false,"replies":[{"id":60642,"content":"你在学校的时候，都是让老师来看你的笔记记得好不好的吗？😂\n\n对不起，如果有明确的问题，我可以回答。否则，我只能暂时忽略了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377830,"ip_address":"","comment_id":158228,"utype":1}],"discussion_count":8,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，我这个初学者看的比较慢，目前只看了右值与右值引用，下面是我总结了的学习心得，请您指点下：\n**背景：  \nC++11为了支持移动操作，引用了新的引用类型-右值引用。  \n所谓右值引用就是绑定到右值的引用。  \n为了区分右值引用，引入左值引用概念，即常规引用。  \n那左值与右值是是什么？**  \n\n## 1、左值与右值\n\n**左值 lvalue 是有标识符、可以取地址的表达式**\n* 变量、函数或数据成员的名字  \n* 返回左值引用的表达式，如 ++x、x = 1、cout &lt;&lt; &#39; &#39;\n* 字符串字面量如 &quot;hello world&quot;\n\n表达式是不是左值，就看是否可以取地址，或者返回类型是否可以用（常规）引用来接收：\n\n```\nint x = 0;\ncout &lt;&lt; &quot;(x).addr = &quot; &lt;&lt; &amp;x &lt;&lt; endl; \ncout &lt;&lt; &quot;(x = 1).addr = &quot; &lt;&lt; &amp;(x = 1) &lt;&lt; endl;   &#47;&#47;x赋值1，返回x  \ncout &lt;&lt; &quot;(++x).addr = &quot; &lt;&lt; &amp;++x &lt;&lt; endl;   &#47;&#47;x自增1，返回x\n```\n\n&gt; 运行结果：  \n(x).addr = 0x22fe4c  \n(x = 1).addr = 0x22fe4c  \n(++x).addr = 0x22fe4c  \n\n```\ncout &lt;&lt; &quot;hello world = &quot; &lt;&lt; &amp;(&quot;hello world&quot;) &lt;&lt; endl; \n```\n\n&gt; 运行结果：  \nhello world = 0x40403a  \n\nC++中的字符串字面量，可以称为字符串常量，表示为const char[N]，其实是地址常量表达式。  \n在内存中有明确的地址，不是临时变量。\n\n```\ncout &lt;&lt; &quot;cout &lt;&lt; &#39; &#39; = &quot; &lt;&lt; &amp;(cout &lt;&lt; &#39; &#39;) &lt;&lt; endl;\n```\n&gt; 运行结果：\ncout &lt;&lt; &#39; &#39; =  0x6fd0acc0\n\n**纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般称为“临时对象”**\n* 返回非引用类型的表达式，如 x++、x + 1、make_shared(42)\n* 除字符串字面量之外的字面量，如 42、true\n\n```\n&#47;&#47;cout &lt;&lt; &quot;(x++).addr = &quot; &lt;&lt; &amp;x++ &lt;&lt; endl;  &#47;&#47;返回一个值为x的临时变量，再把x自增1\n&#47;&#47;cout &lt;&lt; &quot;(x + 1).addr = &quot; &lt;&lt; &amp;(x + 1) &lt;&lt; endl;  &#47;&#47;返回一个值为x+1的临时变量 \n&#47;&#47;cout &lt;&lt; &quot;(42).addr = &quot; &lt;&lt; &amp;(42) &lt;&lt; endl;  &#47;&#47;返回一个值为42的临时变量\n&#47;&#47;cout &lt;&lt; &quot;(true).addr = &quot; &lt;&lt; &amp;(true) &lt;&lt; endl;  &#47;&#47;返回一个值为true的临时变量\n```\n&gt; 编译出错：  \n每行代码报错：表达式必须为左值或函数指示符  \n因为以上表达式都返回的是“临时变量”，是不可以取地址的  \n\n---","like_count":25,"discussions":[{"author":{"id":2642536,"avatar":"https://static001.geekbang.org/account/avatar/00/28/52/68/97107e46.jpg","nickname":"杰","note":"","ucode":"CA6C00F8D724B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383282,"discussion_content":"比作者写的好我觉得。。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626022549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476681,"discussion_content":"你在学校的时候，都是让老师来看你的笔记记得好不好的吗？😂\n\n对不起，如果有明确的问题，我可以回答。否则，我只能暂时忽略了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575377830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181930,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4b/2a/4602363c.jpg","nickname":"高小高","note":"","ucode":"6F7D31403EE67A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321944,"discussion_content":"写得好，反正我是看懂了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604652323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yjPribEvEjfucxIXMz37icztGulgcuBAEQllOWKypiamntLLxkRIb20L7CQ2MVJxSt2KpyXW4dLpgL9YjbkDe9pAQ/132","nickname":"摸摸鱼","note":"","ucode":"E4851BF6E2FB17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653273,"discussion_content":"这个总结确实简单直接👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730566684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049550,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","nickname":"淡漠落寞","note":"","ucode":"17FF0A02D13098","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651073,"discussion_content":"赞努力可爱的兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726153672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484198,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyP4WVaRJVV3OQ6icPfjicf2JqHjNGw0PhhOMnibicoMzLC3xzibHuibd9s2c3uWa1Y9Gg721L4cO2MUQ/132","nickname":"Geek_46cdcd","note":"","ucode":"F67F8709F63A2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622516,"discussion_content":"哈哈哈，你们这么说，作者的面子往哪儿搁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688373187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2289318,"avatar":"","nickname":"Ada Li","note":"","ucode":"7C6413665B9822","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588574,"discussion_content":"写的很好，学到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663856936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1913231,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgiarK8ic7vY1RuR65ESnibhR5D6ic4rCf6DW9PBS4UCHcEZjibZWwGeicU82EllIic5nBcia0B0x0TcsVdQ/132","nickname":"程辉","note":"","ucode":"E9B49C5DDA84CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571400,"discussion_content":"总结的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652193828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279800,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1613966503,"is_pvip":false,"replies":[{"id":101697,"content":"对。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614039792,"ip_address":"","comment_id":279800,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我感觉我有点理解完美转发的意思了，对于一个函数，如果形参是右值引用，但在函数体内，这个“右值引用”实际上是一个左值变量，然后函数内再有一个函数传入这个参数，那么就会调用对应的左值引用版本，而完美转发的意义就相当于做一次类型转换，让这个参数保持一开始传入时的左值右值类别。\n不知道理解的对不对？","like_count":24,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515875,"discussion_content":"对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614039792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158193,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575344727,"is_pvip":false,"replies":[{"id":60639,"content":"对，最主要就是这点，用完美转发来正确调用构造函数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377361,"ip_address":"","comment_id":158193,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;请查看一下标准函数模板 make_shared 的声明，然后想一想，这个函数应该是怎样实现的。&quot;\n\ntemplate &lt;class T, class... Args&gt;\nstd::shared_ptr&lt;T&gt; make_shared (Args&amp;&amp;... args)\n{\n    T* ptr = new T(std::forward&lt;Args...&gt;(args...));\n    return std::shared_ptr&lt;T&gt;(ptr);\n}\n\n我的考虑是：\nmake_shared声明里的（Args&amp;&amp;...） 是universal reference， 所以在函数体里用完美转发（std::forward）把参数出入T的构造函数, 以调用每个参数各自对用的构造函数（copy or move）。\n\n肯定还有别的需要考量的地方，请指正。\n\n谢谢！","like_count":22,"discussions":[{"author":{"id":3044278,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/73/b6/73f85077.jpg","nickname":"DDRH","note":"","ucode":"047BF2A1D1A27A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591611,"discussion_content":"智能指针的make_shared是一个很好的使用完美转发的模板，可以套用到很多data holder的构造方式中，学习了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1666703575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2353732,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ea/44/cf0b2541.jpg","nickname":"Marc Chan","note":"","ucode":"D365D6793F304B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549018,"discussion_content":"  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;\n      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...);\n    }\n\nstd::forward万能转发，不管传入左值还是右值都会正确的调用对应的构造函数，不会让右值引用产生引用坍缩，导致调用了左值的构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643519408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476663,"discussion_content":"对，最主要就是这点，用完美转发来正确调用构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575377361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198474,"discussion_content":"应该主要还是确保调用T中正确的构造函数吧，Args&amp;&amp;里面不论是左值还是右值应该在传入的时候已经构造完成了。话说这个&amp;&amp;的universal reference的设定这么强大？用这种方法，Args&amp;&amp;里面每一个参数都可以按照它们自己的引用方式forward，就是说，Args里面既可以有lvalue也可以有rvalue，这么理解正确吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583505741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1736297,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","nickname":"Initiative Thinker","note":"","ucode":"A884396A1581EF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232155,"discussion_content":"没毛病，应该既可以传输左值也可以传输右值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586857221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198474,"ip_address":"","group_id":0},"score":232155,"extra":""}]}]},{"had_liked":false,"id":158231,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575354282,"is_pvip":false,"replies":[{"id":60647,"content":"再多说一句，如果每个人都这么让我来看笔记的话，我是不可能满足所有人的。只看你的，也对别人不公。在这儿回答（不重复的）问题则不同，问题一般是有共性的，回答之后，大家都能看到，都能从中受益。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575379266,"ip_address":"","comment_id":158231,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，留言有字数限制，我是接着上个留言来的，上面那个总结了下左值与右值，这个是右值引用的学习心得：\n## 2、右值引用\n**针对以上的所说的“临时变量”，如何来“接收”它呢？**  \n* 最直白的办法，就是直接用一个变量来“接收”  \n以x++为例：\n```\nvoid playVal(int y) {\n    cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, (y).adrr = &quot; &lt;&lt; &amp;y &lt;&lt; endl;\n}\n\nint x = 0;\nplayVal(x++);\ncout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, (x).adrr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;\n```\n\n&gt;运行结果：  \ny = 0, (y).adrr = 0x22fe20  \nx = 1, (x).adrr = 0x22fe4c  \n\n这是一个值传递过程，相当于 int y = x++，即x++生成的临时变量给变量y赋值，之后临时变量就“消失”，这里发生是一次拷贝。\n\n如何避免发生拷贝呢？  \n通常做法是使用引用来“接收”，即引用传递。  \n上面说过，使用一个（常规）引用来“接收”一个临时变量，会报错：\n```\nvoid playVal(int&amp; y)\n```\n&gt; error : 非常量引用的初始值必须为左值\n\n* 普遍的做法都是使用常量引用来“接收”临时变量（C++11之前）\n```\nvoid playVal(const int&amp; y)\n```\n这里编译器做了处理： int tmp = x++; const int&amp; y = tmp;  发生内存分配。\n其实还是发生了拷贝。\n\n* 使用右值引用来“接收”临时变量（C++11之后）  \n上面说过，“临时变量”是一个右值，所以这里可以使用右值引用来“接收”它  \n右值引用的形式是 T&amp;&amp; ：  \n```\nvoid playVal(int&amp;&amp; y) {\n    cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, (y).adrr = &quot; &lt;&lt; &amp;y &lt;&lt; endl;\n}\n\nint x = 0;\nplayVal(x++);\ncout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, (x).adrr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;  \n```\n\n&gt; 运行结果：  \ny = 0, (y).adrr = 0x22fe4c  \nx = 1, (x).adrr = 0x22fe48\n\n这是一个（右值）引用传递的过程，相当于 int&amp;&amp; y = x++，这里的右值引用 y 直接“绑定”了“临时变量”，因为它就会有了命名，变成“合法”的，就不会“消失”。  \n**注意：这里的变量 y 虽然是右值引用类型，但它是一个左值，可以正常对它取地址**  \n（如上例所示）","like_count":17,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476684,"discussion_content":"再多说一句，如果每个人都这么让我来看笔记的话，我是不可能满足所有人的。只看你的，也对别人不公。在这儿回答（不重复的）问题则不同，问题一般是有共性的，回答之后，大家都能看到，都能从中受益。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575379266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1890837,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/da/15/207ce035.jpg","nickname":"曌玥希","note":"","ucode":"326CA8B8E4C37F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548413,"discussion_content":"这个笔记写得很好啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643186938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70786,"discussion_content":"好的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575380266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2565411,"avatar":"https://static001.geekbang.org/account/avatar/00/27/25/23/9abd30c0.jpg","nickname":"Carl Wang","note":"","ucode":"C5FE25A658B36B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598967,"discussion_content":"这哥们 有完美转发的笔记么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673242045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1913231,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgiarK8ic7vY1RuR65ESnibhR5D6ic4rCf6DW9PBS4UCHcEZjibZWwGeicU82EllIic5nBcia0B0x0TcsVdQ/132","nickname":"程辉","note":"","ucode":"E9B49C5DDA84CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571401,"discussion_content":"写的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652194062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792714,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","nickname":"Im me","note":"","ucode":"FF7DEED4BB4C37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569870,"discussion_content":"这笔记优秀啊，十分优秀。顺便提一句，谁能跟极客时间提一下支持md呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651582214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219747,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590073576,"is_pvip":false,"replies":[{"id":81297,"content":"因为危险。临时对象在当前语句执行完成之后就被析构了。你握着这个已经不存在的对象的指针，想干嘛？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214253,"ip_address":"","comment_id":219747,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，为什么对临时对象不能使用取地址符&amp;，比如&amp;shape(),我知道这会编译报错:不能对右值取地址。我困惑的是:既然有对象，肯定有地址存放嘛，那一定能取地址才对。c++为什么要这样设计？或者说从堆栈的使用机制上看是为啥？","like_count":14,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495931,"discussion_content":"因为危险。临时对象在当前语句执行完成之后就被析构了。你握着这个已经不存在的对象的指针，想干嘛？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590214253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235116,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594896766,"is_pvip":false,"replies":[{"id":86850,"content":"右值引用只是一种重载规则。如果 B 和 C 是内部不使用指针的值类型的大对象，那 A、B、C 的移动构造是不会比拷贝构造更高效的。\n\n你去看一下标准容器的拷贝构造和移动构造就知道，移动的高效在于右值标明了这个对象马上就没人用了，允许移动构造函数通过调整指针把内容全部偷走而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594948386,"ip_address":"","comment_id":235116,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，不好意思我又来了……\n您给出了例子：\nclass A { B b_; C c_;}; 其实是长久以来我对移动构造的困惑：如果一个A这样的类，他的成员B, C都是通过值类型定义的，并且嵌套地，B、C成员也都是值类型定义的，一直到最终的原生类型。毫无疑问这样的内存布局是最符合temporal and spatial locality的，但是我非常困惑于如何实现一个A的高效率移动构造。除非“所谓的移动构造是一个triky的语法糖, 他事实上等价于容器的emplace”。","like_count":12,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495931,"discussion_content":"因为危险。临时对象在当前语句执行完成之后就被析构了。你握着这个已经不存在的对象的指针，想干嘛？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590214253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157962,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575290505,"is_pvip":false,"replies":[{"id":60529,"content":"对，x = 1 和 ++x 返回的都是对 x 的 int&amp;。x++ 则返回的是 int。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575294765,"ip_address":"","comment_id":157962,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"“返回左值引用的表达式，，如 x++、x + 1 ”不太清楚原因，后来我就试了下：\n\n```\nint x = 0;\ncout &lt;&lt; &quot;(x).addr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;\ncout &lt;&lt; &quot;(x = 1).addr = &quot; &lt;&lt; &amp;(x = 1) &lt;&lt; endl;\ncout &lt;&lt; &quot;(++x).addr = &quot; &lt;&lt; &amp;++x &lt;&lt; endl;\n&#47;&#47;cout &lt;&lt; &quot;(x++).addr = &quot; &lt;&lt; &amp;x++ &lt;&lt; endl;\n```\n\n&gt; 运行结果：  \n(x).addr = 0x22fe4c  \n(x = 1).addr = 0x22fe4c  \n(++x).addr = 0x22fe4c  \n最后一行注释掉的代码报错：表达式必须为左值或函数指示符","like_count":12,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501606,"discussion_content":"右值引用只是一种重载规则。如果 B 和 C 是内部不使用指针的值类型的大对象，那 A、B、C 的移动构造是不会比拷贝构造更高效的。\n\n你去看一下标准容器的拷贝构造和移动构造就知道，移动的高效在于右值标明了这个对象马上就没人用了，允许移动构造函数通过调整指针把内容全部偷走而已。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594948386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2450304,"avatar":"https://static001.geekbang.org/account/avatar/00/25/63/80/c11452db.jpg","nickname":"六饼","note":"","ucode":"CBBED59BAEE415","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579955,"discussion_content":"作为一个C++业余爱好者，这也是困惑我的问题，今天终于弄明白了，感谢老师的解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657784273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157771,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575257290,"is_pvip":false,"replies":[{"id":60517,"content":"1. “通常”。字符串字面量是个继承自C的特殊情况。\n\n2. 这个搜索一下就行。这是CPU的缓存结构决定的。\n\n3. 其他类，尤其容器类，会期待移动构造函数无异常，甚至会在它有异常时选择拷贝构造函数，以保证强异常安全性。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575289113,"ip_address":"","comment_id":157771,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"又是看不懂的一节。。。老师讲的课程太深刻了。。。\n1. 本来感觉自己还比较了解左右值的区别，但是，文中提到：一个 lvalue 是通常可以放在等号左边的表达式，左值，然后下面说：字符串字面量如 &quot;hello world&quot;，但字符串字面量貌似不可以放到等号左边，搞晕了。\n2. 内存访问的局域性是指什么呢？又有何优势呢？老师能提供介绍的链接吗\n3. 为何对于移动构造函数来讲不抛出异常尤其重要呢？\n希望老师能指点一下","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476597,"discussion_content":"对，x = 1 和 ++x 返回的都是对 x 的 int&amp;amp;。x++ 则返回的是 int。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575294765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yjPribEvEjfucxIXMz37icztGulgcuBAEQllOWKypiamntLLxkRIb20L7CQ2MVJxSt2KpyXW4dLpgL9YjbkDe9pAQ/132","nickname":"摸摸鱼","note":"","ucode":"E4851BF6E2FB17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653274,"discussion_content":"试的好 继续试下去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730567152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158343,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575360441,"is_pvip":false,"replies":[{"id":60644,"content":"理解满分。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378121,"ip_address":"","comment_id":158343,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第二题：\n左值和右值都有效是因为构造参数时，如果是左值，就用拷贝构造构造函数，右值就用移动构造函数\n无论是左值还是右值，构造参数时直接生成新的智能指针，因此不需要判断","like_count":54,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476690,"discussion_content":"理解满分。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575378121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736297,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","nickname":"Initiative Thinker","note":"","ucode":"A884396A1581EF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232150,"discussion_content":"不需要判断的关键是Swap吧，前面好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586856953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1736297,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","nickname":"Initiative Thinker","note":"","ucode":"A884396A1581EF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":232995,"discussion_content":"时间太久远了，我刚回看了一下，\nswap主要是规避了 if(&amp;rhs != this)这个判断。\n不需要判断是因为形参是值传递，肯定是需要构造新的对象的，这时候如果实参是左值就用拷贝构造，如果是右值就用移动构造。\n我觉得重点是区分一下左值、右值和左值信用、右值引用的概念。感觉你可能是没理解清楚","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1586882038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":232150,"ip_address":"","group_id":0},"score":232995,"extra":""}]}]},{"had_liked":false,"id":157942,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575287486,"is_pvip":false,"replies":[{"id":60518,"content":"是。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575289268,"ip_address":"","comment_id":157942,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请教下老师，字符串字面量是左值，是不是在C++中 字符串其实是const char[N]，其实是个常量表达式，在内存中有明确的地址。","like_count":26,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476587,"discussion_content":"是。👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575289268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014142,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/7e/c38ac02f.jpg","nickname":"北冥Master","note":"","ucode":"EBCCEC79AFC5DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131457,"discussion_content":"字面量是右值，字面量本身不能被取地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578840463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158228,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575354205,"is_pvip":false,"replies":[{"id":60642,"content":"你在学校的时候，都是让老师来看你的笔记记得好不好的吗？😂\n\n对不起，如果有明确的问题，我可以回答。否则，我只能暂时忽略了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377830,"ip_address":"","comment_id":158228,"utype":1}],"discussion_count":8,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，我这个初学者看的比较慢，目前只看了右值与右值引用，下面是我总结了的学习心得，请您指点下：\n**背景：  \nC++11为了支持移动操作，引用了新的引用类型-右值引用。  \n所谓右值引用就是绑定到右值的引用。  \n为了区分右值引用，引入左值引用概念，即常规引用。  \n那左值与右值是是什么？**  \n\n## 1、左值与右值\n\n**左值 lvalue 是有标识符、可以取地址的表达式**\n* 变量、函数或数据成员的名字  \n* 返回左值引用的表达式，如 ++x、x = 1、cout &lt;&lt; &#39; &#39;\n* 字符串字面量如 &quot;hello world&quot;\n\n表达式是不是左值，就看是否可以取地址，或者返回类型是否可以用（常规）引用来接收：\n\n```\nint x = 0;\ncout &lt;&lt; &quot;(x).addr = &quot; &lt;&lt; &amp;x &lt;&lt; endl; \ncout &lt;&lt; &quot;(x = 1).addr = &quot; &lt;&lt; &amp;(x = 1) &lt;&lt; endl;   &#47;&#47;x赋值1，返回x  \ncout &lt;&lt; &quot;(++x).addr = &quot; &lt;&lt; &amp;++x &lt;&lt; endl;   &#47;&#47;x自增1，返回x\n```\n\n&gt; 运行结果：  \n(x).addr = 0x22fe4c  \n(x = 1).addr = 0x22fe4c  \n(++x).addr = 0x22fe4c  \n\n```\ncout &lt;&lt; &quot;hello world = &quot; &lt;&lt; &amp;(&quot;hello world&quot;) &lt;&lt; endl; \n```\n\n&gt; 运行结果：  \nhello world = 0x40403a  \n\nC++中的字符串字面量，可以称为字符串常量，表示为const char[N]，其实是地址常量表达式。  \n在内存中有明确的地址，不是临时变量。\n\n```\ncout &lt;&lt; &quot;cout &lt;&lt; &#39; &#39; = &quot; &lt;&lt; &amp;(cout &lt;&lt; &#39; &#39;) &lt;&lt; endl;\n```\n&gt; 运行结果：\ncout &lt;&lt; &#39; &#39; =  0x6fd0acc0\n\n**纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般称为“临时对象”**\n* 返回非引用类型的表达式，如 x++、x + 1、make_shared(42)\n* 除字符串字面量之外的字面量，如 42、true\n\n```\n&#47;&#47;cout &lt;&lt; &quot;(x++).addr = &quot; &lt;&lt; &amp;x++ &lt;&lt; endl;  &#47;&#47;返回一个值为x的临时变量，再把x自增1\n&#47;&#47;cout &lt;&lt; &quot;(x + 1).addr = &quot; &lt;&lt; &amp;(x + 1) &lt;&lt; endl;  &#47;&#47;返回一个值为x+1的临时变量 \n&#47;&#47;cout &lt;&lt; &quot;(42).addr = &quot; &lt;&lt; &amp;(42) &lt;&lt; endl;  &#47;&#47;返回一个值为42的临时变量\n&#47;&#47;cout &lt;&lt; &quot;(true).addr = &quot; &lt;&lt; &amp;(true) &lt;&lt; endl;  &#47;&#47;返回一个值为true的临时变量\n```\n&gt; 编译出错：  \n每行代码报错：表达式必须为左值或函数指示符  \n因为以上表达式都返回的是“临时变量”，是不可以取地址的  \n\n---","like_count":25,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476587,"discussion_content":"是。👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575289268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014142,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/7e/c38ac02f.jpg","nickname":"北冥Master","note":"","ucode":"EBCCEC79AFC5DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131457,"discussion_content":"字面量是右值，字面量本身不能被取地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578840463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279800,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1613966503,"is_pvip":false,"replies":[{"id":101697,"content":"对。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614039792,"ip_address":"","comment_id":279800,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我感觉我有点理解完美转发的意思了，对于一个函数，如果形参是右值引用，但在函数体内，这个“右值引用”实际上是一个左值变量，然后函数内再有一个函数传入这个参数，那么就会调用对应的左值引用版本，而完美转发的意义就相当于做一次类型转换，让这个参数保持一开始传入时的左值右值类别。\n不知道理解的对不对？","like_count":24,"discussions":[{"author":{"id":2642536,"avatar":"https://static001.geekbang.org/account/avatar/00/28/52/68/97107e46.jpg","nickname":"杰","note":"","ucode":"CA6C00F8D724B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383282,"discussion_content":"比作者写的好我觉得。。。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626022549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476681,"discussion_content":"你在学校的时候，都是让老师来看你的笔记记得好不好的吗？😂\n\n对不起，如果有明确的问题，我可以回答。否则，我只能暂时忽略了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575377830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2181930,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4b/2a/4602363c.jpg","nickname":"高小高","note":"","ucode":"6F7D31403EE67A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321944,"discussion_content":"写得好，反正我是看懂了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604652323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yjPribEvEjfucxIXMz37icztGulgcuBAEQllOWKypiamntLLxkRIb20L7CQ2MVJxSt2KpyXW4dLpgL9YjbkDe9pAQ/132","nickname":"摸摸鱼","note":"","ucode":"E4851BF6E2FB17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653273,"discussion_content":"这个总结确实简单直接👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730566684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049550,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","nickname":"淡漠落寞","note":"","ucode":"17FF0A02D13098","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651073,"discussion_content":"赞努力可爱的兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726153672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484198,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyP4WVaRJVV3OQ6icPfjicf2JqHjNGw0PhhOMnibicoMzLC3xzibHuibd9s2c3uWa1Y9Gg721L4cO2MUQ/132","nickname":"Geek_46cdcd","note":"","ucode":"F67F8709F63A2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622516,"discussion_content":"哈哈哈，你们这么说，作者的面子往哪儿搁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688373187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2289318,"avatar":"","nickname":"Ada Li","note":"","ucode":"7C6413665B9822","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588574,"discussion_content":"写的很好，学到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663856936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1913231,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgiarK8ic7vY1RuR65ESnibhR5D6ic4rCf6DW9PBS4UCHcEZjibZWwGeicU82EllIic5nBcia0B0x0TcsVdQ/132","nickname":"程辉","note":"","ucode":"E9B49C5DDA84CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571400,"discussion_content":"总结的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652193828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158193,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575344727,"is_pvip":false,"replies":[{"id":60639,"content":"对，最主要就是这点，用完美转发来正确调用构造函数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377361,"ip_address":"","comment_id":158193,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;请查看一下标准函数模板 make_shared 的声明，然后想一想，这个函数应该是怎样实现的。&quot;\n\ntemplate &lt;class T, class... Args&gt;\nstd::shared_ptr&lt;T&gt; make_shared (Args&amp;&amp;... args)\n{\n    T* ptr = new T(std::forward&lt;Args...&gt;(args...));\n    return std::shared_ptr&lt;T&gt;(ptr);\n}\n\n我的考虑是：\nmake_shared声明里的（Args&amp;&amp;...） 是universal reference， 所以在函数体里用完美转发（std::forward）把参数出入T的构造函数, 以调用每个参数各自对用的构造函数（copy or move）。\n\n肯定还有别的需要考量的地方，请指正。\n\n谢谢！","like_count":22,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515875,"discussion_content":"对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614039792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158231,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575354282,"is_pvip":false,"replies":[{"id":60647,"content":"再多说一句，如果每个人都这么让我来看笔记的话，我是不可能满足所有人的。只看你的，也对别人不公。在这儿回答（不重复的）问题则不同，问题一般是有共性的，回答之后，大家都能看到，都能从中受益。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575379266,"ip_address":"","comment_id":158231,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，留言有字数限制，我是接着上个留言来的，上面那个总结了下左值与右值，这个是右值引用的学习心得：\n## 2、右值引用\n**针对以上的所说的“临时变量”，如何来“接收”它呢？**  \n* 最直白的办法，就是直接用一个变量来“接收”  \n以x++为例：\n```\nvoid playVal(int y) {\n    cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, (y).adrr = &quot; &lt;&lt; &amp;y &lt;&lt; endl;\n}\n\nint x = 0;\nplayVal(x++);\ncout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, (x).adrr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;\n```\n\n&gt;运行结果：  \ny = 0, (y).adrr = 0x22fe20  \nx = 1, (x).adrr = 0x22fe4c  \n\n这是一个值传递过程，相当于 int y = x++，即x++生成的临时变量给变量y赋值，之后临时变量就“消失”，这里发生是一次拷贝。\n\n如何避免发生拷贝呢？  \n通常做法是使用引用来“接收”，即引用传递。  \n上面说过，使用一个（常规）引用来“接收”一个临时变量，会报错：\n```\nvoid playVal(int&amp; y)\n```\n&gt; error : 非常量引用的初始值必须为左值\n\n* 普遍的做法都是使用常量引用来“接收”临时变量（C++11之前）\n```\nvoid playVal(const int&amp; y)\n```\n这里编译器做了处理： int tmp = x++; const int&amp; y = tmp;  发生内存分配。\n其实还是发生了拷贝。\n\n* 使用右值引用来“接收”临时变量（C++11之后）  \n上面说过，“临时变量”是一个右值，所以这里可以使用右值引用来“接收”它  \n右值引用的形式是 T&amp;&amp; ：  \n```\nvoid playVal(int&amp;&amp; y) {\n    cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; &quot;, (y).adrr = &quot; &lt;&lt; &amp;y &lt;&lt; endl;\n}\n\nint x = 0;\nplayVal(x++);\ncout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, (x).adrr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;  \n```\n\n&gt; 运行结果：  \ny = 0, (y).adrr = 0x22fe4c  \nx = 1, (x).adrr = 0x22fe48\n\n这是一个（右值）引用传递的过程，相当于 int&amp;&amp; y = x++，这里的右值引用 y 直接“绑定”了“临时变量”，因为它就会有了命名，变成“合法”的，就不会“消失”。  \n**注意：这里的变量 y 虽然是右值引用类型，但它是一个左值，可以正常对它取地址**  \n（如上例所示）","like_count":17,"discussions":[{"author":{"id":3044278,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/73/b6/73f85077.jpg","nickname":"DDRH","note":"","ucode":"047BF2A1D1A27A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591611,"discussion_content":"智能指针的make_shared是一个很好的使用完美转发的模板，可以套用到很多data holder的构造方式中，学习了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1666703575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2353732,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ea/44/cf0b2541.jpg","nickname":"Marc Chan","note":"","ucode":"D365D6793F304B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549018,"discussion_content":"  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;\n      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...);\n    }\n\nstd::forward万能转发，不管传入左值还是右值都会正确的调用对应的构造函数，不会让右值引用产生引用坍缩，导致调用了左值的构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643519408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476663,"discussion_content":"对，最主要就是这点，用完美转发来正确调用构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575377361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198474,"discussion_content":"应该主要还是确保调用T中正确的构造函数吧，Args&amp;&amp;里面不论是左值还是右值应该在传入的时候已经构造完成了。话说这个&amp;&amp;的universal reference的设定这么强大？用这种方法，Args&amp;&amp;里面每一个参数都可以按照它们自己的引用方式forward，就是说，Args里面既可以有lvalue也可以有rvalue，这么理解正确吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583505741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1736297,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI9zRdkKuXMKh30ibeludlAsztmR4rD9iaiclPicOfIhbC4fWxGPz7iceb3o4hKx7qgX2dKwogYvT6VQ0g/132","nickname":"Initiative Thinker","note":"","ucode":"A884396A1581EF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232155,"discussion_content":"没毛病，应该既可以传输左值也可以传输右值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586857221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198474,"ip_address":"","group_id":0},"score":232155,"extra":""}]}]},{"had_liked":false,"id":219747,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590073576,"is_pvip":false,"replies":[{"id":81297,"content":"因为危险。临时对象在当前语句执行完成之后就被析构了。你握着这个已经不存在的对象的指针，想干嘛？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214253,"ip_address":"","comment_id":219747,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，为什么对临时对象不能使用取地址符&amp;，比如&amp;shape(),我知道这会编译报错:不能对右值取地址。我困惑的是:既然有对象，肯定有地址存放嘛，那一定能取地址才对。c++为什么要这样设计？或者说从堆栈的使用机制上看是为啥？","like_count":14,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476684,"discussion_content":"再多说一句，如果每个人都这么让我来看笔记的话，我是不可能满足所有人的。只看你的，也对别人不公。在这儿回答（不重复的）问题则不同，问题一般是有共性的，回答之后，大家都能看到，都能从中受益。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575379266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1890837,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/da/15/207ce035.jpg","nickname":"曌玥希","note":"","ucode":"326CA8B8E4C37F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548413,"discussion_content":"这个笔记写得很好啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643186938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70786,"discussion_content":"好的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575380266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2565411,"avatar":"https://static001.geekbang.org/account/avatar/00/27/25/23/9abd30c0.jpg","nickname":"Carl Wang","note":"","ucode":"C5FE25A658B36B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598967,"discussion_content":"这哥们 有完美转发的笔记么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673242045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1913231,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgiarK8ic7vY1RuR65ESnibhR5D6ic4rCf6DW9PBS4UCHcEZjibZWwGeicU82EllIic5nBcia0B0x0TcsVdQ/132","nickname":"程辉","note":"","ucode":"E9B49C5DDA84CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571401,"discussion_content":"写的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652194062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792714,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","nickname":"Im me","note":"","ucode":"FF7DEED4BB4C37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569870,"discussion_content":"这笔记优秀啊，十分优秀。顺便提一句，谁能跟极客时间提一下支持md呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651582214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235116,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594896766,"is_pvip":false,"replies":[{"id":86850,"content":"右值引用只是一种重载规则。如果 B 和 C 是内部不使用指针的值类型的大对象，那 A、B、C 的移动构造是不会比拷贝构造更高效的。\n\n你去看一下标准容器的拷贝构造和移动构造就知道，移动的高效在于右值标明了这个对象马上就没人用了，允许移动构造函数通过调整指针把内容全部偷走而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594948386,"ip_address":"","comment_id":235116,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，不好意思我又来了……\n您给出了例子：\nclass A { B b_; C c_;}; 其实是长久以来我对移动构造的困惑：如果一个A这样的类，他的成员B, C都是通过值类型定义的，并且嵌套地，B、C成员也都是值类型定义的，一直到最终的原生类型。毫无疑问这样的内存布局是最符合temporal and spatial locality的，但是我非常困惑于如何实现一个A的高效率移动构造。除非“所谓的移动构造是一个triky的语法糖, 他事实上等价于容器的emplace”。","like_count":12,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501606,"discussion_content":"右值引用只是一种重载规则。如果 B 和 C 是内部不使用指针的值类型的大对象，那 A、B、C 的移动构造是不会比拷贝构造更高效的。\n\n你去看一下标准容器的拷贝构造和移动构造就知道，移动的高效在于右值标明了这个对象马上就没人用了，允许移动构造函数通过调整指针把内容全部偷走而已。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594948386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2450304,"avatar":"https://static001.geekbang.org/account/avatar/00/25/63/80/c11452db.jpg","nickname":"六饼","note":"","ucode":"CBBED59BAEE415","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579955,"discussion_content":"作为一个C++业余爱好者，这也是困惑我的问题，今天终于弄明白了，感谢老师的解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657784273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157962,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1575290505,"is_pvip":false,"replies":[{"id":60529,"content":"对，x = 1 和 ++x 返回的都是对 x 的 int&amp;。x++ 则返回的是 int。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575294765,"ip_address":"","comment_id":157962,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"“返回左值引用的表达式，，如 x++、x + 1 ”不太清楚原因，后来我就试了下：\n\n```\nint x = 0;\ncout &lt;&lt; &quot;(x).addr = &quot; &lt;&lt; &amp;x &lt;&lt; endl;\ncout &lt;&lt; &quot;(x = 1).addr = &quot; &lt;&lt; &amp;(x = 1) &lt;&lt; endl;\ncout &lt;&lt; &quot;(++x).addr = &quot; &lt;&lt; &amp;++x &lt;&lt; endl;\n&#47;&#47;cout &lt;&lt; &quot;(x++).addr = &quot; &lt;&lt; &amp;x++ &lt;&lt; endl;\n```\n\n&gt; 运行结果：  \n(x).addr = 0x22fe4c  \n(x = 1).addr = 0x22fe4c  \n(++x).addr = 0x22fe4c  \n最后一行注释掉的代码报错：表达式必须为左值或函数指示符","like_count":12,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476597,"discussion_content":"对，x = 1 和 ++x 返回的都是对 x 的 int&amp;amp;。x++ 则返回的是 int。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575294765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yjPribEvEjfucxIXMz37icztGulgcuBAEQllOWKypiamntLLxkRIb20L7CQ2MVJxSt2KpyXW4dLpgL9YjbkDe9pAQ/132","nickname":"摸摸鱼","note":"","ucode":"E4851BF6E2FB17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653274,"discussion_content":"试的好 继续试下去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730567152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157771,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575257290,"is_pvip":false,"replies":[{"id":60517,"content":"1. “通常”。字符串字面量是个继承自C的特殊情况。\n\n2. 这个搜索一下就行。这是CPU的缓存结构决定的。\n\n3. 其他类，尤其容器类，会期待移动构造函数无异常，甚至会在它有异常时选择拷贝构造函数，以保证强异常安全性。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575289113,"ip_address":"","comment_id":157771,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"又是看不懂的一节。。。老师讲的课程太深刻了。。。\n1. 本来感觉自己还比较了解左右值的区别，但是，文中提到：一个 lvalue 是通常可以放在等号左边的表达式，左值，然后下面说：字符串字面量如 &quot;hello world&quot;，但字符串字面量貌似不可以放到等号左边，搞晕了。\n2. 内存访问的局域性是指什么呢？又有何优势呢？老师能提供介绍的链接吗\n3. 为何对于移动构造函数来讲不抛出异常尤其重要呢？\n希望老师能指点一下","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476526,"discussion_content":"1. “通常”。字符串字面量是个继承自C的特殊情况。\n\n2. 这个搜索一下就行。这是CPU的缓存结构决定的。\n\n3. 其他类，尤其容器类，会期待移动构造函数无异常，甚至会在它有异常时选择拷贝构造函数，以保证强异常安全性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575289113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69344,"discussion_content":"1.  左值lvalue的“字面意思”是能用在赋值运算符左侧的东西，注意，这不是左值的定义。根据https://en.cppreference.com/w/cpp/language/value_category左值的定义have identity and cannot be moved from are called lvalue expressions;\n字符串字面量如 &#34;hello world&#34;是左值，因为，字符串字面量如 &#34;hello world&#34;有地址，也就是有身份（identity)，字符串字面量&#34;hello world&#34;不可移动，所以字符串字面值是左值。\n2. 内存访问的局部性的优势在于可以被用来在处理器内核的指令流水线中进行性能优化，如缓存，内存预读取以及分支预测。请看：https://blog.csdn.net/u013315650/article/details/56347793\n3. 请参见C++ PRIMER 中文版473页：&#34;除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时会抛出异常，并且为了处理这种可能性而一些额外的工作.&#34;","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1575281963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2085640,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d3/08/ffd93029.jpg","nickname":"太阳","note":"","ucode":"24B8E951956789","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397683,"discussion_content":"为啥移动构造会在有异常时会选择拷贝构造函数，以保证强异常安全性？感觉移动构造更不容易有异常的，因为不会进行分配内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632660447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69566,"discussion_content":"嗯嗯，受教了，感谢老师回复！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575293568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69481,"discussion_content":"感谢老兄的解答！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575290054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158152,"user_name":"安静的雨","can_delete":false,"product_type":"c1","uid":1004841,"ip_address":"","ucode":"6371DE858C4D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/29/4fa6e9fb.jpg","comment_is_top":false,"comment_ctime":1575339228,"is_pvip":false,"replies":[{"id":60637,"content":"文中已经说了，禁止返回本地对象的引用。\n\n需要生成一个 Obj，给了一个 Obj&amp;&amp;，不就是调用构造函数而已么。所以（看文中输出），就是多产生了一次Obj(Obj&amp;&amp;) 的调用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575376982,"ip_address":"","comment_id":158152,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"Obj simple_with_move()\n{ \n    Obj obj;  \n    &#47;&#47; move  会禁止  NRVO  \n    return std::move(obj);\n}\n\nmove后不是类型转换到右值引用了吗？ 为啥返回值类型还是obj？","like_count":10},{"had_liked":false,"id":160760,"user_name":"哇咔咔","can_delete":false,"product_type":"c1","uid":1133036,"ip_address":"","ucode":"54BF877836C591","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg","comment_is_top":false,"comment_ctime":1576029722,"is_pvip":false,"replies":[{"id":61353,"content":"因为移动发挥威力了……试试把 std::string(&quot;hello&quot;) 放到 test2 开头作为变量，然后后面使用这个变量。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060387,"ip_address":"","comment_id":160760,"utype":1}],"discussion_count":9,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师你好，这段代码压测下来，发现左值引用没有性能的提升。压测时间对比是：\nelapsed time: 1.2184s\nelapsed time: 1.1857s\n\n请问为什么呢？\n\n#include &lt;string&gt;\n#include &lt;ctime&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n\nvoid func1(std::string s)\n{\n}\n\nvoid func2(const std::string &amp;s)\n{\n}\n\nvoid test2()\n{\n    auto start = std::chrono::system_clock::now();\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func1(std::string(&quot;hello&quot;));\n    }\n    auto end = std::chrono::system_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\n    std::cout &lt;&lt; &quot;elapsed time: &quot; &lt;&lt; elapsed_seconds.count() &lt;&lt; &quot;s\\n&quot;;\n\n    start = std::chrono::system_clock::now();\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func2(std::string(&quot;hello&quot;));\n    }\n    end = std::chrono::system_clock::now();\n    elapsed_seconds = end - start;\n    std::cout &lt;&lt; &quot;elapsed time: &quot; &lt;&lt; elapsed_seconds.count() &lt;&lt; &quot;s\\n&quot;;\n}\n\nint main()\n{\n    test2();\n}","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476643,"discussion_content":"文中已经说了，禁止返回本地对象的引用。\n\n需要生成一个 Obj，给了一个 Obj&amp;amp;&amp;amp;，不就是调用构造函数而已么。所以（看文中输出），就是多产生了一次Obj(Obj&amp;amp;&amp;amp;) 的调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575376982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70493,"discussion_content":"move 将obj强转成右值引用，函数返回时，构造Obj 才会用移动构造函数，否则就是拷贝构造函数了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575362120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1323061,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/35/d9ccd398.jpg","nickname":"陈诚 Mr Chen","note":"","ucode":"6087BA76C92933","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606592,"discussion_content":"迟来的评论，这个 idiom 其实和怎么构造的没有什么关系，它主要讨论了 NRVO 是否可以执行。\nNRVO 可以在调用栈上构建一个对象，然后在被调函数中使用 (虽然从代码上看上去似乎应该是在被调函数中构造的，这个是 NRVO 精髓的地方)。\n文中也说了，如果故意写成 return std::move(xxx)，那么会阻止这种优化，反而需要两次构造，一次是函数里面，一次是函数外面。但 NVRO 只需要一个构造函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677233462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70493,"ip_address":"北京","group_id":0},"score":606592,"extra":""}]},{"author":{"id":1807329,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/93/e1/1d1abb55.jpg","nickname":"这些年🐷","note":"","ucode":"9A09AF3B8E7DCD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129723,"discussion_content":"老师好,如果不加std::move的话有NRVO,是编译器自己进行move,然后如果自己加了std::move的话,就是自己加的这次,再算上编译器自己的move,一共就是2次,我的理解对吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578731413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158798,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1575453644,"is_pvip":false,"replies":[{"id":60752,"content":"中间传的都是引用，没有拷贝或移动发生的。只有用Obj（而不是Obj&amp;或Obj&amp;&amp;）作为参数类型才会发生拷贝或移动构造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575463891,"ip_address":"","comment_id":158798,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我把实例稍微改了下，\nclass Obj \n  {\n    public:\n      Obj()\n      {   \n          std::cout &lt;&lt; &quot;Obj()&quot; &lt;&lt; std::endl;\n      }\n  \n      Obj(const Obj&amp;)\n      {   \n          std::cout &lt;&lt; &quot;Obj(const Obj&amp;)&quot; &lt;&lt; std::endl;\n      }\n  \n      Obj(Obj&amp;&amp;)\n      {   \n          std::cout &lt;&lt; &quot;Obj(Obj&amp;&amp;)&quot; &lt;&lt; std::endl;\n      }   \n  };\n\nvoid foo(const Obj&amp;)\nvoid foo(Obj&amp;&amp;)\nvoid bar(const Obj&amp; s)\nvoid bar(Obj&amp;&amp; s)\n\nint main()\n{\n   bar(Obj());\n}\n\n构造函数内加了打印。\n\n期望看到的结果是这样的\nObj()\nObj(&amp;&amp;)\nbar(Obj&amp;&amp;)\nObj(const&amp;)\nfoo(const Obj&amp;)\n可实际输出如下\nObj()\nbar(&amp;&amp;)\nfoo(const &amp;)\n\n并没有期望中的移动构造和复制构造，这是为什么啊。\n关于没有移动构造，我的理解是Obj()本来已经是个右值了，不必再构造。\n可是想不通为什么没有了复制构造。\n","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477470,"discussion_content":"因为移动发挥威力了……试试把 std::string(&amp;quot;hello&amp;quot;) 放到 test2 开头作为变量，然后后面使用这个变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099170,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","nickname":"Ivan.Qi","note":"","ucode":"36F46A4D1F0EAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626260,"discussion_content":"void test2()\n{\n    std::string a = &#34;hello&#34;;\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func1(std::string(&#34;hello&#34;));\n    }\n\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func2(std::string(&#34;hello&#34;));\n    }\n}\n\n// 改进版本\nvoid test3() {\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func1(a);\n    }\n    \n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func2(a);\n    }\n}\n--------------\n结果为:\n---- test2 测试时间 ----\nelapsed time: 1.8719s\nelapsed time: 1.90104s\n---- test3 测试时间 ----\nelapsed time: 0.424229s\nelapsed time: 0.0873127s\n----\n问题: 在test2 case 中为什么func1比func2快？\n解答: func1(string(&#34;func1&#34;))时，传入的参数是一个右值.同时在函数调用中，临时对象的所有权会被转移给函数的参数s，因此会发生一次移动构造操作。func2(string(&#34;func2&#34;))时，传入的参数也是一个右值，虽然函数参数s是通过常量引用传递的，但临时对象string(&#34;func2&#34;)可以绑定到常量引用，因此不会发生拷贝操作。\n\n问题: 为什么test3整体时间比test2快?\n解答 : 例如func1(a)和func2(a)，传入的参数是一个左值。因为a是一个已命名的变量，它具有持久性，并且可以被多次使用. 原因在于使用已命名的变量作为参数时，可以直接进行拷贝构造，而不需要进行额外的临时对象的创建和销毁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1692694097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1934859,"avatar":"","nickname":"saddamwilson","note":"","ucode":"328AE0F8C31C9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574581,"discussion_content":"std::string(&#34;hello&#34;)是个临时对象也就是右值，所以调用了移动构造","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654160279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311349,"discussion_content":"没懂啊，为什么说移动发挥威力了？移动是怎么发挥威力的。std::string(&#34;hello&#34;)作为变量放到开头后，为啥性能就提升了。求大佬指点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602314384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2054857,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJp4KDwoPkxZFyq0ButALJdrm4eEbkxVdA0PeDLAZ2Kicg7kr7WxAEqkgV8VOLtHybhJ1UNh32Q3Nw/132","nickname":"201201511","note":"","ucode":"1B36FFAF9DD9E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366368,"discussion_content":"为什么说移动发挥威力了？移动是怎么发挥威力的，这个是为啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618043715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311349,"ip_address":"","group_id":0},"score":366368,"extra":""}]},{"author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163237,"discussion_content":"@哇咔咔 你这个按照老师的建议改了测试没有？我测试还是没有明显的变化，即使循环增加了一个数量级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581063803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165808,"discussion_content":"有提升。你是不是写错了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581332595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163237,"ip_address":"","group_id":0},"score":165808,"extra":""},{"author":{"id":1434163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e2/33/9c4ff5db.jpg","nickname":"lc","note":"","ucode":"B5725542C26249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218216,"discussion_content":"有明显提升","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585631395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163237,"ip_address":"","group_id":0},"score":218216,"extra":""},{"author":{"id":1792714,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","nickname":"Im me","note":"","ucode":"FF7DEED4BB4C37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569878,"discussion_content":"先不说盖勒之后提升的事情，想请教下那个没改之前fun1（）是怎么移动的，有点蒙了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651583961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165808,"ip_address":"","group_id":0},"score":569878,"extra":""}]}]},{"had_liked":false,"id":185085,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1583480164,"is_pvip":false,"replies":[{"id":71522,"content":"接近。但不是“可以传地址”，而是：这个值回头马上没人要了，你可以把内容全移走。另外，不管对这个对象做了什么操作，对象还是必须处于可析构的状态。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583502448,"ip_address":"","comment_id":185085,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"一开始我以为左值右值在内存表示上有什么不同，后来才明白内存表示上没有不同。这么做是为了让程序员告诉编译器，我这里可以传地址，不要把内容copy了。","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476851,"discussion_content":"中间传的都是引用，没有拷贝或移动发生的。只有用Obj（而不是Obj&amp;amp;或Obj&amp;amp;&amp;amp;）作为参数类型才会发生拷贝或移动构造。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575463891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283224,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1615627890,"is_pvip":false,"replies":[{"id":102795,"content":"对，很好！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615736065,"ip_address":"","comment_id":283224,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"自我赋值在以下情况下可能会出问题：this内的指针成员变量pb和rhs的pb指向的是同一块堆内存。如果先delete pb；后new Obj(*rhs.pb)，就会把this和rhs指向的同一内存预先释放，那么operator=执行后pb变成了野指针。\n\nswap同时能处理异常安全和自我赋值问题。\nswap达成的效果和如下语句一样：\nResource* pbachup = pb;\npb = new Obj(*rhs.pb);\ndelete pbachup;\n即使new所在语句抛出异常，pb也不会失效；即使this.pb和rhs.pb指向同一内存，由于pb率先指向了另一内存，把this.pb删了了也没事。\n\n而这边之所以可以rhs.swap(*this), 是因为operator=(obj)内参数是以值传递的，以值传递或导致copy一份临时对象，而这个临时对象和上面代码pbachup是一个道理。","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516966,"discussion_content":"对，很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615736065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344410,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1651535450,"is_pvip":false,"replies":[{"id":125734,"content":"++x 返回的是 x 的引用，指向一个稳定的内存地址（x）。x++ 返回 x 之前的值，是一个临时量，执行完当前语句这个值就会消失。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651589568,"ip_address":"","comment_id":344410,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么&quot;++x&quot;是一个可以取地址的表达式，而&quot;x++&quot;不是？前者+1后返回x，后者返回值？想了下两者不管语法和汇编层面都没差。","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569908,"discussion_content":"++x 返回的是 x 的引用，指向一个稳定的内存地址（x）。x++ 返回 x 之前的值，是一个临时量，执行完当前语句这个值就会消失。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651589568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344068,"user_name":"小鱼仙倌","can_delete":false,"product_type":"c1","uid":2701229,"ip_address":"","ucode":"64E4E5A29FBE6C","user_header":"https://static001.geekbang.org/account/avatar/00/29/37/ad/42ef4c8f.jpg","comment_is_top":false,"comment_ctime":1651220725,"is_pvip":false,"replies":[{"id":125680,"content":"仔细理解这一讲，自然就能回答了。有特别问题的话，可以留言。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651411831,"ip_address":"","comment_id":344068,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"好亏呀，今天面试就问了我这个移动，所以我应该怎么给面试官介绍这个移动：从那些方面去聊，聊什么，为什么要有这个移动","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569347,"discussion_content":"仔细理解这一讲，自然就能回答了。有特别问题的话，可以留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651411831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132569,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/19/14dd81d9.jpg","nickname":"铲铲队","note":"","ucode":"D16372C34B7AE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602943,"discussion_content":"就是为了减少拷贝","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1675848052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314156,"user_name":"太阳","can_delete":false,"product_type":"c1","uid":2085640,"ip_address":"","ucode":"24B8E951956789","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d3/08/ffd93029.jpg","comment_is_top":false,"comment_ctime":1632880791,"is_pvip":false,"replies":[{"id":113881,"content":"不太准确。编译器做的事情只是区分左值和右值而已。到底怎么减少复制，那就是看移动构造函数怎么写了。主要的优化点就是知道右值占用的堆上空间可以被取走，写移动构造函数和类似函数的人只需要保证被移动的对象处于一个可析构的状态即可。\n\n拿 string 的 operator+ 为例。如果参数是 const string&amp;，实现者需要产生一个全新的 string，分配新内存，把两个参数的内容复制到新的 string 里。如果第一个参数是 string&amp;&amp; 就不同了，结果就可以直接放在这个参数的缓冲区里。当然，你得保证第一个参数的变量释放它对缓冲区的拥有权。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633146099,"ip_address":"","comment_id":314156,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"右值引用实际上也在栈中分配了内存去保存右值，比如字符串拼接的那个例子，即使调用的移动构造，也是在栈中分配了内存，并进行了拷贝，编译器对右值引用的处理实际上只是减少了一部分构造函数和析构函数的插入。老师，这样理解对吗？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527590,"discussion_content":"不太准确。编译器做的事情只是区分左值和右值而已。到底怎么减少复制，那就是看移动构造函数怎么写了。主要的优化点就是知道右值占用的堆上空间可以被取走，写移动构造函数和类似函数的人只需要保证被移动的对象处于一个可析构的状态即可。\n\n拿 string 的 operator+ 为例。如果参数是 const string&amp;amp;，实现者需要产生一个全新的 string，分配新内存，把两个参数的内容复制到新的 string 里。如果第一个参数是 string&amp;amp;&amp;amp; 就不同了，结果就可以直接放在这个参数的缓冲区里。当然，你得保证第一个参数的变量释放它对缓冲区的拥有权。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1633146099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400076,"discussion_content":"再补充一句，我上面的说法假设 string 的 operator+ 是用非成员函数形式实现的，即：\n\nstring operator+(const string&amp; lhs, const string&amp; rhs);\nstring operator+(string&amp;&amp; lhs, const string&amp; rhs);\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633158013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273445,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1610597079,"is_pvip":false,"replies":[{"id":99101,"content":"一对一也可以用指针，比如你可能中间需要替换成另外一个值，而另外一个值在另外一个地方已经构造出来了，等等。当然，现在推荐用智能指针而不是裸指针了。\n\n如果多个对象使用另外一个对象，那取决于使用的方式，可以选择裸指针、智能指针和引用中的一种。裸指针和引用适用于当前对象不管理那个对象的生命周期的情况。如果可能改变指向的对象或可能为空，那需要使用指针；反之，如果这个对象的存在过程中，永远指向另外一个对象，不会变化也不可能为空，那用引用更好。如果多个对象中有一个对象管理另一个对象的生命周期，那建议使用unique_ptr；如果多个对象共同管理另一个对象的生命周期，在最后一个消失后再销毁那另一个对象，则应使用shared_ptr。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610624456,"ip_address":"","comment_id":273445,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，我想请教一个问题，类中的成员用值还是指针是不是主要看两个类之间的关系，如果是一对一，那就直接用值，如果是一对多，那就只能用指针？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513607,"discussion_content":"一对一也可以用指针，比如你可能中间需要替换成另外一个值，而另外一个值在另外一个地方已经构造出来了，等等。当然，现在推荐用智能指针而不是裸指针了。\n\n如果多个对象使用另外一个对象，那取决于使用的方式，可以选择裸指针、智能指针和引用中的一种。裸指针和引用适用于当前对象不管理那个对象的生命周期的情况。如果可能改变指向的对象或可能为空，那需要使用指针；反之，如果这个对象的存在过程中，永远指向另外一个对象，不会变化也不可能为空，那用引用更好。如果多个对象中有一个对象管理另一个对象的生命周期，那建议使用unique_ptr；如果多个对象共同管理另一个对象的生命周期，在最后一个消失后再销毁那另一个对象，则应使用shared_ptr。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610624456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6e/7d/0485232b.jpg","nickname":"瓜农","note":"","ucode":"CF6B8E5B74BCA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574385,"discussion_content":"这个其实可以看成最佳实践了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654014752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190443,"user_name":"尹登丽","can_delete":false,"product_type":"c1","uid":1908534,"ip_address":"","ucode":"3A113C9E402181","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOYEWpAkrAIwBibQXMLDzOyeELFpRFRibwQg5bITHyztsvBuyicDg6TniaeGic1ocwX0DOb8HKicyxZwnw/132","comment_is_top":false,"comment_ctime":1584661961,"is_pvip":false,"replies":[{"id":73280,"content":"1. 左值（lvalue）不包含xvalue；glvalue才包含xvalue。\n\n2. 当你打算用一个左值去调用某个需要右值引用的函数，并且函数返回后你不会再去使用左值原本包含的内容（因为可能已经被移走了），就使用std::move。使用move是一种优化。比如对于smart_ptr，用move传递给其他函数，可能可以省去一次不必要的add_count和一次不必要的reduce_count。\n\n我没有只是说了一些std::move可能被误用的地方。它本身没什么不好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584680380,"ip_address":"","comment_id":190443,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师  两个问题请教下\n1. 左值也包含xvalue，这个没理解到\n2. std::move如何使用呀，因为感觉讲了好多是std::move不好的地方，所以有点懵","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487979,"discussion_content":"1. 左值（lvalue）不包含xvalue；glvalue才包含xvalue。\n\n2. 当你打算用一个左值去调用某个需要右值引用的函数，并且函数返回后你不会再去使用左值原本包含的内容（因为可能已经被移走了），就使用std::move。使用move是一种优化。比如对于smart_ptr，用move传递给其他函数，可能可以省去一次不必要的add_count和一次不必要的reduce_count。\n\n我没有只是说了一些std::move可能被误用的地方。它本身没什么不好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584680380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158152,"user_name":"安静的雨","can_delete":false,"product_type":"c1","uid":1004841,"ip_address":"","ucode":"6371DE858C4D3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/29/4fa6e9fb.jpg","comment_is_top":false,"comment_ctime":1575339228,"is_pvip":false,"replies":[{"id":60637,"content":"文中已经说了，禁止返回本地对象的引用。\n\n需要生成一个 Obj，给了一个 Obj&amp;&amp;，不就是调用构造函数而已么。所以（看文中输出），就是多产生了一次Obj(Obj&amp;&amp;) 的调用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575376982,"ip_address":"","comment_id":158152,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"Obj simple_with_move()\n{ \n    Obj obj;  \n    &#47;&#47; move  会禁止  NRVO  \n    return std::move(obj);\n}\n\nmove后不是类型转换到右值引用了吗？ 为啥返回值类型还是obj？","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476643,"discussion_content":"文中已经说了，禁止返回本地对象的引用。\n\n需要生成一个 Obj，给了一个 Obj&amp;amp;&amp;amp;，不就是调用构造函数而已么。所以（看文中输出），就是多产生了一次Obj(Obj&amp;amp;&amp;amp;) 的调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575376982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70493,"discussion_content":"move 将obj强转成右值引用，函数返回时，构造Obj 才会用移动构造函数，否则就是拷贝构造函数了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575362120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1323061,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/35/d9ccd398.jpg","nickname":"陈诚 Mr Chen","note":"","ucode":"6087BA76C92933","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606592,"discussion_content":"迟来的评论，这个 idiom 其实和怎么构造的没有什么关系，它主要讨论了 NRVO 是否可以执行。\nNRVO 可以在调用栈上构建一个对象，然后在被调函数中使用 (虽然从代码上看上去似乎应该是在被调函数中构造的，这个是 NRVO 精髓的地方)。\n文中也说了，如果故意写成 return std::move(xxx)，那么会阻止这种优化，反而需要两次构造，一次是函数里面，一次是函数外面。但 NVRO 只需要一个构造函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677233462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70493,"ip_address":"北京","group_id":0},"score":606592,"extra":""}]},{"author":{"id":1807329,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/93/e1/1d1abb55.jpg","nickname":"这些年🐷","note":"","ucode":"9A09AF3B8E7DCD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129723,"discussion_content":"老师好,如果不加std::move的话有NRVO,是编译器自己进行move,然后如果自己加了std::move的话,就是自己加的这次,再算上编译器自己的move,一共就是2次,我的理解对吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578731413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160760,"user_name":"哇咔咔","can_delete":false,"product_type":"c1","uid":1133036,"ip_address":"","ucode":"54BF877836C591","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg","comment_is_top":false,"comment_ctime":1576029722,"is_pvip":false,"replies":[{"id":61353,"content":"因为移动发挥威力了……试试把 std::string(&quot;hello&quot;) 放到 test2 开头作为变量，然后后面使用这个变量。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060387,"ip_address":"","comment_id":160760,"utype":1}],"discussion_count":9,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师你好，这段代码压测下来，发现左值引用没有性能的提升。压测时间对比是：\nelapsed time: 1.2184s\nelapsed time: 1.1857s\n\n请问为什么呢？\n\n#include &lt;string&gt;\n#include &lt;ctime&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n\nvoid func1(std::string s)\n{\n}\n\nvoid func2(const std::string &amp;s)\n{\n}\n\nvoid test2()\n{\n    auto start = std::chrono::system_clock::now();\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func1(std::string(&quot;hello&quot;));\n    }\n    auto end = std::chrono::system_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\n    std::cout &lt;&lt; &quot;elapsed time: &quot; &lt;&lt; elapsed_seconds.count() &lt;&lt; &quot;s\\n&quot;;\n\n    start = std::chrono::system_clock::now();\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func2(std::string(&quot;hello&quot;));\n    }\n    end = std::chrono::system_clock::now();\n    elapsed_seconds = end - start;\n    std::cout &lt;&lt; &quot;elapsed time: &quot; &lt;&lt; elapsed_seconds.count() &lt;&lt; &quot;s\\n&quot;;\n}\n\nint main()\n{\n    test2();\n}","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477470,"discussion_content":"因为移动发挥威力了……试试把 std::string(&amp;quot;hello&amp;quot;) 放到 test2 开头作为变量，然后后面使用这个变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099170,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","nickname":"Ivan.Qi","note":"","ucode":"36F46A4D1F0EAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626260,"discussion_content":"void test2()\n{\n    std::string a = &#34;hello&#34;;\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func1(std::string(&#34;hello&#34;));\n    }\n\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func2(std::string(&#34;hello&#34;));\n    }\n}\n\n// 改进版本\nvoid test3() {\n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func1(a);\n    }\n    \n    for (size_t i = 0; i &lt; 20000000; i++)\n    {\n        func2(a);\n    }\n}\n--------------\n结果为:\n---- test2 测试时间 ----\nelapsed time: 1.8719s\nelapsed time: 1.90104s\n---- test3 测试时间 ----\nelapsed time: 0.424229s\nelapsed time: 0.0873127s\n----\n问题: 在test2 case 中为什么func1比func2快？\n解答: func1(string(&#34;func1&#34;))时，传入的参数是一个右值.同时在函数调用中，临时对象的所有权会被转移给函数的参数s，因此会发生一次移动构造操作。func2(string(&#34;func2&#34;))时，传入的参数也是一个右值，虽然函数参数s是通过常量引用传递的，但临时对象string(&#34;func2&#34;)可以绑定到常量引用，因此不会发生拷贝操作。\n\n问题: 为什么test3整体时间比test2快?\n解答 : 例如func1(a)和func2(a)，传入的参数是一个左值。因为a是一个已命名的变量，它具有持久性，并且可以被多次使用. 原因在于使用已命名的变量作为参数时，可以直接进行拷贝构造，而不需要进行额外的临时对象的创建和销毁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1692694097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1934859,"avatar":"","nickname":"saddamwilson","note":"","ucode":"328AE0F8C31C9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574581,"discussion_content":"std::string(&#34;hello&#34;)是个临时对象也就是右值，所以调用了移动构造","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654160279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311349,"discussion_content":"没懂啊，为什么说移动发挥威力了？移动是怎么发挥威力的。std::string(&#34;hello&#34;)作为变量放到开头后，为啥性能就提升了。求大佬指点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602314384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2054857,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJp4KDwoPkxZFyq0ButALJdrm4eEbkxVdA0PeDLAZ2Kicg7kr7WxAEqkgV8VOLtHybhJ1UNh32Q3Nw/132","nickname":"201201511","note":"","ucode":"1B36FFAF9DD9E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366368,"discussion_content":"为什么说移动发挥威力了？移动是怎么发挥威力的，这个是为啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618043715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311349,"ip_address":"","group_id":0},"score":366368,"extra":""}]},{"author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163237,"discussion_content":"@哇咔咔 你这个按照老师的建议改了测试没有？我测试还是没有明显的变化，即使循环增加了一个数量级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581063803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165808,"discussion_content":"有提升。你是不是写错了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581332595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163237,"ip_address":"","group_id":0},"score":165808,"extra":""},{"author":{"id":1434163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e2/33/9c4ff5db.jpg","nickname":"lc","note":"","ucode":"B5725542C26249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218216,"discussion_content":"有明显提升","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585631395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163237,"ip_address":"","group_id":0},"score":218216,"extra":""},{"author":{"id":1792714,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","nickname":"Im me","note":"","ucode":"FF7DEED4BB4C37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133036,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ec/7f25f6a6.jpg","nickname":"哇咔咔","note":"","ucode":"54BF877836C591","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569878,"discussion_content":"先不说盖勒之后提升的事情，想请教下那个没改之前fun1（）是怎么移动的，有点蒙了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651583961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165808,"ip_address":"","group_id":0},"score":569878,"extra":""}]}]},{"had_liked":false,"id":158798,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1575453644,"is_pvip":false,"replies":[{"id":60752,"content":"中间传的都是引用，没有拷贝或移动发生的。只有用Obj（而不是Obj&amp;或Obj&amp;&amp;）作为参数类型才会发生拷贝或移动构造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575463891,"ip_address":"","comment_id":158798,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我把实例稍微改了下，\nclass Obj \n  {\n    public:\n      Obj()\n      {   \n          std::cout &lt;&lt; &quot;Obj()&quot; &lt;&lt; std::endl;\n      }\n  \n      Obj(const Obj&amp;)\n      {   \n          std::cout &lt;&lt; &quot;Obj(const Obj&amp;)&quot; &lt;&lt; std::endl;\n      }\n  \n      Obj(Obj&amp;&amp;)\n      {   \n          std::cout &lt;&lt; &quot;Obj(Obj&amp;&amp;)&quot; &lt;&lt; std::endl;\n      }   \n  };\n\nvoid foo(const Obj&amp;)\nvoid foo(Obj&amp;&amp;)\nvoid bar(const Obj&amp; s)\nvoid bar(Obj&amp;&amp; s)\n\nint main()\n{\n   bar(Obj());\n}\n\n构造函数内加了打印。\n\n期望看到的结果是这样的\nObj()\nObj(&amp;&amp;)\nbar(Obj&amp;&amp;)\nObj(const&amp;)\nfoo(const Obj&amp;)\n可实际输出如下\nObj()\nbar(&amp;&amp;)\nfoo(const &amp;)\n\n并没有期望中的移动构造和复制构造，这是为什么啊。\n关于没有移动构造，我的理解是Obj()本来已经是个右值了，不必再构造。\n可是想不通为什么没有了复制构造。\n","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476851,"discussion_content":"中间传的都是引用，没有拷贝或移动发生的。只有用Obj（而不是Obj&amp;amp;或Obj&amp;amp;&amp;amp;）作为参数类型才会发生拷贝或移动构造。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575463891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185085,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1583480164,"is_pvip":false,"replies":[{"id":71522,"content":"接近。但不是“可以传地址”，而是：这个值回头马上没人要了，你可以把内容全移走。另外，不管对这个对象做了什么操作，对象还是必须处于可析构的状态。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583502448,"ip_address":"","comment_id":185085,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"一开始我以为左值右值在内存表示上有什么不同，后来才明白内存表示上没有不同。这么做是为了让程序员告诉编译器，我这里可以传地址，不要把内容copy了。","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486245,"discussion_content":"接近。但不是“可以传地址”，而是：这个值回头马上没人要了，你可以把内容全移走。另外，不管对这个对象做了什么操作，对象还是必须处于可析构的状态。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583502448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283224,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1615627890,"is_pvip":false,"replies":[{"id":102795,"content":"对，很好！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615736065,"ip_address":"","comment_id":283224,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"自我赋值在以下情况下可能会出问题：this内的指针成员变量pb和rhs的pb指向的是同一块堆内存。如果先delete pb；后new Obj(*rhs.pb)，就会把this和rhs指向的同一内存预先释放，那么operator=执行后pb变成了野指针。\n\nswap同时能处理异常安全和自我赋值问题。\nswap达成的效果和如下语句一样：\nResource* pbachup = pb;\npb = new Obj(*rhs.pb);\ndelete pbachup;\n即使new所在语句抛出异常，pb也不会失效；即使this.pb和rhs.pb指向同一内存，由于pb率先指向了另一内存，把this.pb删了了也没事。\n\n而这边之所以可以rhs.swap(*this), 是因为operator=(obj)内参数是以值传递的，以值传递或导致copy一份临时对象，而这个临时对象和上面代码pbachup是一个道理。","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486245,"discussion_content":"接近。但不是“可以传地址”，而是：这个值回头马上没人要了，你可以把内容全移走。另外，不管对这个对象做了什么操作，对象还是必须处于可析构的状态。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583502448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344410,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1651535450,"is_pvip":false,"replies":[{"id":125734,"content":"++x 返回的是 x 的引用，指向一个稳定的内存地址（x）。x++ 返回 x 之前的值，是一个临时量，执行完当前语句这个值就会消失。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651589568,"ip_address":"","comment_id":344410,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么&quot;++x&quot;是一个可以取地址的表达式，而&quot;x++&quot;不是？前者+1后返回x，后者返回值？想了下两者不管语法和汇编层面都没差。","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516966,"discussion_content":"对，很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615736065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344068,"user_name":"小鱼仙倌","can_delete":false,"product_type":"c1","uid":2701229,"ip_address":"","ucode":"64E4E5A29FBE6C","user_header":"https://static001.geekbang.org/account/avatar/00/29/37/ad/42ef4c8f.jpg","comment_is_top":false,"comment_ctime":1651220725,"is_pvip":false,"replies":[{"id":125680,"content":"仔细理解这一讲，自然就能回答了。有特别问题的话，可以留言。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651411831,"ip_address":"","comment_id":344068,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"好亏呀，今天面试就问了我这个移动，所以我应该怎么给面试官介绍这个移动：从那些方面去聊，聊什么，为什么要有这个移动","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569908,"discussion_content":"++x 返回的是 x 的引用，指向一个稳定的内存地址（x）。x++ 返回 x 之前的值，是一个临时量，执行完当前语句这个值就会消失。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651589568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314156,"user_name":"太阳","can_delete":false,"product_type":"c1","uid":2085640,"ip_address":"","ucode":"24B8E951956789","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d3/08/ffd93029.jpg","comment_is_top":false,"comment_ctime":1632880791,"is_pvip":false,"replies":[{"id":113881,"content":"不太准确。编译器做的事情只是区分左值和右值而已。到底怎么减少复制，那就是看移动构造函数怎么写了。主要的优化点就是知道右值占用的堆上空间可以被取走，写移动构造函数和类似函数的人只需要保证被移动的对象处于一个可析构的状态即可。\n\n拿 string 的 operator+ 为例。如果参数是 const string&amp;，实现者需要产生一个全新的 string，分配新内存，把两个参数的内容复制到新的 string 里。如果第一个参数是 string&amp;&amp; 就不同了，结果就可以直接放在这个参数的缓冲区里。当然，你得保证第一个参数的变量释放它对缓冲区的拥有权。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633146099,"ip_address":"","comment_id":314156,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"右值引用实际上也在栈中分配了内存去保存右值，比如字符串拼接的那个例子，即使调用的移动构造，也是在栈中分配了内存，并进行了拷贝，编译器对右值引用的处理实际上只是减少了一部分构造函数和析构函数的插入。老师，这样理解对吗？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569347,"discussion_content":"仔细理解这一讲，自然就能回答了。有特别问题的话，可以留言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651411831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132569,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/19/14dd81d9.jpg","nickname":"铲铲队","note":"","ucode":"D16372C34B7AE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602943,"discussion_content":"就是为了减少拷贝","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1675848052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273445,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1610597079,"is_pvip":false,"replies":[{"id":99101,"content":"一对一也可以用指针，比如你可能中间需要替换成另外一个值，而另外一个值在另外一个地方已经构造出来了，等等。当然，现在推荐用智能指针而不是裸指针了。\n\n如果多个对象使用另外一个对象，那取决于使用的方式，可以选择裸指针、智能指针和引用中的一种。裸指针和引用适用于当前对象不管理那个对象的生命周期的情况。如果可能改变指向的对象或可能为空，那需要使用指针；反之，如果这个对象的存在过程中，永远指向另外一个对象，不会变化也不可能为空，那用引用更好。如果多个对象中有一个对象管理另一个对象的生命周期，那建议使用unique_ptr；如果多个对象共同管理另一个对象的生命周期，在最后一个消失后再销毁那另一个对象，则应使用shared_ptr。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610624456,"ip_address":"","comment_id":273445,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，我想请教一个问题，类中的成员用值还是指针是不是主要看两个类之间的关系，如果是一对一，那就直接用值，如果是一对多，那就只能用指针？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527590,"discussion_content":"不太准确。编译器做的事情只是区分左值和右值而已。到底怎么减少复制，那就是看移动构造函数怎么写了。主要的优化点就是知道右值占用的堆上空间可以被取走，写移动构造函数和类似函数的人只需要保证被移动的对象处于一个可析构的状态即可。\n\n拿 string 的 operator+ 为例。如果参数是 const string&amp;amp;，实现者需要产生一个全新的 string，分配新内存，把两个参数的内容复制到新的 string 里。如果第一个参数是 string&amp;amp;&amp;amp; 就不同了，结果就可以直接放在这个参数的缓冲区里。当然，你得保证第一个参数的变量释放它对缓冲区的拥有权。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1633146099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400076,"discussion_content":"再补充一句，我上面的说法假设 string 的 operator+ 是用非成员函数形式实现的，即：\n\nstring operator+(const string&amp; lhs, const string&amp; rhs);\nstring operator+(string&amp;&amp; lhs, const string&amp; rhs);\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633158013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190443,"user_name":"尹登丽","can_delete":false,"product_type":"c1","uid":1908534,"ip_address":"","ucode":"3A113C9E402181","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOYEWpAkrAIwBibQXMLDzOyeELFpRFRibwQg5bITHyztsvBuyicDg6TniaeGic1ocwX0DOb8HKicyxZwnw/132","comment_is_top":false,"comment_ctime":1584661961,"is_pvip":false,"replies":[{"id":73280,"content":"1. 左值（lvalue）不包含xvalue；glvalue才包含xvalue。\n\n2. 当你打算用一个左值去调用某个需要右值引用的函数，并且函数返回后你不会再去使用左值原本包含的内容（因为可能已经被移走了），就使用std::move。使用move是一种优化。比如对于smart_ptr，用move传递给其他函数，可能可以省去一次不必要的add_count和一次不必要的reduce_count。\n\n我没有只是说了一些std::move可能被误用的地方。它本身没什么不好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584680380,"ip_address":"","comment_id":190443,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师  两个问题请教下\n1. 左值也包含xvalue，这个没理解到\n2. std::move如何使用呀，因为感觉讲了好多是std::move不好的地方，所以有点懵","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513607,"discussion_content":"一对一也可以用指针，比如你可能中间需要替换成另外一个值，而另外一个值在另外一个地方已经构造出来了，等等。当然，现在推荐用智能指针而不是裸指针了。\n\n如果多个对象使用另外一个对象，那取决于使用的方式，可以选择裸指针、智能指针和引用中的一种。裸指针和引用适用于当前对象不管理那个对象的生命周期的情况。如果可能改变指向的对象或可能为空，那需要使用指针；反之，如果这个对象的存在过程中，永远指向另外一个对象，不会变化也不可能为空，那用引用更好。如果多个对象中有一个对象管理另一个对象的生命周期，那建议使用unique_ptr；如果多个对象共同管理另一个对象的生命周期，在最后一个消失后再销毁那另一个对象，则应使用shared_ptr。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610624456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6e/7d/0485232b.jpg","nickname":"瓜农","note":"","ucode":"CF6B8E5B74BCA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574385,"discussion_content":"这个其实可以看成最佳实践了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654014752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185190,"user_name":"Fiery","can_delete":false,"product_type":"c1","uid":1897610,"ip_address":"","ucode":"CDB000687A6B14","user_header":"","comment_is_top":false,"comment_ctime":1583509602,"is_pvip":false,"replies":[{"id":71538,"content":"大部分可以了。还有几个问题：\n\n1. 作为静态类型语言，process_shape 返回的结果能不能作为右值处理，是编译时检查的。比如，如果 process_shape 返回一个 shape&amp; 的话，编译就会出错。\n\n2. 把 r 传递给其他函数时，C++ 标准定义的行为略反直觉：只会匹配接受左值引用的函数，不会匹配接受右值引用的函数。要把它作为右值引用传递给另外一个函数，要使用 std::move。\n\n3. 不管哪种情况，r 变量都仍然是有效的。它指向的 shape 对象里的内容可能会被移走（取决于调用的函数的行为），但这个对象仍然应该是一个合法的对象。这个对象统一会在 r 超出作用域时被销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583541724,"ip_address":"","comment_id":185190,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"想确证一下以下的理解，在下面这个赋值并延长prvalue的生命期后：\nresult&amp;&amp; r = process_shape(\n  circle(), triangle());\nr这个变量在当前作用域应该就是一个普通的lvalue，而和它的“右值引用”类型没有关系。这个rvalue reference发挥作用的时刻在于这个r变量作为参数传入其它函数中时，函数要不然接受const result&amp;或者result&amp;&amp;。不过因为是rvalue reference，在传递给其它函数时，我们最好是明确到底是作为左值常引用还是右值引用传递了，如果是按照右值引用传递，那么我们应该默认r变量在函数返回时已经移动而无效，如果是左值常引用，那么r变量在函数返回后依然可以像刚声明后一样使用。不知道理解是否正确？而且想确认一下，确认到底是右值引用还是左值常引用这个是程序员要做的，编译期和runtime都没有保证r变量在函数返回后还是否有效的工具或约定，对吗？","like_count":3},{"had_liked":false,"id":338639,"user_name":"Geek_7bed70","can_delete":false,"product_type":"c1","uid":2463101,"ip_address":"","ucode":"6014E8B2348457","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIL1K9WKIkvsdicFYrgiaUYLucECQMpZyEhl6L6LE5324BlDCEhJmyticcHwN8c37icQOC7q78VoKFdNQ/132","comment_is_top":false,"comment_ctime":1647614177,"is_pvip":false,"replies":[{"id":123894,"content":"不是。返回一个值时，这个结果要么是被移动出来（除非没法使用移动），要么索性可以应用返回值优化，把目标对象构造在调用者的栈帧上。从生命周期的角度，我们从来不认为临时对象是在被调用函数的栈帧上。如果没有生命周期延长的话，这个对象也是在当前执行栈上生成而又立即消亡而已。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1647850141,"ip_address":"","comment_id":338639,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"有个问题想问老师，临时对象在函数中返回，返回值用右值引用来接受会延长临时对象的生命周期，但是临时对象实在函数的栈帧中构造的，返回的时候里面的对象应该都会析构才对，这时候不是只能拷贝一份副本出来吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486283,"discussion_content":"大部分可以了。还有几个问题：\n\n1. 作为静态类型语言，process_shape 返回的结果能不能作为右值处理，是编译时检查的。比如，如果 process_shape 返回一个 shape&amp;amp; 的话，编译就会出错。\n\n2. 把 r 传递给其他函数时，C++ 标准定义的行为略反直觉：只会匹配接受左值引用的函数，不会匹配接受右值引用的函数。要把它作为右值引用传递给另外一个函数，要使用 std::move。\n\n3. 不管哪种情况，r 变量都仍然是有效的。它指向的 shape 对象里的内容可能会被移走（取决于调用的函数的行为），但这个对象仍然应该是一个合法的对象。这个对象统一会在 r 超出作用域时被销毁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583541724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211259,"discussion_content":"关于第二点，真的是百思不得解。。试了一下确实如此，难道是在设计上强制使用move这样就不会产生“需要明确到底是作为左值常引用还是右值引用传递”这样的情况了，因为默认还是按lvalue ref传递过去了，那么还有任何必要用result&amp;&amp;接收函数返回值吗？感觉干脆就直接按value接收好了，反正返回的时候也会优化成移动语义的，请问在实际使用中是不是应该依照“不要使用rvalue ref接收prvalue，而使用lvalue或者lvalue ref”这个准则呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584833851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327940,"user_name":"少年","can_delete":false,"product_type":"c1","uid":2714125,"ip_address":"","ucode":"0403897F55879C","user_header":"https://static001.geekbang.org/account/avatar/00/29/6a/0d/38607302.jpg","comment_is_top":false,"comment_ctime":1640409073,"is_pvip":false,"replies":[{"id":119438,"content":"为了保持和老代码的兼容，右值会优先绑定到右值引用，但也可以绑定到常左值引用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1640501024,"ip_address":"","comment_id":327940,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师你好，关于process_shape函数的调用：\n\nresult process_shape(const shape&amp; shape1, const shape&amp; shape2)\n{\n  puts(&quot;process_shape()&quot;);\n  return result();\n}\n\nint main()\n{   process_shape(circle(), triangle());  }\n\n我想问的是，为什么实参是右值，但是能调用形参是左值的process_shape函数？\n我试了一下，如果添加一个形参是右值的重载函数，会优先调用新写的函数，为什么？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557522,"discussion_content":"不是。返回一个值时，这个结果要么是被移动出来（除非没法使用移动），要么索性可以应用返回值优化，把目标对象构造在调用者的栈帧上。从生命周期的角度，我们从来不认为临时对象是在被调用函数的栈帧上。如果没有生命周期延长的话，这个对象也是在当前执行栈上生成而又立即消亡而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647850141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158258,"user_name":"不谈","can_delete":false,"product_type":"c1","uid":1156936,"ip_address":"","ucode":"2E18977EAC5E5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","comment_is_top":false,"comment_ctime":1575358377,"is_pvip":false,"replies":[{"id":60643,"content":"不是。Java里没有右值，也不必要有右值。因为Java里的对象都是引用语义，从来不是值语义。再仔细看一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378007,"ip_address":"","comment_id":158258,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"感觉左值和右值有点像Java里的值传递和引用传递，但又不完全像，还要再看几遍，好好理解理解","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541648,"discussion_content":"为了保持和老代码的兼容，右值会优先绑定到右值引用，但也可以绑定到常左值引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640501024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157842,"user_name":"嵇斌","can_delete":false,"product_type":"c1","uid":1047812,"ip_address":"","ucode":"C9422C3F8A7B23","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/04/89cc31ab.jpg","comment_is_top":false,"comment_ctime":1575269038,"is_pvip":false,"replies":[{"id":60520,"content":"第二个问题的回答基本正确。不过值类型应当是值类别。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575290444,"ip_address":"","comment_id":157842,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"std::move和右值引用是当时初学C++11比较难理解的一个东西。这篇能结合rvo和std::move一起讲解，相信对大家来讲也是收益匪浅的。记得以前就对小对象，以及工厂方法返回的时候究竟该用std::move还是直接返回有过一小段的讨论。\n\n第一个问题，我很无耻地去看了标准库的实现了……\n关于第二个问题：为什么 smart_ptr::operator= 对左值和右值都有效，而且不需要对等号两边是否引用同一对象进行判断？\n个人理解无论左值和右值在使用 operator=(smart_prt rhs)之前都做了隐式的转换，调用了Copy Constructor 或则 Move Constructor 得到了一个临时的 smart_prt rhs（值类型），至于是否同一对象的判断并没有关系，对于smart_ptr来说已经是一个新的了，而对于内部保存的真实对象，swap的实现保证了这只会是一次浅拷贝的实现，不会有太多的额外开销。标准库实现应该针对&amp;和&amp;&amp;分别重载了operator=","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476550,"discussion_content":"第二个问题的回答基本正确。不过值类型应当是值类别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575290444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045025,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/21/00600713.jpg","nickname":"小侠","note":"","ucode":"A35A61061E41B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206740,"discussion_content":"我在VS2019运行的结果：\n*** 1 ***\nObj()\nObj(Obj&amp;&amp;)\n*** 2 ***\nObj()\nObj(Obj&amp;&amp;)\n*** 3 ***\nObj()\nObj()\nObj(Obj&amp;&amp;)\n第一种情况，也是用了move语义的，与老师的结果不同。是因为编译器不同吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584435911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1047812,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/04/89cc31ab.jpg","nickname":"嵇斌","note":"","ucode":"C9422C3F8A7B23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1045025,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/21/00600713.jpg","nickname":"小侠","note":"","ucode":"A35A61061E41B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370210,"discussion_content":"有具体的代码段么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619330801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206740,"ip_address":"","group_id":0},"score":370210,"extra":""}]}]},{"had_liked":false,"id":157759,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1575256043,"is_pvip":false,"replies":[{"id":60515,"content":"2完全正确。1再想想。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575288488,"ip_address":"","comment_id":157759,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"平时Java是主要使用语言，也来回答一下\n1、make_shared 创建(new)新对象根据传入的值类别调用拷贝构造或移动构造,然后将新对象的指针给shared_ptr，其中我看见了_Types&amp;&amp;和forward\n2、smart_ptr::operator= 中参数为值传递，会先调用smart_ptr的拷贝构造函数，生成了临时对象，然后调用swap，\n因为生成了新对象所以对等号两边是否引用同一对象进行判断，也没意义了，但是a=a也会有临时对象的产生，有性能开销\n\n有错误的方，望老师指正","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476522,"discussion_content":"2完全正确。1再想想。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575288488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307819,"user_name":"天涯游子","can_delete":false,"product_type":"c1","uid":2573392,"ip_address":"","ucode":"E6C8E638362318","user_header":"https://static001.geekbang.org/account/avatar/00/27/44/50/302d5b30.jpg","comment_is_top":false,"comment_ctime":1629270759,"is_pvip":false,"replies":[{"id":111492,"content":"如果你 return 的对象类型就是返回值类型的话，确实如此。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1629333676,"ip_address":"","comment_id":307819,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"&quot;C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用 std::move 对于移动行为没有帮助，反而会影响返回值优化。&quot;\n\n可以理解为11之后, 永远不用手动在 return 里使用 std::move 吗, 最次编译器也会帮我们做","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525303,"discussion_content":"如果你 return 的对象类型就是返回值类型的话，确实如此。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629333676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293864,"user_name":"愚者","can_delete":false,"product_type":"c1","uid":2435071,"ip_address":"","ucode":"6B1B759E40D948","user_header":"https://static001.geekbang.org/account/avatar/00/25/27/ff/996d942f.jpg","comment_is_top":false,"comment_ctime":1621581256,"is_pvip":false,"replies":[{"id":106597,"content":"没说 xvalue 不能绑定到右值引用上啊。这里说的是**生命期延长规则**在 xvalue 的情况下不能生效。函数参数本来就没有生命期延长。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1621678480,"ip_address":"","comment_id":293864,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"result&amp;&amp; r = std::move(process_shape( circle(), triangle()));\n\n对于上面的例子，有个问题向问一下老师，移动构造函数中的参数是右值引用，调用移动构造函数的时候如果传入 std::move（object），生成 xvalue，那为什么这个时候移动构造函数的形参右值引用就可以绑定到这个 xvalue 上呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520403,"discussion_content":"没说 xvalue 不能绑定到右值引用上啊。这里说的是**生命期延长规则**在 xvalue 的情况下不能生效。函数参数本来就没有生命期延长。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621678480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292130,"user_name":"Geek_33f039","can_delete":false,"product_type":"c1","uid":2610441,"ip_address":"","ucode":"6B323A9867DF42","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/6y87fry15p36xvdtbeLCiaQum8VF8XBnehtNcXictwv2cbWO3h1NeS9BZnpmNjd0DX7DH7OayyicnTkTQnuqBcB3w/132","comment_is_top":false,"comment_ctime":1620698339,"is_pvip":false,"replies":[{"id":105765,"content":"匿名的确实是右值，纯右值。右值当然不都是匿名的，还有xvalue呢。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1620708588,"ip_address":"","comment_id":292130,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师早上好，请教一个问题，匿名的都是右值吗，比如匿名变量，对象，函数都是匿名，如果匿名都是右值，那反过来右值全都是匿名的是否成立？谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519693,"discussion_content":"匿名的确实是右值，纯右值。右值当然不都是匿名的，还有xvalue呢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620708588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283315,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1615702358,"is_pvip":false,"replies":[{"id":102793,"content":"意思是你传个 42 过去，T 推导出就是 int 了，不是 int&amp;&amp;。当然，函数的参数 T&amp;&amp; 仍然是 int&amp;&amp;，但 T 不是。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615735694,"ip_address":"","comment_id":283315,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"对于 template &lt;typename T&gt; foo(T&amp;&amp;) 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身。\n请问后半句中右值的推导结果...是什么意思呢？参数的类型本身是指右值引用吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516989,"discussion_content":"意思是你传个 42 过去，T 推导出就是 int 了，不是 int&amp;amp;&amp;amp;。当然，函数的参数 T&amp;amp;&amp;amp; 仍然是 int&amp;amp;&amp;amp;，但 T 不是。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615735694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185190,"user_name":"Fiery","can_delete":false,"product_type":"c1","uid":1897610,"ip_address":"","ucode":"CDB000687A6B14","user_header":"","comment_is_top":false,"comment_ctime":1583509602,"is_pvip":false,"replies":[{"id":71538,"content":"大部分可以了。还有几个问题：\n\n1. 作为静态类型语言，process_shape 返回的结果能不能作为右值处理，是编译时检查的。比如，如果 process_shape 返回一个 shape&amp; 的话，编译就会出错。\n\n2. 把 r 传递给其他函数时，C++ 标准定义的行为略反直觉：只会匹配接受左值引用的函数，不会匹配接受右值引用的函数。要把它作为右值引用传递给另外一个函数，要使用 std::move。\n\n3. 不管哪种情况，r 变量都仍然是有效的。它指向的 shape 对象里的内容可能会被移走（取决于调用的函数的行为），但这个对象仍然应该是一个合法的对象。这个对象统一会在 r 超出作用域时被销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583541724,"ip_address":"","comment_id":185190,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"想确证一下以下的理解，在下面这个赋值并延长prvalue的生命期后：\nresult&amp;&amp; r = process_shape(\n  circle(), triangle());\nr这个变量在当前作用域应该就是一个普通的lvalue，而和它的“右值引用”类型没有关系。这个rvalue reference发挥作用的时刻在于这个r变量作为参数传入其它函数中时，函数要不然接受const result&amp;或者result&amp;&amp;。不过因为是rvalue reference，在传递给其它函数时，我们最好是明确到底是作为左值常引用还是右值引用传递了，如果是按照右值引用传递，那么我们应该默认r变量在函数返回时已经移动而无效，如果是左值常引用，那么r变量在函数返回后依然可以像刚声明后一样使用。不知道理解是否正确？而且想确认一下，确认到底是右值引用还是左值常引用这个是程序员要做的，编译期和runtime都没有保证r变量在函数返回后还是否有效的工具或约定，对吗？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486283,"discussion_content":"大部分可以了。还有几个问题：\n\n1. 作为静态类型语言，process_shape 返回的结果能不能作为右值处理，是编译时检查的。比如，如果 process_shape 返回一个 shape&amp;amp; 的话，编译就会出错。\n\n2. 把 r 传递给其他函数时，C++ 标准定义的行为略反直觉：只会匹配接受左值引用的函数，不会匹配接受右值引用的函数。要把它作为右值引用传递给另外一个函数，要使用 std::move。\n\n3. 不管哪种情况，r 变量都仍然是有效的。它指向的 shape 对象里的内容可能会被移走（取决于调用的函数的行为），但这个对象仍然应该是一个合法的对象。这个对象统一会在 r 超出作用域时被销毁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583541724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211259,"discussion_content":"关于第二点，真的是百思不得解。。试了一下确实如此，难道是在设计上强制使用move这样就不会产生“需要明确到底是作为左值常引用还是右值引用传递”这样的情况了，因为默认还是按lvalue ref传递过去了，那么还有任何必要用result&amp;&amp;接收函数返回值吗？感觉干脆就直接按value接收好了，反正返回的时候也会优化成移动语义的，请问在实际使用中是不是应该依照“不要使用rvalue ref接收prvalue，而使用lvalue或者lvalue ref”这个准则呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584833851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338639,"user_name":"Geek_7bed70","can_delete":false,"product_type":"c1","uid":2463101,"ip_address":"","ucode":"6014E8B2348457","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIL1K9WKIkvsdicFYrgiaUYLucECQMpZyEhl6L6LE5324BlDCEhJmyticcHwN8c37icQOC7q78VoKFdNQ/132","comment_is_top":false,"comment_ctime":1647614177,"is_pvip":false,"replies":[{"id":123894,"content":"不是。返回一个值时，这个结果要么是被移动出来（除非没法使用移动），要么索性可以应用返回值优化，把目标对象构造在调用者的栈帧上。从生命周期的角度，我们从来不认为临时对象是在被调用函数的栈帧上。如果没有生命周期延长的话，这个对象也是在当前执行栈上生成而又立即消亡而已。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1647850141,"ip_address":"","comment_id":338639,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"有个问题想问老师，临时对象在函数中返回，返回值用右值引用来接受会延长临时对象的生命周期，但是临时对象实在函数的栈帧中构造的，返回的时候里面的对象应该都会析构才对，这时候不是只能拷贝一份副本出来吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557522,"discussion_content":"不是。返回一个值时，这个结果要么是被移动出来（除非没法使用移动），要么索性可以应用返回值优化，把目标对象构造在调用者的栈帧上。从生命周期的角度，我们从来不认为临时对象是在被调用函数的栈帧上。如果没有生命周期延长的话，这个对象也是在当前执行栈上生成而又立即消亡而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647850141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327940,"user_name":"少年","can_delete":false,"product_type":"c1","uid":2714125,"ip_address":"","ucode":"0403897F55879C","user_header":"https://static001.geekbang.org/account/avatar/00/29/6a/0d/38607302.jpg","comment_is_top":false,"comment_ctime":1640409073,"is_pvip":false,"replies":[{"id":119438,"content":"为了保持和老代码的兼容，右值会优先绑定到右值引用，但也可以绑定到常左值引用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1640501024,"ip_address":"","comment_id":327940,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师你好，关于process_shape函数的调用：\n\nresult process_shape(const shape&amp; shape1, const shape&amp; shape2)\n{\n  puts(&quot;process_shape()&quot;);\n  return result();\n}\n\nint main()\n{   process_shape(circle(), triangle());  }\n\n我想问的是，为什么实参是右值，但是能调用形参是左值的process_shape函数？\n我试了一下，如果添加一个形参是右值的重载函数，会优先调用新写的函数，为什么？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541648,"discussion_content":"为了保持和老代码的兼容，右值会优先绑定到右值引用，但也可以绑定到常左值引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640501024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158258,"user_name":"不谈","can_delete":false,"product_type":"c1","uid":1156936,"ip_address":"","ucode":"2E18977EAC5E5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","comment_is_top":false,"comment_ctime":1575358377,"is_pvip":false,"replies":[{"id":60643,"content":"不是。Java里没有右值，也不必要有右值。因为Java里的对象都是引用语义，从来不是值语义。再仔细看一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378007,"ip_address":"","comment_id":158258,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"感觉左值和右值有点像Java里的值传递和引用传递，但又不完全像，还要再看几遍，好好理解理解","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476688,"discussion_content":"不是。Java里没有右值，也不必要有右值。因为Java里的对象都是引用语义，从来不是值语义。再仔细看一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575378007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156936,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","nickname":"不谈","note":"","ucode":"2E18977EAC5E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75336,"discussion_content":"谢谢老师，我再看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575729757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157842,"user_name":"嵇斌","can_delete":false,"product_type":"c1","uid":1047812,"ip_address":"","ucode":"C9422C3F8A7B23","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/04/89cc31ab.jpg","comment_is_top":false,"comment_ctime":1575269038,"is_pvip":false,"replies":[{"id":60520,"content":"第二个问题的回答基本正确。不过值类型应当是值类别。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575290444,"ip_address":"","comment_id":157842,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"std::move和右值引用是当时初学C++11比较难理解的一个东西。这篇能结合rvo和std::move一起讲解，相信对大家来讲也是收益匪浅的。记得以前就对小对象，以及工厂方法返回的时候究竟该用std::move还是直接返回有过一小段的讨论。\n\n第一个问题，我很无耻地去看了标准库的实现了……\n关于第二个问题：为什么 smart_ptr::operator= 对左值和右值都有效，而且不需要对等号两边是否引用同一对象进行判断？\n个人理解无论左值和右值在使用 operator=(smart_prt rhs)之前都做了隐式的转换，调用了Copy Constructor 或则 Move Constructor 得到了一个临时的 smart_prt rhs（值类型），至于是否同一对象的判断并没有关系，对于smart_ptr来说已经是一个新的了，而对于内部保存的真实对象，swap的实现保证了这只会是一次浅拷贝的实现，不会有太多的额外开销。标准库实现应该针对&amp;和&amp;&amp;分别重载了operator=","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476688,"discussion_content":"不是。Java里没有右值，也不必要有右值。因为Java里的对象都是引用语义，从来不是值语义。再仔细看一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575378007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156936,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItaas8rpvXb70zfjMetkEuYeLH0rI348MCaKqyn9HAbGZsdCKibLTnfGEBMbwQLBOhPMROcVBk9vA/132","nickname":"不谈","note":"","ucode":"2E18977EAC5E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75336,"discussion_content":"谢谢老师，我再看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575729757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157759,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1575256043,"is_pvip":false,"replies":[{"id":60515,"content":"2完全正确。1再想想。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575288488,"ip_address":"","comment_id":157759,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"平时Java是主要使用语言，也来回答一下\n1、make_shared 创建(new)新对象根据传入的值类别调用拷贝构造或移动构造,然后将新对象的指针给shared_ptr，其中我看见了_Types&amp;&amp;和forward\n2、smart_ptr::operator= 中参数为值传递，会先调用smart_ptr的拷贝构造函数，生成了临时对象，然后调用swap，\n因为生成了新对象所以对等号两边是否引用同一对象进行判断，也没意义了，但是a=a也会有临时对象的产生，有性能开销\n\n有错误的方，望老师指正","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476550,"discussion_content":"第二个问题的回答基本正确。不过值类型应当是值类别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575290444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045025,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/21/00600713.jpg","nickname":"小侠","note":"","ucode":"A35A61061E41B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206740,"discussion_content":"我在VS2019运行的结果：\n*** 1 ***\nObj()\nObj(Obj&amp;&amp;)\n*** 2 ***\nObj()\nObj(Obj&amp;&amp;)\n*** 3 ***\nObj()\nObj()\nObj(Obj&amp;&amp;)\n第一种情况，也是用了move语义的，与老师的结果不同。是因为编译器不同吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584435911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1047812,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/04/89cc31ab.jpg","nickname":"嵇斌","note":"","ucode":"C9422C3F8A7B23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1045025,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/21/00600713.jpg","nickname":"小侠","note":"","ucode":"A35A61061E41B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370210,"discussion_content":"有具体的代码段么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619330801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206740,"ip_address":"","group_id":0},"score":370210,"extra":""}]}]},{"had_liked":false,"id":307819,"user_name":"天涯游子","can_delete":false,"product_type":"c1","uid":2573392,"ip_address":"","ucode":"E6C8E638362318","user_header":"https://static001.geekbang.org/account/avatar/00/27/44/50/302d5b30.jpg","comment_is_top":false,"comment_ctime":1629270759,"is_pvip":false,"replies":[{"id":111492,"content":"如果你 return 的对象类型就是返回值类型的话，确实如此。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1629333676,"ip_address":"","comment_id":307819,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"&quot;C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用 std::move 对于移动行为没有帮助，反而会影响返回值优化。&quot;\n\n可以理解为11之后, 永远不用手动在 return 里使用 std::move 吗, 最次编译器也会帮我们做","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476522,"discussion_content":"2完全正确。1再想想。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575288488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293864,"user_name":"愚者","can_delete":false,"product_type":"c1","uid":2435071,"ip_address":"","ucode":"6B1B759E40D948","user_header":"https://static001.geekbang.org/account/avatar/00/25/27/ff/996d942f.jpg","comment_is_top":false,"comment_ctime":1621581256,"is_pvip":false,"replies":[{"id":106597,"content":"没说 xvalue 不能绑定到右值引用上啊。这里说的是**生命期延长规则**在 xvalue 的情况下不能生效。函数参数本来就没有生命期延长。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1621678480,"ip_address":"","comment_id":293864,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"result&amp;&amp; r = std::move(process_shape( circle(), triangle()));\n\n对于上面的例子，有个问题向问一下老师，移动构造函数中的参数是右值引用，调用移动构造函数的时候如果传入 std::move（object），生成 xvalue，那为什么这个时候移动构造函数的形参右值引用就可以绑定到这个 xvalue 上呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525303,"discussion_content":"如果你 return 的对象类型就是返回值类型的话，确实如此。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629333676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292130,"user_name":"Geek_33f039","can_delete":false,"product_type":"c1","uid":2610441,"ip_address":"","ucode":"6B323A9867DF42","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/6y87fry15p36xvdtbeLCiaQum8VF8XBnehtNcXictwv2cbWO3h1NeS9BZnpmNjd0DX7DH7OayyicnTkTQnuqBcB3w/132","comment_is_top":false,"comment_ctime":1620698339,"is_pvip":false,"replies":[{"id":105765,"content":"匿名的确实是右值，纯右值。右值当然不都是匿名的，还有xvalue呢。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1620708588,"ip_address":"","comment_id":292130,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师早上好，请教一个问题，匿名的都是右值吗，比如匿名变量，对象，函数都是匿名，如果匿名都是右值，那反过来右值全都是匿名的是否成立？谢谢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520403,"discussion_content":"没说 xvalue 不能绑定到右值引用上啊。这里说的是**生命期延长规则**在 xvalue 的情况下不能生效。函数参数本来就没有生命期延长。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621678480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283315,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1615702358,"is_pvip":false,"replies":[{"id":102793,"content":"意思是你传个 42 过去，T 推导出就是 int 了，不是 int&amp;&amp;。当然，函数的参数 T&amp;&amp; 仍然是 int&amp;&amp;，但 T 不是。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615735694,"ip_address":"","comment_id":283315,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"对于 template &lt;typename T&gt; foo(T&amp;&amp;) 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身。\n请问后半句中右值的推导结果...是什么意思呢？参数的类型本身是指右值引用吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519693,"discussion_content":"匿名的确实是右值，纯右值。右值当然不都是匿名的，还有xvalue呢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620708588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283037,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1615528565,"is_pvip":false,"replies":[{"id":102796,"content":"我试了一下，编译命令行上加上 &#47;Za 就会报错了。&#47;Za 的功能是禁用 MSVC 的私有扩展：\n\n&#47;Za disable extensions\n\nMSVC 是出名的默认不按照标准来。对标准符合度最高的编译器应该是 Clang。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615736382,"ip_address":"","comment_id":283037,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，\nauto add7 = &amp;(make_shared&lt;int&gt;(42));&#47;&#47;?can be addr\n我在win10, vs2015试了下可以取地址，返回值应该是std::shared_ptr的一个实例，这个实例本身是右值吗？所以不能取地址？","like_count":1},{"had_liked":false,"id":276403,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1611910806,"is_pvip":false,"replies":[{"id":100321,"content":"可以，但如果这么用的话，你需要先把自己对象清空，否则把非法值交换到被移动的对象里，它析构时就可能错误释放不存在的资源，造成系统崩溃。\n\noperator=的参数是值类型，恰恰就是想尽可能不复制。如果实参是右值，就会使用移动构造然后再交换。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611995428,"ip_address":"","comment_id":276403,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴哥，移动构造那里是不是也可以使用 swap 呢，反正swap 后那个右值引用参数也是不会去用了的\n而且这里 operator= 型参为值类型时是一定会调用复制构造的，如果型参为右值引用，实参也为右值引用时，不用复制会不会更好一点","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516918,"discussion_content":"我试了一下，编译命令行上加上 /Za 就会报错了。/Za 的功能是禁用 MSVC 的私有扩展：\n\n/Za disable extensions\n\nMSVC 是出名的默认不按照标准来。对标准符合度最高的编译器应该是 Clang。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615736382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273400,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1610587944,"is_pvip":false,"replies":[{"id":99102,"content":"因为危险。你在修改一个马上就会消失的对象，这在大部分情况下不是你想要的。\n\n以前MSVC比较宽松，会允许这种情况的出现。现在应该都不允许把一个临时对象绑定到一个非常左值引用上了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610624553,"ip_address":"","comment_id":273400,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师，我想请教一个问题，这个问题我已经疑惑很久：临时对象可以绑定到常左值引用，为什么不可以绑定到非常左值引用（non-const lvalue reference），我查看cppreference，这只是说是规定，我很不理解为什么，既然绑定到常引用延长生命期，非常引用也应该可以才对，甚至这个问题和生命期都没什么关系，你怎么理解","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514691,"discussion_content":"可以，但如果这么用的话，你需要先把自己对象清空，否则把非法值交换到被移动的对象里，它析构时就可能错误释放不存在的资源，造成系统崩溃。\n\noperator=的参数是值类型，恰恰就是想尽可能不复制。如果实参是右值，就会使用移动构造然后再交换。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611995428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255393,"user_name":"Geek_Munich","can_delete":false,"product_type":"c1","uid":1541190,"ip_address":"","ucode":"E9515AADB45144","user_header":"https://static001.geekbang.org/account/avatar/00/17/84/46/97726cd4.jpg","comment_is_top":false,"comment_ctime":1603334415,"is_pvip":false,"replies":[{"id":93104,"content":"1 正确，它们都无法取地址。\n\n我文中只给出了 xvalue 的最常见情况，std::move 只是可能的情况之一。任何返回右值引用的表达式，包括 std::move(…)，都是 xvalue。此外，一个右值数组的下标访问表达式，和一个右值对象的成员访问，也是 xvalue。\n\n这么说有点琐碎，不过文档里就是这么用外延的方式描述的……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1603376066,"ip_address":"","comment_id":255393,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，您好。关于xvalue与prvalue的区别这里我有点不太分清楚，我的理解在于：\n\n1. 无论xvalue与prvalue都是无法直接取地址；\n2. xvalue是经过std::move(A)将(左值or右值 A)强制转换成为右值引用；\n\n不知道我的理解是否正确，它们两个区别","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513593,"discussion_content":"因为危险。你在修改一个马上就会消失的对象，这在大部分情况下不是你想要的。\n\n以前MSVC比较宽松，会允许这种情况的出现。现在应该都不允许把一个临时对象绑定到一个非常左值引用上了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610624553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006628,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","nickname":"wsh","note":"","ucode":"C0FE187C6EECED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342255,"discussion_content":"引用都延长了生命周期，因为危险就不让程序员用，是不是有点过？不是应该像c一样信任程序员么？哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610624929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1006628,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","nickname":"wsh","note":"","ucode":"C0FE187C6EECED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342954,"discussion_content":"程序员如果希望这么用的话，很容易绕过：先把这个右值赋给一个右值引用变量，然后传递该变量到函数即可。反过来，如果允许了这种用法，就很容易出现隐晦的bug。\n\n在编译时利用类型机制防止常见错误，也是一件非常重要的事。对很多C里面的正常操作，在C++里都不鼓励了，甚至直接编译不过。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610886296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342255,"ip_address":"","group_id":0},"score":342954,"extra":""}]}]},{"had_liked":false,"id":252900,"user_name":"Binfun","can_delete":false,"product_type":"c1","uid":1015952,"ip_address":"","ucode":"B0CAAD6C23C2C7","user_header":"","comment_is_top":false,"comment_ctime":1602511467,"is_pvip":false,"replies":[{"id":92444,"content":"目前而言，只在一种情况下有本质区别，就是在你指定的引用类型是函数返回类型的基类的情况下。你可以用一个shape&amp;来成功地接收circle对象，而用shape则会导致对象切割。这个用法甚至不要求shape有虚析构函数，就能工作，因为编译器知道返回值的具体类型，不需要多态的分发。\n\n其他情况下，我目前试下来没有找到效率或功能上的区别——除了r的类型本身是引用类型还是值类型之外。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1602578870,"ip_address":"","comment_id":252900,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师我把这节课看了三遍，想问一下：\n\nresult&amp;&amp; r = process_shape(\n  circle(), triangle());\n这样的所谓的延长生命周期不就是赋值吗？？？\n和以下这个有什么本质上的区别吗？\nresult r = process_shape(\n  circle(), triangle());","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507705,"discussion_content":"1 正确，它们都无法取地址。\n\n我文中只给出了 xvalue 的最常见情况，std::move 只是可能的情况之一。任何返回右值引用的表达式，包括 std::move(…)，都是 xvalue。此外，一个右值数组的下标访问表达式，和一个右值对象的成员访问，也是 xvalue。\n\n这么说有点琐碎，不过文档里就是这么用外延的方式描述的……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603376066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235608,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1595124867,"is_pvip":false,"replies":[{"id":87068,"content":"后者，不带任何修饰的。即参数是 Obj&amp;&amp;，推导得到 Obj。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595207785,"ip_address":"","comment_id":235608,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师好，请问“如果传递过去的参数是右值，T 的推导结果是参数的类型本身”这句怎么理解？参数类型本身是指右值引用还是右值本身不带任何引用修身的类型呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501788,"discussion_content":"后者，不带任何修饰的。即参数是 Obj&amp;amp;&amp;amp;，推导得到 Obj。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595207785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293254,"discussion_content":"谢谢吴老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595493005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235073,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594884865,"is_pvip":false,"replies":[{"id":86842,"content":"内存模型中没啥区别，只是有不同的处理规则而已。\n\n理解汇编的好处主要是理解编译器的优化。不需要精通。简单的代码到 godbolt.org 上看看优化编译产生的输出，能大致看明白就行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594948032,"ip_address":"","comment_id":235073,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师您好，我又来耽误您时间了……\n这回是一个存疑很久的问题：右值引用和左值引用在内存模型中的具体区别是什么呢？这种区别是C++标准定义的，还是编译器厂商各自为战的？我之前猜测可能是有一些标记位上微操作，并且这些微操作应该是有统一标准的。\n今天我试着objdump了一下，在右值引用中发现编译器（g++ (GCC) 7.3.1 20180303）加入了减法指令（sub    $0x10,%rsp）和地址偏移指令（lea    -0x8(%rbp),%rax），而不是位操作。似乎我之前的猜想不大对头了。您能否不吝赐教？\n另外还有个题外话，想要深入学习C++似乎必须吃透C++内存模型，是不是必须要求汇编精熟？我是数学出身，一直下不了决心啃汇编……","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501598,"discussion_content":"内存模型中没啥区别，只是有不同的处理规则而已。\n\n理解汇编的好处主要是理解编译器的优化。不需要精通。简单的代码到 godbolt.org 上看看优化编译产生的输出，能大致看明白就行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594948032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222632,"user_name":"群","can_delete":false,"product_type":"c1","uid":1843313,"ip_address":"","ucode":"F8A363F19DAB9B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/20/71/ad3465c0.jpg","comment_is_top":false,"comment_ctime":1590852655,"is_pvip":false,"replies":[{"id":82207,"content":"就是根据 C++ 的推导规则，具体的规则就很复杂了……\n\n但反过来，规则是为了写代码服务的。我们不看规则，看用法。T&amp;&amp; 这样的写法，及引用坍缩规则，就是为了能够同时适配左值和右值。语言的设计者设计了推导规则和坍缩规则，让左值和右值在这里都能得到合适的结果。换句话说，本质上语言的设计者说的就是：“如果传递过去的参数是左值，令 T 的推导结果是左值引用；如果传递过去的参数是右值，令 T 的推导结果是参数的类型本身。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590991452,"ip_address":"","comment_id":222632,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师,您文中提到的,\n·对于 template &lt;typename T&gt; foo(T&amp;&amp;) 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身\n这个是怎么推导的?不理解为什么会推导成这个样子,可以稍微解释一下吗?","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496869,"discussion_content":"就是根据 C++ 的推导规则，具体的规则就很复杂了……\n\n但反过来，规则是为了写代码服务的。我们不看规则，看用法。T&amp;amp;&amp;amp; 这样的写法，及引用坍缩规则，就是为了能够同时适配左值和右值。语言的设计者设计了推导规则和坍缩规则，让左值和右值在这里都能得到合适的结果。换句话说，本质上语言的设计者说的就是：“如果传递过去的参数是左值，令 T 的推导结果是左值引用；如果传递过去的参数是右值，令 T 的推导结果是参数的类型本身。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590991452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234005,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d4/55/a5ec04f4.jpg","nickname":"PawN","note":"","ucode":"D0678E699327DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285922,"discussion_content":"老师，这里T 的推导结果有点没太理解 。\n```\n template <typename T> foo(arg: T&amp;&amp;) \n```\n您这里指的T的推导结果，是T 本身推到出来的类型，还是参数类型 t 呢 ？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592988910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219874,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590113225,"is_pvip":false,"replies":[{"id":81300,"content":"能。这个在 C++17 里属于必须优化的情况：即使 Obj 不支持拷贝构造也不支持移动构造，下面的语句仍然可以执行成功：\n\nObj obj = simple();\n\n见第 10 讲的讨论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214526,"ip_address":"","comment_id":219874,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，NRVO(named return value optimization),返回值优化，从英文的意思来看，应该是有名称的返回值的优化，那如果是下面的代码能享受优化不?non-named return value optimization  ^_^\nObj simple()\n{\n   &#47;&#47; Obj obj;\n    &#47;&#47; 简单返回对象；一般有 NRVO\n    return Obj();&#47;&#47;返回一个non-named value\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495972,"discussion_content":"能。这个在 C++17 里属于必须优化的情况：即使 Obj 不支持拷贝构造也不支持移动构造，下面的语句仍然可以执行成功：\n\nObj obj = simple();\n\n见第 10 讲的讨论。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590214526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187777,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1584239875,"is_pvip":false,"replies":[{"id":72489,"content":"名字还是 ptr1，没有变化（但这个 xvalue 就不允许取地址了）。它的生命周期还跟原来一样，会持续到超出作用域。而临时对象一般情况下（没有生命期延长的话）在当前语句执行完就被销毁了。就是文中这句话的下面几段的描述内容。\n\n退一步，这些都是对规则的描述而已。归根结底，prvalue 和 xvalue 都是为了能够和右值引用的参数相匹配，以达到移动对象的目的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584260698,"ip_address":"","comment_id":187777,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"“我们可以把 std::move(ptr1) 看作是一个有名字的右值”\n有名字是怎么定义的呢？比如上面表达式，它的名字是什么？它和result（）这样的临时对象有什么区别呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487237,"discussion_content":"名字还是 ptr1，没有变化（但这个 xvalue 就不允许取地址了）。它的生命周期还跟原来一样，会持续到超出作用域。而临时对象一般情况下（没有生命期延长的话）在当前语句执行完就被销毁了。就是文中这句话的下面几段的描述内容。\n\n退一步，这些都是对规则的描述而已。归根结底，prvalue 和 xvalue 都是为了能够和右值引用的参数相匹配，以达到移动对象的目的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584260698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283037,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1615528565,"is_pvip":false,"replies":[{"id":102796,"content":"我试了一下，编译命令行上加上 &#47;Za 就会报错了。&#47;Za 的功能是禁用 MSVC 的私有扩展：\n\n&#47;Za disable extensions\n\nMSVC 是出名的默认不按照标准来。对标准符合度最高的编译器应该是 Clang。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615736382,"ip_address":"","comment_id":283037,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，\nauto add7 = &amp;(make_shared&lt;int&gt;(42));&#47;&#47;?can be addr\n我在win10, vs2015试了下可以取地址，返回值应该是std::shared_ptr的一个实例，这个实例本身是右值吗？所以不能取地址？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516918,"discussion_content":"我试了一下，编译命令行上加上 /Za 就会报错了。/Za 的功能是禁用 MSVC 的私有扩展：\n\n/Za disable extensions\n\nMSVC 是出名的默认不按照标准来。对标准符合度最高的编译器应该是 Clang。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615736382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276403,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1611910806,"is_pvip":false,"replies":[{"id":100321,"content":"可以，但如果这么用的话，你需要先把自己对象清空，否则把非法值交换到被移动的对象里，它析构时就可能错误释放不存在的资源，造成系统崩溃。\n\noperator=的参数是值类型，恰恰就是想尽可能不复制。如果实参是右值，就会使用移动构造然后再交换。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611995428,"ip_address":"","comment_id":276403,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴哥，移动构造那里是不是也可以使用 swap 呢，反正swap 后那个右值引用参数也是不会去用了的\n而且这里 operator= 型参为值类型时是一定会调用复制构造的，如果型参为右值引用，实参也为右值引用时，不用复制会不会更好一点","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514691,"discussion_content":"可以，但如果这么用的话，你需要先把自己对象清空，否则把非法值交换到被移动的对象里，它析构时就可能错误释放不存在的资源，造成系统崩溃。\n\noperator=的参数是值类型，恰恰就是想尽可能不复制。如果实参是右值，就会使用移动构造然后再交换。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611995428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273400,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1610587944,"is_pvip":false,"replies":[{"id":99102,"content":"因为危险。你在修改一个马上就会消失的对象，这在大部分情况下不是你想要的。\n\n以前MSVC比较宽松，会允许这种情况的出现。现在应该都不允许把一个临时对象绑定到一个非常左值引用上了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1610624553,"ip_address":"","comment_id":273400,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师，我想请教一个问题，这个问题我已经疑惑很久：临时对象可以绑定到常左值引用，为什么不可以绑定到非常左值引用（non-const lvalue reference），我查看cppreference，这只是说是规定，我很不理解为什么，既然绑定到常引用延长生命期，非常引用也应该可以才对，甚至这个问题和生命期都没什么关系，你怎么理解","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513593,"discussion_content":"因为危险。你在修改一个马上就会消失的对象，这在大部分情况下不是你想要的。\n\n以前MSVC比较宽松，会允许这种情况的出现。现在应该都不允许把一个临时对象绑定到一个非常左值引用上了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610624553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006628,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","nickname":"wsh","note":"","ucode":"C0FE187C6EECED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342255,"discussion_content":"引用都延长了生命周期，因为危险就不让程序员用，是不是有点过？不是应该像c一样信任程序员么？哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610624929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1006628,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","nickname":"wsh","note":"","ucode":"C0FE187C6EECED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342954,"discussion_content":"程序员如果希望这么用的话，很容易绕过：先把这个右值赋给一个右值引用变量，然后传递该变量到函数即可。反过来，如果允许了这种用法，就很容易出现隐晦的bug。\n\n在编译时利用类型机制防止常见错误，也是一件非常重要的事。对很多C里面的正常操作，在C++里都不鼓励了，甚至直接编译不过。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610886296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342255,"ip_address":"","group_id":0},"score":342954,"extra":""}]}]},{"had_liked":false,"id":255393,"user_name":"Geek_Munich","can_delete":false,"product_type":"c1","uid":1541190,"ip_address":"","ucode":"E9515AADB45144","user_header":"https://static001.geekbang.org/account/avatar/00/17/84/46/97726cd4.jpg","comment_is_top":false,"comment_ctime":1603334415,"is_pvip":false,"replies":[{"id":93104,"content":"1 正确，它们都无法取地址。\n\n我文中只给出了 xvalue 的最常见情况，std::move 只是可能的情况之一。任何返回右值引用的表达式，包括 std::move(…)，都是 xvalue。此外，一个右值数组的下标访问表达式，和一个右值对象的成员访问，也是 xvalue。\n\n这么说有点琐碎，不过文档里就是这么用外延的方式描述的……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1603376066,"ip_address":"","comment_id":255393,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，您好。关于xvalue与prvalue的区别这里我有点不太分清楚，我的理解在于：\n\n1. 无论xvalue与prvalue都是无法直接取地址；\n2. xvalue是经过std::move(A)将(左值or右值 A)强制转换成为右值引用；\n\n不知道我的理解是否正确，它们两个区别","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507705,"discussion_content":"1 正确，它们都无法取地址。\n\n我文中只给出了 xvalue 的最常见情况，std::move 只是可能的情况之一。任何返回右值引用的表达式，包括 std::move(…)，都是 xvalue。此外，一个右值数组的下标访问表达式，和一个右值对象的成员访问，也是 xvalue。\n\n这么说有点琐碎，不过文档里就是这么用外延的方式描述的……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603376066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252900,"user_name":"Binfun","can_delete":false,"product_type":"c1","uid":1015952,"ip_address":"","ucode":"B0CAAD6C23C2C7","user_header":"","comment_is_top":false,"comment_ctime":1602511467,"is_pvip":false,"replies":[{"id":92444,"content":"目前而言，只在一种情况下有本质区别，就是在你指定的引用类型是函数返回类型的基类的情况下。你可以用一个shape&amp;来成功地接收circle对象，而用shape则会导致对象切割。这个用法甚至不要求shape有虚析构函数，就能工作，因为编译器知道返回值的具体类型，不需要多态的分发。\n\n其他情况下，我目前试下来没有找到效率或功能上的区别——除了r的类型本身是引用类型还是值类型之外。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1602578870,"ip_address":"","comment_id":252900,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师我把这节课看了三遍，想问一下：\n\nresult&amp;&amp; r = process_shape(\n  circle(), triangle());\n这样的所谓的延长生命周期不就是赋值吗？？？\n和以下这个有什么本质上的区别吗？\nresult r = process_shape(\n  circle(), triangle());","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506910,"discussion_content":"目前而言，只在一种情况下有本质区别，就是在你指定的引用类型是函数返回类型的基类的情况下。你可以用一个shape&amp;amp;来成功地接收circle对象，而用shape则会导致对象切割。这个用法甚至不要求shape有虚析构函数，就能工作，因为编译器知道返回值的具体类型，不需要多态的分发。\n\n其他情况下，我目前试下来没有找到效率或功能上的区别——除了r的类型本身是引用类型还是值类型之外。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602578870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015952,"avatar":"","nickname":"Binfun","note":"","ucode":"B0CAAD6C23C2C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312151,"discussion_content":"感谢老师回复。我有点明白你说的了\n\n如果去掉返回值优化的话，可以这样：\n  result&amp;&amp; r = std::move(process_shape(circle(), triangle()));\n这个时候会发现r指向的是临时生成result的栈空间地址（虽然变量理论已经被析构掉了）。\n  \nresult r = std::move(process_shape(circle(), triangle())); //这样的话会调用移动构造函数。\n\n这样看来的话，如果编译器取消返回值优化这个选项的话：\n  result&amp;&amp; r = (process_shape(circle(), triangle())); 这个r的确指向的是process_shape函数空间内的栈地址。\n\n这样子看来其实result&amp;&amp; r =也没有所谓延长生命周期，只是取了另外一个栈空间地址而已。反过来说，如果没有返回值优化的话，调用result&amp;&amp; r = (process_shape(circle(), triangle())); 是危险的，因为如果再调用下一个函数的时候，r指向的栈空间地址又被用掉了\n\n我这样理解对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602597612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1015952,"avatar":"","nickname":"Binfun","note":"","ucode":"B0CAAD6C23C2C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312390,"discussion_content":"上次的回答有点问题。为免得误导他人，我改过了。你再看看。\n\n针对你说的，不对，生命期延长规则是安全的。但我上次说能够不拷贝不移动则是错的——如果函数的写法使得返回值优化不能发生的话，使用引用来接收临时对象同样会导致移动或拷贝的发生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602675561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312151,"ip_address":"","group_id":0},"score":312390,"extra":""}]}]},{"had_liked":false,"id":235608,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1595124867,"is_pvip":false,"replies":[{"id":87068,"content":"后者，不带任何修饰的。即参数是 Obj&amp;&amp;，推导得到 Obj。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595207785,"ip_address":"","comment_id":235608,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师好，请问“如果传递过去的参数是右值，T 的推导结果是参数的类型本身”这句怎么理解？参数类型本身是指右值引用还是右值本身不带任何引用修身的类型呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506910,"discussion_content":"目前而言，只在一种情况下有本质区别，就是在你指定的引用类型是函数返回类型的基类的情况下。你可以用一个shape&amp;amp;来成功地接收circle对象，而用shape则会导致对象切割。这个用法甚至不要求shape有虚析构函数，就能工作，因为编译器知道返回值的具体类型，不需要多态的分发。\n\n其他情况下，我目前试下来没有找到效率或功能上的区别——除了r的类型本身是引用类型还是值类型之外。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602578870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015952,"avatar":"","nickname":"Binfun","note":"","ucode":"B0CAAD6C23C2C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312151,"discussion_content":"感谢老师回复。我有点明白你说的了\n\n如果去掉返回值优化的话，可以这样：\n  result&amp;&amp; r = std::move(process_shape(circle(), triangle()));\n这个时候会发现r指向的是临时生成result的栈空间地址（虽然变量理论已经被析构掉了）。\n  \nresult r = std::move(process_shape(circle(), triangle())); //这样的话会调用移动构造函数。\n\n这样看来的话，如果编译器取消返回值优化这个选项的话：\n  result&amp;&amp; r = (process_shape(circle(), triangle())); 这个r的确指向的是process_shape函数空间内的栈地址。\n\n这样子看来其实result&amp;&amp; r =也没有所谓延长生命周期，只是取了另外一个栈空间地址而已。反过来说，如果没有返回值优化的话，调用result&amp;&amp; r = (process_shape(circle(), triangle())); 是危险的，因为如果再调用下一个函数的时候，r指向的栈空间地址又被用掉了\n\n我这样理解对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602597612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1015952,"avatar":"","nickname":"Binfun","note":"","ucode":"B0CAAD6C23C2C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312390,"discussion_content":"上次的回答有点问题。为免得误导他人，我改过了。你再看看。\n\n针对你说的，不对，生命期延长规则是安全的。但我上次说能够不拷贝不移动则是错的——如果函数的写法使得返回值优化不能发生的话，使用引用来接收临时对象同样会导致移动或拷贝的发生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602675561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312151,"ip_address":"","group_id":0},"score":312390,"extra":""}]}]},{"had_liked":false,"id":235073,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594884865,"is_pvip":false,"replies":[{"id":86842,"content":"内存模型中没啥区别，只是有不同的处理规则而已。\n\n理解汇编的好处主要是理解编译器的优化。不需要精通。简单的代码到 godbolt.org 上看看优化编译产生的输出，能大致看明白就行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594948032,"ip_address":"","comment_id":235073,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师您好，我又来耽误您时间了……\n这回是一个存疑很久的问题：右值引用和左值引用在内存模型中的具体区别是什么呢？这种区别是C++标准定义的，还是编译器厂商各自为战的？我之前猜测可能是有一些标记位上微操作，并且这些微操作应该是有统一标准的。\n今天我试着objdump了一下，在右值引用中发现编译器（g++ (GCC) 7.3.1 20180303）加入了减法指令（sub    $0x10,%rsp）和地址偏移指令（lea    -0x8(%rbp),%rax），而不是位操作。似乎我之前的猜想不大对头了。您能否不吝赐教？\n另外还有个题外话，想要深入学习C++似乎必须吃透C++内存模型，是不是必须要求汇编精熟？我是数学出身，一直下不了决心啃汇编……","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501788,"discussion_content":"后者，不带任何修饰的。即参数是 Obj&amp;amp;&amp;amp;，推导得到 Obj。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595207785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","nickname":"yuchen","note":"","ucode":"D4B55B57D218CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293254,"discussion_content":"谢谢吴老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595493005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222632,"user_name":"群","can_delete":false,"product_type":"c1","uid":1843313,"ip_address":"","ucode":"F8A363F19DAB9B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/20/71/ad3465c0.jpg","comment_is_top":false,"comment_ctime":1590852655,"is_pvip":false,"replies":[{"id":82207,"content":"就是根据 C++ 的推导规则，具体的规则就很复杂了……\n\n但反过来，规则是为了写代码服务的。我们不看规则，看用法。T&amp;&amp; 这样的写法，及引用坍缩规则，就是为了能够同时适配左值和右值。语言的设计者设计了推导规则和坍缩规则，让左值和右值在这里都能得到合适的结果。换句话说，本质上语言的设计者说的就是：“如果传递过去的参数是左值，令 T 的推导结果是左值引用；如果传递过去的参数是右值，令 T 的推导结果是参数的类型本身。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590991452,"ip_address":"","comment_id":222632,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师,您文中提到的,\n·对于 template &lt;typename T&gt; foo(T&amp;&amp;) 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身\n这个是怎么推导的?不理解为什么会推导成这个样子,可以稍微解释一下吗?","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501598,"discussion_content":"内存模型中没啥区别，只是有不同的处理规则而已。\n\n理解汇编的好处主要是理解编译器的优化。不需要精通。简单的代码到 godbolt.org 上看看优化编译产生的输出，能大致看明白就行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594948032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219874,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590113225,"is_pvip":false,"replies":[{"id":81300,"content":"能。这个在 C++17 里属于必须优化的情况：即使 Obj 不支持拷贝构造也不支持移动构造，下面的语句仍然可以执行成功：\n\nObj obj = simple();\n\n见第 10 讲的讨论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214526,"ip_address":"","comment_id":219874,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，NRVO(named return value optimization),返回值优化，从英文的意思来看，应该是有名称的返回值的优化，那如果是下面的代码能享受优化不?non-named return value optimization  ^_^\nObj simple()\n{\n   &#47;&#47; Obj obj;\n    &#47;&#47; 简单返回对象；一般有 NRVO\n    return Obj();&#47;&#47;返回一个non-named value\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496869,"discussion_content":"就是根据 C++ 的推导规则，具体的规则就很复杂了……\n\n但反过来，规则是为了写代码服务的。我们不看规则，看用法。T&amp;amp;&amp;amp; 这样的写法，及引用坍缩规则，就是为了能够同时适配左值和右值。语言的设计者设计了推导规则和坍缩规则，让左值和右值在这里都能得到合适的结果。换句话说，本质上语言的设计者说的就是：“如果传递过去的参数是左值，令 T 的推导结果是左值引用；如果传递过去的参数是右值，令 T 的推导结果是参数的类型本身。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590991452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234005,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d4/55/a5ec04f4.jpg","nickname":"PawN","note":"","ucode":"D0678E699327DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285922,"discussion_content":"老师，这里T 的推导结果有点没太理解 。\n```\n template <typename T> foo(arg: T&amp;&amp;) \n```\n您这里指的T的推导结果，是T 本身推到出来的类型，还是参数类型 t 呢 ？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592988910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187777,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1584239875,"is_pvip":false,"replies":[{"id":72489,"content":"名字还是 ptr1，没有变化（但这个 xvalue 就不允许取地址了）。它的生命周期还跟原来一样，会持续到超出作用域。而临时对象一般情况下（没有生命期延长的话）在当前语句执行完就被销毁了。就是文中这句话的下面几段的描述内容。\n\n退一步，这些都是对规则的描述而已。归根结底，prvalue 和 xvalue 都是为了能够和右值引用的参数相匹配，以达到移动对象的目的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584260698,"ip_address":"","comment_id":187777,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"“我们可以把 std::move(ptr1) 看作是一个有名字的右值”\n有名字是怎么定义的呢？比如上面表达式，它的名字是什么？它和result（）这样的临时对象有什么区别呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495972,"discussion_content":"能。这个在 C++17 里属于必须优化的情况：即使 Obj 不支持拷贝构造也不支持移动构造，下面的语句仍然可以执行成功：\n\nObj obj = simple();\n\n见第 10 讲的讨论。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590214526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185535,"user_name":"Fiery","can_delete":false,"product_type":"c1","uid":1897610,"ip_address":"","ucode":"CDB000687A6B14","user_header":"","comment_is_top":false,"comment_ctime":1583615286,"is_pvip":false,"replies":[{"id":71645,"content":"对，左值和右值都可以正确接受和传递。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583634826,"ip_address":"","comment_id":185535,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"make_shared的第一种声明包括了T和可变的Args作为参数模版和Args&amp;&amp;...变长右值引用参数。应该主要还是确保调用T中正确的构造函数，目的是在make_shared执行过程中new一个新的T*实例，Args&amp;&amp;...这个参数里面的对象不论是左值还是右值应该在传入的时候已经构造完成了。话说这个&amp;&amp;的universal reference的设定这么强大？用这种方法，应该是可以保证Args&amp;&amp;里面每一个参数都可以按照它们自己的引用方式forward，就是说，传入make_shared的Args里面的对象&#47;值既可以有lvalue也可以有rvalue，这么理解正确吗？","like_count":1},{"had_liked":false,"id":166650,"user_name":"超大红细胞","can_delete":false,"product_type":"c1","uid":1780519,"ip_address":"","ucode":"08FA6FE03A8C27","user_header":"https://static001.geekbang.org/account/avatar/00/1b/2b/27/9676d6b3.jpg","comment_is_top":false,"comment_ctime":1577533149,"is_pvip":false,"replies":[{"id":63766,"content":"你是说整个课程结束的时候吗？我觉得这是个不错的建议，可以考虑！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577540551,"ip_address":"","comment_id":166650,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，提一点小建议，能否在课程结束的时候再加一至两讲，专门对每节课的课后思考题讲解一下，也方便我们温故知新，查漏补缺~","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486401,"discussion_content":"对，左值和右值都可以正确接受和传递。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583634826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163391,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1576716370,"is_pvip":false,"replies":[{"id":62125,"content":"process_shape 返回的是对象，不是引用。结果不管有没有返回值优化（实际是有的），都是在调用者的栈上。没有生命期延长的话，执行完 process_shape 这一句，对象就销毁了。有生命期延长，则要到 r 的生命期结束时才销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576734229,"ip_address":"","comment_id":163391,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"“result&amp;&amp; r = process_shape(\n  circle(), triangle());\n\n如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。”\n\n\n在上面这行代码执行完后，栈指针已经不再指向这个函数（process_shape)栈，换言之，这个栈所使用的内存可以被后续代码使用。\n\n您的例题中貌似也没有返回值优化，如果是的话，那个prvalue（result（））貌似被构建在了上面那个函数的栈内存上，这样的话，在函数栈被回收后，在函数栈上被构建的prvalue这个对象的周期是如何被延长的？难道这种情况下，函数栈没有被回收？\n\n谢谢！","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479570,"discussion_content":"你是说整个课程结束的时候吗？我觉得这是个不错的建议，可以考虑！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577540551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160125,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1575875547,"is_pvip":false,"replies":[{"id":61126,"content":"迷糊是正常的……我也啃了几遍才基本搞通。多看几遍吧。\n\n1. 是。\n2. 是。\n3. 超出作用域就没了。在你的这个例子里，它的生命期跟对象的生命期没有关系。\n4. 错误解引用是因为引用超出了变量的生命期。如果没有生命期延长，一个临时对象在当前语句执行结束即被销毁。你写的不会有问题，但把value替换成get_value()一般就会了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575896306,"ip_address":"","comment_id":160125,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"看完了目前的06讲. 感觉最不好理解的还是这03讲. 关于xvalue还是感觉有些迷糊... \n关于circle triangle shape result那一段的代码.\n1. 我看上面描述的xvalue, 通常是使用std::move被强制转换为右值的值, 这么理解对不对?\n2. 还有一个就是 \n    result&amp;&amp; r = std::move(process_shape(  circle(), triangle()));\n这个r当然是个左值, 它指代的右值, 就是xvalue, 这么理解对不对?\n3. 上面的这个xvalue, 究竟是什么时候完蛋的?\n最后是从上面引申出来的问题:\n4. std::move()函数的返回值是T&amp;&amp;, 所以用\n    T&amp;&amp; t = std::move(value); \n多么自然的一件事情...为什么这么自然的表达式, 结果却是栈内存的错误解引用呢... C++为啥要这么去规定?\n期待您的回复.","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478376,"discussion_content":"process_shape 返回的是对象，不是引用。结果不管有没有返回值优化（实际是有的），都是在调用者的栈上。没有生命期延长的话，执行完 process_shape 这一句，对象就销毁了。有生命期延长，则要到 r 的生命期结束时才销毁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576734229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158194,"user_name":"泰一","can_delete":false,"product_type":"c1","uid":1757959,"ip_address":"","ucode":"D85C764BA108CE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/07/5fc3c694.jpg","comment_is_top":false,"comment_ctime":1575345150,"is_pvip":false,"replies":[{"id":60640,"content":"是的，有了右值引用，编译器才能分辨左值和右值，才能对右值进行特殊的处理。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377421,"ip_address":"","comment_id":158194,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"“对于 smart_ptr，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销。”\n后半句：实现移动的意义是减少运行开销，因为您说了可以减少引用计数的调用，能理解。\n但是前半句：使用右值引用的目的是实现移动，想知道为什么右值引用能够实现移动呢？难道是因为增加了右值引用，就能够进行构造函数的重载，故而就能有移动构造这个新的重载函数去帮我们减少运行开销么？请老师指点一下。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477265,"discussion_content":"迷糊是正常的……我也啃了几遍才基本搞通。多看几遍吧。\n\n1. 是。\n2. 是。\n3. 超出作用域就没了。在你的这个例子里，它的生命期跟对象的生命期没有关系。\n4. 错误解引用是因为引用超出了变量的生命期。如果没有生命期延长，一个临时对象在当前语句执行结束即被销毁。你写的不会有问题，但把value替换成get_value()一般就会了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394222,"user_name":"Geek_2824a2","can_delete":false,"product_type":"c1","uid":2321211,"ip_address":"广东","ucode":"F007964A735C0F","user_header":"","comment_is_top":false,"comment_ctime":1726149300,"is_pvip":false,"replies":[{"id":143140,"content":"一、拷贝构造后析构的是新对象，没有重复析构的问题。\n\n二、你给出的代码里有拷贝构造，没有问题。但你在讨论赋值运算符……注意“Obj obj2 = obj;”也是拷贝构造而不是赋值。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1726617456,"ip_address":"上海","comment_id":394222,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"请问老师，用 operator=(smart_ptr a)的方式兼容左右值传入，如果传入的左值触发拷贝构造器，不会有重复析构的风险吗？\n比方说 \nclass smart_ptr {\n  ...;\n  ~smart_ptr() { delete ptr_;};\n};\n\nsmart_ptr&lt;Obj&gt; obj_ptr1{&amp;obj};\nsmart_ptr&lt;Obj&gt; obj_ptr2;\nsmart_ptr&lt;Obj&gt; obj_ptr2 = obj_ptr1;  \n&#47;&#47; ~obj_ptr2(); 析构ptr_\n&#47;&#47; ~obj_ptr1(); 重复析构ptr_","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476664,"discussion_content":"是的，有了右值引用，编译器才能分辨左值和右值，才能对右值进行特殊的处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575377421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390240,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"浙江","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1714832694,"is_pvip":false,"replies":[{"id":141938,"content":"p2 是利用左值的拷贝构造，而 p3 是利用右值的移动构造。不是理所当然应该不一样么？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1714992404,"ip_address":"上海","comment_id":390240,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"    &#47;&#47; 1 这个\n    auto p1 = std::shared_ptr&lt;Bot&gt;{new Bot};\n    auto temp = std::move(p1);\n    std::shared_ptr&lt;Bot&gt; p2 = std::shared_ptr&lt;Bot&gt;{temp};\n\n    &#47;&#47; 2 这个\n    std::shared_ptr&lt;Bot&gt; p3 = std::shared_ptr&lt;Bot&gt;{std::move(p1)};\n\n为什么调用的 shared_ptr 构造器不一样呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651234,"discussion_content":"一、拷贝构造后析构的是新对象，没有重复析构的问题。\n\n二、你给出的代码里有拷贝构造，没有问题。但你在讨论赋值运算符……注意“Obj obj2 = obj;”也是拷贝构造而不是赋值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726617456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2321211,"avatar":"","nickname":"Geek_2824a2","note":"","ucode":"F007964A735C0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651066,"discussion_content":"再重新温习了一下原来的代码，支持copy constructor的，在释放目标指针的时候，一定要配合counter来使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726150853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390236,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"浙江","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1714818255,"is_pvip":false,"replies":[{"id":141934,"content":"看参考资料[5]，和下面这个例子：\n\nhttps:&#47;&#47;godbolt.org&#47;z&#47;Kxsn9v71z\n\n用智能指针会导致析构不完整，而用生存期延长则不会。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1714990577,"ip_address":"上海","comment_id":390236,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"参考资料 [5] 中提到了一个有趣的事实：你可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响。\n\n这句话没懂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644115,"discussion_content":"p2 是利用左值的拷贝构造，而 p3 是利用右值的移动构造。不是理所当然应该不一样么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714992405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379028,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1691145280,"is_pvip":false,"replies":[{"id":138154,"content":"1. 是。\n\n2. 第三条说的意思是T不是自动推导的模板参数，而是已经固定下来的情况，如 strong&amp;&amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1691472922,"ip_address":"广东","comment_id":379028,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"template &lt;typename T&gt; foo(T&amp;&amp;)\n1.这里“如果传递过去的参数是右值，T 的推导结果是参数的类型本身。”意思是 如果参数1，参数推导成int，如果是1u，参数类型推导为unsigned int，而不是相应的右值引用是吗？\n2.第三条说的“实际类型”指的是什么呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644111,"discussion_content":"看参考资料[5]，和下面这个例子：\n\nhttps://godbolt.org/z/Kxsn9v71z\n\n用智能指针会导致析构不完整，而用生存期延长则不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714990577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375506,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1685550178,"is_pvip":false,"replies":[{"id":137094,"content":"右值引用当然是右值，但右值引用的**变量**是左值。再想想。🤓","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1685715731,"ip_address":"上海","comment_id":375506,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"有个逻辑不太明白。\n1.右值引用的变量是左值。理解，有符号可以取地址了嘛\n2.std::move的作用是将左值引用强转为右值引用\n3. std::move(ptr1) 看作是一个有名字的右值。为了跟无名的纯右值 prvalue 相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue。\n所以右值引用到底是左值还是右值？xvalue指的是右值引用还是std::move的返回值？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625230,"discussion_content":"1. 是。\n\n2. 第三条说的意思是T不是自动推导的模板参数，而是已经固定下来的情况，如 strong&amp;&amp;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691472922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":625252,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691488954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":625230,"ip_address":"北京","group_id":0},"score":625252,"extra":""}]}]},{"had_liked":false,"id":185535,"user_name":"Fiery","can_delete":false,"product_type":"c1","uid":1897610,"ip_address":"","ucode":"CDB000687A6B14","user_header":"","comment_is_top":false,"comment_ctime":1583615286,"is_pvip":false,"replies":[{"id":71645,"content":"对，左值和右值都可以正确接受和传递。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583634826,"ip_address":"","comment_id":185535,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"make_shared的第一种声明包括了T和可变的Args作为参数模版和Args&amp;&amp;...变长右值引用参数。应该主要还是确保调用T中正确的构造函数，目的是在make_shared执行过程中new一个新的T*实例，Args&amp;&amp;...这个参数里面的对象不论是左值还是右值应该在传入的时候已经构造完成了。话说这个&amp;&amp;的universal reference的设定这么强大？用这种方法，应该是可以保证Args&amp;&amp;里面每一个参数都可以按照它们自己的引用方式forward，就是说，传入make_shared的Args里面的对象&#47;值既可以有lvalue也可以有rvalue，这么理解正确吗？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486401,"discussion_content":"对，左值和右值都可以正确接受和传递。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583634826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166650,"user_name":"超大红细胞","can_delete":false,"product_type":"c1","uid":1780519,"ip_address":"","ucode":"08FA6FE03A8C27","user_header":"https://static001.geekbang.org/account/avatar/00/1b/2b/27/9676d6b3.jpg","comment_is_top":false,"comment_ctime":1577533149,"is_pvip":false,"replies":[{"id":63766,"content":"你是说整个课程结束的时候吗？我觉得这是个不错的建议，可以考虑！","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577540551,"ip_address":"","comment_id":166650,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，提一点小建议，能否在课程结束的时候再加一至两讲，专门对每节课的课后思考题讲解一下，也方便我们温故知新，查漏补缺~","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479570,"discussion_content":"你是说整个课程结束的时候吗？我觉得这是个不错的建议，可以考虑！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577540551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163391,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1576716370,"is_pvip":false,"replies":[{"id":62125,"content":"process_shape 返回的是对象，不是引用。结果不管有没有返回值优化（实际是有的），都是在调用者的栈上。没有生命期延长的话，执行完 process_shape 这一句，对象就销毁了。有生命期延长，则要到 r 的生命期结束时才销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576734229,"ip_address":"","comment_id":163391,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"“result&amp;&amp; r = process_shape(\n  circle(), triangle());\n\n如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。”\n\n\n在上面这行代码执行完后，栈指针已经不再指向这个函数（process_shape)栈，换言之，这个栈所使用的内存可以被后续代码使用。\n\n您的例题中貌似也没有返回值优化，如果是的话，那个prvalue（result（））貌似被构建在了上面那个函数的栈内存上，这样的话，在函数栈被回收后，在函数栈上被构建的prvalue这个对象的周期是如何被延长的？难道这种情况下，函数栈没有被回收？\n\n谢谢！","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478376,"discussion_content":"process_shape 返回的是对象，不是引用。结果不管有没有返回值优化（实际是有的），都是在调用者的栈上。没有生命期延长的话，执行完 process_shape 这一句，对象就销毁了。有生命期延长，则要到 r 的生命期结束时才销毁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576734229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160125,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1575875547,"is_pvip":false,"replies":[{"id":61126,"content":"迷糊是正常的……我也啃了几遍才基本搞通。多看几遍吧。\n\n1. 是。\n2. 是。\n3. 超出作用域就没了。在你的这个例子里，它的生命期跟对象的生命期没有关系。\n4. 错误解引用是因为引用超出了变量的生命期。如果没有生命期延长，一个临时对象在当前语句执行结束即被销毁。你写的不会有问题，但把value替换成get_value()一般就会了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575896306,"ip_address":"","comment_id":160125,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"看完了目前的06讲. 感觉最不好理解的还是这03讲. 关于xvalue还是感觉有些迷糊... \n关于circle triangle shape result那一段的代码.\n1. 我看上面描述的xvalue, 通常是使用std::move被强制转换为右值的值, 这么理解对不对?\n2. 还有一个就是 \n    result&amp;&amp; r = std::move(process_shape(  circle(), triangle()));\n这个r当然是个左值, 它指代的右值, 就是xvalue, 这么理解对不对?\n3. 上面的这个xvalue, 究竟是什么时候完蛋的?\n最后是从上面引申出来的问题:\n4. std::move()函数的返回值是T&amp;&amp;, 所以用\n    T&amp;&amp; t = std::move(value); \n多么自然的一件事情...为什么这么自然的表达式, 结果却是栈内存的错误解引用呢... C++为啥要这么去规定?\n期待您的回复.","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477265,"discussion_content":"迷糊是正常的……我也啃了几遍才基本搞通。多看几遍吧。\n\n1. 是。\n2. 是。\n3. 超出作用域就没了。在你的这个例子里，它的生命期跟对象的生命期没有关系。\n4. 错误解引用是因为引用超出了变量的生命期。如果没有生命期延长，一个临时对象在当前语句执行结束即被销毁。你写的不会有问题，但把value替换成get_value()一般就会了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575896306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158194,"user_name":"泰一","can_delete":false,"product_type":"c1","uid":1757959,"ip_address":"","ucode":"D85C764BA108CE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d3/07/5fc3c694.jpg","comment_is_top":false,"comment_ctime":1575345150,"is_pvip":false,"replies":[{"id":60640,"content":"是的，有了右值引用，编译器才能分辨左值和右值，才能对右值进行特殊的处理。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377421,"ip_address":"","comment_id":158194,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"“对于 smart_ptr，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销。”\n后半句：实现移动的意义是减少运行开销，因为您说了可以减少引用计数的调用，能理解。\n但是前半句：使用右值引用的目的是实现移动，想知道为什么右值引用能够实现移动呢？难道是因为增加了右值引用，就能够进行构造函数的重载，故而就能有移动构造这个新的重载函数去帮我们减少运行开销么？请老师指点一下。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476664,"discussion_content":"是的，有了右值引用，编译器才能分辨左值和右值，才能对右值进行特殊的处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575377421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394222,"user_name":"Geek_2824a2","can_delete":false,"product_type":"c1","uid":2321211,"ip_address":"广东","ucode":"F007964A735C0F","user_header":"","comment_is_top":false,"comment_ctime":1726149300,"is_pvip":false,"replies":[{"id":143140,"content":"一、拷贝构造后析构的是新对象，没有重复析构的问题。\n\n二、你给出的代码里有拷贝构造，没有问题。但你在讨论赋值运算符……注意“Obj obj2 = obj;”也是拷贝构造而不是赋值。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1726617456,"ip_address":"上海","comment_id":394222,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"请问老师，用 operator=(smart_ptr a)的方式兼容左右值传入，如果传入的左值触发拷贝构造器，不会有重复析构的风险吗？\n比方说 \nclass smart_ptr {\n  ...;\n  ~smart_ptr() { delete ptr_;};\n};\n\nsmart_ptr&lt;Obj&gt; obj_ptr1{&amp;obj};\nsmart_ptr&lt;Obj&gt; obj_ptr2;\nsmart_ptr&lt;Obj&gt; obj_ptr2 = obj_ptr1;  \n&#47;&#47; ~obj_ptr2(); 析构ptr_\n&#47;&#47; ~obj_ptr1(); 重复析构ptr_","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651234,"discussion_content":"一、拷贝构造后析构的是新对象，没有重复析构的问题。\n\n二、你给出的代码里有拷贝构造，没有问题。但你在讨论赋值运算符……注意“Obj obj2 = obj;”也是拷贝构造而不是赋值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726617456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2321211,"avatar":"","nickname":"Geek_2824a2","note":"","ucode":"F007964A735C0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651066,"discussion_content":"再重新温习了一下原来的代码，支持copy constructor的，在释放目标指针的时候，一定要配合counter来使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726150853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390240,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"浙江","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1714832694,"is_pvip":false,"replies":[{"id":141938,"content":"p2 是利用左值的拷贝构造，而 p3 是利用右值的移动构造。不是理所当然应该不一样么？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1714992404,"ip_address":"上海","comment_id":390240,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"    &#47;&#47; 1 这个\n    auto p1 = std::shared_ptr&lt;Bot&gt;{new Bot};\n    auto temp = std::move(p1);\n    std::shared_ptr&lt;Bot&gt; p2 = std::shared_ptr&lt;Bot&gt;{temp};\n\n    &#47;&#47; 2 这个\n    std::shared_ptr&lt;Bot&gt; p3 = std::shared_ptr&lt;Bot&gt;{std::move(p1)};\n\n为什么调用的 shared_ptr 构造器不一样呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644115,"discussion_content":"p2 是利用左值的拷贝构造，而 p3 是利用右值的移动构造。不是理所当然应该不一样么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714992405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390236,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"浙江","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1714818255,"is_pvip":false,"replies":[{"id":141934,"content":"看参考资料[5]，和下面这个例子：\n\nhttps:&#47;&#47;godbolt.org&#47;z&#47;Kxsn9v71z\n\n用智能指针会导致析构不完整，而用生存期延长则不会。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1714990577,"ip_address":"上海","comment_id":390236,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"参考资料 [5] 中提到了一个有趣的事实：你可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响。\n\n这句话没懂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644111,"discussion_content":"看参考资料[5]，和下面这个例子：\n\nhttps://godbolt.org/z/Kxsn9v71z\n\n用智能指针会导致析构不完整，而用生存期延长则不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714990577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379028,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1691145280,"is_pvip":false,"replies":[{"id":138154,"content":"1. 是。\n\n2. 第三条说的意思是T不是自动推导的模板参数，而是已经固定下来的情况，如 strong&amp;&amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1691472922,"ip_address":"广东","comment_id":379028,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"template &lt;typename T&gt; foo(T&amp;&amp;)\n1.这里“如果传递过去的参数是右值，T 的推导结果是参数的类型本身。”意思是 如果参数1，参数推导成int，如果是1u，参数类型推导为unsigned int，而不是相应的右值引用是吗？\n2.第三条说的“实际类型”指的是什么呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625230,"discussion_content":"1. 是。\n\n2. 第三条说的意思是T不是自动推导的模板参数，而是已经固定下来的情况，如 strong&amp;&amp;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691472922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1242483,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","nickname":"！null","note":"","ucode":"4E5B7922980397","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":625252,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691488954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":625230,"ip_address":"北京","group_id":0},"score":625252,"extra":""}]}]},{"had_liked":false,"id":375506,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1685550178,"is_pvip":false,"replies":[{"id":137094,"content":"右值引用当然是右值，但右值引用的**变量**是左值。再想想。🤓","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1685715731,"ip_address":"上海","comment_id":375506,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"有个逻辑不太明白。\n1.右值引用的变量是左值。理解，有符号可以取地址了嘛\n2.std::move的作用是将左值引用强转为右值引用\n3. std::move(ptr1) 看作是一个有名字的右值。为了跟无名的纯右值 prvalue 相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue。\n所以右值引用到底是左值还是右值？xvalue指的是右值引用还是std::move的返回值？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620021,"discussion_content":"右值引用当然是右值，但右值引用的**变量**是左值。再想想。🤓","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685715732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370574,"user_name":"谁家内存泄露了","can_delete":false,"product_type":"c1","uid":2436042,"ip_address":"北京","ucode":"CDDA3BE17FE40E","user_header":"https://static001.geekbang.org/account/avatar/00/25/2b/ca/71ff1fd7.jpg","comment_is_top":false,"comment_ctime":1678969591,"is_pvip":false,"replies":[{"id":135277,"content":"1. 理由你已经自己看到了。\n2. 跟拷贝构造函数不同，移动函数很容易自己没有的。看你的代码应该是两条规则共同作用的结果。一条是我在专栏第9讲里写的：“用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。”所以你现在不会有自动生成的的移动构造函数。因为 unique_ptr 是不可拷贝的，所以你的对象也不能拷贝构造。\n\n对于你这样的多态类，建议基类里声明成：\n\nprotected:\n  A(A&amp;&amp;) = default;\n\n不公开是为了防止对象切割（object slicing），虽然一般是发生在拷贝而非移动时。保险点也没坏处吧。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1679271166,"ip_address":"广东","comment_id":370574,"utype":1}],"discussion_count":3,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"吴老师好，不好意思两个专栏来回问问题。。。我最近又有个疑惑：\n在实际项目有类似代码（可运行）：\n#include &lt;memeory&gt;\nclass A{\npublic:\n    A():pU(nullptr){}\n    virtual ~A(){}\n    std::unique_ptr&lt;int&gt; pU;\n};\nclass B : public A\n{\npublic:\n    B(){}\n    B(B&amp;&amp;)=default;\n};\nint main(){return0;}\n------------------------\n编译器：clang version 10.0.0-4ubuntu1\nOS：Ubuntu20.04\n-----------------------\n好了有问题的代码如上：\n编译会出现警告：\nwarning: explicitly defaulted move constructor is implicitly deleted [-Wdefaulted-function-deleted]\n    B(B&amp;&amp;) = default;\n    ^\nnote: move constructor of &#39;B&#39; is implicitly deleted because base class &#39;A&#39; has a deleted move constructor\nclass B : public A\n          ^\nnote: copy constructor of &#39;A&#39; is implicitly deleted because field &#39;pU&#39; has a deleted copy constructor\n    std::unique_ptr&lt;int&gt; pU;\n                         ^\nnote: &#39;unique_ptr&#39; has been explicitly marked deleted here\n      unique_ptr(const unique_ptr&amp;) = delete;\n      ^\n1 warning generated\n我有两个问题：\n1 为什么B的移动构造函数会被隐式删除？\n2 更不能理解为什么class B的移动构造函数被删除，最根本的原因是其基类A中unique_ptr的拷贝构造函数被默认删除。。\n百思不得其解，望解惑。","like_count":0},{"had_liked":false,"id":367559,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"北京","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1675323363,"is_pvip":false,"replies":[{"id":133958,"content":"抱歉，我没看出你的陈述和我的陈述有什么矛盾，也没看出你想说明啥。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1675646412,"ip_address":"上海","comment_id":367559,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"cppreference的定义：an xvalue (an “eXpiring” value) is a glvalue that denotes an object whose resources can be reused;\n\nThe expressions that have identity are called &quot;glvalue expressions&quot; (glvalue stands for &quot;generalized lvalue&quot;). Both lvalues and xvalues are glvalue expressions.\n\nxvalue 是被归为glvalue，泛左值的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609862,"discussion_content":"1. 理由你已经自己看到了。\n2. 跟拷贝构造函数不同，移动函数很容易自己没有的。看你的代码应该是两条规则共同作用的结果。一条是我在专栏第9讲里写的：“用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。”所以你现在不会有自动生成的的移动构造函数。因为 unique_ptr 是不可拷贝的，所以你的对象也不能拷贝构造。\n\n对于你这样的多态类，建议基类里声明成：\n\nprotected:\n  A(A&&) = default;\n\n不公开是为了防止对象切割（object slicing），虽然一般是发生在拷贝而非移动时。保险点也没坏处吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679271166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2436042,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2b/ca/71ff1fd7.jpg","nickname":"谁家内存泄露了","note":"","ucode":"CDDA3BE17FE40E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":609990,"discussion_content":"谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679324007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609862,"ip_address":"北京","group_id":0},"score":609990,"extra":""}]},{"author":{"id":2436042,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2b/ca/71ff1fd7.jpg","nickname":"谁家内存泄露了","note":"","ucode":"CDDA3BE17FE40E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609570,"discussion_content":"应该是找到答案了，B的默认移动构造函数被删除，是因为他的基类A的默认移动构造函数被删除了，这是A中定义了虚析构函数导致。\n默认移动构造函数被删除，会调用默认拷贝构造函数，但是由于std::unique_ptr的原因，默认拷贝构造函数也被删除。\n由此，出现了这个警告及相关note.\n吴老师有空帮看看这个思路是否正确。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679033752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364460,"user_name":"Cafba","can_delete":false,"product_type":"c1","uid":3245533,"ip_address":"江苏","ucode":"A645AD090F3FA4","user_header":"https://static001.geekbang.org/account/avatar/00/31/85/dd/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1670993764,"is_pvip":false,"replies":[{"id":132479,"content":"你的代码和我的代码有明显的不同，最显著的一点是，你没有提供拷贝构造函数。似乎你漏了第二讲里的这段话：\n\n“需要注意，上面这个构造函数［模板形式的拷贝构造函数］不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。”","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1671024133,"ip_address":"江苏","comment_id":364460,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师您好，关于智能指针的实现，使用了两个模板参数，我自己测试了一下，若按您给的那个测试用例，在赋值运算符调用前会调用拷贝构造函数，但当我将其改成内置类型比如int，当赋值时不会再调用拷贝构造函数，因此引用计数也不会增加，赋值后二者的引用计数都是 1，我又将其改为不涉及派生类的测试用例也是这种结果，我认为不调用拷贝构造函数是因为使用两种模板参数，于是我改为只使用一种，这样后两种情况就正常了，但您给的测试用例那个又会出错，这是为什么？一旦使用两种模板参数，类型一致的变量之间赋值就不会调用拷贝构造了（移动构造我试了可以），无法单纯按右值移动，左值拷贝来判断，总是跟类型有关，会有不调用拷贝构造的情况\n代码：\nhttps:&#47;&#47;godbolt.org&#47;z&#47;jEnhExa7E","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602056,"discussion_content":"抱歉，我没看出你的陈述和我的陈述有什么矛盾，也没看出你想说明啥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675646412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359768,"user_name":"Geek_fa7226","can_delete":false,"product_type":"c1","uid":3184848,"ip_address":"江苏","ucode":"B7780A449FAC27","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK418DKQ4eFh00D6vwqE7nJEX1Ou9DWDHKV2Zj21lq00qK6RzpY6SP3ic0I1hMnbvxQBQSCzzOomNg/132","comment_is_top":false,"comment_ctime":1665848480,"is_pvip":false,"replies":[{"id":130915,"content":"在使用值传递的时候，被调用函数总是获得一个对应类型的值，从它的角度，调用者使用左值和右值没有区别。不会像引用传递一样，可以进行区别重载。\n\n当然，从程序整体来讲是有区别的。见第41讲。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1666052089,"ip_address":"江苏","comment_id":359768,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第一个表达式里的 new circle() 就是一个纯右值；但对于指针，我们通常使用值传递，并不关心它是左值还是右值。这句话我不是很理解：为什么值传递不需要关心左值和右值","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590720,"discussion_content":"在使用值传递的时候，被调用函数总是获得一个对应类型的值，从它的角度，调用者使用左值和右值没有区别。不会像引用传递一样，可以进行区别重载。\n\n当然，从程序整体来讲是有区别的。见第41讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666052089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355865,"user_name":"Kavies","can_delete":false,"product_type":"c1","uid":1421427,"ip_address":"上海","ucode":"C5D8A68A006BB5","user_header":"https://static001.geekbang.org/account/avatar/00/15/b0/73/51488d22.jpg","comment_is_top":false,"comment_ctime":1661816564,"is_pvip":false,"replies":[{"id":129524,"content":"如果不关注性能，当然用Python很香，我也喜欢的。但Python基本上就是完全不可能优化到有C++的性能的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1661835360,"ip_address":"上海","comment_id":355865,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"从python过来，感觉要疯了，很多编译器或解释器的应该去解决问题，都丢给程序员去关注了，这心智负担太重了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590720,"discussion_content":"在使用值传递的时候，被调用函数总是获得一个对应类型的值，从它的角度，调用者使用左值和右值没有区别。不会像引用传递一样，可以进行区别重载。\n\n当然，从程序整体来讲是有区别的。见第41讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666052089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355222,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"上海","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1661181655,"is_pvip":false,"replies":[{"id":129264,"content":"不需要你传类型。比如，你用 foo(string(&quot;Hello&quot;)) 去调用（右值），T 就会被推导为 string，函数的形参就成了 string&amp;&amp;。如果你用一个 string 类型的变量去调用（左值），T 就会被推导为 string&amp;，最后的形参仍然是 string&amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1661257563,"ip_address":"上海","comment_id":355222,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"template &lt;typename T&gt; foo(T&amp;&amp;)，如果 T 是一个实际类型，那 T&amp;&amp; 的结果自然就是一个右值引用，老师，能举例说明嘛，比如一个测试代码？不清楚怎么传实际类型。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584987,"discussion_content":"不需要你传类型。比如，你用 foo(string(&#34;Hello&#34;)) 去调用（右值），T 就会被推导为 string，函数的形参就成了 string&amp;&amp;。如果你用一个 string 类型的变量去调用（左值），T 就会被推导为 string&amp;，最后的形参仍然是 string&amp;。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661257564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345327,"user_name":"清茶淡样","can_delete":false,"product_type":"c1","uid":1138339,"ip_address":"","ucode":"BA24BC09FB33DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/5e/a3/de99053a.jpg","comment_is_top":false,"comment_ctime":1652193769,"is_pvip":false,"replies":[{"id":126077,"content":"如果 T 是外层类模板的参数的话，那你给出的代码有点问题。因为在 T 已经确定的情况下，T&amp;&amp; 是右值引用（不是转发引用），所以用 forward 就很奇怪了。用 move(x) 更合适。\n\n排除这点，这样的写法意味着对于某特定类型 T，函数有两种不同的形式。而如果改写成你给出的转发引用形式的话，那实际上对于 const 左值引用、非 const 左值引用、右值引用会出现三种不同的特化，源代码更紧凑，但有二进制膨胀之虞。\n\n关注一下应该下周发布的第 37 讲，我会讨论这个问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1652247147,"ip_address":"","comment_id":345327,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师，请教个问题，在一本书上看到部分代码\nvoid put(const T&amp; x) {  Add(x);  }\nvoid put(T &amp;&amp; x) { Add(std::forward&lt;T&gt;(x)); } \n这是一个类内的两个函数，我的理解的是否可以用\ntemplate&lt;class T&gt;\nvoid put(T&amp;&amp; x) { Add(std::forward&lt;T&gt;(x)); } \n来代替上面两个函数，这样也方便理解\n如果我的理解有误，这两个函数缺一不可的话，希望您能指出他们的必要性，谢谢老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571501,"discussion_content":"如果 T 是外层类模板的参数的话，那你给出的代码有点问题。因为在 T 已经确定的情况下，T&amp;&amp; 是右值引用（不是转发引用），所以用 forward 就很奇怪了。用 move(x) 更合适。\n\n排除这点，这样的写法意味着对于某特定类型 T，函数有两种不同的形式。而如果改写成你给出的转发引用形式的话，那实际上对于 const 左值引用、非 const 左值引用、右值引用会出现三种不同的特化，源代码更紧凑，但有二进制膨胀之虞。\n\n关注一下应该下周发布的第 37 讲，我会讨论这个问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652247147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342698,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1650422409,"is_pvip":false,"replies":[{"id":125257,"content":"不谈语法，语义上指针和引用都是一种指向其他对象的方式。请参见：\n\nhttps:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\n\n你说的在一般术语里叫“引用”，不称作“引用类型”。我同意这有点混乱和二义性，但这些术语都不是我发明的。😜","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1650547311,"ip_address":"","comment_id":342698,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"指针是引用类型??????????????????????????????????? *a,**a,***a,全都是值类型，认为指针是引用类似是混淆了解引用这个动作了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571501,"discussion_content":"如果 T 是外层类模板的参数的话，那你给出的代码有点问题。因为在 T 已经确定的情况下，T&amp;&amp; 是右值引用（不是转发引用），所以用 forward 就很奇怪了。用 move(x) 更合适。\n\n排除这点，这样的写法意味着对于某特定类型 T，函数有两种不同的形式。而如果改写成你给出的转发引用形式的话，那实际上对于 const 左值引用、非 const 左值引用、右值引用会出现三种不同的特化，源代码更紧凑，但有二进制膨胀之虞。\n\n关注一下应该下周发布的第 37 讲，我会讨论这个问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652247147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333418,"user_name":"Geek_889d61","can_delete":false,"product_type":"c1","uid":2403693,"ip_address":"","ucode":"58C53AE4DB6DEB","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/6d/dd46ff73.jpg","comment_is_top":false,"comment_ctime":1644334412,"is_pvip":false,"replies":[{"id":121861,"content":"默认情况下，临时对象在当前语句执行完成后被销毁。所以都不会有问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644383284,"ip_address":"","comment_id":333418,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师， 文中提到「常引用和转发引用的生命期延长规则只对 prvalue 有效，而对 xvalue 无效」，并且连带这个引用本身也会失效，我直接这么引用时确实是这样的。\n但是如果将转发引用作为函数参数类型，将 xvalue 传给这个函数，却发现和传 prvalue 的结果完全一样，并没有失效，这是为什么呢？\n\n```c++\n#include &lt;iostream&gt;\n\nclass result\n{\npublic:\n    result()\n        : ptr(new int(1)) { puts(&quot;result()&quot;); }\n\n    result(const result&amp; other)\n        : ptr(new int(*other.ptr))\n    {\n        puts(&quot;result(const result&amp;)&quot;);\n    }\n\n    result(result&amp;&amp; other) noexcept\n        : ptr(other.ptr)\n    {\n        other.ptr = nullptr;\n        puts(&quot;result(result&amp;&amp;)&quot;);\n    }\n\n    result&amp; operator=(result rhs) {\n        swap(rhs);\n        puts(&quot;result&amp; operator=(result)&quot;);\n        return *this;\n    }\n\n    ~result()\n    {\n        puts(&quot;~result()&quot;);\n        delete ptr;\n    }\n\n    int get() const { return *ptr; }\n\n    void swap(result&amp; other) {\n        using std::swap;\n        swap(ptr, other.ptr);\n    }\n\nprivate:\n    int* ptr;\n};\n\nauto make_result()\n{\n    return result();\n}\n\nvoid process_result(result&amp;&amp; r)\n{\n    std::cout &lt;&lt; r.get() &lt;&lt; std::endl;\n}\n\nint main()\n{\n    process_result(make_result());\n    std::cout &lt;&lt; &quot;================================================================&quot; &lt;&lt; std::endl;\n    process_result(std::move(make_result()));\n}\n```","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550094,"discussion_content":"默认情况下，临时对象在当前语句执行完成后被销毁。所以都不会有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644383285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291015,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1619941919,"is_pvip":false,"replies":[{"id":105439,"content":"1 你没实际回答。2 回答基本正确，但最好强调一下 this 对象的内容没有改变。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619955626,"ip_address":"","comment_id":291015,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"问题1：c++ primer 5th 练习16.61\n问题2：对于左值，构造实参时调用拷贝构造函数；对于右值，构造实参时调用移动构造函数。即使赋值语句左侧和右侧是同一对象，那也没有问题，因为此种情况构造实参时会增加1次引用计数，swap实参和*this完成后，实参还是指向原来的引用计数器，析构实参时减少1次引用计数，相对于没有增减引用计数。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519342,"discussion_content":"1 你没实际回答。2 回答基本正确，但最好强调一下 this 对象的内容没有改变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619955626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370574,"user_name":"谁家内存泄露了","can_delete":false,"product_type":"c1","uid":2436042,"ip_address":"北京","ucode":"CDDA3BE17FE40E","user_header":"https://static001.geekbang.org/account/avatar/00/25/2b/ca/71ff1fd7.jpg","comment_is_top":false,"comment_ctime":1678969591,"is_pvip":false,"replies":[{"id":135277,"content":"1. 理由你已经自己看到了。\n2. 跟拷贝构造函数不同，移动函数很容易自己没有的。看你的代码应该是两条规则共同作用的结果。一条是我在专栏第9讲里写的：“用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。”所以你现在不会有自动生成的的移动构造函数。因为 unique_ptr 是不可拷贝的，所以你的对象也不能拷贝构造。\n\n对于你这样的多态类，建议基类里声明成：\n\nprotected:\n  A(A&amp;&amp;) = default;\n\n不公开是为了防止对象切割（object slicing），虽然一般是发生在拷贝而非移动时。保险点也没坏处吧。","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1679271166,"ip_address":"广东","comment_id":370574,"utype":1}],"discussion_count":3,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"吴老师好，不好意思两个专栏来回问问题。。。我最近又有个疑惑：\n在实际项目有类似代码（可运行）：\n#include &lt;memeory&gt;\nclass A{\npublic:\n    A():pU(nullptr){}\n    virtual ~A(){}\n    std::unique_ptr&lt;int&gt; pU;\n};\nclass B : public A\n{\npublic:\n    B(){}\n    B(B&amp;&amp;)=default;\n};\nint main(){return0;}\n------------------------\n编译器：clang version 10.0.0-4ubuntu1\nOS：Ubuntu20.04\n-----------------------\n好了有问题的代码如上：\n编译会出现警告：\nwarning: explicitly defaulted move constructor is implicitly deleted [-Wdefaulted-function-deleted]\n    B(B&amp;&amp;) = default;\n    ^\nnote: move constructor of &#39;B&#39; is implicitly deleted because base class &#39;A&#39; has a deleted move constructor\nclass B : public A\n          ^\nnote: copy constructor of &#39;A&#39; is implicitly deleted because field &#39;pU&#39; has a deleted copy constructor\n    std::unique_ptr&lt;int&gt; pU;\n                         ^\nnote: &#39;unique_ptr&#39; has been explicitly marked deleted here\n      unique_ptr(const unique_ptr&amp;) = delete;\n      ^\n1 warning generated\n我有两个问题：\n1 为什么B的移动构造函数会被隐式删除？\n2 更不能理解为什么class B的移动构造函数被删除，最根本的原因是其基类A中unique_ptr的拷贝构造函数被默认删除。。\n百思不得其解，望解惑。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609862,"discussion_content":"1. 理由你已经自己看到了。\n2. 跟拷贝构造函数不同，移动函数很容易自己没有的。看你的代码应该是两条规则共同作用的结果。一条是我在专栏第9讲里写的：“用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。”所以你现在不会有自动生成的的移动构造函数。因为 unique_ptr 是不可拷贝的，所以你的对象也不能拷贝构造。\n\n对于你这样的多态类，建议基类里声明成：\n\nprotected:\n  A(A&&) = default;\n\n不公开是为了防止对象切割（object slicing），虽然一般是发生在拷贝而非移动时。保险点也没坏处吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679271166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2436042,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2b/ca/71ff1fd7.jpg","nickname":"谁家内存泄露了","note":"","ucode":"CDDA3BE17FE40E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":609990,"discussion_content":"谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679324007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609862,"ip_address":"北京","group_id":0},"score":609990,"extra":""}]},{"author":{"id":2436042,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2b/ca/71ff1fd7.jpg","nickname":"谁家内存泄露了","note":"","ucode":"CDDA3BE17FE40E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609570,"discussion_content":"应该是找到答案了，B的默认移动构造函数被删除，是因为他的基类A的默认移动构造函数被删除了，这是A中定义了虚析构函数导致。\n默认移动构造函数被删除，会调用默认拷贝构造函数，但是由于std::unique_ptr的原因，默认拷贝构造函数也被删除。\n由此，出现了这个警告及相关note.\n吴老师有空帮看看这个思路是否正确。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679033752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367559,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"北京","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1675323363,"is_pvip":false,"replies":[{"id":133958,"content":"抱歉，我没看出你的陈述和我的陈述有什么矛盾，也没看出你想说明啥。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1675646412,"ip_address":"上海","comment_id":367559,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"cppreference的定义：an xvalue (an “eXpiring” value) is a glvalue that denotes an object whose resources can be reused;\n\nThe expressions that have identity are called &quot;glvalue expressions&quot; (glvalue stands for &quot;generalized lvalue&quot;). Both lvalues and xvalues are glvalue expressions.\n\nxvalue 是被归为glvalue，泛左值的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602056,"discussion_content":"抱歉，我没看出你的陈述和我的陈述有什么矛盾，也没看出你想说明啥。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675646412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364460,"user_name":"Cafba","can_delete":false,"product_type":"c1","uid":3245533,"ip_address":"江苏","ucode":"A645AD090F3FA4","user_header":"https://static001.geekbang.org/account/avatar/00/31/85/dd/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1670993764,"is_pvip":false,"replies":[{"id":132479,"content":"你的代码和我的代码有明显的不同，最显著的一点是，你没有提供拷贝构造函数。似乎你漏了第二讲里的这段话：\n\n“需要注意，上面这个构造函数［模板形式的拷贝构造函数］不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。”","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1671024133,"ip_address":"江苏","comment_id":364460,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师您好，关于智能指针的实现，使用了两个模板参数，我自己测试了一下，若按您给的那个测试用例，在赋值运算符调用前会调用拷贝构造函数，但当我将其改成内置类型比如int，当赋值时不会再调用拷贝构造函数，因此引用计数也不会增加，赋值后二者的引用计数都是 1，我又将其改为不涉及派生类的测试用例也是这种结果，我认为不调用拷贝构造函数是因为使用两种模板参数，于是我改为只使用一种，这样后两种情况就正常了，但您给的测试用例那个又会出错，这是为什么？一旦使用两种模板参数，类型一致的变量之间赋值就不会调用拷贝构造了（移动构造我试了可以），无法单纯按右值移动，左值拷贝来判断，总是跟类型有关，会有不调用拷贝构造的情况\n代码：\nhttps:&#47;&#47;godbolt.org&#47;z&#47;jEnhExa7E","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596481,"discussion_content":"你的代码和我的代码有明显的不同，最显著的一点是，你没有提供拷贝构造函数。似乎你漏了第二讲里的这段话：\n\n“需要注意，上面这个构造函数［模板形式的拷贝构造函数］不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671024134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359768,"user_name":"Geek_fa7226","can_delete":false,"product_type":"c1","uid":3184848,"ip_address":"江苏","ucode":"B7780A449FAC27","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK418DKQ4eFh00D6vwqE7nJEX1Ou9DWDHKV2Zj21lq00qK6RzpY6SP3ic0I1hMnbvxQBQSCzzOomNg/132","comment_is_top":false,"comment_ctime":1665848480,"is_pvip":false,"replies":[{"id":130915,"content":"在使用值传递的时候，被调用函数总是获得一个对应类型的值，从它的角度，调用者使用左值和右值没有区别。不会像引用传递一样，可以进行区别重载。\n\n当然，从程序整体来讲是有区别的。见第41讲。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1666052089,"ip_address":"江苏","comment_id":359768,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第一个表达式里的 new circle() 就是一个纯右值；但对于指针，我们通常使用值传递，并不关心它是左值还是右值。这句话我不是很理解：为什么值传递不需要关心左值和右值","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596481,"discussion_content":"你的代码和我的代码有明显的不同，最显著的一点是，你没有提供拷贝构造函数。似乎你漏了第二讲里的这段话：\n\n“需要注意，上面这个构造函数［模板形式的拷贝构造函数］不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671024134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355865,"user_name":"Kavies","can_delete":false,"product_type":"c1","uid":1421427,"ip_address":"上海","ucode":"C5D8A68A006BB5","user_header":"https://static001.geekbang.org/account/avatar/00/15/b0/73/51488d22.jpg","comment_is_top":false,"comment_ctime":1661816564,"is_pvip":false,"replies":[{"id":129524,"content":"如果不关注性能，当然用Python很香，我也喜欢的。但Python基本上就是完全不可能优化到有C++的性能的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1661835360,"ip_address":"上海","comment_id":355865,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"从python过来，感觉要疯了，很多编译器或解释器的应该去解决问题，都丢给程序员去关注了，这心智负担太重了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585808,"discussion_content":"如果不关注性能，当然用Python很香，我也喜欢的。但Python基本上就是完全不可能优化到有C++的性能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661835360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355222,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"上海","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1661181655,"is_pvip":false,"replies":[{"id":129264,"content":"不需要你传类型。比如，你用 foo(string(&quot;Hello&quot;)) 去调用（右值），T 就会被推导为 string，函数的形参就成了 string&amp;&amp;。如果你用一个 string 类型的变量去调用（左值），T 就会被推导为 string&amp;，最后的形参仍然是 string&amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1661257563,"ip_address":"上海","comment_id":355222,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"template &lt;typename T&gt; foo(T&amp;&amp;)，如果 T 是一个实际类型，那 T&amp;&amp; 的结果自然就是一个右值引用，老师，能举例说明嘛，比如一个测试代码？不清楚怎么传实际类型。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585808,"discussion_content":"如果不关注性能，当然用Python很香，我也喜欢的。但Python基本上就是完全不可能优化到有C++的性能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661835360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345327,"user_name":"清茶淡样","can_delete":false,"product_type":"c1","uid":1138339,"ip_address":"","ucode":"BA24BC09FB33DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/5e/a3/de99053a.jpg","comment_is_top":false,"comment_ctime":1652193769,"is_pvip":false,"replies":[{"id":126077,"content":"如果 T 是外层类模板的参数的话，那你给出的代码有点问题。因为在 T 已经确定的情况下，T&amp;&amp; 是右值引用（不是转发引用），所以用 forward 就很奇怪了。用 move(x) 更合适。\n\n排除这点，这样的写法意味着对于某特定类型 T，函数有两种不同的形式。而如果改写成你给出的转发引用形式的话，那实际上对于 const 左值引用、非 const 左值引用、右值引用会出现三种不同的特化，源代码更紧凑，但有二进制膨胀之虞。\n\n关注一下应该下周发布的第 37 讲，我会讨论这个问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1652247147,"ip_address":"","comment_id":345327,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师，请教个问题，在一本书上看到部分代码\nvoid put(const T&amp; x) {  Add(x);  }\nvoid put(T &amp;&amp; x) { Add(std::forward&lt;T&gt;(x)); } \n这是一个类内的两个函数，我的理解的是否可以用\ntemplate&lt;class T&gt;\nvoid put(T&amp;&amp; x) { Add(std::forward&lt;T&gt;(x)); } \n来代替上面两个函数，这样也方便理解\n如果我的理解有误，这两个函数缺一不可的话，希望您能指出他们的必要性，谢谢老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584987,"discussion_content":"不需要你传类型。比如，你用 foo(string(&#34;Hello&#34;)) 去调用（右值），T 就会被推导为 string，函数的形参就成了 string&amp;&amp;。如果你用一个 string 类型的变量去调用（左值），T 就会被推导为 string&amp;，最后的形参仍然是 string&amp;。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661257564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342698,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1650422409,"is_pvip":false,"replies":[{"id":125257,"content":"不谈语法，语义上指针和引用都是一种指向其他对象的方式。请参见：\n\nhttps:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\n\n你说的在一般术语里叫“引用”，不称作“引用类型”。我同意这有点混乱和二义性，但这些术语都不是我发明的。😜","user_name":"作者回复","user_name_real":"作者","uid":1645639,"ctime":1650547311,"ip_address":"","comment_id":342698,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"指针是引用类型??????????????????????????????????? *a,**a,***a,全都是值类型，认为指针是引用类似是混淆了解引用这个动作了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565822,"discussion_content":"不谈语法，语义上指针和引用都是一种指向其他对象的方式。请参见：\n\nhttps://zh.wikipedia.org/wiki/%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\n\n你说的在一般术语里叫“引用”，不称作“引用类型”。我同意这有点混乱和二义性，但这些术语都不是我发明的。😜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650547311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333418,"user_name":"Geek_889d61","can_delete":false,"product_type":"c1","uid":2403693,"ip_address":"","ucode":"58C53AE4DB6DEB","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/6d/dd46ff73.jpg","comment_is_top":false,"comment_ctime":1644334412,"is_pvip":false,"replies":[{"id":121861,"content":"默认情况下，临时对象在当前语句执行完成后被销毁。所以都不会有问题。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644383284,"ip_address":"","comment_id":333418,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师， 文中提到「常引用和转发引用的生命期延长规则只对 prvalue 有效，而对 xvalue 无效」，并且连带这个引用本身也会失效，我直接这么引用时确实是这样的。\n但是如果将转发引用作为函数参数类型，将 xvalue 传给这个函数，却发现和传 prvalue 的结果完全一样，并没有失效，这是为什么呢？\n\n```c++\n#include &lt;iostream&gt;\n\nclass result\n{\npublic:\n    result()\n        : ptr(new int(1)) { puts(&quot;result()&quot;); }\n\n    result(const result&amp; other)\n        : ptr(new int(*other.ptr))\n    {\n        puts(&quot;result(const result&amp;)&quot;);\n    }\n\n    result(result&amp;&amp; other) noexcept\n        : ptr(other.ptr)\n    {\n        other.ptr = nullptr;\n        puts(&quot;result(result&amp;&amp;)&quot;);\n    }\n\n    result&amp; operator=(result rhs) {\n        swap(rhs);\n        puts(&quot;result&amp; operator=(result)&quot;);\n        return *this;\n    }\n\n    ~result()\n    {\n        puts(&quot;~result()&quot;);\n        delete ptr;\n    }\n\n    int get() const { return *ptr; }\n\n    void swap(result&amp; other) {\n        using std::swap;\n        swap(ptr, other.ptr);\n    }\n\nprivate:\n    int* ptr;\n};\n\nauto make_result()\n{\n    return result();\n}\n\nvoid process_result(result&amp;&amp; r)\n{\n    std::cout &lt;&lt; r.get() &lt;&lt; std::endl;\n}\n\nint main()\n{\n    process_result(make_result());\n    std::cout &lt;&lt; &quot;================================================================&quot; &lt;&lt; std::endl;\n    process_result(std::move(make_result()));\n}\n```","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565822,"discussion_content":"不谈语法，语义上指针和引用都是一种指向其他对象的方式。请参见：\n\nhttps://zh.wikipedia.org/wiki/%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\n\n你说的在一般术语里叫“引用”，不称作“引用类型”。我同意这有点混乱和二义性，但这些术语都不是我发明的。😜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650547311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291015,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1619941919,"is_pvip":false,"replies":[{"id":105439,"content":"1 你没实际回答。2 回答基本正确，但最好强调一下 this 对象的内容没有改变。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619955626,"ip_address":"","comment_id":291015,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"问题1：c++ primer 5th 练习16.61\n问题2：对于左值，构造实参时调用拷贝构造函数；对于右值，构造实参时调用移动构造函数。即使赋值语句左侧和右侧是同一对象，那也没有问题，因为此种情况构造实参时会增加1次引用计数，swap实参和*this完成后，实参还是指向原来的引用计数器，析构实参时减少1次引用计数，相对于没有增减引用计数。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550094,"discussion_content":"默认情况下，临时对象在当前语句执行完成后被销毁。所以都不会有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644383285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235113,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594895311,"is_pvip":false,"replies":[{"id":86845,"content":"实参构造顺序和在参数列表中的位置的关系，在标准中没有定义。鉴于 C 有可变参数，一般从右向左压栈，所以你说的顺序比较多见。但微软还有 stdcall 调用规范呢。构造和析构顺序相反，那一般确实是这样的。\n\n右值和左值只是处理规则不同。当然不可能右值全放在寄存器里。跟左值一样，右值也可以是很大的对象，寄存器里完全可能放不下……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594948214,"ip_address":"","comment_id":235113,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"吴老师您好。\n这一章内容问题很多，又要麻烦您了。\n你在文中提到，circle 和 triangle 的构造和析构顺序在标准中未指明，我隐约记得C++内存模型深度探索哪本书中提到过，实参构造顺序和在参数列表中的位置相关，析构顺序相反。不过看的时间太久很有可能记错了。\n我之前一直以为，所谓纯右值是那些只在寄存器中分配，而没在内存中分配地址的数据。看了一下参考资料5，发现我对纯右值引用这件事愈发理解不能。形如const obj&amp; o =xyz(),或者obj&amp;&amp; o = xyz()这种操作,o最终引用的内存是当前stack frame中的一个地址吗？ 那就是说纯右值并不是一个只存在于寄存器的数据且可以取到内存地址的？","like_count":0},{"had_liked":false,"id":187928,"user_name":"湖海散人","can_delete":false,"product_type":"c1","uid":1096781,"ip_address":"","ucode":"74C0C825D74CC1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","comment_is_top":false,"comment_ctime":1584279106,"is_pvip":false,"replies":[{"id":72664,"content":"再看一下正文吧。对 result 的值没有影响，但两种情况下，result 指向的对象的生命期不同（有没有生命期延长）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584328445,"ip_address":"","comment_id":187928,"utype":1}],"discussion_count":3,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"请问一下，在文章中下面两个例子：\nresult&amp;&amp; r = process_shape( circle(), triangle());\n\nresult&amp;&amp; r = std::move(process_shape( circle(), triangle()));\n\n\n既可以直接将函数返回的result赋值给右值引用的变量，又可以std::move函数返回的值给右值引用的变量，那函数返回的result是一个什么值，没理解这两个赋值操作的区别\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501604,"discussion_content":"实参构造顺序和在参数列表中的位置的关系，在标准中没有定义。鉴于 C 有可变参数，一般从右向左压栈，所以你说的顺序比较多见。但微软还有 stdcall 调用规范呢。构造和析构顺序相反，那一般确实是这样的。\n\n右值和左值只是处理规则不同。当然不可能右值全放在寄存器里。跟左值一样，右值也可以是很大的对象，寄存器里完全可能放不下……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594948214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185017,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1583466075,"is_pvip":false,"replies":[{"id":71521,"content":"不能。这跟寄存器并没有什么关系。通常一个右值仍然在内存里。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583502291,"ip_address":"","comment_id":185017,"utype":1}],"discussion_count":3,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，请问：右值能不能理解为还存在于寄存器中，没有保存到内存中的值呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486216,"discussion_content":"不能。这跟寄存器并没有什么关系。通常一个右值仍然在内存里。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583502291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198552,"discussion_content":"追问一下，栈和寄存器可以划等号吗？而且之所以说“右值通常在内存里”是因为右值只是用来表明所有权是否可以转移，和指针/引用语义并不相关？那么通常都在内存里的原因，是否是因为只有在堆上创建的复杂实例才更注意要使用右值移动语义来减少运行开销？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583507104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199881,"discussion_content":"在谈对象的声明周期的时候，寄存器是个完全无关的事情（跟平台、优化等方面更有关系）。右值/临时对象只是一个对象，从对象本身是看不出跟左值有啥区别的——有区别的只是它的生命周期。需要注意使用移动语义的，确实一般是当对象内有放在堆上的其他数据——使用指针或智能指针来管理的、不和对象成员放在一起的数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583635121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198552,"ip_address":"","group_id":0},"score":199881,"extra":""}]}]},{"had_liked":false,"id":175619,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1580783582,"is_pvip":false,"replies":[{"id":68271,"content":"联合第四点一起看。对象 3 一般不是临时对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580792993,"ip_address":"","comment_id":175619,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，string那里的第三点是不是应该为临时对象😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486216,"discussion_content":"不能。这跟寄存器并没有什么关系。通常一个右值仍然在内存里。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583502291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198552,"discussion_content":"追问一下，栈和寄存器可以划等号吗？而且之所以说“右值通常在内存里”是因为右值只是用来表明所有权是否可以转移，和指针/引用语义并不相关？那么通常都在内存里的原因，是否是因为只有在堆上创建的复杂实例才更注意要使用右值移动语义来减少运行开销？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583507104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199881,"discussion_content":"在谈对象的声明周期的时候，寄存器是个完全无关的事情（跟平台、优化等方面更有关系）。右值/临时对象只是一个对象，从对象本身是看不出跟左值有啥区别的——有区别的只是它的生命周期。需要注意使用移动语义的，确实一般是当对象内有放在堆上的其他数据——使用指针或智能指针来管理的、不和对象成员放在一起的数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583635121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198552,"ip_address":"","group_id":0},"score":199881,"extra":""}]}]},{"had_liked":false,"id":175616,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1580783133,"is_pvip":false,"replies":[{"id":68272,"content":"就是字符串指向的内存区域被类似于 strcpy 或 memcpy 的调用复制了几次。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580793131,"ip_address":"","comment_id":175616,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，string那里的复制1次，复制2次没太懂什么意思😨","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482825,"discussion_content":"就是字符串指向的内存区域被类似于 strcpy 或 memcpy 的调用复制了几次。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580793131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175103,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1580558707,"is_pvip":false,"replies":[{"id":68038,"content":"是这样的。在第 10 讲中有一个更完整的讨论，你也可以参考一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580617981,"ip_address":"","comment_id":175103,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"NRVO行为的例子跟编译器的优化参数也有关系，在MSVC下关闭优化&#47;Od，看不到NRVO，只能看到3类情况下都使用的是移动构造","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482625,"discussion_content":"是这样的。在第 10 讲中有一个更完整的讨论，你也可以参考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580617981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169556,"user_name":"Geek_9e42eb","can_delete":false,"product_type":"c1","uid":1593979,"ip_address":"","ucode":"289E65C28F6C2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","comment_is_top":false,"comment_ctime":1578379011,"is_pvip":false,"replies":[{"id":65789,"content":"试试不就知道了？😉\n\n字符串常量是常左值，有确定的地址。常左值能不能放等号左边呢？我不需要回答了吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392638,"ip_address":"","comment_id":169556,"utype":1}],"discussion_count":5,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"左值 lvalue 是有标识符、可以取地址的表达式，字符串常量（如“hello world”）可以取地址吗？字符串常量(如“hello world”)应该不可以放在等号的左边吧？为什么说它也是左值？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480611,"discussion_content":"试试不就知道了？😉\n\n字符串常量是常左值，有确定的地址。常左值能不能放等号左边呢？我不需要回答了吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578392638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179597,"discussion_content":"这让我想起了 const 应该叫unmutable  constexpr应该叫const","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582243770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593979,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","nickname":"Geek_9e42eb","note":"","ucode":"289E65C28F6C2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125132,"discussion_content":"难道是：\n“hello world” = “hhh”；\n这一看就不可以呀，很不理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578476054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1665239,"avatar":"https://static001.geekbang.org/account/avatar/00/19/68/d7/499f23ec.jpg","nickname":"MXQ","note":"","ucode":"7104D0B5D025AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593979,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","nickname":"Geek_9e42eb","note":"","ucode":"289E65C28F6C2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168153,"discussion_content":"是左值，有地址，但不能更改其中的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581558683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":125132,"ip_address":"","group_id":0},"score":168153,"extra":""},{"author":{"id":1571236,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f9/a4/423e6df6.jpg","nickname":"WORK","note":"","ucode":"0D1751A41F9917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593979,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","nickname":"Geek_9e42eb","note":"","ucode":"289E65C28F6C2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169558,"discussion_content":"这不是伟大而又缠人的const吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581610000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":125132,"ip_address":"","group_id":0},"score":169558,"extra":""}]}]},{"had_liked":false,"id":169322,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578314671,"is_pvip":false,"replies":[{"id":65677,"content":"直观理解，函数已经要返回了，本地对象已经没用了，编译器选择最有效的返回数据方式：第一是返回值优化，第二是移动，第三才是拷贝。\n\n这就是我文中所写的：“在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578325306,"ip_address":"","comment_id":169322,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，感谢您的回复。prvalue应该是test1返回的临时变量吧，但是a是一个左值，编译器根据return来判断此时优先使用move而不是copy来返回吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480507,"discussion_content":"直观理解，函数已经要返回了，本地对象已经没用了，编译器选择最有效的返回数据方式：第一是返回值优化，第二是移动，第三才是拷贝。\n\n这就是我文中所写的：“在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578325306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169279,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578304307,"is_pvip":false,"replies":[{"id":65668,"content":"你返回的是一个对象，prvalue，不是左值。这个对象会被移动返回。可以参见第 10 讲。\n\n如果你把返回值改成左值引用，返回的才是左值。在这种情况下，随机的崩溃就可能会发生了，因为被引用的对象已经被销毁。这也是为什么必须返回对象而不是引用，这样的对象会从返回内容移动或拷贝产生。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578309118,"ip_address":"","comment_id":169279,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"\n老师，我A类里定义了拷贝构造和移动构造，在关闭返回值优化后，test1中返回了一个左值，但是打印结果却是调用了移动构造，不应该是拷贝构造吗？\nA test1()\n{\n    A a(4);\n    a.m_a = 5;\n    cout&lt;&lt;&quot;test1:&quot;&lt;&lt;&amp;a&lt;&lt;endl;\n    return a;\n}\n\nint main()\n{\n   test1();\n    return 0;\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480490,"discussion_content":"你返回的是一个对象，prvalue，不是左值。这个对象会被移动返回。可以参见第 10 讲。\n\n如果你把返回值改成左值引用，返回的才是左值。在这种情况下，随机的崩溃就可能会发生了，因为被引用的对象已经被销毁。这也是为什么必须返回对象而不是引用，这样的对象会从返回内容移动或拷贝产生。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578309118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":121171,"discussion_content":"老师，感谢您的回复。prvalue应该是test1返回的临时变量吧，但是a是一个左值，编译器根据return来判断此时优先使用move而不是copy来返回吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578313865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166569,"user_name":"Lnnnnnn","can_delete":false,"product_type":"c1","uid":1568979,"ip_address":"","ucode":"8E1CF63A12C809","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL1BLgfPicBbStiakFJX2IMzGEuaibsVQRLKsmpgfLumWPvu8B9NunbzRJI9G18XXy3kFc9SZBYw3bfw/132","comment_is_top":false,"comment_ctime":1577504342,"is_pvip":false,"replies":[{"id":63480,"content":"接近了。更精确地说，是这句语句执行完之后（也就是，赋值之后），临时对象就被释放了。\n\n临时对象的生命期一般就是当前语句（如果没有生命期延长的话）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577511914,"ip_address":"","comment_id":166569,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师我想请问下\nresult&amp;&amp; r = std::move(process_shape( circle(), triangle()))；\n这段加了move的代码之所以会有Bug存在是不是因为在函数调用结束后临时对面就被析构，所以move转换出来的右值全是指向不存在的地址空间，而\nresult&amp;&amp; r = process_shape( circle(), triangle())；\n这样直接拿右值引用去接临时对象，延长其生命周期固正常使用。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479543,"discussion_content":"接近了。更精确地说，是这句语句执行完之后（也就是，赋值之后），临时对象就被释放了。\n\n临时对象的生命期一般就是当前语句（如果没有生命期延长的话）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577511914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235113,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594895311,"is_pvip":false,"replies":[{"id":86845,"content":"实参构造顺序和在参数列表中的位置的关系，在标准中没有定义。鉴于 C 有可变参数，一般从右向左压栈，所以你说的顺序比较多见。但微软还有 stdcall 调用规范呢。构造和析构顺序相反，那一般确实是这样的。\n\n右值和左值只是处理规则不同。当然不可能右值全放在寄存器里。跟左值一样，右值也可以是很大的对象，寄存器里完全可能放不下……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594948214,"ip_address":"","comment_id":235113,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"吴老师您好。\n这一章内容问题很多，又要麻烦您了。\n你在文中提到，circle 和 triangle 的构造和析构顺序在标准中未指明，我隐约记得C++内存模型深度探索哪本书中提到过，实参构造顺序和在参数列表中的位置相关，析构顺序相反。不过看的时间太久很有可能记错了。\n我之前一直以为，所谓纯右值是那些只在寄存器中分配，而没在内存中分配地址的数据。看了一下参考资料5，发现我对纯右值引用这件事愈发理解不能。形如const obj&amp; o =xyz(),或者obj&amp;&amp; o = xyz()这种操作,o最终引用的内存是当前stack frame中的一个地址吗？ 那就是说纯右值并不是一个只存在于寄存器的数据且可以取到内存地址的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501604,"discussion_content":"实参构造顺序和在参数列表中的位置的关系，在标准中没有定义。鉴于 C 有可变参数，一般从右向左压栈，所以你说的顺序比较多见。但微软还有 stdcall 调用规范呢。构造和析构顺序相反，那一般确实是这样的。\n\n右值和左值只是处理规则不同。当然不可能右值全放在寄存器里。跟左值一样，右值也可以是很大的对象，寄存器里完全可能放不下……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594948214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187928,"user_name":"湖海散人","can_delete":false,"product_type":"c1","uid":1096781,"ip_address":"","ucode":"74C0C825D74CC1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","comment_is_top":false,"comment_ctime":1584279106,"is_pvip":false,"replies":[{"id":72664,"content":"再看一下正文吧。对 result 的值没有影响，但两种情况下，result 指向的对象的生命期不同（有没有生命期延长）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584328445,"ip_address":"","comment_id":187928,"utype":1}],"discussion_count":3,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"请问一下，在文章中下面两个例子：\nresult&amp;&amp; r = process_shape( circle(), triangle());\n\nresult&amp;&amp; r = std::move(process_shape( circle(), triangle()));\n\n\n既可以直接将函数返回的result赋值给右值引用的变量，又可以std::move函数返回的值给右值引用的变量，那函数返回的result是一个什么值，没理解这两个赋值操作的区别\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487294,"discussion_content":"再看一下正文吧。对 result 的值没有影响，但两种情况下，result 指向的对象的生命期不同（有没有生命期延长）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584328445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096781,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","nickname":"湖海散人","note":"","ucode":"74C0C825D74CC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205652,"discussion_content":"我比较疑惑的是，用不用move都能给result&amp;&amp;赋值，这两者有什么区别呀，process_shape的返回值是个右值还是左值呀，move不是将右值属性的左值转换成右值吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584328916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1096781,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","nickname":"湖海散人","note":"","ucode":"74C0C825D74CC1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205741,"discussion_content":"差别就是生命期延长规则（例子前后都写到的）。再读一遍正文吧……\n\nprocess_shape 返回的是个对象，是个 prvalue。move 会将其强制转换成 xvalue。move 的本质就是一个强制类型转换，例子的这句相当于 static_cast<result&amp;&amp;>(…)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584336628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205652,"ip_address":"","group_id":0},"score":205741,"extra":""}]}]},{"had_liked":false,"id":185017,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1583466075,"is_pvip":false,"replies":[{"id":71521,"content":"不能。这跟寄存器并没有什么关系。通常一个右值仍然在内存里。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583502291,"ip_address":"","comment_id":185017,"utype":1}],"discussion_count":3,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，请问：右值能不能理解为还存在于寄存器中，没有保存到内存中的值呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487294,"discussion_content":"再看一下正文吧。对 result 的值没有影响，但两种情况下，result 指向的对象的生命期不同（有没有生命期延长）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584328445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096781,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","nickname":"湖海散人","note":"","ucode":"74C0C825D74CC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205652,"discussion_content":"我比较疑惑的是，用不用move都能给result&amp;&amp;赋值，这两者有什么区别呀，process_shape的返回值是个右值还是左值呀，move不是将右值属性的左值转换成右值吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584328916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1096781,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","nickname":"湖海散人","note":"","ucode":"74C0C825D74CC1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205741,"discussion_content":"差别就是生命期延长规则（例子前后都写到的）。再读一遍正文吧……\n\nprocess_shape 返回的是个对象，是个 prvalue。move 会将其强制转换成 xvalue。move 的本质就是一个强制类型转换，例子的这句相当于 static_cast<result&amp;&amp;>(…)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584336628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205652,"ip_address":"","group_id":0},"score":205741,"extra":""}]}]},{"had_liked":false,"id":175619,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1580783582,"is_pvip":false,"replies":[{"id":68271,"content":"联合第四点一起看。对象 3 一般不是临时对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580792993,"ip_address":"","comment_id":175619,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，string那里的第三点是不是应该为临时对象😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482826,"discussion_content":"联合第四点一起看。对象 3 一般不是临时对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580792993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175616,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1580783133,"is_pvip":false,"replies":[{"id":68272,"content":"就是字符串指向的内存区域被类似于 strcpy 或 memcpy 的调用复制了几次。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580793131,"ip_address":"","comment_id":175616,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，string那里的复制1次，复制2次没太懂什么意思😨","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482826,"discussion_content":"联合第四点一起看。对象 3 一般不是临时对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580792993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175103,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1580558707,"is_pvip":false,"replies":[{"id":68038,"content":"是这样的。在第 10 讲中有一个更完整的讨论，你也可以参考一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580617981,"ip_address":"","comment_id":175103,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"NRVO行为的例子跟编译器的优化参数也有关系，在MSVC下关闭优化&#47;Od，看不到NRVO，只能看到3类情况下都使用的是移动构造","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482825,"discussion_content":"就是字符串指向的内存区域被类似于 strcpy 或 memcpy 的调用复制了几次。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580793131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169556,"user_name":"Geek_9e42eb","can_delete":false,"product_type":"c1","uid":1593979,"ip_address":"","ucode":"289E65C28F6C2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","comment_is_top":false,"comment_ctime":1578379011,"is_pvip":false,"replies":[{"id":65789,"content":"试试不就知道了？😉\n\n字符串常量是常左值，有确定的地址。常左值能不能放等号左边呢？我不需要回答了吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392638,"ip_address":"","comment_id":169556,"utype":1}],"discussion_count":5,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"左值 lvalue 是有标识符、可以取地址的表达式，字符串常量（如“hello world”）可以取地址吗？字符串常量(如“hello world”)应该不可以放在等号的左边吧？为什么说它也是左值？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482625,"discussion_content":"是这样的。在第 10 讲中有一个更完整的讨论，你也可以参考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580617981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169322,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578314671,"is_pvip":false,"replies":[{"id":65677,"content":"直观理解，函数已经要返回了，本地对象已经没用了，编译器选择最有效的返回数据方式：第一是返回值优化，第二是移动，第三才是拷贝。\n\n这就是我文中所写的：“在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578325306,"ip_address":"","comment_id":169322,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，感谢您的回复。prvalue应该是test1返回的临时变量吧，但是a是一个左值，编译器根据return来判断此时优先使用move而不是copy来返回吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480611,"discussion_content":"试试不就知道了？😉\n\n字符串常量是常左值，有确定的地址。常左值能不能放等号左边呢？我不需要回答了吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578392638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179597,"discussion_content":"这让我想起了 const 应该叫unmutable  constexpr应该叫const","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582243770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593979,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","nickname":"Geek_9e42eb","note":"","ucode":"289E65C28F6C2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125132,"discussion_content":"难道是：\n“hello world” = “hhh”；\n这一看就不可以呀，很不理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578476054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1665239,"avatar":"https://static001.geekbang.org/account/avatar/00/19/68/d7/499f23ec.jpg","nickname":"MXQ","note":"","ucode":"7104D0B5D025AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593979,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","nickname":"Geek_9e42eb","note":"","ucode":"289E65C28F6C2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168153,"discussion_content":"是左值，有地址，但不能更改其中的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581558683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":125132,"ip_address":"","group_id":0},"score":168153,"extra":""},{"author":{"id":1571236,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f9/a4/423e6df6.jpg","nickname":"WORK","note":"","ucode":"0D1751A41F9917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1593979,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","nickname":"Geek_9e42eb","note":"","ucode":"289E65C28F6C2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169558,"discussion_content":"这不是伟大而又缠人的const吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581610000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":125132,"ip_address":"","group_id":0},"score":169558,"extra":""}]}]},{"had_liked":false,"id":169279,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578304307,"is_pvip":false,"replies":[{"id":65668,"content":"你返回的是一个对象，prvalue，不是左值。这个对象会被移动返回。可以参见第 10 讲。\n\n如果你把返回值改成左值引用，返回的才是左值。在这种情况下，随机的崩溃就可能会发生了，因为被引用的对象已经被销毁。这也是为什么必须返回对象而不是引用，这样的对象会从返回内容移动或拷贝产生。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578309118,"ip_address":"","comment_id":169279,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"\n老师，我A类里定义了拷贝构造和移动构造，在关闭返回值优化后，test1中返回了一个左值，但是打印结果却是调用了移动构造，不应该是拷贝构造吗？\nA test1()\n{\n    A a(4);\n    a.m_a = 5;\n    cout&lt;&lt;&quot;test1:&quot;&lt;&lt;&amp;a&lt;&lt;endl;\n    return a;\n}\n\nint main()\n{\n   test1();\n    return 0;\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480507,"discussion_content":"直观理解，函数已经要返回了，本地对象已经没用了，编译器选择最有效的返回数据方式：第一是返回值优化，第二是移动，第三才是拷贝。\n\n这就是我文中所写的：“在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578325306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166569,"user_name":"Lnnnnnn","can_delete":false,"product_type":"c1","uid":1568979,"ip_address":"","ucode":"8E1CF63A12C809","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL1BLgfPicBbStiakFJX2IMzGEuaibsVQRLKsmpgfLumWPvu8B9NunbzRJI9G18XXy3kFc9SZBYw3bfw/132","comment_is_top":false,"comment_ctime":1577504342,"is_pvip":false,"replies":[{"id":63480,"content":"接近了。更精确地说，是这句语句执行完之后（也就是，赋值之后），临时对象就被释放了。\n\n临时对象的生命期一般就是当前语句（如果没有生命期延长的话）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577511914,"ip_address":"","comment_id":166569,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师我想请问下\nresult&amp;&amp; r = std::move(process_shape( circle(), triangle()))；\n这段加了move的代码之所以会有Bug存在是不是因为在函数调用结束后临时对面就被析构，所以move转换出来的右值全是指向不存在的地址空间，而\nresult&amp;&amp; r = process_shape( circle(), triangle())；\n这样直接拿右值引用去接临时对象，延长其生命周期固正常使用。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480490,"discussion_content":"你返回的是一个对象，prvalue，不是左值。这个对象会被移动返回。可以参见第 10 讲。\n\n如果你把返回值改成左值引用，返回的才是左值。在这种情况下，随机的崩溃就可能会发生了，因为被引用的对象已经被销毁。这也是为什么必须返回对象而不是引用，这样的对象会从返回内容移动或拷贝产生。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578309118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":121171,"discussion_content":"老师，感谢您的回复。prvalue应该是test1返回的临时变量吧，但是a是一个左值，编译器根据return来判断此时优先使用move而不是copy来返回吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578313865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163198,"user_name":"张岩","can_delete":false,"product_type":"c1","uid":1314807,"ip_address":"","ucode":"7968C3ECC27CAE","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/f7/7c3e491f.jpg","comment_is_top":false,"comment_ctime":1576668764,"is_pvip":false,"replies":[{"id":62073,"content":"xvalue 是有标识符的。这儿临时对象一直没有标识符，也就一直是 prvalue。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576681806,"ip_address":"","comment_id":163198,"utype":1}],"discussion_count":4,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"int main()\n{\n    A&amp;&amp; a = static_cast&lt;A&amp;&amp;&gt;(GetA());\n    cout&lt;&lt;&quot;main end&quot;&lt;&lt;endl;\n    a.func();\n    return 0;\n}\n\ng++ -g -std=c++11  construct.cpp ;.&#47;a.out \nconstruct: 1\nmain end\nfunc: 1\ndestruct: 1\n\n老师您好，请问下，为什么上面的这种情况xvalue的生命周期被延长了。","like_count":0},{"had_liked":false,"id":161526,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1576223815,"is_pvip":false,"replies":[{"id":61556,"content":"我觉得我做不到比文中更清楚了（否则我就写进去了）。😅\n\n多看例子来体会一下吧……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576275900,"ip_address":"","comment_id":161526,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师，我对左值、右值、移动的区别很懵。可以简单的说下吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478292,"discussion_content":"xvalue 是有标识符的。这儿临时对象一直没有标识符，也就一直是 prvalue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576681806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198804,"discussion_content":"好问题啊，查到了以下这个解释：https://stackoverflow.com/questions/42441791/lifetime-extension-prvalues-and-xvalues\n理解得不太透彻，但是可能大概是，本来xvalue也可以绑定到引用并延长周期，但std:move()这一层函数扰乱了本来的生命期推断，我猜想可能是本来prvalue绑定是一个表达式，prvalue在绑定前都还在表达式中，但是有一层std::move以后，prvalue所在的表达式就在传入std::move之后就算是complete了，所以prvalue的生命期可能就只存在于std::move执行过程中了。。。总之我觉得std::move还是只用在lvalue上比较靠谱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583511891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314807,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/f7/7c3e491f.jpg","nickname":"张岩","note":"","ucode":"7968C3ECC27CAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91069,"discussion_content":"https://zh.cppreference.com/w/cpp/language/value_category\n下列表达式是亡值表达式：\n        返回类型为对象的右值引用的函数调用或重载运算符表达式，例如 std::move(x)；\n        转换为对象的右值引用类型的转型表达式，例如 static_cast<char&amp;&amp;>(x)\n这个static_cast<T&amp;&amp;>表达式是不是只对左值有效可不可以这么理解。\nA&amp;&amp; return_rvalue(A&amp;&amp; a){\n    cout<<&#34;return_rvalue&#34;<<endl;\n    return static_cast<A&amp;&amp;>(a);\n}​\n我自己封装成一个方法，return_rvalue返回的就是一个xvalue\n\n我现在疑惑的是为什么static_cast<T&amp;&amp;>转型后不是一个xvalue，\n求老师解答。感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576808140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314807,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/f7/7c3e491f.jpg","nickname":"张岩","note":"","ucode":"7968C3ECC27CAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88620,"discussion_content":"construct.cpp:54:37: error: taking address of xvalue (rvalue reference)\n     cout<<&amp;(static_cast<A&amp;&amp;>(GetA()))<<endl;\n为啥编译器提示这是一个xvalue。\n老师再指点一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576721203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160640,"user_name":"王小白白白","can_delete":false,"product_type":"c1","uid":1140277,"ip_address":"","ucode":"7049DA34B12208","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/35/1b14f2af.jpg","comment_is_top":false,"comment_ctime":1575991285,"is_pvip":false,"replies":[{"id":61304,"content":"内存复制，memcpy、strcpy 这样的操作。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022910,"ip_address":"","comment_id":160640,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师，string拼接那里，复制指的是？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477750,"discussion_content":"我觉得我做不到比文中更清楚了（否则我就写进去了）。😅\n\n多看例子来体会一下吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576275900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159026,"user_name":"じJRisenづジ","can_delete":false,"product_type":"c1","uid":1401105,"ip_address":"","ucode":"87EB43D4B0B19C","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/11/85386508.jpg","comment_is_top":false,"comment_ctime":1575517130,"is_pvip":false,"replies":[{"id":60857,"content":"https:&#47;&#47;github.com&#47;adah1972&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575539766,"ip_address":"","comment_id":159026,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师您的github 是？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477443,"discussion_content":"内存复制，memcpy、strcpy 这样的操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576022910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158906,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575476317,"is_pvip":false,"replies":[{"id":60817,"content":"返回值优化在没有开启优化编译选项时也是可能发生的。编译器看到这种形式的代码直接统一处理了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575509253,"ip_address":"","comment_id":158906,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"Obj simple()\n{\n  Obj obj;\n  &#47;&#47;  简单返回对象；一般有  NRVO\n  return obj;\n}\n\nauto obj1 = simple();\n\n请问这个不应该是会调用一次构造和拷贝构造吗，因为函数返回对象Obj是用了函数内部的obj进行拷贝构造，而返回的这个对象被直接优化给了obj1而没有调用构造函数\n那么如果没有优化应该是两次构造，一次拷贝构造才对啊，感觉","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476919,"discussion_content":"https://github.com/adah1972/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575539766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401105,"avatar":"https://static001.geekbang.org/account/avatar/00/15/61/11/85386508.jpg","nickname":"じJRisenづジ","note":"","ucode":"87EB43D4B0B19C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72881,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575539831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158181,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1575343681,"is_pvip":false,"replies":[{"id":60635,"content":"呃，这个是C++98就有的东西，现在的书里应该已经讨论得很充分了吧。没有计划单讲，只会在某些话题里约略提到。建议这个就查参考资料了。\n\n而且，我觉得基本概念实际上是相当简单的，就是找最佳匹配而已。有 f(int), f(double), f(const char*)，f(1)、f(1.0) 和 f(&quot;1.0&quot;) 都能找到最合适的函数来调用。复杂在哪里？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575376667,"ip_address":"","comment_id":158181,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师您好 请问后面的学习内容会不会涉及到重载函数和重载运算符呢？感觉这两块不是很好理解呀！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476889,"discussion_content":"返回值优化在没有开启优化编译选项时也是可能发生的。编译器看到这种形式的代码直接统一处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575509253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73828,"discussion_content":"谢谢，受教了，老师的专栏真好，深入才有价值，我目前想对c++11重新学习一遍，因为我在看一些深度学习框架的时候，发现几乎经都已经使用c++11的特性了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575599070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158178,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575342330,"is_pvip":false,"replies":[{"id":60636,"content":"倚天剑有用，但不需要时时刻刻用的。必要的时候，施展一下就行了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575376705,"ip_address":"","comment_id":158178,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"刚刚看了hello world同学的担忧和考虑 然后再看老师的回答 我也想起了我自己的目标是通过努力学习怎么写代码 最后做到不写代码的目标\nc++确实学习成本太高 也比较复杂 但是我记得当时看了个视频,最后课程结束的时候也推荐学习一下c++对于底层的理解会很有帮助, 虽然现在go语言或者是lua语言 学习成本很低 一两天就可以写代码了,那都是别人语言层面已经处理好了的,将底层与我们隔绝了\n所以我努力学c++ 更好的理解底层 也在学go这样才有更多的工作机会 ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476656,"discussion_content":"呃，这个是C++98就有的东西，现在的书里应该已经讨论得很充分了吧。没有计划单讲，只会在某些话题里约略提到。建议这个就查参考资料了。\n\n而且，我觉得基本概念实际上是相当简单的，就是找最佳匹配而已。有 f(int), f(double), f(const char*)，f(1)、f(1.0) 和 f(&amp;quot;1.0&amp;quot;) 都能找到最合适的函数来调用。复杂在哪里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575376667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158096,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575332745,"is_pvip":false,"replies":[{"id":60581,"content":"不完全对。内存里总得放个指针的。\n\n区分值类别确实是为了重载。我目前没想到其他作用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575337223,"ip_address":"","comment_id":158096,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"引用（左值或者右值）仅仅是提供给compiler的一个生成适当机器代码的“提示符号”，在内存和代码的运行过程中，不会有任何的印记，对吗？\n\n区分左值引用，右值引用，除了用在选择重载函数上，还有用在别的地方吗？\n\n谢谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476655,"discussion_content":"倚天剑有用，但不需要时时刻刻用的。必要的时候，施展一下就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575376705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157917,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575282691,"is_pvip":false,"replies":[{"id":60526,"content":"“一个表达式，返回的是右值引用（譬如，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用），这个表达式的value category 是将亡值。” 正确。\n\n引用类型的绑定：\n\n#1非常左值引用可以绑定非const lvalue\n#2常左值引用可以绑定lvalue, xvalue, prvalue\n#3非常右值引用可以绑定非const xvalue, prvalue\n#4常右值引用（不知道是否存在）可以绑定xvalue, prvalue （合法，但我从来没觉得有必要用这种类型过）","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575294633,"ip_address":"","comment_id":157917,"utype":1}],"discussion_count":3,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"请帮忙指正一下：\n\n“一个表达式，返回的是左值引用，这个表达式的value category 是左值。”\n\n一个表达式，返回的是右值引用（譬如，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用），这个表达式的value category 是将亡值。 &lt;—-对吗？\n\n引用类别\n#1非常左值引用\n#2常左值引用 \n#3非常右值引用 \n#4常右值引用（不知道是否存在）\n\nlvalue, xvalue, prvalue,\n分别可以绑定以上四种哪几个？（不知道这种分法是否合理）\n\n非常感谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476630,"discussion_content":"不完全对。内存里总得放个指针的。\n\n区分值类别确实是为了重载。我目前没想到其他作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575337223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158924,"user_name":"宝林","can_delete":false,"product_type":"c1","uid":1302916,"ip_address":"","ucode":"A83691FEE8A8FE","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/84/d549ef5d.jpg","comment_is_top":false,"comment_ctime":1575500848,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"这一节看了三遍，思路太跳跃了，不易读","like_count":36,"discussions":[{"author":{"id":1045869,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/6d/fa3ab44d.jpg","nickname":"徐","note":"","ucode":"4EE8B126738A29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605013,"discussion_content":"如果只看这里的内容，我觉得几乎可以肯定看不懂\n这里的内容基本上是一个知识点串讲，一不完备，二不是按初学者的思路组织的，不适合入门学习","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1676547017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529249,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/a1/e77b9612.jpg","nickname":"峪五","note":"","ucode":"DCF2DC959D0CD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612798,"discussion_content":"没看懂.这个课不值这个钱,极客时间课质量越来越差了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680946640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2642536,"avatar":"https://static001.geekbang.org/account/avatar/00/28/52/68/97107e46.jpg","nickname":"杰","note":"","ucode":"CA6C00F8D724B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383281,"discussion_content":"确实没太看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626022479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163198,"user_name":"张岩","can_delete":false,"product_type":"c1","uid":1314807,"ip_address":"","ucode":"7968C3ECC27CAE","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/f7/7c3e491f.jpg","comment_is_top":false,"comment_ctime":1576668764,"is_pvip":false,"replies":[{"id":62073,"content":"xvalue 是有标识符的。这儿临时对象一直没有标识符，也就一直是 prvalue。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576681806,"ip_address":"","comment_id":163198,"utype":1}],"discussion_count":4,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"int main()\n{\n    A&amp;&amp; a = static_cast&lt;A&amp;&amp;&gt;(GetA());\n    cout&lt;&lt;&quot;main end&quot;&lt;&lt;endl;\n    a.func();\n    return 0;\n}\n\ng++ -g -std=c++11  construct.cpp ;.&#47;a.out \nconstruct: 1\nmain end\nfunc: 1\ndestruct: 1\n\n老师您好，请问下，为什么上面的这种情况xvalue的生命周期被延长了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478292,"discussion_content":"xvalue 是有标识符的。这儿临时对象一直没有标识符，也就一直是 prvalue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576681806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198804,"discussion_content":"好问题啊，查到了以下这个解释：https://stackoverflow.com/questions/42441791/lifetime-extension-prvalues-and-xvalues\n理解得不太透彻，但是可能大概是，本来xvalue也可以绑定到引用并延长周期，但std:move()这一层函数扰乱了本来的生命期推断，我猜想可能是本来prvalue绑定是一个表达式，prvalue在绑定前都还在表达式中，但是有一层std::move以后，prvalue所在的表达式就在传入std::move之后就算是complete了，所以prvalue的生命期可能就只存在于std::move执行过程中了。。。总之我觉得std::move还是只用在lvalue上比较靠谱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583511891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314807,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/f7/7c3e491f.jpg","nickname":"张岩","note":"","ucode":"7968C3ECC27CAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91069,"discussion_content":"https://zh.cppreference.com/w/cpp/language/value_category\n下列表达式是亡值表达式：\n        返回类型为对象的右值引用的函数调用或重载运算符表达式，例如 std::move(x)；\n        转换为对象的右值引用类型的转型表达式，例如 static_cast<char&amp;&amp;>(x)\n这个static_cast<T&amp;&amp;>表达式是不是只对左值有效可不可以这么理解。\nA&amp;&amp; return_rvalue(A&amp;&amp; a){\n    cout<<&#34;return_rvalue&#34;<<endl;\n    return static_cast<A&amp;&amp;>(a);\n}​\n我自己封装成一个方法，return_rvalue返回的就是一个xvalue\n\n我现在疑惑的是为什么static_cast<T&amp;&amp;>转型后不是一个xvalue，\n求老师解答。感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576808140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314807,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/f7/7c3e491f.jpg","nickname":"张岩","note":"","ucode":"7968C3ECC27CAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88620,"discussion_content":"construct.cpp:54:37: error: taking address of xvalue (rvalue reference)\n     cout<<&amp;(static_cast<A&amp;&amp;>(GetA()))<<endl;\n为啥编译器提示这是一个xvalue。\n老师再指点一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576721203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161526,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1576223815,"is_pvip":false,"replies":[{"id":61556,"content":"我觉得我做不到比文中更清楚了（否则我就写进去了）。😅\n\n多看例子来体会一下吧……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576275900,"ip_address":"","comment_id":161526,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师，我对左值、右值、移动的区别很懵。可以简单的说下吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477750,"discussion_content":"我觉得我做不到比文中更清楚了（否则我就写进去了）。😅\n\n多看例子来体会一下吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576275900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160640,"user_name":"王小白白白","can_delete":false,"product_type":"c1","uid":1140277,"ip_address":"","ucode":"7049DA34B12208","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/35/1b14f2af.jpg","comment_is_top":false,"comment_ctime":1575991285,"is_pvip":false,"replies":[{"id":61304,"content":"内存复制，memcpy、strcpy 这样的操作。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022910,"ip_address":"","comment_id":160640,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师，string拼接那里，复制指的是？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477443,"discussion_content":"内存复制，memcpy、strcpy 这样的操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576022910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159026,"user_name":"じJRisenづジ","can_delete":false,"product_type":"c1","uid":1401105,"ip_address":"","ucode":"87EB43D4B0B19C","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/11/85386508.jpg","comment_is_top":false,"comment_ctime":1575517130,"is_pvip":false,"replies":[{"id":60857,"content":"https:&#47;&#47;github.com&#47;adah1972&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575539766,"ip_address":"","comment_id":159026,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师您的github 是？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476919,"discussion_content":"https://github.com/adah1972/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575539766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401105,"avatar":"https://static001.geekbang.org/account/avatar/00/15/61/11/85386508.jpg","nickname":"じJRisenづジ","note":"","ucode":"87EB43D4B0B19C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72881,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575539831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158906,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575476317,"is_pvip":false,"replies":[{"id":60817,"content":"返回值优化在没有开启优化编译选项时也是可能发生的。编译器看到这种形式的代码直接统一处理了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575509253,"ip_address":"","comment_id":158906,"utype":1}],"discussion_count":2,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"Obj simple()\n{\n  Obj obj;\n  &#47;&#47;  简单返回对象；一般有  NRVO\n  return obj;\n}\n\nauto obj1 = simple();\n\n请问这个不应该是会调用一次构造和拷贝构造吗，因为函数返回对象Obj是用了函数内部的obj进行拷贝构造，而返回的这个对象被直接优化给了obj1而没有调用构造函数\n那么如果没有优化应该是两次构造，一次拷贝构造才对啊，感觉","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476889,"discussion_content":"返回值优化在没有开启优化编译选项时也是可能发生的。编译器看到这种形式的代码直接统一处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575509253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73828,"discussion_content":"谢谢，受教了，老师的专栏真好，深入才有价值，我目前想对c++11重新学习一遍，因为我在看一些深度学习框架的时候，发现几乎经都已经使用c++11的特性了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575599070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158181,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1575343681,"is_pvip":false,"replies":[{"id":60635,"content":"呃，这个是C++98就有的东西，现在的书里应该已经讨论得很充分了吧。没有计划单讲，只会在某些话题里约略提到。建议这个就查参考资料了。\n\n而且，我觉得基本概念实际上是相当简单的，就是找最佳匹配而已。有 f(int), f(double), f(const char*)，f(1)、f(1.0) 和 f(&quot;1.0&quot;) 都能找到最合适的函数来调用。复杂在哪里？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575376667,"ip_address":"","comment_id":158181,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师您好 请问后面的学习内容会不会涉及到重载函数和重载运算符呢？感觉这两块不是很好理解呀！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476656,"discussion_content":"呃，这个是C++98就有的东西，现在的书里应该已经讨论得很充分了吧。没有计划单讲，只会在某些话题里约略提到。建议这个就查参考资料了。\n\n而且，我觉得基本概念实际上是相当简单的，就是找最佳匹配而已。有 f(int), f(double), f(const char*)，f(1)、f(1.0) 和 f(&amp;quot;1.0&amp;quot;) 都能找到最合适的函数来调用。复杂在哪里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575376667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158178,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575342330,"is_pvip":false,"replies":[{"id":60636,"content":"倚天剑有用，但不需要时时刻刻用的。必要的时候，施展一下就行了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575376705,"ip_address":"","comment_id":158178,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"刚刚看了hello world同学的担忧和考虑 然后再看老师的回答 我也想起了我自己的目标是通过努力学习怎么写代码 最后做到不写代码的目标\nc++确实学习成本太高 也比较复杂 但是我记得当时看了个视频,最后课程结束的时候也推荐学习一下c++对于底层的理解会很有帮助, 虽然现在go语言或者是lua语言 学习成本很低 一两天就可以写代码了,那都是别人语言层面已经处理好了的,将底层与我们隔绝了\n所以我努力学c++ 更好的理解底层 也在学go这样才有更多的工作机会 ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476655,"discussion_content":"倚天剑有用，但不需要时时刻刻用的。必要的时候，施展一下就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575376705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158096,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575332745,"is_pvip":false,"replies":[{"id":60581,"content":"不完全对。内存里总得放个指针的。\n\n区分值类别确实是为了重载。我目前没想到其他作用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575337223,"ip_address":"","comment_id":158096,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"引用（左值或者右值）仅仅是提供给compiler的一个生成适当机器代码的“提示符号”，在内存和代码的运行过程中，不会有任何的印记，对吗？\n\n区分左值引用，右值引用，除了用在选择重载函数上，还有用在别的地方吗？\n\n谢谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476630,"discussion_content":"不完全对。内存里总得放个指针的。\n\n区分值类别确实是为了重载。我目前没想到其他作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575337223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157917,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575282691,"is_pvip":false,"replies":[{"id":60526,"content":"“一个表达式，返回的是右值引用（譬如，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用），这个表达式的value category 是将亡值。” 正确。\n\n引用类型的绑定：\n\n#1非常左值引用可以绑定非const lvalue\n#2常左值引用可以绑定lvalue, xvalue, prvalue\n#3非常右值引用可以绑定非const xvalue, prvalue\n#4常右值引用（不知道是否存在）可以绑定xvalue, prvalue （合法，但我从来没觉得有必要用这种类型过）","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575294633,"ip_address":"","comment_id":157917,"utype":1}],"discussion_count":3,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"请帮忙指正一下：\n\n“一个表达式，返回的是左值引用，这个表达式的value category 是左值。”\n\n一个表达式，返回的是右值引用（譬如，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用），这个表达式的value category 是将亡值。 &lt;—-对吗？\n\n引用类别\n#1非常左值引用\n#2常左值引用 \n#3非常右值引用 \n#4常右值引用（不知道是否存在）\n\nlvalue, xvalue, prvalue,\n分别可以绑定以上四种哪几个？（不知道这种分法是否合理）\n\n非常感谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476577,"discussion_content":"“一个表达式，返回的是右值引用（譬如，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用），这个表达式的value category 是将亡值。” 正确。\n\n引用类型的绑定：\n\n#1非常左值引用可以绑定非const lvalue\n#2常左值引用可以绑定lvalue, xvalue, prvalue\n#3非常右值引用可以绑定非const xvalue, prvalue\n#4常右值引用（不知道是否存在）可以绑定xvalue, prvalue （合法，但我从来没觉得有必要用这种类型过）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575294633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72005,"discussion_content":"都可行的情况下，自然是选择最“合适”的重载了。右值自然会选择右值引用的重载。如果两个重载都同样可行的话，编译器就会报错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575468188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69737,"discussion_content":"\ntemplate <typename U>\nsmart_ptr(const smart_ptr<U>&amp; other) \n<—常左值引用\n\ntemplate <typename U>\nsmart_ptr(smart_ptr<U>&amp;&amp; other) \n<—非常右值引用\n\n“#2常左值引用可以绑定lvalue, xvalue, prvalue\n#3非常右值引用可以绑定非const xvalue, prvalue” \n<—— 也就是说，非const xvalue可以绑定 常左值引用 或 非常右值引用，对吗？\n\n“\nsmart_ptr<shape> ptr1{new circle()};\nsmart_ptr<shape> ptr2 = std::move(ptr1);”\n\nstd::move(ptr1) 这个表达式是，非const xvalue, 对吗？\n\n为什么构造ptr2会选择第二个重载（非常右值引用），而不是第一个重载（常左值引用）？\n\n谢谢！\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575297920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158924,"user_name":"宝林","can_delete":false,"product_type":"c1","uid":1302916,"ip_address":"","ucode":"A83691FEE8A8FE","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/84/d549ef5d.jpg","comment_is_top":false,"comment_ctime":1575500848,"is_pvip":false,"replies":null,"discussion_count":3,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"这一节看了三遍，思路太跳跃了，不易读","like_count":36,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476577,"discussion_content":"“一个表达式，返回的是右值引用（譬如，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用），这个表达式的value category 是将亡值。” 正确。\n\n引用类型的绑定：\n\n#1非常左值引用可以绑定非const lvalue\n#2常左值引用可以绑定lvalue, xvalue, prvalue\n#3非常右值引用可以绑定非const xvalue, prvalue\n#4常右值引用（不知道是否存在）可以绑定xvalue, prvalue （合法，但我从来没觉得有必要用这种类型过）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575294633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72005,"discussion_content":"都可行的情况下，自然是选择最“合适”的重载了。右值自然会选择右值引用的重载。如果两个重载都同样可行的话，编译器就会报错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575468188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69737,"discussion_content":"\ntemplate <typename U>\nsmart_ptr(const smart_ptr<U>&amp; other) \n<—常左值引用\n\ntemplate <typename U>\nsmart_ptr(smart_ptr<U>&amp;&amp; other) \n<—非常右值引用\n\n“#2常左值引用可以绑定lvalue, xvalue, prvalue\n#3非常右值引用可以绑定非const xvalue, prvalue” \n<—— 也就是说，非const xvalue可以绑定 常左值引用 或 非常右值引用，对吗？\n\n“\nsmart_ptr<shape> ptr1{new circle()};\nsmart_ptr<shape> ptr2 = std::move(ptr1);”\n\nstd::move(ptr1) 这个表达式是，非const xvalue, 对吗？\n\n为什么构造ptr2会选择第二个重载（非常右值引用），而不是第一个重载（常左值引用）？\n\n谢谢！\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575297920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365875,"user_name":"petit_kayak","can_delete":false,"product_type":"c1","uid":1025214,"ip_address":"江苏","ucode":"6889CCCBFA0180","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/be/39cc22f5.jpg","comment_is_top":false,"comment_ctime":1673167773,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"感觉右值引用是一种对于所有权的精细化控制，在rust中移动已经是对象赋值操作的默认行为方式。","like_count":1},{"had_liked":false,"id":242346,"user_name":"四有青年","can_delete":false,"product_type":"c1","uid":2004350,"ip_address":"","ucode":"121A7C613E6C32","user_header":"https://static001.geekbang.org/account/avatar/00/1e/95/7e/1057f77a.jpg","comment_is_top":false,"comment_ctime":1597676832,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"老师讲得很好。第一遍有些迷惑，看完接着过一下讨论区，再复读一遍，就可以基本的了解这些内容。","like_count":1},{"had_liked":false,"id":359937,"user_name":"dragon","can_delete":false,"product_type":"c1","uid":1042114,"ip_address":"北京","ucode":"FC8AB417A9E110","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu7SYgsvC9IY5AicAlCtoMGj7znhgo6IZu51XTFxPasFrJr3WPPqusBBicC0rJ3U2la6JRd3qWse1w/132","comment_is_top":false,"comment_ctime":1666078641,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"干货很多，比较烧脑，需要反复学习下","like_count":0},{"had_liked":false,"id":355392,"user_name":"Wynter","can_delete":false,"product_type":"c1","uid":1298909,"ip_address":"浙江","ucode":"230E04AABF0F1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/d1/dd/295e5d2b.jpg","comment_is_top":false,"comment_ctime":1661331248,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"看了不下10遍，终于能全部理解了","like_count":0},{"had_liked":false,"id":347297,"user_name":"ReCharge","can_delete":false,"product_type":"c1","uid":1712470,"ip_address":"","ucode":"07DACA0F8BA65D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","comment_is_top":false,"comment_ctime":1653907195,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"听君一席话，胜似一席话","like_count":0},{"had_liked":false,"id":344561,"user_name":"Geek_724748","can_delete":false,"product_type":"c1","uid":2342698,"ip_address":"","ucode":"E5D8842A0D1733","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hdTp0C9o8CmNhDW4VOly0sI2xn6ibGKqGH3HvalmYTbjF3auUt6iaibQkLv9tI0YicJ7vKhmoAVianzLJ2wMAOzaNOA/132","comment_is_top":false,"comment_ctime":1651648922,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"主要讲了什么是左值，什么是右值，以及使用右值带来的好处，最后说到了完美转发（原先是什么类型，就使用什么类型，而不会造成原来是右值，传参却变成左值的问题）","like_count":0},{"had_liked":false,"id":289783,"user_name":"Jonathan","can_delete":false,"product_type":"c1","uid":1484965,"ip_address":"","ucode":"031E0DC776E8A0","user_header":"https://static001.geekbang.org/account/avatar/00/16/a8/a5/27466113.jpg","comment_is_top":false,"comment_ctime":1619174072,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"太强了，能理解这一篇的应该是对C++理解比较好的了。","like_count":0},{"had_liked":false,"id":158615,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1575423170,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"虽然我不会c++ 但我依然觉得老师讲的很好","like_count":0},{"had_liked":false,"id":365875,"user_name":"petit_kayak","can_delete":false,"product_type":"c1","uid":1025214,"ip_address":"江苏","ucode":"6889CCCBFA0180","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/be/39cc22f5.jpg","comment_is_top":false,"comment_ctime":1673167773,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"感觉右值引用是一种对于所有权的精细化控制，在rust中移动已经是对象赋值操作的默认行为方式。","like_count":1},{"had_liked":false,"id":242346,"user_name":"四有青年","can_delete":false,"product_type":"c1","uid":2004350,"ip_address":"","ucode":"121A7C613E6C32","user_header":"https://static001.geekbang.org/account/avatar/00/1e/95/7e/1057f77a.jpg","comment_is_top":false,"comment_ctime":1597676832,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"老师讲得很好。第一遍有些迷惑，看完接着过一下讨论区，再复读一遍，就可以基本的了解这些内容。","like_count":1},{"had_liked":false,"id":359937,"user_name":"dragon","can_delete":false,"product_type":"c1","uid":1042114,"ip_address":"北京","ucode":"FC8AB417A9E110","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLu7SYgsvC9IY5AicAlCtoMGj7znhgo6IZu51XTFxPasFrJr3WPPqusBBicC0rJ3U2la6JRd3qWse1w/132","comment_is_top":false,"comment_ctime":1666078641,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"干货很多，比较烧脑，需要反复学习下","like_count":0},{"had_liked":false,"id":355392,"user_name":"Wynter","can_delete":false,"product_type":"c1","uid":1298909,"ip_address":"浙江","ucode":"230E04AABF0F1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/d1/dd/295e5d2b.jpg","comment_is_top":false,"comment_ctime":1661331248,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"看了不下10遍，终于能全部理解了","like_count":0},{"had_liked":false,"id":347297,"user_name":"ReCharge","can_delete":false,"product_type":"c1","uid":1712470,"ip_address":"","ucode":"07DACA0F8BA65D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","comment_is_top":false,"comment_ctime":1653907195,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"听君一席话，胜似一席话","like_count":0},{"had_liked":false,"id":344561,"user_name":"Geek_724748","can_delete":false,"product_type":"c1","uid":2342698,"ip_address":"","ucode":"E5D8842A0D1733","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hdTp0C9o8CmNhDW4VOly0sI2xn6ibGKqGH3HvalmYTbjF3auUt6iaibQkLv9tI0YicJ7vKhmoAVianzLJ2wMAOzaNOA/132","comment_is_top":false,"comment_ctime":1651648922,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"主要讲了什么是左值，什么是右值，以及使用右值带来的好处，最后说到了完美转发（原先是什么类型，就使用什么类型，而不会造成原来是右值，传参却变成左值的问题）","like_count":0},{"had_liked":false,"id":289783,"user_name":"Jonathan","can_delete":false,"product_type":"c1","uid":1484965,"ip_address":"","ucode":"031E0DC776E8A0","user_header":"https://static001.geekbang.org/account/avatar/00/16/a8/a5/27466113.jpg","comment_is_top":false,"comment_ctime":1619174072,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"太强了，能理解这一篇的应该是对C++理解比较好的了。","like_count":0},{"had_liked":false,"id":158615,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1575423170,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"虽然我不会c++ 但我依然觉得老师讲的很好","like_count":0}]}