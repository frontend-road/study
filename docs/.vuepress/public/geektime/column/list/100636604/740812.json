{"id":740812,"title":"第 11 章 特型与泛型(2)","content":"<h2 id=\"nav_point_195\">11.4　定义类型之间关系的特型</h2>\n<p>迄今为止，我们看到的每个特型都是独立的：特型是类型可以实现的一组方法。特型也可以用于多种类型必须协同工作的场景中。它们可以描述多个类型之间的关系。</p>\n<ul>\n<li><code>std::iter::Iterator</code> 特型会为每个迭代器类型与其生成的值的类型建立联系。</li>\n<li><code>std::ops::Mul</code> 特型与可以相乘的类型有关。在表达式 <code>a * b</code> 中，值 <code>a</code> 和 <code>b</code> 可以是相同类型，也可以是不同类型。</li>\n<li><code>rand</code> crate 中包含随机数生成器的特型（<code>rand::Rng</code>）和可被随机生成的类型的特型（<code>rand::Distribution</code>）。这些特型本身就准确地定义了它们是如何协同工作的。</li>\n</ul>\n<p>你不需要每天都创建这样的特型，但它们在整个标准库和第三方 crate 中随处可见。本节将展示每一个示例是如何实现的，并根据需要来展开讲解相关的 Rust 语言特性。你需要掌握的关键技能是能够阅读这些特型和方法签名，并理解它们对所涉及的类型意味着什么。</p>\n<h3 id=\"nav_point_196\">11.4.1　关联类型（或迭代器的工作原理）</h3>\n<p>接下来我们从迭代器讲起。迄今为止，每种面向对象的语言都内置了某种对迭代器的支持，迭代器是用以遍历某种值序列的对象。</p>\n<p>Rust 有一个标准的 <code>Iterator</code> 特型，定义如下：</p>\n<pre class=\"code-rows\"><code>pub trait Iterator {\n    type Item;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n    ...\n}</code></pre>\n<p>这个特型的第一个特性（<code>type Item;</code>）是一个<strong>关联类型</strong>。实现了 <code>Iterator</code> 的每种类型都必须指定它所生成的条目的类型。</p>\n<p>第二个特性（<code>next()</code> 方法）在其返回值中使用了关联类型。<code>next()</code> 会返回一个 <code>Option&lt;Self::Item&gt;</code>：或者是序列中的下一个值 <code>Some(item)</code>，或者当没有更多值可供访问时返回 <code>None</code>。该类型要写成 <code>Self::Item</code>，而不仅仅是无修饰的 <code>Item</code>，因为这里的 <code>Item</code> 是每个迭代器类型下的一个特性，而不是一个独立的类型。同样，<code>self</code> 和 <code>Self</code> 类型在代码中任何使用了其字段、方法等的地方都要像这样显式写出来。</p>\n<p>下面是为一个类型实现 <code>Iterator</code> 的范例：</p>\n<pre class=\"code-rows\"><code>//（来自标准库中std::env模块的代码）\nimpl Iterator for Args {\n    type Item = String;\n\n    fn next(&amp;mut self) -&gt; Option&lt;String&gt; {\n        ...\n    }\n    ...\n}</code></pre>\n<p><code>std::env::Args</code> 是我们在第 2 章中用来访问命令行参数的标准库函数 <code>std::env::args()</code> 返回的迭代器类型。它能生成 <code>String</code> 值，因此这个 <code>impl</code> 声明了 <code>type Item = String;</code>。</p><!-- [[[read_end]]] -->\n<p>泛型代码可以使用关联类型：</p>\n<pre class=\"code-rows\"><code>/// 遍历迭代器，将值存储在新向量中\nfn collect_into_vector&lt;I: Iterator&gt;(iter: I) -&gt; Vec&lt;I::Item&gt; {\n    let mut results = Vec::new();\n    for value in iter {\n        results.push(value);\n    }\n    results\n}</code></pre>\n<p>在这个函数体中，Rust 为我们推断出了 <code>value</code> 的类型，这固然不错，但我们还必须明确写出 <code>collect_into_vector</code> 的返回类型，而 <code>Item</code> 关联类型是唯一的途径。（用 <code>Vec&lt;I&gt;</code> 肯定不对，因为那样是在宣告要返回一个由迭代器组成的向量。）</p>\n<p>前面示例中的代码并不需要你自己编写，因为在阅读第 15 章之后，你会知道迭代器已经有了一个执行此操作的标准方法：<code>iter.collect()</code>。在继续之前，再来看一个例子：</p>\n<pre class=\"code-rows\"><code>/// 打印出迭代器生成的所有值\nfn dump&lt;I&gt;(iter: I)\n    where I: Iterator\n{\n    for (index, value) in iter.enumerate() {\n        println!(\"{}: {:?}\", index, value);   // 错误\n    }\n}</code></pre>\n<p>这几乎已经改好了。但还有一个问题：<code>value</code> 不一定是可打印的类型。</p>\n<pre class=\"code-rows\"><code>error: `&lt;I as Iterator&gt;::Item` doesn't implement `Debug`\n  |\n8 |         println!(\"{}: {:?}\", index, value);   // 错误\n  |                                     ^^^^^\n  |                          `&lt;I as Iterator&gt;::Item` cannot be formatted\n  |                          using `{:?}` because it doesn't implement `Debug`\n  |\n  = help: the trait `Debug` is not implemented for `&lt;I as Iterator&gt;::Item`\n  = note: required by `std::fmt::Debug::fmt`\nhelp: consider further restricting the associated type\n  |\n5 |     where I: Iterator, &lt;I as Iterator&gt;::Item: Debug\n  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>\n<p>由于 Rust 使用了语法 <code>&lt;I as Iterator&gt;::Item</code>（<code>I::Item</code> 的一种明确但冗长的说法），因此错误消息被弄得稍微有点儿乱。虽然这是有效的 Rust 语法，但实际上你很少需要以这种方式书写类型。</p>\n<p>这个错误消息的要点是，要编译此泛型函数，就必须确保 <code>I::Item</code> 实现了 <code>Debug</code> 特型，也就是用 <code>{:?}</code> 格式化值时要求的特型。正如错误消息所暗示的那样，我们可以通过在 <code>I::Item</code> 上设置一个限界来做到这一点：</p>\n<pre class=\"code-rows\"><code>use std::fmt::Debug;\n\nfn dump&lt;I&gt;(iter: I)\n    where I: Iterator, I::Item: Debug\n{\n    ...\n}</code></pre>\n<p>或者，我们可以说“<code>I</code> 必须是针对 <code>String</code> 值的迭代器”：</p>\n<pre class=\"code-rows\"><code>fn dump&lt;I&gt;(iter: I)\n    where I: Iterator&lt;Item=String&gt;\n{\n    ...\n}</code></pre>\n<p><code>Iterator&lt;Item=String&gt;</code> 本身就是一个特型。如果将 <code>Iterator</code> 视为所有迭代器类型的全集，那么 <code>Iterator&lt;Item=String&gt;</code> 就是 <code>Iterator</code> 的子集：生成 <code>String</code> 的迭代器类型的集合。此语法可用于任何可以使用特型名称（包括特型对象类型）的地方：</p>\n<pre class=\"code-rows\"><code>fn dump(iter: &amp;mut dyn Iterator&lt;Item=String&gt;) {\n    for (index, s) in iter.enumerate() {\n        println!(\"{}: {:?}\", index, s);\n    }\n}</code></pre>\n<p>具有关联类型的特型（如 <code>Iterator</code>）与特型对象是兼容的，但前提是要把所有关联类型都明确写出来，就像此处所展示的那样。否则，<code>s</code> 的类型可能是任意类型，同样，这会导致 Rust 无法对这段代码进行类型检查。</p>\n<p>我们已经展示了很多涉及迭代器的示例。之所以花了这么多篇幅，是因为迭代器是迄今为止使用关联类型的最主要场景。但当特型需要包含的不仅仅是方法的时候，关联类型会很有用。</p>\n<ul>\n<li>在线程池库中，<code>Task</code> 特型表示一个工作单元，它可以包含一个关联的 <code>Output</code> 类型。</li>\n<li><p><code>Pattern</code> 特型表示一种搜索字符串的方式，它可以包含一个关联的 <code>Match</code> 类型，后者表示将模式与字符串匹配后收集到的所有信息。</p>\n<pre class=\"code-rows\"><code>trait Pattern {\n    type Match;\n\n    fn search(&amp;self, string: &amp;str) -&gt; Option&lt;Self::Match&gt;;\n}\n\n/// 你可以在字符串中找一个特定的字符\nimpl Pattern for char {\n    /// Match只是找到的字符的位置\n    type Match = usize;\n\n    fn search(&amp;self, string: &amp;str) -&gt; Option&lt;usize&gt; {\n        ...\n    }\n}</code></pre>\n<p>如果你熟悉正则表达式，那么很容易看出 <code>impl Pattern for RegExp</code> 应该有一个更精细的 <code>Match</code> 类型，它可能是一个结构体，其中包含此匹配的开始位置和长度、圆括号组匹配的位置等。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>用于处理关系型数据库的库可能具有 <code>DatabaseConnection</code> 特型，其关联类型表示事务、游标、已准备语句等。</p>\n</li>\n</ul>\n<p>关联类型非常适合每个实现都有<strong>一个</strong>特定相关类型的情况：每种类型的 <code>Task</code> 都会生成特定类型的 <code>Output</code>，每种类型的 <code>Pattern</code> 都会寻找特定类型的 <code>Match</code>。然而，如你所见，类型之间的某些关系并不是这样的。</p>\n<h3 id=\"nav_point_197\">11.4.2　泛型特型（或运算符重载的工作原理）</h3>\n<p>Rust 中的乘法使用了以下特型：</p>\n<pre class=\"code-rows\"><code>/// std::ops::Mul，用于标记支持`*`（乘号）的类型的特型\npub trait Mul&lt;RHS&gt; {\n    /// 在应用了`*`运算符后的结果类型\n    type Output;\n\n    /// 实现`*`运算符的方法\n    fn mul(self, rhs: RHS) -&gt; Self::Output;\n}</code></pre>\n<p><code>Mul</code> 是一个泛型特型。类型参数 <code>RHS</code> 是<strong>右操作数</strong>（right-hand side）的缩写。</p>\n<p>这里的类型参数与它在结构体或函数上的含义是一样的：<code>Mul</code> 是一个泛型特型，它的实例 <code>Mul&lt;f64&gt;</code>、<code>Mul&lt;String&gt;</code>、<code>Mul&lt;Size&gt;</code> 等都是不同的特型，就像 <code>min::&lt;i32&gt;</code> 和 <code>min::&lt;String&gt;</code> 是不同的函数，<code>Vec&lt;i32&gt;</code> 和 <code>Vec&lt;String&gt;</code> 是不同的类型一样。</p>\n<p>单一类型（如 <code>WindowSize</code>）可以同时实现 <code>Mul&lt;f64&gt;</code>、<code>Mul&lt;i32&gt;</code>，等等。然后你就可以将 <code>WindowSize</code> 乘以许多其他类型。每个实现都有自己关联的 <code>Output</code> 类型。</p>\n<p>泛型特型在涉及孤儿规则时会得到特殊豁免：你可以为外部类型实现外部特型，只要特型的类型参数之一是当前 crate 中定义的类型即可。因此，如果你自己定义了 <code>WindowSize</code>，则可以为 <code>f64</code> 实现 <code>Mul&lt;WindowSize&gt;</code>，即使你既没有定义 <code>Mul</code> 也没有定义 <code>f64</code>。这些实现甚至可以是泛型的，比如 <code>impl&lt;T&gt; Mul&lt;WindowSize&gt; for Vec&lt;T&gt;</code>。这是可行的，因为其他 crate 不可能在任何东西上定义 <code>Mul&lt;WindowSize&gt;</code>，因此实现之间不可能出现冲突。（11.2.2 节介绍过孤儿规则。）这就是像 <code>nalgebra</code> 这样的 crate 能为向量定义算术运算的原理。</p>\n<p>前面展示的特型缺少一个小细节。真正的 <code>Mul</code> 特型是这样的：</p>\n<pre class=\"code-rows\"><code>pub trait Mul&lt;RHS=Self&gt; {\n    ...\n}</code></pre>\n<p>语法 <code>RHS=Self</code> 表示 <code>RHS</code> 默认为 <code>Self</code>。如果我写下 <code>impl Mul for Complex</code>，而不指定 <code>Mul</code> 的类型参数，则表示 <code>impl Mul&lt;Complex&gt; for Complex</code>。在类型限界中，如果我写下 <code>where T: Mul</code>，则表示 <code>where T: Mul&lt;T&gt;</code>。</p>\n<p>在 Rust 中，表达式 <code>lhs * rhs</code> 是 <code>Mul::mul(lhs, rhs)</code> 的简写形式。所以在 Rust 中重载 <code>*</code> 运算符就像实现 <code>Mul</code> 特型一样简单。第 12 章会展示相关示例。</p>\n<h3 id=\"nav_point_198\">11.4.3　<code>impl Trait</code></h3>\n<p>如你所料，由许多泛型类型组合而成的结果可能会极其凌乱。例如，使用标准库的组合器组合上几个迭代器，就会迅速把你的返回类型变成一个“丑八怪”：</p>\n<pre class=\"code-rows\"><code>use std::iter;\nuse std::vec::IntoIter;\nfn cyclical_zip(v: Vec&lt;u8&gt;, u: Vec&lt;u8&gt;) -&gt;\n    iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;u8&gt;, IntoIter&lt;u8&gt;&gt;&gt; {\n        v.into_iter().chain(u.into_iter()).cycle()\n}</code></pre>\n<p>我们可以很容易地用特型对象替换这个“丑陋的”返回类型：</p>\n<pre class=\"code-rows\"><code>fn cyclical_zip(v: Vec&lt;u8&gt;, u: Vec&lt;u8&gt;) -&gt; Box&lt;dyn Iterator&lt;Item=u8&gt;&gt; {\n    Box::new(v.into_iter().chain(u.into_iter()).cycle())\n}</code></pre>\n<p>然而，在大多数情况下，如果仅仅是为了避免“丑陋的”类型签名，就要在每次调用这个函数时承受动态派发和不可避免的堆分配开销，可不太划算。</p>\n<p>Rust 有一个名为 <code>impl Trait</code> 的特性，该特性正是为应对这种情况而设计的。<code>impl Trait</code> 允许我们“擦除”返回值的类型，仅指定它实现的一个或多个特型，而无须进行动态派发或堆分配：</p>\n<pre class=\"code-rows\"><code>fn cyclical_zip(v: Vec&lt;u8&gt;, u: Vec&lt;u8&gt;) -&gt; impl Iterator&lt;Item=u8&gt; {\n    v.into_iter().chain(u.into_iter()).cycle()\n}</code></pre>\n<p>现在，<code>cyclical_zip</code> 的签名中再也没有那种带着迭代器组合结构的嵌套类型了，而只是声明它会返回某种 <code>u8</code> 迭代器。返回类型表达了函数的意图，而非实现细节。</p>\n<p>这无疑清理了代码并提高了可读性，但 <code>impl Trait</code> 可不止是一个方便的简写形式。使用 <code>impl Trait</code> 意味着你将来可以更改返回的实际类型，只要返回类型仍然会实现 <code>Iterator&lt;Item=u8&gt;</code>，调用该函数的任何代码就能继续编译而不会出现问题。这就为库作者提供了很大的灵活性，因为其类型签名中只编码了有意义的功能。</p>\n<p>如果库的第一个版本像前面那样使用迭代器的组合器，但后来发现了针对同一过程的更好算法，则库作者可能会改用不同的组合器，甚至会创建一个能实现 <code>Iterator</code> 的自定义类型，但只要当初使用了 <code>impl Trait</code> 来编写签名，库的用户根本不必更改代码就能获得性能改进。</p>\n<p>使用 <code>impl Trait</code> 来为面向对象语言中常用的工厂模式模仿出一个静态派发版本可能是个诱人的想法。例如，你可能会想定义如下特型：</p>\n<pre class=\"code-rows\"><code>trait Shape {\n    fn new() -&gt; Self;\n    fn area(&amp;self) -&gt; f64;\n}</code></pre>\n<p>在为几种类型实现了 <code>Shape</code> 之后，你可能希望根据某个运行期的值（比如用户输入的字符串）使用不同的 <code>Shape</code>。但以 <code>impl Shape</code> 作为返回类型并不能实现这一目标：</p>\n<pre class=\"code-rows\"><code>fn make_shape(shape: &amp;str) -&gt; impl Shape {\n    match shape {\n        \"circle\" =&gt; Circle::new(),\n        \"triangle\" =&gt; Triangle::new(), // 错误：不兼容的类型\n        \"shape\" =&gt; Rectangle::new(),\n    }\n}</code></pre>\n<p>从调用者的角度来看，这样的函数没有多大意义。<code>impl Trait</code> 是一种静态派发形式，因此编译器必须在编译期就知道从函数返回的类型，以便在栈上分配正确的空间数量并正确访问该类型的字段和方法。在这里，这个类型可能是 <code>Circle</code>、<code>Triangle</code> 或 <code>Rectangle</code>，它们可能占用不同的空间大小，并且有着不同的 <code>area()</code> 实现。</p>\n<p>这里的要点是，Rust 不允许特型方法使用 <code>impl Trait</code> 作为返回值。要支持这个特性，就要对语言的类型系统进行一些改进。在这项工作完成之前，只有自由函数和关联具体类型的函数才能使用 <code>impl Trait</code> 作为返回值。</p>\n<p><code>impl Trait</code> 也可以用在带有泛型参数的函数中。例如，考虑下面这个简单的泛型函数：</p>\n<pre class=\"code-rows\"><code>fn print&lt;T: Display&gt;(val: T) {\n    println!(\"{}\", val);\n}</code></pre>\n<p>它与使用 <code>impl Trait</code> 的版本完全相同：</p>\n<pre class=\"code-rows\"><code>fn print(val: impl Display) {\n    println!(\"{}\", val);\n}</code></pre>\n<p>但有一个重要的例外。使用泛型时允许函数的调用者指定泛型参数的类型，比如 <code>print::&lt;i32&gt;(42)</code>，而如果使用 <code>impl Trait</code> 则不能这样做。</p>\n<p>每个 <code>impl Trait</code> 参数都被赋予了自己独有的匿名类型参数，因此，只有在最简单的泛型函数中才能把 <code>impl Trait</code> 参数用作类型，参数的类型之间不能存在关系。</p>\n<h3 id=\"nav_point_199\">11.4.4　关联常量</h3>\n<p>与结构体和枚举一样，特型也可以有关联常量。你可以使用与结构体或枚举相同的语法来声明带有关联常量的特型：</p>\n<pre class=\"code-rows\"><code>trait Greet {\n    const GREETING: &amp;'static str = \"Hello\";\n    fn greet(&amp;self) -&gt; String;\n}</code></pre>\n<p>不过，关联常量在特型中具有特殊的功能。与关联类型和函数一样，你也可以声明它们，但不为其定义值：</p>\n<pre class=\"code-rows\"><code>trait Float {\n    const ZERO: Self;\n    const ONE: Self;\n}</code></pre>\n<p>之后，特型的实现者可以定义这些值：</p>\n<pre class=\"code-rows\"><code>impl Float for f32 {\n    const ZERO: f32 = 0.0;\n    const ONE: f32 = 1.0;\n}\n\nimpl Float for f64 {\n    const ZERO: f64 = 0.0;\n    const ONE: f64 = 1.0;\n}</code></pre>\n<p>你可以编写使用这些值的泛型代码：</p>\n<pre class=\"code-rows\"><code>fn add_one&lt;T: Float + Add&lt;Output=T&gt;&gt;(value: T) -&gt; T {\n    value + T::ONE\n}</code></pre>\n<p>请注意，关联常量不能与特型对象一起使用，因为为了在编译期选择正确的值，编译器会依赖相关实现的类型信息。</p>\n<p>即使是没有任何行为的简单特型（如 <code>Float</code>），也可以提供有关类型的足够信息，再结合一些运算符，以实现像斐波那契数列这样常见的数学函数：</p>\n<pre class=\"code-rows\"><code>fn fib&lt;T: Float + Add&lt;Output=T&gt;&gt;(n: usize) -&gt; T {\n    match n {\n        0 =&gt; T::ZERO,\n        1 =&gt; T::ONE,\n        n =&gt; fib::&lt;T&gt;(n - 1) + fib::&lt;T&gt;(n - 2)\n    }\n}</code></pre>\n<p>在 11.5 节和 11.6 节中，我们将展示用特型描述类型之间关系的不同方式。所有这些都可以看作避免虚方法开销和向下转换的方法，因为它们允许 Rust 在编译期了解更多的具体类型。</p>\n<h2 id=\"nav_point_200\">11.5　逆向工程求限界</h2>\n<p>当没有特型可以满足你的所有需求时，编写泛型代码可能会是一件真正的苦差事。假设我们编写了下面这个非泛型函数来进行一些计算：</p>\n<pre class=\"code-rows\"><code>fn dot(v1: &amp;[i64], v2: &amp;[i64]) -&gt; i64 {\n    let mut total = 0;\n    for i in 0 .. v1.len() {\n        total = total + v1[i] * v2[i];\n    }\n    total\n}</code></pre>\n<p>现在我们想对浮点值使用相同的代码，因此可能会尝试像下面这么做。</p>\n<pre class=\"code-rows\"><code>fn dot&lt;N&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N {\n    let mut total: N = 0;\n    for i in 0 .. v1.len() {\n        total = total + v1[i] * v2[i];\n    }\n    total\n}</code></pre>\n<p>运气不佳：Rust 会报错说乘法（<code>*</code>）的使用以及 0 的类型有问题。我们可以使用 <code>Add</code> 和 <code>Mul</code> 的特型要求 <code>N</code> 是支持 <code>+</code> 和 <code>*</code> 的类型。但是，对 0 的用法需要改变，因为 0 在 Rust 中始终是一个整数，对应的浮点值为 0.0。幸运的是，对于具有默认值的类型，有一个标准的 <code>Default</code> 特型。对于数值类型，默认值始终为 0：</p>\n<pre class=\"code-rows\"><code>use std::ops::;\n\nfn dot&lt;N: Add + Mul + Default&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N {\n    let mut total = N::default();\n    for i in 0 .. v1.len() {\n        total = total + v1[i] * v2[i];\n    }\n    total\n}</code></pre>\n<p>离成功更近了，但仍未完全解决：</p>\n<pre class=\"code-rows\"><code>error: mismatched types\n  |\n5 | fn dot&lt;N: Add + Mul + Default&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N {\n  |        - this type parameter\n...\n8 |         total = total + v1[i] * v2[i];\n  |                         ^^^^^^^^^^^^^ expected type parameter `N`,\n  |                                       found associated type\n  |\n  = note: expected type parameter `N`\n            found associated type `&lt;N as Mul&gt;::Output`\nhelp: consider further restricting this bound\n  |\n5 | fn dot&lt;N: Add + Mul + Default + Mul&lt;Output = N&gt;&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N {\n  |                               ^^^^^^^^^^^^^^^^^</code></pre>\n<p>我们的新代码中假定将两个 <code>N</code> 类型的值相乘会生成另一个 <code>N</code> 类型的值。但事实并非如此。你可以重载乘法运算符以返回想要的任意类型。我们需要以某种方式让 Rust 知道这个泛型函数只适用于那些支持正常乘法规范的类型，其中 <code>N * N</code> 一定会返回 <code>N</code>。错误消息中的建议<strong>几乎</strong>是正确的：我们可以通过将 <code>Mul</code> 替换为 <code>Mul&lt;Output=N&gt;</code> 来做到这一点，对 <code>Add</code> 的处理也是一样的：</p>\n<pre class=\"code-rows\"><code>fn dot&lt;N: Add&lt;Output=N&gt; + Mul&lt;Output=N&gt; + Default&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N\n{\n    ...\n}</code></pre>\n<p>此时，类型限界积累得越来越多，使得代码难以阅读。我们来把限界移动到 <code>where</code> 子句中：</p>\n<pre class=\"code-rows\"><code>fn dot&lt;N&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N\n    where N: Add&lt;Output=N&gt; + Mul&lt;Output=N&gt; + Default\n{\n    ...\n}</code></pre>\n<p>漂亮！但是 Rust 仍然会对这行代码报错：</p>\n<pre class=\"code-rows\"><code>error: cannot move out of type `[N]`, a non-copy slice\n  |\n8 |         total = total + v1[i] * v2[i];\n  |                         ^^^^^\n  |                         |\n  |                         cannot move out of here\n  |                         move occurs because `v1[_]` has type `N`,\n  |                         which does not implement the `Copy` trait</code></pre>\n<p>由于我们没有要求 <code>N</code> 是可复制的类型，因此 Rust 将 <code>v1[i]</code> 解释为试图将值从切片中移动出去（Rust 中禁止这样做）。但是我们根本就没想修改切片，只是想将这些值复制出来以便对它们进行操作。幸运的是，Rust 的所有内置数值类型都实现了 <code>Copy</code>，因此可以简单地将其添加到对 <code>N</code> 的约束中：</p>\n<pre class=\"code-rows\"><code>where N: Add&lt;Output=N&gt; + Mul&lt;Output=N&gt; + Default + Copy</code></pre>\n<p>这样代码就可以编译并运行了。最终代码如下所示：</p>\n<pre class=\"code-rows\"><code>use std::ops::;\n\nfn dot&lt;N&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N\n    where N: Add&lt;Output=N&gt; + Mul&lt;Output=N&gt; + Default + Copy\n{\n    let mut total = N::default();\n    for i in 0 .. v1.len() {\n        total = total + v1[i] * v2[i];\n    }\n    total\n}\n\n#[test]\nfn test_dot() {\n    assert_eq!(dot(&amp;[1, 2, 3, 4], &amp;[1, 1, 1, 1]), 10);\n    assert_eq!(dot(&amp;[53.0, 7.0], &amp;[1.0, 5.0]), 88.0);\n}</code></pre>\n<p>上述现象在 Rust 中偶有发生：虽然经历了一段与编译器的激烈拉锯战，但最后代码看起来相当不错，就仿佛这场拉锯战从未发生过一样，运行起来也很令人满意。</p>\n<p>我们在这里所做的就是对 <code>N</code> 的限界进行逆向工程，使用编译器来指导和检查我们的工作。这个过程有点儿痛苦，因为标准库中没有那么一个 <code>Number</code> 特型包含我们想要使用的所有运算符和方法。碰巧的是，有一个名为 <code>num</code> 的流行开源 crate 定义了这样的一个特型。如果我们能提前知道，就可以将 <code>num</code> 添加到 Cargo.toml 中并这样写：</p>\n<pre class=\"code-rows\"><code>use num::Num;\n\nfn dot&lt;N: Num + Copy&gt;(v1: &amp;[N], v2: &amp;[N]) -&gt; N {\n    let mut total = N::zero();\n    for i in 0 .. v1.len() {\n        total = total + v1[i] * v2[i];\n    }\n    total\n}</code></pre>\n<p>就像在面向对象编程中正确的接口能令一切变得美好一样，在泛型编程中正确的特型也能令一切变得美好。</p>\n<p>不过，为什么要这么麻烦呢？为什么 Rust 的设计者不让泛型更像 C++ 模板中的“鸭子类型”那样在代码中隐含约束呢？</p>\n<p>Rust 的这种方式的一个优点是泛型代码的前向兼容性。你可以更改公共泛型函数或方法的实现，只要没有更改签名，对它的用户就没有任何影响。</p>\n<p>类型限界的另一个优点是，当遇到编译器错误时，至少编译器可以告诉你问题出在哪里。涉及模板的 C++ 编译器错误消息可能比 Rust 的错误消息要长得多，并且会指向许多不同的代码行，因为编译器无法判断谁应该为此问题负责：是模板，还是其调用者？而调用者也可能是模板，或者<strong>调用者模板</strong>的模板……</p>\n<p>也许明确写出限界的最重要的优点是限界就这么写在代码和文档中。你可以查看 Rust 中泛型函数的签名，并准确了解它能接受的参数类型。而使用模板则做不到这些。在像 Boost 这样的 C++ 库中完整记录参数类型的工作比我们在这里经历的还要艰巨得多。Boost 开发人员可没有能帮他们检查工作成果的编译器。</p>\n<h2 id=\"nav_point_201\">11.6　以特型为基础</h2>\n<p>特型成为 Rust 中最主要的组织特性之一是有充分理由的，因为良好的接口在设计程序或库时尤为重要。</p>\n<p>本章是关于语法、规则和解释的“狂风骤雨”。现在我们已经奠定了基础，可以开始讨论在 Rust 代码中使用特型和泛型的多种方式了。事实上，我们才刚刚开始入门。接下来的第 12 章和第 13 章将介绍标准库提供的公共特型。之后的各章将涵盖闭包、迭代器、输入 /输出和并发。特型和泛型在所有这些主题中都扮演着核心角色。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 11 章 特型与泛型(1)","id":740811},"right":{"article_title":"第 12 章 运算符重载","id":740813}},"comments":[]}