{"id":490408,"title":"题目解答 | 期中考试版本参考实现","content":"<p>你好，我是朱涛。上节课我给你布置了一份考试题，你完成得怎么样了呢？这节课呢，我会来告诉你我是如何用Kotlin来做这个图片处理程序的，供你参考。</p><p>由于上节课我们已经做好了前期准备，所以这里我们直接写代码就行了。</p><h2>1.0版本</h2><p>对于图片反转和裁切的这个问题，如果一开始你就去想象一个大图片，里面有几万个像素点，那你可能会被吓到。但是，如果你将数据规模缩小，再来分析的话，你会发现这个问题其实很简单。</p><p>这里，我们就以一张4X4像素的照片为例来分析一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/20/2f31e490e0b973c9511e4aaa921f0520.jpg?wh=1498x646\" alt=\"\"></p><p>这其实就相当于一个抽象的模型，如果我们基于这张4X4的照片，继续分析翻转和裁切，就会容易很多。我们可以来画一个简单的图形：</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/8d/b6a1a1f3b70b9b1a8132c51a92660d8d.jpg?wh=2000x814\" alt=\"\"></p><p>上面这张图，从左到右分别是原图、横向翻转、纵向翻转、裁切。其中，翻转看起来是要复杂一些，而裁切是最简单的。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/c3/64001cb039dbcff66c4e9eec48dcf6c3.jpg?wh=2000x789\" alt=\"\"></p><p>我们先来处理裁切。对于裁切，其实只需要将图片当中某个部分的像素拷贝到内存，然后存储成为一张新图片就行了。</p><pre><code class=\"language-plain\">/**\n * 图片裁切\n */\nfun Image.crop(startY: Int, startX: Int, width: Int, height: Int): Image {\n    val pixels = Array(height) { y -&gt;\n        Array(width) { x -&gt;\n            getPixel(startY + y, startX + x)\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><!-- [[[read_end]]] --><p>以上代码中，我们创建了一个新数组pixels，它的创建方式是通过Lambda来实现的，而Lambda当中最关键的逻辑，就是 <code>getPixel(startY + y, startX + x)</code>，也就是从原图当中取像素点。</p><p>这代码是不是比你想象中简单很多？其实，图片的翻转也是一样的。只要我们能<strong>找出坐标的对应关系</strong>，代码也非常简单。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/c8/7aeeb78bb0a4a6f8cb4a3308e2842fc8.jpg?wh=1633x880\" alt=\"\"></p><p>可以看到，对于原图的(1, 0)这个像素点来说，它横向翻转以后就变成了(2, 0)。所以，对于(x, y)坐标来说，横向翻转以后，就应该变成(width-1-x, y)。找到这个对应关系以后，我们就直接抄代码了！</p><pre><code class=\"language-plain\">/**\n * 横向翻转图片\n */\nfun Image.flipHorizontal(): Image {\n    val pixels = Array(height()) { y -&gt;\n        Array(width()) { x -&gt;\n            getPixel(y, width() - 1 - x)\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><p>可见，以上这段代码几乎跟裁切是一模一样的，只是说，裁切要限制宽高，而翻转则是跟原图保持一致。</p><p>看到这里，相信你也马上就能想明白纵向翻转的代码该如何写了！</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/1e/2e7ae2ec91856141ff2881ec2cdb441e.jpg?wh=1671x899\" alt=\"\"></p><p>我们还是以(1, 0)这个像素点为例，在纵向翻转以后就变成了(1, 3)，它们的转换规则是(x, height-1-y)。</p><pre><code class=\"language-plain\">/**\n * 纵向翻转图片\n */\nfun Image.flipVertical(): Image {\n    val pixels = Array(height()) { y -&gt;\n        Array(width()) { x -&gt;\n            getPixel(height() - 1 - y, x) // 改动这里\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><p>所以说，只要我们能找到中间的转换关系，纵向翻转的代码，只需要在横向翻转的基础上，改动一行即可。</p><h3>单元测试</h3><p>其实针对图像算法的单元测试，我们最好的方式，就是准备一些现有的图片案例。比如说，我们随便找一张图，用其他的软件工具，对它进行翻转、裁切，然后存储起来。比如还是这四张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/85/d8/85f71d3914e23b7ed8664ae57f0e9fd8.png?wh=1128x424\" alt=\"图片\"></p><p>我们可以把处理后的图片保存在单元测试的文件夹下，方便我们写对应的测试用例。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/d2/47ff01b7fd65dcf6e99e298be6e104d2.png?wh=478x327\" alt=\"图片\"></p><p>那么，有了这些图片之后，我想你应该就能想到要怎么办了。这时候，你只需要写一个图片像素对比的方法checkImageSame()就好办了。</p><pre><code class=\"language-plain\">private fun checkImageSame(picture: Image, expected: Image) {\n    assertEquals(picture.height(), expected.height())\n    assertEquals(picture.width(), expected.width())\n    for (row in 0 until picture.height()) {\n        for (column in 0 until picture.width()) {\n            val actualPixel = picture.getPixel(row, column)\n            val expectedPixel = expected.getPixel(row, column)\n            assertEquals(actualPixel, expectedPixel)\n        }\n    }\n}\n</code></pre><p>其实，这个函数的思路也很简单，就是逐个对比两张图片之间的像素，看看它们是不是一样的，如果两张图所有的像素都一样，那肯定就是一样的。</p><p>有了这个方法以后，我们就可以快速实现单元测试代码了。整体流程大致如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/a6/d37e162b313258fa01ed4f1a99d7d0a6.png?wh=1114x394\" alt=\"图片\"></p><pre><code class=\"language-plain\">@Test\nfun testCrop() {\n    val image = loadImage(File(\"${TEST_BASE_PATH}android.png\"))\n    val height = image.height() / 2\n    val width = image.width() / 2\n    val target = loadImage(File(\"${TEST_BASE_PATH}android_half_crop.png\"))\n\n    val crop = image.crop(0, 0, width, height)\n    checkImageSame(crop, target)\n}\n\n@Test\nfun testFlipVertical() {\n    val origin = loadImage(File(\"${TEST_BASE_PATH}android.png\"))\n    val target = loadImage(File(\"${TEST_BASE_PATH}android_up_side_down.png\"))\n    val flipped = origin.flipVertical()\n    checkImageSame(flipped, target)\n}\n\n@Test\nfun testFlipHorizontal() {\n    val origin = loadImage(File(\"${TEST_BASE_PATH}android.png\"))\n    val target = loadImage(File(\"${TEST_BASE_PATH}android_flipped.png\"))\n    val flipped = origin.flipHorizontal()\n    checkImageSame(flipped, target)\n}\n</code></pre><p>有了单元测试，我们就再也不用担心以后改代码的时候，不小心改出问题了。</p><p>好，那么到这里，1.0版本就算是完成了。我们接着来看看2.0版本。</p><h2>2.0版本</h2><p>2.0版本的任务，我们需要支持下载网络上面的图片，并且还要能够存起来。由于这是一个比较耗时的操作，我们希望它是一个挂起函数。</p><p>关于下载HTTP的图片，其实，我们借助OkHttp就可以简单实现。下面我们来看看代码。</p><blockquote>\n<p>补充：为了不偏离主题，我们不考虑HTTPS的问题。</p>\n</blockquote><pre><code class=\"language-plain\">fun downloadSync() {\n    logX(\"Download start!\")\n    val okHttpClient = OkHttpClient().newBuilder()\n        .connectTimeout(10L, TimeUnit.SECONDS)\n        .readTimeout(10L, TimeUnit.SECONDS)\n        .build()\n\n    val request = Request.Builder().url(url).build()\n    val response = okHttpClient.newCall(request).execute()\n\n    val body = response.body\n    val responseCode = response.code\n\n    if (responseCode &gt;= HttpURLConnection.HTTP_OK &amp;&amp;\n        responseCode &lt; HttpURLConnection.HTTP_MULT_CHOICE &amp;&amp;\n        body != null\n    ) {\n        // 1， 注意这里\n        body.byteStream().apply {\n            outputFile.outputStream().use { fileOut -&gt;\n                copyTo(fileOut)\n            }\n        }\n    }\n    logX(\"Download finish!\")\n}\n</code></pre><p>以上代码中，有一个地方是需要注意的，我用注释标记了。也就是当我们想要把网络流中的数据存起来的时候，我们可以借助Kotlin提供的 <strong>IO扩展函数</strong>快速实现，这样不仅方便，而且还不用担心FileOutputStream调用close()的问题。这个部分的代码，在Java当中，是要写一堆模板代码的。</p><p>下载本身的功能实现以后，挂起函数的封装也就容易了。</p><pre><code class=\"language-plain\">suspend fun downloadImage(url: String, outputFile: File): Boolean {\n    return withContext(Dispatchers.IO) {\n        try {\n            downloadSync()\n        } catch (e: Exception) {\n            println(e)\n            // return@withContext  不可省略\n            return@withContext false\n        }\n        // return@withContext 可省略\n        return@withContext true\n    }\n}\n</code></pre><p>这里，我们可以直接用 <strong>withContext</strong>，让下载的任务直接分发到IO线程。</p><p>代码写到这里，2.0版本要求的功能基本上就算是完成了。这样一来，我们就可以在main函数当中去调用它了。</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    val url = \"http://xxxx.jpg\"\n    val path = \"${BASE_PATH}downloaded.png\"\n\n    downloadImage(url, File(path))\n\n    loadImage(File(path))\n        .flipVertical()\n        .writeToFile(File(\"${BASE_PATH}download_flip_vertical.png\"))\n\n    logX(\"Done\")\n}\n\n// 将内存图片保存到硬盘\nfun Image.writeToFile(outputFile: File): Boolean {\n    return try {\n        val width = width()\n        val height = height()\n        val image = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                val awtColor = getPixel(y, x)\n                image.setRGB(x, y, awtColor.rgb)\n            }\n        }\n        ImageIO.write(image, \"png\", outputFile)\n        true\n    } catch (e: Exception) {\n        println(e)\n        false\n    }\n}\n\n/*\n输出结果：\n================================\nDownload start!\nThread:DefaultDispatcher-worker-1\n================================\n================================\nDownload finish!\nThread:DefaultDispatcher-worker-1\n================================\n================================\nDone\nThread:main\n================================\n*/\n</code></pre><p>通过运行结果，我们会发现图片下载的任务，已经被分发到IO线程池了，而其他的代码仍然在主线程之上。</p><h2>小结</h2><p>其实，课程进行到这里，你就会发现，Kotlin和Java、C之类的语言的编程方式是完全不一样的。Kotlin提供了丰富的扩展函数，在很多业务场景下，Kotlin是可以大大减少代码量的。</p><p>另外，你也会发现，当你熟悉Kotlin协程以后，它的使用一点都不难。对于上面的代码，我们通过withContext(Dispatchers.IO)就能切换线程，之后，我们就可以在协程作用域当中随意调用了！</p><h2>思考题</h2><p>你觉得，我们在downloadImage()这个挂起函数内部，直接写死Dispatchers.IO的方式好吗？如果换成下面这种写法，会不会更好？为什么？</p><pre><code class=\"language-plain\">suspend fun downloadImage(\n    coroutineContext: CoroutineContext = Dispatchers.IO,\n    url: String,\n    outputFile: File\n): Boolean {\n\n    return withContext(coroutineContext) {\n        try {\n            downloadSync()\n        } catch (e: Exception) {\n            println(e)\n            return@withContext false\n        }\n        return@withContext true\n    }\n}\n</code></pre>","neighbors":{"left":{"article_title":"期中考试 | 用Kotlin实现图片处理程序","id":489708},"right":{"article_title":"19 | Channel：为什么说Channel是“热”的？","id":491021}},"comments":[]}