{"id":774409,"title":"07｜类型标识：虚拟机支持对象自检的基础设施","content":"<p>你好，我是海纳。</p><p>前边两节课我们实现了控制流的功能。在实现控制流的时候，遇到使用基本数据类型的情况时，我们都采用了一些手段回避过去了。但是在进一步实现其他功能之前，我们必须把对象体系建立起来。这节课我们就从虚拟机中的基本数据类型入手，补全之前的功能，从而实现基本的对象体系。</p><h2>Klass-Oop 二元结构</h2><p>到目前为止，虚拟机里只有一个 HiObject 类，Integer 和 String 都是继承自这个类。我们回顾一下 Integer 的 equal 方法。</p><pre><code class=\"language-python\">HiObject* HiInteger::equal(HiObject* x) {\n    if (_value == ((HiInteger*)x)-&gt;_value)\n        return Universe::HiTrue;\n    else\n        return Universe::HiFalse;\n}\n</code></pre><p>代码里的参数 x，如果它的类型是 Integer，equal 函数就可以正确执行。如果 x 的实际类型不是 Integer，这段代码就不能正常工作了。</p><p>我们需要一种机制，来判断某个 HiObject 对象的实际类型到底是什么。在编程语言虚拟机中，最常用的解决办法就是使用 Klass-Oop 二元结构。Klass 代表一种具体的类型，它是“类”这个概念的实际体现。例如，Integer 类在虚拟机里就有一个 IntegerKlass 与之对应，所有的整数都是 IntegerKlass 的实例。Oop是 Ordinary object pointer 的缩写，代表一个普通的对象。每一个对象都有自己的 Klass ，同一类对象是由同一个 Klass 实例化出来的。</p><!-- [[[read_end]]] --><p>类与类之间有继承关系，类里还会封装其他的属性和方法。这些信息都会保存在 Klass 结构中。</p><p>使用这种二元结构，还有一个原因是，<strong>我们不希望在普通对象里引入虚函数机制</strong>，因为虚函数会在对象的开头引入虚表指针，而虚表指针会影响对象的属性在对象中的偏移。</p><p>所以，我们就把类的方法定义和实现都放到 Klass 中了，而在 HiObject 里只需要调用相应的 Klass 中的函数。</p><p>我们先来定义 Klass 类。</p><pre><code class=\"language-c++\">class Klass {\nprivate:\n    HiString*     _name;\n\npublic:\n    Klass() {};\n\n    void set_name(HiString* x)            { _name = x; }\n    HiString* name()                      { return _name; }\n\n    virtual void print(HiObject* obj) {};\n\n    virtual HiObject* greater  (HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* less     (HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* equal    (HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* not_equal(HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* ge       (HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* le       (HiObject* x, HiObject* y) { return 0; }\n\n    virtual HiObject* add(HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* sub(HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* mul(HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* div(HiObject* x, HiObject* y) { return 0; }\n    virtual HiObject* mod(HiObject* x, HiObject* y) { return 0; }\n};\n</code></pre><p>目前的 Klass 类只包含一个属性，_name 代表了这个类的名称，它是一个字符串。</p><p>Klass 类中最重要的是上述代码中出现的 12 个虚函数。前面我们分析过，虚函数应该从对象中搬到 Klass 中去。在代码中，这 12 个函数都是空的，我们先这样做，等 HiObject 重构完以后，再来重点实现它们。</p><p>有了 Klass 定义，HiObject 的定义也要进行相应地修改，在 HiObject 类里增加一个属性，是一个指向 Klass 的指针，用于表示这个对象的类型。</p><p>由于我们已经把虚函数都搬到了 Klass 中，HiObject 中原来定义的函数就都不必是虚函数了。这样 HiObject 就变成了一个没有虚表的普通对象，更有利于我们清晰地把握它的内存布局。</p><p>接下来我们再把 HiObject 中的函数都实现为转向调用自己所对应的 Klass 中的函数。</p><p>HiObject 的定义变为下面这种形式：</p><pre><code class=\"language-c++\">// object/hiObject.hpp\nclass HiObject {\nprivate:\n    Klass*  _klass;\n\npublic:\n    Klass* klass()             { assert(_klass != NULL); return _klass; }\n    void set_klass(Klass* x)   { _klass = x; }\n\n    void print();\n\n    HiObject* add(HiObject* x);\n    HiObject* sub(HiObject* x);\n    HiObject* mul(HiObject* x);\n    HiObject* div(HiObject* x);\n    HiObject* mod(HiObject* x);\n\n    HiObject* greater  (HiObject* x);\n    HiObject* less     (HiObject* x);\n    HiObject* equal    (HiObject* x);\n    HiObject* not_equal(HiObject* x);\n    HiObject* ge       (HiObject* x);\n    HiObject* le       (HiObject* x);\n};\n\n// object/hiObject.cpp\nvoid HiObject::print() {\n    klass()-&gt;print(this);\n}\n\nHiObject* HiObject::greater(HiObject * rhs) {\n    return klass()-&gt;greater(this, rhs);\n}\n\n// other comparision methods.\n// ...\n\nHiObject* HiObject::add(HiObject * rhs) {\n    return klass()-&gt;add(this, rhs);\n}\n\n// other arithmatic methods.\n// ...\n</code></pre><p>到这里，Klass 和 Oop 的二元结构就搭建完成了。接下来，我们要分别审视各种类型的具体实现。先从整数开始。</p><h2>重构整数</h2><p>原来的系统里已经实现了整数。在 Klass-Oop 二元结构下，整数类也需要做相应的修改。首先是头文件中，HiInteger 类里的虚函数声明都不再需要了，HiInteger 的方法均继承自HiObject，由于 HiObject 中已经实现了所有函数，所以 HiInteger 类就变得很简洁了。</p><pre><code class=\"language-c++\">class HiInteger : public HiObject {\nprivate:\n    int _value;\n\npublic:\n    HiInteger(int x);\n    int value() { return _value; }\n};\n</code></pre><p>接下来的步骤是实现 IntegerKlass，用于表示 Integer 类型。如下图所示，系统中的所有 Integer 对象，它的 Klass 指针（继承自HiObject）都应该指向同一个 Klass 对象，就是我们现在要实现的 IntegerKlass。可见，IntegerKlass 在整个系统中只需要有一个就够了。符合这种特点的对象，我们往往采取单例模式来实现。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/d0/17086a688yy18a3258faecc89db002d0.png?wh=1568x702\" alt=\"图片\"></p><h2>定义IntegerKlass</h2><p>由于 IntegerKlass 类应该实现成单例模式，所以，我们可以这样定义IntegerKlass：</p><pre><code class=\"language-c++\">// object/hiInteger.hpp\nclass IntegerKlass : public Klass {\nprivate:\n    IntegerKlass();\n    static IntegerKlass* instance;\n\npublic:\n    static IntegerKlass* get_instance();\n\n    virtual void print(HiObject* obj);\n\n    virtual HiObject* greater  (HiObject* x, HiObject* y);\n    virtual HiObject* less     (HiObject* x, HiObject* y);\n    virtual HiObject* equal    (HiObject* x, HiObject* y);\n    virtual HiObject* not_equal(HiObject* x, HiObject* y);\n    virtual HiObject* ge       (HiObject* x, HiObject* y);\n    virtual HiObject* le       (HiObject* x, HiObject* y);\n\n    virtual HiObject* add(HiObject* x, HiObject* y);\n    virtual HiObject* sub(HiObject* x, HiObject* y);\n    virtual HiObject* mul(HiObject* x, HiObject* y);\n    virtual HiObject* div(HiObject* x, HiObject* y);\n    virtual HiObject* mod(HiObject* x, HiObject* y);\n};\n\n// object/hiInteger.cpp\nIntegerKlass* IntegerKlass::instance = NULL;\n\nIntegerKlass::IntegerKlass() {\n}\n\nIntegerKlass* IntegerKlass::get_instance() {\n    if (instance == NULL)\n        instance = new IntegerKlass();\n\n    return instance;\n}\n\n\n\nHiInteger::HiInteger(int x) {\n    _value = x;\n    set_klass(IntegerKlass::get_instance());\n}\n</code></pre><p>在上述代码清单里，IntegerKlass 被实现成了一个单例类。Integer 对象在创建的时候会把自己的 klass 设置成 IntegerKlass。做完这一步，Integer 类的二元结构就改造完成了，最后只需要在 Klass 中实现相应的虚函数即可，这里我们以 equal 方法来举例说明。</p><pre><code class=\"language-c++\">HiObject* IntegerKlass::equal(HiObject* x, HiObject* y) {\n&nbsp; &nbsp; if (x-&gt;klass() != y-&gt;klass())\n&nbsp; &nbsp; &nbsp; &nbsp; return Universe::HiFalse;\n\n&nbsp; &nbsp; HiInteger* ix = (HiInteger*) x;\n&nbsp; &nbsp; HiInteger* iy = (HiInteger*) y;\n\n&nbsp; &nbsp; assert(ix &amp;&amp; (ix-&gt;klass() == (Klass *)this));\n&nbsp; &nbsp; assert(iy &amp;&amp; (iy-&gt;klass() == (Klass *)this));\n\n&nbsp; &nbsp; if (ix-&gt;value() == iy-&gt;value())\n&nbsp; &nbsp; &nbsp; &nbsp; return Universe::HiTrue;\n&nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; return Universe::HiFalse;\n}\n</code></pre><p>在 equal 方法的开头部分，提前判断了 x 和 y 的类型，如果它们的类型不一样，那就可以直接返回 False 了。接下来，验证 x 和 y 都是整数类型，最后再取它们的 value 进行比较。在大于或者小于的判断中，如果类型不符合期望，标准的 Python 虚拟机的动作是抛出异常，但现在还没有实现异常机制，在那之前，我们就先使用 assert 让程序崩溃吧。</p><p>其他的比较运算和数学运算，这里我们就不一一列出了，你可以自己动手补齐，并与工程里的源代码进行比较。</p><p>在修改完整数类型以后，下面这个测试用例就可以正确地执行了。</p><pre><code class=\"language-c++\">if 2 &gt; 1:\n    print(2)\nelse:\n    print(1)\n\nprint(3)\n</code></pre><p>因为这个例子只使用了整数，完全没有使用变量。如果程序中使用了变量的话，就不能运行了，因为变量所依赖的局部变量表依赖于字符串的比较操作。所以，接下来就要重构字符串。</p><h2>重构字符串</h2><p>与 IntegerKlass 相似，我们也使用单例模式来实现字符串的 StringKlass，并在字符串的构造函数里把 klass 属性设为 StringKlass。</p><pre><code class=\"language-c++\">// object/hiString.hpp\nclass StringKlass : public Klass {\nprivate:\n&nbsp; &nbsp; StringKlass() {}\n&nbsp; &nbsp; static StringKlass* instance;\n\npublic:\n&nbsp; &nbsp; static StringKlass* get_instance();\n\n&nbsp; &nbsp; virtual HiObject* equal&nbsp; &nbsp; (HiObject* x, HiObject* y);\n\n&nbsp; &nbsp; virtual void print(HiObject* obj);\n};\n\n// object/hiString.cpp\nStringKlass* StringKlass::instance = NULL;\n\nStringKlass* StringKlass::get_instance() {\n&nbsp; &nbsp; if (instance == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; instance = new StringKlass();\n\n&nbsp; &nbsp; return instance;\n}\n\nHiString::HiString(const char* x) {\n&nbsp; &nbsp; _length = strlen(x);\n&nbsp; &nbsp; _value = new char[_length];\n&nbsp; &nbsp; strcpy(_value, x);\n\n&nbsp; &nbsp; set_klass(StringKlass::get_instance());\n}\n</code></pre><p>可以看到，StringKlass 的设计思路和 IntegerKlass 的设计思路是十分相似的。这里就不过多解释了。字符串类里比较重要的两个方法print 和 equal，是要重点实现的，我们先来实现 equal 方法。</p><pre><code class=\"language-c++\">HiObject* StringKlass::equal(HiObject* x, HiObject* y) {\n    if (x-&gt;klass() != y-&gt;klass())\n        return Universe::HiFalse;\n\n    HiString* sx = (HiString*) x;\n    HiString* sy = (HiString*) y;\n\n    assert(sx &amp;&amp; sx-&gt;klass() == (Klass*)this);\n    assert(sy &amp;&amp; sy-&gt;klass() == (Klass*)this);\n\n    if (sx-&gt;length() != sy-&gt;length())\n        return Universe::HiFalse;\n\n    for (int i = 0; i &lt; sx-&gt;length(); i++) {\n        if (sx-&gt;value()[i] != sy-&gt;value()[i])\n            return Universe::HiFalse;\n    }\n\n    return Universe::HiTrue;\n}\n</code></pre><p>在 equal 的实现中，先比较 x 和 y 的类型，如果它们的类型不一样，就直接返回 False。接着，在验证过类型以后，再比较 x 和 y 的长度，如果长度不一样，就直接返回False。最后才是逐个字符进行比较，只要有一个字符不相等，就会返回 False。只有这些检查全部通过了，才会返回 True。</p><p>然后我们再实现 print 方法。</p><pre><code class=\"language-c++\">void StringKlass::print(HiObject* obj) {\n    HiString* str_obj = (HiString*) obj;\n    assert(str_obj &amp;&amp; str_obj-&gt;klass() == (Klass*)this);\n\n    for (int i = 0; i &lt; str_obj-&gt;length(); i++) {\n        printf(\"%c\", str_obj-&gt;value()[i]);\n    }\n}\n</code></pre><p>print 方法里不能使用 <code>%s</code> 直接格式化输出，因为中间有可能会出现字符 <code>'\\0'</code>，所以这里只能逐个字符往外打印。当字符串也修改完了，局部变量表才能正常地起作用。你可以通过运行 Fibonacci 的例子来进行测试。</p><p>对象系统的重构就到此为止了。我们为对象系统打下了非常好的基础，在这套体系下，虚拟机可以实现自定义 class。但在那之前，还要再实现 Python 中最重要的一个机制：函数。所以从下一节课开始，我们就来实现函数机制。</p><h2>总结</h2><p>这节课我们重点重构了整个虚拟机的内建对象系统。最核心的目标是<strong>把内建对象改成不带虚函数的普通对象</strong>，这么做是为了保证每个对象的内存布局完全可控，而不是依赖编译器的实现。</p><p>把原来的 HiObject 修改成普通对象，那么它的多态性就要由相应的 Klass 对象来实现。所以 HiObject 的实现全部被转向调用 Klass 对象中的实现。</p><p>在这个基础上我们重新实现了整数和字符串，从而支持变量功能，最终可以运行 Fibonacci 的例子。虽然从功能上看，我们并没有实现新的特性，但是经过重构，对象系统已经打好了基础，可以继续实现更加强大的功能。</p><h2>思考题</h2><p>请你思考字符串和整数相加的例子，在Python、C++、Java、JavaScript等语言中各自会有怎样的结果？欢迎你把你对比后的内容分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p><h2>知识拓展：单例模式</h2><p>单例模式是设计模式的一种，可以保证一个类在全局只能生成一个对象。这个模式的关键技术点有两个，一是单例类要有一个<strong>私有的构造函数</strong>，从而保证对象不能被任意代码随时创建。例如：</p><pre><code class=\"language-c++\">class Singleton {\nprivate:\n    Singleton() {}\n\npublic:\n    void say_hello();\n};\n\nvoid Singleton::say_hello() {\n    printf(\"hello world\\n\");\n}\n\n// this is wrong.\nSingleton* singleton = new Singleton();\n</code></pre><p>这样一来，我们就无法正常地通过访问构造函数来构造一个 Singleton 的实例了，杜绝了这个类被随意实例化的可能。可是这样就相当于这个类没有用了，我们还要找办法给这个类开一个口子，这就是第二个技术要点：<strong>static 方法</strong>。</p><p>static 方法是可以通过类名访问的，而 static 方法又位于类的内部，对类里的任何方法都有访问权限。这就好了，我们给 Singleton 加上一个静态方法，在这个静态方法里创建类就行。</p><pre><code class=\"language-c++\">class Singleton {\nprivate:\n    Singleton() {}\n    static Singleton* _instance;\n\npublic:\n    static Singleton* get_instance();\n    void say_hello();\n};\n\n// this is important!!! DO NOT FORGET THIS.\nSingleton* Singleton::_instance = NULL;\n\nSingleton* Singleton::get_instance() {\n    if (_instance == NULL)\n        _instance = new Singleton();\n\n    return _instance;\n}\n</code></pre><p>我们通过给 Singleton 类增加一个 public static 方法在这个类上开了一个口子，而这个方法对于私有构造函数是有访问权限的。也就是说，如果你想使用 Singleton 的实例，就不能自己通过 new 来创建，只能通过访问 get_instance 来获取。</p><p>get_instance 不是每次都去创建一个新的对象，而是先去检查以前有没有创建过，如果没有创建过，就先创建一个再把创建的 object 赋值给 _instance 属性存起来。如果已经创建过了，就直接返回这个对象。这样就保证了，无论应用代码怎么写，整个系统里只能有一个 Singleton 对象，全局唯一。这种只能创建一个实例的技巧就是单例模式。</p><p>需要强调的是代码里的第 12 行，静态变量一定要记得定义和初始化，否则就会出现链接错误，这是新手程序员最常见的错误之一。</p>","comments":[{"had_liked":false,"id":390823,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"上海","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1716383700,"is_pvip":true,"replies":[{"id":142175,"content":"这个后面版本就变成了equal方法了，会慢慢添加","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1716830207,"ip_address":"广东","comment_id":390823,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"实现map的时候没有去调用HiObject的equal方法, 而是直接对象比较, 结果测试变量的程序也可以跑过. 因为load_name的参数指向的都是names表中的实例. 那么什么情况下会有问题呢?","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645821,"discussion_content":"这个后面版本就变成了equal方法了，会慢慢添加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716830207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395133,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1729568017,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0}]}