{"id":119499,"title":"11 | 使用ZooKeeper实现分布式锁","content":"<p><strong>课件和Demo地址</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geekbang-zk-course\">https://gitee.com/geektime-geekbang/geekbang-zk-course</a></p>","comments":[{"had_liked":false,"id":142206,"user_name":"公众号-微观技术","can_delete":false,"product_type":"c3","uid":1043546,"ip_address":"","ucode":"BD0E46A9CF97E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/5a/1c68c5a7.jpg","comment_is_top":false,"comment_ctime":1571311464,"is_pvip":false,"replies":[{"id":54929,"content":"分布式锁这么设计的原因是为了避免羊群效应，公平性是一个副作用。这样设计是有你说的那个问题。","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1571364601,"ip_address":"","comment_id":142206,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"公平锁会有一个比较麻烦的地方，比如 节点1获得了锁，节点2客户端watch节点1，节点3客户端watch节点2。此时如果节点2的客户端心跳失效，触发watch机制，节点3的客户端要更换watch节点，也就是watch锁持有者节点1，否则一旦节点1释放锁，其它客户端永远感知不到。\n\n而非公平锁，不会存在这个问题，中间其它未持有锁的client端的session失效，并不会对其他客户端产生影响，另外我们日常工作的大部分场景的锁竞争并不会特别激烈，所以非公平锁的性能会更佳，正因为如此，jdk下JUC包里面的锁类默认都是采用非公平模式","like_count":6,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471030,"discussion_content":"分布式锁这么设计的原因是为了避免羊群效应，公平性是一个副作用。这样设计是有你说的那个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571364601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616913,"discussion_content":"在juc里面的锁默认都采用非公平的模式是因为可以减少不必要的上下文切换所以在大部分场景下的性能会更加，但是这个分布式锁里面不会说上下文切换了吧？在分布式锁下公平不公平应该性能差不多吧？不过按照作者使用zookeeper实现的分布式锁确实会存在你出现的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683186494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068432,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","nickname":"马文龙","note":"","ucode":"679B0F0AB402C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370841,"discussion_content":"那zk的分布式锁到底生产用公平的还是不公平的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619547275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128442,"user_name":"ly","can_delete":false,"product_type":"c3","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1566880784,"is_pvip":false,"replies":[{"id":47720,"content":"&gt; 老师，这个znode是不是就是类似redis中的一个key的概念呢\n\n你可以把znode理解成Redis的一个key。但是znode之间有层次关系。\n\n&gt; 另外我们这边经常用redis来做分布式锁（setnx命令），只是redis没有将请求者进行排队，感觉redis要简单一些，能否点评一下这两种锁的使用场景及优缺点。\n\n1. 如果一个调用setnx的Redis客户端crash，它设置的key还会存在，换言之锁不会自动释放。在ZooKeeper里面，我们用临时节点表示锁，如果ZooKeeper客户端crash，它的锁会自动释放。\n2. ZooKeeper实现的锁可以在锁释放时只通知一个锁请求者，还保证锁分配的FIFO。\n\n个人感觉ZooKeeper的锁方案更加完备。setnx只是一个简单的SET if Not eXists命令，如果你的场景很简单也可以用它。\n\n另外Redis(https:&#47;&#47;redis.io&#47;commands&#47;setnx)本身也不推荐使用setnx了。\n\n&gt; The following pattern is discouraged in favor of the Redlock algorithm which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1566917906,"ip_address":"","comment_id":128442,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"老师，这个znode是不是就是类似redis中的一个key的概念呢。另外我们这边经常用redis来做分布式锁（setnx命令），只是redis没有将请求者进行排队，感觉redis要简单一些，能否点评一下这两种锁的使用场景及优缺点。\n","like_count":5,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464946,"discussion_content":"&amp;gt; 老师，这个znode是不是就是类似redis中的一个key的概念呢\n\n你可以把znode理解成Redis的一个key。但是znode之间有层次关系。\n\n&amp;gt; 另外我们这边经常用redis来做分布式锁（setnx命令），只是redis没有将请求者进行排队，感觉redis要简单一些，能否点评一下这两种锁的使用场景及优缺点。\n\n1. 如果一个调用setnx的Redis客户端crash，它设置的key还会存在，换言之锁不会自动释放。在ZooKeeper里面，我们用临时节点表示锁，如果ZooKeeper客户端crash，它的锁会自动释放。\n2. ZooKeeper实现的锁可以在锁释放时只通知一个锁请求者，还保证锁分配的FIFO。\n\n个人感觉ZooKeeper的锁方案更加完备。setnx只是一个简单的SET if Not eXists命令，如果你的场景很简单也可以用它。\n\n另外Redis(https://redis.io/commands/setnx)本身也不推荐使用setnx了。\n\n&amp;gt; The following pattern is discouraged in favor of the Redlock algorithm which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566917906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/05/fc769d45.jpg","nickname":"Geek_zhw","note":"","ucode":"AABE15F9895613","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277435,"discussion_content":"用setnxex的方法，可以在设置redis的key时同时设置key的有效期，不存在客户端cash ,key还存在的情况","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591057976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1303813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/05/fc769d45.jpg","nickname":"Geek_zhw","note":"","ucode":"AABE15F9895613","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310393,"discussion_content":"我感觉可能还会存在一种情况，就是锁过期了，但是获取该锁的线程任务却没有执行完成","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601815052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277435,"ip_address":"","group_id":0},"score":310393,"extra":""}]}]},{"had_liked":false,"id":180423,"user_name":"钱","can_delete":false,"product_type":"c3","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1582278777,"is_pvip":false,"replies":[{"id":75908,"content":"分布式锁性能保证的关键点是避免herd effect。本节的实现是保证锁释放的时候，只有一个锁请求者收到通知。\n\n","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1586141191,"ip_address":"","comment_id":180423,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"zk分布式锁的高性能是怎么保证的？","like_count":3,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484661,"discussion_content":"分布式锁性能保证的关键点是避免herd effect。本节的实现是保证锁释放的时候，只有一个锁请求者收到通知。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586141191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180420,"user_name":"Douglas","can_delete":false,"product_type":"c3","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1582277920,"is_pvip":false,"replies":[{"id":75919,"content":"您的场景可以创建持久性节点。","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1586143333,"ip_address":"","comment_id":180420,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"老师分布式锁的场景，创建的是临时节点，如果T1 请求获得锁后，执行业务逻辑，这个时候如果业务还没执行完，网络原因导致了 session过期，session过期，临时节点会被服务器删除，这时其他节点也可以获取锁，分布式锁就被破坏了，这个场景如何来解决呢？","like_count":3,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484658,"discussion_content":"您的场景可以创建持久性节点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586143333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068432,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","nickname":"马文龙","note":"","ucode":"679B0F0AB402C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370840,"discussion_content":"这个问题同问，请老师回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619547096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222962,"discussion_content":"谢谢，感谢老师的答疑。设置临时节点是为了避免死锁，这个问题我想问一下有没有更好一点的方式，最好是生产级的解决方案，我的想法如果用持久锁，还得需要一个定时任务，来对锁进行管理避免死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586181581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129961,"user_name":"北海以北","can_delete":false,"product_type":"c3","uid":1645356,"ip_address":"","ucode":"6132B06279A14E","user_header":"https://static001.geekbang.org/account/avatar/00/19/1b/2c/b57ce485.jpg","comment_is_top":false,"comment_ctime":1567340674,"is_pvip":false,"replies":[{"id":48469,"content":"是的，ZooKeeper本身不提供锁，但是可以使用znode操作来实现。但是实现出来的锁也是advisory的，这就是说用户可以忽视这个锁直接获取资源。\n\nChubby的锁机制也是advisory的。","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1567351741,"ip_address":"","comment_id":129961,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"老师，是不是zookeeper没有加锁的功能，而是客户端自行做逻辑判断它如果不是排在第一位，则不能获取资源呢？","like_count":2,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465737,"discussion_content":"是的，ZooKeeper本身不提供锁，但是可以使用znode操作来实现。但是实现出来的锁也是advisory的，这就是说用户可以忽视这个锁直接获取资源。\n\nChubby的锁机制也是advisory的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567351741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138541,"user_name":"legendtkl","can_delete":false,"product_type":"c3","uid":1008863,"ip_address":"","ucode":"71732E3443B241","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/df/c2ade715.jpg","comment_is_top":false,"comment_ctime":1570326934,"is_pvip":false,"replies":[{"id":54760,"content":"一个目录下的顺序性节点是统一进行编号的，用的是int类型。如果一个目录下面有超过2^32个顺序性节点的话，会有您说的问题。但是这种情况实际发生的概率很小，所以ZooKeeper没有针对这种情况做处理。","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1571236431,"ip_address":"","comment_id":138541,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"如果 node 是按数字序号作为后缀，是不是意味着数字序号会被用完？","like_count":1,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469561,"discussion_content":"一个目录下的顺序性节点是统一进行编号的，用的是int类型。如果一个目录下面有超过2^32个顺序性节点的话，会有您说的问题。但是这种情况实际发生的概率很小，所以ZooKeeper没有针对这种情况做处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571236431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128480,"user_name":"WL","can_delete":false,"product_type":"c3","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1566886655,"is_pvip":false,"replies":[{"id":47696,"content":"zookeeper的源代码。https:&#47;&#47;github.com&#47;apache&#47;zookeeper&#47;tree&#47;branch-3.5.5&#47;zookeeper-recipes&#47;zookeeper-recipes-lock","user_name":"作者回复","user_name_real":"Geek_215586","uid":1591870,"ctime":1566914013,"ip_address":"","comment_id":128480,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"请问一下老师课程中讲的代码是zk的代码还是zk客户端的代码，我有点晕","like_count":1,"discussions":[{"author":{"id":1591870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyDiaaDJrwRsdUia9HxA8EuWaDVLr4E1gMG5y2ZTxV7BNUhdNABCmH3GMZTzib796X5duibiaeuRmNXeg/132","nickname":"Geek_215586","note":"","ucode":"5916AC9CC5FBE2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464967,"discussion_content":"zookeeper的源代码。https://github.com/apache/zookeeper/tree/branch-3.5.5/zookeeper-recipes/zookeeper-recipes-lock","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566914013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1741153,"avatar":"","nickname":"Geek_Th","note":"","ucode":"D09996D9DAA9A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209052,"discussion_content":"<!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper-recipes -->\n<dependency>\n    <groupId>org.apache.zookeeper</groupId>\n    <artifactId>zookeeper-recipes</artifactId>\n    <version>3.5.5.7.0.3.0-79</version>\n    <type>pom</type>\n</dependency>\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584603617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1741153,"avatar":"","nickname":"Geek_Th","note":"","ucode":"D09996D9DAA9A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209051,"discussion_content":"不是 server 模块 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584603609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275326,"user_name":"滩涂曳尾","can_delete":false,"product_type":"c3","uid":1187478,"ip_address":"","ucode":"40F650F2A419D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","comment_is_top":false,"comment_ctime":1611473185,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"老师，之所以不用一个znode来实现分布式锁，主要就是为了防止羊群效应吗","like_count":1},{"had_liked":false,"id":234734,"user_name":"长脖子树","can_delete":false,"product_type":"c3","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1594782026,"is_pvip":true,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"感觉还是文字版要清晰, 使用zookeeper创建分布式锁的过程如下:\n1. create  EPHEMERAL_SEQUENTIAL 节点   &#47;lock&#47;xxx-0000000003\n2. 获取所有已经创建的子节点, 但不注册 watcher    &#47;lock&#47;xxx-0000000001  &#47;lock&#47;xxx-0000000002 &#47;lock&#47;xxx-0000000003\n3. 如果发现自己是最小的那个, 则客户端已经获得了锁\n4. 如果不是最小的, 则通过调用 exists() 前一个节点 &#47;lock&#47;xxx-0000000002, 并注册 watcher\n5. 当 watcher 收到前一个节点(&#47;lock&#47;xxx-0000000002) node delete 事件时, 则说明自己获取了锁","like_count":1,"discussions":[{"author":{"id":2171678,"avatar":"https://static001.geekbang.org/account/avatar/00/21/23/1e/cc62c8a8.jpg","nickname":"大桃子又好吃","note":"","ucode":"C84EBAB4B1DF15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305209,"discussion_content":"最后一点不太对，当收到前一个节点的delete时，应该是重新走第二步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227811,"user_name":"dream","can_delete":false,"product_type":"c3","uid":1117793,"ip_address":"","ucode":"65B33D32FA8BE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/61/ae68f8eb.jpg","comment_is_top":false,"comment_ctime":1592486288,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100034201,"comment_content":"老师，请问一下，java程序与zk连接 close() 后，在服务器使用 netstat 查看 2181 端口会有一个 TIME_WAIT 的连接，但是过一段时间，这个连接就没有了，能说一下这是什么原因吗？\n","like_count":0,"discussions":[{"author":{"id":2361341,"avatar":"","nickname":"Geek_bd27f3","note":"","ucode":"53C31862383C25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333431,"discussion_content":"TIME_WAIT是主动关闭连接的一方会处于的一个状态，处在这个状态的时间默认是2MSL，也就是1分钟的时间。MSL在linux上的大小是30s。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607519962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227810,"user_name":"dream","can_delete":false,"product_type":"c3","uid":1117793,"ip_address":"","ucode":"65B33D32FA8BE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/61/ae68f8eb.jpg","comment_is_top":false,"comment_ctime":1592485983,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100034201,"comment_content":"老师，请问一下我在自己的测试用例里面关闭连接报以下错误是什么原因呢？\n09:10:20,457 [main-SendThread(47.98.142.170:2181)] WARN  org.apache.zookeeper.ClientCnxn  - An exception was thrown while closing send thread for session 0x1054fb4db5c001f.\nEndOfStreamException: Unable to read additional data from server sessionid 0x1054fb4db5c001f, likely server has closed socket\n\tat org.apache.zookeeper.ClientCnxnSocketNIO.doIO(ClientCnxnSocketNIO.java:75)\n\tat org.apache.zookeeper.ClientCnxnSocketNIO.doTransport(ClientCnxnSocketNIO.java:348)\n\tat org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1262)\n09:10:20,560 [main-EventThread] INFO  com.xh.zk.ApiTest  - WatchedEvent state:Closed type:None path:null\n\n我的代码如下(主要是在关闭连接的时候报的错误)：\n    @Test\n    public void testConnect() throws Exception {\n        &#47;&#47; ZooKeeper(connectString, sessionTimeout, watcher)\n        ZooKeeper zk = new ZooKeeper(&quot;47.98.142.170:2181&quot;, 100, getCommonWatcher());\n        List&lt;String&gt; children = zk.getChildren(&quot;&#47;&quot;, getCommonWatcher());\n        log.info(&quot;children.size() : [{}]&quot;, children.size());\n        if (!children.isEmpty()) {\n            children.forEach(log::info);\n        }\n        \n        zk.close();\n    }","like_count":0},{"had_liked":false,"id":167181,"user_name":"Keep","can_delete":false,"product_type":"c3","uid":1178075,"ip_address":"","ucode":"ADFD481F03AB84","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/db/51457469.jpg","comment_is_top":false,"comment_ctime":1577709311,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100034201,"comment_content":"同时通知多少client会有羊群效应？如果对于集群规模不是很大的系统采用：jvm锁+zk分布式锁也就是要获取到jvm锁之后才去获取zk的锁，这样zk需要通知的client就是集群数量-1，这样实现是否可行？","like_count":0},{"had_liked":false,"id":162655,"user_name":"Demon.Lee","can_delete":false,"product_type":"c3","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1576573779,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100034201,"comment_content":"老师，如果使用curator框架进行分布式锁的实现（针对并发修改表中的一条记录），\nInterProcessMutex lock = new InterProcessMutex(client, lockPath);\n故我对表中的id字段进行加锁，但是这个id不能放在上面的lockPath中，否则在zookeeper中就会产生成千上万个znode。所以，这个id必须是临时节点，但是InterProcessMutex中好像没有找到相应的api，是否只能走zookeeper原生的方式实现吗","like_count":0,"discussions":[{"author":{"id":1068432,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","nickname":"马文龙","note":"","ucode":"679B0F0AB402C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370842,"discussion_content":"您的问题感觉有点迷糊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619547444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792873,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5b/69/15237720.jpg","nickname":"空白格","note":"","ucode":"EC60EAE256C22B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229379,"discussion_content":"有点疑惑， 分布式锁是为了解决不同服务下的共享资源(我理解的是类似理财的某一只产品的申购额度需要抢占的那种)的问题，但是您的成千上万个的记录有必要使用分布式锁来实现吗？，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586622797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}