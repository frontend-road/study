{"id":173167,"title":"04 | 容器汇编 I：比较简单的若干容器","content":"<p>你好，我是吴咏炜。</p><p>上几讲我们学习了 C++ 的资源管理和值类别。今天我们换一个话题，来看一下 C++ 里的容器。</p><p>关于容器，已经存在不少的学习资料了。在 cppreference 上有很完备的参考资料（<span class=\"orange\">[1]</span>）。今天我们采取一种非正规的讲解方式，尽量不重复已有的参考资料，而是让你加深对于重要容器的理解。</p><p>对于容器，学习上的一个麻烦点是你无法直接输出容器的内容——如果你定义了一个 <code>vector&lt;int&gt; v</code>，你是没法简单输出 <code>v</code> 的内容的。有人也许会说用 <code>copy(v.begin(), v.end(), ostream_iterator(…))</code>，可那既啰嗦，又对像 <code>map</code> 或 <code>vector&lt;vector&lt;…&gt;&gt;</code> 这样的复杂类型无效。因此，我们需要一个更好用的工具。在此，我向你大力推荐 xeus-cling <span class=\"orange\">[2]</span>。它的便利性无与伦比——你可以直接在浏览器里以交互的方式运行代码，不需要本机安装任何编译器（点击“Trying it online”下面的 binder 链接）。下面是在线运行的一个截图：</p><p><img src=\"https://static001.geekbang.org/resource/image/71/ca/7199bb5b1394fe1aa9f91b850c309eca.png?wh=1064*771\" alt=\"\"></p><p>xeus-cling 也可以在本地安装。对于使用 Linux 的同学，安装应当是相当便捷的。有兴趣的话，使用其他平台的同学也可以尝试一下。</p><p>如果你既没有本地运行的条件，也不方便远程使用互联网来运行代码，我个人还为本专栏写了一个小小的工具 <span class=\"orange\">[3]</span>。在你的代码中包含这个头文件，也可以方便地得到类似于上面的输出。示例代码如下所示：</p><!-- [[[read_end]]] --><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include \"output_container.h\"\n\nusing namespace std;\n\nint main()\n{\n  map&lt;int, int&gt; mp{\n    {1, 1}, {2, 4}, {3, 9}};\n  cout &lt;&lt; mp &lt;&lt; endl;\n  vector&lt;vector&lt;int&gt;&gt; vv{\n    {1, 1}, {2, 4}, {3, 9}};\n  cout &lt;&lt; vv &lt;&lt; endl;\n}\n</code></pre><p>我们会得到下面的输出：</p><blockquote>\n<p><code>{ 1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9 }</code><br>\n<code>{ { 1, 1 }, { 2, 4 }, { 3, 9 } }</code></p>\n</blockquote><p>这个代码中用到了很多我们目前专栏还没有讲的知识，所以你暂且不用关心它的实现原理。如果你能看得懂这个代码，那就太棒了。如果你看不懂，唔，不急，慢慢来，你会明白的。</p><p>工具在手，天下我有。下面我们正式开讲容器篇。</p><h2>string</h2><p><code>string</code> 一般并不被认为是一个 C++ 的容器。但鉴于其和容器有很多共同点，我们先拿 <code>string</code> 类来开说。</p><p><code>string</code> 是模板 <code>basic_string</code> 对于 <code>char</code> 类型的特化，可以认为是一个只存放字符 <code>char</code> 类型数据的容器。“真正”的容器类与 <code>string</code> 的最大不同点是里面可以存放任意类型的对象。</p><p>跟其他大部分容器一样， <code>string</code> 具有下列成员函数：</p><ul>\n<li><code>begin</code> 可以得到对象起始点</li>\n<li><code>end</code> 可以得到对象的结束点</li>\n<li><code>empty</code> 可以得到容器是否为空</li>\n<li><code>size</code> 可以得到容器的大小</li>\n<li><code>swap</code> 可以和另外一个容器交换其内容</li>\n</ul><p>（对于不那么熟悉容器的人，需要知道 C++ 的 <code>begin</code> 和 <code>end</code> 是半开半闭区间：在容器非空时，<code>begin</code> 指向第一个元素，而 <code>end</code> 指向最后一个元素后面的位置；在容器为空时，<code>begin</code> 等于 <code>end</code>。在 <code>string</code> 的情况下，由于考虑到和 C 字符串的兼容，<code>end</code> 指向代表字符串结尾的 <code>\\0</code> 字符。）</p><p>上面就几乎是所有容器的共同点了。也就是说：</p><ul>\n<li>容器都有开始和结束点</li>\n<li>容器会记录其状态是否非空</li>\n<li>容器有大小</li>\n<li>容器支持交换</li>\n</ul><p>当然，这只是容器的“共同点”而已。每个容器都有其特殊的用途。</p><p><code>string</code> 的内存布局大致如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/62/eec393f933220a9998b7235c8acc1862.png?wh=1298*450\" alt=\"\"></p><p>下面你会看到，不管是内存布局，还是成员函数，<code>string</code> 和 <code>vector</code> 是非常相似的。</p><p><code>string</code> 当然是为了存放字符串。和简单的 C 字符串不同：</p><ul>\n<li><code>string</code> 负责自动维护字符串的生命周期</li>\n<li><code>string</code> 支持字符串的拼接操作（如之前说过的 <code>+</code> 和 <code>+=</code>）</li>\n<li><code>string</code> 支持字符串的查找操作（如 <code>find</code> 和 <code>rfind</code>）</li>\n<li><code>string</code> 支持从 <code>istream</code> 安全地读入字符串（使用 <code>getline</code>）</li>\n<li><code>string</code> 支持给期待 <code>const char*</code> 的接口传递字符串内容（使用 <code>c_str</code>）</li>\n<li><code>string</code> 支持到数字的互转（<code>stoi</code> 系列函数和 <code>to_string</code>）</li>\n<li>等等</li>\n</ul><p>推荐你在代码中尽量使用 <code>string</code> 来管理字符串。不过，对于对外暴露的接口，情况有一点复杂。我一般不建议在接口中使用 <code>const string&amp;</code>，除非确知调用者已经持有 <code>string</code>：如果函数里不对字符串做复杂处理的话，使用 <code>const char*</code> 可以避免在调用者只有 C 字符串时编译器自动构造 <code>string</code>，这种额外的构造和析构代价并不低。反过来，如果实现较为复杂、希望使用 <code>string</code> 的成员函数的话，那就应该考虑下面的策略：</p><ul>\n<li>如果不修改字符串的内容，使用 <code>const string&amp;</code> 或 C++17 的 <code>string_view</code> 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>\n<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 <code>string</code> 作为参数类型（自动拷贝）。</li>\n<li>如果需要改变调用者的字符串内容，使用 <code>string&amp;</code> 作为参数类型（通常不推荐）。</li>\n</ul><p>估计大部分同学对 <code>string</code> 已经很熟悉了。我们在此只给出一个非常简单的小例子：</p><pre><code class=\"language-c++\">string name;\ncout &lt;&lt; \"What's your name? \";\ngetline(cin, name);\ncout &lt;&lt; \"Nice to meet you, \" &lt;&lt; name\n     &lt;&lt; \"!\\n\";\n</code></pre><h2>vector</h2><p><code>vector</code> 应该是最常用的容器了。它的名字“向量”来源于数学术语，但在实际应用中，我们把它当成动态数组更为合适。它基本相当于 Java 的 <code>ArrayList</code> 和 Python 的 <code>list</code>。</p><p>和 <code>string</code> 相似，<code>vector</code> 的成员在内存里连续存放，同时 <code>begin</code>、<code>end</code>、<code>front</code>、<code>back</code> 成员函数指向的位置也和 <code>string</code> 一样，大致如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/24/10/247951f886561c30ced2eb7700f9d510.png?wh=1298*450\" alt=\"\"></p><p>除了容器类的共同点，<code>vector</code> 允许下面的操作（不完全列表）：</p><ul>\n<li>可以使用中括号的下标来访问其成员（同 <code>string</code>）</li>\n<li>可以使用 <code>data</code> 来获得指向其内容的裸指针（同 <code>string</code>）</li>\n<li>可以使用 <code>capacity</code> 来获得当前分配的存储空间的大小，以元素数量计（同 <code>string</code>）</li>\n<li>可以使用 <code>reserve</code> 来改变所需的存储空间的大小，成功后 <code>capacity()</code> 会改变（同 <code>string</code>）</li>\n<li>可以使用 <code>resize</code> 来改变其大小，成功后 <code>size()</code> 会改变（同 <code>string</code>）</li>\n<li>可以使用 <code>pop_back</code> 来删除最后一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>push_back</code> 在尾部插入一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>insert</code> 在指定位置前插入一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>erase</code> 在指定位置删除一个元素（同 <code>string</code>）</li>\n<li>可以使用 <code>emplace</code> 在指定位置构造一个元素</li>\n<li>可以使用 <code>emplace_back</code> 在尾部新构造一个元素</li>\n</ul><p>大家可以留意一下 <code>push_…</code> 和 <code>pop_…</code> 成员函数。它们存在时，说明容器对指定位置的删除和插入性能较高。<code>vector</code> 适合在尾部操作，这是它的内存布局决定的。只有在尾部插入和删除时，其他元素才会不需要移动，除非内存空间不足导致需要重新分配内存空间。</p><p>当 <code>push_back</code>、<code>insert</code>、<code>reserve</code>、<code>resize</code> 等函数导致内存重分配时，或当 <code>insert</code>、<code>erase</code> 导致元素位置移动时，<code>vector</code> 会试图把元素“移动”到新的内存区域。<code>vector</code> 通常保证强异常安全性，如果元素类型没有提供一个<strong>保证不抛异常的移动构造函数</strong>，<code>vector</code> 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 <code>noexcept</code>，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 <code>smart_ptr</code> 的实现中标上 <code>noexcept</code> 的原因。</p><p>下面的代码可以演示这一行为：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Obj1 {\npublic:\n  Obj1()\n  {\n    cout &lt;&lt; \"Obj1()\\n\";\n  }\n  Obj1(const Obj1&amp;)\n  {\n    cout &lt;&lt; \"Obj1(const Obj1&amp;)\\n\";\n  }\n  Obj1(Obj1&amp;&amp;)\n  {\n    cout &lt;&lt; \"Obj1(Obj1&amp;&amp;)\\n\";\n  }\n};\n\nclass Obj2 {\npublic:\n  Obj2()\n  {\n    cout &lt;&lt; \"Obj2()\\n\";\n  }\n  Obj2(const Obj2&amp;)\n  {\n    cout &lt;&lt; \"Obj2(const Obj2&amp;)\\n\";\n  }\n  Obj2(Obj2&amp;&amp;) noexcept\n  {\n    cout &lt;&lt; \"Obj2(Obj2&amp;&amp;)\\n\";\n  }\n};\n\nint main()\n{\n  vector&lt;Obj1&gt; v1;\n  v1.reserve(2);\n  v1.emplace_back();\n  v1.emplace_back();\n  v1.emplace_back();\n\n  vector&lt;Obj2&gt; v2;\n  v2.reserve(2);\n  v2.emplace_back();\n  v2.emplace_back();\n  v2.emplace_back();\n}\n</code></pre><p>我们可以立即得到下面的输出：</p><blockquote>\n<p><code>Obj1()</code><br>\n<code>Obj1()</code><br>\n<code>Obj1()</code><br>\n<code>Obj1(const Obj1&amp;)</code><br>\n<code>Obj1(const Obj1&amp;)</code><br>\n<code>Obj2()</code><br>\n<code>Obj2()</code><br>\n<code>Obj2()</code><br>\n<code>Obj2(Obj2&amp;&amp;)</code><br>\n<code>Obj2(Obj2&amp;&amp;)</code></p>\n</blockquote><p><code>Obj1</code> 和 <code>Obj2</code> 的定义只差了一个 <code>noexcept</code>，但这个小小的差异就导致了 <code>vector</code> 是否会移动对象。这点非常重要。</p><p>C++11 开始提供的 <code>emplace…</code> 系列函数是为了提升容器的性能而设计的。你可以试试把 <code>v1.emplace_back()</code> 改成 <code>v1.push_back(Obj1())</code>。对于 <code>vector</code> 里的内容，结果是一样的；但使用 <code>push_back</code> 会额外生成临时对象，多一次（移动或拷贝）构造和析构。如果是移动的情况，那会有小幅性能损失；如果对象没有实现移动的话，那性能差异就可能比较大了。</p><p>现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，<code>vector</code> 的连续内存使用是它的一大优势所在。当你不知道该用什么容器时，缺省就使用 <code>vector</code> 吧。</p><p><code>vector</code> 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 <code>reserve</code> 函数为 <code>vector</code> 保留所需的内存，这在 <code>vector</code> 预期会增长很大时能带来很大的性能提升。</p><h2>deque</h2><p><code>deque</code> 的意思是 double-ended queue，双端队列。它主要是用来满足下面这个需求：</p><ul>\n<li>容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。</li>\n</ul><p><code>deque</code> 的接口和 <code>vector</code> 相比，有如下的区别：</p><ul>\n<li><code>deque</code> 提供 <code>push_front</code>、<code>emplace_front</code> 和 <code>pop_front</code> 成员函数。</li>\n<li><code>deque</code> 不提供 <code>data</code>、<code>capacity</code> 和 <code>reserve</code> 成员函数。</li>\n</ul><p><code>deque</code> 的内存布局一般是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/a1/aea92e7e005d65fa56d6332bb7706fa1.png?wh=1104*832\" alt=\"\"></p><p>可以看到：</p><ul>\n<li>如果只从头、尾两个位置对 <code>deque</code> 进行增删操作的话，容器里的对象永远不需要移动。</li>\n<li>容器里的元素只是部分连续的（因而没法提供 <code>data</code> 成员函数）。</li>\n<li>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。</li>\n<li>由于每一段存储大小相等，<code>deque</code> 支持使用下标访问容器元素，大致相当于 <code>index[i / chunk_size][i % chunk_size]</code>，也保持高效。</li>\n</ul><p>如果你需要一个经常在头尾增删元素的容器，那 <code>deque</code> 会是个合适的选择。</p><h2>list</h2><p><code>list</code> 在 C++ 里代表双向链表。和 <code>vector</code> 相比，它优化了在容器中间的插入和删除：</p><ul>\n<li><code>list</code> 提供高效的、O(1) 复杂度的任意位置的插入和删除操作。</li>\n<li><code>list</code> 不提供使用下标访问其元素。</li>\n<li><code>list</code> 提供 <code>push_front</code>、<code>emplace_front</code> 和 <code>pop_front</code> 成员函数（和 <code>deque</code> 相同）。</li>\n<li><code>list</code> 不提供 <code>data</code>、<code>capacity</code> 和 <code>reserve</code> 成员函数（和 <code>deque</code> 相同）。</li>\n</ul><p>它的内存布局一般是下图这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/ad/14/addb521e20de1a302206f4286eac3914.png?wh=1388*788\" alt=\"\"></p><p>需要指出的是，虽然 <code>list</code> 提供了任意位置插入新元素的灵活性，但由于每个元素的内存空间都是单独分配、不连续，它的遍历性能比 <code>vector</code> 和 <code>deque</code> 都要低。这在很大程度上抵消了它在插入和删除操作时不需要移动元素的理论性能优势。如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用 <code>list</code>。</p><p>另外一个需要注意的地方是，因为某些标准算法在 <code>list</code> 上会导致问题，list 提供了成员函数作为替代，包括下面几个：</p><ul>\n<li><code>merge</code></li>\n<li><code>remove</code></li>\n<li><code>remove_if</code></li>\n<li><code>reverse</code></li>\n<li><code>sort</code></li>\n<li><code>unique</code></li>\n</ul><p>下面是一个示例（以 xeus-cling 的交互为例）：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">list&lt;int&gt; lst{1, 7, 2, 8, 3};\nvector&lt;int&gt; vec{1, 7, 2, 8, 3};\n</code></pre><pre><code class=\"language-c++\">sort(vec.begin(), vec.end());     // 正常\n// sort(lst.begin(), lst.end());  // 会出错\nlst.sort();                       // 正常\n</code></pre><pre><code class=\"language-c++\">lst  // 输出 { 1, 2, 3, 7, 8 }\n</code></pre><pre><code class=\"language-c++\">vec  // 输出 { 1, 2, 3, 7, 8 }\n</code></pre><p>如果不用 xeus-cling 的话，我们需要做点转换：</p><ul>\n<li>把 <code>using namespace std;</code> 后面的部分放到 <code>main</code> 函数里。</li>\n<li>文件开头加上 <code>#include \"output_container.h\"</code> 和 <code>#include &lt;iostream&gt;</code>。</li>\n<li>把输出语句改写成 <code>cout &lt;&lt; … &lt;&lt; endl;</code>。</li>\n</ul><p>这次我会给一下改造的示例（下次就请你自行改写了😉）：</p><pre><code class=\"language-c++\">#include \"output_container.h\"\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main()\n{\n  list&lt;int&gt; lst{1, 7, 2, 8, 3};\n  vector&lt;int&gt; vec{1, 7, 2, 8, 3};\n\n  sort(vec.begin(), vec.end());    // 正常\n  // sort(lst.begin(), lst.end()); // 会出错\n  lst.sort();                      // 正常\n\n  cout &lt;&lt; lst &lt;&lt; endl;\n  // 输出 { 1, 2, 3, 7, 8 }\n\n  cout &lt;&lt; vec &lt;&lt; endl;\n  // 输出 { 1, 2, 3, 7, 8 }\n}\n</code></pre><h2>forward_list</h2><p>既然 <code>list</code> 是双向链表，那么 C++ 里有没有单向链表呢？答案是肯定的。从 C++11 开始，前向列表 <code>forward_list</code> 成了标准的一部分。</p><p>我们先看一下它的内存布局：</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/4e/ef23c4d60940c170629cf65771df084e.png?wh=1388*788\" alt=\"\"></p><p>大部分 C++ 容器都支持 <code>insert</code> 成员函数，语义是从指定的位置之前插入一个元素。对于 <code>forward_list</code>，这不是一件容易做到的事情（想一想，为什么？）。标准库提供了一个 <code>insert_after</code> 作为替代。此外，它跟 <code>list</code> 相比还缺了下面这些成员函数：</p><ul>\n<li><code>back</code></li>\n<li><code>size</code></li>\n<li><code>push_back</code></li>\n<li><code>emplace_back</code></li>\n<li><code>pop_back</code></li>\n</ul><p>为什么会需要这么一个阉割版的 list 呢？原因是，在元素大小较小的情况下，<code>forward_list</code> 能节约的内存是非常可观的；在列表不长的情况下，不能反向查找也不是个大问题。提高内存利用率，往往就能提高程序性能，更不用说在内存可能不足时的情况了。</p><p>目前你只需要知道这个东西的存在就可以了。如果你觉得不需要用到它的话，也许你真的不需要它。</p><h2>queue</h2><p>在结束本讲之前，我们再快速讲两个类容器。它们的特别点在于它们都不是完整的实现，而是依赖于某个现有的容器，因而被称为容器适配器（container adaptor）。</p><p>我们先看一下队列 <code>queue</code>，先进先出（FIFO）的数据结构。</p><p><code>queue</code> 缺省用 <code>deque</code> 来实现。它的接口跟 <code>deque</code> 比，有如下改变：</p><ul>\n<li>不能按下标访问元素</li>\n<li>没有 <code>begin</code>、<code>end</code> 成员函数</li>\n<li>用 <code>emplace</code> 替代了 <code>emplace_back</code>，用 <code>push</code> 替代了 <code>push_back</code>，用 <code>pop</code> 替代了 <code>pop_front</code>；没有其他的 <code>push_…</code>、<code>pop_…</code>、<code>emplace…</code>、<code>insert</code>、<code>erase</code> 函数</li>\n</ul><p>它的实际内存布局当然是随底层的容器而定的。从概念上讲，它的结构可如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/09/ff/090f23e3b4cdd8d297e4b970cbbf6cff.png?wh=1298*450\" alt=\"\"></p><p>鉴于 <code>queue</code> 不提供 <code>begin</code> 和 <code>end</code> 方法，无法无损遍历，我们只能用下面的代码约略展示一下其接口：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nint main()\n{\n  std::queue&lt;int&gt; q;\n  q.push(1);\n  q.push(2);\n  q.push(3);\n  while (!q.empty()) {\n    std::cout &lt;&lt; q.front()\n              &lt;&lt; std::endl;\n    q.pop();\n  }\n}\n</code></pre><p>这个代码的输出就不用解释了吧。哈哈。</p><h2>stack</h2><p>类似地，栈 <code>stack</code> 是后进先出（LIFO）的数据结构。</p><p><code>stack</code> 缺省也是用 <code>deque</code> 来实现，但它的概念和 <code>vector</code> 更相似。它的接口跟 <code>vector</code> 比，有如下改变：</p><ul>\n<li>不能按下标访问元素</li>\n<li>没有 <code>begin</code>、<code>end</code> 成员函数</li>\n<li><code>back</code> 成了 <code>top</code>，没有 <code>front</code></li>\n<li>用 <code>emplace</code> 替代了 <code>emplace_back</code>，用 <code>push</code> 替代了 <code>push_back</code>，用 <code>pop</code> 替代了 <code>pop_back</code>；没有其他的 <code>push_…</code>、<code>pop_…</code>、<code>emplace…</code>、<code>insert</code>、<code>erase</code> 函数</li>\n</ul><p>一般图形表示法会把 <code>stack</code> 表示成一个竖起的 <code>vector</code>：</p><p><img src=\"https://static001.geekbang.org/resource/image/68/47/68026091ff5eacac00c49d75151fff47.png?wh=1476*692\" alt=\"\"></p><p>这里有一个小细节需要注意。<code>stack</code> 跟我们前面讨论内存管理时的栈有一个区别：在这里下面是低地址，向上则地址增大；而我们讨论内存管理时，高地址在下面，向上则地址减小，方向正好相反。提这一点，是希望你在有需要检查栈结构时不会因此而发生混淆；在使用 <code>stack</code> 时，这个区别通常无关紧要。</p><p>示例代码和上面的 <code>queue</code> 相似，但输出正好相反：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nint main()\n{\n  std::stack&lt;int&gt; s;\n  s.push(1);\n  s.push(2);\n  s.push(3);\n  while (!s.empty()) {\n    std::cout &lt;&lt; s.top()\n              &lt;&lt; std::endl;\n    s.pop();\n  }\n}\n</code></pre><h2>内容小结</h2><p>本讲我们介绍了 C++ 里面的序列容器和两个容器适配器。通过本讲的介绍，你应该已经对容器有了一定的理解和认识。下一讲我们会讲完剩余的标准容器。</p><h2>课后思考</h2><p>留几个问题请你思考一下：</p><ol>\n<li>今天讲的容器有哪些共同的特点？</li>\n<li>为什么 C++ 有这么多不同的序列容器类型？</li>\n<li>为什么 <code>stack</code>（或 <code>queue</code>）的 <code>pop</code> 函数返回类型为 <code>void</code>，而不是直接返回容器的 <code>top</code>（或 <code>front</code>）成员？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Containers library”. <a href=\"https://en.cppreference.com/w/cpp/container\">https://en.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “容器库”. <a href=\"https://zh.cppreference.com/w/cpp/container\">https://zh.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[2] QuantStack, xeus-cling. <a href=\"https://github.com/QuantStack/xeus-cling\">https://github.com/QuantStack/xeus-cling</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, output_container. <a href=\"https://github.com/adah1972/output_container/blob/master/output_container.h\">https://github.com/adah1972/output_container/blob/master/output_container.h</a> </span></p>","neighbors":{"left":{"article_title":"03 | 右值和移动究竟解决了什么问题？","id":169268},"right":{"article_title":"05 | 容器汇编 II：需要函数对象的容器","id":174434}},"comments":[{"had_liked":false,"id":158902,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575474489,"is_pvip":false,"replies":[{"id":60819,"content":"很棒👌。\n\n异常安全是关键。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575509351,"ip_address":"","comment_id":158902,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我发现老师的问题基本都可以在文章中找到答案，\n1、2就不说了，3说一下我的理解:引用老师在vector那段的话 stack(queue)为保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数， 通常会使用拷贝构造函数，而pop作用是释放元素，c++98还没有移动构造的概念，所以如果返回成员，必须要调用拷贝构造函数，这时分配空间可能出错，导致构造失败，要抛出异常，所以没必要返回成员。","like_count":94},{"had_liked":false,"id":159018,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575515631,"is_pvip":false,"replies":[{"id":60858,"content":"catch住也没有用了。仔细想一下，我现在要把vector里的两个对象移到一个新的vector，移第一个成功，第二个时有异常，然后vector该怎么办？现在两个vector都废掉了。\n\n拷贝不影响旧的容器。即使发生异常，至少老的那个还是好的。这就是异常安全。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575540016,"ip_address":"","comment_id":159018,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请教一个问题，\n#1\n为什么一定强制移动构造函数不要抛出异常？\n移动构造函数抛出异常后，catch处理不可以吗？\n\n#2\n为什么拷贝构造函数被允许抛出异常？\n\n能麻烦给些代码说明一下吗？\n\n非常感谢！","like_count":57,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476916,"discussion_content":"catch住也没有用了。仔细想一下，我现在要把vector里的两个对象移到一个新的vector，移第一个成功，第二个时有异常，然后vector该怎么办？现在两个vector都废掉了。\n\n拷贝不影响旧的容器。即使发生异常，至少老的那个还是好的。这就是异常安全。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575540016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004350,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/95/7e/1057f77a.jpg","nickname":"四有青年","note":"","ucode":"121A7C613E6C32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300092,"discussion_content":"解答了我的疑惑，感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597933785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158691,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1575434728,"is_pvip":false,"replies":[{"id":60761,"content":"3的正解终于出现，有人说到“异常安全”了。👍\n\n再说两句，这是C++98时设计的接口，没有移动就只能那样。有了移动，在多线程的环境里，移动返回加弹出实际上就变得有用了。我对复杂和可读性部分不那么同意。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464632,"ip_address":"","comment_id":158691,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1.都是线性容器\n2.不同容器功能，效率不一样\n3.实现pop时返回元素时，满足强异常安全，代码实现复杂，可读性差。","like_count":31,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476916,"discussion_content":"catch住也没有用了。仔细想一下，我现在要把vector里的两个对象移到一个新的vector，移第一个成功，第二个时有异常，然后vector该怎么办？现在两个vector都废掉了。\n\n拷贝不影响旧的容器。即使发生异常，至少老的那个还是好的。这就是异常安全。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575540016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004350,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/95/7e/1057f77a.jpg","nickname":"四有青年","note":"","ucode":"121A7C613E6C32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300092,"discussion_content":"解答了我的疑惑，感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597933785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160926,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576061887,"is_pvip":false,"replies":[{"id":61377,"content":"头两个在已有空间上成功构造。第三个时发现空间不足，系统会请求更大的空间，大小由实现决定（比如两倍）。有了足够的空间后，就会在新空间的第三个的位置构造（第三个obj1），成功之后再把头两个拷贝或移动过来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576106181,"ip_address":"","comment_id":160926,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师您好，我是那个那天问您vector演示代码的学生，还需要接着请教这段代码的一些问题。因为我刚接触c++不久，可能有些基本语法理解的不是很到位还没有那么深，就需要再问几个基础的问题了。就先请教obj1部分的函数吧，先用reserve（2）预留了两个存储空间，然后接着用emplace_back()在最后面构造新元素，所以说因为有两个新开的空间那么前两次用emplace_back()构造元素成功就调用构造函数抛出两个obj1( )不知道理解的对不对？那第三个obj1( )是怎么来的呢？后面两个obj1( const obj1&amp;)怎么来的也不是很理解？这里的obj1&amp;为什么要定义成const类型呢？\n还有就是我现阶段对构造函数的理解还停留在初始化的意思上理解地还是太浅吧，不知道该怎么再往深理解一下？\n麻烦老师再帮我解答一下问题，辛苦老师了💦","like_count":13,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476813,"discussion_content":"3的正解终于出现，有人说到“异常安全”了。👍\n\n再说两句，这是C++98时设计的接口，没有移动就只能那样。有了移动，在多线程的环境里，移动返回加弹出实际上就变得有用了。我对复杂和可读性部分不那么同意。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575464632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163431,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1576720851,"is_pvip":false,"replies":[{"id":62122,"content":"学习很认真，回答也基本抓住要点了，尤其问题 2 和 3。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576731336,"ip_address":"","comment_id":163431,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"《现代C++实战31讲》第一天\n容器汇编1：比较简单的若干容器\n一、容器的输出：\n1.简单容器(如：vector)输出就是遍历（v.begin，v.end）\n2.复杂容器(如：vector&lt;vector&gt;)就需要工具 xeus-cling\n二、string \n1.接口中不建议使用const string&amp; ，除非确实知道调用者使用的是string，如果函数不对字符串做特殊处理的话用const char* 可以避免在调用字符串的时候构造string\n三、vector\n1.vector主要缺陷是大小的增长导致的元素移动，如果可能，尽早使用reserve函数为vector保留所需要的内存，在vector预期会增长很大时带来很大的性能提升\n四、deque\n1.如果需要经常在头尾增删元素内容，deque会合适\n五、list\n1.list 是双向链表\n2.forward_list是单向链表\n六、stack\n1.后进先出，底层由deque实现\n课后思考：\n1.容器有哪些共同点\n答：都是线性容器，非关联容器\n2.为什么C++有那么多不同的序列容器类型\n答：不同容器对应实现不同需求，效率不同\n3.为什么stack(或者queue) pop函数返回的是void而不是直接返回内容\n答：为了保证异常安全，如果返回的成员构造失败就会抛出异常。","like_count":8,"discussions":[{"author":{"id":1152178,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/b2/6d587bb1.jpg","nickname":"久违的","note":"","ucode":"34F703D88A643D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305508,"discussion_content":"Obj1() //已申请的空间的第一个位置(老空间)\nObj1() //已申请的空间的第二个位置(老空间)\nObj1() //新申请的双倍空间的第三个位置(新空间)\nObj1(const Obj1&amp;) //将老空间的第一个位置的元素拷贝到新空间第一个位置\nObj1(const Obj1&amp;) //将老空间的第二个位置的元素拷贝到新空间第二个位置","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1599972675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477534,"discussion_content":"头两个在已有空间上成功构造。第三个时发现空间不足，系统会请求更大的空间，大小由实现决定（比如两倍）。有了足够的空间后，就会在新空间的第三个的位置构造（第三个obj1），成功之后再把头两个拷贝或移动过来。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576106181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159480,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1575634296,"is_pvip":false,"replies":[{"id":60973,"content":"关于几次拷贝&#47;移动的问题？参考 hello world 的评论下的廖熊猫的回答：\n\n在插入的时候，你会发现空间不够了，然后开辟新的空间，在新空间先把最后插入的元素放好，然后再依次把以前的元素一个一个挪过来。空间不够的话最后一个元素是没法插入进去的啊，所以没办法移动三次的。\n\n还有我自己的回答：\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动&#47;拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。\n\n如果不是这个问题。请把问题阐释得更详细些。可以重新开一个新的评论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575687403,"ip_address":"","comment_id":159480,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师 您好  我是一个c++的初学者😳，这一讲的容器的概念原理都理解了，就是vector那一段的演示代码推不出老师的结果来，能不能麻烦老师再解释一下那段代码，辛苦老师了👨‍🏫！","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478389,"discussion_content":"学习很认真，回答也基本抓住要点了，尤其问题 2 和 3。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576731336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158628,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1575424351,"is_pvip":false,"replies":[{"id":60728,"content":"挺好。三比其他回答已经进一步了，但还是没有触及到某个关键字。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575435465,"ip_address":"","comment_id":158628,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第一个问题 今天讲的大多是线性结构的容器，也可以说大多是非关联容器\n\n第二个问题  应该不只是c++  所有语言都提供了，之所以对其封装是便于使用，不需要用户自己去造轮子。同时有些容器内部有迭代器 与stl算法相结合可以便于实现泛型编程。c++委员会想让c++成为一个多元化的语言支持 面向对象 面向过程 泛型编程\n\n第三个问题 将对容器的操作与获取值的操作分离开，用途会更明确。同时pop由于已经从容器中剔除了那个元素，那么返回的只能是个拷贝不允许返回已销毁元素的引用。这意味着需要一次拷贝构造操作。而top只需要返回指定元素的引用，高效简洁。将两次操作分开使得操作更明确同时没有额外开销。\n\n个人见解  请老师赐教😃","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477073,"discussion_content":"关于几次拷贝/移动的问题？参考 hello world 的评论下的廖熊猫的回答：\n\n在插入的时候，你会发现空间不够了，然后开辟新的空间，在新空间先把最后插入的元素放好，然后再依次把以前的元素一个一个挪过来。空间不够的话最后一个元素是没法插入进去的啊，所以没办法移动三次的。\n\n还有我自己的回答：\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动/拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。\n\n如果不是这个问题。请把问题阐释得更详细些。可以重新开一个新的评论。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575687403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211303,"discussion_content":"自己反应过来了，回复自己一下，如果要使用移动构造vector要求必须是nonexcept，所以不会出现上述情况。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584839725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211300,"discussion_content":"借着老师的回答问一下，按照上述步骤，如果第3步的移动/拷贝旧的对象过程中出问题，而窗口内有的元素已经用移动构造把数据移走，那么原容器内的元素已经无效，能否在catch异常的时候做补救把数据移动回到旧容器中呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584839498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77896,"discussion_content":"好吧，刚刚看第三课。移动构造函数的参数是一个右值引用，是一个xvalue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575953483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77854,"discussion_content":"老师，我这块不太懂，为什么移动构造函数的参数是(Obj1&amp;&amp;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575948434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1725046,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","nickname":"Alice","note":"","ucode":"F0EDC16AC27088","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79066,"discussion_content":"你从新在留言区开一个帖子问老师，这里老师看不到问题的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576052751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77854,"ip_address":"","group_id":0},"score":79066,"extra":""}]}]},{"had_liked":false,"id":275648,"user_name":"农民园丁","can_delete":false,"product_type":"c1","uid":1155913,"ip_address":"","ucode":"6A91EBBC9DCE6C","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/49/4a488f4c.jpg","comment_is_top":false,"comment_ctime":1611632823,"is_pvip":false,"replies":[{"id":100037,"content":"首先，vector 的内存空间必然是连续的。\n\n移动是移动对象，而不是指针。对象内部有什么，什么是合理的移动，由这个对象来定义。就我给出的例子，Obj2 大小为 1，所以移动就是把这个 1 字节的对象移动过去，执行的是 Obj2(Obj2&amp;&amp;)——真实的类就靠这个干活了，而我这里实际什么都没有做。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611639119,"ip_address":"","comment_id":275648,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第三遍学习，产生一个困惑，请教吴老师：\n采用不抛出异常的移动构造函数，会不会导致vector的内存不连续呢？\n在上面的例子中，构造第3个Obj2对象时空间不足自动扩充，此时的空间为新分配的内存空间。\n之后在新的空间第3个位置构造Obj2，然后将原空间第1、2个对象移动到新空间的第1、2个位置。\n这个移动的过程是否只是将原空间第1、2个对象的指针移动到了新的空间？这样是不是新的vector空间内存布局就不连续了？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514425,"discussion_content":"首先，vector 的内存空间必然是连续的。\n\n移动是移动对象，而不是指针。对象内部有什么，什么是合理的移动，由这个对象来定义。就我给出的例子，Obj2 大小为 1，所以移动就是把这个 1 字节的对象移动过去，执行的是 Obj2(Obj2&amp;amp;&amp;amp;)——真实的类就靠这个干活了，而我这里实际什么都没有做。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611639119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155913,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/49/4a488f4c.jpg","nickname":"农民园丁","note":"","ucode":"6A91EBBC9DCE6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345213,"discussion_content":"理解了，感谢老师解惑！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611701256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160705,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1576024235,"is_pvip":false,"replies":[{"id":61350,"content":"对，缺省情况下，std::terminate 会被调用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576059719,"ip_address":"","comment_id":160705,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，假如移动构造函数被声明为noexcept了，诱导编译器调用移动构造，而此时却又抛异常了，程序也会直接停止吗？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514425,"discussion_content":"首先，vector 的内存空间必然是连续的。\n\n移动是移动对象，而不是指针。对象内部有什么，什么是合理的移动，由这个对象来定义。就我给出的例子，Obj2 大小为 1，所以移动就是把这个 1 字节的对象移动过去，执行的是 Obj2(Obj2&amp;amp;&amp;amp;)——真实的类就靠这个干活了，而我这里实际什么都没有做。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611639119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155913,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/49/4a488f4c.jpg","nickname":"农民园丁","note":"","ucode":"6A91EBBC9DCE6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345213,"discussion_content":"理解了，感谢老师解惑！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611701256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160193,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575888941,"is_pvip":false,"replies":[{"id":61130,"content":"Java是引用语义，返回对象就是返回个指针，没有任何问题。\n\nC++是值语义，以前返回对象只能是拷贝，可能发生异常。一旦发生异常，对象已经被弹出，那它就彻底“丢失”了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575896509,"ip_address":"","comment_id":160193,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好 第三个问题能不能这样理解 pop作用是弹出最后一个对象 弹出后该对象内存已经脱离容器当前所管理的有效的范围 虽然该片内存在后续有push操作时候还会被重复使用到 但是pop执行完后 该片内存逻辑层面看是暂时脱离了容器的管理范围的 显然pop不能将该片内存以引用方式传给外面 否则外部会持有一片目前脱离管理的无效内存 外部再对这片内存不论读还是写都是不合适的 所以pop如果要反返回对象 只能选择拷贝方式返回 会触发拷贝构造 对于内存占用大或者是需要进行深拷贝的对象而言 这个操作开销太大了 所以选择用top 返回可以安全访问的对象引用 而pop就单纯作为退栈操作不返回对象 我个人理解这样设计api 接口是为了避免不安全地访问内存 对比Java的 stack的 pop接口 Java的pop接口就返回了栈顶对象 因为这个对象内存托管给了jvm管理 调用端拿到了这个出栈的对象的引用也不会有访问内存的问题 但是c++如果把对象内存通过引用带给调用端 那调用端就可能直接读写容器内部的私有内存了 这片内存地址随时可能因为容器的扩容行为而变成野地址 对其访问其实并不安全 不知道我这样理解是否正确","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477458,"discussion_content":"对，缺省情况下，std::terminate 会被调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576059719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158902,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575474489,"is_pvip":false,"replies":[{"id":60819,"content":"很棒👌。\n\n异常安全是关键。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575509351,"ip_address":"","comment_id":158902,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我发现老师的问题基本都可以在文章中找到答案，\n1、2就不说了，3说一下我的理解:引用老师在vector那段的话 stack(queue)为保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数， 通常会使用拷贝构造函数，而pop作用是释放元素，c++98还没有移动构造的概念，所以如果返回成员，必须要调用拷贝构造函数，这时分配空间可能出错，导致构造失败，要抛出异常，所以没必要返回成员。","like_count":94,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476887,"discussion_content":"很棒👌。\n\n异常安全是关键。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575509351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3542569,"avatar":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","nickname":"🐶的巴普洛夫","note":"","ucode":"1213DD5A056674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606568,"discussion_content":"选课代表的时候我投你一票","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677222761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159018,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575515631,"is_pvip":false,"replies":[{"id":60858,"content":"catch住也没有用了。仔细想一下，我现在要把vector里的两个对象移到一个新的vector，移第一个成功，第二个时有异常，然后vector该怎么办？现在两个vector都废掉了。\n\n拷贝不影响旧的容器。即使发生异常，至少老的那个还是好的。这就是异常安全。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575540016,"ip_address":"","comment_id":159018,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请教一个问题，\n#1\n为什么一定强制移动构造函数不要抛出异常？\n移动构造函数抛出异常后，catch处理不可以吗？\n\n#2\n为什么拷贝构造函数被允许抛出异常？\n\n能麻烦给些代码说明一下吗？\n\n非常感谢！","like_count":57,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476887,"discussion_content":"很棒👌。\n\n异常安全是关键。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575509351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3542569,"avatar":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","nickname":"🐶的巴普洛夫","note":"","ucode":"1213DD5A056674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606568,"discussion_content":"选课代表的时候我投你一票","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677222761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158691,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1575434728,"is_pvip":false,"replies":[{"id":60761,"content":"3的正解终于出现，有人说到“异常安全”了。👍\n\n再说两句，这是C++98时设计的接口，没有移动就只能那样。有了移动，在多线程的环境里，移动返回加弹出实际上就变得有用了。我对复杂和可读性部分不那么同意。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464632,"ip_address":"","comment_id":158691,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1.都是线性容器\n2.不同容器功能，效率不一样\n3.实现pop时返回元素时，满足强异常安全，代码实现复杂，可读性差。","like_count":31,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476813,"discussion_content":"3的正解终于出现，有人说到“异常安全”了。👍\n\n再说两句，这是C++98时设计的接口，没有移动就只能那样。有了移动，在多线程的环境里，移动返回加弹出实际上就变得有用了。我对复杂和可读性部分不那么同意。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575464632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160926,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576061887,"is_pvip":false,"replies":[{"id":61377,"content":"头两个在已有空间上成功构造。第三个时发现空间不足，系统会请求更大的空间，大小由实现决定（比如两倍）。有了足够的空间后，就会在新空间的第三个的位置构造（第三个obj1），成功之后再把头两个拷贝或移动过来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576106181,"ip_address":"","comment_id":160926,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师您好，我是那个那天问您vector演示代码的学生，还需要接着请教这段代码的一些问题。因为我刚接触c++不久，可能有些基本语法理解的不是很到位还没有那么深，就需要再问几个基础的问题了。就先请教obj1部分的函数吧，先用reserve（2）预留了两个存储空间，然后接着用emplace_back()在最后面构造新元素，所以说因为有两个新开的空间那么前两次用emplace_back()构造元素成功就调用构造函数抛出两个obj1( )不知道理解的对不对？那第三个obj1( )是怎么来的呢？后面两个obj1( const obj1&amp;)怎么来的也不是很理解？这里的obj1&amp;为什么要定义成const类型呢？\n还有就是我现阶段对构造函数的理解还停留在初始化的意思上理解地还是太浅吧，不知道该怎么再往深理解一下？\n麻烦老师再帮我解答一下问题，辛苦老师了💦","like_count":13,"discussions":[{"author":{"id":1152178,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/b2/6d587bb1.jpg","nickname":"久违的","note":"","ucode":"34F703D88A643D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305508,"discussion_content":"Obj1() //已申请的空间的第一个位置(老空间)\nObj1() //已申请的空间的第二个位置(老空间)\nObj1() //新申请的双倍空间的第三个位置(新空间)\nObj1(const Obj1&amp;) //将老空间的第一个位置的元素拷贝到新空间第一个位置\nObj1(const Obj1&amp;) //将老空间的第二个位置的元素拷贝到新空间第二个位置","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1599972675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477534,"discussion_content":"头两个在已有空间上成功构造。第三个时发现空间不足，系统会请求更大的空间，大小由实现决定（比如两倍）。有了足够的空间后，就会在新空间的第三个的位置构造（第三个obj1），成功之后再把头两个拷贝或移动过来。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576106181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163431,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1576720851,"is_pvip":false,"replies":[{"id":62122,"content":"学习很认真，回答也基本抓住要点了，尤其问题 2 和 3。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576731336,"ip_address":"","comment_id":163431,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"《现代C++实战31讲》第一天\n容器汇编1：比较简单的若干容器\n一、容器的输出：\n1.简单容器(如：vector)输出就是遍历（v.begin，v.end）\n2.复杂容器(如：vector&lt;vector&gt;)就需要工具 xeus-cling\n二、string \n1.接口中不建议使用const string&amp; ，除非确实知道调用者使用的是string，如果函数不对字符串做特殊处理的话用const char* 可以避免在调用字符串的时候构造string\n三、vector\n1.vector主要缺陷是大小的增长导致的元素移动，如果可能，尽早使用reserve函数为vector保留所需要的内存，在vector预期会增长很大时带来很大的性能提升\n四、deque\n1.如果需要经常在头尾增删元素内容，deque会合适\n五、list\n1.list 是双向链表\n2.forward_list是单向链表\n六、stack\n1.后进先出，底层由deque实现\n课后思考：\n1.容器有哪些共同点\n答：都是线性容器，非关联容器\n2.为什么C++有那么多不同的序列容器类型\n答：不同容器对应实现不同需求，效率不同\n3.为什么stack(或者queue) pop函数返回的是void而不是直接返回内容\n答：为了保证异常安全，如果返回的成员构造失败就会抛出异常。","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478389,"discussion_content":"学习很认真，回答也基本抓住要点了，尤其问题 2 和 3。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576731336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159480,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1575634296,"is_pvip":false,"replies":[{"id":60973,"content":"关于几次拷贝&#47;移动的问题？参考 hello world 的评论下的廖熊猫的回答：\n\n在插入的时候，你会发现空间不够了，然后开辟新的空间，在新空间先把最后插入的元素放好，然后再依次把以前的元素一个一个挪过来。空间不够的话最后一个元素是没法插入进去的啊，所以没办法移动三次的。\n\n还有我自己的回答：\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动&#47;拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。\n\n如果不是这个问题。请把问题阐释得更详细些。可以重新开一个新的评论。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575687403,"ip_address":"","comment_id":159480,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师 您好  我是一个c++的初学者😳，这一讲的容器的概念原理都理解了，就是vector那一段的演示代码推不出老师的结果来，能不能麻烦老师再解释一下那段代码，辛苦老师了👨‍🏫！","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477073,"discussion_content":"关于几次拷贝/移动的问题？参考 hello world 的评论下的廖熊猫的回答：\n\n在插入的时候，你会发现空间不够了，然后开辟新的空间，在新空间先把最后插入的元素放好，然后再依次把以前的元素一个一个挪过来。空间不够的话最后一个元素是没法插入进去的啊，所以没办法移动三次的。\n\n还有我自己的回答：\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动/拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。\n\n如果不是这个问题。请把问题阐释得更详细些。可以重新开一个新的评论。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575687403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211303,"discussion_content":"自己反应过来了，回复自己一下，如果要使用移动构造vector要求必须是nonexcept，所以不会出现上述情况。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584839725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211300,"discussion_content":"借着老师的回答问一下，按照上述步骤，如果第3步的移动/拷贝旧的对象过程中出问题，而窗口内有的元素已经用移动构造把数据移走，那么原容器内的元素已经无效，能否在catch异常的时候做补救把数据移动回到旧容器中呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584839498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77896,"discussion_content":"好吧，刚刚看第三课。移动构造函数的参数是一个右值引用，是一个xvalue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575953483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77854,"discussion_content":"老师，我这块不太懂，为什么移动构造函数的参数是(Obj1&amp;&amp;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575948434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1725046,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","nickname":"Alice","note":"","ucode":"F0EDC16AC27088","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1724769,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","nickname":"hdongdong123","note":"","ucode":"D74589952987D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79066,"discussion_content":"你从新在留言区开一个帖子问老师，这里老师看不到问题的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576052751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77854,"ip_address":"","group_id":0},"score":79066,"extra":""}]}]},{"had_liked":false,"id":158628,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1575424351,"is_pvip":false,"replies":[{"id":60728,"content":"挺好。三比其他回答已经进一步了，但还是没有触及到某个关键字。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575435465,"ip_address":"","comment_id":158628,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第一个问题 今天讲的大多是线性结构的容器，也可以说大多是非关联容器\n\n第二个问题  应该不只是c++  所有语言都提供了，之所以对其封装是便于使用，不需要用户自己去造轮子。同时有些容器内部有迭代器 与stl算法相结合可以便于实现泛型编程。c++委员会想让c++成为一个多元化的语言支持 面向对象 面向过程 泛型编程\n\n第三个问题 将对容器的操作与获取值的操作分离开，用途会更明确。同时pop由于已经从容器中剔除了那个元素，那么返回的只能是个拷贝不允许返回已销毁元素的引用。这意味着需要一次拷贝构造操作。而top只需要返回指定元素的引用，高效简洁。将两次操作分开使得操作更明确同时没有额外开销。\n\n个人见解  请老师赐教😃","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476786,"discussion_content":"挺好。三比其他回答已经进一步了，但还是没有触及到某个关键字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575435465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71526,"discussion_content":"同意，已经有top了，pop没必要再返回了，效率的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575430135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275648,"user_name":"农民园丁","can_delete":false,"product_type":"c1","uid":1155913,"ip_address":"","ucode":"6A91EBBC9DCE6C","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/49/4a488f4c.jpg","comment_is_top":false,"comment_ctime":1611632823,"is_pvip":false,"replies":[{"id":100037,"content":"首先，vector 的内存空间必然是连续的。\n\n移动是移动对象，而不是指针。对象内部有什么，什么是合理的移动，由这个对象来定义。就我给出的例子，Obj2 大小为 1，所以移动就是把这个 1 字节的对象移动过去，执行的是 Obj2(Obj2&amp;&amp;)——真实的类就靠这个干活了，而我这里实际什么都没有做。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611639119,"ip_address":"","comment_id":275648,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第三遍学习，产生一个困惑，请教吴老师：\n采用不抛出异常的移动构造函数，会不会导致vector的内存不连续呢？\n在上面的例子中，构造第3个Obj2对象时空间不足自动扩充，此时的空间为新分配的内存空间。\n之后在新的空间第3个位置构造Obj2，然后将原空间第1、2个对象移动到新空间的第1、2个位置。\n这个移动的过程是否只是将原空间第1、2个对象的指针移动到了新的空间？这样是不是新的vector空间内存布局就不连续了？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476786,"discussion_content":"挺好。三比其他回答已经进一步了，但还是没有触及到某个关键字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575435465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","nickname":"小一日一","note":"","ucode":"0A506C2B918C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71526,"discussion_content":"同意，已经有top了，pop没必要再返回了，效率的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575430135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160705,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1576024235,"is_pvip":false,"replies":[{"id":61350,"content":"对，缺省情况下，std::terminate 会被调用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576059719,"ip_address":"","comment_id":160705,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，假如移动构造函数被声明为noexcept了，诱导编译器调用移动构造，而此时却又抛异常了，程序也会直接停止吗？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477458,"discussion_content":"对，缺省情况下，std::terminate 会被调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576059719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160193,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575888941,"is_pvip":false,"replies":[{"id":61130,"content":"Java是引用语义，返回对象就是返回个指针，没有任何问题。\n\nC++是值语义，以前返回对象只能是拷贝，可能发生异常。一旦发生异常，对象已经被弹出，那它就彻底“丢失”了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575896509,"ip_address":"","comment_id":160193,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好 第三个问题能不能这样理解 pop作用是弹出最后一个对象 弹出后该对象内存已经脱离容器当前所管理的有效的范围 虽然该片内存在后续有push操作时候还会被重复使用到 但是pop执行完后 该片内存逻辑层面看是暂时脱离了容器的管理范围的 显然pop不能将该片内存以引用方式传给外面 否则外部会持有一片目前脱离管理的无效内存 外部再对这片内存不论读还是写都是不合适的 所以pop如果要反返回对象 只能选择拷贝方式返回 会触发拷贝构造 对于内存占用大或者是需要进行深拷贝的对象而言 这个操作开销太大了 所以选择用top 返回可以安全访问的对象引用 而pop就单纯作为退栈操作不返回对象 我个人理解这样设计api 接口是为了避免不安全地访问内存 对比Java的 stack的 pop接口 Java的pop接口就返回了栈顶对象 因为这个对象内存托管给了jvm管理 调用端拿到了这个出栈的对象的引用也不会有访问内存的问题 但是c++如果把对象内存通过引用带给调用端 那调用端就可能直接读写容器内部的私有内存了 这片内存地址随时可能因为容器的扩容行为而变成野地址 对其访问其实并不安全 不知道我这样理解是否正确","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477287,"discussion_content":"Java是引用语义，返回对象就是返回个指针，没有任何问题。\n\nC++是值语义，以前返回对象只能是拷贝，可能发生异常。一旦发生异常，对象已经被弹出，那它就彻底“丢失”了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575896509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144626,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","nickname":"皓首不倦","note":"","ucode":"FA7D282DD40D83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77256,"discussion_content":"喔 是这样 感谢回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575898231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194995,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1585126164,"is_pvip":false,"replies":[{"id":74149,"content":"确实就是像你说的这样。\n\n即使用你说的短字符串优化，string的大小仍然是固定的。它这种优化的做法是，在 string 里（basic_string 里）定义了一个类似于 value_type short_str_[16] 这样的成员。可以用 union 来让这个成员跟其他一些成员来共用空间，来减少额外开销。不管什么情况，basic_string 的大小仍然是固定的。一个类的大小永远是固定的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585130672,"ip_address":"","comment_id":194995,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，请教一个容器相关的问题。\nvector&lt;string&gt; 在底层我原来理解是保存了一个string对象的数组。每个string对象有一个指针成员，指向string的字面值。这样每个string字面量大小不一，但string对象的大小是固定的。\n在《C++导学》里看到一个string的优化，将短字符串直接保存在string对象内部。加上这个优化，导致string对象大小不一，那vector&lt;string&gt; 怎么存储呢？\n谢谢解答","like_count":2},{"had_liked":false,"id":167640,"user_name":"李杰","can_delete":false,"product_type":"c1","uid":1200450,"ip_address":"","ucode":"6A7BBFBC1C3E68","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/42/f686ae7b.jpg","comment_is_top":false,"comment_ctime":1577885189,"is_pvip":false,"replies":[{"id":65081,"content":"有啊，最基本的原因就是多态了：如果你存进去的对象实际是 circle、triangle 等不同对象的话，你声明时用 shared_ptr&lt;shape&gt; 应该就比较合适了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577929631,"ip_address":"","comment_id":167640,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师好，请教个问题。\n\n将对象通过智能指针包装一下再存到容器中，我看文章中说到了其中一条理由，那就是可能这个对象的移动构造函数没有保证一定不抛异常，请问还有其他的原因使用这个用法吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479929,"discussion_content":"有啊，最基本的原因就是多态了：如果你存进去的对象实际是 circle、triangle 等不同对象的话，你声明时用 shared_ptr&amp;lt;shape&amp;gt; 应该就比较合适了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577929631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314909,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1633572666,"is_pvip":false,"replies":[{"id":114152,"content":"按引用捕获一个函数的本地变量在函数外面用？程序没死给你看已经很给你面子啦。\n\n请牢记本地变量的生命周期在函数返回时即已结束。另外，请看一下第 16 讲中关于按引用捕获的使用建议。\n\n今天我来重写的话，我可能还会加一条，lambda 表达式产生完立即调用的情况下，也可以使用 [&amp;] 来捕获。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633787650,"ip_address":"","comment_id":314909,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师请问下，下边我这段 closure 代码 为什么不能正确 capture 变量 weight?\n\nstruct Mammal {\n  std::function&lt;void()&gt; speak;\n  std::function&lt;int()&gt; getWeight;\n  std::function&lt;void(int)&gt; setWeight;\n}\nMammal *Cow() {\n    int weight = 100;\n\n    auto *m = new Mammal();\n    m-&gt;speak = []() { puts(&quot;momo~~ momo~~&quot;); };\n    m-&gt;getWeight = [&amp;]() { return weight; };;\n    m-&gt;setWeight = [&amp;](int w) { weight = w; };\n\n    return m;\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527832,"discussion_content":"按引用捕获一个函数的本地变量在函数外面用？程序没死给你看已经很给你面子啦。\n\n请牢记本地变量的生命周期在函数返回时即已结束。另外，请看一下第 16 讲中关于按引用捕获的使用建议。\n\n今天我来重写的话，我可能还会加一条，lambda 表达式产生完立即调用的情况下，也可以使用 [&amp;amp;] 来捕获。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633787650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403547,"discussion_content":"多谢老师回复！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634106101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402181,"discussion_content":"我以前以为 C++ 中的 lambda ，就是closure, 但是现在看起来它并不符合 closure 的定义，没有把 变量 package 到返回的 closure object 中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633826041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403435,"discussion_content":"那你应该使用按值捕获，而不是按引用捕获。\n\n另外注意，你这样的回复我是没有提醒的。一般建议起新问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634084372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":402181,"ip_address":"","group_id":0},"score":403435,"extra":""}]}]},{"had_liked":false,"id":297214,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623379458,"is_pvip":false,"replies":[{"id":107986,"content":"对，会走移动构造。\n\n你只要在结构体的成员里放一个有真正移动构造行为的对象，在它的移动构造函数里打印信息，可以观察到这一行为。\n\n注意，这个移动构造函数必须标为 noexcept，你才会观察到这一行为。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623479566,"ip_address":"","comment_id":297214,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，有个疑问：对于只有成员变量的自定义结构体，编译器默认会提供搬移构造函数吧？若这个自定义结构体存储在std::vector中，当vector扩容时，会执行自定义结构体的搬移构造吗？这个我不知道怎么测试，想向老师确认一下会不会走搬移构造。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527832,"discussion_content":"按引用捕获一个函数的本地变量在函数外面用？程序没死给你看已经很给你面子啦。\n\n请牢记本地变量的生命周期在函数返回时即已结束。另外，请看一下第 16 讲中关于按引用捕获的使用建议。\n\n今天我来重写的话，我可能还会加一条，lambda 表达式产生完立即调用的情况下，也可以使用 [&amp;amp;] 来捕获。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633787650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403547,"discussion_content":"多谢老师回复！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634106101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402181,"discussion_content":"我以前以为 C++ 中的 lambda ，就是closure, 但是现在看起来它并不符合 closure 的定义，没有把 变量 package 到返回的 closure object 中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633826041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1783342,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","nickname":"ano","note":"","ucode":"7DE64BDFA78550","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403435,"discussion_content":"那你应该使用按值捕获，而不是按引用捕获。\n\n另外注意，你这样的回复我是没有提醒的。一般建议起新问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634084372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":402181,"ip_address":"","group_id":0},"score":403435,"extra":""}]}]},{"had_liked":false,"id":217393,"user_name":"The Answer........","can_delete":false,"product_type":"c1","uid":2003313,"ip_address":"","ucode":"896638729520A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","comment_is_top":false,"comment_ctime":1589476375,"is_pvip":false,"replies":[{"id":80494,"content":"😊😍😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589556727,"ip_address":"","comment_id":217393,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师写的太好了！真的是相见恨晚，看大神写的讲义看得太爽了!","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521762,"discussion_content":"对，会走移动构造。\n\n你只要在结构体的成员里放一个有真正移动构造行为的对象，在它的移动构造函数里打印信息，可以观察到这一行为。\n\n注意，这个移动构造函数必须标为 noexcept，你才会观察到这一行为。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623479566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165887,"user_name":"panda","can_delete":false,"product_type":"c1","uid":1263797,"ip_address":"","ucode":"1CA1C732020F10","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcxz0quUK7Q06aNC3qglvvpTQKOanK3suG0qQkK00Q815zF5oiad1wABibCkm8Lk18LmX8UQoUMS5Q/132","comment_is_top":false,"comment_ctime":1577340448,"is_pvip":false,"replies":[{"id":63271,"content":"这不正是正文里讨论移动构造函数不应该抛异常这个问题么。之所以push_back时没这个要求，因为本来这儿就是临时对象，移动不成功也没有特别的损失。移动现有的元素如果失败了，那vector的状态就彻底混乱了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577357035,"ip_address":"","comment_id":165887,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，vector那个例子我改成\n    vector&lt;Obj1&gt; v1;\n    v1.reserve(2);\n    v1.push_back(Obj1());\n    v1.push_back(Obj1());\n    v1.push_back(Obj1());\n\n    vector&lt;Obj2&gt; v2;\n    v2.reserve(2);\n    v2.push_back(Obj2());\n    v2.push_back(Obj2());\n    v2.push_back(Obj2());\n    return 0;\n输出是：\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1(const Obj1&amp;)\nObj1(const Obj1&amp;)\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2(Obj2&amp;&amp;)\nObj2(Obj2&amp;&amp;)\n\n    \n想请问，Obj1的移动构造不是没用了吗？为啥Obj1前面创建用的还是移动构造,后面转移时移动构造又被禁用了？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495132,"discussion_content":"😊😍😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589556727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162093,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1576460637,"is_pvip":false,"replies":[{"id":61710,"content":"这个疑问提得好👍。在目前这个例子里，确实是移动构造而不是拷贝构造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474410,"ip_address":"","comment_id":162093,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，文中提到使用v1.push_back会额外生成临时对象，多一次拷贝构造和一次析构。是不是应该改为多一次移动构造和析构呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479307,"discussion_content":"这不正是正文里讨论移动构造函数不应该抛异常这个问题么。之所以push_back时没这个要求，因为本来这儿就是临时对象，移动不成功也没有特别的损失。移动现有的元素如果失败了，那vector的状态就彻底混乱了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577357035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2010573,"avatar":"","nickname":"Geek_24c4df","note":"","ucode":"BD66D0854804A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271887,"discussion_content":"没有听懂，“因为本来这儿就是临时对象，移动不成功也没有特别的损失。移动现有的元素如果失败了，那vector的状态就彻底混乱了。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590213490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263797,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcxz0quUK7Q06aNC3qglvvpTQKOanK3suG0qQkK00Q815zF5oiad1wABibCkm8Lk18LmX8UQoUMS5Q/132","nickname":"panda","note":"","ucode":"1CA1C732020F10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106133,"discussion_content":"理解了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577515991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161191,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576141090,"is_pvip":false,"replies":[{"id":61469,"content":"https:&#47;&#47;www.cnblogs.com&#47;skyfsm&#47;p&#47;7488053.html\n\n这篇中文文章说得还比较清楚，可以看一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576150286,"ip_address":"","comment_id":161191,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"谢谢老师的回复，老师您说“扩充空间是一个编译器自发进行的操作，没有用户控制。一般会类似于reserve(size() * 2)”，我之前没有遇到过这个知识点，那老师我应该看点什么稍微补充一下这块知识？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477636,"discussion_content":"https://www.cnblogs.com/skyfsm/p/7488053.html\n\n这篇中文文章说得还比较清楚，可以看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576150286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159687,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575727783,"is_pvip":false,"replies":[{"id":61020,"content":"只有const char*，目标是const string&amp;，会引发一个临时string的构造，会导致内存复制。\n\n用string_view当然也会产生临时对象，但string_view不会复制字符串的内容。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575778987,"ip_address":"","comment_id":159687,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"如果不修改字符串的内容，使用 const string&amp; 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制\n-----------------\n没有理解，“只有 C 字符串的情况，也不会引发不必要的内存复制”，对于string_view相对于const string&amp;，能否简单举个例子","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477143,"discussion_content":"只有const char*，目标是const string&amp;amp;，会引发一个临时string的构造，会导致内存复制。\n\n用string_view当然也会产生临时对象，但string_view不会复制字符串的内容。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575778987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211315,"discussion_content":"const_string&amp;利用const char*构造时会拷贝char*所有的内容吗？还是只拷贝指针？我以为声明成const就可以直接把指针复制一份就好了，反正是只读的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584840077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158869,"user_name":"虫 二","can_delete":false,"product_type":"c1","uid":1434808,"ip_address":"","ucode":"4416C9BFD62F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","comment_is_top":false,"comment_ctime":1575467485,"is_pvip":false,"replies":[{"id":60823,"content":"可以。够言简意赅的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575510179,"ip_address":"","comment_id":158869,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"1.本章节大部分都是非关联容器\n2.各容器效率不同，为了方便使用应用在不同的场景之中\n3.在某些特定情况下会引发异常问题\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477953,"discussion_content":"这个疑问提得好👍。在目前这个例子里，确实是移动构造而不是拷贝构造。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194995,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1585126164,"is_pvip":false,"replies":[{"id":74149,"content":"确实就是像你说的这样。\n\n即使用你说的短字符串优化，string的大小仍然是固定的。它这种优化的做法是，在 string 里（basic_string 里）定义了一个类似于 value_type short_str_[16] 这样的成员。可以用 union 来让这个成员跟其他一些成员来共用空间，来减少额外开销。不管什么情况，basic_string 的大小仍然是固定的。一个类的大小永远是固定的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585130672,"ip_address":"","comment_id":194995,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，请教一个容器相关的问题。\nvector&lt;string&gt; 在底层我原来理解是保存了一个string对象的数组。每个string对象有一个指针成员，指向string的字面值。这样每个string字面量大小不一，但string对象的大小是固定的。\n在《C++导学》里看到一个string的优化，将短字符串直接保存在string对象内部。加上这个优化，导致string对象大小不一，那vector&lt;string&gt; 怎么存储呢？\n谢谢解答","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488943,"discussion_content":"确实就是像你说的这样。\n\n即使用你说的短字符串优化，string的大小仍然是固定的。它这种优化的做法是，在 string 里（basic_string 里）定义了一个类似于 value_type short_str_[16] 这样的成员。可以用 union 来让这个成员跟其他一些成员来共用空间，来减少额外开销。不管什么情况，basic_string 的大小仍然是固定的。一个类的大小永远是固定的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585130672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167640,"user_name":"李杰","can_delete":false,"product_type":"c1","uid":1200450,"ip_address":"","ucode":"6A7BBFBC1C3E68","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/42/f686ae7b.jpg","comment_is_top":false,"comment_ctime":1577885189,"is_pvip":false,"replies":[{"id":65081,"content":"有啊，最基本的原因就是多态了：如果你存进去的对象实际是 circle、triangle 等不同对象的话，你声明时用 shared_ptr&lt;shape&gt; 应该就比较合适了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577929631,"ip_address":"","comment_id":167640,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师好，请教个问题。\n\n将对象通过智能指针包装一下再存到容器中，我看文章中说到了其中一条理由，那就是可能这个对象的移动构造函数没有保证一定不抛异常，请问还有其他的原因使用这个用法吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488943,"discussion_content":"确实就是像你说的这样。\n\n即使用你说的短字符串优化，string的大小仍然是固定的。它这种优化的做法是，在 string 里（basic_string 里）定义了一个类似于 value_type short_str_[16] 这样的成员。可以用 union 来让这个成员跟其他一些成员来共用空间，来减少额外开销。不管什么情况，basic_string 的大小仍然是固定的。一个类的大小永远是固定的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585130672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314909,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1633572666,"is_pvip":false,"replies":[{"id":114152,"content":"按引用捕获一个函数的本地变量在函数外面用？程序没死给你看已经很给你面子啦。\n\n请牢记本地变量的生命周期在函数返回时即已结束。另外，请看一下第 16 讲中关于按引用捕获的使用建议。\n\n今天我来重写的话，我可能还会加一条，lambda 表达式产生完立即调用的情况下，也可以使用 [&amp;] 来捕获。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633787650,"ip_address":"","comment_id":314909,"utype":1}],"discussion_count":4,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师请问下，下边我这段 closure 代码 为什么不能正确 capture 变量 weight?\n\nstruct Mammal {\n  std::function&lt;void()&gt; speak;\n  std::function&lt;int()&gt; getWeight;\n  std::function&lt;void(int)&gt; setWeight;\n}\nMammal *Cow() {\n    int weight = 100;\n\n    auto *m = new Mammal();\n    m-&gt;speak = []() { puts(&quot;momo~~ momo~~&quot;); };\n    m-&gt;getWeight = [&amp;]() { return weight; };;\n    m-&gt;setWeight = [&amp;](int w) { weight = w; };\n\n    return m;\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479929,"discussion_content":"有啊，最基本的原因就是多态了：如果你存进去的对象实际是 circle、triangle 等不同对象的话，你声明时用 shared_ptr&amp;lt;shape&amp;gt; 应该就比较合适了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577929631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297214,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623379458,"is_pvip":false,"replies":[{"id":107986,"content":"对，会走移动构造。\n\n你只要在结构体的成员里放一个有真正移动构造行为的对象，在它的移动构造函数里打印信息，可以观察到这一行为。\n\n注意，这个移动构造函数必须标为 noexcept，你才会观察到这一行为。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623479566,"ip_address":"","comment_id":297214,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，有个疑问：对于只有成员变量的自定义结构体，编译器默认会提供搬移构造函数吧？若这个自定义结构体存储在std::vector中，当vector扩容时，会执行自定义结构体的搬移构造吗？这个我不知道怎么测试，想向老师确认一下会不会走搬移构造。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521762,"discussion_content":"对，会走移动构造。\n\n你只要在结构体的成员里放一个有真正移动构造行为的对象，在它的移动构造函数里打印信息，可以观察到这一行为。\n\n注意，这个移动构造函数必须标为 noexcept，你才会观察到这一行为。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623479566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217393,"user_name":"The Answer........","can_delete":false,"product_type":"c1","uid":2003313,"ip_address":"","ucode":"896638729520A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","comment_is_top":false,"comment_ctime":1589476375,"is_pvip":false,"replies":[{"id":80494,"content":"😊😍😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589556727,"ip_address":"","comment_id":217393,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师写的太好了！真的是相见恨晚，看大神写的讲义看得太爽了!","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495132,"discussion_content":"😊😍😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589556727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165887,"user_name":"panda","can_delete":false,"product_type":"c1","uid":1263797,"ip_address":"","ucode":"1CA1C732020F10","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcxz0quUK7Q06aNC3qglvvpTQKOanK3suG0qQkK00Q815zF5oiad1wABibCkm8Lk18LmX8UQoUMS5Q/132","comment_is_top":false,"comment_ctime":1577340448,"is_pvip":false,"replies":[{"id":63271,"content":"这不正是正文里讨论移动构造函数不应该抛异常这个问题么。之所以push_back时没这个要求，因为本来这儿就是临时对象，移动不成功也没有特别的损失。移动现有的元素如果失败了，那vector的状态就彻底混乱了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577357035,"ip_address":"","comment_id":165887,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，vector那个例子我改成\n    vector&lt;Obj1&gt; v1;\n    v1.reserve(2);\n    v1.push_back(Obj1());\n    v1.push_back(Obj1());\n    v1.push_back(Obj1());\n\n    vector&lt;Obj2&gt; v2;\n    v2.reserve(2);\n    v2.push_back(Obj2());\n    v2.push_back(Obj2());\n    v2.push_back(Obj2());\n    return 0;\n输出是：\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1(const Obj1&amp;)\nObj1(const Obj1&amp;)\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2(Obj2&amp;&amp;)\nObj2(Obj2&amp;&amp;)\n\n    \n想请问，Obj1的移动构造不是没用了吗？为啥Obj1前面创建用的还是移动构造,后面转移时移动构造又被禁用了？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479307,"discussion_content":"这不正是正文里讨论移动构造函数不应该抛异常这个问题么。之所以push_back时没这个要求，因为本来这儿就是临时对象，移动不成功也没有特别的损失。移动现有的元素如果失败了，那vector的状态就彻底混乱了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577357035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2010573,"avatar":"","nickname":"Geek_24c4df","note":"","ucode":"BD66D0854804A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271887,"discussion_content":"没有听懂，“因为本来这儿就是临时对象，移动不成功也没有特别的损失。移动现有的元素如果失败了，那vector的状态就彻底混乱了。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590213490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263797,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcxz0quUK7Q06aNC3qglvvpTQKOanK3suG0qQkK00Q815zF5oiad1wABibCkm8Lk18LmX8UQoUMS5Q/132","nickname":"panda","note":"","ucode":"1CA1C732020F10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106133,"discussion_content":"理解了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577515991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162093,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1576460637,"is_pvip":false,"replies":[{"id":61710,"content":"这个疑问提得好👍。在目前这个例子里，确实是移动构造而不是拷贝构造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474410,"ip_address":"","comment_id":162093,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，文中提到使用v1.push_back会额外生成临时对象，多一次拷贝构造和一次析构。是不是应该改为多一次移动构造和析构呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477953,"discussion_content":"这个疑问提得好👍。在目前这个例子里，确实是移动构造而不是拷贝构造。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161191,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576141090,"is_pvip":false,"replies":[{"id":61469,"content":"https:&#47;&#47;www.cnblogs.com&#47;skyfsm&#47;p&#47;7488053.html\n\n这篇中文文章说得还比较清楚，可以看一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576150286,"ip_address":"","comment_id":161191,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"谢谢老师的回复，老师您说“扩充空间是一个编译器自发进行的操作，没有用户控制。一般会类似于reserve(size() * 2)”，我之前没有遇到过这个知识点，那老师我应该看点什么稍微补充一下这块知识？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477636,"discussion_content":"https://www.cnblogs.com/skyfsm/p/7488053.html\n\n这篇中文文章说得还比较清楚，可以看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576150286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159687,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575727783,"is_pvip":false,"replies":[{"id":61020,"content":"只有const char*，目标是const string&amp;，会引发一个临时string的构造，会导致内存复制。\n\n用string_view当然也会产生临时对象，但string_view不会复制字符串的内容。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575778987,"ip_address":"","comment_id":159687,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"如果不修改字符串的内容，使用 const string&amp; 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制\n-----------------\n没有理解，“只有 C 字符串的情况，也不会引发不必要的内存复制”，对于string_view相对于const string&amp;，能否简单举个例子","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477143,"discussion_content":"只有const char*，目标是const string&amp;amp;，会引发一个临时string的构造，会导致内存复制。\n\n用string_view当然也会产生临时对象，但string_view不会复制字符串的内容。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575778987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211315,"discussion_content":"const_string&amp;利用const char*构造时会拷贝char*所有的内容吗？还是只拷贝指针？我以为声明成const就可以直接把指针复制一份就好了，反正是只读的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584840077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158869,"user_name":"虫 二","can_delete":false,"product_type":"c1","uid":1434808,"ip_address":"","ucode":"4416C9BFD62F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","comment_is_top":false,"comment_ctime":1575467485,"is_pvip":false,"replies":[{"id":60823,"content":"可以。够言简意赅的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575510179,"ip_address":"","comment_id":158869,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"1.本章节大部分都是非关联容器\n2.各容器效率不同，为了方便使用应用在不同的场景之中\n3.在某些特定情况下会引发异常问题\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476875,"discussion_content":"可以。够言简意赅的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575510179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158841,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575463180,"is_pvip":false,"replies":[{"id":60821,"content":"还是重点谈3。对于C++的情况，基本没问题。对于Java，则错了。Java的情况最接近于你返回一个智能指针——这个操作本身性能是没问题的。主要约束是必须在堆上放置对象。\n\n2 你对防犯错的考虑非常好。其他人似乎没提到。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575509994,"ip_address":"","comment_id":158841,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1.线性容器\n2.由于不同场景下需要有合适的数据结构与之对应，比如既然有了deque为何会有queue和stack呢，queue和stack的功能deque也能实现，而且甚至比queue和stack具有更大的自由，这是由于在很多情况下接口的自由使得犯错误的几率也就变大，因此将大多数接口都封装起来来减小出错的可能性。以及链表、数组都存在也是因为他们都具有不可代替的一面。\n3.JAVA中确实是当pop时返回被pop的值，而C++中并没有返回该值，我认为很大程度上是由于C++更注重效率，毕竟这样做可以减小一次拷贝或者移动，当容器中存储的对象拷贝或移动很费劲或者多次pop时，这将大大降低C++的pop速度。另外我认为可能和异常的避免有关，由于如果需要返回被pop的值，需要提前将其拷贝到其他地方或者是移动到其他地方，这两者都可能需要内存的分配，所以可能会出现异常。第二点纯属脑洞，不清楚自己考虑的对不对，希望老师指正。。。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476869,"discussion_content":"还是重点谈3。对于C++的情况，基本没问题。对于Java，则错了。Java的情况最接近于你返回一个智能指针——这个操作本身性能是没问题的。主要约束是必须在堆上放置对象。\n\n2 你对防犯错的考虑非常好。其他人似乎没提到。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575509994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158809,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1575456559,"is_pvip":false,"replies":[{"id":60765,"content":"没有问题的。除了写出来的样子有时候不那么方便，输出项多时性能不那么高，完全可用，毕竟有灵活性和类型安全性。\n\nC++20 会引入新的机制，类似于printf系列但类型安全。见：\n\nhttps:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;utility&#47;format","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575465366,"ip_address":"","comment_id":158809,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，C++11里的“stream流”是不是真的有缺陷，只能在测试等环境下用用？C++后续对此有改进么？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476856,"discussion_content":"没有问题的。除了写出来的样子有时候不那么方便，输出项多时性能不那么高，完全可用，毕竟有灵活性和类型安全性。\n\nC++20 会引入新的机制，类似于printf系列但类型安全。见：\n\nhttps://en.cppreference.com/w/cpp/utility/format","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575465366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158784,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1575450515,"is_pvip":false,"replies":[{"id":60764,"content":"你的3也接近了。关键字见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464990,"ip_address":"","comment_id":158784,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1、这些容器中元素能拉成一条链\n2、为了方便使用😂\n3、pop（）的同时删除元素并返回，返回的时候分配内存，可能失败，而此时对象已经从容器中删除，导致元素丢失","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476846,"discussion_content":"你的3也接近了。关键字见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158778,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575449749,"is_pvip":false,"replies":[{"id":60774,"content":"GCC 版本是多少？我在老版本的 GCC 上能复现这个问题。\n\n请使用 GCC 7 以上版本。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575467677,"ip_address":"","comment_id":158778,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"为什么我使用output_container.h的时候出现了错误：\n我应该开启了c++17标准了（我用的编辑器是CLion，编译器是g++）[但是我不太清楚是否真的开启了]\n\nerror: ‘is_pair_v’ declared as an ‘inline’ variable","like_count":1},{"had_liked":false,"id":158670,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1575430307,"is_pvip":false,"replies":[{"id":60757,"content":"不急，下一讲就来。🤐","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464162,"ip_address":"","comment_id":158670,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师漏了C++11新增加的array容器","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476856,"discussion_content":"没有问题的。除了写出来的样子有时候不那么方便，输出项多时性能不那么高，完全可用，毕竟有灵活性和类型安全性。\n\nC++20 会引入新的机制，类似于printf系列但类型安全。见：\n\nhttps://en.cppreference.com/w/cpp/utility/format","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575465366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158516,"user_name":"Vackine","can_delete":false,"product_type":"c1","uid":1139588,"ip_address":"","ucode":"8E412EE82D3B59","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/84/f45c4af9.jpg","comment_is_top":false,"comment_ctime":1575391454,"is_pvip":false,"replies":[{"id":60668,"content":"动作很快啊。\n\n1. 大体上对。再留意一下它们的方法。\n\n2. 不完全对。再想想。\n\n3. 不是这个原因。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575415581,"ip_address":"","comment_id":158516,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1. 线性的数据结构，其实际的抽象模型对应数组个链表的数据结构。\n2. 满足动态进行插入删除的需求，当然是C++标准想对各种基础常用的数据结构都进行封装(😂猜的)。\n3. 因为C++标准库容器的实现都是模板类的，为了提供泛型编程的模式。\n\n以上内容还有很多不确信的，还请老师指正。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476846,"discussion_content":"你的3也接近了。关键字见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381651,"user_name":"coming","can_delete":false,"product_type":"c1","uid":1262181,"ip_address":"上海","ucode":"7625CE61D9A2D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","comment_is_top":false,"comment_ctime":1695608466,"is_pvip":false,"replies":[{"id":139034,"content":"不是所有情况下都能使用，但作为探索和教学工具，在很多情况下都很有用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1695728188,"ip_address":"上海","comment_id":381651,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"xeus-cling是基于cling(https:&#47;&#47;github.com&#47;root-project&#47;xeus-cling)的, 用起来还是有些问题,在xeus-cling中`void fNoexcept() noexcept { }`直接报错, 但是直接使用cling就不会..., 还有xeus-cling支持using用法, 在cling中就不支持. 还在探索用法中","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476843,"discussion_content":"GCC 版本是多少？我在老版本的 GCC 上能复现这个问题。\n\n请使用 GCC 7 以上版本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575467677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71992,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575467778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71991,"discussion_content":"嗯嗯，我的gcc版本不对，只有5.4.0。导致一直编译不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575467767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380442,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"浙江","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1693580363,"is_pvip":false,"replies":[{"id":138572,"content":"可能写法上让你误解了。意思只是说，只有上面两种情况都不能覆盖、落到第三种情况才用 string&amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1693665456,"ip_address":"上海","comment_id":380442,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"请问老师，“如果需要改变调用者的字符串内容，使用 string&amp; 作为参数类型（通常不推荐）。”请问这里不推荐，那一般推荐怎么样来做呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476799,"discussion_content":"不急，下一讲就来。🤐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339859,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1648438441,"is_pvip":false,"replies":[{"id":124389,"content":"这也是一种办法。各有各的用途。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648638833,"ip_address":"","comment_id":339859,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"查看容器内的元素的话，我感觉 gdb 就挺好用的，print 一下即可。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476753,"discussion_content":"动作很快啊。\n\n1. 大体上对。再留意一下它们的方法。\n\n2. 不完全对。再想想。\n\n3. 不是这个原因。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575415581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324963,"user_name":"笑","can_delete":false,"product_type":"c1","uid":1284647,"ip_address":"","ucode":"C91EAFAB88E5AC","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","comment_is_top":false,"comment_ctime":1638759926,"is_pvip":false,"replies":[{"id":118027,"content":"我用 VS 2019 试下来，结果跟我预期的一致。估计你的 Visual Studio 版本比较老，对标准的符合程度不够。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1638876540,"ip_address":"","comment_id":324963,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Obj1 {\npublic:\n  Obj1()\n  {\n    cout &lt;&lt; &quot;Obj1()\\n&quot;;\n  }\n  Obj1(const Obj1&amp;)\n  {\n    cout &lt;&lt; &quot;Obj1(const Obj1&amp;)\\n&quot;;\n  }\n  Obj1(Obj1&amp;&amp;)\n  {\n    cout &lt;&lt; &quot;Obj1(Obj1&amp;&amp;)\\n&quot;;\n  }\n};\n\nclass Obj2 {\npublic:\n  Obj2()\n  {\n    cout &lt;&lt; &quot;Obj2()\\n&quot;;\n  }\n  Obj2(const Obj2&amp;)\n  {\n    cout &lt;&lt; &quot;Obj2(const Obj2&amp;)\\n&quot;;\n  }\n  Obj2(Obj2&amp;&amp;) noexcept\n  {\n    cout &lt;&lt; &quot;Obj2(Obj2&amp;&amp;)\\n&quot;;\n  }\n};\n\nint main()\n{\n  vector&lt;Obj1&gt; v1;\n  v1.reserve(2);\n  v1.emplace_back();\n  v1.emplace_back();\n  v1.emplace_back();\n\n  vector&lt;Obj2&gt; v2;\n  v2.reserve(2);\n  v2.emplace_back();\n  v2.emplace_back();\n  v2.emplace_back();\n}\n\n\n这段代码我在vs上试了，输出如下：\nObj1()\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1(Obj1&amp;&amp;)\nObj1()\nObj2()\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2(Obj2&amp;&amp;)\nObj2()\n\n并没有调用obj1的拷贝构造函数\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628701,"discussion_content":"不是所有情况下都能使用，但作为探索和教学工具，在很多情况下都很有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695728188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158841,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575463180,"is_pvip":false,"replies":[{"id":60821,"content":"还是重点谈3。对于C++的情况，基本没问题。对于Java，则错了。Java的情况最接近于你返回一个智能指针——这个操作本身性能是没问题的。主要约束是必须在堆上放置对象。\n\n2 你对防犯错的考虑非常好。其他人似乎没提到。👍","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575509994,"ip_address":"","comment_id":158841,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1.线性容器\n2.由于不同场景下需要有合适的数据结构与之对应，比如既然有了deque为何会有queue和stack呢，queue和stack的功能deque也能实现，而且甚至比queue和stack具有更大的自由，这是由于在很多情况下接口的自由使得犯错误的几率也就变大，因此将大多数接口都封装起来来减小出错的可能性。以及链表、数组都存在也是因为他们都具有不可代替的一面。\n3.JAVA中确实是当pop时返回被pop的值，而C++中并没有返回该值，我认为很大程度上是由于C++更注重效率，毕竟这样做可以减小一次拷贝或者移动，当容器中存储的对象拷贝或移动很费劲或者多次pop时，这将大大降低C++的pop速度。另外我认为可能和异常的避免有关，由于如果需要返回被pop的值，需要提前将其拷贝到其他地方或者是移动到其他地方，这两者都可能需要内存的分配，所以可能会出现异常。第二点纯属脑洞，不清楚自己考虑的对不对，希望老师指正。。。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476869,"discussion_content":"还是重点谈3。对于C++的情况，基本没问题。对于Java，则错了。Java的情况最接近于你返回一个智能指针——这个操作本身性能是没问题的。主要约束是必须在堆上放置对象。\n\n2 你对防犯错的考虑非常好。其他人似乎没提到。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575509994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158809,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1575456559,"is_pvip":false,"replies":[{"id":60765,"content":"没有问题的。除了写出来的样子有时候不那么方便，输出项多时性能不那么高，完全可用，毕竟有灵活性和类型安全性。\n\nC++20 会引入新的机制，类似于printf系列但类型安全。见：\n\nhttps:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;utility&#47;format","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575465366,"ip_address":"","comment_id":158809,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，C++11里的“stream流”是不是真的有缺陷，只能在测试等环境下用用？C++后续对此有改进么？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476843,"discussion_content":"GCC 版本是多少？我在老版本的 GCC 上能复现这个问题。\n\n请使用 GCC 7 以上版本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575467677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71992,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575467778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71991,"discussion_content":"嗯嗯，我的gcc版本不对，只有5.4.0。导致一直编译不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575467767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158784,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1575450515,"is_pvip":false,"replies":[{"id":60764,"content":"你的3也接近了。关键字见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464990,"ip_address":"","comment_id":158784,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1、这些容器中元素能拉成一条链\n2、为了方便使用😂\n3、pop（）的同时删除元素并返回，返回的时候分配内存，可能失败，而此时对象已经从容器中删除，导致元素丢失","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476799,"discussion_content":"不急，下一讲就来。🤐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158778,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575449749,"is_pvip":false,"replies":[{"id":60774,"content":"GCC 版本是多少？我在老版本的 GCC 上能复现这个问题。\n\n请使用 GCC 7 以上版本。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575467677,"ip_address":"","comment_id":158778,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"为什么我使用output_container.h的时候出现了错误：\n我应该开启了c++17标准了（我用的编辑器是CLion，编译器是g++）[但是我不太清楚是否真的开启了]\n\nerror: ‘is_pair_v’ declared as an ‘inline’ variable","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476753,"discussion_content":"动作很快啊。\n\n1. 大体上对。再留意一下它们的方法。\n\n2. 不完全对。再想想。\n\n3. 不是这个原因。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575415581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158670,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1575430307,"is_pvip":false,"replies":[{"id":60757,"content":"不急，下一讲就来。🤐","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464162,"ip_address":"","comment_id":158670,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师漏了C++11新增加的array容器","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628701,"discussion_content":"不是所有情况下都能使用，但作为探索和教学工具，在很多情况下都很有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695728188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158516,"user_name":"Vackine","can_delete":false,"product_type":"c1","uid":1139588,"ip_address":"","ucode":"8E412EE82D3B59","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/84/f45c4af9.jpg","comment_is_top":false,"comment_ctime":1575391454,"is_pvip":false,"replies":[{"id":60668,"content":"动作很快啊。\n\n1. 大体上对。再留意一下它们的方法。\n\n2. 不完全对。再想想。\n\n3. 不是这个原因。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575415581,"ip_address":"","comment_id":158516,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1. 线性的数据结构，其实际的抽象模型对应数组个链表的数据结构。\n2. 满足动态进行插入删除的需求，当然是C++标准想对各种基础常用的数据结构都进行封装(😂猜的)。\n3. 因为C++标准库容器的实现都是模板类的，为了提供泛型编程的模式。\n\n以上内容还有很多不确信的，还请老师指正。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627042,"discussion_content":"可能写法上让你误解了。意思只是说，只有上面两种情况都不能覆盖、落到第三种情况才用 string&amp;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693665456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381651,"user_name":"coming","can_delete":false,"product_type":"c1","uid":1262181,"ip_address":"上海","ucode":"7625CE61D9A2D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","comment_is_top":false,"comment_ctime":1695608466,"is_pvip":false,"replies":[{"id":139034,"content":"不是所有情况下都能使用，但作为探索和教学工具，在很多情况下都很有用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1695728188,"ip_address":"上海","comment_id":381651,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"xeus-cling是基于cling(https:&#47;&#47;github.com&#47;root-project&#47;xeus-cling)的, 用起来还是有些问题,在xeus-cling中`void fNoexcept() noexcept { }`直接报错, 但是直接使用cling就不会..., 还有xeus-cling支持using用法, 在cling中就不支持. 还在探索用法中","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559180,"discussion_content":"这也是一种办法。各有各的用途。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648638833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380442,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"浙江","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1693580363,"is_pvip":false,"replies":[{"id":138572,"content":"可能写法上让你误解了。意思只是说，只有上面两种情况都不能覆盖、落到第三种情况才用 string&amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1693665456,"ip_address":"上海","comment_id":380442,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"请问老师，“如果需要改变调用者的字符串内容，使用 string&amp; 作为参数类型（通常不推荐）。”请问这里不推荐，那一般推荐怎么样来做呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627042,"discussion_content":"可能写法上让你误解了。意思只是说，只有上面两种情况都不能覆盖、落到第三种情况才用 string&amp;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693665456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339859,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1648438441,"is_pvip":false,"replies":[{"id":124389,"content":"这也是一种办法。各有各的用途。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648638833,"ip_address":"","comment_id":339859,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"查看容器内的元素的话，我感觉 gdb 就挺好用的，print 一下即可。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559180,"discussion_content":"这也是一种办法。各有各的用途。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648638833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324963,"user_name":"笑","can_delete":false,"product_type":"c1","uid":1284647,"ip_address":"","ucode":"C91EAFAB88E5AC","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/27/4b81bce5.jpg","comment_is_top":false,"comment_ctime":1638759926,"is_pvip":false,"replies":[{"id":118027,"content":"我用 VS 2019 试下来，结果跟我预期的一致。估计你的 Visual Studio 版本比较老，对标准的符合程度不够。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1638876540,"ip_address":"","comment_id":324963,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Obj1 {\npublic:\n  Obj1()\n  {\n    cout &lt;&lt; &quot;Obj1()\\n&quot;;\n  }\n  Obj1(const Obj1&amp;)\n  {\n    cout &lt;&lt; &quot;Obj1(const Obj1&amp;)\\n&quot;;\n  }\n  Obj1(Obj1&amp;&amp;)\n  {\n    cout &lt;&lt; &quot;Obj1(Obj1&amp;&amp;)\\n&quot;;\n  }\n};\n\nclass Obj2 {\npublic:\n  Obj2()\n  {\n    cout &lt;&lt; &quot;Obj2()\\n&quot;;\n  }\n  Obj2(const Obj2&amp;)\n  {\n    cout &lt;&lt; &quot;Obj2(const Obj2&amp;)\\n&quot;;\n  }\n  Obj2(Obj2&amp;&amp;) noexcept\n  {\n    cout &lt;&lt; &quot;Obj2(Obj2&amp;&amp;)\\n&quot;;\n  }\n};\n\nint main()\n{\n  vector&lt;Obj1&gt; v1;\n  v1.reserve(2);\n  v1.emplace_back();\n  v1.emplace_back();\n  v1.emplace_back();\n\n  vector&lt;Obj2&gt; v2;\n  v2.reserve(2);\n  v2.emplace_back();\n  v2.emplace_back();\n  v2.emplace_back();\n}\n\n\n这段代码我在vs上试了，输出如下：\nObj1()\nObj1()\nObj1(Obj1&amp;&amp;)\nObj1(Obj1&amp;&amp;)\nObj1()\nObj2()\nObj2()\nObj2(Obj2&amp;&amp;)\nObj2(Obj2&amp;&amp;)\nObj2()\n\n并没有调用obj1的拷贝构造函数\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536825,"discussion_content":"我用 VS 2019 试下来，结果跟我预期的一致。估计你的 Visual Studio 版本比较老，对标准的符合程度不够。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638876540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319686,"user_name":"严海波","can_delete":false,"product_type":"c1","uid":1264573,"ip_address":"","ucode":"8D4E230FD95383","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/bd/fe8c68b3.jpg","comment_is_top":false,"comment_ctime":1635909292,"is_pvip":false,"replies":[{"id":115918,"content":"你说的是 vector 如何移动对象，而不是 vector 自身的移动，对吧？如果不是，请另起一个新问题。\n\nvector 分配的空间是连续的。如果元素类型为 T，vector 的 capacity 是 n，那分配的空间大小就是 n * sizeof(T)。所谓移动构造，就是 vector 在指定的内存位置上调用 T 的移动构造函数。空间连续性由 vector 保证，“怎么”移动就是 T 的事情了。\n\n对于一个内部有定长数组的对象，显然移动跟拷贝对这个数组没有区别，当这个数组的元素是移动和拷贝没有区别的 POD 类型时。我想你说的该是这种情况，此时移动确实没用。如果你这个含数组的对象很大时，从设计角度应考虑在 vector 里放对象的（智能）指针而不是对象本身。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1635936657,"ip_address":"","comment_id":319686,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"看过这节之后我对移动构造函数有了疑问，我们知道vector就像数组，对象必须放在连续的空间，那么对于在vector里使用的对象，即使提供了移动构造函数，它和拷贝构造函数在语义上是否应该一致呢？比如对象内部保存的是另外一个定长数组，那么移动构造函数是否需要向拷贝构造函数一样进行深层拷贝，如果不这样，vector不就不能把对象复制到连续空间上了么？","like_count":0},{"had_liked":false,"id":313851,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1632712124,"is_pvip":false,"replies":[{"id":113759,"content":"提供移动构造没什么需要谨慎的。你要把对象 move 给其他函数，当然是有要求的（也谈不上“慎用”）——一般而言，一个被移动的对象，后面应当除了析构，没有其他的操作了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1632810295,"ip_address":"","comment_id":313851,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"移动构造这种其实要慎用吧，如果还需要使用源对象的话","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529723,"discussion_content":"你说的是 vector 如何移动对象，而不是 vector 自身的移动，对吧？如果不是，请另起一个新问题。\n\nvector 分配的空间是连续的。如果元素类型为 T，vector 的 capacity 是 n，那分配的空间大小就是 n * sizeof(T)。所谓移动构造，就是 vector 在指定的内存位置上调用 T 的移动构造函数。空间连续性由 vector 保证，“怎么”移动就是 T 的事情了。\n\n对于一个内部有定长数组的对象，显然移动跟拷贝对这个数组没有区别，当这个数组的元素是移动和拷贝没有区别的 POD 类型时。我想你说的该是这种情况，此时移动确实没用。如果你这个含数组的对象很大时，从设计角度应考虑在 vector 里放对象的（智能）指针而不是对象本身。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635936657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306432,"user_name":"朱烈鑫","can_delete":false,"product_type":"c1","uid":2727515,"ip_address":"","ucode":"5D3B15D2E3F2DA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f07iaZ0Iia78LOmLjyGMibG4I4TjoUexQqDYqVXibM7Mia2r7zOw8QpicD0TMq1poqzx6w1CA/132","comment_is_top":false,"comment_ctime":1628561950,"is_pvip":false,"replies":[{"id":110952,"content":"我要求C++17。看起来你的编译器不支持C++17。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1628578338,"ip_address":"","comment_id":306432,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师你好，我把小工具拿到Qt上面，报了不少的错，也\nerror: &#39;is_pair_v&#39; declared as an &#39;inline&#39; variable\n inline bool is_pair_v = is_pair&lt;T&gt;::value;\n             ^","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527492,"discussion_content":"提供移动构造没什么需要谨慎的。你要把对象 move 给其他函数，当然是有要求的（也谈不上“慎用”）——一般而言，一个被移动的对象，后面应当除了析构，没有其他的操作了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632810295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301318,"user_name":"Geek_a93ab1","can_delete":false,"product_type":"c1","uid":1625587,"ip_address":"","ucode":"17D303FA1F3C46","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL63dLLFyh9NGSVaRiboamDHZ0ibD5eOoh3oBMDExAfMMWkiauTT6ClR80d0XtLTibiaHjRODOsKNemtYw/132","comment_is_top":false,"comment_ctime":1625629632,"is_pvip":false,"replies":[{"id":109134,"content":"仔细看图，想一下，如果你有某项的迭代器，你能高效实现在它之前插入一项吗？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1625662408,"ip_address":"","comment_id":301318,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师好， 为什么forward_list要搞一个emplace_after,而不直接像list一样，就用emplace, 而且还要单独搞一个before_front ?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524762,"discussion_content":"我要求C++17。看起来你的编译器不支持C++17。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628578338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293980,"user_name":"Four y","can_delete":false,"product_type":"c1","uid":1608789,"ip_address":"","ucode":"816C50CA85E3AE","user_header":"https://static001.geekbang.org/account/avatar/00/18/8c/55/cac3dbcc.jpg","comment_is_top":false,"comment_ctime":1621666754,"is_pvip":false,"replies":[{"id":106598,"content":"哈哈，不枉我花力气把这些图画出来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1621678753,"ip_address":"","comment_id":293980,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"这节真是干活满满，而且简单易懂，对于很多容器的底层实现通过图的方式展现，很棒。\nPS：之前看了以下STL源码剖析没有坚持看下去，学了这两节应该能有很好的理解。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522967,"discussion_content":"仔细看图，想一下，如果你有某项的迭代器，你能高效实现在它之前插入一项吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625662408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284883,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1616510692,"is_pvip":false,"replies":[{"id":103457,"content":"你编译一下我的例子试试：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;blob&#47;master&#47;04&#47;test02_vector.cpp\n\n我在 VS2019 下获得的结果跟 GCC&#47;Clang 的完全一致。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1616657501,"ip_address":"","comment_id":284883,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师好，请教个问题。\n我在vs2015 x86 Debug模式下，对一个有拷贝构造和移动构造的类多次插入到vector中，结果不管是带没带noexcept，都执行的是移动构造。用文中的vector实例代码也一样。想问下，noexcept用于控制vector调用移动构造或拷贝构造的这个说法，是编译器实现的吗？是不包含在c++标准里的吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520455,"discussion_content":"哈哈，不枉我花力气把这些图画出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621678753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274785,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1611155891,"is_pvip":false,"replies":[{"id":99785,"content":"“指定类型”和“任意类型”没有矛盾吧？\n\n我的原话是这么写的：‘“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。’——容器类里你可以指定放在里面的对象类型，而string（本质是 basic_string&lt;char&gt;）只能放字符类型，不能放 int 或者你自己的类对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611300053,"ip_address":"","comment_id":274785,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"真正的容器类，比如set或者map不也是需要指定类型，然后放一种类型的数据么，请问为什么说可以放任意类型？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517499,"discussion_content":"你编译一下我的例子试试：\n\nhttps://github.com/adah1972/geek_time_cpp/blob/master/04/test02_vector.cpp\n\n我在 VS2019 下获得的结果跟 GCC/Clang 的完全一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616657501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220237,"user_name":"Geek_24c4df","can_delete":false,"product_type":"c1","uid":2010573,"ip_address":"","ucode":"BD66D0854804A7","user_header":"","comment_is_top":false,"comment_ctime":1590211690,"is_pvip":false,"replies":[{"id":81353,"content":"push_back 做的事情就是拷贝或移动对象到目标位置。emplace_back 是在目标位置构造对象。这本来就是这两个成员函数的定义。\n\n按你的目的，最高效的写法应该是 v1.emplace_back()。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247779,"ip_address":"","comment_id":220237,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，请教一个问题，关于vector的示例代码\n如果把emplace_back写成push_back。为什么调用的是移动构造函数。\nv1.push_back(Obj1());\n这样的确会多一次Obj1的析构函数。也会出现一次Obj1(Obj1&amp;&amp;)\n这是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514125,"discussion_content":"“指定类型”和“任意类型”没有矛盾吧？\n\n我的原话是这么写的：‘“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。’——容器类里你可以指定放在里面的对象类型，而string（本质是 basic_string&amp;lt;char&amp;gt;）只能放字符类型，不能放 int 或者你自己的类对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611300053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216978,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":2001918,"ip_address":"","ucode":"BDB1F211D11C54","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8b/fe/a7d1c17a.jpg","comment_is_top":false,"comment_ctime":1589379938,"is_pvip":false,"replies":[{"id":80495,"content":"1. deque 不算连续存储，元素之间只是部分连续，不能满足连续迭代器（第 7 讲）的概念。所以 deque 也不像 vector 一样有 data 成员函数。\n\n2. 某种程度上可以，但成员函数并不是越多越好。容器适配器都是其他容器功能的子集，但有时限定别人只能用这个子集是件好事，防止犯错。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589557063,"ip_address":"","comment_id":216978,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"不好意思才注意到原来容器还有一讲== 小白重新整理一下提问\n1. 既然deque也能连续储存，是不是意味着可以替代vector呢，请问有什么场景不可以吗？\n2. vector是不是也可以替代stack？毕竟还多一个有坐标的功能呢。。。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496097,"discussion_content":"push_back 做的事情就是拷贝或移动对象到目标位置。emplace_back 是在目标位置构造对象。这本来就是这两个成员函数的定义。\n\n按你的目的，最高效的写法应该是 v1.emplace_back()。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590247779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207850,"user_name":"时之沙","can_delete":false,"product_type":"c1","uid":1346221,"ip_address":"","ucode":"E01FB59AE6ABB9","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/ad/6e6275bd.jpg","comment_is_top":false,"comment_ctime":1587197192,"is_pvip":false,"replies":[{"id":77592,"content":"正文里不写了么？……vector的操作一般保证强异常安全性的。仔细想想如果移动的时候可能抛异常会出现什么后果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1587218299,"ip_address":"","comment_id":207850,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师你好，Obj1 和 Obj2 的定义只差了一个 noexcept，但这个小小的差异就导致了 vector 是否会移动对象。那是为什么呢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494998,"discussion_content":"1. deque 不算连续存储，元素之间只是部分连续，不能满足连续迭代器（第 7 讲）的概念。所以 deque 也不像 vector 一样有 data 成员函数。\n\n2. 某种程度上可以，但成员函数并不是越多越好。容器适配器都是其他容器功能的子集，但有时限定别人只能用这个子集是件好事，防止犯错。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589557063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319686,"user_name":"严海波","can_delete":false,"product_type":"c1","uid":1264573,"ip_address":"","ucode":"8D4E230FD95383","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/bd/fe8c68b3.jpg","comment_is_top":false,"comment_ctime":1635909292,"is_pvip":false,"replies":[{"id":115918,"content":"你说的是 vector 如何移动对象，而不是 vector 自身的移动，对吧？如果不是，请另起一个新问题。\n\nvector 分配的空间是连续的。如果元素类型为 T，vector 的 capacity 是 n，那分配的空间大小就是 n * sizeof(T)。所谓移动构造，就是 vector 在指定的内存位置上调用 T 的移动构造函数。空间连续性由 vector 保证，“怎么”移动就是 T 的事情了。\n\n对于一个内部有定长数组的对象，显然移动跟拷贝对这个数组没有区别，当这个数组的元素是移动和拷贝没有区别的 POD 类型时。我想你说的该是这种情况，此时移动确实没用。如果你这个含数组的对象很大时，从设计角度应考虑在 vector 里放对象的（智能）指针而不是对象本身。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1635936657,"ip_address":"","comment_id":319686,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"看过这节之后我对移动构造函数有了疑问，我们知道vector就像数组，对象必须放在连续的空间，那么对于在vector里使用的对象，即使提供了移动构造函数，它和拷贝构造函数在语义上是否应该一致呢？比如对象内部保存的是另外一个定长数组，那么移动构造函数是否需要向拷贝构造函数一样进行深层拷贝，如果不这样，vector不就不能把对象复制到连续空间上了么？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529723,"discussion_content":"你说的是 vector 如何移动对象，而不是 vector 自身的移动，对吧？如果不是，请另起一个新问题。\n\nvector 分配的空间是连续的。如果元素类型为 T，vector 的 capacity 是 n，那分配的空间大小就是 n * sizeof(T)。所谓移动构造，就是 vector 在指定的内存位置上调用 T 的移动构造函数。空间连续性由 vector 保证，“怎么”移动就是 T 的事情了。\n\n对于一个内部有定长数组的对象，显然移动跟拷贝对这个数组没有区别，当这个数组的元素是移动和拷贝没有区别的 POD 类型时。我想你说的该是这种情况，此时移动确实没用。如果你这个含数组的对象很大时，从设计角度应考虑在 vector 里放对象的（智能）指针而不是对象本身。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635936657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313851,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1632712124,"is_pvip":false,"replies":[{"id":113759,"content":"提供移动构造没什么需要谨慎的。你要把对象 move 给其他函数，当然是有要求的（也谈不上“慎用”）——一般而言，一个被移动的对象，后面应当除了析构，没有其他的操作了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1632810295,"ip_address":"","comment_id":313851,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"移动构造这种其实要慎用吧，如果还需要使用源对象的话","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527492,"discussion_content":"提供移动构造没什么需要谨慎的。你要把对象 move 给其他函数，当然是有要求的（也谈不上“慎用”）——一般而言，一个被移动的对象，后面应当除了析构，没有其他的操作了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632810295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306432,"user_name":"朱烈鑫","can_delete":false,"product_type":"c1","uid":2727515,"ip_address":"","ucode":"5D3B15D2E3F2DA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f07iaZ0Iia78LOmLjyGMibG4I4TjoUexQqDYqVXibM7Mia2r7zOw8QpicD0TMq1poqzx6w1CA/132","comment_is_top":false,"comment_ctime":1628561950,"is_pvip":false,"replies":[{"id":110952,"content":"我要求C++17。看起来你的编译器不支持C++17。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1628578338,"ip_address":"","comment_id":306432,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师你好，我把小工具拿到Qt上面，报了不少的错，也\nerror: &#39;is_pair_v&#39; declared as an &#39;inline&#39; variable\n inline bool is_pair_v = is_pair&lt;T&gt;::value;\n             ^","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524762,"discussion_content":"我要求C++17。看起来你的编译器不支持C++17。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628578338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301318,"user_name":"Geek_a93ab1","can_delete":false,"product_type":"c1","uid":1625587,"ip_address":"","ucode":"17D303FA1F3C46","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL63dLLFyh9NGSVaRiboamDHZ0ibD5eOoh3oBMDExAfMMWkiauTT6ClR80d0XtLTibiaHjRODOsKNemtYw/132","comment_is_top":false,"comment_ctime":1625629632,"is_pvip":false,"replies":[{"id":109134,"content":"仔细看图，想一下，如果你有某项的迭代器，你能高效实现在它之前插入一项吗？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1625662408,"ip_address":"","comment_id":301318,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师好， 为什么forward_list要搞一个emplace_after,而不直接像list一样，就用emplace, 而且还要单独搞一个before_front ?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522967,"discussion_content":"仔细看图，想一下，如果你有某项的迭代器，你能高效实现在它之前插入一项吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625662408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293980,"user_name":"Four y","can_delete":false,"product_type":"c1","uid":1608789,"ip_address":"","ucode":"816C50CA85E3AE","user_header":"https://static001.geekbang.org/account/avatar/00/18/8c/55/cac3dbcc.jpg","comment_is_top":false,"comment_ctime":1621666754,"is_pvip":false,"replies":[{"id":106598,"content":"哈哈，不枉我花力气把这些图画出来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1621678753,"ip_address":"","comment_id":293980,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"这节真是干活满满，而且简单易懂，对于很多容器的底层实现通过图的方式展现，很棒。\nPS：之前看了以下STL源码剖析没有坚持看下去，学了这两节应该能有很好的理解。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520455,"discussion_content":"哈哈，不枉我花力气把这些图画出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621678753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284883,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1616510692,"is_pvip":false,"replies":[{"id":103457,"content":"你编译一下我的例子试试：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;blob&#47;master&#47;04&#47;test02_vector.cpp\n\n我在 VS2019 下获得的结果跟 GCC&#47;Clang 的完全一致。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1616657501,"ip_address":"","comment_id":284883,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"吴老师好，请教个问题。\n我在vs2015 x86 Debug模式下，对一个有拷贝构造和移动构造的类多次插入到vector中，结果不管是带没带noexcept，都执行的是移动构造。用文中的vector实例代码也一样。想问下，noexcept用于控制vector调用移动构造或拷贝构造的这个说法，是编译器实现的吗？是不包含在c++标准里的吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517499,"discussion_content":"你编译一下我的例子试试：\n\nhttps://github.com/adah1972/geek_time_cpp/blob/master/04/test02_vector.cpp\n\n我在 VS2019 下获得的结果跟 GCC/Clang 的完全一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616657501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274785,"user_name":"wsh","can_delete":false,"product_type":"c1","uid":1006628,"ip_address":"","ucode":"C0FE187C6EECED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/24/d2575310.jpg","comment_is_top":false,"comment_ctime":1611155891,"is_pvip":false,"replies":[{"id":99785,"content":"“指定类型”和“任意类型”没有矛盾吧？\n\n我的原话是这么写的：‘“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。’——容器类里你可以指定放在里面的对象类型，而string（本质是 basic_string&lt;char&gt;）只能放字符类型，不能放 int 或者你自己的类对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611300053,"ip_address":"","comment_id":274785,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"真正的容器类，比如set或者map不也是需要指定类型，然后放一种类型的数据么，请问为什么说可以放任意类型？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514125,"discussion_content":"“指定类型”和“任意类型”没有矛盾吧？\n\n我的原话是这么写的：‘“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。’——容器类里你可以指定放在里面的对象类型，而string（本质是 basic_string&amp;lt;char&amp;gt;）只能放字符类型，不能放 int 或者你自己的类对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611300053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220237,"user_name":"Geek_24c4df","can_delete":false,"product_type":"c1","uid":2010573,"ip_address":"","ucode":"BD66D0854804A7","user_header":"","comment_is_top":false,"comment_ctime":1590211690,"is_pvip":false,"replies":[{"id":81353,"content":"push_back 做的事情就是拷贝或移动对象到目标位置。emplace_back 是在目标位置构造对象。这本来就是这两个成员函数的定义。\n\n按你的目的，最高效的写法应该是 v1.emplace_back()。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247779,"ip_address":"","comment_id":220237,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，请教一个问题，关于vector的示例代码\n如果把emplace_back写成push_back。为什么调用的是移动构造函数。\nv1.push_back(Obj1());\n这样的确会多一次Obj1的析构函数。也会出现一次Obj1(Obj1&amp;&amp;)\n这是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496097,"discussion_content":"push_back 做的事情就是拷贝或移动对象到目标位置。emplace_back 是在目标位置构造对象。这本来就是这两个成员函数的定义。\n\n按你的目的，最高效的写法应该是 v1.emplace_back()。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590247779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216978,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":2001918,"ip_address":"","ucode":"BDB1F211D11C54","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8b/fe/a7d1c17a.jpg","comment_is_top":false,"comment_ctime":1589379938,"is_pvip":false,"replies":[{"id":80495,"content":"1. deque 不算连续存储，元素之间只是部分连续，不能满足连续迭代器（第 7 讲）的概念。所以 deque 也不像 vector 一样有 data 成员函数。\n\n2. 某种程度上可以，但成员函数并不是越多越好。容器适配器都是其他容器功能的子集，但有时限定别人只能用这个子集是件好事，防止犯错。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589557063,"ip_address":"","comment_id":216978,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"不好意思才注意到原来容器还有一讲== 小白重新整理一下提问\n1. 既然deque也能连续储存，是不是意味着可以替代vector呢，请问有什么场景不可以吗？\n2. vector是不是也可以替代stack？毕竟还多一个有坐标的功能呢。。。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494998,"discussion_content":"1. deque 不算连续存储，元素之间只是部分连续，不能满足连续迭代器（第 7 讲）的概念。所以 deque 也不像 vector 一样有 data 成员函数。\n\n2. 某种程度上可以，但成员函数并不是越多越好。容器适配器都是其他容器功能的子集，但有时限定别人只能用这个子集是件好事，防止犯错。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589557063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207850,"user_name":"时之沙","can_delete":false,"product_type":"c1","uid":1346221,"ip_address":"","ucode":"E01FB59AE6ABB9","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/ad/6e6275bd.jpg","comment_is_top":false,"comment_ctime":1587197192,"is_pvip":false,"replies":[{"id":77592,"content":"正文里不写了么？……vector的操作一般保证强异常安全性的。仔细想想如果移动的时候可能抛异常会出现什么后果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1587218299,"ip_address":"","comment_id":207850,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师你好，Obj1 和 Obj2 的定义只差了一个 noexcept，但这个小小的差异就导致了 vector 是否会移动对象。那是为什么呢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492262,"discussion_content":"正文里不写了么？……vector的操作一般保证强异常安全性的。仔细想想如果移动的时候可能抛异常会出现什么后果。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587218299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200682,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1510495,"ip_address":"","ucode":"C6FC61A90F202B","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","comment_is_top":false,"comment_ctime":1585637327,"is_pvip":false,"replies":[{"id":75156,"content":"🤓🤩","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585661480,"ip_address":"","comment_id":200682,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"这几张图画的真有心","like_count":0},{"had_liked":false,"id":196435,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1585280871,"is_pvip":false,"replies":[{"id":74464,"content":"是说 output_container 吗？这种项目，有点探索性质的，需要掌握了技巧之后见招拆招，按意图的方式去实现，中间会遇到很多问题，一一解决了就出来了。另外，第 15 讲有对 output_container.h 的解读。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585316831,"ip_address":"","comment_id":196435,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"自己照着老师提供的头文件敲了一遍代码，发现里面有好多知识点能够挖掘学习呢。很好奇老师是如何设计开发这个项目的","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489299,"discussion_content":"是说 output_container 吗？这种项目，有点探索性质的，需要掌握了技巧之后见招拆招，按意图的方式去实现，中间会遇到很多问题，一一解决了就出来了。另外，第 15 讲有对 output_container.h 的解读。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585316831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314643,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","nickname":"徐洲更","note":"","ucode":"F8A323CB732D05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215731,"discussion_content":"谢谢老师，就是output_container文件，我去好好学习下15讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585376163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178217,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1581611205,"is_pvip":false,"replies":[{"id":69140,"content":"多想想，不急。有参考答案，但能不看尽量不看吧……到学完再看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581644797,"ip_address":"","comment_id":178217,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"看过STL源码剖析，这些知识还算了解\n但第3题，确实没有想到原因，不过PHP貌似是pop返回一个值的","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483708,"discussion_content":"多想想，不急。有参考答案，但能不看尽量不看吧……到学完再看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581644797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172458,"user_name":"Y.L.","can_delete":false,"product_type":"c1","uid":1649733,"ip_address":"","ucode":"17AFC3E634D6C6","user_header":"https://static001.geekbang.org/account/avatar/00/19/2c/45/f465e6ff.jpg","comment_is_top":false,"comment_ctime":1579181135,"is_pvip":false,"replies":[{"id":66926,"content":"我觉得参考资料里的 cppreference.com 就很好。当然不是离线的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579237134,"ip_address":"","comment_id":172458,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，请教下有没有啥手册或者工具可以速查用法，类似linux的man","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481746,"discussion_content":"我觉得参考资料里的 cppreference.com 就很好。当然不是离线的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579237134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1649733,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2c/45/f465e6ff.jpg","nickname":"Y.L.","note":"","ucode":"17AFC3E634D6C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":140962,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579392566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169554,"user_name":"忆民","can_delete":false,"product_type":"c1","uid":1497815,"ip_address":"","ucode":"E66CEAD1E910C5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBHLqk9ofIib9pgboMKZhVCia28M3FTf45C1bPrvH5ctCDhfAqS6ia13fQtBWGafADFIQsttJ7rgXwg/132","comment_is_top":false,"comment_ctime":1578378383,"is_pvip":false,"replies":[{"id":65788,"content":"OK，基本说到点子上了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392440,"ip_address":"","comment_id":169554,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"1:都是线性非关联容器\n2：这么多类型容器，不同容器适用于不同场景，这些容器使用模板方式实现，可以避免重复遭轮子，提高开发效率。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480609,"discussion_content":"OK，基本说到点子上了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578392440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161969,"user_name":"凌云","can_delete":false,"product_type":"c1","uid":1326161,"ip_address":"","ucode":"C5D3665C4FED40","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/51/c324a7de.jpg","comment_is_top":false,"comment_ctime":1576418985,"is_pvip":false,"replies":[{"id":61669,"content":"会将前面的元素拷贝或移动一遍。\n\n移动的条件文中提到了，元素类型需要“提供一个保证不抛异常的移动构造函数”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576458923,"ip_address":"","comment_id":161969,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"int main()\n{\n\tvector&lt;Obj1&gt; v1;\t\n\t&#47;&#47;v1.reserve(2);\n\tv1.emplace_back();\n\tv1.emplace_back();\n\tv1.emplace_back();\n}\n输出:\nObj1()\nObj1()\nObj1(const Obj1&amp;)\nObj1()\nObj1(const Obj1&amp;)\nObj1(const Obj1&amp;)\n&quot;vector 适合在尾部操作，这是它的内存布局决定的。只有在尾部插入和删除时，其他元素才会不需要移动，除非内存空间不足导致需要重新分配内存空间&quot;,讲义中的例子,如果未调用reserve,那么是构造,构造,拷贝构造,构造,然后是2次拷贝构造,那么重新分配内存空间的意思是,当指定的空间不足以放下所有元素时,会将前面的元素拷贝一遍?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477931,"discussion_content":"会将前面的元素拷贝或移动一遍。\n\n移动的条件文中提到了，元素类型需要“提供一个保证不抛异常的移动构造函数”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576458923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161439,"user_name":"神秘的火柴人","can_delete":false,"product_type":"c1","uid":1574688,"ip_address":"","ucode":"9DD04338833E0D","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/20/8b1291ad.jpg","comment_is_top":false,"comment_ctime":1576206695,"is_pvip":false,"replies":[{"id":61593,"content":"多谢多谢。已经修复。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576312343,"ip_address":"","comment_id":161439,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，文中：\n\nstack\n类似地，栈 stack 是后进先出（LIFO）的数据结构。\nqueue 缺省也是用 deque 来实现，但它的概念和 vector 更相似。它的接口跟 vector 比，有如下改变：\n\n这里queue缺省是不是笔误了，应该是stack吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477720,"discussion_content":"多谢多谢。已经修复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576312343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161136,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576127805,"is_pvip":false,"replies":[{"id":61456,"content":"不是。执行 v1.reserve(2) 之后，空间大小就是 2 了。扩充空间是一个编译器自发进行的操作，没有用户控制。一般会类似于 reserve(size() * 2)。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576140770,"ip_address":"","comment_id":161136,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师 vector obj1演示代码里，在构造第三个元素发现空间不够之后，v1会按我们之前设定好的自动调用v1.reserve（2）来扩充空间，是这个意思嘛？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477720,"discussion_content":"多谢多谢。已经修复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576312343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160213,"user_name":"hdongdong123","can_delete":false,"product_type":"c1","uid":1724769,"ip_address":"","ucode":"D74589952987D9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","comment_is_top":false,"comment_ctime":1575892735,"is_pvip":false,"replies":[{"id":61117,"content":"就像你在代码里对 str 定义两次一样啊。这仍然是 C++，不是 Python。\n\nRestart kernel 可以重新来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575895330,"ip_address":"","comment_id":160213,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师给的工具xeus-cling为啥第二次运行的时候就报错error: redefinition of &#39;str&#39;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477297,"discussion_content":"就像你在代码里对 str 定义两次一样啊。这仍然是 C++，不是 Python。\n\nRestart kernel 可以重新来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159716,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575736478,"is_pvip":false,"replies":[{"id":61016,"content":"指单个元素的大小，sizeof。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575776113,"ip_address":"","comment_id":159716,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师请问 &quot;在元素大小较小的情况下，forward_list 能节约的内存是非常可观的&quot;\n这句话怎么理解呢，元素大小较小的情况下，是指的元素数量小，还是元素本身的值偏小呢。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477297,"discussion_content":"就像你在代码里对 str 定义两次一样啊。这仍然是 C++，不是 Python。\n\nRestart kernel 可以重新来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200682,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1510495,"ip_address":"","ucode":"C6FC61A90F202B","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","comment_is_top":false,"comment_ctime":1585637327,"is_pvip":false,"replies":[{"id":75156,"content":"🤓🤩","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585661480,"ip_address":"","comment_id":200682,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"这几张图画的真有心","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490099,"discussion_content":"🤓🤩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585661480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196435,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1585280871,"is_pvip":false,"replies":[{"id":74464,"content":"是说 output_container 吗？这种项目，有点探索性质的，需要掌握了技巧之后见招拆招，按意图的方式去实现，中间会遇到很多问题，一一解决了就出来了。另外，第 15 讲有对 output_container.h 的解读。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585316831,"ip_address":"","comment_id":196435,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"自己照着老师提供的头文件敲了一遍代码，发现里面有好多知识点能够挖掘学习呢。很好奇老师是如何设计开发这个项目的","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490099,"discussion_content":"🤓🤩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585661480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178217,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1581611205,"is_pvip":false,"replies":[{"id":69140,"content":"多想想，不急。有参考答案，但能不看尽量不看吧……到学完再看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581644797,"ip_address":"","comment_id":178217,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"看过STL源码剖析，这些知识还算了解\n但第3题，确实没有想到原因，不过PHP貌似是pop返回一个值的","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489299,"discussion_content":"是说 output_container 吗？这种项目，有点探索性质的，需要掌握了技巧之后见招拆招，按意图的方式去实现，中间会遇到很多问题，一一解决了就出来了。另外，第 15 讲有对 output_container.h 的解读。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585316831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314643,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","nickname":"徐洲更","note":"","ucode":"F8A323CB732D05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215731,"discussion_content":"谢谢老师，就是output_container文件，我去好好学习下15讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585376163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172458,"user_name":"Y.L.","can_delete":false,"product_type":"c1","uid":1649733,"ip_address":"","ucode":"17AFC3E634D6C6","user_header":"https://static001.geekbang.org/account/avatar/00/19/2c/45/f465e6ff.jpg","comment_is_top":false,"comment_ctime":1579181135,"is_pvip":false,"replies":[{"id":66926,"content":"我觉得参考资料里的 cppreference.com 就很好。当然不是离线的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579237134,"ip_address":"","comment_id":172458,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，请教下有没有啥手册或者工具可以速查用法，类似linux的man","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483708,"discussion_content":"多想想，不急。有参考答案，但能不看尽量不看吧……到学完再看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581644797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169554,"user_name":"忆民","can_delete":false,"product_type":"c1","uid":1497815,"ip_address":"","ucode":"E66CEAD1E910C5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBHLqk9ofIib9pgboMKZhVCia28M3FTf45C1bPrvH5ctCDhfAqS6ia13fQtBWGafADFIQsttJ7rgXwg/132","comment_is_top":false,"comment_ctime":1578378383,"is_pvip":false,"replies":[{"id":65788,"content":"OK，基本说到点子上了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392440,"ip_address":"","comment_id":169554,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"1:都是线性非关联容器\n2：这么多类型容器，不同容器适用于不同场景，这些容器使用模板方式实现，可以避免重复遭轮子，提高开发效率。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481746,"discussion_content":"我觉得参考资料里的 cppreference.com 就很好。当然不是离线的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579237134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1649733,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2c/45/f465e6ff.jpg","nickname":"Y.L.","note":"","ucode":"17AFC3E634D6C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":140962,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579392566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161969,"user_name":"凌云","can_delete":false,"product_type":"c1","uid":1326161,"ip_address":"","ucode":"C5D3665C4FED40","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/51/c324a7de.jpg","comment_is_top":false,"comment_ctime":1576418985,"is_pvip":false,"replies":[{"id":61669,"content":"会将前面的元素拷贝或移动一遍。\n\n移动的条件文中提到了，元素类型需要“提供一个保证不抛异常的移动构造函数”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576458923,"ip_address":"","comment_id":161969,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"int main()\n{\n\tvector&lt;Obj1&gt; v1;\t\n\t&#47;&#47;v1.reserve(2);\n\tv1.emplace_back();\n\tv1.emplace_back();\n\tv1.emplace_back();\n}\n输出:\nObj1()\nObj1()\nObj1(const Obj1&amp;)\nObj1()\nObj1(const Obj1&amp;)\nObj1(const Obj1&amp;)\n&quot;vector 适合在尾部操作，这是它的内存布局决定的。只有在尾部插入和删除时，其他元素才会不需要移动，除非内存空间不足导致需要重新分配内存空间&quot;,讲义中的例子,如果未调用reserve,那么是构造,构造,拷贝构造,构造,然后是2次拷贝构造,那么重新分配内存空间的意思是,当指定的空间不足以放下所有元素时,会将前面的元素拷贝一遍?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480609,"discussion_content":"OK，基本说到点子上了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578392440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161439,"user_name":"神秘的火柴人","can_delete":false,"product_type":"c1","uid":1574688,"ip_address":"","ucode":"9DD04338833E0D","user_header":"https://static001.geekbang.org/account/avatar/00/18/07/20/8b1291ad.jpg","comment_is_top":false,"comment_ctime":1576206695,"is_pvip":false,"replies":[{"id":61593,"content":"多谢多谢。已经修复。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576312343,"ip_address":"","comment_id":161439,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，文中：\n\nstack\n类似地，栈 stack 是后进先出（LIFO）的数据结构。\nqueue 缺省也是用 deque 来实现，但它的概念和 vector 更相似。它的接口跟 vector 比，有如下改变：\n\n这里queue缺省是不是笔误了，应该是stack吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477931,"discussion_content":"会将前面的元素拷贝或移动一遍。\n\n移动的条件文中提到了，元素类型需要“提供一个保证不抛异常的移动构造函数”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576458923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161136,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576127805,"is_pvip":false,"replies":[{"id":61456,"content":"不是。执行 v1.reserve(2) 之后，空间大小就是 2 了。扩充空间是一个编译器自发进行的操作，没有用户控制。一般会类似于 reserve(size() * 2)。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576140770,"ip_address":"","comment_id":161136,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师 vector obj1演示代码里，在构造第三个元素发现空间不够之后，v1会按我们之前设定好的自动调用v1.reserve（2）来扩充空间，是这个意思嘛？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477610,"discussion_content":"不是。执行 v1.reserve(2) 之后，空间大小就是 2 了。扩充空间是一个编译器自发进行的操作，没有用户控制。一般会类似于 reserve(size() * 2)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576140770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160213,"user_name":"hdongdong123","can_delete":false,"product_type":"c1","uid":1724769,"ip_address":"","ucode":"D74589952987D9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","comment_is_top":false,"comment_ctime":1575892735,"is_pvip":false,"replies":[{"id":61117,"content":"就像你在代码里对 str 定义两次一样啊。这仍然是 C++，不是 Python。\n\nRestart kernel 可以重新来。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575895330,"ip_address":"","comment_id":160213,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师给的工具xeus-cling为啥第二次运行的时候就报错error: redefinition of &#39;str&#39;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477610,"discussion_content":"不是。执行 v1.reserve(2) 之后，空间大小就是 2 了。扩充空间是一个编译器自发进行的操作，没有用户控制。一般会类似于 reserve(size() * 2)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576140770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159716,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575736478,"is_pvip":false,"replies":[{"id":61016,"content":"指单个元素的大小，sizeof。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575776113,"ip_address":"","comment_id":159716,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师请问 &quot;在元素大小较小的情况下，forward_list 能节约的内存是非常可观的&quot;\n这句话怎么理解呢，元素大小较小的情况下，是指的元素数量小，还是元素本身的值偏小呢。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477150,"discussion_content":"指单个元素的大小，sizeof。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575776113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159456,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575626867,"is_pvip":false,"replies":[{"id":60950,"content":"上来就错了。大部分容器都是在堆上分配空间的……\n\n2 正确。内存分配成功，新对象构造成功，才移动&#47;拷贝旧对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632535,"ip_address":"","comment_id":159456,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"吴老师，关于 vector 的 emplace_back 有2点疑问：\n1，我的理解，v1 的内存空间是在栈上分配的，当 v1 的capacity达到最大值时，需要给 v1 重新分配空间才能存放新的对象，因为栈帧是连续内存空间，那么不管是从高到低还是从低到高，已经分配的地址，比如v1[0],应该不变，但是查看v1[0]的地址，发现有变化，看起来第三次 emplace_back 导致 v1 的地址变化了，这样一来，原来存放v1[0] 和 v1[1] 的栈空间不就空了吗，那是不是导致了栈的内存空间不连续了？\n2，第三次 emplace_back 的打印信息显示，先调用了构造函数，再调用拷贝函数，是不是表示，当 v1 获得新地址后，是先在新的 v1[2] 上构造新对象，再把原来 v1[0] 和 v1[1] 中的对象拷贝过来？","like_count":0},{"had_liked":false,"id":158837,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575461921,"is_pvip":false,"replies":[{"id":60773,"content":"嘿嘿，还漏了个关键字。见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575466568,"ip_address":"","comment_id":158837,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"然后第三问 我看了留言 和你的提示 我确切的说是避免临时对象的构造和析构 提高性能 毕竟我们Pop掉过后就不需要了 这个回答满分","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477066,"discussion_content":"上来就错了。大部分容器都是在堆上分配空间的……\n\n2 正确。内存分配成功，新对象构造成功，才移动/拷贝旧对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575632535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158836,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575461836,"is_pvip":false,"replies":[{"id":60767,"content":"一、二没有标准答案。三的关键字见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575465608,"ip_address":"","comment_id":158836,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第一问我可以调皮的回答是 都是对对象的一种存储和管理嘛 哈哈哈\n第二问 大概是为了满足不同的操作方式 比如有些需要先进先出 有些需要后进先出 有些需要随机访问等等\n第三问 我大胆猜想 要分开处理的原因 有的时候我们只需访问一下top或者front数据 而不是弹出 所以需要一个获取 既然已经有了获取 弹出的时候就不需要再拿到这个数字了, 如果用pop可以返回元素 栈顶元素就只能正确的访问一次 再一次访问时 栈顶元素就不对了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476866,"discussion_content":"嘿嘿，还漏了个关键字。见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575466568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158835,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575461479,"is_pvip":false,"replies":[{"id":60766,"content":"教知识是我的目的，而不是难倒你们哦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575465535,"ip_address":"","comment_id":158835,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"这节课的内容就浅显多了嘛  不过通过这节课的讲解vector的push_back反而我更能理解右值引用就是为了解决临时变量的拷贝构造和析构从而产生的性能问题 而移动则是为了解决像vector扩容后的拷贝到新内存区域的时候这个耗性能的过程","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476865,"discussion_content":"一、二没有标准答案。三的关键字见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575465608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158814,"user_name":"Zephyr","can_delete":false,"product_type":"c1","uid":1635120,"ip_address":"","ucode":"1DF3525146BFE7","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/30/8a8b2155.jpg","comment_is_top":false,"comment_ctime":1575458029,"is_pvip":false,"replies":[{"id":60753,"content":"谢谢报告。编辑已经修复链接。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575463961,"ip_address":"","comment_id":158814,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"container.h 404了老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476864,"discussion_content":"教知识是我的目的，而不是难倒你们哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575465535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158770,"user_name":"方阳","can_delete":false,"product_type":"c1","uid":1232080,"ip_address":"","ucode":"C8A5CA2422E38E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIsDF3jO1gFeBOboW1eRbeic7wC9Lh1v5wNWUAKcWGogfQicCVic3ic5YzLnKATo79icZzibIbs6kHLPx7Q/132","comment_is_top":false,"comment_ctime":1575448657,"is_pvip":false,"replies":[{"id":60763,"content":"这个只解释了为什么要有top，没解释为什么pop不可以“顺便”返回弹出的对象。\n\n关键字见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464956,"ip_address":"","comment_id":158770,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第三个问题，pop函数的意思是为了移除栈顶的元素，有这种情况，不想移除栈顶元素，只是想用栈顶的元素，如果用pop函数返回出元素，还需要再压入栈中，这造成了浪费，所以提供top函数访问栈顶元素。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476857,"discussion_content":"谢谢报告。编辑已经修复链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575463961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158722,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1575440459,"is_pvip":false,"replies":[{"id":60762,"content":"1、2实际上没标准答案，是引大家思考的。3要“得分”的话，关键字……见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464853,"ip_address":"","comment_id":158722,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"1. 除了老师总结这些我认为些容器都是具有顺序的吧。\n2. 这么多容器都是抽象数据结构的实现吧，这些比较常用，为了方便（?）就给实现出来了（瞎猜的..）\n3. top还有其他容器通过下标以及front，back返回的都是数据的引用，如果pop还要返回的话就会引发复制了，通过top返回可以在适用的场景由自己决定是不是要复制这个对象，不然的话不管需要不需要，每次pop都会复制对象了，会造成浪费","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476839,"discussion_content":"这个只解释了为什么要有top，没解释为什么pop不可以“顺便”返回弹出的对象。\n\n关键字见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158716,"user_name":"舍得","can_delete":false,"product_type":"c1","uid":1147685,"ip_address":"","ucode":"2146A08D2D79B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg","comment_is_top":false,"comment_ctime":1575439694,"is_pvip":false,"replies":[{"id":60760,"content":"你可以试试通用地写这个输出运算符。我写这个还是花了点力气的。😎","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464414,"ip_address":"","comment_id":158716,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"重载运算符就可以输出自定义类型了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476828,"discussion_content":"1、2实际上没标准答案，是引大家思考的。3要“得分”的话，关键字……见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158537,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1575416078,"is_pvip":false,"replies":[{"id":60727,"content":"3 再想想。提示：这个接口设计是 C++98 时的老设计。\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动&#47;拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575435274,"ip_address":"","comment_id":158537,"utype":1}],"discussion_count":3,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"1.今天讲的都是非关联容器，不像map这种可以关联起数据\n2.因为不同的容器类型底层的数据结构不同，适用于不同的场景，连续内存支持下边访问基本不在开头和中间插入删除那就基本上vector，频繁中间插入删除数据量又比较大那就可以考虑list，头尾增删可以考虑deque等\n3. 可能是没有必要？明明已经有top了，返回对象类型必然要实例化，浪费性能\n另外有个问题，关于vector的那段示例代码，各种感觉会分别调用三次构造三次拷贝以及三次构造三次移动。为什么是三次构造二次移动和拷贝呢","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476824,"discussion_content":"你可以试试通用地写这个输出运算符。我写这个还是花了点力气的。😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351254,"user_name":"hallo128","can_delete":false,"product_type":"c1","uid":1212044,"ip_address":"","ucode":"3921D6E11CFCB1","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/8c/f029535a.jpg","comment_is_top":false,"comment_ctime":1657638849,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"centos7中xeus-cling的安装和使用：http:&#47;&#47;t.csdn.cn&#47;ZtEeG\n\n我安装完成后，总结写了上面的安装使用，供大家参考","like_count":1},{"had_liked":false,"id":159456,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575626867,"is_pvip":false,"replies":[{"id":60950,"content":"上来就错了。大部分容器都是在堆上分配空间的……\n\n2 正确。内存分配成功，新对象构造成功，才移动&#47;拷贝旧对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632535,"ip_address":"","comment_id":159456,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"吴老师，关于 vector 的 emplace_back 有2点疑问：\n1，我的理解，v1 的内存空间是在栈上分配的，当 v1 的capacity达到最大值时，需要给 v1 重新分配空间才能存放新的对象，因为栈帧是连续内存空间，那么不管是从高到低还是从低到高，已经分配的地址，比如v1[0],应该不变，但是查看v1[0]的地址，发现有变化，看起来第三次 emplace_back 导致 v1 的地址变化了，这样一来，原来存放v1[0] 和 v1[1] 的栈空间不就空了吗，那是不是导致了栈的内存空间不连续了？\n2，第三次 emplace_back 的打印信息显示，先调用了构造函数，再调用拷贝函数，是不是表示，当 v1 获得新地址后，是先在新的 v1[2] 上构造新对象，再把原来 v1[0] 和 v1[1] 中的对象拷贝过来？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477066,"discussion_content":"上来就错了。大部分容器都是在堆上分配空间的……\n\n2 正确。内存分配成功，新对象构造成功，才移动/拷贝旧对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575632535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158837,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575461921,"is_pvip":false,"replies":[{"id":60773,"content":"嘿嘿，还漏了个关键字。见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575466568,"ip_address":"","comment_id":158837,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"然后第三问 我看了留言 和你的提示 我确切的说是避免临时对象的构造和析构 提高性能 毕竟我们Pop掉过后就不需要了 这个回答满分","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476866,"discussion_content":"嘿嘿，还漏了个关键字。见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575466568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158836,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575461836,"is_pvip":false,"replies":[{"id":60767,"content":"一、二没有标准答案。三的关键字见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575465608,"ip_address":"","comment_id":158836,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第一问我可以调皮的回答是 都是对对象的一种存储和管理嘛 哈哈哈\n第二问 大概是为了满足不同的操作方式 比如有些需要先进先出 有些需要后进先出 有些需要随机访问等等\n第三问 我大胆猜想 要分开处理的原因 有的时候我们只需访问一下top或者front数据 而不是弹出 所以需要一个获取 既然已经有了获取 弹出的时候就不需要再拿到这个数字了, 如果用pop可以返回元素 栈顶元素就只能正确的访问一次 再一次访问时 栈顶元素就不对了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476865,"discussion_content":"一、二没有标准答案。三的关键字见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575465608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158835,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575461479,"is_pvip":false,"replies":[{"id":60766,"content":"教知识是我的目的，而不是难倒你们哦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575465535,"ip_address":"","comment_id":158835,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"这节课的内容就浅显多了嘛  不过通过这节课的讲解vector的push_back反而我更能理解右值引用就是为了解决临时变量的拷贝构造和析构从而产生的性能问题 而移动则是为了解决像vector扩容后的拷贝到新内存区域的时候这个耗性能的过程","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476864,"discussion_content":"教知识是我的目的，而不是难倒你们哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575465535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158814,"user_name":"Zephyr","can_delete":false,"product_type":"c1","uid":1635120,"ip_address":"","ucode":"1DF3525146BFE7","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/30/8a8b2155.jpg","comment_is_top":false,"comment_ctime":1575458029,"is_pvip":false,"replies":[{"id":60753,"content":"谢谢报告。编辑已经修复链接。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575463961,"ip_address":"","comment_id":158814,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"container.h 404了老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476857,"discussion_content":"谢谢报告。编辑已经修复链接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575463961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158770,"user_name":"方阳","can_delete":false,"product_type":"c1","uid":1232080,"ip_address":"","ucode":"C8A5CA2422E38E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIsDF3jO1gFeBOboW1eRbeic7wC9Lh1v5wNWUAKcWGogfQicCVic3ic5YzLnKATo79icZzibIbs6kHLPx7Q/132","comment_is_top":false,"comment_ctime":1575448657,"is_pvip":false,"replies":[{"id":60763,"content":"这个只解释了为什么要有top，没解释为什么pop不可以“顺便”返回弹出的对象。\n\n关键字见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464956,"ip_address":"","comment_id":158770,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第三个问题，pop函数的意思是为了移除栈顶的元素，有这种情况，不想移除栈顶元素，只是想用栈顶的元素，如果用pop函数返回出元素，还需要再压入栈中，这造成了浪费，所以提供top函数访问栈顶元素。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476839,"discussion_content":"这个只解释了为什么要有top，没解释为什么pop不可以“顺便”返回弹出的对象。\n\n关键字见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158722,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1575440459,"is_pvip":false,"replies":[{"id":60762,"content":"1、2实际上没标准答案，是引大家思考的。3要“得分”的话，关键字……见YouCompleteMe的回答。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464853,"ip_address":"","comment_id":158722,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"1. 除了老师总结这些我认为些容器都是具有顺序的吧。\n2. 这么多容器都是抽象数据结构的实现吧，这些比较常用，为了方便（?）就给实现出来了（瞎猜的..）\n3. top还有其他容器通过下标以及front，back返回的都是数据的引用，如果pop还要返回的话就会引发复制了，通过top返回可以在适用的场景由自己决定是不是要复制这个对象，不然的话不管需要不需要，每次pop都会复制对象了，会造成浪费","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476828,"discussion_content":"1、2实际上没标准答案，是引大家思考的。3要“得分”的话，关键字……见YouCompleteMe的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158716,"user_name":"舍得","can_delete":false,"product_type":"c1","uid":1147685,"ip_address":"","ucode":"2146A08D2D79B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg","comment_is_top":false,"comment_ctime":1575439694,"is_pvip":false,"replies":[{"id":60760,"content":"你可以试试通用地写这个输出运算符。我写这个还是花了点力气的。😎","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464414,"ip_address":"","comment_id":158716,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"重载运算符就可以输出自定义类型了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476824,"discussion_content":"你可以试试通用地写这个输出运算符。我写这个还是花了点力气的。😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158537,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1575416078,"is_pvip":false,"replies":[{"id":60727,"content":"3 再想想。提示：这个接口设计是 C++98 时的老设计。\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动&#47;拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575435274,"ip_address":"","comment_id":158537,"utype":1}],"discussion_count":3,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"1.今天讲的都是非关联容器，不像map这种可以关联起数据\n2.因为不同的容器类型底层的数据结构不同，适用于不同的场景，连续内存支持下边访问基本不在开头和中间插入删除那就基本上vector，频繁中间插入删除数据量又比较大那就可以考虑list，头尾增删可以考虑deque等\n3. 可能是没有必要？明明已经有top了，返回对象类型必然要实例化，浪费性能\n另外有个问题，关于vector的那段示例代码，各种感觉会分别调用三次构造三次拷贝以及三次构造三次移动。为什么是三次构造二次移动和拷贝呢","like_count":0,"discussions":[{"author":{"id":1141444,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","nickname":"廖熊猫","note":"","ucode":"8E8C475CD11FBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71628,"discussion_content":"在插入的时候，你会发现空间不够了，然后开辟新的空间，在新空间先把最后插入的元素放好，然后再依次把以前的元素一个一个挪过来。空间不够的话最后一个元素是没法插入进去的啊，所以没办法移动三次的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575440005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1141444,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","nickname":"廖熊猫","note":"","ucode":"8E8C475CD11FBC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73084,"discussion_content":"这位同学说得很简单明了。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575552226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71628,"ip_address":"","group_id":0},"score":73084,"extra":""}]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476760,"discussion_content":"3 再想想。提示：这个接口设计是 C++98 时的老设计。\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动/拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575435274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351254,"user_name":"hallo128","can_delete":false,"product_type":"c1","uid":1212044,"ip_address":"","ucode":"3921D6E11CFCB1","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/8c/f029535a.jpg","comment_is_top":false,"comment_ctime":1657638849,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"centos7中xeus-cling的安装和使用：http:&#47;&#47;t.csdn.cn&#47;ZtEeG\n\n我安装完成后，总结写了上面的安装使用，供大家参考","like_count":1,"discussions":[{"author":{"id":1141444,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","nickname":"廖熊猫","note":"","ucode":"8E8C475CD11FBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71628,"discussion_content":"在插入的时候，你会发现空间不够了，然后开辟新的空间，在新空间先把最后插入的元素放好，然后再依次把以前的元素一个一个挪过来。空间不够的话最后一个元素是没法插入进去的啊，所以没办法移动三次的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575440005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1141444,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","nickname":"廖熊猫","note":"","ucode":"8E8C475CD11FBC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73084,"discussion_content":"这位同学说得很简单明了。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575552226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71628,"ip_address":"","group_id":0},"score":73084,"extra":""}]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476760,"discussion_content":"3 再想想。提示：这个接口设计是 C++98 时的老设计。\n\n两者都是要构造第 3 个对象时空间不足，需要这样：\n\n1. 分配一个足够大的新内存区域。\n2. 在上面构造第 3 个对象。\n3. 如果成功（没有异常），再移动/拷贝旧的对象。\n4. 全部成功，则析构旧对象，释放旧对象的内存。\n5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575435274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381649,"user_name":"coming","can_delete":false,"product_type":"c1","uid":1262181,"ip_address":"上海","ucode":"7625CE61D9A2D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","comment_is_top":false,"comment_ctime":1695607264,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100040501,"comment_content":" 关于本地配置xeus-cling\n\n- 安装\n```shell\n$ sh Mambaforge-23.3.1-1-Linux-x86_64.sh\n```\n\n- 配置环境变量: $HOME&#47;.profile\n\n```\n# miniforge\nexport MINIFORGE_HOME=$HOME&#47;mambaforge\nexport PATH=$PATH:$MINIFORGE_HOME&#47;bin\n```\n\n```shell\n$ source ~&#47;.profile\n```\n\n安装xeus-cling\n- https:&#47;&#47;github.com&#47;jupyter-xeus&#47;xeus-cling\n```shell\n$ mamba install -c conda-forge xeus-cling\n```\n\n- VSCode安装好jupyter插件\n&gt; Windows下使用WSL或者Docker环境\n```json\n{\n    &quot;recommendations&quot;: [\n        &quot;ms-toolsai.vscode-jupyter-cell-tags&quot;,\n        &quot;ms-toolsai.jupyter-renderers&quot;,\n        &quot;ms-toolsai.vscode-jupyter-powertoys&quot;,\n        &quot;ms-toolsai.vscode-jupyter-slideshow&quot;,\n        &quot;ms-python.python&quot;,\n        &quot;ms-python.vscode-pylance&quot;\n    ]\n}\n```","like_count":0},{"had_liked":false,"id":294557,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1621999252,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"反复看看，反复练习","like_count":0},{"had_liked":false,"id":381649,"user_name":"coming","can_delete":false,"product_type":"c1","uid":1262181,"ip_address":"上海","ucode":"7625CE61D9A2D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/65/5bfd0a65.jpg","comment_is_top":false,"comment_ctime":1695607264,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100040501,"comment_content":" 关于本地配置xeus-cling\n\n- 安装\n```shell\n$ sh Mambaforge-23.3.1-1-Linux-x86_64.sh\n```\n\n- 配置环境变量: $HOME&#47;.profile\n\n```\n# miniforge\nexport MINIFORGE_HOME=$HOME&#47;mambaforge\nexport PATH=$PATH:$MINIFORGE_HOME&#47;bin\n```\n\n```shell\n$ source ~&#47;.profile\n```\n\n安装xeus-cling\n- https:&#47;&#47;github.com&#47;jupyter-xeus&#47;xeus-cling\n```shell\n$ mamba install -c conda-forge xeus-cling\n```\n\n- VSCode安装好jupyter插件\n&gt; Windows下使用WSL或者Docker环境\n```json\n{\n    &quot;recommendations&quot;: [\n        &quot;ms-toolsai.vscode-jupyter-cell-tags&quot;,\n        &quot;ms-toolsai.jupyter-renderers&quot;,\n        &quot;ms-toolsai.vscode-jupyter-powertoys&quot;,\n        &quot;ms-toolsai.vscode-jupyter-slideshow&quot;,\n        &quot;ms-python.python&quot;,\n        &quot;ms-python.vscode-pylance&quot;\n    ]\n}\n```","like_count":0},{"had_liked":false,"id":294557,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1621999252,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"反复看看，反复练习","like_count":0}]}