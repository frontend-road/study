{"id":6849,"title":"第2讲 | Exception和Error有什么区别？","content":"<p>世界上存在永远不会出错的程序吗？也许这只会出现在程序员的梦中。随着编程语言和软件的诞生，异常情况就如影随形地纠缠着我们，只有正确处理好意外情况，才能保证程序的可靠性。</p>\n<p>Java语言在设计之初就提供了相对完善的异常处理机制，这也是Java得以大行其道的原因之一，因为这种机制大大降低了编写和维护可靠程序的门槛。如今，异常处理机制已经成为现代编程语言的标配。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">请对比Exception和Error，另外，运行时异常与一般异常有什么区别？</span></p>\n<h2>典型回答</h2>\n<p>Exception和Error都是继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>\n<p>Exception和Error体现了Java平台设计者对不同异常情况的分类。Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>\n<p>Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。</p>\n<p>Exception又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的Error，是Throwable不是Exception。</p>\n<p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>\n<h2>考点分析</h2>\n<p>分析Exception和Error的区别，是从概念角度考察了Java处理机制。总的来说，还处于理解的层面，面试者只要阐述清楚就好了。</p>\n<p>我们在日常编程中，如何处理好异常是比较考验功底的，我觉得需要掌握两个方面。</p>\n<!-- [[[read_end]]] -->\n<p>第一，<strong>理解Throwable、Exception、Error的设计和分类</strong>。比如，掌握那些应用最为广泛的子类，以及如何自定义异常等。</p>\n<p>很多面试官会进一步追问一些细节，比如，你了解哪些Error、Exception或者RuntimeException？我画了一个简单的类图，并列出来典型例子，可以给你作为参考，至少做到基本心里有数。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ac/00/accba531a365e6ae39614ebfa3273900.png?wh=803*474\" alt=\"\" /></p>\n<p>其中有些子类型，最好重点理解一下，比如NoClassDefFoundError和ClassNotFoundException有什么区别，这也是个经典的入门题目。</p>\n<p>第二，<strong>理解Java语言中操作Throwable的元素和实践</strong>。掌握最基本的语法是必须的，如try-catch-finally块，throw、throws关键字等。与此同时，也要懂得如何处理典型场景。</p>\n<p>异常处理代码比较繁琐，比如我们需要写很多千篇一律的捕获代码，或者在finally里面做一些资源回收工作。随着Java语言的发展，引入了一些更加便利的特性，比如try-with-resources和multiple catch，具体可以参考下面的代码段。在编译时期，会自动生成相应的处理逻辑，比如，自动按照约定俗成close那些扩展了AutoCloseable或者Closeable的对象。</p>\n<pre><code>try (BufferedReader br = new BufferedReader(…);\n     BufferedWriter writer = new BufferedWriter(…)) {// Try-with-resources\n// do something\ncatch ( IOException | XEception e) {// Multiple catch\n   // Handle it\n} \n</code></pre>\n<h2>知识扩展</h2>\n<p>前面谈的大多是概念性的东西，下面我来谈些实践中的选择，我会结合一些代码用例进行分析。</p>\n<p>先开看第一个吧，下面的代码反映了异常处理中哪些不当之处？</p>\n<pre><code>try {\n  // 业务代码\n  // …\n  Thread.sleep(1000L);\n} catch (Exception e) {\n  // Ignore it\n}\n</code></pre>\n<p>这段代码虽然很短，但是已经违反了异常处理的两个基本原则。</p>\n<p>第一，<strong>尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常</strong>，在这里是Thread.sleep()抛出的InterruptedException。</p>\n<p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的Exception之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望RuntimeException被扩散出来，而不是被捕获。</p>\n<p>进一步讲，除非深思熟虑了，否则不要捕获Throwable或者Error，这样很难保证我们能够正确程序处理OutOfMemoryError。</p>\n<p>第二，<strong>不要生吞（swallow）异常</strong>。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</p>\n<p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！</p>\n<p>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p>\n<p>再来看看第二段代码</p>\n<pre><code>try {\n   // 业务代码\n   // …\n} catch (IOException e) {\n    e.printStackTrace();\n}\n</code></pre>\n<p>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理。你先思考一下这是为什么呢？</p>\n<p>我们先来看看<a href=\"https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html#printStackTrace--\">printStackTrace()</a>的文档，开头就是“Prints this throwable and its backtrace to the <strong>standard error stream</strong>”。问题就在这里，在稍微复杂一点的生产系统中，标准出错（STERR）不是个合适的输出选项，因为你很难判断出到底输出到哪里去了。</p>\n<p>尤其是对于分布式系统，如果发生异常，但是无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。</p>\n<p>我们接下来看下面的代码段，体会一下<strong>Throw early, catch late原则</strong>。</p>\n<pre><code>public void readPreferences(String fileName){\n\t //...perform operations... \n\tInputStream in = new FileInputStream(fileName);\n\t //...read the preferences file...\n}\n</code></pre>\n<p>如果fileName是null，那么程序就会抛出NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个NPE只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p>\n<p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p>\n<pre><code>public void readPreferences(String filename) {\n\tObjects. requireNonNull(filename);\n\t//...perform other operations... \n\tInputStream in = new FileInputStream(filename);\n\t //...read the preferences file...\n}\n</code></pre>\n<p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的cause信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p>\n<p>有的时候，我们会根据需要自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑：</p>\n<ul>\n<li>是否需要定义成Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。</li>\n<li>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看Java的标准类库，你可能注意到类似java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。</li>\n</ul>\n<p>业界有一种争论（甚至可以算是某种程度的共识），Java语言的Checked Exception也许是个设计错误，反对者列举了几点：</p>\n<ul>\n<li>\n<p>Checked Exception的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception的使用，已经大大偏离了最初的设计目的。</p>\n</li>\n<li>\n<p>Checked Exception不兼容functional编程，如果你写过Lambda/Stream代码，相信深有体会。</p>\n</li>\n</ul>\n<p>很多开源项目，已经采纳了这种实践，比如Spring、Hibernate等，甚至反映在新的编程语言设计中，比如Scala等。 如果有兴趣，你可以参考：</p>\n<p><a href=\"http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/\">http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/</a>。</p>\n<p>当然，很多人也觉得没有必要矫枉过正，因为确实有一些异常，比如和环境相关的IO、网络等，其实是存在可恢复性的，而且Java已经通过业界的海量实践，证明了其构建高质量软件的能力。我就不再进一步解读了，感兴趣的同学可以点击<strong><a href=\"http://v.qq.com/x/page/d0635rf5x0o.html\">链接</a></strong>，观看Bruce Eckel在2018年全球软件开发大会QCon的分享Failing at Failing: How and Why We’ve Been Nonchalantly Moving Away From Exception Handling。</p>\n<p>我们从性能角度来审视一下Java的异常处理机制，这里有两个可能会相对昂贵的地方：</p>\n<ul>\n<li>\n<p>try-catch代码段会产生额外的性能开销，或者换个角度说，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</p>\n</li>\n<li>\n<p>Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</p>\n</li>\n</ul>\n<p>所以，对于部分追求极致性能的底层类库，有种方式是尝试创建不进行栈快照的Exception。这本身也存在争议，因为这样做的假设在于，我创建异常时知道未来是否需要堆栈。问题是，实际上可能吗？小范围或许可能，但是在大规模项目中，这么做可能不是个理智的选择。如果需要堆栈，但又没有收集这些信息，在复杂情况下，尤其是类似微服务这种分布式系统，这会大大增加诊断的难度。</p>\n<p>当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的Exception也是一种思路。关于诊断后台变慢的问题，我会在后面的Java性能基础模块中系统探讨。</p>\n<p>今天，我从一个常见的异常处理概念问题，简单总结了Java异常处理的机制。并结合代码，分析了一些普遍认可的最佳实践，以及业界最新的一些异常使用共识。最后，我分析了异常性能开销，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？可以思考一个问题，对于异常处理编程，不同的编程范式也会影响到异常处理策略，比如，现在非常火热的反应式编程（Reactive Stream），因为其本身是异步、基于事件机制的，所以出现异常情况，决不能简单抛出去；另外，由于代码堆栈不再是同步调用那种垂直的结构，这里的异常处理和日志需要更加小心，我们看到的往往是特定executor的堆栈，而不是业务方法调用关系。对于这种情况，你有什么好的办法吗？</p>\n<p>请你在留言区分享一下你的解决方案，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","comments":[{"had_liked":false,"id":8947,"user_name":"迷途知返","can_delete":false,"product_type":"c1","uid":1134438,"ip_address":"","ucode":"7C75D39F7497B3","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/66/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1526533674,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"4249249189418","product_id":100006701,"comment_content":"我比较菜  在听到“NoClassDefFoundError 和 ClassNotFoundException 有什么区别，这也是个经典的入门题目。“ 这一段的时候   我以为会讲这两个的区别呢   我觉得这个区别详细讲讲  就是干货！文章总结性的语言比较多 并不具体  ","like_count":990,"discussions":[{"author":{"id":1176620,"avatar":"","nickname":"正义的伙伴","note":"","ucode":"D8247A99BEBD81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174541,"discussion_content":"类的加载分为显式加载(用字符串为类名加载类，抛出ClassNotFoundException)和隐式加载(不是通过显式方法调用，由引用、实例化或继承导致装入类。通常这种错误在编译阶段会发现，报错为找不到符号。如果编译时能找到这个类，但运行时找不到这个类，就抛出NoClassDefFoundError)\n官方文档解释如下：\n————————————————\nClassNotFoundException：\n\n * Thrown when an application tries to load in a class through its\n * string name using:\n * 类 Class 中的 forName() 方法。\n * 类 ClassLoader 中的 findSystemClass() 方法。\n * 类 ClassLoader 中的 loadClass() 方法。\n * but no definition for the class with the specified name could be found.\n————————————————\nNoClassDefFoundError：\n\n * Thrown if the Java Virtual Machine or a <code>ClassLoader</code> instance\n * tries to load in the definition of a class (as part of a normal method call\n * or as part of creating a new instance using the <code>new</code> expression)\n * and no definition of the class could be found.\n * <p>\n * The searched-for class definition existed when the currently\n * executing class was compiled, but the definition can no longer be\n * found.\n比如：用maven的pom文件里引用了A.jar，这个A.jar需要依赖B.jar，但你只写了A.jar,没写B.jar，就会出现NoClassDefFoundError。 例子：java.lang.NoClassDefFoundError: org/apache/commons/beanutils/PropertyUtils\n————————————————","likes_number":67,"is_delete":false,"is_hidden":false,"ctime":1581926148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1117874,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0e/b2/7cf7e91c.jpg","nickname":"wsw","note":"","ucode":"68885262052BCD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176620,"avatar":"","nickname":"正义的伙伴","note":"","ucode":"D8247A99BEBD81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272775,"discussion_content":"能给出两者代表性的代码示例最好了(●°u°●)​ 」。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590340599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174541,"ip_address":""},"score":272775,"extra":""},{"author":{"id":1125885,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/fd/cfc952f5.jpg","nickname":"大科爱吃肉","note":"","ucode":"4C243A5729A848","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176620,"avatar":"","nickname":"正义的伙伴","note":"","ucode":"D8247A99BEBD81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375021,"discussion_content":"如果编译时能找到这个类，但运行时找不到这个类，就抛出NoClassDefFoundError)\n\n这一句话让我清醒了……  感谢~","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1621437558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174541,"ip_address":""},"score":375021,"extra":""}]},{"author":{"id":1338758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/86/2a0717df.jpg","nickname":"国奉","note":"","ucode":"9946ADFA81D92E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166964,"discussion_content":"1、NoClassDefFoundError 是Error 异常 ，然而ClassNotFoundException是检查异常\n2、NoClassDefFoundError 是在编译阶段发生，ClassNotFoundException是在运行期，Class.forName()、ClassLoader.findSystemClass()和ClassLoader.loadClass()的时候可能会发生\n3、当应用运行时没有找到对应的引用，则会抛出java.lang.NoClassDefFoundError","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1581434380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1666988,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6f/ac/7d3ca7a4.jpg","nickname":"kiss","note":"","ucode":"FB82014C34FC61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/86/2a0717df.jpg","nickname":"国奉","note":"","ucode":"9946ADFA81D92E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219866,"discussion_content":"你前面说是ClassNotFoundException发生在运行期，NoClassDefFoundError发生在编译期，最后一句怎么又说NoClassDefFoundError发生在运行时呢？","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1585818612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":166964,"ip_address":""},"score":219866,"extra":""},{"author":{"id":1600887,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKw8ictgYcqf6micS5WsEc5VBKRibvicicdoqvf2Y1vHsfqmmW6VlaKjmxpRfvVjUsLBllNypAicYcicj5fg/132","nickname":"子炎","note":"","ucode":"CE98D6CB1E5BA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/86/2a0717df.jpg","nickname":"国奉","note":"","ucode":"9946ADFA81D92E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282766,"discussion_content":"NoClassDefFoundError 也是在运行期发生的，简单的重现方式：\n编译后删除依赖的class文件后运行即可","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1592067595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":166964,"ip_address":""},"score":282766,"extra":""}]},{"author":{"id":1358984,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/QUTL809ntic1OkeHznEib1Q7g3SK6ic14g1zQZW8hoCqEAM1J8It27DJn5zNc7S9iaNotCYU4GKcW2EGgPL1yV4YAA/132","nickname":"Geek_500f31","note":"","ucode":"06287FA41FD22D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156201,"discussion_content":"文中提了后，又不具体说一下，真是。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1580318367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204234,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/0a/f971c088.jpg","nickname":"J","note":"","ucode":"4E568123CF5A3D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547004,"discussion_content":"NoClassDefFoundError 很多时候都是包冲突","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1642492878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2573588,"avatar":"","nickname":"Geek_8b92bf","note":"","ucode":"0EED09DA79D171","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398588,"discussion_content":"文中有简单的解析：\nException 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632816679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1646052,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1d/e4/517fbbbf.jpg","nickname":"白芷","note":"","ucode":"D37530955CF919","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215920,"discussion_content":"楼上的都太迷了，可以看Caliven的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585397846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636659,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f9/33/17246ab9.jpg","nickname":"Goslly","note":"","ucode":"8F868DAF3275CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187425,"discussion_content":"哪个高手是师傅手把手教成的？！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582731123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178158,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/2e/1359cb82.jpg","nickname":"Malanore","note":"","ucode":"602EA3FB647217","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564774,"discussion_content":"第一个多发生在类的静态变量没有初始化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650329908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2563994,"avatar":"https://static001.geekbang.org/account/avatar/00/27/1f/9a/d58b18cc.jpg","nickname":"SongY","note":"","ucode":"019C6474EA81BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396038,"discussion_content":"这个真的需要掌握嘛？都没遇到过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632384549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2424437,"avatar":"","nickname":"Geek_12f2a5","note":"","ucode":"5DCCBB9F868CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344565,"discussion_content":"不要听得要看的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611499216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9423,"user_name":"毛毛熊","can_delete":false,"product_type":"c1","uid":1118499,"ip_address":"","ucode":"B7332728804E6B","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/23/e7c7e870.jpg","comment_is_top":false,"comment_ctime":1526865163,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"2484017962251","product_id":100006701,"comment_content":"NoClassDefFoundError是一个错误(Error)，而ClassNOtFoundException是一个异常，在Java中对于错误和异常的处理是不同的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。<br>ClassNotFoundException的产生原因：<br><br>Java支持使用Class.forName方法来动态地加载类，任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br><br>ClassNotFoundException的产生原因：<br><br>Java支持使用Class.forName方法来动态地加载类，任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br>ClassNotFoundException的产生原因主要是：<br>Java支持使用反射方式在运行时动态加载类，例如使用Class.forName方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br>解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。<br>另外还有一个导致ClassNotFoundException的原因就是：当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。通过控制动态类加载过程，可以避免上述情况发生。<br><br>NoClassDefFoundError产生的原因在于：<br>如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError.<br>造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。","like_count":579,"discussions":[{"author":{"id":1485845,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ac/15/935acedb.jpg","nickname":"iusugar","note":"","ucode":"1372E5AD2068D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1684,"discussion_content":"3遍一样的，你是复制来的吗...","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1562811911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1463114,"avatar":"https://static001.geekbang.org/account/avatar/00/16/53/4a/331d6bce.jpg","nickname":"秋天的铁工匠","note":"","ucode":"47D6F9005C3BE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143085,"discussion_content":"这明显写的有问题的啊，为什么这么多人点赞","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1579489571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1423993,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ba/79/5a6336f5.jpg","nickname":"Ornamentism","note":"","ucode":"1A3BFE53A3BDBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1463114,"avatar":"https://static001.geekbang.org/account/avatar/00/16/53/4a/331d6bce.jpg","nickname":"秋天的铁工匠","note":"","ucode":"47D6F9005C3BE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201544,"discussion_content":"能不能给出正确答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583806939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143085,"ip_address":""},"score":201544,"extra":""}]},{"author":{"id":1756181,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cc/15/35622b02.jpg","nickname":"Jason","note":"","ucode":"B2765DD1D90B0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73378,"discussion_content":"点赞的是什么心态？都不仔细看的？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575558592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242263,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/97/2f738e40.jpg","nickname":"你当刚强壮胆。📌","note":"","ucode":"70D0219FC48F85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69586,"discussion_content":"复读机？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575294334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451688,"avatar":"https://static001.geekbang.org/account/avatar/00/16/26/a8/2a2cacfb.jpg","nickname":"zhuyu","note":"","ucode":"6A7DE3498CF5AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299089,"discussion_content":"重要的事情说三遍？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597559302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1423993,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ba/79/5a6336f5.jpg","nickname":"Ornamentism","note":"","ucode":"1A3BFE53A3BDBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201543,"discussion_content":"好奇葩，为什么会有三段一样的，第二段和第三段还有点差","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583806909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1721168,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","nickname":"凡","note":"","ucode":"80C2A6452AB9EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43598,"discussion_content":"对啊，还那么多人点赞 我去，能仔细看下么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572882051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26194,"user_name":"继业(Adrian)","can_delete":false,"product_type":"c1","uid":1021147,"ip_address":"","ucode":"D9BAF5F939A2B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/db/4e658ce8.jpg","comment_is_top":false,"comment_ctime":1537516203,"is_pvip":true,"replies":[{"id":"9887","content":"形象！","user_name":"作者回复","comment_id":26194,"uid":"1009360","ip_address":"","utype":1,"ctime":1537896343,"user_name_real":"杨晓峰"}],"discussion_count":9,"race_medal":0,"score":"1680869728939","product_id":100006701,"comment_content":"假如你开车上山，车坏了，你拿出工具箱修一修，修好继续上路（Exception被捕获，从异常中恢复，继续程序的运行），车坏了，你不知道怎么修，打电话告诉修车行，告诉你是什么问题，要车行过来修。（在当前的逻辑背景下，你不知道是怎么样的处理逻辑，把异常抛出去到更高的业务层来处理）。你打电话的时候，要尽量具体，不能只说我车动不了了。那修车行很难定位你的问题。（要补货特定的异常，不能捕获类似Exception的通用异常）。还有一种情况是，你开车上山，山塌了，这你还能修吗？（Error：导致你的运行环境进入不正常的状态，很难恢复）<br>------------------<br>思考问题：由于代码堆栈不再是同步调用那种垂直的结构，这里的异常处理和日志需要更加小心，我们看到的往往是特定 executor 的堆栈，而不是业务方法调用关系。对于这种情况，你有什么好的办法吗？<br>------------------<br>业务功能模块分配ID，在记录日志是将前后模块的ID进行调用关系的串联，一并跟任务信息，进行日志保存。","like_count":392,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424559,"discussion_content":"形象！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537896343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100271,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/ef/b7dd32d9.jpg","nickname":"Ben","note":"","ucode":"127AFF8EFFB2B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317716,"discussion_content":"traceId","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603592456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1881894,"avatar":"","nickname":"Geek_23bafd","note":"","ucode":"F7B38DF2F267A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219651,"discussion_content":"通俗易懂！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585792193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1665192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/68/a8/1fa41264.jpg","nickname":"马什么梅","note":"","ucode":"251B100AC229EE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84003,"discussion_content":"生动形象","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576480022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267106,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJaOtZQClC1UCJwoUnWUk4WhRQoicgVgicC4DhrM0bhtVK6Yj7KdV6BoJceK23vq0g2uVywxumwpM2g/132","nickname":"清风一阵吹我心","note":"","ucode":"C6F1D9331EC520","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69075,"discussion_content":"很简单的比喻，通俗易懂！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575258037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434361,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJxPAvD1ia0bpaVb7SzIgBCRR71KXVYt9zbyW61Ua8zaxVr9xVOjwgDZpqkFSRib3gmicre51ib7onJXQ/132","nickname":"Geek_c6292c","note":"","ucode":"4D4A1BC01EE762","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229096,"discussion_content":"膜拜","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586608902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514885,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1d/85/be44661a.jpg","nickname":"Suarez","note":"","ucode":"2341371D2ACA80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350867,"discussion_content":"通俗易懂，看评论也可以学到很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614058614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1728278,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/5f/16/e0946ab5.jpg","nickname":"我爱吃桃子","note":"","ucode":"897172BD6987CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305741,"discussion_content":"6666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600073139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018972,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","nickname":"亚林","note":"","ucode":"4A5A6D24314B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276239,"discussion_content":"调用链监控的起源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590844759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7826,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1525741377,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1156871944001","product_id":100006701,"comment_content":"在Java世界里，异常的出现让我们编写的程序运行起来更加的健壮，同时为程序在调试、运行期间发生的一些意外情况，提供了补救机会；即使遇到一些严重错误而无法弥补，异常也会非常忠实的记录所发生的这一切。以下是文章心得感悟:<br><br>1 不要推诿或延迟处理异常，就地解决最好，并且需要实实在在的进行处理，而不是只捕捉，不动作。<br><br>2 一个函数尽管抛出了多个异常，但是只有一个异常可被传播到调用端。最后被抛出的异常时唯一被调用端接收的异常，其他异常都会被吞没掩盖。如果调用端要知道造成失败的最初原因，程序之中就绝不能掩盖任何异常。<br><br>3 不要在finally代码块中处理返回值。<br><br>4 按照我们程序员的惯性认知：当遇到return语句的时候，执行函数会立刻返回。但是，在Java语言中，如果存在finally就会有例外。除了return语句，try代码块中的break或continue语句也可能使控制权进入finally代码块。<br><br>5 请勿在try代码块中调用return、break或continue语句。万一无法避免，一定要确保finally的存在不会改变函数的返回值。<br><br>6 函数返回值有两种类型：值类型与对象引用。对于对象引用，要特别小心，如果在finally代码块中对函数返回的对象成员属性进行了修改，即使不在finally块中显式调用return语句，这个修改也会作用于返回值上。<br><br>7 勿将异常用于控制流。<br><br>8 如无必要，勿用异常。<br>","like_count":270,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285850,"discussion_content":"怎么理解“一个函数尽管抛出了多个异常，但是只有一个异常可被传播到调用端。最后被抛出的异常时唯一被调用端接收的异常，其他异常都会被吞没掩盖。”？异常不是能抛出去多个并且捕获多个的么？？？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592970120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1182383,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/af/6f244997.jpg","nickname":"lee","note":"","ucode":"CD672BDB1B58F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320503,"discussion_content":"try catch finally 代码块中，如果try代码块中发生异常，被catch住之后，如果catch代码块也发生异常了，则会舍弃掉try代码块中的异常，finally同理，如果finally代码块中也发生异常了，则会舍弃掉之前的异常，转而抛出finally代码块中的异常","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604384982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285850,"ip_address":""},"score":320503,"extra":""}]}]},{"had_liked":false,"id":8487,"user_name":"DavidWhom佳传","can_delete":false,"product_type":"c1","uid":1130014,"ip_address":"","ucode":"C768B868115710","user_header":"https://static001.geekbang.org/account/avatar/00/11/3e/1e/01a794cb.jpg","comment_is_top":false,"comment_ctime":1526261817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"568461944889","product_id":100006701,"comment_content":"提出面试问题，却没有较好的回答，很难受(;_;)","like_count":131},{"had_liked":false,"id":7823,"user_name":"钱宇祥","can_delete":false,"product_type":"c1","uid":1107037,"ip_address":"","ucode":"D4D88CC869C803","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/5d/fccd3913.jpg","comment_is_top":false,"comment_ctime":1525741154,"is_pvip":false,"replies":[{"id":"2263","content":"很棒的总结","user_name":"作者回复","comment_id":7823,"uid":"1009360","ip_address":"","utype":1,"ctime":1525752914,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"443907372642","product_id":100006701,"comment_content":"1.异常：这种情况下的异常，可以通过完善任务重试机制，当执行异常时，保存当前任务信息加入重试队列。重试的策略根据业务需要决定，当达到重试上限依然无法成功，记录任务执行失败，同时发出告警。<br>2.日志：类比消息中间件，处在不同线程之间的同一任务，简单高效一点的做法可能是用traceId&#47;requestId串联。有些日志系统本身支持MDC&#47;NDC功能，可以串联相关联的日志。","like_count":104,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417483,"discussion_content":"很棒的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525752914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383656,"discussion_content":"traceId和spanId\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626181927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7867,"user_name":"coder王","can_delete":false,"product_type":"c1","uid":1121990,"ip_address":"","ucode":"21465DC3850BCB","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/c6/6f817e6e.jpg","comment_is_top":false,"comment_ctime":1525752793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"413842613209","product_id":100006701,"comment_content":"留言中凸显高手。","like_count":97},{"had_liked":false,"id":7941,"user_name":"欧阳田","can_delete":false,"product_type":"c1","uid":1054491,"ip_address":"","ucode":"24004916354446","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/1b/4a088e67.jpg","comment_is_top":false,"comment_ctime":1525792592,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"297878536016","product_id":100006701,"comment_content":"1.Error:系统错误，虚拟机出错，我们处理不了，也不需要我们来处理。<br>2.Exception，可以捕获的异常，且作出处理。也就是要么捕获异常并作出处理，要么继续抛出异常。<br>3.RuntimeException，经常性出现的错误，可以<br>捕获，并作出处理，可以不捕获，也可以不用抛出。ArrayIndexOutOfBoundsException像这种异常可以不捕获，为什么呢？在一个程序里，使用很多数组，如果使用一次捕获一次，则很累。<br>4.继承某个异常时，重写方法时，要么不抛出异常，要么抛出一模一样的异常。<br>5.当一个try后跟了很多个catch时，必须先捕获小的异常再捕获大的异常。<br>6.假如一个异常发生了，控制台打印了许多行信息，是因为程序中进行多层方法调用造成的。关键是看类型和行号。<br>7.上传下载不能抛异常。上传下载一定要关流。<br>8.异常不是错误。异常控制代码流程不利于代码简单易读。<br>9.try  catch  finally执行流程，与 return，break，continue等混合使用注意代码执行顺序。不是不可以，而是越是厉害的人，代码越容易理解。","like_count":70,"discussions":[{"author":{"id":1092044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a9/cc/c417c886.jpg","nickname":"湮灭星空","note":"","ucode":"B1061A4C298E13","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321728,"discussion_content":"9.try catch finally执行流程，与 return，break，continue等混合使用注意代码执行顺序。不是不可以，而是越是厉害的人，代码越容易理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604627256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1636659,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f9/33/17246ab9.jpg","nickname":"Goslly","note":"","ucode":"8F868DAF3275CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187415,"discussion_content":"9.try catch finally执行流程，与 return，break，continue等混合使用注意代码执行顺序。不是不可以，而是越是厉害的人，代码越容易理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582730969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1635513,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f4/b9/66f78e40.jpg","nickname":"杨军","note":"","ucode":"1BB7B6DCD42A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5359,"discussion_content":"9.try catch finally执行流程，与 return，break，continue等混合使用注意代码执行顺序。不是不可以，而是越是厉害的人，代码越容易理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566202515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7816,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1525740791,"is_pvip":false,"replies":[{"id":"2264","content":"是的，非常棒的总结，归根结底我们需要一堆人合作构建各种规模的程序，Java异常处理有槽点，但实践证明了其能力；<br>类似第二点，我个人也觉得可以泛化为异步编程的概念，比如Future Stage之类使用ExecutionException的思路","user_name":"作者回复","comment_id":7816,"uid":"1009360","ip_address":"","utype":1,"ctime":1525753232,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"272108680439","product_id":100006701,"comment_content":"先说问题外的话，Java的checked exception总是被诟病，可我是从C#转到Java开发上来的，中间经历了go，体验过scala。我觉得Java这种机制并没有什么不好，不同的语言体验下来，错误与异常机制真是各有各的好处和槽点，而Java我觉得处在中间，不极端。当然老师提到lambda这确实是个问题...<br>至于响应式编程，我可以泛化为异步编程的概念嘛？一般各种异步编程框架都会对异常的传递和堆栈信息做处理吧？比如promise&#47;future风格的。本质上大致就是把lambda中的异常捕获并封装，再进一步延续异步上下文，或者转同步处理时拿到原始的错误和堆栈信息","like_count":64,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417481,"discussion_content":"是的，非常棒的总结，归根结底我们需要一堆人合作构建各种规模的程序，Java异常处理有槽点，但实践证明了其能力；\n类似第二点，我个人也觉得可以泛化为异步编程的概念，比如Future Stage之类使用ExecutionException的思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525753232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7857,"user_name":"飞云","can_delete":false,"product_type":"c1","uid":1113175,"ip_address":"","ucode":"03C2EC2D0A5BE2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/57/cf335b10.jpg","comment_is_top":false,"comment_ctime":1525747361,"is_pvip":false,"replies":[{"id":"2266","content":"谢谢建议，极客课程设计是尽量偏向通用场景，我们掉坑里，往往都不是在高大上的地方；全局异常Spring MVC的方式就很实用；对与干货，你是希望特定场景，特定问题吗？说说你的想法","user_name":"作者回复","comment_id":7857,"uid":"1009360","ip_address":"","utype":1,"ctime":1525753650,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"143259668129","product_id":100006701,"comment_content":"能不能讲下怎么捕捉整个项目的全局异常，说实话前两篇额干货都不多，希望点更实在的干货","like_count":34,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417497,"discussion_content":"谢谢建议，极客课程设计是尽量偏向通用场景，我们掉坑里，往往都不是在高大上的地方；全局异常Spring MVC的方式就很实用；对与干货，你是希望特定场景，特定问题吗？说说你的想法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525753650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7890,"user_name":"小绵羊拉拉","can_delete":false,"product_type":"c1","uid":1123168,"ip_address":"","ucode":"E41D1C66AE6CAF","user_header":"","comment_is_top":false,"comment_ctime":1525763066,"is_pvip":false,"replies":[{"id":"2290","content":"谢谢反馈，如果不做jvm或非常底层开发，个人没有看到这些细节的实际意义，如果非要问可以鄙视他：-）<br>创建Throwable因为要调用native方法fillInStacktrace；至于try catch finally，jvms第三章有细节，也可以自己写一段程序，用javap反编译看看 goto、异常表等等","user_name":"作者回复","comment_id":7890,"uid":"1009360","ip_address":"","utype":1,"ctime":1525796127,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"121784847354","product_id":100006701,"comment_content":"看完文章简单认识一些浅层的意思 但是我关注的 比如try catch源码实现 涉及   以及 文章中提到 try catch 产生 堆栈快照 影响jvm性能等 一笔带过 觉得不太过瘾。只是对于阿里的面试 读懂这篇文章还是不够。还希望作者从面试官的角度由浅入深的剖析异常处理 最后还是 谢谢分享","like_count":28,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417509,"discussion_content":"谢谢反馈，如果不做jvm或非常底层开发，个人没有看到这些细节的实际意义，如果非要问可以鄙视他：-）\n创建Throwable因为要调用native方法fillInStacktrace；至于try catch finally，jvms第三章有细节，也可以自己写一段程序，用javap反编译看看 goto、异常表等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525796127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41978,"user_name":"_JQ.Wang","can_delete":false,"product_type":"c1","uid":1227617,"ip_address":"","ucode":"6BE451E16592F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/61/90ad7c91.jpg","comment_is_top":false,"comment_ctime":1542885469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"117507002461","product_id":100006701,"comment_content":"希望作者能写一些干货，读完后，感觉没有多大收益。希望再深入些。","like_count":27},{"had_liked":false,"id":7811,"user_name":"猿工匠","can_delete":false,"product_type":"c1","uid":1112986,"ip_address":"","ucode":"82FA8DE6C28936","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/9a/72f7b184.jpg","comment_is_top":false,"comment_ctime":1525739955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"108899922355","product_id":100006701,"comment_content":"每天早上学习与复习一下😁😁","like_count":25},{"had_liked":false,"id":8060,"user_name":"小猴子吹泡泡","can_delete":false,"product_type":"c1","uid":1122941,"ip_address":"","ucode":"A5F214E388E41F","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/7d/b093ca1e.jpg","comment_is_top":false,"comment_ctime":1525885485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104605100589","product_id":100006701,"comment_content":"老师可以在文章末尾推荐一些基础和进阶的Java学习书籍或是资料吗？最好是使用较新版本jdk的","like_count":24},{"had_liked":false,"id":17228,"user_name":"Caliven","can_delete":false,"product_type":"c1","uid":1003139,"ip_address":"","ucode":"8C5DACDF30EF03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/83/88151c5f.jpg","comment_is_top":false,"comment_ctime":1532511434,"is_pvip":true,"replies":[{"id":"6052","content":"基本正确，另外jit不是解释而是编译，解释是解释器的工作","user_name":"作者回复","comment_id":17228,"uid":"1009360","ip_address":"","utype":1,"ctime":1532680175,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"91726824650","product_id":100006701,"comment_content":"<br>ClassNotFoundException是在写编码的时候编译器就能告诉你这个地方需要捕获异常，如：你使用Class.forName的时候就必须要你捕获或者throws这个异常。<br>而NoClassDefFoundError在Javac已经把程序成功的编译成字节码文件了,当JVM进程启动，通过类加载器加载字节码文件，然后由JIT去解释字节码指令的时候，在classpath下找不到对应的类进行加载时就会发生NoClassDefFoundError这个错误。<br>我也不知道我的理解正确么？","like_count":22,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421092,"discussion_content":"基本正确，另外jit不是解释而是编译，解释是解释器的工作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532680175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2809887,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/e0/1f/de322ce3.jpg","nickname":"Harley","note":"","ucode":"F92472893F2156","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555477,"discussion_content":"这里要看是开启的解释器还是jit及时编译器，执行java -version可以发现，默认是mixed mode模式混合使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646921599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7841,"user_name":"James","can_delete":false,"product_type":"c1","uid":1004593,"ip_address":"","ucode":"94920E60C5936E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/31/b4f14b84.jpg","comment_is_top":false,"comment_ctime":1525743270,"is_pvip":false,"replies":[{"id":"2261","content":"有道理，谢谢指出","user_name":"作者回复","comment_id":7841,"uid":"1009360","ip_address":"","utype":1,"ctime":1525752573,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"78835154598","product_id":100006701,"comment_content":"个人觉得checked exception &#47; unchecked exception 分别翻译为 检查型异常&#47;非检查型异常 更加好理解。<br>可检查异常容易被理解为可以不检查。","like_count":19,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417490,"discussion_content":"有道理，谢谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525752573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1648388,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/XA9Dx0Gv5dTDjZbdRDd8m5BQWOdsXhJcib2oosKqBpkztD4G63PIna2moqndQ0Zu0WVga4wFP7arLaR2RshczwA/132","nickname":"Geek_320111","note":"","ucode":"837D86A00F9DA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103934,"discussion_content":"但是作者到现在还没改过来！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577407308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9870,"user_name":"五年","can_delete":false,"product_type":"c1","uid":1081224,"ip_address":"","ucode":"28A6F945FB0626","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/88/c4263c58.jpg","comment_is_top":false,"comment_ctime":1527134346,"is_pvip":false,"replies":[{"id":"3088","content":"有打算，最近出差，黑白颠倒，回去找机会弄下","user_name":"作者回复","comment_id":9870,"uid":"1009360","ip_address":"","utype":1,"ctime":1527196577,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"65951643786","product_id":100006701,"comment_content":"老师讲的很好 😄 <br>不过理论讲过之后很容易忘 老师可以开一个github的代码库，将课程的最佳实践还有反例放进去吗","like_count":15,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418235,"discussion_content":"有打算，最近出差，黑白颠倒，回去找机会弄下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527196577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8002,"user_name":"涟漪","can_delete":false,"product_type":"c1","uid":1007590,"ip_address":"","ucode":"0CD89EBE88E478","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/e6/4a2ec290.jpg","comment_is_top":false,"comment_ctime":1525841287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61655383431","product_id":100006701,"comment_content":"非常感谢作者以及评论中的高手们！我很喜欢作者能够精选评论。","like_count":14},{"had_liked":false,"id":27039,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1537803458,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"57372378306","product_id":100006701,"comment_content":"杨老师和各位一起学习的学友们好！<br>学习完本节有以下几个小问题，麻烦解惑下，非常感谢：<br>1、Java中Exception为什么要分为checked、unchecked Exception?  <br>2、怎么区分以上两种Exception？仅仅是unchecked Exception都是继承自RuntimeException？<br>3、关于NoClassDefFoundError和ClassNotFoundException的问题：<br>  3.1）求两者区别的典型回答（标准答案）<br>  3.2）Java中类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备（Preparation)、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载(Unloading）7个阶段。请问NoClassDefFoundError和ClassNotFoundException分别都发生在哪几个阶段？","like_count":13,"discussions":[{"author":{"id":2011492,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b1/64/5570b054.jpg","nickname":"逍遥","note":"","ucode":"EDC322BAB83D67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272770,"discussion_content":"1、checked Exception 编译器会提醒你捕获的异常，并且可以处理修复。 unchecked Exception 是可以捕获，但无法处理的异常。\n2、RuntimeException 是 Exception 的一个子类，可以捕获，无法处理。比如ArrayIndexOutOfBoundsException，数组越界是无法处理的。例如FileNotFoundException(checked)无法读取到配置文件时，可以在异常抛出时，设置一个默认配置文件。\n3、类加载的时候先要把编译好的类文件（.class ，jar包等）加载到 JVM 管理的方法区当中，这个过程叫做加载，如果这个过程中没找类文件就会出现 ClassNotFoundException（比如：`Class.forName()`）。如果加载成功之后，会有一个该类的类对象（class 对象）。想访问类（解析），就通过这个类对象，当在内存当中没有找到这个类对象，就会出现 NotClassDefFoundError。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590338586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1943690,"avatar":"","nickname":"Geek_1b42a9","note":"","ucode":"79AF29855A53D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2011492,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b1/64/5570b054.jpg","nickname":"逍遥","note":"","ucode":"EDC322BAB83D67","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299702,"discussion_content":"关于第三点个人认为两者都是在运行时类加载阶段报错的， ClassNotFoundException是由Class.forName 尝试去某个路径的下找字节码文件，没有找到的话这是异常，而不是错误。NoClassDefFoundError则是编译时是ok的，但是由于某些原因，导致字节码文件丢失了，本来有的，却找不到了，导致无法加载类字节码文件而报的错。解析阶段只是替换为直接引用，并非在此阶段去保证对应的类信息存在。（我设计了在一个类A中new 类B 对象，编译后删除B.class，运行类A的字节码文件，然后就报 NoClassDefFoundError ，说明JVM 加载类B就没成功）。理解有误还请指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597771742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272770,"ip_address":""},"score":299702,"extra":""}]},{"author":{"id":1071945,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/49/90dbe5e5.jpg","nickname":"MOSAIC","note":"","ucode":"6217B689FFC36B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289472,"discussion_content":"都是发生在运行时 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594114023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2011492,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b1/64/5570b054.jpg","nickname":"逍遥","note":"","ucode":"EDC322BAB83D67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272772,"discussion_content":"不好意思，关于第二点。我在后面的评论看到老师有说 unchecked 可以处理，但难以处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590339291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8826,"user_name":"拉灯灯","can_delete":false,"product_type":"c1","uid":1127499,"ip_address":"","ucode":"059359B1FB157B","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/4b/de175f25.jpg","comment_is_top":false,"comment_ctime":1526469810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53066077362","product_id":100006701,"comment_content":"error指的是不可预料的错误，可能会导致程序宕机；而exception指的是在程序运行中可以预见的异常，而异常分为检查异常与一般异常，检查异常需要在程序中显示捕获并处理，一般异常可以通过程序编码来进行处理，比如数组越界，空指针等；异常处理的两大基本原则：不要捕获泛泛的异常信息，比如直接捕获Exception，这样会在增加代码阅读难度；不要生吞异常；打印异常信息是一个比较重的操作，会导致程序变慢；try catch最好是包括需要检验异常的代码，不要包含过长代码，这样会降低JVM的优化效率；这是学习本节课的部分总结","like_count":12},{"had_liked":false,"id":7861,"user_name":"Attract","can_delete":false,"product_type":"c1","uid":1112638,"ip_address":"","ucode":"DEB10AF9AB5A41","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/3e/92d74b38.jpg","comment_is_top":false,"comment_ctime":1525749916,"is_pvip":false,"replies":[{"id":"2256","content":"嗯，有些类似trace id的思路，构建树形堆栈也有帮助","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525751197,"ip_address":"","comment_id":7861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48770390172","product_id":100006701,"comment_content":"对于日志里面我们看到的往往是特定 executor 的堆栈，而不是业务方法调用关系这种情况，我在公司推行的是自定义异常，自定义的异常有一个错误码，这个错误码需要细到某个业务的某个方法的某种错，这样排查问题会很方便，但是写的时候就比较麻烦，文档也比较多","like_count":11,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417499,"discussion_content":"嗯，有些类似trace id的思路，构建树形堆栈也有帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525751197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7796,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1525739078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48770379334","product_id":100006701,"comment_content":"由于反应式编程是异步的，基于事件的，所以异常肯定不能直接抛出，如果直接抛出，随便一个异常都会引起程序崩溃，直接影响到对后续事件处理。个人觉得一种处理方式是：当某个事件发生异常时，为了不影响对后续事件的处理，可以对当前发生异常的事件进行拦截处理，然后将异常信息发送出去。<br><br>至于发生异常时，堆栈信息只是关于特定executor框架中的，不知道是否可以将之前事件的“上下文”带到executor，再传递给观察者？<br>（对反应式编程不太了解，尝试作答^_^）","like_count":11},{"had_liked":false,"id":66911,"user_name":"wgg9696","can_delete":false,"product_type":"c1","uid":1402167,"ip_address":"","ucode":"B59488988122F2","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/37/abc7a5bf.jpg","comment_is_top":false,"comment_ctime":1550040118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40204745782","product_id":100006701,"comment_content":"关于有些人说的讲解不深入，我想说一下我的看法。<br>老师讲解的是纲领和重要的知识点，剩下的细节，可以留给我们自己去深入学习。<br>比如，通过学习异常这节课，我总结了这道题面试的回答，概念性问题的理解和回答方法，还查找了阿里巴巴的java开发规范中关于异常的部分用以补充异常的实践。<br>所以，我觉得学习的过程中要学会按照老师提炼的框架，自己去深入学习，查找资料，各取所需。<br>","like_count":10},{"had_liked":false,"id":62864,"user_name":"美猴王","can_delete":false,"product_type":"c1","uid":1222844,"ip_address":"","ucode":"0B46E686B11C8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/bc/9f179054.jpg","comment_is_top":false,"comment_ctime":1548195471,"is_pvip":false,"replies":[{"id":"23336","content":"很新颖的思路","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549814741,"ip_address":"","comment_id":62864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40202901135","product_id":100006701,"comment_content":"提供一种思路：结合项目管理中对风险的分类，与文章的exception和errer做个关系对应。<br>checked exception（编译期异常）对应已知风险；<br>unchecked exception（运行时异常）对应可预测异常；<br>error（严重错误）对应不可预测风险；","like_count":9,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437375,"discussion_content":"很新颖的思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549814741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8207,"user_name":"三军","can_delete":false,"product_type":"c1","uid":1115689,"ip_address":"","ucode":"C1BCA262D7DE6C","user_header":"https://static001.geekbang.org/account/avatar/00/11/06/29/bf619df8.jpg","comment_is_top":false,"comment_ctime":1525967382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40180673046","product_id":100006701,"comment_content":"Java语言规范将派生于Error类或RuntimeException类的所有异常称为未检查（unchecked）异常，所有其他的异常成为已检查（checked）异常。<br><br>编译器将检查是否为所有的已检查异常提供了异常处理器。<br><br>这是经典，要好好理解。<br><br>平时我们使用throws往外拋错，或者try-catch这类异常处理器不就是处理已检查异常吗😊<br><br>未检查异常就是潜在的，编译器无需提供异常处理器进行处理。","like_count":9},{"had_liked":false,"id":8127,"user_name":"不吃老鼠的猫","can_delete":false,"product_type":"c1","uid":1126984,"ip_address":"","ucode":"0D87C9F66F57A8","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/48/933ba354.jpg","comment_is_top":false,"comment_ctime":1525915230,"is_pvip":true,"replies":[{"id":"2397","content":"这种处理是对的，这不是通常意义的业务逻辑","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525963573,"ip_address":"","comment_id":8127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40180620894","product_id":100006701,"comment_content":"看了整篇文章和留言，大家都提到了不能用异常控制流程，这个我也懂，可是在项目中比如一个serivce方法，会对请求参数做检验，如果请求参数bean有5个属性需要检验，检验不成功，怎么处理？我目前项目中大都是如果检验不成功，就throw一个RuntimeException，如果不用这种抛异常的方式，用其他什么方式让上层调用放知道呢？如果用返回值，是不是要定义好多返回码？","like_count":9,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417591,"discussion_content":"这种处理是对的，这不是通常意义的业务逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525963573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7938,"user_name":"fangxuan","can_delete":false,"product_type":"c1","uid":1073369,"ip_address":"","ucode":"3870F2BF5679A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/d9/829ac53b.jpg","comment_is_top":false,"comment_ctime":1525791863,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"35885530231","product_id":100006701,"comment_content":"有种浅尝辄止的感觉，希望老师能再深入一点。另外对于程序中到底是该抛出异常还是默默的处理掉，把我不好，希望老师能给点这方面的最佳实践。函数式编程中遇到checkedexception怎么处理能详细指点一下吗？","like_count":8},{"had_liked":false,"id":8643,"user_name":"先天专治不服","can_delete":false,"product_type":"c1","uid":1131162,"ip_address":"","ucode":"B23338F91797D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/9a/183455ca.jpg","comment_is_top":false,"comment_ctime":1526350959,"is_pvip":false,"replies":[{"id":"2585","content":"区分它是用来作为业务流转，还是利用切面编程做异常处理？<br>再说所谓实践，本就是仁者见仁的事","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526370425,"ip_address":"","comment_id":8643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31591122031","product_id":100006701,"comment_content":"同样有一个问题，在spring mvc中，就提供了controllerAdvice注解，在业主流程中抛出相应的异常，在controllerAdvice中通过异常类型，完成相应的message输出。这个本质上也是通过异常完成对流程控制。而且能让业务流程很干净整洁。但是我一直很纠结，按文中说法，这是比较低效的流程控制，请问要如何取舍？","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417805,"discussion_content":"区分它是用来作为业务流转，还是利用切面编程做异常处理？\n再说所谓实践，本就是仁者见仁的事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526370425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7781,"user_name":"米斯特.杜","can_delete":false,"product_type":"c1","uid":1089110,"ip_address":"","ucode":"C2C567259FDEE2","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/56/af7a9435.jpg","comment_is_top":false,"comment_ctime":1525735530,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31590506602","product_id":100006701,"comment_content":"Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。<br><br>提问：为什么要生成快照，什么时间销毁呢？","like_count":7,"discussions":[{"author":{"id":2922573,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/98/4d/e67671c9.jpg","nickname":"鱼","note":"","ucode":"EC8E8665290B5A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577412,"discussion_content":"你说的快照是e.print...嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656081466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1721168,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","nickname":"凡","note":"","ucode":"80C2A6452AB9EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43675,"discussion_content":"异常是要打印调用栈信息的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572883671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8148,"user_name":"Ccook","can_delete":false,"product_type":"c1","uid":1078672,"ip_address":"","ucode":"0CD06E0FCDF803","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/90/ae39bc39.jpg","comment_is_top":false,"comment_ctime":1525926978,"is_pvip":false,"replies":[{"id":"2392","content":"Thtead 一个UnCaughtExceptionHandler","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525962407,"ip_address":"","comment_id":8148,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23000763458","product_id":100006701,"comment_content":"大佬能介绍下，线程间调用导致异常信息丢失的问题吗","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417597,"discussion_content":"Thtead 一个UnCaughtExceptionHandler","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525962407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182509,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/2d/4a6d7d41.jpg","nickname":"道法自然","note":"","ucode":"F88FBFB34EE764","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1921,"discussion_content":"老师能否介绍下线程池的异常处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563097154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7937,"user_name":"王宁","can_delete":false,"product_type":"c1","uid":1048061,"ip_address":"","ucode":"4E6258270B7BE9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/fd/1e3d14ee.jpg","comment_is_top":false,"comment_ctime":1525789825,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"23000626305","product_id":100006701,"comment_content":"个人想的有三步:<br>1，完善的异常记录。包括调用的上下文信息，如果在同一个进程内考虑ThreadLocal传递参数。如果分布式，把核心的参数封装传递。<br>2，在基础1之上构建traceid之类的调用链跟踪。<br>3，基于回调机制，发生异常时以事件的方式通知调用方。<br><br>另 对学习的的结果做个小总结。首先二者继承体系的异同。设计里面也不同，error一般表示不可自主从异常中恢复，Exception意味着可能可以恢复。其中Exception分为两类检查异常，非检查异常。<br>最佳实践，try中的代码块不宜过长，捕获时不宜大而全，finally里只释放资源不要有业务逻辑，尤其是修改返回值。用新语法可增强代码的可读性和简洁性。<br>业务异常可继承runntimeexception，封装applicationexception.<br>finally中的代码始终是执行的，用途为清理资源。<br>对于线程池注意runntimeexception导致的线程逃逸现象。<br><br>","like_count":5,"discussions":[{"author":{"id":1176620,"avatar":"","nickname":"正义的伙伴","note":"","ucode":"D8247A99BEBD81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174511,"discussion_content":"只用threadLocal有问题的，如果把任务扔到线程池里，如果把traceId带过去？以前面试遇到过这个问题，没回答上来，很难受。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581924042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1630243,"avatar":"https://static001.geekbang.org/account/avatar/00/18/e0/23/03d664fc.jpg","nickname":"MEGAMETAL","note":"","ucode":"122AAEC40E1A60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176620,"avatar":"","nickname":"正义的伙伴","note":"","ucode":"D8247A99BEBD81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573041,"discussion_content":"transmitable thread local","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653159460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174511,"ip_address":""},"score":573041,"extra":""}]}]},{"had_liked":false,"id":7844,"user_name":"风动静泉","can_delete":false,"product_type":"c1","uid":1113190,"ip_address":"","ucode":"34DEF4FF06A491","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/66/d7f7ad77.jpg","comment_is_top":false,"comment_ctime":1525743518,"is_pvip":false,"replies":[{"id":"2252","content":"没错，看描述的角度和范围，不然让人晕了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525747903,"ip_address":"","comment_id":7844,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23000579998","product_id":100006701,"comment_content":"&quot;Exception 又分为可检查（checked）异常和不检查（unchecked）异常&quot;这句话本身没问题，但是不够全面吧。查了下&lt;&lt;JAVA核心技术 卷Ⅰ&gt;&gt; 第9版，pp.474  &quot;JAVA语言规范将派生于Error类或RuntimeException类的所有异常称为未检查(unchecked)异常，所有其他的异常称为已检查(checked)异常。&quot;","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417491,"discussion_content":"没错，看描述的角度和范围，不然让人晕了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525747903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325777,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/1a4orZQgenzVuicWSGSZRsN8EVHbaQk3VmnVdSvDLtBZLLY9iaNSVH2Z3gfZ2oHMpJAEpgcING6z08urrkLeJ9rw/132","nickname":"Geek_02e28e","note":"","ucode":"170B5F9B1B8358","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323358,"discussion_content":"自定义的检查型异常如果是继承自RuntimeException，那还算检查型异常吗？这个所谓的首席工程师讲的真是一般啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604921880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19440,"user_name":"繁华～","can_delete":false,"product_type":"c1","uid":1205169,"ip_address":"","ucode":"3E4D98F994E987","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/b1/7ea675e8.jpg","comment_is_top":false,"comment_ctime":1533828700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18713697884","product_id":100006701,"comment_content":"既然说try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if&#47;else、switch）要低效。<br>那我看到spring social代码，好多地方判断空不是用的if else，而是直接使用try catch ，是不是不合理的？","like_count":4},{"had_liked":false,"id":8027,"user_name":"暴走的🐌","can_delete":false,"product_type":"c1","uid":1033630,"ip_address":"","ucode":"804381D877E53C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/9e/d6fce09c.jpg","comment_is_top":false,"comment_ctime":1525864932,"is_pvip":false,"replies":[{"id":"2338","content":"我在文章里提到了,不建议以异常控制业务流程","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525878503,"ip_address":"","comment_id":8027,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18705734116","product_id":100006701,"comment_content":"业务规则检验是抛异常好还是if return好","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417553,"discussion_content":"我在文章里提到了,不建议以异常控制业务流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525878503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716617,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","nickname":"Geek_498c16","note":"","ucode":"616913785EFF06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168745,"discussion_content":"但是看作者文中给出的检验filename是否为空就是用的异常而不是if","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581593606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716617,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","nickname":"Geek_498c16","note":"","ucode":"616913785EFF06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168748,"discussion_content":"这里是否和这里说的相冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581593637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7876,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1525755218,"is_pvip":true,"replies":[{"id":"2275","content":"嗯，算是切面编程典型场景","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525774916,"ip_address":"","comment_id":7876,"utype":1}],"discussion_count":1,"race_medal":1,"score":"18705624402","product_id":100006701,"comment_content":"关于捕获全局异常，可以考虑使用AOP技术在接口入口层统一捕获，特别是使用类似dubbo这样的非springmvc架构的系统非常有用","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417503,"discussion_content":"嗯，算是切面编程典型场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525774916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220883,"user_name":"逍遥","can_delete":false,"product_type":"c1","uid":2011492,"ip_address":"","ucode":"EDC322BAB83D67","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b1/64/5570b054.jpg","comment_is_top":false,"comment_ctime":1590333663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14475235551","product_id":100006701,"comment_content":"对于 try early catch late 我在 stack 上找到了一个比较恰当的解释<br>你希望今早的抛出异常，因为他可以使我们更轻松的找到异常产生的原因。以一个因为某些参数而失败的方法为例。如果你在方法开始的时候就检验方法参数失败，你就立即知道错误发生在调用（方法的）代码中。如果等到需要参数时代码停止运行，你就不得不跟踪执行代码，以探查错误是否出现在调用方法的代码中（错误参数）或者是由于方法的其他问题导致的。越早抛出异常，你就越可能的接近bug产生的根本原因，也就越容易找到问题出在了哪里。<br>\t在高层抛出异常的原因是在低层开发代码时，你并不知道如何适当的处理该异常。事实上，根据调用方法的代码的不同将有多种合适的方法处理相同的异常。以打开文件举例。如果你想要打开一个配置文件，然而这个文件并不存在（或者没找到），忽略异常并继续使用默认配置可能是一个合适的办法。如果你打开的是一个对程序执行至关重要的私人文件，但不知何故丢失了，你唯一的选择可能是关闭程序。<br>\t用正确的类型包装异常是一个纯粹的正交关系。<br>原文网址：https:&#47;&#47;softwareengineering.stackexchange.com&#47;questions&#47;231057&#47;exceptions-why-throw-early-why-catch-late<br>原文：You want to throw an exception as soon as possible because that makes it easier to find the cause. For example, consider a method that could fail with certain arguments. If you validate the arguments and fail at the very beginning of the method, you immediately know the error is in the calling code. If you wait until the arguments are needed before failing, you have to follow the execution and figure out if the bug is in the calling code (bad argument) or the method has a bug. The earlier you throw the exception, the closer it is to its underlying cause and the easier it is to figure out where things went wrong.<br><br>The reason exceptions are handled at higher levels is because the lower levels don&#39;t know what&#39;s the appropriate course of action to handle the error. In fact, there could be multiple appropriate ways to handle the same error depending on what the calling code is. Take opening a file for example. If you&#39;re trying to open a config file and it&#39;s not there, ignoring the exception and proceeding with the default configuration can be an appropriate response. If you&#39;re opening a private file that&#39;s vital to the program&#39;s execution and it&#39;s somehow missing, your only option is probably to close the program.<br><br>Wrapping the exceptions in the right types is a purely orthogonal concern.<br>","like_count":4},{"had_liked":false,"id":9352,"user_name":"周红阳","can_delete":false,"product_type":"c1","uid":1118378,"ip_address":"","ucode":"3A515AE59BE926","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/aa/0b0ec8a9.jpg","comment_is_top":false,"comment_ctime":1526811227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14411713115","product_id":100006701,"comment_content":"使用Exception的性能问题是两个方面:  1. 创建exception,尤其是fillInStackTrace开销巨大; 2. 部分编译器优化策越不能使用. 第一个问题解决方法有2个: 1, cache exception,(或者Exception设计为单例) . 他的问题是stackTrace打出来是错误的.  2, 禁止掉fillInStackTrace操作,问题是stackTrace完全没有了,不方便定位问题. 可以在系统上线稳定后,使用者这个办法. 第二个问题可以忽略, 可读性好,维护性好的代码比性能重要很多.\r<br>\r<br>try catch NullPointerException和使用if(ref!=null), 使用exception只有exception实际发生的时候才会有问题一的性能问题; 但是这个if判断每次都要执行. 异常情况毕竟是极少数. 平衡性能问题也要考虑到. 而且并不是每个代码都有编译器优化\r<br>\r<br>我认为: exception写的代码更简洁,逻辑更清晰,我喜欢用.","like_count":4},{"had_liked":false,"id":7956,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1525821108,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14410722996","product_id":100006701,"comment_content":"executor 出来的异常和外层逻辑的的关联信息可以考虑实例化线程池时候自定义threadfactory保留一部分，比如线程名称前缀在日志里就蛮有用的，而且扩展这个factry还有一个有用的地方在于可以处理那些未补货的异常，比如调用的底层代码的运行时异常，老师讲到的那个被很多框架尊崇的一切都该是运行时异常的哲学往往会让人多线程时候在这个点崴脚，不过呢，这里也有一大招，就是可以“深思熟虑”一下，考虑使用个反模式，Runnable时候try一个大的throwable，然后catch里面记个log来避免这种意外中异常被吞的情况，坏处是老师课程里提到的执行效率的代价，而且直接和工作代码耦合，当然也可以中间加一个油漆工模式隔离下这个try块，但就没了这个反模式的唯一好处：仅看run方法上下文就知道这东西是不是已经处理了，之所以这里可以考虑违反通常对异常的最佳实践，主要是要看你处理的问题规模和粒度，这会影响最终你测量出来的性能的差异是不是足够明显，和让你团队中绝大多数人快速理解排查问题哪一个你更在意，本质上看，如果是团队开发，应该有一致的风格，我倾向于前者，因为这个问题完全可以结合代码审查和静态代码检查工具来做，形成一个统一的团队的代码风格，如果自己干私活…一般可能就不用java了哈","like_count":3},{"had_liked":false,"id":7952,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1525799310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14410701198","product_id":100006701,"comment_content":"关于检查型异常，因为要强制捕获或者在函数签名声明，导致要写好多的代码。现在都改为用运行时异常，根据业务定义好编码和消息，然后通过全局的异常处理器处理。一些特殊的需要携带更多信息的异常，会自定义异常类，当然它也是运行时异常。","like_count":3},{"had_liked":false,"id":7889,"user_name":"张世杰","can_delete":false,"product_type":"c1","uid":1113765,"ip_address":"","ucode":"FA87192960AEA8","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/a5/71dd98d6.jpg","comment_is_top":false,"comment_ctime":1525761581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14410663469","product_id":100006701,"comment_content":"老师总结的类图，对理解Throwable,Exception,Error非常的直观！但再说掌握的两个方面，第二方面时候，仅仅提到懂得如何处理典型场景！如果能详细描述一下什么样的典型场景，会对深入理解，使用Exception,Error非常有帮助！","like_count":3},{"had_liked":false,"id":79332,"user_name":"请叫我华仔","can_delete":false,"product_type":"c1","uid":1465300,"ip_address":"","ucode":"307D39B12CEF61","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/d4/f4a2888a.jpg","comment_is_top":false,"comment_ctime":1553436541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10143371133","product_id":100006701,"comment_content":"NoClassDefFoundError是在编译时依赖的类在运行时找不到了，一般是缺少依赖的jar包导致的。编译好的class文件中已经引用了这个类，虚拟机无法继续往下运行，所以这是一个ERROR<br>ClassNotFoundException是在classpath下找不到这个类，编译时不依赖，运行时尝试去加载，找不到的话程序可以进行处理，是一个Exception。<br><br>异常处理的基本原则是throw early，catch late。<br><br>Checked Exception设计的初衷是要让程序去处理异常，从异常恢复。但是实际情况是大部分情况下都不可能恢复，已经偏离了初衷。另外，在函数式编程中，如果用了检查异常，则需要在用lambda表达式的地方都声明异常，与lambda表达式使程序简洁的目的违背。所以spring等框架不采用Checked Exception，异常都设计为运行时异常。","like_count":2},{"had_liked":false,"id":68132,"user_name":"刘冬","can_delete":false,"product_type":"c1","uid":1401797,"ip_address":"","ucode":"982676C96C0EB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/63/c5/a85ade71.jpg","comment_is_top":false,"comment_ctime":1550431991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10140366583","product_id":100006701,"comment_content":"我个人也是对开头那个 classnotfoundexception v.s. noclassdeffounderror 的问题很感兴趣，在网上找到一个高赞的答案：https:&#47;&#47;dzone.com&#47;articles&#47;java-classnotfoundexception-vs-noclassdeffounderro，请老师帮忙看看理解是否正确。<br><br>简单的说：<br>classnotfoundexception 是个 runtime exception，主要发生在反射或者loadclass()时，在classpath中找不到指定的class name。一个常见的情况就是没有更新引入Jar包。不过我个人感觉使用IntelliJ这类IDE，几乎不会发生这种问题了。<br>noclassdeffounderror 是个 error，所以通常不去catch，而是直接throws。这个error的定义就是 compile时有class的定义，但是runtime找不到了，比如说某个class被误删除了。这种错误有可能是项目中的操作配置不当造成的。","like_count":2},{"had_liked":false,"id":62441,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1548058840,"is_pvip":false,"replies":[{"id":"23354","content":"看具体是什么信息，以及对安全性的要求了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549819721,"ip_address":"","comment_id":62441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10137993432","product_id":100006701,"comment_content":"用户数据一般不输入到日志中,那么不能记录接口的请求参数了?","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437215,"discussion_content":"看具体是什么信息，以及对安全性的要求了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549819721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61057,"user_name":"感动超人","can_delete":false,"product_type":"c1","uid":1245294,"ip_address":"","ucode":"DDBFE64A9DB28D","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/6e/11362a1e.jpg","comment_is_top":false,"comment_ctime":1547609503,"is_pvip":false,"replies":[{"id":"23331","content":"对，看来确实有必要具体介绍一下这个老问题，我回头有空专门补充一篇详细的介绍，简单说 NoClassDefFoundError是隐式加载出错，是个link error；ClassNotFoundException是动态（显式）加载异常","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549814269,"ip_address":"","comment_id":61057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10137544095","product_id":100006701,"comment_content":"我看第一条和第二条留言的疑问<br>java的动态加载和反射<br>Reflection 是 Java被视为动态（或准动态）语言的一个关键性质<br>动态加载是java运行期的时候再去加载类,不同于静态加载时编译期获得类的属性与方法,<br>动态加载通过反射来获取类内部的属性和方法","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436726,"discussion_content":"对，看来确实有必要具体介绍一下这个老问题，我回头有空专门补充一篇详细的介绍，简单说 NoClassDefFoundError是隐式加载出错，是个link error；ClassNotFoundException是动态（显式）加载异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549814269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16156,"user_name":"Dean","can_delete":false,"product_type":"c1","uid":1178744,"ip_address":"","ucode":"23B6BE5CAEE11C","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/78/ef1cb09c.jpg","comment_is_top":false,"comment_ctime":1531803161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10121737753","product_id":100006701,"comment_content":"在使用RxJava或者有重试机制的框架时，许多调用是通过线程池方式运行，那么这时的异常只能由当前执行线程捕获，可以通过写日志的方式记录，并通过traceid与主线程关联，当然traceid的传递也是需要格外注意的。","like_count":2},{"had_liked":false,"id":10170,"user_name":"徐金铎","can_delete":false,"product_type":"c1","uid":1080462,"ip_address":"","ucode":"E13FD19FD27869","user_header":"https://static001.geekbang.org/account/avatar/00/10/7c/8e/73581062.jpg","comment_is_top":false,"comment_ctime":1527320685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10117255277","product_id":100006701,"comment_content":"从架构，或者不同模块的角度，推荐大家注意一个点，一般类似mybatis这类的框架，都会有关于exception的converter，比如mybatis会先封装mysqlexception，然后是自己的，再封装向上是spring的exception。类似的思想在微服务调用链路也有体现，上游服务对下游服务的error解析convert，是可以加强代码健壮性的。","like_count":2},{"had_liked":false,"id":8776,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1132478,"ip_address":"","ucode":"F7E4F39FA18CA8","user_header":"http://thirdwx.qlogo.cn/mmopen/2kpMNDYsSfCibibkl1x62jWvwQVpWqT54wibNoNOtlncnZ9icRv3Ol8lUHO0cmmYDNp2E4gyFbiajicy67qwv372x1YHVMPUGyLRUy/132","comment_is_top":false,"comment_ctime":1526431792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10116366384","product_id":100006701,"comment_content":"如果业务中有一个段业务逻辑抛出异常，不能影响后面的业务逻辑的处理，如果不用try catch 吃掉异常，还有什么好的办法处理呢？","like_count":2},{"had_liked":false,"id":7983,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1525830065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10115764657","product_id":100006701,"comment_content":"1，无论各种异常均可以看成线程无法继续执行的信号(引发线程中断)。是否恢复执行由用户决定。信号的重要程度构成了 Throwable 的继承层级。<br>2，既然是线程无法继续执行就需要打印线程的执行状况。以便分析。<br>3，既然是线程中断，就可以跨调用 catch 与throw 而不用像 c 等过程语言要判断每个函数的返回。方便统一 catch 处理。<br>不足之处望指出。","like_count":3},{"had_liked":false,"id":7864,"user_name":"dingsai88","can_delete":false,"product_type":"c1","uid":1029484,"ip_address":"","ucode":"A725428A983ADC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/6c/617c0193.jpg","comment_is_top":false,"comment_ctime":1525750984,"is_pvip":false,"replies":[{"id":"2269","content":"感谢认可，很高兴对大家有帮助","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525759562,"ip_address":"","comment_id":7864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10115685576","product_id":100006701,"comment_content":"物超所值啊  买的很对","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417501,"discussion_content":"感谢认可，很高兴对大家有帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525759562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7824,"user_name":"BUGS","can_delete":false,"product_type":"c1","uid":1119631,"ip_address":"","ucode":"40E63F005E9504","user_header":"","comment_is_top":false,"comment_ctime":1525741288,"is_pvip":false,"replies":[{"id":"2262","content":"有帮助","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525752874,"ip_address":"","comment_id":7824,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10115675880","product_id":100006701,"comment_content":"Spring cloud sleuth不知道是否可以解决调用跟踪问题（包括异常？）","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417484,"discussion_content":"有帮助","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525752874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7822,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1525741144,"is_pvip":false,"replies":[{"id":"2265","content":"都抓起来是担心RuntimeException吗？即使抓起来，业务逻辑怎么走下去呢？<br>对于日志，实用主义也不错啊","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525753374,"ip_address":"","comment_id":7822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10115675736","product_id":100006701,"comment_content":"首先说说异常，虽然所有人都不建议一个大try-catch包住整个方法捕获exception，但我还是不放心啊，怎么破？我的做法是对小的代码段try-catch捕获指定的异常，然后在最外面套一个大的try-catch防止遗漏的情况，不知道这样做算不算一个折衷的办法，希望晓峰老师和其他同学多多指教。<br><br>响应式编程接触比较少，没什么经验，笨办法还是有。异常还是那些异常，如果把握不好捕获的位置和方法，不妨前期多加一些日志，把关键参数输出出来，从错误中反向总结异常处理方式。","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417482,"discussion_content":"都抓起来是担心RuntimeException吗？即使抓起来，业务逻辑怎么走下去呢？\n对于日志，实用主义也不错啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525753374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295921,"user_name":"时光守护者-基兰","can_delete":false,"product_type":"c1","uid":1554995,"ip_address":"","ucode":"F0B0887B1979D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","comment_is_top":false,"comment_ctime":1622642088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5917609384","product_id":100006701,"comment_content":"这个ClassNotFoundException和NoClassDefFoundError讲的不错<br>https:&#47;&#47;dzone.com&#47;articles&#47;java-classnotfoundexception-vs-noclassdeffounderro","like_count":1},{"had_liked":false,"id":228394,"user_name":"陈狄","can_delete":false,"product_type":"c1","uid":2011954,"ip_address":"","ucode":"456F00EB2EB43D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg","comment_is_top":false,"comment_ctime":1592656533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887623829","product_id":100006701,"comment_content":"1、NoClassDefFoundError是编译期没问题，但是运行期找不到类。2、ClassNotFoundException是类加载器加载类的时候找不到类，比如说调用Class.forName()时找不到类<br>3、throw关键字是往外抛一个异常<br>4、throws关键字是函数声明要抛出哪些异常，是调用函数的调用者来抛出<br>","like_count":1},{"had_liked":false,"id":119390,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1564576864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859544160","product_id":100006701,"comment_content":"类似 React 这种反应式，我猜其实就像 API 一样，不能抛异常，否则调用者拿不到结果。所以需要捕获到，通过封装成错误异步返回。","like_count":1},{"had_liked":false,"id":94448,"user_name":"南瓜","can_delete":false,"product_type":"c1","uid":1500785,"ip_address":"","ucode":"A3828CEC6257CC","user_header":"https://static001.geekbang.org/account/avatar/00/16/e6/71/491dcad1.jpg","comment_is_top":false,"comment_ctime":1557815236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852782532","product_id":100006701,"comment_content":"try-catch为何会产生额外的性能开销呢？为何会影响到jvm对代码的优化呢？","like_count":1},{"had_liked":false,"id":70587,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1551144318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846111614","product_id":100006701,"comment_content":"学习了Exception和Error，写下总结和感想，杨老师有空帮忙看下哦<br>1、Exception 和 Error 都是继承了 Throwable, Exception表示异常，可以被捕获，Error表示错误，除非有好的处理方法，不然不对其进行捕获处理，RunntimeException和CheckException是Exception的子类，RunntimeException表示运行时异常，也称非检查异常，可以通过编码进行避免，可以选择进行try catch，如果在自己的方法上throws抛出运行时异常，和没有抛出是一样的，CheckException检查型异常，如果调用jdk api，比如文件抛出IoException,需要我们调用程序进行捕获，不然编译不通过，除非有做一些重试或者日志记录，不然感觉checkException可以用RunntimeException来代替，因为捕获checkException也对其处理不了，恢复不了，感觉可以在内部不用对其异常进行处理，比如需要和前端交互，需要提示信息，可以做个全局的异常处理，如果是内部程序的问题，抛出系统异常，如果是用户操作非法可以提示其信息。<br>2、掌握那些异常的分类，那些是Error，那些是RunntimeException和CheckException，掌握自定义异常（注意①判断是否需要自定义成checkException②提供足够的信息，但是不暴露出内部的敏感信息，比如用户信息，也需防止将用户信息记录在日志中）<br>3、注意事项：①Throw early catch late②尽量不要捕获类似 Exception 这样的通用异常，而是应捕获特定异常③不要生吞异常④生产环境避免使用printStackTrace()④避免使用try catch做流程跳转⑤Java 每实例化一个 Exception，都会对当时的栈进行快照，比较重的操作。<br>4、优化思路，如果后台缓慢，查看是否使用try catch进行流程跳转，或者查看那个频繁异常被创建","like_count":1},{"had_liked":false,"id":64057,"user_name":"消失的子弹","can_delete":false,"product_type":"c1","uid":1001321,"ip_address":"","ucode":"3AE1A89D1AE940","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/69/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1548652125,"is_pvip":false,"replies":[{"id":"23345","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549818093,"ip_address":"","comment_id":64057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843619421","product_id":100006701,"comment_content":"总结：<br>1 不要直接catch exception，要补获具体异常<br>2 不要大段代码catch，实例化异常时会对内存做快照，所以增大了快照开销，应该尽量小颗粒度补获异常<br>3 性能优化时异常处理也是一个重要关注点","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437835,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549818093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57863,"user_name":"xxl","can_delete":false,"product_type":"c1","uid":1211090,"ip_address":"","ucode":"7B09DE985E5B24","user_header":"https://static001.geekbang.org/account/avatar/00/12/7a/d2/26575723.jpg","comment_is_top":false,"comment_ctime":1546931684,"is_pvip":false,"replies":[{"id":"23317","content":"请看Shipilev的分析吧：<br>https:&#47;&#47;shipilev.net&#47;blog&#47;2014&#47;exceptional-performance&#47;","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549807240,"ip_address":"","comment_id":57863,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841898980","product_id":100006701,"comment_content":"文中并未明确说异常对性能的影响，看了Throwal中的方法并未提及性能问题，有具体的抛出异常情况与通过返回码返回方式性能差异对比吗？<br>fillInStackTrace<br><br>public Throwable fillInStackTrace()<br><br>Fills in the execution stack trace. This method records within this Throwable object information about the current state of the stack frames for the current thread.<br><br>If the stack trace of this Throwable is not writable, calling this method has no effect.<br><br>Returns:a reference to this Throwable instance.See Also:printStackTrace()","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435798,"discussion_content":"请看Shipilev的分析吧：\nhttps://shipilev.net/blog/2014/exceptional-performance/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549807240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56256,"user_name":"李政勇","can_delete":false,"product_type":"c1","uid":1355126,"ip_address":"","ucode":"2BBD3A787C1B93","user_header":"https://static001.geekbang.org/account/avatar/00/14/ad/76/5fb160ec.jpg","comment_is_top":false,"comment_ctime":1546412284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5841379580","product_id":100006701,"comment_content":"老师讲的很不错，起码不用简单的浮于表面 ，我想能买即刻时间课程的，大多数都脱离了什么是error ，什么是异常的阶段的 ，能在这些基础上讲点干货，我个人觉得就比在慕课网那些糊弄不会编程的消费者的强 。","like_count":1},{"had_liked":false,"id":45939,"user_name":"Loong","can_delete":false,"product_type":"c1","uid":1170296,"ip_address":"","ucode":"3B96FC58C9612C","user_header":"","comment_is_top":false,"comment_ctime":1543822938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838790234","product_id":100006701,"comment_content":"Throwable - 在 Java 中只有 Throwable 类型的实例才可以被抛出或者捕获，它是异常处理机制的基本组成类型。<br>\t<br>    1. Exception<br>\t 程序正常运行中，可以预料的意外情况，应该被捕获进行相应处理<br>\t\t可检查异常 IOException<br>\t\t 可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分<br>\t\t不检查异常 - 运行时异常<br>    2. Error 非正常的、不可恢复状态 OOM &#47; StackOverflowError 等<br>\t<br>    3. 异常实践<br>\t\t- try - catch - finally，finally 中关闭 AutoCloseable 或者 Closeable 的对象<br>\t\t- 不要捕获 Exception ，而要捕获特定异常<br>\t\t- 不要生吞异常，catch 到异常后要不就向上抛出要不就添加输出到日志等操作<br>\t\t- 异常内容不要包含敏感信息<br>\t\t- try-catch 有性能开销，只包住必要代码","like_count":1},{"had_liked":false,"id":19163,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1533692814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828660110","product_id":100006701,"comment_content":"受教了，我就是那种直接捕获所有异常的小白🙃，以后坚决改正！","like_count":1},{"had_liked":false,"id":16028,"user_name":"Patrick","can_delete":false,"product_type":"c1","uid":1081590,"ip_address":"","ucode":"0821DD65A26FD2","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/f6/24a3e582.jpg","comment_is_top":false,"comment_ctime":1531747371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5826714667","product_id":100006701,"comment_content":"老师可不可以做个Github repo 把样例代码可以让大家动动手，谢谢老师的课","like_count":1},{"had_liked":false,"id":14041,"user_name":"ZK","can_delete":false,"product_type":"c1","uid":1064852,"ip_address":"","ucode":"62263E52E86151","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/94/f4c36128.jpg","comment_is_top":false,"comment_ctime":1530150623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5825117919","product_id":100006701,"comment_content":"我就想问，很多程序包括开源的都是比如参数错误，参数非法 类型错误，不进行判断，直接throw出来异常在外层进行捕获异常后整体返回出去，肯定对性能有影响吧？那么为什么很多还这样做呢？如何取舍？或者优化？","like_count":1},{"had_liked":false,"id":13497,"user_name":"張煥旭","can_delete":false,"product_type":"c1","uid":1161975,"ip_address":"","ucode":"8D01E2FEAF0C99","user_header":"https://static001.geekbang.org/account/avatar/00/11/ba/f7/173efc45.jpg","comment_is_top":false,"comment_ctime":1529680259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5824647555","product_id":100006701,"comment_content":"try catch块真的会影响性能吗？我记得java编程思想里面提到并不会影响性能，请尽情使用","like_count":1},{"had_liked":false,"id":9275,"user_name":"马婷婷","can_delete":false,"product_type":"c1","uid":1128683,"ip_address":"","ucode":"5D7E6265759A4D","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/eb/1c34a31e.jpg","comment_is_top":false,"comment_ctime":1526722018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5821689314","product_id":100006701,"comment_content":"NoClassDefFoundError 和 ClassNotFoundException 有什么区别<br><br>前者是找不到类的定义，类文件还在；后者是找不到class文件；前者可能是在类初始化的时候（比如初始化某个变量报错）发生异常；后者可能是找不到引用的类文件，可能是某个包没有导入.前者是运行时异常，后者是可检查异常","like_count":1},{"had_liked":false,"id":8295,"user_name":"sonnyfu","can_delete":false,"product_type":"c1","uid":1124795,"ip_address":"","ucode":"8E843CE6FA207B","user_header":"https://wx.qlogo.cn/mmopen/vi_32/KJUOWgZ6tc7j6s3ofibT3WvHH0XhnZB69uT4YNZ3QKC0x2ooSLT2RC59ocp6EHW922ViaW5KlJWuRIfwkqLVRMMw/132","comment_is_top":false,"comment_ctime":1526058071,"is_pvip":false,"replies":[{"id":"2449","content":"请问抓住OOM，写什么代码处理，如果内存已经over commit，怎么保证后续逻辑可靠性，不是做不到，不大容易","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526103199,"ip_address":"","comment_id":8295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5821025367","product_id":100006701,"comment_content":"捕获了throw或error，为啥就难以保证我们能够正确程序处理 OutOfMemoryError？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417656,"discussion_content":"请问抓住OOM，写什么代码处理，如果内存已经over commit，怎么保证后续逻辑可靠性，不是做不到，不大容易","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526103199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7929,"user_name":"VincentWei","can_delete":false,"product_type":"c1","uid":1070128,"ip_address":"","ucode":"BFF589C9A4E530","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/30/867ce6a6.jpg","comment_is_top":false,"comment_ctime":1525784973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5820752269","product_id":100006701,"comment_content":"链路追踪","like_count":1},{"had_liked":false,"id":7801,"user_name":"YANGFEI","can_delete":false,"product_type":"c1","uid":1001995,"ip_address":"","ucode":"38477A7CFD3EF4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/0b/093f7d9e.jpg","comment_is_top":false,"comment_ctime":1525739391,"is_pvip":false,"replies":[{"id":"2267","content":"比如，写段lambda的程序试试，调用一个抛出检查异常的方法，现在语言层面并没有流畅处理的机制，往往需要自定义functional interface","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525754002,"ip_address":"","comment_id":7801,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5820706687","product_id":100006701,"comment_content":"Checked Exception 不兼容 functional 编程，如果你写过 Lambda&#47;Stream 代码，相信深有体会。这段话可以详细剖析下吗？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417477,"discussion_content":"比如，写段lambda的程序试试，调用一个抛出检查异常的方法，现在语言层面并没有流畅处理的机制，往往需要自定义functional interface","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525754002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350818,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1657241140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657241140","product_id":100006701,"comment_content":"有一次我面试别人：请问怎么定义一个受检查异常？冷场了。。。","like_count":0},{"had_liked":false,"id":318613,"user_name":"偷鱼的喵大仙","can_delete":false,"product_type":"c1","uid":1514277,"ip_address":"","ucode":"640A04F8CCB567","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/25/f22d26a6.jpg","comment_is_top":false,"comment_ctime":1635348568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635348568","product_id":100006701,"comment_content":"以前没有很认真思考过异常处理的问题，就知道编译的时候Error异常解决掉，业务逻辑代码编写的时候搞一个大大的try catch，然后捕获出现概率最大的Exception异常，再把e.getMessage抛出给上层😂<br><br>通过本节的学习，以后可能会对异常处理更谨慎一些，例如：<br>1、多关注一下Exception的类型，尽量去把捕获的异常精确一些；<br>2、不去生吞捕获到的异常，尽量抛出来给上层或者做一些记录的操作<br>3、考虑代码可能出现的多种异常，尽早的去处理并抛出异常，避免多种异常重叠造成不必要的麻烦<br><br>我觉得大佬们的评论非常精彩，最后想问一个很不理解的地方，为什么每个公司都喜欢自定义一些异常类，这样做的目的主要是为了什么呢？🤔","like_count":0},{"had_liked":false,"id":317223,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1634716082,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1634716082","product_id":100006701,"comment_content":"对所学进行总结<br><br>一.先对Exception与Error 的区别做出回答 先说总的 在分别展开<br>总<br>\tException与Error都继承Throwable类  而只有Throwable类才可以抛出或捕获异常 <br>分<br>\tExcepiton<br>\t\t程序正常运行 可以预料的意外结果 应该被捕获处理<br>\t\t分<br>\t\t\t可检查异常<br>\t\t\t\t在程序运行中必须捕获或者抛出的<br>\t\t\t非检查异常<br>\t\t\t\t也叫运行时异常<br>\t\t\t\t是在编码中可以避免的逻辑错误 根据需要 不强制捕获处理<br>\tError<br>\t\t非正常情况下导致的情况 不需要被捕获 不可恢复的状态<br><br>二.NoClassDefFoundError 和 ClassNotFoundException 有什么区别？<br><br>前者在编译期存在 运行时找不到了 class文件了 可能是发生了损坏什么的<br>后者是调用class.forName() 路径写错了导致的 属于异常范畴<br><br>三. throw early catch late原则<br>1.如果传入参数为null 会引发npe异常 而在程序中很难明确 所以要先对参数进行校验<br>2.不知道如何处理异常 就将问题提早的抛出来 选择保留原有异常的cause信息 往更高层抛<br><br>四.异常是昂贵的<br><br>1.try-catch会产生额外的性能开销 所以尽量不要一整个try全部包裹 且不要用异常处理流程 性能比if&#47;else差<br>2.每实例化Exception都会对栈进行快照 增加消耗","like_count":0},{"had_liked":false,"id":296312,"user_name":"AAA_叶子","can_delete":false,"product_type":"c1","uid":1325994,"ip_address":"","ucode":"1E93617D308EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/aa/e8dfcd7e.jpg","comment_is_top":false,"comment_ctime":1622895435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622895435","product_id":100006701,"comment_content":"每创建一个Exception实例就要对 堆栈进行一次快照，我发现我接手的前人的代码有很多不校验参数直接操作数据库，出了异常然后catch的操作。","like_count":0},{"had_liked":false,"id":296311,"user_name":"AAA_叶子","can_delete":false,"product_type":"c1","uid":1325994,"ip_address":"","ucode":"1E93617D308EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/aa/e8dfcd7e.jpg","comment_is_top":false,"comment_ctime":1622895196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622895196","product_id":100006701,"comment_content":"这里其实有个高频的面试问题：如何定位线上的oom问题。","like_count":0},{"had_liked":false,"id":292269,"user_name":"Geek_jerry","can_delete":false,"product_type":"c1","uid":1736148,"ip_address":"","ucode":"684923936D7849","user_header":"","comment_is_top":false,"comment_ctime":1620746656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620746656","product_id":100006701,"comment_content":"log4j框架，可以把同一个线程的堆栈信息输入到同一个文件中。不同的线程可以往不同的log文件中输入日志内容。这样就可以把不同线程的堆栈信息隔离开了。","like_count":0},{"had_liked":false,"id":287141,"user_name":"且听风吟","can_delete":false,"product_type":"c1","uid":2291112,"ip_address":"","ucode":"D7E37D0C3CE45D","user_header":"https://static001.geekbang.org/account/avatar/00/22/f5/a8/f10d2446.jpg","comment_is_top":false,"comment_ctime":1617792351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617792351","product_id":100006701,"comment_content":"虽然不了解反应式编程，但看起来异步思想和分布式系统挺像的，针对这类场景的异常处理，我觉得应该需要加入一个类似traceId一样的标识，当输出错误堆栈的时候能通过标识找到各个异步线程的执行堆栈，不能简单的抛出异常，那么也需要类似事务补偿机制一样要对异常线程处理结果进行特定处理","like_count":0},{"had_liked":false,"id":284015,"user_name":"K","can_delete":false,"product_type":"c1","uid":2529222,"ip_address":"","ucode":"029332D154ED2F","user_header":"","comment_is_top":false,"comment_ctime":1616037533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616037533","product_id":100006701,"comment_content":"实用。","like_count":0},{"had_liked":false,"id":281567,"user_name":"早起不吃虫","can_delete":false,"product_type":"c1","uid":1369757,"ip_address":"","ucode":"13CD3B5E1F9435","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7WkTI1IicbKvsPJng5vQh5qlrf1smbfl2zb7icHZfzcAk1k4lr8w8IDEAdrqq1NHW5XZMPXiaa1h7Jn1LGOWOCkIA/132","comment_is_top":false,"comment_ctime":1614792503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614792503","product_id":100006701,"comment_content":"   &#47;**<br>     * 异常处理机制<br>     *  1考察对异常继承树的了解<br>     *      Exception和Error都继承自Throwable类<br>     *      Exception 分为受检异常和非受检异常，也叫运行时异常，Exception可以用try-catch捕获或者throw抛出异常<br>     *          受检异常：例如IOException<br>     *              在代码编译期检查时，受检异常必须被显示的捕获进行处理，或者throws抛出给上层调用方法<br>     *              受检异常的缺点，不能在函数式lamda表达式调用的，内部类中受限<br>     *          非受检异常&#47;运行时异常：例如非法参数异常，空指针异常，数组越界异常<br>     *              一般是可以通过代码修改来避免这类异常，在编译期不强制要求捕获<br>     *      Error是程序上的严重错误，不允许捕获，例如OutOfMemoryError，栈溢出Error<br>     *<br>     *   throws 和 throw 的区别<br>     *      throw是代码中主动抛出一个指定类型类型的异常<br>     *      throws是在方法最后声明，这个方法可能抛出异常，交给上层调用它的方法来处理<br>     *<br>     *   语法<br>     *      try-catch-finally<br>     *<br>     *  2考察对项目中异常处理的规范<br>     *      记录异常日志<br>     *      尽量捕获必要的代码段，不要一整块try<br>     *      不要捕获捕获类似Exception通用异常，应该捕获具体的异常，未知的异常要抛出<br>     *      不要吞掉异常<br>     *      不要直接打印异常堆栈轨迹，输出日志最佳<br>     *<br>     *  3jdk1.7之后的新的异常处理的特性<br>     *      jdk1.7之后可以使用try with resources异常处理机制，如果发生异常，自动关闭异资源<br>     *      语法是<br>     *      try(){}<br>     *          特点：<br>     *          try模块中的资源类，必须实现autoCloseable自动关闭接口的close()方法<br>     *          关闭资源的顺序，是逆序关闭<br>     *     多重catch，之前版本的catch，如果有多种异常，要分别catch<br>     *     throws 可以抛出多种异常，但是不能有多个异常之间不能有继承关系，否则编译不通过<br>     *&#47;","like_count":0},{"had_liked":false,"id":280404,"user_name":"袁军","can_delete":false,"product_type":"c1","uid":2411102,"ip_address":"","ucode":"201E088AE4D271","user_header":"","comment_is_top":false,"comment_ctime":1614179638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614179638","product_id":100006701,"comment_content":"异常结合错误码一起使用，服务接口结果对象标准化，结果对象采用范型包含结果码、结果描述，原始结果码、原始描述，不同的服务错误码唯一前缀，异常和结果码能通用转换。如A—B—C3个服务调用，当C出现异常，抛出的异常里包含错误码信息，异常被捕获后打印错误日志，并将异常中错误码与异常描述转换为标准结果对象中错误码、原始错误码，B收到响应后发现是异常的，可以直接转换为新的异常，新异常中包含新的错误码以及C的原始错误码。原始错误码层层透传，整个调用链路通过如此处理，在任意服务都能第一时间看到原始错误码，识别错误码前缀，快速定位出问题的服务。对于响应式编程也适用，返回应用标准结果对象，定义特定错误码前缀，通过错误码透传原始错误信息。","like_count":0},{"had_liked":false,"id":280021,"user_name":"Thomas Yang","can_delete":false,"product_type":"c1","uid":1612933,"ip_address":"","ucode":"29249144F708D7","user_header":"","comment_is_top":false,"comment_ctime":1614055949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614055949","product_id":100006701,"comment_content":"以前做.net是没有Checked Exception的哈哈，刚转到java的时候还挺懵对这东西，后面做久了发现这东西还是挺好的，最起码某些场景我能强制让调用方处理异常，虽然他也可能瞎处理。。。","like_count":0},{"had_liked":false,"id":268765,"user_name":"acqierement","can_delete":false,"product_type":"c1","uid":1234980,"ip_address":"","ucode":"AC8DA74B9CB924","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/24/f48a38f4.jpg","comment_is_top":false,"comment_ctime":1608343521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608343521","product_id":100006701,"comment_content":"Error：程序运行不太可能会出现，一般是系统错误。常见；OutOfMemoryError,StackOverFlowError<br>Exception:程序运行中可以预料的错误，可以进行捕获并处理。<br>Exception又可以分为受检异常和非受检异常。<br>受检异常：发生在编译期，必须要显示捕获并处理。IOException<br>非受检异常：运行期发生，通常是编码时的逻辑错误，根据需求看是否要捕获。比如：空指针，数组越界。<br>捕获异常时，尽量明确具体是什么异常；处理异常时，要做有意义的事情，一般来说记录日志啥的，方便之后排查问题。","like_count":0},{"had_liked":false,"id":263252,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1606059878,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1606059878","product_id":100006701,"comment_content":"这一篇其实是两道面试题，一个是 Exception 和 Error 的区别，另一个则是 NoClassDefFoundError 和 ClassNotFoundException 的区别。<br><br>我觉的第二个题似乎更好一点，而且更容易形成探讨，顺便也就涵盖的第一题。<br><br>1. 不要捕获通用异常 Exception<br>2. 不要生吞 swallow 异常<br><br>这两个似乎都是像我这样的新手容易犯的错误。<br><br>Throw early, catch later 是第一次听说。<br><br>关于 Checked Exception 的争论之前听到过，本文中的解释让我搞清楚其中的由来。<br><br>留言中，@adrian-jser 提到的“车坏了”的例子，的确形象。","like_count":0},{"had_liked":false,"id":244297,"user_name":"GmDcf","can_delete":false,"product_type":"c1","uid":1128586,"ip_address":"","ucode":"8FFA9A404F4ECC","user_header":"","comment_is_top":false,"comment_ctime":1598452823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598452823","product_id":100006701,"comment_content":"毕业找工作的时候买了这个资源，当时看完感觉很多文章很多段落讲得不好理解，不切实际。<br>等工作了一年，再回来重头看时，以前的不好理解多半是因为自己知道太少，不切实际是因为当时只想应对面试。好多东西工作了一年才发现价值，像用什么串联起分布式系统中的日志的问题。自己还是知道得太少，工作上面还有很多东西要做。","like_count":0},{"had_liked":false,"id":238852,"user_name":"上下求索","can_delete":false,"product_type":"c1","uid":2088785,"ip_address":"","ucode":"02342FB4CC7D03","user_header":"https://static001.geekbang.org/account/avatar/00/1f/df/51/e7312fd7.jpg","comment_is_top":false,"comment_ctime":1596342656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596342656","product_id":100006701,"comment_content":"我来补充一下try  catch  finally一些重要语法：<br>1、finally中的代码总会被执行。<br><br>2、当try、catch中有return时，也会执行finally。return的时候，要注意返回值的类型，是否受到finally中代码的影响。<br><br>3、finally中有return时，会直接在finally中退出，导致try、catch中的return失效。","like_count":0},{"had_liked":false,"id":235651,"user_name":"白菜炒五花肉","can_delete":false,"product_type":"c1","uid":1519828,"ip_address":"","ucode":"0D4CBD221C2880","user_header":"https://static001.geekbang.org/account/avatar/00/17/30/d4/6eb8f5af.jpg","comment_is_top":false,"comment_ctime":1595137329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595137329","product_id":100006701,"comment_content":"Error和Exception都是Throwable的子类，在Java中只有Throwable类才可以被捕获或者抛出。<br>Error是程序正常运行时，不太可能出现的情况，一般会导致程序出现不正常，难以恢复的状态。<br>Exception是程序运行时可以预料的情况，可以被捕获并进行相应处理<br>Exception分为可受查异常和不可受查异常，可受查异常是接受编译期检查，必须显示的进行捕获处理","like_count":0},{"had_liked":false,"id":233541,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1594349998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594349998","product_id":100006701,"comment_content":"ClassNotFoundException和NoClassDefFoundError区别，显示调用Class.forName方法，传入类路径错误的时候，会报ClassNotFoundException，而后者大致能想到是JVM无法找到类的class定义信息。思考题：对于异步编程的异常，使用第三方库或者自定义唯一ID进行追踪","like_count":0},{"had_liked":false,"id":229013,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1592880163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592880163","product_id":100006701,"comment_content":"从性能角度讲，try不要包含一个非常大的代码段。但从方便性上讲，try包含一个大的代码段更方便。比如使用spring boot，用户访问API时，当发生错误，在service层直接throw一个自定义异常，然后让spring捕获并自定义处理逻辑。这样做远比自己在每个API的controller层捕获并处理要简单的多","like_count":0},{"had_liked":false,"id":215059,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588898656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588898656","product_id":100006701,"comment_content":"Throwable是Exception和Error的父类。异常是可以尝试恢复程序到正常状态的，而且有时候捕获后不处理也不影响程序执行，而错误直接就是运行环境出问题了，比如栈溢出，程序再健壮也不行。Exception又分为RuntimeException和IOException等，运行时异常有空指针异常，数组越界异常等，是可以代码修复的。<br>早捕获晚catch，早捕获可以暴露出明确的堆栈信息。<br>异常try太大会影响jvm的优化，new异常时需要快照栈帧的信息，比较影响性能。","like_count":0},{"had_liked":false,"id":213845,"user_name":"陈龙","can_delete":false,"product_type":"c1","uid":1986330,"ip_address":"","ucode":"06544C6A87EE7C","user_header":"","comment_is_top":false,"comment_ctime":1588576067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588576067","product_id":100006701,"comment_content":"看完课程看评论，精华","like_count":0},{"had_liked":false,"id":202509,"user_name":"仲夏夜の夢","can_delete":false,"product_type":"c1","uid":1124842,"ip_address":"","ucode":"45951FCA1D1665","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/ea/b1ef4121.jpg","comment_is_top":false,"comment_ctime":1585998600,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585998600","product_id":100006701,"comment_content":"关于检查异常和非检查异常，运行时异常属于非检查异常，比如数组下标越界异常、空指针异常，一般是由程序逻辑错误引起的，出现运行时异常后如果没有捕获，系统会将异常不断向上抛出，一直到最上层；一般异常包括IOException、SQLException以及用户自定义异常，必须对这些异常进行捕获和处理，否则程序无法编译通过。","like_count":0},{"had_liked":false,"id":198932,"user_name":"rexcai","can_delete":false,"product_type":"c1","uid":1595589,"ip_address":"","ucode":"E3AEB9A6D94EE8","user_header":"https://static001.geekbang.org/account/avatar/00/18/58/c5/433de59b.jpg","comment_is_top":false,"comment_ctime":1585473783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585473783","product_id":100006701,"comment_content":"看完对于异常的讲解，其实和自己在日常工作中的处理大同小异，对于可预见的异常，我们常常是将堆栈打印出来，然后再将异常封装一把，不同业务线不同错误码，封装丢给上层。而对于error级别的，从来都是通过日志监控，告警马上紧急处理，这也是当前没办法的事情。<br>现在业界流行的微服务，对于杨老师最后提出的问题，其实我们工作中的做法就是通过traceID统一跟踪，可以完整地看到整个系统的调用链，分析也就相对清晰了","like_count":0},{"had_liked":false,"id":197422,"user_name":"玩家","can_delete":false,"product_type":"c1","uid":1187094,"ip_address":"","ucode":"75BC2C2B4FC391","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/16/b75d040a.jpg","comment_is_top":false,"comment_ctime":1585376242,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585376242","product_id":100006701,"comment_content":"Error是我们处理不了的，而Exception是可以处理的","like_count":0},{"had_liked":false,"id":196431,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1585280575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585280575","product_id":100006701,"comment_content":"老师说的那个异常时 存快照的问题，大家可以自行去看下 Throwable源码，里面很清晰<br>异常的时候，也就是 实例化 Throwable及其子类对象时，会调用 java.lang.Throwable#fillInStackTrace()方法，这时会存下 中间状态和mark标记 (即 当前线程的栈)，<br>用于 后面 有调用 getInternalStackTrace() 来获取 栈 使用(比如 writeObject()、getStackTrace()、printStackTrace())","like_count":0},{"had_liked":false,"id":196379,"user_name":"luoChao","can_delete":false,"product_type":"c1","uid":1322823,"ip_address":"","ucode":"E8A46B41B3178D","user_header":"https://static001.geekbang.org/account/avatar/00/14/2f/47/eadc8482.jpg","comment_is_top":false,"comment_ctime":1585277104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585277104","product_id":100006701,"comment_content":"自定义异常继承RuntimeException<br>要捕获Exception这样的通用异常，应该捕获特定的异常如自定义异常<br>业务层不需要捕获异常，都抛出去交给controller来进行处理","like_count":0},{"had_liked":false,"id":195274,"user_name":"黄乔鑫","can_delete":false,"product_type":"c1","uid":1863174,"ip_address":"","ucode":"CBD0A8E5E99427","user_header":"https://static001.geekbang.org/account/avatar/00/1c/6e/06/bb43e716.jpg","comment_is_top":false,"comment_ctime":1585152674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585152674","product_id":100006701,"comment_content":"对于异常可以考虑给自己的业务定个基准exception，这样子就可以统一捕捉这个基准exception，用来兜底，防止出错，透传信息给前端","like_count":0},{"had_liked":false,"id":190473,"user_name":"时代先锋","can_delete":false,"product_type":"c1","uid":1856411,"ip_address":"","ucode":"956E3E6A6A4F30","user_header":"https://static001.geekbang.org/account/avatar/00/1c/53/9b/d0a21378.jpg","comment_is_top":false,"comment_ctime":1584663253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584663253","product_id":100006701,"comment_content":"异常处理，是一个程序员需要认真思考的问题","like_count":0},{"had_liked":false,"id":190120,"user_name":"不忘初心","can_delete":false,"product_type":"c1","uid":1015494,"ip_address":"","ucode":"5B5F45564DDBE7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/c6/83684988.jpg","comment_is_top":false,"comment_ctime":1584604484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584604484","product_id":100006701,"comment_content":"java发生异常： Throwable类  stackTrace 这个栈是什么时候赋值的？跟到这没了，jvm处理的?<br>private native Throwable fillInStackTrace(int dummy);","like_count":0},{"had_liked":false,"id":185653,"user_name":"doannado","can_delete":false,"product_type":"c1","uid":1169379,"ip_address":"","ucode":"16CF3E7C2E0827","user_header":"https://static001.geekbang.org/account/avatar/00/11/d7/e3/7e07ae99.jpg","comment_is_top":false,"comment_ctime":1583656304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583656304","product_id":100006701,"comment_content":"20200308 throwable exception error try-with-resources multi-catch","like_count":0},{"had_liked":false,"id":185071,"user_name":"张镇鸿","can_delete":false,"product_type":"c1","uid":1889764,"ip_address":"","ucode":"7648CDED60E718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bca6GH6xIs5DsH4RibBEQh1pZSTkUT4bFP8fkLBC4Jkm6g8VDcOrySNg0icum9pEuUW259vP8Yv7icCW63Ff1J1ag/132","comment_is_top":false,"comment_ctime":1583477173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583477173","product_id":100006701,"comment_content":"3、Exception和Error有什么区别<br>    记录：stackoverflowerror: http:&#47;&#47;www.imooc.com&#47;article&#47;details&#47;id&#47;291031<br>    线程的本地栈内存消耗完，不是创建太多的对象（对象存放在堆，那里消耗完是宝oom），局部变量存放在本地方法栈中，方法调用过多或者无限递归或者本地方法有栈上的分配逻辑（循环依赖也有可能有问题），一个类对当前类实例化并作为该类的实例变量，也是循环。<br>    throw 主动抛出特定异常，需要catch，throws跟在方法后面，抛出所有异常<br>    try-with-resource就是语法糖，会自动关闭而不需要在finally手动关闭<br>    不要捕获Exception通用异常，而是捕获特定异常，比如thread就是InterruptedException，为的是展示更多的信息，主动有目的的捕获异常，比如一些异常捕获到后处理，一些异常就抛出<br>    异常处理要打印，最好就是扔到日志系统去。<br>    <br>    阅读：Exception和error都是继承Throwable类，Exception分为IO异常和runtimeException运行异常，需要去捕获处理，error一般是jvm层面的，比如OutOfMemory。不检查异常也就是运行时异常，比如nullPointerException(NPE)\\ArrayIndexOutOfBoundsException等。逻辑异常。<br>    try catch可以作用于重试机制<br>    NoClassDefFoundError和ClassNotFoundException，前者是error，后者是Exception。<br>ClassNotFoundException 是runtimeException，使用class loader加载类文件的时候，在classpath查找不到类，则会抛出ClassNotFoundException，比如Class.forname()\\ClassLoader.loadClass加载类的时候（反射）。比如JDBC会用Class.forname()加载JDBC的驱动<br>    NoClassDefFoundError是jvm层面，编译时候存在该类，但是运行时找不到该类的定义，比如new一个类的时候。（生成的字节码.class文件丢失），jvm抛出<br>    函数式编程不能捕获异常<br>    性能方面，trycatch不要包一大段，实例化Exception的时候会对栈进行快照，Exception多的话开销大<br>    trycatch finally、return问题， https:&#47;&#47;blog.csdn.net&#47;qq_36262896&#47;article&#47;details&#47;79779953<br>    我们要明确返回值本质是在线程的方法栈中开辟一个空间来存放内容（复制过去），比如return基本数据类型，finally中的改变不会影响，因为返回值占据的内容空间的内容并没有改变，改变的是本地方法的内容，而对已包装类或者对象，由于返回值空间传入的是引用，因此finally改变了，则会导致返回值空间的引用指向的内容该笔那。<br><br>&#47;&#47;断言还是狠好用的<br>Assert.notNull()","like_count":0},{"had_liked":false,"id":178130,"user_name":"Geek_498c16","can_delete":false,"product_type":"c1","uid":1716617,"ip_address":"","ucode":"616913785EFF06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6ibvATzI5FKR6r71GU3CjdlPkZYYSBYBtNibIGENFZDnqajW7LOPKZXUPWSsjt8OiaxTZ0neT8LwQQ/132","comment_is_top":false,"comment_ctime":1581593842,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581593842","product_id":100006701,"comment_content":"<br>public void readPreferences(String filename) {<br>  Objects. requireNonNull(filename);<br>  &#47;&#47;...perform other operations... <br>  InputStream in = new FileInputStream(filename);<br>   &#47;&#47;...read the preferences file...<br>}<br>文中给的代码，为什么不用if来判断filename是否为空。","like_count":0},{"had_liked":false,"id":173349,"user_name":"秋天的铁工匠","can_delete":false,"product_type":"c1","uid":1463114,"ip_address":"","ucode":"47D6F9005C3BE3","user_header":"https://static001.geekbang.org/account/avatar/00/16/53/4a/331d6bce.jpg","comment_is_top":false,"comment_ctime":1579508884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579508884","product_id":100006701,"comment_content":"NoClassDefFoundError和ClassNotFoundException区别:我们经常被java.lang.ClassNotFoundException和java.lang.NoClassDefFoundError这两个错误迷惑不清，尽管他们都与Java classpath有关，但是他们完全不同。NoClassDefFoundError发生在JVM在动态运行时，根据你提供的类名，在classpath中找到对应的类进行加载，但当它找不到这个类时，就发生了java.lang.NoClassDefFoundError的错误，而ClassNotFoundException是在编译的时候在classpath中找不到对应的类而发生的错误。ClassNotFoundException比NoClassDefFoundError容易解决，是因为在编译时我们就知道错误发生，并且完全是由于环境的问题导致。而如果你在J2EE的环境下工作，并且得到NoClassDefFoundError的异常，而且对应的错误的类是确实存在的，这说明这个类对于类加载器来说，可能是不可见的。<br><br>从文章中: 学到以下几点 1.尽量使用框架打印日志，在微服务系统中需要加上服务名称，比如在日志框架Log4j中加上 application的名字，定位到那个服务问题。 2.不要使用e.printStackTrace()方法输出日志，同意在Log4j中可以使用log.info(&quot;错误日志{}&quot;,e.getMessage())获取日志信息。3.try...catch...不要包住整个方法体，在认为有问题的地方添加。提升效率，并且尽量不要捕获类似 Exception 这样的通用异常。","like_count":0},{"had_liked":false,"id":145838,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1572393693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572393693","product_id":100006701,"comment_content":"2 exception和error区别 2.1 Exception和Error类，都继承Throwable类，Java中继承了Throwable类的实例才可以被捕获，Exception用于捕获可预知的异常，Error常见与内存溢出等不可预知的异常，而且会导致整个程序瘫痪。Exception又分为可检查的异常和不可检查的异常，可检查异常在代码必须显示捕获，不可检查异常则不用。2.2 Object 子类 Throwable，Throwable类包含Exception和Error，Exception包含IOException checked<br>异常，和RuntimeException，NullPointerException，ClassCastException等unchecked异常。Error包含NoclassError，RuntimeError，OutofMemoryError，StackOverFlowError。<br>2.3 Exception的几个应用场景 2.21要捕获具体的异常，不用用Exception 2.22 不要吞异常，要记日志，往外抛出 2.23 try late，catch early 像生吞异常属于catch early，2.24 自定义异常，需要考虑敏感信息和是否定义成可检查的异常 2.4 2.41 try catch 有性能开销，会影响JVM对代码进行性能优化，所以仅包括大的代码段，不要包住整段代码，2.42 每实例化一个Exception，都对当时的栈进行快照，比较耗时 ","like_count":0},{"had_liked":false,"id":144155,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571864478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571864478","product_id":100006701,"comment_content":"请问杨老师，在手机开发中，某些用户界面操作会有异常（通常是某些特定的操作系统版本，甚至特定的机型抛出的）。我原来的做法是会捕获所有异常，报个错或者其他恢复，log一下异常，我的考量是简单的用户操作，如果crash了，显然用户体验不好，但捕获所有异常也违背了异常捕获的原则，如果针对每个异常，又怕有疏漏，毕竟手机型号众多，请问杨老师怎样处理这种情况比较好，多谢！","like_count":0},{"had_liked":false,"id":144153,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571863535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571863535","product_id":100006701,"comment_content":"异常是处理偏离主流逻辑的逻辑，异常包含了作者对问题考量的信息。生吞异常不是好习惯。","like_count":0},{"had_liked":false,"id":141570,"user_name":"qiezitx","can_delete":false,"product_type":"c1","uid":1664274,"ip_address":"","ucode":"AEA470E33B4C19","user_header":"https://static001.geekbang.org/account/avatar/00/19/65/12/98fe9d80.jpg","comment_is_top":false,"comment_ctime":1571192706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571192706","product_id":100006701,"comment_content":"对比Exception和Error<br>1、Exception：程序运行时，程序本身可能出现的意外情况。分两种：<br>    * 受检异常：这类异常在代码里必须显示捕获。<br>    * 运行时异常：这类异常在代码不强制要求捕获，通常是编码的逻辑错误。当然，根据需求也可以显示捕获，但一般好像不建议。<br>2、Error：一般预留给JVM使用，指环境不正常了。<br><br>关键如何处理异常：<br>1、理解异常分类<br>2、理解异常处理的语法和实践<br><br>两条基本原则<br>1、尽量不要使用通用（高层次）异常。这样可读性差；并且希望捕获的和不希望捕获的就都包含进来了，这样很难分类处理不同的异常。<br>2、不要生吞异常。<br>另外，《Effective Java》中还有一些指导原则，可这么分：处理异常的原则和设计异常的原则。日常的业务开发，再增加以下感觉就够了：<br>1、不要用异常来做控制流程，条件判断。<br>2、try-catch-finally的相关指导意见。<br>设计异常的话，参考《Effective Java》，主要是考虑：严格分类、谨慎自定义、文档定义。<br><br>NoClassDefFoundError：是错误，指这个类在编译时有，但加载时找不到了。都是JVM内部参与，所以是一种环境出错。<br>ClassNotFoundException：是运行时异常。当Application直接或间接动态加载类时找不到了。","like_count":0},{"had_liked":false,"id":136381,"user_name":"qf年间","can_delete":false,"product_type":"c1","uid":1463023,"ip_address":"","ucode":"AA08AC984637EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLbchZfeEnshPuUwEsQkn1XbWxjs3rRUpSRUxjW4q7rOcrPvXld0IxEZ1jlpEJdklFeEVERJoOfibg/132","comment_is_top":false,"comment_ctime":1569419396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569419396","product_id":100006701,"comment_content":"https:&#47;&#47;dzone.com&#47;articles&#47;java-classnotfoundexception-vs-noclassdeffounderro<br>最简单的ClassNotFoundException例子就是数据库驱动加载，而NoClassDefFoundError这种编译期间可以发现，就好比ide红色下划线报错就是这个原因","like_count":0},{"had_liked":false,"id":128502,"user_name":"陈琪","can_delete":false,"product_type":"c1","uid":1240475,"ip_address":"","ucode":"CE9FB0AF9DAD96","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/9b/9f52a22f.jpg","comment_is_top":false,"comment_ctime":1566891219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566891219","product_id":100006701,"comment_content":"对于本身是异步、基于事件机制的异常处理我的大致想法是1、记录异常日志 2、针对不同的业务设计补偿处理流程<br><br>","like_count":0},{"had_liked":false,"id":121019,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1565050920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565050920","product_id":100006701,"comment_content":"Try-catch最好不要用于大段代码，会影响性能，指的是JVM对代码的编译优化吗？老师","like_count":0},{"had_liked":false,"id":118178,"user_name":"土豆侠Kane","can_delete":false,"product_type":"c1","uid":1301915,"ip_address":"","ucode":"E2BDAF919A7834","user_header":"https://static001.geekbang.org/account/avatar/00/13/dd/9b/c7bfd750.jpg","comment_is_top":false,"comment_ctime":1564283206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564283206","product_id":100006701,"comment_content":"Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。最后一句表达的并不好，读起来很绕口","like_count":0},{"had_liked":false,"id":112061,"user_name":"TANMIYOO","can_delete":false,"product_type":"c1","uid":1375256,"ip_address":"","ucode":"BC3556131D4D61","user_header":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","comment_is_top":false,"comment_ctime":1562662290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562662290","product_id":100006701,"comment_content":"总结：<br>1. NoClassDefFoundError 与 NotFoundClassException 的区别：<br>NoClassDefFoundError是error的子类，发生在编译通过后，在运行时找不到class文件；<br>NotFoundClassException 是检查exception的子类，发生在显示声明某一类路径<br>2.对于异常要注意的点：<br>i. 避免捕获exception，尽量捕获特定异常<br>ii. 避免生吞异常<br>iii. 追从throw early，catch late的原则<br>iv. 自定义异常要考虑注意过滤敏感信息","like_count":0},{"had_liked":false,"id":105809,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":1585942,"ip_address":"","ucode":"B4DC878EFC6D3C","user_header":"https://static001.geekbang.org/account/avatar/00/18/33/16/01b98f1c.jpg","comment_is_top":false,"comment_ctime":1561086283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561086283","product_id":100006701,"comment_content":"异常:可以预料的意外情况，可以被我们操作。 错误:不大可能发生，不可预料，自己处理不了。都是继承throwable 。不要扩大异常捕获范围，不要使用异常进程程序流程控制，异常会保存栈快照，大量异常也会影响程序效率，不要扩大try catch范围。","like_count":0},{"had_liked":false,"id":105093,"user_name":"罗洪州 IT","can_delete":false,"product_type":"c1","uid":1234281,"ip_address":"","ucode":"3688313E7D010A","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/69/d1f2f7c8.jpg","comment_is_top":false,"comment_ctime":1560915111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560915111","product_id":100006701,"comment_content":"ClassNotFoundException异常交给程序员处理，NoClassDefFoundError直接由JVM处理，其他的没什么区别。","like_count":0},{"had_liked":false,"id":100278,"user_name":"ゞ﹏雨天____゛","can_delete":false,"product_type":"c1","uid":1451392,"ip_address":"","ucode":"9639F0340C6C91","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/80/fdd5a88f.jpg","comment_is_top":false,"comment_ctime":1559521261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559521261","product_id":100006701,"comment_content":"看了两篇了，虽然我已经看过JVM知识了，但是，听老师讲的内容，具体是啥，感觉有点懵。","like_count":0},{"had_liked":false,"id":95877,"user_name":"蓝士钦","can_delete":false,"product_type":"c1","uid":1229516,"ip_address":"","ucode":"726EB5C8EF1249","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/cc/ca22bb7c.jpg","comment_is_top":false,"comment_ctime":1558239934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558239934","product_id":100006701,"comment_content":"一课一练：<br>---------------------<br>Exception和Error都继承自Throwable类，只有Throwable类的实例才可以被抛出throw 和捕获 catch。<br>大多数情况下Error是不需要开发人员之间抛出和捕获的，比如OutOfMemoryError错误等，Error一般都来自JVM虚拟机，程序无法从错误中恢复。<br>Exception分为可检查（check）和不检查（uncheck）异常。可检查异常在编译期就要检查，比如进行IO操作时，必须在代码中显示的捕获 IOException等。不检查异常就是在运行时期才可能发生的异常，比如NullPointerException，运行时的异常可以在编码中规范约束，也可以选择抛出异常并处理。大多数情况下推荐在编码中处理可能发生的不检查（uncheck）异常。避免抛出异常导致产生当前的堆栈快照损耗性能。<br>几个规范：<br>1. 尽量不要获取类似 Exception 这样的全局异常<br>2.不要生吞异常，这会造成无法排查问题<br>3.尽早抛出异常，第一时间抛出异常可以快速准确的定位问题，<br>比如Objects.requireNonNull(name,&quot;姓名不能为空&quot;); 如果不尽早对name可能为空进行抛出，在实际运行过程中抛出异常将会产生大量的其他调用信息，为排查问题增加难度。<br><br>疑问：<br>---------------------<br>在日常开发中，Service层对一些业务进行判断，如果不符合业务规则就显示throw抛出自定义的APIException，并携带业务规则提示，在Controller层的调用处使用了 try{ ... }catch(APIException e){ 返回业务异常信息} catch(Exception e){ 返回系统异常信息 }这样的做法是不是合理呢？<br>在大多数业务开发中，异常似乎已经没有必要重试和恢复，而是要返回给调用者出现的异常。<br>另外对待入参校验比如姓名不能为空，也通过自定义APIException包装并抛出，实际上也会产生调用堆栈镜像，导致一些额外的性能损耗吧？是不是不推荐这样的做法呢。","like_count":0},{"had_liked":false,"id":92991,"user_name":"思而学","can_delete":false,"product_type":"c1","uid":1128821,"ip_address":"","ucode":"AFCFFDC78A7266","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iavhNQNYg0tY5DFibJNnOmsUicjQalo90rbic5jricgps1EUeibIb9yhiayicS5QiapicldcXmeDHPDfHX48AYicZ8XQiaS3ag/132","comment_is_top":false,"comment_ctime":1557373906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557373906","product_id":100006701,"comment_content":"本课程的思考<br>出处<br>Exception 和 Error 都是继承至 Throwable ，只有 Throwable 类型的实力才可以被捕获或者抛出。<br>作用<br>在程序运行时，如果程序或者系统出现错误，则会抛出对应的 Exception 或者 Error。<br>体现<br>体现了java平台对不同异常情况的分类。<br>不同<br>Exception 是程序代码在产生的，可以被捕获处理。而 Error 则是系统或者硬件出错产生的错误，是无法被处理的，比如 OOM，ANR。<br>Exception分为可检查异常和未检查异常，可检查异常就是一般异常，未检查异常就是运行时异常，可检查异常在编码阶段就必须进行捕获处理，否则编译不同通过。","like_count":0},{"had_liked":false,"id":91979,"user_name":"PoL","can_delete":false,"product_type":"c1","uid":1416147,"ip_address":"","ucode":"72BA3C2D50D463","user_header":"https://static001.geekbang.org/account/avatar/00/15/9b/d3/41d04923.jpg","comment_is_top":false,"comment_ctime":1557148069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557148069","product_id":100006701,"comment_content":"runtimeException  error  不可检查，程序崩溃，不处理<br>exception   可检查，预处理 ，logger少打印 ，日志 要业务关联trace id","like_count":0},{"had_liked":false,"id":87897,"user_name":"傲娇的小宝","can_delete":false,"product_type":"c1","uid":1493922,"ip_address":"","ucode":"C079B19BCC1B7C","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/a2/5e7c557e.jpg","comment_is_top":false,"comment_ctime":1555746676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555746676","product_id":100006701,"comment_content":"反应式编程是指各类事件的编程开发么？如果是的话，我的理解是：这类的开发，因为方法是固定的，如果没有定义异常，我们无法在方法上抛出，所以需要捕获。可以将一些特定的异常信息带出，比如哪个方法或者参数引起的异常，然后记录到日志中，并且显示的告知客户异常了。","like_count":0},{"had_liked":false,"id":83876,"user_name":"holmesye","can_delete":false,"product_type":"c1","uid":1476994,"ip_address":"","ucode":"2E3B563E1DB362","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWFpNAqenicDLsE1icK3kz13NjZXDLnTOHpCC7CFrkx1Hk7Vq33R16fcViaggfmNVxqqtsQ3MBOOicvA/132","comment_is_top":false,"comment_ctime":1554727782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554727782","product_id":100006701,"comment_content":"反应式编程下的栈输出：<br>栈输出的目的是为了呈现调用关系上下文。<br>由于反应式编程的异步特性，调用关系上下文实际不通过栈对象，而是通过堆对象来承载，所以这种况下异常时可以同时输出堆内存里的上下文信息。","like_count":0},{"had_liked":false,"id":83145,"user_name":"多格","can_delete":false,"product_type":"c1","uid":1222021,"ip_address":"","ucode":"122195F3D90EA1","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/85/eeb5b42f.jpg","comment_is_top":false,"comment_ctime":1554439680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554439680","product_id":100006701,"comment_content":"响应式编程与微服务在结构上很相似，都是“独立”的“功能块”。拆分粒度过细的一个显著缺点是：无法跟踪调用链。在微服务中可以采用全链路的服务跟踪来解决这个问题。放在这个场景里，应该是两个阶段：<br>1、异常抛出的代码块的堆栈信息（不全，无法判断业务逻辑）<br>2、（自行记录的）链路跟踪的堆栈信息（","like_count":0},{"had_liked":false,"id":79303,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1553431230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553431230","product_id":100006701,"comment_content":"之前觉得简单的异常处理可以衍生出那么多的干货，的确是要提高自己的代码规范了，加油","like_count":0},{"had_liked":false,"id":72414,"user_name":"要离刺荆轲","can_delete":false,"product_type":"c1","uid":1107380,"ip_address":"","ucode":"3405ED1580A19D","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/b4/a12edf06.jpg","comment_is_top":false,"comment_ctime":1551617840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551617840","product_id":100006701,"comment_content":"没记错  转化红黑树的是时候  除了链表长度大于8以外  数组大小也需要大于64  不然的话只是扩容而已","like_count":0},{"had_liked":false,"id":70056,"user_name":"L","can_delete":false,"product_type":"c1","uid":1434145,"ip_address":"","ucode":"375C376511214C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e2/21/484cd17f.jpg","comment_is_top":false,"comment_ctime":1550978876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550978876","product_id":100006701,"comment_content":"提问：目前代码中捕获通用异常后会打印日志 通过日志去定位问题。如果不捕获通用异常 一旦有些异常没有捕获到 如何定位问题呢","like_count":0},{"had_liked":false,"id":69682,"user_name":"赵达铭","can_delete":false,"product_type":"c1","uid":1438212,"ip_address":"","ucode":"8ED742EA118285","user_header":"https://static001.geekbang.org/account/avatar/00/15/f2/04/993ec92d.jpg","comment_is_top":false,"comment_ctime":1550807974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550807974","product_id":100006701,"comment_content":"老师将的很好,深浅适度,不会误导我们过分扣无用的细节~~.但是对于一课 一练~老师方便给我们一个例子连接么.～比如会出现这种问题的样列代码,以及参考的解决方案连接~~,可以是将我们导向某种讨论区的..因为网上质量高低的各种信息比较多..所以渴望老师能帮助我们甄别一下=。=","like_count":0},{"had_liked":false,"id":68907,"user_name":"。。。","can_delete":false,"product_type":"c1","uid":1204191,"ip_address":"","ucode":"96B1540E9B55B6","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/df/1c58ef91.jpg","comment_is_top":false,"comment_ctime":1550627316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550627316","product_id":100006701,"comment_content":"&quot;try-catch 代码段会产生额外的性能开销&quot; 请问下具体的开销指的是什么，影响有多大，能具体讲讲吗？","like_count":0},{"had_liked":false,"id":62447,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1548059491,"is_pvip":false,"replies":[{"id":"23355","content":"谢谢反馈","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549819746,"ip_address":"","comment_id":62447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548059491","product_id":100006701,"comment_content":"总结: <br>exception和error都继承了throwable<br>exception是程序正常运行中可以预料的意外情况,error会导致程序处于非正常不可恢复状态。<br>exception分为编译时异常和运行时异常,编译时异常必须捕获,运行时异常可以不捕获<br>扩展<br>尽量不要捕获类似Exception这样的通用异常,而是应该捕获特定异学<br>不要生吞(swallow)异常。所谓生吞异常就是捕获了异常不处理<br>try-catch代码影响JVM对代码的优化,所以能不用就不用,尽量不要用大的try包装整段代码<br>不要用异常控制代码流程<br><br>内容不够多不够深","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437219,"discussion_content":"谢谢反馈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549819746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58801,"user_name":"caohuan","can_delete":false,"product_type":"c1","uid":1256428,"ip_address":"","ucode":"4B092E33F3DF1E","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/ec/af6d0b10.jpg","comment_is_top":false,"comment_ctime":1547195765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547195765","product_id":100006701,"comment_content":"本篇所得：<br>1.error为系统或者环境JRE、JDK、JVM的错误，java程序员 是处理不了的;<br>2.exception 为 异常，我们可以捕获 也可以处理，（1）需要 精确的捕获，不能太泛化的用Exception捕获（2）也不能生吞异常 （3）异常可以用日志系统记录（4）exception 分为检查异常--checked 可以在源代码中捕获，和不检查异常--unchecked ，比如索引异常、空节点异常;<br>3.try 后面可以跟随多个 catch 捕获异常，一般先捕获小异常，然后捕获大异常;<br>4.Runtime Exception 经常性的异常可以捕获，还可以处理 异常;<br>5.异常引起的性能问题，所以 需要注意（1）try 后面只获取小段代码，捕获 真正的异常 （2）捕获 常出现的异常。<br><br>回答 老师的问题：反应式编程 Reactive Stream 异步 且基于事件机制，不同步，可以把异步 转化为同步的处理机制，然后 用已有的方式处理。<br><br>有个问题：异步捕获 与 同步捕获、异步处理 与 同步处理 1.那种使用的比较多 运用比较广 2.那种更方便 3.效率更高 4.分别 的使用场景 以及 优缺点。<br><br>看到 即友的回答 1.给业务功能 匹配ID，然后 把这些ID业务连接起来，写入日志文件中 2.运用泛化异步编程，捕获异常并封装，然后连接 到 上下文的异步，老师 觉得 二种方式 哪一种比较好，或者在那种场景下 哪一种更有优势。","like_count":0},{"had_liked":false,"id":56060,"user_name":"悠南","can_delete":false,"product_type":"c1","uid":1193711,"ip_address":"","ucode":"333665DB7CFDD6","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/ef/83c2a743.jpg","comment_is_top":false,"comment_ctime":1546390658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546390658","product_id":100006701,"comment_content":"结合项目中的自定义异常和常见异常处理手法讲讲才是真的,技术经验难能可贵 这些理解和基础概念百度几篇文章都能理解的.    技术的学习成本很低使用成本很高","like_count":0},{"had_liked":false,"id":54536,"user_name":"微凉的夏日","can_delete":false,"product_type":"c1","uid":1326955,"ip_address":"","ucode":"FFE82E4E1E9CCD","user_header":"https://static001.geekbang.org/account/avatar/00/14/3f/6b/4e583936.jpg","comment_is_top":false,"comment_ctime":1545893652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545893652","product_id":100006701,"comment_content":"老师总结的还是比较全面的，该说的点也都说到了。前面有朋友提出讲的不够深，过不了阿里的面试，老师回复说不做底层不必太深究底层，鄙视面试官。阿里面试深有感触，就算鄙视他们千次万次，offer也拿不到啊，拿到了也可能被压工资啊......<br>不做底层就不深究底层，这观点我觉得很不妥。我们平时做业务开发，也完全不必要去学习JVM，可是我们为什么还要学了？为了让自己更强，能解决更深更难的问题，不是说眼前不用就不学啊，如果一直不学，哪里谈得上运用了。尤其try-catch实现、以及堆栈快照性能耗费这里，我也觉得完全有必要深入讲解。<br>老师身在oracle，对JDK现在和未来，肯定是很了解的，能给我们深入一下就深入一下吧，小小建议一条。","like_count":0},{"had_liked":false,"id":53921,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1545754978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545754978","product_id":100006701,"comment_content":"一般不用异常控制代码流程。但如果是业务上的异常呢？抛出异常终止业务处理并回滚数据库，全局处理返回响应，这种异常控制合适吗？","like_count":0},{"had_liked":false,"id":50999,"user_name":"传证","can_delete":false,"product_type":"c1","uid":1214246,"ip_address":"","ucode":"E5BC5C7BAAA8A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/26/eb0febef.jpg","comment_is_top":false,"comment_ctime":1545097569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545097569","product_id":100006701,"comment_content":"思考总结：多线程环境下发生异常，个人觉得分两种情况，<br>1.checked excetion :<br> 在现场内部捕捉，输出有用的业务日志，业务模块id 等信息，线程相关信息<br>2.unchecked 异常：<br>线程本身，无论runnable 还是callable 接口生命方法的时候都没有声明异常，因此如果在run 方法抛异常，编译都不会过，线程实例对象扩展了uncaultexception,通过设置该接口的实例进行收集异步线程异常应该可以<br>","like_count":0},{"had_liked":false,"id":48442,"user_name":"Julian","can_delete":false,"product_type":"c1","uid":1331563,"ip_address":"","ucode":"451287999E982F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcqPrJEUz4PWI9fNOCFwPQ9SYZ9Sk7jcfLBl9IZSa0eCCibqKOO3FoaPZEB6ZiaWO7S1fTJ7nA3dNw/132","comment_is_top":false,"comment_ctime":1544445642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544445642","product_id":100006701,"comment_content":"第2讲 | Exception和Error有什么区别的学习总结。<br><br>通过查看源码发现Exeception和Error都是继承Throwable,而且里面的实现代码都一样。我个人感觉只是java语言的设计人员为了区分问题所定义的两个概念。Exeception和Error分为可检查类型异常和非检查类型异常。可检查类型异常在编码阶段就会提示你，非检查类型会在运行时提示你。<br>这两个概念的区别就是，Exeception异常在运行时是可以捕获的，并且你也有机会可以对程序进行回复，并执行正确的逻辑。而Error是程序已经处于不正确的运行了，大部分都不能再恢复程序的状态，也就是程序会挂掉等等。<br><br>处理异常要遵守以下几条规则：<br>1.不要处理父类Exeception异常，因为这样会让你分析不了问题原因，因为所有子类都继承它，只要是个问题都会被忽略，那么你怎么可能排查到真正的原因并解决呢？<br>2.不要生吞异常，原因也是你生吞了说明也解决不了问题。<br>3.异常特别消耗性能，所以不要大篇幅的try cath；当然，如果要保证程序的稳定性，浪费一下资源也不是不可以。<br>4.不要用异常进行程序逻辑的控制。<br>","like_count":0},{"had_liked":false,"id":41938,"user_name":"RocWay","can_delete":false,"product_type":"c1","uid":1088024,"ip_address":"","ucode":"377CD114BABBF7","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/18/3596069c.jpg","comment_is_top":false,"comment_ctime":1542878145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542878145","product_id":100006701,"comment_content":"NoClassDefFoundError 和 ClassNotFoundException，<br>Error在正常环境中不应该出现，而Exception则有可能出现。比如编译时有的类，但在运行时类不见了，这时就是Error。而如果程序的逻辑就是根据类名去找类，Class.forName，找不到就抛异常也比较合乎逻辑。<br>另外一个是No...Def，一个是NotFound，显然前者是编译期的概念，后者是运行时概念","like_count":0},{"had_liked":false,"id":39736,"user_name":"落落彩虹","can_delete":false,"product_type":"c1","uid":1264832,"ip_address":"","ucode":"F4CE1908DF149A","user_header":"https://static001.geekbang.org/account/avatar/00/13/4c/c0/73d52c05.jpg","comment_is_top":false,"comment_ctime":1542344124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542344124","product_id":100006701,"comment_content":"我比较喜欢老师的这种讲解方式，否则全部写出来，我可能反而不会花太多时间精力去深入了解，看过一遍或者几遍，自以为全部掌握了，过阵子有些东西还是会忘记.还是需要依靠自己的深入思考学习.给老师点赞👍👍","like_count":0},{"had_liked":false,"id":37346,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1541553551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541553551","product_id":100006701,"comment_content":"Exception和Error。Exception分为检查型异常与非检查型异常，检查型异常是编译器必须处理的如ioexception，非检查型异常又称运行期异常，如arrayoutofindexException。Error会造成环境的错误，一般处理不了。处理异常要精确，先抛，后处理，处理要精确，try catch开销大所以范围要小","like_count":0},{"had_liked":false,"id":35543,"user_name":"啊哈","can_delete":false,"product_type":"c1","uid":1274827,"ip_address":"","ucode":"2CC1C2641F5CC7","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/cb/b340daa6.jpg","comment_is_top":false,"comment_ctime":1540647366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540647366","product_id":100006701,"comment_content":"评论很精彩  马克","like_count":0},{"had_liked":false,"id":34076,"user_name":"special·D","can_delete":false,"product_type":"c1","uid":1107687,"ip_address":"","ucode":"246E14EE0BB4A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/e7/2c3cf94d.jpg","comment_is_top":false,"comment_ctime":1539989820,"is_pvip":false,"replies":[{"id":"12316","content":"这就是白马和马的问题，error 、exception都是throwable的子类型，本身doc也是有点拗口，角度、侧重点不同","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1540256151,"ip_address":"","comment_id":34076,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539989820","product_id":100006701,"comment_content":"文中老师您提到：error是不检查的是，是throwable，不是exception。到throwable是检查异常，需要在方法上显示定义。<br>JAVA源码注释：throwable and any subclass of throwable that is not also a subclass of either runtimeException or Error are regard as checked exception。throwable和它的子类，只有runtimeException和Error不是检查异常，其它都是检查异常","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427109,"discussion_content":"这就是白马和马的问题，error 、exception都是throwable的子类型，本身doc也是有点拗口，角度、侧重点不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540256151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31738,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1539274320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539274320","product_id":100006701,"comment_content":"NoClassDefFoundError 和ClassNotFoundException 有什么区别？<br><br>简单地说，NoClassDefFoundError是Error的子类，Error在java规范的异常体系中是unchecked exception，所以编译期不会检查，因此常发生在调用某些“偏僻”的API时报这个Error。<br>ClassNotFoundException是Exception的子类，Exception在java规范的异常体系中是checked exception，所以强制你处理，你可以往上抛（throws），或者catch处理。<br><br>还有一点要说明的是，checked exception在java规范中明示了这类异常通常可以预料，所以会强制你处理，如传输文件时网络中断，抛出IOException，此时解决方式一般是重试（几次）。","like_count":0},{"had_liked":false,"id":31651,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1539254086,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539254086","product_id":100006701,"comment_content":"Error属于unchecked exception，所以都不用异常处理器（try-catch）或throws","like_count":0},{"had_liked":false,"id":29705,"user_name":"xmy","can_delete":false,"product_type":"c1","uid":1259490,"ip_address":"","ucode":"B625313A67EED7","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/e2/86a115b3.jpg","comment_is_top":false,"comment_ctime":1538494114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538494114","product_id":100006701,"comment_content":"一般有nullpointexception异常可能会发生时，我都会<br><br>if （A==NULL）<br>&#47;&#47;log...<br> return；<br><br> 进行处理，不知这样处理是否恰当，这样造成代码中会有很多相似代码片段","like_count":0},{"had_liked":false,"id":27142,"user_name":"冯宇","can_delete":false,"product_type":"c1","uid":1248481,"ip_address":"","ucode":"894A0951E776D7","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/e1/e54540b9.jpg","comment_is_top":false,"comment_ctime":1537838852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537838852","product_id":100006701,"comment_content":"最后的思考题，我认为vert.x项目给了一份非常好的答卷。vert.x就是继续actor和akka实现的高性能异步框架。它处理异常的时候是将异常一并封装进入一个Future，通过异步回调告知调用者","like_count":0},{"had_liked":false,"id":26964,"user_name":"行者无端","can_delete":false,"product_type":"c1","uid":1185485,"ip_address":"","ucode":"53521F325C9087","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/cd/34136697.jpg","comment_is_top":false,"comment_ctime":1537786345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537786345","product_id":100006701,"comment_content":"我觉得checked exception &#47; unchecked exception，这些名词不用翻译。每个人自我理解不一样，原词贴出来，让每个人心中自我翻译。","like_count":0},{"had_liked":false,"id":26811,"user_name":"༦志海࿔࿆࿐ོ","can_delete":false,"product_type":"c1","uid":1241631,"ip_address":"","ucode":"BB783313BEB487","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/1f/c6b7cabc.jpg","comment_is_top":false,"comment_ctime":1537756745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537756745","product_id":100006701,"comment_content":"异常分为exception和error，<br>1.error是不经常出现或者出现概率比较低，所以程序处理的时候不需要处理，比如outofmemeryerror<br>2.exception分可检查的异常和不检查的异常，可检查的异常必须处理，比如ioexception<br>3. 不可检查的异常又叫运行时异常，nullpiontexception<br>4.异常处理要尽量处理特定的异常，尽量不要用exception来接异常<br>5.不要生吞异常不处理<br>6.异常处理消耗性能，要尽量少的包括代码","like_count":0},{"had_liked":false,"id":25477,"user_name":"0928","can_delete":false,"product_type":"c1","uid":1240990,"ip_address":"","ucode":"03221745CF8141","user_header":"https://static001.geekbang.org/account/avatar/00/12/ef/9e/78420b67.jpg","comment_is_top":false,"comment_ctime":1537339408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537339408","product_id":100006701,"comment_content":"这节课并没有说我们应该怎么正确的使用exception和error，感觉总结性东西多。","like_count":0},{"had_liked":false,"id":23936,"user_name":"宇坤_","can_delete":false,"product_type":"c1","uid":1079523,"ip_address":"","ucode":"111B9B5A62808E","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/e3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1536725003,"is_pvip":false,"replies":[{"id":"8975","content":"trycatch结构的影响是理论上的偏门，最通常的一点在于，当真的抛异常时new exception对象，jvm会去snapshot线程栈fillstacktrace","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1537092724,"ip_address":"","comment_id":23936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1536725003","product_id":100006701,"comment_content":"try catch 会影响到jvm对代码的优化！我在controller 捕获 service中的业务。 是否会影响到service业务代码被jvm优化","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423787,"discussion_content":"trycatch结构的影响是理论上的偏门，最通常的一点在于，当真的抛异常时new exception对象，jvm会去snapshot线程栈fillstacktrace","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537092724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22209,"user_name":"AmosWooo","can_delete":false,"product_type":"c1","uid":1191605,"ip_address":"","ucode":"481780ABC37013","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/b5/5f1c7ae1.jpg","comment_is_top":false,"comment_ctime":1535554660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535554660","product_id":100006701,"comment_content":"甚是受教!","like_count":0},{"had_liked":false,"id":20343,"user_name":"小地主家の长工","can_delete":false,"product_type":"c1","uid":1209427,"ip_address":"","ucode":"A4C96D37737DD7","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/53/0bb1163d.jpg","comment_is_top":false,"comment_ctime":1534385911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534385911","product_id":100006701,"comment_content":"&quot;最好重点理解一下，比如 NoClassDefFoundError 和 ClassNotFoundException 有什么区别，这也是个经典的入门题目&quot; 我看下面没有介绍，果断的滑向了评论区，果真找到了答案，高手在民间","like_count":0},{"had_liked":false,"id":19399,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1533808950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533808950","product_id":100006701,"comment_content":"checked Exception 为检查时异常，编译期间可以检查出来的异常，必须在编码期间进行处理。<br>unchecked Exception 为运行时异常，只有在运行期间才可能发生的异常，编码期间可以处理，也可以不处理。","like_count":0},{"had_liked":false,"id":19168,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1533692951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533692951","product_id":100006701,"comment_content":"抛砖引玉，引导自己去求解，以前图省事直接捕获所有异常，没想到会有那么大的性能损耗，学习了🧐","like_count":0},{"had_liked":false,"id":18343,"user_name":"绍晖","can_delete":false,"product_type":"c1","uid":1194932,"ip_address":"","ucode":"4196CF795417EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/b4/b8d0f8c8.jpg","comment_is_top":false,"comment_ctime":1533262472,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1533262472","product_id":100006701,"comment_content":"我们看到的往往是特定 executor 的堆栈，而不是业务方法调用关系。解决方法：日志中把问题和参数加上吧","like_count":0},{"had_liked":false,"id":16751,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1532153964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532153964","product_id":100006701,"comment_content":"1&#39;noClassDefFoundError 和 ClassNotFoundException 有什么区别，前者是jvm没找到类定义，后者是jvm没找到class文件<br>2,ractor 响应式编程，异常还是就地处理，影响逻辑则直接返回处理信息。<br>3,excutor中也是在内部处理，记录下错误日志。","like_count":0},{"had_liked":false,"id":16729,"user_name":"滴答丶滴","can_delete":false,"product_type":"c1","uid":1181206,"ip_address":"","ucode":"2093C2948B4327","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","comment_is_top":false,"comment_ctime":1532139591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532139591","product_id":100006701,"comment_content":"为什么说抛异常最好不用Expection?","like_count":0},{"had_liked":false,"id":14319,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1530285977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530285977","product_id":100006701,"comment_content":"对于此场景处理分为几个部分<br>1，发生异常时，将异常信息收集到统一的日志中，不是直接的处理，然后在日志中心进行日志的查看<br>2，对于任务根据业务定义重试机制！<br>3，业务线程要独立与reactor线程<br><br>这是我的观点，欢迎指正，谢谢","like_count":0},{"had_liked":false,"id":14003,"user_name":"Geek_af3d01","can_delete":false,"product_type":"c1","uid":1107401,"ip_address":"","ucode":"58C5FDD61C955E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/c9/fa9199d0.jpg","comment_is_top":false,"comment_ctime":1530112745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530112745","product_id":100006701,"comment_content":"感谢老师的分享 感谢下方评论的小伙伴的全面解析","like_count":0},{"had_liked":false,"id":13823,"user_name":"reven404","can_delete":false,"product_type":"c1","uid":1022868,"ip_address":"","ucode":"F84AAF2DC1D18F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/94/4977913a.jpg","comment_is_top":false,"comment_ctime":1530005323,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1530005323","product_id":100006701,"comment_content":"checked exception &#47; unchecked exception是相对编译器（javac）而言，可检查和不可检查的到.","like_count":0},{"had_liked":false,"id":13615,"user_name":"带着猪散步","can_delete":false,"product_type":"c1","uid":1162555,"ip_address":"","ucode":"2E1E8475792DE6","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/3b/96bb4327.jpg","comment_is_top":false,"comment_ctime":1529859069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529859069","product_id":100006701,"comment_content":"可是我要执行一连串流程，每个中断就随时结束返给前端，并写mq接着重试，这时用异常抛出去更好控制，况且他执行到这有问题了，确实也算异常，这时可以这么搞吧","like_count":0},{"had_liked":false,"id":12339,"user_name":"robbin🐳","can_delete":false,"product_type":"c1","uid":1005984,"ip_address":"","ucode":"1333C3E0C5567F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/a0/66486058.jpg","comment_is_top":false,"comment_ctime":1528767769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528767769","product_id":100006701,"comment_content":"我们在实际开发中因为不能准确保证程序的哪里会有异常情况，一般都会将代码段包起来，同时使用throwable捕获，有时很难做到每段都仔细判断异常。<br><br>关于异步的部分我想是否可以像golang的模式将上下文对象传递","like_count":0},{"had_liked":false,"id":11166,"user_name":"洺叶","can_delete":false,"product_type":"c1","uid":1074258,"ip_address":"","ucode":"DF3BC91564A0B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/52/8cb50037.jpg","comment_is_top":false,"comment_ctime":1527906490,"is_pvip":false,"replies":[{"id":"3586","content":"默认是标准输出，具体看应用重定向到哪里","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527977152,"ip_address":"","comment_id":11166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527906490","product_id":100006701,"comment_content":"Printstacktrace 在稍微复杂一点的生产系统中，很难判断出到底输出到哪里去了，老师能否举例说明下会输出到什么地方？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418738,"discussion_content":"默认是标准输出，具体看应用重定向到哪里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527977152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10753,"user_name":"韩峰","can_delete":false,"product_type":"c1","uid":1145289,"ip_address":"","ucode":"0C14C370EFBFD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/c9/2108e987.jpg","comment_is_top":false,"comment_ctime":1527686134,"is_pvip":false,"replies":[{"id":"3475","content":"这个建议要从业务逻辑角度看哪里负责处理，比如你提到的基础不足，我相信是业务逻辑的一部分，如何处理其实从业务设计角度是有答案的，例如，应用肯定是要给用户一个合理的反馈，而不是简单打个堆栈或不响应；<br>开销不用过于担心，毕竟也不是netty这种特别性能敏感的框架，还是优先考虑业务需要","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527795064,"ip_address":"","comment_id":10753,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527686134","product_id":100006701,"comment_content":"老师，关于异常，我有两点疑惑，第一点一个程序一级级的调用，是应该在在最上级捕获吗，第二点，目前我公司已有的项目自定义大量的业务异常继承自runtimException,比如库存不足异常，这样会不会额外增加开销，这是不是一种不可理的方式","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418587,"discussion_content":"这个建议要从业务逻辑角度看哪里负责处理，比如你提到的基础不足，我相信是业务逻辑的一部分，如何处理其实从业务设计角度是有答案的，例如，应用肯定是要给用户一个合理的反馈，而不是简单打个堆栈或不响应；\n开销不用过于担心，毕竟也不是netty这种特别性能敏感的框架，还是优先考虑业务需要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527795064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10353,"user_name":"Jerome","can_delete":false,"product_type":"c1","uid":1106386,"ip_address":"","ucode":"B51927F268EC52","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/d2/8dd23eb5.jpg","comment_is_top":false,"comment_ctime":1527501040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527501040","product_id":100006701,"comment_content":"如果项目自定义异常应该继承exception还是runtimeexception, 我现在写的代码两种都有， 这两种形式有什么区别 比如错误显示，记录日志。什么场景下用呢？","like_count":0},{"had_liked":false,"id":9960,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1527203319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527203319","product_id":100006701,"comment_content":"1.异常的父类。throwable.<br>2.异常的分类。error错误。exception异常。  <br>3。对异常分类的使用。error是jvm环境运行错误，不可进行捕获。包括，throwable。exception是程序上的错误，需要在错误时进行捕获，恢复正常运行的形态。对异常捕获，最好进行异常类型最匹配的形式，这样具有日志堆栈信息便于查询，排错。<br>4。异常的使用是比较消耗性能。消耗性能的方式有try代码快，与生成exception的堆栈快照。<br>5。注意信息。在生成exception错误信息时，不能使用exception自带方法进行输出。这种方式，不清楚会输出到什么地方，不好排查。<br>6。异常实践。异常分2种进行处理，一种业务异常，一种程序异常。业务异常直接抛出，程序异常，先处理一次，如果处理不了在进行抛出。","like_count":0},{"had_liked":false,"id":9801,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1527094087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527094087","product_id":100006701,"comment_content":"请问老师，当catch 住异常时<br>catch (IOException e) {<br>    e.printStackTrace();<br>}<br>1、正确的打印异常的方式是什么？<br>例如使用slf4j：<br>log.error(&quot;发现异常了 {}&quot;, e.getMessage());<br>2、日志的级别应该是warn、error的哪一个更合适？<br>谢谢！","like_count":0},{"had_liked":false,"id":9800,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1527093339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527093339","product_id":100006701,"comment_content":"最大的收获是明白了为什么不建议用异常控制正常业务流程，因为这种条件判断方式是低效的。具体原因：Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。","like_count":0},{"had_liked":false,"id":9490,"user_name":"azhansy","can_delete":false,"product_type":"c1","uid":1122381,"ip_address":"","ucode":"17CA3C1BFA6DB1","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/4d/a73999b9.jpg","comment_is_top":false,"comment_ctime":1526908932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526908932","product_id":100006701,"comment_content":"我们读代码的机会往往超过写代码，<br>软件工程是门协作的艺术，<br>优秀是一种习惯。","like_count":0},{"had_liked":false,"id":9269,"user_name":"日光倾城","can_delete":false,"product_type":"c1","uid":1120345,"ip_address":"","ucode":"E4329963F660DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/59/daeb0b6c.jpg","comment_is_top":false,"comment_ctime":1526718752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526718752","product_id":100006701,"comment_content":"Exception与Error都继承自Throwable，单纯从字面理解，前者是异常，后者是错误。Exception是在编码过程中可以预见的异常情况，比如数组越界，文件不存在，网络不通等。Error是正常情况下不会发生，一旦发生jvm也无法进行恢复的情况，比如OutOfMemoryError，StackOverflowError，这些错误情况一旦出现，jvm也无能为力了，只能停止整个进程。<br>运行时异常也就是非受检异常，比如说NPE，数组越界，这种异常其实是我们可以通过一些判断避免的，比如非空判断，数组长度判断，如果我们没做判断抛出了这类异常，说明我们的程序不严谨。一般异常就是我们在编码阶段无法预知但是也无法避免的异常情况，比如网络不通之类，所以我们可以提前进行预防，发生这种情况我们如何处理？并尝试从这类异常中恢复，至少能给出良好的提示","like_count":0},{"had_liked":false,"id":9268,"user_name":"日光倾城","can_delete":false,"product_type":"c1","uid":1120345,"ip_address":"","ucode":"E4329963F660DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/59/daeb0b6c.jpg","comment_is_top":false,"comment_ctime":1526718711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526718711","product_id":100006701,"comment_content":"Exception与Error都继承自Throwable，单纯从字面理解，前者是异常，后者是错误。Exception是在编码过程中可以预见的异常情况，比如数组越界，文件不存在，网络不通等。Error是正常情况下不会发生，一旦发生jvm也无法进行恢复的情况，比如OutOfMemoryError，StackOverflowError，这些错误情况一旦出现，jvm也无能为力了，只能停止整个进程。<br>运行时异常也就是非受检异常，比如说NPE，数组越界，这种异常其实是我们可以通过一些判断避免的，比如非空判断，数组长度判断，如果我们没做判断抛出了这类异常，说明我们的程序不严谨。一般异常就是我们在编码阶段无法预知但是也无法避免的异常情况，比如网络不通之类，所以我们可以提前进行预防，发生这种情况我们如何处理？并尝试从这类异常中恢复，至少能给出良好的提示","like_count":0},{"had_liked":false,"id":8839,"user_name":"New Yorker","can_delete":false,"product_type":"c1","uid":1088168,"ip_address":"","ucode":"C7D1B1BB7F50F6","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/a8/a028bb9e.jpg","comment_is_top":false,"comment_ctime":1526477357,"is_pvip":false,"replies":[{"id":"2697","content":"1，狭义上是，Error也是unchecked类<br>2，比如cache一个，或者自己实现个，去掉对应逻辑","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526597446,"ip_address":"","comment_id":8839,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526477357","product_id":100006701,"comment_content":"两点疑问：<br>1，checked exception 和 unchecked exception 是 Exception 的子类吗？如果不是，如何自定义一个unchecked exception？<br>2，如何控制一个Exception 在实例化时不进行栈快照？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417863,"discussion_content":"1，狭义上是，Error也是unchecked类\n2，比如cache一个，或者自己实现个，去掉对应逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526597446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8818,"user_name":"戴","can_delete":false,"product_type":"c1","uid":1113316,"ip_address":"","ucode":"BB5EF9A41BAFA7","user_header":"","comment_is_top":false,"comment_ctime":1526463632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526463632","product_id":100006701,"comment_content":"留言区的一些留言，语言表达能力好差，很难看懂。","like_count":0},{"had_liked":false,"id":8817,"user_name":"戴","can_delete":false,"product_type":"c1","uid":1113316,"ip_address":"","ucode":"BB5EF9A41BAFA7","user_header":"","comment_is_top":false,"comment_ctime":1526462928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526462928","product_id":100006701,"comment_content":"多看看评论，感觉评论比原文有价值。评论里更像一个专题交流会，从中可以看到大家日常工作实践中面临的痛点","like_count":0},{"had_liked":false,"id":8809,"user_name":"LBF","can_delete":false,"product_type":"c1","uid":1128460,"ip_address":"","ucode":"82BD5731F51A8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/0c/1b85eb66.jpg","comment_is_top":false,"comment_ctime":1526458345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526458345","product_id":100006701,"comment_content":"小白留言:<br>捕获不了异常的捕获不是好捕获，<br>什么异常都捕获的捕获不是好捕获，<br>解决不了异常的捕获一定是坏捕获，<br>捕获不是俄罗斯转盘，小概率事件会致命！","like_count":0},{"had_liked":false,"id":8673,"user_name":"happyhacking","can_delete":false,"product_type":"c1","uid":1022803,"ip_address":"","ucode":"E65A6FB98640BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/53/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1526361476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526361476","product_id":100006701,"comment_content":"提几点我觉得可以改进的地方，<br>简单的内容可以篇幅少一些<br>标题和结构感觉不够清晰<br>结合实践可以更多一些<br><br>我的感受是，一篇读完，读之前模棱两可的，读之后还是不清楚，如果不回头再看一遍的话都不记得有什么内容…<br><br>对了，可以贴一些推荐的好的文章和资料。总之让读者看到用心呀。<br>否则和网上搜到的资料水准不就差不多了~ <br>不过本来就基础的东西，要体现出水平还不能说太深又要实用还是挺难的。加油","like_count":0},{"had_liked":false,"id":8470,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1526256786,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526256786","product_id":100006701,"comment_content":"只看到理论介绍，和一些实验代码，没看到生产代码实践示范？还比如，如何合理自定义异常的示范？","like_count":0},{"had_liked":false,"id":8432,"user_name":"末日没有进行曲","can_delete":false,"product_type":"c1","uid":1025667,"ip_address":"","ucode":"D2EEF4CD34B466","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/83/d1176d65.jpg","comment_is_top":false,"comment_ctime":1526213234,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1526213234","product_id":100006701,"comment_content":"问一下老师如何能更好地消化这些知识呢？感觉看过一遍懂，但是自己说却不能完整表述出来。多看？","like_count":0},{"had_liked":false,"id":8400,"user_name":"ls","can_delete":false,"product_type":"c1","uid":1007293,"ip_address":"","ucode":"6C14A1D24DDC2E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/bd/e28f8ce5.jpg","comment_is_top":false,"comment_ctime":1526181214,"is_pvip":false,"replies":[{"id":"2500","content":"“过早优化是万恶之源”，当然是保证应用可靠性更重要","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526270790,"ip_address":"","comment_id":8400,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526181214","product_id":100006701,"comment_content":"老师您好，我是做Android 客户端的,对于网络请求回来的bean 解释及后续处理，我们的做法也是把一整段给try-catch，即使有异常没有被处理，也不会导致客户端崩溃 。像客户端这种频率不是很大的，对性能影响会怎么样？ <br><br>另外也很希望能讲解下自定义异常的实践，或者如何去设计一个合适的异常处理机制。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417698,"discussion_content":"“过早优化是万恶之源”，当然是保证应用可靠性更重要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526270790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8386,"user_name":"davidimu","can_delete":false,"product_type":"c1","uid":1113244,"ip_address":"","ucode":"6E28FF113F33CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/9c/008247ed.jpg","comment_is_top":false,"comment_ctime":1526140619,"is_pvip":false,"replies":[{"id":"2504","content":"Rxjava我了解有限，如果我没理解错，那是reactive编程注册异常listener的方式，jdk最新版本websocket api也是使用类似机制，虽然细节有区别","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526272030,"ip_address":"","comment_id":8386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526140619","product_id":100006701,"comment_content":"RxJava中有一些异常处理的方法 比如doOnError switchOnError 可以选择把异常包起来再抛出去来保留上下文","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417691,"discussion_content":"Rxjava我了解有限，如果我没理解错，那是reactive编程注册异常listener的方式，jdk最新版本websocket api也是使用类似机制，虽然细节有区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526272030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8296,"user_name":"清风","can_delete":false,"product_type":"c1","uid":1128147,"ip_address":"","ucode":"59B28277CC675D","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/d3/e85df944.jpg","comment_is_top":false,"comment_ctime":1526058566,"is_pvip":false,"replies":[{"id":"2521","content":"保证可靠性是最重要的；这种情况使用了spring exception handler吗？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526276713,"ip_address":"","comment_id":8296,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1526058566","product_id":100006701,"comment_content":"我有一个问题想请教一下，目前公司里的异常处理方式是直接用try catch 把整个逻辑块都包住，不管是controller层还是service层，这种代码到处可见，虽然觉得这样不太好，但确没有想到更好的解决方案，因为这样确实比较容易排查问题。而且目前使用的是微服务式开发，每个功能可能都由不同人开发，服务调用采用不信任原则也是有道理的，所以想请问一下，目前有关于在这样情况下比较好的异常处理方案吗？补充一下，公司用的是spring boot框架。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417657,"discussion_content":"保证可靠性是最重要的；这种情况使用了spring exception handler吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526276713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8237,"user_name":"自在","can_delete":false,"product_type":"c1","uid":1066745,"ip_address":"","ucode":"BE081FC67FDA71","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/f9/0a009b6f.jpg","comment_is_top":false,"comment_ctime":1525999999,"is_pvip":false,"replies":[{"id":"2418","content":"也会影响优化","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1526013679,"ip_address":"","comment_id":8237,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525999999","product_id":100006701,"comment_content":"我记得栈帧里面异常块与代码块是分离的，如果不出现异常好像是不影响性能的吧...","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417643,"discussion_content":"也会影响优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526013679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8153,"user_name":"淡云天","can_delete":false,"product_type":"c1","uid":1109218,"ip_address":"","ucode":"90A13E2A0570FF","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/e2/79780894.jpg","comment_is_top":false,"comment_ctime":1525927777,"is_pvip":false,"replies":[{"id":"2390","content":"符合catch late原则，业务代码更清楚怎么处理，这个看什么角度，不完全通常意义的流程控制；<br>“非致命”Error的出现，恰恰说明了异常机制在实践中并没有达到设计目的，所以才出现了争论，这么catch前提是清楚那些Error是应用能处理的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525960819,"ip_address":"","comment_id":8153,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525927777","product_id":100006701,"comment_content":"在忽略try-catch和流程控制时的性能消耗下，前者的控制能力更强一些吧？一些业务级异常都是交给顶层的ExceptionHandler处理的，写一个整体处理类即可。而用流程控制的话，细节处理上就会相当麻烦。而且像servlet等一些类似server的程序，都会在外面包一层try-catch以保证程序在非致命Error下可以正常运行的吧？还望作者解惑","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417602,"discussion_content":"符合catch late原则，业务代码更清楚怎么处理，这个看什么角度，不完全通常意义的流程控制；\n“非致命”Error的出现，恰恰说明了异常机制在实践中并没有达到设计目的，所以才出现了争论，这么catch前提是清楚那些Error是应用能处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525960819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8108,"user_name":"Gerald","can_delete":false,"product_type":"c1","uid":1115544,"ip_address":"","ucode":"6B44B838D1E483","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/98/d152b8c5.jpg","comment_is_top":false,"comment_ctime":1525913189,"is_pvip":false,"replies":[{"id":"2357","content":"应用里的logger","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525914506,"ip_address":"","comment_id":8108,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525913189","product_id":100006701,"comment_content":"“尤其是对于分布式系统，如果发生异常，但是无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。”什么是产品日志呢？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417583,"discussion_content":"应用里的logger","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525914506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8106,"user_name":"Gerald","can_delete":false,"product_type":"c1","uid":1115544,"ip_address":"","ucode":"6B44B838D1E483","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/98/d152b8c5.jpg","comment_is_top":false,"comment_ctime":1525913016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525913016","product_id":100006701,"comment_content":"e.printStackTrace();在产品代码里使用有问题，这个不是能理解，IOException 是checked 异常，在catch块里应该怎么处理呢？","like_count":0},{"had_liked":false,"id":8071,"user_name":"小马","can_delete":false,"product_type":"c1","uid":1121951,"ip_address":"","ucode":"1D57B292CF1193","user_header":"","comment_is_top":false,"comment_ctime":1525908449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525908449","product_id":100006701,"comment_content":"学习总结：1.理解Throwable,Error,Exception的关系。<br>2.尽量不要捕获Exception通用异常,这样会使程序保留隐藏的异常，有很大的隐患。<br>3.不能生吞异常，就是将一大段代码放在try中，不知道会发生那些异常，就将其全部包起来，问题一保留隐藏异常对程序有隐患问题二：异常捕获处理对jvm的开销很大。更不能在异常处理实现业务逻辑。<br>学会了规范写异常处理部分的代码，以及这么规范的好处。","like_count":0},{"had_liked":false,"id":8059,"user_name":"Billion","can_delete":false,"product_type":"c1","uid":1120556,"ip_address":"","ucode":"149D8D23A78D8B","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/2c/94c160b0.jpg","comment_is_top":false,"comment_ctime":1525883675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525883675","product_id":100006701,"comment_content":"复习了一下Java异常处理知识，有很多启发性的内容，受益匪浅！最后的思考题我也想了下，是否可以构建一个独立的异常分析模块，业务端在提交异步任务时，将其重要的状态信息及traceid发送到异常分析模块，同时异步任务也与traceid捆绑，发生异常时，异步任务只需把捆绑的traceid及异常信息发送给异常分析模块，由异常分析模块来处理业务端与异常的配对。","like_count":0},{"had_liked":false,"id":8055,"user_name":"coulson","can_delete":false,"product_type":"c1","uid":1125035,"ip_address":"","ucode":"ADBC6AEED866FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/ab/6b2475e9.jpg","comment_is_top":false,"comment_ctime":1525880475,"is_pvip":false,"replies":[{"id":"2344","content":"心动不如行动，个人建议，试着问自己一个特定的问题，然后针对性的总结，别怕不够完美。<br>编程也是一样，不是什么时候都完全想清楚再做的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525881404,"ip_address":"","comment_id":8055,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525880475","product_id":100006701,"comment_content":"老师，你写的这些我大部分都能看懂，也能理解一部分，可是让我用文字形式写出来，我脑子就一踏糊涂，不知道从哪下手，该怎么办？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417562,"discussion_content":"心动不如行动，个人建议，试着问自己一个特定的问题，然后针对性的总结，别怕不够完美。\n编程也是一样，不是什么时候都完全想清楚再做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525881404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8054,"user_name":"无意中找到的","can_delete":false,"product_type":"c1","uid":1124039,"ip_address":"","ucode":"88F18CDA6A749C","user_header":"https://static001.geekbang.org/account/avatar/00/11/26/c7/91ce3b4b.jpg","comment_is_top":false,"comment_ctime":1525880410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525880410","product_id":100006701,"comment_content":"同事老是在catch中，直接用e.print打印堆栈，然后再用log打印一个e.getMessage() 还说在log里面没必要把堆栈打出来，太浪费空间时间了。。。感觉这样明显有问题，可我就是说不过他-_-||","like_count":0},{"had_liked":false,"id":8044,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1525872640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525872640","product_id":100006701,"comment_content":"checked exception至少有一个用，通过编译时提醒你如果出错应该释放资源。否则如果是unchecked，说不定忘记了","like_count":0},{"had_liked":false,"id":8037,"user_name":"Mine","can_delete":false,"product_type":"c1","uid":1069193,"ip_address":"","ucode":"D3919D4C67A991","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/89/fff46087.jpg","comment_is_top":false,"comment_ctime":1525869725,"is_pvip":false,"replies":[{"id":"2336","content":"我对Kotlin了解有限，初略的理解是：<br>二者不完全对比，因为kotlin catch可以返回值，try-catch就变成了表达式，更优雅一些；<br>对于函数会不会抛异常，IDE不会提供提示吗","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525877632,"ip_address":"","comment_id":8037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525869725","product_id":100006701,"comment_content":"最近学了一点kotlin，在kotlin里面就是没有checkedException。这里想请教一下老师，在这种一切都是runtime的情况下应该以何种思路处理异常？因为不知道调用的函数会不会抛异常，不知道会抛哪种异常，而都用try catch包起来也不现实，最近一直在困惑这个点……","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417555,"discussion_content":"我对Kotlin了解有限，初略的理解是：\n二者不完全对比，因为kotlin catch可以返回值，try-catch就变成了表达式，更优雅一些；\n对于函数会不会抛异常，IDE不会提供提示吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525877632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8034,"user_name":"渊","can_delete":false,"product_type":"c1","uid":1107745,"ip_address":"","ucode":"F0CE82CF2B41B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/21/735ccb2d.jpg","comment_is_top":false,"comment_ctime":1525869025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525869025","product_id":100006701,"comment_content":"如何知道我的try bllck会throw什么exception?","like_count":0},{"had_liked":false,"id":8033,"user_name":"渊","can_delete":false,"product_type":"c1","uid":1107745,"ip_address":"","ucode":"F0CE82CF2B41B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/21/735ccb2d.jpg","comment_is_top":false,"comment_ctime":1525868976,"is_pvip":false,"replies":[{"id":"2337","content":"try住的代码，抛出什么是明确声明了的，这种情况一般IDE更擅长","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525877697,"ip_address":"","comment_id":8033,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525868976","product_id":100006701,"comment_content":"我怎么知道我try block应该catch什么exception?","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417554,"discussion_content":"try住的代码，抛出什么是明确声明了的，这种情况一般IDE更擅长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525877697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8014,"user_name":"wangbo","can_delete":false,"product_type":"c1","uid":1125722,"ip_address":"","ucode":"3F0C9C320F0A1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/5a/d965c147.jpg","comment_is_top":false,"comment_ctime":1525855319,"is_pvip":false,"replies":[{"id":"2334","content":"绝大部分情况是不，除非确定可以从Error恢复，或者没有别的选择","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525875729,"ip_address":"","comment_id":8014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525855319","product_id":100006701,"comment_content":"error开发者能不能去捕获和处理？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417546,"discussion_content":"绝大部分情况是不，除非确定可以从Error恢复，或者没有别的选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525875729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7988,"user_name":"大胖","can_delete":false,"product_type":"c1","uid":1112394,"ip_address":"","ucode":"01C517B91A9F57","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/4a/ace7b837.jpg","comment_is_top":false,"comment_ctime":1525832596,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1525832596","product_id":100006701,"comment_content":"error:jvm或者说是系统级别问题，捕获会导致问题无法定位，而且错误捕获应用程序也没什么作为，不如暴露出来定位错误！\r<br>exception:RuntimeException以外的子类,属于应用程序可以处理的也在编程过程中可以遇判的，应该抛出异常进行处理！这样理解对否？","like_count":0},{"had_liked":false,"id":7955,"user_name":"沈老师","can_delete":false,"product_type":"c1","uid":1124296,"ip_address":"","ucode":"7870DDE5005648","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/c8/3addd7b7.jpg","comment_is_top":false,"comment_ctime":1525819514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525819514","product_id":100006701,"comment_content":"能否选择您项目中一段设计比较完善的异常处理结合业务分析下，这样比较有具体场景的深入了解好的代码是怎么一个思路。谢谢！","like_count":0},{"had_liked":false,"id":7953,"user_name":"板砖","can_delete":false,"product_type":"c1","uid":1124658,"ip_address":"","ucode":"C5421E028DFFD6","user_header":"","comment_is_top":false,"comment_ctime":1525806052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525806052","product_id":100006701,"comment_content":"不要用一个大的try-catch包含整个代码这个怎么理解呢，因为springmvc来说，我现在的做法是在axtion里一个方法写一个业务，然后就写一个try-catch，如果不用一个大的该怎么写，还是说老师您的说法就是一个业务一个try-catch？？？","like_count":0},{"had_liked":false,"id":7913,"user_name":"愣子","can_delete":false,"product_type":"c1","uid":1032177,"ip_address":"","ucode":"C45E2DCEF4E8BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/f1/c7e54db8.jpg","comment_is_top":false,"comment_ctime":1525779593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525779593","product_id":100006701,"comment_content":"反应式编程里出现异常是否可以搞一个类似dead queue的异常队列，把异常放到这个队列里供消费者去消费？","like_count":0},{"had_liked":false,"id":7892,"user_name":"我奋斗去了","can_delete":false,"product_type":"c1","uid":1017931,"ip_address":"","ucode":"C13918E425F595","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/4b/4fb10188.jpg","comment_is_top":false,"comment_ctime":1525764691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525764691","product_id":100006701,"comment_content":"Reactor 目前在Java中还没有使用过 ，感觉类似nodeJs的回调？期待正解","like_count":0},{"had_liked":false,"id":7879,"user_name":"Rebby","can_delete":false,"product_type":"c1","uid":1071771,"ip_address":"","ucode":"C2723F5FF14483","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/9b/215cd2e0.jpg","comment_is_top":false,"comment_ctime":1525756394,"is_pvip":false,"replies":[{"id":"2268","content":"有的代码被设计为，当发生某种异常时，走某条路径，这种条件判断方式是低效的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525759484,"ip_address":"","comment_id":7879,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525756394","product_id":100006701,"comment_content":"try 包住整段的代码；远比我们通常意义上的条件语句（if&#47;else、switch）要低效。<br> 请问 这段怎么理解呢？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417505,"discussion_content":"有的代码被设计为，当发生某种异常时，走某条路径，这种条件判断方式是低效的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525759484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7858,"user_name":"Hidden","can_delete":false,"product_type":"c1","uid":1114462,"ip_address":"","ucode":"6323E5D32A3190","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/5e/95f7d928.jpg","comment_is_top":false,"comment_ctime":1525747501,"is_pvip":false,"replies":[{"id":"2255","content":"很高兴能有帮助，程序开发不是只有那些高大上的东西的，以前有人找我帮助诊断应用上线闪退问题，我发现大部分就是几个NPE、IllegalState之类runtime exception低级错误导致的！","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525751107,"ip_address":"","comment_id":7858,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525747501","product_id":100006701,"comment_content":"分析的太好了，学习完，基础就牢固很多了","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417498,"discussion_content":"很高兴能有帮助，程序开发不是只有那些高大上的东西的，以前有人找我帮助诊断应用上线闪退问题，我发现大部分就是几个NPE、IllegalState之类runtime exception低级错误导致的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525751107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7854,"user_name":"刹那间的永恒","can_delete":false,"product_type":"c1","uid":1114738,"ip_address":"","ucode":"DAB8A1BE22C4EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/72/6933412b.jpg","comment_is_top":false,"comment_ctime":1525746852,"is_pvip":false,"replies":[{"id":"2258","content":"换个角度，如果出了错，我们是希望看看log就能定位问题，还是觉得需要熬夜改改代码多print几行？<br>前人（自己）挖坑，含泪也得爬出来<br>","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525751556,"ip_address":"","comment_id":7854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525746852","product_id":100006701,"comment_content":"由于是半路出家，所以对于基础这块儿很不牢靠，尤其是之前对于异常处理很不重视，看了这篇文章收获了很多:<br>       1.catch具体的异常，不是exception;<br>       2.慎用try catch，只包裹可能会抛出异常的代码;<br>       3.慎用return break continue;<br>       4.慎用e.printstacktrace()，都记录到日志(这个还不是很理解);<br>       5.能处理的异常尽早捕获处理，不能的就抛给上层。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417495,"discussion_content":"换个角度，如果出了错，我们是希望看看log就能定位问题，还是觉得需要熬夜改改代码多print几行？\n前人（自己）挖坑，含泪也得爬出来\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525751556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7839,"user_name":"Heart to bodhi","can_delete":false,"product_type":"c1","uid":1124661,"ip_address":"","ucode":"4C8B24FA24CE9C","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/35/5563d6c1.jpg","comment_is_top":false,"comment_ctime":1525743083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525743083","product_id":100006701,"comment_content":"对于反应式编程 应该用日志记录好每个 executor信息 和输入信息","like_count":0},{"had_liked":false,"id":7831,"user_name":"李志博","can_delete":false,"product_type":"c1","uid":1009109,"ip_address":"","ucode":"F3C72573B3C112","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/d5/88beb15a.jpg","comment_is_top":false,"comment_ctime":1525741895,"is_pvip":false,"replies":[{"id":"2253","content":"对头，非常不同的编程模式","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1525747990,"ip_address":"","comment_id":7831,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525741895","product_id":100006701,"comment_content":"Reactor我记得有onError和doError开头的一些方法","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417486,"discussion_content":"对头，非常不同的编程模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525747990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7820,"user_name":"不会游泳的鱼","can_delete":false,"product_type":"c1","uid":1077238,"ip_address":"","ucode":"D0AEA7C5C079EE","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLSqNYhASmjn759XTmvzqX8dqMwlIgva7nERaGicHng7kZCfkSxOsoV6rYDglVsu2FTicicQyK0RItFw/0","comment_is_top":false,"comment_ctime":1525741118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1525741118","product_id":100006701,"comment_content":"exception做设计的话有什么好的设计方案么？自动测试中捕获异常是必备的","like_count":0},{"had_liked":false,"id":7779,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1525735297,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1525735297","product_id":100006701,"comment_content":"扩展任务类的实现，把当前的堆栈信息保留进去后提交，这样在任务中捕获异常后就可以做相关处理。","like_count":0}]}