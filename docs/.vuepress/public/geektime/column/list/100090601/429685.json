{"id":429685,"title":"17｜日志：如何设计多输出的日志服务？","content":"<p>你好，我是轩脉刃。</p><p>上面两节课，我们将环境变量和配置服务作为一个服务注册到容器中了。这样，在业务中就能很方便获取环境变量和配置了。不知道你有没有逐渐体会到这种“一切皆服务”思想的好处。</p><p>就像堆积积木，只要想好了一个服务的接口，我们逐步实现服务之后，这一个服务就是一块积木，之后可以用相同的思路实现各种服务的积木块，用它们来拼出我们需要的业务逻辑。这节课，我们就来实现另一个框架最核心的积木：日志服务。</p><p>实现一个框架的服务，我们习惯了要创建三个文件：接口协议文件 framework/contract/log.go、服务提供者 framework/provider/log/provider.go、接口实例framework/provider/log/service.go。</p><h2>日志接口协议</h2><p>说到日志服务，最先冒出来的一定是三个问题：什么样的日志需要输出？日志输出哪些内容？日志输出到哪里？一个个来分析。</p><h3>日志级别</h3><p>什么样的日志需要输出，这是个关于日志级别的问题。我们想要把日志分为几个级别？每个级别代表什么？这个日志级别其实在不同系统中有不同划分，比如Linux的<a href=\"https://datatracker.ietf.org/doc/html/rfc5424\">syslog</a>中将系统划分为以下八种日志级别：<br>\n<img src=\"https://static001.geekbang.org/resource/image/f5/ea/f5382bc685494efb2c024f31f25aa2ea.png?wh=912x438\" alt=\"\"><br>\n而Java的<a href=\"https://zh.wikipedia.org/wiki/Log4j\">log4j</a>将日志分为以下七种日志级别：<br>\n<img src=\"https://static001.geekbang.org/resource/image/e0/78/e07a0aefb9039788d17921e192394f78.jpg?wh=1920x1080\" alt=\"\"></p><!-- [[[read_end]]] --><p>其实仔细看，它们的日志级别差别都不大。比如都同意用Error级别代表运行时的错误情况，而Warn级别代表运行时可以弥补的错误、Info级别代表运行时信息、debug代表调试的时候需要打印的信息。</p><p>不同点就在是否有trace级别以及Error级别往上的级别定义。syslog没有trace级别，而在Error级别往上分别定义了Emergency级别、Alert级别、Critical级别。而log4j在ERROR上定义了两个级别FATAL和OFF，也同时保留了Trace级别。</p><p>在我看来，syslog和log4j的日志区分主要是由于场景不同。syslog比较偏向于<strong>操作系统的使用场景</strong>，它的分级语义更多是告诉我们系统的情况，比如Alert这个级别表示“系统有问题，需要立即采取行动”；而log4j的日志级别定义是<strong>从一个应用出发的</strong>，它的影响范围理论上会小一些，所以它很难定义比如像“需要立即采取行动”这样的级别。</p><p>所以，这里我们主要参考log4j的日志级别方法，并做了一些小调整，归并为下列七种日志级别：</p><ul>\n<li>panic，表示会导致整个程序出现崩溃的日志信息</li>\n<li>fatal，表示会导致当前这个请求出现提前终止的错误信息</li>\n<li>error，表示出现错误，但是不一定影响后续请求逻辑的错误信息</li>\n<li>warn，表示出现错误，但是一定不影响后续请求逻辑的报警信息</li>\n<li>info，表示正常的日志信息输出</li>\n<li>debug，表示在调试状态下打印出来的日志信息</li>\n<li>trace，表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息</li>\n</ul><p>在error级别之上，我们把导致程序崩溃和导致请求结束的错误拆分出来，分为panic和fatal两个类型来定义级别。而其他的error、warn、info、debug 都和其他的日志系统一致。另外也增加一个trace级别，当需要打印调用堆栈等这些比较详细的信息的时候，可以使用这种日志级别。</p><p><strong>日志级别是按照严重顺序从下往上排列的</strong>。也就是说，如果我们设置了日志输出级别为info，那么info级别的日志及info级别往上，日志级别更高的warn、error、fatal、panic的日志，也需要被打印出来。</p><p>按照这个思路，我们在framework/contract/log.go中定义的接口协议如下：</p><pre><code class=\"language-go\">package contract\nimport (\n   \"context\"\n   \"io\"\n   \"time\"\n)\n\n// 协议关键字\nconst LogKey = \"hade:log\"\n\ntype LogLevel uint32\n\nconst (\n   // UnknownLevel 表示未知的日志级别\n   UnknownLevel LogLevel = iota\n   // PanicLevel level, panic 表示会导致整个程序出现崩溃的日志信息\n   PanicLevel\n   // FatalLevel level. fatal 表示会导致当前这个请求出现提前终止的错误信息\n   FatalLevel\n   // ErrorLevel level. error 表示出现错误，但是不一定影响后续请求逻辑的错误信息\n   ErrorLevel\n   // WarnLevel level. warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息\n   WarnLevel\n   // InfoLevel level. info 表示正常的日志信息输出\n   InfoLevel\n   // DebugLevel level. debug 表示在调试状态下打印出来的日志信息\n   DebugLevel\n   // TraceLevel level. trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息\n   TraceLevel\n)\n...\n\n// Log define interface for log\ntype Log interface {\n   // Panic 表示会导致整个程序出现崩溃的日志信息\n   Panic(ctx context.Context, msg string, fields map[string]interface{})\n   // Fatal 表示会导致当前这个请求出现提前终止的错误信息\n   Fatal(ctx context.Context, msg string, fields map[string]interface{})\n   // Error 表示出现错误，但是不一定影响后续请求逻辑的错误信息\n   Error(ctx context.Context, msg string, fields map[string]interface{})\n   // Warn 表示出现错误，但是一定不影响后续请求逻辑的报警信息\n   Warn(ctx context.Context, msg string, fields map[string]interface{})\n   // Info 表示正常的日志信息输出\n   Info(ctx context.Context, msg string, fields map[string]interface{})\n   // Debug 表示在调试状态下打印出来的日志信息\n   Debug(ctx context.Context, msg string, fields map[string]interface{})\n   // Trace 表示最详细的信息，一般信息量比较大，可能包含调用堆栈等信息\n   Trace(ctx context.Context, msg string, fields map[string]interface{})\n   // SetLevel 设置日志级别\n   SetLevel(level LogLevel)\n   ...\n}\n</code></pre><p>在接口中，我们针对七种日志级别设置了七个不同的方法，并且提供SetLevel方法，来设置当前这个日志服务需要输出的日志级别。</p><h3>日志格式</h3><p>定义好了日志级别，下面该定义日志格式了。日志格式包括输出哪些内容、如何输出？</p><p>首先明确下需要输出的日志信息，不外乎有下面四个部分：</p><ul>\n<li>日志级别，输出当前日志的级别信息。</li>\n<li>日志时间，输出当前日志的打印时间。</li>\n<li>日志简要信息，输出当前日志的简要描述信息，一句话说明日志错误。</li>\n<li>日志上下文字段，输出当前日志的附带信息。这些字段代表日志打印的上下文。</li>\n</ul><p>比如这就是一个完整的日志信息：</p><pre><code class=\"language-plain\">[Info]&nbsp; 2021-09-22T00:04:21+08:00&nbsp; &nbsp; &nbsp; &nbsp;\"demo test error\"&nbsp; &nbsp; &nbsp; &nbsp;map[api:demo/demo cspan_id: parent_id: span_id:c55051d94815vbl56i2g trace_id:c55051d94815vbl56i20 user:jianfengye]\n</code></pre><p>上面那条日志，日志级别为Info，时间为2021-09-21年15:40:03，时区为+08:00。简要信息demo test error 表示这个日志希望打印的信息，剩下的map表示的key、value为补充的日志上下文字段。</p><p>它对应的调用函数如下：</p><pre><code class=\"language-go\">logger.Info(c, \"demo test error\", map[string]interface{}{\n   \"api\":  \"demo/demo\",\n   \"user\": \"jianfengye\",\n})\n</code></pre><p>这里我额外说一下日志上下文字段。它是一个map值，来源可能有两个：一个是用户在打印日志的时候传递的map，比如上面代码中的api和user；而另外一部分数据是可能来自context，因为在具体业务开发中，我们很有可能把一些通用信息，比如trace_id等放在context里，这一部分信息也会希望取出放在日志的上下文字段中。</p><p>所以这里有一个从context中获取日志上下文字段的方法。在framework/contract/log.go中定义其为CtxFielder。</p><pre><code class=\"language-go\">// CtxFielder 定义了从context中获取信息的方法\ntype CtxFielder func(ctx context.Context) map[string]interface{}\n</code></pre><p>明确了打印哪些信息，更要明确这些信息按照什么输出格式输出。这个输出格式也是一个通用方法Fomatter，它的传入参数就是刚才的四个日志信息。</p><pre><code class=\"language-go\">// Formatter 定义了将日志信息组织成字符串的通用方法\ntype Formatter func(level LogLevel, t time.Time, msg string, fields map[string]interface{}) ([]byte, error)\n</code></pre><p>同时在log服务协议中增加了SetFormatter 和 SetCtxFielder的方法。</p><pre><code class=\"language-go\">// Log 定义了日志服务协议\ntype Log interface {\n   ...\n   // SetCtxFielder 从context中获取上下文字段field\n   SetCtxFielder(handler CtxFielder)\n   // SetFormatter 设置输出格式\n   SetFormatter(formatter Formatter)\n   ...\n}\n</code></pre><h3>日志输出</h3><p>已经解决了前两个问题，明确了日志的级别和输出格式，那日志可以输出在哪些地方？</p><p>其实我们在定义接口的时候，并不知道它会输出到哪里。但是只需要知道一定会输出到某个输出管道就可以了，之后在每个应用中使用的时候，我们再根据每个应用的配置，来确认具体的输出管道实现。</p><p>目前这个输出管道我们使用io.Writer来进行设置：</p><pre><code class=\"language-go\">// Log 定义了日志服务协议\ntype Log interface {\n   ...\n   // SetOutput 设置输出管道\n   SetOutput(out io.Writer)\n}\n</code></pre><h2>日志服务提供者</h2><p>日志接口协议文件就完成了，下面来实现日志的服务提供者，在framework/provider/log/provider.go中。</p><p>在编写服务提供者的时候，我们需要先明确最终会提供哪些服务。对于日志服务，按照我们平时的使用情况，可以分为四类：</p><ul>\n<li>控制台输出</li>\n<li>本地单个日志文件输出</li>\n<li>本地单个日志文件，自动进行切割输出</li>\n<li>自定义输出</li>\n</ul><p>这四种输出我们都各自定义一个服务，分别放在framework/provider/log/service/ 目录下的四个文件里：</p><ul>\n<li>console.go 表示控制台输出，定义初始化实例方法NewHadeConsoleLog；</li>\n<li>single.go 表述单个日志文件输出，定义初始化实例方法NewHadeSingleLog；</li>\n<li>rotate.go 表示单个文件输出，但是自动进行切割，定义初始化实例方法NewHadeRotateLog；</li>\n<li>custom.go 表示自定义输出，定义实例化方法NewHadeCustomLog。</li>\n</ul><p>那在服务提供者的Register注册服务实例方法中，我们设计成根据配置项“log.driver” ，来选择不同的实例化方法，默认为NewHadeConsoleLog 方法。</p><pre><code class=\"language-go\">// Register 注册一个服务实例\nfunc (l *HadeLogServiceProvider) Register(c framework.Container) framework.NewInstance {\n   if l.Driver == \"\" {\n      tcs, err := c.Make(contract.ConfigKey)\n      if err != nil {\n         // 默认使用console\n         return services.NewHadeConsoleLog\n      }\n      cs := tcs.(contract.Config)\n      l.Driver = strings.ToLower(cs.GetString(\"log.Driver\"))\n   }\n   // 根据driver的配置项确定\n   switch l.Driver {\n   case \"single\":\n      return services.NewHadeSingleLog\n   case \"rotate\":\n      return services.NewHadeRotateLog\n   case \"console\":\n      return services.NewHadeConsoleLog\n   case \"custom\":\n      return services.NewHadeCustomLog\n   default:\n      return services.NewHadeConsoleLog\n   }\n}\n</code></pre><p>而上一节里面分析的，日志的几个配置：日志级别、输出格式方法、context内容获取方法、输出方法，都以服务提供者provider.go 中参数的方式提供。</p><pre><code class=\"language-go\">// HadeLogServiceProvider 服务提供者\ntype HadeLogServiceProvider struct {\n   ...\n\n   // 日志级别\n   Level contract.LogLevel\n   // 日志输出格式方法\n   Formatter contract.Formatter\n   // 日志context上下文信息获取函数\n   CtxFielder contract.CtxFielder\n   // 日志输出信息\n   Output io.Writer\n}\n</code></pre><p>默认提供两种输出格式，一种是文本输出形式，比如上面举的那个例子，</p><pre><code class=\"language-plain\">[Info]&nbsp; 2021-09-22T00:04:21+08:00&nbsp; &nbsp; &nbsp; &nbsp;\"demo test error\"&nbsp; &nbsp; &nbsp; &nbsp;map[api:demo/demo cspan_id: parent_id: span_id:c55051d94815vbl56i2g trace_id:c55051d94815vbl56i20 user:jianfengye]\n</code></pre><p>另外一种是JSON输出形式，如下：</p><pre><code class=\"language-plain\">{\"api\":\"demo/demo\",\"cspan_id\":\"\",\"level\":5,\"msg\":\"demo1\",\"parent_id\":\"\",\"span_id\":\"c54v0tt9481537jasreg\",\"timestamp\":\"2021-09-21T22:47:19+08:00\",\"trace_id\":\"c54v0tt9481537jasre0\",\"user\":\"jianfengye\"}\n</code></pre><p>这两种输出除了格式不同，其中的内容应该是相同的。具体使用起来，文本输出更便于我们阅读，而JSON输出更便于机器或者程序阅读。</p><p>在实现文件夹framework/provider/log/formatter/ 里，我们增加两个文件json.go和text.go表示两种格式输出，对应的TextFormatter和JsonFormatter是对应的文本格式输出方法，</p><p>这里就贴出text.go的具体实现，很简单，其他的差别不大，可以参考<a href=\"https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go\">G</a><a href=\"https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go\">it</a><a href=\"https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go\">H</a><a href=\"https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/formatter/text.go\">ub</a>。</p><pre><code class=\"language-go\">// TextFormatter 表示文本格式输出\nfunc TextFormatter(level contract.LogLevel, t time.Time, msg string, fields map[string]interface{}) ([]byte, error) {\n   bf := bytes.NewBuffer([]byte{})\n   Separator := \"\\t\"\n\n   // 先输出日志级别\n   prefix := Prefix(level)\n\n   bf.WriteString(prefix)\n   bf.WriteString(Separator)\n\n   // 输出时间\n   ts := t.Format(time.RFC3339)\n   bf.WriteString(ts)\n   bf.WriteString(Separator)\n\n   // 输出msg\n   bf.WriteString(\"\\\"\")\n   bf.WriteString(msg)\n   bf.WriteString(\"\\\"\")\n   bf.WriteString(Separator)\n\n   // 输出map\n   bf.WriteString(fmt.Sprint(fields))\n   return bf.Bytes(), nil\n}\n</code></pre><p>再回到 framework/provider/log/provider.go，定义服务提供者的Params方法。比如获取格式化方法Formatter，我们就设定成，先判断在初始化的时候，是否定义了服务提供者；如果没有，再判断配置项log.formatter是否指定了格式化方法 json/text，设置最终的Formatter，并且传递实例化的方法。</p><pre><code class=\"language-go\">// Params 定义要传递给实例化方法的参数\nfunc (l *HadeLogServiceProvider) Params(c framework.Container) []interface{} {\n   // 获取configService\n   configService := c.MustMake(contract.ConfigKey).(contract.Config)\n\n   // 设置参数formatter\n   if l.Formatter == nil {\n      l.Formatter = formatter.TextFormatter\n      if configService.IsExist(\"log.formatter\") {\n         v := configService.GetString(\"log.formatter\")\n         if v == \"json\" {\n            l.Formatter = formatter.JsonFormatter\n         } else if v == \"text\" {\n            l.Formatter = formatter.TextFormatter\n         }\n      }\n   }\n\n   if l.Level == contract.UnknownLevel {\n      l.Level = contract.InfoLevel\n      if configService.IsExist(\"log.level\") {\n         l.Level = logLevel(configService.GetString(\"log.level\"))\n      }\n   }\n\n   // 定义5个参数\n   return []interface{}{c, l.Level, l.CtxFielder, l.Formatter, l.Output}\n}\n</code></pre><p>至于日志服务提供者的其他几个方法（Register、Boot、IsDefer、Name），就不在这里说明了，可以参考<a href=\"https://github.com/gohade/coredemo/blob/geekbang/17/framework/provider/log/provider.go\">GitHub</a>上的代码。</p><h2>日志服务的具体实现</h2><p>最后就到具体的日志服务的实现了。上面我们说，针对四种不同的输出方式，定义了四个不同的服务实例，<strong>这四个不同的服务实例都需要实现前面定义的日志服务协议。如果每个实例都实现一遍，还是非常麻烦的。这里可以使用一个技巧：类型嵌套</strong>。</p><p>我们先创建一个通用的服务实例HadeLog，在HadeLog中存放通用的字段，比如上述日志服务提供者传递的五个参数：container、level、ctxFielder、formatter、output。</p><p>在 provider/log/services/log.go中定义这个结构：</p><pre><code class=\"language-go\">// HadeLog 的通用实例\ntype HadeLog struct {\n   // 五个必要参数\n   level      contract.LogLevel   // 日志级别\n   formatter  contract.Formatter  // 日志格式化方法\n   ctxFielder contract.CtxFielder // ctx获取上下文字段\n   output     io.Writer           // 输出\n   c          framework.Container // 容器\n}\n</code></pre><p>接着在通用实例中，使用这几个必要的参数，就能实现日志协议的所有接口了，这里展示了Info方法是怎么打印信息的：</p><pre><code class=\"language-go\">// Info 会打印出普通的日志信息\nfunc (log *HadeLog) Info(ctx context.Context, msg string, fields map[string]interface{}) {\n   log.logf(contract.InfoLevel, ctx, msg, fields)\n}\n\n// logf 为打印日志的核心函数\nfunc (log *HadeLog) logf(level contract.LogLevel, ctx context.Context, msg string, fields map[string]interface{}) error {\n   // 先判断日志级别\n   if !log.IsLevelEnable(level) {\n      return nil\n   }\n\n   // 使用ctxFielder 获取context中的信息\n   fs := fields\n   if log.ctxFielder != nil {\n      t := log.ctxFielder(ctx)\n      if t != nil {\n         for k, v := range t {\n            fs[k] = v\n         }\n      }\n   }\n\n   ...\n\n   // 将日志信息按照formatter序列化为字符串\n   if log.formatter == nil {\n      log.formatter = formatter.TextFormatter\n   }\n   ct, err := log.formatter(level, time.Now(), msg, fs)\n   if err != nil {\n      return err\n   }\n\n   // 如果是panic级别，则使用log进行panic\n   if level == contract.PanicLevel {\n      pkgLog.Panicln(string(ct))\n      return nil\n   }\n\n   // 通过output进行输出\n   log.output.Write(ct)\n   log.output.Write([]byte(\"\\r\\n\"))\n   return nil\n}\n</code></pre><p>可以看到，Info打印最终调用logf 方法，而logf方法的实现步骤也很清晰，简单梳理一下：</p><ul>\n<li>先判断日志级别是否符合要求，如果不符合要求，则直接返回，不进行打印；</li>\n<li>再使用ctxFielder，从context中获取信息放在上下文字段中；</li>\n<li>接着将日志信息按照formatter序列化为字符串；</li>\n<li>最后通过output进行输出。</li>\n</ul><p>HadeLog其他方法的实现和Info大同小异，这里就不展示所有代码了。实现了基础的HadeLog实例，接下来，就实现对应的四个不同输出类型的实例HadeConsoleLog、HadeSingleLog、HadeRotateLog、HadeCustomLog。<br>\n<img src=\"https://static001.geekbang.org/resource/image/f2/a5/f2a9c4d54dyy468f00ce97f8888049a5.jpg?wh=1920x1080\" alt=\"\"></p><p>这里四个具体实例使用类型嵌套的方式，就能自动拥有HadeLog已经实现了的那些方法。</p><p>比如在 framework/provider/log/service/console.log 中，使用类型嵌套实现 HadeConsoleLog：</p><pre><code class=\"language-go\">// HadeConsoleLog 代表控制台输出\ntype HadeConsoleLog struct {\n   // 类型嵌套HadeLog\n   HadeLog\n}\n</code></pre><p>相当于 HadeConsoleLog 就已经实现了日志服务协议了。我们唯一要做的就是在实例化HadeConosoleLog的时候，将基础HadeLog中的通用字段进行填充。比如 HadeConsoleLog 最重要就是将输出类型output设置为控制台os.stdout：</p><pre><code class=\"language-go\">// NewHadeConsoleLog 实例化HadeConsoleLog\nfunc NewHadeConsoleLog(params ...interface{}) (interface{}, error) {\n   c := params[0].(framework.Container)\n   level := params[1].(contract.LogLevel)\n   ctxFielder := params[2].(contract.CtxFielder)\n   formatter := params[3].(contract.Formatter)\n\n   log := &amp;HadeConsoleLog{}\n\n   log.SetLevel(level)\n   log.SetCtxFielder(ctxFielder)\n   log.SetFormatter(formatter)\n\n   // 最重要的将内容输出到控制台\n   log.SetOutput(os.Stdout)\n   log.c = c\n   return log, nil\n}\n</code></pre><p>四种输出文件其实都大同小异，这里就挑选一个最复杂的带有日志切割的HadeRotateLog来讲解。</p><p>Golang中日志切割有个非常好用的 <a href=\"https://github.com/lestrrat-go/file-rotatelogs\">file-rotatelogs</a>，这个库的使用方法也不复杂，最核心的就是一个初始化操作New：</p><pre><code class=\"language-go\">func New(p string, options ...Option) (*RotateLogs, error) \n</code></pre><p>它有两个参数，第一个参数p是带目录的日志地址，可以允许有通配符代表日期的日志文件名。这里的通配符符合Linux的strftime的定义，具体哪个通配符代表日期、小时、分钟等可以参考strftime的<a href=\"https://man7.org/linux/man-pages/man3/strftime.3.html\">文档说明</a>。而第二个参数是Option数组，表示这个切割日志的一些配置，比如多久切割一次日志文件、切割后的日志文件保存多少天等。</p><p>使用很简单，直接看我们对HadeRotateLog的具体实现。大致思路就是<strong>先定义结构，再实现初始化方法，在初始化方法中，我们实例化file-rotatelogs的初始化操作New</strong>。</p><p>首先定义了 HadeRotateLog 的结构，其中嵌套了基础实例结构HadeLog，同时有这个结构特定的字段folder和file：</p><pre><code class=\"language-go\">// HadeRotateLog 代表会进行切割的日志文件存储\ntype HadeRotateLog struct {\n   HadeLog\n   // 日志文件存储目录\n   folder string\n   // 日志文件名\n   file string\n}\n</code></pre><p>实例化的NewHadeRotateLog 先获取参数，然后从配置文件中获取参数属性folder、file、date_format、rotate_count、rotate_size、max_age、rotate_time，这些属性都和 file-rotatelogs 库实例化的Option参数一一对应。</p><p>所以这里也展示一下我们的log.yaml配置文件可配置的rotate：</p><pre><code class=\"language-yaml\">driver: rotate # 切割日志\nlevel: trace # 日志级别\nfile: coredemo.log # 保存的日志文件\nrotate_count: 10  # 最多日志文件个数\nrotate_size: 120000 # 每个日志大小\nrotate_time: \"1m\" # 切割时间\nmax_age: \"10d\" # 文件保存时间\ndate_format: \"%Y-%m-%d-%H-%M\" # 文件后缀格式\n</code></pre><p>再回到 NewHadeRotateLog，设置了这些配置属性之后，我们实例化 file-rotatelogs，得到了一个符合io.Writer的输出，将这个输出使用 SetOutput 设置到嵌套的 HadeLog 中即可。</p><pre><code class=\"language-go\">// NewHadeRotateLog 实例化HadeRotateLog\nfunc NewHadeRotateLog(params ...interface{}) (interface{}, error) {\n   // 参数解析\n   c := params[0].(framework.Container)\n   level := params[1].(contract.LogLevel)\n   ctxFielder := params[2].(contract.CtxFielder)\n   formatter := params[3].(contract.Formatter)\n\n   appService := c.MustMake(contract.AppKey).(contract.App)\n   configService := c.MustMake(contract.ConfigKey).(contract.Config)\n\n   // 从配置文件中获取folder信息，否则使用默认的LogFolder文件夹\n   folder := appService.LogFolder()\n   if configService.IsExist(\"log.folder\") {\n      folder = configService.GetString(\"log.folder\")\n   }\n   // 如果folder不存在，则创建\n   if !util.Exists(folder) {\n      os.MkdirAll(folder, os.ModePerm)\n   }\n\n   // 从配置文件中获取file信息，否则使用默认的hade.log\n   file := \"hade.log\"\n   if configService.IsExist(\"log.file\") {\n      file = configService.GetString(\"log.file\")\n   }\n\n   // 从配置文件获取date_format信息\n   dateFormat := \"%Y%m%d%H\"\n   if configService.IsExist(\"log.date_format\") {\n      dateFormat = configService.GetString(\"log.date_format\")\n   }\n\n   linkName := rotatelogs.WithLinkName(filepath.Join(folder, file))\n   options := []rotatelogs.Option{linkName}\n\n   // 从配置文件获取rotate_count信息\n   if configService.IsExist(\"log.rotate_count\") {\n      rotateCount := configService.GetInt(\"log.rotate_count\")\n      options = append(options, rotatelogs.WithRotationCount(uint(rotateCount)))\n   }\n\n   // 从配置文件获取rotate_size信息\n   if configService.IsExist(\"log.rotate_size\") {\n      rotateSize := configService.GetInt(\"log.rotate_size\")\n      options = append(options, rotatelogs.WithRotationSize(int64(rotateSize)))\n   }\n\n   // 从配置文件获取max_age信息\n   if configService.IsExist(\"log.max_age\") {\n      if maxAgeParse, err := time.ParseDuration(configService.GetString(\"log.max_age\")); err == nil {\n         options = append(options, rotatelogs.WithMaxAge(maxAgeParse))\n      }\n   }\n\n   // 从配置文件获取rotate_time信息\n   if configService.IsExist(\"log.rotate_time\") {\n      if rotateTimeParse, err := time.ParseDuration(configService.GetString(\"log.rotate_time\")); err == nil {\n         options = append(options, rotatelogs.WithRotationTime(rotateTimeParse))\n      }\n   }\n\n   // 设置基础信息\n   log := &amp;HadeRotateLog{}\n   log.SetLevel(level)\n   log.SetCtxFielder(ctxFielder)\n   log.SetFormatter(formatter)\n   log.folder = folder\n   log.file = file\n\n   w, err := rotatelogs.New(fmt.Sprintf(\"%s.%s\", filepath.Join(log.folder, log.file), dateFormat), options...)\n   if err != nil {\n      return nil, errors.Wrap(err, \"new rotatelogs error\")\n   }\n   log.SetOutput(w)\n   log.c = c\n   return log, nil\n}\n</code></pre><p>本节课我们只是修改了框架目录中的日志服务相关的文件。文件目录：</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/a8/8c305493bba44f8787efecdf1a8694a8.png?wh=404x512\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/e7/2e/e78a3a67060e989616fa0440bd792d2e.png?wh=630x1122\" alt=\"图片\"></p><p>所有代码都放在GitHub上的 <a href=\"https://github.com/gohade/coredemo/tree/geekbang/17\">geekbang/17</a> 分支，欢迎比对查看。</p><h2>小结</h2><p>我们这节课通过定义了日志级别、日志格式、日志输出，来实现了日志的级别，并且使用类型嵌套方法实现了四种本地日志输出方式。</p><p>回顾今天实现的日志服务，你会发现和其他服务的实现思路是差不多的。我们<strong>在一个服务中，实现了多个实现类，但是所有的实现类都实现了同样的服务接口</strong>，最后能让我们根据配置来决定这个服务使用哪个实现类，其中还使用了嵌套方式，能节省大量重复性的代码。</p><p>希望你能熟练掌握这种实现方式，因为我们的服务会越来越多，越上层的服务，比如数据库、缓存，它的具体实现就越是多种多样，到时候我们都可以用同样的套路来进行。</p><h2>思考题</h2><p>在微服务盛行的今天，全链路日志是非常重要的一个需求。全链路日志的需求本质就是在日志中增加trace_id、span_id 这样的链路字段。具体实现有三点：</p><ul>\n<li>在接收请求的时候，从请求request中解析全链路字段，存放进入context中</li>\n<li>在打印日志的时候从context中获取全链路字段序列化进入日志</li>\n<li>在发送请求的时候将全链路字段加入到request中</li>\n</ul><p>你可以思考下这个功能应该怎么实现？</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果觉得有收获，也欢迎把今天的内容分享给你身边的朋友，邀他一起学习。我们下节课见。</p>","comments":[{"had_liked":false,"id":318109,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1635153612,"is_pvip":true,"replies":[{"id":"115338","content":"是的，一般是在中间件中解决","user_name":"作者回复","comment_id":318109,"uid":"1069186","ip_address":"","utype":1,"ctime":1635203612,"user_name_real":"叶剑峰"}],"discussion_count":3,"race_medal":0,"score":"10225088204","product_id":100090601,"comment_content":"接收下游请求和返回响应时打印日志可以在中间件中解决，向上游发送请求时打印日志可能需要框架提供一种方法截获请求并向其中注入trace信息，或者是自行封装一个http请求服务","like_count":2,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529107,"discussion_content":"是的，一般是在中间件中解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635203612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408379,"discussion_content":"中间件只能处理下游请求，调用上游服务在中间件里就处理不了了。比如下游请求传来的trace是1.2，调用上游服务时就需要传入trace如1.2.1, 1.2.2,...等，这样才能串起完整的调用链。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635238385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":537629,"discussion_content":"学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639124361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":408379,"ip_address":""},"score":537629,"extra":""}]}]},{"had_liked":false,"id":341433,"user_name":"Charles","can_delete":false,"product_type":"c1","uid":2559238,"ip_address":"","ucode":"8ACBA423B5A505","user_header":"https://static001.geekbang.org/account/avatar/00/27/0d/06/970cc957.jpg","comment_is_top":false,"comment_ctime":1649602834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649602834","product_id":100090601,"comment_content":"日志输出的原理讲的很细，受益匪浅。用作者的源码切换日志输出类型咋没有效果","like_count":0},{"had_liked":false,"id":335703,"user_name":"Geek_78dacc","can_delete":false,"product_type":"c1","uid":2450981,"ip_address":"","ucode":"152D20866EC554","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo0z990grziaq7U71fqERjUBGPYVxns2yTCVicYClEK2BicmZYVnQ3w8iaAiaYHacLZtSpibrRfjQy0ZsQg/132","comment_is_top":false,"comment_ctime":1645636288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645636288","product_id":100090601,"comment_content":"将log.SetOutput设置为文件，程序中正常的info，debug日志都可以记录至该文件中。但是当程序出现panic时，却不能记录panic日志。请问这个是为什么呀？除了在每次go func（）时，手动捕捉panic并显式打印日志外，还有什么更加优雅的解决方案吗？","like_count":0},{"had_liked":false,"id":335469,"user_name":"chongsheng","can_delete":false,"product_type":"c1","uid":1368768,"ip_address":"","ucode":"859DF328FCA608","user_header":"https://static001.geekbang.org/account/avatar/00/14/e2/c0/e7a59706.jpg","comment_is_top":false,"comment_ctime":1645529096,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1645529096","product_id":100090601,"comment_content":"这块貌似没有实现配置热更新。常见的需求是日志级别的热更新","like_count":0,"discussions":[{"author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559729,"discussion_content":"是的。自己现实下也简单。配置文件监听那里，加个判断，日志级别发生变化，调用一下SetLogLevel，更新日志级别","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648895299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1718011,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/36/fb/b480f2ac.jpg","nickname":"人间理想","note":"","ucode":"0D6A4C402D7CBD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580768,"discussion_content":"学到了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658370002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":559729,"ip_address":""},"score":580768,"extra":""}]}]},{"had_liked":false,"id":330642,"user_name":"牛玉富","can_delete":false,"product_type":"c1","uid":1231623,"ip_address":"","ucode":"DD962676F8FAF6","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/07/482b7155.jpg","comment_is_top":false,"comment_ctime":1642081954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642081954","product_id":100090601,"comment_content":"定制化的日志功能就得像这样，把每个细节都展开梳理清了才能动手。对日志感触挺深的是调用了个第三方类库修改麻烦至极。索性最后自己实现了。","like_count":0}]}