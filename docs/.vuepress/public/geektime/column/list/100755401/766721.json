{"id":766721,"title":"17｜如何与LLM结对编程？","content":"<p>你好，我是徐昊，今天我们来继续学习AI时代的软件工程。</p><p>上节课，我们系统性地介绍了使用大语言模型（Large Language Model，LLM）辅助软件开发的思路，也就是遵从测试驱动开发（Test Driven Development，TDD）的节奏，并与LLM结对编程（Pair Programming）完成需求。</p><p>那么，让我们使用这个思路，重新做一遍第15节课的例子，看看这一次有什么不一样。需求和之前是一样的：</p><blockquote>\n<p>我们中的大多数人都不得不时不时地解析一下命令行参数。如果我们没有一个方便的工具，那么我们就简单地处理一下传入main函数的字符串数组。有很多开源工具可以完成这个任务，但它们可能并不能完全满足我们的要求。所以我们再写一个吧。<br>\n&nbsp;<br>\n传递给程序的参数由标志和值组成。标志应该是一个字符，前面有一个减号。每个标志都应该有零个或多个与之相关的值。例如：<br>\n&nbsp;<br>\n-l -p 8080 -d /usr/logs<br>\n&nbsp;<br>\n“l”（日志）没有相关的值，它是一个布尔标志，如果存在则为true，不存在则为false。“p”（端口）有一个整数值，“d”（目录）有一个字符串值。标志后面如果存在多个值，则该标志表示一个列表：<br>\n&nbsp;<br>\n-g this is a list -d 1 2 -3 5<br>\n&nbsp;<br>\n“g” 表示一个字符串列表[“this”, “is”, “a”, “list”]，\"d\"标志表示一个整数列表[1, 2, -3, 5]。<br>\n&nbsp;<br>\n如果参数中没有指定某个标志，那么解析器应该指定一个默认值。例如，false代表布尔值，0代表数字， <code>\"\"</code> 代表字符串，[]代表列表。如果给出的参数与模式不匹配，重要的是给出一个好的错误信息，准确地解释什么是错误的。<br>\n&nbsp;<br>\n确保你的代码是可扩展的，即如何增加新的数值类型是直接和明显的。</p>\n</blockquote><!-- [[[read_end]]] --><h2>测试先行</h2><p>这次做的时候我们会有一些不一样的地方。按照我们<a href=\"https://time.geekbang.org/column/article/766281\">上节课</a>讲的内容，首先要做的是明确架构和测试策略，然后进行任务分解。目前的需求非常简单，我们知道这是一个单体的应用，最简单的做法就是使用一个类完成所有的功能。需要的测试也就是对于这个类的功能测试。因而，我们目前的任务分解主要围绕功能需求进行。</p><p>通过如下的模板，我们可以使用LLM帮助我们分解任务：</p><blockquote>\n<p>功能需求<br>\n====<br>\n{requirement}<br>\n&nbsp;<br>\n任务<br>\n====<br>\n请根据上面的功能需求，列出需要测试的场景。描述场景，并给出相关的测试数据。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/2d/ec/2d739a4c3ae67615fd44f1be6be8deec.jpg?wh=2020x3333\" alt=\"\"><br>\n简单阅读GPT的返回结果，我们就能发现几个错误：</p><ol>\n<li>场景中存在大量的重复覆盖，比如2、4、6实际测试的是同样的场景。</li>\n<li>场景8实际不可测试，而且LLM在理解题目的时候，认为 “-l -p -d -g” 是唯一需要支持的参数，而不是通过配置可以扩展的设计。这就完全误解了题目的意思。</li>\n</ol><p>对比我们第一次使用LLM直接生成代码的情况，就会发现这些对于需求的误解是一直存在的，只不过第一次LLM生成的是生产代码，而这一次我们让它生产了测试列表。也就是说，<strong>LLM从需求中提取到的知识是相同的。这些知识会被LLM应用到不同的场景中去</strong>。<strong>不正确的生产代码和不正确的测试列表，是同一份知识的不同表现形式</strong>。</p><p>但是这里有个关键差别：<strong>以自然语言产生的测试/任务列表，我们更容易发现错误，并提出反馈。而以代码形式表示的功能代码，我们却很难在第一时间发现错误。</strong>因此我们就更需要在更早的时候提出反馈，避免错误的累积。</p><p>目前最重要的问题是，LLM认为 “-l -p -d -g” 是必需的参数，而不是通过可以配置的设计。我们首先要反馈调整这个问题：</p><blockquote>\n<p>需求中的-l -p -d -g 是例子，并不是必须支持的参数。参数是可配置，可扩展的。比如，用户配置了-x为int类型，那么就可以通过-x 100 指定。如果用户没有配置-p为int类型，那么-p就是非法参数。请按照这个补充，列出需要测试的场景。描述场景，并给出相关的测试数据。</p>\n</blockquote><p>GPT给出的结果如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/34/3da905eb5cb57e33b05fe245a0d7df34.jpg?wh=2000x3369\" alt=\"\"></p><p>这一次明显比之前的理解好了很多。虽然测试间仍然存在重复的情况，以及场景4这个更复杂的情况，处理得过于简单了，但是这些并不影响我们目前的操作。</p><p>接下来，我们可以让LLM帮助我们生产测试代码：</p><blockquote>\n<p>请不要考虑custom type的情况，测试的场景生成junit junpiter测试。<br>\n要求：</p>\n<ul>\n<li>每个场景对应一个测试方法。</li>\n<li>被测试的类叫ArgumentParser。它的构造函数接受Map&lt;String, ArgumentType&gt;作为参数配置；</li>\n<li>ArgumentParser的parse方法返回Map&lt;String, Object&gt;作为解析结果；</li>\n<li>验证时，通过从Map中获取对应参数值，完成验证</li>\n</ul>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/af/e0/af705c7407ec7c71050908e3e58afbe0.jpg?wh=2000x377\" alt=\"\"></p><pre><code class=\"language-plain\">import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ArgumentParserTest {\n\n&nbsp; &nbsp; private ArgumentParser parser;\n\n&nbsp; &nbsp; @BeforeEach\n&nbsp; &nbsp; void setUp() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 在每个测试前初始化解析器\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, ArgumentType&gt; config = new HashMap&lt;&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; config.put(\"-l\", ArgumentType.BOOLEAN);\n&nbsp; &nbsp; &nbsp; &nbsp; config.put(\"-p\", ArgumentType.INTEGER);\n&nbsp; &nbsp; &nbsp; &nbsp; config.put(\"-d\", ArgumentType.STRING);\n&nbsp; &nbsp; &nbsp; &nbsp; config.put(\"-g\", ArgumentType.STRING_LIST);\n&nbsp; &nbsp; &nbsp; &nbsp; parser = new ArgumentParser(config);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testBooleanFlag() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试布尔标志\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-l\";\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, Object&gt; result = parser.parse(input);\n&nbsp; &nbsp; &nbsp; &nbsp; assertTrue((Boolean) result.get(\"-l\"));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testIntegerValue() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试整数值\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-p 8080\";\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, Object&gt; result = parser.parse(input);\n&nbsp; &nbsp; &nbsp; &nbsp; assertEquals(8080, result.get(\"-p\"));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testStringValue() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试字符串值\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-d /usr/logs\";\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, Object&gt; result = parser.parse(input);\n&nbsp; &nbsp; &nbsp; &nbsp; assertEquals(\"/usr/logs\", result.get(\"-d\"));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testStringListValue() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试字符串列表值\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-g this is a list\";\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, Object&gt; result = parser.parse(input);\n&nbsp; &nbsp; &nbsp; &nbsp; assertArrayEquals(new String[]{\"this\", \"is\", \"a\", \"list\"}, ((Object[]) result.get(\"-g\")));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testDefaultValues() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试默认值\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-l -p -d\";\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, Object&gt; result = parser.parse(input);\n&nbsp; &nbsp; &nbsp; &nbsp; assertTrue((Boolean) result.get(\"-l\"));\n&nbsp; &nbsp; &nbsp; &nbsp; assertEquals(0, result.get(\"-p\"));\n&nbsp; &nbsp; &nbsp; &nbsp; assertEquals(\"\", result.get(\"-d\"));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testMixedParameters() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试混合参数\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-l -p 8080 -d /usr/logs -g this is a list\";\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, Object&gt; result = parser.parse(input);\n&nbsp; &nbsp; &nbsp; &nbsp; assertTrue((Boolean) result.get(\"-l\"));\n&nbsp; &nbsp; &nbsp; &nbsp; assertEquals(8080, result.get(\"-p\"));\n&nbsp; &nbsp; &nbsp; &nbsp; assertEquals(\"/usr/logs\", result.get(\"-d\"));\n&nbsp; &nbsp; &nbsp; &nbsp; assertArrayEquals(new String[]{\"this\", \"is\", \"a\", \"list\"}, ((Object[]) result.get(\"-g\")));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testIllegalValue() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试非法值\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-p not_an_integer\";\n&nbsp; &nbsp; &nbsp; &nbsp; assertThrows(IllegalValueException.class, () -&gt; parser.parse(input));\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; @Test\n&nbsp; &nbsp; void testUnconfiguredParameter() {\n&nbsp; &nbsp; &nbsp; &nbsp; // 测试未配置参数\n&nbsp; &nbsp; &nbsp; &nbsp; String input = \"-x custom_value\";\n&nbsp; &nbsp; &nbsp; &nbsp; assertThrows(UnconfiguredParameterException.class, () -&gt; parser.parse(input));\n&nbsp; &nbsp; }\n}\n\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/7e/f7/7e5116b12635c78b0000e653b39cf8f7.jpg?wh=2000x397\" alt=\"\"></p><h2>生成生产代码</h2><p>不得不说，虽然与LLM给出的测试场景不太相关，但是LLM给出的测试代码质量还是非常不错的。那么，接下来我们就可以生成生产代码了。</p><blockquote>\n<p>请按照需求，生成ArgumentParser以及相关类，可以通过这组测试。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/5f/09/5fb01221bda2ab538007de6bfe3d0009.jpg?wh=2000x429\" alt=\"\"></p><pre><code class=\"language-plain\">import java.util.HashMap;\nimport java.util.Map;\npublic class ArgumentParser {\n    private Map&lt;String, ArgumentType&gt; config;\n    public ArgumentParser(Map&lt;String, ArgumentType&gt; config) {\n        this.config = config;\n    }\n    public Map&lt;String, Object&gt; parse(String input) {\n        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();\n        String[] tokens = input.split(\"\\\\s+\");\n        for (int i = 0; i &lt; tokens.length; i++) {\n            String token = tokens[i];\n            if (config.containsKey(token)) {\n                ArgumentType type = config.get(token);\n                switch (type) {\n                    case BOOLEAN:\n                        result.put(token, true);\n                        break;\n                    case INTEGER:\n                        i++;\n                        try {\n                            result.put(token, Integer.parseInt(tokens[i]));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalValueException(\"Illegal value for parameter: \" + tokens[i - 1]);\n                        }\n                        break;\n                    case STRING:\n                        i++;\n                        result.put(token, tokens[i]);\n                        break;\n                    case STRING_LIST:\n                        i++;\n                        result.put(token, tokens[i].split(\" \"));\n                        break;\n                    default:\n                        // Handle custom types if needed\n                        break;\n                }\n            } else {\n                throw new UnconfiguredParameterException(\"Unconfigured parameter: \" + token);\n            }\n        }\n        return result;\n    }\n}\nenum ArgumentType {\n    BOOLEAN,\n    INTEGER,\n    STRING,\n    STRING_LIST,\n    CUSTOM_TYPE // Add more types as needed\n}\nclass IllegalParameterException extends RuntimeException {\n    public IllegalParameterException(String message) {\n        super(message);\n    }\n}\nclass IllegalValueException extends RuntimeException {\n    public IllegalValueException(String message) {\n        super(message);\n    }\n}\nclass UnconfiguredParameterException extends RuntimeException {\n    public UnconfiguredParameterException(String message) {\n        super(message);\n    }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/08/3f/08e0a06ec28bdb89f8c4e4c4b876313f.jpg?wh=2000x385\" alt=\"\"></p><p>那么接下来，让我们跑一下测试看看结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/42/1dcd21a520489c0dfd5bf5b867d23b42.jpg?wh=2896x2062\" alt=\"\"></p><p>一共8个测试，通过了5个失败了3个。其中比较重要的是testStringListValue，错误信息是这样的：</p><pre><code class=\"language-plain\">@Test\nvoid testStringListValue() {\n    // 测试字符串列表值\n    String input = \"-g this is a list\";\n    Map&lt;String, Object&gt; result = parser.parse(input);\n    assertArrayEquals(new String[]{\"this\", \"is\", \"a\", \"list\"}, ((Object[]) result.get(\"-g\")));\n}\n</code></pre><blockquote>\n<p>UnconfiguredParameterException: Unconfigured parameter: is<br>\nat ArgumentParser.parse(ArgumentParser.java:45)<br>\nat ArgumentParserTest.testStringListValue(ArgumentParserTest.java:51)<br>\nat java.base/java.lang.reflect.Method.invoke(Method.java:580)<br>\nat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)<br>\nat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)</p>\n</blockquote><p>也就是说，目前代码中只能处理单值的情况，并不能处理多值的情况。那么我们可以让LLM帮助我们修改：</p><blockquote>\n<p>执行测试的错误信息如下，请根据错误信息，修改ArgumentParse的代码：<br>\n&nbsp;<br>\nUnconfiguredParameterException: Unconfigured parameter: is<br>\nat ArgumentParser.parse(ArgumentParser.java:45)<br>\nat ArgumentParserTest.testStringListValue(ArgumentParserTest.java:51)<br>\nat java.base/java.lang.reflect.Method.invoke(Method.java:580)<br>\nat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)<br>\nat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/c5/yb/c582b3404d4b50c40cb7b6b3a15c4yyb.jpg?wh=2000x2090\" alt=\"\"></p><p>此时需要注意，ChatGPT尝试通过修改测试的方式蒙混过关。我们需要坚守目前<strong>生产代码领航员的角色</strong>，对GPT作出要求：</p><blockquote>\n<p>不是测试的问题，请修改ArgumentParser的逻辑</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/96/ce/9689f38156315f2811c9ab1fc2141dce.jpg?wh=2000x389\" alt=\"\"></p><pre><code class=\"language-plain\">public class ArgumentParser {\n    private Map&lt;String, ArgumentType&gt; config;\n    public ArgumentParser(Map&lt;String, ArgumentType&gt; config) {\n        this.config = config;\n    }\n    public Map&lt;String, Object&gt; parse(String input) {\n        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();\n        String[] tokens = input.split(\"\\\\s+\");\n        for (int i = 0; i &lt; tokens.length; i++) {\n            String token = tokens[i];\n            if (config.containsKey(token)) {\n                ArgumentType type = config.get(token);\n                switch (type) {\n                    case BOOLEAN:\n                        result.put(token, true);\n                        break;\n                    case INTEGER:\n                        i++;\n                        try {\n                            result.put(token, Integer.parseInt(tokens[i]));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalValueException(\"Illegal value for parameter: \" + tokens[i - 1]);\n                        }\n                        break;\n                    case STRING:\n                        i++;\n                        result.put(token, tokens[i]);\n                        break;\n                    case STRING_LIST:\n                        i++;\n                        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();\n                        while (i &lt; tokens.length &amp;&amp; !tokens[i].startsWith(\"-\")) {\n                            stringList.add(tokens[i]);\n                            i++;\n                        }\n                        result.put(token, stringList.toArray(new String[0]));\n                        i--;  // Decrement to correctly process the next token in the loop\n                        break;\n                    default:\n                        // Handle custom types if needed\n                        break;\n                }\n            } else {\n                throw new UnconfiguredParameterException(\"Unconfigured parameter: \" + token);\n            }\n        }\n        return result;\n    }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/eb/78/eb72cd139988702fbe5dede0e65dab78.jpg?wh=2000x392\" alt=\"\"></p><p>我们再次运行测试：</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/61/c77183a21d50d0958bc652ac7a5fd061.jpg?wh=2928x2045\" alt=\"\"></p><p>就这时我们会发现只剩了一个没有通过的测试。而仔细查看会发现这个测试构造有问题。我们也不需要通过LLM再次修改了。自己直接改掉就行：</p><pre><code class=\"language-plain\">@Test\nvoid testDefaultValues() {\n    // 测试默认值\n    String input = \"\";\n    Map&lt;String, Object&gt; result = parser.parse(input);\n    assertFalse((Boolean) result.get(\"-l\"));\n    assertEquals(0, result.get(\"-p\"));\n    assertEquals(\"\", result.get(\"-d\"));\n}\n</code></pre><p>再次执行，仍然失败，这时候我们发现代码中并没有对于默认值的处理。反馈给LLM：</p><blockquote>\n<p>目前代码中没有对于默认值的处理，请求改变ArgumentParser的逻辑，让它能够通过下面的测试：<br>\n&nbsp;<br>\n@Test<br>\nvoid testDefaultValues() {<br>\n&nbsp; &nbsp; // 测试默认值<br>\n&nbsp; &nbsp; String input = “”;<br>\n&nbsp; &nbsp; Map&lt;String, Object&gt; result = parser.parse(input);<br>\n&nbsp; &nbsp; assertFalse((Boolean) result.get(“-l”));<br>\n&nbsp; &nbsp; assertEquals(0, result.get(“-p”));<br>\n&nbsp; &nbsp; assertEquals(“”, result.get(“-d”));<br>\n}</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/e9/72/e9d947c9afd5516f711e92dfd8ded472.jpg?wh=2000x391\" alt=\"\"></p><pre><code class=\"language-plain\">public class ArgumentParser {\n    private Map&lt;String, ArgumentType&gt; config;\n    public ArgumentParser(Map&lt;String, ArgumentType&gt; config) {\n        this.config = config;\n    }\n    public Map&lt;String, Object&gt; parse(String input) {\n        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();\n        String[] tokens = input.split(\"\\\\s+\");\n        if (tokens.length == 1 &amp;&amp; tokens[0].isEmpty()) {\n            // Handle empty input\n            setDefaultValues(result);\n            return result;\n        }\n        for (int i = 0; i &lt; tokens.length; i++) {\n            String token = tokens[i];\n            if (config.containsKey(token)) {\n                ArgumentType type = config.get(token);\n                switch (type) {\n                    case BOOLEAN:\n                        result.put(token, true);\n                        break;\n                    case INTEGER:\n                        i++;\n                        try {\n                            result.put(token, Integer.parseInt(tokens[i]));\n                        } catch (NumberFormatException e) {\n                            throw new IllegalValueException(\"Illegal value for parameter: \" + tokens[i - 1]);\n                        }\n                        break;\n                    case STRING:\n                        i++;\n                        result.put(token, tokens[i]);\n                        break;\n                    case STRING_LIST:\n                        i++;\n                        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();\n                        while (i &lt; tokens.length &amp;&amp; !tokens[i].startsWith(\"-\")) {\n                            stringList.add(tokens[i]);\n                            i++;\n                        }\n                        result.put(token, stringList.toArray(new String[0]));\n                        i--;  // Decrement to correctly process the next token in the loop\n                        break;\n                    default:\n                        // Handle custom types if needed\n                        break;\n                }\n            } else {\n                throw new UnconfiguredParameterException(\"Unconfigured parameter: \" + token);\n            }\n        }\n        return result;\n    }\n    private void setDefaultValues(Map&lt;String, Object&gt; result) {\n        for (Map.Entry&lt;String, ArgumentType&gt; entry : config.entrySet()) {\n            String param = entry.getKey();\n            ArgumentType type = entry.getValue();\n            if (!result.containsKey(param)) {\n                switch (type) {\n                    case BOOLEAN:\n                        result.put(param, false);\n                        break;\n                    case INTEGER:\n                        result.put(param, 0);\n                        break;\n                    case STRING:\n                        result.put(param, \"\");\n                        break;\n                    case STRING_LIST:\n                        result.put(param, new String[0]);\n                        break;\n                    default:\n                        // Handle custom types if needed\n                        break;\n                }\n            }\n        }\n    }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/14/53/1430f70db5716410a4bae76e0c335c53.jpg?wh=2000x399\" alt=\"\"></p><p>现在我们再来跑一次测试，结果如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/be/b7605094fca653c2a429c727dbb29cbe.jpg?wh=2917x2079\" alt=\"\"></p><h2>小结</h2><p>到此为止，我们基本上完成了这个功能。对比第一次实现这个功能，我们迭代的次数更少，完成的过程中更有把握，严重的设计问题在早期就得到了重视。</p><p>我们做出的改变有这么几个：</p><ul>\n<li>通过测试列表，更加关注与LLM对齐对于知识的理解；</li>\n<li>以测试驱动的方式，遵守“红-绿-重构”的节奏；</li>\n<li>按照“导航员-司机”的模式与LLM结对。</li>\n</ul><p>这些改变让我们在获得速度提升的时候，保证了代码的质量，得到了真正的效率提升。</p><h2>思考题</h2><p>请总结在这个过程中，我们使用了哪些认知行为模式。</p><p>欢迎你在留言区分享自己的思考或疑惑，我们会把精彩内容置顶供大家学习讨论。</p>","neighbors":{"left":{"article_title":"16｜任务划分与测试驱动AI开发","id":766281},"right":{"article_title":"18｜测试策略（一）：如何构造有效的测试策略？","id":767358}},"comments":[{"had_liked":false,"id":389639,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"北京","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1713146260,"is_pvip":true,"replies":[{"id":141764,"content":"就是测试列表","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1713163684,"ip_address":"浙江","comment_id":389639,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"我一直有一个疑问，到底是任务列表？还是测试列表？\n\n还是先根据软件架构和测试策略将需求切到足够小，形成任务列表，在针对任务列表中的每个任务写出测试，从而形成测试列表。\n\n之前提到过用户故事及验收条件，用户故事需要根据软件架构和测试策略再切分吗？验收条件，是不是就是测试列表或者测试列表的一部分？\n\n后面会有复杂点的例子，介绍需求如何从用户故事，到被不同软件架构，测试策略组合影响，从而导出不同的任务列表，进而导出测试列列表的过程吗？","like_count":2,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641941,"discussion_content":"就是测试列表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713163685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","nickname":"范飞扬","note":"","ucode":"A665DF46833A81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642781,"discussion_content":"问的好，我解释一下老师的回复，摘自《Test Driven》\n\n\nTo clarify the difference between tasks and tests, table 2.1 contrasts a few of thepossible decompositions of the mail-template subsystem into tasks and tests,respectively. Decomposing into tasks (left-hand column) leads to items that donot represent progress in terms of produced software. Contrast this with the right-hand column of tests, which have a clear connection to capabilities of the pro-duced software.\n\n\n\ntask:\nWrite a regular expression for identifying variables from the template.\n\ntest:\nTemplate with one variable is rendered with the variable replaced with its value.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1713798297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389637,"user_name":"起个名称吧","can_delete":false,"product_type":"c1","uid":3845303,"ip_address":"陕西","ucode":"47B29E84D0926A","user_header":"https://static001.geekbang.org/account/avatar/00/3a/ac/b7/92ebd0a5.jpg","comment_is_top":false,"comment_ctime":1713145679,"is_pvip":false,"replies":[{"id":141763,"content":"不需重构 重写就行","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1713163656,"ip_address":"浙江","comment_id":389637,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"我认为应该是庞杂+清晰\n庞杂的认知行为模式，从gpt给与的需求拆分的任务列表，我们和llm进行认知对齐，帮其弥补llm认知需求的差异，在该模式下我们根据对齐的任务列表生成测试代码和生产代码\n清晰的认知行为模式，根据测试代码执行进行测试来发现生产代码上的遗漏，发现错误,与llm进行交互调整生产代码，最终完成测试的通过。\n这里有两个疑问\n1. 假设根据测试代码执行发现未知的错误(此时无法与gpt进行交互)，我们也不理解改错误的信息，我们此时就需要debug一步步调试，此时我们本身又处于复杂模式下(探索-感知-响应)，而可以和llm交互后我们又处于清晰模式下(感知-分类-响应)。我们因为一个llm帮助我们的认知行为发生了两个重大的变更吗？\n2. TDD测试驱动,红-绿-重构，这节课里没看到重构循环,感觉缺少了点啥","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641940,"discussion_content":"不需重构 重写就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713163656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393337,"user_name":"FARO_Z","can_delete":false,"product_type":"c1","uid":2410092,"ip_address":"四川","ucode":"B33BCC36C2A74E","user_header":"https://static001.geekbang.org/account/avatar/00/24/c6/6c/a400175a.jpg","comment_is_top":false,"comment_ctime":1723542345,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"感觉 LLM 只能比较好的生成单点功能的代码，一般也就是工具类\n\n如果涉及到业务上下文，不是歇菜，就是要喂大量 promot 进行调校。有这功夫代码早写完了\n\n感觉目前 LLM 对于程序员最大的帮助在于阅读源码上面，对于已有内容 LLM 能作为一个很好的索引器，帮助快速理清代码上下文。至于很多业务驱动的工程，还是先不要动 LLM 提升工作效率的念头了吧","like_count":2},{"had_liked":false,"id":389674,"user_name":"范飞扬","can_delete":false,"product_type":"c1","uid":2721761,"ip_address":"广东","ucode":"A665DF46833A81","user_header":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","comment_is_top":false,"comment_ctime":1713239504,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"感谢老师，已经用到工作中了。\n目前我们只让GPT进行了需求分解。\n盲猜一波，接下来应该让gpt，不仅根据需求分解，还要根据架构，分解成功能上下文的任务项。\n\n再根据任务项，列出测试场景和测试数据。\n然后生成测试用例。\n最后生成代码。\n\n（这其中，我觉得还可以提供现有测试类的代码作为few shot，而且测试类也蕴含了SUT的API如何使用的信息）","like_count":2},{"had_liked":false,"id":389647,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1713166375,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"学习后收获了 2 个模版\n练习后获得经验：需要认真检查 AI 列出的测试场景，不然会出现奇怪的代码！\n\n实用的 AI 模版\n======\n\n列出测试场景\n----------------\n功能需求\n====\n{requirement}\n\n任务\n====\n请根据上面的功能需求，列出需要测试的场景。描述场景，并给出相关的测试数据。\n\n编写测试代码\n----------------\n请生成 junit junpiter 测试\n要求：\n每个场景对应一个测试方法\n使用 Kotlin 编写\n使用 TDD 中的 should style 编写测试\n\n详见 https:&#47;&#47;wyyl1.com&#47;post&#47;28&#47;17","like_count":1},{"had_liked":false,"id":390227,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1714808583,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"有个问题，那如何把 TDD 与 LLM 结合写业务代码呢？\n如果按照 16 节的内容，逻辑就是拆分一个业务功能的架构，比如 http 层、业务逻辑层、数据层\n然后对业务逻辑层写清楚诉求，然后跟 LLM 结队编程吗？运用本篇内容","like_count":0},{"had_liked":false,"id":389631,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1713135756,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"&#47;&#47; Question by EnigmaWU: generate could missing ut code for me\n&#47;&#47; Answer from ChatCopilot:\nTEST(CC_parseCmdLineArgs, LogSavingDir) {\n  CC_CmdLineArgs_T CmdLineArgs;\n  char *argv[] = {(char *)&quot;test&quot;, (char *)&quot;-d&quot;, (char *)&quot;&#47;path&#47;to&#47;log&quot;};\n  EXPECT_EQ(CC_SUCCESS, CC_parseCmdLineArgs(3, argv, &amp;CmdLineArgs));\n  EXPECT_FALSE(CmdLineArgs.IsLoggingEnabled);\n  EXPECT_EQ(0, CmdLineArgs.RecvPort);\n  EXPECT_STREQ(&quot;&#47;path&#47;to&#47;log&quot;, CmdLineArgs.pLogSavingDir);\n}\n\nTEST(CC_parseCmdLineArgs, InvalidArgs) {\n  CC_CmdLineArgs_T CmdLineArgs;\n  char *argv[] = {(char *)&quot;test&quot;, (char *)&quot;invalid&quot;};\n  EXPECT_EQ(CC_FAIL, CC_parseCmdLineArgs(2, argv, &amp;CmdLineArgs));\n}\n\nTEST(CC_parseCmdLineArgs, MissingValueForPort) {\n  CC_CmdLineArgs_T CmdLineArgs;\n  char *argv[] = {(char *)&quot;test&quot;, (char *)&quot;-p&quot;};\n  EXPECT_EQ(CC_FAIL, CC_parseCmdLineArgs(2, argv, &amp;CmdLineArgs));\n}\n\nTEST(CC_parseCmdLineArgs, MissingValueForDir) {\n  CC_CmdLineArgs_T CmdLineArgs;\n  char *argv[] = {(char *)&quot;test&quot;, (char *)&quot;-d&quot;};\n  EXPECT_EQ(CC_FAIL, CC_parseCmdLineArgs(2, argv, &amp;CmdLineArgs));\n}\n\nTEST(CC_parseCmdLineArgs, NonNumericPort) {\n  CC_CmdLineArgs_T CmdLineArgs;\n  char *argv[] = {(char *)&quot;test&quot;, (char *)&quot;-p&quot;, (char *)&quot;nonnumeric&quot;};\n  EXPECT_EQ(CC_FAIL, CC_parseCmdLineArgs(3, argv, &amp;CmdLineArgs));\n}\n\nTEST(CC_parseCmdLineArgs, MultipleSameArgs) {\n  CC_CmdLineArgs_T CmdLineArgs;\n  char *argv[] = {(char *)&quot;test&quot;, (char *)&quot;-l&quot;, (char *)&quot;-l&quot;};\n  EXPECT_EQ(CC_SUCCESS, CC_parseCmdLineArgs(3, argv, &amp;CmdLineArgs));\n  EXPECT_TRUE(CmdLineArgs.IsLoggingEnabled);\n}\n\nTEST(CC_parseCmdLineArgs, ArgsInDifferentOrder) {\n  CC_CmdLineArgs_T CmdLineArgs;\n  char *argv[] = {(char *)&quot;test&quot;, (char *)&quot;-p&quot;, (char *)&quot;1234&quot;, (char *)&quot;-l&quot;, (char *)&quot;-d&quot;, (char *)&quot;&#47;path&#47;to&#47;log&quot;};\n  EXPECT_EQ(CC_SUCCESS, CC_parseCmdLineArgs(6, argv, &amp;CmdLineArgs));\n  EXPECT_TRUE(CmdLineArgs.IsLoggingEnabled);\n  EXPECT_EQ(1234, CmdLineArgs.RecvPort);\n  EXPECT_STREQ(&quot;&#47;path&#47;to&#47;log&quot;, CmdLineArgs.pLogSavingDir);\n}","like_count":0},{"had_liked":false,"id":389630,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1713135698,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"&#47;&#47; Chat with Copilot, Question by EnigmaWU:\n&#47;&#47; #file:CC_parseCmdLineArgs.c #file:CC_parseCmdLineArgsTest_byCopilot.cxx\n&#47;&#47;      what UT already written and what UT is missed?\n\n&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;&#47;\n&#47;&#47; Answer from ChatCopilot:\n&#47;**\nThe unit tests that are already written for the CC_parseCmdLineArgs function in the CC_parseCmdLineArgsTest_byCopilot.cxx file\nare:\n\nNullCmdLineArgs: Tests the function with argc as 0 and argv as NULL.\nNullCmdLineArgsPtr: Tests the function with argc as 0, argv as NULL, and pCmdLineArgs as NULL.\nNoArgs: Tests the function with no command line arguments.\nLoggingEnabled: Tests the function with the logging enabled argument -l.\nRecvPort: Tests the function with the receive port argument -p and a value.\nLogSavingDir: Tests the function with the log saving directory argument -d and a value.\nAllArgs: Tests the function with all possible arguments.\nThe unit tests that are missing could be:\n\nInvalidArgs: Tests the function with invalid arguments that do not start with -.\nMissingValueForPort: Tests the function with the -p argument but without a value following it.\nMissingValueForDir: Tests the function with the -d argument but without a value following it.\nNonNumericPort: Tests the function with a non-numeric value for the -p argument.\nMultipleSameArgs: Tests the function with multiple instances of the same argument.\nArgsInDifferentOrder: Tests the function with all possible arguments in a different order.\n **&#47;","like_count":0}]}