{"id":670130,"title":"28｜认证机制：Flask认证机制设计与实现","content":"<p>你好，我是Barry。</p><p>上节课，我们初步了解了Flask认证机制，也完成了使用Token进行认证的前置工作。在我们的视频直播平台中，也需要通过认证机制来实现用户的平台认证和安全保障。</p><p>这节课，我们就进入项目实战环节，巩固一下你对Flask认证机制的应用能力。整体流程包括生成Token、Token验证、登录认证和用户鉴权这四个环节。</p><p>认证的第一步，我们就从生成Token开始说起。</p><h2>生成Token</h2><p><a href=\"https://time.geekbang.org/column/article/669871\">上节课</a>，我们学习过Token结构，它有三个部分，分别是header，playload和signature。</p><p>在项目中我们借助Flask的扩展Flask-JWT来生成Token，具体就是使用JWT.encode函数将JSON对象编码为JWT Token。因此，我们有必要了解一下JWT.encode函数的参数，你可以参考后面我画的思维导图。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/da/2b08510cae1b9446918329388223edda.jpg?wh=1900x922\" alt=\"\"></p><p>你或许注意到了，在JWT.encode函数中只传入了payload部分。这是因为在使用JWT.encode函数时，会自动根据默认算法生成Header部分，并将Header和Payload部分进行签名生成最终的Token字符串。我们需要手动指定Payload部分。</p><p>具体生成Token的实现代码是后面这样，你可以参考一下。</p><!-- [[[read_end]]] --><pre><code class=\"language-python\">import time\nimport datetime\nimport jwt\nfrom flask import current_app\nfrom api import redis_store\nfrom api.models.user import UserLogin\nfrom api.utils import constants\nfrom api.utils.response_utils import error, HttpCode, success\nfrom config.config import Config\nclass Auth(object):\n    @staticmethod\n    # 声明为静态方法\n    def encode_auth_token(user_id, login_time):\n        \"\"\"\n        生成认证Token\n        :param user_id: int\n        :param login_time: int(timestamp)\n        :return: string\n        \"\"\"\n        try:\n            payload = {\n                'exp': datetime.datetime.utcnow() + datetime.timedelta(days=1),\n                'iat': datetime.datetime.utcnow(),\n                'iss': 'Barry',\n                'data': {\n                    'id': user_id,\n                    'login_time': login_time\n                }\n            }\n            return jwt.encode(\n                payload,\n                Config.SECRET_KEY,\n                algorithm='HS256'\n            )\n        except Exception as e:\n            print(e)\n            return error(code=HttpCode.auth_error, msg='没有生成对应的token')\n</code></pre><p>接下来，我们一起来解读一下这段代码。函数前的@staticmethod装饰器，我们将该方法声明为静态方法，也就是类的方法可以直接调用，而不需要再创建该类的实例。</p><p>紧接着我们在encode_auth_token函数中传入两个参数，分别是用户的user_id和用户登录时间login_time，用户登录时间用于检查Token是否过期，保证时效性。然后是Token的有效负载payload，其中主要包括Token的过期时间、签发时间、发行人和自定义数据。在自定义数据中两个参数是用户ID和登录时间。</p><p>其中的payload为字典类型，以便作为参数传入encode函数中。这里使用Config.SECRET_KEY作为加密用的密钥，采用HS256算法对JWT进行加密。HS256算法是一种基于哈希函数的对称加密算法。如果生成过程出现异常，则返回一个错误消息。这里的auth_error是我们上节课自定义的HTTP状态函数。</p><h2>验证Token</h2><p>生成Token的下一步就是Token的验证。方法就是借助JWT扩展的decode函数，将客户端发送的Token进行解码。我们还是结合代码来理解。</p><pre><code class=\"language-python\">@staticmethod\ndef decode_auth_token(auth_token):\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 验证Token\n&nbsp; &nbsp; :param auth_token:\n&nbsp; &nbsp; :return: integer|string\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; # payload = jwt.decode(auth_token, Config.SECRET_KEY, leeway=datetime.timedelta(days=1))\n&nbsp; &nbsp; &nbsp; &nbsp; # 取消过期时间验证\n&nbsp; &nbsp; &nbsp; &nbsp; payload = jwt.decode(auth_token, Config.SECRET_KEY, options={'verify_exp': False})\n        # options，不要执行过期时间验证\n&nbsp; &nbsp; &nbsp; &nbsp; if 'data' in payload and 'id' in payload['data']:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return dict(code=HttpCode.ok, payload=payload)\n&nbsp; &nbsp; &nbsp; &nbsp; else:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; raise dict(code=HttpCode.auth_error, msg=jwt.InvalidTokenError)\n&nbsp; &nbsp; except jwt.ExpiredSignatureError:\n&nbsp; &nbsp; &nbsp; &nbsp; return dict(code=HttpCode.auth_error, msg='Token过期')\n&nbsp; &nbsp; except jwt.InvalidTokenError:\n&nbsp; &nbsp; &nbsp; &nbsp; return dict(code=HttpCode.auth_error, msg='无效Token')\n</code></pre><p>上面代码同样是一个静态方法，主要用于验证JWT token的有效性。首先从传入的auth_token参数中解码token，使用保存在配置文件中的SECRET_KEY来解码，options选项表示在验证token的过期时间时，不要执行过期时间验证。</p><p>随后要验证auth_token 中是否包含有效的数据，这里要分三种情况考虑。</p><ul>\n<li>如果包含有效数据，则返回一个字典，其中 code 为 HttpCode.ok，表示请求成功，payload 为解码后的数据。</li>\n<li>如果不包含有效数据或者解码失败，则抛出 InvalidTokenError，表示 Token 验证失败，并返回相应的错误信息。</li>\n<li>如果 auth_token 中包含有效数据但是 Token 已经过期，则抛出 ExpiredSignatureError，表示 Token 已经失效，并返回相应的错误信息。</li>\n</ul><p>虽然代码中取消了过期时间验证，但是在后面依旧会抛出 ExpiredSignatureError，提示Token过期，所以我们需要把异常处理情况涵盖得更全。</p><h2>登录认证</h2><p>搞定了生成Token和对Token认证的代码后，下一步，我们就需要对用户登录进行认证。登录认证成功即可给客户端返回Token，下次向服务端请求资源的时候，必须带着服务端签发的 Token，才能实现对用户信息的认证。</p><p>实现用户登录的代码是后面这样。</p><pre><code class=\"language-python\">def authenticate(self, mobile, password):\n    \"\"\"\n    用户登录，登录成功返回token，写将登录时间写入数据库；登录失败返回失败原因\n    :param password:\n    :return: json\n    \"\"\"\n    user = UserLogin.query.filter_by(mobile=mobile).first()\n    if not user:\n        return error(code=HttpCode.auth_error, msg='请求的用户不存在')\n    else:\n        if user.check_password(password):\n            login_time = int(time.time())\n            try:\n                user.last_login_stamp = login_time\n                user.last_login = datetime.datetime.now()\n                user.update()\n            except Exception as e:\n                current_app.logger.error(e)\n                return error(code=HttpCode.db_error, msg='登录时间查询失败')\n            token = self.encode_auth_token(user.user_id, login_time)  # bytes\n            token = str(token, encoding=\"utf-8\")\n            user_id = user.user_id\n            # 存储到redis中\n            try:\n                redis_store.set(\"jwt_token:%s\" % user_id, token, constants.JWT_TOKEN_REDIS_EXPIRES)\n            # 设置过期时间为常量JWT_TOKEN_REDIS_EXPIRES（86400秒，即24小时）\n            except Exception as e:\n                current_app.logger.error(e)\n                return error(code=HttpCode.db_error, msg=\"token保存redis失败\")\n            from api.modules.video.views import user_action_log\n            user_action_log.warning({\n                'user_id': user_id,\n                'url': '/passport/login',\n                'method': 'post',\n                'msg': 'login',\n                'event': 'login',\n            })\n            return success(msg='用户登录成功', data={\"token\": token, \"user_id\": user_id})\n        else:\n            return error(code=HttpCode.parmas_error, msg='用户登录密码输入错误')\n</code></pre><p>上面代码整体实现流程是，首先要做的就是接收用户输入的手机号码和密码，然后利用手机号码查询数据库中是，否存在该用户。如果不存在，则返回错误信息。如果存在，使用在数据库表中定义的函数check_password来，检查密码是否正确。</p><p>如果密码错误，则返回错误信息。如果密码正确则记录用户的登录时间和日期，使用当前用户的user_id和登录时间戳作为参数，调用encode_auth_token()方法生成一个token，再使用redis_store.set()方法将生成的token存储在redis中，并设置过期时间。</p><p>如果存储失败，则将该错误信息存入应用日志中，以便于后续的调试和问题排查。如果所有条件都满足，最后返回成功信息和token以及用户ID。</p><p>这里还调用了video模块中的user_action_log。user_action_log用来记录出现的异常等信息。具体代码是后面这样。</p><pre><code class=\"language-python\">from api.utils.log_utils import json_log\njson_log('user_action', 'logs/user_action.log')\nuser_action_log = logging.getLogger('user_action')\n</code></pre><p>这里调用了log_utils中的json_log函数，使用  <code>json_log</code> 函数来创建一个名为 <code>user_action_log</code> 的日志记录器对象，并将其指向  <code>logs/user_action.log</code> 路径的文件，这样记录用户操作的相关信息会更方便。</p><h2>用户鉴权</h2><p>接下来的环节就是在请求时获取用户的登录信息，并进行鉴权。如果用户没有相应的权限，则返回相应的错误信息。具体实现代码是后面这样。</p><pre><code class=\"language-python\">def identify(self, request):\n    \"\"\"\n    用户鉴权\n    :return: list\n    \"\"\"\n    auth_header = request.headers.get('Authorization', None)\n    if auth_header:\n        auth_token_arr = auth_header.split(\" \")\n        # 分成列表，含有两个元素\n        if not auth_token_arr or auth_token_arr[0] != 'JWT' or len(auth_token_arr) != 2:\n            return dict(code=HttpCode.auth_error, msg='请求未携带认证信息，认证失败')\n        else:\n            auth_token = auth_token_arr[1]\n            # 将JWT令牌的字符串值给auth_token\n            payload_dict = self.decode_auth_token(auth_token)\n            if 'payload' in payload_dict and payload_dict.get('code') == 200:\n                payload = payload_dict.get('payload')\n                user_id = payload.get('data').get('id')\n                login_time = payload.get('data').get('login_time')\n                # print('👉👉   解析出的时间戳', login_time)\n                user = UserLogin.query.filter_by(user_id=user_id).first()\n                if not user:  # 未在请求中找到对应的用户\n                    return dict(code=HttpCode.auth_error, msg='用户不存在，查无此用户')\n                else:\n                    # 通过user取出redis中的token\n                    try:\n                        # print(user_id)\n                        redis_jwt_token = redis_store.get(\"jwt_token:%s\" % user_id)\n                        # print('👈redis', redis_jwt_token)\n                    except Exception as e:\n                        current_app.logger.error(e)\n                        return dict(code=HttpCode.db_error, msg=\"redis查询token失败\")\n                    if not redis_jwt_token or redis_jwt_token != auth_token:\n                        # print('👉👉   解析出来的token', auth_token)\n                        return dict(code=HttpCode.auth_error, msg=\"jwt-token失效\")\n                    # print(type(user.last_login_stamp), type(login_time))\n                    # print(user.last_login_stamp, login_time)\n                    if user.last_login_stamp == login_time:\n\n                        return dict(code=HttpCode.ok, msg='用户认证成功', data={\"user_id\": user.user_id})\n                    else:\n                        return dict(code=HttpCode.auth_error, msg='用户认证失败，需要再次登录')\n            else:\n                return dict(code=HttpCode.auth_error, msg=payload_dict.get('msg') or '用户认证失败，携带认证参数不合法')\n    else:\n        return dic在代码中，t(code主要=HttpCode.auth_error, msg='用户认证失败,请求未携带对应认证信息')\n</code></pre><p>用户鉴权函数主要用于验证用户的身份是否合法。首先通过request.headers获取请求头中的Authorization字段，如果不存在，说明用户未携带对应认证信息，返回包含错误信息的字典。</p><p>如果存在该字段，就按照空格将其分割成一个列表，列表中包含两个元素，第一个元素为JWT，第二个元素为JWT令牌的字符串值。如果auth_token_arr为空，那么auth_token_arr第一个元素不包含 “JWT” 字符串，或者分割后的auth_token_arr长度不为2，这就证明JWT令牌格式不正确，需要返回认证失败的信息。</p><p>这一步如果通过的话，我们再将auth_token_arr列表中的第二个值，也就是JWT令牌的字符串值赋给auth_token，并将解码结果赋值payload_dict。</p><p>下一步就是判断payload_dict中是否有payload字段，且code字段的值是否为200。不符合判断条件同样要返回错误信息，说明携带认证参数不合法。如果符合条件，就从payload中把用户ID、登录时间和payload信息取出来，并根据用户ID在用户登录表中完成查询。</p><p>如果不存在该用户同样要返回错误。如果用户存在，则从 Redis内存中，获取以 user_id 为键的jwt_token，赋给redis_jwt_token。如果内存中取不出来该值，这时候就返回错误。</p><p>紧接着会再次做条件判断，如果请求中解析出的JWT令牌的字符串值，跟之前存储在内存中的不相符合，同样要返回错误。最后，验证该token对应的登录时间戳是否与数据库中最近一次登录时间戳一致。如果一致，则表示认证通过，否则表示需要重新登录。</p><p>在实操环节我们知道Token的认证流程是当用户在进行首次登录，服务器会使用密钥和加密算法，生成Token，发送给客户端，由客户端自己进行存储。等再次登录时，客户端携带Token请求资源，服务器会进行Token的认证，完成一系列验证（如Token是否过期，JWT令牌的格式是否正确等），通过异常处理的把控来保证Token认证的安全和稳定性。</p><h2>总结</h2><p>又到了课程的尾声，我们来回顾总结一下。</p><p>这节课，我们主要是通过项目实战来强化对认证机制的应用。在项目中应用也是一样的认证流程，我们先要生成Token，借助Flask的扩展Flask-JWT来生成Token。你需要掌握生成Token的代码，理解它的生成过程。</p><p>之后就是Token验证和认证阶段，Token的验证就是借助JWT扩展的decode函数，将客户端发送的Token进行解码。我们重点要关注登录认证成功的前提下，客户端接收Token以后，下次向服务端请求资源的时候，<strong>必须带着服务端签发的 Token</strong>，这样才能实现对用户信息的认证。</p><p>用户鉴权函数主要用于验证用户的身份是否合法。鉴定方法就是通过request.headers请求头中的Authorization字段来判断：如果该字段不存在，说明用户未携带对应认证信息；如果存在则需要我们验证内部参数来判定。</p><p>通过这节课的实操练习，相信你会对认证机制的应用得更加熟练。课程里有很多的代码，一定在课后自己多实践。下节课我们即将开启功能接口的实战，不见不散。</p><h2>思考题</h2><p>前面的课程里，我们讲到了current_app，session，request，你知道他们有什么区别么？</p><p>欢迎你在留言区和我交流互动，如果这节课对你有启发，也推荐你把这节课分享给更多朋友。</p>","comments":[{"had_liked":false,"id":381846,"user_name":"胡歌衡阳分歌","can_delete":false,"product_type":"c1","uid":3206232,"ip_address":"湖南","ucode":"F39E856E73F938","user_header":"https://static001.geekbang.org/account/avatar/00/30/ec/58/7948ea79.jpg","comment_is_top":false,"comment_ctime":1695974894,"is_pvip":false,"replies":[{"id":139186,"content":"是这样同学，在这一节课我们把整体的认证机制梳理下来，以及做了一些小的案例实践，在后边课程中的项目实战会结合这部分内容做项目开发应用，如果单独看目前不太理解，不要让自己丧失信心，接着听后边的课程，会解开你的疑惑。加油","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1696735315,"ip_address":"北京","comment_id":381846,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"这个教程是相当的不完整啊，看的心烦","like_count":1,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629148,"discussion_content":"是这样同学，在这一节课我们把整体的认证机制梳理下来，以及做了一些小的案例实践，在后边课程中的项目实战会结合这部分内容做项目开发应用，如果单独看目前不太理解，不要让自己丧失信心，接着听后边的课程，会解开你的疑惑。加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696735315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1163668,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c1/94/d8717630.jpg","nickname":"雪儿欢","note":"","ucode":"5AE6D46F2097C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":640489,"discussion_content":"主要是git代码都是截取出来的 也没有给完整的代码以及结构\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711537193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":629148,"ip_address":"广东","group_id":0},"score":640489,"extra":""}]}]},{"had_liked":false,"id":384923,"user_name":"石佛慈悲","can_delete":false,"product_type":"c1","uid":1002788,"ip_address":"北京","ucode":"9BE727D82672E3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/24/6c621045.jpg","comment_is_top":false,"comment_ctime":1701787931,"is_pvip":false,"replies":[{"id":140504,"content":"将token存储在Redis中并进行校验可以增加额外的安全层。这可以帮助防止token被篡改或伪造，从而保护应用程序的安全。同时，通过设置过期时间，可以确保token在一段时间后自动失效，进一步保护用户的安全。\n此外，通过校验Redis中的token，可以确保一旦token过期或被撤销，它就不能再被用来访问受保护的资源。这对于管理用户会话和权限非常有用。","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1702958352,"ip_address":"北京","comment_id":384923,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"token存在redis里的意义是啥呢，为啥还要校验redis的token，不是解码比对都已经校验了吗？为了控制token失效？","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634056,"discussion_content":"将token存储在Redis中并进行校验可以增加额外的安全层。这可以帮助防止token被篡改或伪造，从而保护应用程序的安全。同时，通过设置过期时间，可以确保token在一段时间后自动失效，进一步保护用户的安全。\n此外，通过校验Redis中的token，可以确保一旦token过期或被撤销，它就不能再被用来访问受保护的资源。这对于管理用户会话和权限非常有用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702958352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376993,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1687820763,"is_pvip":false,"replies":[{"id":137516,"content":"1、Config.SECRET_KEY 是 Flask 框架中提供的一个系统默认的密钥。在 Flask 应用中，Config.SECRET_KEY 用于加密和保护会话数据，以确保用户会话的安全性。当然，你也可以通过其他方式设置 SECRET_KEY，但无论哪种方式，确保 SECRET_KEY 的安全性是非常重要的，因为它用于保护用户的会话数据和身份验证信息。\n2、在 HTTP header 中，确实存在一个名为 &quot;Authorization&quot; 的字段，用于传递身份验证信息和授权令牌。这个字段是 HTTP 协议中预定义的标准字段之一，用于标识客户端的身份验证方式、授权令牌类型以及授权令牌的值。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1688399061,"ip_address":"北京","comment_id":376993,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"请教老师两个问题：\nQ1：Config.SECRET_KEY是系统自带的吗？\nQ2：token放在http的header中的Authorization字段，Authorization字段是http固有的字段吗？记不清楚了，好像应该是自定义字段？","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622562,"discussion_content":"1、Config.SECRET_KEY 是 Flask 框架中提供的一个系统默认的密钥。在 Flask 应用中，Config.SECRET_KEY 用于加密和保护会话数据，以确保用户会话的安全性。当然，你也可以通过其他方式设置 SECRET_KEY，但无论哪种方式，确保 SECRET_KEY 的安全性是非常重要的，因为它用于保护用户的会话数据和身份验证信息。\n2、在 HTTP header 中，确实存在一个名为 &#34;Authorization&#34; 的字段，用于传递身份验证信息和授权令牌。这个字段是 HTTP 协议中预定义的标准字段之一，用于标识客户端的身份验证方式、授权令牌类型以及授权令牌的值。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688399061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}