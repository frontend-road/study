{"id":239580,"title":"08 | smart_ptr：智能指针到底“智能”在哪里？","content":"<p>你好，我是Chrono。</p><p>上节课在讲const的时候，说到const可以修饰指针，不过今天我要告诉你：请忘记这种用法，在现代C++中，绝对不要再使用“裸指针（naked pointer）”了，而是应该使用“智能指针（smart pointer）”。</p><p>你肯定或多或少听说过、用过智能指针，也可能看过实现源码，那么，你心里有没有一种疑惑，智能指针到底“智能”在哪里？难道它就是解决一切问题的“灵丹妙药”吗？</p><p>学完了今天的这节课，我想你就会有个明确的答案了。</p><h2>什么是智能指针？</h2><p>所谓的“智能指针”，当然是相对于“不智能指针”，也就是“裸指针”而言的。</p><p>所以，我们就先来看看裸指针，它有时候也被称为原始指针，或者直接简称为指针。</p><p>指针是源自C语言的概念，本质上是一个内存地址索引，代表了一小片内存区域（也可能会很大），能够直接读写内存。</p><p>因为它完全映射了计算机硬件，所以操作效率高，是C/C++高效的根源。当然，这也是引起无数麻烦的根源。访问无效数据、指针越界，或者内存分配后没有及时释放，就会导致运行错误、内存泄漏、资源丢失等一系列严重的问题。</p><p>其他的编程语言，比如Java、Go就没有这方面的顾虑，因为它们内置了一个“垃圾回收”机制，会检测不再使用的内存，自动释放资源，让程序员不必为此费心。</p><!-- [[[read_end]]] --><p>其实，C++里也是有垃圾回收的，不过不是Java、Go那种严格意义上的垃圾回收，而是广义上的垃圾回收，这就是<strong>构造/析构函数</strong>和<strong>RAII惯用法</strong>（Resource Acquisition Is Initialization）。</p><p>我们可以应用代理模式，把裸指针包装起来，在构造函数里初始化，在析构函数里释放。这样当对象失效销毁时，C++就会<strong>自动</strong>调用析构函数，完成内存释放、资源回收等清理工作。</p><p>和Java、Go相比，这算是一种“微型”的垃圾回收机制，而且回收的时机完全“自主可控”，非常灵活。当然也有一点代价——你必须要针对每一个资源手写包装代码，又累又麻烦。</p><p>智能指针就是代替你来干这些“脏活累活”的。它完全实践了RAII，包装了裸指针，而且因为重载了*和-&gt;操作符，用起来和原始指针一模一样。</p><p>不仅如此，它还综合考虑了很多现实的应用场景，能够自动适应各种复杂的情况，防止误用指针导致的隐患，非常“聪明”，所以被称为“智能指针”。</p><p>常用的有两种智能指针，分别是<strong>unique_ptr</strong>和<strong>shared_ptr</strong>，下面我就来分别介绍一下。</p><h2>认识unique_ptr</h2><p>unique_ptr是最简单、最容易使用的一个智能指针，在声明的时候必须用模板参数指定类型：</p><pre><code>unique_ptr&lt;int&gt; ptr1(new int(10));      // int智能指针\nassert(*ptr1 == 10);                     // 可以使用*取内容\nassert(ptr1 != nullptr);                // 可以判断是否为空指针\n\nunique_ptr&lt;string&gt; ptr2(new string(&quot;hello&quot;));  // string智能指针\nassert(*ptr2 == &quot;hello&quot;);                // 可以使用*取内容\nassert(ptr2-&gt;size() == 5);               // 可以使用-&gt;调用成员函数\n</code></pre><p>你需要注意的是，unique_ptr虽然名字叫指针，用起来也很像，但<strong>它实际上并不是指针，而是一个对象。所以，不要企图对它调用delete，它会自动管理初始化时的指针，在离开作用域时析构释放内存。</strong></p><p>另外，它也没有定义加减运算，不能随意移动指针地址，这就完全避免了指针越界等危险操作，可以让代码更安全：</p><pre><code>ptr1++;                        // 导致编译错误\nptr2 += 2;                     // 导致编译错误\n</code></pre><p>除了调用delete、加减运算，初学智能指针还有一个容易犯的错误是把它当成普通对象来用，不初始化，而是声明后直接使用：</p><pre><code>unique_ptr&lt;int&gt; ptr3;                // 未初始化智能指针\n*ptr3 = 42 ;                         // 错误！操作了空指针\n</code></pre><p>未初始化的unique_ptr表示空指针，这样就相当于直接操作了空指针，运行时就会产生致命的错误（比如core dump）。</p><p>为了避免这种低级错误，你可以调用工厂函数<strong>make_unique()</strong>，强制创建智能指针的时候必须初始化。同时还可以利用自动类型推导（<a href=\"https://time.geekbang.org/column/article/237964\">第6讲</a>）的auto，少写一些代码：</p><pre><code>auto ptr3 = make_unique&lt;int&gt;(42);               // 工厂函数创建智能指针\nassert(ptr3 &amp;&amp; *ptr3 == 42);\n\nauto ptr4 = make_unique&lt;string&gt;(&quot;god of war&quot;);  // 工厂函数创建智能指针\nassert(!ptr4-&gt;empty());\n</code></pre><p>不过，make_unique()要求C++14，好在它的原理比较简单。如果你使用的是C++11，也可以自己实现一个简化版的make_unique()，可以参考下面的代码：</p><pre><code>template&lt;class T, class... Args&gt;              // 可变参数模板\nstd::unique_ptr&lt;T&gt;                            // 返回智能指针\nmy_make_unique(Args&amp;&amp;... args)                // 可变参数模板的入口参数\n{\n    return std::unique_ptr&lt;T&gt;(                // 构造智能指针\n            new T(std::forward&lt;Args&gt;(args)...));    // 完美转发\n}\n</code></pre><h2>unique_ptr的所有权</h2><p>使用unique_ptr的时候还要特别注意指针的“<strong>所有权</strong>”问题。</p><p>正如它的名字，表示指针的所有权是“唯一”的，不允许共享，任何时候只能有一个“人”持有它。</p><p>为了实现这个目的，unique_ptr应用了C++的“转移”（move）语义，同时禁止了拷贝赋值，所以，在向另一个unique_ptr赋值的时候，要特别留意，必须用<strong>std::move()</strong>函数显式地声明所有权转移。</p><p>赋值操作之后，指针的所有权就被转走了，原来的unique_ptr变成了空指针，新的unique_ptr接替了管理权，保证所有权的唯一性：</p><pre><code>auto ptr1 = make_unique&lt;int&gt;(42);    // 工厂函数创建智能指针\nassert(ptr1 &amp;&amp; *ptr1 == 42);         // 此时智能指针有效\n\nauto ptr2 = std::move(ptr1);         // 使用move()转移所有权\nassert(!ptr1 &amp;&amp; ptr2);               // ptr1变成了空指针\n</code></pre><p>如果你对右值、转移这些概念不是太理解，也没关系，它们用起来也的确比较“微妙”，这里你只要记住，<strong>尽量不要对unique_ptr执行赋值操作</strong>就好了，让它“自生自灭”，完全自动化管理。</p><h2>认识shared_ptr</h2><p>接下来要说的是shared_ptr，它是一个比unique_ptr更“智能”的智能指针。</p><p>初看上去shared_ptr和unique_ptr差不多，也可以使用工厂函数来创建，也重载了*和-&gt;操作符，用法几乎一样——只是名字不同，看看下面的代码吧：</p><pre><code>shared_ptr&lt;int&gt; ptr1(new int(10));     // int智能指针\nassert(*ptr1 == 10);                    // 可以使用*取内容\n\nshared_ptr&lt;string&gt; ptr2(new string(&quot;hello&quot;));  // string智能指针\nassert(*ptr2 == &quot;hello&quot;);                      // 可以使用*取内容\n\nauto ptr3 = make_shared&lt;int&gt;(42);  // 工厂函数创建智能指针\nassert(ptr3 &amp;&amp; *ptr3 == 42);       // 可以判断是否为空指针\n\nauto ptr4 = make_shared&lt;string&gt;(&quot;zelda&quot;);  // 工厂函数创建智能指针\nassert(!ptr4-&gt;empty());                   // 可以使用-&gt;调用成员函数\n</code></pre><p>但shared_ptr的名字明显表示了它与unique_ptr的最大不同点：<strong>它的所有权是可以被安全共享的</strong>，也就是说支持拷贝赋值，允许被多个“人”同时持有，就像原始指针一样。</p><pre><code>auto ptr1 = make_shared&lt;int&gt;(42);    // 工厂函数创建智能指针\nassert(ptr1 &amp;&amp; ptr1.unique() );     // 此时智能指针有效且唯一\n\nauto ptr2 = ptr1;                  // 直接拷贝赋值，不需要使用move()\nassert(ptr1 &amp;&amp; ptr2);              // 此时两个智能指针均有效\n\nassert(ptr1 == ptr2);             // shared_ptr可以直接比较\n\n// 两个智能指针均不唯一，且引用计数为2\nassert(!ptr1.unique() &amp;&amp; ptr1.use_count() == 2); \nassert(!ptr2.unique() &amp;&amp; ptr2.use_count() == 2); \n</code></pre><p>shared_ptr支持安全共享的秘密在于<strong>内部使用了“引用计数”</strong>。</p><p>引用计数最开始的时候是1，表示只有一个持有者。如果发生拷贝赋值——也就是共享的时候，引用计数就增加，而发生析构销毁的时候，引用计数就减少。只有当引用计数减少到0，也就是说，没有任何人使用这个指针的时候，它才会真正调用delete释放内存。</p><p>因为shared_ptr具有完整的“值语义”（即可以拷贝赋值），所以，<strong>它可以在任何场合替代原始指针，而不用再担心资源回收的问题</strong>，比如用于容器存储指针、用于函数安全返回动态创建的对象，等等。</p><h2>shared_ptr的注意事项</h2><p>那么，既然shared_ptr这么好，是不是就可以只用它而不再考虑unique_ptr了呢？</p><p>答案当然是否定的，不然也就没有必要设计出来多种不同的智能指针了。</p><p>虽然shared_ptr非常“智能”，但天下没有免费的午餐，它也是有代价的，<strong>引用计数的存储和管理都是成本</strong>，这方面是shared_ptr不如unique_ptr的地方。</p><p>如果不考虑应用场合，过度使用shared_ptr就会降低运行效率。不过，你也不需要太担心，shared_ptr内部有很好的优化，在非极端情况下，它的开销都很小。</p><p>另外一个要注意的地方是<strong>shared_ptr的销毁动作</strong>。</p><p>因为我们把指针交给了shared_ptr去自动管理，但在运行阶段，引用计数的变动是很复杂的，很难知道它真正释放资源的时机，无法像Java、Go那样明确掌控、调整垃圾回收机制。</p><p>你要特别小心对象的析构函数，不要有非常复杂、严重阻塞的操作。一旦shared_ptr在某个不确定时间点析构释放资源，就会阻塞整个进程或者线程，“整个世界都会静止不动”（也许用过Go的同学会深有体会）。这也是我以前遇到的实际案例，排查起来费了很多功夫，真的是“血泪教训”。</p><pre><code>class DemoShared final      //  危险的类，不定时的地雷   \n{\npublic:\n    DemoShared() = default;\n   ~DemoShared()            // 复杂的操作会导致shared_ptr析构时世界静止\n   {\n       // Stop The World ...\n   }\n};\n\n</code></pre><p>shared_ptr的引用计数也导致了一个新的问题，就是“<strong>循环引用</strong>”，这在把shared_ptr作为类成员的时候最容易出现，典型的例子就是<strong>链表节点</strong>。</p><p>下面的代码演示了一个简化的场景：</p><pre><code>class Node final\n{\npublic:\n    using this_type     = Node;\n    using shared_type   = std::shared_ptr&lt;this_type&gt;;\npublic:\n    shared_type     next;      // 使用智能指针来指向下一个节点\n};\n\nauto n1 = make_shared&lt;Node&gt;();   // 工厂函数创建智能指针\nauto n2 = make_shared&lt;Node&gt;();   // 工厂函数创建智能指针\n\nassert(n1.use_count() == 1);    // 引用计数为1\nassert(n2.use_count() == 1);\n\nn1-&gt;next = n2;                 // 两个节点互指，形成了循环引用\nn2-&gt;next = n1;\n\nassert(n1.use_count() == 2);    // 引用计数为2\nassert(n2.use_count() == 2);    // 无法减到0，无法销毁，导致内存泄漏\n</code></pre><p>在这里，两个节点指针刚创建时，引用计数是1，但指针互指（即拷贝赋值）之后，引用计数都变成了2。</p><p>这个时候，shared_ptr就“犯傻”了，意识不到这是一个循环引用，多算了一次计数，后果就是引用计数无法减到0，无法调用析构函数执行delete，最终导致内存泄漏。</p><p>这个例子很简单，你一下子就能看出存在循环引用。但在实际开发中，指针的关系可不像例子那么清晰，很有可能会不知不觉形成一个链条很长的循环引用，复杂到你根本无法识别，想要找出来基本上是不可能的。</p><p>想要从根本上杜绝循环引用，光靠shared_ptr是不行了，必须要用到它的“小帮手”：<strong>weak_ptr</strong>。</p><p>weak_ptr顾名思义，功能很“弱”。它专门为打破循环引用而设计，只观察指针，不会增加引用计数（弱引用），但在需要的时候，可以调用成员函数lock()，获取shared_ptr（强引用）。</p><p>刚才的例子里，只要你改用weak_ptr，循环引用的烦恼就会烟消云散：</p><pre><code>class Node final\n{\npublic:\n    using this_type     = Node;\n\n    // 注意这里，别名改用weak_ptr\n    using shared_type   = std::weak_ptr&lt;this_type&gt;;\npublic:\n    shared_type     next;    // 因为用了别名，所以代码不需要改动\n};\n\nauto n1 = make_shared&lt;Node&gt;();  // 工厂函数创建智能指针\nauto n2 = make_shared&lt;Node&gt;();  // 工厂函数创建智能指针\n\nn1-&gt;next = n2;             // 两个节点互指，形成了循环引用\nn2-&gt;next = n1;\n\nassert(n1.use_count() == 1);    // 因为使用了weak_ptr，引用计数为1\nassert(n2.use_count() == 1);   // 打破循环引用，不会导致内存泄漏\n\nif (!n1-&gt;next.expired()) {     // 检查指针是否有效\n    auto ptr = n1-&gt;next.lock();  // lock()获取shared_ptr\n    assert(ptr == n2);\n}\n</code></pre><h2>小结</h2><p>好了，今天就先到这里。智能指针的话题很大，但是学习的时候我们不可能一下子把所有知识点都穷尽，而是要有优先级。所以我会捡最要紧的先介绍给你，剩下的接口函数等细节，还是需要你根据自己的情况，再去参考一些其他资料深入学习的。</p><p>我们来回顾一下这节课的重点。</p><ol>\n<li>智能指针是代理模式的具体应用，它使用RAII技术代理了裸指针，能够自动释放内存，无需程序员干预，所以被称为“智能指针”。</li>\n<li>如果指针是“独占”使用，就应该选择unique_ptr，它为裸指针添加了很多限制，更加安全。</li>\n<li>如果指针是“共享”使用，就应该选择shared_ptr，它的功能非常完善，用法几乎与原始指针一样。</li>\n<li>应当使用工厂函数make_unique()、make_shared()来创建智能指针，强制初始化，而且还能使用auto来简化声明。</li>\n<li>shared_ptr有少量的管理成本，也会引发一些难以排查的错误，所以不要过度使用。</li>\n</ol><p>我还有一个很重要的建议：</p><p><strong>既然你已经理解了智能指针，就尽量不要再使用裸指针、new和delete来操作内存了</strong>。</p><p>如果严格遵守这条建议，用好unique_ptr、shared_ptr，那么，你的程序就不可能出现内存泄漏，你也就不需要去费心研究、使用valgrind等内存调试工具了，生活也会更“美好”一点。</p><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>你觉得unique_ptr和shared_ptr的区别有哪些？列举一下。</li>\n<li>你觉得应该如何在程序里“消灭”new和delete？</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友，我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/51/e5298af2501d0156fcc50d50cdb82351.jpg?wh=1000*1677\" alt=\"\"></p>","neighbors":{"left":{"article_title":"07 | const/volatile/mutable：常量/变量究竟是怎么回事？","id":238486},"right":{"article_title":"09 | exception：怎样才能用好异常？","id":240292}},"comments":[{"had_liked":false,"id":220279,"user_name":"Eglinux","can_delete":false,"product_type":"c1","uid":1187353,"ip_address":"","ucode":"4AAB9940789442","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/19/17245c59.jpg","comment_is_top":false,"comment_ctime":1590220008,"is_pvip":false,"replies":[{"id":"81318","content":"已经不少了吧，相识就是缘分，笑。","user_name":"作者回复","comment_id":220279,"uid":"1181974","ip_address":"","utype":1,"ctime":1590230746,"user_name_real":"chrono"}],"discussion_count":2,"race_medal":0,"score":"194863748328","product_id":100051801,"comment_content":"C++ 这么小众吗？讲得这么好，如果写成书，完全可以看成另外一本 effective C++ 了，为什么才 3000 多订阅人数？","like_count":45,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496110,"discussion_content":"已经不少了吧，相识就是缘分，笑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590230746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247617,"avatar":"https://static001.geekbang.org/account/avatar/00/13/09/81/15d84fbb.jpg","nickname":"绀野木棉季","note":"","ucode":"4DCA6991911741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303542,"discussion_content":"学习难度大 开发成本高 既要保证功能又要保证硬件，操作系统，g++版本等等一些列问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599293814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227406,"user_name":"酸葡萄","can_delete":false,"product_type":"c1","uid":1154146,"ip_address":"","ucode":"9D059C4FB327C0","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","comment_is_top":false,"comment_ctime":1592374550,"is_pvip":false,"replies":[{"id":"83814","content":"我给一个不是很精确的评价标准吧。<br><br>shared_ptr是强引用，无论如何都需要持有共享对象的时候就用它。<br><br>weak_ptr是弱引用，不一定要持有对象，只是“偶尔”想去看看对象在不在，不在也可以接受。","user_name":"作者回复","comment_id":227406,"uid":"1181974","ip_address":"","utype":1,"ctime":1592383669,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"126146426134","product_id":100051801,"comment_content":"老师，您好，什么时候用weak_ptr,什么时候用shared_ptr？","like_count":28,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498624,"discussion_content":"我给一个不是很精确的评价标准吧。\n\nshared_ptr是强引用，无论如何都需要持有共享对象的时候就用它。\n\nweak_ptr是弱引用，不一定要持有对象，只是“偶尔”想去看看对象在不在，不在也可以接受。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592383669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220936,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1590360142,"is_pvip":false,"replies":[{"id":"81457","content":"是的，涉及到系统底层，有时候就可能要用到delete，不过你也可以试着用RAII来管理，或者用shared_ptr的定制删除函数，还是能够找到不用delete的方式的。","user_name":"作者回复","comment_id":220936,"uid":"1181974","ip_address":"","utype":1,"ctime":1590368020,"user_name_real":"chrono"}],"discussion_count":2,"race_medal":0,"score":"78899771470","product_id":100051801,"comment_content":"默认用的比较多的是unique_ptr ，相反的shared_ptr倒是用的不多，因为担心文中提到的循环引用，资源消耗，线程安全等问题。大部分时候，unique_ptr是能完全取代裸指针的。如果是存粹的标准C++代码，使用智能指针确实很舒服，把它们当成一个普通的类型看就行了。但是，同时，作为C++程序员我们又不得不和裸指针打交道，不论是Linux还是Windows，我们不可避免的要使用它们的系统api，于是就不得不使用get将智能指针转成裸指针。而这条指针所指向的内存在系统api里也许是不应该随意析构掉的，因为在系统内部可能还得继续使用这段内存，那么在这种场景下，智能指针的特性就可能帮倒忙，难受了😫。针对这种问题，我想到的就是延长这个智能指针的生命周期，或者直接使用release将裸指针释放出来，可是这样一来，delete就少不了要使用了😔<br>","like_count":18,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496270,"discussion_content":"是的，涉及到系统底层，有时候就可能要用到delete，不过你也可以试着用RAII来管理，或者用shared_ptr的定制删除函数，还是能够找到不用delete的方式的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590368020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1604330,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL6vCJbd9waPcVY3s46PUC9Qeic2ed4vqviaYfYhjOZEHXY7PO1o6FyeibwkcT07zHRT5vgiaibw8Pwichg/132","nickname":"trackfact","note":"","ucode":"79AAFBAFEA74CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357197,"discussion_content":"这种情况下使用intrusive_ptr","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615748632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231406,"user_name":"颓废人才","can_delete":false,"product_type":"c1","uid":1984432,"ip_address":"","ucode":"DED839F68A822D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/47/b0/f44aef75.jpg","comment_is_top":false,"comment_ctime":1593669664,"is_pvip":false,"replies":[{"id":"85464","content":"我一般看的是cppreference.com，觉得它的界面比较好，资料组织整理的也很清楚，和官方标准基本吻合。<br><br>这些网站都是免费的，我觉得就可以一起看，互相参照。","user_name":"作者回复","comment_id":231406,"uid":"1181974","ip_address":"","utype":1,"ctime":1593675993,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"40248375328","product_id":100051801,"comment_content":"罗老师您好，还有一个问题，常用的C++ reference 我看到一个 cplusplus.com和cppreference.com, 但是网上有一些不好评价，觉得这两个网站都有问题，罗老师这边一般参考的哪些文档网站，可以推荐下么。非常感谢。","like_count":9,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500290,"discussion_content":"我一般看的是cppreference.com，觉得它的界面比较好，资料组织整理的也很清楚，和官方标准基本吻合。\n\n这些网站都是免费的，我觉得就可以一起看，互相参照。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593675993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220958,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1590367234,"is_pvip":false,"replies":[{"id":"81480","content":"值是和引用对应的，值就是有实体，可以拷贝，而引用是虚的，只是个别名，操作上有区别。","user_name":"作者回复","comment_id":220958,"uid":"1181974","ip_address":"","utype":1,"ctime":1590374695,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"35950105602","product_id":100051801,"comment_content":"“因为 shared_ptr 具有完整的“值语义”（即可以拷贝赋值）”<br><br>一直都觉得值语义这三个字比较难理解。想请教下这个概念到底是想说明什么问题，这个“值”该怎么理解？","like_count":8,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496280,"discussion_content":"值是和引用对应的，值就是有实体，可以拷贝，而引用是虚的，只是个别名，操作上有区别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590374695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222548,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1010819,"ip_address":"","ucode":"8368A63185356D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","comment_is_top":false,"comment_ctime":1590832734,"is_pvip":false,"replies":[{"id":"82054","content":"追求极致性能，那当然还是要自己管理好了，但这样也就要自己承担安全的责任了。<br><br>建议用unique_ptr，它的速度与裸指针几乎相同，没有引用计数的成本。","user_name":"作者回复","comment_id":222548,"uid":"1181974","ip_address":"","utype":1,"ctime":1590839057,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"27360636510","product_id":100051801,"comment_content":"使用智能指针可以自动析构“资源”，隐含了指针管理的细节，从而提高了代码的安全性和易用性，但是这是否同时意味着效率下降？在极致追求执行速度的系统中，是否需要避免使用智能指针，依赖程序员自己管理裸指针的new和delete呢？","like_count":6,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496839,"discussion_content":"追求极致性能，那当然还是要自己管理好了，但这样也就要自己承担安全的责任了。\n\n建议用unique_ptr，它的速度与裸指针几乎相同，没有引用计数的成本。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590839057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234052,"user_name":"The Answer","can_delete":false,"product_type":"c1","uid":1664773,"ip_address":"","ucode":"1ECF369780BFA9","user_header":"https://static001.geekbang.org/account/avatar/00/19/67/05/a0315f44.jpg","comment_is_top":false,"comment_ctime":1594565885,"is_pvip":false,"replies":[{"id":"86372","content":"shared_ptr就像是一个盒子，它自己是安全操作的，但一旦把里面的东西拿出来，就无法保证了。<br><br>shared_ptr和它指向的对象是彼此独立的，所以线程安全当然是没有关系的，shared_ptr只是一个handle，离开了handle，它就不能保证了。","user_name":"作者回复","comment_id":234052,"uid":"1181974","ip_address":"","utype":1,"ctime":1594601550,"user_name_real":"罗剑锋"}],"discussion_count":4,"race_medal":0,"score":"23069402365","product_id":100051801,"comment_content":"老师，shared_ptr 本身是线程安全的，但是如何理解它所管理的对象不是线程安全的呢？","like_count":5,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501256,"discussion_content":"shared_ptr就像是一个盒子，它自己是安全操作的，但一旦把里面的东西拿出来，就无法保证了。\n\nshared_ptr和它指向的对象是彼此独立的，所以线程安全当然是没有关系的，shared_ptr只是一个handle，离开了handle，它就不能保证了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594601550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2765503,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/32/bf/8dcbf91a.jpg","nickname":"孙阳","note":"","ucode":"43B5231D2C9245","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537600,"discussion_content":"引用计数是安全的，因为它是原子变量，但指向的对象本身是不安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639112315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2149899,"avatar":"https://static001.geekbang.org/account/avatar/00/20/ce/0b/b1e244e6.jpg","nickname":"IMBFD","note":"","ucode":"2E7B3D01C537A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304548,"discussion_content":"shared-ptr是线程安全的吗？我怎么记得好像不是。至少包含了一个指针和一个引用计数，内部操作他们的时候是加锁了么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599612732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2046086,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/38/86/156e5583.jpg","nickname":"无名","note":"","ucode":"885A6A3B0F86CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2149899,"avatar":"https://static001.geekbang.org/account/avatar/00/20/ce/0b/b1e244e6.jpg","nickname":"IMBFD","note":"","ucode":"2E7B3D01C537A0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342658,"discussion_content":"引用计数的是原子的所以引用计数安全，但指向的内存值不是线程安全的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610767035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304548,"ip_address":""},"score":342658,"extra":""}]}]},{"had_liked":false,"id":220505,"user_name":"郭郭","can_delete":false,"product_type":"c1","uid":1517814,"ip_address":"","ucode":"E358C980AB9555","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/f6/7fa61d68.jpg","comment_is_top":false,"comment_ctime":1590252484,"is_pvip":false,"replies":[{"id":"81460","content":"我测试了一下，是不行的，会报编译错误，因为unique_ptr禁止了普通的拷贝赋值，只允许转移，必须调用std::move()。","user_name":"作者回复","comment_id":220505,"uid":"1181974","ip_address":"","utype":1,"ctime":1590368561,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"23065088964","product_id":100051801,"comment_content":"老师，关于unique_ptr，如auto ptr = ptr1，那ptr1就应该被置空啦。不需要显示的调用std::move","like_count":5,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496158,"discussion_content":"我测试了一下，是不行的，会报编译错误，因为unique_ptr禁止了普通的拷贝赋值，只允许转移，必须调用std::move()。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590368561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248462,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1600172111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18780041295","product_id":100051801,"comment_content":"weak_ptr没有重载operator-&gt;和operator *操作符，不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象。","like_count":4},{"had_liked":false,"id":243008,"user_name":"Geek_王","can_delete":false,"product_type":"c1","uid":1625386,"ip_address":"","ucode":"75E5791737D6EC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZqsT4YGrnaBtCgetwQiaK8nt2qXr5z56a9j2ricUiadibsPNqYqiawaygHicq3frt1jPVaoT78gh2f7Uw/132","comment_is_top":false,"comment_ctime":1597918435,"is_pvip":false,"replies":[{"id":"89608","content":"就是类的析构函数比较大，里面的操作很多，用shared_ptr来管理，由于析构的时机不确定，经常会发生莫名其妙的系统抖动，就像是java&#47;go的gc stop the world一样。","user_name":"作者回复","comment_id":243008,"uid":"1181974","ip_address":"","utype":1,"ctime":1597971889,"user_name_real":"罗剑锋"}],"discussion_count":3,"race_medal":0,"score":"14482820323","product_id":100051801,"comment_content":"罗老师能把文中提到的血泪教训详细说一下吗？什么问题？怎么解决的？","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504153,"discussion_content":"就是类的析构函数比较大，里面的操作很多，用shared_ptr来管理，由于析构的时机不确定，经常会发生莫名其妙的系统抖动，就像是java/go的gc stop the world一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597971889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378058,"discussion_content":"shared_ptr有引用计数，所以离开作用域时可能还有别的地方引用，不一定会立即析构，只有所有的引用都变成0才会释放资源，这在运行时是不太好把握的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623036306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2344081,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c4/91/a017bf72.jpg","nickname":"coconut","note":"","ucode":"07B95C7A6AC2F7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376345,"discussion_content":"不是离开作用域就会调用析构函数么，为什么说&#34;析构的时机不确定&#34;呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622088106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231276,"user_name":"颓废人才","can_delete":false,"product_type":"c1","uid":1984432,"ip_address":"","ucode":"DED839F68A822D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/47/b0/f44aef75.jpg","comment_is_top":false,"comment_ctime":1593620949,"is_pvip":false,"replies":[{"id":"85398","content":"可以在智能指针的模板参数里定制删除函数，执行特别的资源释放操作，而不是简单的delete。<br><br>智能指针的使用场景就是替代原始指针，只要想自动管理资源，或者想避免资源泄漏，就应该用智能指针。<br><br>所以在用指针的时候，自己心里问一下这个问题，就可以知道是否该用智能指针了。","user_name":"作者回复","comment_id":231276,"uid":"1181974","ip_address":"","utype":1,"ctime":1593652335,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"14478522837","product_id":100051801,"comment_content":"老师您好，请问智能指针的释放和内存管理的结合怎么使用例如以前我们写的智能指针的简单用法：<br>Template&lt;class T&gt;<br>class AutoPtr<br>{<br>private:<br>    T* m_ptr<br>public:<br>    AutoPtr(T* ptr):m_ptr(ptr)   {}<br>    ~AutoPtr()                          {if(ptr) ptr-&gt;release()}          &#47;&#47;析构函数里去回收对象内存<br>}<br>那现在使用stl的智能指针能否做到这步。<br>还有能否介绍下实际项目开发中的一些使用场景和使用小技巧。","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500232,"discussion_content":"可以在智能指针的模板参数里定制删除函数，执行特别的资源释放操作，而不是简单的delete。\n\n智能指针的使用场景就是替代原始指针，只要想自动管理资源，或者想避免资源泄漏，就应该用智能指针。\n\n所以在用指针的时候，自己心里问一下这个问题，就可以知道是否该用智能指针了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593652335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229630,"user_name":"Zhangwh","can_delete":false,"product_type":"c1","uid":1244001,"ip_address":"","ucode":"49CDE4BCFC2534","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/61/c84a45be.jpg","comment_is_top":false,"comment_ctime":1593078827,"is_pvip":false,"replies":[{"id":"84748","content":"课程设计的时候就想的是贵精不贵多，数量少一点学起来不累，容易吸收领会。<br><br>想要了解更多可以去看GitHub上的资料，然后有疑问留言或者GitHub提issue。","user_name":"作者回复","comment_id":229630,"uid":"1181974","ip_address":"","utype":1,"ctime":1593086202,"user_name_real":"罗剑锋"}],"discussion_count":2,"race_medal":0,"score":"14477980715","product_id":100051801,"comment_content":"讲的很好很实用，不过只有30讲，有点少呀","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499572,"discussion_content":"课程设计的时候就想的是贵精不贵多，数量少一点学起来不累，容易吸收领会。\n\n想要了解更多可以去看GitHub上的资料，然后有疑问留言或者GitHub提issue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593086202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2620900,"avatar":"https://static001.geekbang.org/account/avatar/00/27/fd/e4/5a5b5a83.jpg","nickname":"尼莫姬","note":"","ucode":"FA390E7CC8657A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":584220,"discussion_content":"老师，问一下，Github仓库名是叫什么？能发一下链接吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660695665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":499572,"ip_address":"上海"},"score":584220,"extra":""}]}]},{"had_liked":false,"id":221344,"user_name":"Zivon","can_delete":false,"product_type":"c1","uid":2005287,"ip_address":"","ucode":"2C7D4557C2903D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/99/27/15d2c4f5.jpg","comment_is_top":false,"comment_ctime":1590478642,"is_pvip":false,"replies":[{"id":"81639","content":"基本的数据结构强调效率，用智能指针就有点成本略高，当然作为练手还是可以的。<br><br>智能指针最适合的应用场景是“自动资源管理”，链表还是不太合适，而且使用shared_ptr容易出现循环引用，改成weak_ptr会好一些。","user_name":"作者回复","comment_id":221344,"uid":"1181974","ip_address":"","utype":1,"ctime":1590479441,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"14475380530","product_id":100051801,"comment_content":"罗老师，今天尝试使用智能指针改写双向链表的时候感觉实现很麻烦啊，请问在实现这种基本数据结构的时候需要使用智能指针吗","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496432,"discussion_content":"基本的数据结构强调效率，用智能指针就有点成本略高，当然作为练手还是可以的。\n\n智能指针最适合的应用场景是“自动资源管理”，链表还是不太合适，而且使用shared_ptr容易出现循环引用，改成weak_ptr会好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590479441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288273,"user_name":"不如不见","can_delete":false,"product_type":"c1","uid":1253228,"ip_address":"","ucode":"2403A4B831B528","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/6c/43c82d43.jpg","comment_is_top":false,"comment_ctime":1618389308,"is_pvip":false,"replies":[{"id":"104669","content":"很好的问题。<br><br>要清楚智能指针的用途，它主要是用来管理资源，保证自动释放，所以如果是想引用对象，最好用weak_ptr。<br><br>","user_name":"作者回复","comment_id":288273,"uid":"1181974","ip_address":"","utype":1,"ctime":1618450720,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"10208323900","product_id":100051801,"comment_content":"罗老师，请教个问题。确实有时候在很长的链中很难发现shared_ptr的循环引用问题。那有没有什么好的办法（工具）知道自己发生了循环引用。或者一开始在设计的时候，从哪些方面可以考虑或者避免循环引用的问题。感谢。","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518567,"discussion_content":"很好的问题。\n\n要清楚智能指针的用途，它主要是用来管理资源，保证自动释放，所以如果是想引用对象，最好用weak_ptr。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618450720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228998,"user_name":"湖海散人","can_delete":false,"product_type":"c1","uid":1096781,"ip_address":"","ucode":"74C0C825D74CC1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","comment_is_top":false,"comment_ctime":1592877415,"is_pvip":false,"replies":[{"id":"84435","content":"右值、move、完美转发这些概念比较底层，细节比较多，不是特别好解释，也容易用错。<br><br>可以看一下GitHub资源，C++之父BS的faq，说的还是比较清楚。","user_name":"作者回复","comment_id":228998,"uid":"1181974","ip_address":"","utype":1,"ctime":1592878698,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"10182812007","product_id":100051801,"comment_content":"老师，文中提到的右值，move，完美转发会有课程讲到吗","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499291,"discussion_content":"右值、move、完美转发这些概念比较底层，细节比较多，不是特别好解释，也容易用错。\n\n可以看一下GitHub资源，C++之父BS的faq，说的还是比较清楚。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592878698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221104,"user_name":"Zivon","can_delete":false,"product_type":"c1","uid":2005287,"ip_address":"","ucode":"2C7D4557C2903D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/99/27/15d2c4f5.jpg","comment_is_top":false,"comment_ctime":1590405173,"is_pvip":false,"replies":[{"id":"81584","content":"说的很好，智能指针就要这样用。","user_name":"作者回复","comment_id":221104,"uid":"1181974","ip_address":"","utype":1,"ctime":1590454434,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"10180339765","product_id":100051801,"comment_content":"shared_ptr 与unique_ptr最大区别就在于前者可以多个指针共享一个对象或元素，而后者一块内存空间只能由唯一的一个指针持有。<br>使用堆内存新建对象均使用智能指针，就可以不用new&#47;delete","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496334,"discussion_content":"说的很好，智能指针就要这样用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590454434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220277,"user_name":"K. D.","can_delete":false,"product_type":"c1","uid":1914230,"ip_address":"","ucode":"7A1EC6B64D1EAF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/35/76/951b0daf.jpg","comment_is_top":false,"comment_ctime":1590219722,"is_pvip":false,"replies":[{"id":"81319","content":"区别很大，move是转移语义，=是拷贝共享语义，但对于shared_ptr来说一般没有必要用转移语义。","user_name":"作者回复","comment_id":220277,"uid":"1181974","ip_address":"","utype":1,"ctime":1590230800,"user_name_real":"chrono"}],"discussion_count":1,"race_medal":0,"score":"10180154314","product_id":100051801,"comment_content":"罗老师你好，有个问题请教一下：std::move是否也适用于shared_ptr，和=有区别吗？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496109,"discussion_content":"区别很大，move是转移语义，=是拷贝共享语义，但对于shared_ptr来说一般没有必要用转移语义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590230800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220260,"user_name":"sea520","can_delete":false,"product_type":"c1","uid":1508621,"ip_address":"","ucode":"C943EAD079B2A4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIm5rlbJ4HdXLbxmflvW0FW4rTyLcDzHLGDJUJic9W3f1KibWY7mAj9dxUIEVlxDyjwRXEX54KXEn5g/132","comment_is_top":false,"comment_ctime":1590217041,"is_pvip":false,"replies":[{"id":"81322","content":"是啊，我觉得这样的面试官很low，可能他们的水平也就那样了吧。<br><br>不过既然是面试，也只能忍一下了，不过可以看出应聘公司的水平。","user_name":"作者回复","comment_id":220260,"uid":"1181974","ip_address":"","utype":1,"ctime":1590230952,"user_name_real":"chrono"}],"discussion_count":2,"race_medal":0,"score":"10180151633","product_id":100051801,"comment_content":"您好！为什么面试喜欢问cpp底层实现细节。比如说虚表实现，stl实现？有什么最大的价值？万一工作换新语言还要都弄的很清楚吗？那时间成本呢？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496103,"discussion_content":"是啊，我觉得这样的面试官很low，可能他们的水平也就那样了吧。\n\n不过既然是面试，也只能忍一下了，不过可以看出应聘公司的水平。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590230952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292159,"discussion_content":"面试也有成本，市场上主流面试流程不外乎：算法+项目+语言基础+英语技能，对公司来说这是一套比较保险的iso流程。换做你是面试官，你会考察候选人什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595121978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318162,"user_name":"e^(iα)=cosα+isinα⁵·⁰","can_delete":false,"product_type":"c1","uid":2601561,"ip_address":"","ucode":"7A41A00CF5EAF2","user_header":"https://static001.geekbang.org/account/avatar/00/27/b2/59/4ea0e511.jpg","comment_is_top":false,"comment_ctime":1635168018,"is_pvip":false,"replies":[{"id":"115414","content":"这里的“独占”“共享”与线程无关，指的是指针的使用者，也就是常说的“客户代码”。<br><br>比如说，指针只在一个地方使用，那就是独占，被两段代码在不同的地方使用，就是共享。","user_name":"作者回复","comment_id":318162,"uid":"1181974","ip_address":"","utype":1,"ctime":1635230175,"user_name_real":"罗剑锋"}],"discussion_count":1,"race_medal":0,"score":"5930135314","product_id":100051801,"comment_content":"老师，您好，<br>如果指针是“独占”使用，就应该选择 unique_ptr；<br>“共享”使用，就应该选择 shared_ptr；<br>这里独占指的是在单一线程里使用，共享是指可能多个线程都会使用这个指针，是这个意思吗？<br>所以一个叫unique_pte，一个叫shared_ptr","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529124,"discussion_content":"这里的“独占”“共享”与线程无关，指的是指针的使用者，也就是常说的“客户代码”。\n\n比如说，指针只在一个地方使用，那就是独占，被两段代码在不同的地方使用，就是共享。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635230175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281769,"user_name":"超越杨超越","can_delete":false,"product_type":"c1","uid":1028887,"ip_address":"","ucode":"BB390B4B7E19D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/17/9f6d67dc.jpg","comment_is_top":false,"comment_ctime":1614874293,"is_pvip":false,"replies":[{"id":"102288","content":"智能指针的目标是“自动内存管理”，它本身是一个在栈上分配的对象，但里面的内容是在堆上，有那么一点绕。<br><br>当你需要一个生命周期有限，又得“动态”在堆上创建的时候，就用unique_ptr。<br><br>如果不是动态创建，与堆无关，那显然直接用栈对象更省事，没有了智能指针的成本。<br><br>C++对内存管理得太细了，要操心的事情太多。","user_name":"作者回复","comment_id":281769,"uid":"1181974","ip_address":"","utype":1,"ctime":1614907918,"user_name_real":"罗剑锋"}],"discussion_count":2,"race_medal":0,"score":"5909841589","product_id":100051801,"comment_content":"请问老师，如果直接在栈上分配对象，跟unique ptr相比，我应该倾向于哪种呢","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516506,"discussion_content":"智能指针的目标是“自动内存管理”，它本身是一个在栈上分配的对象，但里面的内容是在堆上，有那么一点绕。\n\n当你需要一个生命周期有限，又得“动态”在堆上创建的时候，就用unique_ptr。\n\n如果不是动态创建，与堆无关，那显然直接用栈对象更省事，没有了智能指针的成本。\n\nC++对内存管理得太细了，要操心的事情太多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614907918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2463755,"avatar":"https://static001.geekbang.org/account/avatar/00/25/98/0b/702cb261.jpg","nickname":"凡人我回来","note":"","ucode":"88B34BF95AA3A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366991,"discussion_content":"要看对象占用内存的大小，比如一个100KB的char数组就不要在栈上分配，否则可能运行时进入函数入口的时候就崩了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618232493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222725,"user_name":"silverhawk","can_delete":false,"product_type":"c1","uid":1018649,"ip_address":"","ucode":"BFBC8AF32868DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/19/a15d060d.jpg","comment_is_top":false,"comment_ctime":1590899221,"is_pvip":false,"replies":[{"id":"82133","content":"shared_ptr的缺点就是功能太多，有时候会给人以误解，以为它无所不能，但实际上它用起来也是要当心的，用在不恰当的地方就会有负效果。<br><br>只要恰当使用，shared_ptr还是一个很好的工具，多看文档吧。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590909049,"ip_address":"","comment_id":222725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885866517","product_id":100051801,"comment_content":"说实话，unique_ptr比起裸指针革命性进步，但是shared_ptr 有点over engineering ，感觉有些时候用起来会很坑。不知道你怎么看","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496894,"discussion_content":"shared_ptr的缺点就是功能太多，有时候会给人以误解，以为它无所不能，但实际上它用起来也是要当心的，用在不恰当的地方就会有负效果。\n\n只要恰当使用，shared_ptr还是一个很好的工具，多看文档吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590909049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222199,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1590715797,"is_pvip":false,"replies":[{"id":"81932","content":"uniqptr_ptr不是线程安全的，不要在多线程里用。<br><br>应该用shared_ptr，但它也只有最基本的线程安全保证，不能完全依赖它，具体要看文档里的精确描述。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590725791,"ip_address":"","comment_id":222199,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885683093","product_id":100051801,"comment_content":"老师文稿中的这段代码我改了下如果封装到一个函数里，可以被多线程并发调用吗？unique_ptr尽管有move可以进行转移，但是同一时刻ptr1是不是只允许转移到一个ptr2，而之前转移成功的后续逻辑还没有执行完<br><br><br>void methodtest（uniqptr_ptr ptr1）｛<br>auto ptr2 = std::move(ptr1);         &#47;&#47; 使用move()转移所有权<br>assert(!ptr1 &amp;&amp; ptr2);               &#47;&#47; ptr1变成了空指针<br><br>&#47;&#47;use ptr2 dosomething……<br>｝","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496712,"discussion_content":"uniqptr_ptr不是线程安全的，不要在多线程里用。\n\n应该用shared_ptr，但它也只有最基本的线程安全保证，不能完全依赖它，具体要看文档里的精确描述。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590725791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221132,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1590413741,"is_pvip":false,"replies":[{"id":"81585","content":"<br>1.说的挺好。move操作是转移，不是拷贝，把原unique_ptr给“偷”到了另一个对象里，所有权也就同时转移了。<br><br>2.对，shared_ptr的关键就是引用计数，原来的名字叫counted_ptr。<br><br>3.weak_ptr是“弱引用”，只是观察目标，不增加计数，所以不会导致循环引用，可以再看标准文档。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590454577,"ip_address":"","comment_id":221132,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885381037","product_id":100051801,"comment_content":"1. 我的理解是Unique pointer 是对象而不是指针，但重载了*和箭头，离开了对象的作用域就会被析构，所管理的资源在析构执行过程中被释放；那move操作是不是对对象进行拷贝了才得以传递？<br>shared_ptr 貌似也是对象，重点在于引用计数，对赋值拷贝计数+1，对于执行析构时计数-1，同时判断计数是否0，被管理的资源是否需要释放；<br>没明白为什么weak pointer能避免循环引用，是因为locker，避免错误计数？<br>","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496347,"discussion_content":"\n1.说的挺好。move操作是转移，不是拷贝，把原unique_ptr给“偷”到了另一个对象里，所有权也就同时转移了。\n\n2.对，shared_ptr的关键就是引用计数，原来的名字叫counted_ptr。\n\n3.weak_ptr是“弱引用”，只是观察目标，不增加计数，所以不会导致循环引用，可以再看标准文档。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590454577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358276,"user_name":"ryanxw","can_delete":false,"product_type":"c1","uid":2119325,"ip_address":"北京","ucode":"0B91EAC8D06EED","user_header":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","comment_is_top":false,"comment_ctime":1664162925,"is_pvip":false,"replies":[{"id":"130642","content":"在对象的传参、构造方面有一些优化，可以看它的实现源码。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1665355117,"ip_address":"北京","comment_id":358276,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1664162925","product_id":100051801,"comment_content":"请教一下老师make_shared，make_unique这种工厂函数除了能防止操作空指针的失误，还有哪些方面要比手动构造好呢？能详细说一下吗","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589837,"discussion_content":"在对象的传参、构造方面有一些优化，可以看它的实现源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665355117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344355,"user_name":"大白v5","can_delete":false,"product_type":"c1","uid":2063599,"ip_address":"","ucode":"F343BCC18FA3AF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7c/ef/013087c4.jpg","comment_is_top":false,"comment_ctime":1651487280,"is_pvip":false,"replies":[{"id":"125822","content":"great","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1651736837,"ip_address":"","comment_id":344355,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651487280","product_id":100051801,"comment_content":"weak_ptr与shared_ptr配合着使用，用weak_ptr先确保shared_ptr是持有指针的，然后再放心使用","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570338,"discussion_content":"great","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651736837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343622,"user_name":"娃哈哈","can_delete":false,"product_type":"c1","uid":2981739,"ip_address":"","ucode":"355EADE8479480","user_header":"https://static001.geekbang.org/account/avatar/00/2d/7f/6b/83236a96.jpg","comment_is_top":false,"comment_ctime":1650958386,"is_pvip":false,"replies":[{"id":"125582","content":"不要紧，先做知识储备，再看看其他开源项目，养兵千日用兵一时。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1651128336,"ip_address":"","comment_id":343622,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650958386","product_id":100051801,"comment_content":"老师讲的很好，但是让我用，我还是用不出来，难受呀。。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568412,"discussion_content":"不要紧，先做知识储备，再看看其他开源项目，养兵千日用兵一时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651128336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342656,"user_name":"Geek_5dc6ac","can_delete":false,"product_type":"c1","uid":2981423,"ip_address":"","ucode":"06ADE0DC593735","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/petsz7bmadiaWedwMOhjXB78dl5oumPqBpOFpCJa8PhgIfF8Wibxcf3BianQ9wvlibEWUzXQPrgxWpbtbT8BIDx3rw/132","comment_is_top":false,"comment_ctime":1650385105,"is_pvip":false,"replies":[{"id":"125205","content":"应该不会有内存泄漏吧，lambda表达式的捕获和shared_ptr的引用计数没有必然关系，而且这么基本的用法标准委员会不会没有想到，可以放心地用。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1650423959,"ip_address":"","comment_id":342656,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650385105","product_id":100051801,"comment_content":"shared_ptr和lambda表达式一起用，要注意什么，我知道lambda表达式的实现原理是用一个类对捕获的对象拷贝了一份，我不清楚在什么情况下会lambda表达式和shared_ptr一起使用会导致内存泄漏，能给个例子么","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565271,"discussion_content":"应该不会有内存泄漏吧，lambda表达式的捕获和shared_ptr的引用计数没有必然关系，而且这么基本的用法标准委员会不会没有想到，可以放心地用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650423960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342005,"user_name":"Mari","can_delete":false,"product_type":"c1","uid":2271867,"ip_address":"","ucode":"5260C80C8B6AD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/E73UicmpgFiaZW4SOTGaxoIk9PWue54neNcfsicz7HOxJUucep4jSMyeMMruLNcIlxsE330qOFMacaEQ9Vz4zXJyg/132","comment_is_top":false,"comment_ctime":1649948240,"is_pvip":false,"replies":[{"id":"125016","content":"shared_ptr最好不要传引用，不好控制生命周期，就把它当做一个普通的值对象使用就可以了。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1650010191,"ip_address":"","comment_id":342005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649948240","product_id":100051801,"comment_content":"罗老师，问个问题：shared_ptr作为函数参数时，什么情况传值，什么情况传引用？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563491,"discussion_content":"shared_ptr最好不要传引用，不好控制生命周期，就把它当做一个普通的值对象使用就可以了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650010191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336761,"user_name":"H X","can_delete":false,"product_type":"c1","uid":1982957,"ip_address":"","ucode":"B73939E7C6A8B9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/41/ed/31db8bce.jpg","comment_is_top":false,"comment_ctime":1646357790,"is_pvip":false,"replies":[{"id":"123102","content":"感谢指正，是写错了，会尽快修改。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1646445260,"ip_address":"","comment_id":336761,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1646357790","product_id":100051801,"comment_content":"老罗，section2里面的smart_ptr的case3里的65行，assert（*ptr = 10）应该是手误写错了吧。断言assert要判断是否相等，而不是赋值。 应该是 assert(*ptr == 10) 吧~~","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554524,"discussion_content":"感谢指正，是写错了，会尽快修改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646445260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1982957,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/41/ed/31db8bce.jpg","nickname":"H X","note":"","ucode":"B73939E7C6A8B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":554531,"discussion_content":"老罗谦虚了 人非机器 都会手误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646451498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":554524,"ip_address":""},"score":554531,"extra":""}]}]},{"had_liked":false,"id":336095,"user_name":"H X","can_delete":false,"product_type":"c1","uid":1982957,"ip_address":"","ucode":"B73939E7C6A8B9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/41/ed/31db8bce.jpg","comment_is_top":false,"comment_ctime":1645923111,"is_pvip":false,"replies":[{"id":"122921","content":"欢迎，有什么疑问或者心得一起来探讨。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1646115246,"ip_address":"","comment_id":336095,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1645923111","product_id":100051801,"comment_content":"老罗 我来啦~~ 希望能在我的无人驾驶中 把cpp用的炉火纯青~","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553838,"discussion_content":"欢迎，有什么疑问或者心得一起来探讨。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646115246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1982957,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/41/ed/31db8bce.jpg","nickname":"H X","note":"","ucode":"B73939E7C6A8B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554075,"discussion_content":"老罗 永远的神～。工作中遇到很多数据结构 封装的不好。一水struct 没有union。还有智能指针 几乎全是shared_ptr，我看到很多人说shared_ptr 不好。还有多线程 远远没有使用起来 发挥其威力。同时在真正上车跑的时候，还说老卡 性能很差。以上就是我目前看到的可以优化的方面吧。其他的我功力浅，还没有悟到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646206185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328088,"user_name":"Geek_222086","can_delete":false,"product_type":"c1","uid":2633089,"ip_address":"","ucode":"E49E725F7F9D4A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epNdP7suCIc1jk9WojvhDRJMEAeCCdPKgicJDsiaEbZ5K2cxEArib73QYWLgY5YqX9TJC8blr547fX6w/132","comment_is_top":false,"comment_ctime":1640525465,"is_pvip":false,"replies":[{"id":"119491","content":"unique_ptr这样的用法不是太好，它最好用来管理单个对象而不是数组，如果想要这样的效果应该改用vector。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1640599366,"ip_address":"","comment_id":328088,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640525465","product_id":100051801,"comment_content":"unique_ptr&lt;char&gt;buff1 (new char[100]); 想知道我这样开创的buff1应该要怎么使用呀，我如果用buff1[20]=0x02; 会报错","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541909,"discussion_content":"unique_ptr这样的用法不是太好，它最好用来管理单个对象而不是数组，如果想要这样的效果应该改用vector。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640599366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327728,"user_name":"天翼","can_delete":false,"product_type":"c1","uid":2459638,"ip_address":"","ucode":"82153820B786E0","user_header":"https://static001.geekbang.org/account/avatar/00/25/87/f6/bc199560.jpg","comment_is_top":false,"comment_ctime":1640254127,"is_pvip":false,"replies":[{"id":"119412","content":"createNode()创建共享指针，当函数返回的时候对象销毁，所以引用数就会减1。<br><br>如果是弱指针，因为不影响计数，所以看到的现象就是引用数少了。<br>如果是共享指针，因为又多了一次引用，减1再加1，所以数量不变。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1640390286,"ip_address":"","comment_id":327728,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1640254127","product_id":100051801,"comment_content":"老师，请问一下，在一个函数中创建 weak_ptr 指针并返回后，引用数会减1，但是在函数中创建的 share_ptr 返回后，引用数并不会变化，是什么原因呢？这个有点没法理解。<br><br>class Node final {<br>public:<br>    using this_type = Node;<br>    using shared_type = std::weak_ptr&lt;this_type&gt;;<br>    &#47;&#47; using shared_type = std::shared_ptr&lt;this_type&gt;;<br>public:<br>    shared_type next;<br>};<br><br>Node::shared_type createNode() {<br>    auto retNode = make_shared&lt;Node&gt;();<br>    cout &lt;&lt; &quot;====== retNode ======&quot; &lt;&lt; endl;<br>    cout &lt;&lt; &quot;retNode 引用数量 : &quot; &lt;&lt; retNode.use_count() &lt;&lt; endl;<br>    return retNode;<br>}<br><br>int main() {<br>    auto newNode = createNode();<br>    cout &lt;&lt; &quot;====== newNode ======&quot; &lt;&lt; endl;<br>    cout &lt;&lt; &quot;newNode 引用数量 : &quot; &lt;&lt; newNode.use_count() &lt;&lt; endl;<br>}","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541460,"discussion_content":"createNode()创建共享指针，当函数返回的时候对象销毁，所以引用数就会减1。\n\n如果是弱指针，因为不影响计数，所以看到的现象就是引用数少了。\n如果是共享指针，因为又多了一次引用，减1再加1，所以数量不变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640390286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2459638,"avatar":"https://static001.geekbang.org/account/avatar/00/25/87/f6/bc199560.jpg","nickname":"天翼","note":"","ucode":"82153820B786E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":541462,"discussion_content":"懂了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640390863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":541460,"ip_address":""},"score":541462,"extra":""}]}]},{"had_liked":false,"id":326564,"user_name":"忧天小鸡","can_delete":false,"product_type":"c1","uid":1073947,"ip_address":"","ucode":"A1412BDC108FD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/1b/83ac7733.jpg","comment_is_top":false,"comment_ctime":1639562922,"is_pvip":false,"replies":[{"id":"118669","content":"C++注重运行效率，为开发者提供多种选择，怎么用取决于我们自己。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1639611936,"ip_address":"","comment_id":326564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639562922","product_id":100051801,"comment_content":"这个和苹果的objective- C不是一回事吗？感觉cpp有些操作还是很纠结的啊，不如oc干脆","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539106,"discussion_content":"C++注重运行效率，为开发者提供多种选择，怎么用取决于我们自己。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639611936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326353,"user_name":"Geek_0db98e","can_delete":false,"product_type":"c1","uid":2866319,"ip_address":"","ucode":"593C54FFB06824","user_header":"","comment_is_top":false,"comment_ctime":1639479168,"is_pvip":false,"replies":[{"id":"118538","content":"= delete是禁止了拷贝构造函数，所以unique_ptr只能转移不能拷贝，就不符合标准容器的值语义要求。<br><br>不过可以使用std::move把unique_ptr放进容器里，但同样是因为它不能拷贝，从容器里取出来就不太容易控制它的生命周期。<br><br>一般来说不要在容器里存储unique_ptr，很容易误用，改成shared_ptr比较好。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1639526919,"ip_address":"","comment_id":326353,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639479168","product_id":100051801,"comment_content":"老师你好，有个问题想请教一下，在其他地方看到过：unique_ptr做为STL容器的元素时，不能作为类的成员变量，这句话是否正确，原因是什么呢？我下面这个代码报错使用了已经删除的函数unique_ptr(const unique_ptr&amp;) = delete 是因为上述因素引起的吗？<br>class A{};<br><br>class B{<br>public:<br>  void add(const A&amp;);<br>  std::queue&lt;std::unique_ptr&lt;A&gt;&gt; queue_;<br>};<br><br>void B::add(const A&amp; a){<br>  queue_.push(std::make_unique&lt;A&gt;(a));<br>}","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538800,"discussion_content":"= delete是禁止了拷贝构造函数，所以unique_ptr只能转移不能拷贝，就不符合标准容器的值语义要求。\n\n不过可以使用std::move把unique_ptr放进容器里，但同样是因为它不能拷贝，从容器里取出来就不太容易控制它的生命周期。\n\n一般来说不要在容器里存储unique_ptr，很容易误用，改成shared_ptr比较好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639526919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323572,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1637997400,"is_pvip":false,"replies":[{"id":"117495","content":"是的，当然用函数指针也可以。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1638143247,"ip_address":"","comment_id":323572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637997400","product_id":100051801,"comment_content":"随意找节课程，就书籍中的疑问提个问题：map+lambda表达式替代if&#47;else&#47;switch，含义是用数字或者字符串作为key，lambda作为value，然后匹配key执行对应的lamba?我一般用了函数指针","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534218,"discussion_content":"是的，当然用函数指针也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638143247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321214,"user_name":"侠客°","can_delete":false,"product_type":"c1","uid":2608611,"ip_address":"","ucode":"73C68093919F5E","user_header":"https://static001.geekbang.org/account/avatar/00/27/cd/e3/cf6d1491.jpg","comment_is_top":false,"comment_ctime":1636710983,"is_pvip":false,"replies":[{"id":"116629","content":"有get方法，可以给出内部的原始指针，可以看一下接口文档。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1636719643,"ip_address":"","comment_id":321214,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636710983","product_id":100051801,"comment_content":"如果有的api或者接口只能传递普通的指针，这时智能指针要怎么处理呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530244,"discussion_content":"有get方法，可以给出内部的原始指针，可以看一下接口文档。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636719643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296765,"user_name":"鲍勃","can_delete":false,"product_type":"c1","uid":1142312,"ip_address":"","ucode":"9B5E4A5B1A54E5","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/28/1e307312.jpg","comment_is_top":false,"comment_ctime":1623152076,"is_pvip":false,"replies":[{"id":"107819","content":"理论上来说是不安全的，因为脱离了智能指针的控制，有隐患。<br><br>但如果谨慎地使用，不做危险操作（移动指针、删除指针），也是可以的，但毕竟违反了智能指针的初衷，所以最好少用。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1623200660,"ip_address":"","comment_id":296765,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623152076","product_id":100051801,"comment_content":"罗老师，请问智能指针使用get方法获取裸指针作为函数参数来使用安全吗？<br>auto ptr = make_shared&lt;int&gt;(42);<br>func (ptr.get());","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521575,"discussion_content":"理论上来说是不安全的，因为脱离了智能指针的控制，有隐患。\n\n但如果谨慎地使用，不做危险操作（移动指针、删除指针），也是可以的，但毕竟违反了智能指针的初衷，所以最好少用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623200660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296489,"user_name":"河山","can_delete":false,"product_type":"c1","uid":1128970,"ip_address":"","ucode":"244F0F35FF4112","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/0a/91f0d27a.jpg","comment_is_top":false,"comment_ctime":1622997422,"is_pvip":false,"replies":[{"id":"107643","content":"这种比较复杂的情况，标准库里的智能指针就不适用了，只好自己造轮子。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1623027648,"ip_address":"","comment_id":296489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622997422","product_id":100051801,"comment_content":"不得不吐槽下某些基于resume的共享内存技术栈，基本没法用智能指针","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521457,"discussion_content":"这种比较复杂的情况，标准库里的智能指针就不适用了，只好自己造轮子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623027648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289487,"user_name":"dog_brother","can_delete":false,"product_type":"c1","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1619051704,"is_pvip":true,"replies":[{"id":"105028","content":"unique_ptr的目的很简单，就是对裸指针的封装，没有提供线程安全机制，多线程操作当然就可能会出问题。<br><br>而shared_ptr的目的是指针共享，考虑了多线程应用的场景，引用计数是原子的，在多线程里用不会出问题。<br><br>当然，shared_ptr也不是绝对的线程安全，如果多线程同时改指针就会有竞争。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1619059327,"ip_address":"","comment_id":289487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1619051704","product_id":100051801,"comment_content":"老师，看到评论说unique_ptr是线程不安全的，shared_ptr是线程安全的，这个是什么原因呢，怎么理解呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518929,"discussion_content":"unique_ptr的目的很简单，就是对裸指针的封装，没有提供线程安全机制，多线程操作当然就可能会出问题。\n\n而shared_ptr的目的是指针共享，考虑了多线程应用的场景，引用计数是原子的，在多线程里用不会出问题。\n\n当然，shared_ptr也不是绝对的线程安全，如果多线程同时改指针就会有竞争。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619059327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246322,"user_name":"池强泽","can_delete":false,"product_type":"c1","uid":1231762,"ip_address":"","ucode":"1E5A4D70FE9C96","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/92/3dbeb6ab.jpg","comment_is_top":false,"comment_ctime":1599276946,"is_pvip":false,"replies":[{"id":"90613","content":"这里比较偏实践经验，有空也可以再补一些理论知识。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1599440873,"ip_address":"","comment_id":246322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599276946","product_id":100051801,"comment_content":"很实在，有重点","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505113,"discussion_content":"这里比较偏实践经验，有空也可以再补一些理论知识。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599440873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244259,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1598444442,"is_pvip":false,"replies":[{"id":"89968","content":"对，class... Args这样的可变模板参数可以对照printf来理解，一个是编译时参数数量任意，一个是运行时参数数量任意。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1598492118,"ip_address":"","comment_id":244259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598444442","product_id":100051801,"comment_content":"罗老师,template&lt;class T, class... Args&gt;可以这样理解吗: T是用来和unique_ptr搭配的;而Args是任意数目,任意类型的参数类型,调用起来类似这样的:auto ptr = my_make_unique&lt;string&gt;(&quot;hello&quot;,  8, 26, 7.7);","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504536,"discussion_content":"对，class... Args这样的可变模板参数可以对照printf来理解，一个是编译时参数数量任意，一个是运行时参数数量任意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598492118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240730,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":2001918,"ip_address":"","ucode":"BDB1F211D11C54","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8b/fe/a7d1c17a.jpg","comment_is_top":false,"comment_ctime":1597046837,"is_pvip":false,"replies":[{"id":"88955","content":"weak_ptr同样是智能指针，但它是弱引用，不持有指针的所有权，不会导致引用计数增加，不能独立使用。<br><br>掌握了上面说的几个关键点就好理解了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1597107151,"ip_address":"","comment_id":240730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597046837","product_id":100051801,"comment_content":"没看懂weak_ptr，感觉可以多补充点。。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503543,"discussion_content":"weak_ptr同样是智能指针，但它是弱引用，不持有指针的所有权，不会导致引用计数增加，不能独立使用。\n\n掌握了上面说的几个关键点就好理解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597107151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240029,"user_name":"张飞Dear","can_delete":false,"product_type":"c1","uid":2004589,"ip_address":"","ucode":"EECEDF12DC7EB9","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/6d/85723167.jpg","comment_is_top":false,"comment_ctime":1596721018,"is_pvip":false,"replies":[{"id":"88638","content":"1.说的很好。<br><br>2.在现代C++里不推荐使用裸数组，应当尽量用array和vector，更安全也更容易操作。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596761804,"ip_address":"","comment_id":240029,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596721018","product_id":100051801,"comment_content":"1，所有权问题，unique_ptr 只能一个独自使用，不能进行赋值，必须要赋值是要用std::move() 来进行。不能进行加减运算。<br>shared_ptr 能够共享使用，可以进行赋值。<br>weak_ptr  弱引用，但是可以通过lock  来调用shared_ptr。<br>2，对于 int[]  这种不太理解，  网上资料有说 C++11 对此没有支持，后面的版本才有，但是在实际中 用 int[]  char[] 等 有很多。尤其是对 数据点阵，我们都是使用BYTE数组来进行处理的。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503312,"discussion_content":"1.说的很好。\n\n2.在现代C++里不推荐使用裸数组，应当尽量用array和vector，更安全也更容易操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596761804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238807,"user_name":"皮皮鲁","can_delete":false,"product_type":"c1","uid":1691670,"ip_address":"","ucode":"75CD824292FDC8","user_header":"https://static001.geekbang.org/account/avatar/00/19/d0/16/7d0d02cc.jpg","comment_is_top":false,"comment_ctime":1596325441,"is_pvip":false,"replies":[{"id":"88276","content":"可以在模板参数里定制删除器deleter，在里面用内存池。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596417091,"ip_address":"","comment_id":238807,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596325441","product_id":100051801,"comment_content":"请问下罗老师，在嵌入式开发领域，如果用了C++，且对new操作符（重载），malloc都用了内存池，这种情况下，在函数体内申请使用内存，为了防止栈溢出（栈空间比较有限），现在创建对象，是否可以用unique_ptr，如果用了unique_ptr如何和内存池关联？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502859,"discussion_content":"可以在模板参数里定制删除器deleter，在里面用内存池。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596417091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233854,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1594480422,"is_pvip":false,"replies":[{"id":"86323","content":"<br>1.要理解智能指针的目的，为了自动管理资源，像这样的动态数组，应该用vector。<br><br>2.不建议用智能指针管理new []出来的数据，它析构时用的是delete，所以删除会有问题。<br><br>3.是的，但shared_ptr的问题在于析构的时机不确定，难于排查定位。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594524709,"ip_address":"","comment_id":233854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594480422","product_id":100051801,"comment_content":"老师，又有疑问想问你了：<br>1. 这样的裸指针char* pdata = new char[8];有必要使用智能指针吗？<br>2. 如果使用unique_ptr，是不是和unique_ptr&lt;char&gt; ptr = make_unique&lt;char&gt;(8);等价？我感觉写得有点问题。<br>3. shared_ptr 的销毁动作可能引起整个世界静止，如果class的析构函数中有IO阻塞，不管是否使用智能指针，整个世界不也同样静止了吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501188,"discussion_content":"\n1.要理解智能指针的目的，为了自动管理资源，像这样的动态数组，应该用vector。\n\n2.不建议用智能指针管理new []出来的数据，它析构时用的是delete，所以删除会有问题。\n\n3.是的，但shared_ptr的问题在于析构的时机不确定，难于排查定位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594524709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229925,"user_name":"IAmLinGe","can_delete":false,"product_type":"c1","uid":1994848,"ip_address":"","ucode":"9DCDA0FA5CF2B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/TXAUcbHlPbyEibtUB2STNgmOb6oQdO8nKuA9nnhuI76Ccv2U5Vgxfp8YxvGeKQP8k47ULBwVGglH4DibOzH8Qfeg/132","comment_is_top":false,"comment_ctime":1593203259,"is_pvip":false,"replies":[{"id":"84865","content":"RAII的关键是利用C++构造函数和析构函数的特性，对象创建时自动调用构造函数，离开作用域失效时自动调用析构函数。<br><br>明确了这两点，就可以在构造函数里写代码自动获取资源，在析构函数里自动释放资源，再有就是理解作用域和对象的生命周期了。就像是一个微型的垃圾回收机制。<br><br>智能指针，还有后面线程锁的LockGuard，都用的是RAII，结合它们再体会一下自动资源管理吧。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593240272,"ip_address":"","comment_id":229925,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593203259","product_id":100051801,"comment_content":"RAII不是特别清楚，编程除了智能指针，如何在实际开发中用到这种思想？能举例详细讲讲就好了。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499698,"discussion_content":"RAII的关键是利用C++构造函数和析构函数的特性，对象创建时自动调用构造函数，离开作用域失效时自动调用析构函数。\n\n明确了这两点，就可以在构造函数里写代码自动获取资源，在析构函数里自动释放资源，再有就是理解作用域和对象的生命周期了。就像是一个微型的垃圾回收机制。\n\n智能指针，还有后面线程锁的LockGuard，都用的是RAII，结合它们再体会一下自动资源管理吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593240272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229924,"user_name":"IAmLinGe","can_delete":false,"product_type":"c1","uid":1994848,"ip_address":"","ucode":"9DCDA0FA5CF2B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/TXAUcbHlPbyEibtUB2STNgmOb6oQdO8nKuA9nnhuI76Ccv2U5Vgxfp8YxvGeKQP8k47ULBwVGglH4DibOzH8Qfeg/132","comment_is_top":false,"comment_ctime":1593202939,"is_pvip":false,"replies":[{"id":"84866","content":"<br>1.unique_ptr不允许拷贝，所以在函数参数中可以用引用的形式，或者用std::move，但要明确，为什么要传递unique_ptr进函数，所有权是否还是唯一的，是否要转移，如果不清楚就很容易误用导致错误。<br><br>2.函数返回unique_ptr很简单，直接return就行了，它会自己转移所有权，参考make_unique()函数。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593240411,"ip_address":"","comment_id":229924,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593202939","product_id":100051801,"comment_content":"如何在函数参数中使用unique_ptr？函数如何返回一个unique_ptr？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499697,"discussion_content":"\n1.unique_ptr不允许拷贝，所以在函数参数中可以用引用的形式，或者用std::move，但要明确，为什么要传递unique_ptr进函数，所有权是否还是唯一的，是否要转移，如果不清楚就很容易误用导致错误。\n\n2.函数返回unique_ptr很简单，直接return就行了，它会自己转移所有权，参考make_unique()函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593240411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228545,"user_name":"禾众","can_delete":false,"product_type":"c1","uid":1105469,"ip_address":"","ucode":"C37D2965ECA3A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/3d/b74ee1af.jpg","comment_is_top":false,"comment_ctime":1592731142,"is_pvip":false,"replies":[{"id":"84265","content":"意思是如果析构函数有磁盘io这样的阻塞操作，那么shared_ptr销毁就会被阻塞，从而整个程序也就被阻塞了。<br><br>整个取决于shared_ptr管理对象的析构函数，一般不会有什么问题，只有极特殊的情况才要考虑。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592740370,"ip_address":"","comment_id":228545,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592731142","product_id":100051801,"comment_content":"shared_ptr 的销毁动作可能引起整个世界静止不动的例子没有看明白，老师的意思是说 shared_ptr 对象析构花的时间比普通 delete 要久吗，为什么呢？老师给的析构函数只有一行注释，没看出有什么特别的。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499070,"discussion_content":"意思是如果析构函数有磁盘io这样的阻塞操作，那么shared_ptr销毁就会被阻塞，从而整个程序也就被阻塞了。\n\n整个取决于shared_ptr管理对象的析构函数，一般不会有什么问题，只有极特殊的情况才要考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592740370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226256,"user_name":"paradoxxx","can_delete":false,"product_type":"c1","uid":1233527,"ip_address":"","ucode":"FD94E547273B18","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/77/bae2045d.jpg","comment_is_top":false,"comment_ctime":1592017497,"is_pvip":false,"replies":[{"id":"83325","content":"感谢指正，疏忽了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592023206,"ip_address":"","comment_id":226256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592017497","product_id":100051801,"comment_content":"老师，第一段代码里 assert(*ptr1 = 10); 应该是assert(*ptr1 == 10); ","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498168,"discussion_content":"感谢指正，疏忽了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592023206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224062,"user_name":"秀","can_delete":false,"product_type":"c1","uid":1347035,"ip_address":"","ucode":"0E7B6FAEA23CA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVzmZvQuYSw5IfzprjgQj9U3Jmrez8YWU1hhruUOvZpvQOwvVcjDyaBKs0Up09OaZNzKaHibVwAJA/132","comment_is_top":false,"comment_ctime":1591264094,"is_pvip":false,"replies":[{"id":"82555","content":"weak_ptr是为了防止循环引用，还有就是“弱引用”“弱联系”，只是观察目标。<br><br>关键是要明确指针与指向对象的关系，是要一直持有（强关系），还是想偶尔用一下（弱关系）。<br><br>例子不太好找，一般要仔细分析指针的用途和目的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591324485,"ip_address":"","comment_id":224062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591264094","product_id":100051801,"comment_content":"老师你好，想问一下是否有一些明确的规则来区分是否要搭配weak指针使用。能不能帮忙再举个例子。谢谢。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497351,"discussion_content":"weak_ptr是为了防止循环引用，还有就是“弱引用”“弱联系”，只是观察目标。\n\n关键是要明确指针与指向对象的关系，是要一直持有（强关系），还是想偶尔用一下（弱关系）。\n\n例子不太好找，一般要仔细分析指针的用途和目的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591324485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223737,"user_name":"Seven","can_delete":false,"product_type":"c1","uid":1656378,"ip_address":"","ucode":"6F502CDCAD7A79","user_header":"https://static001.geekbang.org/account/avatar/00/19/46/3a/35d9cc02.jpg","comment_is_top":false,"comment_ctime":1591169121,"is_pvip":false,"replies":[{"id":"82396","content":"Android不了解，不过现代编程语言里的大部分特性应该都是从C++里拿过来的，或者是针对C++改良的。<br><br>自动类型推导其实是一个很古老的特性，早在80年代C++初期就有实现，但因为考虑到对C的兼容性，所以才推迟到了C++11。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591174920,"ip_address":"","comment_id":223737,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591169121","product_id":100051801,"comment_content":"越看越像android提供的指针，不过应该说像C++指针，老师可以讲一期，所有语言特性来自于C，自动类型检测不就是JS当中的一样么，加油","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497229,"discussion_content":"Android不了解，不过现代编程语言里的大部分特性应该都是从C++里拿过来的，或者是针对C++改良的。\n\n自动类型推导其实是一个很古老的特性，早在80年代C++初期就有实现，但因为考虑到对C的兼容性，所以才推迟到了C++11。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591174920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068914,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4f/72/0c75c0bf.jpg","nickname":"arvilin","note":"","ucode":"D40D4021226612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278506,"discussion_content":"share_ptr、weak_ptr让我想起来ios里面strong强类型跟weak","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591193735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221607,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1590548526,"is_pvip":true,"replies":[{"id":"81718","content":"不建议用智能指针管理数组，虽然这样也可以，最好用容器。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590553013,"ip_address":"","comment_id":221607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590548526","product_id":100051801,"comment_content":"智能指针管理数组，是不是不会移动释放，需要自己手动书写？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496512,"discussion_content":"不建议用智能指针管理数组，虽然这样也可以，最好用容器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590553013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221462,"user_name":"李锐","can_delete":false,"product_type":"c1","uid":1688247,"ip_address":"","ucode":"476273EDCD86D2","user_header":"https://static001.geekbang.org/account/avatar/00/19/c2/b7/f7facaae.jpg","comment_is_top":false,"comment_ctime":1590503209,"is_pvip":false,"replies":[{"id":"81689","content":"动态数组虽然也可以用shared_ptr来管理，但不是很推荐，其实更应该用容器vector，这个在C++98里就有。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590540588,"ip_address":"","comment_id":221462,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590503209","product_id":100051801,"comment_content":"罗老师，您好，我的工作场景中经常需要new一个数组来缓存从下位机采集到的数据，比如new [100]来缓存100帧图像数据，请问下，c++11中智能指针如何去管理new数组，谢谢","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496459,"discussion_content":"动态数组虽然也可以用shared_ptr来管理，但不是很推荐，其实更应该用容器vector，这个在C++98里就有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590540588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026967,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/97/57fa9ad5.jpg","nickname":"x404","note":"","ucode":"96FEC9853BA413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274837,"discussion_content":"你也是做上位机的吗，感觉用c++做上位机有点慢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590625302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220726,"user_name":"fl260919784","can_delete":false,"product_type":"c1","uid":1045678,"ip_address":"","ucode":"D6E10B8BDD0BB8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/ae/3b101c00.jpg","comment_is_top":false,"comment_ctime":1590314738,"is_pvip":false,"replies":[{"id":"81459","content":"可以用std::dynamic_pointer_cast，在shared_ptr里存储基类指针，然后再动态转型成子类。<br><br>shared_ptr很灵活，有很多形式的构造函数和辅助工具，你说的这种情形很常见，所以肯定考虑到了，需要看接口文档，找出合适自己的解决办法。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590368217,"ip_address":"","comment_id":220726,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590314738","product_id":100051801,"comment_content":"罗老师好，咨询个shared_ptr与多态的问题：<br>class A {public: virtual ~A() = default;}; &#47;&#47;虚析构<br>class B: public A{};                       &#47;&#47;共有继承<br><br>class HolderA {public: std::shared_ptr&lt;A&gt; data;}; &#47;&#47;最少知道原则，只需持有A即可<br>class HolderB {public: std::shared_ptr&lt;B&gt; data;}; &#47;&#47;需要派生类的高级特性，所以需要持有B<br><br>存在如下的使用场景：<br>std::shared_ptr&lt;B&gt; data = std::make_shared&lt;B&gt;();<br>需要将data同时交付给HolderA&#47;HoladerB，这样化的话，发现搞不定了。。。（HolderA没法被赋值）<br><br>思考：<br>1、如果HolderA&#47;HolderB中使用裸指针的话，还是比较轻松的，指针的生命周期交由外部统一管理，但是感觉指针管理方式不统一。<br>2、如果使用shared_ptr那该如何实现？<br>3、像此类共享场景、或者类的数据成员，一般在裸指针与shared_ptr如何选择<br>4、unique_ptr不存在共享，就没这么麻烦","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496222,"discussion_content":"可以用std::dynamic_pointer_cast，在shared_ptr里存储基类指针，然后再动态转型成子类。\n\nshared_ptr很灵活，有很多形式的构造函数和辅助工具，你说的这种情形很常见，所以肯定考虑到了，需要看接口文档，找出合适自己的解决办法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590368217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045678,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f4/ae/3b101c00.jpg","nickname":"fl260919784","note":"","ucode":"D6E10B8BDD0BB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272680,"discussion_content":"static_pointer_cast 转换完成后，虽然指针地址不一定相同（多继承），但引用计数依旧有效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590332746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220548,"user_name":"52rock","can_delete":false,"product_type":"c1","uid":1025632,"ip_address":"","ucode":"3C4376A8EAAEF6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/60/0eac2751.jpg","comment_is_top":false,"comment_ctime":1590287444,"is_pvip":true,"replies":[{"id":"81426","content":"xp系统太老了，但新版的vc应该也支持编译出xp运行的应用吧。<br><br>抱歉很久没有做Windows开发了，这方面不是太了解。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590328280,"ip_address":"","comment_id":220548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590287444","product_id":100051801,"comment_content":"开发的软件要在xp系统上运行貌似这些都不能用","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496176,"discussion_content":"xp系统太老了，但新版的vc应该也支持编译出xp运行的应用吧。\n\n抱歉很久没有做Windows开发了，这方面不是太了解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590328280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220321,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1590223017,"is_pvip":false,"replies":[{"id":"81321","content":"说的很好，有了智能指针，就不需要new和delete了。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590230882,"ip_address":"","comment_id":220321,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590223017","product_id":100051801,"comment_content":"1.unique的所有权只能转移，不能增加。shared可以转移也可以增加。多个线程访问一个unique或shared也存在并发问题。unique没有循环引用的问题。<br><br>2. 尽量使用智能指针，就可以避免手动管理了。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496119,"discussion_content":"说的很好，有了智能指针，就不需要new和delete了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590230882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220287,"user_name":"Confidant.","can_delete":false,"product_type":"c1","uid":1660039,"ip_address":"","ucode":"6E137F863906B0","user_header":"https://static001.geekbang.org/account/avatar/00/19/54/87/3b1f9de4.jpg","comment_is_top":false,"comment_ctime":1590220865,"is_pvip":false,"replies":[{"id":"81324","content":"shared_ptr也可以自定义删除函数，自己定制管理策略，这个就需要仔细分析资源的生存周期了，涉及到底层必须小心。<br><br>C++提供的工具很多，用法也复杂，得仔细看接口文档，很可能就会在里面找到好的解决方案。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590231181,"ip_address":"","comment_id":220287,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590220865","product_id":100051801,"comment_content":"问老师一个我最近被困惑到的智能指针相关的问题，多线程的一些系统调用，它需要传递一些指针来作为参数，比如Linux或Windows底下的系统线程中子线程的参数，比如CreateIoCompectionPort里面的参数，我们从A线程传参，B线程取参，中间可能经过了操作系统，这种情况是无法使用智能指针的，那是不是只能靠手动来管理呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496114,"discussion_content":"shared_ptr也可以自定义删除函数，自己定制管理策略，这个就需要仔细分析资源的生存周期了，涉及到底层必须小心。\n\nC++提供的工具很多，用法也复杂，得仔细看接口文档，很可能就会在里面找到好的解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590231181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220273,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1590219308,"is_pvip":true,"replies":[{"id":"81320","content":"析构，里面有复杂操作阻塞线程。<br><br>shared_ptr只提供基本的线程安全，需要去细看文档，不能完全依赖它。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590230854,"ip_address":"","comment_id":220273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590219308","product_id":100051801,"comment_content":" shared_ptr 的销毁动作，这段说世界停止，是为什么停止，做了什么操作导致世界停止，智能指针不是线程安全？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496107,"discussion_content":"析构，里面有复杂操作阻塞线程。\n\nshared_ptr只提供基本的线程安全，需要去细看文档，不能完全依赖它。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590230854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220215,"user_name":"HoshinoKanade","can_delete":false,"product_type":"c1","uid":1770245,"ip_address":"","ucode":"AA8B4F90FB9E5F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/03/05/140068f9.jpg","comment_is_top":false,"comment_ctime":1590207274,"is_pvip":false,"replies":[{"id":"81294","content":"boost里有一个intrusive_ptr，应该可以解决你的问题，可惜它不是标准库里的。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590214123,"ip_address":"","comment_id":220215,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1590207274","product_id":100051801,"comment_content":"項目正在使用一個自家編寫的win32 api實現的引用計數器proxy，最近陷入了不可移植性的苦惱。請問老師有沒有辦法利用c++11的好處，而不需要停止使用這已經滲透在代碼庫所有角落的自家類別？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496090,"discussion_content":"boost里有一个intrusive_ptr，应该可以解决你的问题，可惜它不是标准库里的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590214123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273367,"discussion_content":"这个需要仔细看shared_ptr的文档了，我感觉好像是不行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590453173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1770245,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/03/05/140068f9.jpg","nickname":"HoshinoKanade","note":"","ucode":"AA8B4F90FB9E5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272959,"discussion_content":"謝謝老師。組內有人拒絕使用boost，哎。在自家類別實現改為包著一個shared_ptr似乎也可行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590382359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220206,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1590203479,"is_pvip":true,"replies":[{"id":"81295","content":"红黑树结构应该是一样的，但区别在于是否允许key重复。还有，set里只是key，而map是key-value。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590214182,"ip_address":"","comment_id":220206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590203479","product_id":100051801,"comment_content":"罗老师，问一个跟本节无关的问题，是今天早上脑袋里闪过的问题。STL中map set multimap multiset内部都是红黑树实现的，其原理有什么不同吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496083,"discussion_content":"红黑树结构应该是一样的，但区别在于是否允许key重复。还有，set里只是key，而map是key-value。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590214182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}