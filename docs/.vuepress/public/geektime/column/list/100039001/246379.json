{"id":246379,"title":"95 | 项目实战二：设计实现一个通用的接口幂等框架（实现）","content":"<p>上一节课，我们讲解了幂等框架的设计思路。在正常情况下，幂等框架的处理流程是比较简单的。调用方生成幂等号，传递给实现方，实现方记录幂等号或者用幂等号判重。但是，幂等框架要处理的异常情况很多，这也是设计的复杂之处和难点之处。比如，代码运行异常、业务系统宕机、幂等框架异常。</p><p>虽然幂等框架要处理的异常很多，但考虑到开发成本以及简单易用性，我们对某些异常的处理在工程上做了妥协，交由业务系统或者人工介入处理。这样就大大简化了幂等框架开发的复杂度和难度。</p><p>今天，我们针对幂等框架的设计思路，讲解如何编码实现。跟限流框架的讲解相同，对于幂等框架，我们也会还原它的整个开发过程，从V1版本需求、最小原型代码讲起，然后讲解如何review代码发现问题、重构代码解决问题，最终得到一份易读、易扩展、易维护、灵活、可测试的高质量代码实现。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>V1版本功能需求</h2><p>上一节课给出的设计思路比较零散，重点还是在讲设计的缘由，为什么要这么设计。今天，我们再重新整理一下，经过上一节课的分析梳理最终得到的设计思路。虽然上一节课的分析很复杂、很烧脑，但思从深而行从简，最终得到的幂等框架的设计思路是很简单的，主要包含下面这样两个主要的功能开发点：</p><!-- [[[read_end]]] --><ul>\n<li>实现生成幂等号的功能；</li>\n<li>实现存储、查询、删除幂等号的功能。</li>\n</ul><p>因为功能非常简单，所以，我们就不再进一步裁剪了。在V1版本中，我们会实现上面罗列的所有功能。针对这两个功能点，我们先来说下实现思路。</p><p><strong>我们先来看，如何生成幂等号。</strong></p><p>幂等号用来标识两个接口请求是否是同一个业务请求，换句话说，两个接口请求是否是重试关系，而非独立的两个请求。接口调用方需要在发送接口请求的同时，将幂等号一块传递给接口实现方。那如何来生成幂等号呢？一般有两种生成方式。一种方式是集中生成并且分派给调用方，另一种方式是直接由调用方生成。</p><p>对于第一种生成方式，我们需要部署一套幂等号的生成系统，并且提供相应的远程接口（Restful或者RPC接口），调用方通过调用远程接口来获取幂等号。这样做的好处是，对调用方完全隐藏了幂等号的实现细节。当我们需要改动幂等号的生成算法时，调用方不需要改动任何代码。</p><p>对于第二种生成方式，调用方按照跟接口实现方预先商量好的算法，自己来生成幂等号。这种实现方式的好处在于，不用像第一种方式那样调用远程接口，所以执行效率更高。但是，一旦需要修改幂等号的生成算法，就需要修改每个调用方的代码。</p><p>并且，每个调用方自己实现幂等号的生成算法也会有问题。一方面，重复开发，违反DRY原则。另一方面，工程师的开发水平层次不齐，代码难免会有bug。除此之外，对于复杂的幂等号生成算法，比如依赖外部系统Redis等，显然更加适合上一种实现方式，可以避免调用方为了使用幂等号引入新的外部系统。</p><p>权衡来讲，既考虑到生成幂等号的效率，又考虑到代码维护的成本，我们选择第二种实现方式，并且在此基础上做些改进，由幂等框架来统一提供幂等号生成算法的代码实现，并封装成开发类库，提供给各个调用方复用。除此之外，我们希望生成幂等号的算法尽可能的简单，不依赖其他外部系统。</p><p>实际上，对于幂等号的唯一要求就是全局唯一。全局唯一ID的生成算法有很多。比如，简单点的有取UUID，复杂点的可以把应用名拼接在UUID上，方便做问题排查。总体上来讲，幂等号的生成算法并不难。</p><p><strong>我们再来看，如何实现幂等号的存储、查询和删除。</strong></p><p>从现在的需求来看，幂等号只是为了判重。在数据库中，我们只需要存储一个幂等号就可以，不需要太复杂的存储结构，所以，我们不选择使用复杂的关系型数据库，而是选择使用更加简单的、读写更加快速的键值数据库，比如Redis。</p><p>在幂等判重逻辑中，我们需要先检查幂等号是否存在。如果没有存在，再将幂等号存储进Redis。多个线程（同一个业务实例的多个线程）或者多进程（多个业务实例）同时执行刚刚的“检查-设置”逻辑时，就会存在竞争关系（竞态，race condition）。比如，A线程检查幂等号不存在，在A线程将幂等号存储进Redis之前，B线程也检查幂等号不存在，这样就会导致业务被重复执行。为了避免这种情况发生，我们要给“检查-设置”操作加锁，让同一时间只有一个线程能执行。除此之外，为了避免多进程之间的竞争，普通的线程锁还不起作用，我们需要分布式锁。</p><p>引入分布式锁会增加开发的难度和复杂度，而Redis本身就提供了把“检查-设置”操作作为原子操作执行的命令：setnx(key, value)。它先检查key是否存在，如果存在，则返回结果0；如果不存在，则将key值存下来，并将值设置为value，返回结果1。因为Redis本身是单线程执行命令的，所以不存在刚刚讲到的并发问题。</p><h2>最小原型代码实现</h2><p>V1版本要实现的功能和实现思路，现在已经很明确了。现在，我们来看下具体的代码实现。还是跟限流框架同样的实现方法，我们先不考虑设计和代码质量，怎么简单怎么来，先写出MVP代码，然后基于这个最简陋的版本做优化重构。</p><p>V1版本的功能非常简单，我们用一个类就能搞定，代码如下所示。只用了不到30行代码，就搞定了一个框架，是不是觉得有点不可思议。对于这段代码，你可以先思考下，有哪些值得优化的地方。</p><pre><code>public class Idempotence {\n  private JedisCluster jedisCluster;\n\n  public Idempotence(String redisClusterAddress, GenericObjectPoolConfig config) {\n    String[] addressArray= redisClusterAddress.split(&quot;;&quot;);\n    Set&lt;HostAndPort&gt; redisNodes = new HashSet&lt;&gt;();\n    for (String address : addressArray) {\n      String[] hostAndPort = address.split(&quot;:&quot;);\n      redisNodes.add(new HostAndPort(hostAndPort[0], Integer.valueOf(hostAndPort[1])));\n    }\n    this.jedisCluster = new JedisCluster(redisNodes, config);\n  }\n  \n  public String genId() {\n    return UUID.randomUUID().toString();\n  }\n\n  public boolean saveIfAbsent(String idempotenceId) {\n    Long success = jedisCluster.setnx(idempotenceId, &quot;1&quot;);\n    return success == 1;\n  }\n\n  public void delete(String idempotenceId) {\n    jedisCluster.del(idempotenceId);\n  }\n}\n</code></pre><h2>Review最小原型代码</h2><p>尽管MVP代码很少，但仔细推敲，也有很多值得优化的地方。现在，我们就站在Code Reviewer的角度，分析一下这段代码。我把我的所有意见都放到代码注释中了，你可以对照着代码一块看下。</p><pre><code>public class Idempotence {\n  // comment-1: 如果要替换存储方式，是不是很麻烦呢？\n  private JedisCluster jedisCluster;\n\n  // comment-2: 如果幂等框架要跟业务系统复用jedisCluster连接呢？\n  // comment-3: 是不是应该注释说明一下redisClusterAddress的格式，以及config是否可以传递进null呢？\n  public Idempotence(String redisClusterAddress, GenericObjectPoolConfig config) {\n    // comment-4: 这段逻辑放到构造函数里，不容易写单元测试呢\n    String[] addressArray= redisClusterAddress.split(&quot;;&quot;);\n    Set&lt;HostAndPort&gt; redisNodes = new HashSet&lt;&gt;();\n    for (String address : addressArray) {\n      String[] hostAndPort = address.split(&quot;:&quot;);\n      redisNodes.add(new HostAndPort(hostAndPort[0], Integer.valueOf(hostAndPort[1])));\n    }\n    this.jedisCluster = new JedisCluster(redisNodes, config);\n  }\n  \n  // comment-5: generateId()是不是比缩写要好点？\n  // comment-6: 根据接口隔离原则，这个函数跟其他函数的使用场景完全不同，这个函数主要用在调用方，其他函数用在实现方，是不是应该分别放到两个类中？\n  public String genId() {\n    return UUID.randomUUID().toString();\n  }\n\n  // comment-7: 返回值的意义是不是应该注释说明一下？\n  public boolean saveIfAbsent(String idempotenceId) {\n    Long success = jedisCluster.setnx(idempotenceId, &quot;1&quot;);\n    return success == 1;\n  }\n\n  public void delete(String idempotenceId) {\n    jedisCluster.del(idempotenceId);\n  }\n}\n</code></pre><p>总结一下，MVP代码主要涉及下面这样几个问题。</p><ul>\n<li><strong>代码可读性问题</strong>：有些函数的参数和返回值的格式和意义不够明确，需要注释补充解释一下。genId()函数使用了缩写，全拼generateId()可能更好些！</li>\n<li><strong>代码可扩展性问题</strong>：按照现在的代码实现方式，如果改变幂等号的存储方式和生成算法，代码修改起来会比较麻烦。除此之外，基于接口隔离原则，我们应该将genId()函数跟其他函数分离开来，放到两个类中。独立变化，隔离修改，更容易扩展！</li>\n<li><strong>代码可测试性问题</strong>：解析Redis Cluster地址的代码逻辑较复杂，但因为放到了构造函数中，无法对它编写单元测试。</li>\n<li><strong>代码灵活性问题</strong>：业务系统有可能希望幂等框架复用已经建立好的jedisCluster，而不是单独给幂等框架创建一个jedisCluster。</li>\n</ul><h2>重构最小原型代码</h2><p>实际上，问题找到了，修改起来就容易多了。针对刚刚罗列的几个问题，我们对MVP代码进行重构，重构之后的代码如下所示。</p><pre><code>// 代码目录结构\ncom.xzg.cd.idempotence\n --Idempotence\n --IdempotenceIdGenerator(幂等号生成类)\n --IdempotenceStorage(接口：用来读写幂等号)\n --RedisClusterIdempotenceStorage(IdempotenceStorage的实现类)\n\n// 每个类的代码实现\npublic class Idempotence {\n  private IdempotenceStorage storage;\n\n  public Idempotence(IdempotenceStorage storage) {\n    this.storage = storage;\n  }\n\n  public boolean saveIfAbsent(String idempotenceId) {\n    return storage.saveIfAbsent(idempotenceId);\n  }\n\n  public void delete(String idempotenceId) {\n    storage.delete(idempotenceId);\n  }\n}\n\npublic class IdempotenceIdGenerator {\n  public String generateId() {\n    return UUID.randomUUID().toString();\n  }\n}\n\npublic interface IdempotenceStorage {\n  boolean saveIfAbsent(String idempotenceId);\n  void delete(String idempotenceId);\n}\n\npublic class RedisClusterIdempotenceStorage implements IdempotenceStorage {\n  private JedisCluster jedisCluster;\n\n  /**\n   * Constructor\n   * @param redisClusterAddress the format is 128.91.12.1:3455;128.91.12.2:3452;289.13.2.12:8978\n   * @param config should not be null\n   */\n  public RedisIdempotenceStorage(String redisClusterAddress, GenericObjectPoolConfig config) {\n    Set&lt;HostAndPort&gt; redisNodes = parseHostAndPorts(redisClusterAddress);\n    this.jedisCluster = new JedisCluster(redisNodes, config);\n  }\n\n  public RedisIdempotenceStorage(JedisCluster jedisCluster) {\n    this.jedisCluster = jedisCluster;\n  }\n\n  /**\n   * Save {@idempotenceId} into storage if it does not exist.\n   * @param idempotenceId the idempotence ID\n   * @return true if the {@idempotenceId} is saved, otherwise return false\n   */\n  public boolean saveIfAbsent(String idempotenceId) {\n    Long success = jedisCluster.setnx(idempotenceId, &quot;1&quot;);\n    return success == 1;\n  }\n\n  public void delete(String idempotenceId) {\n    jedisCluster.del(idempotenceId);\n  }\n\n  @VisibleForTesting\n  protected Set&lt;HostAndPort&gt; parseHostAndPorts(String redisClusterAddress) {\n    String[] addressArray= redisClusterAddress.split(&quot;;&quot;);\n    Set&lt;HostAndPort&gt; redisNodes = new HashSet&lt;&gt;();\n    for (String address : addressArray) {\n      String[] hostAndPort = address.split(&quot;:&quot;);\n      redisNodes.add(new HostAndPort(hostAndPort[0], Integer.valueOf(hostAndPort[1])));\n    }\n    return redisNodes;\n  }\n}\n</code></pre><p>接下来，我再总结罗列一下，针对之前发现的问题，我们都做了哪些代码改动。主要有下面这样几点，你可以结合着代码一块看下。</p><p><strong>在代码可读性方面，</strong>我们对构造函数、saveIfAbsense()函数的参数和返回值做了注释，并且将genId()函数改为全拼generateId()。不过，对于这个函数来说，缩写实际上问题也不大。</p><p><strong>在代码可扩展性方面，</strong>我们按照基于接口而非实现的编程原则，将幂等号的读写独立出来，设计成IdempotenceStorage接口和RedisClusterIdempotenceStorage实现类。RedisClusterIdempotenceStorage实现了基于Redis Cluster的幂等号读写。如果我们需要替换新的幂等号读写方式，比如基于单个Redis而非Redis Cluster，我们就可以再定义一个实现了IdempotenceStorage接口的实现类：RedisIdempotenceStorage。</p><p>除此之外，按照接口隔离原则，我们将生成幂等号的代码抽离出来，放到IdempotenceIdGenerator类中。这样，调用方只需要依赖这个类的代码就可以了。幂等号生成算法的修改，跟幂等号存储逻辑的修改，两者完全独立，一个修改不会影响另外一个。</p><p><strong>在代码可测试性方面，</strong>我们把原本放在构造函数中的逻辑抽离出来，放到了parseHostAndPorts()函数中。这个函数本应该是Private访问权限的，但为了方便编写单元测试，我们把它设置为成了Protected访问权限，并且通过注解@VisibleForTesting做了标明。</p><p><strong>在代码灵活性方面，</strong>为了方便复用业务系统已经建立好的jedisCluster，我们提供了一个新的构造函数，支持业务系统直接传递jedisCluster来创建Idempotence对象。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>我们前面花了两节课的时间，用很大的篇幅在讲需求和设计，特别是设计的缘由。而真正到了实现环节，我们只用了不到30行代码，就实现了幂等框架。这就很好体现了“思从深而行从简”的道理。对于不到30行代码，很多人觉得不大可能有啥优化空间了，但我们今天还是提出了7个优化建议，并且对代码结构做了比较大的调整。这说明，只要仔细推敲，再小的代码都有值得优化的地方。</p><p>不过，之前有人建议我举一些大型项目中的例子，最好是上万行代码的那种，不要举这种几十行的小例子。大项目和小项目在编码这个层面，实际上没有太大区别。再宏大的工程、再庞大的项目，也是一行一行写出来的。那些上来就要看上万行代码，分析庞大项目的，大部分都还没有理解编码的精髓。编码本身就是一个很细节的事情，牛不牛也都隐藏在一行一行的代码中。空谈架构、设计、大道理，实际上没有太多意义，对你帮助不大。能沉下心来把细节都做好那才是真的牛！</p><h2>课堂讨论</h2><ol>\n<li>针对MVP代码，我有两个问题留给你思考。其中一个问题是，delete()是应该返回void值还是boolean值？如果删除出错，应该如何处理？另一个问题是，需不需要给幂等号生成算法抽象出一个接口呢？为什么？</li>\n<li>在后续的版本规划中，你觉得幂等框架还可以继续扩展哪些功能？或者做哪些优化？如果让你规划第二个版本，你会做哪些东西？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":225413,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1591752478,"is_pvip":false,"discussion_count":6,"race_medal":1,"score":"139030705950","product_id":100039001,"comment_content":"delete是否返回boolean和如果出错该如何处理这个问题，要看业务方是处理业务和幂等号的顺序，如果先存储幂等号，在做业务，那么业务没处理成功时，后续处理就要删除幂等号，然后重复业务处理，这就要保证删除幂等号一定要成功，这样就要返回boolean值；相反，如果业务处理成功后在保存幂等号，那么删除幂等号成功与否都无关，删除幂等号可以不反回值。<br>幂等号生成算法没必要再开个接口，因为幂等号生成算法需要稳定性全局性，否则不同业务用不同算法生成幂等号，那么幂等框架就可能无法区分不同的业务请求了。<br>后续版本可以让幂等框架更易用，不需要过多配置，比如提供一个注解，使用方直接在需要幂等的接口上添加上这个注解，那么这个请求就一定会保证幂等。","like_count":33,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":144524,"discussion_content":"把自己写的代码拿出来看看命名，不规范的改一遍，第二天再看看，再改一遍，第三天.....就够看了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579529314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396147,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4d/b3/85828cc4.jpg","nickname":"f","note":"","ucode":"686BD6C21FE02B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141250,"discussion_content":"看完有什么用 要会用啊 反复阅读直到融会贯通","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579405356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225487,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1591765319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61721307463","product_id":100039001,"comment_content":"1.针对mvp代码，delete不该返回boolean，void即可。因为该方法只有在技术异常（网络超时，redis节点无法提供服务）时才会有失败的场景。而我的习惯，是把技术异常放在最外层处理，或则代理层处理（技术异常的处理应该尽量与业务代码分离）。如果delete里面也有业务逻辑，比如入参检验，那么我会返回boolean。因为这时候的异常是业务代码该处理的场景，同时我认为调用方无需知道delete因何失败，只需要知道delete失败，所以收敛delete内部业务异常，对外只以boolean返回值做交互。<br><br>2.因为唯一id的需求方并不只有幂等框架，抽离出来在其他场景也能用，比如流水id。我认为幂等服务方提供幂等id生成接口给调用方的方式并不合适。这样做是一种资源的浪费。在这个场景，我只是为了保证幂等id生成代码的去重，并没有动态上扩缩节点调整负载的诉求。所以幂等id生成代码以公共包的方式被调用方项目依赖，仅做代码级的复用会好些。<br><br><br>3.抽成公共包（去重），提供声明式接口（易用），提供配置接口（灵活）。","like_count":15},{"had_liked":false,"id":225361,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1591741348,"is_pvip":false,"replies":[{"id":"84000","content":"可以的，我现在有空了，我最近就能补上，关注我的github吧：<br>https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","comment_id":225361,"uid":"1190123","ip_address":"","utype":1,"ctime":1592526678,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"44541414308","product_id":100039001,"comment_content":"老师讲的真的好后期老师把所讲课程配套代码提供上，我对着再仔细阅读一次结合实际应用到实际开发中，谢谢","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510515,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225551,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1053390,"ip_address":"","ucode":"ABB3F1A63E102A","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","comment_is_top":false,"comment_ctime":1591783391,"is_pvip":false,"replies":[{"id":"84978","content":"嗯嗯 多谢指出~","user_name":"作者回复","comment_id":225551,"uid":"1190123","ip_address":"","utype":1,"ctime":1593311045,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"35951521759","product_id":100039001,"comment_content":"RedisClusterIdempotenceStorage是不是少implements IdempotenceStorage？","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510459,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235003,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1594867428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23069703908","product_id":100039001,"comment_content":"能沉下心来把细节都做好那才是真的牛！","like_count":6},{"had_liked":false,"id":225415,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1591752684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18771621868","product_id":100039001,"comment_content":"delete还是返回boolean好一点，对删除出错的key可以人工干预或者记录下来统一处理","like_count":4},{"had_liked":false,"id":229844,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1593161759,"is_pvip":false,"replies":[{"id":"84961","content":"不是重试之前删除，而是在出错之后删除。重试的时候并不知道原来是执行正确还是错误、","user_name":"作者回复","comment_id":229844,"uid":"1190123","ip_address":"","utype":1,"ctime":1593309244,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"14478063647","product_id":100039001,"comment_content":"有一点不明白，框架为什么要对外提供delete接口呢？调用方乱用怎么办？如果是为了处理系统异常，我觉得可以让调用方重新生成新的幂等号再发起请求，而不是依赖调用方在重试之前正确地调用delete接口。","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499665,"discussion_content":"不是重试之前删除，而是在出错之后删除。重试的时候并不知道原来是执行正确还是错误、","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593309244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226582,"user_name":"Jemmy","can_delete":false,"product_type":"c1","uid":1007330,"ip_address":"","ucode":"A979F4A5210225","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/e2/1fad3052.jpg","comment_is_top":false,"comment_ctime":1592145286,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14477047174","product_id":100039001,"comment_content":"优化：IdempotenceIdGenerator 可以面向接口编程，未来 uuid 生成方式可能会变。","like_count":3},{"had_liked":false,"id":225457,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1591759396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14476661284","product_id":100039001,"comment_content":"1.在框架里,使用删除操作的时候,应该是人工介入时候使用的吧,这时候返回一个boolean方便盘查,对于幂等号生成算法来说,我们是抽取出来作为一个类库去放在客户端调用的,那么客户端传递给我们的格式最好一致,所以不应该抽象出一个接口,只能有一个实现的话,接口没有甚意义<br>2.在新版本,支持配置文件中,配置不同的名称来选择不同的幂等读写方法,并且,利用注解来进行AOP的切面编程,让使用人员使用注解就可以进行相关的幂等性保证","like_count":3},{"had_liked":false,"id":225431,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1591755739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14476657627","product_id":100039001,"comment_content":"delete返回boolean，这样调用方会知道是否删除成功，调用方可以自己重试。可以幂等算法抽象出一个接口，用户可以选择自己想要用的幂等算法套件。","like_count":3},{"had_liked":false,"id":287122,"user_name":"walkingonair","can_delete":false,"product_type":"c1","uid":1444748,"ip_address":"","ucode":"0C8BEE064ABF8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/8c/db1ee0a2.jpg","comment_is_top":false,"comment_ctime":1617784391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10207718983","product_id":100039001,"comment_content":"这种依赖请求发起方实现的幂等不是真正的幂等。<br>例如：对外的api接口，没办法使调用方自行判断是否重复请求<br><br>把重点放在框架的分析、设计和实现上","like_count":2},{"had_liked":false,"id":231985,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1593811136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10183745728","product_id":100039001,"comment_content":"Code Review的思维很有帮助","like_count":2},{"had_liked":false,"id":231729,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1593760956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10183695548","product_id":100039001,"comment_content":"我觉得delete可以根据业务的需要来判断是否需要，如果是单纯的删除那就不需要，如果还需要在删除后进行一些其它操作则可以返回结果，幂等号算法可以选择策略模式进行切换，为后续如果业务改变需要不同的生成算法的话，可以随时替换","like_count":2},{"had_liked":false,"id":225392,"user_name":"tingye","can_delete":false,"product_type":"c1","uid":1391463,"ip_address":"","ucode":"54F7A44066DF5D","user_header":"https://static001.geekbang.org/account/avatar/00/15/3b/67/c188d3bc.jpg","comment_is_top":false,"comment_ctime":1591750261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181684853","product_id":100039001,"comment_content":"delete接口还是返回boolean好，让调用方能感知到异常，虽然调用方也不好处理，但能做些业务补偿或人工补救。生成算法也应该抽象成接口，便于扩展生成算法，甚至开放给业务端定制。另外幂等号一直存储在redis数据量会越来越大，可能要考虑设置过期策略和定期持久化数据","like_count":2},{"had_liked":false,"id":225387,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1591750056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181684648","product_id":100039001,"comment_content":"思考题。<br><br>问题1，可以返回boolean，删除出错，返回false，不用抛异常。删除失败最多导致redis里存储了失效的幂等号。幂等号可以抽出一个接口，后期幂等算法可能修改，各自的算法实现各自的generateId。<br><br>问题2，可以新增不同的幂等算法实现，幂等算法调用成功率与失败率监控，允许业务方扩展幂等算法等。主要还是看业务需求，代码都是服务于业务，过早的扩展也是万恶之源。","like_count":2},{"had_liked":false,"id":239861,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1596678878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5891646174","product_id":100039001,"comment_content":"作为框架功能，应该要把异常上抛给调用方，让调用方自己决定如何处理；现在通用的功能框架几乎都是这么做的。","like_count":1},{"had_liked":false,"id":226686,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1592185326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887152622","product_id":100039001,"comment_content":"1.是否返回boolean，还是看业务场景的，大多数情况下，是不用返回的，一个业务执行成功了，返回给调用方成功，调用方就不可能再次调用了，而且过期了，也会自动删除。如果业务上有别的考虑，比如一个id可能重复用，那就必须删除，如果删除失败，可以记录下来，做补偿。<br>我觉得还是要个幂等号算法抽象一个接口的，不一定每个幂等号都是完全一样的生成逻辑。比如在金融借款的场景，幂等号需要加入一些业务属性，比如身份证号、银行卡、手机号等，有些的业务场景，幂等号又有别的含义。<br>2.生成幂等号的接口要完善，允许用户传入参数来获取幂等好；增加一些补偿机制，比如删除失败的补偿；高可用部署","like_count":1},{"had_liked":false,"id":341992,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1285986,"ip_address":"","ucode":"F29D56F9265751","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/62/960eecc3.jpg","comment_is_top":false,"comment_ctime":1649943437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649943437","product_id":100039001,"comment_content":"框架和业务系统接入的功能呢？<br>","like_count":0},{"had_liked":false,"id":328295,"user_name":"元哥","can_delete":false,"product_type":"c1","uid":2007818,"ip_address":"","ucode":"1F457416738746","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a3/0a/c0f6d731.jpg","comment_is_top":false,"comment_ctime":1640656545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640656545","product_id":100039001,"comment_content":"@VisibleForTesting 这个标注会被sonar检查出Code smell","like_count":0},{"had_liked":false,"id":326004,"user_name":"我是曾经那个少年","can_delete":false,"product_type":"c1","uid":1015189,"ip_address":"","ucode":"9F02F7FF147D14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","comment_is_top":false,"comment_ctime":1639302990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639302990","product_id":100039001,"comment_content":"问题1：delete()方法返回值的问题，个人感觉没必要，只要没有异常调用放就会正确处理。幂等号生成算法抽象出一个接口，个人感觉抽象接口要考虑有没有扩展的必要性，这个只需要保证全局唯一就好了，没有一些业务需求导致它的变化。<br>问题2：迭代和优化<br>个人感觉调用方的重试需要框架支持，让调用方去判断是否重试，是个伪需求，因为我都考虑幂等了，我肯定希望被执行放能正常执行。让调用方执行就变成了每个调用者要写轮询处理的代码。调用发的重试机制也不好处理呀。","like_count":0},{"had_liked":false,"id":313377,"user_name":"瀚海","can_delete":false,"product_type":"c1","uid":2062203,"ip_address":"","ucode":"E64C22F3F6D285","user_header":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","comment_is_top":false,"comment_ctime":1632401901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632401901","product_id":100039001,"comment_content":"老师讲的很好          分析的很详细，只是实现写的过于简单了点   看功能核心只有生成随机id和setnx         如果真想在业务中使用，需要业务方依赖随机id生成算法，大多场景不合适","like_count":0},{"had_liked":false,"id":305788,"user_name":"Lowic","can_delete":false,"product_type":"c1","uid":2172704,"ip_address":"","ucode":"8D9E3D7C503FC0","user_header":"https://static001.geekbang.org/account/avatar/00/21/27/20/8147351d.jpg","comment_is_top":false,"comment_ctime":1628161554,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1628161554","product_id":100039001,"comment_content":"老师，用链路追踪的traceId作为幂等号有可行性嘛？😁","like_count":0,"discussions":[{"author":{"id":1008517,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","nickname":"姑射仙人","note":"","ucode":"3EFC1F3E592165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537679,"discussion_content":"使用方在发起请求前，是拿不到traceId，traceId是请求之后才能拿到吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639141530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293536,"user_name":"码哥字节","can_delete":false,"product_type":"c1","uid":1572356,"ip_address":"","ucode":"362103AD52C8E0","user_header":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","comment_is_top":false,"comment_ctime":1621422448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621422448","product_id":100039001,"comment_content":"空谈架构、设计、大道理，实际上没有太多意义，对你帮助不大。能沉下心来把细节都做好那才是真的牛！深表赞同","like_count":0},{"had_liked":false,"id":289911,"user_name":"Geek_89111a","can_delete":false,"product_type":"c1","uid":1367091,"ip_address":"","ucode":"CB60086FD9D3A3","user_header":"","comment_is_top":false,"comment_ctime":1619261117,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619261117","product_id":100039001,"comment_content":"用uuid来处理幂等号 ，uuid是随机值，每次请求uuid都不一样，就算是重试也是不一样，uuid根本处理不了这种场景，感觉在误人子弟","like_count":0,"discussions":[{"author":{"id":2062203,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","nickname":"瀚海","note":"","ucode":"E64C22F3F6D285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396181,"discussion_content":"老师的意思是    让调用方来携带这个uuid，重试时，带着上次一样的uuid来   就可以判断是重试请求了                       怀疑这样的实现可行性，因为调用方也可能不清楚是否是重试请求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632402052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253638,"user_name":"杨少君","can_delete":false,"product_type":"c1","uid":1251143,"ip_address":"","ucode":"39AA0AE742D257","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/47/f9e1a563.jpg","comment_is_top":false,"comment_ctime":1602817642,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602817642","product_id":100039001,"comment_content":"老师，您好，在微服务中，这个幂等框架是独立为一个微服务，还是集成在Client端，还是Server端，是否Server端还需要对幂等接口定义幂等注解进行幂等校验，文中偏向client端的操。如果幂等框架独立为一个微服务，提供生成幂等号和入库作为resful接口，那服务端的幂等校验是否也可以集成进来，不然每个服务端需要重复编码校验，我理解作为一个sdk是不是比微服务更好。","like_count":0},{"had_liked":false,"id":247788,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1599837534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599837534","product_id":100039001,"comment_content":"leetcode.com题解中有很多几十行甚至几行代码解题的优秀的不能在优秀的代码。对提升编码能力很有帮助","like_count":0},{"had_liked":false,"id":246941,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1599535275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599535275","product_id":100039001,"comment_content":"问题1：delete函数最好返回bool值，true为成功，false为失败，至于删除失败后的处理，可以交给业务调用方处理，幂等框架只要返回是否删除成功就可以了；而对于幂等号生成算法是否需要抽象出一个接口，这个主要看是否有后续幂等号生成算法扩展的需求，如果后续有这个需求并且为了提高框架的扩展性，可以考虑抽象出一个生成算法接口；如果后续没有这种需求，而且生成算法也不会进行频繁的修改和扩充，那么也没必要抽象出一个接口，避免过度设计；<br>问题2：后续的幂等框架优化主要集中在异常处理吧，如设计篇中所说，要考虑到各种异常情况，比如可以在框架中增加异常日志记录；redis存储、删除发生异常时，接口可以直接失败。。","like_count":0},{"had_liked":false,"id":242721,"user_name":"习惯说","can_delete":false,"product_type":"c1","uid":1235385,"ip_address":"","ucode":"5429FAF60E4FBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/b9/e21b699a.jpg","comment_is_top":false,"comment_ctime":1597823697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597823697","product_id":100039001,"comment_content":"这个能防止重复请求幂等吗，比如我支付订单连续请求两次付款，完全和业务无关不是会生成两个不同的幂等号吗","like_count":0},{"had_liked":false,"id":241932,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597505455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597505455","product_id":100039001,"comment_content":"1 delete应该返回bool，失败后可以安全重试<br>","like_count":0},{"had_liked":false,"id":239357,"user_name":"Tobias","can_delete":false,"product_type":"c1","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1596509698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596509698","product_id":100039001,"comment_content":"思考题2：<br>（1）增加幂等开关，支持配置化的开启&#47;关闭幂等功能。<br>","like_count":0},{"had_liked":false,"id":233646,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1594374705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594374705","product_id":100039001,"comment_content":"1. delete()方法应该返回boolean而非void. 返回boolean清晰得告诉客户端本次执行的结果, 如果删除出错, 可直接返回false.<br>除此之外, 可以通过接口实现的模板方法模式编写void delete(String id, DeleteCallback callback)通过接口回调的方式通知客户端执行结果.<br><br>幂等号生成算法不需要抽象出一个接口. 幂等号本质是全局唯一id, 基本没有替换的必要性.<br><br>2. 参考限流框架的设计, 二期可以让幂等框架支持Spring, ReactiveX, Redis等常用框架的扩展使用. <br>","like_count":0},{"had_liked":false,"id":232997,"user_name":"北纬8℃","can_delete":false,"product_type":"c1","uid":1433189,"ip_address":"","ucode":"4999F2E037C93C","user_header":"https://static001.geekbang.org/account/avatar/00/15/de/65/51147fb6.jpg","comment_is_top":false,"comment_ctime":1594187152,"is_pvip":false,"replies":[{"id":"86255","content":"幂等号相同就是同一个请求。两个请求是否是同一个请求，由业务发起方来定义（他说了算），他觉得某两个请求是同一个请求，就赐予相同的幂等号。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594388380,"ip_address":"","comment_id":232997,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1594187152","product_id":100039001,"comment_content":"老师，能帮菜鸟讲解下幂等咋就实现了，区分请求，是一个新的请求或者是同一个请求再次发送","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500842,"discussion_content":"幂等号相同就是同一个请求。两个请求是否是同一个请求，由业务发起方来定义（他说了算），他觉得某两个请求是同一个请求，就赐予相同的幂等号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087077,"avatar":"https://static001.geekbang.org/account/avatar/00/10/96/65/aaf5985b.jpg","nickname":"云川","note":"","ucode":"49EC5972B9EB1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545571,"discussion_content":"所以说代码里幂等id的生成是在调用方？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641996557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179622,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/e6/4b0ddfcf.jpg","nickname":"李飞","note":"","ucode":"4B23FF72AA4BA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361059,"discussion_content":"我也觉得，比如我们请求方是app端，让app端创建幂等号吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616590158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2062203,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","nickname":"瀚海","note":"","ucode":"E64C22F3F6D285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179622,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/e6/4b0ddfcf.jpg","nickname":"李飞","note":"","ucode":"4B23FF72AA4BA0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396577,"discussion_content":"嗯   是的    不能依赖请求方来实现幂等       不能信任请求方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632454873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361059,"ip_address":""},"score":396577,"extra":""},{"author":{"id":1463834,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Bag6ZX7euicB9BTibY6KyFDmhjCOnI5OrrgTsh3YHUnPPSv8icVgr7ZxAzwjkY6lTRV5UC8bDibucLAm2ndMltsobA/132","nickname":"mapan","note":"","ucode":"3BF62213579291","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2062203,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","nickname":"瀚海","note":"","ucode":"E64C22F3F6D285","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415089,"discussion_content":"比如用户下订单，请求了一次生成了幂等号此时网络卡住了，然后又点了一下，不是又请求了一次吗，重新生成了幂等号，怎么就幂等了，难道第二次请求带的还是第一次生成的幂等号吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636985893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":396577,"ip_address":""},"score":415089,"extra":""}]},{"author":{"id":1235385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/b9/e21b699a.jpg","nickname":"习惯说","note":"","ucode":"5429FAF60E4FBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299798,"discussion_content":"这个如果由请求方来定义，如果请求方自己无无感知呢，不能完全把主导权交给上游吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597823882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}