{"id":740878,"title":"第 9 章 Spring MVC 实践(3)","content":"<h2 id=\"nav_point_144\">9.4　访问 Web 资源</h2>\n<p>前面我们都在聊如何编写 Web 服务端的内容，如何发布服务与资源，通过浏览器和一些工具就能访问我们发布的内容。但在一个分布式系统里，我们通常都是编写代码用客户端来进行访问的。这一节里就让我们一起来了解一下如何使用 Spring Framework 提供的 <code>RestTemplate</code> 来访问 Web 资源。</p>\n<h3 id=\"nav_point_145\">9.4.1　通过 <code>RestTemplate</code> 访问 Web 资源</h3>\n<p><code>RestTemplate</code> 封装了常用的 HTTP 操作，支持 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>HEAD</code>、<code>PATCH</code> 和 <code>OPTIONS</code> 方法，表 9-16 罗列了 <code>RestTemplate</code> 的一些常用方法，本节后面还会聊到 <code>exchange()</code> 等方法。</p>\n<p><strong>表 9-16　<code>RestTemplate</code> 的一些常用方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>方法名</p></th>\n<th><p>返回类型</p></th>\n<th><p>对应 HTTP 方法</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>getForObject()</code></p></td>\n<td><p><code>T</code></p></td>\n<td><p><code>GET</code></p></td>\n<td><p>获取内容并转换为指定类型</p></td>\n</tr>\n<tr>\n<td><p><code>getForEntity()</code></p></td>\n<td><p><code>ResponseEntity&lt;T&gt;</code></p></td>\n<td><p><code>GET</code></p></td>\n<td><p>获取内容并转换为指定类型，同时提供 HTTP 应答头等信息</p></td>\n</tr>\n<tr>\n<td><p><code>postForObject()</code></p></td>\n<td><p><code>T</code></p></td>\n<td><p><code>POST</code></p></td>\n<td><p>提交内容，将结果转换为指定类型</p></td>\n</tr>\n<tr>\n<td><p><code>postForEntity()</code></p></td>\n<td><p><code>ResponseEntity&lt;T&gt;</code></p></td>\n<td><p><code>POST</code></p></td>\n<td><p>提交内容，将结果转换为指定类型，同时提供 HTTP 应答头等信息</p></td>\n</tr>\n<tr>\n<td><p><code>postForLocation()</code></p></td>\n<td><p><code>URI</code></p></td>\n<td><p><code>POST</code></p></td>\n<td><p>提交内容，无须获得返回，只要拿到结果中的地址信息即可</p></td>\n</tr>\n<tr>\n<td><p><code>put()</code></p></td>\n<td><p><code>void</code></p></td>\n<td><p><code>PUT</code></p></td>\n<td><p>发送 <code>PUT</code> 请求，创建或更新内容，无返回值</p></td>\n</tr>\n<tr>\n<td><p><code>delete()</code></p></td>\n<td><p><code>void</code></p></td>\n<td><p><code>DELETE</code></p></td>\n<td><p>发送 <code>DELETE</code> 请求，删除内容，无返回值</p></td>\n</tr>\n</tbody>\n</table>\n<p>通常，Spring Boot 的自动配置都会为我们提供所需的 Bean，早期的 Spring Boot 的确也提供了一个默认的 <code>RestTemplate</code> Bean，但是在后来的版本中又把它去掉了。不过，<code>RestTemplateAutoConfiguration</code> 为我们提供了 <code>RestTemplateBuilder</code> Bean，<code>RestTemplateAutoConfiguration</code> 会将上下文中的 <code>RestTemplateCustomizer</code> 和 <code>RestTemplateRequestCustomizer</code> 收集起来，放到 <code>RestTemplateBuilder</code> 里。而我们可以直接通过这个 <code>RestTemplateBuilder</code> 的 <code>build()</code> 方法来构造自己的 <code>RestTemplate</code> Bean。</p><!-- [[[read_end]]] -->\n<p>接下来，我们通过一个例子来演示如何通过 <code>RestTemplate</code> 来模拟顾客的操作，访问我们的二进制奶茶店。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店准备得差不多了，有了菜单，顾客也可以下订单了，现在该看看来到门店的顾客都有哪些行为了。顾客来到店门口之后，可能会先张望一下，看看有没有开门，没开门的话可能直接走开，也可能稍微等上一会儿，开门的话可能进来瞄一眼菜单。一般人查看菜单可能会有这样一些习惯：</p>\n<ul>\n<li>先看看菜单上第一项；</li>\n<li>浏览一下有没有自己喜欢的；</li>\n<li>把整个菜单看完再说。</li>\n</ul>\n<p>我们已经有了所需的菜单服务，现在该让顾客出场了。</p>\n</blockquote>\n<p>第 5 章里我们已经写了一个简单的等待开门的 Customer 工程，此处在它的基础上稍作修改。<span class=\"comment-number\">14</span> 第一步，调整一下 pom.xml，增加 Spring MVC 等 Web 支持，因为菜单上有金额，所以还需要 Joda Money 相关的支持，在 <code>&lt;dependencies/&gt;</code> 中增加如下内容。</p>\n\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.joda&lt;/groupId&gt;\n    &lt;artifactId&gt;joda-money&lt;/artifactId&gt;\n    &lt;version&gt;1.0.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-datatype-joda-money&lt;/artifactId&gt;\n    &lt;version&gt;2.13.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>第二步，调整主类 <code>CustomerApplication</code>，因为引入了 spring-boot-starter-web，所以默认会启动 Web 容器，我们目前只希望开发一个命令行运行的程序，所以需要自定义 Spring 应用，使用 <code>WebApplicationType.NONE</code> 将应用指定为非 Web 类型。此外，通过 <code>RestTemplateBuilder</code> 来定义我们自己的 <code>RestTemplate</code>，这里设置一下超时时间。对于 <code>Money</code> 类型，我们还需要定义 <code>JodaMoneyModule</code> 来处理序列化相关的事宜。具体如代码示例 9-22 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-22</strong>　调整后的 <code>CustomerApplication</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\npublic class CustomerApplication {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder()\n             .sources(CustomerApplication.class)\n             .web(WebApplicationType.NONE)\n             .run(args);\n    }\n\n    @Bean\n    public RestTemplate restTemplate(RestTemplateBuilder builder) {\n        return builder\n                .setConnectTimeout(Duration.ofSeconds(1)) // 连接超时\n                .setReadTimeout(Duration.ofSeconds(5)) // 读取超时\n                .build();\n    }\n\n    @Bean\n    public JodaMoneyModule jodaMoneyModule() {\n        return new JodaMoneyModule();\n    }\n\n    @Bean\n    public ExitCodeGenerator waitExitCodeGenerator(ApplicationArguments args) {\n        return () -&gt; (args.containsOption(\"wait\") ? 0 : 1);\n    }\n}</code></pre>\n<p>第三步，调整原来的 <code>WaitForOpenRunner</code>，本来它只是根据命令行参数来决定是否等待，等完就退出的。现在我们的 BinaryTea 服务端准备好了，可以通过访问服务端来判断是否可以提供服务，所以这里就用 <code>RestTemplate</code> 来发起 <code>GET</code> 请求，能获得 <code>200 OK</code> 的响应码就说明奶茶店开门了。具体如代码示例 9-23 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-23</strong>　调整后的 <code>WaitForOpenRunner</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\n@Order(2)\npublic class WaitForOpenRunner implements ApplicationRunner, ApplicationContextAware {\n    @Setter\n    private ApplicationContext applicationContext;\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String binarytea;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        boolean flag = isOpen(); // 开门了吗？\n        flag = flag ? true : (waitForOpen(args) &amp;&amp; isOpen()); // 没开门，等一下再看看\n        if (!flag) { // 没开门就退出\n            log.info(\"店没开门，走了\");\n            System.exit(SpringApplication.exit(applicationContext));\n        } else {\n            log.info(\"店开门了，进去看看\");\n        }\n    }\n\n    private boolean waitForOpen(ApplicationArguments args) throws InterruptedException {\n        boolean needWait = args.containsOption(\"wait\");\n        if (!needWait) {\n            log.info(\"如果没开门，就不用等了。\");\n        } else {\n            List&lt;String&gt; waitSeconds = args.getOptionValues(\"wait\");\n            if (!waitSeconds.isEmpty()) {\n                int seconds = NumberUtils.parseNumber(waitSeconds.get(0), Integer.class);\n                log.info(\"还没开门，先等{}秒。\", seconds);\n                Thread.sleep(seconds * 1000);\n            }\n        }\n        return needWait;\n    }\n\n    private boolean isOpen() {\n        ResponseEntity&lt;String&gt; entity = null;\n        try {\n            entity = restTemplate.getForEntity(binarytea + \"/menu\", String.class);\n            return entity.getStatusCode().is2xxSuccessful();\n        } catch (Exception e) {\n            log.warn(\"应该还没开门，访问出错：{}\", e.getMessage());\n        }\n        return false;\n    }\n}</code></pre>\n<p>代码示例 9-26 中的 <code>waitForOpen()</code> 就是从原来的 <code>run()</code> 方法里抽取出来的，专门判断是否要等待，以及要等多久。<code>isOpen()</code> 方法向服务端发起一个 <code>GET</code> 请求，这里访问的是 http://localhost:8080/menu，返回的是 JSON，暂时先用 <code>String</code> 来处理，反正也不用这个返回值，只需要判断响应码即可。在 <code>application.properties</code> 中加上 <code>binarytea.url</code> 配置，这是我们要访问的服务器地址和端口：</p>\n<pre class=\"code-rows\"><code>binarytea.url=http://localhost:8080</code></pre>\n<p>如果命令行上传入 <code>--wait=5</code>，也就是等待 5 秒 <span class=\"comment-number\">15</span>，在不启动服务端的情况下，我们得到的输出大概是下面这样的：</p>\n\n<pre class=\"code-rows\"><code>2020-12-13 23:40:16.586 INFO 24352 --- [main] l.spring.customer.ArgsPrinterRunner : 共传入了1个参数。\n分别是：--wait=5\n2020-12-13 23:40:16.609 WARN 24352 --- [main] l.spring.customer.WaitForOpenRunner : 应该还没开门，\n访问出错：I/O error on GET request for \"http://localhost:8080/menu\": Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused)\n2020-12-13 23:40:16.610 INFO 24352 --- [main] l.spring.customer.WaitForOpenRunner : 还没开门，先等5秒。\n2020-12-13 23:40:21.613 WARN 24352 --- [main] l.spring.customer.WaitForOpenRunner : 应该还没开门，\n访问出错：I/O error on GET request for \"http://localhost:8080/menu\": Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused)\n2020-12-13 23:40:21.613 INFO 24352 --- [main] l.spring.customer.WaitForOpenRunner : 店没开门，走了</code></pre>\n<p>最后，来实现查看菜单内容的功能。先要在 Customer 工程中也定义一个菜单的模型，基本与 BinaryTea 中的一样，但不需要增加 JPA 的注解，为了简单，也不需要表示杯型大小的枚举了，具体如代码示例 9-24 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-24</strong>　Customer 工程中的 <code>MenuItem</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Getter\n@Setter\n@ToString\npublic class MenuItem {\n    private Long id;\n    private String name;\n    private String size;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n}</code></pre>\n<p>编写一个 <code>MenuRunner</code> 类，其中包含了需求中提到的三种查看菜单的动作，都是用的 <code>getForObject()</code> 方法，不过这里会演示三种不同的用法，具体如代码示例 9-25 所示。</p>\n<ul>\n<li>返回类型指定为具体的类 <code>MenuItem</code>，同时，传入的 URL 中包含占位符 <code></code>，这里根据占位符的顺序选择参数中的值。</li>\n<li>返回列表，暂时还用 <code>String</code> 来做返回值，但占位符替换不再用可变参数，而是使用 <code>Map&lt;String, ?&gt;</code>，其中的键与占位符对应。</li>\n<li>URL 中没有占位符需要替换，最简单的调用。</li>\n</ul>\n<blockquote>\n<p><strong>代码示例 9-25</strong>　包含三种查看菜单动作的 <code>MenuRunner</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\n@Order(3)\npublic class MenuRunner implements ApplicationRunner {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String binarytea;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        MenuItem item = restTemplate.getForObject(binarytea + \"/menu/\", MenuItem.class, 1);\n        log.info(\"菜单上的第一项是{}\", item);\n\n        String coffee = restTemplate.getForObject(binarytea + \"/menu?name=\", String.class,\n                Collections.singletonMap(\"name\", \"Java咖啡\"));\n        log.info(\"有Java咖啡吗？{}\", coffee);\n\n        String menuJson = restTemplate.getForObject(binarytea + \"/menu\", String.class);\n        log.info(\"完整菜单：{}\", menuJson);\n    }\n}</code></pre>\n<blockquote>\n<p><strong>需求描述</strong>　顾客在看完菜单之后，就要开始点单了。之前在 Web 页面上有个下单的功能，现在是时候把这个功能挪到客户端来实现了。</p>\n</blockquote>\n<p>在上一节的例子里，<code>OrderController</code> 只能处理表单请求，而我们暂时还无法用 <code>RestTemplate</code> 来发起表单请求（后面会介绍如何发送带有请求头的 HTTP 请求），所以在第 9 章的 binarytea-rest-controller 例子中，我们简单修改一下 <code>OrderController</code>，增加一个处理 <code>REST</code> 请求的新建订单方法，如代码示例 9-26 所示。新增的 <code>createNewOrder()</code> 方法仅处理 <code>application/json</code> 的请求，使用同样的表单对象，但增加了 <code>@RequestBody</code> 注解，将整个请求正文转换为 <code>NewOrderForm</code>，并进行了校验，其他的逻辑和之前处理表单的 <code>createNewOrder()</code> 别无二致，最后返回一个 <code>Optional&lt;Order&gt;</code>。</p>\n<blockquote>\n<p><strong>代码示例 9-26</strong>　增加了 <code>REST</code> 接口的 <code>OrderController</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    // 省略其他内容\n    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE)\n    @ResponseBody\n    public Optional&lt;Order&gt; createNewOrder(@RequestBody @Valid NewOrderForm form, BindingResult result,\n                                          HttpServletResponse response) {\n        if (result.hasErrors()) {\n            log.warn(\"参数不正确，[{}]\", result.getAllErrors());\n            response.setStatus(HttpStatus.BAD_REQUEST.value());\n            return Optional.empty();\n        }\n        response.setStatus(HttpStatus.CREATED.value());\n        return Optional.ofNullable(createNewOrderWithForm(form));\n    }\n\n    private Order createNewOrderWithForm(NewOrderForm form) {\n        List&lt;MenuItem&gt; itemList = form.getItemIdList().stream()\n                .map(i -&gt; NumberUtils.toLong(i)).collect(Collectors.collectingAndThen(Collectors.toList(),\n                list -&gt; menuService.getByIdList(list)));\n        Order order = orderService.createOrder(itemList, form.getDiscount());\n        log.info(\"创建新订单，Order={}\", order);\n        return order;\n    }\n}</code></pre>\n<p>在客户端上，我们新建一个 <code>OrderRunner</code>，其中使用 <code>restTemplate.postForObject()</code> 来发送 <code>POST</code> 请求。请求的正文是一个 <code>NewOrderForm</code> 对象，这个类的内容与服务端一致，只是在注解上稍作调整，去掉了校验相关的注解，增加了一个 <code>@Builder</code>，方便创建对象。<code>@NoArgsConstructor</code> 和 <code>@AllArgsConstructor</code> 是为了在序列化和反序列化时能有合适的构造方法，如代码示例 9-27 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-27</strong>　客户端里调整后的 <code>NewOrderForm</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Getter\n@Setter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class NewOrderForm {\n    private List&lt;String&gt; itemIdList;\n    private int discount;\n}</code></pre>\n<p>而 <code>OrderRunner</code> 则如代码示例 9-28 所示，它的逻辑很简单，创建一个 <code>NewOrderForm</code>，其中只有一个编号为 <code>1</code> 的饮料，折扣为 <code>90</code>，用 <code>POST</code> 方法发送到服务端，返回的内容先以 JSON 字符串输出。</p>\n<blockquote>\n<p><strong>代码示例 9-28</strong>　用来创建订单的 <code>OrderRunner</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(5)\n@Setter\n@Slf4j\npublic class OrderRunner implements ApplicationRunner {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String binarytea;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        callForObject();\n    }\n\n    protected String callForObject() {\n        NewOrderForm form = NewOrderForm.builder().itemIdList(Arrays.asList(\"1\")).discount(90).build();\n        String response = restTemplate.postForObject(binarytea + \"/order\", form, String.class);\n        log.info(\"下订单：{}\", response);\n        return response;\n    }\n}</code></pre>\n<p>程序运行后的效果大概是下面这样的：</p>\n<pre class=\"code-rows\"><code>2020-12-15 00:50:10.022 INFO 37900 --- [main] learning.spring.customer.OrderRunner : 下订单：{\"id\":2,\n\"maker\":null,\"items\":[{\"id\":1,\"name\":\"Java咖啡\",\"size\":\"MEDIUM\",\"price\":{\"amount\":12.00,\"currency\":\n\"CNY\"},\"createTime\":\"2020-12-14T16:49:48.918+00:00\",\"updateTime\":\"2020-12-14T16:49:48.918+00:00\"}],\n\"amount\":{\"discount\":90,\"totalAmount\":{\"amount\":12.00,\"currency\":\"CNY\"},\"payAmount\":{\"amount\":10.80,\n\"currency\":\"CNY\"}},\"status\":\"ORDERED\",\"createTime\":\"2020-12-14T16:50:09.987+00:00\",\"updateTime\":\n\"2020-12-14T16:50:09.987+00:00\"}</code></pre>\n<h3 id=\"nav_point_146\">9.4.2　<code>RestTemplate</code> 的进阶用法</h3>\n<p>面对简单的 HTTP 操作时，上一小节提到的方法就已经绰绰有余了，但现实中往往会有很多复杂的情况，例如，要在请求中传递多个请求头，需要判断应答中的 HTTP 响应码。如果结果复杂一些，例如包含 <code>List</code>、<code>Map</code> 等数据结构，还要把泛型类型用起来……这些事情 <code>RestTemplate</code> 都可以帮我们轻松搞定。</p>\n<ol>\n<li><p><strong>通过 <code>HttpEntity&lt;T&gt;</code> 进行复杂操作</strong></p>\n<p>HTTP 头是 HTTP 请求和应答中的重要部分，根据 HTTP 响应码和 HTTP 头可以做很多处理，在发送请求时也可以在 HTTP 头里带入很多信息。在之前的内容中，我们的代码并没有对 HTTP 头做太多处理，只是在使用 Postman 时做了些简单修改。在 <code>RestTemplate</code> 中，可以用 <code>RequestEntity&lt;T&gt;</code> 和 <code>ResponseEntity&lt;T&gt;</code> 分别表示请求和响应，它们都继承了 <code>HttpEntity&lt;T&gt;</code>，其中包含了 HTTP 头和正文，正文会被转换为给定的类型 <code>T</code>。</p>\n<p>我们可以将上一节的例子稍作调整，用 <code>postForEntity()</code> 代替 <code>postForObject()</code>，重新写一个请求方法，打印出 HTTP 头和正文，如代码示例 9-29 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-29</strong>　用来演示 <code>ResponseEntity&lt;T&gt;</code> 的 <code>OrderRunner</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(5)\n@Setter\n@Slf4j\npublic class OrderRunner implements ApplicationRunner {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String binarytea;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        callForEntity();\n    }\n\n    protected ResponseEntity&lt;String&gt; callForEntity() {\n        NewOrderForm form = NewOrderForm.builder().itemIdList(Arrays.asList(\"1\")).discount(90).build();\n\n        ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(binarytea + \"/order\",form, String.class);\n        log.info(\"HTTP Status: {}, Headers: \", response.getStatusCode());\n        response.getHeaders().entrySet().forEach(e -&gt; log.info(\"{}: {}\", e.getKey(), e.getValue()));\n        log.info(\"Body: {}\", response.getBody());\n        return response;\n    }\n    // 省略其他内容\n}</code></pre>\n<p>上面的代码运行后的效果大概会是下面这样的，包含 HTTP 响应码、响应中的所有 HTTP 头以及响应正文：</p>\n<pre class=\"code-rows\"><code>2020-12-16 00:28:17.866 INFO 44944 --- [main] learning.spring.customer.OrderRunner : HTTP Status:\n201 CREATED, Headers:\n2020-12-16 00:28:17.868 INFO 44944 --- [main] learning.spring.customer.OrderRunner : Content-Type:\n[application/json]\n2020-12-16 00:28:17.868 INFO 44944 --- [main] learning.spring.customer.OrderRunner : Content-Length:\n[436]\n2020-12-16 00:28:17.868 INFO 44944 --- [main] learning.spring.customer.OrderRunner : Date: [Tue, 15\nDec 2020 16:28:17 GMT]\n2020-12-16 00:28:17.868 INFO 44944 --- [main] learning.spring.customer.OrderRunner : Keep-Alive:\n[timeout=60]\n2020-12-16 00:28:17.868 INFO 44944 --- [main] learning.spring.customer.OrderRunner : Connection:\n[keep-alive]\n2020-12-16 00:28:17.868 INFO 44944 --- [main] learning.spring.customer.OrderRunner : Body: {\"id\":2,\n\"maker\":null,\"items\":[{\"id\":1,\"name\":\"Java咖啡\",\"size\":\"MEDIUM\",\"price\":{\"amount\":12.00,\"currency\":\n\"CNY\"},\"createTime\":\"2020-12-15T16:28:08.084+00:00\",\"updateTime\":\"2020-12-15T16:28:08.084+00:00\"}],\n\"amount\":{\"discount\":90,\"totalAmount\":{\"amount\":12.00,\"currency\":\"CNY\"},\"payAmount\":{\"amount\":10.80,\n\"currency\":\"CNY\"}},\"status\":\"ORDERED\",\"createTime\":\"2020-12-15T16:28:17.835+00:00\",\"updateTime\":\n\"2020-12-15T16:28:17.835+00:00\"}</code></pre>\n<p><code>postForXxx()</code> 方法中传递的请求对象也可以直接传入一个 <code>HttpEntity&lt;T&gt;</code> 对象（严格说起来这里的请求，应该是 <code>RequestEntity&lt;T&gt;</code>，里面可以对 HTTP 头做各种控制）。可以像代码示例 9-30 这样把 <code>callForEntity()</code> 稍微修改一下。</p>\n<blockquote>\n<p><strong>代码示例 9-30</strong>　请求对象改为 <code>RequestEntity&lt;T&gt;</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(5)\n@Setter\n@Slf4j\npublic class OrderRunner implements ApplicationRunner {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String binarytea;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        callWithEntity();\n    }\n\n    protected ResponseEntity&lt;String&gt; callWithEntity() {\n        NewOrderForm form = NewOrderForm.builder().itemIdList(Arrays.asList(\"1\")).discount(90).build();\n        URI uri = UriComponentsBuilder.fromUriString(binarytea + \"/order\").build().toUri();\n        RequestEntity&lt;NewOrderForm&gt; request = RequestEntity.post(uri).contentType(MediaType\n            .APPLICATION_JSON).body(form);\n        ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(binarytea + \"/order\", request,\n            String.class);\n        log.info(\"HTTP Status: {}, Headers: \", response.getStatusCode());\n        response.getHeaders().entrySet().forEach(e -&gt; log.info(\"{}: {}\", e.getKey(), e.getValue()));\n        log.info(\"Body: {}\", response.getBody());\n        return response;\n    }\n    // 省略其他内容\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>处理响应中的泛型</strong></p>\n<p>在上面的所有例子里，我们都只是简单地指定了请求和返回对象的类型，那如果我们希望返回的类型带有泛型又该怎么办呢？以 <code>MenuController</code> 的 <code>getAll()</code> 方法为例，返回的是 JSON 字符串，内容是一个列表，我们该怎么将它还原为 <code>List&lt;MenuItem&gt;</code> 呢？这时就该轮到 <code>RestTemplate</code> 的 <code>exchange()</code> 方法登场了，它在指定返回类型时，不仅可以简单地给出一个 <code>Class&lt;T&gt;</code>，也可以传入一个 <code>ParameterizedTypeReference&lt;T&gt;</code>，通过这个对象来指定泛型类型。具体如代码示例 9-31 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-31</strong>　通过 <code>exchange()</code> 方法查询菜单</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\n@Order(3)\npublic class MenuRunner implements ApplicationRunner {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String binarytea;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        // 省略其他内容\n        getAllMenu();\n    }\n\n    private void getAllMenu() {\n        ParameterizedTypeReference&lt;List&lt;MenuItem&gt;&gt;typeReference =\n                new ParameterizedTypeReference&lt;List&lt;MenuItem&gt;&gt;() {};\n        URI uri = UriComponentsBuilder.fromUriString(binarytea + \"/menu\").build().toUri();\n        RequestEntity&lt;Void&gt; request = RequestEntity.get(uri).accept(MediaType.APPLICATION_JSON).build();\n        ResponseEntity&lt;List&lt;MenuItem&gt;&gt; response = restTemplate.exchange(request, typeReference);\n        log.info(\"响应码：{}\", response.getStatusCode());\n        response.getBody().forEach( menuItem -&gt; log.info(\"条目：{}\", menuItem));\n    }\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>HTTP 客户端的单元测试</strong></p>\n<p>在日常的开发工作中，服务端与客户端的代码通常是由不同人编写的，而且会出现两者并行开发的情况。这时没办法向真实的服务端发起请求，又或者开发者希望能在自己的电脑上运行单元测试，而不依赖任何其他组件。一般这类情况下会有两种做法：</p>\n<ul>\n<li>将发起 HTTP 请求的客户端代码剥离出来，写成单独的类，通过 Mockito 等工具，模拟出这个对象，上层业务代码通过模拟的类进行测试；</li>\n<li>通过 MockWebServer<span class=\"comment-number\">16</span> 等工具模拟出一个服务端，它能接收请求并作出响应。</li>\n</ul>\n<p>显然，相比第一种方式，第二种方式有一个好处，就是它能覆盖具体发起 HTTP 请求的代码，所以，在这里我们来演示一下如何通过 MockWebServer 编写一个单元测试，大概分成下面几个步骤：</p>\n<p>(1) 引入 <code>com.squareup.okhttp3:mockwebserver</code> 依赖；</p>\n<p>(2) 在测试类中构造并启动 <code>MockWebServer</code>；</p>\n<p>(3) 获取 <code>MockWebServer</code> 的端口，设置到客户端；</p>\n<p>(4) 构造模拟的请求应答；</p>\n<p>(5) 客户端发起 HTTP 调用；</p>\n<p>(6) 验证客户端收到应答后的处理情况；</p>\n<p>(7) 验证模拟服务器收到的请求信息。</p>\n<p>我们就以代码示例 9-29 为例，为它编写一个单元测试，先在 pom.xml 中增加如下依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;\n    &lt;artifactId&gt;mockwebserver&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n<p>测试的公共部分如代码示例 9-32 所示，<code>@BeforeAll</code> 是在所有测试运行前执行的，在这里我们创建并启动了 <code>MockWebServer</code>；<code>@AfterAll</code> 在所有测试运行结束后执行，负责关闭 <code>MockWebServer</code>；<code>@BeforeEach</code> 是在每个测试运行前都会执行的，这里我们直接新建一个 <code>OrderRunner</code>，设置对应的属性；其实还有 <code>@AfterEach</code>，可以在每个测试运行后进行一些操作，这个例子里的清理就是把 <code>this.runner</code> 设置为 <code>null</code>，因为我们每次都会 <code>new</code> 一个，所以不用做这步动作，就不用写了。</p>\n<blockquote>\n<p><strong>代码示例 9-32</strong>　<code>OrderRunnerTest</code> 测试类的公共部分</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class OrderRunnerTest {\n    private static MockWebServer webServer;\n    private OrderRunner runner;\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @BeforeAll\n    static void setUp() throws IOException {\n        webServer = new MockWebServer();\n        webServer.start();\n    }\n\n    @AfterAll\n    static void tearDown() throws IOException {\n        webServer.shutdown();\n    }\n\n    @BeforeEach\n    void setUpBeforeEach() {\n        runner = new OrderRunner();\n        runner.setRestTemplate(new RestTemplate());\n        runner.setBinarytea(\"http://localhost:\" + webServer.getPort());\n    }\n    // 省略具体测试方法\n}</code></pre>\n<p>针对 <code>callForEntity()</code> 的测试方法 <code>testCallForEntity()</code> 的具体代码如代码示例 9-33 所示，我们先构造了一个模拟的应答，设置了 <code>201 Created</code> 响应码、<code>Content-Type</code> 头和应答的正文，通过 <code>enqueue()</code> 方法将其设置到 <code>MockWebServer</code> 里；随后调用 <code>runner.callForEntity()</code> 发起请求，再验证响应和请求的内容。</p>\n<blockquote>\n<p><strong>代码示例 9-33</strong>　<code>callForEntity()</code> 的测试方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class OrderRunnerTest {\n    // 省略公共部分代码\n    @Test\n    void testCallForEntity() throws Exception {\n        // 构造应答\n        String body = \"{\\\"id\\\":1, \\\"status\\\":\\\"ORDERED\\\"}\";\n        MockResponse response = new MockResponse().setResponseCode(HttpStatus.CREATED.value())\n                .addHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE).setBody(body);\n        webServer.enqueue(response);\n\n        ResponseEntity&lt;String&gt; entity = runner.callForEntity();\n        // 验证响应\n        assertEquals(HttpStatus.CREATED, entity.getStatusCode());\n        assertEquals(MediaType.APPLICATION_JSON_VALUE,entity.getHeaders().getFirst(HttpHeaders.CONTENT_TYPE));\n        assertEquals(body, entity.getBody());\n\n        // 验证请求\n        RecordedRequest request = webServer.takeRequest();\n        assertEquals(\"/order\", request.getPath());\n\n        NewOrderForm form = objectMapper.readValue(request.getBody().readUtf8(),NewOrderForm.class);\n        assertLinesMatch(Arrays.asList(\"1\"), form.getItemIdList());\n        assertEquals(90, form.getDiscount());\n    }\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：模板设计模式</strong></p>\n<p>模板模式是 GoF 23 种经典设计模式中的一种，它定义了整个程序执行的骨架，允许开发者在不改变大结构的前提下对其中的一些步骤进行定制。</p>\n<p>在 Spring Framework 中，模板模式的例子随处可见，例如我们之前看到过的 <code>JdbcTemplate</code>、<code>TransactionTemplate</code> 和这一节的 <code>RestTemplate</code>。以 <code>TransactionTemplate</code> 为例，常规的事务操作分为如下几个步骤：</p>\n<p>(1) 获取连接，并在该连接上开启事务；</p>\n<p>(2) 执行具体操作；</p>\n<p>(3) 提交或者回滚事务。</p>\n<p>其中的第 (2) 步可以通过 <code>TransactionCallback</code> 来传入具体的操作，整个事务操作的执行骨架在这个过程中是固定的。</p>\n<p><code>RestTemplate</code> 的情况也是类似的，整个过程分为创建请求、执行请求、获得结果和结果处理（提取内容），各种格式转换和底层的多种客户端都被 <code>RestTemplate</code> 封装了起来，可以根据我们的选择进行定制，但这些定制都不影响骨架。</p>\n<p>通过这两个例子，我们可以看到模板模式提升了代码的<strong>复用性和可扩展性</strong>。原始的模板模式需要使用抽象类，在 Spring Framework 里并没有这么教条，通过参数、配置、传入匿名类或 Lambda 的方式都可以发挥它的作用。</p>\n</blockquote>\n</li>\n</ol>\n\n<h3 id=\"nav_point_147\">9.4.3　简单定制 <code>RestTemplate</code></h3>\n<p>虽然直接用 <code>new</code> 关键字创建一个 <code>RestTemplate</code> 就能拿来使用了，但这样的 <code>RestTemplate</code> 使用的全是默认配置。在生产环境中，我们追求的不仅是能用，还要更快、更稳、更安全。Spring Framework 当然也充分考虑到了这些诉求，<code>RestTemplate</code> 是个模板，在固定的步骤背后有大量可以灵活配置的东西，下面就让我们一起来了解一下。</p>\n<ol>\n<li><p><strong>配置底层实现</strong></p>\n<p><code>RestTemplate</code> 在其父类 <code>HttpAccessor</code> 中默认设置了 <code>SimpleClientHttpRequestFactory</code> 作为请求工厂类，其内部使用 Java 内置的 <code>HttpURLConnection</code> 来处理请求。但其实 <code>RestTemplate</code> 支持不少 HTTP 客户端，表 9-17 列出了支持的客户端和对应的 <code>ClientHttpRequestFactory</code> 实现类。</p>\n<p><strong>表 9-17　<code>RestTemplate</code> 支持的 HTTP 客户端</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>客户端</th><th>版本</th><th><code>ClientHttpRequestFactory</code> 实现类</th></tr><tr><td>Apache HttpComponents</td><td>从 Spring Framework 4.0 开始仅支持 4.3 以上版本</td><td><code>HttpComponentsClientHttpRequestFactory</code></td></tr><tr><td>OkHttp</td><td>3.<i>x</i> 版本</td><td><code>OkHttp3ClientHttpRequestFactory</code></td></tr><tr><td>Netty</td><td>4.<i>x</i> 版本</td><td><code>ReactorClientHttpConnector</code>，在 Spring Framework 5.0 前是 <code>Netty4ClientHttpRequestFactory</code></td></tr></table>\n\n<p>HttpComponents 和 OkHttp 的实现都是同步的，而 Netty 的实现则是响应式的。要替换底层的客户端，其本质就是替换 <code>ClientHttpRequestFactory</code> 的实现。接下来，我们以 HttpComponents 为例，来做个简单的演示，有三种方法来设置 <code>requestFactory</code>，推荐在使用时优先考虑后两种方法。</p>\n<p>(1) 用 <code>new</code> 来从头创建一个 <code>RestTemplate</code>，通过构造方法或 <code>setRequestFactory()</code> 方法传入 <code>HttpComponentsClientHttpRequestFactory</code> 实例，这种做法无法利用 Spring Boot 提供的各种全局定制配置，不推荐。</p>\n<p>(2) 依然使用之前用过的 <code>RestTemplateBuilder</code> 来构造 <code>RestTemplate</code>，通过 <code>RestTemplateBuilder</code> 的 <code>requestFactory()</code> 传入 <code>HttpComponentsClientHttpRequestFactory</code> 实例，调用 <code>requestFactory()</code> 会创建一个新的 <code>RestTemplateBuilder</code>，因此仅对当前要 <code>build()</code> 的 <code>RestTemplate</code> 有效。</p>\n<p>(3) 创建一个 <code>RestTemplateCustomizer</code> 的实现类，并注册为 Bean，Spring Boot 自动配置的 <code>RestTemplateBuilder</code> 会收集上下文中所有的 <code>RestTemplateCustomizer</code>，在构造 <code>RestTemplate</code> 时，会调用 <code>RestTemplateCustomizer</code> 的 <code>customize()</code> 方法，我们的 <code>customize()</code> 负责为 <code>RestTemplate</code> 设置 <code>HttpComponentsClientHttpRequestFactory</code> 实例。这种方式会作用于所有的 <code>RestTemplate</code>。</p>\n<p>HttpComponents 是个功能强大的 HTTP 客户端，除了基本的功能，还支持 HTTP 代理、连接池管理、连接复用 Keep-Alive、超时重试等功能。在 pom.xml 中引入 HttpComponents 的依赖 <code>org.apache.httpcomponents:httpclient</code>，随后通过 <code>HttpClientBuilder</code> 可以很方便地定制 <code>HttpClient</code>，并用它来构建 <code>HttpComponentsClientHttpRequestFactory</code>，再创建 <code>RestTemplate</code>，具体如代码示例 9-34 所示。<span class=\"comment-number\">17</span></p>\n<blockquote>\n<p><strong>代码示例 9-34</strong>　使用 HttpComponents 作为底层 HTTP 客户端的 <code>RestTemplate</code> 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\npublic class CustomerApplication {\n    // 省略其他代码\n    @Bean\n    public RestTemplate restTemplate(RestTemplateBuilder builder) {\n        return builder\n                .requestFactory(this::requestFactory)\n                .setConnectTimeout(Duration.ofSeconds(1)) // 连接超时\n                .setReadTimeout(Duration.ofSeconds(5)) // 读取超时\n                .build();\n    }\n\n    @Bean\n    public ClientHttpRequestFactory requestFactory() {\n        HttpClientBuilder builder = HttpClientBuilder.create()\n        .disableAutomaticRetries() // 默认重试是开启的，建议关闭\n        .evictIdleConnections(10, TimeUnit.MINUTES) // 空闲连接10分钟关闭\n        .setConnectionTimeToLive(30, TimeUnit.SECONDS) // 连接的TTLS时间\n        .setMaxConnTotal(200) // 连接池大小\n        .setMaxConnPerRoute(20); // 每个主机的最大连接数\n\n        return new HttpComponentsClientHttpRequestFactory(builder.build());\n    }\n}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：HttpComponents 的 Keep-Alive 默认策略优化</strong></p>\n<p>通过 <code>HttpClientBuilder</code> 构造的 <code>HttpClient</code> 默认会使用 <code>DefaultConnectionKeepAliveStrategy</code> 这个 Keep-Alive 策略，该策略比较简单：</p>\n<ul>\n<li class=\"第3级无序列表\">查找 HTTP 头里的 <code>Keep-Alive</code> 头；</li>\n<li class=\"第3级无序列表\">找到 <code>Keep-Alive</code> 头里名称是 <code>timeout</code>（忽略大小写）的那项；</li>\n<li class=\"第3级无序列表\">有给定复用时间，就用给定的时间；</li>\n<li class=\"第3级无序列表\">除此之外，都返回 <code>- 1</code>，也就是连接永久有效。</li>\n</ul>\n<p>连接永久有效往往不是我们想要的结果，通常都会给一个默认时间，比如 300 秒。可以像下面这样通过 Lambda 表达式来实现一个 <code>ConnectionKeepAliveStrategy</code>，传给 <code>HttpClientBuilder</code>：</p>\n<pre class=\"code-rows\"><code>builder.setKeepAliveStrategy((response, context) -&gt;\n        Arrays.asList(response.getHeaders(HTTP.CONN_KEEP_ALIVE))\n                .stream()\n                .filter(h -&gt; StringUtils.equalsIgnoreCase(h.getName(), \"timeout\")\n                &amp;&amp; StringUtils.isNumeric(h.getValue()))\n                .findFirst()\n                .map(h -&gt; NumberUtils.toLong(h.getValue(), 300L))\n                .orElse(300L) * 1000);</code></pre>\n<p>这里用到的 <code>StringUtils</code> 和 <code>NumberUtils</code> 都是 Apache Common Langs3 中的辅助类。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置 SSL 相关选项</strong></p>\n<p>现在随着大家安全意识的加强（也要感谢各大厂商的强力推动），越来越多的网站开始对外提供 HTTPS 服务，甚至很多公司的内部服务也强制使用 HTTPS 访问。<span class=\"comment-number\">18</span></p>\n<p>在访问外部服务时，一般这些目标站点的数字证书都是由专门的机构签发的，Java 内置了大机构的根证书，可以进行证书的校验。针对这种情况，我们无须做什么特殊的处理。</p>\n<p>在提供内部 HTTPS 时，如果条件允许，当然也推荐购买或者使用免费的正规证书，但往往在很多企业内部会选择自己签发证书，这时 Java 无法验证证书的有效性，出于安全考虑就会让请求失败。这时有以下方案可以选择：</p>\n<p>(1) 将自签证书的根证书导入 Java 的证书链里，这样就能把自己模拟成签发机构；</p>\n<p>(2) 调整 <code>HttpClient</code> 的设置，忽略证书校验相关的错误。</p>\n<p>这里，我们演示一下第二种方案，具体如代码示例 9-35 所示。</p>\n<blockquote>\n<p><strong>代码示例 9-35</strong>　不校验证书和主机名的 <code>HttpClientBuilder</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>SSLContext sslContext = null;\ntry {\n    sslContext = SSLContextBuilder.create()\n    // 放过所有证书校验\n    .loadTrustMaterial(null, (certificate, authType) -&gt; true).build();\n} catch (GeneralSecurityException e) {\n    log.error(\"Can NOT create SSLContext\", e);\n}\nif (sslContext != null) {\n    builder.setSSLContext(sslContext) // 设置SSLContext\n            .setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE); // 不校验主机名\n}</code></pre>\n<p>如果是希望加载一个证书用于校验，可以在使用 <code>loadTrustMaterial()</code> 时，传入对应的证书与密码。最后，还是要强调一下，如果条件允许，无论什么情况，都应该使用正规机构签发的有效数字证书。</p>\n</li>\n</ol>\n\n\n<h2 id=\"nav_point_148\">9.5　小结</h2>\n<p>本章我们讨论了很多 Spring MVC 相关的内容。Spring MVC 主要用于 Web 开发，是日常开发 Web 应用必不可少的利器。以前的 Web 开发以后端为主，前端为辅；但现在更流行大前端和前后端分离的策略，前端同学挑大梁，后端负责提供 <code>REST</code> 接口。</p>\n<p>除了 Spring MVC 最基本的用法，我们还讨论了以 <code>DispatcherServlet</code> 为中心的请求处理流程，详细介绍了请求处理方法的内容。Spring MVC 的视图层支持很多不同的格式，本章介绍了常用于 <code>REST</code> 接口的 JSON 和 XML 格式，还有呈现页面用的 Thymeleaf 模板。虽然 Spring MVC 也可以提供静态资源服务，但在生产环境中，我们建议大家使用专门的静态资源服务器，例如 Nginx。</p>\n<p>最后我们介绍了 <code>RestTemplate</code> 的各种用法和相关配置，有了它就能方便地发起 HTTP 请求，更确切地说是发起 <code>REST</code> 请求的调用。</p>\n<p>下一章，我们将聊聊安全那些事儿，有针对性地讨论一下与 Web 安全相关的话题，具体看看 Spring Security 是怎么来保护我们的系统的。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>本章中，我们的二进制奶茶店已经有了一个使用 Spring MVC 开发的 Web 界面—服务员可以在浏览器里查看菜单并为顾客下单，还可以以逐条或批量上传的方式来维护菜单。</p>\n<p>为了方便系统交互，除了 Web 界面，服务端的程序还提供了对应的 REST 接口。而使用这些接口的正是我们为顾客开发的客户端程序，通过它，我们能够方便地与二进制奶茶店的服务端进行交互。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 9 章 Spring MVC 实践(2)","id":740877},"right":{"article_title":"第 10 章 保护 Web 安全(1)","id":740879}},"comments":[]}