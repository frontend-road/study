{"id":39841,"title":"16 | go语句及其执行规则（上）","content":"<p>你很棒，已经学完了关于Go语言数据类型的全部内容。我相信你不但已经知晓了怎样高效地使用Go语言内建的那些数据类型，还明白了怎样正确地创造自己的数据类型。</p><p>对于Go语言的编程知识，你确实已经知道了不少了。不过，如果你真想玩转Go语言还需要知道它的一些特色流程和语法。</p><p>尤其是我们将会在本篇文章中讨论的<code>go</code>语句，这也是Go语言的最大特色了。它足可以代表Go语言最重要的编程哲学和并发编程模式。</p><p>让我们再重温一下下面这句话：</p><blockquote>\n<p>Don’t communicate by sharing memory; share memory by communicating.</p>\n</blockquote><p>从Go语言编程的角度解释，这句话的意思就是：不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。</p><p>我们已经知道，通道（也就是channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的goroutine之间传递数据。那么goroutine到底代表着什么呢？</p><p>简单来说，goroutine代表着并发编程模型中的用户级线程。你可能已经知道，操作系统本身提供了进程和线程，这两种并发执行程序的工具。</p><h2>前导内容：进程与线程</h2><p>进程，描述的就是程序的执行过程，是运行着的程序的代表。换句话说，一个进程其实就是某个程序运行时的一个产物。如果说静静地躺在那里的代码就是程序的话，那么奔跑着的、正在发挥着既有功能的代码就可以被称为进程。</p><!-- [[[read_end]]] --><p>我们的电脑为什么可以同时运行那么多应用程序？我们的手机为什么可以有那么多App同时在后台刷新？这都是因为在它们的操作系统之上有多个代表着不同应用程序或App的进程在同时运行。</p><p>再来说说线程。首先，线程总是在进程之内的，它可以被视为进程中运行着的控制流（或者说代码执行的流程）。</p><p>一个进程至少会包含一个线程。如果一个进程只包含了一个线程，那么它里面的所有代码都只会被串行地执行。每个进程的第一个线程都会随着该进程的启动而被创建，它们可以被称为其所属进程的主线程。</p><p>相对应的，如果一个进程中包含了多个线程，那么其中的代码就可以被并发地执行。除了进程的第一个线程之外，其他的线程都是由进程中已存在的线程创建出来的。</p><p>也就是说，主线程之外的其他线程都只能由代码显式地创建和销毁。这需要我们在编写程序的时候进行手动控制，操作系统以及进程本身并不会帮我们下达这样的指令，它们只会忠实地执行我们的指令。</p><p>不过，在Go程序当中，Go语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程。</p><p>而对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。</p><p>这带来了很多优势，比如，因为它们的创建和销毁并不用通过操作系统去做，所以速度会很快，又比如，由于不用等着操作系统去调度它们的运行，所以往往会很容易控制并且可以很灵活。</p><p>但是，劣势也是有的，最明显也最重要的一个劣势就是复杂。如果我们只使用了系统级线程，那么我们只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他的一切具体实现都会由操作系统代劳。</p><p>但是，如果使用用户级线程，我们就不得不既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。</p><p>操作系统不但不会帮忙，还会要求我们的具体实现必须与它正确地对接，否则用户级线程就无法被并发地，甚至正确地运行。毕竟我们编写的所有代码最终都需要通过操作系统才能在计算机上执行。这听起来就很麻烦，不是吗？</p><p><strong>不过别担心，Go语言不但有着独特的并发编程模型，以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度器。</strong></p><p>这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：G（goroutine的缩写）、P（processor的缩写）和M（machine的缩写）。</p><p>其中的M指代的就是系统级线程。而P指的是一种可以承载若干个G，且能够使这些G适时地与M进行对接，并得到真正运行的中介。</p><p>从宏观上说，G和M由于P的存在可以呈现出多对多的关系。当一个正在与某个M对接并运行着的G，需要因某个事件（比如等待I/O或锁的解除）而暂停运行的时候，调度器总会及时地发现，并把这个G与那个M分离开，以释放计算资源供那些等待运行的G使用。</p><p>而当一个G需要恢复运行的时候，调度器又会尽快地为它寻找空闲的计算资源（包括M）并安排运行。另外，当M不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个M已无用时，调度器又会负责把它及时地销毁掉。</p><p>正因为调度器帮助我们做了很多事，所以我们的Go程序才总是能高效地利用操作系统和计算机资源。程序中的所有goroutine也都会被充分地调度，其中的代码也都会被并发地运行，即使这样的goroutine有数以十万计，也仍然可以如此。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/7d/9ea14f68ffbcde373ddb61e186695d7d.png?wh=1589*820\" alt=\"\"></p><p><strong> M、P、G之间的关系（简化版）</strong></p><p>由于篇幅原因，关于Go语言内部的调度器和运行时系统的更多细节，我在这里就不再深入讲述了。你需要知道，Go语言实现了一套非常完善的运行时系统，保证了我们的程序在高并发的情况下依旧能够稳定、高效地运行。</p><p>如果你对这些具体的细节感兴趣，并还想进一步探索，那么我推荐你去看看我写的那本《Go并发编程实战》。我在这本书中用了相当大的篇幅阐释了Go语言并发编程模型的原理、运作机制，以及所有与之紧密相关的知识。</p><p>下面，我会从编程实践的角度出发，以<code>go</code>语句的用法为主线，向你介绍<code>go</code>语句的执行规则、最佳实践和使用禁忌。</p><p>我们来看一下今天的<strong>问题：什么是主goroutine，它与我们启用的其他goroutine有什么不同？</strong></p><p>我们具体来看一道我在面试中经常提问的编程题。</p><pre><code>package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n\tfor i := 0; i &lt; 10; i++ {\n\t\tgo func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}\n</code></pre><p>在demo38.go中，我只在<code>main</code>函数中写了一条<code>for</code>语句。这条<code>for</code>语句中的代码会迭代运行10次，并有一个局部变量<code>i</code>代表着当次迭代的序号，该序号是从<code>0</code>开始的。</p><p>在这条<code>for</code>语句中仅有一条<code>go</code>语句，这条<code>go</code>语句中也仅有一条语句。这条最里面的语句调用了<code>fmt.Println</code>函数并想要打印出变量<code>i</code>的值。</p><p>这个程序很简单，三条语句逐条嵌套。我的具体问题是：这个命令源码文件被执行后会打印出什么内容？</p><p>这道题的<strong>典型回答</strong>是：不会有任何内容被打印出来。</p><h2>问题解析</h2><p>与一个进程总会有一个主线程类似，每一个独立的Go程序在运行时也总会有一个主goroutine。这个主goroutine会在Go程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。</p><p>想必你已经知道，每条<code>go</code>语句一般都会携带一个函数调用，这个被调用的函数常常被称为<code>go</code>函数。而主goroutine的<code>go</code>函数就是那个作为程序入口的<code>main</code>函数。</p><p>一定要注意，<code>go</code>函数真正被执行的时间，总会与其所属的<code>go</code>语句被执行的时间不同。当程序执行到一条<code>go</code>语句的时候，Go语言的运行时系统，会先试图从某个存放空闲的G的队列中获取一个G（也就是goroutine），它只有在找不到空闲G的情况下才会去创建一个新的G。</p><p>这也是为什么我总会说“启用”一个goroutine，而不说“创建”一个goroutine的原因。已存在的goroutine总是会被优先复用。</p><p>然而，创建G的成本也是非常低的。创建一个G并不会像新建一个进程或者一个系统级线程那样，必须通过操作系统的系统调用来完成，在Go语言的运行时系统内部就可以完全做到了，更何况一个G仅相当于为需要并发执行代码片段服务的上下文环境而已。</p><p>在拿到了一个空闲的G之后，Go语言运行时系统会用这个G去包装当前的那个<code>go</code>函数（或者说该函数中的那些代码），然后再把这个G追加到某个存放可运行的G的队列中。</p><p>这类队列中的G总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。</p><p>因此，<code>go</code>函数的执行时间总是会明显滞后于它所属的<code>go</code>语句的执行时间。当然了，这里所说的“明显滞后”是对于计算机的CPU时钟和Go程序来说的。我们在大多数时候都不会有明显的感觉。</p><p>在说明了原理之后，我们再来看这种原理下的表象。请记住，只要<code>go</code>语句本身执行完毕，Go程序完全不会等待<code>go</code>函数的执行，它会立刻去执行后边的语句。这就是所谓的异步并发地执行。</p><p>这里“后边的语句”指的一般是<code>for</code>语句中的下一个迭代。然而，当最后一个迭代运行的时候，这个“后边的语句”是不存在的。</p><p>在demo38.go中的那条<code>for</code>语句会以很快的速度执行完毕。当它执行完毕时，那10个包装了<code>go</code>函数的goroutine往往还没有获得运行的机会。</p><p>请注意，<code>go</code>函数中的那个对<code>fmt.Println</code>函数的调用是以<code>for</code>语句中的变量<code>i</code>作为参数的。你可以想象一下，如果当<code>for</code>语句执行完毕的时候，这些<code>go</code>函数都还没有执行，那么它们引用的变量<code>i</code>的值将会是什么？</p><p>它们都会是<code>10</code>，对吗？那么这道题的答案会是“打印出10个<code>10</code>”，是这样吗？</p><p>在确定最终的答案之前，你还需要知道一个与主goroutine有关的重要特性，即：一旦主goroutine中的代码（也就是<code>main</code>函数中的那些代码）执行完毕，当前的Go程序就会结束运行。</p><p>如此一来，如果在Go程序结束的那一刻，还有goroutine未得到运行机会，那么它们就真的没有运行机会了，它们中的代码也就不会被执行了。</p><p>我们刚才谈论过，当<code>for</code>语句的最后一个迭代运行的时候，其中的那条<code>go</code>语句即是最后一条语句。所以，在执行完这条<code>go</code>语句之后，主goroutine中的代码也就执行完了，Go程序会立即结束运行。那么，如果这样的话，还会有任何内容被打印出来吗？</p><p>严谨地讲，Go语言并不会去保证这些goroutine会以怎样的顺序运行。由于主goroutine会与我们手动启用的其他goroutine一起接受调度，又因为调度器很可能会在goroutine中的代码只执行了一部分的时候暂停，以期所有的goroutine有更公平的运行机会。</p><p>所以哪个goroutine先执行完、哪个goroutine后执行完往往是不可预知的，除非我们使用了某种Go语言提供的方式进行了人为干预。然而，在这段代码中，我们并没有进行任何人为干预。</p><p>那答案到底是什么呢？就demo38.go中如此简单的代码而言，绝大多数情况都会是“不会有任何内容被打印出来”。</p><p>但是为了严谨起见，无论应聘者的回答是“打印出10个<code>10</code>”还是“不会有任何内容被打印出来”，又或是“打印出乱序的<code>0</code>到<code>9</code>”，我都会紧接着去追问“为什么？”因为只有你知道了这背后的原理，你做出的回答才会被认为是正确的。</p><p>这个原理是如此的重要，以至于如果你不知道它，那么就几乎无法编写出正确的可并发执行的程序。如果你不知道此原理，那么即使你写的并发程序看起来可以正确地运行，那也肯定是运气好而已。</p><h2>总结</h2><p>今天，我描述了goroutine在操作系统的并发编程体系，以及在Go语言并发编程模型中的地位和作用。这些知识点会为你打下一个坚实的基础。</p><p>我还提到了Go语言内部的运行时系统和调度器，以及它们围绕着goroutine做的那些统筹调配和维护工作。这些内容中的每句话应该都会对你正确理解goroutine起到实质性的作用。你可以用这些知识去解释主问题中的那个程序在运行后为什么会产出那样的结果。</p><p>下一篇内容，我们还会继续围绕go语句以及执行规则谈一些扩展知识，今天留给你的思考题就是：用什么手段可以对goroutine的启用数量加以限制？</p><p>感谢你的收听，我们下次再见。</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","neighbors":{"left":{"article_title":"15 | 关于指针的有限操作","id":18042},"right":{"article_title":"17 | go语句及其执行规则（下）","id":39844}},"comments":[{"had_liked":false,"id":71627,"user_name":"Kevin Xiao","can_delete":false,"product_type":"c1","uid":1258274,"ip_address":"","ucode":"F3A5D18E731131","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/22/3e14fb1b.jpg","comment_is_top":false,"comment_ctime":1551402659,"is_pvip":false,"replies":[{"id":"25759","content":"Go语言里只有传值，没有传引用。如果go函数是无参数的匿名函数，那么在它里面的fmt.Println函数的参数只会在go函数被执行的时候才会求值。到那个时候，i的值可能已经是10（最后一个数）了，因为for语句那时候可能已经都执行完毕了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551415862,"ip_address":"","comment_id":71627,"utype":1}],"discussion_count":2,"race_medal":0,"score":"91745715875","product_id":100013101,"comment_content":"请问，该示例代码中，当go函数是一个闭包？而传给fmt.Println(a ...interface{})的是变量i的引用吗？","like_count":22,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441240,"discussion_content":"Go语言里只有传值，没有传引用。如果go函数是无参数的匿名函数，那么在它里面的fmt.Println函数的参数只会在go函数被执行的时候才会求值。到那个时候，i的值可能已经是10（最后一个数）了，因为for语句那时候可能已经都执行完毕了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551415862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381619,"discussion_content":"这相当于指针吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625146971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133348,"user_name":"ArtistLu","can_delete":false,"product_type":"c1","uid":1166373,"ip_address":"","ucode":"2E641A3EB4F9AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/cc/25/8c6eab2c.jpg","comment_is_top":false,"comment_ctime":1568523615,"is_pvip":true,"replies":[{"id":"51111","content":"可运行 G 队列里面是先入先出的，可是调度器里有多个可运行 G 队列（每个 P 都有一个），而且哪个 G 什么进入哪个可运行G 队列还另有规则。所以这两句话并不矛盾。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1568535069,"ip_address":"","comment_id":133348,"utype":1}],"discussion_count":2,"race_medal":0,"score":"78877934943","product_id":100013101,"comment_content":"老师请问下文中提到，这类队列中的 G 总是会按照先入先出的顺序……和Go 语言并不会去保证这些 goroutine 会以怎样的顺执行如何理解勒？<br>","like_count":18,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467360,"discussion_content":"可运行 G 队列里面是先入先出的，可是调度器里有多个可运行 G 队列（每个 P 都有一个），而且哪个 G 什么进入哪个可运行G 队列还另有规则。所以这两句话并不矛盾。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568535069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250580,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/14/21e0807e.jpg","nickname":"gm","note":"","ucode":"0E39AE5BE34E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380580,"discussion_content":"队列中是先进先出，而如何选择进哪个队列另有规则。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624590950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224173,"user_name":"Geek_51aa7f","can_delete":false,"product_type":"c1","uid":2029348,"ip_address":"","ucode":"B92E2C36923EB8","user_header":"","comment_is_top":false,"comment_ctime":1591299801,"is_pvip":false,"replies":[{"id":"82565","content":"即使P是1，M也可能有多个啊。“打印”是一种I&#47;O事件。只要是I&#47;O事件在执行的时候当前M和当前G就会脱离当前P，这时候当前P可以再去找别的G去运行。况且，操作系统也是会调度线程的运行的。<br><br>所以，这种顺序的预测还是不要做。如果想保证绝对的顺序，就要用同步工具或者通道。<br><br>最后，我看了一下最新的Go源码（go 1.14），在有一些时候调度器也会让G插队，比如在从通道的阻塞操作返回的时候，又比如在从网络I&#47;O事件返回的时候，还比如在执行GC任务的时候。不过，这种插队行为也可能不成功，比如在本地P的可运行G队列已满的时候。<br><br>最后的最后，还是那句话，除非有同步工具或者通道的保障，否则不要去猜测G的执行顺序。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1591328115,"ip_address":"","comment_id":224173,"utype":1}],"discussion_count":6,"race_medal":0,"score":"70310776537","product_id":100013101,"comment_content":"郝老师您好，我想知道设置了P的最大数量为1之后，那么根据使用go语句提交的顺序，调度器可运行队列或者本地P的队列运行顺序是先入先出的，但下面代码返回的结果却先打印了9然后是顺序打印0-8，这是为什么呢<br>func main() {<br>   runtime.GOMAXPROCS(1)<br>   for i := 0; i &lt; 10; i++ {<br>      go func(i int) {<br>         fmt.Println(i)<br>      }(i)<br>   }<br>   time.Sleep(time.Second)<br>}<br>&#47;&#47; 9 0 1 2 3 4 5 6 7 8","like_count":17,"discussions":[{"author":{"id":2100644,"avatar":"","nickname":"Geek_8e2759","note":"","ucode":"EBDBA4D92B5C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301558,"discussion_content":"`runtime.GOMAXPROCS()` 设置 P 的数量，实际上设置提 P 的 Local 队列数量；但是 go runtime 还会额外存在一个 global 队列，也就是说即使设置 GOMAXPROCS 为 1，系统中还是会至少存在两个调度队列。参考自 https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1598575689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2100644,"avatar":"","nickname":"Geek_8e2759","note":"","ucode":"EBDBA4D92B5C50","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312182,"discussion_content":"这篇推荐的文章很棒，谢谢！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602603058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301558,"ip_address":""},"score":312182,"extra":""}]},{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497388,"discussion_content":"即使P是1，M也可能有多个啊。“打印”是一种I/O事件。只要是I/O事件在执行的时候当前M和当前G就会脱离当前P，这时候当前P可以再去找别的G去运行。况且，操作系统也是会调度线程的运行的。\n\n所以，这种顺序的预测还是不要做。如果想保证绝对的顺序，就要用同步工具或者通道。\n\n最后，我看了一下最新的Go源码（go 1.14），在有一些时候调度器也会让G插队，比如在从通道的阻塞操作返回的时候，又比如在从网络I/O事件返回的时候，还比如在执行GC任务的时候。不过，这种插队行为也可能不成功，比如在本地P的可运行G队列已满的时候。\n\n最后的最后，还是那句话，除非有同步工具或者通道的保障，否则不要去猜测G的执行顺序。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591328115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1875343,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqHMAwG4atmGDJ2MtH9A3ua8N7rtxu7gAiaomCVJ53U2OBxLWibQa9gicmgfoTy4mCgFRoknes6iaJyEQ/132","nickname":"黄楷文","note":"","ucode":"130546198B6F55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387798,"discussion_content":"其实这个跟调度的实现有关，p在源码实现上是一个结构体，上面有两个属性存了g。一个是runq ,这个是一个长度为256的goroutine数组。还有个属性是runnext，这个属性保存了下一个可运行的g。协程在调度的时候总是优先从runnext中拿，如果runnext为空才会去runq中获取一个。新创建的协程总是会先放到runnext中，如果runnext已经有值了就会把之前的值放入到runq中。所以最后一个创建的goroutine会被先执行。但是虽然从调度的源码上来看是这样，还是跟作者说的一样，除非有同步工具或者通道的保障，否则不要去猜测G的执行顺序。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628418908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541034,"discussion_content":"这个代码案例很好啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640239715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312183,"discussion_content":"我觉得，既然大多数时候都是这么个固定的结果，必然是有深层次原因的。\n不知道有没有高手对着源码帮忙分析分析产生这个现象的原因。\n\n我猜测是两个G队列导致的，一个是本地的G队列，一个是全局的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602603193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24662,"user_name":"cygnus","can_delete":false,"product_type":"c1","uid":1120452,"ip_address":"","ucode":"C60A86E3084754","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/c4/e55fdc1c.jpg","comment_is_top":false,"comment_ctime":1537181741,"is_pvip":false,"replies":[{"id":"9373","content":"这是控制P的数量的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537443404,"ip_address":"","comment_id":24662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70256658477","product_id":100013101,"comment_content":"除了用带缓冲的通道，还可以用runtime.GOMAXPROCS(maxProcs)来控制Goroutine并发数","like_count":16,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424077,"discussion_content":"这是控制P的数量的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537443404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30920,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1539048353,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61668590497","product_id":100013101,"comment_content":"请问这个例子中go routine对变量i的捕获是引用？","like_count":14,"discussions":[{"author":{"id":1229070,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","nickname":"蜉蝣","note":"","ucode":"77CF92496855D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33135,"discussion_content":"使用函数之外的变量   这里是闭包","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571101249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201009,"avatar":"https://static001.geekbang.org/account/avatar/00/12/53/71/a4e9f20e.jpg","nickname":"言午木杉","note":"","ucode":"300BEDC1B07DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133397,"discussion_content":"是值传递","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578963834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229686,"user_name":"wilson","can_delete":false,"product_type":"c1","uid":2028264,"ip_address":"","ucode":"690A09CBBCCD80","user_header":"","comment_is_top":false,"comment_ctime":1593098243,"is_pvip":false,"replies":[{"id":"84779","content":"这个表示：调用前面的函数，也就是 func {} ","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1593148349,"ip_address":"","comment_id":229686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53132705795","product_id":100013101,"comment_content":"go func { } ()   最后那个左右括号的作用是什么？","like_count":13,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499592,"discussion_content":"这个表示：调用前面的函数，也就是 func {} ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593148349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28319,"user_name":"yandongxiao","can_delete":false,"product_type":"c1","uid":1017700,"ip_address":"","ucode":"D397F4DB0109C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/64/3882d90d.jpg","comment_is_top":false,"comment_ctime":1538050166,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"48782690422","product_id":100013101,"comment_content":"创建能创建成千上万个goroutine，但是不一定有那么多的系统资源，比如一般程序的最大可以打开4096个文件描述符。所以需要对goroutine 的启用数量加以限制。常用方法：<br>1. buffered channel<br>2. WaitGroup<br>","like_count":12,"discussions":[{"author":{"id":1636568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6iagw7ct4ca3niaSEFNicu2wy2KuCibO6eiaRzoRGJb50WTrbkKQib9mTArnTr8jJUazO9O2ibLZNfjjl35cfCHkBPs7N/132","nickname":"Geek_f39659","note":"","ucode":"2206A8C590423C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46001,"discussion_content":"我的理解是goroutine是基于线程池实现的轻量级用户线程，跟文件句柄什么的不沾边。这样可以同时有成千上万的goroutine在队列中等待调度。同时调度的数目就要取决于底下线程池的大小了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573108253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071974,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","nickname":"党","note":"","ucode":"EE531DB3EA124D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3034,"discussion_content":"goroutine是协程+线程，成千上万是可能","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564126740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613760,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9f/c0/86febfff.jpg","nickname":"Master","note":"","ucode":"79D0145B853C9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337810,"discussion_content":"老哥你这说的有问题啊，和系统级\n没关系啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609079434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87012,"user_name":"孙稚昊","can_delete":false,"product_type":"c1","uid":1010660,"ip_address":"","ucode":"44283BA4A577B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/e4/afacba1c.jpg","comment_is_top":false,"comment_ctime":1555496759,"is_pvip":false,"replies":[{"id":"31375","content":"我再强调一下。在go语句执行后，Go运行时系统会把对应的go函数装进新启用的goroutine中，随后调度执行。因为这个调度是不保证先后顺序的，所以这些go函数的执行在默认情况下也是乱序的。因此，你这样写无法保证数字的顺序打印。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555556121,"ip_address":"","comment_id":87012,"utype":1}],"discussion_count":5,"race_medal":0,"score":"44505169719","product_id":100013101,"comment_content":"如果是<br>package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func(i int) {<br>\t\t\tfmt.Println(i)<br>\t\t}(i)<br>\t}<br>}<br>这样子的话，i输入就是0-9了吧","like_count":10,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447280,"discussion_content":"我再强调一下。在go语句执行后，Go运行时系统会把对应的go函数装进新启用的goroutine中，随后调度执行。因为这个调度是不保证先后顺序的，所以这些go函数的执行在默认情况下也是乱序的。因此，你这样写无法保证数字的顺序打印。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555556121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2100644,"avatar":"","nickname":"Geek_8e2759","note":"","ucode":"EBDBA4D92B5C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301555,"discussion_content":"保证的是传递给每个 go 的参数是  0-9；但各个 go 得到『被执行』的顺序是无法保证的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598575261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1417824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","nickname":"哈哼","note":"","ucode":"C1108406573D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":11745,"discussion_content":"他说的是这样i就不会重复，不可能都是10之类的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568428568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1171449,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL40CYbBtPXNzH9iatW8pdfsGR321dgzicIujfa0fyEh0KsowmrEBsLcznZ4A0SichgECtOib3SsyU6jg/132","nickname":"豢龙氏","note":"","ucode":"7F50E0EE2CFC5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1417824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a2/60/f3939ab4.jpg","nickname":"哈哼","note":"","ucode":"C1108406573D49","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298752,"discussion_content":"试一下，确实是0-9乱序","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597392291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":11745,"ip_address":""},"score":298752,"extra":""}]},{"author":{"id":2323770,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/UsavciapkMHkEnWLF3Dy9Od2VfLc1h56ibw26icXLfkoXhLyh8fIWTerz214ZImpyKf0S0AFAKjGa8oyL7iavZubcA/132","nickname":"Geek_a21c83","note":"","ucode":"151208F780F47D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383095,"discussion_content":"我试了下，结果也是空啊。主goroutine运行完直接退出，这些开启的goroutine没机会执行的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1625902695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138204,"user_name":"坤坤","can_delete":false,"product_type":"c1","uid":1307441,"ip_address":"","ucode":"E18B495A98A14C","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/31/903448f8.jpg","comment_is_top":false,"comment_ctime":1570092753,"is_pvip":false,"replies":[{"id":"53416","content":"主要是因为计算机的内存（以及其他资源）总是有限的。从程序设计的角度讲，限制某种执行高并发任务的 goroutine 的数量也是很有必要的。另外，单进程内数十万的 goroutine 也会对 Go 语言的调度器和操作系统带来不小的压力。<br><br>再有，我们应该尽量地去量化程序对资源的使用，并且有节制地区使用资源。当然，具体的使用上限设定成多少合适，还有以实际压测的结果为准。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1570435708,"ip_address":"","comment_id":138204,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40224798417","product_id":100013101,"comment_content":"既然 GPM 分层模型定义了 G 与 M 可以多对多，并且 G 的创建代价很小数量没有限制。为什么要对 goroutine 的启用数量加以限制？","like_count":9,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469435,"discussion_content":"主要是因为计算机的内存（以及其他资源）总是有限的。从程序设计的角度讲，限制某种执行高并发任务的 goroutine 的数量也是很有必要的。另外，单进程内数十万的 goroutine 也会对 Go 语言的调度器和操作系统带来不小的压力。\n\n再有，我们应该尽量地去量化程序对资源的使用，并且有节制地区使用资源。当然，具体的使用上限设定成多少合适，还有以实际压测的结果为准。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570435708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205305,"user_name":"扩散性百万咸面包","can_delete":false,"product_type":"c1","uid":1905171,"ip_address":"","ucode":"6D703D51553B42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","comment_is_top":false,"comment_ctime":1586589254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18766458438","product_id":100013101,"comment_content":"goroutine协程与线程进程的区别是什么（这是面试常考的）？为什么它的创建和销毁开销就这么低？再说了GPM也会对接系统级线程啊，也应该会存在系统调用，那优势体现在哪里呢？<br><br>还有能不能举几个关于用户级线程的例子？我知道系统级线程是用比如glibc的库函数创建的，但是不了解用户级线程。感觉多线程库，我们也确实只需要管线程的创建和销毁啊，并不管调度。","like_count":5},{"had_liked":false,"id":30017,"user_name":"🚲🏃🏊","can_delete":false,"product_type":"c1","uid":1103772,"ip_address":"","ucode":"F235DF04916264","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/9c/f7d3b973.jpg","comment_is_top":false,"comment_ctime":1538624706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18718493890","product_id":100013101,"comment_content":"限制G的数量，可以使用goroutine pool","like_count":4},{"had_liked":false,"id":26151,"user_name":"colben","can_delete":false,"product_type":"c1","uid":1200769,"ip_address":"","ucode":"5E5DBA48578E96","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/81/745475e9.jpg","comment_is_top":false,"comment_ctime":1537507037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18717376221","product_id":100013101,"comment_content":"&quot;那也肯定是运气好而已&quot;<br>“总结”前的最后这句话说得太对了！","like_count":4},{"had_liked":false,"id":24573,"user_name":"oyt","can_delete":false,"product_type":"c1","uid":1075038,"ip_address":"","ucode":"E1E4F27FB3535F","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/5e/e0323566.jpg","comment_is_top":false,"comment_ctime":1537148091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14422049979","product_id":100013101,"comment_content":"要限制goroutine的启用数量，即达到规定限制数量后就阻塞。 可以使用有缓冲的channel，例如chanCount：=make(chan int,10) 可以限制启用10个goroutine。","like_count":3},{"had_liked":false,"id":81785,"user_name":"杨康","can_delete":false,"product_type":"c1","uid":1179356,"ip_address":"","ucode":"B9BAE2DCE50CAC","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/dc/3c025f83.jpg","comment_is_top":false,"comment_ctime":1554034826,"is_pvip":false,"replies":[{"id":"29705","content":"隐式传递？我好像没说过这个词吧。总之这种传递都是值传递。<br><br>你说的这个问题与值传递没有直接关系。原因是go函数的执行顺序的不确定性。当这些go函数执行时，迭代变量i的值是什么，go函数就会拿到什么。你可以再看看我在文章中的说明。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1554128518,"ip_address":"","comment_id":81785,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143969418","product_id":100013101,"comment_content":"你好，老师，这个里面的变量i 传递到goroutine里面应该是值传递，为什么会出现1,10,10,10这种情况呢？<br>如果真的是值传递，怎么理解go语言中隐式传递是值传递这句话。","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445342,"discussion_content":"隐式传递？我好像没说过这个词吧。总之这种传递都是值传递。\n\n你说的这个问题与值传递没有直接关系。原因是go函数的执行顺序的不确定性。当这些go函数执行时，迭代变量i的值是什么，go函数就会拿到什么。你可以再看看我在文章中的说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554128518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63247,"user_name":"帅","can_delete":false,"product_type":"c1","uid":1207367,"ip_address":"","ucode":"DB792F56C26429","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/47/57b6c4e8.jpg","comment_is_top":false,"comment_ctime":1548311035,"is_pvip":false,"replies":[{"id":"25245","content":"不会，主goroutine结束了进程也就结束了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551181118,"ip_address":"","comment_id":63247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138245627","product_id":100013101,"comment_content":"demo38的例子，主gorutine结束之后，其他已经被调度的gorutine，会继续执行吗？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437518,"discussion_content":"不会，主goroutine结束了进程也就结束了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551181118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24812,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1537195734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10127130326","product_id":100013101,"comment_content":"不认为 buffered channel 的容量可以限制 goroutine 的数量，这个数量的最佳值应该跟硬件配置相关，但是如何限制应该是一个runtime 的参数来限制。具体是什么，还真不清楚。","like_count":2},{"had_liked":false,"id":277747,"user_name":"mkii","can_delete":false,"product_type":"c1","uid":1674466,"ip_address":"","ucode":"534914EC7EA304","user_header":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","comment_is_top":false,"comment_ctime":1612539953,"is_pvip":false,"replies":[{"id":"100846","content":"这是由于：这些go函数的执行顺序在默认情况下相当于是伪随机的。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1612676679,"ip_address":"","comment_id":277747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5907507249","product_id":100013101,"comment_content":"试了一下让主goroutine退出前睡1秒，会打印多个10","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515153,"discussion_content":"这是由于：这些go函数的执行顺序在默认情况下相当于是伪随机的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612676679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168236,"user_name":"水先生","can_delete":false,"product_type":"c1","uid":1249714,"ip_address":"","ucode":"362A71DF511E3E","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/b2/dd0606b2.jpg","comment_is_top":false,"comment_ctime":1578035911,"is_pvip":false,"replies":[{"id":"65373","content":"这里的两个print是做对比用的吧。0～9顺序打印应该是第一个print打印出来的。你可以把两个print打印的东西分别加上不同的前缀。这样就容易区分了。<br><br>go函数的执行会稍微滞后一些，所以当 for 语句执行完的时候（迭代变量 i 会定格在 10 这个值上），有的go函数可能还没开始执行。等到它们执行的时候，打印变量 i，就只会打印出 10。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1578121282,"ip_address":"","comment_id":168236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873003207","product_id":100013101,"comment_content":"func main() {<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tfmt.Println(i) &#47;&#47; the first Print<br>\t\tgo func() {<br>\t\t\tfmt.Println(i)\t&#47;&#47; the second Print<br>\t\t}()<br>\t}<br>}<br>-------<br>第一个print算是为go函数争取了执行时间吗？得到的结果是0至9顺序，然后3，6，10，10，10。<br>按理，循环到10，go函数不是应该结束了么？为啥还会多两个10的呀？<br>麻烦老师~","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480169,"discussion_content":"这里的两个print是做对比用的吧。0～9顺序打印应该是第一个print打印出来的。你可以把两个print打印的东西分别加上不同的前缀。这样就容易区分了。\n\ngo函数的执行会稍微滞后一些，所以当 for 语句执行完的时候（迭代变量 i 会定格在 10 这个值上），有的go函数可能还没开始执行。等到它们执行的时候，打印变量 i，就只会打印出 10。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578121282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165252,"user_name":"lixiaofeng","can_delete":false,"product_type":"c1","uid":1100200,"ip_address":"","ucode":"0D6710D95B6FFB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a8/98507423.jpg","comment_is_top":false,"comment_ctime":1577188852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872156148","product_id":100013101,"comment_content":"goroutine 代表着并发模型中的用户级线程。<br>一个进程就是某个程序运行时的产物。<br>线程总是在进程之内，它可以被视为进程中运行着的控制流。<br>每个进程的第一个线程都会随着该进程的启动而创建，他们可以被称为所属进程的主线程。<br>主线程之外的其他线程都由代码显示的创建和销毁。<br>Go语言运行时（runtime）系统会帮助我们自动创建和销毁系统级线程。<br>Go 语言不但有独特的并发编程模型，以及用户级线程goroutine ，还拥有强大的goroutine 。<br>调度器是Go 语言运行时（runtime）的重要组成部分，它主要负责统筹调配go 并发编程模型中的三个主要元素：<br>Goroutine<br>processor，<br>mechine，系统级线程<br>G和M 之间，由于P的存在呈现出，多对多的关系<br>当一个G由于某些原因暂停时，P 会及时发现，并把相应的M 分开，给其他的G 使用。","like_count":1},{"had_liked":false,"id":105083,"user_name":"jacke","can_delete":false,"product_type":"c1","uid":1161209,"ip_address":"","ucode":"05F355E1FF88C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/f9/a8f26b10.jpg","comment_is_top":false,"comment_ctime":1560913278,"is_pvip":false,"replies":[{"id":"38167","content":"可以从两个方面理解：<br><br>1. 这些 go 函数的执行顺序是不固定的。这个想必你已经理解了。<br>2. 当一个 fmt.Println 引发 I&#47;O 操作的时候也可能被中断（被切换下 CPU）。当它再次获得运行机会的时候，也许其他的 fmt.Println 都打印完了。这种切换其实就是 Go 运行时系统进行调度的结果。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1561003644,"ip_address":"","comment_id":105083,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5855880574","product_id":100013101,"comment_content":"问下：<br>func main() {<br>\tfmt.Println(&quot;cup &quot;,runtime.NumCPU())<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func() {<br>\t\t\tfmt.Println(i, &amp;i)<br>\t\t}()<br>\t}<br>\ttime.Sleep(time.Second)<br>}<br>结果：<br>cup  4<br>10 0xc420016088<br>10 0xc420016088<br>10 0xc420016088<br>10 0xc420016088<br>10 0xc420016088<br>10 0xc420016088<br>10 0xc420016088<br>4 0xc420016088<br>10 0xc420016088<br>10 0xc420016088<br> <br>疑问：go routine的调度是随机，按照郝老师的讲解，在go routine得到执行的时候 fmt.Println，前面的i以及是10了，为什么后面还有打印是4的情况,而且看出来i地址一样，应该是同一个值？是不是go routine执行是并行的原因，所以打印到屏幕显示缓冲区，最后是乱序？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454554,"discussion_content":"可以从两个方面理解：\n\n1. 这些 go 函数的执行顺序是不固定的。这个想必你已经理解了。\n2. 当一个 fmt.Println 引发 I/O 操作的时候也可能被中断（被切换下 CPU）。当它再次获得运行机会的时候，也许其他的 fmt.Println 都打印完了。这种切换其实就是 Go 运行时系统进行调度的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561003644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253063,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/rUPjvMdUGic56wNdVm0be85REaB7nLwyEC7HiamhmeWsQichtADA3IsFubIqOXMjlsEtmicdpDRC2YhNWVrpPKj1lw/132","nickname":"姜子牙","note":"","ucode":"1830E2FA33308B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3159,"discussion_content":"这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系...\n\n极客时间版权所有: https://time.geekbang.org/column/article/39841 如果按这句来理解，打印4的不是肯定在打印10 的之前吗？为啥顺序又是不固定的了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564234046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24682,"user_name":"江山如画","can_delete":false,"product_type":"c1","uid":1188280,"ip_address":"","ucode":"BEB6228E6135B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/b8/aca814dd.jpg","comment_is_top":false,"comment_ctime":1537184383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832151679","product_id":100013101,"comment_content":"如果允许开启的最大协程数是 maxRoutineNumber ， 可以用 容量为maxRoutineNumber的空结构体类型的缓冲通道 控制允许启用的最大协程数目。<br><br>实验代码如下：<br><br>func handle(i int, ch chan struct{}) {<br>\t_ = i<br>\t&lt;-ch<br>}<br><br>func main() {<br>\tvar maxRoutineNumber int = 10 &#47;&#47;最大允许开启的协程数目<br>\tch := make(chan struct{}, maxRoutineNumber)<br><br>\tvar total int = 1000000 &#47;&#47;总的处理数目<br><br>\tfor i := 0; i &lt; total; i++ {<br>\t\tch &lt;- struct{}{}<br>\t\tgo handle(i, ch)<br>\t}<br><br>}<br>","like_count":1},{"had_liked":false,"id":24586,"user_name":"开开心心","can_delete":false,"product_type":"c1","uid":1203132,"ip_address":"","ucode":"42AB03AA49628E","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/bc/c3bcd529.jpg","comment_is_top":false,"comment_ctime":1537156139,"is_pvip":false,"replies":[{"id":"9374","content":"不应该，我这里也正常，不知道你还改了什么。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537443506,"ip_address":"","comment_id":24586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5832123435","product_id":100013101,"comment_content":"这样子为什么会造成阻塞？我就加了\ttime.Sleep(1*time.Microsecond)，而且时间很短<br>for i := uint32(0); i &lt; 10; i++ {<br>\t\tgo func(i uint32) {<br>\t\t\tfn := func() {<br>\t\t\t\ttime.Sleep(1*time.Microsecond)<br>\t\t\t\tfmt.Println(i)<br>\t\t\t}<br>\t\t\t&#47;&#47;fmt.Println(&quot;准备&quot;,i)<br>\t\t\ttrigger(i, fn)<br>\t\t}(i)<br>\t}","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424045,"discussion_content":"不应该，我这里也正常，不知道你还改了什么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537443506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352274,"user_name":"晴天了","can_delete":false,"product_type":"c1","uid":1359669,"ip_address":"","ucode":"5310E02F8DF1F0","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/35/0e3a92a7.jpg","comment_is_top":false,"comment_ctime":1658491967,"is_pvip":false,"replies":[{"id":"128217","content":"你是对哪段代码还是哪句话有疑问？","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1658751455,"ip_address":"","comment_id":352274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1658491967","product_id":100013101,"comment_content":"问下老师 为什么协程 go语句main被等待了","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581393,"discussion_content":"你是对哪段代码还是哪句话有疑问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658751455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336995,"user_name":"李泰汛","can_delete":false,"product_type":"c1","uid":1880234,"ip_address":"","ucode":"379E06A90A30D9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZxgDrR65vd6wo2ibFQM3r0IdqlY0sG0ZOJAnMuhjVfJmib4ib3dbNlnz0MH4YmjV9ajQ6IXXiaVYRlg/132","comment_is_top":false,"comment_ctime":1646541350,"is_pvip":false,"replies":[{"id":"123140","content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1646559682,"ip_address":"","comment_id":336995,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1646541350","product_id":100013101,"comment_content":"思考题：我觉得是有存在的意义的，因为指针可以重新赋值而指向其他的变量，而引用却不能，引用封装了底层数据的裸指针，除此之外，还添加了其他一些数据，比如slice的len和cap。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554701,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646559682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1880234,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZxgDrR65vd6wo2ibFQM3r0IdqlY0sG0ZOJAnMuhjVfJmib4ib3dbNlnz0MH4YmjV9ajQ6IXXiaVYRlg/132","nickname":"李泰汛","note":"","ucode":"379E06A90A30D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":554799,"discussion_content":"评论怎么跑到下一章了哈哈，谢谢老师回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646620741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":554701,"ip_address":""},"score":554799,"extra":""}]}]},{"had_liked":false,"id":336162,"user_name":"Geek_108cb5","can_delete":false,"product_type":"c1","uid":2355516,"ip_address":"","ucode":"47959B1E8926A5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/KhQRc8hIxHHyPV3Og2Fc5qhN3zkWUnw31wkc7mcmGyxicD9Yrvhh7N5B3icqpgWZXfuWbysn7Lv6QMPIEmYPeC4w/132","comment_is_top":false,"comment_ctime":1645962973,"is_pvip":false,"replies":[{"id":"122884","content":"没错，是这样，所以若要想结果可预测，就需要使用专用工具来协调。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1646027893,"ip_address":"","comment_id":336162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645962973","product_id":100013101,"comment_content":"其实也可能不是打印10个10的， 也有可能中间某个协程刚好就是执行了， 所以其实结果是不可预测的","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553683,"discussion_content":"没错，是这样，所以若要想结果可预测，就需要使用专用工具来协调。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646027894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332862,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1643765640,"is_pvip":true,"replies":[{"id":"121713","content":"自从线程技术正式在CPU中出现以来，每个进程都会有一个主线程的，与是否有其他线程无关。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1644042934,"ip_address":"","comment_id":332862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643765640","product_id":100013101,"comment_content":"这章节主要阐述或者说想表达的还是对go语言，就只有一个主程在运行，主程结束了以后，其他相关的线程就关闭的了。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549511,"discussion_content":"自从线程技术正式在CPU中出现以来，每个进程都会有一个主线程的，与是否有其他线程无关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644042935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327938,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1640404232,"is_pvip":false,"replies":[{"id":"119433","content":"我不知道你这句话哪儿来的，看官方文档，看官方文档，看官方文档，重要的事情我再跟你说三遍！（我记得跟你说过不止两次了）给你网址：https:&#47;&#47;pkg.go.dev&#47;runtime#GOMAXPROCS","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1640490907,"ip_address":"","comment_id":327938,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640404232","product_id":100013101,"comment_content":"The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. <br>根据go文档的描述GOMAXPROCS是用来控制系统级线程的数量，那不就是图中M吗，但是又有说法是指的P的数量，这个GOMAXPROCS到底指的应该谁呢。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541628,"discussion_content":"我不知道你这句话哪儿来的，看官方文档，看官方文档，看官方文档，重要的事情我再跟你说三遍！（我记得跟你说过不止两次了）给你网址：https://pkg.go.dev/runtime#GOMAXPROCS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640490908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327853,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1640328760,"is_pvip":false,"replies":[{"id":"119436","content":"你需要好好看一下GPM模型，G是可以被灵活调度的，除非特殊情况，它可以在任何M上运行（M代表系统线程）。 而且P并不代表go程序，一个P相当于一个输送G的轨道，我们设置GOMAXPROCS的时候，实际上就是在设置这个轨道的数量，设置可以有多少个轨道同时向CPU输送G，所以最好设置成与CPU逻辑核心数量相同。","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1640491125,"ip_address":"","comment_id":327853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640328760","product_id":100013101,"comment_content":"看了这里解释的P，结合effective-go中相关描述:<br>The current implementation of the Go runtime will not parallelize this code by default. It<br>dedicates only a single core to user-level processing. An arbitrary number of goroutines can be<br>blocked in system calls, but by default only one can be executing user-level code at any time. It<br>should be smarter and one day it will be smarter, but until it is if you want CPU parallelism you<br>must tell the run-time how many goroutines you want executing code simultaneously. There are<br>two related ways to do this. Either run your job with environment variable GOMAXPROCS set to<br>the number of cores to use or import the runtime package and call runtime.GOMAXPROCS(NCPU).<br>A helpful value might be runtime.NumCPU(), which reports the number of logical CPUs on the<br>local machine. Again, this requirement is expected to be retired as the scheduling and run-time<br>improve.<br><br>这段文字应该是针对cpu计算型任务而言，<br>P是否可以理解为一个go程序，通过GOMAXPROCS控制内部有多少个P同时在不同CPU上运行各自的goroutine，如果值为1，那么用户态的goroutine始终用一个cpu运算","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541631,"discussion_content":"你需要好好看一下GPM模型，G是可以被灵活调度的，除非特殊情况，它可以在任何M上运行（M代表系统线程）。 而且P并不代表go程序，一个P相当于一个输送G的轨道，我们设置GOMAXPROCS的时候，实际上就是在设置这个轨道的数量，设置可以有多少个轨道同时向CPU输送G，所以最好设置成与CPU逻辑核心数量相同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640491125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327226,"user_name":"ian","can_delete":false,"product_type":"c1","uid":1330724,"ip_address":"","ucode":"83C411A9BA8D0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoIbczdrKInh6f4Mh1HVt6umicibxHQmSccrytwf8Ev0nfLRLYmHHibia6s4a9BSsR8SI0ib4VAav9ibLOg/132","comment_is_top":false,"comment_ctime":1639990918,"is_pvip":false,"replies":[{"id":"119122","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1640066441,"ip_address":"","comment_id":327226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639990918","product_id":100013101,"comment_content":"创建goroutine，可以理解成线程的创建，也算一种异步操作；<br>go事件触发后，立马会执行之后的代码，文中的for循环，新运行了10个g，都是异步发生，不做人为干预，所以具体调度到的时间也是不确定的；<br>而只有go函数调度到的时候，才会真正使用到 i 的值，由于goroutine的滞后性，导致这个时候 i 可能已经是最后的10了","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540480,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640066441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323943,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1638235845,"is_pvip":false,"replies":[{"id":"117597","content":"这个调度的时机还可以是执行语句的前后，不仅仅是阻塞发生的时候。如果你对这方面很感兴趣，我强烈建议你看我写的那本书。虽然是前些年写的，但现在也不过时，而且里面介绍的非常详细。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1638271006,"ip_address":"","comment_id":323943,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638235845","product_id":100013101,"comment_content":"<br>由于主 goroutine 会与我们手动启用的其他 goroutine 一起接受调度，又因为调度器很可能会在 goroutine 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会。<br>暂停的时机和条件是什么： 是否是go函数中执行等待而引起阻塞时触发，还有其他情况可能引起暂停吗<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534756,"discussion_content":"这个调度的时机还可以是执行语句的前后，不仅仅是阻塞发生的时候。如果你对这方面很感兴趣，我强烈建议你看我写的那本书。虽然是前些年写的，但现在也不过时，而且里面介绍的非常详细。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638271006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323942,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1638235841,"is_pvip":false,"replies":[{"id":"117596","content":"显然不是一个队列啊，“空闲G队列”和“可运行G队列”。如果想详细了解，可以买我之前写的那本《Go并发编程实战》来看。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1638270794,"ip_address":"","comment_id":323942,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638235841","product_id":100013101,"comment_content":"<br>当程序执行到一条go语句的时候，Go 语言的运行时系统，会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine）<br>...<br>然后再把这个 G 追加到某个存放可运行的 G 的队列中。<br>文中提到的这两个队列是否是同一个队列：","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534754,"discussion_content":"显然不是一个队列啊，“空闲G队列”和“可运行G队列”。如果想详细了解，可以买我之前写的那本《Go并发编程实战》来看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638270794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284243,"user_name":"爱看书的小女神","can_delete":false,"product_type":"c1","uid":1347664,"ip_address":"","ucode":"5E21F5A1161054","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZZZzKAbLpj2qZwic2brxJ9laAcFFkjN0k8qib0UuXCwFuL472KCcDic1VeTpQ1oUxSu1TK9pPyiaRIQ/132","comment_is_top":false,"comment_ctime":1616135380,"is_pvip":false,"replies":[{"id":"103185","content":"这时会让 M 和 G 分开，然后让空闲的 M 去运行其他的可运行 G；当 M 开始运行某个 G 之前，这个 G 就已经被移出相应 P 的可运行队列了；另外，M 与 P 之间没有必然联系。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1616303418,"ip_address":"","comment_id":284243,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1616135380","product_id":100013101,"comment_content":"请问，当M运行的G 系统级调用发生阻塞时，那么P是让M与G分开，还是把M和G与P分开，然后去用空闲的M(没有空闲再去创建M)去运行下一个G?","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517282,"discussion_content":"这时会让 M 和 G 分开，然后让空闲的 M 去运行其他的可运行 G；当 M 开始运行某个 G 之前，这个 G 就已经被移出相应 P 的可运行队列了；另外，M 与 P 之间没有必然联系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616303418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361322,"discussion_content":"老师回答错了吧？题主问的是M和G在系统调用时发生阻塞，《go并发编程实战》讲，G会导致M一起阻塞。\n感觉老师是不是没看清“系统调用”啊，老师回答应该是非系统调用阻塞的场景吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616641992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273404,"user_name":"DavidJiang","can_delete":false,"product_type":"c1","uid":1643779,"ip_address":"","ucode":"92EBF337569A1B","user_header":"https://static001.geekbang.org/account/avatar/00/19/15/03/682bd618.jpg","comment_is_top":false,"comment_ctime":1610589373,"is_pvip":false,"replies":[{"id":"99075","content":"你那个 i0 在每次迭代里都是一个新变量啊（i0 := i），都是单独存储的，","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1610598928,"ip_address":"","comment_id":273404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610589373","product_id":100013101,"comment_content":"为啥这样写i值就是不同的?\t<br>var wg sync.WaitGroup<br><br>\tfor i := 0; i &lt; 10; i++ {<br>\t\twg.Add(1)<br>\t\ti0 := i<br>\t\tgo func() {<br>\t\t\tdefer wg.Done()<br>\t\t\t&#47;&#47;time.Sleep(1 * time.Second)<br>\t\t\tfmt.Println(i0)<br>\t\t}()<br><br>\t\t&#47;&#47;go func(i int) {<br>\t\t&#47;&#47;\tdefer wg.Done()<br>\t\t&#47;&#47;\ttime.Sleep(1 * time.Second)<br>\t\t&#47;&#47;\tfmt.Println(i)<br>\t\t&#47;&#47;}(i)<br>\t}<br><br>\twg.Wait() &#47;&#47; 等待<br><br>\tfmt.Println(&quot;TestGorouting main end&quot;)<br><br><br>这样写i的值就全是10?<br>\tfmt.Println(&quot;TestGorouting main exist&quot;)<br>\tvar wg sync.WaitGroup<br><br>\tfor i := 0; i &lt; 10; i++ {<br>\t\twg.Add(1)<br>\t\t&#47;&#47;i0 := i<br>\t\tgo func() {<br>\t\t\tdefer wg.Done()<br>\t\t\t&#47;&#47;time.Sleep(1 * time.Second)<br>\t\t\tfmt.Println(i)<br>\t\t}()<br><br>\t\t&#47;&#47;go func(i int) {<br>\t\t&#47;&#47;\tdefer wg.Done()<br>\t\t&#47;&#47;\ttime.Sleep(1 * time.Second)<br>\t\t&#47;&#47;\tfmt.Println(i)<br>\t\t&#47;&#47;}(i)<br>\t}<br><br>\twg.Wait() &#47;&#47; 等待<br><br>\tfmt.Println(&quot;TestGorouting main end&quot;)","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513595,"discussion_content":"你那个 i0 在每次迭代里都是一个新变量啊（i0 := i），都是单独存储的，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610598928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260466,"user_name":"甜质粥","can_delete":false,"product_type":"c1","uid":2153136,"ip_address":"","ucode":"696E929660A124","user_header":"https://static001.geekbang.org/account/avatar/00/20/da/b0/a2425eca.jpg","comment_is_top":false,"comment_ctime":1605015889,"is_pvip":false,"replies":[{"id":"94610","content":"顺序怎样保证呢？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1605063638,"ip_address":"","comment_id":260466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605015889","product_id":100013101,"comment_content":"我觉得应该这样：<br>func main() {<br>\tvar wg sync.WaitGroup<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\twg.Add(1)<br>\t\tgo func(num int) {<br>\t\t\tfmt.Println(num)<br>\t\t\twg.Done()<br>\t\t}(i)<br>\t}<br>\twg.Wait()<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509201,"discussion_content":"顺序怎样保证呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605063638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248429,"user_name":"满怀","can_delete":false,"product_type":"c1","uid":1483113,"ip_address":"","ucode":"EFAC662A37D684","user_header":"https://static001.geekbang.org/account/avatar/00/16/a1/69/0ddda908.jpg","comment_is_top":false,"comment_ctime":1600160112,"is_pvip":false,"replies":[{"id":"91276","content":"你这是完全是串行化了啊，串行化的送出了1-10。与问题和考查要点不符，我觉得可以不得分;-)","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1600230160,"ip_address":"","comment_id":248429,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600160112","product_id":100013101,"comment_content":"通过通道的方法实现了按顺序打印0-9<br>func main() {<br>\tvar ch = make(chan int, 10)<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tch &lt;- i<br>\t}<br>\truntime.GOMAXPROCS(1)<br>\tfor j := 0; j &lt; 10; j++ {<br>\t\tgo func() {<br>\t\t\tvalue := &lt;-ch<br>\t\t\tfmt.Println(value)<br>\t\t}()<br>\t}<br>\ttime.Sleep(time.Second)<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505647,"discussion_content":"你这是完全是串行化了啊，串行化的送出了1-10。与问题和考查要点不符，我觉得可以不得分;-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600230160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240152,"user_name":"小奕","can_delete":false,"product_type":"c1","uid":1171471,"ip_address":"","ucode":"5294DD5895D602","user_header":"https://static001.geekbang.org/account/avatar/00/11/e0/0f/12e08ce9.jpg","comment_is_top":false,"comment_ctime":1596771312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596771312","product_id":100013101,"comment_content":"package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>\tch := make(chan int, 1)<br>\tfor i:=0; i&lt;10; i++ {<br>\t\tgo func() {<br>\t\t\tfmt.Println(i)<br>\t\t\tch &lt;- i<br>\t\t}()<br>\t\t&lt;- ch<br>\t}<br>}","like_count":0},{"had_liked":false,"id":219168,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1589960269,"is_pvip":false,"replies":[{"id":"81062","content":"要说清理工作，也就是释放各种资源，内存、文件系统、网络（如果有的话）。我觉得具体清理了什么，以及顺序是什么无关紧要。细节你可以去看Go语言的源码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1590033674,"ip_address":"","comment_id":219168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589960269","product_id":100013101,"comment_content":"当主goroutine结束时，go会做什么清理工作，清理顺序是怎么样的？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495700,"discussion_content":"要说清理工作，也就是释放各种资源，内存、文件系统、网络（如果有的话）。我觉得具体清理了什么，以及顺序是什么无关紧要。细节你可以去看Go语言的源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590033674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204093,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1586331570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586331570","product_id":100013101,"comment_content":"背后原理懂了，不打印任何数字；打印出7 7 8 8 8 3 8 10 等随机结果都执行出现过","like_count":0},{"had_liked":false,"id":195993,"user_name":"starj","can_delete":false,"product_type":"c1","uid":1108791,"ip_address":"","ucode":"3546E42F1340B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/37/a2f4c9f8.jpg","comment_is_top":false,"comment_ctime":1585228567,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585228567","product_id":100013101,"comment_content":"写了段时间代码，回来再看果然明白很多","like_count":0},{"had_liked":false,"id":191545,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584780132,"is_pvip":false,"replies":[{"id":"73554","content":"像做这种简单的循环的时候，一般都会在里面sleep若干纳秒。不过，Go最新版本应该已经做了这方面的优化。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584870929,"ip_address":"","comment_id":191545,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1584780132","product_id":100013101,"comment_content":"我今天又把10改成100 1000 甚至10000都没见打印！我觉得是因为主goroutine一直在占用cpu以至于我们用go语句启动的goroutine没有机会得到执行，当我们主goroutine执行完以后，虽然释放了cpu但是程序已经结束了，所以也不见任何打印，所以加个等待或者睡眠，让出cpu其他goroutine才会有机会执行！不知道我理解得对不对！","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488200,"discussion_content":"像做这种简单的循环的时候，一般都会在里面sleep若干纳秒。不过，Go最新版本应该已经做了这方面的优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584870929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1959820,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibWRTLrWvazQT5Oc35WZnLeayYYd0TqmaN4u0iciakwjul6UmqEiaQGwSE944TQZicNwpBNSeHtVshJQ/132","nickname":"曹世宏","note":"","ucode":"077D133BF3E760","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261081,"discussion_content":"我用的是go1.13.5，当把for循环10改成100的时候，有时候就会输出数据。改成1000每次都会输出数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588937837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210834,"discussion_content":"或者让出时间片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584780235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191016,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584717698,"is_pvip":false,"replies":[{"id":"73382","content":"当然有可能，所以我们不能在缺省情况下做多个goroutine之间的执行顺序的假设（main函数对应着主goroutine）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584779711,"ip_address":"","comment_id":191016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584717698","product_id":100013101,"comment_content":"<br>package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>  for i := 0; i &lt; 10; i++ {<br>    go func() {<br>      fmt.Println(i)<br>    }()<br>  }<br>}我今天突然想问的是，有没有可能for循环还没执行完goroutine就在执行了？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488102,"discussion_content":"当然有可能，所以我们不能在缺省情况下做多个goroutine之间的执行顺序的假设（main函数对应着主goroutine）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584779711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189622,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584534886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584534886","product_id":100013101,"comment_content":"前面提到<br>这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。<br>后面又说<br>Go 语言并不会去保证这些 goroutine 会以怎样的顺序运行。由于主 goroutine 会与我们手动启用的其他 goroutine 一起接受调度，又因为调度器很可能会在 goroutine 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会。<br>所以就有点迷糊,后面提到的应该是 我们手动启用的goroutine所在的队列和主routine在进行抢占吧,队列中的goroutine是严格按照顺序执行的 除非有代码使得goroutine暂停或者挂起吧<br>之前我就在想go到底是怎么实现高并发的 直到看了今天的课程我才明白<br>主要还是因为我们启用的goroutine不会有系统参与 虽然最终是依靠系统线程在执行的,而且goroutine的创建比较廉价 不影响系统，而且有一种线程池的感觉需要用的时候取出来用 不够了扩容<br>而且go 语句 执行了以后并不会影响当前routine的执行状态,<br>重点是 goroutine的执行可能明显迟于go语句的执行 主要还是提到前面的准备工作(比如先从空闲G队列中找一个可以用的goroutine,没有就直接创建一个goroutine相当于扩容，然后再和M系统线程相挂靠，如果M实在不够用了再申请一个系统线程,如果某个正在执行的goroutine被挂起了，则让出M给其他需要执行的goroutine，而且这些goroutine是按照队列的顺序执行)<br>","like_count":0},{"had_liked":false,"id":188420,"user_name":"给力","can_delete":false,"product_type":"c1","uid":1113645,"ip_address":"","ucode":"646EE4AFC17224","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/2d/2c9177ca.jpg","comment_is_top":false,"comment_ctime":1584352173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584352173","product_id":100013101,"comment_content":"可以用带缓冲的chan来控制并发的数量，同样也可以控制启动的数量","like_count":0},{"had_liked":false,"id":173313,"user_name":"木杉","can_delete":false,"product_type":"c1","uid":1127799,"ip_address":"","ucode":"85651CBDDF7EDC","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/77/95e95b32.jpg","comment_is_top":false,"comment_ctime":1579501700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579501700","product_id":100013101,"comment_content":"加锁 ","like_count":0},{"had_liked":false,"id":166658,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1577537771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577537771","product_id":100013101,"comment_content":"第二遍读，理解得更加深刻了。字字句句将原理解释得清晰到位。","like_count":0},{"had_liked":false,"id":151465,"user_name":"x","can_delete":false,"product_type":"c1","uid":1234454,"ip_address":"","ucode":"AB74494440A008","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/16/43b4814c.jpg","comment_is_top":false,"comment_ctime":1573725695,"is_pvip":false,"replies":[{"id":"58358","content":"sync.WaitGroup 用在这里不是很好。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1573786974,"ip_address":"","comment_id":151465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573725695","product_id":100013101,"comment_content":"sync.WaitGroup来限制goroutine的数量？ 每启动一个ADD一次，执行完再done一次，为了防止主线程的结束可以在循环后加上wait。 ","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474482,"discussion_content":"sync.WaitGroup 用在这里不是很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573786974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146878,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1572685588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572685588","product_id":100013101,"comment_content":"因为goroutine是异步并发执行，所以有可能什么打印不出来，也有可能，打印出的是乱序的0-9","like_count":0},{"had_liked":false,"id":117769,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1564126977,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1564126977","product_id":100013101,"comment_content":"这个题的例子肯定是没有任何显示，因为主线程都结束了，依托这个主线程的一切都灰飞烟灭了，但是要是后边加个定时，那会无序的显示0到9，因为每次for循环会把i的值拷贝到打印参数里。是一个副本不是原来的i","like_count":0,"discussions":[{"author":{"id":1244537,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fd/79/d42c4c68.jpg","nickname":"不成熟的萌","note":"","ucode":"4F5059446D062D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7092,"discussion_content":"这里不是副本。这里的i相当于共享内存。你看它的例子不是传参的。所以是有可能出现全10的。这里应该主要是讲如果不主动干预调度，哪个携程先被执行是无法确定的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567354382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93597,"user_name":"志鑫","can_delete":false,"product_type":"c1","uid":1095392,"ip_address":"","ucode":"408869664EEA13","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/e0/52a07898.jpg","comment_is_top":false,"comment_ctime":1557528141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557528141","product_id":100013101,"comment_content":"个人笔记：通过阻塞通道数组来实现<br><br>package main<br>import &quot;fmt&quot;<br><br>func main() {<br>\tconst n = 10<br>\tchs := [n + 1]chan struct{}{}<br>\tchs[n] = make(chan struct{})<br>\tfor i := 0; i &lt; n; i++ {<br>\t\tchs[i] = make(chan struct{})<br>\t\tgo func(i int) {<br>\t\t\t&lt;-chs[i]<br>\t\t\tfmt.Println(i)<br>\t\t\tchs[i+1] &lt;- struct{}{}<br>\t\t}(i)<br>\t}<br>\tchs[0] &lt;- struct{}{}<br>\t&lt;-chs[n]<br>}","like_count":0},{"had_liked":false,"id":92586,"user_name":"王朝阳","can_delete":false,"product_type":"c1","uid":1326057,"ip_address":"","ucode":"27484160F289EA","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/e9/d05b5434.jpg","comment_is_top":false,"comment_ctime":1557304953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557304953","product_id":100013101,"comment_content":"&#47;&#47;看了评论 感觉这样的代码更有效说明问题<br>package main<br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br>func main() {<br>\tfor i := 0; i &lt; 100; i++ {<br>\t\tgo func(j int) {<br>\t\t\tfmt.Printf(&quot;%d,%d\\n&quot;, i, j)<br>\t\t}(i)<br>\t}<br>        &#47;&#47; 尝试注释掉下边这行代码<br>\ttime.Sleep(time.Second * 2)<br>}<br>","like_count":0},{"had_liked":false,"id":92569,"user_name":"王朝阳","can_delete":false,"product_type":"c1","uid":1326057,"ip_address":"","ucode":"27484160F289EA","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/e9/d05b5434.jpg","comment_is_top":false,"comment_ctime":1557303598,"is_pvip":false,"replies":[{"id":"33118","content":"希望在你看完了这一篇和下一篇之后能明白如此输出的原因。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557325380,"ip_address":"","comment_id":92569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557303598","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func() {<br>\t\t\tfmt.Println(i)<br>\t\t}()<br>\t}<br>\ttime.Sleep(time.Second * 2)<br>}<br><br>运行结果  全部10，偶现4或者5","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449323,"discussion_content":"希望在你看完了这一篇和下一篇之后能明白如此输出的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557325380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69486,"user_name":"Geek_1ed70f","can_delete":false,"product_type":"c1","uid":1394112,"ip_address":"","ucode":"B9A1928A6967B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erNhKGpqicibpQO3tYvl9vwiatvBzn27ut9y5lZ8hPgofPCFC24HX3ko7LW5mNWJficgJncBCGKpGL2jw/132","comment_is_top":false,"comment_ctime":1550755402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550755402","product_id":100013101,"comment_content":"本来想回答   &quot;或许只能无序的打印  2-3个 0-9之间无序 print 时候main函数就结束了,其他的就没机会打印了&quot; ...........大多数情况是 一个机会都拿不到?","like_count":0},{"had_liked":false,"id":64124,"user_name":"超sir","can_delete":false,"product_type":"c1","uid":1306234,"ip_address":"","ucode":"5F8D9E8659D5DE","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/7a/ed5352d2.jpg","comment_is_top":false,"comment_ctime":1548671283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548671283","product_id":100013101,"comment_content":"import (<br>\t&quot;fmt&quot;<br>)<br><br>func main() {<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func() {<br>\t\t\tfmt.Println(i)<br>\t\t}()<br>\t}<br><br>}<br>结果：<br>情景1：<br>1<br>10<br>10<br>10<br>情景2：<br>无输出","like_count":0},{"had_liked":false,"id":64122,"user_name":"超sir","can_delete":false,"product_type":"c1","uid":1306234,"ip_address":"","ucode":"5F8D9E8659D5DE","user_header":"https://static001.geekbang.org/account/avatar/00/13/ee/7a/ed5352d2.jpg","comment_is_top":false,"comment_ctime":1548671169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548671169","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;time&quot;<br>)<br><br>func main() {<br>\tfor i := 0; i &lt; 10; i++ {<br>\t\tgo func(i int) {<br>\t\t\tfmt.Println(i)<br>\t\t}(i)<br>\t}<br>\ttime.Sleep(5*time.Second)<br>}<br>&#47;&#47;结果是：<br>0<br>7<br>6<br>2<br>1<br>3<br>4<br>8<br>9<br>5","like_count":0},{"had_liked":false,"id":62280,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1548000395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548000395","product_id":100013101,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":56706,"user_name":"臣子","can_delete":false,"product_type":"c1","uid":1197737,"ip_address":"","ucode":"88A9924E77C052","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/a9/87da06f7.jpg","comment_is_top":false,"comment_ctime":1546525368,"is_pvip":false,"replies":[{"id":"21286","content":"往后看，这是连续剧","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1547205458,"ip_address":"","comment_id":56706,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546525368","product_id":100013101,"comment_content":"请问如果想让for循环打印i的变量只能通过sleep吗？ 那如果这样的话，我编写业务逻辑还没完成就结束了。岂不是有问题？ ","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435185,"discussion_content":"往后看，这是连续剧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547205458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46021,"user_name":"Dev-L","can_delete":false,"product_type":"c1","uid":1145068,"ip_address":"","ucode":"485E940C3F17B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/78/ec/f7f0d21a.jpg","comment_is_top":false,"comment_ctime":1543834568,"is_pvip":false,"replies":[{"id":"16991","content":"Go里只会传值，取决于传的值本身的特性了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1544185592,"ip_address":"","comment_id":46021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543834568","product_id":100013101,"comment_content":"请问给go 后面的函数传参，参数是什么时候绑定的呢？是函数执行的时候吗？如果是这样，相当于传的i其实不是传值而且传引用了？还请老师解答一下！","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431307,"discussion_content":"Go里只会传值，取决于传的值本身的特性了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544185592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25421,"user_name":"yann [扬] :曹同学","can_delete":false,"product_type":"c1","uid":1199315,"ip_address":"","ucode":"C449253263E796","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/d3/365fe5a1.jpg","comment_is_top":false,"comment_ctime":1537325777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537325777","product_id":100013101,"comment_content":"python的话,会有一个主程序的阻塞过程,并且需要显性导入线程模块,貌似go没有明显表现出类似的特征","like_count":0},{"had_liked":false,"id":24891,"user_name":"笨笨","can_delete":false,"product_type":"c1","uid":1005351,"ip_address":"","ucode":"6DA6DCAF6A7DCB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/27/805786be.jpg","comment_is_top":false,"comment_ctime":1537228006,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1537228006","product_id":100013101,"comment_content":"我理解这里“启用goruntine”指的是同时参与并发的goruntine，限制的手段可以通过配置参数GOMAXPROCESS或者函数调用设置max process来实现。","like_count":0}]}