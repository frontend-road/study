{"id":522342,"title":"35｜DI Container（23）：项目回顾与总结","content":"<p>你好，我是徐昊。今天我们来回顾一下第二个实战项目的整个过程。</p><h2>最终的完成形态</h2><p>首先，让我们来看一下最终的完成形态：</p><p><video poster=\"https://media001.geekbang.org/60cdd231fbab43639433b7417175c4ce/snapshots/49e71671b9674750b164fa0fda6c29e7-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/62068975-18112dc4f01-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/69cf850cd5c14a8a82d3ea2c686e0265/0ced5149f7aa46938ef599f07d224ac9-54ff4117895c7391a73695c33c6e4fd5-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>项目回顾与总结</h2><p>首先是任务分解。在项目刚开始的时候，我们没有构想任何的架构愿景，而是直接采用经典模式，从功能点出发进行TDD开发。一开始进展是很顺利的，从任务列表上看，除了偶有遗落的功能点，基本上是按照任务列表顺畅进行的。</p><p>第一个转折点出现在我们第一次重构之后，我们将InjectionProvider从ContextConfig中分离了出来。并将依赖的检查从运行期检查，变成了在ContextConfig.getContext时预先检查。</p><p>也就是说，我们的<strong>架构愿景</strong>在此时发生了改变：只要Context能够被构建出来，其中就不存在无效组件和无效的组件关系（循环依赖、依赖缺失）。</p><p>这个架构愿景改变的直接影响，就是让我们<strong>分解任务的方式</strong>发生了变化。体现在任务列表上为：</p><ul>\n<li>\n<p>方法注入（改变前）</p>\n<ul>\n<li>通过Inject标注的方法，其参数为依赖组件</li>\n<li>通过Inject标注的无参数方法，会被调用</li>\n<li>按照子类中的规则，覆盖父类中的Inject方法</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>方法注入（改变后）</p>\n<ul>\n<li>通过Inject标注的方法，其参数为依赖组件</li>\n<li>通过Inject标注的无参数方法，会被调用</li>\n<li>按照子类中的规则，覆盖父类中的Inject方法</li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li>依赖中应包含Inject Method声明的依赖</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><p>也就是说，在这一刻，除了功能点之外，我们出现了两个功能上下文：ComponentProvider和ContextConfig。很自然地，连带着分解任务的方式也发生了改变。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/20/c3520c517b3c890b717601ca4bee3520.jpg?wh=8000x4500\" alt=\"\"></p><p>同时，我们的项目还发生过两次重大的<strong>模型调整</strong>：</p><ul>\n<li>第一次是在引入Provider接口的时候。也就是除了能够直接对组件依赖外，还可以通过Provider<t>获取组件的工厂。</t></li>\n<li>第二次则是在引入Qualifier的时候。</li>\n</ul><p>第一次模型调整的时候，我们发现之前都以Class&lt;?&gt;作为获取组件的标识。而当引入Provider之后，我们就需要通过Type作为获取组件的标识。我们修改了ComponentProvider的接口体现了这种变化：</p><pre><code>引入Provider之前：\n\n    public interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        \n        default List&lt;Class&lt;?&gt;&gt; getDependencies() {\n            return List.of();\n        }\n    }\n\n引入Provider之后：\n\n    public interface ComponentProvider&lt;T&gt; {\n        T get(Context context);\n        \n        default List&lt;Type&gt; getDependencies() {\n            return List.of();\n        }\n    }\n</code></pre><p>第二次<strong>模型调整</strong>的时候，我们需要将Type和Qualifier标注组合在一起。于是我们引入了ComponentRef（最开始叫Ref）对象，作为获取组件的标识。我们再次修改了ComponentProvider的接口：</p><pre><code>public interface ComponentProvider&lt;T&gt; {\n    T get(Context context);\n    \n    default List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return List.of();\n    }\n}\n</code></pre><p><strong>模型调整</strong>之后，Context中的组件就从实例组件（Instance）和注入组件（Injectable Component），变成实例组件、注入组件、带Qualifier的实例组件、带Qualifier的注入组件以及它们对应的Provider形式<strong>等八种</strong>。</p><p>这也进一步帮助我们理解了软件的需求，帮助我们进一步有效率地分解了任务。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/9f/3d0dd1fa1f6f235011f8cba22cce739f.jpg?wh=8000x4500\" alt=\"\"></p><p>带来的结果是，任务列表发生了更为剧烈的改变：</p><ul>\n<li>\n<p>自定义Qualifier的依赖（最开始的任务）</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖（实际完成的任务）</p>\n<ul>\n<li>\n<p>注册组件时，可额外指定Qualifier</p>\n<ul>\n<li>针对instance指定一个Qualifieri（新增任务）</li>\n<li>针对组件指定一个Qualiifer（新增任务）</li>\n<li>针对instance指定多个Qualifieri（新增任务）</li>\n<li>针对组件指定多个Qualiifer（新增任务）</li>\n</ul>\n</li>\n<li>\n<p>注册组件时，如果不是合法的Qualifier，则不接受组件注册（新增任务）</p>\n</li>\n<li>\n<p>寻找依赖时，需同时满足类型与自定义Qualifier标注</p>\n<ul>\n<li>\n<p>在检查依赖时使用Qualifier（新增任务）</p>\n</li>\n<li>\n<p>在检查循环依赖时使用Qualifier（新增任务）</p>\n</li>\n<li>\n<p>构造函数注入可以使用Qualifier声明依赖（新增任务）</p>\n<ul>\n<li>依赖中包含Qualifier（新增任务）</li>\n<li>如果不是合法的Qualifier，则组件非法</li>\n</ul>\n</li>\n<li>\n<p>字段注入可以使用Qualifier声明依赖（新增任务）</p>\n<ul>\n<li>依赖中包含Qualifier（新增任务）</li>\n<li>如果不是合法的Qualifier，则组件非法</li>\n</ul>\n</li>\n<li>\n<p>函数注入可以使用Qualifier声明依赖（新增任务）</p>\n<ul>\n<li>依赖中包含Qualifier（新增任务）</li>\n<li>如果不是合法的Qualifier，则组件非法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>支持默认Qualifier——Named（不需要）</p>\n</li>\n<li>\n<p>注册组件时，可从类对象上提取Qualifier（不需要）</p>\n</li>\n</ul>\n</li>\n</ul><p>我们通过<strong>重组测试</strong>，从结构上梳理并记录了这些改变。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/9c/e09ce21672d1639fec4c51b11fb11a9c.jpeg?wh=1920x1080\" alt=\"\"></p><p>这种对于核心模型的调整是<strong>痛苦的</strong>，在很多情况下，意味着软件需要重写。我们展示了如何通过<strong>重构</strong>来完成这种改写，所以请<strong>重点回看</strong>与重构有关的章节，<strong>反思</strong>我们是如何做到的。</p><p>最后，我的代码是这样的：</p><pre><code>ComponentProvider.java\n\npackage geektime.tdd.di;\nimport java.util.List;\npublic interface ComponentProvider&lt;T&gt; {\n    T get(Context context);\n    default List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return List.of();\n    }\n}\n\nComponentRef.java\n\npackage geektime.tdd.di;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Objects;\npublic class ComponentRef&lt;ComponentType&gt; {\n    public static &lt;ComponentType&gt; ComponentRef&lt;ComponentType&gt; of(Class&lt;ComponentType&gt; component) {\n        return new ComponentRef&lt;&gt;(component, null);\n    }\n    public static &lt;ComponentType&gt; ComponentRef&lt;ComponentType&gt; of(Class&lt;ComponentType&gt; component, Annotation qualifier) {\n        return new ComponentRef&lt;&gt;(component, qualifier);\n    }\n    public static ComponentRef&lt;?&gt; of(Type type, Annotation qualifier) {\n        return new ComponentRef&lt;&gt;(type, qualifier);\n    }\n    private Type container;\n    private ContextConfig.Component component;\n    ComponentRef(Type type, Annotation qualifier) {\n        init(type, qualifier);\n    }\n    protected ComponentRef() {\n        this(null);\n    }\n    protected ComponentRef(Annotation qualifier) {\n        Type type = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n        init(type, qualifier);\n    }\n    private void init(Type type, Annotation qualifier) {\n        if (type instanceof ParameterizedType container) {\n            this.container = container.getRawType();\n            this.component = new ContextConfig.Component((Class&lt;ComponentType&gt;) container.getActualTypeArguments()[0], qualifier);\n        } else\n            this.component = new ContextConfig.Component((Class&lt;ComponentType&gt;) type, qualifier);\n    }\n    public Type getContainer() {\n        return container;\n    }\n    public boolean isContainer() {\n        return container != null;\n    }\n    ContextConfig.Component component() {\n        return component;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ComponentRef&lt;?&gt; that = (ComponentRef&lt;?&gt;) o;\n        return Objects.equals(container, that.container) &amp;&amp; component.equals(that.component);\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(container, component);\n    }\n}\n    \nConfig.java\n \npackage geektime.tdd.di;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\npublic interface Config {\n    @Documented\n    @Retention(RUNTIME)\n    @Target({ElementType.FIELD})\n    @interface Export {\n        Class&lt;?&gt; value();\n    }\n}\n    \nContext.java\n    \npackage geektime.tdd.di;\nimport java.util.Optional;\npublic interface Context {\n    &lt;ComponentType&gt; Optional&lt;ComponentType&gt; get(ComponentRef&lt;ComponentType&gt; ref);\n}\n    \nContextConfig.java\n    \npackage geektime.tdd.di;\nimport geektime.tdd.di.ContextConfig.Component;\nimport jakarta.inject.Provider;\nimport jakarta.inject.Qualifier;\nimport jakarta.inject.Scope;\nimport jakarta.inject.Singleton;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.text.MessageFormat;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\nimport static geektime.tdd.di.ContextConfigError.circularDependencies;\nimport static geektime.tdd.di.ContextConfigError.unsatisfiedResolution;\nimport static geektime.tdd.di.ContextConfigException.illegalAnnotation;\nimport static java.util.Arrays.spliterator;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.*;\npublic class ContextConfig {\n    private final Map&lt;Component, ComponentProvider&lt;?&gt;&gt; components = new HashMap&lt;&gt;();\n    private final Map&lt;Class&lt;?&gt;, ScopeProvider&gt; scopes = new HashMap&lt;&gt;();\n    public ContextConfig() {\n        scope(Singleton.class, SingletonProvider::new);\n    }\n    public &lt;Type&gt; void instance(Class&lt;Type&gt; type, Type instance) {\n        bind(new Component(type, null), context -&gt; instance);\n    }\n    public &lt;Type&gt; void instance(Class&lt;Type&gt; type, Type instance, Annotation... annotations) {\n        bindInstance(type, instance, annotations);\n    }\n    public &lt;Type, Implementation extends Type&gt;\n    void component(Class&lt;Type&gt; type, Class&lt;Implementation&gt; implementation, Annotation... annotations) {\n        bindComponent(type, implementation, annotations);\n    }\n    public &lt;ScopeType extends Annotation&gt; void scope(Class&lt;ScopeType&gt; scope, ScopeProvider provider) {\n        scopes.put(scope, provider);\n    }\n    public void from(Config config) {\n        new DSL(config).bind();\n    }\n    public Context getContext() {\n        components.keySet().forEach(component -&gt; checkDependencies(component, new Stack&lt;&gt;()));\n        HashMap&lt;Component, ComponentProvider&lt;?&gt;&gt; context = new HashMap&lt;&gt;(components);\n        return new Context() {\n            @Override\n            public &lt;ComponentType&gt; Optional&lt;ComponentType&gt; get(ComponentRef&lt;ComponentType&gt; ref) {\n                if (ref.isContainer()) {\n                    if (ref.getContainer() != Provider.class) return Optional.empty();\n                    return (Optional&lt;ComponentType&gt;) Optional.ofNullable(getProvider(ref))\n                            .map(provider -&gt; (Provider&lt;Object&gt;) () -&gt; provider.get(this));\n                }\n                return Optional.ofNullable(getProvider(ref)).map(provider -&gt; (ComponentType) provider.get(this));\n            }\n            private &lt;ComponentType&gt; ComponentProvider&lt;?&gt; getProvider(ComponentRef&lt;ComponentType&gt; ref) {\n                return context.get(ref.component());\n            }\n        };\n    }\n    private void bindComponent(Class&lt;?&gt; type, Class&lt;?&gt; implementation, Annotation... annotations) {\n        Bindings bindings = Bindings.component(implementation, annotations);\n        bind(type, bindings.qualifiers(), provider(implementation, bindings.scope()));\n    }\n    private void bindInstance(Class&lt;?&gt; type, Object instance, Annotation[] annotations) {\n        bind(type, Bindings.instance(type, annotations).qualifiers(), context -&gt; instance);\n    }\n    private &lt;Type&gt; void bind(Class&lt;Type&gt; type, List&lt;Annotation&gt; qualifiers, ComponentProvider&lt;?&gt; provider) {\n        if (qualifiers.isEmpty()) bind(new Component(type, null), provider);\n        for (Annotation qualifier : qualifiers)\n            bind(new Component(type, qualifier), provider);\n    }\n    private void bind(Component component, ComponentProvider&lt;?&gt; provider) {\n        if (components.containsKey(component)) throw ContextConfigException.duplicated(component);\n        components.put(component, provider);\n    }\n    private &lt;Type&gt; ComponentProvider&lt;?&gt; provider(Class&lt;Type&gt; implementation, Optional&lt;Annotation&gt; scope) {\n        ComponentProvider&lt;?&gt; injectionProvider = new InjectionProvider&lt;&gt;(implementation);\n        return scope.&lt;ComponentProvider&lt;?&gt;&gt;map(s -&gt; scoped(s, injectionProvider)).orElse(injectionProvider);\n    }\n    private ComponentProvider&lt;?&gt; scoped(Annotation scope, ComponentProvider&lt;?&gt; provider) {\n        if (!scopes.containsKey(scope.annotationType()))\n            throw ContextConfigException.unknownScope(scope.annotationType());\n        return scopes.get(scope.annotationType()).create(provider);\n    }\n    private void checkDependencies(Component component, Stack&lt;Component&gt; visiting) {\n        for (ComponentRef&lt;?&gt; dependency : components.get(component).getDependencies()) {\n            if (!components.containsKey(dependency.component()))\n                throw unsatisfiedResolution(component, dependency.component());\n            if (!dependency.isContainer()) {\n                if (visiting.contains(dependency.component()))\n                    throw circularDependencies(visiting, dependency.component());\n                visiting.push(dependency.component());\n                checkDependencies(dependency.component(), visiting);\n                visiting.pop();\n            }\n        }\n    }\n    record Component(Class&lt;?&gt; type, Annotation qualifier) {\n    }\n    static class Bindings {\n        public static Bindings component(Class&lt;?&gt; component, Annotation... annotations) {\n            return new Bindings(component, annotations, Qualifier.class, Scope.class);\n        }\n        public static Bindings instance(Class&lt;?&gt; instance, Annotation... annotations) {\n            return new Bindings(instance, annotations, Qualifier.class);\n        }\n        Class&lt;?&gt; type;\n        Map&lt;Class&lt;?&gt;, List&lt;Annotation&gt;&gt; group;\n        public Bindings(Class&lt;?&gt; type, Annotation[] annotations, Class&lt;? extends Annotation&gt;... allowed) {\n            this.type = type;\n            this.group = parse(type, annotations, allowed);\n        }\n        private static Map&lt;Class&lt;?&gt;, List&lt;Annotation&gt;&gt; parse(Class&lt;?&gt; type, Annotation[] annotations, Class&lt;? extends Annotation&gt;... allowed) {\n            Map&lt;Class&lt;?&gt;, List&lt;Annotation&gt;&gt; annotationGroups = stream(annotations).collect(groupingBy(allow(allowed), toList()));\n            if (annotationGroups.containsKey(Illegal.class))\n                throw illegalAnnotation(type, annotationGroups.get(Illegal.class));\n            return annotationGroups;\n        }\n        private static Function&lt;Annotation, Class&lt;?&gt;&gt; allow(Class&lt;? extends Annotation&gt;... annotations) {\n            return annotation -&gt; Stream.of(annotations).filter(annotation.annotationType()::isAnnotationPresent)\n                    .findFirst().orElse(Illegal.class);\n        }\n        private @interface Illegal {\n        }\n        Optional&lt;Annotation&gt; scope() {\n            List&lt;Annotation&gt; scopes = group.getOrDefault(Scope.class, from(type, Scope.class));\n            if (scopes.size() &gt; 1) throw illegalAnnotation(type, scopes);\n            return scopes.stream().findFirst();\n        }\n        List&lt;Annotation&gt; qualifiers() {\n            return group.getOrDefault(Qualifier.class, List.of());\n        }\n        private static List&lt;Annotation&gt; from(Class&lt;?&gt; implementation, Class&lt;? extends Annotation&gt; annotation) {\n            return stream(implementation.getAnnotations()).filter(a -&gt; a.annotationType().isAnnotationPresent(annotation)).toList();\n        }\n    }\n    class DSL {\n        private Config config;\n        public DSL(Config config) {\n            this.config = config;\n        }\n        void bind() {\n            for (Declaration declaration : declarations())\n                declaration.value().ifPresentOrElse(declaration::bindInstance, declaration::bindComponent);\n        }\n        private List&lt;Declaration&gt; declarations() {\n            return stream(config.getClass().getDeclaredFields()).filter(f -&gt; !f.isSynthetic()).map(Declaration::new).toList();\n        }\n        class Declaration {\n            private Field field;\n            Declaration(Field field) {\n                this.field = field;\n            }\n            void bindInstance(Object instance) {\n                ContextConfig.this.bindInstance(type(), instance, annotations());\n            }\n            void bindComponent() {\n                ContextConfig.this.bindComponent(type(), field.getType(), annotations());\n            }\n            private Optional&lt;Object&gt; value() {\n                try {\n                    return Optional.ofNullable(field.get(config));\n                } catch (IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            private Class&lt;?&gt; type() {\n                Config.Export export = field.getAnnotation(Config.Export.class);\n                return export != null ? export.value() : field.getType();\n            }\n            private Annotation[] annotations() {\n                return stream(field.getAnnotations()).filter(a -&gt; a.annotationType() != Config.Export.class).toArray(Annotation[]::new);\n            }\n        }\n    }\n}\n    \nclass ContextConfigError extends Error {\n    public static ContextConfigError unsatisfiedResolution(Component component, Component dependency) {\n        return new ContextConfigError(MessageFormat.format(&quot;Unsatisfied resolution: {1} for {0} &quot;, component, dependency));\n    }\n    public static ContextConfigError circularDependencies(Collection&lt;Component&gt; path, Component circular) {\n        return new ContextConfigError(MessageFormat.format(&quot;Circular dependencies: {0} -&gt; [{1}]&quot;,\n                path.stream().map(Objects::toString).collect(joining(&quot; -&gt; &quot;)), circular));\n    }\n    ContextConfigError(String message) {\n        super(message);\n    }\n}\nclass ContextConfigException extends RuntimeException {\n    static ContextConfigException illegalAnnotation(Class&lt;?&gt; type, List&lt;Annotation&gt; annotations) {\n        return new ContextConfigException(MessageFormat.format(&quot;Unqualified annotations: {0} of {1}&quot;,\n                String.join(&quot; , &quot;, annotations.stream().map(Object::toString).toList()), type));\n    }\n    static ContextConfigException unknownScope(Class&lt;? extends Annotation&gt; annotationType) {\n        return new ContextConfigException(MessageFormat.format(&quot;Unknown scope: {0}&quot;, annotationType));\n    }\n    static ContextConfigException duplicated(Component component) {\n        return new ContextConfigException(MessageFormat.format(&quot;Duplicated: {0}&quot;, component));\n    }\n    ContextConfigException(String message) {\n        super(message);\n    }\n}\n    \nInjectionProvider.java\n    \npackage geektime.tdd.di;\nimport jakarta.inject.Inject;\nimport jakarta.inject.Qualifier;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.*;\nimport java.text.MessageFormat;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport static geektime.tdd.di.ComponentError.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Stream.concat;\nclass InjectionProvider&lt;T&gt; implements ComponentProvider&lt;T&gt; {\n    private final Injectable&lt;Constructor&lt;T&gt;&gt; injectConstructor;\n    private final Map&lt;Class&lt;?&gt;, List&lt;Injectable&lt;Method&gt;&gt;&gt; injectMethods;\n    private final Map&lt;Class&lt;?&gt;, List&lt;Injectable&lt;Field&gt;&gt;&gt; injectFields;\n    private final Collection&lt;Class&lt;?&gt;&gt; superClasses;\n    private final List&lt;ComponentRef&lt;?&gt;&gt; dependencies;\n    public InjectionProvider(Class&lt;T&gt; component) {\n        this.injectConstructor = getInjectConstructor(component);\n        this.superClasses = allSuperClass(component);\n        var injectFields = getInjectFields(component);\n        var injectMethods = getInjectMethods(component);\n        this.dependencies = concat(concat(Stream.of(injectConstructor), injectFields.stream()), injectMethods.stream())\n                .map(Injectable::required).flatMap(Arrays::stream).toList();\n        this.injectFields = groupByClass(injectFields);\n        this.injectMethods = groupByClass(injectMethods);\n    }\n    @Override\n    public T get(Context context) {\n        try {\n            T instance = injectConstructor.element().newInstance(injectConstructor.toDependencies(context));\n            for (Class&lt;?&gt; c : superClasses) {\n                for (Injectable&lt;Field&gt; field : injectFields.getOrDefault(c, List.of()))\n                    field.element().set(instance, field.toDependencies(context)[0]);\n                for (Injectable&lt;Method&gt; method : injectMethods.getOrDefault(c, List.of()))\n                    method.element().invoke(instance, method.toDependencies(context));\n            }\n            return instance;\n        } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    @Override\n    public List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return dependencies;\n    }\n    record Injectable&lt;Element extends AccessibleObject&gt;(Element element, ComponentRef&lt;?&gt;[] required) {\n        Object[] toDependencies(Context context) {\n            return stream(required).map(context::get).map(Optional::get).toArray();\n        }\n        static &lt;Element extends Executable&gt; Injectable&lt;Element&gt; of(Element element) {\n            element.setAccessible(true);\n            return new Injectable&lt;&gt;(element, stream(element.getParameters()).map(Injectable::toComponentRef).toArray(ComponentRef&lt;?&gt;[]::new));\n        }\n        static Injectable&lt;Field&gt; of(Field field) {\n            field.setAccessible(true);\n            return new Injectable&lt;&gt;(field, new ComponentRef&lt;?&gt;[]{toComponentRef(field)});\n        }\n        private static ComponentRef&lt;?&gt; toComponentRef(Field field) {\n            return ComponentRef.of(field.getGenericType(), getQualifier(field));\n        }\n        private static ComponentRef&lt;?&gt; toComponentRef(Parameter parameter) {\n            return ComponentRef.of(parameter.getParameterizedType(), getQualifier(parameter));\n        }\n        private static Annotation getQualifier(AnnotatedElement element) {\n            List&lt;Annotation&gt; qualifiers = stream(element.getAnnotations())\n                    .filter(a -&gt; a.annotationType().isAnnotationPresent(Qualifier.class)).toList();\n            if (qualifiers.size() &gt; 1) throw ComponentError.ambiguousQualifiers(element, qualifiers);\n            return qualifiers.stream().findFirst().orElse(null);\n        }\n    }\n    private static &lt;T&gt; List&lt;Injectable&lt;Method&gt;&gt; getInjectMethods(Class&lt;T&gt; component) {\n        List&lt;Method&gt; injectMethods = traverse(component, (methods, current) -&gt; injectable(current.getDeclaredMethods())\n                .filter(m -&gt; isOverrideByInjectMethod(methods, m))\n                .filter(m -&gt; isOverrideByNoInjectMethod(component, m)).toList());\n        List&lt;Injectable&lt;Method&gt;&gt; injectableMethods = injectMethods.stream().map(Injectable::of).toList();\n        return check(component, injectableMethods, InjectionProvider::noTypeParameter, ComponentError::injectMethodsWithTypeParameter);\n    }\n    private static &lt;T&gt; List&lt;Injectable&lt;Field&gt;&gt; getInjectFields(Class&lt;T&gt; component) {\n        List&lt;Injectable&lt;Field&gt;&gt; injectableFields = InjectionProvider.&lt;Field&gt;traverse(component, (fields, current) -&gt; injectable(current.getDeclaredFields()).toList())\n                .stream().map(Injectable::of).toList();\n        return check(component, injectableFields, InjectionProvider::notFinal, ComponentError::finalInjectFields);\n    }\n    private static &lt;Type&gt; Injectable&lt;Constructor&lt;Type&gt;&gt; getInjectConstructor(Class&lt;Type&gt; implementation) {\n        if (Modifier.isAbstract(implementation.getModifiers())) throw abstractComponent(implementation);\n        List&lt;Constructor&lt;?&gt;&gt; injectConstructors = injectable(implementation.getDeclaredConstructors()).toList();\n        if (injectConstructors.size() &gt; 1) throw ambiguousInjectableConstructors(implementation);\n        return Injectable.of((Constructor&lt;Type&gt;) injectConstructors.stream().findFirst().orElseGet(() -&gt; defaultConstructor(implementation)));\n    }\n    private static &lt;Type&gt; Constructor&lt;Type&gt; defaultConstructor(Class&lt;Type&gt; implementation) {\n        try {\n            return implementation.getDeclaredConstructor();\n        } catch (NoSuchMethodException e) {\n            throw noDefaultConstructor(implementation);\n        }\n    }\n    private static &lt;E extends AccessibleObject&gt; Map&lt;Class&lt;?&gt;, List&lt;Injectable&lt;E&gt;&gt;&gt; groupByClass(List&lt;Injectable&lt;E&gt;&gt; injectFields) {\n        return injectFields.stream().collect(Collectors.groupingBy(i -&gt; ((Member)i.element()).getDeclaringClass(), Collectors.toList()));\n    }\n    private static Collection&lt;Class&lt;?&gt;&gt; allSuperClass(Class&lt;?&gt; component) {\n        List&lt;Class&lt;?&gt;&gt; result = new ArrayList&lt;&gt;();\n        for (Class superClass = component;\n             superClass != Object.class;\n             superClass = superClass.getSuperclass())\n            result.add(0, superClass);\n        return result;\n    }\n    private static &lt;T&gt; List&lt;T&gt; traverse(Class&lt;?&gt; component, BiFunction&lt;List&lt;T&gt;, Class&lt;?&gt;, List&lt;T&gt;&gt; finder) {\n        List&lt;T&gt; members = new ArrayList&lt;&gt;();\n        Class&lt;?&gt; current = component;\n        while (current != Object.class) {\n            members.addAll(finder.apply(members, current));\n            current = current.getSuperclass();\n        }\n        return members;\n    }\n    private static &lt;T extends AnnotatedElement&gt; Stream&lt;T&gt; injectable(T[] declaredFields) {\n        return stream(declaredFields).filter(f -&gt; f.isAnnotationPresent(Inject.class));\n    }\n    private static boolean isOverride(Method m, Method o) {\n        boolean visible;\n        if (m.getDeclaringClass().getPackageName().equals(o.getDeclaringClass().getPackageName()))\n            visible = !Modifier.isPrivate(o.getModifiers()) &amp;&amp; !Modifier.isPrivate(m.getModifiers());\n        else visible = (Modifier.isPublic(o.getModifiers()) || Modifier.isProtected(o.getModifiers()))\n                &amp;&amp; (Modifier.isPublic(m.getModifiers()) || Modifier.isProtected(m.getModifiers()));\n        return visible &amp;&amp; o.getName().equals(m.getName()) &amp;&amp; Arrays.equals(o.getParameterTypes(), m.getParameterTypes());\n    }\n    private static &lt;T&gt; boolean isOverrideByNoInjectMethod(Class&lt;T&gt; component, Method m) {\n        return stream(component.getDeclaredMethods()).filter(m1 -&gt; !m1.isAnnotationPresent(Inject.class)).noneMatch(o -&gt; isOverride(m, o));\n    }\n    private static boolean isOverrideByInjectMethod(List&lt;Method&gt; injectMethods, Method m) {\n        return injectMethods.stream().noneMatch(o -&gt; isOverride(m, o));\n    }\n    private static &lt;Element extends AccessibleObject&gt; List&lt;Injectable&lt;Element&gt;&gt; check(Class&lt;?&gt; component, List&lt;Injectable&lt;Element&gt;&gt; target, Predicate&lt;Element&gt; predicate,\n                                                                                      BiFunction&lt;Class&lt;?&gt;, List&lt;Element&gt;, ComponentError&gt; error) {\n        List&lt;Element&gt; found = target.stream().map(Injectable::element).filter(predicate).toList();\n        if (found.size() &gt; 0) throw error.apply(component, found.stream().toList());\n        return target;\n    }\n    private static boolean notFinal(Field field) {\n        return Modifier.isFinal(field.getModifiers());\n    }\n    private static boolean noTypeParameter(Method method) {\n        return method.getTypeParameters().length != 0;\n    }\n}\nclass ComponentError extends Error {\n    public static ComponentError abstractComponent(Class&lt;?&gt; component) {\n        return new ComponentError(MessageFormat.format(&quot;Can not be abstract: {0}&quot;, component));\n    }\n    public static ComponentError finalInjectFields(Class&lt;?&gt; component, Collection&lt;Field&gt; fields) {\n        return new ComponentError(MessageFormat.format(&quot;Injectable field can not be final: {0} in {1}&quot;,\n                String.join(&quot; , &quot;, fields.stream().map(Field::getName).toList()), component));\n    }\n    public static ComponentError injectMethodsWithTypeParameter(Class&lt;?&gt; component, Collection&lt;Method&gt; fields) {\n        return new ComponentError(MessageFormat.format(&quot;Injectable method can not have type parameter: {0} in {1}&quot;,\n                String.join(&quot; , &quot;, fields.stream().map(Method::getName).toList()), component));\n    }\n    public static ComponentError ambiguousInjectableConstructors(Class&lt;?&gt; component) {\n        return new ComponentError(MessageFormat.format(&quot;Ambiguous injectable constructors: {0}&quot;, component));\n    }\n    public static ComponentError noDefaultConstructor(Class&lt;?&gt; component) {\n        return new ComponentError(MessageFormat.format(&quot;No default constructors: {0}&quot;, component));\n    }\n    public static ComponentError ambiguousQualifiers(AnnotatedElement element, List&lt;Annotation&gt; qualifiers) {\n        Class&lt;?&gt; component;\n        if (element instanceof Parameter p) component = p.getDeclaringExecutable().getDeclaringClass();\n        else component = ((Field) element).getDeclaringClass();\n        return new ComponentError(MessageFormat.format(&quot;Ambiguous qualifiers: {0} on {1} of {2}&quot;,\n                String.join(&quot; , &quot;, qualifiers.stream().map(Object::toString).toList()), element, component));\n    }\n    ComponentError(String message) {\n        super(message);\n    }\n}\n    \nScopeProvider.java\n    \npackage geektime.tdd.di;\npublic interface ScopeProvider {\n    ComponentProvider&lt;?&gt; create(ComponentProvider&lt;?&gt; provider);\n}\n   \nSingletonProvider.java\n    \npackage geektime.tdd.di;\nimport java.util.List;\nclass SingletonProvider&lt;T&gt; implements ComponentProvider&lt;T&gt; {\n    private T singleton;\n    private ComponentProvider&lt;T&gt; provider;\n    public SingletonProvider(ComponentProvider&lt;T&gt; provider) {\n        this.provider = provider;\n    }\n    @Override\n    public T get(Context context) {\n        if (singleton == null) singleton = provider.get(context);\n        return singleton;\n    }\n    @Override\n    public List&lt;ComponentRef&lt;?&gt;&gt; getDependencies() {\n        return provider.getDependencies();\n    }\n}\n</code></pre><h2>思考题</h2><p>在进入下节课之前，希望你能认真思考如下两个问题。</p><ol>\n<li>请增加static注入，并通过Jakarta Inject TCK。</li>\n<li>请回顾整个项目实践，看看跟最开始学习TDD相比，都有哪些进步和改变。</li>\n</ol><p>与我们实际工作中的项目相比，DI Container这个框架级实战的复杂度要略微高一些。经过这三个月的学习，除了提升你的技术能力外，相信对你的学习能力也有不小的磨练。所以，坚持到这一站的同学们，请为自己点个赞吧！</p>","neighbors":{"left":{"article_title":"34｜DI Container（22）：如何对Bind的逻辑进行重构？","id":521323},"right":{"article_title":"36｜实战中的TDD：RESTful Web Services","id":522343}},"comments":[{"had_liked":false,"id":348200,"user_name":"枫中的刀剑","can_delete":false,"product_type":"c1","uid":1322387,"ip_address":"","ucode":"4B086F538184AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/93/0f1cbf44.jpg","comment_is_top":false,"comment_ctime":1654843151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654843151","product_id":100109401,"comment_content":"第一次静距离观察一个完整项目的TDD过程，感受还是挺深的。特别是第一次接触到测试重组、测试文档化的时候有种眼前一亮的感觉。而其中ComponentRef 模型和 Qualifier 模型调整的重构过程更加让人赏心悦目。新的模型引入拓展了知识，带来个更加明确的功能上下文划分。而原有整体的结构却没有发生太多的变化。这种一点点进步是能够很清楚的感受到的。<br><br>最后在附上项目链接：https:&#47;&#47;github.com&#47;maplestoryJin&#47;DiContainer  <br>包括 static 注入实现。","like_count":0},{"had_liked":false,"id":347875,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1654528963,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1654528963","product_id":100109401,"comment_content":"有个关于bind的实现问题，一般情况都是bind(Component.class, Instance.class)或者bind(Component.class, Provider&lt;Instance.class&gt;)。如果直接bind(Instance.class, Instance.class)，那么get(Component.class)还能找到吗？<br>另外，无论bind的是Intance还是Provider，当需要注入Provider类型的时候，是都需要支持吗？<br>这些规范的东西我可以去哪里找到，希望老师能解答一下。","like_count":0},{"had_liked":false,"id":347710,"user_name":"张铁林","can_delete":false,"product_type":"c1","uid":1108258,"ip_address":"","ucode":"4AB8BC6CDAC0A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/22/7606c6ba.jpg","comment_is_top":false,"comment_ctime":1654334362,"is_pvip":false,"replies":[{"id":"127875","content":"开阔了眼界，很不错👍","user_name":"编辑回复","user_name_real":"编辑","uid":"2189689","ctime":1658043074,"ip_address":"","comment_id":347710,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1654334362","product_id":100109401,"comment_content":"主要还是开阔了眼界，用TDD来做一个相对复杂的功能，不像很多kata那样，短短几十行代码量，体会不到不断的重构和深进。","like_count":0,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"🐑","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580252,"discussion_content":"开阔了眼界，很不错👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658043074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347588,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1654176164,"is_pvip":false,"replies":[{"id":"126711","content":"我再给你点个赞！坚持到这里不容易！继续嘎油～","user_name":"编辑回复","user_name_real":"编辑","uid":"2189689","ctime":1654182283,"ip_address":"","comment_id":347588,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1654176164","product_id":100109401,"comment_content":"这次要求中最容易做到的就是为自己点个赞，我已经点了！<br>最开始学习 TDD 相比：学会使用 @Nested 标签；学会了泛型中 ?、T 之类的含义；有测试做保障想重构就重构","like_count":0,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"🐑","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574622,"discussion_content":"我再给你点个赞！坚持到这里不容易！继续嘎油～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654182283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]}]}