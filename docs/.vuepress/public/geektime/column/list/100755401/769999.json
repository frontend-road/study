{"id":769999,"title":"22｜通过测试工序提高LLM代码质量","content":"<p>你好，我是徐昊，今天我们来继续学习AI时代的软件工程。</p><p>上节课，我们讲解了如何将架构模式转化为测试工序，以及工序在架构落地过程中发挥的作用。测试工序有助于将抽象的架构设计转化为具体的开发任务和实际的工作流程，帮助团队有效地实现架构设计，并最终产生质量高、可靠性强的软件系统。</p><p>同样，通过测试工序，我们也可以让LLM帮助我们有效地实现架构设计，并提高LLM生成代码的质量。这节课我们就讨论一下如何实现这个目标。</p><h2>将工序转化为提示词模版</h2><p>首先，我们需要将测试工序转化为CoT（Chain of Thought），通过CoT指导LLM按照测试工序的要求，将给定的需求功能拆分成对应的任务列表。</p><p>这里我们使用的测试工序仍然是前面提到的那一个：</p><p><img src=\"https://static001.geekbang.org/resource/image/26/ee/26e48c8fc6ca29b39eb57366dbb42fee.jpg?wh=1833x932\" alt=\"\"></p><p>我们将架构组件中的三种不同的组件分别进行测试，其中Persistent层中的组件，使用假对象（Fake，内存数据库）作为测试替身。而HTTP interface和Application Logic层则通过存根（Stub）作为测试替身。最后，再通过功能测试，对整个系统进行验证。</p><p>那么让我们来构造CoT的提示词模板：</p><pre><code class=\"language-plain\">架构描述\n=======\n当前系统技术栈为Spring Boot，Jersey和MyBatis。\n\n当前系统采用典型的三层架构设计，分别为:\n- HTTP interface层，负责提供RESTful API，命名规则为XXXAPI，比如OrdersAPI；\n  - API通过JAX-RS的Resource实现；\n  - HTTP interface层调用Application Logic层的Service，完成功能；\n- Application Logic层，负责提供核心逻辑，命名规则为XXXService，比如OrderService；\n  - 使用Java实现，Service使用POJO为主的领域对象；\n  - Application Logic层调用Persistent层的DAO完成对于数据的访问；\n- Persistent层，负责与持久化数据交互，命名规则为XXXDAO，比如OrderDAO；\n  - 使用Java实现，DAO使用DTO为主的数据对象；\n  - DAO通过MyBatis的Mapper实现\n \n工序说明\n=======\n  - 如果功能要求使用到HTTP interface层，那么：\n     - 使用Application Logic层中对应Service的Stub作为测试替身；\n     - 列出需求描述的场景使用到HTTP interface组件的功能（HTTP interface层目标功能）；\n     - 列出“HTTP interface层目标功能”需要测试的场景（HTTP层目标场景）；\n\n  - 如果功能要求使用到Application Logic层，那么：\n     - 使用Persistent层中对应DAO的Stub作为测试替身；\n     - 列出需求描述的场景使用到Application Logic组件的功能（Application Logic层目标功能）；\n     - 列出“Application Logic层目标功能”要测试的场景（Application Logic层目标场景）；\n\n  - 如果功能要求使用到Persistent层，那么：\n     - 使用H2数据库作为fake implementation；\n     - 列出需求描述的场景使用到Persistent组件的功能（Persistent层目标功能）；\n     - 列出“Persistent层目标功能”要测试的场景（Persistent层目标场景）；\n\n功能需求\n=======\n{functionalities}\n\n任务\n====\n首先，列出每一个验收场景以及对应的测试数据；\n然后，针对每一个验收场景，按照架构描述和工序说明的指引，列出任务列表。\n</code></pre><!-- [[[read_end]]] --><p>当我们针对列出所有商品的功能使用这个模板时，可以得到以下的回答：</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/fc/a2c27e002fd44786ccdfc248a012fefc.jpg?wh=1070x2109\" alt=\"\"><br>\n可以看到，虽然这个任务列表稍显粗略，但是对于任务的划分，的确是按照我们给定的工序进行的。在获得任务列表之后，我们可以围绕任务列表的指引，让LLM帮助我们完成代码的编写，这里我只展示对于测试代码的编写：</p><pre><code class=\"language-plain\">请按照任务列表，编写http interface层的测试代码\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/2e/38/2e1699bc68fe93eed6a8ef8f8d3a4638.jpg?wh=1658x239\" alt=\"\"></p><pre><code class=\"language-plain\">import static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\nimport javax.ws.rs.core.Response;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class ProductsAPITest {\n  private ProductsAPI productsAPI;\n  \n  private OrderService orderServiceMock;\n  \n  @Before\n  public void setUp() {\n    // 创建 OrderService 的 Mock 对象\n    orderServiceMock = mock(OrderService.class);\n    // 初始化 ProductsAPI 并注入 Mock 对象\n    productsAPI = new ProductsAPI(orderServiceMock);\n  }\n\n  @Test\n  public void testGetProductCatalogList() {\n    // 模拟 OrderService 返回的产品目录列表\n    List&lt;ProductCatalog&gt; mockProductCatalogList = new ArrayList&lt;&gt;();\n    // 添加一些测试数据\n    mockProductCatalogList.add(new ProductCatalog(\"1\", \"Product 1\"));\n    mockProductCatalogList.add(new ProductCatalog(\"2\", \"Product 2\"));\n    // 当调用 orderServiceMock 的方法时，返回模拟的产品目录列表\n    when(orderServiceMock.getProductCatalogList()).thenReturn(mockProductCatalogList);\n    // 发送获取产品目录列表的请求\n    Response response = productsAPI.getProductCatalogList();\n    // 验证响应状态码是否为 200 OK\n    assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());\n    // 验证响应内容是否与模拟数据一致\n    List&lt;ProductCatalog&gt; actualProductCatalogList = (List&lt;ProductCatalog&gt;) response.getEntity();\n    assertEquals(mockProductCatalogList.size(), actualProductCatalogList.size());\n    for (int i = 0; i &lt; mockProductCatalogList.size(); i++) {\n      assertEquals(mockProductCatalogList.get(i).getId(), actualProductCatalogList.get(i).getId());\n      assertEquals(mockProductCatalogList.get(i).getName(), actualProductCatalogList.get(i).getName());\n    }\n  }\n  \n  @Test\n  public void testGetEmptyProductCatalogList() {\n    // 模拟 OrderService 返回空的产品目录列表\n    List&lt;ProductCatalog&gt; emptyProductCatalogList = new ArrayList&lt;&gt;();\n    // 当调用 orderServiceMock 的方法时，返回空的产品目录列表\n    when(orderServiceMock.getProductCatalogList()).thenReturn(emptyProductCatalogList);\n    // 发送获取产品目录列表的请求\n    Response response = productsAPI.getProductCatalogList();\n    // 验证响应状态码是否为 200 OK\n    assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());\n    // 验证响应内容是否为空列表\n    List&lt;ProductCatalog&gt; actualProductCatalogList = (List&lt;ProductCatalog&gt;) response.getEntity();\n    assertEquals(0, actualProductCatalogList.size());\n  }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/df/d9/df259706632f7b8bccb32ff5399417d9.jpg?wh=1598x337\" alt=\"\"></p><pre><code class=\"language-plain\">请按照任务列表，编写application logic层的测试代码\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/2a/6a/2a60080f07f7319df2d0d61de5e3516a.jpg?wh=1696x229\" alt=\"\"></p><pre><code class=\"language-plain\">import static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class OrderServiceTest {\n  private OrderService orderService;\n  private OrderDAO orderDAOMock;\n  \n  @Before\n  public void setUp() {\n    // 创建 OrderDAO 的 Mock 对象\n    orderDAOMock = mock(OrderDAO.class);\n    // 初始化 OrderService 并注入 Mock 对象\n    orderService = new OrderService(orderDAOMock);\n  }\n\n  @Test\n  public void testGetProductCatalogList() {\n    // 模拟 OrderDAO 返回的产品目录列表\n    List&lt;ProductCatalog&gt; mockProductCatalogList = new ArrayList&lt;&gt;();\n    // 添加一些测试数据\n    mockProductCatalogList.add(new ProductCatalog(\"1\", \"Product 1\"));\n    mockProductCatalogList.add(new ProductCatalog(\"2\", \"Product 2\"));\n    // 当调用 orderDAOMock 的方法时，返回模拟的产品目录列表\n    when(orderDAOMock.getProductCatalogList()).thenReturn(mockProductCatalogList);\n    // 调用 OrderService 的方法获取产品目录列表\n    List&lt;ProductCatalog&gt; actualProductCatalogList = orderService.getProductCatalogList();\n    // 验证返回的产品目录列表是否与模拟数据一致\n    assertEquals(mockProductCatalogList.size(), actualProductCatalogList.size());\n    for (int i = 0; i &lt; mockProductCatalogList.size(); i++) {\n      assertEquals(mockProductCatalogList.get(i).getId(), actualProductCatalogList.get(i).getId());\n      assertEquals(mockProductCatalogList.get(i).getName(), actualProductCatalogList.get(i).getName());\n    }\n  }\n\n  @Test\n  public void testGetEmptyProductCatalogList() {\n    // 模拟 OrderDAO 返回空的产品目录列表\n    List&lt;ProductCatalog&gt; emptyProductCatalogList = new ArrayList&lt;&gt;();\n    // 当调用 orderDAOMock 的方法时，返回空的产品目录列表\n    when(orderDAOMock.getProductCatalogList()).thenReturn(emptyProductCatalogList);\n    // 调用 OrderService 的方法获取产品目录列表\n    List&lt;ProductCatalog&gt; actualProductCatalogList = orderService.getProductCatalogList();\n    // 验证返回的产品目录列表是否为空列表\n    assertEquals(0, actualProductCatalogList.size());\n  }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/56/b3/563d5ba66376967c6a4e9414bd46a5b3.jpg?wh=1640x330\" alt=\"\"></p><pre><code class=\"language-plain\">请按照任务列表，编写persistent层的测试代码\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/6f/69/6f03b6b550f58122625365f6c7d33169.jpg?wh=1708x262\" alt=\"\"></p><pre><code class=\"language-plain\">import static org.junit.Assert.assertEquals;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.List;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class OrderDAOTest {\n  private static final String DB_URL = \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\";\n  private static final String DB_USER = \"sa\";\n  private static final String DB_PASSWORD = \"\";\n  private OrderDAO orderDAO;\n\n  @Before\n  public void setUp() throws SQLException {\n    // 初始化并创建内存数据库表\n    createTable();\n    // 初始化 OrderDAO\n    orderDAO = new OrderDAO(DB_URL, DB_USER, DB_PASSWORD);\n  }\n\n  @After\n  public void tearDown() throws SQLException {\n    // 删除内存数据库表\n    dropTable();\n  }\n\n  @Test\n  public void testGetProductCatalogList() throws SQLException {\n    // 插入测试数据到内存数据库\n    insertTestData();\n    // 调用 OrderDAO 的方法获取产品目录列表\n    List&lt;ProductCatalog&gt; productCatalogList = orderDAO.getProductCatalogList();\n    // 验证返回的产品目录列表是否与预期一致\n    assertEquals(2, productCatalogList.size());\n    assertEquals(\"1\", productCatalogList.get(0).getId());\n    assertEquals(\"Product 1\", productCatalogList.get(0).getName());\n    assertEquals(\"2\", productCatalogList.get(1).getId());\n    assertEquals(\"Product 2\", productCatalogList.get(1).getName());\n  }\n\n  private void createTable() throws SQLException {\n    try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);\n      Statement stmt = conn.createStatement()) {\n      stmt.execute(\"CREATE TABLE product_catalog (id VARCHAR(50), name VARCHAR(100))\");\n    }\n  }\n\n  private void dropTable() throws SQLException {\n    try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);\n      Statement stmt = conn.createStatement()) {\n      stmt.execute(\"DROP TABLE product_catalog\");\n    }\n  }\n\n  private void insertTestData() throws SQLException {\n    try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);\n      Statement stmt = conn.createStatement()) {\n      stmt.execute(\"INSERT INTO product_catalog VALUES ('1', 'Product 1')\");\n      stmt.execute(\"INSERT INTO product_catalog VALUES ('2', 'Product 2')\");\n    }\n  }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/30/7c/303f6c0e47f068917cd63a60ef68297c.jpg?wh=1580x291\" alt=\"\"></p><p>请注意观察，上述代码中对于测试策略的应用，是符合我们对于测试工序的描述的。在确认测试代码没有问题之后，我们就可以通过与LLM的交互配合，完成生产代码的编写。这个在前面的课程里已经给过了例子，就不再重复了。</p><h2>将测试工序模版化</h2><p>对于简单的场景，我们通过CoT化的测试工序，就足以应对了。但是如果工序本身就有很多细节，需要更多的指导时，我们要怎么办呢？这时候，我们可以为这样的测试工序提供独立的提示词模板。</p><p>比如，对于Persistent层的测试工序，我们希望使用flyway，在测试开始之前完成对于schema的灌注。那么我们可以提供一个独立的测试工序提示词模板：</p><pre><code class=\"language-plain\">技术要求\n=======\n使用H2数据库作为fake implementation；\n在所有测试开始之前，使用flyway db构建表结构；\n在所有测试结束后，清空数据库；\n\n需求\n====\n{requirements}\n\n任务列表\n====\n{task list}\n\n任务\n===\n按照任务列表，符合技术要求，编写测试代码\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ff/32/ffb73ccb52c6689c13b099df6051d232.jpg?wh=1620x214\" alt=\"\"></p><pre><code class=\"language-plain\">import org.flywaydb.core.Flyway;\nimport org.h2.jdbcx.JdbcDataSource;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class OrderDAOTest {\n  private static JdbcDataSource dataSource;\n  \n  private static OrderDAO orderDAO;\n  \n  @BeforeClass\n  public static void setupDatabase() throws SQLException {\n    // 设置H2数据库\n    dataSource = new JdbcDataSource();\n    dataSource.setURL(\"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n    // 运行Flyway来创建表结构\n    Flyway flyway = Flyway.configure().dataSource(dataSource).load();\n    flyway.migrate();\n    // 初始化OrderDAO\n    orderDAO = new OrderDAO(dataSource);\n  }\n  \n  @AfterClass\n  public static void tearDownDatabase() throws SQLException {\n    // 清空数据库\n    try (Connection conn = dataSource.getConnection();\n      Statement stmt = conn.createStatement()) {\n      stmt.executeUpdate(\"DROP ALL OBJECTS DELETE FILES\");\n    }\n  }\n\n  @Test\n  public void testGetProductCatalogWhenNotEmpty() {\n    // 插入一些测试数据\n    insertTestDataIntoDatabase();\n    // 测试获取产品目录列表\n    assertEquals(2, orderDAO.getProductCatalog().size());\n  }\n  \n  @Test\n  public void testGetProductCatalogWhenEmpty() {\n    // 测试空产品目录列表情况\n    assertEquals(0, orderDAO.getProductCatalog().size());\n  }\n\n  private void insertTestDataIntoDatabase() {\n    // 在数据库中插入一些测试数据\n    // 这里可以使用任何测试数据来模拟实际场景\n    // 由于这里只是示例，我将简单地插入两条数据作为示例\n    // 实际项目中应该根据需要插入更多的测试数据\n    try (Connection conn = dataSource.getConnection();\n      Statement stmt = conn.createStatement()) {\n      stmt.executeUpdate(\"INSERT INTO product_catalog (id, name) VALUES (1, 'Product 1')\");\n      stmt.executeUpdate(\"INSERT INTO product_catalog (id, name) VALUES (2, 'Product 2')\");\n    } catch (SQLException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/e9/a3/e947eb686851666b85f8cb239c6904a3.jpg?wh=1536x271\" alt=\"\"></p><p>需要注意的是，在这个提示词模版中，我们需要填入<strong>需求</strong>和<strong>任务列表</strong>这两个上下文。从而保证CoT的提示词模板和具体测试工序的提示词模板，在上下文中是统一的。在得到上面的回答时，我分别填入的上下文是：</p><pre><code class=\"language-plain\">验收场景及测试数据\n\t\t用户请求获取产品目录列表：\n请求：GET /products/catalog\n预期响应：200 OK\n测试数据：无\n\t\t空产品目录列表情况下的响应：\n请求：GET /products/catalog\n预期响应：200 OK，空列表\n测试数据：空的产品目录列表\n</code></pre><pre><code class=\"language-plain\">用户请求获取产品目录列表：\n  创建名为 OrderDAO 的 DAO 类。\n  实现方法用于从数据库中获取产品目录列表。\n  创建 H2 数据库作为 fake implementation。\n  编写 SQL 查询以获取产品目录列表。\n  返回查询结果，如果为空则返回空列表。\n</code></pre><h2>小结</h2><p>当然，另一个做法是，在得到任务列表之后。与LLM交互，进入到某个测试工序时，将该工序的技术要求直接贴到LLM的对话中，比如前面用到持久层工序的时候，我们可以直接这样来写：</p><pre><code class=\"language-plain\">请按照任务列表，编写persistent层的测试代码。请注意，要符合下列技术要求\n\n技术要求\n=======\n使用H2数据库作为fake implementation；\n在所有测试开始之前，使用flyway db构建表结构；\n在所有测试结束后，清空数据库；\n</code></pre><p>这样可以避免需要人工传递上下文的问题。我不建议在CoT模版中放入太多的具体工序细节，这是因为以目前（2024年3月）LLM的能力，当工序细节过多时，它会遗漏一些细节。而独立的测试工序模版，可以帮助我们更好地发现这些细节。</p><p>除此之外，另一个使用独立测试工序模版的好处是，更容易过渡到大模型驱动的自主代理架构（LLM based Autonomous Agent）。</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/88/a51a7885590830fbe08a4da55b22d088.jpg?wh=2000x1078\" alt=\"\"></p><p>这种由一个Agent控制任务列表，并调用其他Agent完成具体工作的架构，非常类似于最近（2024年3月）火热的Devin。而在crewAI等框架的帮助下，获得一个更加精准的、也符合我们架构要求的“定制版Devin”，成本是非常低的。我们只要梳理清楚与架构对应的测试工序即可。</p><h2>思考题</h2><p>请修改本文中的样例工序，并调整CoT模版，生成符合工序要求的任务列表。</p><p>欢迎在留言区分享你的想法，我会让编辑置顶一些优质回答供大家学习讨论。</p>","neighbors":{"left":{"article_title":"21｜什么是测试工序？","id":769164},"right":{"article_title":"23｜团队开发的核心模式","id":770627}},"comments":[{"had_liked":false,"id":390004,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1714086899,"is_pvip":true,"replies":[{"id":141871,"content":"没什么区别","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1714109423,"ip_address":"广东","comment_id":390004,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"🤔☕️🤔☕️🤔\n【R】列出：验收场景 + 测试数据 -&gt; 任务列表\n-》按照任务列表、符合技术要求，编写测试代码。\n独立测试工序模板 -&gt; 大模型驱动的自主代理架构（LLM based Autonomous Agent）。\n【.I.】课程到这里，似乎越来越淡薄于是否有一只开发团队，这是种错觉、还是种趋势，我不太确定。而且，引入LLM来助推软件开发过程中的这些地方，那么作为具体的人，在哪些地方出现，以及需要具备或需要提升的能力在哪些方面，也得试着辨别明晰出来。\n【Q】课程中的CoT，跟业界的CoT的联系与区别是什么？\n— by 术子米德@2024年4月26日","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":643176,"discussion_content":"没什么区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714109423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}