{"id":204845,"title":"50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式","content":"<p>上一节课我们学习了桥接模式，桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，类似“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>今天，我们通过剖析Java IO类的设计思想，再学习一种新的结构型模式，装饰器模式。它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>Java IO类的“奇怪”用法</h2><p>Java IO类库非常庞大和复杂，有几十个类，负责IO数据的读取和写入。如果对Java IO类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/50/05/507526c2e4b255a45c60722df14f9a05.jpg?wh=1823*503\" alt=\"\"></p><p>针对不同的读取和写入场景，Java IO又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg?wh=2285*2546\" alt=\"\"></p><p>在我初学Java的时候，曾经对Java IO的一些用法产生过很大疑惑，比如下面这样一段代码。我们打开文件test.txt，从中读取数据。其中，InputStream是一个抽象类，FileInputStream是专门用来读取文件流的子类。BufferedInputStream是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p><!-- [[[read_end]]] --><pre><code>InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nInputStream bin = new BufferedInputStream(in);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n  //...\n}\n</code></pre><p>初看上面的代码，我们会觉得Java IO的用法比较麻烦，需要先创建一个FileInputStream对象，然后再传递给BufferedInputStream对象来使用。我在想，Java IO为什么不设计一个继承FileInputStream并且支持缓存的BufferedFileInputStream类呢？这样我们就可以像下面的代码中这样，直接创建一个BufferedFileInputStream类对象，打开文件读取数据，用起来岂不是更加简单？</p><pre><code>InputStream bin = new BufferedFileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n  //...\n}\n</code></pre><h2>基于继承的设计方案</h2><p>如果InputStream只有一个子类FileInputStream的话，那我们在FileInputStream基础之上，再设计一个孙子类BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。</p><p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的DataInputStream类，支持按照基本数据类型（int、boolean、long等）来读取数据。</p><pre><code>FileInputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nDataInputStream din = new DataInputStream(in);\nint data = din.readInt();\n</code></pre><p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出DataFileInputStream、DataPipedInputStream等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出BufferedDataFileInputStream、BufferedDataPipedInputStream等n多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们在<a href=\"https://time.geekbang.org/column/article/169593\">第10节</a>中讲的不推荐使用继承的原因。</p><h2>基于装饰器模式的设计方案</h2><p>在第10节中，我们还讲到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示了Java IO的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构，如果你感兴趣的话，可以直接去查看JDK源码。</p><pre><code>public abstract class InputStream {\n  //...\n  public int read(byte b[]) throws IOException {\n    return read(b, 0, b.length);\n  }\n  \n  public int read(byte b[], int off, int len) throws IOException {\n    //...\n  }\n  \n  public long skip(long n) throws IOException {\n    //...\n  }\n\n  public int available() throws IOException {\n    return 0;\n  }\n  \n  public void close() throws IOException {}\n\n  public synchronized void mark(int readlimit) {}\n    \n  public synchronized void reset() throws IOException {\n    throw new IOException(&quot;mark/reset not supported&quot;);\n  }\n\n  public boolean markSupported() {\n    return false;\n  }\n}\n\npublic class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  //...实现基于缓存的读数据接口...  \n}\n\npublic class DataInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected DataInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  //...实现读取基本类型数据的接口\n}\n</code></pre><p>看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从Java IO的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p><p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong>比如，下面这样一段代码，我们对FileInputStream嵌套了两个装饰器类：BufferedInputStream和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><pre><code>InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);\nInputStream bin = new BufferedInputStream(in);\nDataInputStream din = new DataInputStream(bin);\nint data = din.readInt();\n</code></pre><p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</strong>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p><pre><code>// 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n  void f();\n}\npublic class A impelements IA {\n  public void f() { //... }\n}\npublic class AProxy implements IA {\n  private IA a;\n  public AProxy(IA a) {\n    this.a = a;\n  }\n  \n  public void f() {\n    // 新添加的代理逻辑\n    a.f();\n    // 新添加的代理逻辑\n  }\n}\n\n// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA {\n  void f();\n}\npublic class A implements IA {\n  public void f() { //... }\n}\npublic class ADecorator implements IA {\n  private IA a;\n  public ADecorator(IA a) {\n    this.a = a;\n  }\n  \n  public void f() {\n    // 功能增强代码\n    a.f();\n    // 功能增强代码\n  }\n}\n</code></pre><p>实际上，如果去查看JDK的源码，你会发现，BufferedInputStream、DataInputStream并非继承自InputStream，而是另外一个叫FilterInputStream的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</p><p>我们再重新来看一下BufferedInputStream类的代码。InputStream是一个抽象类而非接口，而且它的大部分函数（比如read()、available()）都有默认实现，按理来说，我们只需要在BufferedInputStream类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承InputStream的默认实现。但实际上，这样做是行不通的。</p><p>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream还是必须把它重新实现一遍，简单包裹对InputStream对象的函数调用。具体的代码示例如下所示。如果不重新实现，那BufferedInputStream类就无法将最终读取数据的任务，委托给传递进来的InputStream对象来完成。这一部分稍微有点不好理解，你自己多思考一下。</p><pre><code>public class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  // f()函数不需要增强，只是重新调用一下InputStream in对象的f()\n  public void f() {\n    in.f();\n  }  \n}\n</code></pre><p>实际上，DataInputStream也存在跟BufferedInputStream同样的问题。为了避免代码重复，Java IO抽象出了一个装饰器父类FilterInputStream，代码实现如下所示。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p><pre><code>public class FilterInputStream extends InputStream {\n  protected volatile InputStream in;\n\n  protected FilterInputStream(InputStream in) {\n    this.in = in;\n  }\n\n  public int read() throws IOException {\n    return in.read();\n  }\n\n  public int read(byte b[]) throws IOException {\n    return read(b, 0, b.length);\n  }\n   \n  public int read(byte b[], int off, int len) throws IOException {\n    return in.read(b, off, len);\n  }\n\n  public long skip(long n) throws IOException {\n    return in.skip(n);\n  }\n\n  public int available() throws IOException {\n    return in.available();\n  }\n\n  public void close() throws IOException {\n    in.close();\n  }\n\n  public synchronized void mark(int readlimit) {\n    in.mark(readlimit);\n  }\n\n  public synchronized void reset() throws IOException {\n    in.reset();\n  }\n\n  public boolean markSupported() {\n    return in.markSupported();\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h2>课堂讨论</h2><p>在上节课中，我们讲到，可以通过代理模式给接口添加缓存功能。在这节课中，我们又通过装饰者模式给InputStream添加缓存读取数据功能。那对于“添加缓存”这个应用场景来说，我们到底是该用代理模式还是装饰器模式呢？你怎么看待这个问题？</p><p>欢迎留言和我分享你的思考，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？","id":202786},"right":{"article_title":"51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？","id":205912}},"comments":[{"had_liked":false,"id":181966,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1582685418,"is_pvip":false,"discussion_count":33,"race_medal":0,"score":"2252145548522","product_id":100039001,"comment_content":"你是一个优秀的歌手，只会唱歌这一件事，不擅长找演唱机会，谈价钱，搭台，这些事情你可以找一个经纪人帮你搞定，经纪人帮你做好这些事情你就可以安稳的唱歌了，让经纪人做你不关心的事情这叫代理模式。<br>你老爱记错歌词，歌迷和媒体经常吐槽你没有认真对待演唱会，于是你想了一个办法，买个高端耳机，边唱边提醒你歌词，让你摆脱了忘歌词的诟病，高端耳机让你唱歌能力增强，提高了基础能力这叫装饰者模式。","like_count":525,"discussions":[{"author":{"id":1070601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/56/09/4a9d4a35.jpg","nickname":"zj坚果","note":"","ucode":"D6E787FF032D7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263203,"discussion_content":"软件工程没有银弹。我不同意一刀切，正如你所说的“人类无法预知未来”，你又如何能知道未来不会有更好的解决方案，未来这个系统是否会采用采用其他技术重构甚至重做等等。如果未来是指几年后的话，个人觉得大可不必过早担心，毕竟我们的项目还要考虑各种其他因素，诸如人力资源，开发时间，队友是否跟你一样熟悉设计模式等。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1589187157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65645,"discussion_content":"作为一个职场老油条，还是赞同争哥观点的，毕竟还是要考虑到人力成本~~~","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1575018178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147925,"discussion_content":"就和贫血模型一样，人力成本在实际工作中也是很重要的考量维度","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1579681527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1032345,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","nickname":"Geeker","note":"","ucode":"9937127DE96D78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":223260,"discussion_content":"所以最重要的因素还是人，无论是需求分析阶段人与人的沟通，还是编码阶段的开发人力，还是测试阶段开发测试的沟通，还是上线后的运维。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586195746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":147925,"ip_address":""},"score":223260,"extra":""},{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1032345,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","nickname":"Geeker","note":"","ucode":"9937127DE96D78","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":297486,"discussion_content":"也因为人的多样性，最后还是需要流程和规范。有时遇到那种换个领导就一种搞法的，真实痛苦。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1596949011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223260,"ip_address":""},"score":297486,"extra":""}]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246810,"discussion_content":"文本的规范是没法做到最终的统一的，可以要求自己控制好度，一个工程是多人开发，所以没法要求别人也控制好度，这也就是为什么go语言和您说的kotlin放弃继承的原因，把握好度只是一种理想的状态，大部分人是把握不好的，特别在项目工期紧工作量大的情况下","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1587779669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59846,"discussion_content":"所以为什么会新起函数式编程，感觉接口，组合，委托的思路和函数式编程有点接近了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574694568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58171,"discussion_content":"矢量化思想，是你发明的名词么","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574656195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220277,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b5/17ff83e6.jpg","nickname":"Leo","note":"","ucode":"7A11B26AEA5510","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345650,"discussion_content":"还有一个就是不要过渡设计，拆分的很细后续维护也是一个痛点","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1611756054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018604,"avatar":"","nickname":"huxian","note":"","ucode":"60699B4C279E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70218,"discussion_content":"不完全赞同，继承还是有使用场景的，只是不能过度使用，我觉得和单例模式类似，尽量要少用，但有些场景还是必须要用的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575336971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025958,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a7/a6/120412b1.jpg","nickname":"姜中正","note":"","ucode":"D76875214401CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124855,"discussion_content":"这就是golang中经常用到的方法。golang中没有继承。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578454359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291391,"discussion_content":"请教一下，如果是按照功能分成多个基类，然后再按需继承。\n比如 Fly类，Tweet类，Egg类。\n鸵鸟就只继承Tweet类，Egg类\n这样也可以实现接口，组合，委托的效果啊，请问一下这样有什么坏处呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594802812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1071883,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epaibTssLXqSXryibVuFoMyicg64o3IqFaobS9J7TibqUpRQ45lVj2nbRQpfLQicW6W81zwYM19X1VIk8A/132","nickname":"ixonya","note":"","ucode":"1CE0897B39AD18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291643,"discussion_content":"本小白觉得你的方法也没啥不行的，和“接口，组合，委托”的思想是一致的，只是一些语言不支持多重继承。。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1594896372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291391,"ip_address":""},"score":291643,"extra":""},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071883,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epaibTssLXqSXryibVuFoMyicg64o3IqFaobS9J7TibqUpRQ45lVj2nbRQpfLQicW6W81zwYM19X1VIk8A/132","nickname":"ixonya","note":"","ucode":"1CE0897B39AD18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291726,"discussion_content":"可以直接组合呀😏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594920361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291643,"ip_address":""},"score":291726,"extra":""},{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294524,"discussion_content":"面向接口而非实现编程，接口是稳定的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595916852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291726,"ip_address":""},"score":294524,"extra":""}]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271417,"discussion_content":"第5点写的很好，其它的各有已见，没必要统一。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590134046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2829583,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/2d/0f/52e5dcff.jpg","nickname":"右手特别大","note":"","ucode":"9B9A4600B97D81","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576941,"discussion_content":"通过组合复用另外一个模块有一个限制条件，就是组合类必须定义实现对外的函数接口。 恰恰有一种场景，多个子类的功能与父类相似，但是就是有小部分不同。 用户希望这些子类都必须提供某套接口。除非你能忍受每一个子类都实现一遍这些接口，并且实现大多是代理调用某个成员变量模块的函数，显而易见的重复，只有继承才能解决，因为只有继承才支持函数实现的复用。至于重复代码有什么缺点，那是另外一个故事了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655860364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393478,"discussion_content":"你用组合实现一个模板方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631448857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377142,"discussion_content":"厉害👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622522979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2273754,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b1/da/5602cb4b.jpg","nickname":"king","note":"","ucode":"1E5BD0E2A789C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319070,"discussion_content":"可以想法不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603935871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1900967,"avatar":"","nickname":"ricepot100","note":"","ucode":"318CBC10964946","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218715,"discussion_content":"对于只利用继承进行分类的话，还是使用继承比较合适吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585670843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182984,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/08/2f825f69.jpg","nickname":"丁源(156*****518)","note":"","ucode":"BDBB8B7D0745FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185291,"discussion_content":"兄台结合实战的经验之谈着实值得点赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582613257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181937,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1582682580,"is_pvip":false,"discussion_count":10,"race_medal":1,"score":"1315842675156","product_id":100039001,"comment_content":"对于添加缓存这个应用场景使用哪种模式，要看设计者的意图，如果设计者不需要用户关注是否使用缓存功能，要隐藏实现细节，也就是说用户只能看到和使用代理类，那么就使用proxy模式；反之，如果设计者需要用户自己决定是否使用缓存的功能，需要用户自己新建原始对象并动态添加缓存功能，那么就使用decorator模式。","like_count":307,"discussions":[{"author":{"id":1744864,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iah9ialZUzXeuEgIFEwk0QqZiaJAv0ib2f5grmbt2QtqhPZOXn3JSmQJZBTfYelAZVjue9WyL4pGXBVR1ZiaDibPOjMQ/132","nickname":"Geek_9a6932","note":"","ucode":"091355315E7160","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308853,"discussion_content":"真优秀 比这篇文章说得好","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1601097899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219501,"discussion_content":"解释的很棒","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585756627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198204,"discussion_content":"说的太好了我是这样理解用代理模式使用给方法加缓存的:  代理类增加使用缓存的功能,如果能查到缓存直接返回数据,查不到缓存执行被代理方法去数据库查找需要的数据返回。对调用方来说,使用缓存调用代理类,不使用缓存调用被代理类。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583487392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2620971,"avatar":"https://static001.geekbang.org/account/avatar/00/27/fe/2b/1eeac409.jpg","nickname":"FREDŸŸ","note":"","ucode":"241DF863FB0E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535227,"discussion_content":"你这样的用法，我怎么反而觉得更像是装饰器呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638371434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198204,"ip_address":""},"score":535227,"extra":""}]},{"author":{"id":1618328,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b1/98/11b22d79.jpg","nickname":"絆","note":"","ucode":"52D965461314DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539634,"discussion_content":"厉害,我也看迷糊了,评论区都是大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639793367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531669,"discussion_content":"说得很好。一下就理解了。真的是胜过那些乱七八糟的博文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637378901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466467,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/63/d2c91e2b.jpg","nickname":"JoeyforJoy","note":"","ucode":"5598501E71D35D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370180,"discussion_content":"一语中的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619319385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1604438,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7b/56/80a75331.jpg","nickname":"徐丶昌隆","note":"","ucode":"9EE3F971F90C4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357667,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615851981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1038811,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/db/66d5b3f4.jpg","nickname":"Leo","note":"","ucode":"BFAF83E23199DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332524,"discussion_content":"优秀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607248548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306650,"discussion_content":"牛！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600340687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182018,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1582693317,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"624352951237","product_id":100039001,"comment_content":"今天的课后题：<br>1.有意思，关于代理模式和装饰者模式，各自应用场景和区别刚好也想过。<br><br>1.代理模式和装饰者模式都是 代码增强这一件事的落地方案。前者个人认为偏重业务无关，高度抽象，和稳定性较高的场景（性能其实可以抛开不谈）。后者偏重业务相关，定制化诉求高，改动较频繁的场景。<br><br>2.缓存这件事一般都是高度抽象，全业务通用，基本不会改动的东西，所以一般也是采用代理模式，让业务开发从缓存代码的重复劳动中解放出来。但如果当前业务的缓存实现需要特殊化定制，需要揉入业务属性，那么就该采用装饰者模式。因为其定制性强，其他业务也用不着，而且业务是频繁变动的，所以改动的可能也大，相对于动代，装饰者在调整（修改和重组）代码这件事上显得更灵活。","like_count":146,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103974,"discussion_content":"一人血书求老师答疑","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1577408248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341023,"discussion_content":"找了全专栏，没有讨论题的答疑呀，","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1610264947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57880,"discussion_content":"为请老师讲解讨论题点赞","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574645438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338602,"discussion_content":"后来，老师答疑了吗","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1609321266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2343174,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c1/06/442b20a3.jpg","nickname":"小笨蛋","note":"","ucode":"159A8DCA371A35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338773,"discussion_content":"同问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609378914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338602,"ip_address":""},"score":338773,"extra":""}]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475635,"discussion_content":"抽空集中答疑一下吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574853379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1910698,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/27/aa/5e65bd19.jpg","nickname":"Eden","note":"","ucode":"1A03D9F9D5A17A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536446,"discussion_content":"老师突然想起来极客时间的账号了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638786413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475635,"ip_address":""},"score":536446,"extra":""},{"author":{"id":1246156,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/cc/fa33828b.jpg","nickname":"yuuki","note":"","ucode":"6C068781E03EA1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1910698,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/27/aa/5e65bd19.jpg","nickname":"Eden","note":"","ucode":"1A03D9F9D5A17A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":537603,"discussion_content":"老师这些课后思考题， 不讲解一下嘛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639114066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536446,"ip_address":""},"score":537603,"extra":""},{"author":{"id":1459863,"avatar":"https://static001.geekbang.org/account/avatar/00/16/46/97/ddd4b05f.jpg","nickname":"爱上我们的微笑","note":"","ucode":"40CDB7AB0991CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1910698,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/27/aa/5e65bd19.jpg","nickname":"Eden","note":"","ucode":"1A03D9F9D5A17A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":543814,"discussion_content":"哈哈哈\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641306783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536446,"ip_address":""},"score":543814,"extra":""}]},{"author":{"id":1335980,"avatar":"https://static001.geekbang.org/account/avatar/00/14/62/ac/1f3391dd.jpg","nickname":"张姗","note":"","ucode":"A075C34614FE4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136483,"discussion_content":"请老师讲解讨论题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579143376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111973,"avatar":"","nickname":"AdrianH","note":"","ucode":"1D5A7CB36BF57E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69059,"discussion_content":"+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575255833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1584787,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2e/93/029eee99.jpg","nickname":"阿维","note":"","ucode":"84CBFDBD016806","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60954,"discussion_content":"请老师加餐讲解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574766948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201342,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/be/9dada6f6.jpg","nickname":"Yannis","note":"","ucode":"9A59D61EDE1833","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60209,"discussion_content":"请老师加餐讲解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574703204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529040,"avatar":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","nickname":"帆大肚子","note":"","ucode":"3DB11DB2FA1802","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59659,"discussion_content":"老师讲解讨论题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574692387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363054,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cc/6e/c3c9ea88.jpg","nickname":"别","note":"","ucode":"D806471DA0EDD9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58253,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574662572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261538,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/lNv6icIOUpEbUx4wBNLucxfH6SRNvpq6huvz0iaxtX1rSBticJvcxiaZVy6qIkpibPZ7axSDpnHAy0ZsHndczKbVxqA/132","nickname":"天堂up","note":"","ucode":"0881FCFA744147","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58250,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574662489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58248,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574662292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","nickname":"郑童文","note":"","ucode":"3D193715CB8549","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57947,"discussion_content":"请老师讲解讨论题+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574647151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2065130,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/82/ea/c11d99f7.jpg","nickname":"Minghan","note":"","ucode":"8762CC489C3C6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587964,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663408002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1862316,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/6a/ac/b1738d6b.jpg","nickname":"杨振泽","note":"","ucode":"1666FEB0309BB7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576025,"discussion_content":"hu~ 2022年了，老师啥时候忙完？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655253428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023818,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/4a/f5b8c6b3.jpg","nickname":"Walker Jiang","note":"","ucode":"92AE855D428917","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549525,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644055738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393483,"discussion_content":"老师答疑没有?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631450356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691447,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","nickname":"Dunk","note":"","ucode":"A8F5AB98382719","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367710,"discussion_content":"请老师加餐答疑一波课后题吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618447544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361952,"discussion_content":"后来还是没有答疑？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616811853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242122,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","nickname":"YourSweetHeart","note":"","ucode":"38843F447B03F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85292,"discussion_content":"留言有点靠后了，在用委托代替继承修改之后，如果fly方法依赖鸵鸟类里某个属性，这该怎么办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576526125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1245904,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","nickname":"治慧","note":"","ucode":"47C331EF63EDC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242122,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","nickname":"YourSweetHeart","note":"","ucode":"38843F447B03F2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207869,"discussion_content":"fly方法是在上层对应的接口中,不应该去依赖下层类中的属性 这样就成环形了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1584519379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85292,"ip_address":""},"score":207869,"extra":""}]},{"author":{"id":1122412,"avatar":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","nickname":"NoAsk","note":"","ucode":"71CA29776B4F68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61973,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574809854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60768,"discussion_content":"臣附议...😄 最近也很头疼，有的时候感觉类爆炸了，但好像又不得不去创建一个字段差不多的类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574753331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60297,"discussion_content":"求老师加餐+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574726398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010957,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6d/0d/e3fa096f.jpg","nickname":"拓","note":"","ucode":"AC1940ECC25436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59721,"discussion_content":"请老师讲解讨论题+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181961,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582684826,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"383834774170","product_id":100039001,"comment_content":"补充关于Proxy Pattern 和Decorator Pattern的一点区别:<br><br>Decorator关注为对象动态的添加功能, Proxy关注对象的信息隐藏及访问控制.<br>Decorator体现多态性, Proxy体现封装性.<br><br>reference:<br>https:&#47;&#47;stackoverflow.com&#47;questions&#47;18618779&#47;differences-between-proxy-and-decorator-pattern","like_count":90,"discussions":[{"author":{"id":1740281,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8d/f9/ceb39113.jpg","nickname":"hostfox²⁰²⁰","note":"","ucode":"0D987C733D7CCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193514,"discussion_content":"赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583155617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203183,"discussion_content":"这个信息隐藏及访问控制指的是?求大佬解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584008152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198034,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583464523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206711,"user_name":"andi轩","can_delete":false,"product_type":"c1","uid":1214649,"ip_address":"","ucode":"3AE241BE60A3E0","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/b9/af5db174.jpg","comment_is_top":false,"comment_ctime":1586919659,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"229220186347","product_id":100039001,"comment_content":"对于为什么必须继承装饰器父类 FilterInputStream的思考：<br>装饰器如BufferedInputStream等，本身并不真正处理read()等方法，而是由构造函数传入的被装饰对象：InputStream（实际上是FileInputStream或者ByteArrayInputStream等对象）来完成的。<br>如果不重写默认的read()等方法，则无法完成如FileInputStream或者ByteArrayInputStream等对象所真正实现的read功能。<br>所以必须重写对应的方法，代理给这些被装饰对象进行处理（这也是类似于代理模式的地方）。<br>如果像DataInputStream和BufferedInputStream等每个装饰器都重写的这些方法话，会存在大量重复的代码。<br>所以让它们都继承FilterInputStream提供的默认实现，可以减少代码重复，让装饰器只聚焦在它自己的装饰功能上即可。","like_count":54,"discussions":[{"author":{"id":1108365,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e9/8d/e079d12a.jpg","nickname":"Geek_c61ff9","note":"","ucode":"66588B9DEC50D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560429,"discussion_content":"刚才还有这个疑问，看了你的理解了，谢谢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649326206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2870321,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE9hv64CEabxt76tQQcWDicx0sucpAApFvYoM8eXBViaJgz06EjcfJjiamSFWY9aAuxjILaPoiaa0lNw/132","nickname":"Soil","note":"","ucode":"3B353BC858B5AE","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560474,"discussion_content":"老哥你最棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649342377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537815,"discussion_content":"课文里面已经说的很清楚了,看来你们的理解能力没我强,哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639206635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2733574,"avatar":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","nickname":"小王在努力","note":"","ucode":"A324EF87198905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407425,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635002156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384567,"discussion_content":"果然 还是得看 评论区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626665513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1463740,"avatar":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","nickname":"Yeyw","note":"","ucode":"C9D20DB91C3BE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360615,"discussion_content":"nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616489676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194982,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/e6/86ae0cd9.jpg","nickname":"满场飞奔","note":"","ucode":"5F8F4238BC93C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313893,"discussion_content":"靠谱 老哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603102462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306683,"discussion_content":"真棒，我看下来 你说的最有道理，我确实想了半天也不太理解这里有什么必要，受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600347494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073845,"avatar":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","nickname":"zhanyd","note":"","ucode":"4C994EE512A3C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286543,"discussion_content":"老哥，你说的真棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593222649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181875,"user_name":"rammelzzz","can_delete":false,"product_type":"c1","uid":1606275,"ip_address":"","ucode":"3BA634B5F6F74B","user_header":"https://static001.geekbang.org/account/avatar/00/18/82/83/8f168e4e.jpg","comment_is_top":false,"comment_ctime":1582652416,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"151906507776","product_id":100039001,"comment_content":"对于无需Override的方法也要重写的理解：<br>虽然本身BufferedInputStream也是一个InputStream，但是实际上它本身不作为任何io通道的输入流，而传递进来的委托对象InputStream才能真正从某个“文件”（广义的文件，磁盘、网络等）读取数据的输入流。因此必须默认进行委托。","like_count":35,"discussions":[{"author":{"id":2694117,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1b/e5/4f8612b0.jpg","nickname":"DougLea","note":"","ucode":"179F29D304519D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383407,"discussion_content":"非常同意楼主的观点，这三层确实必须要相互隔离，尽管代码重复，也不要滥用代码复用。如果一味的追求代码简洁，到最后遇到一点儿变动更加是得不偿失。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1626081853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1830814,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/ef/9e/fd29bdd8.jpg","nickname":"Bacchus","note":"","ucode":"A8AA7E4909B201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401891,"discussion_content":"同意，这三者其实就是三个领域的东西，不能因为属性的现实意义相同就混为一谈，海水里的鱼和鱼缸里的鱼虽然都是鱼，但是用法是不一样的，哈哈","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1633759605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257453,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","nickname":"此鱼不得水","note":"","ucode":"95268E823FB4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109448,"discussion_content":"不同领域的对象，属性重复没毛病。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577695431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286654,"discussion_content":"是的，这三者本身是三层结构的对象，分三层也是触偶\n如果存在复用则意味着一层的对象改变会影响到另一层","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1593255003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446024,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/GA9AqKGEdib009iaPw3FSluiaeibCXmen7yFIKicZB8qqEtczZJF2WmwBJ738eExnxDmPREIGjqc4BFVXiamyhuCZASw/132","nickname":"一缕阳光","note":"","ucode":"CA89C1B7CB16C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585346,"discussion_content":"听君一席话，胜听一席话","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1661496128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297488,"discussion_content":"也是这种想法，有时适当重复也是一种模式，彼此之间没有依赖。最怕一些同事，见不得一点重复，总搞一些继承出来，看得都头大。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596949324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73233,"discussion_content":"我通常尽量只写一个类，然后用各层生效的注解来注释各个属性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575555925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384871,"discussion_content":"炫技，是不是，分开写纯粹点，没有鱼龙混杂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626777531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73233,"ip_address":""},"score":384871,"extra":""}]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72954,"discussion_content":"有道理！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575544874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59888,"discussion_content":"突然想到ddd里面的实体和值对象，或许从业务上来处理这个问题更好，根据业务来区分实体和值对象来建立entity，而不是死扣Entity、Bo、Vo做三层区分。个人思考的结果","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574694906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287634,"discussion_content":"那你这种就不是传统的MVC模式了，DDD讲究聚合根来聚合实体对象，那么就不存在细分的BO、VO、Entity了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593500137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":59888,"ip_address":""},"score":287634,"extra":""}]},{"author":{"id":1518793,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/c9/462afe28.jpg","nickname":"小白","note":"","ucode":"11FC209D9ED65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590854,"discussion_content":"确实，从业务角度来讲，这几个在上下文本来就不是同个东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666117659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394143,"avatar":"https://static001.geekbang.org/account/avatar/00/15/45/df/97a71dc8.jpg","nickname":"怀英","note":"","ucode":"E2838AF06FB300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587882,"discussion_content":"同意，有时VO不需要全部的entity的所有属性，如果要使用“接口+组合+委托”，那么这个“接口”就很难制定。此外，如果要实现如此的灵活性，在VO多变的情况下，最好的方法就是entity的每一个属性定义成一个接口，这样一来，工作量大，有点儿得不偿失","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663342009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005356,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","nickname":"ssala","note":"","ucode":"CCD82C81756FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554691,"discussion_content":"学到了，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646553234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213448,"discussion_content":"分开写没毛病，复用我觉得很重要看重业务趋同还是趋异，这里明显是趋异的，复用代码干嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585095010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117318,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","nickname":"花花大脸猫","note":"","ucode":"8ABDB3F7F4FB0F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87739,"discussion_content":"目前处理方式Entity， Bo， Vo三者之间，该重复还是重复吧，如果采用组合，虽然代码复用了，但是对于调用端/前端的数据获取增加了复杂性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576678061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73238,"discussion_content":"这个课后问题是常见的问题，可惜没有一个好方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575556023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1412220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIaTvOKvUt4WnuSjkBp0tjd6O6vvVyw5fcib3UgZibE8tz2ICbTfkwbzs8MHNMJjV6W2mLjywLsvBibg/132","nickname":"火力全开","note":"","ucode":"8CE1733A2F618C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393161,"discussion_content":"三层独立，用bean拷贝工具复制","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631272491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73238,"ip_address":""},"score":393161,"extra":""}]}]},{"had_liked":false,"id":182060,"user_name":"Yo nací para quererte.","can_delete":false,"product_type":"c1","uid":1664572,"ip_address":"","ucode":"8B6E9B8B3D007C","user_header":"https://static001.geekbang.org/account/avatar/00/19/66/3c/2d563488.jpg","comment_is_top":false,"comment_ctime":1582701828,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"134726688004","product_id":100039001,"comment_content":"对于为什么中间要多继承一个FilterInputStream类，我的理解是这样的：<br>假如说BufferedInputStream类直接继承自InputStream类且没有进行重写，只进行了装饰<br>创建一个InputStream is = new BufferedInputStream(new FileInputStream(FilePath));<br>此时调用is的没有重写方法(如read方法)时调用的是InputStream类中的read方法，而不是FileInputStream中的read方法，这样的结果不是我们想要的。所以要将方法再包装一次，从而有FilterInputStream类，也是避免代码的重复，多个装饰器只用写一遍包装代码即可。","like_count":31,"discussions":[{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374743,"discussion_content":"组合其实就是依赖","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621332750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336634,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","nickname":"mqray","note":"","ucode":"15664507AD7033","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533056,"discussion_content":"这个组方就像spring boot中注入其他类一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637763577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2828609,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/29/41/371c3b77.jpg","nickname":"神经蛙vx qingtian01266","note":"","ucode":"83C047B851E23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532926,"discussion_content":"你的回复更像是看到类用了 extends ，说明他是 is-a 关系 。。。。。。作者想告诉我们的是什么时候用继续，什么时候用组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637734171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2034881,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0c/c1/1efe5b42.jpg","nickname":"小璇璇","note":"","ucode":"C574FDBA0F66D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378264,"discussion_content":"委托的最终目标是方法的委托，即方法的委托或方法的代理，比如调用obj.f()的时候转而去调用obj1.f()。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623134642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263982,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1606307492,"is_pvip":false,"replies":[{"id":"96083","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700672,"ip_address":"","comment_id":263982,"utype":1}],"discussion_count":3,"race_medal":0,"score":"121865391780","product_id":100039001,"comment_content":"代理模式体现封装性，非业务功能与业务功能分开，而且使用是透明的，使用者只需要关注于自身的业务，在业务场景上适用于对某一类功能进行加强，比如日志，事务，权限。<br>装饰器模式体现多态性，优点在于避免了继承爆炸，适用于扩展多个平行功能。在场景上，这些扩展的功能可以像火车厢一样串起来，使原有的业务功能不断增强。<br>具体到“缓存”这个单个问题，两种模式都可以，主要还是看设计者的目的，如果是为了新增功能的隐藏性，就使用代理模式；如果设计者不仅要增加“缓存”功能，还要增加“过滤”等功能，就更适于装饰器模式。","like_count":29,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510377,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537513,"discussion_content":"到位！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639091536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041396,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","nickname":"宙斯","note":"","ucode":"80DF36BAD298AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387975,"discussion_content":"这个回答也是不错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628518189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185379,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1583570856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74598014888","product_id":100039001,"comment_content":"设计模式_50:<br># 作业<br><br>正如文中所说，装饰器是对原有功能的扩展，代理是增加并不相关的功能。<br>所以问题就变成使用者认为“缓存”是否扩展了原功能<br>- 比如说需要把想把所有的网络信息都加上缓存，提高一些查询效率，这时候应该使用代理模式；<br>- 如果我在设计网络通信框架，需要把提供“缓存”作为一种扩展能力，这时应该用装饰器模式；<br><br>现实中，大部分的网络缓存都以代理模式被实现。<br><br>另外，缓存(Cache)与缓冲(Buffer)是不同的概念，这里也可以区分一下。<br><br># 感受<br>到了具体模式的课程，有一个明显的特点：一句话感觉看懂了，反复读才能发现有更多的信息在里面，坦白讲，很多模式编程中没有用过，与单纯地读原理和特征相比，我想真正用的时候才能理解更深入的东西。","like_count":17},{"had_liked":false,"id":182297,"user_name":"岁月神偷","can_delete":false,"product_type":"c1","uid":1484111,"ip_address":"","ucode":"BA851259EA1F71","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/4f/592d00f2.jpg","comment_is_top":false,"comment_ctime":1582765234,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"61712307378","product_id":100039001,"comment_content":"我觉得应该用代理模式，当然这个是要看场景的。代理模式是在原有功能之外增加了其他的能力，而装饰器模式则在原功能的基础上增加额外的能力。一个是增加，一个是增强，就好比一个是在手机上增加了一个摄像头用于拍照，而另一个则是在拍照这个功能的基础上把像素从800W提升到1600W。我觉得通过这样的方式区分的话，大家互相沟通起来理解会统一一些。","like_count":14,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363931,"discussion_content":"人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617327836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182088,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1582706323,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"44532379283","product_id":100039001,"comment_content":"<br>&#47;&#47; 代理模式的代码结构(下面的接口也可以替换成抽象类)<br>public interface IA {<br>  void f();<br>}<br>public class A impelements IA {<br>  public void f() { &#47;&#47;... }<br>}<br>public class AProxy impements IA {<br>  private IA a;<br>  public AProxy(IA a) {<br>    this.a = a;<br>  }<br>  <br>  public void f() {<br>    &#47;&#47; 新添加的代理逻辑<br>    a.f();<br>    &#47;&#47; 新添加的代理逻辑<br>  }<br>}<br><br>&#47;&#47; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)<br>public interface IA {<br>  void f();<br>}<br>public class A impelements IA {<br>  public void f() { &#47;&#47;... }<br>}<br>public class ADecorator impements IA {<br>  private IA a;<br>  public ADecorator(IA a) {<br>    this.a = a;<br>  }<br>  <br>  public void f() {<br>    &#47;&#47; 功能增强代码<br>    a.f();<br>    &#47;&#47; 功能增强代码<br>  }<br>}<br><br>老师 上面代码结构完全一样啊 不能因为 f() 中写的 逻辑不同  就说是两种模式吧  ","like_count":10,"discussions":[{"author":{"id":1315968,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZIqY4cs6YKNx0OqeMrbjLIicqiafLNtLYJTN2zTtVPlwXZ7qlJ7xrGQictk1xCq5pEsIyqnkiaCib4zQ/132","nickname":"全炸攻城狮","note":"","ucode":"DB437F9190575C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218866,"discussion_content":"装饰器模式可以认为是对代理模式的拓展、延伸。代理模式是1对1，装饰器模式是1对多","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1585708265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194454,"discussion_content":"虽然代码结构相同,但是两种方式的设计意图不同.代理模式主要目的是访问控制,而不是功能的增强;装饰者模式主要目的是对功能的增强.","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1583221244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1530295,"avatar":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","nickname":"渊จุ๊บ","note":"","ucode":"E3A2C1E89EB576","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364987,"discussion_content":"注释不一样。我理解的是，装饰器遵从里式替换原则；代理是额外的功能，不遵从里式替换原则","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617679100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288182,"discussion_content":"代码结构确实一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593672130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2055696,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/USbsicTvESSEM8CKwDoLsIk4IhpKFVqTyhS7zMksu8XgmiayNnlTX2aO62liavApicF5cIKZFexUZVztUvj4SRtEhw/132","nickname":"小明明","note":"","ucode":"CADE860269BFA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389111,"discussion_content":"我个人认为，代理模式应该是在构造函数里进行new，别人使用代理类也就对原始类进行封装，换句话说，在编译器就确定了多态。装饰模式也是传入了原始类的对象，对原始类进行增强，在运行时才能确定传入的多态对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629123235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182003,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1582690388,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35942428756","product_id":100039001,"comment_content":"订单的优惠有很多种，比如满减，领券这样的是不是可以使用decorator 模式来实现","like_count":8,"discussions":[{"author":{"id":1000565,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/75/5e6d6975.jpg","nickname":"冯威","note":"","ucode":"52A4F1989DD286","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295355,"discussion_content":"这个应该是策略吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596173784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530741,"discussion_content":"这个是策略   不同的功能了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637137803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737886,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/9e/d4c0e2c4.jpg","nickname":"Broadm","note":"","ucode":"BEA06300731AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343894,"discussion_content":"这个是策略不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611210207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273225,"user_name":"楚小奕","can_delete":false,"product_type":"c1","uid":1011022,"ip_address":"","ucode":"AB808A42C2535E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/4e/347c3e8f.jpg","comment_is_top":false,"comment_ctime":1610502385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23085338865","product_id":100039001,"comment_content":"我觉得不要纠结代理和装饰吧， 自己清楚设计意图就好","like_count":5},{"had_liked":false,"id":181890,"user_name":"木头","can_delete":false,"product_type":"c1","uid":1099319,"ip_address":"","ucode":"32EACA5DCA857D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/37/8d22be0a.jpg","comment_is_top":false,"comment_ctime":1582673619,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"23057510099","product_id":100039001,"comment_content":"看业务场景，如果只是针对某个类的某一个对象，添加缓存，那么就使用装饰模式。如果是针对这个类的所有对象，添加缓存。那么就使用代理模式","like_count":5},{"had_liked":false,"id":185516,"user_name":"年轻的我们","can_delete":false,"product_type":"c1","uid":1763079,"ip_address":"","ucode":"D7D7D6AE9F4CB7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e7/07/0e9d85c3.jpg","comment_is_top":false,"comment_ctime":1583597579,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18763466763","product_id":100039001,"comment_content":"个人理解：装饰者模式就是代理模式中的静态代理模式，装饰类对于需要新增附加功能的方法，新增附加功能，对应不需要实现定制化功能的方法，继承和组合方式调用原始类功能即可","like_count":4,"discussions":[{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79923,"discussion_content":"赞同，但也期待更精彩更完美的解决方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576123697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730626,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","nickname":"小妖","note":"","ucode":"49C01DBFADF101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63803,"discussion_content":"和我的理解不谋而合，VO的作用本来就是为了和对外数据更灵活、不能也没必要和其他层有集成或者实现关系，划分三层最重要的是隔离，更容易拓展，如果把封装的定义泛化，这同样是另外一种封装","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574912377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1176980,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f5/94/67fabf8e.jpg","nickname":"Kevinlvlc","note":"","ucode":"90DFD58CED138C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60290,"discussion_content":"支持这种理解～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574725747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518793,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/c9/462afe28.jpg","nickname":"小白","note":"","ucode":"11FC209D9ED65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590855,"discussion_content":"最佳方案，DDD 就是这样设计的，重复就让他重复吧，从业务层面看，本就不是同个语义，随时有变化的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666117803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304087,"discussion_content":"防腐层还是第一次听说，他跟模型转换层有什么区别呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599464804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102194,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/72/4cc8475c.jpg","nickname":"Leaf","note":"","ucode":"9AB56B7971237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297493,"discussion_content":"目前我们项目也是部分混用，但需要开发人员理解好业务 model 以及 分层 model 的区别，要不为了兼容不同层，很容易把 model 搞成全家桶。而 model 是最容易导致各层耦合的点，用不好就容易导致高耦合造成混乱。因为在我看来，分层实现的还坏，决定于 model 的分层隔离有没有做好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596949890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438470,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/06/8da1bf0c.jpg","nickname":"Fredo","note":"","ucode":"681D6692617DAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157898,"discussion_content":"关于DO VO等大家可以参考下 阿里巴巴JAVA开发手册","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580529496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042753,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p6kkT7nsViayxazIrxx7p0pklPRvet933nEGBupj1phL2zArLStC3MnHFFyBYZ9fDGbPWJxS6WOICkxCCLia7nhw/132","nickname":"Qfxl","note":"","ucode":"4554F28BB10F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96770,"discussion_content":"十分同意，相互隔离才是正确的抽象封装方法，业务不复杂亦可适度混用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577092239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83780,"discussion_content":"这里说的DO，是domain object 还是 data object?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576463031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87116,"discussion_content":"domain object 是你自己发明的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576644887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83780,"ip_address":""},"score":87116,"extra":""},{"author":{"id":1560281,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ce/d9/e3fc735c.jpg","nickname":"leo","note":"","ucode":"AAF0F90D8A2481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222589,"discussion_content":"domain object是DDD里面领域对象的意思。DDD将对象划分为DTO（Data Transfer Object）数据传输对象，DO（Domain Object）领域对象和PO（Persist Object）持久层对象。不过这三个概念和MVC中的VO，BO和DO不是对应的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586160273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87116,"ip_address":""},"score":222589,"extra":""},{"author":{"id":2791308,"avatar":"","nickname":"Geek3425","note":"","ucode":"C7292D0AF11F43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402748,"discussion_content":"domain\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633942351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83780,"ip_address":""},"score":402748,"extra":""}]},{"author":{"id":1078280,"avatar":"https://static001.geekbang.org/account/avatar/00/10/74/08/aa2a9f36.jpg","nickname":"tomcat","note":"","ucode":"1929E1028414F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83777,"discussion_content":"“DO是具体的存储方式” -- 存储方式不是PO吗，这里为什么说是DO?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576462772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1498641,"avatar":"https://static001.geekbang.org/account/avatar/00/16/de/11/72f96304.jpg","nickname":"M.O(∩_∩)O","note":"","ucode":"B245C2BA20DDA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78975,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576040864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181867,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1582647792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18762516976","product_id":100039001,"comment_content":"通过将原始类以组合的方式注入到装饰器类中，以增强原始类的功能，而不是使用继承，避免维护复杂的继承关系。另外，装饰器类通常和原始类实现相同的接口，如果方法不需要增强，重新调用原始类的方法即可。<br>","like_count":4},{"had_liked":false,"id":290010,"user_name":"JoeyforJoy","can_delete":false,"product_type":"c1","uid":1466467,"ip_address":"","ucode":"5598501E71D35D","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/63/d2c91e2b.jpg","comment_is_top":false,"comment_ctime":1619320159,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14504222047","product_id":100039001,"comment_content":"代理模式和装饰器模式的区别要从类的调用者的角度来看。<br>对于代理模式，调用者不需要知道代理类中有哪些额外的功能模块，直接调用代理类即可。正如我们找别人“代理”办事一样，我不需要知道代理人为我们多做了哪些事，我们只关心我们交代的事情有没有办好。<br>而对于装饰器模式，调用者则需要知道装饰类提供的额外的功能，来满足定制化的服务。就好比买手机时的套餐服务，我们不仅关心手机的好坏，我们还关心提不提供保修、送不送充电器等额外的服务。<br>回过头来回答课后问题，对于类的设计者来说，如果设计者认为“缓存”功能对于调用者来说在任何时刻都是必要的，那么则选择代理模式；如果设计者认为“缓存”功能对调用者来说是可有可无的，希望调用者根据自己的需要来定制的，那么则选择装饰器模式","like_count":3,"discussions":[{"author":{"id":1160678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","nickname":"左耳朵东","note":"","ucode":"60134ACF12BB52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405672,"discussion_content":"那可以这样理解吗，比如去餐馆点餐，如果是代理模式，只提供一个套餐，我只能选择点或不点。如果是装饰模式，那就会拿到一份菜单，想吃什么点什么，想点几个点几个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634617142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234830,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1594805678,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14479707566","product_id":100039001,"comment_content":"读了第三遍了 , JAVA IO 用例才理解透 ~~","like_count":3,"discussions":[{"author":{"id":1620113,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b8/91/8a5c3ec6.jpg","nickname":"王一之","note":"","ucode":"7E13332BAEC2F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69861,"discussion_content":"可以有,不过有些评论(未回复的)还是很精彩的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575300131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60565,"discussion_content":"我也有","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574738388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1197722,"avatar":"https://static001.geekbang.org/account/avatar/00/12/46/9a/3b9062b5.jpg","nickname":"zxh","note":"","ucode":"8B4FEDA65B8187","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295165,"discussion_content":"你用 control+F 就可以实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596107486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016052,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/80/f4/d340dc44.jpg","nickname":"devin","note":"","ucode":"C9682026B6B1FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59871,"discussion_content":"赞，有同样的需求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574694791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182559,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1582809181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14467711069","product_id":100039001,"comment_content":"打卡 设计模式-装饰器模式<br>装饰器模式是一种类似于代理模式的结构型模式。主要意图是增强原始类的功能，可以实现多个功能的增强（即不同的功能单独一个类维护，使用该模式将其功能组合起来）。该模式主要是为了解决为了实现某些功能导致子类膨胀的问题。个人觉得主要体现了单一职责、组合优先于继承原则。主要应用场景有Java IO 流设计。但是有个疑惑，在Reader和Writer体系结构的设计中，并没有像InputStream和OutputStream那样设计一个过滤流类，而BufferedReader等直接继承了Reader。按照作者本文的分析，字符输入流直接跳过了使用中间类来继承的步骤，这样的设计又该如何理解？<br>对于课堂讨论，我觉得应该使用装饰器模式，因为“添加缓存”这个功能跟原始功能是由直接关系的。而代理模式所面向主要是将框架代码与业务代码解耦合。","like_count":3},{"had_liked":false,"id":247548,"user_name":"查理","can_delete":false,"product_type":"c1","uid":1111297,"ip_address":"","ucode":"A9FEA901E3A05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/01/5389295c.jpg","comment_is_top":false,"comment_ctime":1599738497,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"10189673089","product_id":100039001,"comment_content":"还是不太懂代理模式和装饰器模式的区别，感觉他们太像了，只不过人为规定，代理模式新增的是与原始类不相关的功能，装饰器模式是对原始功能的增强，但是他们在代码类结构上是相同的。","like_count":2,"discussions":[{"author":{"id":1609964,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","nickname":"拂尘","note":"","ucode":"9563C002E4B06A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57767,"discussion_content":"因为是面向抽象编程，如果不用工厂或者spring依赖注入的话，那么在new 对象的时候仍然会是面向实现，因为new肯定要new 实现类。组合应该就是使用类变量吧，然后委托就是将工作委托给类变量的对象方法实现，然后也是实现代码复用吧。所以spring依赖注入是帮助组合完全是面向接口抽象，脱离面向实现咯。以前是工厂现在在升级诶","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574642786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238051,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/23/ac13d916.jpg","nickname":"圆哥哥呐丶","note":"","ucode":"8E56E3E68A3836","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1609964,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","nickname":"拂尘","note":"","ucode":"9563C002E4B06A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58255,"discussion_content":"如果是类变量是组合的话， 那 容器变量属于组合吗，容器里面装的也是类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574662611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57767,"ip_address":""},"score":58255,"extra":""}]},{"author":{"id":1234314,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/8a/7050236a.jpg","nickname":"东征","note":"","ucode":"DC557A1631A493","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58138,"discussion_content":"我认为是组合的一种体现","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574654072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2373458,"avatar":"https://static001.geekbang.org/account/avatar/00/24/37/52/fdfe66a1.jpg","nickname":"小熊","note":"","ucode":"7DDDC76895C1D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352254,"discussion_content":"我也是这么觉得的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614665774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249981,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/bd/54987d4b.jpg","nickname":"vince","note":"","ucode":"90DC7EA30D34B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72572,"discussion_content":"+1赞，一看就有这种感觉！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575506073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60308,"discussion_content":"的确，我想的一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574726680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184319,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583289450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173224042","product_id":100039001,"comment_content":"关于思考题 我觉得首先还是总结一下 代理模式和装饰器模式的区别<br>代理模式 主要是外部增强功能<br>装饰器模式主要是内部增强功能<br>首先从i&#47;o来看  他增加缓存的目的在于 提高效率 避免 不停的内存和硬盘之间的切换 是增强了读取功能<br>而代理模式 可能增加缓存是为了检查或者验证 或者写日志查看操作内容 这种外部功能的话 就应该用代理模式","like_count":2},{"had_liked":false,"id":183569,"user_name":"嘿泥鳅","can_delete":false,"product_type":"c1","uid":1285186,"ip_address":"","ucode":"A22BDA7A6DA23E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/F5Srwp8IibOU9PDCDgmpdIZF9UXQZzfPKzNseHW5GR0WmusGfrkmzQ6wq32omW3uTtl8aXjkudYSA0NEmibxAcnw/132","comment_is_top":false,"comment_ctime":1583068211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173002803","product_id":100039001,"comment_content":"添加缓存这个功能与父类或者接口定义的功能无关应该使用代理模式。","like_count":2},{"had_liked":false,"id":181957,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582684406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172618998","product_id":100039001,"comment_content":"如果仅添加缓存一个功能, 使用Proxy好一些, 如果还有其他需求, 使用Decorator好一些.<br>如果让我选择的话, 我宁愿选择Decorator, 方便扩展, 符合开闭原则. ","like_count":2},{"had_liked":false,"id":181923,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1582680984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172615576","product_id":100039001,"comment_content":"如果只是需要对所有 对象的缓存功能进行增强（相当于缓存是新的功能了），则可以使用代理模式。<br>如果只是对某一类对象进行增强，而这类对象有共同的接口或父类，则可以使用装饰模式。","like_count":2},{"had_liked":false,"id":348131,"user_name":"Broadm","can_delete":false,"product_type":"c1","uid":1737886,"ip_address":"","ucode":"BEA06300731AE8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/9e/d4c0e2c4.jpg","comment_is_top":false,"comment_ctime":1654763336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5949730632","product_id":100039001,"comment_content":"感觉装饰器模式,更像是多重代理, 在一个代理的基础上,继续代理","like_count":1},{"had_liked":false,"id":239213,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1596460395,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5891427691","product_id":100039001,"comment_content":"关于BufferedInputStream为什么不能直接继承InputStream这个问题，我的理解是因为InputStream是抽象方法，继承他就得默认重写内部的抽象逻辑，而装饰器模式需要解决的最主要的问题是用任意组合的方式拼接业务的各个功能特性，这也就表示本身业务特性很多，业务特性之间的关联还比较弱（否则将关联度比较大的几个特性单独实现然后组合在InputStream中，然后直接替代FilterInputStream的角色即可），那么每个特性增强的子类都需要重写调用super.method，重复代码就会很多，所以这里就加了一个FilterInputStream装饰器父类，把需要重写调用的super.method方法在里面实现，具体的业务增强子类只需要继承FilterInputStream类，并编写自己的业务增强子类即可。同时，也没有打破所有实现类都是InputStream这个基础，也即依然可以实现多个组合嵌套，以最少的代码实现了最多特性的组合增强。<br>最后，说一下思考题，代理模式和装饰器模式两者在目的上没啥区别，都是对已有业务的一种增强，但前者是业务无关的独立的，而且增强的特性不多；后者是业务相关，增强特性支持更多；实现上，前者既可以基于继承，也可以基于接口，还能实现动态代理；后者只能基于抽象类的继承，且不太适合实现动态，因为没法动态增强业务相关的功能特性","like_count":1},{"had_liked":false,"id":214302,"user_name":"mike","can_delete":false,"product_type":"c1","uid":1326662,"ip_address":"","ucode":"AB330E7B88EF1C","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/46/0b888d5a.jpg","comment_is_top":false,"comment_ctime":1588705402,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883672698","product_id":100039001,"comment_content":"BufferedInputStream继承自InputStream，如果不override read方法，那么条用read（）时将调用继承自Inputstream的read方法，该方法操作的是this，而不是传入的InputStream对象is，故无法委托给is来完成相关的功能。是这样吗？","like_count":1,"discussions":[{"author":{"id":1012815,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/4f/7975c7ee.jpg","nickname":"胡敏And","note":"","ucode":"8FA14B27F47F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382042,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625383711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189070,"user_name":"Vivian","can_delete":false,"product_type":"c1","uid":1396208,"ip_address":"","ucode":"5A68E4C163195F","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/f0/ebff46af.jpg","comment_is_top":false,"comment_ctime":1584452755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879420051","product_id":100039001,"comment_content":"代理模式：用户不用关心和参与具体的实现细节，只想拿到增强后的最终结果，相对于用户是静态的增强。<br>装饰器模式：装饰器类和原始类都需要继承相同的类或者实现相同的接口，用户可以根据自己的配置决定使用怎样的增强功能，相对于用户是动态的增强。<br>🌰：对于“添加缓存”这个场景，如果需要添加的缓存是固定的，变化不多，可以用代理模式；如果缓存有多种类型且配置多变，应该采用装饰器模式。比如 mybatis 的二级缓存的配置，可以配置缓存的有效时长，缓存的淘汰策略：LRU&#47;FIFO，是否只读等。","like_count":1},{"had_liked":false,"id":188577,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1584370694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879337990","product_id":100039001,"comment_content":"代理模式和装饰器模式最主要的不同是意图不同。其次使用方式也不同。<br>课堂讨论题中，我们给接口添加缓存功能的时候，使用的是代理模式；给InputStream添加缓存读取功能的时候，则使用的是装饰器模式。<br>前者实际上是由框架处理的，也就是把缓存的事情代理给框架去处理了；而后者则还是由应用自己处理，应用调用方得到的是一个增强过的类。","like_count":1},{"had_liked":false,"id":187008,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1583988491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878955787","product_id":100039001,"comment_content":"用代理模式，因为：1、可以动态代理  2、装饰器支持嵌套，但是缓存场景也用不上嵌套，如果支持嵌套，有点过度设计了","like_count":1},{"had_liked":false,"id":186969,"user_name":"石仔","can_delete":false,"product_type":"c1","uid":1177921,"ip_address":"","ucode":"974E4604CE2213","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/41/411b1753.jpg","comment_is_top":false,"comment_ctime":1583980352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878947648","product_id":100039001,"comment_content":"缓存场景<br>代理模式:可以很好的做到解耦用户代码,做到无侵入.<br>装饰器模式:需要用户自己组合代码,非常的不方便.和业务代码混杂在一起.","like_count":1},{"had_liked":false,"id":186813,"user_name":"LiuHu","can_delete":false,"product_type":"c1","uid":1039768,"ip_address":"","ucode":"284E2025C554BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","comment_is_top":false,"comment_ctime":1583933150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878900446","product_id":100039001,"comment_content":"*  代理模式中，抽象使用接口更加合适，因为是为了附加功能，满足接口协议即可。<br>*  装饰器模式中， 抽象使用抽象类根据合适，因为是做强相关的功能增强，仍然是 is - a 的关系<br>*  上面的两个句话也可以反过来用，如果是为原始类附加不相关的功能，用代理模式；增加强相关的功能，增强出来的类和原始类仍能满足是 is - a 的关系，用装饰器模式","like_count":1},{"had_liked":false,"id":186415,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583842016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878809312","product_id":100039001,"comment_content":"对于这个问题,如果使用装饰器模式,是一种对于原有类的增强,而原有类原本没有缓存这个功能,应该是去增加这个功能,所以应该使用代理模式才对","like_count":1},{"had_liked":false,"id":186331,"user_name":"LT","can_delete":false,"product_type":"c1","uid":1147795,"ip_address":"","ucode":"4E902E1EFBB9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBV8Deuz0Ys4omVlErUvTeRLt7xYRPd8nxhSZ1C2Q9Nice7icHnndsHmyT3KBenxLGw7xghlDzfIuA/132","comment_is_top":false,"comment_ctime":1583826288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878793584","product_id":100039001,"comment_content":"装修模式就是unix下的管道操作，见下例：<br>[root@pekphicprd38677 ~]# df | grep tmpfs| awk &#39;{print $6}&#39;<br>&#47;dev<br>&#47;dev&#47;shm<br>&#47;run<br>&#47;sys&#47;fs&#47;cgroup<br>&#47;run&#47;user&#47;989<br>&#47;run&#47;user&#47;0","like_count":1},{"had_liked":false,"id":186330,"user_name":"LT","can_delete":false,"product_type":"c1","uid":1147795,"ip_address":"","ucode":"4E902E1EFBB9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBV8Deuz0Ys4omVlErUvTeRLt7xYRPd8nxhSZ1C2Q9Nice7icHnndsHmyT3KBenxLGw7xghlDzfIuA/132","comment_is_top":false,"comment_ctime":1583826235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878793531","product_id":100039001,"comment_content":"装修者模式就是linux下的管道操作","like_count":1},{"had_liked":false,"id":184441,"user_name":"Treasure","can_delete":false,"product_type":"c1","uid":1177602,"ip_address":"","ucode":"4211ECEB347C3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","comment_is_top":false,"comment_ctime":1583315585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878282881","product_id":100039001,"comment_content":"老师，代码中用的是哪个版本的jdk啊？","like_count":1},{"had_liked":false,"id":184090,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1583220847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878188143","product_id":100039001,"comment_content":"对于“添加缓存”这个应用场景来说，我们到底是该用代理模式还是装饰器模式呢？<br>应该使用代理模式.<br>添加缓存读取数据功能的核心功能还是读取数据,并没有语义功能上的增强,为了方便调用者调用建议使用代理模式,把性能提升的复杂逻辑封装起来.","like_count":1},{"had_liked":false,"id":183726,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1583120418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878087714","product_id":100039001,"comment_content":"我觉得代理和装饰器区别还是很明显的。更加值得讨论的是桥接模式和装饰器模式的区别。桥接模式也是和装饰器类似，先实现好接口，把具体功能委托给内部组合进去的类去做，这点和装饰器模式很像。然后这三中模式的代码结构基本一致，这个真的太容易让新手混淆得稀里糊涂的。。。。。","like_count":1},{"had_liked":false,"id":183321,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1582993528,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5877960824","product_id":100039001,"comment_content":"对于 “如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。”，我的理解是：<br><br>假设 BufferedInputStream 类直接继承 InputStream。<br><br>现在有一个场景，我们创建一个 FileInputStream 对象，且该类重写了父类 InputStream 的某个方法 f()。接着我们用 BufferedInputStream 类来修饰 FileInputStream 类，并且没有为加强功能而重写父类 InputStream 的 f() 方法。这时候我们执行的就是 InputStream 对象的 f() 方法，而不是 BufferedInputStream 的 f() 方法。因为我们使用的是组合（不是继承），f 方法中完全没有和 BufferedInputStream 相关的代码。","like_count":1,"discussions":[{"author":{"id":1591399,"avatar":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","nickname":"席席","note":"","ucode":"656377E29D4F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388577,"discussion_content":"你有没有试过你的理论，我试了一下，执行的不是inputStream的方法，而是FileInputStream 的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628839706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182141,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1582718211,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5877685507","product_id":100039001,"comment_content":"无需Override的方法也要重写的原因：<br>对输入输出流的处理最终都需要调用一个InputStream，而InputStream抽象类里面的每个方法不能通过“调用自身”来完成方法。","like_count":1,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289332,"discussion_content":"错了，InputStream有已实现的实例方法，真正原因是不重写的话无法对传入的被装饰者进行调用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594054726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351347,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1657714015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657714015","product_id":100039001,"comment_content":"代理模式是附加功能,  比如原有接口的监控,统计, 鉴权,限流, 事务, 幂等...","like_count":0},{"had_liked":false,"id":348686,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1655302989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655302989","product_id":100039001,"comment_content":"看你对缓存的理解，如果是你认为这个缓存是每个InputStream的必备的步骤，那就是加强封装的代理。但是你认为不是非必要的，同级别的何有如何对InputStream日志打印，加密等众多功能之一，那就是加强多态的装饰器。","like_count":0},{"had_liked":false,"id":346413,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1653117867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653117867","product_id":100039001,"comment_content":"装饰器是动态的给类实例添加功能，而不是扩展类。<br>代理对类的方法运行增加额外处理，但不对类的方法，属性做增减。<br>桥接是分离类的抽象和实现，提高类的抽象的扩展性，在抽象的扩展中，踢出实现，并且可以带来动态替换实现类的便捷","like_count":0},{"had_liked":false,"id":344831,"user_name":"Geek_06d056","can_delete":false,"product_type":"c1","uid":2888683,"ip_address":"","ucode":"3A1AD7A4E435BB","user_header":"","comment_is_top":false,"comment_ctime":1651815215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651815215","product_id":100039001,"comment_content":"全都是java，一开始还说什么不要局限在一种语言，结果全都是java","like_count":0},{"had_liked":false,"id":343629,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1650961195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650961195","product_id":100039001,"comment_content":"添加缓存做的是和原来无关的事情，所以要用代理模式。缓存读取是为了增加读取的速度，属于功能增强","like_count":0},{"had_liked":false,"id":340331,"user_name":"乔宏民","can_delete":false,"product_type":"c1","uid":2181661,"ip_address":"","ucode":"B6A9F971E9CC96","user_header":"https://static001.geekbang.org/account/avatar/00/21/4a/1d/3567f117.jpg","comment_is_top":false,"comment_ctime":1648747375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648747375","product_id":100039001,"comment_content":"我觉得的确没啥区别，还是叫法的区别吧，比如一个人可以有好多个昵称，不同的朋友圈或者平台使用不同的昵称，其实都是同一个人","like_count":0},{"had_liked":false,"id":334074,"user_name":"铲铲队","can_delete":false,"product_type":"c1","uid":1132569,"ip_address":"","ucode":"D16372C34B7AE3","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/19/14dd81d9.jpg","comment_is_top":false,"comment_ctime":1644728721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644728721","product_id":100039001,"comment_content":"1：代理模式是给某一个对象提供一个代理或者占位符，并由代理对象来控制对源对象的访问。代理和被代理对象之间的关系通常在编译时设置，当我们使用代理模式时，我们经常创建一个主题的实例放到代理类里，而使用的时候直接访问代理类就好了，客户端不感知被代理对象。代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。<br>2：装饰器是指：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。Decorator在运行时分配给主题，只知道主题的接口(应该就是指基类)。Decorator可以进行嵌套进行多次装饰。在使用的时候，通常将原始的对象作为参数传给Decorator的构造函数中","like_count":0},{"had_liked":false,"id":333004,"user_name":"徐志超-Klaus","can_delete":false,"product_type":"c1","uid":2343086,"ip_address":"","ucode":"CF26B39965F2A2","user_header":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","comment_is_top":false,"comment_ctime":1643951507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643951507","product_id":100039001,"comment_content":"代理模式增强更侧重于将某个功能与一批功能解耦，目的是遵循的是单一职责原则；而装饰器增强更侧重于将原始功能的增强的同时保证代码的灵活性和扩展性。","like_count":0},{"had_liked":false,"id":328899,"user_name":"白不吃","can_delete":false,"product_type":"c1","uid":1033578,"ip_address":"","ucode":"F019914D8819C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","comment_is_top":false,"comment_ctime":1640929505,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1640929505","product_id":100039001,"comment_content":"https:&#47;&#47;www.liaoxuefeng.com&#47;wiki&#47;1252599548343744&#47;1281319302594594","like_count":0},{"had_liked":false,"id":328104,"user_name":"idiot","can_delete":false,"product_type":"c1","uid":2526391,"ip_address":"","ucode":"D7A6E980B530B4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","comment_is_top":false,"comment_ctime":1640531666,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640531666","product_id":100039001,"comment_content":"这个装饰器和代理模式的区别确实没看出来。另外，另一个python课程里也有讲到装饰器，是作用在函数上而非类上的，@写法，通过闭包来在原函数上添加功能。直观上来说，这种加个@的方式更像是装饰，而主动构造proxy（A）的方式（这节课的讲解）更像代理。","like_count":0},{"had_liked":false,"id":327053,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1639888295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639888295","product_id":100039001,"comment_content":"非常棒","like_count":0},{"had_liked":false,"id":317883,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1635004205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635004205","product_id":100039001,"comment_content":"关于装饰器模式和代理模式的理解：比如要读取一个文件，装饰器模式做的就是快速的读取这个文件，而代理模式就可以是在读取文件的前后打印一下时间，看一下读取文件的时间。装饰器模式做的是增强读取文件这一方法的事，代理模式做的就比较杂七杂八了。装饰器模式中很好地体现了多态这一特性。二者都是基于组合的方式。","like_count":0},{"had_liked":false,"id":315014,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1633659184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633659184","product_id":100039001,"comment_content":"个人理解，从代理模式和装饰器模式的代码结构来看，两者唯一的不同，就是要应用的场景不同，场景不同，增强部分的代码也就不同，叫法也就不同（代理模式或者装饰器模式），所以核心就是理解要解决的问题，如果是类似统计，监控等与业务无关的逻辑，就用代理模式，业界代表就是Spring的切面编程。如果是对功能本身的增强，则用装饰器模式，业界代表就是IO库的实现。","like_count":0},{"had_liked":false,"id":314671,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1633318998,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1633318998","product_id":100039001,"comment_content":"添加缓存功能，增强逻辑不会很多，所以用代理模式就OK。","like_count":0},{"had_liked":false,"id":311623,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1049235,"ip_address":"","ucode":"D48077EBAD2E87","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/93/fed4baec.jpg","comment_is_top":false,"comment_ctime":1631347796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631347796","product_id":100039001,"comment_content":"关于课后思考题我是这样理解的：“添加缓存”是采用代理模式还是装饰器模式，主要取决于“添加缓存”这个动作是否和原始类（强）相关，以本文IO操作为例，缓存是对文件读取功能的增强，本质是服务于IO操作本身，所以可看成是对原始类相关功能的增强，适合使用装饰器模式；而对于客户端图片下载器来说，是否使用缓存图片跟下载功能本身无关，对于采用何种缓存策略？图片存储在什么位置？采用一级缓存或二级缓存都需要使用者自行定义，这种场景则更适合使用代理模式。","like_count":0},{"had_liked":false,"id":300874,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1625412481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625412481","product_id":100039001,"comment_content":"代理模式是1对多，比如我做了个日志打印代理，可以用到很多class上。装饰器模式上增强，多对多，我设置了很多增强装饰器，可以多个装饰器设置到多个class上，来增强其能力。<br>不对啊：我应该也可以设置多个代理，层层代理到class上，除了处理逻辑上的差别，这2种设计模式有什么区别呢","like_count":0},{"had_liked":false,"id":297852,"user_name":"zart","can_delete":false,"product_type":"c1","uid":1148637,"ip_address":"","ucode":"E32677C0FD4421","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eomCrCRrLAWib0gMI2L2NbicMummlxOY6nVmphsDO0J3xx7OygNd8wJicc88RbNoHrcuXBsKLtCMvgFQ/132","comment_is_top":false,"comment_ctime":1623813519,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623813519","product_id":100039001,"comment_content":"代理模式VS装饰器模式：两者都基于组合实现。代理模式更侧重于提供固定但多样的功能；装饰者模式更侧重于提供扩展功能。","like_count":0},{"had_liked":false,"id":289178,"user_name":"Geek_92d619","can_delete":false,"product_type":"c1","uid":2019655,"ip_address":"","ucode":"BE0E322B9178E6","user_header":"","comment_is_top":false,"comment_ctime":1618904279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618904279","product_id":100039001,"comment_content":"代理模式：<br>       1、我个人觉得本质上和继承一样的，就是个动态的继承。它有着继承有的优点，也有着它的缺点，比如扩展不够灵活，层次可能过多。<br>       2、但是它有继承没有的优点，更好地隔离被代理类，同时可以避免重复代码，可以对不同的子类实现使用同一份代码来实现相同的增强，可以认为是一种动态的继承。<br>       3、所以它也有着继承的问题，比如一个功能，有 n 中增强，而且每种增强又可能相互组合，那就需要有 2^n 个代理逻辑要实现。<br><br>装饰器：<br>      1、通过组合来达到 “半继承”，相当于继承的“手动挡”，每个装饰器都只添加一个增强功能，至于用户最后要达到什么效果，自己组装上去，最终组装成一个你需要的“完全继承的子类”。<br>      2、好处就是 有 n 种 功能要增强，你只需要提供 n 个装饰器即可。<br><br>最后：代理模式 + 组合 或者 代理模式 + 责任链 是不是也能达到装饰器的效果呢？<br>ps：纯粹个人理解","like_count":0},{"had_liked":false,"id":288242,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618377379,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618377379","product_id":100039001,"comment_content":"代理模式：业务无关，用户无感知<br>装饰器模式：业务相关，用户可选择","like_count":0},{"had_liked":false,"id":288062,"user_name":"Windqiu","can_delete":false,"product_type":"c1","uid":2278659,"ip_address":"","ucode":"EF78D3CF73BCBB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/TUMtkaIMdbFDS28AhjrQcqOhiapNvHyPMApz9QoZZkShZmomJRh6GX2aL2YeSMg4SicdydzdWxXZOZz49HNS9EtA/132","comment_is_top":false,"comment_ctime":1618283572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618283572","product_id":100039001,"comment_content":" * 装饰器设计思想解读<br> * 1、有共同的父类，有共同的实现方法<br> * 2、抽象父类&#47;方法不需要具体实现<br> * 3、套娃式初始化，并实现对应的共同实现方法，解决需要的问题(与代理模式很相似，但是本质不同)","like_count":0,"discussions":[{"author":{"id":1139367,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","nickname":"K战神","note":"","ucode":"527E6BB26BB766","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322024,"discussion_content":"同意，职责不一样，为了复用而进行聚合抽离，我觉得和你的想发一样，各自保持自己的独立性，一个类，只能有一个影响点，独立更好。\n\n不是所有的代码重复，就要消除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604664099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284939,"user_name":"刘章","can_delete":false,"product_type":"c1","uid":1009693,"ip_address":"","ucode":"7608C518D49AE4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLxEbhSEziblPNVkr9XFIAzPCib0TQvBxHYwiaKiaib7ExZ8dmUWyqWoibSedACTHCf52INMib80ic92G6wQ/132","comment_is_top":false,"comment_ctime":1616551771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616551771","product_id":100039001,"comment_content":"FilterInputStream extends InputStream 这个 FilterInputStream 感觉用了代理 和装饰的模式","like_count":0},{"had_liked":false,"id":284216,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1616124107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616124107","product_id":100039001,"comment_content":"课后问题<br>代理模式、装饰器模式<br>我觉得主要看业务场景，代理模式是不用改原先的逻辑来做功能的扩展，<br>装饰器是对对功能的增强，意味者要改动原先的代码，耦合度更高。<br>增加缓存功能是增加读取功能的速度，我觉得用装饰器比较合适<br>","like_count":0},{"had_liked":false,"id":281287,"user_name":"snake","can_delete":false,"product_type":"c1","uid":2347137,"ip_address":"","ucode":"47BFFE4D048156","user_header":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","comment_is_top":false,"comment_ctime":1614675756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614675756","product_id":100039001,"comment_content":"我觉得添加缓存还是使用代理模式好一点，因为这个功能跟接口的逻辑功能是无关的","like_count":0},{"had_liked":false,"id":279537,"user_name":"null","can_delete":false,"product_type":"c1","uid":1192719,"ip_address":"","ucode":"4C6D43260E5546","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/0f/85250526.jpg","comment_is_top":false,"comment_ctime":1613813221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613813221","product_id":100039001,"comment_content":"避免类数量膨胀，引入装饰器模式。","like_count":0},{"had_liked":false,"id":277117,"user_name":"小白","can_delete":false,"product_type":"c1","uid":2314948,"ip_address":"","ucode":"ED798245A9B0CA","user_header":"","comment_is_top":false,"comment_ctime":1612263754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612263754","product_id":100039001,"comment_content":"举一个装饰器模式的应用场景加深理解:<br>比如现在需要设计一个SDK对外提供一组数据，用户需要对这组数据进行不同的操作（比如排序，删选，过滤等等），前提是我们不知道用户该如何操作这组数据，为了方便操作，这里就可以用装饰器模式，每种操作我们可以定义一个装饰器类，用户通过不同的组合最终达到需要的数据，同时用户也可以继承接口实现自定义的装饰器","like_count":0},{"had_liked":false,"id":274107,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1610855557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610855557","product_id":100039001,"comment_content":"实际区分二者的关系还是得从原始功能来看， 如果添加的功能和原始功能无关的就是代理，如果贴近的就是装饰器。","like_count":0},{"had_liked":false,"id":273419,"user_name":"Song╮承諾","can_delete":false,"product_type":"c1","uid":1590793,"ip_address":"","ucode":"50FDBFE5BDDD12","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/09/c61257f6.jpg","comment_is_top":false,"comment_ctime":1610592367,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610592367","product_id":100039001,"comment_content":"public interface IDecorator {<br>    void decorator();<br>}<br>public class decoratorA implements IDecorator{<br>    public void decorator() {<br><br>    }<br>}<br>public class decoratorB implements IDecorator{<br>    public void decorator() {<br><br>    }<br>}<br>public class example {<br>    private List&lt;IDecorator&gt; decorators = new ArrayList&lt;IDecorator&gt;();<br><br>    public void setDecorators(IDecorator iDecorator){<br>        decorators.add(iDecorator);<br>    }<br><br>    public void run(){<br>        if (decorators.size() &gt; 0){<br>            for (IDecorator iDecorator : decorators){<br>                iDecorator.decorator();<br>            }<br>        }<br>        &#47;&#47; run something<br>    }<br>}<br><br>Example e = new example();<br>e.setDecorators(new decoratorA);<br>e.setDecorators(new decoratorB);<br>e.run()","like_count":0},{"had_liked":false,"id":271009,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1609349234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609349234","product_id":100039001,"comment_content":"装饰器模式注重结果，代理模式注重过程。","like_count":0},{"had_liked":false,"id":270691,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1609218407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609218407","product_id":100039001,"comment_content":"思考题：添加缓存这个应用场景使用哪种模式，要看设计的意图，如果我们的目的是对计算结果进行缓存，避免重复计算，由于我们不改变计算过程本身，属于代理模式。如果我们的目的是提高计算的效率，通过使用缓冲区来优化计算过程，则属于装饰器模式。<br>换句话说，装饰器模式只是增强，但不影响最终结果，但代理模式则附加额外功能，对结果造成影响。<br>","like_count":0},{"had_liked":false,"id":270465,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1609139368,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609139368","product_id":100039001,"comment_content":"代理模式无侵入的增加跟业务无关功能。<br>装饰器模式增强原类，与业务相关。","like_count":0},{"had_liked":false,"id":269742,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1608775309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608775309","product_id":100039001,"comment_content":"特别形象！装饰器拿到原始对象，装饰原始对象，使得原始对象有新的功能，是一种扩展的解决方案。<br>为什么不直接使用继承呢？如果继承关系简单，当然用继承，但这里的例子(Java IO)继承关系太复杂了，可能会导致继承爆炸，复杂度指数上升，最后导致难以维护。<br>继承和组合都是代码复用的解决方案，而组合又是“继承复杂度”问题的解决方案。<br>不得不说，这里又和代理模式太像了，期待明天的区分他们的区别。","like_count":0},{"had_liked":false,"id":268230,"user_name":"席席","can_delete":false,"product_type":"c1","uid":1591399,"ip_address":"","ucode":"656377E29D4F76","user_header":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","comment_is_top":false,"comment_ctime":1608107616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608107616","product_id":100039001,"comment_content":"王老师，我想问一下，装饰器模式和代理模式，既然代码结构非常相似，那么他们的区别仅仅是业务逻辑上的？代码增强以及附加与原始类功能不同的代码。","like_count":0},{"had_liked":false,"id":267255,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607660883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607660883","product_id":100039001,"comment_content":"打卡：用Java实现了文件IO操作的Demo。","like_count":0},{"had_liked":false,"id":266747,"user_name":"Rock_wang_1988","can_delete":false,"product_type":"c1","uid":2041310,"ip_address":"","ucode":"0E61D1F959B4D3","user_header":"","comment_is_top":false,"comment_ctime":1607478312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607478312","product_id":100039001,"comment_content":"文中代理模式和装饰者模式对比的代码，没有不同啊老师？","like_count":0},{"had_liked":false,"id":258341,"user_name":"别","can_delete":false,"product_type":"c1","uid":1363054,"ip_address":"","ucode":"D806471DA0EDD9","user_header":"https://static001.geekbang.org/account/avatar/00/14/cc/6e/c3c9ea88.jpg","comment_is_top":false,"comment_ctime":1604391010,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604391010","product_id":100039001,"comment_content":"关于两者的代码实现上，我觉得对于调用者来说，代理模式中的代理应该是隐式的，而装饰器模中的装饰器是显示的。","like_count":0},{"had_liked":false,"id":258267,"user_name":"Sic Pavis","can_delete":false,"product_type":"c1","uid":1106088,"ip_address":"","ucode":"48B5F0118347C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","comment_is_top":false,"comment_ctime":1604365575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604365575","product_id":100039001,"comment_content":"判断代理还是装饰器核心问题就是判断要增加的功能和目标类本身功能有没有联系。创建用户的类想加个日志，日志本身和创建用户没关系，所以用代理。 文末说的加缓存，缓存目的是优化性能，属于原功能增强，所以用装饰器","like_count":0},{"had_liked":false,"id":253554,"user_name":"Jimmy.Hum","can_delete":false,"product_type":"c1","uid":1429055,"ip_address":"","ucode":"438006AC6F34CB","user_header":"https://static001.geekbang.org/account/avatar/00/15/ce/3f/3bbe6532.jpg","comment_is_top":false,"comment_ctime":1602774590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602774590","product_id":100039001,"comment_content":"关于为什么要重写inputStream的默认实现，即便只是调用inputStream的方法，是因为有可能会多次装饰，如果只装饰一次，例如只做了缓存装饰，那除了缓存的函数需要重写其他的用默认的就可以，但如果装饰完缓存，又装饰了基本数据类型，再没用重写的情况下调用时继承来的缓存函数，即没有起到增强缓存的作用。","like_count":0},{"had_liked":false,"id":250310,"user_name":"王大喵","can_delete":false,"product_type":"c1","uid":1109528,"ip_address":"","ucode":"C14AAE3ED964DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","comment_is_top":false,"comment_ctime":1601020316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601020316","product_id":100039001,"comment_content":"想到之前业务方吐槽accesslog中间件不能满足其需求，展示的信息不够全面。其实accesslog并不是针对某个业务方定制的，而是一个业务无关的中间件；如果业务方需要更加完善的log，可以通过装饰器来进行定制。","like_count":0},{"had_liked":false,"id":248339,"user_name":"叉歪叉","can_delete":false,"product_type":"c1","uid":1071601,"ip_address":"","ucode":"2C1AFC6335FF0E","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/f1/8909b9e0.jpg","comment_is_top":false,"comment_ctime":1600130280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600130280","product_id":100039001,"comment_content":"如果这个接口有的场景要缓存，同时还有其他场景要其他增强，就用装饰。如果只有缓存场景，那可以认为装饰和代理是一回事啊。不知道对不对","like_count":0},{"had_liked":false,"id":243566,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1598187954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598187954","product_id":100039001,"comment_content":"我觉得两者实现起来既然很像，其实就没必要区分了。对这两条设计模式的区分本身就违反了关注抽象忽略细节的原则。这条设计模式中，方法拦截是它的抽象，拦截之后是增强还是做其他业务无关逻辑这是细节。","like_count":0},{"had_liked":false,"id":240207,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596788044,"is_pvip":false,"replies":[{"id":"89264","content":"主要看应用场景","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597453573,"ip_address":"","comment_id":240207,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596788044","product_id":100039001,"comment_content":"有个疑问 既然代码结构是一样的  那在于怎么叫了  我可以叫做代理模式 也可以叫做装饰器模式？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479647,"discussion_content":"可以的 等后面有时间了吧 年底比较忙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380984,"discussion_content":"好像没有找到答疑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624853267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233782,"user_name":"Giacomo","can_delete":false,"product_type":"c1","uid":1478055,"ip_address":"","ucode":"BE5B1E68BCDBB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","comment_is_top":false,"comment_ctime":1594449072,"is_pvip":false,"replies":[{"id":"86365","content":"你的意思是，定义很多不同的interface对吧。这样也可以，但用起来就没有现在的好用了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594598958,"ip_address":"","comment_id":233782,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1594449072","product_id":100039001,"comment_content":"能不能把BufferedInputStream这些可以叠加的功能做成interface，然后定义一些内部的类","like_count":0,"discussions":[{"author":{"id":2730834,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ab/52/7da45fc4.jpg","nickname":"Lancer","note":"","ucode":"6F0D2FBA72E69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394407,"discussion_content":"这个叫 “jiaoable”着实把我逗笑了~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631869972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297921,"discussion_content":"还有麻雀也会下蛋","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597111038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242122,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","nickname":"YourSweetHeart","note":"","ucode":"38843F447B03F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62540,"discussion_content":"😂😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574850482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232225,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593930079,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593930079","product_id":100039001,"comment_content":"装饰者解决多个水功能维度的功能扩展问题，如果只是使用继承则会出现继承暴炸问题<br>包含角色：被装饰者，装饰者<br>如io中，被装饰者包含：InputStream，装饰者实现了InputStream，可以有n个装饰者<br>而具体由于每个装饰者都需要实现inputStream所有接口方法，所以为了方便性才抽出一个装饰者父类FilterInputStream","like_count":0},{"had_liked":false,"id":231491,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593687289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593687289","product_id":100039001,"comment_content":"缓存用代理还是装饰？<br>二者都是对方法进行扩展，所以本质要考虑怎么对方法进行扩展，如果对方法的扩展，只是在该方法前后增加逻辑，这部分增加的逻辑对方法本身没有丝毫影响，加不加这部分逻辑，该方法执行结果一样，那就用代理；<br>相反，如果增加的逻辑，会影响这个方法的执行结果，就用装饰；<br>缓存这个东西，对原方法的执行是没影响的，你加不加缓存，也就是走不走缓存，原先的方法该怎么执行还是怎么执行，所以个人认为用代理较好；<br>其实仔细想下，不管代理还是装饰，在这个增加缓存功能上，代码基本是一样的，只是名字不一样，名字不一样，就是让你知道扩展的意图。你可以叫他代理，也可以叫装饰。","like_count":0},{"had_liked":false,"id":231486,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593686468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593686468","product_id":100039001,"comment_content":"如何理解FilterInputStream，为什么继承这个类？个人感觉老师应该用接口和实现的方式来讲好理解；<br>如果对类中的某个方式进行扩展，用装饰模式，可以用装饰类实现这个被扩展类实现的接口，进行功能扩展，但是需求是只需要扩展一个方法，但是实现接口需要的是把接口中的所有接口都实现，否则语法 都通不过，现实中，有的接口中方法上百个，这样扩展必定带来很多麻烦。<br>所以java中，还有很多模板类，以 Template结尾命名的类，之前见过，但是忘记是啥类了，这里的模板类就是实现了接口的类，这里模板类似FilterInputStream ，如果扩展功能，只在这个模板类上扩展；避免实现其他不需要扩展的方法；","like_count":0},{"had_liked":false,"id":230711,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1593476093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593476093","product_id":100039001,"comment_content":"终于明白代理模式和装饰模式的区别了，感谢老师！<br>1. 装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。<br>2. 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。<br>3. 装饰器与代理模式的区别：代理模式中，代理类附加的是跟原始类**无关**的功能，而在装饰器模式中，装饰器类附加的是跟原始类**相关**的增强功能。<br>4. 装饰器主要的作用是给原始类添加增强功能。<br>5. 装饰器可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。","like_count":0},{"had_liked":false,"id":230386,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593358664,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593358664","product_id":100039001,"comment_content":"代理模式用来添加和原有功能不相关的功能增强，装饰者模式用来添加和原有功能相关的功能增强。意图不一样。所以思考题应该选择装饰者模式更加合适。","like_count":0},{"had_liked":false,"id":227163,"user_name":"李德政","can_delete":false,"product_type":"c1","uid":1023885,"ip_address":"","ucode":"3AC49F5671485C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/8d/d725d32c.jpg","comment_is_top":false,"comment_ctime":1592301602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592301602","product_id":100039001,"comment_content":"在Python里面，一般用装饰器来实现缓存和打印日志的功能。<br>不管是代理模式还是装饰器模式，最终的目的就是将业务和不相关的逻辑解耦，让代码更加清晰、可读。","like_count":0},{"had_liked":false,"id":226353,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592045103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592045103","product_id":100039001,"comment_content":"感觉可以这样理解：代理模式和装饰器模式，从代码结构上是看不出区别的，而是看实际的业务。如果添加的是和原始类无关的功能，就是代理模式；如果添加的是和原始类相关的增强功能，那么就是装饰器模式<br>","like_count":0},{"had_liked":false,"id":224001,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1591253583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591253583","product_id":100039001,"comment_content":"为什么BufferedReader没有使用FilterReader 呢？","like_count":0},{"had_liked":false,"id":222015,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1590656615,"is_pvip":false,"replies":[{"id":"86256","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594388467,"ip_address":"","comment_id":222015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590656615","product_id":100039001,"comment_content":"按照本节讲的内容, java io例子里<br>原始类: InputStream<br>共同父类: FileInputStream<br>装饰器类: BufferedInputStream ,  DataInputStream<br>是这关系吗 ? 因为InputStream本身是FileInputStream的父类 有点绕来着 . ","like_count":0,"discussions":[{"author":{"id":1190085,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/c5/3a880251.jpg","nickname":"李鑫|MT","note":"","ucode":"D9985A7D2EC2FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57903,"discussion_content":"不太可行吧，Entity的代码多数都是根据表结构自动生成的，怎么抽取？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574645927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1132337,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","nickname":"小晏子","note":"","ucode":"3AAA6FB5ACB6AE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1190085,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/c5/3a880251.jpg","nickname":"李鑫|MT","note":"","ucode":"D9985A7D2EC2FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58551,"discussion_content":"VO BO里面应该有字段跟entity名字一样的吧 就把那些抽出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574680725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57903,"ip_address":""},"score":58551,"extra":""}]}]},{"had_liked":false,"id":221993,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1590651880,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590651880","product_id":100039001,"comment_content":" 代理模式除了给增加新的功能点之外还可以将业务和非业务功能区分开来。装饰着模式的缓存工作还是在其正常功能之上增加新的功能，功能属于同一个范畴。<br>","like_count":0},{"had_liked":false,"id":220508,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1590252806,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1590252806","product_id":100039001,"comment_content":"设计模式真的是一个很玄乎的一个东西，越看越感觉高深，越来越懵","like_count":0},{"had_liked":false,"id":219962,"user_name":"荒川之主","can_delete":false,"product_type":"c1","uid":2000330,"ip_address":"","ucode":"12724B4B37BEB5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/85/ca/e6003d08.jpg","comment_is_top":false,"comment_ctime":1590126254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590126254","product_id":100039001,"comment_content":"有时候我们会创建了多层子类，但如果当子类层数超过三层，一般来说不太建议，这个时候可以考虑使用装饰器模式。","like_count":0},{"had_liked":false,"id":219655,"user_name":"foree","can_delete":false,"product_type":"c1","uid":1600599,"ip_address":"","ucode":"D1F053C369D656","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/57/bb5885d1.jpg","comment_is_top":false,"comment_ctime":1590056979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590056979","product_id":100039001,"comment_content":"这篇文章最大的疑惑点在于为什么要有FilterInputStream？<br>从装饰者模式的角度来看，每个装饰者方法内部一定要调用要装饰对象的方法，也就是代理装饰对象的方法，这样多个装饰对象嵌套时，就会出现类似链式的调用，如果某个方法没有这么做，那么就会出现链式中断，导致前边嵌套的装饰者无法被调用到<br><br>从BufferedInputStream看，其实直接继承 InputStream 也是可以的，只不过上述的原则一定要满足， 也就是装饰的那几个方法一定要调用被装饰者的方法，<br>实际来看，BufferedInputStream 复写了除read(byte[])之外的所有方法，而其他的方法也从各个角度调用了被装饰对象的方法（有个getInIfOpen方法可以拿到被装饰的input流）从这个角度来说，FilterInputStream可有可无<br><br>装饰者模式关键在于多个装饰者嵌套时，能否实现链式递归调用","like_count":0},{"had_liked":false,"id":216048,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1589173986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589173986","product_id":100039001,"comment_content":"总结：<br><br>1、装饰模式，是对一个核心功能的不断增强，无论如何装饰但初心不改，感觉有点李氏替换原则的感觉。被装饰的对象的类型是具体的，确定的，是某个接口的实现类或者某个类的子类，实际上是先有原始类，之后才有装饰类。<br><br>2、动态代理：关注的是代理类自身的逻辑，不关心原始类是什么，也就是：我不要你要，我要我要。<br><br>如果强行让代理类和装饰类一样，也对某个确定核心功能进行增强，比如<br><br><br><br>","like_count":0},{"had_liked":false,"id":212688,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1588175625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588175625","product_id":100039001,"comment_content":"读争哥的文章，我总是读的特别慢，仔细体会，收益良多，其实基于代理模式实现有spring cache. 但有时候同时需要缓存和不查缓存的功能，装饰器模式最佳","like_count":0},{"had_liked":false,"id":212525,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1588141669,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588141669","product_id":100039001,"comment_content":"隔离垂直划分的不同功能，达到类指责单一，代理。<br>装饰器主要解决继承类爆炸、增强类功能。<br>至于跟桥接对比，其实解决的问题都是继承的类爆炸。<br>但是桥接本身类的延伸拓展不稳定，可能有多个维度任意拓展，而装饰器本身类的拓展是稳定的维度，只不过是不断增强类的功能。<br>","like_count":0},{"had_liked":false,"id":205648,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1586695204,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586695204","product_id":100039001,"comment_content":"java io利用了装饰器，模式，解决了按需增强的问题，这点是不是与netty的ChannelInboundHandler，ChannelOutboundHandler有异曲同工之妙呢？netty也是对功能的增强，引入一个父类，对相关的方法，默认实现，这样，其他的类就可以按需去增强相关的功能了。","like_count":0},{"had_liked":false,"id":205443,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1586618652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586618652","product_id":100039001,"comment_content":"<br>对于添加缓存，肯定是动态代理呀，静态模式pass掉。<br>一路学习过来，我的理解是：<br><br>动态代理，是对很多的方法的“增强”的抽象，强调的是一类方法。<br><br>装饰者模式，它也是“增强”的抽象，但它更强调于对于一个接口，不同“增强”的抽象。<br><br>我觉得光凭实现是很难看出设计模式之间的差别的，因为设计模式本就是一种设计代码的思路，你怎么实现那是你自己的事情。<br><br>重视它门之间的区别就好了。","like_count":0,"discussions":[{"author":{"id":1188524,"avatar":"https://static001.geekbang.org/account/avatar/00/12/22/ac/fc8e435a.jpg","nickname":"郭凯强","note":"","ucode":"002F58C3640560","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57645,"discussion_content":"……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574639129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203213,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1586157022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586157022","product_id":100039001,"comment_content":"&quot;对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。这一部分稍微有点不好理解，你自己多思考一下&quot; 这一段没搞明白老师？为啥 子类不能调用父类的方法呢？","like_count":0},{"had_liked":false,"id":200726,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1585643939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585643939","product_id":100039001,"comment_content":"添加缓存读取数据功能是属于附加功能还是增强功能？","like_count":0},{"had_liked":false,"id":196339,"user_name":"云韵","can_delete":false,"product_type":"c1","uid":1025622,"ip_address":"","ucode":"3DE26DBAAAEDE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1585274078,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1585274078","product_id":100039001,"comment_content":"“对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。”这几句还是不太明白，希望争哥再详细讲解一下😊","like_count":0},{"had_liked":false,"id":196324,"user_name":"L","can_delete":false,"product_type":"c1","uid":1024906,"ip_address":"","ucode":"EDA19E20BE3B81","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8a/b8b6ef13.jpg","comment_is_top":false,"comment_ctime":1585272627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585272627","product_id":100039001,"comment_content":"代理模式更适合于层级比较少的扩展，如果层级多的话，就跟文章中刚开始提到的用继承来实现扩展的方式差不多了，会造成类关系比较复杂。<br>装饰模式是对代理模式的扩展，每个装饰器都是一个代理类，并且可以自由组合使用。<br>所以增加缓存使用代理模式，如果还有多种扩展需求，并且这些扩展又有多种组合方式，这时就可以用装饰模式来实现。","like_count":0},{"had_liked":false,"id":195157,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1585142056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585142056","product_id":100039001,"comment_content":"“装饰”这个词就有装饰类和原类是相同类型的意思，装饰，就以为着没有改变功能的本质，只是“装饰”一下。既然如此，装饰类可以当做另外一个装饰类的“原类”，这样就可以层层嵌套了。","like_count":0},{"had_liked":false,"id":194925,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1585121215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585121215","product_id":100039001,"comment_content":"代理模式是处理一些与功能性无关的业务,而对于添加缓存是一种功能的增强行为,应该使用装饰器模式,并且增强是可以多层叠加增强的,代理不能搞很多层代理,会乱","like_count":0},{"had_liked":false,"id":194761,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1181486,"ip_address":"","ucode":"E82C58AF2604ED","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","comment_is_top":false,"comment_ctime":1585103884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585103884","product_id":100039001,"comment_content":"看着文章，自己也写了一个简单的装饰器模式。总算知道IO类干嘛要这样做了。果然学懂了设计模式，看源码都简单一点。","like_count":0},{"had_liked":false,"id":191954,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1584805387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584805387","product_id":100039001,"comment_content":"为什么java不设计成readStream和writeStream，input和output初学的时候一脸懵逼","like_count":0},{"had_liked":false,"id":190729,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1584687837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584687837","product_id":100039001,"comment_content":"FilterInputStream 这个设计很巧妙哈","like_count":0},{"had_liked":false,"id":189798,"user_name":"小洛","can_delete":false,"product_type":"c1","uid":1005062,"ip_address":"","ucode":"227EC21891012B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/06/ea49b29d.jpg","comment_is_top":false,"comment_ctime":1584552211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584552211","product_id":100039001,"comment_content":"请教您一个问题：在Reader和Writer体系结构的设计中，并没有像InputStream和OutputStream那样设计一个过滤流类，而BufferedReader直接继承了Reader ，这里的设计原因？","like_count":0},{"had_liked":false,"id":184073,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1583218356,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583218356","product_id":100039001,"comment_content":"Mark一下.  <br>如果是该接口or抽象类的实现类都要进行读取缓存, 那么就用代理模式 (通用),<br>如果是某一个的话,那么就对对该对象单独进行功能增强, 使用装饰器模式.(特例)","like_count":0},{"had_liked":false,"id":183489,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1583050801,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583050801","product_id":100039001,"comment_content":"通过组合的方式实现代理，代理本身的业务和被代理类不想关。通过组合的方式实现装饰器，要做到被装饰的对象能力不断增强，但增强的能力一定是对被装饰对象业务相关。。","like_count":0},{"had_liked":false,"id":183419,"user_name":"柏油","can_delete":false,"product_type":"c1","uid":1604468,"ip_address":"","ucode":"92BFEEEE8BBFA0","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/74/9b88e040.jpg","comment_is_top":false,"comment_ctime":1583035764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583035764","product_id":100039001,"comment_content":"个人理解装饰者模式解决了一揽子实现之间的任意组合关系以达到具体想要的效果，这种设计避免了继承层次深结构混乱等问题，是多态的一大应用","like_count":0},{"had_liked":false,"id":183348,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1583026112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583026112","product_id":100039001,"comment_content":"一、定义：<br>对现有的类对象进行包裹和封装，以期望在不改变类对象及其类定义的情况下，为对象添加额外功能。<br><br>二、使用场景：<br>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。需要动态的为同一类的不同对象加以修饰以添加新的功能。<br><br>三、实现方式：<br>1）实现一个装饰器类，原始类对象通过依赖注入到装饰器类中，在装饰类中进行功能增强；<br>2）装饰器类和原始类继承相同的接口或是抽象类，这样可以对原始类嵌套多个装饰器（JAVA IO）；<br><br>四、 装饰器模式和代理模式的区别<br>对于是设计成或是称作为装饰器还是代理模式，需要看设计的意图。如果需要设计成在原始类上的功能对用户隐藏，那也就是说用户只能看到和使用代理类，那么就使用proxy模式；反之需要用户自己新建原始对象，选择需不需要使用新增功能，就使用装饰器模式。","like_count":0},{"had_liked":false,"id":182521,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1582801255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582801255","product_id":100039001,"comment_content":"请问老师适配器模式和装饰器模式一样吗？有何本质不同？","like_count":0},{"had_liked":false,"id":182275,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1582758110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582758110","product_id":100039001,"comment_content":"装饰器模式和代理模式结构完全一样，这个对？如果真的一样，无论选择哪个都可以，只是说附加功能区分类别不一样，与原始类无关或者有关，人为区分不一样，其实本质是一样。可以这样理解？勇接口实现是一样的，结构代码","like_count":0},{"had_liked":false,"id":182219,"user_name":"Boogie 捷","can_delete":false,"product_type":"c1","uid":1541552,"ip_address":"","ucode":"9F54EF69CC0106","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/b0/496ae224.jpg","comment_is_top":false,"comment_ctime":1582730090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582730090","product_id":100039001,"comment_content":"介于JAVA8可以支持default method 了，设计decorate pattern 的时候可以把 最底层的abstract 类（比如文中的InputStream）换成 interface 么？","like_count":0},{"had_liked":false,"id":182209,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1582729172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582729172","product_id":100039001,"comment_content":"打卡  白天在家办公<br>晚上来着精华","like_count":0},{"had_liked":false,"id":182196,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1582727519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582727519","product_id":100039001,"comment_content":"老师讲的很好啊😁这回知道应用场景了","like_count":0},{"had_liked":false,"id":182163,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1582723808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582723808","product_id":100039001,"comment_content":"因为inputstream里的方法有些是抽象的，还没实现。所以需要一个fileinputstream来实现抽象方法。这样bufferedinputstream只要继承需要装饰的方法","like_count":0},{"had_liked":false,"id":182151,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1582721078,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582721078","product_id":100039001,"comment_content":"装饰者模式：不创建对象，给已有对象新增功能。<br>代理模式：控制对象访问，创建了新的对象。通常实现框架级别的缓存。<br><br>代理模式现实生活中，让我想起了申请专利的代理。你写好技术交底书，专利代理人员帮你写申请材料，帮你交专利申请。<br>装饰者模式相当于产品定制服务。例如我买了一台自行车（有基本功能），要给自行车配自己喜欢的配件（装饰）。","like_count":0},{"had_liked":false,"id":181988,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1582688010,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582688010","product_id":100039001,"comment_content":"对于“添加缓存”这个应用场景来说，如果是给无关类也增加缓存功能，使用代理模式，做一个通用型的缓存。如果考虑到被增强类方法契约兼容性和一至性需要使用装饰器模式。","like_count":0},{"had_liked":false,"id":181899,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1582675786,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"1582675786","product_id":100039001,"comment_content":"如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。<br><br>这个地方不是很理解，即使加了FliterInputStream 之后，对于不要增强的，调用父类实现就好了，与直接继承InputStream区别在哪呢？","like_count":0}]}