{"id":720128,"title":"03｜所有权（下）：Rust中借用与引用的规则是怎样的？","content":"<p>你好，我是Mike。今天我们继续探讨Rust中所有权这一关键设计。</p><p>上节课我们了解了计算机内存结构知识，理解了Rust在内存资源管理上特立独行的设计——所有权，也知道了Rust准备采用所有权来重构整个软件体系。那么这节课我们继续学习所有权的相关内容——借用与引用，学完这节课我们就会对Rust语言的所有权方案有一个相对完整的认知了。</p><p>这节课我会用一些精心设计的示例，让你体会Rust引用的独特之处。</p><h2>借用与引用</h2><p>我们来复习一下上一节课最后一个例子。我们想在函数 <code>foo</code> 执行后继续使用字符串s1，我们通过把字符串的所有权转移出来，来达到我们的目的。</p><pre><code class=\"language-plain\">fn foo(s: String) -&gt; String {\n    println!(\"{s}\");\n    s\n}\n\nfn main() {\n    let s1 = String::from(\"I am a superman.\");\n    let s1 = foo(s1);\n    println!(\"{s1}\");\n}\n</code></pre><p>这样可以是可以，不过很麻烦。一是会给程序员造成一些心智负担，还得想着把值传回来再继续使用。如果代码中到处都是所有权传来传去，会让代码显得相当冗余，毕竟很多时候函数返回值是要用作其他类型的返回的。为了解决这个问题，Rust引入了借用的概念。</p><!-- [[[read_end]]] --><p>借用概念也是实际生活中思维的映射。比如你有一样东西，别人想用一下，可以从你这里借，你可以借出。那“引用”概念又是什么呢？其实在Rust中，<strong>借用和引用是一体两面</strong>。你把东西借给别人用，也就是别人持有了对你这个东西的引用。这里你理解就好，后面我们会混用这两个词。</p><p>在Rust中，变量前用“&amp;”符号来表示引用，比如 <code>&amp;x</code>。</p><p>其实<strong>引用也是一种值，并且是固定尺寸的值</strong>，一般来说，与机器CPU位数一致，比如64位或32位。因为是值，所以就可以赋给另一个变量。同时它又是固定的而且是小尺寸的值，那其实赋值的时候，就可以直接复制一份这个引用。</p><p>让我们来看一下如何使用引用。</p><pre><code class=\"language-plain\">fn main() {\n    let a = 10u32;\n    let b = &amp;a;        // b是变量a的一级引用\n    let c = &amp;&amp;&amp;&amp;&amp;a;    // c是变量a的多级引用\n    let d = &amp;b;        // d是变量a的间接引用\n    let e = b;         // 引用b再赋值给e\n    \n    println!(\"{a}\");\n    println!(\"{b}\");\n    println!(\"{c}\");\n    println!(\"{d}\");\n    println!(\"{e}\");\n}\n// 输出\n10\n10\n10\n10\n10\n</code></pre><p>从上面示例中可以看出，Rust识别了我们一般情况下的意图，不会打印出引用的内存地址什么的，而是打印出了被引用对象的值。示例中的c实际是a的5次引用，但是打印时仍然正确获取到了a的值。d是a的间接引用，但是仍然正确获取到了a的值。这里我们可以看出Rust与C这种纯底层语言的显著区别，Rust对程序员更友好，它会更多地面向业务。因为人们还是普遍关注最终那个值的部分，而不是中间过程的内存地址。</p><p>上面示例中，b和e都是对a的一级引用。由于引用是固定尺寸的值，<code>let e = b</code> 做的就是引用的复制操作，并没有再复制一份a的值。</p><p>那对字符串来说会怎样呢？我们改一下上面的示例。</p><pre><code class=\"language-plain\">fn main() {\n    let s1 = String::from(\"I am a superman.\");\n    let s2 = &amp;s1;\n    let s3 = &amp;&amp;&amp;&amp;&amp;s1;\n    let s4 = &amp;s2;\n    let s5 = s2;\n    \n    println!(\"{s1}\");\n    println!(\"{s2}\");\n    println!(\"{s3}\");\n    println!(\"{s4}\");\n    println!(\"{s5}\");\n}\n// 输出 \nI am a superman.\nI am a superman.\nI am a superman.\nI am a superman.\nI am a superman.\n</code></pre><p>结果符合我们的期望。同样，这些引用都没有导致堆中的字符串资源被复制一份或多份。字符串的所有权仍然在s1那里，s2、s3、s4、s5都是对这个所有权变量的引用。从这里开始，我们可以将变量按一个新的维度划分为<strong>所有权型变量</strong>和<strong>引用型变量</strong>。</p><p>也可以看出，在Rust中，一个所有权型变量（如 s1）带有值和类型的信息，一个引用型变量（如 s2、s3、s4、s5）也带有值和类型的信息，不然它没法正确回溯到最终的值。这些信息是Rust编译器帮我们维护的。</p><h2>不可变引用、可变引用</h2><p>上一节课，我们看到Rust的变量具有可变性。那么同样的规则，是不是可以施加到引用上来呢？当然可以。这正是Rust语言设计一致性的体现。</p><p>实际上默认 <code>&amp;x</code> 指的是不可变引用。而要获取到可变引用，需要使用 <code>&amp;mut</code> 符号，如 <code>&amp;mut x</code>。</p><p>好家伙，我们一下子又引入了两个新概念：不可变引用和可变引用。让我们好好来消化一下它们。</p><ul>\n<li>引用分成不可变引用和可变引用。</li>\n<li><code>&amp;x</code> 是对变量x的不可变引用。</li>\n<li><code>&amp;mut x</code> 是对变量x的可变引用。</li>\n</ul><p>你应该发现了，这里mut和x中间有个空格，为什么呢？很简单，就是为了避免和 <code>&amp;mutx</code> 混淆。</p><p>不可变引用和可变引用对应的现实概念也是很容易理解的。比如，你把你的书借给别人，并且嘱咐，只能阅读，不能在书上记笔记。这就相当于不可变引用。如果你允许他在书上面写写划划，那就相当于可变引用。</p><p>为什么会有可变引用的存在呢？这个事情是这样的。到目前为止，如果要对一个变量内容进行修改，我们必须拥有所有权型变量才行。而很多时候，我们没法拥有那个资源的所有权，比如你引用一个别人的库，它没有把所有权类型暴露出来，但是确实又有更新其内部状态的需求。因此需要一个东西，它既是一种引用，又能够修改指向资源的内容。于是就引入了<strong>可变引用</strong>。</p><p>我们前面举的引用的例子，实际只是访问（打印）变量的值，没有修改它们，所以没问题。现在我们再来看一下，如果要使用引用修改变量的值，应该怎么做。</p><pre><code class=\"language-plain\">fn main() {\n    let a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n\n    println!(\"{b}\");\n}\n</code></pre><p>提示：</p><pre><code class=\"language-plain\">error[E0596]: cannot borrow `a` as mutable, as it is not declared as mutable\n  --&gt; src/main.rs:19:13\n   |\n19 |     let b = &amp;mut a;\n   |             ^^^^^^ cannot borrow as mutable\n   |\nhelp: consider changing this to be mutable\n   |\n18 |     let mut a = 10u32;\n   |         +++\n</code></pre><p>报错了。怎么回事呢？</p><p>前面我们说过，要修改一个变量的值，变量名前要加 <code>mut</code> 修饰符，我们忘加了（不要害羞，这是很正常的事情），Rust编译器给我们指出来了。</p><p>现在我们加上。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n\n    println!(\"{b}\");\n}\n// 输出 \n20\n</code></pre><p>接下来改动一下例子。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n\n    println!(\"{b}\");\n    println!(\"{a}\");    // 这里多打印了一行a\n}\n// 输出 \n20\n20\n</code></pre><p>正确输出了修改后的值。</p><p>我们再换一下两个打印语句的位置试试。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n\n    println!(\"{a}\");  // 这一句移到前面来\n    println!(\"{b}\");\n}\n</code></pre><p>编译居然报错了！</p><pre><code class=\"language-plain\">   Compiling playground v0.0.1 (/playground)\nerror[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable\n --&gt; src/main.rs:6:15\n  |\n3 |     let b = &amp;mut a;\n  |             ------ mutable borrow occurs here\n...\n6 |     println!(\"{a}\");  // 这一句移到的前面来\n  |               ^^^ immutable borrow occurs here\n// 提示说这里发生了不可变借用\n7 |     println!(\"{b}\");\n  |               --- mutable borrow later used here\n// 在这后面使用了可变借用\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n</code></pre><p>只是移动了一下打印语句，就会导致程序编译不通过。什么道理！我能充分理解你初学Rust的心情。</p><p>那这到底是为什么呢？我们先总结一下观察到的事情。</p><ul>\n<li>打印语句 <code>println!</code> 中，不管是传所有权型变量还是引用型变量，都能打印出预期的值。实际上 <code>println!</code> 中默认会对所有权变量做不可变借用操作（对应代码里的第6行）。</li>\n<li>可变引用调用的时机（对应代码里的第7行）和不可变引用调用的时机（对应代码里的第6行），好像有顺序要求。目前我们尚不清楚这种机制是什么。</li>\n</ul><p>为了让问题暴露得更加明显，我又设计了另外一个例子。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n    let c = &amp;a;      // 在利用b更新了a的值后，c再次借用a\n}\n</code></pre><p>这个代码是可以顺利编译的。但是加了一句打印就又不行了！</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n    let c = &amp;a;       // 在利用b更新了a的值后，c再次借用a\n    \n    println!(\"{b}\");  // 加了一句打印语句\n}\n</code></pre><p>提示：</p><pre><code class=\"language-plain\">   Compiling playground v0.0.1 (/playground)\nerror[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable\n// 不能将a借用为不可变的，因为它已经被可变借用了\n  --&gt; src/main.rs:5:13\n  |\n3 |     let b = &amp;mut a;\n  |             ------ mutable borrow occurs here\n// 可变借用发生在这里\n4 |     *b = 20;\n5 |     let c = &amp;a;\n  |             ^^ immutable borrow occurs here\n// 不可变借用发生在这里\n6 |     \n7 |     println!(\"{b}\");  // 加了一句打印语句\n  |               --- mutable borrow later used here\n// 可变借用在这里使用了\n</code></pre><p>怎么回事呢？</p><p>我们试着改一下打印语句。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n    let c = &amp;a;\n    \n    println!(\"{c}\");  // 不打印b了，换成打印c\n}\n// 输出\n20\n</code></pre><p>这下编译通过了，打印出 20。</p><p>我们尝试一下把变量c的定义移到前面一些，结果又不能编译了。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let c = &amp;a;        // c的定义移到这里来了\n    let b = &amp;mut a;\n    *b = 20;\n  \n    println!(\"{c}\");\n}\n</code></pre><p>提示：</p><pre><code class=\"language-plain\">   Compiling playground v0.0.1 (/playground)\nerror[E0502]: cannot borrow `a` as mutable because it is also borrowed as immutable\n --&gt; src/main.rs:4:13\n  |\n3 |     let c = &amp;a;        // c的定义移到这里来了\n  |             -- immutable borrow occurs here\n4 |     let b = &amp;mut a;\n  |             ^^^^^^ mutable borrow occurs here\n...\n7 |     println!(\"{c}\");\n  |               --- immutable borrow later used here\n</code></pre><p>你有没有感觉Rust就像一头发疯的野牛！不听使唤。而我们现在要做的就是摸清它的脾气，驯服它！</p><p>再尝试修改代码，又编译通过了。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let c = &amp;a;           // c的定义移到这里来了\n    let b = &amp;mut a;\n    *b = 20;\n\n    println!(\"{b}\");      // 这里打印的变量换成b\n}\n</code></pre><p>到这里为止，我们已经积累了不少素材了，从这些素材中你有没有发现什么规律？<strong>引用的最后一次调用时机很关键</strong>。</p><p>前面我们讲过，一个所有权型变量的作用域是从它定义时开始到花括号结束。而引用型变量的作用域不是这样，<strong>引用型变量的作用域是从它定义起到它最后一次使用时结束。</strong>比如上面的示例中，所有权型变量a的作用域是2~8行；不可变引用c的作用域只有第3行，它定义了，但并没有被使用，所以它的作用域就只有那一行；可变引用b的作用域是4~7行。</p><p>同时，我们发现还存在一条规则：<strong>一个所有权型变量的可变引用与不可变引用的作用域不能交叠</strong>，也可以说不能同时存在。我们用这条规则分析前面的示例。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let c = &amp;a;        \n    let b = &amp;mut a;\n    *b = 20;\n  \n    println!(\"{c}\");\n}\n</code></pre><p>所有权型变量a的作用域是2~8行，不可变引用c的作用域是3~7行，可变引用b的作用域是4~5行。b和c的作用域交叠了，因此无法编译通过。</p><p>后面你可以采用我的这种分析方法来分析每一个例子。</p><p>接下来我们再看一个例子。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n    let d = &amp;mut a;\n    \n    println!(\"{d}\");      // 打印d\n}\n// 输出\n20\n</code></pre><p>这个例子打印出 20。那我们尝试打印b试试。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let b = &amp;mut a;\n    *b = 20;\n    let d = &amp;mut a;\n    \n    println!(\"{b}\");      // 打印b\n}\n</code></pre><p>编译不通过，提示：</p><pre><code class=\"language-plain\">   Compiling playground v0.0.1 (/playground)\nerror[E0499]: cannot borrow `a` as mutable more than once at a time\n// 在一个时刻不能把`a`以可变借用形式借用超过一次\n --&gt; src/main.rs:5:13\n  |\n3 |     let b = &amp;mut a;\n  |             ------ first mutable borrow occurs here\n4 |     *b = 20;\n5 |     let d = &amp;mut a;\n  |             ^^^^^^ second mutable borrow occurs here\n6 |     \n7 |     println!(\"{b}\");\n  |               --- first borrow later used here\n</code></pre><p>编译器抱怨：“在一个时刻不能把a以可变借用形式借用超过一次”。分析代码后，我们发现确实这两个可变借用的作用域交叠了！b的作用域是3～7行，d的作用域是第5行，难怪会报错。于是我们又学到了一条经验：<strong>同一个所有权型变量的可变借用之间的作用域也不能交叠</strong>。</p><p>然后，让我们继续看。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a = 10u32;\n&nbsp; &nbsp; let r1 = &amp;a;\n&nbsp; &nbsp; a = 20;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{r1}\");\n}\n</code></pre><p>编译报错：</p><pre><code class=\"language-plain\">   Compiling playground v0.0.1 (/playground)\nerror[E0506]: cannot assign to `a` because it is borrowed\n// 不能给a赋值，因为它被借用了\n --&gt; src/main.rs:4:5\n  |\n3 |     let r1 = &amp;a;\n  |              -- `a` is borrowed here\n4 |     a = 20;\n  |     ^^^^^^ `a` is assigned to here but it was already borrowed\n5 |     \n6 |     println!(\"{r1}\");\n  |               ---- borrow later used here\n</code></pre><p>提示在有借用的情况下，不能对所有权变量进行更改值的操作（写操作）。</p><p>有可变借用存在的情况下也一样。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a = 10u32;\n&nbsp; &nbsp; let r1 = &amp;mut a;\n&nbsp; &nbsp; a = 20;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{r1}\");\n}\n</code></pre><p>编译报错：</p><pre><code class=\"language-plain\">   Compiling playground v0.0.1 (/playground)\nerror[E0506]: cannot assign to `a` because it is borrowed\n --&gt; src/main.rs:4:5\n  |\n3 |     let r1 = &amp;mut a;\n  |              ------ `a` is borrowed here\n4 |     a = 20;\n  |     ^^^^^^ `a` is assigned to here but it was already borrowed\n5 |     \n6 |     println!(\"{r1}\");\n  |               ---- borrow later used here\n</code></pre><p>提示在有借用的情况下，不能对所有权变量进行更改值的操作（写操作）。</p><p>通过前面这么多例子的摸索，你是不是找到了一些规律？到此为止，我们可以做一下阶段性的总结，得出关于引用（借用）的一些规则。</p><ul>\n<li>所有权型变量的作用域是从它定义时开始到所属那层花括号结束。</li>\n<li>引用型变量的作用域是从它定义起到它最后一次使用时结束。</li>\n<li>引用（不可变引用和可变引用）型变量的作用域不会长于所有权变量的作用域。这是肯定的，不然就会出现悬锤引用，这是典型的内存安全问题。</li>\n<li>一个所有权型变量的不可变引用可以同时存在多个，可以复制多份。</li>\n<li>一个所有权型变量的可变引用与不可变引用的作用域不能交叠，也可以说不能同时存在。</li>\n<li>某个时刻对某个所有权型变量只能存在一个可变引用，不能有超过一个可变借用同时存在，也可以说，对同一个所有权型变量的可变借用之间的作用域不能交叠。</li>\n<li>在有借用存在的情况下，不能通过原所有权型变量对值进行更新。当借用完成后（借用的作用域结束后），物归原主，又可以使用所有权型变量对值做更新操作了。</li>\n</ul><p>下面我们再来试试可变引用能否被复制。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let r1 = &amp;mut a;\n    let r2 = r1;\n    \n    println!(\"{r1}\")\n}\n</code></pre><p>出错了，提示：</p><pre><code class=\"language-plain\">error[E0382]: borrow of moved value: `r1`\n --&gt; src/main.rs:6:16\n  |\n3 |     let r1 = &amp;mut a;\n  |         -- move occurs because `r1` has type `&amp;mut u32`, which does not implement the `Copy` trait\n4 |     let r2 = r1;\n  |              -- value moved here\n5 |     \n6 |     println!(\"{r1}\")\n  |                ^^ value borrowed here after move\n</code></pre><p>它说r1的值移动给了r2，因此r1不能再被使用了。</p><p>我们修改一下例子。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a = 10u32;\n    let r1 = &amp;mut a;\n    let r2 = r1;\n    \n    println!(\"{r2}\");    // 打印r2\n}\n// 输出\n10\n</code></pre><p>成功打印。</p><p>从这个例子可以看出，可变引用的再赋值，会执行移动操作。赋值后，原来的那个可变引用变量就不能用了。这有点类似于所有权的转移，因此<strong>一个所有权型变量的可变引用也具有所有权特征</strong>，它可以被理解为那个所有权变量的独家代理，具有<strong>排它性</strong>。</p><h2>多级引用</h2><p>我们来看剩下的一些语言细节。下面这段代码展示了 <code>mut</code> 修饰符，<code>&amp;mut</code> 和 <code>&amp;</code> 同时出现的情况。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a1 = 10u32;\n&nbsp; &nbsp; let mut a2 = 15u32;\n\n&nbsp; &nbsp; let mut b = &amp;mut a1;\n&nbsp; &nbsp; b = &amp;mut a2;\n\n&nbsp; &nbsp; let mut c = &amp;a1;\n&nbsp; &nbsp; c = &amp;a2;\n}\n</code></pre><p>下面我们再来看一个多级可变引用的例子。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a1 = 10u32;\n    let mut b = &amp;mut a1;\n    *b = 20;\n\n    let c = &amp;mut b;\n    **c = 30;          // 多级解引用操作\n    \n    println!(\"{c}\");\n}\n// 输出 \n30\n</code></pre><p>假如我们解引用错误会怎样，来看看。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a1 = 10u32;\n    let mut b = &amp;mut a1;\n    *b = 20;\n\n    let c = &amp;mut b;\n    *c = 30;            // 这里对二级可变引用只使用一级解引用操作\n    \n    println!(\"{c}\");\n}\n</code></pre><p>哦！会报错。</p><pre><code class=\"language-plain\">   Compiling playground v0.0.1 (/playground)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:7:10\n  |\n7 |     *c = 30;\n  |     --   ^^ expected `&amp;mut u32`, found integer\n  |     |\n  |     expected due to the type of this binding\n  |\nhelp: consider dereferencing here to assign to the mutably borrowed value\n  |\n7 |     **c = 30;\n  |     +\n</code></pre><p>它正确识别到了中间引用的类型为 <code>&amp;mut u32</code>，而我们却要给它赋值为 <code>u32</code>，一定是代码写错了，然后还给我们建议了正确的写法。强大！</p><p>我们再来看一个例子。</p><pre><code class=\"language-plain\">fn main() {\n    let mut a1 = 10u32;\n    let b = &amp;mut a1;\n    let mut c = &amp;b;\n    let d = &amp;mut c;\n    \n    ***d = 30;\n    \n    println!(\"{d}\");\n}\n</code></pre><p>提示：</p><pre><code class=\"language-plain\">error[E0594]: cannot assign to `***d`, which is behind a `&amp;` reference\n  --&gt; src/main.rs:21:5\n   |\n21 |     ***d = 30;\n   |     ^^^^^^^^^ cannot assign\n\nFor more information about this error, try `rustc --explain E0594`.\n</code></pre><p>提示：不能这样更新目标的值，因为目标躲在一个 <code>&amp;</code> 引用后面。</p><p>这里，我们又可以发现Rust中三条关于引用的知识点。</p><ul>\n<li>对于多级可变引用，要利用可变引用去修改目标资源的值的时候，需要做正确的多级解引用操作，比如例子中的 <code>**c</code>，做了两级解引用。</li>\n<li>只有全是多级可变引用的情况下，才能修改到目标资源的值。</li>\n<li>对于多级引用（包含可变和不可变），打印语句中，可以自动为我们解引用正确的层数，直到访问到目标资源的值，这很符合人的直觉和业务的需求。</li>\n</ul><h2>用引用改进函数的定义</h2><p>有了引用这个设施，我们可以改进前面将字符串所有权传进函数，然后又传出来的例子。第一个例子是将字符串的不可变引用传进函数参数。</p><pre><code class=\"language-plain\">fn foo(s: &amp;String) {\n    println!(\"in fn foo: {s}\");\n}\n\nfn main() {\n    let s1 = String::from(\"I am a superman.\");\n    foo(&amp;s1);    // 注意这里传的是字符串的引用 &amp;s1\n    println!(\"{s1}\");    // 这里可以打印s1的值了\n}\n</code></pre><p>可以看到，打印出了正确的结果。</p><pre><code class=\"language-plain\">in fn foo: I am a superman.\nI am a superman.\n</code></pre><p>然后我们试试将字符串的可变引用传进函数，并修改字符串的内容。</p><pre><code class=\"language-plain\">fn foo(s: &amp;mut String) {\n    s.push_str(\" You are batman.\");\n}\n\nfn main() {\n    let mut s1 = String::from(\"I am a superman.\");\n    println!(\"{s1}\");\n    foo(&amp;mut s1);    // 注意这里传的是字符串的可变引用 &amp;mut s1\n    println!(\"{s1}\");\n}\n</code></pre><p>输出：</p><pre><code class=\"language-plain\">I am a superman.\nI am a superman. You are batman.\n</code></pre><p>与我们的期望一致。我们成功地使用引用，来改进函数的传参过程以及函数的定义，我们这里的 <code>foo</code> 函数，不再需要费力地把所有权再传回来了。</p><p>从代码中可以看到，这里Rust的代码 <code>&amp;s1</code> 和 <code>&amp;mut s1</code> 留下了清晰的足迹。如果一个函数参数接受的是可变引用或所有权参数，那么它里面的逻辑一般都会对其引用的资源进行修改。如果一个函数参数只接受不可变引用，那么它里面的逻辑，就一定不会修改被引用的资源。简单的一个参数的签名形式，就将函数的意图初步划分出来了。就是这么清晰，非常利于代码的阅读。</p><h2>小结</h2><p>这节课我带着你摸了一遍Rust这头野牛的怪脾气，现在已经大致清楚了。下面我们一起来总结一下这节课的主要内容。</p><p>在同一时刻，同一个所有权变量的不可变引用和可变引用两者不能同时存在，不可变引用可以同时存在多个。可变引用具有排它性，只能同时存在一个。</p><p>借用结束后，原本的所有权变量会重新恢复可读可写的状态。不可变引用可以被任意复制多份，但是可变引用不能被复制，只能转移，这也体现了<strong>可变引用具有一定的所有权特征</strong>。所有权和引用模型是Rust语言编写高可靠和高性能代码的基础，理解这些模型有助于优化程序的效率，提高代码质量。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/8d/41cf986d8da00cce53436aba30e89e8d.jpg?wh=1732x1398\" alt=\"\"></p><p>本文通过探索性的方式尝试遍历不可变引用与可变引用的各种形式和可能的组合，由此揭开了Rust中引用的各种性质以及同所有权的关系，并总结出了多条相关规则。看起来略显繁琐，但每个示例其实非常简单，理解起来并不困难。请一定记住，<strong>不要死记硬背那些条条框框，请你亲自敲上面的代码示例，编译并运行它，在实践中去理解它们</strong>。久而久之，就会形成一种思维习惯，觉得Rust中的这种设计是理所当然的了。</p><h2>思考题</h2><ol>\n<li>请思考，为何在不可变引用存在的情况下（只是读操作），原所有权变量也无法写入？</li>\n</ol><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a: u32 = 10;\n&nbsp; &nbsp; let b = &amp;a;\n&nbsp; &nbsp; a = 20;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{}\", b);\n}\n</code></pre><ol start=\"2\">\n<li>请回答，可变引用复制的时候，为什么不允许copy，而是move？</li>\n</ol><p>欢迎你把你思考后的答案分享到评论区，和我一起讨论，也欢迎你把这节课分享给需要的朋友，邀他一起学习，我们下节课再见！</p>","comments":[{"had_liked":false,"id":382992,"user_name":"Andylinge","can_delete":false,"product_type":"c1","uid":2727445,"ip_address":"安徽","ucode":"D0D24185E99A67","user_header":"https://static001.geekbang.org/account/avatar/00/29/9e/15/e499fc69.jpg","comment_is_top":false,"comment_ctime":1698288102,"is_pvip":false,"replies":[{"id":139504,"content":"很棒，对的，基础扫清了才能启航远洋。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698327779,"ip_address":"重庆","comment_id":382992,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"1. 不可变引用的作用域跨越了所有权变量的写入过程，意味着同一个作用域同时存在可变引用和不可变引用，编译器为了防止读取错误，不能通过编译。可以把a = 20放到引用之前，即可编译通过。\n2. 可变引用如果可以Copy，就违反了可变引用不能同时存在的规则，因此只能Move.\n跟唐老师学习我觉得我理解能力变强了，感谢唐老师的课程，扫清了很多基础的迷雾。","like_count":22,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630340,"discussion_content":"很棒，对的，基础扫清了才能启航远洋。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698327779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1104366,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/ee/8042d31d.jpg","nickname":"John","note":"","ucode":"165BDDE8E7677E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630602,"discussion_content":"😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698724264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":630340,"ip_address":"北京","group_id":0},"score":630602,"extra":""}]}]},{"had_liked":false,"id":383065,"user_name":"Geek_6fjt20","can_delete":false,"product_type":"c1","uid":1672482,"ip_address":"北京","ucode":"B7EB9B061E2C06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrbHib1v0wPRVHxrFK2CPQQX8Wg3rRMPiaZ5teMKu5klT48yns6yo4krZsIqHskwdEsibVvQ3QB7CUQ/132","comment_is_top":false,"comment_ctime":1698385677,"is_pvip":false,"replies":[{"id":139544,"content":"有趣🤔️","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698402368,"ip_address":"重庆","comment_id":383065,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"rust完全模拟了现实世界中借的概念，a有一本书，b要用的时候向a借，b不能超出a的移动范围（作用域范围），因为怕借了不还跑路了。","like_count":11,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630427,"discussion_content":"有趣🤔️","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698402368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182120,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/oCx7GX9P4w5cml1cpbFD1x21Biad3MLCTOhTPJvicRW3xp9C8xTgdiaOSdpFyvibKSfcD1LL4miaT7VtqqKms6rgujg/132","nickname":"zshanjun","note":"","ucode":"0C99216D6FBDB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647788,"discussion_content":"大善","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1720605094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2457422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyyEahkmw06Y7Vmn6CYh6pIK0oT6UBSQx2lIcc0P0IoOR2H7Njbc9YhfDwMSjz5bMxuf11gG7aXw/132","nickname":"姜明","note":"","ucode":"0238F0031CE24A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636962,"discussion_content":"妙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707364503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383022,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"中国香港","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1698310001,"is_pvip":false,"replies":[{"id":139509,"content":"因为后面c要对b进行可变借用。这样，语法上就要求b在前面加mut修饰。你如果后面再有d对c进行可变借用，那么你试试，c也需要加mut修饰的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698328048,"ip_address":"重庆","comment_id":383022,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"想请问下下面这段代码，为什么变量b之前的mut是必须的，变量c之前不需要：\n\nfn main() {\n    let mut a1 = 10u32;\n    let mut b = &amp;mut a1;\n    *b = 20;\n\n    let c = &amp;mut b;\n    **c = 30;          &#47;&#47; 多级解引用操作\n\n    println!(&quot;{c}&quot;);\n}","like_count":8,"discussions":[{"author":{"id":1118976,"avatar":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","nickname":"Michael","note":"","ucode":"35F4FFAC4A4B15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630330,"discussion_content":"明白了，总结下就是：\n\n1. 如果通过引用修改变量，引用自身没必要声明为可变，他最终指向的变量是可变的即可；\n2. 只能从可变变量获取可变引用，就像 let c = &amp;mut b;","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1698320662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630345,"discussion_content":"因为后面c要对b进行可变借用。这样，语法上就要求b在前面加mut修饰。你如果后面再有d对c进行可变借用，那么你试试，c也需要加mut修饰的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1698328048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382998,"user_name":"一个人旅行","can_delete":false,"product_type":"c1","uid":2555864,"ip_address":"北京","ucode":"A708238B10B44B","user_header":"https://static001.geekbang.org/account/avatar/00/26/ff/d8/d48d6088.jpg","comment_is_top":false,"comment_ctime":1698291693,"is_pvip":false,"replies":[{"id":139505,"content":"不错。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698327802,"ip_address":"重庆","comment_id":382998,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"问题1. 所有权型变量被借用时，不能对所有权型变量进行修改。\n问题2. 同一时刻，所有权型变量只能有一个可变引用或多个不可变引用。如果复制，则会有多个不可变引用，违反了借用规则。","like_count":5,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630341,"discussion_content":"不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698327802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3204086,"avatar":"https://static001.geekbang.org/account/avatar/00/30/e3/f6/823e346a.jpg","nickname":"浣花公子","note":"","ucode":"2C88563566FF0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636363,"discussion_content":"而且，问题2,如果允许复制，那就会引发内存泄漏和数据副本不同步的一系列问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705998512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"吉林","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386907,"user_name":"RobinH","can_delete":false,"product_type":"c1","uid":1764303,"ip_address":"湖北","ucode":"4D74D32C8D1FB8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/eb/cf/8fa3dd5a.jpg","comment_is_top":false,"comment_ctime":1705891574,"is_pvip":false,"replies":[{"id":141077,"content":"你的直觉非常准👍👍， 最后一篇总结揭开谜底","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705970900,"ip_address":"重庆","comment_id":386907,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"所有权 感觉像是一种 栈范围 在控制","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636342,"discussion_content":"你的直觉非常准👍👍， 最后一篇总结揭开谜底","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705970900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384206,"user_name":"Geek_c01211","can_delete":false,"product_type":"c1","uid":2676652,"ip_address":"广东","ucode":"0166D1B80EBFBB","user_header":"","comment_is_top":false,"comment_ctime":1700532328,"is_pvip":false,"replies":[{"id":140153,"content":"很简单：解决多方写冲突的问题。可参考锁机制。这正是Rust想解决内存安全问题的基本思路出发点。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700539691,"ip_address":"重庆","comment_id":384206,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"感觉讲的比较细，给了很多 case 去分析，很喜欢，但是想请教一个问题，为啥可变引用和不可变引用或者多个不可变引用的作用域之间不能重叠？如果编译器不对这一块做检查，会有啥样子的问题了，基于目前的例子，好像没有办法合理的解释为什么不能重叠","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632168,"discussion_content":"很简单：解决多方写冲突的问题。可参考锁机制。这正是Rust想解决内存安全问题的基本思路出发点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700539691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1202222,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep66fdwo3ebSicKjf0iacAx4C2tZOthDDD4bSJqib1iauFBK6EoMSWUBp4UbbN2BQlib7mFR3hQD6MUwew/132","nickname":"chai","note":"","ucode":"C686EB1B1EBAB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":654405,"discussion_content":"多写冲突是发生在多线程环境中，在单线程中不会有多写的问题，所以是不是可以说明rust目前做的还不够智能？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732637511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":632168,"ip_address":"天津","group_id":0},"score":654405,"extra":""}]}]},{"had_liked":false,"id":382962,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1698235841,"is_pvip":false,"replies":[{"id":139500,"content":"很棒。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698327640,"ip_address":"重庆","comment_id":382962,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"1. 不可变引用的语义更像是“借一下这个值使用一下”，如果在不可变引用作用域结束之前，对所有权变量进行写入，那么这个借的“值”，就没有意义了，因为不确定是否跟想借的时候是一致的。\n\n2. 如文中所说，可变引用的作用域不能交叉，如果采用 copy，则两份可变引用其实是互不影响的，即可以交叉，就产生矛盾了。","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630336,"discussion_content":"很棒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698327640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388990,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"广东","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1711344121,"is_pvip":false,"replies":[{"id":141743,"content":"s1是所有权型变量，s2是引用型变量，但是它是可变引用，因此它具有排它性。于是在做 s3=s2时，会把这种排它性传递给s3。s3持有对s1的可变引用了，这时，s2被置invalid状态。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1713028380,"ip_address":"加拿大","comment_id":388990,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"想问下老师，下面这段代码中，s2 和 s3 分别是什么类型的变量（所有权型还是引用型？），引用算不算上一种特殊的资源（值）？变量 s3 对 s2 拥有所谓的“所有权”吗？\n\nlet mut s1 = &quot;Hello World&quot;.to_string();\nlet s2 = &amp;mut s1;\nlet s3 = s2;\nprintln!(&quot;{s3}&quot;)","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641824,"discussion_content":"s1是所有权型变量，s2是引用型变量，但是它是可变引用，因此它具有排它性。于是在做 s3=s2时，会把这种排它性传递给s3。s3持有对s1的可变引用了，这时，s2被置invalid状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713028381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388158,"user_name":"林子茗","can_delete":false,"product_type":"c1","uid":2337884,"ip_address":"广东","ucode":"59EDCECD54731F","user_header":"https://static001.geekbang.org/account/avatar/00/23/ac/5c/bb67abe6.jpg","comment_is_top":false,"comment_ctime":1709526858,"is_pvip":false,"replies":[{"id":141754,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1713028829,"ip_address":"加拿大","comment_id":388158,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题1：因为这样会导致b的结果不一致，类似于数据库的不可重复读。\n2：多个引用都能修改，可能会有并发问题，所以还是数据不一致的问题。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641836,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713028829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385615,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"江苏","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1702978994,"is_pvip":true,"replies":[{"id":140557,"content":"你是说原资源所有权变量在借用期间不能用来修改资源吧？","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703122615,"ip_address":"重庆","comment_id":385615,"utype":1}],"discussion_count":2,"race_medal":1,"score":2,"product_id":100626901,"comment_content":"一句话总结：资源在借用期间不能被修改（包括定义可变借用）","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634232,"discussion_content":"你是说原资源所有权变量在借用期间不能用来修改资源吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703122615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634255,"discussion_content":"是的，还有就是在借用的期间（借用作用域），也不可以通过可变引用修改资源。我是想通过一句话总结所有场景的。\n\n所以还是想得太简单了，没有考虑到可变借用的独占。这里还有一个问题，为什么可变借用期间也不可以做不可变借用呢？这是出于什么考虑？\n毕竟不可变借用不能修改资源不会产生副作用。\n\n感觉 rust 的编译器真是保姆级的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703141425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634232,"ip_address":"江苏","group_id":0},"score":634255,"extra":""}]}]},{"had_liked":false,"id":383930,"user_name":"Citroen","can_delete":false,"product_type":"c1","uid":2188563,"ip_address":"辽宁","ucode":"03017DB11EC537","user_header":"https://static001.geekbang.org/account/avatar/00/21/65/13/8654e7c9.jpg","comment_is_top":false,"comment_ctime":1699953729,"is_pvip":false,"replies":[{"id":140081,"content":"对，其实非常自然。只是之前的语言给我们造成的先入为主的观念让我们觉得Rust的概念开始非常不适应。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699959890,"ip_address":"重庆","comment_id":383930,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"看了老师的文章体会深刻醍醐灌顶。不可变借用，从字面理解就是借出去了，你就不能变了，所以既然保证不变了，那这样的借用当然可以被借出去N次（原变量不可变是只限于在借出去的变量的有效生命周期内）。可变借用就是借出去随时有被改变的可能，在同一生命周期内借出去多次，有不确定性的被谁改变的风险，尤其多线程中，所以就只让你借出去一次，既然存在有不确定性的被修改的可能，那这个时期肯定就不会让你再有不可以变借用了（因为随时会改变了，不可变借用本身也就不成立了）。Rust这个逻辑看似很繁杂，实则逻辑环环相扣清晰很符合常规。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631785,"discussion_content":"对，其实非常自然。只是之前的语言给我们造成的先入为主的观念让我们觉得Rust的概念开始非常不适应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699959891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383895,"user_name":"三过rust门而不入","can_delete":false,"product_type":"c1","uid":3537445,"ip_address":"广东","ucode":"88ECCC99AB2672","user_header":"https://static001.geekbang.org/account/avatar/00/35/fa/25/e40eeb9c.jpg","comment_is_top":false,"comment_ctime":1699890610,"is_pvip":false,"replies":[{"id":140078,"content":"谢谢你的认可，如能做到铺平一些Rust的学习曲线，那就说明我们的初衷正在实现。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699948900,"ip_address":"重庆","comment_id":383895,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"太细了，这个课程写的真的好！","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631771,"discussion_content":"谢谢你的认可，如能做到铺平一些Rust的学习曲线，那就说明我们的初衷正在实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699948900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383801,"user_name":"javpower","can_delete":false,"product_type":"c1","uid":1362777,"ip_address":"江西","ucode":"92867F35D11590","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJ4reATXtqhQ26vWXhiaZUEF9W1E0ZEqibrxxzR7NrlGwjrCZeLvF2HnL8jFjGXaFtN1vBTSia6492g/132","comment_is_top":false,"comment_ctime":1699669373,"is_pvip":false,"replies":[{"id":139963,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699706462,"ip_address":"重庆","comment_id":383801,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"借用规则类似于读写锁，即同一时刻只能拥有一个写锁，或者多个读锁，不允许写锁和读锁同时出现。这是为了避免数据竞争，保障数据一致性。\n","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631537,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699706462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383309,"user_name":"古明地觉","can_delete":false,"product_type":"c1","uid":1528298,"ip_address":"北京","ucode":"31DA063A17FC27","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/ea/d9a83bb3.jpg","comment_is_top":false,"comment_ctime":1698837430,"is_pvip":false,"replies":[{"id":139650,"content":"很棒！","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698893048,"ip_address":"重庆","comment_id":383309,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"1. 如果换个例子就好解释了\nfn main() {\n    let mut s = &quot;hello&quot;.to_string();\n    let p = &amp;s;  &#47;&#47; 不可变借用\n    s.push_str(&quot; world&quot;);  &#47;&#47; 可变借用\n    println!(&quot;{}&quot;, p);  &#47;&#47; 不可变借用\n}\n由于不可变借用和可变借用的范围出现了重叠，因此编译出错。而 a = 20 和此处类似，都是修改了实际数据。\n\n2. 因为多个可变引用的作用范围不能存在交集，所以 Copy 的话没有意义，因此只能 Move","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630790,"discussion_content":"很棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698893048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383004,"user_name":"励研冰","can_delete":false,"product_type":"c1","uid":1106394,"ip_address":"上海","ucode":"FCBC8266018FA0","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/da/d7f591a7.jpg","comment_is_top":false,"comment_ctime":1698297145,"is_pvip":false,"replies":[{"id":139506,"content":"思考得很棒，后面会看到关于所有权在并发中的处理相关内容。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698327864,"ip_address":"重庆","comment_id":383004,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"从语意上保证了安全性，不可变引用语意:从此刻开始到我的运用域结束，原始值请保持我开始的状态，不然就破坏了我的不可变引用的语;可变引用同样的道理;。类似于mysql中的可重复读事物，不过mysql的实现方式是通过mvcc ,为了提高并发度；而rust是限制修改，更像是排斥锁，不允许交叉；不过这样的话不知道后面的 无谓并发 在对同一个数据的修改上会不会有什么问题","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630342,"discussion_content":"思考得很棒，后面会看到关于所有权在并发中的处理相关内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698327864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382960,"user_name":"刘永臣","can_delete":false,"product_type":"c1","uid":2033098,"ip_address":"北京","ucode":"31426CE31CA514","user_header":"https://static001.geekbang.org/account/avatar/00/1f/05/ca/eefef69b.jpg","comment_is_top":false,"comment_ctime":1698232050,"is_pvip":false,"replies":[{"id":139499,"content":"对的。2，写清楚可变引用比较好。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698327615,"ip_address":"重庆","comment_id":382960,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"问题1：所有权借出时，原所有权变量不能操作；\n问题2：引用的复制实际上是所有权的借出，类似于所有权转移，不是复制数据。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630335,"discussion_content":"对的。2，写清楚可变引用比较好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698327616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387764,"user_name":"RobinH","can_delete":false,"product_type":"c1","uid":1764303,"ip_address":"美国","ucode":"4D74D32C8D1FB8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/eb/cf/8fa3dd5a.jpg","comment_is_top":false,"comment_ctime":1708536997,"is_pvip":false,"replies":[{"id":141269,"content":"node 作为 &amp;mut cur.next 持有了引用，因此并不是“while 完后，while 里的 cur.next 应该结束了”.","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1708826559,"ip_address":"加拿大","comment_id":387764,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"struct NewNode&lt;T&gt; {\n    val: T,\n    next: Option&lt;Box&lt;NewNode&lt;T&gt;&gt;&gt;,\n}\n\nimpl&lt;T: Display&gt; NewNode&lt;T&gt; {\n    fn new(val: T) -&gt; Self {\n        NewNode { val, next: None }\n    }\n\n    pub fn put(&amp;mut self, val: T) {\n        let mut cur = self;\n        while let Some(node) = &amp;mut cur.next {  &#47;&#47; `cur.next` is borrowed here\n            cur = node;\n        }\n\n        &#47;&#47; error: `cur.next` is assigned to here but it was already borrowed\n        cur.next = Some(Box::new(NewNode { val, next: None }));\n    }\n}\n\nwhile 完后，while 里的 cur.next 应该结束了，下一行的 cur.next 赋值应该不会发生可变引用问题，为什么会出现借用报错？老师有空帮指导下哈 ","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637696,"discussion_content":"node 作为 &amp;mut cur.next 持有了引用，因此并不是“while 完后，while 里的 cur.next 应该结束了”.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708826560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385476,"user_name":"Young！","can_delete":false,"product_type":"c1","uid":1025221,"ip_address":"北京","ucode":"2A658CEFD26011","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/c5/a53f8bbc.jpg","comment_is_top":false,"comment_ctime":1702723247,"is_pvip":false,"replies":[{"id":140501,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702907971,"ip_address":"重庆","comment_id":385476,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"1. 为了保证数据在内存中的一致性。如果当前时刻，可变引用可以修改原数据值，原值也可以改变自身的值，那在多线程的情况下就会发生原值不一致的问题。所以在同一时刻只有一个不管是原值也好可变引用也好，只有一个所有权才能去改变原值！\n2. 我觉得还是第一个问题的结论，当前时刻如果有多个可变引用的话，你改我改，数据最后都乱了。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634016,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702907971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385040,"user_name":"Mango","can_delete":false,"product_type":"c1","uid":1560032,"ip_address":"重庆","ucode":"CCD3A91D69555D","user_header":"https://static001.geekbang.org/account/avatar/00/17/cd/e0/7ba3c15d.jpg","comment_is_top":false,"comment_ctime":1701960677,"is_pvip":false,"replies":[{"id":140386,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702050877,"ip_address":"重庆","comment_id":385040,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"function (&amp;mut s1) 值可以修改，且后面可以继续使用（引用传递）","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633385,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702050877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384924,"user_name":"文经","can_delete":false,"product_type":"c1","uid":1072346,"ip_address":"福建","ucode":"2C059BD2A4276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/da/0a8bc27b.jpg","comment_is_top":false,"comment_ctime":1701788091,"is_pvip":true,"replies":[{"id":140374,"content":"是的。所有指针相关的内存安全问题，在rust中一次性从语言层面原生解决了。你这个建议很好，适合从c语言过来的同学对照学习。后面我写一篇这样的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701919566,"ip_address":"重庆","comment_id":384924,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"有两个疑问\n1. 是不是代码只要遵守了这些引用的规则，就能够解决C语言中指针使用的所有不安全的问题？\n2. 没有这些规则，C语言指针能够实现的所有安全的功能，用Rust语言是否都能解决？\n如果能有个C语言中指针的问题清单，使用哪些规则分别解决什么问题的对应列表，理解起来就更透彻了。\n例如，越界，返回局部变量的地址，悬挂的指针等。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633229,"discussion_content":"是的。所有指针相关的内存安全问题，在rust中一次性从语言层面原生解决了。你这个建议很好，适合从c语言过来的同学对照学习。后面我写一篇这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701919566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384829,"user_name":"Apple_9029b4","can_delete":false,"product_type":"c1","uid":2865234,"ip_address":"上海","ucode":"FCCB8DDB110A7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/jwGOeRZ97OGOFTpW8AsJJNGHhPsm8hP3RvjnKyAibDfSZSjcvoFkDzZYXQS7pyqicwUe5WC5opEDYkrTG0Yazo2A/132","comment_is_top":false,"comment_ctime":1701658016,"is_pvip":false,"replies":[{"id":140325,"content":"对的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701745713,"ip_address":"","comment_id":384829,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"b的作用域是3-6行，在当中发生了写入，这个是不允许的","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633007,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701745713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384172,"user_name":"都市夜归人","can_delete":false,"product_type":"c1","uid":1071909,"ip_address":"北京","ucode":"DFF59BE3D80B42","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg","comment_is_top":false,"comment_ctime":1700461603,"is_pvip":false,"replies":[{"id":140155,"content":"1. c前面没加mut\n2. 解引用时，层次多了一个*号。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700539831,"ip_address":"重庆","comment_id":384172,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"\nfn main() {\n    let mut a = 10u32;\n    let mut b = &amp;mut a;\n    let c = &amp;mut b;\n    let d = &amp;mut c;\n\n    ****d = 30;\n\n    println!(&quot;{d}&quot;);\n}\n为何上面的c可以引用b；而d却不能再引用c了","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632170,"discussion_content":"1. c前面没加mut\n2. 解引用时，层次多了一个*号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700539831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384162,"user_name":"都市夜归人","can_delete":false,"product_type":"c1","uid":1071909,"ip_address":"北京","ucode":"DFF59BE3D80B42","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg","comment_is_top":false,"comment_ctime":1700448495,"is_pvip":false,"replies":[{"id":140159,"content":"b本身是可变借用，在最后一句用到的。a那一句是在println!里面自动加了一个 &amp;a 操作。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700540324,"ip_address":"重庆","comment_id":384162,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"println!(&quot;{a}&quot;);  &#47;&#47; 这一句移到的前面来  \n|               ^^^ immutable borrow occurs here&#47;&#47; 提示说这里发生了不可变借用7 |     \nprintln!(&quot;{b}&quot;);  \n|               --- mutable borrow later used here&#47;&#47; 在这后面使用了可变借用\n\n上面的代码中为何同样是println!语句，上面的是不可变借用而下面的却又是可变借用？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632174,"discussion_content":"b本身是可变借用，在最后一句用到的。a那一句是在println!里面自动加了一个 &amp;a 操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700540324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383851,"user_name":"5-刘新波(Arvin)","can_delete":false,"product_type":"c1","uid":1174199,"ip_address":"陕西","ucode":"DBD135D2587A93","user_header":"https://static001.geekbang.org/account/avatar/00/11/ea/b7/1a18a39d.jpg","comment_is_top":false,"comment_ctime":1699801759,"is_pvip":false,"replies":[{"id":139985,"content":"感谢你的评价，非常开心。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699846392,"ip_address":"重庆","comment_id":383851,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"讲的太棒，非常清晰！","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631613,"discussion_content":"感谢你的评价，非常开心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699846392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383452,"user_name":"Geek_f84b05","can_delete":false,"product_type":"c1","uid":3187308,"ip_address":"广东","ucode":"99FD920392A52C","user_header":"","comment_is_top":false,"comment_ctime":1699077140,"is_pvip":false,"replies":[{"id":139728,"content":"感谢提出的反馈，剩下的细节那一段确实表述有点问题。原意应该是要表达在同一小段代码里面同时出现这几种符号的情况。我们尽快修正。感谢。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699183057,"ip_address":"重庆","comment_id":383452,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"这段描述“我们来看剩下的一些语言细节。下面这段代码展示了 mut 修饰符，&amp;mut 和 &amp; 同时出现的情况，也就是说，可变引用和不可变引用是可以同时存在的。”与“在一个所有权型变量的可变引用与不可变引用的作用域不能交叠，也可以说不能同时存在。”相矛盾，事实上代码中的两个引用的作用域并没有重叠，也就是说可变引用和不可变引用是并没有同时存在","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630983,"discussion_content":"感谢提出的反馈，剩下的细节那一段确实表述有点问题。原意应该是要表达在同一小段代码里面同时出现这几种符号的情况。我们尽快修正。感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699183057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383385,"user_name":"Noya","can_delete":false,"product_type":"c1","uid":1519230,"ip_address":"浙江","ucode":"52EEB72E80BAF8","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","comment_is_top":false,"comment_ctime":1698958320,"is_pvip":false,"replies":[{"id":139672,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699001676,"ip_address":"重庆","comment_id":383385,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"    &#47;&#47; 思考题1\n    &#47;&#47; 问题: 为啥在不可变引用存在的情况下, 原变量不能被修改呢?\n    &#47;&#47; 我的解答: 因为如果可以修改原变量, 那么对于不可变引用来说相当于是可变了, 失去了不可变引用的意义\n    &#47;&#47; let mut a: u32 = 10;\n    &#47;&#47; let b = &amp;a;\n    &#47;&#47; a = 20;\n    &#47;&#47; println!(&quot;{}&quot;, b);\n\n    &#47;&#47; 思考题2\n    &#47;&#47; 问题: 可变引用复制的时候，为什么不允许 copy，而是 move?\n    &#47;&#47; 我的解答:\n    &#47;&#47;        如果是copy, 那么会发生两个可变引用同时存在的情况, 违反了可变引用的规则\n}\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630876,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699001676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383050,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"浙江","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1698373271,"is_pvip":false,"replies":[{"id":139536,"content":"动手play一下就懂了。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698388950,"ip_address":"重庆","comment_id":383050,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"多级引用那块没怎么看懂XD","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630401,"discussion_content":"动手play一下就懂了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698388950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383038,"user_name":"冷石","can_delete":false,"product_type":"c1","uid":1523432,"ip_address":"广东","ucode":"2A2B056A83E963","user_header":"https://static001.geekbang.org/account/avatar/00/17/3e/e8/3736f3cd.jpg","comment_is_top":false,"comment_ctime":1698340838,"is_pvip":false,"replies":[{"id":139516,"content":"谢谢支持，一起加油","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1698372950,"ip_address":"北京","comment_id":383038,"utype":2}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"赞👍","like_count":0,"discussions":[{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630372,"discussion_content":"谢谢支持，一起加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698372950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383015,"user_name":"Geek_004fb2","can_delete":false,"product_type":"c1","uid":1698399,"ip_address":"湖北","ucode":"D0CDAA6852AC3C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equY82MMjfvGtzlo8fhT9fdKO5LjWoy0P8pfCmiaFJS0v8Z4ibzrmwHjib9CnmgMiaYMhPyja7qS6KqiaQ/132","comment_is_top":false,"comment_ctime":1698304442,"is_pvip":false,"replies":[{"id":139508,"content":"对的。👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698327961,"ip_address":"重庆","comment_id":383015,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"1.明确声明的是不可变借用,拥有所有权的如果能改变值,那么对我这个不可变借用来说是不安全的\n2.如果Copy的话,违背了可变引用独占的原则","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630344,"discussion_content":"对的。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698327961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383000,"user_name":"二夕","can_delete":false,"product_type":"c1","uid":2907644,"ip_address":"浙江","ucode":"2587A8DE51F629","user_header":"https://static001.geekbang.org/account/avatar/00/2c/5d/fc/2e5e2a90.jpg","comment_is_top":false,"comment_ctime":1698292745,"is_pvip":false,"replies":[{"id":139507,"content":"棒","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698327897,"ip_address":"重庆","comment_id":383000,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"思考题 1：第三行创建了一个不可变引用，它会借用原始变量 a 的所有权，为了避免潜在的数据竞争和不确定性，a 在借用期间不能修改；\n思考题 2：Rust 借用规则中有说：一次只能由一个可变引用或多个只读引用。如果允许复制可变引用，就可能会导致多个可变引用同时存在，并同时修改同一个值，违反了 Rust 的借用规则。所以为了避免这种情况，Rust 禁止了可变引用的复制，只允许移动操作。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630343,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698327897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386728,"user_name":"舒灿","can_delete":false,"product_type":"c1","uid":3813096,"ip_address":"四川","ucode":"98266B5188DD9E","user_header":"https://static001.geekbang.org/account/avatar/00/3a/2e/e8/9dc046af.jpg","comment_is_top":false,"comment_ctime":1705418123,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100626901,"comment_content":"核心思想：值的使用不能产生竞争","like_count":1},{"had_liked":false,"id":395999,"user_name":"chai","can_delete":false,"product_type":"c1","uid":1202222,"ip_address":"天津","ucode":"C686EB1B1EBAB6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep66fdwo3ebSicKjf0iacAx4C2tZOthDDD4bSJqib1iauFBK6EoMSWUBp4UbbN2BQlib7mFR3hQD6MUwew/132","comment_is_top":false,"comment_ctime":1732637325,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100626901,"comment_content":"1、我认为在单线程模式中，可以同时存在多个可变引用和不可变引用，不会发生冲突；但是在多线程模式下，就不行了，不然由于可变引用会引发自动扩容，进而导致指向的堆地址发生变化，那么其他类型的引用就会出现悬垂指针的问题。\n\n2、可变引用复制的时候，为什么不允许 copy? \n答：如果允许copy，那么就会同时存在多个可变引用，与rust的规则冲突","like_count":0},{"had_liked":false,"id":392979,"user_name":"Seven","can_delete":false,"product_type":"c1","uid":2403766,"ip_address":"四川","ucode":"37D99CF8535CDE","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/b6/a8caa2c7.jpg","comment_is_top":false,"comment_ctime":1722388752,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100626901,"comment_content":"1. 在不可变借出读期前，如果改变了 a 的值，会导致读错误，类似数据库的幻读，导致数据不一致。按照借用原理，此时 a 的数据已经借出给 b 了。a手上没有东西，必须是无法编辑的。\n\n2. copy会复制一份变量，允许当前空间存在两份；也就违背了在一个作用域里面只允许存在一个独占可变引用的原则。类比生活就是，只有一本借出去的涂鸦书，a已经有了，b想用，只能从 a 哪里获取到，不能凭空生成一本一模一样的","like_count":0},{"had_liked":false,"id":392266,"user_name":"Geek_337881","can_delete":false,"product_type":"c1","uid":3922272,"ip_address":"广东","ucode":"632C54F3CD7EF6","user_header":"","comment_is_top":false,"comment_ctime":1720442779,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100626901,"comment_content":"一个变量有以下权限:读，写，销毁，不可变引用只能读，可以有多个，没有问题，但是读写权限只能有一个，即一个可变引用，而且还不能跟不可变引用共存，写的时候不能读，而销毁权限只有所有者自己！","like_count":0},{"had_liked":false,"id":391416,"user_name":"alexy","can_delete":false,"product_type":"c1","uid":1630242,"ip_address":"福建","ucode":"6ECFC6F6B21816","user_header":"https://static001.geekbang.org/account/avatar/00/18/e0/22/0812cfd5.jpg","comment_is_top":false,"comment_ctime":1718205758,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100626901,"comment_content":"1.在不可变引用存在的情况下，相当于不可变引用和所有权变量同时指向同一个内存地址，那么，此时如果允许所有权变量进行写入操作。就会造成不可变引用跟着改变（姑且这么理解），这样就违反了不可变的规则，同时也造成代码可读性变差（debug时，开发人员很疑惑，需要在一段很冗长的代码中寻找，哪里对这个变量进行了修改呢？）\n2.因为“同一时刻某个所有权变量只能存在一个可变引用，不能有超过一个可变借用同时存在”如果此时可变引用复制的时候允许copy，那么就违反了这一规则，我们也可以从实际应用来理解这个问题，如果同时存在多个可变借用，很容易出现悬垂引用（作用域相互交叠，从而引发的内存安全问题）\n有不对的地方，恳请老师指出\n\n","like_count":0},{"had_liked":false,"id":390143,"user_name":"Geek_db027f","can_delete":false,"product_type":"c1","uid":3875308,"ip_address":"北京","ucode":"A5B267DE972735","user_header":"https://static001.geekbang.org/account/avatar/00/3b/21/ec/829edcfd.jpg","comment_is_top":false,"comment_ctime":1714460489,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100626901,"comment_content":"问题1：    let mut a: u32 = 10; \n    let b = &amp;a; &#47;&#47;b的生命周期在第三行\n    a = 20; &#47;&#47;出作用域了没有问题\n    println!(&quot;{}&quot;, b);&#47;&#47;如果有这句话，说明b的生命周期拉长到这里，这也就是导致a不能修改的原因。规律：在有引用存在下，不能通过原所有权变量来对值进行更新，除非引用的生命周期结束。\n问题2：    &#47;&#47;可变引用复制例子\n    let mut x: i32 = 5; &#47;&#47;x add: 0xaecaaff76c, x: 5\n    println!(&quot;x add: {:p}, x: {}&quot;, &amp;x, x);\n    {\n        let y: &amp;mut i32 = &amp;mut x; &#47;&#47;如果是copy则 y不会影响到x的值\n        \n        *y += 1;\n\n        print!(&quot;y address: {:p}, y:{:p}, y: {}&quot;, &amp;y, y, y); &#47;&#47;y address: 0xaecaaff7c8, y:0xaecaaff76c, y: 6\n    }","like_count":0},{"had_liked":false,"id":383384,"user_name":"Noya","can_delete":false,"product_type":"c1","uid":1519230,"ip_address":"浙江","ucode":"52EEB72E80BAF8","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","comment_is_top":false,"comment_ctime":1698957984,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100626901,"comment_content":"&#47;&#47; Note\n&#47;&#47; 引用语法 &amp; 与 &amp;mut ,解引用 *\n\n&#47;&#47; 所有权型变量, 引用型变量\n\n&#47;&#47; 引用的作用域-&gt; 从声明开始到最后一次使用的地方\n&#47;&#47; 引用的限制\n&#47;&#47;   1. 对同一个 所有权型变量 的 可变引用 的作用域不能交叠(不能同时存在两个可变引用)\n&#47;&#47;   2. 对同一个 所有权型变量 的 可变引用 与 不可变引用 的作用域不能交叠(不能同时存在一个可变引用和一个不可变引用)\n\n&#47;&#47; 在一个所有权型变量有借用(可变&#47;不可变)的情况下, 不能直接修改这个所有权型变量的值(可间接-&gt; 可变引用 解引用)\n\n&#47;&#47; 将可变引用赋值给另一个变量, 会导致原来的可变引用失效(可以看成与所有权型变量一样,会发生所有权转移)\n\n&#47;&#47; 多级引用\n&#47;&#47;  1. 解引用修改值(注意层数)\n&#47;&#47;  2. println! 会自动解引用找到最终的值\n&#47;&#47;  3. 如果要通过多级引用修改值,需要保证中间的引用都是可变引用","like_count":0}]}