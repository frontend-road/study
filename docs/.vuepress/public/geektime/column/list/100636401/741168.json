{"id":741168,"title":"13｜Filter与Listener：如何实现过滤和持续监听？","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上一节课我们实现了Pipeline和Valve，这样我们在流程走通的前提下，可以在每一层Container之间增加权限校验、日志打印、错误输出等自定义的处理逻辑。此外我们引入了责任链这一设计模式，来依次调用这些处理逻辑。</p><p>这节课我们继续来完善MiniTomcat，我们计划引入两个组件——Filter（过滤器）以及Listener（监听器），并且还是使用经典的职责链模式。</p><p>过滤器可以检查请求对象以及返回对象，并通过请求对象和返回对象的包装类进行修改，而且多个过滤器之间可以串联，就像流水线一样一层层进行过滤，协同起来组装成最终的请求对象和响应对象。</p><p>而监听器的存在是为了配合我们目前已有的Container、Session等机制，通过监听这些机制的事件，比如启动、超时、结束等，更好地对服务器进行处理。</p><p>我们一起来动手实现。</p><h2>项目结构</h2><p>这节课我们主要新增了Filter相关处理方法类，还有Container、Instance与Session的事件和监听器，具体类的功能我们后面会详细介绍。你可以看一下现在的项目结构。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ com\n│  │  │  │  ├─ minit\n│  │  │  │  │  ├─ connector\n│  │  │  │  │  │  ├─ http\n│  │  │  │  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  │  │  │  ├─ HttpConnector.java\n│  │  │  │  │  │  │  ├─ HttpHeader.java\n│  │  │  │  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  │  │  │  ├─ HttpRequestImpl.java\n│  │  │  │  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  │  │  │  ├─ HttpResponseImpl.java\n│  │  │  │  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  │  │  │  ├─ StatisResourceProcessor.java\n│  │  │  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  │  ├─ core\n│  │  │  │  │  │  ├─ ApplicationFilterChain.java\n│  │  │  │  │  │  ├─ ApplicationFilterConfig.java\n│  │  │  │  │  │  ├─ ContainerBase.java\n│  │  │  │  │  │  ├─ ContainerListenerDef.java\n│  │  │  │  │  │  ├─ FilterDef.java\n│  │  │  │  │  │  ├─ FilterMap.java\n│  │  │  │  │  │  ├─ StandardContext.java\n│  │  │  │  │  │  ├─ StandardContextValve.java\n│  │  │  │  │  │  ├─ StandardPipeline.java\n│  │  │  │  │  │  ├─ StandardWrapper.java\n│  │  │  │  │  │  ├─ StandardWrapperValve.java\n│  │  │  │  │  ├─ logger\n│  │  │  │  │  │  ├─ Constants.java\n│  │  │  │  │  │  ├─ FileLogger.java\n│  │  │  │  │  │  ├─ LoggerBase.java\n│  │  │  │  │  │  ├─ SystemErrLogger.java\n│  │  │  │  │  │  ├─ SystemOutLogger.java\n│  │  │  │  │  ├─ session\n│  │  │  │  │  │  ├─ StandardSession.java\n│  │  │  │  │  │  ├─ StandardSessionFacade.java\n│  │  │  │  │  ├─ startup\n│  │  │  │  │  │  ├─ BootStrap.java\n│  │  │  │  │  ├─ util\n│  │  │  │  │  │  ├─ CookieTools.java\n│  │  │  │  │  │  ├─ StringManager.java\n│  │  │  │  │  │  ├─ URLDecoder.java\n│  │  │  │  │  ├─ valves\n│  │  │  │  │  │  ├─ AccessLogValve.java\n│  │  │  │  │  │  ├─ ValveBase.java\n│  │  │  │  ├─ Connector.java\n│  │  │  │  ├─ Container.java\n│  │  │  │  ├─ ContainerEvent.java\n│  │  │  │  ├─ ContainerListener.java\n│  │  │  │  ├─ Context.java\n│  │  │  │  ├─ InstanceEvent.java\n│  │  │  │  ├─ InstanceListener.java\n│  │  │  │  ├─ Logger.java\n│  │  │  │  ├─ Pipeline.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionEvent.java\n│  │  │  │  ├─ SessionListener.java\n│  │  │  │  ├─ Valve.java\n│  │  │  │  ├─ ValveContext.java\n│  │  │  │  ├─ Wrapper.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestFilter.java\n│  │  │  │  ├─ TestListener.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  │  ├─ TestFilter.class\n│  │  ├─ TestListener.class\n│  │  ├─ TestServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><!-- [[[read_end]]] --><h2>引入过滤器</h2><p>首先我们看看如何引入过滤器。按照Servlet规范，我们定义了Filter、FilterConfig和FilterChain三个接口。我们先采用ApplicationFilterConfig类，对Filter进行包装。你可以看一下ApplicationFilterConfig类的定义。</p><pre><code class=\"language-java\">package com.minit.core;\nfinal class ApplicationFilterConfig implements FilterConfig {\n    public ApplicationFilterConfig(Context context, FilterDef filterDef)\n            throws ClassCastException, ClassNotFoundException,\n            IllegalAccessException, InstantiationException,\n            ServletException {\n        super();\n        this.context = context;\n        setFilterDef(filterDef);\n    }\n    private Context context = null;\n    private Filter filter = null;\n    private FilterDef filterDef = null;\n    public String getFilterName() {\n        return (filterDef.getFilterName());\n    }\n    public String getInitParameter(String name) {\n        Map&lt;String,String&gt; map = filterDef.getParameterMap();\n        if (map == null)\n            return (null);\n        else\n            return ((String) map.get(name));\n    }\n    public Enumeration&lt;String&gt; getInitParameterNames() {\n        Map&lt;String,String&gt; map = filterDef.getParameterMap();\n        if (map == null)\n            return Collections.enumeration(new ArrayList&lt;String&gt;());\n        else\n            return (Collections.enumeration(map.keySet()));\n    }\n    public ServletContext getServletContext() {\n        return (this.context.getServletContext());\n    }\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"ApplicationFilterConfig[\");\n        sb.append(\"name=\");\n        sb.append(filterDef.getFilterName());\n        sb.append(\", filterClass=\");\n        sb.append(filterDef.getFilterClass());\n        sb.append(\"]\");\n        return (sb.toString());\n    }\n    Filter getFilter() throws ClassCastException, ClassNotFoundException,\n            IllegalAccessException, InstantiationException, ServletException {\n        // 返回现有的过滤器实例（如果有的话）\n        if (this.filter != null)\n            return (this.filter);\n        // 确定我们将使用的类加载器\n        String filterClass = filterDef.getFilterClass();\n        ClassLoader classLoader = null;\n        classLoader = context.getLoader();\n        ClassLoader oldCtxClassLoader =\n                Thread.currentThread().getContextClassLoader();\n        // 实例化这个过滤器的新实例并返回\n        Class clazz = classLoader.loadClass(filterClass);\n        this.filter = (Filter) clazz.newInstance();\n        filter.init(this);\n        return (this.filter);\n    }\n    FilterDef getFilterDef() {\n        return (this.filterDef);\n    }\n    void release() {\n        if (this.filter != null)\n            filter.destroy();\n        this.filter = null;\n    }\n    void setFilterDef(FilterDef filterDef)\n            throws ClassCastException, ClassNotFoundException,\n            IllegalAccessException, InstantiationException,\n            ServletException {\n        this.filterDef = filterDef;\n        if (filterDef == null) {\n            // 释放之前分配的所有过滤器实例\n            if (this.filter != null)\n                this.filter.destroy();\n            this.filter = null;\n        } else {\n            // 分配一个新的过滤器实例\n            Filter filter = getFilter();\n        }\n    }\n}\n</code></pre><p>通过ApplicationFilterConfig类的实现我们可以看到，引入了Filter对象，这个Filter对象就是 <code>javax.servlet.Filter</code>，同时还定义了Context和FilterDef，FilterDef定义了Filter的部分参数信息，你可以看一下相关实现。</p><pre><code class=\"language-java\">package com.minit.core;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\npublic final class FilterDef {\n    private String description = null;\n    public String getDescription() {\n        return (this.description);\n    }\n    public void setDescription(String description) {\n        this.description = description;\n    }\n    private String displayName = null;\n    public String getDisplayName() {\n        return (this.displayName);\n    }\n    public void setDisplayName(String displayName) {\n        this.displayName = displayName;\n    }\n    private String filterClass = null;\n    public String getFilterClass() {\n        return (this.filterClass);\n    }\n    public void setFilterClass(String filterClass) {\n        this.filterClass = filterClass;\n    }\n    private String filterName = null;\n    public String getFilterName() {\n        return (this.filterName);\n    }\n    public void setFilterName(String filterName) {\n        this.filterName = filterName;\n    }\n    private String largeIcon = null;\n    public String getLargeIcon() {\n        return (this.largeIcon);\n    }\n    public void setLargeIcon(String largeIcon) {\n        this.largeIcon = largeIcon;\n    }\n    private Map&lt;String,String&gt; parameters = new ConcurrentHashMap&lt;&gt;();\n    public Map&lt;String,String&gt; getParameterMap() {\n        return (this.parameters);\n    }\n    private String smallIcon = null;\n    public String getSmallIcon() {\n        return (this.smallIcon);\n    }\n    public void setSmallIcon(String smallIcon) {\n        this.smallIcon = smallIcon;\n    }\n    public void addInitParameter(String name, String value) {\n        parameters.put(name, value);\n    }\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"FilterDef[\");\n        sb.append(\"filterName=\");\n        sb.append(this.filterName);\n        sb.append(\", filterClass=\");\n        sb.append(this.filterClass);\n        sb.append(\"]\");\n        return (sb.toString());\n    }\n}\n</code></pre><p>FilterDef定义不难理解，主要包括Filter的描述、名称等信息，定义了众多Getter和Setter方法。在FilterDef类定义完毕后，我们就通过Config拿到了Filter，并进行初始化工作。</p><p>由于支持多个FilterConfig，所以我们使用链路模式进行管理，定义ApplicationFilterChain类。</p><pre><code class=\"language-java\">package com.minit.core;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport com.minit.connector.HttpRequestFacade;\nimport com.minit.connector.HttpResponseFacade;\nimport com.minit.connector.http.HttpRequestImpl;\nimport com.minit.connector.http.HttpResponseImpl;\nfinal class ApplicationFilterChain implements FilterChain {\n    public ApplicationFilterChain() {\n        super();\n    }\n    private ArrayList&lt;ApplicationFilterConfig&gt; filters = new ArrayList&lt;&gt;();\n    private Iterator&lt;ApplicationFilterConfig&gt; iterator = null;\n    private Servlet servlet = null;\n    \n    //核心方法，启动过滤\n    public void doFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException {\n        System.out.println(\"FilterChain doFilter()\");\n        internalDoFilter(request,response);\n    }\n    private void internalDoFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException {\n        if (this.iterator == null)\n            this.iterator = filters.iterator();\n        if (this.iterator.hasNext()) {\n            //拿到下一个filter\n            ApplicationFilterConfig filterConfig =\n                    (ApplicationFilterConfig) iterator.next();\n            Filter filter = null;\n            try {\n                //进行过滤，这是职责链模式，一个一个往下传\n                filter = filterConfig.getFilter();\n                System.out.println(\"Filter doFilter()\");\n                //调用filter的过滤逻辑，根据规范，filter中要再次调用filterChain.doFilter\n                //这样又会回到internalDoFilter()方法，就会再拿到下一个filter，\n                //如此实现一个一个往下传\n                filter.doFilter(request, response, this);\n            } catch (IOException e) {\n                throw e;\n            } catch (ServletException e) {\n                throw e;\n            } catch (RuntimeException e) {\n                throw e;\n            } catch (Throwable e) {\n                throw new ServletException(\"filterChain.filter\", e);\n            }\n            return;\n        }\n        try {\n            //最后调用servlet\n            HttpServletRequest requestFacade = new HttpRequestFacade((HttpRequestImpl) request);\n            HttpServletResponse responseFacade = new HttpResponseFacade((HttpResponseImpl) response);\n            servlet.service(requestFacade, responseFacade);\n        } catch (IOException e) {\n            throw e;\n        } catch (ServletException e) {\n            throw e;\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Throwable e) {\n            throw new ServletException(\"filterChain.servlet\", e);\n        }\n    }\n    void addFilter(ApplicationFilterConfig filterConfig) {\n        this.filters.add(filterConfig);\n    }\n    void release() {\n        this.filters.clear();\n        this.iterator = iterator;\n        this.servlet = null;\n    }\n    void setServlet(Servlet servlet) {\n        this.servlet = servlet;\n    }\n}\n</code></pre><p>我们使用ArrayList存放所有的filter，而最重要的实现方法就是 <strong>doFilter</strong>，这也是FilterChain接口本身所定义的，我们在这进行了实现。doFilter方法内又调用了internalDoFilter方法来实现。我们使用了iterator迭代器指向filters，通过 <code>filterConfig.getFilter()</code> 方法获取第一个filter后调用 <code>filter.doFilter(request, response, this)</code>。</p><p>需要注意的是，这个地方调用了第一个 <code>Filter.doFilter()</code>，而不是在ApplicationFilterChain中迭代遍历。之后的filter还是采用职责链设计模式，由第一个Filter调用下一个，一个一个地继续。</p><p>当所有Filter过滤完之后，执行 <code>servlet.service(requestFacade, responseFacade)</code> 方法，这也是Filter Chain自动完成的，<code>service()</code> 成了Chain之后的一个环节，所以Processor和Container不再需要显式地调用 <code>service()</code>。</p><p>有了这些准备后，我们接下来可以把Filter加入到Container里，每一层都可以加，我们只在StandardContext这一层保存，重新启动的时候在BootStrap里加上，调用的程序写在StandardWrapperValve里。</p><p>接下来我们看看如何实现，首先定义FilterMap类以及URLDecoder工具类。</p><p>URLDecoder工具类：</p><pre><code class=\"language-java\">package com.minit.util;\npublic class URLDecoder {\n    public static String URLDecode(String str) {\n        return URLDecode(str, null);\n    }\n    public static String URLDecode(String str, String enc) {\n        if (str == null)\n            return (null);\n        int len = str.length();\n        byte[] bytes = new byte[len];\n        bytes = str.getBytes();\n        return URLDecode(bytes, enc);\n    }\n    public static String URLDecode(byte[] bytes) {\n        return URLDecode(bytes, null);\n    }\n    public static String URLDecode(byte[] bytes, String enc) {\n        if (bytes == null)\n            return (null);\n        int len = bytes.length;\n        int ix = 0;\n        int ox = 0;\n        while (ix &lt; len) {\n            byte b = bytes[ix++];     // 获取要测试的字节\n            if (b == '+') {\n                b = (byte)' ';\n            } else if (b == '%') {\n                b = (byte) ((convertHexDigit(bytes[ix++]) &lt;&lt; 4)\n                        + convertHexDigit(bytes[ix++]));\n            }\n            bytes[ox++] = b;\n        }\n        if (enc != null) {\n            try {\n                return new String(bytes, 0, ox, enc);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return new String(bytes, 0, ox);\n    }\n    private static byte convertHexDigit( byte b ) {\n        if ((b &gt;= '0') &amp;&amp; (b &lt;= '9')) return (byte)(b - '0');\n        if ((b &gt;= 'a') &amp;&amp; (b &lt;= 'f')) return (byte)(b - 'a' + 10);\n        if ((b &gt;= 'A') &amp;&amp; (b &lt;= 'F')) return (byte)(b - 'A' + 10);\n        return 0;\n    }\n}\n</code></pre><p>FilterMap类：</p><pre><code class=\"language-java\">package com.minit.core;\nimport com.minit.util.URLDecoder;\npublic final class FilterMap {\n    private String filterName = null;\n    public String getFilterName() {\n        return (this.filterName);\n    }\n    public void setFilterName(String filterName) {\n        this.filterName = filterName;\n    }\n    private String servletName = null;\n    public String getServletName() {\n        return (this.servletName);\n    }\n    public void setServletName(String servletName) {\n        this.servletName = servletName;\n    }\n    private String urlPattern = null;\n    public String getURLPattern() {\n        return (this.urlPattern);\n    }\n    public void setURLPattern(String urlPattern) {\n        this.urlPattern = URLDecoder.URLDecode(urlPattern);\n    }\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"FilterMap[\");\n        sb.append(\"filterName=\");\n        sb.append(this.filterName);\n        if (servletName != null) {\n            sb.append(\", servletName=\");\n            sb.append(servletName);\n        }\n        if (urlPattern != null) {\n            sb.append(\", urlPattern=\");\n            sb.append(urlPattern);\n        }\n        sb.append(\"]\");\n        return (sb.toString());\n    }\n}\n</code></pre><p>紧接着调整StandardContext，新增下面这些代码。这些代码进行了过滤器的配置和处理。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardContext extends ContainerBase implements Context{\n    //下面的属性记录了filter的配置\n    private Map&lt;String,ApplicationFilterConfig&gt; filterConfigs = new ConcurrentHashMap&lt;&gt;();\n    private Map&lt;String,FilterDef&gt; filterDefs = new ConcurrentHashMap&lt;&gt;();\n    private FilterMap filterMaps[] = new FilterMap[0];\n    \n    public void addFilterDef(FilterDef filterDef) {\n        filterDefs.put(filterDef.getFilterName(), filterDef);\n    }\n    public void addFilterMap(FilterMap filterMap) {\n        // 验证所建议的过滤器映射\n        String filterName = filterMap.getFilterName();\n        String servletName = filterMap.getServletName();\n        String urlPattern = filterMap.getURLPattern();\n        if (findFilterDef(filterName) == null)\n            throw new IllegalArgumentException(\"standardContext.filterMap.name\"+filterName);\n        if ((servletName == null) &amp;&amp; (urlPattern == null))\n            throw new IllegalArgumentException(\"standardContext.filterMap.either\");\n        if ((servletName != null) &amp;&amp; (urlPattern != null))\n            throw new IllegalArgumentException(\"standardContext.filterMap.either\");\n        // 因为过滤器模式是2.3中的新功能，所以不需要调整\n        // 对于2.2版本的向后兼容性\n        if ((urlPattern != null) &amp;&amp; !validateURLPattern(urlPattern))\n            throw new IllegalArgumentException(\"standardContext.filterMap.pattern\"+urlPattern);\n        // 将这个过滤器映射添加到我们已注册的集合中\n        synchronized (filterMaps) {\n            FilterMap results[] =new FilterMap[filterMaps.length + 1];\n            System.arraycopy(filterMaps, 0, results, 0, filterMaps.length);\n            results[filterMaps.length] = filterMap;\n            filterMaps = results;\n        }\n    }\n    public FilterDef findFilterDef(String filterName) {\n        return ((FilterDef) filterDefs.get(filterName));\n    }\n    public FilterDef[] findFilterDefs() {\n        synchronized (filterDefs) {\n            FilterDef results[] = new FilterDef[filterDefs.size()];\n            return ((FilterDef[]) filterDefs.values().toArray(results));\n        }\n    }\n    public FilterMap[] findFilterMaps() {\n        return (filterMaps);\n    }\n    public void removeFilterDef(FilterDef filterDef) {\n        filterDefs.remove(filterDef.getFilterName());\n    }\n    \n    public void removeFilterMap(FilterMap filterMap) {\n        synchronized (filterMaps) {\n            // 确保当前存在这个过滤器映射\n            int n = -1;\n            for (int i = 0; i &lt; filterMaps.length; i++) {\n                if (filterMaps[i] == filterMap) {\n                    n = i;\n                    break;\n                }\n            }\n            if (n &lt; 0)\n                return;\n            // 删除指定的过滤器映射\n            FilterMap results[] = new FilterMap[filterMaps.length - 1];\n            System.arraycopy(filterMaps, 0, results, 0, n);\n            System.arraycopy(filterMaps, n + 1, results, n,\n                    (filterMaps.length - 1) - n);\n            filterMaps = results;\n        }\n    }\n    //对配置好的所有filter名字，创建实例，存储在filterConfigs中，可以生效了\n    public boolean filterStart() {\n        System.out.println(\"Filter Start..........\");\n        // 为每个定义的过滤器实例化并记录一个FilterConfig\n        boolean ok = true;\n        synchronized (filterConfigs) {\n            filterConfigs.clear();\n            Iterator&lt;String&gt; names = filterDefs.keySet().iterator();\n            while (names.hasNext()) {\n                String name = names.next();\n                ApplicationFilterConfig filterConfig = null;\n                try {\n                    filterConfig = new ApplicationFilterConfig\n                            (this, (FilterDef) filterDefs.get(name));\n                    filterConfigs.put(name, filterConfig);\n                } catch (Throwable t) {\n                    ok = false;\n                }\n            }\n        }\n        return (ok);\n    }\n    public FilterConfig findFilterConfig(String name) {\n        return (filterConfigs.get(name));\n    }\n    private boolean validateURLPattern(String urlPattern) {\n        if (urlPattern == null)\n            return (false);\n        if (urlPattern.startsWith(\"*.\")) {\n            if (urlPattern.indexOf('/') &lt; 0)\n                return (true);\n            else\n                return (false);\n        }\n        if (urlPattern.startsWith(\"/\"))\n            return (true);\n        else\n            return (false);\n    }\n}\n</code></pre><p>可以看到StandardContext里主要定义了filter的启动方法，用来在BootStrap启动类中启动过滤器。</p><p>接下来再调整StandardContextValve类里的invoke方法的实现，增加了filter的支持，不是直接调用Servlet，而是放在filterChain中进行调用，即先进行过滤，然后再到Servlet。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardWrapperValve extends ValveBase {\n    private FilterDef filterDef = null;\n    @Override\n    public void invoke(Request request, Response response, ValveContext context) throws IOException, ServletException {\n        //创建filter Chain，再调用filter，然后调用servlet\n        System.out.println(\"StandardWrapperValve invoke()\");\n        Servlet instance = ((StandardWrapper)getContainer()).getServlet();\n        ApplicationFilterChain filterChain = createFilterChain(request, instance);\n        if ((instance != null) &amp;&amp; (filterChain != null)) {\n            filterChain.doFilter((ServletRequest)request, (ServletResponse)response);\n        }\n        filterChain.release();\n    }\n    //根据context中的filter map信息挑选出符合模式的filter，创建filterChain\n    private ApplicationFilterChain createFilterChain(Request request, Servlet servlet) {\n        System.out.println(\"createFilterChain()\");\n        if (servlet == null)\n            return (null);\n        ApplicationFilterChain filterChain = new ApplicationFilterChain();\n        filterChain.setServlet(servlet);\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        StandardContext context = (StandardContext) wrapper.getParent();\n        //从context中拿到filter的信息\n        FilterMap filterMaps[] = context.findFilterMaps();\n        if ((filterMaps == null) || (filterMaps.length == 0))\n            return (filterChain);\n        //要匹配的路径\n        String requestPath = null;\n        if (request instanceof HttpServletRequest) {\n            String contextPath = \"\";\n            String requestURI = ((HttpRequestImpl)request).getUri(); //((HttpServletRequest) request).getRequestURI();\n            if (requestURI.length() &gt;= contextPath.length())\n                requestPath = requestURI.substring(contextPath.length());\n        }\n        //要匹配的servlet名\n        String servletName = wrapper.getName();\n        \n        //下面遍历filter Map，找到匹配URL模式的filter，加入到filterChain中\n        int n = 0;\n        for (int i = 0; i &lt; filterMaps.length; i++) {\n            if (!matchFiltersURL(filterMaps[i], requestPath))\n                continue;\n            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)\n                    context.findFilterConfig(filterMaps[i].getFilterName());\n            if (filterConfig == null) {\n                continue;\n            }\n            filterChain.addFilter(filterConfig);\n            n++;\n        }\n        //下面遍历filter Map，找到匹配servlet的filter，加入到filterChain中\n        for (int i = 0; i &lt; filterMaps.length; i++) {\n            if (!matchFiltersServlet(filterMaps[i], servletName))\n                continue;\n            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)\n                    context.findFilterConfig(filterMaps[i].getFilterName());\n            if (filterConfig == null) {\n                continue;\n            }\n            filterChain.addFilter(filterConfig);\n            n++;\n        }\n        return (filterChain);\n    }\n    //字符串模式匹配filter的过滤路径\n    private boolean matchFiltersURL(FilterMap filterMap, String requestPath) {\n        if (requestPath == null)\n            return (false);\n        String testPath = filterMap.getURLPattern();\n        if (testPath == null)\n            return (false);\n        if (testPath.equals(requestPath))\n            return (true);\n        if (testPath.equals(\"/*\"))\n            return (true);\n        if (testPath.endsWith(\"/*\")) { //路径符合/前缀，通配成功\n            String comparePath = requestPath;\n            while (true) {  //以/截取前段字符串，循环匹配\n                if (testPath.equals(comparePath + \"/*\"))\n                    return (true);\n                int slash = comparePath.lastIndexOf('/');\n                if (slash &lt; 0)\n                    break;\n                comparePath = comparePath.substring(0, slash);\n            }\n            return (false);\n        }\n        if (testPath.startsWith(\"*.\")) {\n            int slash = requestPath.lastIndexOf('/');\n            int period = requestPath.lastIndexOf('.');\n            if ((slash &gt;= 0) &amp;&amp; (period &gt; slash))\n                return (testPath.equals(\"*.\" + requestPath.substring(period + 1)));\n        }\n        return (false); // NOTE - Not relevant for selecting filters\n    }\n    private boolean matchFiltersServlet(FilterMap filterMap, String servletName) {\n        if (servletName == null)\n            return (false);\n        else\n            return (servletName.equals(filterMap.getServletName()));\n    }\n}\n\n</code></pre><p>最后调整BootStrap类，你可以看一下当前main函数的实现。主要的变化就是配置了filter信息、名称、类名、过滤路径等等。</p><pre><code class=\"language-java\">package com.minit.startup;\npublic class BootStrap {\n    public static void main(String[] args) {\n        if (debug &gt;= 1)\n            log(\".... startup ....\");\n        HttpConnector connector = new HttpConnector();\n        StandardContext container = new StandardContext();\n        connector.setContainer(container);\n        container.setConnector(connector);\n        Logger logger = new FileLogger();\n        container.setLogger(logger);\n        FilterDef filterDef = new FilterDef();\n        filterDef.setFilterName(\"TestFilter\");\n        filterDef.setFilterClass(\"test.TestFilter\");\n        container.addFilterDef(filterDef);\n        FilterMap filterMap = new FilterMap();\n        filterMap.setFilterName(\"TestFilter\");\n        filterMap.setURLPattern(\"/*\");\n        container.addFilterMap(filterMap);\n        container.filterStart();\n        connector.start();\n    }\n}\n</code></pre><p>这样Filter就定义好了，我们可以在测试文件夹里定义TestFIlter类来测试一下。</p><pre><code class=\"language-java\">package test;\npublic class TestFilter implements Filter{\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        System.out.println(\"The very first Filter\");\n        chain.doFilter(request, response);\n    }\n}\n</code></pre><p>测试类比较简单，实现Servlet的标准Filter规范，实现doFilter方法。</p><p>完成过滤器的定义与实现后，我们再来看监听器的实现。</p><h2>引入监听器</h2><p>监听器一般和事件共同存在，也就是先有事件定义，后面对这个事件进行监听。在MiniTomcat里，我们定义InstanceListener、ContainerListener、SessionListener三种监听器以及对应的事件，分别作用于整个对象实例、容器Container和Session处理。这样我们MiniTomcat内部主要对象的各种行为都能够被监听了。</p><p>我们先来看看事件和监听器的代码定义。</p><p>ContainerEvent是一个基础的容器事件对象。</p><pre><code class=\"language-java\">package com.minit;\npublic final class ContainerEvent extends EventObject {\n    private Container container = null;\n    private Object data = null;\n    private String type = null;\n    public ContainerEvent(Container container, String type, Object data) {\n        super(container);\n        this.container = container;\n        this.type = type;\n        this.data = data;\n    }\n    public Object getData() {\n        return (this.data);\n    }\n    public Container getContainer() {\n        return (this.container);\n    }\n    public String getType() {\n        return (this.type);\n    }\n    public String toString() {\n        return (\"ContainerEvent['\" + getContainer() + \"','\" +\n                getType() + \"','\" + getData() + \"']\");\n    }\n}\n</code></pre><p>ContainerListener用于监听容器事件。</p><pre><code class=\"language-java\">package com.minit;\npublic interface ContainerListener {\n    public void containerEvent(ContainerEvent event);\n}\n</code></pre><p>InstanceEvent是Servlet的事件。</p><pre><code class=\"language-java\">package com.minit;\npublic final class InstanceEvent extends EventObject {\n    public static final String BEFORE_INIT_EVENT = \"beforeInit\";\n    public static final String AFTER_INIT_EVENT = \"afterInit\";\n    public static final String BEFORE_SERVICE_EVENT = \"beforeService\";\n    public static final String AFTER_SERVICE_EVENT = \"afterService\";\n    public static final String BEFORE_DESTROY_EVENT = \"beforeDestroy\";\n    public static final String AFTER_DESTROY_EVENT = \"afterDestroy\";\n    public static final String BEFORE_DISPATCH_EVENT = \"beforeDispatch\";\n    public static final String AFTER_DISPATCH_EVENT = \"afterDispatch\";\n    public static final String BEFORE_FILTER_EVENT = \"beforeFilter\";\n    public static final String AFTER_FILTER_EVENT = \"afterFilter\";\n    public InstanceEvent(Wrapper wrapper, Filter filter, String type) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = filter;\n        this.servlet = null;\n        this.type = type;\n    }\n    public InstanceEvent(Wrapper wrapper, Filter filter, String type,\n                         Throwable exception) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = filter;\n        this.servlet = null;\n        this.type = type;\n        this.exception = exception;\n    }\n    public InstanceEvent(Wrapper wrapper, Filter filter, String type,\n                         ServletRequest request, ServletResponse response) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = filter;\n        this.servlet = null;\n        this.type = type;\n        this.request = request;\n        this.response = response;\n    }\n    public InstanceEvent(Wrapper wrapper, Filter filter, String type,\n                         ServletRequest request, ServletResponse response,\n                         Throwable exception) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = filter;\n        this.servlet = null;\n        this.type = type;\n        this.request = request;\n        this.response = response;\n        this.exception = exception;\n    }\n    public InstanceEvent(Wrapper wrapper, Servlet servlet, String type) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = null;\n        this.servlet = servlet;\n        this.type = type;\n    }\n    public InstanceEvent(Wrapper wrapper, Servlet servlet, String type,\n                         Throwable exception) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = null;\n        this.servlet = servlet;\n        this.type = type;\n        this.exception = exception;\n    }\n    public InstanceEvent(Wrapper wrapper, Servlet servlet, String type,\n                         ServletRequest request, ServletResponse response) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = null;\n        this.servlet = servlet;\n        this.type = type;\n        this.request = request;\n        this.response = response;\n    }\n    public InstanceEvent(Wrapper wrapper, Servlet servlet, String type,\n                         ServletRequest request, ServletResponse response,\n                         Throwable exception) {\n        super(wrapper);\n        this.wrapper = wrapper;\n        this.filter = null;\n        this.servlet = servlet;\n        this.type = type;\n        this.request = request;\n        this.response = response;\n        this.exception = exception;\n    }\n    private Throwable exception = null;\n    private Filter filter = null;\n    private ServletRequest request = null;\n    private ServletResponse response = null;\n    private Servlet servlet = null;\n    private String type = null;\n    private Wrapper wrapper = null;\n    public Throwable getException() {\n        return (this.exception);\n    }\n    public Filter getFilter() {\n        return (this.filter);\n    }\n    public ServletRequest getRequest() {\n        return (this.request);\n    }\n    public ServletResponse getResponse() {\n        return (this.response);\n    }\n    public Servlet getServlet() {\n        return (this.servlet);\n    }\n    public String getType() {\n        return (this.type);\n    }\n    public Wrapper getWrapper() {\n        return (this.wrapper);\n    }\n}\n</code></pre><p>InstanceListener是Servlet事件的监听器。</p><pre><code class=\"language-java\">package com.minit;\npublic interface InstanceListener {\n    public void instanceEvent(InstanceEvent event);\n}\n</code></pre><p>SessionEvent是session事件。</p><pre><code class=\"language-java\">package com.minit;\npublic final class SessionEvent extends EventObject {\n    private Object data = null;\n    private Session session = null;\n    private String type = null;\n    public SessionEvent(Session session, String type, Object data) {\n        super(session);\n        this.session = session;\n        this.type = type;\n        this.data = data;\n    }\n    public Object getData() {\n        return (this.data);\n    }\n    public Session getSession() {\n        return (this.session);\n    }\n    public String getType() {\n        return (this.type);\n    }\n    public String toString() {\n        return (\"SessionEvent['\" + getSession() + \"','\" +\n                getType() + \"']\");\n    }\n}\n</code></pre><p>SessionListener是session事件监听器。</p><pre><code class=\"language-java\">package com.minit;\npublic interface SessionListener {\n    public void sessionEvent(SessionEvent event);\n}\n</code></pre><p>有了这些事件和监听器的定义后，在响应的类里面加上 <code>addlistener()</code>、<code>removelistener()</code> 方法以及 <code>fireEvent()</code> 就可以了。所以在StandardContext类和StandardSession类中，我们可以添加这三个方法，你可以看一下相关实现。</p><p>首先是StandardContext类，我们在代码里新增方法实现。这些新代码处理了容器监听器。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardContext extends ContainerBase implements Context{\n    private ArrayList&lt;ContainerListenerDef&gt; listenerDefs = new ArrayList&lt;&gt;();\n    private ArrayList&lt;ContainerListener&gt; listeners = new ArrayList&lt;&gt;();\n    \n    public void start(){\n    &nbsp;   // 触发一个容器启动事件&nbsp;&nbsp;\n        fireContainerEvent(\"Container Started\",this);\n    }\n    public void addContainerListener(ContainerListener listener) {\n        // 添加一个新的容器监听器到监听器列表，并确保线程安全&nbsp;&nbsp;\n        synchronized (listeners) {\n            listeners.add(listener);\n        }\n    }\n    public void removeContainerListener(ContainerListener listener) {\n        // 移除指定的容器监听器，并确保线程安全&nbsp;&nbsp;\n        synchronized (listeners) {\n            listeners.remove(listener);\n        }\n    }\n    public void fireContainerEvent(String type, Object data) {\n        // 检查是否已经有监听器，如果没有则直接返回&nbsp;&nbsp;\n        if (listeners.size() &lt; 1)\n            return;\n        ContainerEvent event = new ContainerEvent(this, type, data);\n        ContainerListener list[] = new ContainerListener[0];\n        synchronized (listeners) {\n            list = (ContainerListener[]) listeners.toArray(list);\n        }\n        // 遍历所有监听器并触发事件&nbsp;&nbsp;\n        for (int i = 0; i &lt; list.length; i++)\n            ((ContainerListener) list[i]).containerEvent(event);\n    }\n    public void addListenerDef(ContainerListenerDef listenererDef) {\n        synchronized (listenerDefs) {\n            listenerDefs.add(listenererDef);\n        }\n    }\n    \n    public boolean listenerStart() {\n        System.out.println(\"Listener Start..........\");\n        boolean ok = true;\n        synchronized (listeners) {\n            listeners.clear();\n            Iterator&lt;ContainerListenerDef&gt; defs = listenerDefs.iterator();\n            while (defs.hasNext()) {\n                ContainerListenerDef def = defs.next();\n                ContainerListener listener = null;\n                try {\n                    // 确定我们将要使用的类加载器\n                    String listenerClass = def.getListenerClass();\n                    ClassLoader classLoader = null;\n                    classLoader = this.getLoader();\n                    ClassLoader oldCtxClassLoader =\n                            Thread.currentThread().getContextClassLoader();\n                    // 创建这个过滤器的新实例并返回它\n                    Class&lt;?&gt; clazz = classLoader.loadClass(listenerClass);\n                    listener = (ContainerListener) clazz.newInstance();\n                    addContainerListener(listener);\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                    ok = false;\n                }\n            }\n        }\n        return (ok);\n    }\n}\n</code></pre><p>和前面说的一样，我们在这儿新增了addContainerListener、removeContainerListener以及fireContainerEvent三个方法，使方法名称更加具体化了。有一些不同的是我们还引入了addListenerDef方法，接受ContainerListenerDef类型的传参数。其实ContainerListenerDef和上一部分的FilterDef类似，也只是对Container监听器的属性进行定义，我们看看具体定义内容。</p><pre><code class=\"language-java\">package com.minit.core;\npublic final class ContainerListenerDef {\n    private String description = null;\n    public String getDescription() {\n        return (this.description);\n    }\n    public void setDescription(String description) {\n        this.description = description;\n    }\n    private String displayName = null;\n    public String getDisplayName() {\n        return (this.displayName);\n    }\n    public void setDisplayName(String displayName) {\n        this.displayName = displayName;\n    }\n    private String listenerClass = null;\n    public String getListenerClass() {\n        return (this.listenerClass);\n    }\n    public void setListenerClass(String listenerClass) {\n        this.listenerClass = listenerClass;\n    }\n    private String listenerName = null;\n    public String getListenerName() {\n        return (this.listenerName);\n    }\n    public void setListenerName(String listenerName) {\n        this.listenerName = listenerName;\n    }\n    private Map&lt;String,String&gt; parameters = new ConcurrentHashMap&lt;&gt;();\n    public Map&lt;String,String&gt; getParameterMap() {\n        return (this.parameters);\n    }\n    public void addInitParameter(String name, String value) {\n        parameters.put(name, value);\n    }\n    public String toString() {\n        StringBuffer sb = new StringBuffer(\"ListenerDef[\");\n        sb.append(\"listenerName=\");\n        sb.append(this.listenerName);\n        sb.append(\", listenerClass=\");\n        sb.append(this.listenerClass);\n        sb.append(\"]\");\n        return (sb.toString());\n    }\n}\n</code></pre><p>接下来我们看看StandardSession类如何进行改造，你可以看一下新增的代码实现。代码里面增加了session监听器的处理。</p><pre><code class=\"language-java\">package com.minit.session;\npublic class StandardSession implements HttpSession, Session {\n    private transient ArrayList&lt;SessionListener&gt; listeners = new ArrayList&lt;&gt;();\n    public void addSessionListener(SessionListener listener) {\n        synchronized (listeners) {\n            listeners.add(listener);\n        }\n    }\n    public void removeSessionListener(SessionListener listener) {\n        synchronized (listeners) {\n            listeners.remove(listener);\n        }\n    }\n    public void fireSessionEvent(String type, Object data) {\n        if (listeners.size() &lt; 1)\n            return;\n        SessionEvent event = new SessionEvent(this, type, data);\n        SessionListener list[] = new SessionListener[0];\n        synchronized (listeners) {\n            list = (SessionListener[]) listeners.toArray(list);\n        }\n        for (int i = 0; i &lt; list.length; i++)\n            ((SessionListener) list[i]).sessionEvent(event);\n    }\n    \n    public void setId(String sessionId) {\n        this.sessionid = sessionId;\n        fireSessionEvent(Session.SESSION_CREATED_EVENT, null);\n    }\n}\n</code></pre><p>其实也基本上类似于StandardContext。和过滤器一样，最后我们在启动类BootStrap的main函数里启动监听器就可以了，这样在服务器运行过程中则会持续监听指定事件。你可以看一下改造后BootStrap类中的main方法。</p><pre><code class=\"language-java\">package com.minit.startup;\npublic class BootStrap {\n    public static final String WEB_ROOT =\n            System.getProperty(\"user.dir\") + File.separator + \"webroot\";\n    private static int debug = 0;\n    public static void main(String[] args) {\n        if (debug &gt;= 1)\n            log(\".... startup ....\");\n        HttpConnector connector = new HttpConnector();\n        StandardContext container = new StandardContext();\n        connector.setContainer(container);\n        container.setConnector(connector);\n        Logger logger = new FileLogger();\n        container.setLogger(logger);\n        FilterDef filterDef = new FilterDef();\n        filterDef.setFilterName(\"TestFilter\");\n        filterDef.setFilterClass(\"test.TestFilter\");\n        container.addFilterDef(filterDef);\n        FilterMap filterMap = new FilterMap();\n        filterMap.setFilterName(\"TestFilter\");\n        filterMap.setURLPattern(\"/*\");\n        container.addFilterMap(filterMap);\n        container.filterStart();\n        ContainerListenerDef listenerDef = new ContainerListenerDef();\n        listenerDef.setListenerName(\"TestListener\");\n        listenerDef.setListenerClass(\"test.TestListener\");\n        container.addListenerDef(listenerDef);\n        container.listenerStart();\n        container.start();\n        connector.start();\n    }\n}\n</code></pre><p>到这里监听器部分的改造就先告一段落，现在我们可以监听Session和Container的动态了。</p><p>同样地，在测试目录中新增TestListener，可以测试我们的功能，测试方法的实现比较简单，直接输出事件对象，能够在控制台中看到输出就可以了。</p><pre><code class=\"language-java\">package test;\nimport com.minit.ContainerEvent;\nimport com.minit.ContainerListener;\npublic class TestListener implements ContainerListener{\n    @Override\n    public void containerEvent(ContainerEvent event) {\n        System.out.println(event);\n    }\n}\n</code></pre><p>我们需要将 <code>TestFilter.java</code> 与 <code>TestListener.java</code> 进行编译，生成的 <code>.class</code> 文件放入webroot目录下。</p><h2>小结</h2><p>这节课我们进一步完善了MiniTomcat，新增了过滤器和事件监听器。过滤器可以在Container互相调用的时候发挥作用，对请求对象与响应对象进一步封装改造，而且通过FilterChain可以让过滤器跟链条一样串联使用。而事件监听器则可以对服务器运行过程中的Container与Session等进行持续监听，捕获它们的状态，可以对启动、超时、响应等过程进行处理。</p><p>这两种机制使我们的MiniTomcat更加易于维护和扩展，能够更好地适应各种业务需求和变化。同时，过滤器和监听器也提高了系统的灵活性和可追溯性，帮助我们更好地管理和监控服务器的运行状况。</p><p>这节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter13\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter13</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：几个filter按照职责链串在一起，具体哪几段代码是用来实现链条依次调用的呢？</p><p>欢迎你把你的答案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":386337,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1704612612,"is_pvip":false,"replies":[{"id":140890,"content":"很好。 再考虑一下valve之间的次序，和filter之间的次序，是一样的吗？","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705023594,"ip_address":"澳大利亚","comment_id":386337,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"抓大放小， 个人觉得核心流程： ApplicationFilterChain.doFilter()  --&gt;  ApplicationFilterChain.internalDoFilter()   --&gt;   Filter.doFilter()  --&gt; ApplicationFilterChain.doFilter()   一个环状； 入口 StandardWrapperValve ， 出口是否有下一个Filter。 ","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635646,"discussion_content":"很好。 再考虑一下valve之间的次序，和filter之间的次序，是一样的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705023594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":635767,"discussion_content":"不一样， 刚好相反","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705142708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":635646,"ip_address":"广东","group_id":0},"score":635767,"extra":""}]}]},{"had_liked":false,"id":386323,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1704579857,"is_pvip":false,"replies":[{"id":140894,"content":"HttpServer这个名字含义是服务器，Bootstrap含义是启动，功能的划分，启动的概念更加贴切\nFilter&#47;Listener是规范定义的，必须符合规范，只能自己实现不能修改接口\n用Arraylist是这种场景：有次序，不需要名字。所以这里用的arraylist\n是filterchain最后调用servlet，这是规范规定的\n从术语上，servlet是后端，不是浏览器上的，远古时代，浏览器上有applet","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705024086,"ip_address":"澳大利亚","comment_id":386323,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：BootStrap代替了HttpServer吗？为什么这么做？\nQ2：Filter、Listener可以扩展吗？\n比如，用户自定义Filter、Listener，是否支持？\nQ3：用 ArrayList 存放所有的 filter和listener，有什么考虑？\n用Map不行吗？\nQ4：对于Filter，是FilterChain最后调用servlet吗？\n按说不应该由Filter调用servlet，而是由一个更高层的一个东西来调用，类似于控制器或调度器一类的来调用。\nQ5：有浏览器上的servlet吗？\n我们这里说的servlet，都是运行在后端。我听说有运行在浏览器上的servlet，是否有？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635650,"discussion_content":"HttpServer这个名字含义是服务器，Bootstrap含义是启动，功能的划分，启动的概念更加贴切\nFilter/Listener是规范定义的，必须符合规范，只能自己实现不能修改接口\n用Arraylist是这种场景：有次序，不需要名字。所以这里用的arraylist\n是filterchain最后调用servlet，这是规范规定的\n从术语上，servlet是后端，不是浏览器上的，远古时代，浏览器上有applet","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705024086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390184,"user_name":"到不了的塔","can_delete":false,"product_type":"c1","uid":1258362,"ip_address":"上海","ucode":"0F5BE3CB58DE31","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/7a/ac307bfc.jpg","comment_is_top":false,"comment_ctime":1714611535,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"郭老师，你好，请问下为啥StandardContext中会有listenerDefs字段来保存listener config呢, 有listeners字段来保存listener实例应该就足够满足需求了吧。 \n我看filter的设计也跟这类似，也有filter config，这种设计的好处是啥？","like_count":0}]}