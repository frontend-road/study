{"id":689362,"title":"29｜高性能：Kafka 为什么性能那么好？","content":"<p>你好，我是大明。今天我们来讨论一个问题，Kafka 的性能为什么那么好？</p><p>Kafka 的高性能话题也算是热点了，如果你面试的公司在并发量或者数据量上已经到了一定地步，那么面试的时候大概率逃不过这个问题。</p><p>大部分人面不好这个部分的原因只有一个：Kafka 为了实现高性能采用的手段太多了，以至于根本记不住。那么这一节课我就先聚焦在 Kafka 本身为了高性能做了哪些事情，下一节课我再从实践出发，告诉你怎么优化 Kafka 的性能。</p><p>让我们先从 Kafka 的一些基本知识开始说起。</p><h2>Kafka 分段与索引</h2><p>即便在同一个分区内部，Kafka 也进一步利用了分段日志和索引来加速消息查找。在 Kafka 内部，一个分区的日志是由很多个段（segment）组成的，每个段你可以理解成一个文件。同一个 topic 的文件就存放在以 topic 命名的目录下。</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/af/5b02d02b705bfd1b6afd1000b462bbaf.png?wh=1920x653\" alt=\"图片\"></p><p>为了快速找到对应的段文件，段日志文件使用了偏移量来命名。假如说一个文件的名字是 N.log，那么就表示这个段文件里第一条消息的偏移量是 N + 1。</p><p>这里你就能猜到，Kafka 完全可以根据文件名来进行二分查找，从而快速定位到段文件。</p><p>为了加快段文件内的查找，每一个段文件都有两个索引文件。</p><ul>\n<li>一个是偏移量索引文件，存储着部分消息偏移量到存储位置的映射，类似于 <code>&lt;offset, position&gt;</code> 这种二元组。这个 offset 不是全局 offset，是相对于这个文件第一条消息的偏移量。也就是说假如第一条消息的全局偏移量是 1000，那么偏移量为 1002 的消息的索引项是 <code>&lt;2, pos1&gt;</code>。</li>\n<li>一个是时间索引文件，存储着时间戳到存储位置的映射，类似于 <code>&lt;timestamp, position&gt;</code> 二元组。</li>\n</ul><!-- [[[read_end]]] --><p>所以整个日志文件目录看上去是这样的。</p><p><img src=\"https://static001.geekbang.org/resource/image/88/e8/880b85b2c0f64bdb72665b78615335e8.png?wh=1920x783\" alt=\"图片\"></p><p>以这张图片为例，假如说要查找 topic 为 test_topic，分区为 1，偏移量为 20000 的消息，那么整个过程是这样的。</p><ol>\n<li>在日志目录下找到名字为 test_topic_1 的子目录，里面就放着这个分区的消息日志文件。</li>\n<li>在 test_topic_1 子目录下，根据文件名进行二分查找，可以确定 20000 这条消息应该放在010031.log 这个文件里面。</li>\n<li>利用 010031.index 的内容进行二分查找，查找索引项。如果 20000 恰好有一个索引项 <code>&lt;20000, pos0&gt;</code>，那么就读取 pos0 这个位置的数据。</li>\n<li>如果 20000 没有对应的索引项，就找到比 20000 小的最接近 20000 的索引项，假如有 <code>&lt;19990，pos1&gt;</code>，那么就从 pos1 往后遍历，找到 20000 对应的数据。</li>\n</ol><p>对应的根据时间查找也差不多。这里要注意的是，索引文件放的只是部分消息对应的位置，因为 Kafka 希望索引文件能够装入内存。这种思想我之前提到过，我们在讨论 MySQL 索引的时候也是默认索引都在内存里面。</p><p>为了帮助你记忆，我整理成了三句话：<strong>topic 加分区定目录，偏移量定文件，索引定位置。</strong>记住这三句话就可以了。</p><h2>零拷贝</h2><p>零拷贝（zero copy）是中间件广泛使用的一个技术，它能极大地提高中间件的性能。所谓的零拷贝，就是指没有 CPU 参与的拷贝。要理解零拷贝，要先从一般的读写操作开始讲起。假如说你现在要从磁盘读取内容，然后发送到网络上，那么基本流程如图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/15/4ac629727b0538e96aeb2ed0c281ab15.png?wh=1920x1090\" alt=\"图片\"></p><p>DMA （Direct Memory Access）是一个独立于 CPU 的硬件，所以我们不太在意 DMA 拷贝。NIC（Network Interface Card）就是指网卡。</p><p>这里面总共有四个步骤。</p><ol>\n<li>应用进入内核态，从磁盘里读取数据到内核缓存，也就是读缓存。这一步应用就是发了一个指令，然后是 DMA 来完成的。</li>\n<li>应用把读缓存里的数据拷贝到应用缓存里，这个时候切换回用户态。</li>\n<li>应用进入内核态，把应用缓存里的数据拷贝到内核缓存里，也就是写缓存。</li>\n<li>应用把数据从写缓存拷贝到 NIC 缓存里，这一步应用也就是发了一个指令，DMA 负责执行。</li>\n</ol><p>而这里面总共有四次内核态与用户态的切换。</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/5d/6a82af6cfb15e83178ec25704e88405d.png?wh=2448x1076\" alt=\"\"></p><p>为什么要那么复杂，能不能不经过应用缓存，直接让磁盘读到内核缓存，然后内核缓存直接写到 NIC 缓存？这样不是非常完美吗？</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/04/ee3ae14795834184909a34279dc2d704.png?wh=1920x1090\" alt=\"图片\"></p><p>也可以，而这就是零拷贝，对应的内核态-用户态切换，也只剩下了两次。</p><p><img src=\"https://static001.geekbang.org/resource/image/22/c5/22af5f6b822a629a3847bb6da8e313c5.png?wh=1920x690\" alt=\"图片\"></p><p>那么和最原始的操作比起来，零拷贝少了两次内核态与用户态的切换，还少了两次 CPU 拷贝。但是零拷贝本身还是要用到 DMA 拷贝。</p><h2>批量操作的优势</h2><p>批量操作在高性能中间件里面也很常见。那么批量操作的优势究竟在哪里呢？主要体现在两个方面：一个是更少的系统调用和内核态与用户态的切换，还有一个是高效利用网络带宽。</p><p>我给你举一个例子，客户端每次都只发一个请求到服务端上，如今要发 100 个请求。现在客户端用了零拷贝技术，那么客户端发送 100 个请求，需要 100 次系统调用，200次内核态与用户态的切换。而如果客户端一次性发送 100 个请求，那么它只需要 1 次系统调用，2 次内核态与用户态的切换。</p><p>在网络传输的时候，每一次发送都有一个固定开销，比如说协议头的部分，这个开销大小和具体的协议设计有关。假如说每个请求大小是 1KB，在网络传输的时候，分 100 次传输 1KB 和 1 次传输 100KB，后者也是明显快很多的。前者需要传输 100 次协议头，而后者只需要传输 1 次协议头。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/ae/45b059b3a720a29a830c5e3edd43bfae.png?wh=1920x645\" alt=\"图片\"></p><p>当然，这是指应用层协议，如果是底层协议，比如 TCP，这方面也能节省一些，但是效果不如应用层协议好。</p><h2>面试准备</h2><p>准备Kafka高性能的面试，你还可以在公司内部了解一些信息。</p><ul>\n<li>公司有没有因为分区或者 topic 太多导致 Kafka 性能衰退的案例？如果有，当时是怎么解决的？</li>\n<li>公司内部的 Kafka 用的是机械硬盘还是固态硬盘？</li>\n<li>公司内部的 Kafka 能撑住的并发量是多大？你的业务并发量是多大？</li>\n<li>公司内部还有没有别的中间件也使用了类似的优化技术？</li>\n<li>你在业务中有没有使用批量处理的技术来优化系统性能？如果有，具体是怎么做的？</li>\n</ul><p>在面试中，比较好的策略是你根据自己对不同中间件的了解进行横向对比。比如说聊到 WAL 的时候，把它和 MySQL、Redis 进行对比。这样能够凸显你对系统设计原则有深刻的理解。</p><p>当你和面试官聊到了下面这些话题的时候，你都可以尝试引导到这节课的话题下。</p><ul>\n<li>你们聊到了 WAL 和 AOF，可以提及 Kafka 利用了类似的技术。</li>\n<li>你们聊到操作系统的基本原理，系统调用、文件 IO 等，你就可以提及零拷贝，批量处理技术在 Kafka 中的应用。</li>\n<li>你们聊到了并发优化的内容，那么可以用分区作为例子解释缩小并发粒度的好处。</li>\n<li>你们聊到其他中间件采用了后面我列举的技术，那么你就可以和 Kafka对比，深入阐述相关原理。</li>\n<li>你们聊到了 Kafka 消息怎么存储，那么你就可以从性能的角度解释 Kafka 的分段和索引的优点。</li>\n</ul><p>当然，面试官不一定直接问你为什么Kafka 性能那么高，他也可能有多种问法。</p><ul>\n<li>你们公司的 Kafka 性能怎样？怎么做到的？</li>\n<li>Kafka 为什么要用零拷贝？</li>\n<li>分区太多为什么会导致 Kafka 性能衰退？</li>\n<li>Kafka 为什么要用压缩技术？</li>\n<li>Kafka 是怎么查找到特定偏移量的消息的？</li>\n</ul><p>这一类问题，你都可以用后面的内容来回答。</p><h2>面试思路</h2><p>Kafka 本身使用了很多手段来保证高性能，包括零拷贝、page cache（页缓存）、顺序读写、分区分段与索引、批量处理、压缩。其中零拷贝和顺序读写最重要，是一定要能回答出来的。</p><h3>零拷贝</h3><p>前面你已经了解了什么是零拷贝，那么你在回答的时候就可以介绍零拷贝是如何运作的，然后再总结零拷贝的优势。</p><blockquote>\n<p>零拷贝是中间件设计的通用技术，是指完全没有 CPU 参与的读写操作。我以从磁盘读数据，然后写到网卡上为例介绍一下。首先，应用程序发起系统调用，这个系统调用会读取磁盘的数据，读到内核缓存里面。同时，磁盘到内核缓存是 DMA 拷贝。然后再从内核缓存拷贝到 NIC 缓存中，这个过程也是 DMA 拷贝。这样就完成了整个读写操作。和普通的读取磁盘再发送到网卡比起来，零拷贝少了两次 CPU 拷贝，和两次内核态与用户态的切换。</p>\n</blockquote><p>正常来说，你在回答里面不需要介绍普通的读取磁盘再发送的流程，不过如果面试官问了，你就可以按照前置知识里面的内容来回答。这里还有可能引申到操作系统相关的基本知识，面试前你也不要忘了复习。</p><p>然后你再补充一句，引出 page cache 的内容。</p><blockquote>\n<p>这里说的内核缓存，在 linux 系统上其实就是 page cache。</p>\n</blockquote><h3>page cache</h3><p>相信你对page cache并不陌生，前面我们接触过很多次了。Kafka 把数据写入到 page cache 而不是直接刷新到磁盘上，有效减少了真实的 IO 操作次数。</p><p>另外一方面，Kafka 是基于 JVM的，所以直接操作 page cache能够避开 JVM 的垃圾回收。同时也能充分利用操作系统对 page cache 的优化。</p><blockquote>\n<p>Kafka 充分利用了 page cache。Kafka 写入的时候只是写入到了 page cache，这几乎等价于一个内存写入操作，然后依靠异步刷新把数据刷新到磁盘上。而 page cache 是可以存放很多数据的，也就是说 Kafka 本身调用了很多次写入操作之后，才会真的触发 IO 操作，提高了性能。而且，Kafka 是基于 JVM 的，那么利用 page cache 也能缓解垃圾回收的压力。大多数跟 IO 操作打交道的中间件都有类似的机制，比如说 MySQL、Redis。</p>\n</blockquote><p>你在这里可以适当引导一下，把话题引导到消息丢失上。</p><blockquote>\n<p>不过使用 page cache 的缺陷就是如果消息还没刷新到磁盘上，服务器就宕机了，那么整个消息就丢失了。</p>\n</blockquote><h3>顺序写</h3><p>在写操作里面，我们一般默认写是很慢的。但是实际上，写操作分成顺序写和随机写，我们认为写操作很慢，那都是随机写，而顺序写本身并不慢，所以你要先指出顺序写的性能。</p><blockquote>\n<p>在计算机里面，普遍认为写很慢，但是实际上是随机写很慢，但是顺序写并不慢。即便是机械硬盘的顺序写也并不一定会比固态硬盘的顺序写慢。</p>\n</blockquote><p>然后补充 Kafka 充分利用了顺序写。</p><blockquote>\n<p>Kafka 在写入数据的时候就充分利用了顺序写的特性。它针对每一个分区，有一个日志文件 WAL（write-ahead log），这个日志文件是只追加的，也就是顺序写的，因此发消息的性能会很好。MySQL、Redis 和其他消息中间件也采用了类似的技术。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/ff/27/ff0cbe809be426d82f115a0c30996127.png?wh=1920x645\" alt=\"图片\"></p><p>紧接着你再补充一点业界早期的讨论。</p><blockquote>\n<p>所以早期的时候业界就有人做过实验，一台 Kafka 服务器，把磁盘从机械硬盘切换到固态硬盘，性能虽然有提升，但是并不明显。在固态硬盘很贵的情况下，并不划算。</p>\n</blockquote><p>接下来你可以从两个角度刷亮点：分区多影响写入性能和如何解决分区多问题。</p><h3>分区多影响写入性能</h3><p>你应该注意到， Kafka 是每一个分区都有一个日志文件，万一你有很多分区呢？也就是说，如果分区特别多，就可能导致 Kafka 的写性能衰退。</p><blockquote>\n<p>但是 Kafka 的顺序写要求的是分区内部顺序写，不同的分区之间就不是顺序写的。所以如果一个 topic 下的分区数量不合理，偏多的话，写入性能是比较差的。<br>\n&nbsp;<br>\n举个例子，假如说要写入 100M 的数据，如果只有一个分区，那就是直接顺序写入 100M。但是如果有 100 个分区，每个分区写入 1M，它的性能是要差很多的。因为一个 topic 至少有一个分区，topic 多也会影响 Kafka 的性能。最好是在创建 topic 的时候就规划好分区，但是如果没规划好，还是得考虑解决。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/59/36/59a137d035215d702c6db1d56c201236.png?wh=1920x819\" alt=\"图片\"></p><p>这个回答里你提到了一个点，就是分区设置不合理，所以面试官就会追问你如何估计分区数量。这个知识你已经在前面<a href=\"https://time.geekbang.org/column/article/685943\">第 25 讲</a>学过了，记得复习一下。</p><p>最后一句话，也是你引导面试官追问怎么解决分区或者 topic 过多的问题。</p><h3>分区过多如何解决？</h3><p>我们从分区过多和 topic 过多的角度分别去讨论。</p><p>如果是分区过多的话很好办，你只需要<strong>不使用其中的一些分区</strong>就可以了。</p><blockquote>\n<p>如果某个 topic 分区太多了用不上，就可以考虑不用其中的一些分区。假设说我们现在有 32 个分区，但是事实上业务本身用不上那么多分区，那么就可以考虑要求发送者只将消息发送到特定的 16 个分区上。当然，能够直接创建新 topic 是最好的。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/c3/5c/c37146b35ef503b3dc83dbbd2ac3025c.png?wh=1920x1059\" alt=\"图片\"></p><p>topic 过多的问题，要稍微棘手一点，你可以考虑<strong>合并</strong> topic。</p><blockquote>\n<p>topic 过多的话，可以考虑合并一些 topic，但这也是看业务的。比如说最开始的设计是某个主业务下的子业务都有一个 topic，那么可以考虑这些子业务合并使用一个 topic，然后在里面用 type 等字段来标记是归属于哪个子业务的。</p>\n</blockquote><p>有时候面试官可能会问，究竟多少个分区才算多，或者多少个分区才会导致性能下降呢？这里我给你一个阿里云中间件团队测试的结论。</p><blockquote>\n<p>多少分区才算多，以及多少分区才会引起性能下降，这和 topic 本身有关，也和业务有关。<br>\n&nbsp;<br>\n不过之前阿里云中间件团队测试过，在一个 topic 八个分区的情况下，超过 64 个 topic 之后，Kafka 性能就开始下降了。</p>\n</blockquote><p>如果有兴趣，你也可以在你们公司的 Kafka 上执行一下测试。</p><h3>分区</h3><p>分区本身就能带来性能的提升，分区的好处就是 Kafka 可以按分区来处理，<strong>减少并发竞争</strong>。</p><blockquote>\n<p>Kafka 的分区机制也能提高性能。假如说现在 Kafka 没有分区机制，只有 topic，那么可以预计的是不管是读还是写，并发竞争都是 topic 维度的。而在引入了分区机制之后，并发竞争的维度就变成分区了。如果是操作不同的分区，那么完全不需要搞并发控制。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/1c/85/1cbd466eac09bba24ce608cd2cf26785.png?wh=1920x905\" alt=\"图片\"></p><p>如果你在面试过程中和面试官讲到了并发优化的点，那么你可以用分区这个例子来解释可以通过缩小并发粒度来提高性能。</p><h3>分段与索引</h3><p>分段与索引的基本概念我们已经学过了，所以你只需要根据我总结的三句话简单介绍分段与索引就可以。同时讲清楚如何查找到特定消息，因为查找过程本身就是一个亮点。</p><blockquote>\n<p>在 Kafka 中，每一个分区都对应多个段文件，放在同一个目录下。Kafka 根据 topic 和分区就可以确定消息存储在哪个目录内。每个段文件的文件名就是偏移量，假设为 N，那么这个文件第一条消息的偏移量就是 N+1。所以 Kafka 根据偏移量和文件名进行二分查找，就能确定消息在哪个文件里。<br>\n&nbsp;<br>\n然后每一个段文件都有一个对应的偏移量索引文件和时间索引文件。Kafka 根据这个索引文件进行二分查找，就很容易在文件里面找到对应的消息。如果目标消息刚好有这个索引项，那么直接读取对应位置的数据。如果没有，就找到比目标消息偏移量小的，最接近目标消息的位置，顺序找过去。整个过程非常像跳表。</p>\n</blockquote><h3>批量处理</h3><p>批量处理是高并发和大数据的常见解决方案。Kafka 为了提高性能，引入端到端的批量发送机制。在发送端，Kafka 的客户端并不是一次只发送一条消息，而是发送一批消息（record batch）。简单来说，就是好几条消息合并在一起发送。</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/e3/a5acbbc1d81bdbf7365993666a2099e3.png?wh=1920x1182\" alt=\"图片\"></p><p>而在 broker 端，Kafka 在存储的时候也是按照批来处理的。你在回答的时候要先解释 Kafka <strong>批量处理</strong>的基本机制。</p><blockquote>\n<p>Kafka 还采用了批量处理来提高性能。Kafka 的客户端在发送的时候，并不是说每来一条消息就发送到 broker 上，而是说聚合够一批再发送。而在 broker 这一端，Kafka 也是同样按照批次来处理的，显然即便同样是顺序写，一次性写入数据都要比分多次快很多。除了 Kafka，很多高并发、大数据的中间件也采用类似的技术，比如说日志采集与上报就采用批量处理来提升性能。</p>\n</blockquote><p>然后你可以从批量处理的高性能原因和兜底技术两个角度刷亮点。</p><h4>批量处理高性能原因</h4><p>首先你要深入分析批量处理高性能的原因。</p><blockquote>\n<p>批量处理能够提升性能的原因是非常直观的，有两方面。一方面是减少系统调用和内核态与用户态切换的次数。比方说100 个请求发送出去，即便采用零拷贝技术，也要 100 次系统调用 200 次内核态与用户态切换。而如果是一次性发送的话，那么就只需要 1 次系统调用和 2 次内核态与用户态切换。<br>\n&nbsp;<br>\n另外一方面，批量处理也有利于网络传输。在网络传输中，一个难以避免的问题就是网络协议自身的开销。比如说协议头开销。那么如果发送 100 次请求，就需要传输 100 次协议头。如果 100 个请求合并为一批，那就只需要一个协议头。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/03/ce/0390fc774852fe34893f50c86927bace.png?wh=1920x645\" alt=\"图片\"></p><h4>批量处理的兜底技术</h4><p>那么多大批次比较合适呢？关键词就是<strong>要兜底</strong>。</p><blockquote>\n<p>不过批次也要设计合理。正常来说批次总是越大越好，但是批次太大会导致一个后果，就是客户端难以凑够一个批次。比如说 100 条消息一批和 1000 条消息一批，后者肯定很难凑够一个批次。一般来说批量处理都是要兜底的，就是在固定时间内如果都没有凑够某个批次，那么就直接发送。比如说 Kafka 里面生产者就可以通过 <code>linger.ms</code> 参数来控制生产者最终等多长时间。时间到了，即便只有一条消息，生产者也会把消息发送到 broker 上。</p>\n</blockquote><h3>压缩</h3><p>为了进一步降低数据传输和存储的压力，Kafka 还启用了压缩功能。Kafka 的压缩机制很特别。正常我们会认为如果 Kafka 支持压缩，那么应该是生产者压缩，发送到 broker 之后，broker 解压缩。然后 broker 压缩，发送到消费者之后，消费者解压缩。</p><p>Kafka 是彻底地端到端，就是生产者压缩之后发送到 broker，broker 直接存储。当 broker 推送到消费者的时候，消费者解压缩。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/1b/2c94c7054eb25955d1fbee719e47101b.png?wh=1920x653\" alt=\"图片\"></p><blockquote>\n<p>Kafka 为了进一步降低网络传输和存储的压力，还对消息进行了压缩。这种压缩是端到端的压缩，也就是生产者压缩，broker 直接存储压缩后的数据，只有消费者才会解压缩。它带来的好处就是，网络传输的时候传输的数据会更少，存储的时候需要的磁盘空间也更少。当然，缺点就是压缩还是会消耗 CPU。如果生产者和消费者都是 CPU 密集型的应用，那么这种压缩机制反而加重了它们的负担。</p>\n</blockquote><p>最后我们点出 CPU 密集型应用在使用 Kafka 的时候还面临着压缩数据竞争 CPU 资源的问题。不过在业界，CPU 密集型的应用非常少，会使用到 Kafka 的 CPU 密集型应用就更少了。</p><h2>面试思路总结</h2><p>最后我来总结一下这节课的要点。通过 <strong>Kafka 的分段与索引技术</strong>，我们了解到一个消息是怎么被存储的，还有消息是怎么查找的。这里还引入了一个新概念——<strong>零拷贝技术</strong>，你需要记住相比传统 IO 它独特的优势。</p><p>在回答Kafka 为什么性能这么好这个问题的时候，你要从<strong>零拷贝、page cache、顺序写、分区、分段与索引、批量处理、压缩</strong>这几个角度回答。而如果你记不住这么多内容，那么记住零拷贝、顺序写这两个也可以。</p><p>我也建议你从横向角度去分类，比如写下零拷贝再写下使用了零拷贝的相应的中间件。这样能够加深你的理解，你在面试的时候也可以用这个知识来刷亮点。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/40/5f9f06fdae07580aab5124a704943040.png?wh=2326x1914\" alt=\"\"></p><h2>思考题</h2><p>最后，请你来思考两个问题。</p><ul>\n<li>Kafka 用到的这些优化技术，很多中间件也用到了，你能举几个例子吗？</li>\n<li>我在分区里面讲到分区可以用来缩小并发粒度，减轻并发竞争，你还见过类似的技术吗？或者你有没有尝试在工作中使用类似的技术来优化自己的业务并发性能？</li>\n</ul><p>欢迎你把你的答案分享在评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":379998,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1367048,"ip_address":"广东","ucode":"B639AB5F6AA03D","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","comment_is_top":false,"comment_ctime":1692799451,"is_pvip":false,"replies":[{"id":138400,"content":"赞！在面试中要记得这种横向对比的面试技巧！","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1692891185,"ip_address":"广东","comment_id":379998,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"老师这节课讲的很好，之前也看过其他人讲过Kafka为什么性能高，但是都讲的不全面，学习到了。\n\npage cache 技术，MySQL、 Redis、Elasticsearch  也用到了。\n顺序写  Hive、Spark、ClickHouse 都使用到了。\n零拷贝 技术  Netty, RocketMQ肯定使用到了。\n\n分区可以用来缩小并发粒度，减轻并发竞争:\nJDK1.8 之前实现的 ConcurrentHashMap 版本。HashTable 是基于一个数组 + 链表实现的，所以在并发读写操作集合时，存在激烈的锁资源竞争，也因此性能会存在瓶颈。而 ConcurrentHashMap 就很很巧妙地使用了分段锁 Segment 来降低锁资源竞争","like_count":5,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626415,"discussion_content":"赞！在面试中要记得这种横向对比的面试技巧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692891185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383432,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"北京","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1699014924,"is_pvip":false,"replies":[{"id":139747,"content":"我应该没写错吧？这里就是整个偏移量是 20000，010031 的第一条应该是 10032，20000 在这个文件。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1699282302,"ip_address":"广东","comment_id":383432,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"“可以确定 20000 这条消息应该放在 010031.log 这个文件里面。”，这里的20000是不是写错了，应该是2000？\n根据描述：假如说一个文件的名字是 N.log，那么就表示这个段文件里第一条消息的偏移量是 N + 1。","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631062,"discussion_content":"我应该没写错吧？这里就是整个偏移量是 20000，010031 的第一条应该是 10032，20000 在这个文件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699282302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3864871,"avatar":"","nickname":"Geek_304156","note":"","ucode":"81FDF888FF029E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640853,"discussion_content":"同学的意思是20000这个全局偏移量？在010031.log中的偏移量是9969（20000-010031）？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711940771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631161,"discussion_content":"喔喔 明白啦 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699351005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389022,"user_name":"上杉夏香","can_delete":false,"product_type":"c1","uid":1521568,"ip_address":"北京","ucode":"9FDDE0979BCC8C","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/a0/032d0828.jpg","comment_is_top":false,"comment_ctime":1711413676,"is_pvip":false,"replies":[{"id":141993,"content":"是的，类似的解决思路都会有全局队列，并且支持偷拿。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1715231554,"ip_address":"广东","comment_id":389022,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"让我想到Go的GMP模型，P拿G的时候，先从本地G队列里面拿，没有的话，再去全局G队列拿。本地G队列竞争比较少（应该全无竞争，只不过得防一手其他P来自己这里偷拿），全局G队列就要面对所有P的“偷拿”。","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644415,"discussion_content":"是的，类似的解决思路都会有全局队列，并且支持偷拿。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715231554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383437,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"北京","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1699022141,"is_pvip":false,"replies":[{"id":139748,"content":"这个是和你的生产者的 acks 设置有关的。如果你选择要同步到从分区，那么就是写主分区，然后同步到从分区之后，才算是写入成功了。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1699282388,"ip_address":"广东","comment_id":383437,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"请问老师一个问题：kafka 多分区，在写入的时候，是同时写入多个分区吗？还是只写主分区，然后同步到从分区？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631063,"discussion_content":"这个是和你的生产者的 acks 设置有关的。如果你选择要同步到从分区，那么就是写主分区，然后同步到从分区之后，才算是写入成功了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699282388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383059,"user_name":"Lum","can_delete":false,"product_type":"c1","uid":3231352,"ip_address":"北京","ucode":"7EF828425E685A","user_header":"https://static001.geekbang.org/account/avatar/00/31/4e/78/ee4e12cc.jpg","comment_is_top":false,"comment_ctime":1698382384,"is_pvip":false,"replies":[{"id":139761,"content":"赞赞赞！如果是面试的话，比较建议用自己业务的例子，这样会有更好的说服力。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1699283786,"ip_address":"广东","comment_id":383059,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"锁分离（Lock Separation）：在高并发环境下，锁竞争可能会成为瓶颈。锁分离是一种将锁拆分成多个细粒度锁的技术，以减少锁竞争和提高并发性能。例如，在数据库中，可以将表锁拆分为行锁或列锁。\n\n数据分片（Data Sharding）：数据分片是一种将数据拆分成多个分片的技术，以提高并发性能和可扩展性。每个分片可以独立处理请求，从而减少竞争和提高吞吐量。例如，在分布式数据库中，可以将数据按照某种规则（如哈希或范围）划分到不同的节点上。\n\n缓存（Caching）：缓存是一种将数据存储在内存中，以加速读写操作和减少对后端存储系统的访问的技术。例如，在 Web 应用中，可以使用缓存来缓存页面、结果集或对象，以减少数据库访问和提高响应速度。\n\n异步处理（Asynchronous Processing）：异步处理是一种将请求和响应分离的技术，以提高并发性能和可扩展性。例如，在 Web 应用中，可以使用异步 Servlet 或异步消息处理器来处理请求，从而释放线程资源和提高吞吐量。\n\n无锁编程（Lock-free Programming）：无锁编程是一种不使用锁的并发编程技术，以减少竞争和提高性能。例如，在并发数据结构中，可以使用无锁算法（如 CAS）来实现原子操作，从而避免锁竞争和死锁。","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631076,"discussion_content":"赞赞赞！如果是面试的话，比较建议用自己业务的例子，这样会有更好的说服力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699283786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382514,"user_name":"Geek_icecream","can_delete":false,"product_type":"c1","uid":2694856,"ip_address":"广东","ucode":"09F7E85D0E38FA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/o2pS2W4rp4ribiaoZpkeWRoCaibyNHqK5oqa71Rf23KPjBwCzsIdXiaalfT1o9BT8NbkViagSVAwD8sF6qOEC7bOibvg/132","comment_is_top":false,"comment_ctime":1697511110,"is_pvip":true,"replies":[{"id":139307,"content":"多谢提醒，已经改好啦🌹","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1697512044,"ip_address":"北京","comment_id":382514,"utype":2}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"老师在讲解“零拷贝”时，提到的“四次内核态与用户态的切换”那张图里面，出现了两次“系统调用写操作”，是不是写错了？在进行第一次用户态与内核态切换时，不应该是“系统调用读操作”吗？先将内核态的数据“读”到用户态","like_count":0,"discussions":[{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629673,"discussion_content":"多谢提醒，已经改好啦🌹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697512044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629672,"discussion_content":"多谢提醒，已经改好啦🌹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697511996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381842,"user_name":"ZhiguoXue_IT","can_delete":false,"product_type":"c1","uid":2639055,"ip_address":"北京","ucode":"EAA83F53B54520","user_header":"https://static001.geekbang.org/account/avatar/00/28/44/cf/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1695961094,"is_pvip":false,"replies":[{"id":139229,"content":"基本类似，但是我研究不够深入，哈哈哈，没怎么看过源码。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1696923191,"ip_address":"广东","comment_id":381842,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"请教一下老师，kafka高性能的原因是这些，阿里的rocketmq的高性能有相似的吗","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629297,"discussion_content":"基本类似，但是我研究不够深入，哈哈哈，没怎么看过源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696923191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381441,"user_name":"Geek_43dc82","can_delete":false,"product_type":"c1","uid":2753124,"ip_address":"北京","ucode":"B79FA1C1E94E5A","user_header":"","comment_is_top":false,"comment_ctime":1695204390,"is_pvip":false,"replies":[{"id":139044,"content":"赞！这就是典型的全局竞争优化为局部竞争！","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1695728834,"ip_address":"广东","comment_id":381441,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"发现了一些语言层面为了减少并发粒度的，减少锁并发竞争的优化，比如Golang GMP调度模型中的有global queue还有每个P本地的queue，实际P本地的queue的存在也是为了减少并发竞争","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628711,"discussion_content":"赞！这就是典型的全局竞争优化为局部竞争！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695728834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381029,"user_name":"五号特派员","can_delete":false,"product_type":"c1","uid":3653946,"ip_address":"四川","ucode":"D92133F112A20D","user_header":"https://static001.geekbang.org/account/avatar/00/37/c1/3a/880a0932.jpg","comment_is_top":false,"comment_ctime":1694594531,"is_pvip":false,"replies":[{"id":138854,"content":"问到我的知识盲区了，我没怎么用过 plusar。之前我做技术选型的时候，我差不多就是无脑选 Kafka。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1694781902,"ip_address":"广东","comment_id":381029,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"请问老师kafka和pulsar对比如何呢","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628040,"discussion_content":"问到我的知识盲区了，我没怎么用过 plusar。之前我做技术选型的时候，我差不多就是无脑选 Kafka。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694781902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379958,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1692766955,"is_pvip":false,"replies":[{"id":138402,"content":"1. 在 JAVA 层面上其实你是感知不到的，你只知道你调用了一个JAVA 方法。如果这个 JAVA 方法最终在 JDK 里面发起了系统调用，那么你就要进入内核态了。在 Java 里面有一部分方法都是依赖native 方法来实现的。\n2. 说起来，这就是我的知识盲点了，以前JAVA我也没直接操作过 Page Cache，但是我之前记得就是有不同的文件相关的 OutputStream 实现，就是没特意写明就是写到了 page cache。\n3. 都是可以设置的。\n4. 这个每个公司，甚至一个公司的不同部门设计方案都不一样，要看具体的场景。这个topic 和商品分类没什么关系，一般是指什么业务场景。\n5. 对的\n6. 也不是，因为别的 MQ 有一些 Kafka 没有的功能。不过如果你技术选项，无脑选 Kafka 就是了。这样做最大的好处就是，万一出问题了，别人也不能说 kafka 选得不对。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1692891548,"ip_address":"广东","comment_id":379958,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"请教老师几个问题：\nQ1：应用进入内核态，以Java为例，是什么语句？\n文中有这一句：“这一步应用就是发了一个指令，然后是 DMA 来完成的”，这里的“应用发指令”，从Java代码的角度，什么代码的效果是普通的两次拷贝？什么代码可以做到零拷贝（即该代码可以控制DMA来完成数据拷贝）？\n(附：如果是C语言，又是哪一个语句？这个和专栏有点距离，可以不答)\nQ2：kafa是用Java写的，kafka可以控制Page Cache，那么，什么Java代码可以控制Page Cache？\nQ3：kafka的批量处理，是可以设置的吗？比如：是否采用批量处理，批量处理的数量等。应用可以设置吗？\nQ4：电商的topic按什么分类？\n比如京东，首页左边是商品分类，会按商品类型来设置topic吗？\nQ5：生产者和消费者的压缩，并不是应用压缩，而是kafka客户端的压缩，对吗？ 即生产者和消费者的开发人员并不需要开发压缩、解压缩功能，而是调用kafka的客户端的库，由库来完成压缩和解压缩功能。\nQ6：kafka功能强大，那其他三种MQ就没有必要用了，只选kafka就可以了。是这样吗？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626417,"discussion_content":"1. 在 JAVA 层面上其实你是感知不到的，你只知道你调用了一个JAVA 方法。如果这个 JAVA 方法最终在 JDK 里面发起了系统调用，那么你就要进入内核态了。在 Java 里面有一部分方法都是依赖native 方法来实现的。\n2. 说起来，这就是我的知识盲点了，以前JAVA我也没直接操作过 Page Cache，但是我之前记得就是有不同的文件相关的 OutputStream 实现，就是没特意写明就是写到了 page cache。\n3. 都是可以设置的。\n4. 这个每个公司，甚至一个公司的不同部门设计方案都不一样，要看具体的场景。这个topic 和商品分类没什么关系，一般是指什么业务场景。\n5. 对的\n6. 也不是，因为别的 MQ 有一些 Kafka 没有的功能。不过如果你技术选项，无脑选 Kafka 就是了。这样做最大的好处就是，万一出问题了，别人也不能说 kafka 选得不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692891548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379941,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1692750272,"is_pvip":false,"replies":[{"id":138404,"content":"我给你找找原文，应该是这篇 https:&#47;&#47;developer.aliyun.com&#47;article&#47;62832。\n\n我个人的话对一个 Broker 节点该分配多少分区，没有研究，这个得去找 Kafka 运维的同学了解一下了。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1692892552,"ip_address":"广东","comment_id":379941,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"不过之前阿里云中间件团队测试过，在一个 topic 八个分区的情况下，超过 64 个 topic 之后，Kafka 性能就开始下降了。\n老师，这个测试数据是部署了多少broker节点？换句话说，一个broker节点分配多少分区比较合适？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626419,"discussion_content":"我给你找找原文，应该是这篇 https://developer.aliyun.com/article/62832。\n\n我个人的话对一个 Broker 节点该分配多少分区，没有研究，这个得去找 Kafka 运维的同学了解一下了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692892552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388658,"user_name":"Geek_3d0fe8","can_delete":false,"product_type":"c1","uid":3794407,"ip_address":"广东","ucode":"E75EACDA00E7A6","user_header":"","comment_is_top":false,"comment_ctime":1710600107,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"如果broken存储的是批量压缩后的消息，那么消费者读取的时候是会把整批读出来然后取满足条件的offset吗？","like_count":3}]}