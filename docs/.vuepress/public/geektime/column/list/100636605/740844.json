{"id":740844,"title":"第 7 章 函数(1)","content":"<h1 id=\"nav_point_115\">第 7 章　函数</h1>\n<p>假如你把编程语言里的所有常见概念，比如循环、分支、异常、函数等，全部一股脑儿摆在我面前，问我最喜欢哪个，我会毫不犹豫地选择“函数”（function）。</p>\n<p>我对函数的喜爱，最直接的原因来自于对重复代码的厌恶。通过函数，我可以把一段段逻辑封装成可复用的小单位，成片地消除项目里的重复代码。</p>\n<p>试想你正在给系统开发一个新功能，在写代码时，你发现新功能的主要逻辑和一个旧功能非常类似，于是你认真读了一遍旧代码，并从中提炼出了好几个<strong>函数</strong>。通过复用这些函数，你只增加了寥寥几行代码，就完成了新功能开发——还有比这更让人有成就感的事情吗？</p>\n<p>而消除重复代码，只是函数所提供给我们的众多好处之一。如果以它为起点，向四周继续发散，你会发现更多有趣的编程概念，包括<strong>高阶函数</strong>（higher-order function）、<strong>闭包</strong>（closure）、<strong>装饰器</strong>（decorator），等等。深入理解和掌握这些概念，是成为一名合格程序员的必经之路。</p>\n<p>话题回到 Python 里的函数。我们知道，Python 是一门支持<strong>面向对象</strong>（object-oriented）的编程语言，但除此之外，Python 对函数的支持也毫不逊色。</p>\n<p>从基础开始，我们最常用的函数定义方式是使用 <code>def</code> 语句：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code># 定义函数\ndef add(x, y):\n    return x + y\n\n# 调用函数\nadd(3, 4)</code></pre>\n<p>除了 <code>def</code> 以外，你还可以使用 <code>lambda</code> 关键字来定义一个匿名函数：</p>\n<pre class=\"code-rows\"><code># 效果与 add 函数一样\nadd = lambda x, y: x + y</code></pre>\n<p>函数在 Python 中是一等对象，这意味着我们可以把函数自身作为函数参数来使用。最常用的内置排序函数 <code>sorted()</code> 就利用了这个特性：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; l = [13, 16, 21, 3]\n\n# key 参数接收匿名函数作为参数\n&gt;&gt;&gt; sorted(l, key=lambda i: i % 3)\n[21, 3, 13, 16]</code></pre>\n<p>创建一个函数很容易——只要写下一行 <code>def</code>，丢进去一些代码就行。但要写出一个好函数就没那么简单了。在编写函数时，有许多环节值得我们仔细推敲：</p>\n<ul>\n<li>函数的名字是否易读好记？<code>dump_fields</code> 是个好名字吗？</li>\n<li>函数的参数设计是否合理？接收 4 个参数会太多吗？</li>\n<li>函数应该返回 <code>None</code> 吗？</li>\n</ul>\n<p>类似的问题还有很多。</p>\n<p>假如函数设计得当，其他人在阅读代码时，不光能更快地理解代码的意图，调用函数时也会觉得轻松惬意。而设计糟糕的函数，不光读起来晦涩难懂，想调用它时也常会碰一鼻子灰。</p>\n<p>在本章中，我将分享一些在 Python 里编写函数的技巧，帮你避开一些常见陷阱，写出更清晰、更健壮的函数。</p>\n<h2 id=\"nav_point_116\">7.1　基础知识</h2>\n<h3 id=\"nav_point_117\">7.1.1　函数参数的常用技巧</h3>\n<p><strong>参数</strong>（parameter）是函数的重要组成部分，它是函数最主要的输入源，决定了调用方使用函数时的体验。</p>\n<p>接下来，我将介绍与 Python 函数参数有关的几个常用技巧。</p>\n<ol>\n<li><p><strong>别将可变类型作为参数默认值</strong></p>\n<p>在编写函数时，我们经常需要为参数设置默认值。这些默认值可以是任何类型，比如字符串、数值、列表，等等。而当它是可变类型时，怪事儿就会发生。</p>\n<p>以下面这个函数为例：</p>\n<pre class=\"code-rows\"><code>def append_value(value, items=[]):\n    \"\"\"向 items 列表中追加内容，并返回列表\"\"\"\n    items.append(value)\n    return items</code></pre>\n<p>这样的函数定义看上去没什么问题，但当你多次调用它以后，就会发现函数的行为和预想的不太一样：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; append_value('foo')\n['foo']\n&gt;&gt;&gt; append_value('bar')\n['foo', 'bar']</code></pre>\n<p>可以看到，在第二次调用时，函数并没有返回正确结果 <code>['bar']</code>，而是返回了 <code>['foo', 'bar']</code>，这意味着参数 <code>items</code> 的值不再是函数定义的空列表 <code>[]</code>，而是变成了第一次执行后的结果 <code>['foo']</code>。</p>\n<p>之所以出现这个问题，是因为 Python 函数的<strong>参数默认值只会在函数定义阶段被创建一次</strong>，之后不论再调用多少次，函数内拿到的默认值都是同一个对象。</p>\n<p>假如再多花点儿功夫，你甚至可以通过函数对象的保留属性 <code>__defaults__</code> 直接读取这个默认值：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; append_value.__defaults__[0] ➊\n['foo', 'bar']\n\n&gt;&gt;&gt; append_value.__defaults__[0].append('baz') ➋\n&gt;&gt;&gt; append_value('value')\n['foo', 'bar', 'baz', 'value']</code></pre>\n<blockquote>\n<p>❶ 通过 <code>__defaults__</code> 属性可以直接获取函数的参数默认值</p>\n<p>❷ 假如修改这个参数默认值，可以直接影响函数调用结果</p>\n</blockquote>\n<p>因此，熟悉 Python 的程序员通常不会将可变类型作为参数默认值。这是因为一旦函数在执行时修改了这个默认值，就会对之后的所有函数调用产生影响。</p>\n<p>为了规避这个问题，使用 <code>None</code> 来替代可变类型默认值是比较常见的做法：</p>\n<pre class=\"code-rows\"><code>def append_value(value, items=None):\n    if items is None:\n        items = []\n    items.append(value)\n    return item</code></pre>\n<p>这样修改后，假如调用方没有提供 <code>items</code> 参数，函数每次都会构建一个新列表，不会再出现之前的问题。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>定义特殊对象来区分是否提供了默认参数</strong></p>\n<p>当我们为函数参数设置了默认值，不强制要求调用方提供这些参数以后，会引入另一件麻烦事儿：无法严格区分调用方是不是<strong>真的</strong>提供了这个默认参数。</p>\n<p>以下面这个函数为例：</p>\n<pre class=\"code-rows\"><code>def dump_value(value, extra=None):\n    if extra is None:\n        # 无法区分是否提供 None 是不是主动传入\n    ...\n\n# 两种调用方式\ndump_value(value)\ndump_value(value, extra=None)</code></pre>\n<p>对于 <code>dump_value()</code> 函数来说，当调用方使用上面两种方式来调用它时，它其实无法分辨。因为在这两种情况下，函数内拿到的 <code>extra</code> 参数的值都是 <code>None</code>。</p>\n<p>要解决这个问题，最常见的做法是定义一个特殊对象（标记变量）作为参数默认值：</p>\n<pre class=\"code-rows\"><code># 定义标记变量\n# object 通常不会单独使用，但是拿来做这种标记变量刚刚好\n_not_set = object()\n\ndef dump_value(value, extra=_not_set):\n    if extra is _not_set:\n        # 调用方没有传递 extra 参数\n    ...</code></pre>\n<p>相比 <code>None</code>，<code>_not_set</code> 是一个独一无二、无法随意获取的标记值。假如函数在执行时判断 <code>extra</code> 的值等于 <code>_not_set</code>，那我们基本可以认定：调用方没有提供 <code>extra</code> 参数。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>定义仅限关键字参数</strong></p>\n<p>在经典编程图书《代码整洁之道》<span class=\"comment-number\">1</span> 中，作者 Robert C. Martin 提到：“函数接收的参数不要太多，最好不要超过 3 个。”这个建议很有道理，因为参数越多，函数的调用方式就会变得越复杂，代码也会变得更难懂。</p>\n<p>下面这段代码就是个反例：</p>\n<pre class=\"code-rows\"><code># 参数太多，根本不知道函数在做什么\nfunc_with_many_args(user, post, True, 30, 100, 'field')</code></pre>\n<p>但建议归建议，在真实的 Python 项目中，接收超过 3 个参数的函数比比皆是。</p>\n<p>为什么会这样呢？大概是因为 Python 里的函数不光支持通过有序<strong>位置参数</strong>（positional argument）调用，还能指定参数名，通过<strong>关键字参数</strong>（keyword argument）的方式调用。</p>\n<p>比如下面这个用户查询函数：</p>\n<pre class=\"code-rows\"><code>def query_users(limit, offset, min_followers_count, include_profile):\n    \"\"\"查询用户\n\n    :param min_followers_count: 最小关注者数量\n    :param include_profile: 结果包含用户详细档案\n    \"\"\"\n    ...</code></pre>\n<p>假如完全使用位置参数来调用它，会写出非常让人糊涂的代码：</p>\n<pre class=\"code-rows\"><code># 时间长了，谁能知道 100 和 True 分别代表什么呢？\nquery_users(20, 0, 100, True)</code></pre>\n<p>但如果使用关键字参数，代码就会易读许多：</p>\n<pre class=\"code-rows\"><code>query_users(limit=20, offset=0, min_followers_count=100, include_profile=True)\n\n# 关键字参数可以不严格按照函数定义参数的顺序来传递\nquery_users(min_followers_count=100, include_profile=True, limit=20, offset=0)</code></pre>\n<p>所以，当你要调用参数较多（超过 3 个）的函数时，使用关键字参数模式可以大大提高代码的可读性。</p>\n<p>虽然关键字参数调用模式很有用，但有一个美中不足之处：它只是调用函数时的一种可选方式，无法成为强制要求。不过，我们可以用一种特殊的参数定义语法来弥补这个不足：</p>\n<pre class=\"code-rows\"><code># 注意参数列表中的 * 符号\ndef query_users(limit, offset, *, min_followers_count, include_profile):</code></pre>\n<p>通过在参数列表中插入 <code>*</code> 符号，该符号后的所有参数都变成了“仅限关键字参数”（keyword-only argument）。如果调用方仍然想用位置参数来提供这些参数值，程序就会抛出错误：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; query_users(20, 0, 100, True)\n# 执行后报错：\nTypeError: query_users() takes 2 positional arguments but 4 were given\n\n# 正确的调用方式\n&gt;&gt;&gt; query_users(20, 0, min_followers_count=100, include_profile=True)</code></pre>\n<p>当函数参数较多时，通过这种方式把部分参数变为“仅限关键字参数”，可以强制调用方提供参数名，提升代码可读性。</p>\n<blockquote>\n<p><strong>仅限位置参数</strong></p>\n<p>除了“仅限关键字参数”外，Python 还在 3.8 版本后提供另一个对称特性：“仅限位置参数”（positional-only argument）。</p>\n<p>“仅限位置参数”的使用方式是在参数列表中插入 <code>/</code> 符号。比如 <code>def query_users(limit, offset, /, min_followers_count, include_profile)</code> 表示，<code>limit</code> 和 <code>offset</code> 参数都只能通过位置参数来提供。</p>\n<p>不过在日常编程中，我发现需要使用“仅限位置参数”的场景，远没有“仅限关键字参数”的多，所以就不做过多介绍了。假如你感兴趣，可以阅读 PEP-570 了解详细说明。</p>\n</blockquote>\n</li>\n</ol>\n\n<h3 id=\"nav_point_118\">7.1.2　函数返回的常见模式</h3>\n<p>除了参数以外，函数还有另一个重要组成部分：返回值。下面是一些和返回值有关的常见模式。</p>\n<ol>\n<li><p><strong>尽量只返回一种类型</strong></p>\n<p>Python 是一门动态语言，它在类型方面非常灵活，因此我们能用它轻松完成一些在其他静态语言里很难做到的事情，比如让一个函数同时返回多种类型的结果：</p>\n<pre class=\"code-rows\"><code>def get_users(user_id=None):\n    if user_id is not None:\n        return User.get(user_id)\n    else:\n        return User.filter(is_active=True)\n　\n　\n# 返回单个用户\nuser = get_users(user_id=1)\n# 返回多个用户\nusers = get_users()</code></pre>\n<p>当使用方调用这个函数时，如果提供了 <code>user_id</code> 参数，函数就会返回单个用户对象，否则函数会返回所有活跃用户列表。同一个函数搞定了两种需求。</p>\n<p>虽然这样的“多功能函数”看上去很实用，像瑞士军刀一样“多才多艺”，但在现实世界里，这样的函数只会更容易让调用方困惑——“明明 <code>get_users()</code> 函数名字里写的是 <code>users</code>，为什么有时候只返回了单个用户呢？”</p>\n<p>好的函数设计一定是简单的，这种简单体现在各个方面。返回多种类型明显违反了简单原则。这种做法不光会给函数本身增加不必要的复杂度，还会提高用户理解和使用函数的成本。</p>\n<p>像上面的例子，更好的做法是将它拆分为两个独立的函数。</p>\n<p>(1) <code>get_user_by_id(user_id)</code>：返回单个用户。</p>\n<p>(2) <code>get_active_users()</code>：返回多个用户列表。</p>\n<p>这样就能让每个函数只返回一种类型，变得更简单易用。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>谨慎返回 None 值</strong></p>\n<p>在编程语言的世界里，“空值”随处可见，它通常用来表示某个<strong>应该存在但是缺失</strong>的东西。“空值”在不同编程语言里有不同的名字，比如 Go 把它叫作 <code>nil</code>，Java 把它叫作 <code>null</code>，Python 则称它为 <code>None</code>。</p>\n<p>在 Python 中，<code>None</code> 是独一无二的存在。因为它有着一种独特的“虚无”含义，所以经常会用作函数返回值。</p>\n<p>当我们需要让函数返回 <code>None</code> 时，主要是下面 3 种情况。</p>\n<ul>\n<li><p><strong>操作类函数的默认返回值</strong></p>\n<p>当某个操作类函数不需要任何返回值时，通常会返回 <code>None</code>。与此同时，<code>None</code> 也是不带任何 <code>return</code> 语句的函数的默认返回值：</p>\n<pre class=\"code-rows\"><code>def close_ignore_errors(fp):\n# 操作类函数，默认返回 None\ntry:\n    fp.close()\nexcept IOError:\n    logger.warning('error closing file')</code></pre>\n<p>在这种场景下，返回 <code>None</code> 没有任何问题。标准库里有许多这类函数，比如 <code>os.chdir()</code>、列表的 <code>append()</code> 方法等。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>意料之中的缺失值</strong></p>\n<p>还有一类函数，它们所做的事情天生就是在尝试，比如从数据库里查找一个用户、在目录中查找一个文件。视条件不同，函数执行后可能有结果，也可能没有结果。而重点在于，对于函数的调用方来说，“没有结果”是意料之中的事情。</p>\n<p>针对这类函数，使用 <code>None</code> 作为“没有结果”时的返回值通常也是合理的。</p>\n<p>在标准库中，正则表达式模块 <code>re</code> 下的 <code>re.search()</code>、<code>re.match()</code> 函数均属于此类。这两个函数在找到匹配结果时，会返回 <code>re.Match</code> 对象，否则返回 <code>None</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>在执行失败时代表“错误”</strong></p>\n<p>有时候，<code>None</code> 也会用作执行失败时的默认返回值。以下面这个函数为例：</p>\n<pre class=\"code-rows\"><code>def create_user_from_name(username):\n    \"\"\"通过用户名创建一个 User 实例\"\"\"\n    if validate_username(username):\n        return User.from_username(username)\n    else:\n        return None\n　\n　\nuser = create_user_from_name(username)\nif user is not None:\n    user.do_something()</code></pre>\n<p>当 <code>username</code> 通过校验时，函数会返回正常的用户对象，否则返回 <code>None</code>。</p>\n<p>这种做法看上去合情合理，甚至你会觉得，这和上一个场景“意料之中的缺失值”是同一回事儿。但它们之间其实有着微妙的区别。拿两个典型的具体函数来说，这种区别如下。</p>\n<ul>\n<li class=\"第3级无序列表\"><code>re.search()</code>：函数名 <code>search</code>，代表从目标字符串里<strong>搜索</strong>匹配结果，而搜索行为一向是可能有结果，也可能没有结果的。而且，当没有结果时，函数也不需要向调用方说明原因，所以它适合返回 <code>None</code>。</li>\n<li class=\"第3级无序列表\"><code>create_user_from_name()</code>：函数名的含义是“通过名字构建用户”，里面并没有一种可能没有结果的含义。而且如果创建失败，调用方大概率会想知道失败原因，而不仅仅是拿到一个 <code>None</code>。</li>\n</ul>\n<p>从上面的分析来看，适合返回 <code>None</code> 的函数需要满足以下两个特点：</p>\n<p>(1) 函数的名称和参数必须表达“结果可能缺失”的意思；</p>\n<p>(2) 如果函数执行无法产生结果，调用方也不关心具体原因。</p>\n<p>所以，除了“搜索”“查询”几个场景外，对绝大部分函数而言，返回 <code>None</code> 并不是一个好的做法。</p>\n<p>对这些函数来说，用抛出异常来代替返回 <code>None</code> 会更为合理。这也很好理解：当函数被调用时，如果无法返回正常结果，就代表出现了意料以外的状况，而“意料之外”正是异常所掌管的领域。</p>\n<p>使用异常改写函数后，代码会变成下面这样：</p>\n<pre class=\"code-rows\"><code>class UnableToCreateUser(Exception):\n    \"\"\"当无法创建用户时抛出\"\"\"\n　\n　\ndef create_user_from_name(username):\n    \"\"\"通过用户名创建一个 User 实例\n\n    :raises: 当无法创建用户时抛出 UnableToCreateUser\n    \"\"\"\n    if validate_username(username):\n        return User.from_username(username)\n    else:\n        raise UnableToCreateUser(f'unable to create user from ')\n　\n　\ntry:\n    user = create_user_from_name(username)\nexcept UnableToCreateUser:\n    # 此处编写异常处理逻辑\nelse:\n    user.do_something()</code></pre>\n<p>与返回 <code>None</code> 相比，这种方式要求调用方使用 <code>try</code> 语句来捕获可能出现的异常。虽然代码比之前多了几行，但这样做有一个明显的优势：调用方可以从异常对象里获取错误原因——只返回一个 <code>None</code> 可做不到这点。</p>\n<p>&nbsp;</p>\n</li>\n</ul>\n</li>\n<li><p><strong>早返回，多返回</strong></p>\n<p>自打我开始写代码以来，常常会听人说起一条叫“单一出口”的原则。这条原则是说：“函数应该保证只有一个出口。”如果从字面上理解，符合这条原则的函数大概如下所示：</p>\n<pre class=\"code-rows\"><code>def user_get_tweets(user):\n    \"\"\"获取用户已发布状态\n\n    - 如果配置\"展示随机状态\"，获取随机状态\n    - 如果配置\"不展示任何状态\"，返回空的占位符状态\n    - 默认返回最新状态\n    \"\"\"\n    tweets = []\n    if user.profile.show_random_tweets:\n        tweets.extend(get_random_tweets(user))\n    elif user.profile.hide_tweets:\n        tweets.append(NULL_TWEET_PLACEHOLDER)\n    else:\n        # 最新状态需要用 token 从其他服务获取，并转换格式\n        token = user.get_token()\n        latest_tweets = get_latest_tweets(token)\n        tweets.extend([transorm_tweet(item) for item in latest_tweets])\n    return tweets</code></pre>\n<p>在这段代码里，<code>user_get_tweets()</code> 函数首先在头部初始化了结果变量 <code>tweets</code>，然后统一在尾部用一条 <code>return</code> 语句返回，符合“单一出口”原则。</p>\n<p>如果以 4.3.1 节的“避免多层分支嵌套”的要求来看，上面的代码是完全符合标准的——函数内部只有一层分支，没有多层嵌套。</p>\n<p>但这种风格的代码可读性不是很好，主要原因在于，读者在阅读函数的过程中，必须先把所有逻辑一个不落的装进脑子里，只有等到最后的 <code>return</code> 出现时，才能搞清楚所有事情。</p>\n<p>拿具体场景举例，假如我在读 <code>user_get_tweets()</code> 函数时，只想弄明白“展示随机状态”这个分支会返回什么，那当我读完第二行代码后，仍然需要继续看完剩下的所有代码，才能确认函数最终会返回什么。</p>\n<p>当函数逻辑较为复杂时，这种遵循“单一出口”风格编写的代码，为阅读代码增加了不少负担。</p>\n<p>如果我们稍微调整一下写代码的思路：一旦函数在执行过程中满足返回结果的要求，就直接返回，代码会变成下面这样：</p>\n<pre class=\"code-rows\"><code>def user_get_tweets(user):\n    \"\"\"获取用户已发布状态\"\"\"\n    if user.profile.show_random_tweets:\n        return get_random_tweets(user)\n\n    if user.profile.hide_tweets:\n        return [NULL_TWEET_PLACEHOLDER]\n\n    # 最新状态需要用 token 从其他服务获取，并转换格式\n    token = user.get_token()\n    latest_tweets = get_latest_tweets(token)\n    return [transorm_tweet(item) for item in latest_tweets]</code></pre>\n<p>在这段代码里，函数的 <code>return</code> 数量从 1 个变成了 3 个。试着读读上面的代码，是不是会发现函数的逻辑变得更容易理解了？</p>\n<p>产生这种变化的主要原因是，对于读代码的人来说，<code>return</code> 是一种有效的思维减负工具。当我们自上而下阅读代码时，假如遇到了 <code>return</code>，就会清楚知道：“这条执行路线已经结束了”。这部分逻辑在大脑里占用的空间会立刻得到释放，让我们可以专注于下一段逻辑。</p>\n<p>因此，在编写函数时，请不要纠结函数是不是应该只有一个 <code>return</code>，只要尽早返回结果可以提升代码可读性，那就多多返回吧。</p>\n<blockquote>\n<p><strong>“单一出口”的由来</strong></p>\n<p>在写这部分内容时，我特意查询了“单一出口”原则的历史，以下是我的发现。</p>\n<p>在几十年前，汇编与 FORTRAN 语言流行的年代，编程语言拥有令人头疼的灵活性，你可以用各种花样在代码内随意跳转，这导致程序员很容易写出各种难以调试的代码。</p>\n<p>为了解决这个问题，著名计算机科学家 Dijkstra 提出了“单一入口，单一出口”（Single Entry, Single Exit）原则。在这个原则中，“单一出口”的意思是：函数（子程序）应该只从同一个地方跳出。</p>\n<p>这样一来事情就很明朗了。在现代编程语言里，无论函数内部有多少个 <code>return</code> 语句，函数的出口都是统一的——通往上层调用栈，所以这完全不属于最初的“单一出口”原则所担心的范围。</p>\n<p>即使后来“单一出口”原则发展出了别的含义，它也只针对一些特定的编程语言、编程场景有意义。比如在特定环境下，不恰当的返回会导致程序资源泄露等问题，所以要把返回统一起来管理。</p>\n<p>但在 Python 中，“单一出口原则建议函数只写一个 <code>return</code>”只能算是一种误读，在“单一出口”和“多多返回”之间，我们完全可以选择可读性更强的那个。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"nav_point_119\">7.1.3　常用函数模块：<code>functools</code></h3>\n<p>在 Python 标准库中，有一些与函数关系紧密的模块，其中最有代表性的当属 <code>functools</code>。</p>\n<p><code>functools</code> 是一个专门用来处理函数的内置模块，其中有十几个和函数相关的有用工具，我会挑选比较常用的两个，简单介绍它们的功能。</p>\n<ol>\n<li><p><strong><code>functools.partial()</code></strong></p>\n<p>假如在你的项目中，有一个负责进行乘法运算的函数 <code>multiply()</code>：</p>\n<pre class=\"code-rows\"><code>def multiply(x, y):\n    return x * y</code></pre>\n<p>同时，还有许多调用 <code>multiplay()</code> 函数进行运算的代码：</p>\n<pre class=\"code-rows\"><code>result = multiply(2, value)\nval = multiply(2, number)\n# ...</code></pre>\n<p>这些代码有一个共同的特点，那就是它们调用函数时的第一个参数都是 <code>2</code>——全都是对某个值进行 <code>*2</code> 操作。</p>\n<p>为了简化函数调用，让代码更简洁，我们其实可以定义一个接收单个参数的 <code>double()</code> 函数，让它通过 <code>multiply()</code> 完成计算：</p>\n<pre class=\"code-rows\"><code>def double(value):\n    # 返回 multiply 函数调用结果\n    return multiply(2, value)\n\n# 调用代码变得更简单\nresult = double(value)\nval = double(number)</code></pre>\n<p>这是一个很常见的函数使用场景：首先有一个接收许多参数的函数 <code>a</code>，然后额外定义一个接收更少参数的函数 <code>b</code>，通过在 <code>b</code> 内部补充一些预设参数，最后返回调用 <code>a</code> 函数的结果。</p>\n<p>针对这类场景，我们其实不需要像前面一样，用 <code>def</code> 去完全定义一个新函数——直接使用 <code>functools</code> 模块提供的高阶函数 <code>partial()</code> 就行。</p>\n<p><code>partial</code> 的调用方式为 <code>partial(func, *arg, **kwargs)</code>，其中：</p>\n<ul>\n<li><code>func</code> 是完成具体功能的原函数；</li>\n<li><code>*args</code>/<code>**kwargs</code> 是可选位置与关键字参数，必须是原函数 <code>func</code> 所接收的合法参数。</li>\n</ul>\n<p>举个例子，当你调用 <code>partial(func, True, foo=1)</code> 后，函数会返回一个新的<strong>可调用对象</strong>（callable object）——偏函数 <code>partial_obj</code>。</p>\n<p>拿到这个偏函数后，如果你不带任何参数调用它，效果等同于使用构建 <code>partial_obj</code> 对象时的参数调用原函数：<code>partial_obj()</code> 等同于 <code>func(True, foo=1)</code>。</p>\n<p>但假如你在调用 <code>partial_obj</code> 对象时提供了额外参数，前者就会首先将本次调用参数和构造 <code>partial_obj</code> 时的参数进行合并，然后将合并后的参数透传给原始函数 <code>func</code> 处理，也就是说，<code>partial_obj(bar=2)</code> 与 <code>func(True, foo=1, bar=2)</code> 效果相同。</p>\n<p>使用 <code>functools.partial</code>，上面的 <code>double()</code> 函数定义可以变得更简洁：</p>\n<pre class=\"code-rows\"><code>import functools\n\ndouble = functools.partial(multiply, 2)</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong><code>functools.lru_cache()</code></strong></p>\n<p>在编码时，我们的函数常常需要做一些耗时较长的操作，比如调用第三方 API、进行复杂运算等。这些操作会导致函数执行速度慢，无法满足要求。为了提高效率，给这类慢函数加上缓存是比较常见的做法。</p>\n<p>在缓存方面，<code>functools</code> 模块为我们提供一个开箱即用的工具：<code>lru_cache()</code>。使用它，你可以方便地给函数加上缓存功能，同时不用修改任何函数内部代码。</p>\n<p>假设我有一个分数统计函数 <code>caculate_score()</code>，每次执行都要耗费一分钟以上：</p>\n<pre class=\"code-rows\"><code>def calculate_score(class_id):\n    print(f'Calculating score for class: ...')\n    # 模拟此处存在一些速度很慢的统计代码……\n    time.sleep(60)\n    return 42</code></pre>\n<p>因为 <code>caculate_score()</code> 函数执行耗时较长，而且每个 <code>class_id</code> 的统计结果都是稳定的，所以我可以直接使用 <code>lru_cache()</code> 为它加上缓存：</p>\n<pre class=\"code-rows\"><code>@lru_cache(maxsize=None)\ndef calculate_score(class_id):\n    print(f'Calculating score for class: ...')\n    time.sleep(60)\n    return 42</code></pre>\n<p>加上 <code>lru_cache()</code> 后的效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; calculate_score(100)\n# 缓存未命中，耗时较长\nCalculating score for class: 100...\n42\n\n# 第二次使用同样的参数调用函数，就不会触发函数内部的计算逻辑，\n# 结果立刻就返回了。\n&gt;&gt;&gt; calculate_score(100)\n42</code></pre>\n<p>在使用 <code>lru_cache()</code> 装饰器时，可以传入一个可选的 <code>maxsize</code> 参数，该参数代表当前函数最多可以保存多少个缓存结果。当缓存的结果数量超过 <code>maxsize</code> 以后，程序就会基于“最近最少使用”（least recently used，LRU）算法丢掉旧缓存，释放内存。默认情况下，<code>maxsize</code> 的值为 128。</p>\n<p>如果你把 <code>maxsize</code> 设置为 <code>None</code>，函数就会保存每一个执行结果，不再剔除任何旧缓存。这时如果被缓存的内容太多，就会有占用过多内存的风险。</p>\n<p>除了 <code>partial()</code> 与 <code>lru_cache()</code> 以外，<code>functools</code> 模块里还有许多有趣的函数工具，比如 <code>wraps()</code>、<code>reduce()</code> 等。如果有兴趣，可以到官方文档查阅更详细的资料，这里就不再一一赘述。</p>\n</li>\n</ol>\n<h2 id=\"nav_point_120\">7.2　案例故事</h2>\n<p>在<strong>函数式编程</strong>（functional programming）领域，有一个术语<strong>纯函数</strong>（pure function）。它最大的特点是，假如输入参数相同，输出结果也一定相同，不受任何其他因素影响。换句话说，纯函数是一种无状态的函数。</p>\n<p>比如下面的 <code>mosaic()</code> 函数就符合我们对纯函数的定义：</p>\n<pre class=\"code-rows\"><code>def mosaic(s):\n    \"\"\"把输入字符串替换为等长的星号字符\"\"\"\n    return '*' * len(s)</code></pre>\n<p>调用结果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; mosaic('input')\n'*****'</code></pre>\n<p>让函数保持无状态有不少好处。相比有状态函数，无状态函数的逻辑通常更容易理解。在进行并发编程时，无状态函数也有着无须处理状态相关问题的天然优势。</p>\n<p>但即便如此，我们的日常工作还是免不了要和“状态”打交道，比如在下面这个故事里，小 R 遇到的问题就需要用“状态”来解决。</p>\n<h3 id=\"nav_point_121\">函数与状态</h3>\n<ol>\n<li><p><strong>热身运动</strong></p>\n<p>小 R 正在自学 Python，一天，他从网上看到一道和字符串处理有关的练习题：</p>\n<blockquote>\n<p>有一段文字，里面包含各类数字，比如数量、价格等，编写一段代码把文字里的所有数字都用星号替代，实现脱敏的效果。</p>\n<ul>\n<li class=\"第3级无序列表\">原始文本：商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个。</li>\n<li class=\"第3级无序列表\">目标文本：商店共 <code>*</code> 个苹果，小明以 <code>*</code> 元每斤的价格买走了 <code>*</code> 个。</li>\n</ul>\n</blockquote>\n<p>看完这道题目，小 R 心想：“前段时间刚学过正则表达式，用它来处理这个问题正合适！”翻了翻正则表达式模块 <code>re</code> 的官方文档后，他很快锁定了目标：<code>re.sub()</code> 函数。</p>\n<p><code>re.sub(pattern, repl, string, count, flags)</code> 是正则表达式模块所提供的字符串替换函数，它接收五个参数。</p>\n<p>(1)<code>pattern</code>：需要匹配的正则模式。</p>\n<p>(2)<code>repl</code>：用于替换的目标内容，可以是字符串或函数。</p>\n<p>(3)<code>string</code>：待替换的目标字符串。</p>\n<p>(4)<code>count</code>：最大替换次数，默认为 0，表示不限制次数。</p>\n<p>(5) <code>flags</code>：正则匹配标志，比如 <code>re.IGNORECASE</code> 代表不区分大小写。</p>\n<p>使用 <code>re.sub()</code> 函数，小 R 很快解出了练习题的答案，如代码清单 7-1 所示。</p>\n<blockquote>\n<p><strong>代码清单 7-1</strong>　用正则替换连续数字的函数代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>import re\n\ndef mosaic_string(s):\n    \"\"\"用 * 替换输入字符串里面所有的连续数字\"\"\"\n    return re.sub(r'\\d+', '*', s) ➊</code></pre>\n<blockquote>\n<p>❶ 正则小知识入门：此处 <code>pattern</code> 中的 <code>\\d</code> 表示 0～9 的所有数字，<code>+</code> 表示重复 1 次以上</p>\n</blockquote>\n<p>调用效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; mosaic_string(\"商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个\")\n'商店共 * 个苹果，小明以 * 元每斤的价格买走了 * 个'</code></pre>\n<p>完成练习题后，小 R 点击了“下一步”按钮，没想到屏幕上出现了新的要求。</p>\n<blockquote>\n<p>恭喜你完成了第一步，但这只是热身运动。</p>\n<p>现在请进一步修改函数，保留每个被替换数字的原始长度，比如 100 应该被替换成 <code>***</code>。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用函数</strong></p>\n<p>看到新的问题说明后，小 R 觉得这个需求仍然可以用 <code>re.sub()</code> 函数满足，于是他重新认真翻了一遍函数文档，果然找到了办法。</p>\n<p>原来，在使用 <code>re.sub(pattern, repl, string)</code> 函数时，第二个参数 <code>repl</code> 不光可以是普通字符串，还可以是一个可调用的函数对象。</p>\n<p>如果要用等长的星号来替换所有数字，只要先定义如代码清单 7-2 所示的函数。</p>\n<blockquote>\n<p><strong>代码清单 7-2</strong>　用等长星号替换数字</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def mosaic_matchobj(matchobj): ➊\n    \"\"\"将匹配到的模式替换为等长星号字符串\"\"\"\n    length = len(matchobj.group())\n    return '*' * length</code></pre>\n<blockquote>\n<p>❶ 用作 <code>repl</code> 参数的函数必须接收一个参数：<code>matchobj</code>，它的值是当前匹配到的对象。</p>\n</blockquote>\n<p>然后将它作为 <code>repl</code> 参数，就能实现题目要求的效果：</p>\n<pre class=\"code-rows\"><code>def mosaic_string(s):\n    \"\"\"用等长的 * 替换输入字符串里面所有的连续数字\"\"\"\n    return re.sub(r'\\d+', mosaic_matchobj, s)</code></pre>\n<p>调用结果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; mosaic_string(\"商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个\")\n'商店共 *** 个苹果，小明用 ** 元的价格买走了 * 个'</code></pre>\n<p>解决问题后，小 R 高兴地点击了“下一步”。不出所料，屏幕上又出现了新的需求。</p>\n<blockquote>\n<p>恭喜你完成了问题，现在请迎接最终挑战。</p>\n<p>请在替换数字时加入一些更有趣的逻辑——全部使用星号 <code>*</code> 来替换，显得有些单调，如果能轮换使用 <code>*</code> 和 <code>x</code> 两种符号就好了。</p>\n<p>举个例子，“商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个”被替换后应该变成“商店共 <code>***</code> 个苹果，小明以 <code>xx</code> 元每斤的价格买走了 <code>*</code> 个”。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>给函数加上状态：全局变量</strong></p>\n<p>看到新的问题后，小 R 陷入了思考。</p>\n<p>截至上一个问题，小 R 所写的 <code>mosaic_matchobj()</code> 函数只是一个无状态函数。但为了满足新需求，小 R 需要调整 <code>mosaic_matchobj()</code> 函数，把它从一个无状态函数改为有状态函数。</p>\n<p>这里的“状态”，当然就是指它需要记录每次调用时应该使用 <code>*</code> 还是 <code>x</code> 符号。</p>\n<p>给函数加上状态的办法有很多，而全局变量通常是最容易想到的方式。</p>\n<p>为了实现每次调用时轮换马赛克字符，小 R 可以直接定义一个全局变量 <code>_mosaic_char_index</code>，用它来记录函数当前使用了 <code>'*'</code> 还是 <code>'x'</code> 字符。只要在每次调用函数时修改它的值，就能实现轮换功能。</p>\n<p>函数代码如代码清单 7-3 所示。</p>\n<blockquote>\n<p><strong>代码清单 7-3</strong>　使用全局变量的有状态替换函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>_mosaic_char_index = 0\n　\n　\ndef mosaic_global_var(matchobj):\n    \"\"\"\n    将匹配到的模式替换为其他字符，使用全局变量实现轮换字符效果\n    \"\"\"\n    global _mosaic_char_index ➊\n    mosaic_chars = ['*', 'x']\n\n    char = mosaic_chars[_mosaic_char_index]\n    # 递增马赛克字符索引值\n    _mosaic_char_index = (_mosaic_char_index + 1) % len(mosaic_chars)\n\n    length = len(matchobj.group())\n    return char * length</code></pre>\n<blockquote>\n<p>❶ 使用 <code>global</code> 关键字声明一个全局变量</p>\n</blockquote>\n<p>经过测试，函数可以满足要求：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; print(re.sub(r'\\d+', mosaic_global_var, '商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个'))\n商店共 *** 个苹果，小明以 xx 元每斤的价格买走了 * 个</code></pre>\n<p>虽然全局变量能满足需求，而且看上去似乎挺简单，但千万不要被它的外表蒙蔽了双眼。用全局变量保存状态，其实是写代码时最应该避开的事情之一。</p>\n<p>为什么这么说？其中的原因有很多。</p>\n<p>首先，上面这种方式封装性特别差，代码里的 <code>mosaic_global_var()</code> 函数不是一个完整可用的对象，必须配合一个模块级状态 <code>_mosaic_char_index</code> 使用。</p>\n<p>其次，上面这种方式非常脆弱。如果多个模块在不同线程里，同时导入并使用 <code>mosaic_global_var()</code> 函数，整个字符轮换的逻辑就会乱掉，因为多个调用方共享同一个全局标记变量 <code>_mosaic_char_index</code>。</p>\n<p>最后，现在的函数提供的调用结果甚至都不稳定。如果连续调用函数，就会出现下面这种情况：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; print(re.sub(r'\\d+', mosaic_global_var, '商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个')) ➊\n商店共 *** 个苹果，小明以 xx 元每斤的价格买走了 * 个\n\n&gt;&gt;&gt; print(re.sub(r'\\d+', mosaic_global_var, '商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个')) ➋\n商店共 xxx 个苹果，小明以 ** 元每斤的价格买走了 x 个</code></pre>\n<blockquote>\n<p>❶ 首次调用，从 <code>*</code> 符号开始</p>\n<p>❷ 第二次调用，因为全局标记没有被重置，刚好轮换到从 <code>x</code> 而不是 <code>*</code> 开始</p>\n</blockquote>\n<p>总而言之，用全局变量管理状态，在各种场景下几乎都是下策，仅可在迫不得已时作为终极手段使用。</p>\n<p>除了全局变量以外，小 R 还可以使用另一个办法：闭包。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>给函数加上状态：闭包</strong></p>\n<p><strong>闭包</strong>（closure）是编程语言领域里的一个专有名词。简单来说，闭包是一种允许函数访问已执行完成的其他函数里的私有变量的技术，是为函数增加状态的另一种方式。</p>\n<p>正常情况下，当 Python 完成一次函数执行后，本次使用的局部变量都会在调用结束后被回收，无法继续访问。但是，如果你使用下面这种“函数套函数”的方式，在外层函数执行结束后，返回内嵌函数，后者就可以继续访问前者的局部变量，形成了一个“闭包”结构，如代码清单 7-4 所示。</p>\n<blockquote>\n<p><strong>代码清单 7-4</strong>　闭包示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def counter():\n    value = 0\n    def _counter():\n        # nonlocal 用来标注变量来自上层作用域，如不标明，内层函数将无法直接修改外层函数变量\n        nonlocal value\n\n        value += 1\n        return value\n    return _counter</code></pre>\n<p>调用 <code>counter</code> 返回的结果函数，可以继续访问本该被释放的 <code>value</code> 变量的值：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; c = counter()\n&gt;&gt;&gt; c()\n1\n&gt;&gt;&gt; c()\n2\n&gt;&gt;&gt; c2 = counter() ➊\n&gt;&gt;&gt; c2()\n1</code></pre>\n<blockquote>\n<p>❶ 创建一个与 <code>c</code> 无关的新闭包对象 <code>c2</code></p>\n</blockquote>\n<p>得益于闭包的这个特点，小 R 可以用它来实现“会轮换字符的马赛克函数”，如代码清单 7-5 所示。</p>\n<blockquote>\n<p><strong>代码清单 7-5</strong>　使用闭包的有状态替换函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def make_cyclic_mosaic():\n    \"\"\"\n    将匹配到的模式替换为其他字符，使用闭包实现轮换字符效果\n    \"\"\"\n    char_index = 0\n    mosaic_chars = ['*', 'x']\n\n    def _mosaic(matchobj):\n        nonlocal char_index\n        char = mosaic_chars[char_index]\n        char_index = (char_index + 1) % len(mosaic_chars)\n\n        length = len(matchobj.group())\n        return char * length\n\n    return _mosaic</code></pre>\n<p>调用效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; re.sub(r'\\d+', make_cyclic_mosaic(), '商店共 100 个苹果，小明以 12 元每斤的价格买走了\n8 个') ➊\n'商店共 *** 个苹果，小明以 xx 元每斤的价格买走了 * 个'\n\n&gt;&gt;&gt; re.sub(r'\\d+', make_cyclic_mosaic(), '商店共 100 个苹果，小明以 12 元每斤的价格买走了\n8 个') ➋\n'商店共 *** 个苹果，小明以 xx 元每斤的价格买走了 * 个'</code></pre>\n<blockquote>\n<p>❶ 注意：此处是 <code>make_cyclic_mosaic()</code> 而不是 <code>make_cyclic_mosaic</code>，因为 <code>make_cyclic_mosaic()</code> 函数的调用结果才是真正的替换函数</p>\n<p>❷ 重复调用时使用新的闭包函数对象，计数器重新从 0 开始，没有结果不稳定问题</p>\n</blockquote>\n<p>相比全局变量，使用闭包最大的特点就是封装性要好得多。在闭包代码里，索引变量 <code>called_cnt</code> 完全处于闭包内部，不会污染全局命名空间，而且不同闭包对象之间也不会相互影响。</p>\n<p>总而言之，闭包是一种非常有用的工具，非常适合用来实现简单的有状态函数。</p>\n<p>不过，除了闭包之外，还有一个天生就适合用来实现“状态”的工具：类。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>给函数加上状态：类</strong></p>\n<p><strong>类</strong>（class）是面向对象编程里最基本的概念之一。在一个类中，状态和行为可以被很好地封装在一起，因此它天生适合用来实现有状态对象。</p>\n<p>通过类，我们可以生成一个个类实例，而这些实例对象的方法，可以像普通函数一样被调用。正因如此，小 R 也可以完全用类来实现一个“会轮换屏蔽字符的马赛克对象”，如代码清单 7-6 所示。</p>\n<blockquote>\n<p><strong>代码清单 7-6</strong>　基于类实现有状态替换方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class CyclicMosaic:\n    \"\"\"使用会轮换的屏蔽字符，基于类实现\"\"\"\n\n    _chars = ['*', 'x']\n\n    def __init__(self):\n        self._char_index = 0 ➊\n\n    def generate(self, matchobj):\n        char = self._chars[self._char_index]\n        self._char_index = (self._char_index + 1) % len(self._chars)\n        length = len(matchobj.group())\n        return char * length</code></pre>\n<blockquote>\n<p>❶ 类实例的状态一般都在 <code>__init__</code> 函数里初始化</p>\n</blockquote>\n<p>在调用时，需要先初始化一个 <code>CycleMosaic</code> 实例，然后使用它的 <code>generate</code> 方法：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; re.sub(r'\\d+', CycleMosaic().generate, '商店共 100 个苹果，小明以 12 元每斤的价格买走了 8 个')\n'商店共 *** 个苹果，小明以 xx 元每斤的价格买走了 * 个'</code></pre>\n<p>使用类和使用闭包一样，也可以很好地满足需求。</p>\n<p>不过严格说来，这个方案最终依赖的 <code>CycleMosaic().generate</code>，并非一个有状态的<strong>函数</strong>，而是一个有状态的<strong>实例方法</strong>。但无论是函数还是实例方法，它们都是“可调用对象”的一种，都可以作为 <code>re.sub()</code> 函数的 <code>repl</code> 参数使用。</p>\n<p>权衡了这三种方案的利弊后，小 R 最终选择了第三种基于类的方案，完成了这道练习题。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>小结</strong></p>\n<p>在小 R 解答练习题的过程中，一共出现了三种实现有状态函数的方式，这三种方式各有优缺点，总结如下。</p>\n<p>基于全局变量：</p>\n<ul>\n<li>学习成本最低，最容易理解；</li>\n<li>会增加模块级的全局状态，封装性和可维护性最差。</li>\n</ul>\n<p>基于函数闭包：</p>\n<ul>\n<li>学习成本适中，可读性较好；</li>\n<li>适合用来实现变量较少，较简单的有状态函数。</li>\n</ul>\n<p>创建类来封装状态：</p>\n<ul>\n<li>学习成本较高；</li>\n<li>当变量较多、行为较复杂时，类代码比闭包代码更易读，也更容易维护。</li>\n</ul>\n<p>在日常编码中，如果你需要实现有状态的函数，应该尽量避免使用全局变量，闭包或类才是更好的选择。</p>\n</li>\n</ol>\n","neighbors":{"left":{"article_title":"第 6 章 循环与可迭代对象","id":740843},"right":{"article_title":"第 7 章 函数(2)","id":740845}},"comments":[]}