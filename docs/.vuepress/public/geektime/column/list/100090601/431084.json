{"id":431084,"title":"20｜提效（下）：实现调试模式加速开发效率","content":"<p>你好，我是轩脉刃。</p><p>上一节课，我们讨论了调试模式的整体设计思路和关键的技术难点-反向代理，最后定义了具体的命令设计，包括三个二级命令，能让我们调试前端/后端，或者同时调试。现在，大的框架都建立好了，但是其中的细节实现还没有讨论。成败在于细节，今天我们就撸起袖子开始实现它们。</p><h2>配置项的设计</h2><p>简单回顾一下调试模式的架构设计。所有外部请求进入反响代理服务后，会由反向代理服务进行分发，前端请求分发到前端进程，后端请求分发到后端进程。<br>\n<img src=\"https://static001.geekbang.org/resource/image/86/16/86d2c8a583a1dafa52ee79fb95f30616.jpg?wh=1920x1080\" alt=\"\"><br>\n在这个设计中，前端服务启动的时候占用哪个端口？后端服务启动的时候占用哪个端口？反向代理服务proxy启动的时候占用哪个端口呢？这些都属于配置项，需要在设计之初就规划好，所以我们先设计配置项的具体实现。</p><p>由于调试模式配置项比较多，在framework/command/dev.go 中，我们定义如下的配置结构devConfig来表示配置信息：</p><pre><code class=\"language-go\">// devConfig 代表调试模式的配置信息\ntype devConfig struct {\n\n   Port    string   // 调试模式最终监听的端口，默认为8070\n   \n   Backend struct { // 后端调试模式配置\n      RefreshTime   int    // 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s\n      Port          string // 后端监听端口， 默认 8072\n      MonitorFolder string // 监听文件夹，默认为AppFolder\n   }\n   \n   Frontend struct { // 前端调试模式配置\n      Port string // 前端启动端口, 默认8071\n   }\n}\n</code></pre><!-- [[[read_end]]] --><p>这个结构可以说已经非常清晰了。结构根目录下的Port代表proxy的端口，而根目录下的Backend 和 Frontend 分别代表后端和前端的配置。</p><p>其中，前端只需要配置一个端口Port，<strong>而后端，我们除了配置端口Port之外，还另外多了两个配置，一个是监听的文件夹MonitorFolder，另外一个是监听文件夹的变更时间RefreshTime</strong>，这两个配置都是和后端监听文件夹相关的，具体如何使用，我们在后面写proxy的方法monitorBackend再详细说。</p><p>有了这个配置结构还不够，我们还要定义配置结构中每个值的赋值和默认值，在配置文件app.yaml中对应定义的配置字段如下：</p><pre><code class=\"language-yaml\">dev: # 调试模式\n  port: 8070 # 调试模式最终监听的端口，默认为8070\n  backend: # 后端调试模式配置\n    refresh_time: 3  # 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s\n    port: 8072 # 后端监听端口，默认8072\n    monitor_folder: \"\" # 监听文件夹地址，为空或者不填默认为AppFolder\n  frontend: # 前端调试模式配置\n    port: 8071 # 前端监听端口, 默认8071\n</code></pre><p>之后如果在配置文件中有配置这些字段，就使用配置文件中的字段，否则的话，则使用默认配置。对应到代码上，我们可以在framework/command/dev.go中实现一个initDevConfig。</p><p>实现思路也不难，参数只需要把服务容器传递进入就行了，在这个函数中，我们先定义好默认的配置，然后从容器中获取配置服务，通过配置服务，获取对应的配置文件的设置，如果配置文件有对应字段的话，就进行对应字段的配置。</p><pre><code class=\"language-go\">// 初始化配置文件\nfunc initDevConfig(c framework.Container) *devConfig {\n    // 设置默认值\n    devConfig := &amp;devConfig{\n        Port: \"8087\",\n        Backend: struct {\n            RefreshTime   int\n            Port          string\n            MonitorFolder string\n        }{\n            1,\n            \"8072\",\n            \"\",\n        },\n        Frontend: struct {\n            Port string\n        }{\n            \"8071\",\n        },\n    }\n    // 容器中获取配置服务\n    configer := c.MustMake(contract.ConfigKey).(contract.Config)\n    // 每个配置项进行检查\n    if configer.IsExist(\"app.dev.port\") {\n        devConfig.Port = configer.GetString(\"app.dev.port\")\n    }\n    if configer.IsExist(\"app.dev.backend.refresh_time\") {\n        devConfig.Backend.RefreshTime = configer.GetInt(\"app.dev.backend.refresh_time\")\n    }\n    if configer.IsExist(\"app.dev.backend.port\") {\n        devConfig.Backend.Port = configer.GetString(\"app.dev.backend.port\")\n    }\n    \n    // monitorFolder 默认使用目录服务的AppFolder()\n    monitorFolder := configer.GetString(\"app.dev.backend.monitor_folder\")\n    if monitorFolder == \"\" {\n        appService := c.MustMake(contract.AppKey).(contract.App)\n        devConfig.Backend.MonitorFolder = appService.AppFolder()\n    }\n    if configer.IsExist(\"app.dev.frontend.port\") {\n        devConfig.Frontend.Port = configer.GetString(\"app.dev.frontend.port\")\n    }\n    return devConfig\n}\n\n</code></pre><p>这里着重说一下monitorFolder这个配置的逻辑，如果配置文件中有定义这个配置的话，我们就使用配置文件的配置，否则我们就去目录服务中获取AppFolder。其实这种有层次的配置方式，在配置服务那一节我们已经见过了，多使用这种配置方式能让框架可用性更高。</p><p>但是之前<a href=\"https://time.geekbang.org/column/article/425820\">第12节课</a>，定义目录服务接口的时候，没有定义App的服务接口，所以我们得去稍微修改下目录服务接口 framework/contract/app.go，为其增加AppFolder这个目录接口：</p><pre><code class=\"language-go\">// App 定义接口\ntype App interface {\n   ...\n\n   // AppFolder 定义业务代码所在的目录，用于监控文件变更使用\n   AppFolder() string\n   ...\n}\n</code></pre><p>同时修改其对应实现 framework/provider/app/service.go，增加这个AppFolder的实现：</p><pre><code class=\"language-go\">// AppFolder 代表app目录\nfunc (app *HadeApp) AppFolder() string {\n   if val, ok := app.configMap[\"app_folder\"]; ok {\n      return val\n   }\n   return filepath.Join(app.BaseFolder(), \"app\")\n}\n</code></pre><p>到这里，配置结构devConfig及配置结构初始化方法 initDevConfig，就实现完成了。</p><h2>具体实现</h2><p>现在，来完成拼图的最后一个部分，回到framework/command/dev.go中，上节课只定义了Proxy结构，但是Proxy结构中的字段，我们没有讨论。</p><p>首先有了上面定义的devConfig结构之后，Proxy的结构中，应该有一个字段保存这个Proxy的配置信息devConfig。</p><p>其次，在restart前端或者后端的时候，由于<strong>新进程和旧进程都使用一样的端口</strong>，我们一定是先关闭旧的前端进程或者后端进程，才能启动新的前端或者后端进程。所以这里要记录一下前后端进程的进程ID，设置了backendPid和 frontendPid来存储进程ID。</p><pre><code class=\"language-go\">// Proxy 代表serve启动的服务器代理\ntype Proxy struct {\n   devConfig   *devConfig // 配置文件\n   backendPid  int        // 当前的backend服务的pid\n   frontendPid int        // 当前的frontend服务的pid\n}\n</code></pre><p>下面我们就针对每个函数的具体实现一一说明，这里把上节课定义的各个函数简单再列一下，如果你对它们的功能有点模糊了，可以再回顾一下第19课。</p><pre><code class=\"language-go\">// 初始化一个Proxy\nfunc NewProxy(c framework.Container) *Proxy{}\n// 重新启动一个proxy网关\nfunc (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy{}\n// 启动前端服务\nfunc (p *Proxy) restartFrontend() error{}\n// 启动后端服务\nfunc (p *Proxy) restartBackend() error {}\n// 编译后端服务\nfunc (p *Proxy) rebuildBackend() error {}\n// 启动proxy\nfunc (p *Proxy) startProxy(startFrontend, startBackend bool) error{}\n// 监控后端服务源码文件的变更\nfunc (p *Proxy) monitorBackend() error{}\n</code></pre><h3>newProxyReverseProxy</h3><p>首先是newProxyReverseProxy，它的核心逻辑就是创建ReverseProxy，设置Director、ModifyResponse、ErrorHandler三个字段。但是我们在细节上要做一些补充。</p><p>首先，既然已经在proxy中存了前后端的PID，那就可以知道当下前端服务或者后端服务是否已经启动了。如果只启动了前端服务，我们直接代理前端就好了；如果只启动后端服务，就直接代理后端。而<strong>只有两个服务都启动了，我们才进行上一节课说的：先请求后端服务，遇到404了，再请求前端服务</strong>。</p><p>同时稍微修改一下director，对于前端一些固定的请求地址，比如 / 或者 /app.js，我们直接将这个地址固定请求前端。</p><pre><code class=\"language-go\">// 重新启动一个proxy网关\nfunc (p *Proxy) newProxyReverseProxy(frontend, backend *url.URL) *httputil.ReverseProxy {\n   if p.frontendPid == 0 &amp;&amp; p.backendPid == 0 {\n      fmt.Println(\"前端和后端服务都不存在\")\n      return nil\n   }\n\n   // 后端服务存在\n   if p.frontendPid == 0 &amp;&amp; p.backendPid != 0 {\n      return httputil.NewSingleHostReverseProxy(backend)\n   }\n\n   // 前端服务存在\n   if p.backendPid == 0 &amp;&amp; p.frontendPid != 0 {\n      return httputil.NewSingleHostReverseProxy(frontend)\n   }\n\n   // 两个都有进程\n   // 先创建一个后端服务的directory\n   director := func(req *http.Request) {\n      if req.URL.Path == \"/\" || req.URL.Path == \"/app.js\" {\n         req.URL.Scheme = frontend.Scheme\n         req.URL.Host = frontend.Host\n      } else {\n         req.URL.Scheme = backend.Scheme\n         req.URL.Host = backend.Host\n      }\n   }\n\n   // 定义一个NotFoundErr\n   NotFoundErr := errors.New(\"response is 404, need to redirect\")\n   return &amp;httputil.ReverseProxy{\n      Director: director, // 先转发到后端服务\n      ModifyResponse: func(response *http.Response) error {\n         // 如果后端服务返回了404，我们返回NotFoundErr 会进入到errorHandler中\n         if response.StatusCode == 404 {\n            return NotFoundErr\n         }\n         return nil\n      },\n      ErrorHandler: func(writer http.ResponseWriter, request *http.Request, err error) {\n         // 判断 Error 是否为NotFoundError, 是的话则进行前端服务的转发，重新修改writer\n         if errors.Is(err, NotFoundErr) {\n            httputil.NewSingleHostReverseProxy(frontend).ServeHTTP(writer, request)\n         }\n      }}\n}\n</code></pre><h3>rebuildBackend / restartBackend</h3><p>下一个函数是rebuildBackend。这个函数的作用是重新编译后端。</p><p>那如何编译后端呢？还记得第18课中为编译后端定义了命令行么？所以在“调试命令”中，我们只需要调用“编译命令”就行了。</p><ul>\n<li>编译前端  ./hade build frontend</li>\n<li>编译后端  ./hade build backend</li>\n<li>同时编译前后端 ./hade build all</li>\n<li>自编译 ./hade build self</li>\n</ul><p>所以rebuildBackend 这个函数，我们就是调用一次 <code>./hade build backend</code> 。</p><pre><code class=\"language-go\">// rebuildBackend 重新编译后端\nfunc (p *Proxy) rebuildBackend() error {\n   // 重新编译hade\n   cmdBuild := exec.Command(\"./hade\", \"build\", \"backend\")\n   cmdBuild.Stdout = os.Stdout\n   cmdBuild.Stderr = os.Stderr\n   if err := cmdBuild.Start(); err == nil {\n      err = cmdBuild.Wait()\n      if err != nil {\n         return err\n      }\n   }\n   return nil\n}\n</code></pre><p>编译后端函数实现了，下面就是重启后端进程restartBackend。</p><p>我们当然也会记得在<a href=\"https://time.geekbang.org/column/article/425820\">第12章</a>将启动Web服务变成一个命令  <code>./hade app start</code> 。所以重启后端服务的步骤就是：</p><ul>\n<li>关闭旧进程（kill）</li>\n<li>启动新进程（./hade app start）</li>\n</ul><p>但是这里有个小问题，<strong>之前启动进程的时候，进程端口是写死的。但是，现在需要固定启动的App的进程端口</strong>。所以要对  <code>./hade app start</code> 命令进行一些改造。</p><p>来修改framework/command/app.go，我们增加一个appAddress地址，这个地址可以传递类似   <code>localhost:8888</code> 或者  <code>:8888</code> 这样的启动服务地址，并且在appStartCommand中使用这个appAddress。</p><pre><code class=\"language-go\">// app启动地址\nvar appAddress = \"\"\n\n// initAppCommand 初始化app命令和其子命令\nfunc initAppCommand() *cobra.Command {\n   // 设置启动地址\n   appStartCommand.Flags().StringVar(&amp;appAddress, \"address\", \":8888\", \"设置app启动的地址，默认为:8888\")\n\n   appCommand.AddCommand(appStartCommand)\n   return appCommand\n}\n\n// appStartCommand 启动一个Web服务\nvar appStartCommand = &amp;cobra.Command{\n   Use:   \"start\",\n   Short: \"启动一个Web服务\",\n   RunE: func(c *cobra.Command, args []string) error {\n      ...\n      // 创建一个Server服务\n      server := &amp;http.Server{\n         Handler: core,\n         Addr:    appAddress,\n      }\n      // 这个goroutine是启动服务的goroutine\n      go func() {\n         server.ListenAndServe()\n      }()\n      ...\n   },\n}\n</code></pre><p>这样，后端进程就可以通过命令  <code>./hade app start --address=:8888</code> 这样的方式，来指定端口启动服务了。</p><p>小问题解决之后，回到framework/command/dev.go， 我们实现restartBackend方法。先杀死旧的进程，再通过命令  <code>./hade app start</code> 带上参数 address，启动新的后端服务。启动之后，再将启动的进程ID存储到proxy结构的backendPid字段中：</p><pre><code class=\"language-go\">// restartBackend 启动后端服务\nfunc (p *Proxy) restartBackend() error {\n\n   // 杀死之前的进程\n   if p.backendPid != 0 {\n      syscall.Kill(p.backendPid, syscall.SIGKILL)\n      p.backendPid = 0\n   }\n\n   // 设置随机端口，真实后端的端口\n   port := p.devConfig.Backend.Port\n   hadeAddress := fmt.Sprintf(\":\" + port)\n   // 使用命令行启动后端进程\n   cmd := exec.Command(\"./hade\", \"app\", \"start\", \"--address=\"+hadeAddress)\n   cmd.Stdout = os.NewFile(0, os.DevNull)\n   cmd.Stderr = os.Stderr\n   fmt.Println(\"启动后端服务: \", \"http://127.0.0.1:\"+port)\n   err := cmd.Start()\n   if err != nil {\n      fmt.Println(err)\n   }\n   p.backendPid = cmd.Process.Pid\n   fmt.Println(\"后端服务pid:\", p.backendPid)\n   return nil\n}\n</code></pre><h3>restartFrontend</h3><p>而重启前端服务的函数restartFrontend也是一样的逻辑，先关闭旧的前端进程，然后启动新的前端进程。这里同样也有一个问题，启动前端进程的命令是  <code>npm run dev</code> ，我们怎么固定其端口呢？</p><p>在Vue中，我们可以通过<a href=\"https://stackoverflow.com/questions/47219819/how-to-change-port-number-in-vue-cli-project\">设置环境变量PORT</a>，来规定前端进程的启动端口。也就是让启动命令变为  <code>PORT=8071 npm run dev</code> ，在Golang中启动一个命令，并为命令设置环境变量是这样设置的：</p><pre><code class=\"language-go\">// 运行命令\ncmd := exec.Command(\"npm\", \"run\", \"dev\")\n// 为默认的环境变量增加PORT=xxx的变量\ncmd.Env = os.Environ()\ncmd.Env = append(cmd.Env, fmt.Sprintf(\"%s%s\", \"PORT=\", port))\n</code></pre><p>所以启动前端服务的逻辑就如下，很简单，重点位置你可以看注释。</p><pre><code class=\"language-go\">// 启动前端服务\nfunc (p *Proxy) restartFrontend() error {\n   // 启动前端调试模式\n   // 先杀死旧进程\n   if p.frontendPid != 0 {\n      syscall.Kill(p.frontendPid, syscall.SIGKILL)\n      p.frontendPid = 0\n   }\n   // 否则开启npm run serve\n   port := p.devConfig.Frontend.Port\n   path, err := exec.LookPath(\"npm\")\n   if err != nil {\n      return err\n   }\n   cmd := exec.Command(path, \"run\", \"dev\")\n   cmd.Env = os.Environ()\n   cmd.Env = append(cmd.Env, fmt.Sprintf(\"%s%s\", \"PORT=\", port))\n   cmd.Stdout = os.NewFile(0, os.DevNull)\n   cmd.Stderr = os.Stderr\n   // 因为npm run serve 是控制台挂起模式，所以这里使用go routine启动\n   err = cmd.Start()\n   fmt.Println(\"启动前端服务: \", \"http://127.0.0.1:\"+port)\n   if err != nil {\n      fmt.Println(err)\n   }\n   p.frontendPid = cmd.Process.Pid\n   fmt.Println(\"前端服务pid:\", p.frontendPid)\n   return nil\n}\n</code></pre><h3>startProxy</h3><p>下面我们来实现startProxy方法，它有两个参数，表示在启动Proxy时是否要启动前端、后端服务。</p><p>这个方法的逻辑也并不复杂，步骤有四步，先根据参数判断是否启动后端服务，根据参数判断是否启动前端服务，然后使用newProxyReverseProxy来创建新的ReverseProxy，最后启动Proxy服务。在代码中也做了步骤说明了：</p><pre><code class=\"language-go\">// 启动proxy服务，并且根据参数启动前端服务或者后端服务\nfunc (p *Proxy) startProxy(startFrontend, startBackend bool) error {\n   var backendURL, frontendURL *url.URL\n   var err error\n\n   // 启动后端\n   if startBackend {\n      if err := p.restartBackend(); err != nil {\n         return err\n      }\n   }\n   // 启动前端\n   if startFrontend {\n      if err := p.restartFrontend(); err != nil {\n         return err\n      }\n   }\n\n   if frontendURL, err = url.Parse(fmt.Sprintf(\"%s%s\", \"http://127.0.0.1:\", p.devConfig.Frontend.Port)); err != nil {\n      return err\n   }\n\n   if backendURL, err = url.Parse(fmt.Sprintf(\"%s%s\", \"http://127.0.0.1:\", p.devConfig.Backend.Port)); err != nil {\n      return err\n   }\n\n   // 设置反向代理\n   proxyReverse := p.newProxyReverseProxy(frontendURL, backendURL)\n   proxyServer := &amp;http.Server{\n      Addr:    \"127.0.0.1:\" + p.devConfig.Port,\n      Handler: proxyReverse,\n   }\n\n   fmt.Println(\"代理服务启动:\", \"http://\"+proxyServer.Addr)\n   // 启动proxy服务\n   err = proxyServer.ListenAndServe()\n   if err != nil {\n      fmt.Println(err)\n   }\n   return nil\n}\n</code></pre><h3>monitorBackend</h3><p>最后是一个monitorBackend方法，监控某个文件夹的变动，并且重新编译并且运行后端服务。</p><p>这个方法我们重点说一下，有些逻辑还是比较绕的。</p><p>首先，在前一节课说过了，可以使用 <a href=\"https://github.com/fsnotify/fsnotify\">fsnotify</a> 库对目录进行监控。那么对哪个目录进行监控呢？之前在配置devConfig中，定义了一个Backend.MonitorFolder目录，这个配置默认使用的是AppFolder目录。这个就是我们监控的目标目录。</p><p>其次，每次有变化的时候，都要进行一次编译后端服务、杀死旧进程、重启新进程么？</p><p>在开发过程中我们知道，每次调整一个逻辑的时候，是有可能短时间内重复修改、保存多个文件的，或者保存一个文件多次。而重新编译、重新启动进程的过程，又是有一定耗时的，如果每改一次就重来一次，可以想象这个体验是很差的。</p><p>能怎么优化这种体验呢？我们可以使用一种计时时间机制。</p><p>这个机制的逻辑就是，<strong>每次有文件变动，并不立刻进行实质的操作，而是开启一个计时时间</strong>，如果这个时间内，没有任何后续的文件变动了，那么在计时时间到了之后，我们再进行实质的操作。而如果在计时时间内，有任何更新的文件变动，我们就将计时时间机制重新开始计时。</p><p>这种机制能有一定概率保证，在“更新代码等待一段时间后”进行后端的重启服务。而这里的计时时间我们也变成一个配置，devConfig里面的Backend.RefreshTime，默认时长为1s。</p><p>对应在framework/command/dev.go的monitorBackend代码实现中，我们大致分为这么几步，<strong>先创建watcher，监听目标目录，有变动的时候开启计时时间机制，循环监听</strong>：</p><ul>\n<li>目标目录变更事件，有事件更新计时机制；</li>\n<li>计时机制到点事件，计时到点事件触发，代表有一个或多个目标目录变更已经存在，更新后端服务。</li>\n</ul><p>这里在监听目标目录的时候，我们需要监听AppFolder目录下的所有子目录及孙目录，所以这里需要用到递归 filepath.Walk ，来递归一遍所有子目录及孙目录。如果是目录，就使用watcher.Add 来将目录加入到监控列表中。</p><p>具体的代码逻辑可以看framework/command/dev.go中的monitorBackend：</p><pre><code class=\"language-go\">// monitorBackend 监听应用文件\nfunc (p *Proxy) monitorBackend() error {\n   // 监听\n   watcher, err := fsnotify.NewWatcher()\n   if err != nil {\n      return err\n   }\n   defer watcher.Close()\n\n   // 开启监听目标文件夹\n   appFolder := p.devConfig.Backend.MonitorFolder\n   fmt.Println(\"监控文件夹：\", appFolder)\n   // 监听所有子目录，需要使用filepath.walk\n   filepath.Walk(appFolder, func(path string, info os.FileInfo, err error) error {\n      if info != nil &amp;&amp; !info.IsDir() {\n         return nil\n      }\n      // 如果是隐藏的目录比如 . 或者 .. 则不用进行监控\n      if util.IsHiddenDirectory(path) {\n         return nil\n      }\n      return watcher.Add(path)\n   })\n\n   // 开启计时时间机制\n   refreshTime := p.devConfig.Backend.RefreshTime\n   t := time.NewTimer(time.Duration(refreshTime) * time.Second)\n   // 先停止计时器\n   t.Stop()\n   for {\n      select {\n      case &lt;-t.C:\n         // 计时器时间到了，代表之前有文件更新事件重置过计时器\n         // 即有文件更新\n         fmt.Println(\"...检测到文件更新，重启服务开始...\")\n         if err := p.rebuildBackend(); err != nil {\n            fmt.Println(\"重新编译失败：\", err.Error())\n         } else {\n            if err := p.restartBackend(); err != nil {\n               fmt.Println(\"重新启动失败：\", err.Error())\n            }\n         }\n         fmt.Println(\"...检测到文件更新，重启服务结束...\")\n         // 停止计时器\n         t.Stop()\n      case _, ok := &lt;-watcher.Events:\n         if !ok {\n            continue\n         }\n         // 有文件更新事件，重置计时器\n         t.Reset(time.Duration(refreshTime) * time.Second)\n      case err, ok := &lt;-watcher.Errors:\n         if !ok {\n            continue\n         }\n         // 如果有文件监听错误，则停止计时器\n         fmt.Println(\"监听文件夹错误：\", err.Error())\n         t.Reset(time.Duration(refreshTime) * time.Second)\n      }\n   }\n}\n</code></pre><h2>验证</h2><p>到这里Proxy相关的逻辑和调试对应的命令行工具都开发完成了，下面我们来做一下对应的验证，一共三次验证，单独的前端、后端修改，以及同时对前后端的修改。</p><p>先修改一下config/development/app.yaml，增加对应的调试模式配置：</p><pre><code class=\"language-yaml\">dev: # 调试模式\n  port: 8070 # 调试模式最终监听的端口，默认为8070\n  backend: # 后端调试模式配置\n    refresh_time: 3  # 调试模式后端更新时间，如果文件变更，等待3s才进行一次更新，能让频繁保存变更更为顺畅, 默认1s\n    port: 8072 # 后端监听端口，默认8072\n    monitor_folder: \"\" # 监听文件夹地址，为空或者不填默认为AppFolder\n  frontend: # 前端调试模式配置\n    port: 8071 # 前端监听端口, 默认8071\n</code></pre><p>这里设置refresh_time为3s，代表后续后端变更后3s后会触发重新编译。对我们的代码进行一次编译，不用go build了，可以使用自定义的build命令了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/bc/dc/bccyy36fb507fc398b4ac69d6fab12dc.png?wh=744x53\" alt=\"\"></p><h3>前端验证</h3><p>首先验证前端调试模式。调用命令 <code>./hade dev front</code>，可以看到如下的控制台信息：<br>\n<img src=\"https://static001.geekbang.org/resource/image/69/3f/6932b5eacdd96f46bd7c431388a5663f.png?wh=1837x388\" alt=\"\"></p><p>先是出现几行信息：</p><pre><code class=\"language-go\">启动前端服务:&nbsp; http://127.0.0.1:8071\n前端服务pid: 13750\n代理服务启动: http://127.0.0.1:8070\n</code></pre><p>然后进入到了Vue的调试模式，从上述信息我们知道，代理服务启动在8070端口，使用浏览器打开 <a href=\"http://127.0.0.1:8070\">http://127.0.0.1:8070</a> 看到了熟悉的Vue界面。<br>\n<img src=\"https://static001.geekbang.org/resource/image/51/cd/51bbd33f01b482fe38543e09fcf6a8cd.png?wh=821x675\" alt=\"\"></p><p>然后修改首页的前端组件，业务目录下src/components/HelloWorld.vue，将其展示在首页的msg内容：</p><pre><code class=\"language-javascript\">&lt;script&gt;\nexport default {\n  name: 'HelloWorld',\n  data() {\n    return {\n      msg: 'Welcome to Your Vue.js App '\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>修改为：</p><pre><code class=\"language-javascript\">&lt;script&gt;\nexport default {\n    name: 'HelloWorld',\n    data() {\n        return {\n            msg: 'Welcome to Hade Vue.js App '\n        }\n    }\n}\n&lt;/script&gt;\n</code></pre><p>现在你可以看到，前端自动更新：<br>\n<img src=\"https://static001.geekbang.org/resource/image/54/3b/54b76e64904e2c38b011e0625317cf3b.png?wh=823x700\" alt=\"\"><br>\n前端验证完成。下面验证后端调试模式。</p><h3>后端验证</h3><p>我们已经在业务代码app/http/module/demo/api.go中，定义了/demo/demo的路由，并且简单输出文字\"this is demo\"。</p><pre><code class=\"language-go\">func Register(r *gin.Engine) error {\n   api := NewDemoApi()\n   ...\n   r.GET(\"/demo/demo\", api.Demo)\n   ...\n   return nil\n}\n\nfunc (api *DemoApi) Demo(c *gin.Context) {\n   c.JSON(200, \"this is demo\")\n}\n</code></pre><p>使用命令  <code>./hade dev backend</code> ，有如下输出，可以看到输出中已经把监控文件夹、后端服务端口、代理服务端口完整输出了：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a1/71/a140ce0ef5yya414bb7c51879966a871.png?wh=756x126\" alt=\"\"></p><p>访问代理服务 <a href=\"http://127.0.0.1:8087/demo/demo\">http://127.0.0.1:8087/demo/demo</a>：<br>\n<img src=\"https://static001.geekbang.org/resource/image/9c/35/9cfabbc9617ea7d382ef7a7656bbyy35.png?wh=819x223\" alt=\"\"></p><p>输出了后端接口内容。</p><p>同时在代码中修改下输出内容之后：</p><pre><code class=\"language-go\">func (api *DemoApi) Demo(c *gin.Context) {\n   c.JSON(200, \"this is demo for dev\")\n}\n</code></pre><p>在控制台中我们可以看到，等待了3s后（这里配置文件设置为3s），在控制台看到如下输出：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a9/77/a9f482cf449bdd63ab10b9589552f677.png?wh=766x251\" alt=\"\"></p><p>检测到文件更新，重启服务开启。</p><p>这个时候我们再刷新浏览器的接口，输出已经变化了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/8d/cd/8d2e45d4e396cda0772855466c864bcd.png?wh=826x257\" alt=\"\"><br>\n后端调试模式通过！</p><h3>前后端验证</h3><p>最后同时验证前端和后端，其实和前面单独验证的方法一样，只是启动命令换成了  <code>./hade dev all</code></p><p>这里我们同时打开两个窗口，<a href=\"http://127.0.0.1:8070/demo/demo\">http://127.0.0.1:8070/demo/demo</a>、<a href=\"http://127.0.0.1:8070/#/\">http://127.0.0.1:8070/#/</a>，能同时看到前端和后端信息：<br>\n<img src=\"https://static001.geekbang.org/resource/image/94/8b/948ca235cb9aaafafdfd019ec49c6e8b.png?wh=822x648\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/24/a5/244a3f45c561081d2836da782c9d3ba5.png?wh=824x258\" alt=\"\"></p><p>修改前端msg和修改后端内容后，变更生效：<br>\n<img src=\"https://static001.geekbang.org/resource/image/b8/4b/b8322b3854a955ddab449324afb8574b.png?wh=822x686\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/3e/8a/3eba5c41cdafd870878609274f05658a.png?wh=825x204\" alt=\"\"><br>\n到这里，前后端同时调试模式验证成功！</p><p>今天的主要内容是创建调试模式的三个二级命令。完整的代码示例在GitHub上的 <a href=\"https://github.com/gohade/coredemo/tree/geekbang/20\">geekbang/20</a> 分支，欢迎比对查看。本节课我们只在命令文件中增加了一个framework/command/dev.go文件：<br>\n<img src=\"https://static001.geekbang.org/resource/image/e7/y3/e7yy0d64af957beed7139733ac2fdyy3.png?wh=296x811\" alt=\"\"></p><h2>小结</h2><p>今天我们具体实现了调试模式，其实了解了上节课对调试模式的设计之后，今天的内容主要是细节上的代码实现了，就是工作量。不过其中的实现细节，也是在工作中不断积累下来的，你可以多多体会。</p><p>比如refresh_time这个计时器窗口设计，在最初版本是没有的，在实际工作中，使用这个调试模式，遇到了频繁重建的困扰，才做了这个设计。总之，整个调试模式支持是非常赞的，它能让我们的Web开发效率提高了一个档次，希望你也能感同身受。</p><h2>思考题</h2><p>在回答同学们问题的时候，我发现有不少是其他语言转来Go的，不知道你的经历是怎样的，可以来聊一聊你在使用其他语言时，调试一个程序都是怎么调试的呢？有没有比较好的调试模式？</p><p>欢迎在留言区分享你的思考。感谢你的收听，我们下节课见～</p>","comments":[{"had_liked":false,"id":319545,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1635846314,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14520748202","product_id":100090601,"comment_content":"实时重载(live reloading): 代码变动时重新编译和启动app。这个应该是文中的模式；<br><br>热重载(hot reloading): 代码变动时加载变动后的代码，不重启app，保留当前app的状态；<br><br>调试(debug): 通常牵涉到打断点，单步跟踪等。<br><br>如果只是实现live reload的话也可以单独用Air或nodemon等，前后端在不同的子目录里分别修改和reload也没啥问题。","like_count":3,"discussions":[{"author":{"id":1231623,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cb/07/482b7155.jpg","nickname":"牛玉富","note":"","ucode":"DD962676F8FAF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545915,"discussion_content":"一看就是有前端底子啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642082342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325875,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1639208282,"is_pvip":false,"replies":[{"id":"118646","content":"你可以观察下，ide的行为在修改的时候，会先创建一个.xxx.swp文件，然后修改文件，然后保存的时候把.xxx.swap文件删除，所以出现3次","user_name":"作者回复","user_name_real":"编辑","uid":"1069186","ctime":1639585593,"ip_address":"","comment_id":325875,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10229142874","product_id":100090601,"comment_content":"如果refreshTime设置的时间太短 那么改一次会rebuild3次 ","like_count":3,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539075,"discussion_content":"你可以观察下，ide的行为在修改的时候，会先创建一个.xxx.swp文件，然后修改文件，然后保存的时候把.xxx.swap文件删除，所以出现3次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639585593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345504,"user_name":"tsunamiShi","can_delete":false,"product_type":"c1","uid":1519060,"ip_address":"","ucode":"AE2BBC8F84EAB6","user_header":"https://static001.geekbang.org/account/avatar/00/17/2d/d4/5d1d15f3.jpg","comment_is_top":false,"comment_ctime":1652339362,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652339362","product_id":100090601,"comment_content":"控制台也监听文件夹了，修改文件夹也重启服务了，但是刷新浏览器并没有改变，","like_count":0},{"had_liked":false,"id":345503,"user_name":"tsunamiShi","can_delete":false,"product_type":"c1","uid":1519060,"ip_address":"","ucode":"AE2BBC8F84EAB6","user_header":"https://static001.geekbang.org/account/avatar/00/17/2d/d4/5d1d15f3.jpg","comment_is_top":false,"comment_ctime":1652339309,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652339309","product_id":100090601,"comment_content":"后端修改api文件，刷新浏览器并没有改变，请问是什么原因啊？","like_count":0},{"had_liked":false,"id":326620,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1639587054,"is_pvip":true,"replies":[{"id":"118670","content":"是的，节省不少开发时间","user_name":"作者回复","user_name_real":"编辑","uid":"1069186","ctime":1639617065,"ip_address":"","comment_id":326620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639587054","product_id":100090601,"comment_content":"有了这个调试起来是很方便 ，只要把自己编译出来了，然后启动，后续调试就会自己编译自己然后自行启动","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539119,"discussion_content":"是的，节省不少开发时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639617066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}