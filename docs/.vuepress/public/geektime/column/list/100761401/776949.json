{"id":776949,"title":"09｜函数对象 ：函数是依赖什么成为第一类公民的？","content":"<p>你好，我是海纳。</p><p>上一节课我们介绍了函数的静态代码和动态记录之间的区别，以及通过递归函数的执行过程，深入介绍了栈帧的组织结构，这一节课我们就通过编写代码实现相应的功能。</p><p>在 Python 中，函数（function）和方法（method）的意义是不同的。类中定义的成员函数被称为方法，不在类中定义的函数才是我们平常所说的狭义的函数。方法是建立在类机制上的，所以函数比方法要简单一些，这节课我们就从函数开始实现。</p><h2>实现函数功能</h2><p>我们先从一个最简单的例子开始，定义一个函数，让它打印一个字符串。</p><pre><code class=\"language-python\">def foo():\n&nbsp; &nbsp; print(\"hello\")\n\t\nfoo()\n</code></pre><p>将这段代码存为一个文件，名为 func.py，然后使用 <code>python -m compileall func.py</code> 命令，把这个文件编译成 func.pyc 文件。再使用 show_file.py 工具，查看 func.pyc 文件的构造。</p><pre><code class=\"language-plain\">&nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (&lt;code object fo&gt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 ('foo')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 MAKE_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 STORE_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (foo)\n\n&nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (foo)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 RETURN_VALUE\n</code></pre><!-- [[[read_end]]] --><p>这里展示的是定义 foo 函数和调用 foo 函数的字节码。这一段里有两个字节码是我们之前没有实现的，就是 <strong>MAKE_FUNCTION 和 CALL_FUNCTION</strong>。前者用于定义函数，后者用于调用函数。这一节课的关键就是实现这两个字节码。</p><p>在<a href=\"https://time.geekbang.org/column/article/772694\">第 4 节课</a>使用 print 函数的时候，实际上我们就已经遇到过 CALL_FUNCTION 指令了，但是因为当时没有函数的功能，所以我们就使用了一些特殊的手段绕过去了，现在就应该正常地实现这条指令了。</p><p>除了上述两个字节码，你还要注意第一条指令和第二条指令，第一个是LOAD_CONST，从常量表里加载第一项，而这一项是一个 code object。在这里code object 的定义出现了嵌套，也就是说 foo 所对应的 code object 出现在了主模块的常量表里。</p><p>第二个 LOAD_CONST从常量表里加载了一个字符串，代表函数的名字。这是与Python 2.7有区别的地方。在Python 2中，MAKE_FUNCTION 指令并不需要函数名字。</p><p>接下来，我们重点查看主模块的 consts 表的内容。</p><pre><code class=\"language-plain\">&nbsp; &nbsp;consts\n&nbsp; &nbsp; &nbsp; code\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;argcount 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nlocals 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stacksize 2\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flags 0043\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;code 740064018301010064005300\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_GLOBAL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 ('hello')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 RETURN_VALUE\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;consts\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; None\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'hello'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;names ('print',)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;varnames ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;freevars ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cellvars ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;filename 'test_func.py'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name 'foo'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;firstlineno 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lnotab 0001\n&nbsp; &nbsp; &nbsp; 'foo'\n&nbsp; &nbsp; &nbsp; None\n</code></pre><p>这就很清楚了，consts 表包含了三项。其中的第一项，就是一个 code object，它的 name 就是 foo。前边我们在讲解 code object 的结构的时候也提到过，code object 是可以嵌套定义的，在二进制文件中用字母 <code>'c'</code> 代表 code object。在实现 BinaryFileParser 的时候，我们已经提前支持了这一特性。这里就不用再修改了。</p><h2>实现函数栈帧</h2><p>上一节课我们讲过，每一次函数调用都会有一个活动记录与之对应。这个活动记录也被叫做栈帧（frame）。</p><p>在当前的虚拟机执行器里，还没有栈帧的概念，因此我们要实现一种数据结构，来记录函数的调用过程，这个数据结构就是 FrameObject。每一次调用一个函数，就有一个这次调用的活动记录，也就是说每次函数调用，都会创建一个 FrameObject。每次函数执行结束，相应的 FrameObject 也会被销毁。</p><p>在 Interpreter 里，有很多变量是为函数执行时的活动记录服务的。例如，pc 记录了程序当前执行到的位置；locals 表记录了变量的值等等。本质上这些变量是与函数的执行绑定的，所以它们应该被封装到 FrameObject 里，而不是 Interpreter 中。</p><p>所以，接下来我们就应该重构 Interpreter，把所有这些与执行状态相关的量移到 FrameObject 中。</p><p>首先，我们来定义 FrameObject。</p><pre><code class=\"language-c++\">class FrameObject {\npublic:\n&nbsp; &nbsp; FrameObject(CodeObject* codes);\n&nbsp; &nbsp; ~FrameObject();\n\n&nbsp; &nbsp; ArrayList&lt;HiObject*&gt;* _stack;\n&nbsp; &nbsp; ArrayList&lt;Block*&gt;*&nbsp; &nbsp; _loop_stack;\n\n&nbsp; &nbsp; ArrayList&lt;HiObject*&gt;* _consts;\n&nbsp; &nbsp; ArrayList&lt;HiObject*&gt;* _names;\n\n&nbsp; &nbsp; Map&lt;HiObject*, HiObject*&gt;* _locals;\n\n&nbsp; &nbsp; CodeObject*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_codes;\n&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_pc;\n\npublic:\n&nbsp; &nbsp; void set_pc(int x)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { _pc = x; }\n&nbsp; &nbsp; int&nbsp; get_pc()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _pc; }\n\n&nbsp; &nbsp; ArrayList&lt;HiObject*&gt;* stack()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _stack; }\n&nbsp; &nbsp; ArrayList&lt;Block*&gt;* loop_stack()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _loop_stack; }\n&nbsp; &nbsp; ArrayList&lt;HiObject*&gt;* consts()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { return _consts; }\n&nbsp; &nbsp; ArrayList&lt;HiObject*&gt;* names()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _names; }\n&nbsp; &nbsp; Map&lt;HiObject*, HiObject*&gt;* locals()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _locals; }\n\n&nbsp; &nbsp; bool has_more_codes();\n&nbsp; &nbsp; unsigned char get_op_code();\n&nbsp; &nbsp; int&nbsp; get_op_arg();\n};\n</code></pre><p>上述代码已经把 Interpreter 中的相关变量都转移到 FrameObject 中了。注意第 3 行的构造方法，以前虚拟机要执行一段字节码的时候，是通过直接调用 Interpreter 的 run 方法来实现的，其中 CodeObject 是 run 方法的参数。现在则要先创建一个 FrameObject，代码执行时，就只会影响 FrameObject 中的 pc、locals 等变量。</p><p>这段代码的逻辑很简单，FrameObject 只是对一些状态变量的封装，包括代码第 27 至 29 行所声明的三个方法，也不过是对一些简单逻辑的封装。具体内容你可以看我给出的代码。</p><pre><code class=\"language-c++\">// this constructor is used for module only.\nFrameObject::FrameObject(CodeObject* codes) {\n&nbsp; &nbsp; _consts&nbsp; = codes-&gt;_consts;\n&nbsp; &nbsp; _names&nbsp; &nbsp;= codes-&gt;_names;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; _locals&nbsp; = new Map&lt;HiObject*, HiObject*&gt;();\n\n&nbsp; &nbsp; _stack&nbsp; = new ArrayList&lt;HiObject*&gt;();\n&nbsp; &nbsp; _loop_stack&nbsp; = new ArrayList&lt;Block*&gt;();\n\n&nbsp; &nbsp; _codes = codes;\n&nbsp; &nbsp; _pc&nbsp; &nbsp; = 0;\n}\n\nint FrameObject::get_op_arg() {\n&nbsp; &nbsp; int byte1 = _codes-&gt;_bytecodes-&gt;value()[_pc++] &amp; 0xff;\n&nbsp; &nbsp; int byte2 = _codes-&gt;_bytecodes-&gt;value()[_pc++] &amp; 0xff;\n&nbsp; &nbsp; return byte2 &lt;&lt; 8 | byte1;\n}\n\nunsigned char FrameObject::get_op_code() {\n&nbsp; &nbsp; return _codes-&gt;_bytecodes-&gt;value()[_pc++];\n}\n\nbool FrameObject::has_more_codes() {\n&nbsp; &nbsp; return _pc &lt; _codes-&gt;_bytecodes-&gt;length();\n}\n</code></pre><p>和它相应的，Interpreter的run方法也发生了很多变化。</p><pre><code class=\"language-c++\">// [runtime/interpreter.cpp]\n// stack has been moved into FrameObject.\n#define PUSH(x)&nbsp; &nbsp; &nbsp; &nbsp;_frame-&gt;stack()-&gt;add((x))\n#define POP()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_frame-&gt;stack()-&gt;pop()\n#define STACK_LEVEL() _frame-&gt;stack()-&gt;size()\n...\nvoid Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n&nbsp; &nbsp; &nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; bool has_argument = (op_code &amp; 0xFF) &gt;= ByteCode::HAVE_ARGUMENT;\n\n&nbsp; &nbsp; &nbsp; &nbsp; int op_arg = -1;\n&nbsp; &nbsp; &nbsp; &nbsp; if (has_argument) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_arg = _frame-&gt;get_op_arg();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp;\t \t...\n&nbsp;\t}\n}\n</code></pre><p>除了上述代码所展示的修改以外，run 方法里还有很多处修改，这里我就不一一列出了，你可以通过工程提交记录自己比较代码还有哪些变化。</p><p>有了 FrameObject 这个基础结构以后，我们终于可以把注意力转向  MAKE_FUNCTION &nbsp;和 CALL_FUNCTION 这两个字节码了。</p><h2>创建 FunctionObject</h2><p>有了代表栈帧的 FrameObject 和代表代码的 CodeObject，分别用于描述动态的活动记录和静态的代码信息，对于普通的编程语言就已经够了。但是在 Python 中，函数是第一类公民，所以虚拟机中还需要一个表示函数的对象。我们先来看一个例子。</p><pre><code class=\"language-python\">def make_func(a):\n&nbsp; &nbsp; def add(b):\n&nbsp; &nbsp; &nbsp; &nbsp; return a + b\n\n&nbsp; &nbsp; return add\n\nadd3 = make_func(3)\nadd5 = make_func(5)\n\nprint(add3(2))\nprint(add5(2))\n</code></pre><p>在这个例子里，add 函数所对应的代码只有一份，也就是说，虚拟机在执行的过程中只需要一个 CodeObject 就可以了。但是，add3 和 add5 这两个函数却明显不相同，虽然它们的代码是相同的，但是因为绑定的参数不同，所以就成为了两个不同的函数。</p><p>从这个例子中，我们可以看出，CodeObject 所代表的静态代码和 FunctionObject 所代表的运行时构建出来的函数是有区别的。当我们把一个函数像变量一样用于函数返回值、参数等场景中，实际上使用的是 FunctionObject，而不是 CodeObject。</p><p>不同于 C 语言中的函数定义，FunctionObject 是一个真正的虚拟机对象。它可以被变量引用，也可以被添加到列表中。总之，所有可以对普通对象进行的操作，都可以施加到 FunctionObject 上。一个 CodeObject 可以对应多个 FunctionObject。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/89/83d893e0ba9a7271b2eb4609c5315189.png?wh=1464x820\" alt=\"图片\"></p><p>如上图所示，经过这些分析，我们可以这样定义 FunctionObject：</p><pre><code class=\"language-c++\">class FunctionKlass : public Klass {\nprivate:\n&nbsp; &nbsp; FunctionKlass();\n&nbsp; &nbsp; static FunctionKlass* instance;\n\npublic:\n&nbsp; &nbsp; static FunctionKlass* get_instance();\n\n&nbsp; &nbsp; virtual void print(HiObject* obj);\n};\n\nclass FunctionObject : public HiObject {\nfriend class FunctionKlass;\nfriend class FrameObject;\n\nprivate:\n&nbsp; &nbsp; CodeObject* _func_code;\n&nbsp; &nbsp; HiString*&nbsp; &nbsp;_func_name;\n\n&nbsp; &nbsp; unsigned int _flags;\n\npublic:\n&nbsp; &nbsp; FunctionObject(HiObject* code_object);\n&nbsp; &nbsp; FunctionObject(Klass* klass) {\n&nbsp; &nbsp; &nbsp; &nbsp; _func_code = NULL;\n&nbsp; &nbsp; &nbsp; &nbsp; _func_name = NULL;\n&nbsp; &nbsp; &nbsp; &nbsp; _flags&nbsp; &nbsp; &nbsp;= 0;\n\n&nbsp; &nbsp; &nbsp; &nbsp; set_klass(klass);\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; HiString*&nbsp; func_name()&nbsp; &nbsp;{ return _func_name; }\n&nbsp; &nbsp; int&nbsp; flags()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _flags; }\n};\n</code></pre><p>FunctionObject 与普通的 Object 相比，并没有什么特别之处，所以它也要遵守 Klass-Oop 的二元结构。上述程序开始的地方定义的 FunctionKlass 用来指示对象的类型。</p><p>接下来定义的 FunctionObject 的属性也很简单，一个是指向自己所对应的 CodeObject 指针，还有一个代表了方法名称的字符串，最后一个属性 _flags，用于指示函数的类型，我们现在先不用，留到以后扩展。你可以看一下FunctionKlass 和 FunctionObject 中定义的方法实现。</p><pre><code class=\"language-c++\">FunctionKlass* FunctionKlass::instance = NULL;\n\nFunctionKlass* FunctionKlass::get_instance() {\n&nbsp; &nbsp; if (instance == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; instance = new FunctionKlass();\n\n&nbsp; &nbsp; return instance;\n}\n\nFunctionKlass::FunctionKlass() {\n}\n\nvoid FunctionKlass::print(HiObject* obj) {\n&nbsp; &nbsp; printf(\"&lt;function : \");\n&nbsp; &nbsp; FunctionObject* fo = static_cast&lt;FunctionObject*&gt;(obj);\n\n&nbsp; &nbsp; assert(fo &amp;&amp; fo-&gt;klass() == (Klass*) this);\n&nbsp; &nbsp; fo-&gt;func_name()-&gt;print();\n&nbsp; &nbsp; printf(\"&gt;\");\n}\n\nFunctionObject::FunctionObject(HiObject* code_object) {\n&nbsp; &nbsp; CodeObject* co = (CodeObject*) code_object;\n\n&nbsp; &nbsp; _func_code = co;\n&nbsp; &nbsp; _func_name = co-&gt;_co_name;\n&nbsp; &nbsp; _flags&nbsp; &nbsp; &nbsp;= co-&gt;_flag;\n\n&nbsp; &nbsp; set_klass(FunctionKlass::get_instance());\n}\n</code></pre><p>FunctionKlass 和其他的 Klass 一样，也采用了单例的实现方式。FunctionObject 的 print 方法，主要用于打印方法名。在 FrameObject 的构造函数里，把该对象的 klass 设置为 FunctionKlass。这就是上述代码的全部逻辑。</p><p>有了 FunctionObject，我们再来看 MAKE_FUNCTION 的具体实现，这个字节码的任务是通过 CodeObject，创建一个 FunctionObject。与这个功能相关的类和构造函数都已经实现好了，所以 MAKE_FUNCTION 的实现就很简单了。</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; //...\n&nbsp; &nbsp; &nbsp; &nbsp; FunctionObject* fo;\n&nbsp; &nbsp; &nbsp; &nbsp; //...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t//...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::MAKE_FUNCTION:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo = new FunctionObject(v);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(fo);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; //...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>这里需要注意的是，MAKE_FUNCTION 指令本身是带有参数的，它是一个整数，代表了这个函数有多少个默认参数。我们现在还没有关心函数调用传参的问题，所以就先把 MAKE_FUNCTION 的参数忽略掉。</p><h2>执行函数</h2><p>有了函数对象，接下来我们就可以研究函数是如何被执行的了。</p><p>当函数被调用时，最关键的是正确地维护与这个函数相对应的 FrameObject。这节课开头我们已经介绍了，FrameObject 中存储了程序运行时所需要的所有信息，例如程序计数器、局部变量表等等。</p><p>当虚拟机执行一个函数的时候，需要为这个函数创建对应的 FrameObject；当一个函数的执行结束，也就是执行到 return 指令时，虚拟机就应该销毁对应的 FrameObject，然后回到调用者的栈帧中去。</p><p>为了维护这种函数调用时的栈帧切换，我们可以在 FrameObject 里增加一个链表项，将所有的 FrameObject 串起来，每次新增的 FrameObject 只能增加到链表的头部。同理，销毁时也只能从链表的头部进行删除。这样的话，FrameObject 的实现必须有所调整。</p><pre><code class=\"language-c++\">// runtime/frameObject.hpp\nclass FrameObject {\npublic:\n&nbsp; &nbsp; FrameObject(CodeObject* codes);\n&nbsp; &nbsp; FrameObject(FunctionObject* func);\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; FrameObject*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _sender;\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; void set_sender(FrameObject* x) { _sender = x; }\n&nbsp; &nbsp; FrameObject* sender()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _sender;}\n&nbsp; &nbsp; ...\n};\n\n// runtime/frameObject.cpp\nFrameObject::FrameObject (FunctionObject* func) {\n&nbsp; &nbsp; _codes&nbsp; &nbsp;= func-&gt;_func_code;\n&nbsp; &nbsp; _consts&nbsp; = _codes-&gt;_consts;\n&nbsp; &nbsp; _names&nbsp; &nbsp;= _codes-&gt;_names;\n\n&nbsp; &nbsp; _locals&nbsp; = new Map&lt;HiObject*, HiObject*&gt;();\n\n&nbsp; &nbsp; _stack&nbsp; &nbsp;= new ArrayList&lt;HiObject*&gt;();\n&nbsp; &nbsp; _loop_stack&nbsp; = new ArrayList&lt;Block*&gt;();\n\n&nbsp; &nbsp; _pc&nbsp; &nbsp; &nbsp; = 0;\n&nbsp; &nbsp; _sender&nbsp; = NULL;\n}\n</code></pre><p>FrameObject 中的构造函数发生了变化，新的实现中，它的参数变成了 FunctionObject。目前看来，这个构造函数与第一个版本，即以CodeObject为参数的那个构造函数，并没有太大的差别，但当后面我们的函数中有参数和返回值的时候，这两个构造函数就会产生差异了。</p><p>FrameObject 里还新增了 sender 这个域，这个域里会记录调用者的栈帧，当函数执行结束的时候，就会通过这个域返回到调用者的栈帧里。</p><p>前面我们介绍过，帧是用链表串起来的，创建的时候挂到链表头上，销毁的时候从链表头上的第一帧开始销毁。满足<strong>后进先出</strong>的特性，所以这是一个典型的栈结构，这再次表明了函数调用的活动记录被叫做栈帧的原因。</p><p>最后，我们可以实现 CALL_FUNCTION 这个字节码了。我们在 Interpreter 里增加一个 build_frame 方法，这个方法用于创建新的 FrameObject，被调用的方法的内部状态全部由新的 FrameObject 维护。这些内部状态包括程序计数器 pc、局部变量表 locals 等。</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; FunctionObject* fo;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::CALL_FUNCTION:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; build_frame(POP());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nvoid Interpreter::build_frame(HiObject* callable) {\n&nbsp; &nbsp; FrameObject* frame = new FrameObject((FunctionObject*) callable);\n&nbsp; &nbsp; frame-&gt;set_sender(_frame);\n&nbsp; &nbsp; _frame = frame;\n}\n</code></pre><p>这段代码里定义的 build_frame，将 FrameObject 切换到新函数后就立即退出，返回到 run 方法里继续执行。与调用 build_frame 方法之前不同的是，_frame 变量已经发生了变化。_frame里的程序计数器已经指向要调用的目标方法里了。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/7b/10c4f4fyyd82dc55747a841e0945477b.png?wh=2138x928\" alt=\"\"></p><p>如上图所示，作为调用者，老的程序计数器还在它所对应的 FrameObject 里保存着，并且指向了CALL_FUNCTION 的下一条指令。而 _frame 变量现在指向了 foo 所对应的栈帧，当被调用的函数结束时，虚拟机就会把 _frame 变量重新指回调用者的 FrameObject，从而回到调用者的栈帧里继续执行。</p><p>所以，我们可以这样实现 RETURN_VALUE 字节码。</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; eval_frame();\n&nbsp; &nbsp; destroy_frame();\n}\n\nvoid Interpreter::eval_frame() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; FunctionObject* fo;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::RETURN_VALUE:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ret_value = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_frame-&gt;is_first_frame())\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leave_frame();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nvoid Interpreter::leave_frame() {\n&nbsp; &nbsp; destroy_frame();\n&nbsp; &nbsp; PUSH(_ret_value);\n}\n\nvoid Interpreter::destroy_frame() {\n&nbsp; &nbsp; FrameObject* temp = _frame;\n&nbsp; &nbsp; _frame = _frame-&gt;sender();\n\n&nbsp; &nbsp; delete temp;\n}\n\nclass FrameObject {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; bool is_first_frame()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return _sender == NULL; }\n};\n</code></pre><p>我们来分析一下RETURN_VALUE 字节码的具体实现，首先它将被调用函数的返回值赋给了 ret_value 变量（第 17 行），然后调用 leave_frame 方法离开当前函数栈帧。<br>\nleave_frame 方法做了三件事情。</p><ol>\n<li>使用 destroy_frame 方法将被调用者的 FrameObject 销毁（第36行）。</li>\n<li>将 _frame 变量切换为自己的调用者的栈帧（第34行）。</li>\n<li>将返回值 push 到调用者的栈帧中去（第29行）。</li>\n</ol><p>注意，这是我们的项目中第一次使用 delete 来销毁和释放一个对象，其他对象都没有通过这种方法释放。这是因为后面虚拟机的内部对象都会使用垃圾回收器进行自动管理，但是我们并不打算将 FrameObject 也纳入自动内存管理中。FrameObject 的生命周期是确定的，所以虚拟机就在能够释放的时候尽早释放，这样做对自动内存管理的性能是有好处的。</p><p>自动内存管理的相关知识，我们会在后面的章节中继续介绍。</p><p>如果某个 FrameObject 的 sender 为 NULL，就代表它是第一个栈帧，是程序开始的地方，或者说是“主程序”，因为它没有调用者。这种情况下，只需要直接结束 run 的逻辑即可，也就是直接通过 return 结束（第 19 行）。</p><p>同时，我们做一点代码的重构，将 run 方法的逻辑改得更清晰一点。就是把原来在 run 方法中的那些解释执行的逻辑搬到 eval_frame 方法中。而 run 方法则简化为创建 frame，对 frame 进行解释执行以及销毁 frame 三个步骤。这样可以使代码的可读性更高一些。</p><p>我们执行以下测试用例就会发现，函数的返回值机制已经完美地实现了。</p><pre><code class=\"language-python\">def hello():\n    print(\"hello\")\n    return \"world\"\n    \nprint(hello())\n</code></pre><p>增加了函数以后，变量的定义和作用域受到了很大的影响。下一节课，我们就将重新审视变量的实现方式。</p><h2>总结</h2><p>上一节课介绍了函数的静态信息和动态信息之后，我们这一节课就实现了相关的功能。这涉及到了2个关键的结构，CodeObject和FrameObject。其中，<strong>CodeObject 用于描述静态信息，FrameObject 用于描述动态信息。</strong></p><p>由于 Python 语言中函数是第一类公民，这就意味着函数可以像变量一样作为返回值和参数进行传递，所以即使是同一份代码，也可以创建出多个不同的函数对象。这就要求虚拟机中要提供可以描述函数的对象，也就是 <strong>FunctionObject</strong>。</p><p>在实现了上述三个关键的数据结构以后，就可以实现 MAKE_FUNCTION 和 CALL_FUNCTION 两条字节码了。MAKE_FUNCTION 的作用是使用 CodeObject 创建 FunctionObject，CALL_FUNCTION 则是创建新的函数栈帧，并转入新的帧里执行。</p><p>当函数执行结束以后，遇到 RETURN_VALUE 指令。这个时候，虚拟机就退出当前栈帧，返回到调用者的栈帧中，并且把返回值带回到调用者栈帧中，这样就完成了一次函数调用。</p><p>定义函数会创建不同的变量的作用域，这对变量的使用产生了比较大的影响，所以下节课我们就将重新梳理和实现变量的相关功能。</p><h2>思考题</h2><p>请你多设计几个测试用例，验证把函数作为变量进行赋值是否可以正确执行。欢迎你把你验证后的结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"08｜函数和栈帧：深入区分函数的静态描述和动态记录","id":774417},"right":{"article_title":"10｜变量的作用域：哪些复杂规则是因函数而产生的？","id":776954}},"comments":[{"had_liked":false,"id":390909,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"上海","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1716713070,"is_pvip":false,"replies":[{"id":142177,"content":"理解到这里，其实你对编程语言的理解就深了很多。在这个dsl上，你可以进一步构建类型系统啊，monad啊等等更加抽象的东西。","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1716830341,"ip_address":"广东","comment_id":390909,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"续一个上次的评论，尝试总结下：字节码可以视为一个dsl文件，然后用c++写了一个程序&#47;引擎去执行这个文件 ==&gt; 这个c++程序有一些基本设计 Klass-Oop（包括内建class 与自定义class）来支持一个基本流程Interpreter.run，每一个字节码都对应一段代码的执行，也就是涉及的内建class与自定义class 新增、删除、方法的调用。","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645823,"discussion_content":"理解到这里，其实你对编程语言的理解就深了很多。在这个dsl上，你可以进一步构建类型系统啊，monad啊等等更加抽象的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716830341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390908,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"上海","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1716710869,"is_pvip":true,"replies":[{"id":142176,"content":"哦。我检查一下文稿。可能文稿里的代码和代码库没匹配上。","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1716830256,"ip_address":"广东","comment_id":390908,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"示例代码似乎混进了旧版虚拟机的代码...根据代码库里的代码才跑起来. 测试程序生成的字节码里似乎有后面才会讲到的内容, 可能需要先囤几节课再一起看","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645822,"discussion_content":"哦。我检查一下文稿。可能文稿里的代码和代码库没匹配上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716830256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395205,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1729742636,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0}]}