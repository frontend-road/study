{"id":632698,"title":"08｜防微杜渐：5类遗留系统典型的代码坏味道","content":"<p>你好，我是黄俊彬。今天我们正式进入到解耦重构篇。在这个章节中，我们将根据“分析设计篇”中分析出的问题清单重构改造Sharing项目，最后将设计落地到具体的代码上。</p><p>在我过去碰到的很多遗留系统中，代码都存在一些相似的问题，其中最典型的有五种：过度嵌套、重复代码、无效代码及资源、缺少抽象和随意依赖。</p><p>千里之堤，溃于蚁穴，遗留系统不是一天造成的，而是在日常开发中不断累积出来的，而这五种典型的代码坏味道其实就是<strong>推动系统演化成遗留系统的重要元凶</strong>。</p><p>所以，在重构Sharing项目的代码之前，我们先通过一些示例看看这些代码坏味道带来的影响以及如何解决它们。当然了，最重要的是，我们怎么提前避免这些问题。</p><h2>过度嵌套</h2><p>我们先来看过度嵌套。<strong>过度嵌套指的是代码的圈复杂度过高，存在大量的嵌套逻辑，不方便开发人员维护和扩展功能。</strong>首先请你想一下，这个圈复杂度多少算高？多少算低呢？</p><p>提出圈复杂度概念的麦凯布给我们的建议是：<strong>若一模块的循环复杂度超过10，需再分割为更小的模块。</strong>按照这个阈值来看，如果圈复杂度超过10，我们就认为圈复杂度过高；如果在5-10之间认为是中等，可以接受；如果低于5，就认为圈复杂度比较低了。</p><p>下面我们来看一段圈复杂度超过10的代码，你可以细品一下，阅读这段代码时是什么感受。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">public void case0(){\n    boolean A = true,B=true,C=false,D=true,E=true,F=false,G=true,H=false,I=true,J=false;\n    if(A){\n        System.out.println(\"A\");\n        if(B){\n            System.out.println(\"B\");\n            if(C){\n                System.out.println(\"C\");\n            }else if(D){\n                System.out.println(\"D\");\n                if(E){\n                    System.out.println(\"E\");\n                }\n            }\n        }else if(F){\n            System.out.println(\"F\");\n            if(G){\n                System.out.println(\"G\");\n            }\n        }\n    }else if(H){\n        System.out.println(\"H\");\n        if(I){\n            System.out.println(\"I\");\n            if(J){\n                System.out.println(\"J\");\n            }\n        }\n    }\n}\n</code></pre><p>你是不是觉得这段代码的逻辑层层嵌套，可读性很差？其实这就是过度嵌套带来的一个主要问题：<strong>代码阅读性差，不方便维护。</strong>此外，<strong>这种代码修改起来也非常容易出错，稍不注意就可能破坏之前的逻辑。</strong></p><p>那么如何简化过度嵌套的代码呢？<strong>最好的方式就是将逻辑拉平，我们不用在分支中来回切换上下文。</strong></p><p>将逻辑拉平的方式有多种，下面我们通过一些示例来看看。</p><pre><code class=\"language-plain\">boolean isA,isB,isC;\ndouble getAmount() {\n    double result;\n    if (isA) result = adAmount();\n    else {\n        if (isB) result = bAmount();\n        else {\n            if (isC) result = cAmount();\n            else result = otherAmount();\n        };\n    }\n    return result;\n}\n</code></pre><p>对于上面这个例子，我们可以通过“<strong>提前Return</strong>”将这个示例的嵌套逻辑拉平（如下所示），你可以对比一下上下两段代码的阅读感受。</p><pre><code class=\"language-plain\">double getAmountRefactor() {\n    double result;\n    if (isA) return adAmount();\n    if (isB) return bAmount();\n    if (isC) return cAmount();\n    return otherAmount();\n}\n</code></pre><p>还有一种常用的简化嵌套逻辑的方式就是 <strong>“使用多态+路由表”</strong>，比如后面这个示例。</p><pre><code class=\"language-plain\">public void login(String type) {\n    if (\"wechat\".equals(type)) {\n        weChatLogin();\n    } else if (\"qq\".equals(type)) {\n        qqLogin();\n    } else if (\"phone\".equals(type)) {\n        phoneLogin();\n    } \n}\n</code></pre><p>对于这样的情况，我们就可以提取接口，将各个实现区分开，然后通过路由配置的方式来获取具体的实现（如下所示）。这种方法不仅简化了嵌套，也非常便于后续的代码扩展。</p><p>后面是优化之后的代码，你不妨做个对比。</p><pre><code class=\"language-plain\">HashMap&lt;String,Ilogin&gt; maps = new HashMap&lt;String, Ilogin&gt;(){\n    {\n        put(\"wechat\", new WeChatLogin());\n        put(\"qq\", new QQChatLogin());\n        put(\"phone\",new PhoneChatLogin());\n    }\n};\n\npublic void login(String type) {\n   maps.get(type).login();\n}\n</code></pre><p>事前预防，远胜于事后解决，我们在平时的项目开发中就应该避免过度的代码嵌套。因此，我建议<strong>在代码合入之前先进行静态代码扫描，在扫描工具上设置合适的圈复杂度阈值（小于10），一旦发现超过阈值，就提示错误，不让代码合并入库。</strong></p><p>对于扫描工具的选择，我推荐使用Sonar，也就是将Sonar作为质量门禁接入到流水线中，检查代码的圈复杂度。如果你的项目有一些约束使用不了，也可以用SonarLint插件在IDE中扫描检查。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/03/1e578952294f9093c491eba9928a1403.jpg?wh=2488x1769\" alt=\"\"></p><h2>重复代码</h2><p>重复代码指的是<strong>在整个项目中有两个地方以上存在相同的代码行，相同部分少则3-5行代码，多则可能除了2个类小部分逻辑不一样外，其他都是一样的代码</strong>。通常来说，重复代码大都是由复制粘贴导致的，那怎么解决呢？下面我们来看两个例子。</p><p>首先是对于部分的代码行重复。</p><pre><code class=\"language-plain\">public class DuplicateCodeCopyCase {\n    String name;\n    String password;\n    public void login(){\n        if(name == null){\n            return;\n        }\n        if(password == null){\n            return;\n        }\n        phoneLogin();\n    }\n    public void Register(){\n        if(name == null){\n            return;\n        }\n        if(password == null){\n            return;\n        }\n        phoneRegister();\n    }\n    private void phoneLogin() {\n    }\n    private void phoneRegister() {\n    }\n}\n</code></pre><p>我们可以<strong>将共同逻辑提取成公共的方法，来减少重复代码</strong>。在上面的例子中，name和password的判断就可以提取成公共的方法，具体如下所示。</p><pre><code class=\"language-plain\">private boolean isInValid() {\n    if (name == null) {\n        return true;\n    }\n    if (password == null) {\n        return true;\n    }\n    return false;\n}\n</code></pre><p>而对于大部分代码重复、只有小部分不同的情况，我们再看一个例子。</p><pre><code class=\"language-plain\">public class DuplicateCodeCopyCase {\n    String name;\n    String password;\n    public void login(){\n        if (isInValid()) return;\n        phoneLogin();\n    }\n    private boolean isInValid() {\n        if (name == null) {\n            return true;\n        }\n        if (password == null) {\n            return true;\n        }\n        return false;\n    }\n    public void Register(){\n        if (isInValid()) return;\n        phoneRegister();\n    }\n    private void phoneLogin() {\n    }\n    private void phoneRegister() {\n    }\n}\n</code></pre><p>这时候，我们可以把<strong>差异部分进行组合或者将公共部分提取为超类，来减少重复代码</strong>。在上面的例子中，我们可以将不同方式的登录注册都提取出来。</p><pre><code class=\"language-plain\">public class DuplicateCodeCopyCase {\n    //将差异的实现通过接口注入进来\n    IAccountOperator iAccountOperator;\n   \n    String name;\n    String password;\n    public void login(){\n        if (isInValid()) return;\n        iAccountOperator.login();\n    }\n    \n    public void Register(){\n        if (isInValid()) return;\n        iAccountOperator.register();\n    }\n    //... ...\n   }\n</code></pre><p>因为重复代码在遇到变化时，往往要修改很多不同的类，让维护代码的工作量呈指数上升，所以我们应该提前避免在项目中产生这种问题。</p><p>同样地，建议<strong>在代码合入之前先进行静态代码扫描，在扫描工具上设置合适代码重复率阈值（一般建议低于5%），如果发现超过阈值，就提示错误不让代码合并入库。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/75/74/757965fce2df0dec6a3508b3b0511074.jpg?wh=2546x653\" alt=\"\"></p><p>在日常的开发中，你也可以通过IDE提前在开发阶段扫描代码中的重复代码，及时做优化。比如使用Intellij的Locate Duplicates功能，选择：Code→Analyze Code→Located Duplicates，就可以扫描了，扫描结果是后面这样。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/89/9335f1e2b5119ffd8b379e8569de9389.jpg?wh=3090x826\" alt=\"\"></p><p>需要说明的是，因为目前最新版的Android Studio还不支持Locate Duplicates功能，所以我们要借助Intellij来使用此功能。</p><h2>无效代码及资源</h2><p>接下来我们看看遗留系统中第三种代码坏味道：无效代码及资源。</p><p><strong>无效代码及资源指的是在整个项目中没有被任何代码所调用到的类、方法、变量或者资源问题。</strong></p><p>一般来说，编译工具在打包时会自动将这些无效的代码移除，不会导致应用的包体积增大。但是无效代码及资源在你编写代码的时候依旧会存在，这会增加代码的理解成本，降低代码的可维护性。</p><p>对此可以借助工具自动化识别和去除。我们先来看无效代码的处理，步骤很简单，就是在Android Studio中选择Analyze，进而选择run inspection by name命令，然后输入unused&nbsp;declaration来扫描代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/bf/1def3f6943fcd9c1376fdd58f7339ebf.jpg?wh=2488x1769\" alt=\"\"></p><p>根据扫描结果，如果扫描的结果显示代码为无效代码，就通过Safe&nbsp;delete进行删除。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/90/e60470646b27a5b8c4ef43a8b6736f90.jpg?wh=2993x1365\" alt=\"\"></p><p>对于应用资源，可以在Android Studio中选择对应的模块，再选择重构菜单，然后选择Remove&nbsp;Unused&nbsp;Resources进行扫描。</p><p><img src=\"https://static001.geekbang.org/resource/image/97/9b/9769c856612c08c87d9d47df346eca9b.jpg?wh=2555x1560\" alt=\"\"></p><p>根据扫描结果，如果扫描的资源是无效资源，可以通过Do&nbsp;Refactor进行删除。</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/7f/7c2180bf0f09840c14a78af9994b507f.jpg?wh=3043x1388\" alt=\"\"></p><p>特别要注意的是，在项目中还有一种常见的情况是“僵尸代码”，这类代码的特点是：代码有引用，但从系统的角度来看，这些代码的逻辑永远不会被触发。通常，我们无法单纯通过工具来识别僵尸代码，需要结合业务具体分析。</p><p>相比无效代码，僵尸代码增加的代码理解成本更高，对代码可维护性影响更大，所以要及时定期清理。</p><p>总体来说，对于无效代码及资源，我们可以把静态代码扫描工具（Sonar、Lint等）加入到流水线中及时检查。而对于僵尸代码，则需要加强人工的代码监视来应对。</p><h2>缺少抽象</h2><p>除了逻辑过度嵌套、重复和无效外，还有一种情况是<strong>随着代码复杂度的提高，由于缺少合适的分层设计，所有代码都掺杂在了一个类中</strong>。我们将这种代码问题称为“<strong>缺少抽象</strong>”。</p><p>在项目中比较常见的情况是将所有的逻辑都写在一个界面中，这些逻辑包含UI操作、业务数据处理、网络操作、数据缓存等等。我们在<a href=\"https://time.geekbang.org/column/article/629322\">第3节课</a>中讲的代码可测性的例子，就是这种情况。</p><pre><code class=\"language-plain\">public class LoginActivity extends AppCompatActivity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_login);\n        final EditText usernameEditText = findViewById(R.id.username);\n        final EditText passwordEditText = findViewById(R.id.password);\n        final Button loginButton = findViewById(R.id.login);\n        loginButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                boolean isLoginSuccess = false;\n                String username = usernameEditText.getText().toString();\n                String password = passwordEditText.getText().toString();\n                boolean isUserNameValid;\n                if (username == null) {\n                    isUserNameValid = false;\n                } else {\n                    Pattern pattern = Pattern.compile(\"\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*\");\n                    Matcher matcher = pattern.matcher(username);\n                    if (username.contains(\"@\")) {\n                        isUserNameValid = matcher.matches();\n                    } else {\n                        isUserNameValid = !username.trim().isEmpty();\n                    }\n                }\n                if (!isUserNameValid || !(password != null &amp;&amp; password.trim().length() &gt; 5)) {\n                    isLoginSuccess = false;\n                } else {\n                    //通过服务器判断账户及密码的有效性\n                    if (username.equals(\"123@163.com\") &amp;&amp; password.equals(\"123456\")) {\n                        //登录成功保存本地的信息\n                        SharedPreferencesUtils.put(LoginActivity.this, username, password);\n                        isLoginSuccess = true;\n                    }\n                }\n                if (isLoginSuccess) {\n                    //登录成功跳转主界面\n                    startActivity(new Intent(LoginActivity.this, MainActivity.class));\n                } else {\n                    //对登录失败进行提示\n                    Toast.makeText(LoginActivity.this, \"login failed\", Toast.LENGTH_LONG).show();\n                }\n            }\n        });\n    }\n}\n</code></pre><p><strong>这种缺少抽象设计的代码可扩展性差，所有的需求变化都要在一个类中集中修改，容易出错</strong>。这种问题的解决思路也很清晰，就是分而治之，将不同维度的代码独立开来，使其职责更加单一，这样有需求变化时就能独立演进了。在第13节课中，我会具体介绍如何优化缺少抽象设计的过大类。</p><p>如果你想提前避免这类缺少抽象设计的代码，可以通过Sonar在代码入库前进行过大类及过大方法的检查。具体方式与前面的圈复杂度检查类似，我就不细讲了。</p><h2>随意依赖</h2><p>我们再来看最后一种代码坏味道：随意依赖。<strong>它是指项目中不同分层的代码直接依赖具体的实现，导致彼此之间产生耦合。</strong>比较常见的是不同业务模块之间直接依赖，或者一些底层的组件依赖了上层的业务模块实现。</p><p>“低耦合高内聚”是我们经常提的一个设计思想，因为代码耦合度低可以减少修改代码引起的风险，同时也是做组件化的重要条件之一。如果代码直接耦合，在拆分成独立的模块后，编译也会直接不通过。</p><p>解决这类“随意依赖”问题，要分两种情况。第一种是底层组件依赖上层业务模块的实现，例如一些日志的工具类会直接依赖一些用户模块的个人数据。</p><pre><code class=\"language-plain\">public class LogCodeCase {\n    public void log(){\n        //... ...\n        Log.d(\"log\",User.id);\n    }\n}\n</code></pre><p>对此，比较好的解决方式是，通过提取参数或者构造函数注入来解除具体的依赖。</p><pre><code class=\"language-plain\">public class LogCodeCase {\n    String id;\n    public LogCodeCase(String id) {\n        this.id = id;\n    }\n    \n    public void log() {\n        //... ...\n        Log.d(\"log\", id);\n    }\n}\n</code></pre><p>另一种情况是业务模块之间的直接依赖，例如消息模块直接依赖了文件模块的文件发布。</p><pre><code class=\"language-plain\">public void sendMessage(String text){\n    //依赖具体的实现\n    String url=new FileManager().upload();\n    send(url,text);\n}\n</code></pre><p>这时候，我们可以通过提取接口，依赖稳定的抽象接口来进行解耦。解耦后再通过注入框架，将接口的实现注入到接口的调用类中。对于如何解耦重构组件间的依赖，我会在第11节课详细讲解。</p><pre><code class=\"language-plain\">IUpload iUpload;\npublic void sendMessage(String text) {\n    String url = iUpload.upload();\n    send(url, text);\n}\n</code></pre><p>为了避免随意依赖的代码，我们同样可以通过守护工具ArchUnit在代码合入前进行架构约束检查。这块内容我们在<a href=\"https://time.geekbang.org/column/article/629359\">第7节课</a>中已经讲过，如果你不太清楚，可以通过文稿的超链接再回顾一下。</p><h2>总结</h2><p>不积跬步，无以至千里，我们只有在日常开发中重视基本的代码规范和代码质量，才能更有效地避免遗留系统产生。</p><p>今天，我给你分享了遗留系统中常见的五种典型的代码坏味道，包括过度嵌套、重复代码、无效代码及资源、缺少抽象和随意依赖，你可以参考我梳理的表格。<br>\n<img src=\"https://static001.geekbang.org/resource/image/26/b6/26a28d83f0378893dbffaaf859b3e4b6.jpg?wh=3600x2300\" alt=\"\"></p><p>下节课，我将给你分享遗留系统中常用的6种安全重构手法，教你如何通过IDE自动化完成代码的重构，减少人工修改代码。敬请期待。</p><h2>思考题</h2><p>感谢你学完了今天的内容，今天的思考题是这样的：你的项目的重复代码率有多少？请你通过今天学习的方法对你的项目做一个诊断。</p><p>欢迎你在留言区与我交流讨论，也欢迎你把它分享给你的同事或朋友，我们一起来高效、高质量交付软件！</p>","comments":[{"had_liked":false,"id":369613,"user_name":"刘军","can_delete":false,"product_type":"c1","uid":1373201,"ip_address":"北京","ucode":"B2223C3713739C","user_header":"https://static001.geekbang.org/account/avatar/00/14/f4/11/727ebf8d.jpg","comment_is_top":false,"comment_ctime":1677728340,"is_pvip":true,"replies":[{"id":134691,"content":"hi,刘军。期待一起完成专栏的学习🤝。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1677744505,"ip_address":"广东","comment_id":369613,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"老师讲得好，终于明白“防微杜渐”的含义了。","like_count":0,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607288,"discussion_content":"hi,刘军。期待一起完成专栏的学习🤝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677744505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369353,"user_name":"李鑫鑫","can_delete":false,"product_type":"c1","uid":1169021,"ip_address":"北京","ucode":"BEC451BFBEFD25","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/7d/4b09b0bf.jpg","comment_is_top":false,"comment_ctime":1677459727,"is_pvip":false,"replies":[{"id":134588,"content":"Hi，鑫鑫。后续的课程会有实操演示，跟着课程练习就能掌握🤝。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1677462661,"ip_address":"广东","comment_id":369353,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"idea 工具使用不太熟悉","like_count":0,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606850,"discussion_content":"Hi，鑫鑫。后续的课程会有实操演示，跟着课程练习就能掌握🤝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677462661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369351,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1677458410,"is_pvip":false,"replies":[{"id":134655,"content":"Hi，peter。\nQ1:使用Intellij的付费版，选择：Code→Analyze Code→Located Duplicates，就可以扫描了。安装Android的插件页可以打开安卓项目。\nQ2:对的，定期组织进行CodeReview。\nQ3:整个应用有静默更新，可以理解为热更新。（但是一般在手机厂商内部才有这个机制）。整个应用的升级可以理解为只能走正常的更新流程。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1677632625,"ip_address":"广东","comment_id":369351,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"请教老师几个问题：\nQ1：怎么借用Idea来使用duplicate code检查？\nIdea能打开安卓项目吗？没有用idea打开过安卓项目。\nQ2：对于“僵尸代码”老师有什么好的实践方法？\n在实际工作中，老师所经历的公司中，对于“僵尸代码”有什么方法？定期组织多人对代码进行review吗？\nQ3：整个应用有“热更新”吗？\n上次请教老师热更新的问题，老师的回答是“我的理解是热更新是应用内插件的更新，不是整个应用的更新”， 从这句话看，似乎对于整个应用来说，没有“热更新”，应用从版本1升级到版本2，没有“热更新”的方法，只能走正常的更新流程（即重新下载、安装），是这样吗？","like_count":0,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607111,"discussion_content":"Hi，peter。\nQ1:使用Intellij的付费版，选择：Code→Analyze Code→Located Duplicates，就可以扫描了。安装Android的插件页可以打开安卓项目。\nQ2:对的，定期组织进行CodeReview。\nQ3:整个应用有静默更新，可以理解为热更新。（但是一般在手机厂商内部才有这个机制）。整个应用的升级可以理解为只能走正常的更新流程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677632625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}