{"id":145464,"title":"26 | 使用阻塞I/O和线程模型：换一种轻量的方式","content":"<p>你好，我是盛延敏，这里是网络编程实战第26讲，欢迎回来。</p><p>在前面一讲中，我们使用了进程模型来处理用户连接请求，进程切换上下文的代价是比较高的，幸运的是，有一种轻量级的模型可以处理多用户连接请求，这就是线程模型。这一讲里，我们就来了解一下线程模型。</p><p>线程（thread）是运行在进程中的一个“逻辑流”，现代操作系统都允许在单进程中运行多个线程。线程由操作系统内核管理。每个线程都有自己的上下文（context），包括一个可以唯一标识线程的ID（thread ID，或者叫tid）、栈、程序计数器、寄存器等。在同一个进程中，所有的线程共享该进程的整个虚拟地址空间，包括代码、数据、堆、共享库等。</p><p>在前面的程序中，我们没有显式使用线程，但这不代表线程没有发挥作用。实际上，每个进程一开始都会产生一个线程，一般被称为主线程，主线程可以再产生子线程，这样的主线程-子线程对可以叫做一个对等线程。</p><p>你可能会问，既然可以使用多进程来处理并发，为什么还要使用多线程模型呢？</p><p>简单来说，在同一个进程下，线程上下文切换的开销要比进程小得多。怎么理解线程上下文呢？我们的代码被CPU执行的时候，是需要一些数据支撑的，比如程序计数器告诉CPU代码执行到哪里了，寄存器里存了当前计算的一些中间值，内存里放置了一些当前用到的变量等，从一个计算场景，切换到另外一个计算场景，程序计数器、寄存器等这些值重新载入新场景的值，就是线程的上下文切换。</p><!-- [[[read_end]]] --><h2>POSIX线程模型</h2><p>POSIX线程是现代UNIX系统提供的处理线程的标准接口。POSIX定义的线程函数大约有60多个，这些函数可以帮助我们创建线程、回收线程。接下来我们先看一个简单的例子程序。</p><pre><code>int another_shared = 0;\n\nvoid thread_run(void *arg) {\n    int *calculator = (int *) arg;\n    printf(&quot;hello, world, tid == %d \\n&quot;, pthread_self());\n    for (int i = 0; i &lt; 1000; i++) {\n        *calculator += 1;\n        another_shared += 1;\n    }\n}\n\nint main(int c, char **v) {\n    int calculator;\n\n    pthread_t tid1;\n    pthread_t tid2;\n\n    pthread_create(&amp;tid1, NULL, thread_run, &amp;calculator);\n    pthread_create(&amp;tid2, NULL, thread_run, &amp;calculator);\n\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n\n    printf(&quot;calculator is %d \\n&quot;, calculator);\n    printf(&quot;another_shared is %d \\n&quot;, another_shared);\n}\n</code></pre><p>thread_helloworld程序中，主线程依次创建了两个子线程，然后等待这两个子线程处理完毕之后终止。每个子线程都在对两个共享变量进行计算，最后在主线程中打印出最后的计算结果。</p><p>程序的第18和19行分别调用了pthread_create创建了两个线程，每个线程的入口都是thread_run函数，这里我们使用了calculator这个全局变量，并且通过传地址指针的方式，将这个值传给了thread_run函数。当调用pthread_create结束，子线程会立即执行，主线程在此后调用了pthread_join函数等待子线程结束。</p><p>运行这个程序，很幸运，计算的结果是正确的。</p><pre><code>$./thread-helloworld\nhello, world, tid == 125607936 \nhello, world, tid == 126144512 \ncalculator is 2000 \nanother_shared is 2000 \n</code></pre><h2>主要线程函数</h2><h3>创建线程</h3><p>正如前面看到，通过调用pthread_create函数来创建一个线程。这个函数的原型如下：</p><pre><code>int pthread_create(pthread_t *tid, const pthread_attr_t *attr,\n　　　　　　　　　　　void *(*func)(void *), void *arg);\n\n返回：若成功则为0，若出错则为正的Exxx值\n</code></pre><p>每个线程都有一个线程ID（tid）唯一来标识，其数据类型为pthread_t，一般是unsigned int。pthread_create函数的第一个输出参数tid就是代表了线程ID，如果创建线程成功，tid就返回正确的线程ID。</p><p>每个线程都会有很多属性，比如优先级、是否应该成为一个守护进程等，这些值可以通过pthread_attr_t来描述，一般我们不会特殊设置，可以直接指定这个参数为NULL。</p><p>第三个参数为新线程的入口函数，该函数可以接收一个参数arg，类型为指针，如果我们想给线程入口函数传多个值，那么需要把这些值包装成一个结构体，再把这个结构体的地址作为pthread_create的第四个参数，在线程入口函数内，再将该地址转为该结构体的指针对象。</p><p>在新线程的入口函数内，可以执行pthread_self函数返回线程tid。</p><pre><code>pthread_t pthread_self(void)\n</code></pre><h3>终止线程</h3><p>终止一个线程最直接的方法是在父线程内调用以下函数：</p><pre><code>void pthread_exit(void *status)\n</code></pre><p>当调用这个函数之后，父线程会等待其他所有的子线程终止，之后父线程自己终止。</p><p>当然，如果一个子线程入口函数直接退出了，那么子线程也就自然终止了。所以，绝大多数的子线程执行体都是一个无限循环。</p><p>也可以通过调用pthread_cancel来主动终止一个子线程，和pthread_exit不同的是，它可以指定某个子线程终止。</p><pre><code>int pthread_cancel(pthread_t tid)\n</code></pre><h3>回收已终止线程的资源</h3><p>我们可以通过调用pthread_join回收已终止线程的资源：</p><pre><code>int pthread_join(pthread_t tid, void ** thread_return)\n</code></pre><p>当调用pthread_join时，主线程会阻塞，直到对应tid的子线程自然终止。和pthread_cancel不同的是，它不会强迫子线程终止。</p><h3>分离线程</h3><p>一个线程的重要属性是可结合的，或者是分离的。一个可结合的线程是能够被其他线程杀死和回收资源的；而一个分离的线程不能被其他线程杀死或回收资源。一般来说，默认的属性是可结合的。</p><p>我们可以通过调用pthread_detach函数可以分离一个线程：</p><pre><code>int pthread_detach(pthread_t tid)\n</code></pre><p>在高并发的例子里，每个连接都由一个线程单独处理，在这种情况下，服务器程序并不需要对每个子线程进行终止，这样的话，每个子线程可以在入口函数开始的地方，把自己设置为分离的，这样就能在它终止后自动回收相关的线程资源了，就不需要调用pthread_join函数了。</p><h2>每个连接一个线程处理</h2><p>接下来，我们改造一下服务器端程序。我们的目标是这样：每次有新的连接到达后，创建一个新线程，而不是用新进程来处理它。</p><pre><code>#include &quot;lib/common.h&quot;\n\nextern void loop_echo(int);\n\nvoid thread_run(void *arg) {\n    pthread_detach(pthread_self());\n    int fd = (int) arg;\n    loop_echo(fd);\n}\n\nint main(int c, char **v) {\n    int listener_fd = tcp_server_listen(SERV_PORT);\n    pthread_t tid;\n    \n    while (1) {\n        struct sockaddr_storage ss;\n        socklen_t slen = sizeof(ss);\n        int fd = accept(listener_fd, (struct sockaddr *) &amp;ss, &amp;slen);\n        if (fd &lt; 0) {\n            error(1, errno, &quot;accept failed&quot;);\n        } else {\n            pthread_create(&amp;tid, NULL, &amp;thread_run, (void *) fd);\n        }\n    }\n\n    return 0;\n}\n</code></pre><p>这个程序的第18行阻塞调用在accept上，一旦有新连接建立，阻塞调用返回，调用pthread_create创建一个子线程来处理这个连接。</p><p>描述连接最主要的是连接描述字，这里通过强制把描述字转换为void *指针的方式，完成了传值。如果你对这部分有点不理解，建议看一下C语言相关的指针部分内容。我们这里可以简单总结一下，虽然传的是一个指针，但是这个指针里存放的并不是一个地址，而是连接描述符的数值。</p><p>新线程入口函数thread_run里，第6行使用了pthread_detach方法，将子线程转变为分离的，也就意味着子线程独自负责线程资源回收。第7行，强制将指针转变为描述符数据，和前面将描述字转换为void *指针对应，第8行调用loop_echo方法处理这个连接的数据读写。</p><p>loop_echo的程序如下，在接收客户端的数据之后，再编码回送出去。</p><pre><code>char rot13_char(char c) {\n    if ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))\n        return c + 13;\n    else if ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))\n        return c - 13;\n    else\n        return c;\n}\n\nvoid loop_echo(int fd) {\n    char outbuf[MAX_LINE + 1];\n    size_t outbuf_used = 0;\n    ssize_t result;\n    while (1) {\n        char ch;\n        result = recv(fd, &amp;ch, 1, 0);\n\n        //断开连接或者出错\n        if (result == 0) {\n            break;\n        } else if (result == -1) {\n            error(1, errno, &quot;read error&quot;);\n            break;\n        }\n\n        if (outbuf_used &lt; sizeof(outbuf)) {\n            outbuf[outbuf_used++] = rot13_char(ch);\n        }\n\n        if (ch == '\\n') {\n            send(fd, outbuf, outbuf_used, 0);\n            outbuf_used = 0;\n            continue;\n        }\n    }\n}\n</code></pre><p>运行这个程序之后，开启多个telnet客户端，可以看到这个服务器程序可以处理多个并发连接并回送数据。单独一个连接退出也不会影响其他连接的数据收发。</p><pre><code>$telnet 127.0.0.1 43211\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\naaa\nnnn\n^]\ntelnet&gt; quit\nConnection closed.\n</code></pre><h2>构建线程池处理多个连接</h2><p>上面的服务器端程序虽然可以正常工作，不过它有一个缺点，那就是如果并发连接过多，就会引起线程的频繁创建和销毁。虽然线程切换的上下文开销不大，但是线程创建和销毁的开销却是不小的。</p><p>能不能对这个程序进行一些优化呢？</p><p>我们可以使用预创建线程池的方式来进行优化。在服务器端启动时，可以先按照固定大小预创建出多个线程，当有新连接建立时，往连接字队列里放置这个新连接描述字，线程池里的线程负责从连接字队列里取出连接描述字进行处理。</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/72/d976c7b993862f0dbef75354d2f49672.png?wh=1430*462\" alt=\"\"><br>\n这个程序的关键是连接字队列的设计，因为这里既有往这个队列里放置描述符的操作，也有从这个队列里取出描述符的操作。</p><p>对此，需要引入两个重要的概念，一个是锁mutex，一个是条件变量condition。锁很好理解，加锁的意思就是其他线程不能进入；条件变量则是在多个线程需要交互的情况下，用来线程间同步的原语。</p><pre><code>//定义一个队列\ntypedef struct {\n    int number;  //队列里的描述字最大个数\n    int *fd;     //这是一个数组指针\n    int front;   //当前队列的头位置\n    int rear;    //当前队列的尾位置\n    pthread_mutex_t mutex;  //锁\n    pthread_cond_t cond;    //条件变量\n} block_queue;\n\n//初始化队列\nvoid block_queue_init(block_queue *blockQueue, int number) {\n    blockQueue-&gt;number = number;\n    blockQueue-&gt;fd = calloc(number, sizeof(int));\n    blockQueue-&gt;front = blockQueue-&gt;rear = 0;\n    pthread_mutex_init(&amp;blockQueue-&gt;mutex, NULL);\n    pthread_cond_init(&amp;blockQueue-&gt;cond, NULL);\n}\n\n//往队列里放置一个描述字fd\nvoid block_queue_push(block_queue *blockQueue, int fd) {\n    //一定要先加锁，因为有多个线程需要读写队列\n    pthread_mutex_lock(&amp;blockQueue-&gt;mutex);\n    //将描述字放到队列尾的位置\n    blockQueue-&gt;fd[blockQueue-&gt;rear] = fd;\n    //如果已经到最后，重置尾的位置\n    if (++blockQueue-&gt;rear == blockQueue-&gt;number) {\n        blockQueue-&gt;rear = 0;\n    }\n    printf(&quot;push fd %d&quot;, fd);\n    //通知其他等待读的线程，有新的连接字等待处理\n    pthread_cond_signal(&amp;blockQueue-&gt;cond);\n    //解锁\n    pthread_mutex_unlock(&amp;blockQueue-&gt;mutex);\n}\n\n//从队列里读出描述字进行处理\nint block_queue_pop(block_queue *blockQueue) {\n    //加锁\n    pthread_mutex_lock(&amp;blockQueue-&gt;mutex);\n    //判断队列里没有新的连接字可以处理，就一直条件等待，直到有新的连接字入队列\n    while (blockQueue-&gt;front == blockQueue-&gt;rear)\n        pthread_cond_wait(&amp;blockQueue-&gt;cond, &amp;blockQueue-&gt;mutex);\n    //取出队列头的连接字\n    int fd = blockQueue-&gt;fd[blockQueue-&gt;front];\n    //如果已经到最后，重置头的位置\n    if (++blockQueue-&gt;front == blockQueue-&gt;number) {\n        blockQueue-&gt;front = 0;\n    }\n    printf(&quot;pop fd %d&quot;, fd);\n    //解锁\n    pthread_mutex_unlock(&amp;blockQueue-&gt;mutex);\n    //返回连接字\n    return fd;\n}  \n</code></pre><p>这里有block_queue相关的定义和实现，并在关键的地方加了一些注释，有几个地方需要特别注意：</p><p>第一是记得对操作进行加锁和解锁，这里是通过pthread_mutex_lock和pthread_mutex_unlock来完成的。</p><p>第二是当工作线程没有描述字可用时，需要等待，第43行通过调用pthread_cond_wait，所有的工作线程等待有新的描述字可达。第32行，主线程通知工作线程有新的描述符需要服务。</p><p>服务器端程序如下：</p><pre><code>void thread_run(void *arg) {\n    pthread_t tid = pthread_self();\n    pthread_detach(tid);\n\n    block_queue *blockQueue = (block_queue *) arg;\n    while (1) {\n        int fd = block_queue_pop(blockQueue);\n        printf(&quot;get fd in thread, fd==%d, tid == %d&quot;, fd, tid);\n        loop_echo(fd);\n    }\n}\n\nint main(int c, char **v) {\n    int listener_fd = tcp_server_listen(SERV_PORT);\n\n    block_queue blockQueue;\n    block_queue_init(&amp;blockQueue, BLOCK_QUEUE_SIZE);\n\n    thread_array = calloc(THREAD_NUMBER, sizeof(Thread));\n    int i;\n    for (i = 0; i &lt; THREAD_NUMBER; i++) {\n        pthread_create(&amp;(thread_array[i].thread_tid), NULL, &amp;thread_run, (void *) &amp;blockQueue);\n    }\n\n    while (1) {\n        struct sockaddr_storage ss;\n        socklen_t slen = sizeof(ss);\n        int fd = accept(listener_fd, (struct sockaddr *) &amp;ss, &amp;slen);\n        if (fd &lt; 0) {\n            error(1, errno, &quot;accept failed&quot;);\n        } else {\n            block_queue_push(&amp;blockQueue, fd);\n        }\n    }\n\n    return 0;\n}\n</code></pre><p>有了描述字队列，主程序变得非常简洁。第19-23行预创建了多个线程，组成了一个线程池。28-32行在新连接建立后，将连接描述字加入到队列中。</p><p>7-9行是工作线程的主循环，从描述字队列中取出描述字，对这个连接进行服务处理。</p><p>同样的，运行这个程序之后，开启多个telnet客户端，可以看到这个服务器程序可以正常处理多个并发连接并回显。</p><pre><code>$telnet 127.0.0.1 43211\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\naaa\nnnn\n^]\ntelnet&gt; quit\nConnection closed.\n</code></pre><p>和前面的程序相比，线程创建和销毁的开销大大降低，但因为线程池大小固定，又因为使用了阻塞套接字，肯定会出现有连接得不到及时服务的场景。这个问题的解决还是要回到我在开篇词里提到的方案上来，多路I/O复用加上线程来处理，仅仅使用阻塞I/O模型和线程是没有办法达到极致的高并发处理能力。</p><h2>总结</h2><p>这一讲，我们使用了线程来构建服务器端程序。一种是每次动态创建线程，另一种是使用线程池提高效率。和进程相比，线程的语义更轻量，使用的场景也更多。线程是高性能网络服务器必须掌握的核心知识，希望你能够通过本讲的学习，牢牢掌握它。</p><h2>思考题</h2><p>和往常一样，给你留两道思考题。</p><p>第一道，连接字队列的实现里，有一个重要情况没有考虑，就是队列里没有可用的位置了，想想看，如何对这种情况进行优化？</p><p>第二道，我在讲到第一个hello-world计数器应用时，说“结果是幸运”这是为什么呢？怎么理解呢？</p><p>欢迎你在评论区写下你的思考，我会和你一起思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":178140,"user_name":"丷王传奇丷","can_delete":false,"product_type":"c1","uid":1239842,"ip_address":"","ucode":"CAF539501F884C","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/22/46b054b0.jpg","comment_is_top":false,"comment_ctime":1581596718,"is_pvip":false,"replies":[{"id":"71019","content":"多线程程序设计的常见坑。解释到位，赞。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583050992,"ip_address":"","comment_id":178140,"utype":1}],"discussion_count":4,"race_medal":0,"score":"78891008046","product_id":100032701,"comment_content":"第二题：可能会得到比正确的值小的值<br>i++大致分为三个步骤：<br>       1、从内存读出i的值到寄存器<br>       2、操作寄存器加1<br>       3、将寄存器值写到i内存<br>多个线程去操作同一个全局变量的时候，可能某个线程在第二步的时候切换到另一个线程，这样就导致少加了。比如线程A 在i=1 的时候在第二步，这个时候寄存器加1值为2，在这个时候切换到线程B ，由于线程A还没有把2写到i里面，使用B读出来还是1，自增写到i里面，i为2，在切换到线程A，线程A将寄存器里面的2写到i，这样就少加了一次。","like_count":18,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483680,"discussion_content":"多线程程序设计的常见坑。解释到位，赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583050992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2450040,"avatar":"","nickname":"王蓬勃","note":"","ucode":"DDF4CCE9728DCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532300,"discussion_content":"也有可能值变大吧，我试了，自增可了1亿次，结果多线程计算的比实际的结果要大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637569321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":1,"child_discussions":[{"author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2450040,"avatar":"","nickname":"王蓬勃","note":"","ucode":"DDF4CCE9728DCF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554645,"discussion_content":"只可能变小，不可能变大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646532336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532300,"ip_address":""},"score":554645,"extra":""}]},{"author":{"id":1803259,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","nickname":"linker","note":"","ucode":"6C5799F2FC2C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216308,"discussion_content":"使用未初始化的变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585415099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187838,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1584257544,"is_pvip":false,"replies":[{"id":"73542","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1584864753,"ip_address":"","comment_id":187838,"utype":1}],"discussion_count":4,"race_medal":0,"score":"66008766984","product_id":100032701,"comment_content":"第一道，其实这里使用的生产者-消费者模型，可以使用扩容策略解决fd存放的问题。<br>第二题，在并发场景下很容易造成计算结果的不准确。因为这里面是两个线程各执行1000次。实际上很大结果是少于2000的结果。解决方法可以加上锁或volitate关键字（解决可见行问题）。","like_count":15,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487262,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584864753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014061,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/2d/dbb5570f.jpg","nickname":"huadanian","note":"","ucode":"A986E1DB777428","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532647,"discussion_content":"请问加volitate关键字，可以解决互斥访问吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637660710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":2,"child_discussions":[{"author":{"id":2831233,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/33/81/3693f4d9.jpg","nickname":"坚定的抢手","note":"","ucode":"E5A5EC6196C518","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1014061,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/2d/dbb5570f.jpg","nickname":"huadanian","note":"","ucode":"A986E1DB777428","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543271,"discussion_content":"java才可以把。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641040570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532647,"ip_address":""},"score":543271,"extra":""},{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1014061,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/2d/dbb5570f.jpg","nickname":"huadanian","note":"","ucode":"A986E1DB777428","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554699,"discussion_content":"不能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646557233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532647,"ip_address":""},"score":554699,"extra":""}]}]},{"had_liked":false,"id":138753,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1570440188,"is_pvip":false,"replies":[{"id":"54312","content":"不错的想法。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570972002,"ip_address":"","comment_id":138753,"utype":1}],"discussion_count":4,"race_medal":0,"score":"61699982332","product_id":100032701,"comment_content":"关于队列满的情况，额外加一个cond，表示队列未满条件就可以了。<br><br>typedef struct {<br>    int number;<br>    int *fd;<br>    int front;<br>    int rear;<br>    &#47;&#47; 队列中当前元素数目<br>    int count;<br>    pthread_mutex_t mutex;<br>    pthread_cond_t not_empty;<br>    &#47;&#47; 队列未满条件<br>    pthread_cond_t not_full;<br>} block_queue;<br><br>void block_queue_init(block_queue *blockQueue, int number) {<br>    blockQueue-&gt;number = number;<br>    blockQueue-&gt;fd = calloc(number, sizeof(int));<br>    blockQueue-&gt;count = blockQueue-&gt;front = blockQueue-&gt;rear = 0;<br>    pthread_mutex_init(&amp;blockQueue-&gt;mutex, NULL);<br>    pthread_cond_init(&amp;blockQueue-&gt;not_empty, NULL);<br>    pthread_cond_init(&amp;blockQueue-&gt;not_full, NULL);<br>}<br><br>void block_queue_push(block_queue *blockQueue, int fd) {<br>    pthread_mutex_lock(&amp;blockQueue-&gt;mutex);<br>    while (blockQueue-&gt;count == blockQueue-&gt;number){   &#47;&#47;队列满<br>        pthread_cond_wait(&amp;blockQueue-&gt;not_full, &amp;blockQueue-&gt;mutex);<br>    }<br><br>    blockQueue-&gt;fd[blockQueue-&gt;rear] = fd;<br>    if (++blockQueue-&gt;rear == blockQueue-&gt;number) { <br>        blockQueue-&gt;rear = 0;<br>    }<br>    blockQueue-&gt;count++;<br>    printf(&quot;push fd %d&quot;, fd);<br>    pthread_cond_signal(&amp;blockQueue-&gt;not_empty);<br>    pthread_mutex_unlock(&amp;blockQueue-&gt;mutex);<br>}<br><br>int block_queue_pop(block_queue *blockQueue) {<br>    pthread_mutex_lock(&amp;blockQueue-&gt;mutex);<br>    while (blockQueue-&gt;front == blockQueue-&gt;rear)  &#47;&#47; 空队列<br>        pthread_cond_wait(&amp;blockQueue-&gt;not_empty, &amp;blockQueue-&gt;mutex);<br>    int fd = blockQueue-&gt;fd[blockQueue-&gt;front];<br>    if (++blockQueue-&gt;front == blockQueue-&gt;number) {<br>        blockQueue-&gt;front = 0;<br>    }<br>    blockQueue-&gt;count--;<br>    printf(&quot;pop fd %d&quot;, fd);<br>    pthread_cond_signal(&amp;blockQueue-&gt;not_full);<br>    &#47;&#47; 解锁<br>    pthread_mutex_unlock(&amp;blockQueue-&gt;mutex);<br>    return fd;<br>}<br>","like_count":14,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469636,"discussion_content":"不错的想法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570972002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508329,"avatar":"https://static001.geekbang.org/account/avatar/00/17/03/e9/6358059c.jpg","nickname":"GalaxyCreater","note":"","ucode":"C79E8A088D57CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296674,"discussion_content":"这不就会死锁吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596620153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1081922,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","nickname":"刘丹","note":"","ucode":"66594D1C957E15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25904,"discussion_content":"while (blockQueue->count == blockQueue->number){ //队列满 和 blockQueue->count = blockQueue->front = blockQueue->rear = 0; 这2行代码有冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570579640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1177315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","nickname":"沉淀的梦想","note":"","ucode":"BCB7C26F9D214B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1081922,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","nickname":"刘丹","note":"","ucode":"66594D1C957E15","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28449,"discussion_content":"没有冲突啊，count是会在push和pop的过程中维护的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570698093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25904,"ip_address":""},"score":28449,"extra":""}]}]},{"had_liked":false,"id":140723,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1571038116,"is_pvip":false,"replies":[{"id":"55081","content":"好问题。<br><br>这是为了确保被pthread_cond_wait唤醒之后的线程，确实可以满足继续往下执行的条件。如果没有while循环的再次确认，可能直接就往下执行了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571453136,"ip_address":"","comment_id":140723,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48815678372","product_id":100032701,"comment_content":"请问block_queue_pop的pthread_cond_wait为什么要放在while而不是if中","like_count":11,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470527,"discussion_content":"好问题。\n\n这是为了确保被pthread_cond_wait唤醒之后的线程，确实可以满足继续往下执行的条件。如果没有while循环的再次确认，可能直接就往下执行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1620168,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b8/c8/950fb2c9.jpg","nickname":"马不停蹄","note":"","ucode":"9AB66524672291","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46757,"discussion_content":"避免假唤醒","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1573203156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138659,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1570412892,"is_pvip":false,"replies":[{"id":"54311","content":"很好的方法。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570971850,"ip_address":"","comment_id":138659,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23045249372","product_id":100032701,"comment_content":"block_queue_push未考虑队列满的情况，可以在本函数里先判断是否队列满了，如果满就按某个策略扩容，例如扩大1.5或2倍。扩容失败或者容量超过最大值，就返回失败。","like_count":5,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469612,"discussion_content":"很好的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570971850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290007,"user_name":"林燕","can_delete":false,"product_type":"c1","uid":2368765,"ip_address":"","ucode":"4A6CB5394E885D","user_header":"","comment_is_top":false,"comment_ctime":1619319820,"is_pvip":false,"replies":[{"id":"105518","content":"问题的关键是pthread_cond_wait这个函数，事实上，这个函数使得当前线程进入休眠，并且释放当前线程持有的互斥锁。而当调用线程后来从pthread_cond_wait返回时，该线程再次持有该互斥锁。这就是为什么四个子线程都可以跑完pthread_mutex_lock，然后都在pthread_cond_wait这个函数中休眠等待的原因。<br>","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1620223386,"ip_address":"","comment_id":290007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10209254412","product_id":100032701,"comment_content":"老师，请问一下，我跑了thread02这个程序。在没有客户端连上来的情况下，我发现四个子线程都执行到了block_queqe_pop函数里面，并都成功执行完pthread_mutex_lock，阻塞在后面的while循环里面。这里我想问的是四个子线程，不是最多只应该有一个能拿到互斥量，其他三个都应该阻塞在pthread_mutex_lock函数中么？","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519086,"discussion_content":"问题的关键是pthread_cond_wait这个函数，事实上，这个函数使得当前线程进入休眠，并且释放当前线程持有的互斥锁。而当调用线程后来从pthread_cond_wait返回时，该线程再次持有该互斥锁。这就是为什么四个子线程都可以跑完pthread_mutex_lock，然后都在pthread_cond_wait这个函数中休眠等待的原因。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620223386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191801,"user_name":"愚笨的老鼠","can_delete":false,"product_type":"c1","uid":1896619,"ip_address":"","ucode":"85E16D1338396B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f0/ab/3f7f3ae7.jpg","comment_is_top":false,"comment_ctime":1584797242,"is_pvip":false,"replies":[{"id":"73531","content":"问题的关键在于pthread_cond_wait的语义，在消费者线程中，通过wait等待连接处理，这个时候accept之后执行 push获取锁是可以的，并且通过signal的方式让消费者线程苏醒过来处理。<br><br>在绝大部分时刻，消费者线程都是在wait状态的，push一开始的lock锁只是一个非常短暂的check动作。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1584863190,"ip_address":"","comment_id":191801,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10174731834","product_id":100032701,"comment_content":"有个地方不太理解，一开始初始状态下，线程pop加锁了，为什么，有accept时候，执行push的时候获取锁怎么能成功呢，不是锁已经被pop用了，还没释放呢","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488260,"discussion_content":"问题的关键在于pthread_cond_wait的语义，在消费者线程中，通过wait等待连接处理，这个时候accept之后执行 push获取锁是可以的，并且通过signal的方式让消费者线程苏醒过来处理。\n\n在绝大部分时刻，消费者线程都是在wait状态的，push一开始的lock锁只是一个非常短暂的check动作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584863190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/d8/425e1b0a.jpg","nickname":"小虾米","note":"","ucode":"F543987A7FAB20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263615,"discussion_content":"pthread_cond_wait 在等待条件到来的过程中是先把锁释放掉了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589213359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190789,"user_name":"愚笨的老鼠","can_delete":false,"product_type":"c1","uid":1896619,"ip_address":"","ucode":"85E16D1338396B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f0/ab/3f7f3ae7.jpg","comment_is_top":false,"comment_ctime":1584692630,"is_pvip":false,"replies":[{"id":"73534","content":"确实如此，需要在循环函数里处理完加上close(fd)的操作。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1584863529,"ip_address":"","comment_id":190789,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174627222","product_id":100032701,"comment_content":"这个线程函数里面，没有调用close关闭connfd，导致，很多很多socket状态不对，没有正常进入time_wait状态<br>tcp4       0      0  127.0.0.1.43211        127.0.0.1.53703        CLOSE_WAIT <br>tcp4       0      0  127.0.0.1.53703        127.0.0.1.43211        FIN_WAIT_2 <br>tcp4       0      0  127.0.0.1.43211        127.0.0.1.53695        CLOSE_WAIT <br>tcp4       0      0  127.0.0.1.53695        127.0.0.1.43211        FIN_WAIT_2","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488054,"discussion_content":"确实如此，需要在循环函数里处理完加上close(fd)的操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584863529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181498,"user_name":"supermouse","can_delete":false,"product_type":"c1","uid":1321860,"ip_address":"","ucode":"88072D5F881827","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","comment_is_top":false,"comment_ctime":1582552287,"is_pvip":false,"replies":[{"id":"71036","content":"我觉得是线程。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583052690,"ip_address":"","comment_id":181498,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10172486879","product_id":100032701,"comment_content":"老师我想问一下，线程的创建销毁和进程的创建销毁哪个开销比较大？","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485014,"discussion_content":"我觉得是线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583052690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2776006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er5SNsSoiaZw4Qzd2ctH4vtibHQordcLrYsX43oFZFloRTId0op617mcGlrvGx33U8ic2LTgdicoEFPvQ/132","nickname":"Frankey","note":"","ucode":"2F09BC2500C9E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":569587,"discussion_content":"是线程?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651491504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":485014,"ip_address":""},"score":569587,"extra":""}]},{"author":{"id":2675399,"avatar":"https://static001.geekbang.org/account/avatar/00/28/d2/c7/b7f52df2.jpg","nickname":"雨里","note":"","ucode":"C475DE8B5375AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546670,"discussion_content":"肯定是进程创建和销毁开销比较大\n1、线程的创建时间比进程快，因为进程在创建的过程中，还需要管理资源信息，如内存、文件。而线程不用管理这些，因为共享它们。\n2、线程的终止时间比进程快，因为线程释放的资源比较少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642387758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338074,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609165255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148708,"user_name":"阿尔卑斯","can_delete":false,"product_type":"c1","uid":1244998,"ip_address":"","ucode":"0C9C026D02002D","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/46/2ea2fe90.jpg","comment_is_top":false,"comment_ctime":1573052081,"is_pvip":false,"replies":[{"id":"57492","content":"可以的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1573283265,"ip_address":"","comment_id":148708,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10162986673","product_id":100032701,"comment_content":"我自定义阻塞队列(多了个cnt计数元素个数，和条件变量分开来，实现起来清晰明了简单多了)<br>typedef struct<br>{<br>  int size;       &#47;&#47;队列容量<br>  int *pFd;      &#47;&#47;存储队列元素，动态分配<br>  int cnt;         &#47;&#47;队列当前元素个数<br>  int pushIdx; &#47;&#47;入队元素索引<br>  int popIdx;   &#47;&#47;出对元素索引<br>  pthread_mutex_t mutex;  &#47;&#47;锁<br>  pthread_cond_t noFull;     &#47;&#47;非满，即队列元素个数cnt从size值，变成size - 1时的触发条件<br>  pthread_cond_t noEmpty;&#47;&#47;非空，即队列元素个数cnt从0值，变成1时的触发条件<br>}BlockQueue;","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473579,"discussion_content":"可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573283265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138646,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1570407499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10160342091","product_id":100032701,"comment_content":"1.没位置可用可以选择丢弃，取出来直接关闭，等待对方重连，或者先判断队列是否有位置，没位置的话直接就不取出套接字，让它留在内核队列中，让内核处理。<br>2.存在竞态条件，需要加锁，不加锁可能大部分时间也能得到正确结果。","like_count":2},{"had_liked":false,"id":209134,"user_name":"我瑟瑟的方法","can_delete":false,"product_type":"c1","uid":1065819,"ip_address":"","ucode":"1364CD531E1B72","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/5b/17fef3ba.jpg","comment_is_top":false,"comment_ctime":1587514369,"is_pvip":false,"replies":[{"id":"78412","content":"你可以想象成有一个I&#47;O处理的&quot;多面手&quot;，可以同时处理多个I&#47;O，所以把它叫做&quot;多路I&#47;O复用&quot;。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1587803970,"ip_address":"","comment_id":209134,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882481665","product_id":100032701,"comment_content":"多路 I&#47;O 复用具体是啥意思啊","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492719,"discussion_content":"你可以想象成有一个I/O处理的&amp;quot;多面手&amp;quot;，可以同时处理多个I/O，所以把它叫做&amp;quot;多路I/O复用&amp;quot;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587803970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172718,"user_name":"超大红细胞","can_delete":false,"product_type":"c1","uid":1780519,"ip_address":"","ucode":"08FA6FE03A8C27","user_header":"https://static001.geekbang.org/account/avatar/00/1b/2b/27/9676d6b3.jpg","comment_is_top":false,"comment_ctime":1579263179,"is_pvip":false,"replies":[{"id":"68042","content":"好办法","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580624362,"ip_address":"","comment_id":172718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5874230475","product_id":100032701,"comment_content":"每次添加 fd 之前，判断队列是否满了<br> (blockQueue-&gt;rear + 1) % blockQueue-&gt;number == blockQueue-&gt;front<br>如果满了可以采用类似 C++ vector 的扩容方式直接把线程池翻倍扩容，<br>如果扩容前的 blockQueue-&gt;rear &lt; blockQueue-&gt;front <br>还需要将 0~blockQueue-&gt;rear 的 fd 移到 blockQueue-&gt;front~blockQueue-&gt;number-1 的后面，再将新的 fd 加入","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481831,"discussion_content":"好办法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580624362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154884,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1574588171,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869555467","product_id":100032701,"comment_content":"1：阻塞IO+多进程——实现简单，性能一般<br>2：阻塞IO+多线程——相比于阻塞IO+多进程，减少了上下文切换所带来的开销，性能有所提高。<br>3：阻塞IO+线程池——相比于阻塞IO+多线程，减少了线程频繁创建和销毁的开销，性能有了进一步的提高。","like_count":1,"discussions":[{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334905,"discussion_content":"这里的“性能一般” 也要看场景吧。\n比如 当前的server就是用来做CPU密集型的任务，接受完数据之后会消耗大量的CPU资源。\n这种场景，第一种方式就比较合适了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608023064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139396,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1570626390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865593686","product_id":100032701,"comment_content":"1. (just talk)可以拒绝 扩容 或者 加一个信号量来变为阻塞队列叭<br><br>2. 绝大多数情况下这个值小于2000哇","like_count":1},{"had_liked":false,"id":351770,"user_name":"简简单单就是幸福","can_delete":false,"product_type":"c1","uid":2740779,"ip_address":"","ucode":"A08080E6FD255F","user_header":"https://static001.geekbang.org/account/avatar/00/29/d2/2b/af13fcd6.jpg","comment_is_top":false,"comment_ctime":1658189045,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658189045","product_id":100032701,"comment_content":"线程里面的打印能显示出来？？","like_count":0},{"had_liked":false,"id":347377,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1653978686,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653978686","product_id":100032701,"comment_content":"老师，我记得锁有一个是非阻塞，那能不能用那个来替换普通的锁来实现这个线程池来增加这个线程池的运行效率。<br>第一问感觉最简单的方法就是用链表来试试无论单向还是双向链表管理。或者用realloc来扩容","like_count":0},{"had_liked":false,"id":347374,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1653978175,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653978175","product_id":100032701,"comment_content":"第一问：可以给一个扩容的最大值，然后用realloc扩容。如果超过了最大值然后等待一个条件变量就可以了","like_count":0},{"had_liked":false,"id":344158,"user_name":"mikewoo","can_delete":false,"product_type":"c1","uid":1118888,"ip_address":"","ucode":"9AE90E05048DE1","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/a8/8aaf13e0.jpg","comment_is_top":false,"comment_ctime":1651312527,"is_pvip":true,"replies":[{"id":"126192","content":"👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1652614501,"ip_address":"","comment_id":344158,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651312527","product_id":100032701,"comment_content":"第一个问题是需要考虑在队列满了的场景下是否需要做扩容或者采取各种拒绝策略；第二个问题是多线程执行常见的线程安全问题。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572133,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652614501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333973,"user_name":"淡C","can_delete":false,"product_type":"c1","uid":2696647,"ip_address":"","ucode":"046DE6F5301044","user_header":"https://static001.geekbang.org/account/avatar/00/29/25/c7/edd74dfb.jpg","comment_is_top":false,"comment_ctime":1644647639,"is_pvip":false,"replies":[{"id":"122009","content":"我猜你是说可以循序.....","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1644729071,"ip_address":"","comment_id":333973,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644647639","product_id":100032701,"comment_content":"1.可以自旋<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550759,"discussion_content":"我猜你是说可以循序.....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644729071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311272,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1631152198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631152198","product_id":100032701,"comment_content":"更改全部变量的操作不是原子操作（去数据到寄存器，寄存器完成加法操作，将结果存放会数据变量中），可能导致一个线程在更改全局变量时，其他线程也来更改这个变量，最终两个线程都会写入新的结果，但是这个结果可能是错误的","like_count":0},{"had_liked":false,"id":300155,"user_name":"vv_test","can_delete":false,"product_type":"c1","uid":1685884,"ip_address":"","ucode":"1D164B2F034E2B","user_header":"https://static001.geekbang.org/account/avatar/00/19/b9/7c/afe6f1eb.jpg","comment_is_top":false,"comment_ctime":1625023076,"is_pvip":false,"replies":[{"id":"109699","content":"而且还要保存进程的各种上下文数据哦。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1626606214,"ip_address":"","comment_id":300155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625023076","product_id":100032701,"comment_content":"线程上下文切换的开销要比进程小得多。主要是因为虚拟地址切换导致开销更大点。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522657,"discussion_content":"而且还要保存进程的各种上下文数据哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626606214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287772,"user_name":"王蓬勃","can_delete":false,"product_type":"c1","uid":2450040,"ip_address":"","ucode":"DDF4CCE9728DCF","user_header":"","comment_is_top":false,"comment_ctime":1618142839,"is_pvip":false,"replies":[{"id":"104847","content":"有些大啊，这个tid......<br><br>calculator这个值不对是正常的","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618751441,"ip_address":"","comment_id":287772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618142839","product_id":100032701,"comment_content":"这是我跑出来的结果。。。。<br>hello, world, tid == 140117162977024<br>hello, world, tid == 140117171369728<br>calculator is 24091<br>another_shared is 2000<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518415,"discussion_content":"有些大啊，这个tid......\n\ncalculator这个值不对是正常的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618751441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287735,"user_name":"Geek_93d8e2","can_delete":false,"product_type":"c1","uid":2024432,"ip_address":"","ucode":"67A65E1DCA3D3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/B6Ed9L0AoFg96622tjfaib6obcf1KfKJ9mF0UHOFoQYDFsLgGfqG38kibx4cYVZhKBAzNEmnYd0LbWSDGNuL0X3A/132","comment_is_top":false,"comment_ctime":1618129126,"is_pvip":false,"replies":[{"id":"104495","content":"不会。<br><br>注意这个时候rear被重新置为0了。<br> if (++blockQueue-&gt;rear == blockQueue-&gt;number) {<br>        blockQueue-&gt;rear = 0;<br>  }<br><br>所以是 <br>blockQueue-&gt;fd[0] = fd<br>","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618140904,"ip_address":"","comment_id":287735,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618129126","product_id":100032701,"comment_content":"   25行 会造成数组越界吧 <br> blockQueue-&gt;fd[blockQueue-&gt;rear] = fd;<br>    if (++blockQueue-&gt;rear == blockQueue-&gt;number) {<br>        blockQueue-&gt;rear = 0;<br>    }<br>当number为1时，第二次插入时blockQueue-&gt;fd[1]","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518400,"discussion_content":"不会。\n\n注意这个时候rear被重新置为0了。\n if (++blockQueue-&amp;gt;rear == blockQueue-&amp;gt;number) {\n        blockQueue-&amp;gt;rear = 0;\n  }\n\n所以是 \nblockQueue-&amp;gt;fd[0] = fd\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618140904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246341,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1599286596,"is_pvip":false,"replies":[{"id":"90595","content":"������","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1599402180,"ip_address":"","comment_id":246341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599286596","product_id":100032701,"comment_content":"第一道，扩容。<br>第二道，多线程并发会造成结果不一致，原因在于非原子性操作。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505117,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599402180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246054,"user_name":"井底之蛙","can_delete":false,"product_type":"c1","uid":1624505,"ip_address":"","ucode":"DAEE283B210B23","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/b9/aff32d3c.jpg","comment_is_top":false,"comment_ctime":1599145175,"is_pvip":false,"replies":[{"id":"90593","content":"你是回答的这个问题？<br>我在讲到第一个 hello-world 计数器应用时，说“结果是幸运”这是为什么呢？怎么理解呢？","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1599400461,"ip_address":"","comment_id":246054,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599145175","product_id":100032701,"comment_content":"第二个问题，是必须要设置的，不设置的话，内核就会认为用户不关心这个，即使有事件发生也不会置位，do_sys_poll()函数这个判断。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505046,"discussion_content":"你是回答的这个问题？\n我在讲到第一个 hello-world 计数器应用时，说“结果是幸运”这是为什么呢？怎么理解呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599400461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232747,"user_name":"郑祖煌","can_delete":false,"product_type":"c1","uid":1469608,"ip_address":"","ucode":"49A0D2E3279826","user_header":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","comment_is_top":false,"comment_ctime":1594107558,"is_pvip":false,"replies":[{"id":"86803","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1594906602,"ip_address":"","comment_id":232747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594107558","product_id":100032701,"comment_content":"1. 可以使用链表来存储，这样当队列不够时还能够再创建链表去连接上，同时如果线程退出的时候就删除对应的节点<br>2.结果很幸运。因为他的运行结果都是一次运行完thread_run紧接着运行下一次的thread_run的值。 如果线程之间交互运行，比如线程1刚执行玩*calculator += 1; 有可能另一个线程就运行int *calculator = (int *) arg; 这样就达不到2000了。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500759,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594906602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225835,"user_name":"李沛霖-程序猿","can_delete":false,"product_type":"c1","uid":1063957,"ip_address":"","ucode":"10CF0DBED2D220","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/15/71a2aca9.jpg","comment_is_top":false,"comment_ctime":1591869132,"is_pvip":false,"replies":[{"id":"84274","content":"线程池也是把多个线程有效的组织起来使用，不是取消线程的意思。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1592743754,"ip_address":"","comment_id":225835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591869132","product_id":100032701,"comment_content":"那用了池技术，就没有进程切换的问题了。线程是不是就可以取消了。而且进程的隔离型比较好。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498011,"discussion_content":"线程池也是把多个线程有效的组织起来使用，不是取消线程的意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592743754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222494,"user_name":"jhren","can_delete":false,"product_type":"c1","uid":1596987,"ip_address":"","ucode":"60F7CCEA1E2C88","user_header":"https://static001.geekbang.org/account/avatar/00/18/5e/3b/845fb641.jpg","comment_is_top":false,"comment_ctime":1590821144,"is_pvip":false,"replies":[{"id":"82180","content":"我看应该是多路复用I&#47;O为主的事件驱动模型吧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1590931614,"ip_address":"","comment_id":222494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590821144","product_id":100032701,"comment_content":"请问老师，Redis6.0多线程模型是不是就是&quot;阻塞I&#47;O和线程模型&quot;<br>https:&#47;&#47;www.dropbox.com&#47;s&#47;ooyxgfhh7pzf6i9&#47;redis-threads.png?dl=0<br>https:&#47;&#47;time.geekbang.org&#47;course&#47;detail&#47;100051101-241464<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496816,"discussion_content":"我看应该是多路复用I/O为主的事件驱动模型吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590931614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181465,"user_name":"supermouse","can_delete":false,"product_type":"c1","uid":1321860,"ip_address":"","ucode":"88072D5F881827","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","comment_is_top":false,"comment_ctime":1582546572,"is_pvip":false,"replies":[{"id":"71037","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583052713,"ip_address":"","comment_id":181465,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1582546572","product_id":100032701,"comment_content":"思考题第一道：我能想到的有两种方式，第一种是动态扩容，将描述字的数组扩大1倍；第二种方式是采用链表的方式实现描述字队列。<br>思考题第二道：CPU缓存会导致可见性问题，即两个线程同时修改一个变量时，会出现前一个线程的修改结果被后一个线程覆盖掉的情况，导致最后变量的值不是预期的2000，而是介于1000~2000之间。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485007,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583052713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","nickname":"Richard","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204293,"discussion_content":"第二个问题并不是CPU缓存问题，CPU的架构设计本身会保证缓存一致性，程序员应该关注的是顺序一致性问题，这里会有问题是因为对于共享变量的修改不是原子的，因此在指令运行期间有可能被调度器打破从而造成结果不准确。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584150767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1321860,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","nickname":"supermouse","note":"","ucode":"88072D5F881827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","nickname":"Richard","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206422,"discussion_content":"单核CPU的缓存不会导致这个问题，但如果是多核CPU，每个CPU都有自己的缓存，就会有这个问题了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584404978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204293,"ip_address":""},"score":206422,"extra":""}]}]},{"had_liked":false,"id":161926,"user_name":"Geek_68d3d2","can_delete":false,"product_type":"c1","uid":1674369,"ip_address":"","ucode":"EBD6D881AA7A74","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqf54z1ZmqQY1kmJ6t1HAnrqMM3j6WKf0oDeVLhtnA2ZUKY6AX9MK6RjvcO8SiczXy3uU0IzBQ3tpw/132","comment_is_top":false,"comment_ctime":1576406348,"is_pvip":false,"replies":[{"id":"63918","content":"可能的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1577604774,"ip_address":"","comment_id":161926,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576406348","product_id":100032701,"comment_content":"线程里面 用完的fd好像都没有close掉吧","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477914,"discussion_content":"可能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577604774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143167,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1571641948,"is_pvip":false,"replies":[{"id":"55836","content":"我的main函数已经在验证了，开多个线程，有往队列里扔对象的，有从队列里取对象处理的，看看这个程序是否可以处理高并发的场景，这就是你的代码逻辑需要关注的点。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1572059141,"ip_address":"","comment_id":143167,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571641948","product_id":100032701,"comment_content":"请问我想验证这个阻塞队列的正确性，那我的代码逻辑应该怎么写","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471404,"discussion_content":"我的main函数已经在验证了，开多个线程，有往队列里扔对象的，有从队列里取对象处理的，看看这个程序是否可以处理高并发的场景，这就是你的代码逻辑需要关注的点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572059141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142424,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1571366460,"is_pvip":false,"replies":[{"id":"55126","content":"合法的，传值还是传地址，是自己在程序里面定义的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571457734,"ip_address":"","comment_id":142424,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571366460","product_id":100032701,"comment_content":"请问thread_run函数里这个int fd = (int) arg 合法吗，我觉得是int fd = *(int *)arg吧<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471120,"discussion_content":"合法的，传值还是传地址，是自己在程序里面定义的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571457734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53607,"discussion_content":"老师你好，这样的写法 int fd = (int) arg  编译不过啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574178589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140765,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1571045293,"is_pvip":false,"replies":[{"id":"55084","content":"提个MR或者issue?我看大家都正常啊，你的系统是啥？","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571453373,"ip_address":"","comment_id":140765,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571045293","product_id":100032701,"comment_content":" pthread_create(&amp;(thread_array[i].thread_tid), NULL, &amp;thread_run, (void *) &amp;blockQueue);<br>pthread_create函数调用这里有问题 应该是<br>void* thread_run(void *arg) {<br>    pthread_t tid = pthread_self();<br>    pthread_detach(tid);<br><br>    block_queue *blockQueue = (block_queue *) arg;<br>    while (1) {<br>        int fd = block_queue_pop(blockQueue);<br>        printf(&quot;get fd in thread, fd==%d, tid == %d&quot;, fd, tid);<br>        loop_echo(fd);<br>    }<br>}<br>我编辑代码的时候总是报错 后来通过man函数和编译才差出来","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470545,"discussion_content":"提个MR或者issue?我看大家都正常啊，你的系统是啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217413,"avatar":"https://static001.geekbang.org/account/avatar/00/12/93/85/f5d9474c.jpg","nickname":"乔丹","note":"","ucode":"D832A9F97A0C7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348227,"discussion_content":"centos7+gcc6.3,void *thread_run(void *arg)才能编译成功。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612487793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140727,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1571038821,"is_pvip":false,"replies":[{"id":"55082","content":"你的例子是说accetpor不要无限制的接收客户端的连接，相当于做了一个限流，这也是比较常见的一种手段。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571453215,"ip_address":"","comment_id":140727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571038821","product_id":100032701,"comment_content":"看了git上的代码,我又思考了第一题 一般来说肯定数量一定会被限定,不可能无线扩容,并且还要回收利用,比如某个连接关闭了,就应该将其移除,而不是再对其进行读写等操作,不然会浪费很多资源,还容易出现很多莫名其妙的tcp层面错误,最简单的例子 很多游戏都设置了一个排队,例如之前看见英雄联盟在登录界面的排队,还有魔兽也有类似的操作,所以如果本来描述符数量已经设置到合理大小了就不要再扩容而是采取排队进入的方式","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470529,"discussion_content":"你的例子是说accetpor不要无限制的接收客户端的连接，相当于做了一个限流，这也是比较常见的一种手段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140709,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1571035904,"is_pvip":false,"replies":[{"id":"55080","content":"第一个问题可以提个MR给我哈","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571452835,"ip_address":"","comment_id":140709,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571035904","product_id":100032701,"comment_content":"第一问 连接字队列不可能说无限扩容,当某个连接断开时应该是要从连接字队列里面移除<br>第二问 那是因为没有出现多线程竞争的情况也就是异步事件，也可以通过加锁来解决异步问题","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470520,"discussion_content":"第一个问题可以提个MR给我哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571452835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139253,"user_name":"赖阿甘","can_delete":false,"product_type":"c1","uid":1351988,"ip_address":"","ucode":"77493FE85CBAF8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICBNZjA9hW65x6g9b2iaicKUJW5gxFxtgPXH9Cqp6eyFfY1sD2hVY4dZrY5pmoK2r1KZEiaaIKocdZQ/132","comment_is_top":false,"comment_ctime":1570592755,"is_pvip":false,"replies":[{"id":"54322","content":"我理解pthread_detach以后就不能了，你可以尝试一下。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570973235,"ip_address":"","comment_id":139253,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570592755","product_id":100032701,"comment_content":"分离线程中的“而一个分离的线程不能被其他线程杀死或回收资源。”这句话有误？虽然你调用pthread_detach（），但是其他线程还是可以通过pthread_cancel（）结束这个线程吧！还望老师指点","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469856,"discussion_content":"我理解pthread_detach以后就不能了，你可以尝试一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570973235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138793,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1570453574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570453574","product_id":100032701,"comment_content":"1.队列满可以关闭fd拒绝服务，也可以扩容等待队列，但都不太好。毕竟一个线程服务一个socket的开销还是有点大。还是多路复用加异步比较划算。<br>2.就是并发会产生不确定性。在这个循环次数从1000变大些，出现的概率可能就更大了。","like_count":0},{"had_liked":false,"id":138641,"user_name":"程序水果宝","can_delete":false,"product_type":"c1","uid":1371633,"ip_address":"","ucode":"1700DDFE073A56","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","comment_is_top":false,"comment_ctime":1570403249,"is_pvip":false,"replies":[{"id":"54310","content":"typedef struct {<br>    pthread_t thread_tid;        &#47;* thread ID *&#47;<br>    long thread_count;    &#47;* # connections handled *&#47;<br>} Thread;<br><br>因为篇幅原因，不是所有代码都放到文稿里了，请到这里看详细的代码<br>https:&#47;&#47;github.com&#47;froghui&#47;yolanda<br>","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570971777,"ip_address":"","comment_id":138641,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1570403249","product_id":100032701,"comment_content":"thread_array = calloc(THREAD_NUMBER, sizeof(Thread));这个Thread是哪里来的，是C库的线程结构体吗？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469603,"discussion_content":"typedef struct {\n    pthread_t thread_tid;        /* thread ID */\n    long thread_count;    /* # connections handled */\n} Thread;\n\n因为篇幅原因，不是所有代码都放到文稿里了，请到这里看详细的代码\nhttps://github.com/froghui/yolanda\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570971777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","nickname":"沉淀的梦想","note":"","ucode":"BCB7C26F9D214B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25155,"discussion_content":"好像是老师代码里自己定义的结构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570438308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1371633,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqyicZYyW7ahaXgXUD8ZAS8x0t8jx5rYLhwbUCJiawRepKIZfsLdkxdQ9XQMo99c1UDibmNVfFnAqwPg/132","nickname":"程序水果宝","note":"","ucode":"1700DDFE073A56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1177315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","nickname":"沉淀的梦想","note":"","ucode":"BCB7C26F9D214B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25192,"discussion_content":"没有定义Thread的结构体吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570449660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25155,"ip_address":""},"score":25192,"extra":""}]}]}]}