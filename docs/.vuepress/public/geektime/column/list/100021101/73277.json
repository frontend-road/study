{"id":73277,"title":"06补充篇 | 卡顿优化：卡顿现场与卡顿分析","content":"<p>我们使用上一期所讲的插桩或者Profilo的方案，可以得到卡顿过程所有运行函数的耗时。在大部分情况下，这几种方案的确非常好用，可以让我们更加明确真正的卡顿点在哪里。</p><p>但是，你肯定还遇到过很多莫名其妙的卡顿，比如读取1KB的文件、读取很小的asset资源或者只是简单的创建一个目录。</p><p>为什么看起来这么简单的操作也会耗费那么长的时间呢？那我们如何通过收集更加丰富的卡顿现场信息，进一步定位并排查问题呢？</p><h2>卡顿现场</h2><p>我先来举一个线上曾经发现的卡顿例子，下面是它的具体耗时信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/46/2398281c40faaa3620f48e1d23da9046.png?wh=1292*866\" alt=\"\"></p><p>从图上看，Activity的onCreate函数耗时达到3秒，而其中Lottie动画中<a href=\"http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/res/AssetManager.java#852\">openNonAsset</a>函数耗时竟然将近2秒。尽管是读取一个30KB的资源文件，但是它的耗时真的会有那么长吗？</p><p>今天我们就一起来分析这个问题吧。</p><p><strong>1. Java实现</strong></p><p>进一步分析openNonAsset相关源码的时候发现，AssetManager内部有大量的synchronized锁。首先我怀疑还是锁的问题，接下来需要把卡顿时各个线程的状态以及堆栈收集起来做进一步分析。</p><p><strong>步骤一：获得Java线程状态</strong></p><p>通过Thread的getState方法可以获取线程状态，当时主线程果然是BLOCKED状态。</p><!-- [[[read_end]]] --><p>什么是BLOCKED状态呢？当线程无法获取下面代码中的object对象锁的时候，线程就会进入BLOCKED状态。</p><pre><code>// 线程等待获取object对象锁\nsynchronized (object)  {\n    dosomething();\n}  \n</code></pre><p><strong>WAITING、TIME_WAITING和BLOCKED都是需要特别注意的状态。</strong>很多同学可能对BLOCKED和WAITING这两种状态感到比较困惑，BLOCKED是指线程正在等待获取锁，对应的是下面代码中的情况一；WAITING是指线程正在等待其他线程的“唤醒动作”，对应的是代码中的情况二。</p><pre><code>synchronized (object)  {     // 情况一：在这里卡住 --&gt; BLOCKED\n    object.wait();           // 情况二：在这里卡住 --&gt; WAITING\n}  \n</code></pre><p>不过当一个线程进入WAITING状态时，它不仅会释放CPU资源，还会将持有的object锁也同时释放。对Java各个线程状态的定义以及转换等更多介绍，你可以参考<a href=\"http://developer.android.com/reference/java/lang/Thread.State\">Thread.State</a>和<a href=\"http://juejin.im/post/5b31b510e51d4558a426f7e9\">《Java线程Dump分析》</a>。</p><p><strong>步骤二：获得所有线程堆栈</strong></p><p>接着我们在Java层通过Thread.getAllStackTraces()进一步拿所有线程的堆栈，希望知道具体是因为哪个线程导致主线程的BLOCKED。</p><p>需要注意的是在Android 7.0，getAllStackTraces是不会返回主线程的堆栈的。通过分析收集上来的卡顿日志，我们发现跟AssetManager相关的线程有下面这个。</p><pre><code>&quot;BackgroundHandler&quot;  RUNNABLE\n  at  android.content.res.AssetManager.list\n  at  com.sample.business.init.listZipFiles\n</code></pre><p>通过查看<a href=\"http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/res/AssetManager.java#788\">AssetManager.list</a>的确发现是使用了同一个synchronized锁，而list函数需要遍历整个目录，耗时会比较久。</p><pre><code>public String[] list(String path) throws IOException {\n  synchronized (this) {\n    ensureValidLocked();\n    return nativeList(mObject, path);\n  }\n}\n</code></pre><p><strong>另外一方面，“BackgroundHandler”线程属于低优先级后台线程，这也是我们前面文章提到的不良现象，也就是主线程等待低优先级的后台线程。</strong></p><p><strong>2. SIGQUIT信号实现</strong></p><p>Java实现的方案看起来非常不错，也帮助我们发现了卡顿的原因。不过在我们印象中，似乎<a href=\"http://developer.android.com/topic/performance/vitals/anr\">ANR日志</a>的信息更加丰富，那我们能不能直接用ANR日志呢？</p><p>比如下面的例子，它的信息的确非常全，所有线程的状态、CPU时间片、优先级、堆栈和锁的信息应有尽有。其中utm代表utime，HZ代表CPU的时钟频率，将utime转换为毫秒的公式是“time * 1000/HZ”。例子中utm=218，也就是218*1000/100=2180毫秒。</p><pre><code>// 线程名称; 优先级; 线程id; 线程状态\n&quot;main&quot; prio=5 tid=1 Suspended\n  // 线程组;  线程suspend计数; 线程debug suspend计数; \n  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x74746000 self=0xf4827400\n  // 线程native id; 进程优先级; 调度者优先级;\n  | sysTid=28661 nice=-4 cgrp=default sched=0/0 handle=0xf72cbbec\n  // native线程状态; 调度者状态; 用户时间utime; 系统时间stime; 调度的CPU\n  | state=D schedstat=( 3137222937 94427228 5819 ) utm=218 stm=95 core=2 HZ=100\n  // stack相关信息\n  | stack=0xff717000-0xff719000 stackSize=8MB\n</code></pre><p><strong>疑问一：Native线程状态</strong></p><p>细心的你可能会发现，为什么上面的ANR日志中“main”线程的状态是Suspended？想了一下，Java线程中的6种状态中并不存在Suspended状态啊。</p><p>事实上，Suspended代表的是Native线程状态。怎么理解呢？在Android里面Java线程的运行都委托于一个Linux标准线程pthread来运行，而Android里运行的线程可以分成两种，一种是Attach到虚拟机的，一种是没有Attach到虚拟机的，在虚拟机管理的线程都是托管的线程，所以本质上Java线程的状态其实是Native线程的一种映射。</p><p>不同的Android版本Native线程的状态不太一样，例如Android 9.0就定义了27种线程状态，它能更加明确地区分线程当前所处的情况。关于Java线程状态、Native线程状态转换，你可以参考<a href=\"http://androidxref.com/9.0.0_r3/xref/art/runtime/thread_state.h#24\">thread_state.h</a>和<a href=\"http://androidxref.com/9.0.0_r3/xref/art/runtime/native/java_lang_Thread.cc#64\">Thread_nativeGetStatus</a>。</p><p><img src=\"https://static001.geekbang.org/resource/image/af/4b/af6485856d47626b13433f96ec48d44b.png?wh=1284*936\" alt=\"\"></p><p><strong>我们可以看到Native线程状态的确更加丰富，例如将TIMED_WAITING拆分成TimedWaiting和Sleeping两种场景，而WAITING更是细化到十几种场景等，这对我们分析特定场景问题的时候会有非常大的帮助。</strong></p><p><strong>疑问二：获得ANR日志</strong></p><p>虽然ANR日志信息非常丰富，那问题又来了，如何拿到卡顿时的ANR日志呢？</p><p>我们可以利用系统ANR的生成机制，具体步骤是：</p><p>第一步：当监控到主线程卡顿时，主动向系统发送SIGQUIT信号。</p><p>第二步：等待/data/anr/traces.txt文件生成。</p><p>第三步：文件生成以后进行上报。</p><p>通过ANR日志，我们可以直接看到主线程的锁是由“BackgroundHandler”线程持有。相比之下通过getAllStackTraces方法，我们只能通过一个一个线程进行猜测。</p><pre><code>  // 堆栈相关信息\n  at android.content.res.AssetManager.open(AssetManager.java:311)\n  - waiting to lock &lt;0x41ddc798&gt; (android.content.res.AssetManager) held by tid=66 (BackgroundHandler)\n  at android.content.res.AssetManager.open(AssetManager.java:289)\n</code></pre><p>线程间的死锁和热锁分析是一个非常有意思的话题，很多情况分析起来也比较困难，例如我们只能拿到Java代码中使用的锁，而且有部分类型锁的持有并不会表现在堆栈上面。对这部分内容感兴趣，想再深入一下的同学，可以认真看一下这两篇文章：<a href=\"http://juejin.im/post/5b31b510e51d4558a426f7e9\">《Java线程Dump分析》</a>、<a href=\"http://cloud.tencent.com/developer/article/1064396\">《手Q Android线程死锁监控与自动化分析实践》</a>。</p><p><strong>3. Hook实现</strong></p><p>用SIGQUIT信号量获取ANR日志，从而拿到所有线程的各种信息，这套方案看起来很美好。但事实上，它存在这几个问题：</p><ul>\n<li>\n<p><strong>可行性</strong>。正如我在崩溃分析所说的一样，很多高版本系统已经没有权限读取/data/anr/traces.txt文件。</p>\n</li>\n<li>\n<p><strong>性能</strong>。获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。</p>\n</li>\n</ul><p>那有什么方法既可以拿到ANR日志，整个过程又不会影响用户的体验呢？</p><p>再回想一下，在<a href=\"http://time.geekbang.org/column/article/70602\">崩溃分析</a>的时候我们就讲过一种获得所有线程堆栈的方法。它通过下面几个步骤实现。</p><ul>\n<li>\n<p>通过<code>libart.so</code>、<code>dlsym</code>调用<a href=\"http://androidxref.com/9.0.0_r3/xref/art/runtime/thread_list.cc#1501\">ThreadList::ForEach</a>方法，拿到所有的Native线程对象。</p>\n</li>\n<li>\n<p>遍历线程对象列表，调用<a href=\"http://androidxref.com/9.0.0_r3/xref/art/runtime/thread.cc#1615\">Thread::DumpState</a>方法。</p>\n</li>\n</ul><p>它基本模拟了系统打印ANR日志的流程，但是因为整个过程使用了一些黑科技，可能会造成线上崩溃。</p><p>为了兼容性考虑，我们会通过fork子进程方式实现，这样即使子进程崩溃了也不会影响我们主进程的运行。<strong>这样还可以带来另外一个非常大的好处，获取所有线程堆栈这个过程可以做到完全不卡我们主进程。</strong></p><p>但使用fork进程会导致进程号改变，源码中通过/proc/self方式获取的一些信息都会失败（<strong>错误的拿了子进程的信息，而子进程只有一个线程</strong>），例如state、schedstat、utm、stm、core等。不过问题也不大，这些信息可以通过指定/proc/[父进程id]的方式重新获取。</p><pre><code>&quot;main&quot; prio=7 tid=1 Native\n  | group=&quot;&quot; sCount=0 dsCount=0 obj=0x74e99000 self=0xb8811080\n  | sysTid=23023 nice=-4 cgrp=default sched=0/0 handle=0xb6fccbec\n  | state=? schedstat=( 0 0 0 ) utm=0 stm=0 core=0 HZ=100\n  | stack=0xbe4dd000-0xbe4df000 stackSize=8MB\n  | held mutexes=\n</code></pre><p><strong>总的来说，通过Hook方式我们实现了一套“无损”获取所有Java线程堆栈与详细信息的方法。为了降低上报数据量，只有主线程的Java线程状态是WAITING、TIME_WAITING或者BLOCKED的时候，才会进一步使用这个“大杀器”。</strong></p><p><strong>4. 现场信息</strong></p><p>现在再来看，这样一份我们自己构造的“ANR日志”是不是已经是收集崩溃现场信息的完全体了？它似乎缺少了我们常见的头部信息，例如进程CPU使用率、GC相关的信息。</p><p>正如第6期文章开头所说的一样，卡顿跟崩溃一样是需要“现场信息”的。能不能进一步让卡顿的“现场信息”的比系统ANR日志更加丰富？我们可以进一步增加这些信息：</p><ul>\n<li>\n<p><strong>CPU使用率和调度信息</strong>。参考第5期的课后练习，我们可以得到系统CPU使用率、负载、各线程的CPU使用率以及I/O调度等信息。</p>\n</li>\n<li>\n<p><strong>内存相关信息</strong>。我们可以添加系统总内存、可用内存以及应用各个进程的内存等信息。如果开启了Debug.startAllocCounting或者atrace，还可以增加GC相关的信息。</p>\n</li>\n<li>\n<p><strong>I/O和网络相关</strong>。我们还可以把卡顿期间所有的I/O和网络操作的详细信息也一并收集，这部分内容会在后面进一步展开。</p>\n</li>\n</ul><p>在Android 8.0后，Android虚拟机终于支持了JVM的<a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html\">JVMTI</a>机制。Profiler中内存采集等很多模块也切换到这个机制中实现，后面我会邀请“学习委员”鹏飞给你讲讲JVMTI机制与应用。使用它可以获得的信息非常丰富，包括内存申请、线程创建、类加载、GC等，有大量的应用场景。</p><p>最后我们还可以利用崩溃分析中的一些思路，例如添加用户操作路径等信息，这样我们可以得到一份比系统ANR更加丰富的卡顿日志，这对我们解决某些疑难的卡顿问题会更有帮助。</p><h2>卡顿分析</h2><p>在客户端捕获卡顿之后，最后数据需要上传到后台统一分析。我们可以对数据做什么样的处理？应该关注哪些指标？</p><p><strong>1. 卡顿率</strong></p><p>如果把主线程卡顿超过3秒定义为一个卡顿问题，类似崩溃，我们会先评估卡顿问题的影响面，也就是UV卡顿率。</p><pre><code>UV 卡顿率 = 发生过卡顿 UV / 开启卡顿采集 UV\n</code></pre><p>因为卡顿问题一般都是抽样上报，采样规则跟内存相似，都应该按照人来抽样。一个用户如果命中采集，那么在一天内都会持续的采集数据。</p><p>UV卡顿率可以评估卡顿的影响范围，但对于低端机器来说比较难去优化卡顿的问题。如果想评估卡顿的严重程度，我们可以使用PV卡顿率。</p><pre><code>PV 卡顿率 = 发生过卡顿 PV / 启动采集 PV\n</code></pre><p>需要注意的是，对于命中采集PV卡顿率的用户，每次启动都需要上报作为分母。</p><p><strong>2. 卡顿树</strong></p><p>发生卡顿时，我们会把CPU使用率和负载相关信息也添加到卡顿日志中。虽然采取了抽样策略，但每天的日志量还是达到十万级别。这么大的日志量，如果简单采用堆栈聚合日志，会发现有几百上千种卡顿类型，很难看出重点。</p><p>我们能不能实现卡顿的火焰图，在一张图里就可以看到卡顿的整体信息？</p><p>这里我非常推荐卡顿树的做法，对于超过3秒的卡顿，具体是4秒还是10秒，这涉及手机性能和当时的环境。我们决定抛弃具体的耗时，只按照相同堆栈出现的比例来聚合。这样我们从一棵树上面，就可以看到哪些堆栈出现的卡顿问题最多，它下面又存在的哪些分支。</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/5d/ca54f510455317ce487476cbe9cd285d.png?wh=1482*706\" alt=\"\"></p><p>我们的精力是有限的，一般会优先去解决Top的卡顿问题。采用卡顿树的聚合方式，可以从全盘的角度看到Top卡顿问题的各个分支情况，帮助我们快速找到关键的卡顿点。</p><h2>总结</h2><p>今天我们从一个简单的卡顿问题出发，一步一步演进出解决这个问题的三种思路。其中Java实现的方案是大部分同学首先想到的方案，它虽然简单稳定，不过存在信息不全、性能差等问题。</p><p>可能很多同学认为问题可以解决就算万事大吉了，但我并不这样认为。我们应该继续敲问自己，如果再出现类似的问题，我们是否也可以采用相同的方法去解决？这个方案的代价对用户会带来多大的影响，是否还有优化的空间？</p><p>只有这样，才会出现文中的方案二和方案三，解决方案才会一直向前演进，做得越来越好。也只有这样，我们才能在追求卓越的过程中快速进步。</p><h2>课后作业</h2><p>线程等待、死锁和热锁在应用中都是非常普遍的，<span class=\"orange\">今天的课后作业是分享一下你的产品中是否出现过这些问题，又是如何解决的？</span>请你在留言区分享一下今天学习、练习的收获与心得。</p><p>我在评论中发现很多同学对监控Thread的创建比较感兴趣，今天我们的<a href=\"http://github.com/AndroidAdvanceWithGeektime/Chapter06-plus\">Sample</a>是如何监控线程的创建。在实践前，给你一些可以参考的链接。</p><ul>\n<li>\n<p><a href=\"http://www.jianshu.com/p/a26d11502ec8\">Android线程的创建过程</a></p>\n</li>\n<li>\n<p><a href=\"http://androidxref.com/9.0.0_r3/xref/art/runtime/native/java_lang_Thread.cc#43\">java_lang_Thread.cc</a></p>\n</li>\n<li>\n<p><a href=\"http://androidxref.com/9.0.0_r3/xref/art/runtime/thread.cc\">thread.cc</a></p>\n</li>\n<li>\n<p><a href=\"http://androidxref.com/9.0.0_r3/xref/art/runtime/Android.bp\">编译脚本Android.bp</a></p>\n</li>\n</ul><p>对于PLT Hook和Inline Hook的具体实现原理与差别，我在后面会详细讲到。这里我们可以把它们先隐藏掉，直接利用开源的实现即可。通过这个Sample我希望你可以学会通过分析源码，寻找合理的Hook函数与具体的so库。我相信当你熟悉这些方法之后，一定会惊喜地发现实现起来其实真的不难。</p><p>欢迎你点击“请朋友读”，把今天的内容分享给好友，邀请他一起学习。最后别忘了在评论区提交今天的作业，我也为认真完成作业的同学准备了丰厚的“学习加油礼包”，期待与你一起切磋进步哦。</p><p></p>","comments":[{"had_liked":false,"id":51486,"user_name":"郭威","can_delete":false,"product_type":"c1","uid":1331454,"ip_address":"","ucode":"FDA06FE64489FB","user_header":"https://static001.geekbang.org/account/avatar/00/14/50/fe/33cc0374.jpg","comment_is_top":false,"comment_ctime":1545188839,"is_pvip":false,"replies":[{"id":"18629","content":"先留时间给大家实现，后续看情况要不要放出来","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1545192746,"ip_address":"","comment_id":51486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48789829095","product_id":100021101,"comment_content":"问一下作者那个fork获取线程堆栈的方式说的太笼统了，有小demo么","like_count":11,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433478,"discussion_content":"先留时间给大家实现，后续看情况要不要放出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545192746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52748,"user_name":"Sean","can_delete":false,"product_type":"c1","uid":1092610,"ip_address":"","ucode":"0668817CD42095","user_header":"https://static001.geekbang.org/account/avatar/00/10/ac/02/3b8eedd6.jpg","comment_is_top":false,"comment_ctime":1545494932,"is_pvip":false,"replies":[{"id":"19185","content":"这里笔误了，应该是Android 7.0，没有之后。我后面改一下","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1545534814,"ip_address":"","comment_id":52748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35905233300","product_id":100021101,"comment_content":"文中说明的 &quot; 需要注意的是在 Android 7.0 之后，getAllStackTraces 是不会返回主线程的堆栈的&quot;，我在8.0和8.1的系统下Java 层通过代码测试过，发现主线程的stacktrace实际上是可以得到的。不知所述结论是如何得到的？","like_count":8,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433970,"discussion_content":"这里笔误了，应该是Android 7.0，没有之后。我后面改一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545534814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51282,"user_name":"李鑫鑫","can_delete":false,"product_type":"c1","uid":1169021,"ip_address":"","ucode":"BEC451BFBEFD25","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/7d/4b09b0bf.jpg","comment_is_top":false,"comment_ctime":1545146122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35904884490","product_id":100021101,"comment_content":"感觉我在浪费生命！每天写view！原来安卓还有这么好玩的东西！","like_count":8},{"had_liked":false,"id":95191,"user_name":"1874","can_delete":false,"product_type":"c1","uid":1234643,"ip_address":"","ucode":"8539390F22C015","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/d3/84c45977.jpg","comment_is_top":false,"comment_ctime":1557980422,"is_pvip":false,"replies":[{"id":"62027","content":"native堆栈对应不上java线程的堆栈的，线程id 也是对应不上的，java的堆栈是独立在虚拟机里的和native执行的堆栈对应不上，那个只能对应到虚拟机的执行栈<br>","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1576677309,"ip_address":"","comment_id":95191,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442882310","product_id":100021101,"comment_content":"老师好，通过breakpad方案获取native堆栈时能关联上java层的堆栈吗？thread id是对应不上的。根据threadname？c层子线程要是没命名应该会有很多重复吧，期待老师解答","like_count":3,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450363,"discussion_content":"native堆栈对应不上java线程的堆栈的，线程id 也是对应不上的，java的堆栈是独立在虚拟机里的和native执行的堆栈对应不上，那个只能对应到虚拟机的执行栈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576677309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51036,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1545103686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14430005574","product_id":100021101,"comment_content":"绍文老师 ，android 系统里面没有 jstack 要如何dump 出 thread 信息呢？麻烦老师指导下~","like_count":3},{"had_liked":false,"id":51189,"user_name":"X","can_delete":false,"product_type":"c1","uid":1150623,"ip_address":"","ucode":"BA4C2F83953C54","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erxia5dpTeXMHR1e4ibicyRkS6fAuxarFicFZ3kwlrosFszjazFDJaRrrAiaH9hX0ia45xTKE6GetKIrgqg/132","comment_is_top":false,"comment_ctime":1545128997,"is_pvip":false,"replies":[{"id":"18443","content":"1. 数据库要case by case <br>2. Sigquit是卡在当前进程操作，黑科技是卡在子进程操作<br>3. 服务端","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1545131040,"ip_address":"","comment_id":51189,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10135063589","product_id":100021101,"comment_content":"老师好，工作中的确遇到过类似开篇描述的卡顿现场，只不过当时是操作一个三方数据库，主线程里初始化了数据库有关的实体对象，然后又进行了数据库异步查找，结果ANR. 查看源码发现，两个操作都用的该数据库核心类的类锁，导致主线程一直等待子线程是释放锁。这个不是线上的，是线下的，所以查找很快，解决方式是把把异步查找用handler  post了一个runnable去操作，确保主线程初始化该数据库的操作在这个异步查找之前，即先得到锁。<br>所以这里顺便问下：<br>1.上述线程抢占导致的ANR处理方法是否妥当？<br>2. 文中说到SIGQUIT性能差，那个不是模仿系统ANR机制么 ，而那个黑科技黑科技也是模仿ANR日志打印，为何就比前者好呢？<br>3.另外想问下那个文中提到的抽样是客户端控制还是服务端控制的啊？","like_count":2,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433333,"discussion_content":"1. 数据库要case by case \n2. Sigquit是卡在当前进程操作，黑科技是卡在子进程操作\n3. 服务端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545131040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114984,"user_name":"Geek_2d38e3","can_delete":false,"product_type":"c1","uid":1163126,"ip_address":"","ucode":"9E2CB54C2A7822","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0lTtM624ia8QlghIm9yfGLvjFltC03TgWlfuNC8vLibnuD8sosTcb3ynR5F2gANq1fwMPh4EiakbRVT8I59YKYjCg/132","comment_is_top":false,"comment_ctime":1563442149,"is_pvip":false,"replies":[{"id":"62054","content":"需要慢慢调试一下哈，是可以实现的","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1576679664,"ip_address":"","comment_id":114984,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5858409445","product_id":100021101,"comment_content":"张老师，请教一下，黑科技手机线程堆栈那个方案，我成功调用了DumpState函数，但是函数执行完毕后，传入的std::ostream里面没有内容，您有遇到过这种情况吗？","like_count":1,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458913,"discussion_content":"需要慢慢调试一下哈，是可以实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576679664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1426485,"avatar":"https://static001.geekbang.org/account/avatar/00/15/c4/35/e4b77fde.jpg","nickname":"Steven","note":"","ucode":"A330FBF1895161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236679,"discussion_content":"有demo可以看看么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587115349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53574,"user_name":"Fred","can_delete":false,"product_type":"c1","uid":1010991,"ip_address":"","ucode":"9B69B33F17D0DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/2f/ed8db646.jpg","comment_is_top":false,"comment_ctime":1545697187,"is_pvip":false,"replies":[{"id":"19462","content":"通过第七章systrace的方法可以分析具体的差异情况","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1545700193,"ip_address":"","comment_id":53574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5840664483","product_id":100021101,"comment_content":"老师好，在应用开发时发现同一个方法，拥有相同的输入参数，在不同的Activity里面执行的耗时会不一样。对于这个问题应该从那些角度去分析呢？","like_count":1,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434188,"discussion_content":"通过第七章systrace的方法可以分析具体的差异情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545700193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360796,"user_name":"自在飞","can_delete":false,"product_type":"c1","uid":1167825,"ip_address":"北京","ucode":"A2712148DA06E0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","comment_is_top":false,"comment_ctime":1666858291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666858291","product_id":100021101,"comment_content":"老师您好，请问【通过 Hook 方式】获取的ANR日志，是怎么读取的呢？高版本系统中不是已经没有权限读取 &#47;data&#47;anr&#47;traces.txt 文件了么？","like_count":0},{"had_liked":false,"id":360324,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"日本","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1666429363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666429363","product_id":100021101,"comment_content":"衡量页面流畅度：丢帧率、冻帧率<br><br>卡顿现场信息：卡断堆栈（摒弃具体耗时堆栈聚合成卡顿树）、CPU使用率及调度信息、内存信息、GC信息、IO和网络相关、当前页面信息、操作路径等","like_count":0},{"had_liked":false,"id":279909,"user_name":"lxw","can_delete":false,"product_type":"c1","uid":1136748,"ip_address":"","ucode":"232FA3E5CC4782","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/6c/6fe7614b.jpg","comment_is_top":false,"comment_ctime":1613999101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613999101","product_id":100021101,"comment_content":"hook线程创建之后，怎么拿到hook的线程的信息呢","like_count":0},{"had_liked":false,"id":206833,"user_name":"张训博-forrest","can_delete":false,"product_type":"c1","uid":1331072,"ip_address":"","ucode":"9A50F9BD3FFDE1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIdTsqPhlVH3TFElzic8422uBDelRjYiaktCJRmIRpLrgBBfBKnSO9PlbHibnHAc9cQEmLHes3fayEw/132","comment_is_top":false,"comment_ctime":1586942870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586942870","product_id":100021101,"comment_content":"fork 进程按理说要权限 普通的方式感觉不行","like_count":0},{"had_liked":false,"id":186626,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1583893218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583893218","product_id":100021101,"comment_content":"“这里我非常推荐卡顿树的做法，对于超过 3 秒的卡顿，具体是 4 秒还是 10 秒，这涉及手机性能和当时的环境。我们决定抛弃具体的耗时，只按照相同堆栈出现的比例来聚合。这样我们从一棵树上面，就可以看到哪些堆栈出现的卡顿问题最多，它下面又存在的哪些分支。”<br><br>这里有两个疑问：<br>1. 这里的聚合是在客户端上进行的吗？<br>2. 根据什么来判断卡顿堆栈是相同的呢？不同系统、机型上，同一个卡顿问题的堆栈可能也不一样吧","like_count":0},{"had_liked":false,"id":186623,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1583892876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583892876","product_id":100021101,"comment_content":"“热锁”，是不是就是“活锁”","like_count":0},{"had_liked":false,"id":176667,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1581134011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581134011","product_id":100021101,"comment_content":"获取线程堆栈时，文中提到：“需要注意的是在 Android 7.0，getAllStackTraces 是不会返回主线程的堆栈的”，那在Android 7.0上，该如何做呢？","like_count":0},{"had_liked":false,"id":151467,"user_name":"Tony","can_delete":false,"product_type":"c1","uid":1432723,"ip_address":"","ucode":"E30A96891AE98F","user_header":"https://static001.geekbang.org/account/avatar/00/15/dc/93/3521ff2b.jpg","comment_is_top":false,"comment_ctime":1573725734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573725734","product_id":100021101,"comment_content":"老师我想问下应用自己不适用JNI层代码去fork子进程，使用android上层框架，比如java或者Kotlin语言的api如何fork应用的子进程出来，网上也看了一些，都是通过JNI层c++代码去fork的","like_count":0},{"had_liked":false,"id":135404,"user_name":"薯条","can_delete":false,"product_type":"c1","uid":1334064,"ip_address":"","ucode":"08E591FC62563A","user_header":"https://static001.geekbang.org/account/avatar/00/14/5b/30/83104f0f.jpg","comment_is_top":false,"comment_ctime":1569147555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569147555","product_id":100021101,"comment_content":"学习了，坚持打卡，走完整个课程","like_count":0},{"had_liked":false,"id":135391,"user_name":"朱刚","can_delete":false,"product_type":"c1","uid":1080311,"ip_address":"","ucode":"74FD5C1E5C05C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/f7/21fb7574.jpg","comment_is_top":false,"comment_ctime":1569144319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569144319","product_id":100021101,"comment_content":"案例的最终解决方案呢","like_count":0},{"had_liked":false,"id":80209,"user_name":"1874","can_delete":false,"product_type":"c1","uid":1234643,"ip_address":"","ucode":"8539390F22C015","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/d3/84c45977.jpg","comment_is_top":false,"comment_ctime":1553623330,"is_pvip":false,"replies":[{"id":"31131","content":"主要是通过Hook跟日志，定位是哪些view的问题","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1555401215,"ip_address":"","comment_id":80209,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553623330","product_id":100021101,"comment_content":"老师好，在native层hook子进程获取java堆栈的Demo能放出来吗？期待","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444785,"discussion_content":"主要是通过Hook跟日志，定位是哪些view的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555401215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69740,"user_name":"catkin","can_delete":false,"product_type":"c1","uid":1127815,"ip_address":"","ucode":"2E7ECACBC30CEC","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/87/b2a1e5cc.jpg","comment_is_top":false,"comment_ctime":1550823739,"is_pvip":false,"replies":[{"id":"24818","content":"什么意思？fork机制在很多场景都有使用，android系统也是这样。","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1550830040,"ip_address":"","comment_id":69740,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550823739","product_id":100021101,"comment_content":"张老师，文中说的fork进程收集，但是在高版本中好像fork出来的进程不能执行啊！","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440257,"discussion_content":"什么意思？fork机制在很多场景都有使用，android系统也是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550830040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57164,"user_name":"sjx","can_delete":false,"product_type":"c1","uid":1159226,"ip_address":"","ucode":"C23BC7808A89F2","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/3a/544179bf.jpg","comment_is_top":false,"comment_ctime":1546670121,"is_pvip":false,"replies":[{"id":"23095","content":"需要进一步拆解下去具体的原因，是哪些步骤耗时","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1549101872,"ip_address":"","comment_id":57164,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546670121","product_id":100021101,"comment_content":"项目中使用的lottie，CPU占用非常高，大家有什么解决方案吗？","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435439,"discussion_content":"需要进一步拆解下去具体的原因，是哪些步骤耗时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549101872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55853,"user_name":"Juinn","can_delete":false,"product_type":"c1","uid":1334226,"ip_address":"","ucode":"257796850A6CD9","user_header":"https://static001.geekbang.org/account/avatar/00/14/5b/d2/34a8c79c.jpg","comment_is_top":false,"comment_ctime":1546328971,"is_pvip":false,"replies":[{"id":"20132","content":"plt hook只能hook本进程的，对其他进程是无效的","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1546350011,"ip_address":"","comment_id":55853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546328971","product_id":100021101,"comment_content":"shaowen老师，课后作业中，hook线程的创建，为什么只有在sample进程有效，so库不是共享的吗","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434861,"discussion_content":"plt hook只能hook本进程的，对其他进程是无效的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546350011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55821,"user_name":"Juinn","can_delete":false,"product_type":"c1","uid":1334226,"ip_address":"","ucode":"257796850A6CD9","user_header":"https://static001.geekbang.org/account/avatar/00/14/5b/d2/34a8c79c.jpg","comment_is_top":false,"comment_ctime":1546317418,"is_pvip":false,"replies":[{"id":"20147","content":"收集卡顿堆栈，然后在后台根据堆栈聚合得到的","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1546389661,"ip_address":"","comment_id":55821,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546317418","product_id":100021101,"comment_content":"shaowen老师，此章节的例子是基于有卡顿树情况下，再去分析，那么这个卡顿树怎么获取？","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434851,"discussion_content":"收集卡顿堆栈，然后在后台根据堆栈聚合得到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546389661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53305,"user_name":"Geek_295233","can_delete":false,"product_type":"c1","uid":1136875,"ip_address":"","ucode":"AD406546A1EB21","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/eb/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1545623983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545623983","product_id":100021101,"comment_content":"实践见真理，开阔了视野","like_count":0},{"had_liked":false,"id":52142,"user_name":"欧哩給","can_delete":false,"product_type":"c1","uid":1173812,"ip_address":"","ucode":"496AE288A03640","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoWicVeQYJ5B3hK2A51QO2hQUTpjkxhzYfjMD7ibk3YALgNypho185ZDrSItVNORQV2PU8qxD5IJONQ/132","comment_is_top":false,"comment_ctime":1545318921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545318921","product_id":100021101,"comment_content":"老师，关于Android的内存管理与GC，有推荐的书籍或者博客吗？","like_count":0},{"had_liked":false,"id":51553,"user_name":"废帅","can_delete":false,"product_type":"c1","uid":1330975,"ip_address":"","ucode":"34774766A7531A","user_header":"https://static001.geekbang.org/account/avatar/00/14/4f/1f/7dd61bfd.jpg","comment_is_top":false,"comment_ctime":1545198886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545198886","product_id":100021101,"comment_content":"现在学的还是糊涂的，先坚持打卡吧","like_count":0},{"had_liked":false,"id":51481,"user_name":"null","can_delete":false,"product_type":"c1","uid":1334619,"ip_address":"","ucode":"95420BEB63C6AA","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/5b/9b1dc56d.jpg","comment_is_top":false,"comment_ctime":1545188163,"is_pvip":false,"replies":[{"id":"18627","content":"要看具体版本跟代码","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1545192608,"ip_address":"","comment_id":51481,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545188163","product_id":100021101,"comment_content":"老师，我主线程调用 synchronized时，显示的是Monitor状态，查过之后，&quot;Monitor&quot; is the BLOCKED state，只是名字不同，实际是一种状态是吗？","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433475,"discussion_content":"要看具体版本跟代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545192608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51183,"user_name":"嘿，抬头","can_delete":false,"product_type":"c1","uid":1328797,"ip_address":"","ucode":"1D36F7BA8C128F","user_header":"https://static001.geekbang.org/account/avatar/00/14/46/9d/79edce49.jpg","comment_is_top":false,"comment_ctime":1545127163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545127163","product_id":100021101,"comment_content":"虽然不理解的很多，还是坚持看，多看几遍多实践吧😂","like_count":0},{"had_liked":false,"id":51055,"user_name":"Kenny","can_delete":false,"product_type":"c1","uid":1234061,"ip_address":"","ucode":"E57D67DCE27967","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/8d/a3fd8957.jpg","comment_is_top":false,"comment_ctime":1545107541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545107541","product_id":100021101,"comment_content":"张老师，线程的用户时间跟系统时间有什么关联？系统时间是不是一定小于用户时间？","like_count":0},{"had_liked":false,"id":51012,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1545098923,"is_pvip":false,"replies":[{"id":"18344","content":"参考链接有写，timewaiting是有timeout超时的，waiting没有","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1545100356,"ip_address":"","comment_id":51012,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545098923","product_id":100021101,"comment_content":"张老师 waiting 和 timewaiting 区别是什么呢","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433229,"discussion_content":"参考链接有写，timewaiting是有timeout超时的，waiting没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545100356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}