{"id":741034,"title":"第 12 章 shell脚本","content":"\n<p>shell脚本在Linux系统管理员的运维工作中非常重要，下面就让阿铭带你正式进入shell脚本的世界吧！</p>\n<h2 id=\"nav_point_220\">12.1 什么是shell脚本</h2>\n<p>shell脚本并不能作为正式的编程语言，因为它是在Linux的shell中运行的，所以称为shell脚本。事实上，shell脚本就是一些命令的集合。比如，我想实现这样的操作：</p>\n<p>(1) 进入 /tmp/ 目录；</p>\n<p>(2) 列出当前目录中所有的文件名；</p>\n<p>(3) 把所有当前的文件都复制到 /root/ 目录下；</p>\n<p>(4) 删除当前目录下所有的文件。</p>\n<p>完成以上简单的4步需要在shell窗口中输入4次命令，按4次回车，这不算太难。但如果是输入复杂的命令，一次一次敲键盘就会很麻烦。所以我们不妨把所有的操作都记录到一个文档中，然后去调用此文档中的命令，这样一步操作就可以完成。其实这个文档就是shell脚本，只是这个shell脚本有它特殊的格式。</p>\n<p>shell脚本能帮助我们很方便地管理服务器，因为我们可以指定一个任务计划，定时去执行某个shell脚本来满足需求。这对于Linux系统管理员来说是一件非常值得自豪的事情。我们可以在Linux服务器上部署监控的shell脚本，然后脚本中可以加上邮件通知来告之自己出现故障。比如，网卡流量出现异常或者Web服务器停止服务时，就可以发一封邮件给管理员。这样可以让管理员及时知道服务器出问题了。</p><!-- [[[read_end]]] -->\n<p>在正式编写shell脚本之前，阿铭建议凡是自定义的脚本都放到 /usr/local/sbin/ 目录下。这样做的目的是：一来可以更好地管理文档；二来以后接管你工作的管理员都知道自定义脚本放在哪里，方便维护。</p>\n<h3 id=\"nav_point_221\">12.1.1 shell脚本的创建和执行</h3>\n<p>下面请跟着阿铭编写第一个shell脚本，如下所示：</p>\n<pre class=\"code-rows\"><code># cd /usr/local/sbin/\n# vim first.sh // 加入如下内容\n#! /bin/bash\n\n## This is my first shell script.\n## Writen by Aming 2020-03-02.\n\ndate\necho \"Hello world!\"</code></pre>\n<p>shell脚本通常以.sh为后缀名。这并不是说不加.sh的脚本就不能执行，只是大家都有这样一个习惯而已。所以，以后如果发现了以.sh为后缀的文件，那么只能说它可能是一个shell脚本。本例中，脚本文件first.sh的第1行要以<code>#! /bin/bash</code>开头，表示该文件使用的是bash语法。如果不设置该行，你的shell脚本也可以执行，但是不符合规范。<code>#</code>表示注释，后面跟一些该脚本的相关注释内容，以及作者、创建日期或者版本等。当然，这些注释并非必需的，但阿铭不建议省略。因为随着工作时间的逐渐过渡，写的shell脚本也会越来越多，如果有一天你回头查看自己写过的某个脚本，很有可能忘记该脚本是用来干什么的以及什么时候写的，所以写上注释是有必要的。另外，系统管理员并非只有你一个，写上注释有助于其他管理员查看你的脚本。</p>\n<p>下面我们执行一下这个脚本，如下所示：</p>\n<pre class=\"code-rows\"><code># sh first.sh\nMon Mar 2 22:16:56 CST 2020\nHello world!</code></pre>\n<p>其实shell脚本还有一种执行方法，如下所示：</p>\n<pre class=\"code-rows\"><code># ./first.sh\n-bash: ./first.sh: 权限不够\n# chmod +x first.sh\n# ./first.sh\nMon Mar 2 22:16:56 CST 2020\nHello world!</code></pre>\n<p>使用该方法运行shell脚本的前提是脚本本身有执行权限，所以需要给脚本加一个<code>x</code>权限。另外，使用<code>sh</code>命令执行一个shell脚本时，可以加<code>-x</code>选项来查看这个脚本的执行过程，这样有利于我们调试这个脚本。如下所示：</p>\n<pre class=\"code-rows\"><code># sh -x first.sh\n+ date\nMon Mar 2 22:17:43 CST 2020\n+ echo 'Hello world!'\nHello world!</code></pre>\n<p>本例中有一个<code>date</code>命令，之前阿铭从未介绍过，这个命令在shell脚本中使用非常频繁，因此有必要介绍一下它的用法。</p>\n<h3 id=\"nav_point_222\">12.1.2 命令<code>date</code></h3>\n<p><code>date</code>命令在shell脚本中最常用的几个用法如下。</p>\n<ul>\n<li><strong><code>date +%Y</code></strong>：表示以四位数字格式打印年份。</li>\n<li><strong><code>date +%y</code></strong>：表示以两位数字格式打印年份。</li>\n<li><strong><code>date +%m</code></strong>：表示月份。</li>\n<li><strong><code>date +%d</code></strong>：表示日期。</li>\n<li><strong><code>date +%H</code></strong>：表示小时。</li>\n<li><strong><code>date +%M</code></strong>：表示分钟。</li>\n<li><strong><code>date +%S</code></strong>：表示秒。</li>\n<li><strong><code>date +%w</code></strong>：表示星期。结果显示<code>0</code>则表示周日。</li>\n</ul>\n<p>下面阿铭举几个比较实用的例子来帮助你掌握<code>date</code>命令的用法，示例代码如下：</p>\n<pre class=\"code-rows\"><code># date +\"%Y-%m-%d %H:%M:%S\"\n2020-03-02 22:18:03</code></pre>\n<p>有时，在脚本中会用到一天前的日期，如下所示：</p>\n<pre class=\"code-rows\"><code># date -d \"-1 day\" +%d\n01</code></pre>\n<p>或者一小时前，如下所示：</p>\n<pre class=\"code-rows\"><code># date -d \"-1 hour\" +%H\n21</code></pre>\n<p>甚至一分钟前，如下所示：</p>\n<pre class=\"code-rows\"><code># date -d \"-1 min\" +%M\n17</code></pre>\n<h2 id=\"nav_point_223\">12.2 shell脚本中的变量</h2>\n<p>在shell脚本中使用变量会使我们的脚本更加专业，更像是一门语言。如果你写了一个长达1000行的shell脚本，并且脚本中多次出现某一个命令或者路径，而你觉得路径不对想修改一下，就得一个一个修改，或者使用批量替换的命令修改。这样做很麻烦，并且脚本也显得臃肿了很多。变量就是用来解决这个问题的。定义变量的格式为：“变量名<code>=</code>变量的值”。在脚本中引用变量时需要加上符号<code>$</code>，这跟前面介绍的在shell中自定义变量是一致的。</p>\n<p>下面我们编写第一个与变量相关的脚本，如下所示：</p>\n<pre class=\"code-rows\"><code># vim variable.sh\n#! /bin/bash\n\n## In this script we will use variables.\n## Writen by Aming 2020-03-02.\n\nd=`date +%H:%M:%S`\necho \"The script begin at $d.\"\necho \"Now we'll sleep 2 seconds.\"\nsleep 2\nd1=`date +%H:%M:%S`\necho \"The script end at $d1.\"</code></pre>\n<p>本例中使用到了反引号，它的作用是将引号中的字符串当成shell命令执行，返回命令的执行结果。<code>d</code>和<code>d1</code>在脚本中作为变量出现。</p>\n<p>下面来看看该脚本的执行结果，如下所示：</p>\n<pre class=\"code-rows\"><code># sh variable.sh\nThe script begin at 22:23:04.\nNow we'll sleep 2 seconds.\nThe script end at 22:23:06.</code></pre>\n<h3 id=\"nav_point_224\">12.2.1 数学运算</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># vim sum.sh\n#! /bin/bash\n\n## For get the sum of two numbers.\n## Aming 2020-03-02.\n\na=1\nb=2\nsum=$[$a+$b]\necho \"$a+$b=$sum\"</code></pre>\n<p>数学计算要用<code>[ ]</code>括起来，并且前面要加符号<code>$</code>。该脚本的结果如下：</p>\n<pre class=\"code-rows\"><code># sh sum.sh\n1+2=3</code></pre>\n<h3 id=\"nav_point_225\">12.2.2 和用户交互</h3>\n<p>示例脚本如下：</p>\n<pre class=\"code-rows\"><code># cat read.sh\n#! /bin/bash\n\n## Using 'read' in shell script.\n## Aming 2020-03-02.\n\nread -p \"Please input a number: \" x\nread -p \"Please input another number: \" y\nsum=$[$x+$y]\necho \"The sum of the two numbers is: $sum\"</code></pre>\n<p><code>read</code>命令用于和用户交互，它把用户输入的字符串作为变量值。该脚本的执行过程如下：</p>\n<pre class=\"code-rows\"><code># sh read.sh\nPlease input a number: 2\nPlease input another number: 10\nThe sum of the two numbers is: 12</code></pre>\n<p>我们不妨加上<code>-x</code>选项再来看看这个执行过程：</p>\n<pre class=\"code-rows\"><code># sh -x read.sh\n+ read -p 'Please input a number: ' x\nPlease input a number: 22\n+ read -p 'Please input another number: ' y\nPlease input another number: 13\n+ sum=35\n+ echo 'The sum of the two numbers is: 35'\nThe sum of the two numbers is: 35</code></pre>\n<h3 id=\"nav_point_226\">12.2.3 shell脚本预设变量</h3>\n<p>有时我们会用到类似<code>/etc/init.d/iptables restart</code>（该命令来源于早期CentOS系统）的命令，其中前面的/etc/init.d/iptables文件其实就是一个shell脚本。脚本后面为什么可以跟一个<code>restart</code>字符串呢？这就涉及shell脚本的预设变量了。实际上，shell脚本在执行时，后面可以跟一个或者多个参数。比如下面的脚本：</p>\n<pre class=\"code-rows\"><code># vim option.sh // 内容如下\n#! /bin/bash\n\nsum=$[$1+$2]\necho \"sum=$sum\"</code></pre>\n<p>该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh -x option.sh 1 2\n+ sum=3\n+ echo sum=3\nsum=3</code></pre>\n<p>你可能会问：脚本中的<code>$1</code>和<code>$2</code>是从哪里来的？这其实就是shell脚本的预设变量。本例中，<code>$1</code>和<code>$2</code>的值就是在执行时分别输入的<code>1</code>和<code>2</code>，<code>$1</code>就是脚本的第一个参数，<code>$2</code>是脚本的第二个参数，以此类推。当然一个shell脚本的预设变量是没有限制的。</p>\n<p>另外还有一个<code>$0</code>，它代表脚本本身的名字。我们不妨把脚本修改一下，如下所示：</p>\n<pre class=\"code-rows\"><code>#! /bin/bash\n\necho \"$1 $2 $0\"</code></pre>\n<p>该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh option.sh 1 2\n1 2 option.sh</code></pre>\n<h2 id=\"nav_point_227\">12.3 shell脚本中的逻辑判断</h2>\n<p>如果你学过C等语言，相信你不会对<code>if</code>感到陌生。在shell脚本中，我们同样可以使用<code>if</code>逻辑判断。</p>\n<h3 id=\"nav_point_228\">12.3.1 不带<code>else</code></h3>\n<p>具体格式如下：</p>\n<pre class=\"code-rows\"><code>if 判断语句; then\n command\nfi</code></pre>\n<p>示例脚本如下：</p>\n<pre class=\"code-rows\"><code># cat if1.sh\n#! /bin/bash\n\nread -p \"Please input your score: \" a\nif ((a&lt;60)); then\n echo \"You didn't pass the exam.\"\nfi</code></pre>\n<p><code>if1.sh</code>中出现了<code>((a&lt;60))</code>这样的形式，这是shell脚本中特有的格式，只用一个小括号或者不用都会报错，请记住这个格式。阿铭还会用另外一种格式，后面会介绍到。</p>\n<p>该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh if1.sh\nPlease input your score: 90\n# sh if1.sh\nPlease input your score: 33\nYou didn't pass the exam.</code></pre>\n<h3 id=\"nav_point_229\">12.3.2 带有<code>else</code></h3>\n<p>具体格式如下：</p>\n<pre class=\"code-rows\"><code>if 判断语句; then\n command\nelse\n command\nfi</code></pre>\n<p>示例脚本如下：</p>\n<pre class=\"code-rows\"><code># vim if2.sh // 内容如下\n#! /bin/bash\n\nread -p \"Please input your score: \" a\nif ((a&lt;60)); then\n echo \"You didn't pass the exam.\"\nelse\n echo \"Good! You passed the exam.\"\nfi</code></pre>\n<p>该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh if2.sh\nPlease input your score: 80\nGood! You passed the exam.\n# sh if2.sh\nPlease input your score: 25\nYou didn't pass the exam.</code></pre>\n<p>脚本if2.sh和脚本if1.sh唯一的区别是：如果输入大于或等于60的数字时会有提示。</p>\n<h3 id=\"nav_point_230\">12.3.3 带有<code>elif</code></h3>\n<p>具体格式如下：</p>\n<pre class=\"code-rows\"><code>if 判断语句1; then\n command\nelif 判断语句2; then\n command\nelse\n command\nfi</code></pre>\n<p>示例脚本如下：</p>\n<pre class=\"code-rows\"><code># vim if3.sh // 内容如下\n#! /bin/bash\n\nread -p \"Please input your score: \" a\nif ((a&lt;60)); then\n echo \"You didn't pass the exam.\"\nelif ((a&gt;=60)) &amp;&amp; ((a&lt;85)); then\n echo \"Good! You pass the exam.\"\nelse\n echo \"Very good! Your score is very high!\"\nfi</code></pre>\n<p>这里的<code>&amp;&amp;</code>表示“并且”的意思，当然也可以使用<code>||</code>表示“或者”。</p>\n<p>该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh if3.sh\nPlease input your score: 90\nVery good! Your score is very high!\n# sh if3.sh\nPlease input your score: 60\nGood! You pass the exam.</code></pre>\n<p>以上只是简单介绍了<code>if</code>语句的结构。判断数值大小除了可以用<code>(())</code>的形式外，还可以使用<code>[]</code>。但是不能使用<code>&gt;</code>、<code>&lt;</code>、<code>=</code>这样的符号了，要使用<code>-lt</code>（小于）、<code>-gt</code>（大于）、<code>-le</code>（小于或等于）、<code>-ge</code>（大于或等于）、<code>-eq</code>（等于）、<code>-ne</code>（不等于）。下面阿铭就以命令行的形式简单比较一下，不再写shell脚本。示例代码如下：</p>\n<pre class=\"code-rows\"><code># a=10; if [ $a -lt 5 ]; then echo ok; fi\n# a=10; if [ $a -gt 5 ]; then echo ok; fi\nok\n# a=10; if [ $a -ge 10 ]; then echo ok; fi\nok\n# a=10; if [ $a -eq 10 ]; then echo ok; fi\nok\n# a=10; if [ $a -ne 10 ]; then echo ok; fi</code></pre>\n<p>下面是在<code>if</code>语句中使用<code>&amp;&amp;</code>和<code>||</code>的情况，示例代码如下：</p>\n<pre class=\"code-rows\"><code># a=10; if [ $a -lt 1 ] || [ $a -gt 5 ]; then echo ok; fi\nok\n# a=10; if [ $a -gt 1 ] || [ $a -lt 10 ]; then echo ok; fi\nok</code></pre>\n<h3 id=\"nav_point_231\">12.3.4 和文件相关的判断</h3>\n<p>shell脚本中<code>if</code>还经常用于判断文件的属性，比如判断文件是普通文件还是目录，判断文件是否有读、写、执行权限等。<code>if</code>常用的选项有以下几个。</p>\n<ul>\n<li><strong><code>-e</code></strong>：判断文件或目录是否存在。</li>\n<li><strong><code>-d</code></strong>：判断是不是目录以及目录是否存在。</li>\n<li><strong><code>-f</code></strong>：判断是不是普通文件以及普通文件是否存在。</li>\n<li><strong><code>-r</code></strong>：判断是否有读权限。</li>\n<li><strong><code>-w</code></strong>：判断是否有写权限。</li>\n<li><strong><code>-x</code></strong>：判断是否可执行。</li>\n</ul>\n<p>使用<code>if</code>判断时的具体格式如下：</p>\n<pre class=\"code-rows\"><code>if [ -e filename ] ; then\n command\nfi</code></pre>\n<p>示例代码如下：</p>\n<pre class=\"code-rows\"><code># if [ -d /home/ ]; then echo ok; fi\nok\n# if [ -f /home/ ]; then echo ok; fi</code></pre>\n<p>因为/home/是目录而非文件，所以并不会显示<code>ok</code>。其他示例如下所示：</p>\n<pre class=\"code-rows\"><code># if [ -f /root/test.txt ]; then echo ok; fi\nok\n# if [ -r /root/test.txt ]; then echo ok; fi\nok\n# if [ -w /root/test.txt ]; then echo ok; fi\nok\n# if [ -x /root/test.txt ]; then echo ok; fi\n# if [ -e /root/test1.txt ]; then echo ok; fi</code></pre>\n<h3 id=\"nav_point_232\">12.3.5 <code>case</code>逻辑判断</h3>\n<p>在shell脚本中，除了用<code>if</code>来判断逻辑外，还有一种常用的方式——<code>case</code>。其具体格式如下：</p>\n<pre class=\"code-rows\"><code>case 变量 in\nvalue1)\n command\n ;;\nvalue2)\n command\n ;;\nvalue3)\n command\n ;;\n*)\n command\n ;;\nesac</code></pre>\n<p>上面的结构中，不限制<code>value</code>的个数，<code>*</code>代表其他值。下面阿铭写一个判断输入数值是奇数还是偶数的脚本，如下所示：</p>\n<pre class=\"code-rows\"><code># vim case.sh // 内容如下\n#! /bin/bash\n\nread -p \"Input a number: \" n\na=$[$n%2]\ncase $a in\n 1)\n echo \"The number is odd.\"\n ;;\n 0)\n echo \"The number is even.\"\n ;;\n *)\n echo \"It's not a number!\"\n ;;\nesac</code></pre>\n<p>脚本中<code>$a</code>的值为<code>1</code>或<code>0</code>，其执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh case.sh\nInput a number: 100\nThe number is even.\n# sh case.sh\nInput a number: 101\nThe number is odd.</code></pre>\n<h2 id=\"nav_point_233\">12.4 shell脚本中的循环</h2>\n<p>shell脚本可以算是一种简易的编程语言，脚本中的循环也是不能缺少的。常用到的循环有<code>for</code>循环和<code>while</code>循环，下面我们就分别介绍一下这两种循环结构。</p>\n<h3 id=\"nav_point_234\">12.4.1 <code>for</code>循环</h3>\n<p><code>for</code>循环结构是阿铭在日常运维工作中使用最频繁的循环结构。下面阿铭先写个简单的<code>for</code>循环脚本，如下所示：</p>\n<pre class=\"code-rows\"><code># vim for.sh // 内容如下\n#! /bin/bash\n\nfor i in `seq 1 5`; do\n echo $i\ndone</code></pre>\n<p>脚本中的<code>seq 1 5</code>表示从<code>1</code>到<code>5</code>的一个序列。你可以直接运行这个命令试一下。该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh for.sh\n1\n2\n3\n4\n5</code></pre>\n<p>通过这个脚本就可以看到<code>for</code>循环的基本结构，具体格式如下：</p>\n<pre class=\"code-rows\"><code>for 变量名 in 循环的条件; do\n command\ndone</code></pre>\n<p>这里“循环的条件”可以是一组字符串或者数字（用一个或者多个空格隔开）,也可以是一条命令的执行结果。为了方便演示，阿铭以一条命令的形式给大家举例，命令如下：</p>\n<pre class=\"code-rows\"><code># for i in 1 2 3 a b; do echo $i; done\n1\n2\n3\na\nb</code></pre>\n<p>“循环的条件”还可以引用系统命令的执行结果（如<code>seq 1 5</code>），但必须用反引号括起来。示例命令如下：</p>\n<pre class=\"code-rows\"><code># for file in `ls`; do echo $file; done\ncase.sh\nfirst.sh\nfor.sh\nif1.sh\nif2.sh\nif3.sh\noption.sh\nread.sh\nsum.sh\nvariable.sh</code></pre>\n<h3 id=\"nav_point_235\">12.4.2 <code>while</code>循环</h3>\n<p>阿铭常常用<code>while</code>循环来编写死循环的脚本，用于监控某项服务。<code>while</code>循环的格式也很简单，如下所示：</p>\n<pre class=\"code-rows\"><code>while 条件; do\n command\ndone</code></pre>\n<p>示例脚本如下：</p>\n<pre class=\"code-rows\"><code># cat while.sh\n#! /bin/bash\n\na=5\nwhile [ $a -ge 1 ]; do\n echo $a\n a=$[$a-1]\ndone</code></pre>\n<p>该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh while.sh\n5\n4\n3\n2\n1</code></pre>\n<p>另外，你可以用一个冒号代替循环条件，这样可以做到死循环。示例代码如下：</p>\n<pre class=\"code-rows\"><code>while :; do\n command\n sleep 3\ndone</code></pre>\n<h2 id=\"nav_point_236\">12.5 shell脚本中的函数</h2>\n<p>shell脚本中的函数就是把一段代码整理到一个小单元中，并给这个小单元命名，当用到这段代码时直接调用这个小单元的名字即可。有时候脚本中的某段代码总是重复使用，如果将这段代码写成函数，那么每次用到时直接用函数名代替即可，这样不仅节省时间还节省空间。</p>\n<p>下面阿铭写一个简单的带有函数功能的shell脚本，示例脚本如下：</p>\n<pre class=\"code-rows\"><code># vim func.sh // 内容如下\n#! /bin/bash\n\nfunction sum()\n{\n sum=$[$1+$2]\n echo $sum\n}\n\nsum $1 $2</code></pre>\n<p>该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh func.sh 1 2\n3</code></pre>\n<p>func.sh中的<code>sum()</code>为自定义的函数。在shell脚本中函数的格式如下：</p>\n<pre class=\"code-rows\"><code>function 函数名()\n{\n command1\n command2\n}</code></pre>\n<p>值得注意的是，在shell脚本中，函数一定要写在最前面，不能出现在中间或者最后。因为函数是要被调用的，如果还没有出现就被调用，肯定会出错。</p>\n<h2 id=\"nav_point_237\">12.6 shell脚本中的中断和继续</h2>\n<p>在shell脚本循环的过程中，我们难免会遇到一些特殊需求，比如当循环到某个地方时需要做一些事情，这时候很有可能需要退出循环，或者跳过本次循环，这样的需求如何实现呢？</p>\n<h3 id=\"nav_point_238\">12.6.1 <code>break</code></h3>\n<p>首先有一点你需要明白，<code>break</code>用在循环中，不管是<code>for</code>循环或者<code>while</code>循环都可以。在脚本中使用它，表示退出该层循环。之所以说层，是因为有时我们会用到嵌套循环，大循环里面还有小循环，而<code>break</code>仅仅是退出那一层循环，它的上层循环并不受影响。下面阿铭给大家写一个<code>break</code>的示例，如下所示：</p>\n<pre class=\"code-rows\"><code># vim break.sh // 内容如下\n#!/bin/bash\nfor i in `seq 1 5`\ndo\n echo $i\n if [ $i == 3 ]\n then\n break\n fi\n echo $i\ndone\necho aaaaaaa</code></pre>\n<p>此脚本中，本意是要把<code>1~5</code>数值赋予<code>i</code>，当<code>i</code>等于3时，就跳出循环，因此后面的<code>4</code>和<code>5</code>都不会再执行了。该脚本的执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh break.sh\n1\n1\n2\n2\n3\naaaaaaa</code></pre>\n<h3 id=\"nav_point_239\">12.6.2 <code>continue</code></h3>\n<p><code>continue</code>也是使用在循环中的，但和<code>break</code>不同的是，当在shell脚本中遇到<code>continue</code>时，结束的不是整个循环，而是本次循环。具体示例如下：</p>\n<pre class=\"code-rows\"><code># vim continue.sh // 内容如下\n#!/bin/bash\nfor i in `seq 1 5`\ndo\n echo $i\n if [ $i == 3 ]\n then\n continue\n fi\n echo $i\ndone\necho $i</code></pre>\n<p>脚本执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh continue.sh\n1\n1\n2\n2\n3\n4\n4\n5\n5\n5</code></pre>\n<p>当<code>i</code>等于<code>3</code>的时候，出现了<code>continue</code>，所以结束本次循环，<code>continue</code>后面的语句不再执行，继续下一次循环。</p>\n<h3 id=\"nav_point_240\">12.6.3 <code>exit</code></h3>\n<p>其实，还有一个和<code>break</code>、<code>continue</code>类似的用法，那就是<code>exit</code>，它的作用范围更大，表示直接退出整个shell脚本。示例脚本如下：</p>\n<pre class=\"code-rows\"><code># vim exit.sh // 内容如下\n#!/bin/bash\nfor i in `seq 1 5`\ndo\n echo $i\n if [ $i == 3 ]\n then\n exit\n fi\n echo $i\ndone\necho aaaaaaa</code></pre>\n<p>这个就很容易理解了，脚本执行结果如下：</p>\n<pre class=\"code-rows\"><code># sh exit.sh\n1\n1\n2\n2\n3</code></pre>\n<h2 id=\"nav_point_241\">12.7 shell脚本练习题</h2>\n<p>以上阿铭所举的例子都是最基础的，如果你想写好shell脚本就要多加练习，或者找专门介绍shell脚本的书深入地研究一下。下面阿铭将留几个shell脚本的练习题，请不要偷懒哦。</p>\n<p>(1) 编写shell脚本，计算<code>1~100</code>的和。</p>\n<p>(2) 编写shell脚本，输入一个数字<code>n</code>并计算<code>1~n</code>的和。要求：如果输入的数字小于<code>1</code>，则重新输入，直到输入正确的数字为止。</p>\n<p>(3) 编写shell脚本，把/root/目录下的所有目录（只需要一级）复制到/tmp/目录下。</p>\n<p>(4) 编写shell脚本，批量建立用户<code>user_00</code>、<code>user_01</code>...<code>user_99</code>。要求：所有用户同属于<code>users</code>组。</p>\n<p>(5) 编写shell脚本，截取文件test.log中包含关键词<code>abc</code>的行中的第1列（假设分隔符为<code>:</code>），然后把截取的数字排序（假设第1列为数字），最后打印出重复超过10次的列。</p>\n<p>(6) 编写shell脚本，判断输入的IP是否正确。要求：IP的规则是<code>n1.n2.n3.n4</code>，其中<code>1&lt;n1&lt;255</code>，<code>0&lt;n2&lt;255</code>，<code>0&lt;n3&lt;255</code>，<code>0&lt;n4&lt;255</code>）。</p>\n<p>下面是以上习题的答案，仅作参考。</p>\n<p>(1) <code># cat 1.sh</code></p>\n<pre class=\"code-rows\"><code>#! /bin/bash\n\nsum=0\nfor i in `seq 1 100`; do\n sum=$[$i+$sum]\ndone\necho $sum</code></pre>\n<p>(2) <code># cat 2.sh</code></p>\n<pre class=\"code-rows\"><code>#! /bin/bash\n\nn=0\nwhile [ $n -lt \"1\" ]; do\n read -p \"Please input a number, it must greater than \"1\":\" n\ndone\n\nsum=0\nfor i in `seq 1 $n`; do\n sum=$[$i+$sum]\ndone\necho $sum</code></pre>\n<p>(3) <code># cat 3.sh</code></p>\n<pre class=\"code-rows\"><code>#! /bin/bash\ncd /root\nfor f in `ls `; do\n if [ -d $f ] ; then\n cp -r $f /tmp/\n fi\ndone</code></pre>\n<p>(4) <code># cat 4.sh</code></p>\n<pre class=\"code-rows\"><code>#! /bin/bash\ngroupadd users\nfor i in `seq –w 0 99`; do\n useradd -g users user_0$i\ndone</code></pre>\n<blockquote>\n<p><strong>说明</strong> <code>seq -w</code>可以让序列等宽。</p>\n</blockquote>\n<p>(5) <code># cat 5.sh</code></p>\n<pre class=\"code-rows\"><code>#! /bin/bash\nawk -F':' '$0~/abc/ ' test.log &gt;/tmp/n.txt\nsort -n n.txt |uniq -c |sort -n &gt;/tmp/n2.txt\nawk '$1&gt;10 ' /tmp/n2.txt</code></pre>\n<p>(6) <code># cat 6.sh</code></p>\n<pre class=\"code-rows\"><code>#! /bin/bash\ncheckip()\n{\n if echo $1 |egrep -q '^[0-9]\\.[0-9]\\.[0-9]\\.[0-9]$'\n then\n a=`echo $1 | awk -F. ''`\n b=`echo $1 | awk -F. ''`\n c=`echo $1 | awk -F. ''`\n d=`echo $1 | awk -F. ''`\n\n for n in $a $b $c $d; do\n if [ $n -ge 255 ] || [ $n -le 0 ]; then\n echo \"the number should less than 255 and greate than 0\"\n return 2\n fi\n done\n\n else\n echo \"The IP you input is something wrong, the format is like 192.168.100.1\"\n return 1\n fi\n}\n\nrs=1\nwhile [ $rs -gt 0 ]; do\n read -p \"Please input the ip:\" ip\n checkip $ip\n rs=`echo $?`\ndone\necho \"The IP is right!\"</code></pre>\n<h2 id=\"nav_point_242\">12.8 课后习题</h2>\n<p>(1) shell脚本中，怎么把某一行当作注释？</p>\n<p>(2) 如何执行一个shell脚本呢？</p>\n<p>(3) 为了方便管理，我们约定把shell脚本都放到哪个目录下？</p>\n<p>(4) 为了更好地调试shell脚本，我们可以加哪个选项来观察shell脚本的执行过程？</p>\n<p>(5) 使用<code>date</code>命令打印5天前的日期。要求：日期格式为<em>xxxx-xx-xx</em>。</p>\n<p>(6) 请指出下面这个脚本的问题出现在哪里。</p>\n<pre class=\"code-rows\"><code>#! /bin/bash\na = 1\nb = 2\necho $a, $b</code></pre>\n<p>(7) 在shell脚本中如何使用数学运算？请举例说明。</p>\n<p>(8) shell脚本中的哪个命令可以实现脚本和用户交互？怎么使用？</p>\n<p>(9) 在shell中如何进行大小或者等于判断？</p>\n<p>(10) 在shell脚本中，用什么符号表示“并且”？用什么符号表示“或者”？</p>\n<p>(11) 在shell脚本中，<code>case</code>逻辑判断的结构是什么样的？</p>\n<p>(12) 列举shell脚本中常用的循环结构。</p>\n<p>(13) shell脚本中函数的作用是什么？函数结构是什么样的？</p>\n<p>(14) 编写一个shell脚本，在一个目录下的所有文件（不含目录）的文件名后面加“.bak”。</p>\n<p>(15) 编写一个shell脚本，将当前目录下大于100 KB的文件全部移动到/tmp/目录下。</p>\n<p>(16) 编写一个shell脚本，获取本机的HOSTNAME、IP地址以及DNS地址。</p>\n<p>(17) 编写两个小脚本，验证<code>break</code>和<code>continue</code>在循环中的作用。</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}