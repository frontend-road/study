{"id":296793,"title":"04｜ Mutex：骇客编程，如何拓展额外功能？","content":"<p>你好，我是鸟窝。</p><p>前面三讲，我们学习了互斥锁Mutex的基本用法、实现原理以及易错场景，可以说是涵盖了互斥锁的方方面面。如果你能熟练掌握这些内容，那么，在大多数的开发场景中，你都可以得心应手。</p><p>但是，在一些特定的场景中，这些基础功能是不足以应对的。这个时候，我们就需要开发一些扩展功能了。我来举几个例子。</p><p>比如说，我们知道，如果互斥锁被某个goroutine获取了，而且还没有释放，那么，其他请求这把锁的goroutine，就会阻塞等待，直到有机会获得这把锁。有时候阻塞并不是一个很好的主意，比如你请求锁更新一个计数器，如果获取不到锁的话没必要等待，大不了这次不更新，我下次更新就好了，如果阻塞的话会导致业务处理能力的下降。</p><p>再比如，如果我们要监控锁的竞争情况，一个监控指标就是，等待这把锁的goroutine数量。我们可以把这个指标推送到时间序列数据库中，再通过一些监控系统（比如Grafana）展示出来。要知道，<strong>锁是性能下降的“罪魁祸首”之一，所以，有效地降低锁的竞争，就能够很好地提高性能。因此，监控关键互斥锁上等待的goroutine的数量，是我们分析锁竞争的激烈程度的一个重要指标</strong>。</p><p>实际上，不论是不希望锁的goroutine继续等待，还是想监控锁，我们都可以基于标准库中Mutex的实现，通过Hacker的方式，为Mutex增加一些额外的功能。这节课，我就来教你实现几个扩展功能，包括实现TryLock，获取等待者的数量等指标，以及实现一个线程安全的队列。</p><!-- [[[read_end]]] --><h1>TryLock</h1><p>我们可以为Mutex添加一个TryLock的方法，也就是尝试获取排外锁。PS：在Go 1.18官方标准库中，已经为Mutex/RWMutex增加了TryLock方法。</p><p>这个方法具体是什么意思呢？我来解释一下这里的逻辑。当一个goroutine调用这个TryLock方法请求锁的时候，如果这把锁没有被其他goroutine所持有，那么，这个goroutine就持有了这把锁，并返回true；如果这把锁已经被其他goroutine所持有，或者是正在准备交给某个被唤醒的goroutine，那么，这个请求锁的goroutine就直接返回false，不会阻塞在方法调用上。</p><p>如下图所示，如果Mutex已经被一个goroutine持有，调用Lock的goroutine阻塞排队等待，调用TryLock的goroutine直接得到一个false返回。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/65/e7787d959b60d66cc3a46ee921098865.jpg?wh=2973*1913\" alt=\"\"></p><p>在实际开发中，如果要更新配置数据，我们通常需要加锁，这样可以避免同时有多个goroutine并发修改数据。有的时候，我们也会使用TryLock。这样一来，当某个goroutine想要更改配置数据时，如果发现已经有goroutine在更改了，其他的goroutine调用TryLock，返回了false，这个goroutine就会放弃更改。</p><p>很多语言（比如Java）都为锁提供了TryLock的方法，但是，Go官方<a href=\"https://github.com/golang/go/issues/6123\">issue 6123</a>有一个讨论（后来一些issue中也提到过），标准库的Mutex不会添加TryLock方法。虽然通过Go的Channel我们也可以实现TryLock的功能，但是基于Channel的实现我们会放在Channel那一讲中去介绍，这一次我们还是基于Mutex去实现，毕竟大部分的程序员还是熟悉传统的同步原语，而且传统的同步原语也不容易出错。所以这节课，还是希望带你掌握基于Mutex实现的方法。</p><p>那怎么实现一个扩展TryLock方法的Mutex呢？我们直接来看代码。</p><pre><code>// 复制Mutex定义的常量\nconst (\n    mutexLocked = 1 &lt;&lt; iota // 加锁标识位置\n    mutexWoken              // 唤醒标识位置\n    mutexStarving           // 锁饥饿标识位置\n    mutexWaiterShift = iota // 标识waiter的起始bit位置\n)\n\n// 扩展一个Mutex结构\ntype Mutex struct {\n    sync.Mutex\n}\n\n// 尝试获取锁\nfunc (m *Mutex) TryLock() bool {\n    // 如果能成功抢到锁\n    if atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)), 0, mutexLocked) {\n        return true\n    }\n\n    // 如果处于唤醒、加锁或者饥饿状态，这次请求就不参与竞争了，返回false\n    old := atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)))\n    if old&amp;(mutexLocked|mutexStarving|mutexWoken) != 0 {\n        return false\n    }\n\n    // 尝试在竞争的状态下请求锁\n    new := old | mutexLocked\n    return atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)), old, new)\n}\n</code></pre><p>第17行是一个fast path，如果幸运，没有其他goroutine争这把锁，那么，这把锁就会被这个请求的goroutine获取，直接返回。</p><p>如果锁已经被其他goroutine所持有，或者被其他唤醒的goroutine准备持有，那么，就直接返回false，不再请求，代码逻辑在第23行。</p><p>如果没有被持有，也没有其它唤醒的goroutine来竞争锁，锁也不处于饥饿状态，就尝试获取这把锁（第29行），不论是否成功都将结果返回。因为，这个时候，可能还有其他的goroutine也在竞争这把锁，所以，不能保证成功获取这把锁。</p><p>我们可以写一个简单的测试程序，来测试我们的TryLock的机制是否工作。</p><p>这个测试程序的工作机制是这样子的：程序运行时会启动一个goroutine持有这把我们自己实现的锁，经过随机的时间才释放。主goroutine会尝试获取这把锁。如果前一个goroutine一秒内释放了这把锁，那么，主goroutine就有可能获取到这把锁了，输出“got the lock”，否则没有获取到也不会被阻塞，会直接输出“<code>can't get the lock</code>”。</p><pre><code>func try() {\n    var mu Mutex\n    go func() { // 启动一个goroutine持有一段时间的锁\n        mu.Lock()\n        time.Sleep(time.Duration(rand.Intn(2)) * time.Second)\n        mu.Unlock()\n    }()\n\n    time.Sleep(time.Second)\n\n    ok := mu.TryLock() // 尝试获取到锁\n    if ok { // 获取成功\n        fmt.Println(&quot;got the lock&quot;)\n        // do something\n        mu.Unlock()\n        return\n    }\n\n    // 没有获取到\n    fmt.Println(&quot;can't get the lock&quot;)\n}\n</code></pre><h1>获取等待者的数量等指标</h1><p>接下来，我想和你聊聊怎么获取等待者数量等指标。</p><p>第二讲中，我们已经学习了Mutex的结构。先来回顾一下Mutex的数据结构，如下面的代码所示。它包含两个字段，state和sema。前四个字节（int32）就是state字段。</p><pre><code>type Mutex struct {\n    state int32\n    sema  uint32\n}\n</code></pre><p>Mutex结构中的state字段有很多个含义，通过state字段，你可以知道锁是否已经被某个goroutine持有、当前是否处于饥饿状态、是否有等待的goroutine被唤醒、等待者的数量等信息。但是，state这个字段并没有暴露出来，所以，我们需要想办法获取到这个字段，并进行解析。</p><p>怎么获取未暴露的字段呢？很简单，我们可以通过unsafe的方式实现。我来举一个例子，你一看就明白了。</p><pre><code>const (\n    mutexLocked = 1 &lt;&lt; iota // mutex is locked\n    mutexWoken\n    mutexStarving\n    mutexWaiterShift = iota\n)\n\ntype Mutex struct {\n    sync.Mutex\n}\n\nfunc (m *Mutex) Count() int {\n    // 获取state字段的值\n    v := atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)))\n    v = v &gt;&gt; mutexWaiterShift + (v &amp; mutexLocked)\n    return int(v)\n</code></pre><p>这个例子的第14行通过unsafe操作，我们可以得到state字段的值。第15行我们右移三位（这里的常量mutexWaiterShift的值为3），就得到了当前等待者的数量。如果当前的锁已经被其他goroutine持有，那么，我们就稍微调整一下这个值，加上一个1（第16行），你基本上可以把它看作是当前持有和等待这把锁的goroutine的总数。</p><p>state这个字段的第一位是用来标记锁是否被持有，第二位用来标记是否已经唤醒了一个等待者，第三位标记锁是否处于饥饿状态，通过分析这个state字段我们就可以得到这些状态信息。我们可以为这些状态提供查询的方法，这样就可以实时地知道锁的状态了。</p><pre><code>// 锁是否被持有\nfunc (m *Mutex) IsLocked() bool {\n    state := atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)))\n    return state&amp;mutexLocked == mutexLocked\n}\n\n// 是否有等待者被唤醒\nfunc (m *Mutex) IsWoken() bool {\n    state := atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)))\n    return state&amp;mutexWoken == mutexWoken\n}\n\n// 锁是否处于饥饿状态\nfunc (m *Mutex) IsStarving() bool {\n    state := atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)))\n    return state&amp;mutexStarving == mutexStarving\n}\n</code></pre><p>我们可以写一个程序测试一下，比如，在1000个goroutine并发访问的情况下，我们可以把锁的状态信息输出出来：</p><pre><code>func count() {\n    var mu Mutex\n    for i := 0; i &lt; 1000; i++ { // 启动1000个goroutine\n        go func() {\n            mu.Lock()\n            time.Sleep(time.Second)\n            mu.Unlock()\n        }()\n    }\n\n    time.Sleep(time.Second)\n    // 输出锁的信息\n    fmt.Printf(&quot;waitings: %d, isLocked: %t, woken: %t,  starving: %t\\n&quot;, mu.Count(), mu.IsLocked(), mu.IsWoken(), mu.IsStarving())\n}\n</code></pre><p>有一点你需要注意一下，在获取state字段的时候，并没有通过Lock获取这把锁，所以获取的这个state的值是一个瞬态的值，可能在你解析出这个字段之后，锁的状态已经发生了变化。不过没关系，因为你查看的就是调用的那一时刻的锁的状态。</p><h1>使用Mutex实现一个线程安全的队列</h1><p>最后，我们来讨论一下，如何使用Mutex实现一个线程安全的队列。</p><p>为什么要讨论这个话题呢？因为Mutex经常会和其他非线程安全（对于Go来说，我们其实指的是goroutine安全）的数据结构一起，组合成一个线程安全的数据结构。新数据结构的业务逻辑由原来的数据结构提供，而<strong>Mutex提供了锁的机制，<strong><strong>来</strong></strong>保证线程安全</strong>。</p><p>比如队列，我们可以通过Slice来实现，但是通过Slice实现的队列不是线程安全的，出队（Dequeue）和入队（Enqueue）会有data race的问题。这个时候，Mutex就要隆重出场了，通过它，我们可以在出队和入队的时候加上锁的保护。</p><pre><code>type SliceQueue struct {\n    data []interface{}\n    mu   sync.Mutex\n}\n\nfunc NewSliceQueue(n int) (q *SliceQueue) {\n    return &amp;SliceQueue{data: make([]interface{}, 0, n)}\n}\n\n// Enqueue 把值放在队尾\nfunc (q *SliceQueue) Enqueue(v interface{}) {\n    q.mu.Lock()\n    q.data = append(q.data, v)\n    q.mu.Unlock()\n}\n\n// Dequeue 移去队头并返回\nfunc (q *SliceQueue) Dequeue() interface{} {\n    q.mu.Lock()\n    if len(q.data) == 0 {\n        q.mu.Unlock()\n        return nil\n    }\n    v := q.data[0]\n    q.data = q.data[1:]\n    q.mu.Unlock()\n    return v\n}\n</code></pre><p>因为标准库中没有线程安全的队列数据结构的实现，所以，你可以通过Mutex实现一个简单的队列。通过Mutex我们就可以为一个非线程安全的data interface{}实现线程安全的访问。</p><h1>总结</h1><p>好了，我们来做个总结。</p><p>Mutex是package sync的基石，其他的一些同步原语也是基于它实现的，所以，我们“隆重”地用了四讲来深度学习它。学到后面，你一定能感受到，多花些时间来完全掌握Mutex是值得的。</p><p>今天这一讲我和你分享了几个Mutex的拓展功能，这些方法是不是给你带来了一种“骇客”的编程体验呢，通过Hacker的方式，我们真的可以让Mutex变得更强大。</p><p>我们学习了基于Mutex实现TryLock，通过unsafe的方式读取到Mutex内部的state字段，这样，我们就解决了开篇列举的问题，一是不希望锁的goroutine继续等待，一是想监控锁。</p><p>另外，使用Mutex组合成更丰富的数据结构是我们常见的场景，今天我们就实现了一个线程安全的队列，未来我们还会讲到实现线程安全的map对象。</p><p>到这里，Mutex我们就系统学习完了，最后给你总结了一张Mutex知识地图，帮你复习一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/0b/5ayy6cd9ec9fe0bcc13113302056ac0b.jpg?wh=2396*3131\" alt=\"\"></p><h1>思考题</h1><p>你可以为Mutex获取锁时加上Timeout机制吗？会有什么问题吗？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"03｜Mutex：4种易错场景大盘点","id":296541},"right":{"article_title":"05｜ RWMutex：读写锁的实现原理及避坑指南","id":297868}},"comments":[{"had_liked":false,"id":254134,"user_name":"Junes","can_delete":false,"product_type":"c1","uid":1354665,"ip_address":"","ucode":"CD2E829C868970","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","comment_is_top":false,"comment_ctime":1603070516,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"134747056692","product_id":100061801,"comment_content":"我来提供个思路~<br><br>最简单直接的是采用channel实现，用select监听锁和timeout两个channel，不在今天的讨论范围内。<br><br>1. 用for循环+TryLock实现：<br>先记录开始的时间，用for循环判断是否超时：没有超时则反复尝试tryLock，直到获取成功；如果超时直接返回失败。<br><br>问题：高频的CAS自旋操作，如果失败的太多，会消耗大量的CPU。<br><br>2. 优化1：TryLock的fast的拆分<br>TryLock的抢占实现分为两部分，一个是fast path，另一个是竞争状态下的，后者的cas操作很多。我会考虑减少slow方法的频率，比如调用n次fast path失败后，再调用一次整个Trylock。<br><br>3. 优化2：借鉴TCP重试机制<br>for循环中的重试增加休眠时间，每次失败将休眠时间乘以一个系数（如1.5），直到达到上限（如10ms），减少自旋带来的性能损耗","like_count":32,"discussions":[{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315772,"discussion_content":"感觉优化1反倒造成了“高频的CAS”自旋","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603326621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1354665,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","nickname":"Junes","note":"","ucode":"CD2E829C868970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315927,"discussion_content":"可能我没表述清楚，举个例子，指是原先for循环里有10次完整的TryLock，优化1是指调整为9次fast+1次完整的TryLock，减少了9次竞争状态下的自旋。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603337124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":315772,"ip_address":""},"score":315927,"extra":""}]}]},{"had_liked":false,"id":255732,"user_name":"+1day","can_delete":false,"product_type":"c1","uid":1299743,"ip_address":"","ucode":"ADF6576F46B8E6","user_header":"https://static001.geekbang.org/account/avatar/00/13/d5/1f/9fbd95ac.jpg","comment_is_top":false,"comment_ctime":1603419635,"is_pvip":false,"replies":[{"id":"93170","content":"你说的对","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603428339,"ip_address":"","comment_id":255732,"utype":1}],"discussion_count":7,"race_medal":0,"score":"91797732851","product_id":100061801,"comment_content":"老师您好，在获取等待者数量的代码中<br>如果要加上锁持有者的数量的话，为什么不是 <br>v = v &gt;&gt; mutexWaiterShift + (v &amp; mutexLocked)<br>而是<br>v = v &gt;&gt; mutexWaiterShift &#47;&#47;得到等待者的数值<br>v = v + (v &amp; mutexLocked) &#47;&#47;再加上锁持有者的数量，0或者1<br>这样呢？第一步修改了 v 的值，v 的第一位已经不再是记录该锁是否被持有了，那 v&amp;mutexLocked 是不是不对呢？","like_count":22,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507818,"discussion_content":"你说的对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603428339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1191550,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","nickname":"NULL","note":"","ucode":"2A323DD05352BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537864,"discussion_content":"一年了，正文中还是错的，倒是改改啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639230492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":507818,"ip_address":""},"score":537864,"extra":""},{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":1191550,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","nickname":"NULL","note":"","ucode":"2A323DD05352BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538058,"discussion_content":"收到，是我们和老师流程有问题，明天就处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639318893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537864,"ip_address":""},"score":538058,"extra":""}]},{"author":{"id":1364628,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/94/c7223eb8.jpg","nickname":"白志稳","note":"","ucode":"6D47A362797C6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391862,"discussion_content":"没太明白。而且内容出错应该改一下吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630662663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336864,"discussion_content":"那应该是这样才是正确的吗？\nv = v >> mutexWaiterShift + (v &amp; mutexLocked)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608719697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1029289,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b4/a9/abb7bfe3.jpg","nickname":"天涯若海","note":"","ucode":"C9ADC590034CA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318381,"discussion_content":"讲义没改，看了半天，看到评论才确认是错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603720714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336865,"discussion_content":"是不是应该正文中也修改一下呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608719716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254266,"user_name":"18","can_delete":false,"product_type":"c1","uid":2229244,"ip_address":"","ucode":"4ADE57BEA7C37C","user_header":"https://static001.geekbang.org/account/avatar/00/22/03/fc/daa02847.jpg","comment_is_top":false,"comment_ctime":1603094030,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70322570766","product_id":100061801,"comment_content":"我变秃了，也变强了","like_count":16,"discussions":[{"author":{"id":1340730,"avatar":"https://static001.geekbang.org/account/avatar/00/14/75/3a/a7596c06.jpg","nickname":"大大","note":"","ucode":"3A3DC9AC382651","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315228,"discussion_content":"恭喜你，就怕变秃了，也没变强","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1603253642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256070,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1603518943,"is_pvip":false,"replies":[{"id":"93233","content":"是的.这只是hack方式，和go的版本有关系。","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603526225,"ip_address":"","comment_id":256070,"utype":1}],"discussion_count":4,"race_medal":0,"score":"31668290015","product_id":100061801,"comment_content":"如果底层 Mutex 的 state 在某个版本中含义变了，上边写的 TryLock 和监控锁的一些方法就会失效，所以这样做是不是比较危险。","like_count":7,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507921,"discussion_content":"是的.这只是hack方式，和go的版本有关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603526225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2650754,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/pEsmmPPRZictCKpQM8ZzzWSYeWPGUloGoYLP2vjRkMY0WicxZ71avFCNZiahRCn8yxibJ3t5buoNVqL7QKHVSHD5Qg/132","nickname":"Geek_a0bef1","note":"","ucode":"A2B99F30C570DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385349,"discussion_content":"这个考虑是对的，所以有个疑问，老师文中的代码能够在生产环境使用吗？哪些代码可以在生产环境使用是不是可以加上一些标识，因为有些学习者可能不会考虑到这个层面的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627009550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623409,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c5/71/f7c43b49.jpg","nickname":"风向北吹","note":"","ucode":"2FD0BC5159E1C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332447,"discussion_content":"hack是啥意思？看文章中提到了几次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607223181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1623409,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c5/71/f7c43b49.jpg","nickname":"风向北吹","note":"","ucode":"2FD0BC5159E1C1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":382264,"discussion_content":"非正常的操作，骇客，黑客","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625491298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332447,"ip_address":""},"score":382264,"extra":""}]}]},{"had_liked":false,"id":254606,"user_name":"不二","can_delete":false,"product_type":"c1","uid":1027123,"ip_address":"","ucode":"D0700609740FB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/33/110437cc.jpg","comment_is_top":false,"comment_ctime":1603157500,"is_pvip":false,"replies":[{"id":"92907","content":"只取第一个用","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603168037,"ip_address":"","comment_id":254606,"utype":1}],"discussion_count":6,"race_medal":0,"score":"23077993980","product_id":100061801,"comment_content":"请教一个基础问题，为啥 (*int32)(unsafe.Pointer(&amp;m.Mutex)) 可以获取sync.Mutex中state的值，Mutex结构中不是还有sema吗？","like_count":5,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507453,"discussion_content":"只取第一个用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603168037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2730577,"avatar":"","nickname":"kdocs服务组2","note":"","ucode":"F1B0D5EB2E4B31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530962,"discussion_content":"atomic.loadint32也是一个意思吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637197035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":507453,"ip_address":""},"score":530962,"extra":"{\"user_type\":1}"},{"author":{"id":1140830,"avatar":"https://static001.geekbang.org/account/avatar/00/11/68/5e/5676ece1.jpg","nickname":"Exler","note":"","ucode":"41E5FCD39698D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2730577,"avatar":"","nickname":"kdocs服务组2","note":"","ucode":"F1B0D5EB2E4B31","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541077,"discussion_content":"这个指的是以原子的方式加载 *int32，1. 加载 int32 不同的CPU可能需要的指令数量不一样，多条指令，多线程就会出问题；2. 提供读写的同步","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640250027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":530962,"ip_address":""},"score":541077,"extra":""}]},{"author":{"id":1419723,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","nickname":"木头发芽","note":"","ucode":"657B381C5DA963","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314601,"discussion_content":"因为结构体里的成员按顺序组织在内存中,所以结构体内存指针指向的地址值就是第一个成员变量的地址.\n 题外话:结构体的对其,因为CPU 3级缓存大小是以8字节的倍数来分配的为了让CPU缓存减少缓存失效问题不让一个结构体分2块,经常会对结构体补足8字节的倍数,这个一般叫填充字节成员变量. ","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1603176434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2730577,"avatar":"","nickname":"kdocs服务组2","note":"","ucode":"F1B0D5EB2E4B31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1419723,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","nickname":"木头发芽","note":"","ucode":"657B381C5DA963","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531138,"discussion_content":"因此这也是获取不到第二个变量的原因吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637239907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":314601,"ip_address":""},"score":531138,"extra":"{\"user_type\":1}"}]},{"author":{"id":2689371,"avatar":"","nickname":"Geek6401","note":"","ucode":"9A59B7F991F0D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395408,"discussion_content":"(*int32)  取的是 前4个字节的数据，mutex中对应的数据就是state","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632301017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254163,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1603074222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23077910702","product_id":100061801,"comment_content":"认真消化完前三章后看今天的这章感觉容易多了。","like_count":5},{"had_liked":false,"id":254315,"user_name":"( ･᷄ὢ･᷅ )","can_delete":false,"product_type":"c1","uid":2234129,"ip_address":"","ucode":"E5F5EDEBB74C46","user_header":"https://static001.geekbang.org/account/avatar/00/22/17/11/a63acc6a.jpg","comment_is_top":false,"comment_ctime":1603099812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14488001700","product_id":100061801,"comment_content":"可以通过Context.WithTimeout进行超时机制添加 也可以通过select time.After配合使用","like_count":3},{"had_liked":false,"id":258117,"user_name":"50%","can_delete":false,"product_type":"c1","uid":1674992,"ip_address":"","ucode":"3E4247B5844B5B","user_header":"https://static001.geekbang.org/account/avatar/00/19/8e/f0/18720510.jpg","comment_is_top":false,"comment_ctime":1604304430,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10194239022","product_id":100061801,"comment_content":"type Mutex struct {<br>\tsync.Mutex<br>}<br>var m Mutex<br>\tfmt.Printf(&quot;%+v\\n&quot;, unsafe.Pointer(&amp;m))<br>\t&#47;&#47;state 字段 先得到m中sync.Mutex字段的地址 再用int32类型的指针获取state字段<br>\tfmt.Printf(&quot;%+v\\n&quot;, (*int32)(unsafe.Pointer(&amp;m.Mutex)))<br>\t&#47;&#47;sema 字段 先得到m中sync.Mutex字段的地址 + state（int32类型）所占的内存地址（偏移量）得到sema的字段的起始地址 在转换int32类型的指针获取sema字段<br>\t&#47;&#47;fmt.Printf(&quot;%+v\\n&quot;, unsafe.Sizeof(uint32(0)))<br>\tfmt.Printf(&quot;%+v\\n&quot;, (*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;m.Mutex))+unsafe.Sizeof(int32(0)))))","like_count":3,"discussions":[{"author":{"id":1067224,"avatar":"https://static001.geekbang.org/account/avatar/00/10/48/d8/d0e9bd80.jpg","nickname":"当运元宝","note":"","ucode":"525542C70260F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530594,"discussion_content":"茅塞顿开\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637110838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073236,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","nickname":"阿牛","note":"","ucode":"DC8C189FCF3289","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350930,"discussion_content":"茅塞顿开\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614076234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254715,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1603173109,"is_pvip":true,"replies":[{"id":"92926","content":"多谢","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603188391,"ip_address":"","comment_id":254715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10193107701","product_id":100061801,"comment_content":"1）『获取等待者的数量等指标』小节，『第 15 行我们左移三位（这里的常量 mutexWaiterShift 的值为 3）』应该是右移三位。<br>2）在now～now+timout内，间隔重试调用TryLock","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507499,"discussion_content":"多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603188391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298467,"user_name":"geek_arong2048","can_delete":false,"product_type":"c1","uid":1518310,"ip_address":"","ucode":"AB575BE100E4A9","user_header":"https://static001.geekbang.org/account/avatar/00/17/2a/e6/c788257f.jpg","comment_is_top":false,"comment_ctime":1624119287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5919086583","product_id":100061801,"comment_content":"timeout实现：<br>1、select+time.After<br>2、for自旋+时间戳判断","like_count":1},{"had_liked":false,"id":291876,"user_name":"上校","can_delete":false,"product_type":"c1","uid":1069548,"ip_address":"","ucode":"DEE1CEE9E4C680","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/ec/3d51d5e6.jpg","comment_is_top":false,"comment_ctime":1620566948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5915534244","product_id":100061801,"comment_content":"你可以为 Mutex 获取锁时加上 Timeout 机制吗？会有什么问题吗？<br><br>希望老师抽时间把相关的课后思考题解答下，从经验和工作中遇到的问题肯定不如老师理解的深刻，老师辛苦了","like_count":1},{"had_liked":false,"id":291534,"user_name":"斯蒂芬.赵","can_delete":false,"product_type":"c1","uid":1200179,"ip_address":"","ucode":"AA0FF2DA654418","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/33/9dcd30c4.jpg","comment_is_top":false,"comment_ctime":1620352200,"is_pvip":true,"replies":[{"id":"105611","content":"尝试和唤醒的goroutine抢一抢。<br>当然为了简单不易出错，return false更好，容易理解，不易出错","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1620363547,"ip_address":"","comment_id":291534,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5915319496","product_id":100061801,"comment_content":"fast path执行失败，直接返回false不就行了，为啥还要往下执行？正常不是多个携程并发只有一个执行成功，其他都是失败么？","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519499,"discussion_content":"尝试和唤醒的goroutine抢一抢。\n当然为了简单不易出错，return false更好，容易理解，不易出错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620363547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200179,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/33/9dcd30c4.jpg","nickname":"斯蒂芬.赵","note":"","ucode":"AA0FF2DA654418","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372528,"discussion_content":"还有一个问题，就是发现fast path 里的cas不是原子操作，多个携程并发执行的时候发现都返回ture，这是咋回事，麻烦老师解答一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620368145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200179,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/33/9dcd30c4.jpg","nickname":"斯蒂芬.赵","note":"","ucode":"AA0FF2DA654418","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372520,"discussion_content":"昨晚试了一下您的这段代码，多个携程并发抢一个锁，发现好几个携程都返回了true，和预期的只有一个携程抢锁成功返回ture，其他都返回false结果不一样，所以不大明白是不是fast path后面的代码是不是写有问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620363815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259648,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1604801171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5899768467","product_id":100061801,"comment_content":"老师好。在 trylock 中，我想不明白为什么在唤醒状态下也要直接 return 出去，是因为如果唤醒状态下取得锁会破坏原有的 Mutex 处理逻辑吗？我看如果 trylock 在唤醒取得锁，并且不清除 Mutex 的唤醒标记，对 Mutex 的处理不会有影响，但如果清除了，会造成一些走 Lock 方法的 goroutine 误以为是自己取得了锁（atomic.CompareAndSwapInt32(&amp;m.state, old, new) &amp;&amp; (old&amp;(mutexLocked|mutexStarving))）。不知道我的理解对不对。","like_count":1},{"had_liked":false,"id":255027,"user_name":"罗帮奎","can_delete":false,"product_type":"c1","uid":1271773,"ip_address":"","ucode":"8598D116E1FC3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/67/dd/55aa6e07.jpg","comment_is_top":false,"comment_ctime":1603252802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898220098","product_id":100061801,"comment_content":"感觉可以把timeout分小段，每过一小段时间尝试拿锁，要不然一直卡在自旋拿锁会很耗cpu","like_count":1},{"had_liked":false,"id":254969,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1603243210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898210506","product_id":100061801,"comment_content":"通过tryLock-&gt;sleep-&gt;tryLock存在的问题是，可能sleep过程中就能获取到锁，但是不得不等设定的时长，如果间隔一段时间就尝试，有可能实际拿不到锁而浪费CPU","like_count":1},{"had_liked":false,"id":254721,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1603173785,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5898141081","product_id":100061801,"comment_content":"TryLock方法中27行表示的是：<br>1）在锁的瞬时状态为正常模式+无唤醒的等待者+锁未被持有时，当前goroutine与等待队列中队头goroutine一起竞争（此时等待者队列不为空）。<br>2）与TryLock的fast path一样，锁的瞬时状态为正常模式+无唤醒的等待者+锁未被持有+等待队列为空。此时无竞争，直接获取到锁。<br><br>&#47;&#47; 尝试在竞争的状态下请求锁 <br>new := old | mutexLocked <br>return atomic.CompareAndSwapInt32((*int32(unsafe.Pointer(&amp;m.Mutex)), old, new)","like_count":1},{"had_liked":false,"id":340917,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1649229156,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1649229156","product_id":100061801,"comment_content":"对于 Mutex 的理解更深入了一层","like_count":0},{"had_liked":false,"id":334187,"user_name":"tourist","can_delete":false,"product_type":"c1","uid":2875489,"ip_address":"","ucode":"57D33FF8377EC0","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e0/61/53a17039.jpg","comment_is_top":false,"comment_ctime":1644804870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644804870","product_id":100061801,"comment_content":"不知道其他语言怎么搞，但看完Go写的，感觉Go确实挺简洁的","like_count":0},{"had_liked":false,"id":310466,"user_name":"白志稳","can_delete":false,"product_type":"c1","uid":1364628,"ip_address":"","ucode":"6D47A362797C6B","user_header":"https://static001.geekbang.org/account/avatar/00/14/d2/94/c7223eb8.jpg","comment_is_top":false,"comment_ctime":1630662820,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1630662820","product_id":100061801,"comment_content":"每次思考题的答案在哪呀？有没有老师的标准答案？只看评论区也不知道谁的对啊？<br>v = v &gt;&gt; mutexWaiterShift &#47;&#47;得到等待者的数值 <br>v = v + (v &amp; mutexLocked) &#47;&#47;再加上锁持有者的数量，0或者1<br>这个地方能再解释一下吗？怎么拆出来的那几个字段？","like_count":0,"discussions":[{"author":{"id":2554951,"avatar":"https://static001.geekbang.org/account/avatar/00/26/fc/47/5fb0d905.jpg","nickname":"张健华","note":"","ucode":"577452129C885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392931,"discussion_content":"mutexWaiterShift值是3，代表最低的三个标志位，右移后就得到了等待着的数量。\nv &amp; mutexLocked是查看最后一位是否已加锁，有则结果为1，没有则为0.\n因此等待者数量+已获得锁的数量（0或1）就是总的数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631184555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296049,"user_name":"关东燕雀寇关来","can_delete":false,"product_type":"c1","uid":1466455,"ip_address":"","ucode":"34393C584158FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/57/6a53393a.jpg","comment_is_top":false,"comment_ctime":1622716613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622716613","product_id":100061801,"comment_content":"time.Sleep(time.Duration(rand.Intn(2)) * time.Second)前没有time.Seed() 导致随机数失效","like_count":0},{"had_liked":false,"id":293202,"user_name":"斯蒂芬.赵","can_delete":false,"product_type":"c1","uid":1200179,"ip_address":"","ucode":"AA0FF2DA654418","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/33/9dcd30c4.jpg","comment_is_top":false,"comment_ctime":1621262972,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621262972","product_id":100061801,"comment_content":"v = v + (v &amp; mutexLocked) &#47;&#47;再加上锁持有者的数量，0或者1 这块的逻辑是不是写的有问题，判断是否上锁不应该用state := atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;m.Mutex))) return state&amp;mutexLocked == mutexLocked 来判断么，v &amp; mutexLocked) v 这时候代表的是锁等待着的数量，不是state当前的状态","like_count":0},{"had_liked":false,"id":291130,"user_name":"鲁迅原名周树人","can_delete":false,"product_type":"c1","uid":2337877,"ip_address":"","ucode":"45D5F91AB0F5BB","user_header":"https://static001.geekbang.org/account/avatar/00/23/ac/55/80dc6b48.jpg","comment_is_top":false,"comment_ctime":1620041486,"is_pvip":false,"replies":[{"id":"105468","content":"对","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1620092672,"ip_address":"","comment_id":291130,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1620041486","product_id":100061801,"comment_content":"老师您好，<br><br>&#47;&#47; 如果能成功抢到锁 if atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)), 0, mutexLocked) { return true }<br><br>在以上代码中，(*int32)(unsafe.Pointer(&amp;m.Mutex))是取的Mutex中state的首地址对嘛?<br>","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519381,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620092672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346975,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6DJtWjicHFwUticYW7G16rhQxbgJ4Oic568f7XcJUL79uEWhN74B7tibWtiaib16rh8gyFUCicqEuLUXLYQ/132","nickname":"Jkd","note":"","ucode":"2B3BB802810A10","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372747,"discussion_content":"老师，这个方法等于就是取结构体内第一个字段的地址是吧，如果state是结构体中定义的第二个字段，sema是第一个字段，那么以上这个方法执行完，取的就是sema字段的地址吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620450364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261859,"user_name":"黄毅","can_delete":false,"product_type":"c1","uid":1159363,"ip_address":"","ucode":"201C9FD58CF90B","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/c3/e1e2c097.jpg","comment_is_top":false,"comment_ctime":1605539821,"is_pvip":false,"replies":[{"id":"95057","content":"在大并发竞争锁，在释放锁的时候可能会出现。很极端的情况，可能难以模拟，但是通过分析mutex的lock&#47;unlock代码应该能分析出来。<br>另外如果trylick简单实现，可以只保留第一段，其它情况返回false即可","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605575711,"ip_address":"","comment_id":261859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605539821","product_id":100061801,"comment_content":"func (m *Mutex) TryLock() bool {<br>\t&#47;&#47; 如果能成功抢到锁<br>\tif atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)), 0, mutexLocked) {<br>\t\treturn true<br>\t}<br><br>\t&#47;&#47; 如果处于唤醒、加锁或者饥饿状态，这次请求就不参与竞争了，返回false<br>\told := atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)))<br>\tfmt.Println(&quot;===old===:&quot;, old)<br>\tif old&amp;(mutexLocked|mutexStarving|mutexWoken) != 0 {<br>\t\treturn false<br>\t}<br><br>\t&#47;&#47; 尝试在竞争的状态下请求锁<br>\tnew := old | mutexLocked<br>\tfmt.Println(&quot;===new===:&quot;, new) &#47;&#47;请问在什么情况下会执行到这里<br>\treturn atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)), old, new)<br>}<br><br>func main() {<br>\tvar mu Mutex<br>\tgo func() { &#47;&#47; 启动一个goroutine持有一段时间的锁<br>\t\tmu.Lock()<br>\t\ttime.Sleep(time.Duration(rand.Intn(2)) * time.Second)<br>\t\tmu.Unlock()<br>\t}()<br><br>\ttime.Sleep(time.Second)<br><br>\tn := int(10)<br>\tvar wg sync.WaitGroup<br>\twg.Add(n)<br><br>\tfor i := 0; i &lt; n; i++ {<br>\t\tgo func() {<br>\t\t\tok := mu.TryLock() &#47;&#47; 尝试获取到锁<br>\t\t\tdefer wg.Done()<br>\t\t\tif ok { &#47;&#47; 获取成功<br>\t\t\t\tfmt.Println(&quot;got the lock&quot;)<br>\t\t\t\t&#47;&#47; do something<br>\t\t\t\tmu.Unlock()<br>\t\t\t\treturn<br>\t\t\t}<br>\t\t}()<br>\t}<br>\t&#47;&#47; 没有获取到<br>\twg.Wait()<br>}<br><br>老师，你好。在main中尝试编写一段逻辑测试TryLock方法，请问在什么情况下会执行fmt.Println(&quot;===new===:&quot;, new) 请老师答疑解惑，谢谢。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509643,"discussion_content":"在大并发竞争锁，在释放锁的时候可能会出现。很极端的情况，可能难以模拟，但是通过分析mutex的lock/unlock代码应该能分析出来。\n另外如果trylick简单实现，可以只保留第一段，其它情况返回false即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605575711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258822,"user_name":"樊少","can_delete":false,"product_type":"c1","uid":1050047,"ip_address":"","ucode":"44D5817C37156F","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/bf/cc9d43ae.jpg","comment_is_top":false,"comment_ctime":1604563576,"is_pvip":false,"replies":[{"id":"94189","content":"可以用","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604574134,"ip_address":"","comment_id":258822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604563576","product_id":100061801,"comment_content":"在安全Queue的实现中，锁的释放为什么不用defer?","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508762,"discussion_content":"可以用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604574134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257710,"user_name":"niceshot","can_delete":false,"product_type":"c1","uid":1312493,"ip_address":"","ucode":"2C2BBC07A6E02D","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","comment_is_top":false,"comment_ctime":1604072065,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604072065","product_id":100061801,"comment_content":"这个try测试TryLock rand应该先设置一个种子吧 要不随机数都一样的","like_count":0},{"had_liked":false,"id":257707,"user_name":"niceshot","can_delete":false,"product_type":"c1","uid":1312493,"ip_address":"","ucode":"2C2BBC07A6E02D","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","comment_is_top":false,"comment_ctime":1604071205,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604071205","product_id":100061801,"comment_content":"old:=atomic.LoadInt32((*int32)(unsafe.Pointer(&amp;mu.Mutex)))<br>\t&#47;&#47;如果当前锁被持有或者有饥饿状态和唤醒状态,则直接返回false<br>\tif old&amp;(mutexLocked|mutexStaving|mutexWoken)!=0{<br>\t\treturn false<br>\t}<br>      if这一段是个原子操作吗 如果拿完old的值 再if的过程中state被修改了怎么办？一直搞不懂怎么样才算一个原子操作","like_count":0,"discussions":[{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388675,"discussion_content":"那也就是返回了false 不会有影响 主要是不返回true就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628908422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255444,"user_name":"moooofly","can_delete":false,"product_type":"c1","uid":1008348,"ip_address":"","ucode":"4A20795C281B6F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","comment_is_top":false,"comment_ctime":1603346434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603346434","product_id":100061801,"comment_content":"&gt; 可以为 Mutex 获取锁时加上 Timeout 机制吗？会有什么问题吗？<br><br>我想，问题的关键不在于能不能加，因为加是肯定可以加的，关键应该是有了超时之后，会导致 unlock 的逻辑变得复杂，容易导致多次 unlock 的问题","like_count":0},{"had_liked":false,"id":255342,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1603326493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603326493","product_id":100061801,"comment_content":"对tryLock中提到的第一行被称作fast path不太理解，是节省了一次LoadInt32么？","like_count":0},{"had_liked":false,"id":255312,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1202705,"ip_address":"","ucode":"E72556A81DDC4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/11/1f0d54f8.jpg","comment_is_top":false,"comment_ctime":1603299632,"is_pvip":false,"replies":[{"id":"93024","content":"看图，左边三位是其它标志","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603326247,"ip_address":"","comment_id":255312,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603299632","product_id":100061801,"comment_content":"第 15 行我们右移三位（这里的常量 mutexWaiterShift 的值为 3），就得到了当前等待者的数量<br>=&gt;&gt; 这里看不懂，为什么右移三位=》得到等待者数量","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507681,"discussion_content":"看图，左边三位是其它标志","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603326247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254968,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1603243077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603243077","product_id":100061801,"comment_content":"课后思考题 是不是可以通过tryLock尝试获取锁获取失败就sleep一段时间，超时后再调用tryLock","like_count":0},{"had_liked":false,"id":254943,"user_name":"新味道","can_delete":false,"product_type":"c1","uid":2227527,"ip_address":"","ucode":"979E3574082CE7","user_header":"https://static001.geekbang.org/account/avatar/00/21/fd/47/499339d1.jpg","comment_is_top":false,"comment_ctime":1603239172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603239172","product_id":100061801,"comment_content":"Channel 是用memory access synchronization来构建的吗？","like_count":0},{"had_liked":false,"id":254736,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1603178291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603178291","product_id":100061801,"comment_content":"Hacker 编程  自己动手 丰衣足食   打卡  催更  哈哈哈<br>内容很棒   深入学习 Go 并发编程","like_count":0},{"had_liked":false,"id":254616,"user_name":"linxs","can_delete":false,"product_type":"c1","uid":1006728,"ip_address":"","ucode":"0D860DF26FD150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/88/9575e5d3.jpg","comment_is_top":false,"comment_ctime":1603158520,"is_pvip":true,"replies":[{"id":"92912","content":"你能访问到？","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603168199,"ip_address":"","comment_id":254616,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1603158520","product_id":100061801,"comment_content":"TryLock方法内，对于这段代码有点不理解，为什么要把&amp;m.Mutex转换成*int32，这里的话我直接用&amp;m.Mutex.state是否是一样的<br><br>if atomic.CompareAndSwapInt32((*int32)(unsafe.Pointer(&amp;m.Mutex)), 0, mutexLocked) { <br>     return true <br>}","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507456,"discussion_content":"你能访问到？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603168199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1857527,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQqPt0njRN0tibqKBaDaM7S7a3m2XlhwV3cNgiaeRfI0EaqPhgy16ZOV3Xtaia3dbdGibh0D9SnpAhwQ/132","nickname":"Geek_35eafa","note":"","ucode":"1CDF2212499FD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314559,"discussion_content":"state不暴露出来的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603171976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1006728,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/88/9575e5d3.jpg","nickname":"linxs","note":"","ucode":"0D860DF26FD150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1857527,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQqPt0njRN0tibqKBaDaM7S7a3m2XlhwV3cNgiaeRfI0EaqPhgy16ZOV3Xtaia3dbdGibh0D9SnpAhwQ/132","nickname":"Geek_35eafa","note":"","ucode":"1CDF2212499FD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314585,"discussion_content":"经过实践以及往下看之后就明白了。谢谢你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603174763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":314559,"ip_address":""},"score":314585,"extra":""}]}]}]}