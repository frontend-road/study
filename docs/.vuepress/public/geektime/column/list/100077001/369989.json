{"id":369989,"title":"06｜Spring AOP 常见错误（下）","content":"<p>你好，我是傅健。</p><p>上一节课，我们介绍了 Spring AOP 常遇到的几个问题，通过具体的源码解析，相信你对 Spring AOP 的基本原理已经有所了解了。不过，AOP 毕竟是 Spring 的核心功能之一，不可能规避那零散的两三个问题就一劳永逸了。所以这节课，我们继续聊聊 Spring AOP 中还会有哪些易错点。实际上，当一个系统采用的切面越来越多时，因为执行顺序而导致的问题便会逐步暴露出来，下面我们就重点看一下。</p><h2>案例1：错乱混合不同类型的增强</h2><p>还是沿用上节课的宿舍管理系统开发场景。</p><p>这里我们先回顾下，你就不用去翻代码了。这个宿舍管理系统保护了一个电费充值模块，它包含了一个负责电费充值的类 ElectricService，还有一个充电方法 charge()：</p><pre><code>@Service\npublic class ElectricService {\n    public void charge() throws Exception {\n        System.out.println(&quot;Electric charging ...&quot;);\n    }\n}\n</code></pre><p>为了在执行 charge() 之前，鉴定下调用者的权限，我们增加了针对于 Electric 的切面类 AopConfig，其中包含一个 @Before 增强。这里的增强没有做任何事情，仅仅是打印了一行日志，然后模拟执行权限校验功能（占用 1 秒钟）。</p><pre><code>//省略 imports\n@Aspect\n@Service\n@Slf4j\npublic class AspectService {\n  @Before(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)\n  public void checkAuthority(JoinPoint pjp) throws Throwable {\n      System.out.println(&quot;validating user authority&quot;);\n      Thread.sleep(1000);\n  }\n}\n</code></pre><p>执行后，我们得到以下 log，接着一切按照预期继续执行：</p><pre><code>validating user authority\nElectric charging ...\n</code></pre><p>一段时间后，由于业务发展，ElectricService 中的 charge() 逻辑变得更加复杂了，我们需要仅仅针对 ElectricService 的 charge() 做性能统计。为了不影响原有的业务逻辑，我们在 AopConfig 中添加了另一个增强，代码更改后如下：</p><!-- [[[read_end]]] --><pre><code>//省略 imports\n@Aspect\n@Service\npublic class AopConfig {\n    @Before(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)\n    public void checkAuthority(JoinPoint pjp) throws Throwable {\n        System.out.println(&quot;validating user authority&quot;);\n        Thread.sleep(1000);\n    }\n\n    @Around(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)\n    public void recordPerformance(ProceedingJoinPoint pjp) throws Throwable {\n        long start = System.currentTimeMillis();\n        pjp.proceed();\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;charge method time cost: &quot; + (end - start));\n    }\n}\n</code></pre><p>执行后得到日志如下：</p><blockquote>\n<p>validating user authority<br>\nElectric charging …<br>\ncharge method time cost 1022 (ms)</p>\n</blockquote><p>通过性能统计打印出的日志，我们可以得知 charge() 执行时间超过了 1 秒钟。然而，该方法仅打印了一行日志，它的执行不可能需要这么长时间。</p><p>因此我们很容易看出问题所在：当前 ElectricService 中 charge() 的执行时间，包含了权限验证的时间，即包含了通过 @Around 增强的 checkAuthority() 执行的所有时间。这并不符合我们的初衷，我们需要统计的仅仅是 ElectricService.charge() 的性能统计，它并不包含鉴权过程。</p><p>当然，这些都是从日志直接观察出的现象。实际上，这个问题出现的根本原因和 AOP 的执行顺序有关。针对这个案例而言，当同一个切面（Aspect）中同时包含多个不同类型的增强时（Around、Before、After、AfterReturning、AfterThrowing 等），它们的执行是有顺序的。那么顺序如何？我们不妨来解析下。</p><h3>案例解析</h3><p>其实一切都可以从源码中得到真相！在<a href=\"https://time.geekbang.org/column/article/367876\">第04课</a>我们曾经提到过，Spring 初始化单例类的一般过程，基本都是 getBean()-&gt;doGetBean()-&gt;getSingleton()，如果发现 Bean 不存在，则调用 createBean()-&gt;doCreateBean() 进行实例化。</p><p>而如果我们的代码里使用了 Spring AOP，doCreateBean() 最终会返回一个代理对象。至于代理对象如何创建，大体流程我们在上一讲已经概述过了。如果你记忆力比较好的话，应该记得在代理对象的创建过程中，我们贴出过这样一段代码（参考 AbstractAutoProxyCreator#createProxy）：</p><pre><code>protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,\n      @Nullable Object[] specificInterceptors, TargetSource targetSource) {\n   //省略非关键代码\n   Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n   proxyFactory.addAdvisors(advisors);\n   proxyFactory.setTargetSource(targetSource);\n   //省略非关键代码\n   return proxyFactory.getProxy(getProxyClassLoader());\n}\n</code></pre><p>其中 advisors 就是增强方法对象，它的顺序决定了面临多个增强时，到底先执行谁。而这个集合对象本身是由 specificInterceptors 构建出来的，而 specificInterceptors 又是由 AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean 方法构建：</p><pre><code>@Override\n@Nullable\nprotected Object[] getAdvicesAndAdvisorsForBean(\n      Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {\n   List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);\n   if (advisors.isEmpty()) {\n      return DO_NOT_PROXY;\n   }\n   return advisors.toArray();\n  }\n</code></pre><p>简单说，其实就是根据当前的 beanClass、beanName 等信息，结合所有候选的 advisors，最终找出匹配（Eligible）的 Advisor，为什么如此？毕竟 AOP 拦截点可能会配置多个，而我们执行的方法不见得会被所有的拦截配置拦截。寻找匹配 Advisor 的逻辑参考 AbstractAdvisorAutoProxyCreator#findEligibleAdvisors：</p><pre><code>protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {\n   //寻找候选的 Advisor\n   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();\n   //根据候选的 Advisor 和当前 bean 算出匹配的 Advisor\n   List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n   extendAdvisors(eligibleAdvisors);\n   if (!eligibleAdvisors.isEmpty()) {\n      //排序\n      eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n   }\n   return eligibleAdvisors;\n}\n</code></pre><p>通过研读代码，最终 Advisors 的顺序是由两点决定：</p><ol>\n<li>candidateAdvisors 的顺序；</li>\n<li>sortAdvisors 进行的排序。</li>\n</ol><p>这里我们可以重点看下对本案例起关键作用的 candidateAdvisors 排序。实际上，它的顺序是在 @Aspect 标记的 AopConfig Bean 构建时就决定了。具体而言，就是在初始化过程中会排序自己配置的 Advisors，并把排序结果存入了缓存（BeanFactoryAspectJAdvisorsBuilder#advisorsCache）。</p><p>后续 Bean 创建代理时，直接拿出这个排序好的候选 Advisors。候选 Advisors 排序发生在 Bean 构建这个结论时，我们也可以通过 AopConfig Bean 构建中的堆栈信息验证：</p><p><img src=\"https://static001.geekbang.org/resource/image/61/d1/611f386b14b05c2d151340d31f34e3d1.png?wh=1343*275\" alt=\"\"></p><p>可以看到，排序是在 Bean 的构建中进行的，而最后排序执行的关键代码位于下面的方法中（参考 ReflectiveAspectJAdvisorFactory#getAdvisorMethods）：</p><pre><code>private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) {\n   final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();\n   ReflectionUtils.doWithMethods(aspectClass, method -&gt; {\n      // Exclude pointcuts\n      if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {\n         methods.add(method);\n      }\n   }, ReflectionUtils.USER_DECLARED_METHODS);\n   // 排序\n   methods.sort(METHOD_COMPARATOR);\n   return methods;\n}\n</code></pre><p>上述代码的重点是第九行 methods.sort(METHOD_COMPARATOR)方法。</p><p>我们来查看 METHOD_COMPARATOR 的代码，会发现它是定义在 ReflectiveAspectJAdvisorFactory 类中的静态方法块，代码如下：</p><pre><code>static {\n   Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(\n         new InstanceComparator&lt;&gt;(\n               Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),\n         (Converter&lt;Method, Annotation&gt;) method -&gt; {\n            AspectJAnnotation&lt;?&gt; annotation =\n               AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);\n            return (annotation != null ? annotation.getAnnotation() : null);\n         });\n   Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);\n   //合并上面两者比较器\n   METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);\n}\n</code></pre><p>METHOD_COMPARATOR 本质上是一个连续比较器，由 adviceKindComparator 和 methodNameComparator 这两个比较器通过 thenComparing()连接而成。</p><p>通过这个案例，我们重点了解 adviceKindComparator 这个比较器，此对象通过实例化 ConvertingComparator 类而来，而 ConvertingComparator 类是 Spring 中较为经典的一个实现。顾名思义，先转化再比较，它构造参数接受以下这两个参数：</p><ul>\n<li>第一个参数是基准比较器，即在 adviceKindComparator 中最终要调用的比较器，在构造函数中赋值于 this.comparator；</li>\n<li>第二个参数是一个 lambda 回调函数，用来将传递的参数转化为基准比较器需要的参数类型，在构造函数中赋值于 this.converter。</li>\n</ul><p>查看 ConvertingComparator 比较器核心方法 compare 如下：</p><pre><code>public int compare(S o1, S o2) {\n   T c1 = this.converter.convert(o1);\n   T c2 = this.converter.convert(o2);\n   return this.comparator.compare(c1, c2);\n}\n</code></pre><p>可知，这里是先调用从构造函数中获取到的 lambda 回调函数 this.converter，将需要比较的参数进行转化。我们可以从之前的代码中找出这个转化工作：</p><pre><code>(Converter&lt;Method, Annotation&gt;) method -&gt; {\n   AspectJAnnotation&lt;?&gt; annotation =\n      AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);\n   return (annotation != null ? annotation.getAnnotation() : null);\n});\n</code></pre><p>转化功能的代码逻辑较为简单，就是返回传入方法（method）上标记的增强注解（Pointcut,Around,Before,After,AfterReturning 以及 AfterThrowing）：</p><pre><code>private static final Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = new Class&lt;?&gt;[] {\n      Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};\n\nprotected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) {\n   for (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) {\n      AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz);\n      if (foundAnnotation != null) {\n         return foundAnnotation;\n      }\n   }\n   return null;\n}\n</code></pre><p>经过转化后，我们获取到的待比较的数据其实就是注解了。而它们的排序依赖于 ConvertingComparator 的第一个参数，即最终会调用的基准比较器，以下是它的关键实现代码：</p><pre><code>new InstanceComparator&lt;&gt;(\n      Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class)\n</code></pre><p>最终我们要调用的基准比较器本质上就是一个 InstanceComparator 类，我们先重点注意下这几个增强注解的传递顺序。继续查看它的构造方法如下：</p><pre><code>public InstanceComparator(Class&lt;?&gt;... instanceOrder) {\n   Assert.notNull(instanceOrder, &quot;'instanceOrder' array must not be null&quot;);\n   this.instanceOrder = instanceOrder;\n}\n</code></pre><p>构造方法也是较为简单的，只是将传递进来的 instanceOrder 赋予了类成员变量，继续查看 InstanceComparator 比较器核心方法 compare 如下，也就是最终要调用的比较方法：</p><pre><code>public int compare(T o1, T o2) {\n   int i1 = getOrder(o1);\n   int i2 = getOrder(o2);\n   return (i1 &lt; i2 ? -1 : (i1 == i2 ? 0 : 1));\n}\n</code></pre><p>一个典型的 Comparator，代码逻辑按照 i1、i2 的升序排列，即 getOrder() 返回的值越小，排序越靠前。</p><p>查看 getOrder() 的逻辑如下：</p><pre><code>private int getOrder(@Nullable T object) {\n   if (object != null) {\n      for (int i = 0; i &lt; this.instanceOrder.length; i++) {\n         //instance 在 instanceOrder 中的“排号”\n         if (this.instanceOrder[i].isInstance(object)) {\n            return i;\n         }\n      }\n   }\n   return this.instanceOrder.length;\n}\n</code></pre><p>返回当前传递的增强注解在 this.instanceOrder 中的序列值，序列值越小，则越靠前。而结合之前构造参数传递的顺序，我们很快就能判断出：最终的排序结果依次是 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</p><p>到此为止，答案也呼之欲出：this.instanceOrder 的排序，即为不同类型增强的优先级，<strong>排序越靠前，优先级越高</strong>。</p><p>结合之前的讨论，我们可以得出一个结论：同一个切面中，不同类型的增强方法被调用的顺序依次为Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</p><h3>问题修正</h3><p>从上述案例解析中，我们知道 Around 类型的增强被调用的优先级高于 Before 类型的增强，所以上述案例中性能统计所花费的时间，包含权限验证的时间，也在情理之中。</p><p>知道了原理，修正起来也就简单了。假设不允许我们去拆分类，我们可以按照下面的思路来修改：</p><ol>\n<li>将 ElectricService.charge() 的业务逻辑全部移动到 doCharge()，在 charge() 中调用 doCharge()；</li>\n<li>性能统计只需要拦截 doCharge()；</li>\n<li>权限统计增强保持不变，依然拦截 charge()。</li>\n</ol><p>ElectricService 类代码更改如下：</p><pre><code>@Service\npublic class ElectricService {\n    @Autowired\n    ElectricService electricService;\n    public void charge() {\n        electricService.doCharge();\n    }\n    public void doCharge() {\n        System.out.println(&quot;Electric charging ...&quot;);\n    }\n}\n</code></pre><p>切面代码更改如下：</p><pre><code>//省略 imports\n@Aspect\n@Service\npublic class AopConfig {\n    @Before(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)\n    public void checkAuthority(JoinPoint pjp) throws Throwable {\n        System.out.println(&quot;validating user authority&quot;);\n        Thread.sleep(1000);\n    }\n\n    @Around(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.doCharge()) &quot;)\n    public void recordPerformance(ProceedingJoinPoint pjp) throws Throwable {\n    long start = System.currentTimeMillis();\n    pjp.proceed();\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;charge method time cost: &quot; + (end - start));\n  }\n}\n</code></pre><h2>案例 2：错乱混合同类型增强</h2><p>那学到这里，你可能还有疑问，如果同一个切面里的多个增强方法其增强都一样，那调用顺序又如何呢？我们继续看下一个案例。</p><p>这里业务逻辑类 ElectricService 没有任何变化，仅包含一个 charge()：</p><pre><code>import org.springframework.stereotype.Service;\n@Service\npublic class ElectricService {\n    public void charge() {\n        System.out.println(&quot;Electric charging ...&quot;);\n    }\n}\n</code></pre><p>切面类 AspectService 包含两个方法，都是 Before 类型增强。</p><p>第一个方法 logBeforeMethod()，目的是在 run() 执行之前希望能输入日志，表示当前方法被调用一次，方便后期统计。另一个方法 validateAuthority()，目的是做权限验证，其作用是在调用此方法之前做权限验证，如果不符合权限限制要求，则直接抛出异常。这里为了方便演示，此方法将直接抛出异常：</p><pre><code>//省略 imports\n@Aspect\n@Service\npublic class AopConfig {\n  @Before(&quot;execution(* com.spring.puzzle.class5.example2.ElectricService.charge())&quot;)\n  public void logBeforeMethod(JoinPoint pjp) throws Throwable {\n      System.out.println(&quot;step into -&gt;&quot;+pjp.getSignature());\n  }\n  @Before(&quot;execution(* com.spring.puzzle.class5.example2.ElectricService.charge()) &quot;)\n  public void validateAuthority(JoinPoint pjp) throws Throwable {\n      throw new RuntimeException(&quot;authority check failed&quot;);\n  }\n}\n</code></pre><p>我们对代码的执行预期为：当鉴权失败时，由于 ElectricService.charge() 没有被调用，那么 run() 的调用日志也不应该被输出，即 logBeforeMethod() 不应该被调用，但事实总是出乎意料，执行结果如下：</p><blockquote>\n<p>step into -&gt;void com.spring.puzzle.class6.example2.Electric.charge()<br>\nException in thread “main” java.lang.RuntimeException: authority check failed</p>\n</blockquote><p>虽然鉴权失败，抛出了异常且 ElectricService.charge() 没有被调用，但是 logBeforeMethod() 的调用日志却被输出了，这将导致后期针对于 ElectricService.charge() 的调用数据统计严重失真。</p><p>这里我们就需要搞清楚一个问题：当同一个切面包含多个同一种类型的多个增强，且修饰的都是同一个方法时，这多个增强的执行顺序是怎样的？</p><h3>案例解析</h3><p>我们继续从源代码中寻找真相！你应该还记得上述代码中，定义 METHOD_COMPARATOR  的静态代码块吧。</p><p>METHOD_COMPARATOR 本质是一个连续比较器，而上个案例中我们仅仅只看了第一个比较器，细心的你肯定发现了这里还有第二个比较器 methodNameComparator，任意两个比较器都可以通过其内置的 thenComparing() 连接形成一个连续比较器，从而可以让我们按照比较器的连接顺序依次比较：</p><pre><code>static {\n   //第一个比较器，用来按照增强类型排序\n   Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(\n         new InstanceComparator&lt;&gt;(\n               Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),\n         (Converter&lt;Method, Annotation&gt;) method -&gt; {\n            AspectJAnnotation&lt;?&gt; annotation =\n               AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);\n            return (annotation != null ? annotation.getAnnotation() : null);\n         })\n   //第二个比较器，用来按照方法名排序\n   Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);\n   METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);\n}\n</code></pre><p>我们可以看到，在第 12 行代码中，第 2 个比较器 methodNameComparator 依然使用的是 ConvertingComparator，传递了方法名作为参数。我们基本可以猜测出该比较器是按照方法名进行排序的，这里可以进一步查看构造器方法及构造器调用的内部 comparable()：</p><pre><code>public ConvertingComparator(Converter&lt;S, T&gt; converter) {\n   this(Comparators.comparable(), converter);\n}\n// 省略非关键代码\npublic static &lt;T&gt; Comparator&lt;T&gt; comparable() {\n   return ComparableComparator.INSTANCE;\n}\n</code></pre><p>上述代码中的 ComparableComparator 实例其实极其简单，代码如下：</p><pre><code>public class ComparableComparator&lt;T extends Comparable&lt;T&gt;&gt; implements Comparator&lt;T&gt; {\n \n   public static final ComparableComparator INSTANCE = new ComparableComparator();\n\n   @Override\n   public int compare(T o1, T o2) {\n      return o1.compareTo(o2);\n   }\n}\n</code></pre><p>答案和我们的猜测完全一致，methodNameComparator 最终调用了 String 类自身的 compareTo()，代码如下：</p><pre><code>public int compareTo(String anotherString) {\n    int len1 = value.length;\n    int len2 = anotherString.value.length;\n    int lim = Math.min(len1, len2);\n    char v1[] = value;\n    char v2[] = anotherString.value;\n\n    int k = 0;\n    while (k &lt; lim) {\n        char c1 = v1[k];\n        char c2 = v2[k];\n        if (c1 != c2) {\n            return c1 - c2;\n        }\n        k++;\n    }\n    return len1 - len2;\n}\n</code></pre><p>到这，答案揭晓：如果两个方法名长度相同，则依次比较每一个字母的 ASCII 码，ASCII 码越小，排序越靠前；若长度不同，且短的方法名字符串是长的子集时，短的排序靠前。</p><h3>问题修正</h3><p>从上述分析我们得知，在同一个切面配置类中，针对同一个方法存在多个同类型增强时，其执行顺序仅和当前增强方法的名称有关，而不是由谁代码在先、谁代码在后来决定。了解了这点，我们就可以直接通过调整方法名的方式来修正程序：</p><pre><code>//省略 imports\n@Aspect\n@Service\npublic class AopConfig {\n  @Before(&quot;execution(* com.spring.puzzle.class6.example2.ElectricService.charge())&quot;)\n  public void logBeforeMethod(JoinPoint pjp) throws Throwable {\n      System.out.println(&quot;step into -&gt;&quot;+pjp.getSignature());\n  }\n  @Before(&quot;execution(* com.spring.puzzle.class6.example2.ElectricService.charge()) &quot;)\n  public void checkAuthority(JoinPoint pjp) throws Throwable {\n      throw new RuntimeException(&quot;authority check failed&quot;);\n  }\n}\n</code></pre><p>我们可以将原来的 validateAuthority() 改为 checkAuthority()，这种情况下，<strong>对增强（Advisor）的排序，其实最后就是在比较字符 l 和 字符 c</strong>。显然易见，checkAuthority()的排序会靠前，从而被优先执行，最终问题得以解决。</p><h2>重点回顾</h2><p>通过学习这两个案例，相信你对 Spring AOP 增强方法的执行顺序已经有了较为深入的理解。这里我来总结下关键点：</p><ul>\n<li>在同一个切面配置中，如果存在多个不同类型的增强，那么其执行优先级是按照增强类型的特定顺序排列，依次的增强类型为 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class；</li>\n<li>在同一个切面配置中，如果存在多个相同类型的增强，那么其执行优先级是按照该增强的方法名排序，排序方式依次为比较方法名的每一个字母，直到发现第一个不相同且 ASCII 码较小的字母。</li>\n</ul><p>同时，这节课我们也拓展了一些比较器相关的知识：</p><ul>\n<li>任意两个比较器（Comparator）可以通过 thenComparing() 连接合成一个新的连续比较器；</li>\n<li>比较器的比较规则有一个简单的方法可以帮助你理解，就是最终一定需要对象两两比较，而比较的过程一定是比较这两个对象的同种属性。你只要抓住这两点：比较了什么属性以及比较的结果是什么就可以了，若比较结果为正数，则按照该属性的升序排列；若为负数，则按属性降序排列。</li>\n</ul><h2>思考题</h2><p>实际上，审阅上面两个案例的修正方案，你会发现它们虽然改动很小，但是都还不够优美。那么有没有稍微优美点的替代方案呢？如果有，你知道背后的原理及关键源码吗？顺便你也可以想想，我为什么没有用更优美的方案呢？</p><p>期待在留言区看到你的思考，我们下节课再见！</p>","comments":[{"had_liked":false,"id":292633,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1620905846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35980644214","product_id":100077001,"comment_content":"拆分成两个切面，用@Order或Ordered接口控制顺序。个人觉得Spring在排序设计上比较混乱，各种排序规则不统一","like_count":9},{"had_liked":false,"id":291700,"user_name":"luke Y","can_delete":false,"product_type":"c1","uid":2311463,"ip_address":"","ucode":"111F98D367235B","user_header":"https://static001.geekbang.org/account/avatar/00/23/45/27/4fbf8f6a.jpg","comment_is_top":false,"comment_ctime":1620440217,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"35980178585","product_id":100077001,"comment_content":"老师你好，请教个问题，案例一的问题修正doCharge() 方法在charge()中调用，这个代理应该不会走到doCharge()的切面吧","like_count":8,"discussions":[{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409402,"discussion_content":"electricService.doCharge();  electricService是代理对象，是会走切面，可以实践一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635431047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541789,"discussion_content":"他们说的应该是修正前的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640568869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":409402,"ip_address":""},"score":541789,"extra":""}]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382540,"discussion_content":"是的没错 确实是这样不执行的 \n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625627861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168960,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/40/e1a51ac1.jpg","nickname":"Washington","note":"","ucode":"00F5F36416147D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374289,"discussion_content":"我也有同样的疑问，这个doCharge的修改不是和上节课案例一：this 调用的当前类方法无法被拦截是一样的么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621108625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304485,"user_name":"大斌啊啊啊","can_delete":false,"product_type":"c1","uid":2094057,"ip_address":"","ucode":"FB28CC7890D574","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83errHypG6kuO0QPzlibWLetJqTKy9JzxYbDYEjfjZMuIvdvDTeIJJlETLJicIeETVTLYoc19ohQiaXRkA/132","comment_is_top":false,"comment_ctime":1627451118,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23102287598","product_id":100077001,"comment_content":"&quot;如果两个方法名长度相同，则依次比较每一个字母的 ASCII 码，ASCII 码越小，排序越靠前；若长度不同，且短的方法名字符串是长的子集时，短的排序靠前。&quot; 这里的描述好像有点问题，短的方法名字符串是长的子集时，短的排序不一定靠前。因为子集不能保证起始值相同，比如说”bc“是”abc“的子集，但是abc会排前面吧","like_count":5,"discussions":[{"author":{"id":2613555,"avatar":"https://static001.geekbang.org/account/avatar/00/27/e1/33/247c5c9c.jpg","nickname":"天上明月","note":"","ucode":"A16AEE2A360442","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572778,"discussion_content":"从左到右，依次比较，字符相同就比较下一个字符，字符不同循环就结束","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652952493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541788,"discussion_content":"看源码是忠实地从左往右逐个比较，谁小谁靠前，比较次数为较短字符串的长度。如果都一样，则谁短谁靠前。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640568771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298923,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1624375220,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"18804244404","product_id":100077001,"comment_content":"这段代码调用doCharge()会失效的。这不是上节课的坑吗？就躺进去了<br><br>@Service<br>public class ElectricService {<br> <br>    public void charge() {<br>        doCharge();<br>    }<br>    public void doCharge() {<br>        System.out.println(&quot;Electric charging ...&quot;);<br>    }<br>}","like_count":4,"discussions":[{"author":{"id":2450893,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/L8EpqHoAnmvkzCIsdOkv5QvhIzu5tMaF2FDusXShqukv5ZBkS8DbicWaErjnYydibiaqBrs70wQ8P6axvC2FbWpbQ/132","nickname":"Geek_d3928c","note":"","ucode":"7CB09FD1F7CB23","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553635,"discussion_content":"是的，后面用Service来调用了，这老师也不回复读者的问题，就很奇怪","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1646011924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2613555,"avatar":"https://static001.geekbang.org/account/avatar/00/27/e1/33/247c5c9c.jpg","nickname":"天上明月","note":"","ucode":"A16AEE2A360442","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572779,"discussion_content":"本类中调用当前类的方法，是不走代理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652952528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2133923,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICJ4uqL3AleMbjUKX45haT5apSQicYRyCqfJ0tXkhgQ3t5OZUic9UTSpZXBdFyrbgyJOm3zicoxepeg/132","nickname":"Geek_ddc292","note":"","ucode":"E283DDA2E76880","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383565,"discussion_content":"后悔买课啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626161035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1437425,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ee/f1/16545faf.jpg","nickname":"学习","note":"","ucode":"CDFB71E0D1508B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2133923,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICJ4uqL3AleMbjUKX45haT5apSQicYRyCqfJ0tXkhgQ3t5OZUic9UTSpZXBdFyrbgyJOm3zicoxepeg/132","nickname":"Geek_ddc292","note":"","ucode":"E283DDA2E76880","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408779,"discussion_content":"最新的文章更新了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635323081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383565,"ip_address":""},"score":408779,"extra":""}]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382539,"discussion_content":"说的没错 我也纳闷呢 这老师还不回复\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625627814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325873,"user_name":"松松","can_delete":false,"product_type":"c1","uid":1337030,"ip_address":"","ucode":"EB2A80CF7BCA4B","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/c6/d779dfb6.jpg","comment_is_top":false,"comment_ctime":1639207028,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10229141620","product_id":100077001,"comment_content":"直觉上@Around和@Before是各干各的，容易把优先级理解成“先用@Around包一圈然后把@Before挂前头”，实际上同一个切面配置类里是捆在一起然后判断执行顺序的。<br>若干切面配置类之间的Order则是优先级高（数字小）的越外层（@Around和@Before先执行），优先级低的在内层。<br>怎么说呢，有点儿反直觉，特别是后者，圆环套圆环直觉上来说优先级越高越靠近本体来着。<br>把@Around、@Before、@After拆到三个优先级从高到低的配置类中，那么会变成@Around-&gt;@Before-&gt;proceed()-&gt;@After-&gt;@Around的顺序，和放在同一个配置类中的@Around-&gt;@Before-&gt;proceed()-&gt;@Around()-&gt;@After是不一样的。","like_count":2,"discussions":[{"author":{"id":2943644,"avatar":"","nickname":"Geek_de7049","note":"","ucode":"DC0779858443FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562508,"discussion_content":"放在不同配置类中@After和@Around的执行顺序，应该是跟他们配置类的@Order相关吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649840131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291411,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1620279172,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10210213764","product_id":100077001,"comment_content":"思考题：切面实现Order接口或者增加@Ordered注解<br>AspectJAwareAdvisorAutoProxyCreator#sortAdvisors  --&gt;  <br>AnnotationAwareOrderComparator.sort(advisors)    AnnotationAwareOrderComparator<br><br>另外有个小问题：PartialOrder.sort(partiallyComparableAdvisors) 这段代码是在干啥，没看明白。<br>","like_count":2,"discussions":[{"author":{"id":1676064,"avatar":"https://static001.geekbang.org/account/avatar/00/19/93/20/da7c92a1.jpg","nickname":"鱼鱼鱼","note":"","ucode":"3B55D9861FCE6D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372502,"discussion_content":"偏序排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620356630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354599,"user_name":"尘灬","can_delete":false,"product_type":"c1","uid":2033168,"ip_address":"江苏","ucode":"553924A550B3BD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/06/10/77f6ccea.jpg","comment_is_top":false,"comment_ctime":1660576923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660576923","product_id":100077001,"comment_content":"spring5.3.x版本之前的顺序是上面这样的 <br>之后的顺序是<br>around前置，before 目标方法 afterreturning&#47;afterthrowing  after  around后置","like_count":1},{"had_liked":false,"id":341355,"user_name":"行者","can_delete":false,"product_type":"c1","uid":2967886,"ip_address":"","ucode":"5241CAE6F8E59B","user_header":"https://static001.geekbang.org/account/avatar/00/2d/49/4e/f97abc5b.jpg","comment_is_top":false,"comment_ctime":1649563476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649563476","product_id":100077001,"comment_content":"笔记：<br>在同一个切面配置中，如果存在多个不同类型的增强，那么其执行优先级是按照增强类型的特定顺序排列，依次的增强类型为 Around.class,Before.class,After.class,AfterReturning.class,AfterThrowing.class;<br>在同一个切面配置中，如果存在多个相同类型的增强，那么其执行优先级是按照该增强的方法名排序，排序放松依次为比较方法名的每一个字母，直到发现第一个不相同且ASCII码较小的字母","like_count":0},{"had_liked":false,"id":337403,"user_name":"安迪密恩","can_delete":false,"product_type":"c1","uid":1331611,"ip_address":"","ucode":"A6F3F67CF8E6F8","user_header":"https://static001.geekbang.org/account/avatar/00/14/51/9b/ccea47d9.jpg","comment_is_top":false,"comment_ctime":1646807338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646807338","product_id":100077001,"comment_content":"师傅领进门，修行在个人。<br>专栏有瑕疵不要紧，知识学到手才是重要的啊同学们。<br>共勉。","like_count":1},{"had_liked":false,"id":337401,"user_name":"安迪密恩","can_delete":false,"product_type":"c1","uid":1331611,"ip_address":"","ucode":"A6F3F67CF8E6F8","user_header":"https://static001.geekbang.org/account/avatar/00/14/51/9b/ccea47d9.jpg","comment_is_top":false,"comment_ctime":1646806347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646806347","product_id":100077001,"comment_content":"这里的 字符l 是不是写错了， 应该是字符 v？<br><br>我们可以将原来的 validateAuthority() 改为 checkAuthority()，这种情况下，对增强（Advisor）的排序，其实最后就是在比较字符 l 和 字符 c。","like_count":0},{"had_liked":false,"id":333555,"user_name":"","can_delete":false,"product_type":"c1","uid":2907669,"ip_address":"","ucode":"","user_header":"","comment_is_top":false,"comment_ctime":1644403226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644403226","product_id":100077001,"comment_content":"其实想一下优先级是用于提前执行的顺序，所以外圈的先执行也容易理解了","like_count":0},{"had_liked":false,"id":318523,"user_name":"学习","can_delete":false,"product_type":"c1","uid":1437425,"ip_address":"","ucode":"CDFB71E0D1508B","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/f1/16545faf.jpg","comment_is_top":false,"comment_ctime":1635323015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635323015","product_id":100077001,"comment_content":"关于doChange()问题，好似后面都重新发文章了，现在是自己注入了自己，看得我一脸懵逼","like_count":0}]}