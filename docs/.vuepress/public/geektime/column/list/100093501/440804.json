{"id":440804,"title":"13｜基本数据类型：为什么Go要原生支持字符串类型？","content":"<p>你好，我是Tony Bai。</p><p>在上节课中，我们讲解了在Go编程中最广泛使用的一类基本数据类型：<strong>数值类型</strong>，包括整型、浮点类型和复数类型。这一节课，我们继续来学习Go语言中另一类基本数据类型：<strong>字符串类型</strong>。</p><p>字符串类型，是现代编程语言中最常用的数据类型之一，多数主流编程语言都提供了对这个类型的原生支持，少数没有提供原生字符串的类型的主流语言（比如C语言）也通过其他形式提供了对字符串的支持。</p><p>对于这样在日常开发中高频使用的基本数据类型，我们要给予更多的关注。所以，我们这一节课，将会按照Why-What-How的逻辑，讲清楚Go对字符串类型的支持，让你对Go语言中的字符串有个完整而清晰的认识。</p><p>首先，让我们来看看为什么Go要原生支持字符串类型。</p><h2>原生支持字符串有什么好处？</h2><p>我们前面提过，Go是站在巨人的肩膀上成长起来的现代编程语言。它继承了前辈语言的优点，又改进了前辈语言中的不足。这其中一处就体现在Go对字符串类型的原生支持上。</p><p>这样的设计会有什么好处呢？作为对比，我们先来看看前辈语言之一的C语言对字符串的支持情况。</p><p>C语言没有提供对字符串类型的原生支持，也就是说，C语言中并没有“字符串”这个数据类型。在C语言中，字符串是以字符串字面值或以’\\0’结尾的字符类型数组来呈现的，比如下面代码：</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">#define GO_SLOGAN \"less is more\"\nconst char * s1 = \"hello, gopher\"\nchar s2[] = \"I love go\"\n</code></pre><p>这样定义的非原生字符串在使用过程中会有很多问题，比如：</p><ul>\n<li>不是原生类型，编译器不会对它进行类型校验，导致类型安全性差；</li>\n<li>字符串操作时要时刻考虑结尾的’\\0’，防止缓冲区溢出；</li>\n<li>以字符数组形式定义的“字符串”，它的值是可变的，在并发场景中需要考虑同步问题；</li>\n<li>获取一个字符串的长度代价较大，通常是O(n)时间复杂度；</li>\n<li>C语言没有内置对非ASCII字符（如中文字符）的支持。</li>\n</ul><p>这些问题都大大加重了开发人员在使用字符串时的心智负担。于是，Go设计者们选择了原生支持字符串类型。</p><p>在Go中，字符串类型为 <strong>string</strong>。Go语言通过string类型统一了对“字符串”的抽象。这样无论是字符串常量、字符串变量或是代码中出现的字符串字面值，它们的类型都被统一设置为string，比如上面C代码换成等价的Go代码是这样的：</p><pre><code class=\"language-plain\">const (\n\tGO_SLOGAN = \"less is more\" // GO_SLOGAN是string类型常量\n\ts1 = \"hello, gopher\"       // s1是string类型常量\n)\n\nvar s2 = \"I love go\" // s2是string类型变量\n</code></pre><p>那既然我们都说了，Go原生支持string的做法是对前辈语言的改进，这样的设计到底有哪些优秀的性质，会带来什么好处呢？</p><p><strong>第一点：string类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。</strong></p><p>Go语言规定，字符串类型的值在它的生命周期内是不可改变的。这就是说，如果我们声明了一个字符串类型的变量，那我们是无法通过这个变量改变它对应的字符串值的，但这并不是说我们不能为一个字符串类型变量进行二次赋值。</p><p>什么意思呢？我们看看下面的代码就好理解了：</p><pre><code class=\"language-plain\">var s string = \"hello\"\ns[0] = 'k'   // 错误：字符串的内容是不可改变的\ns = \"gopher\" // ok\n</code></pre><p>在这段代码中，我们声明了一个字符串类型变量s。当我们试图通过下标方式把这个字符串的第一个字符由h改为k的时候，我们会收到编译器错误的提示：<strong>字符串是不可变的</strong>。但我们仍可以像最后一行代码那样，为变量s重新赋值为另外一个字符串。</p><p>Go这样的“字符串类型数据不可变”的性质给开发人员带来的最大好处，就是我们不用再担心字符串的并发安全问题。这样，Go字符串可以被多个Goroutine（Go语言的轻量级用户线程，后面我们会详细讲解）共享，开发者不用因为担心并发安全问题，使用会带来一定开销的同步机制。</p><p>另外，也由于字符串的不可变性，针对同一个字符串值，无论它在程序的几个位置被使用，Go编译器只需要为它分配一块存储就好了，大大提高了存储利用率。</p><p><strong>第二点：没有结尾’\\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</strong></p><p>在C语言中，获取一个字符串的长度可以调用标准库的strlen函数，这个函数的实现原理是遍历字符串中的每个字符并做计数，直到遇到字符串的结尾’\\0’停止。显然这是一个线性时间复杂度的算法，执行时间与字符串中字符个数成正比。并且，它存在一个约束，那就是传入的字符串必须有结尾’\\0’，结尾’\\0’是字符串的结束标志。如果你使用过C语言，想必你也吃过字符串结尾’\\0’的亏。</p><p>Go语言修正了这个缺陷，Go字符串中没有结尾’\\0’，获取字符串长度更不需要结尾’\\0’作为结束标志。并且，Go获取字符串长度是一个常数级时间复杂度，无论字符串中字符个数有多少，我们都可以快速得到字符串的长度值。至于这方面的原理，我们等会再详细说明。</p><p><strong>第三点：原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</strong></p><p>如果我们要在C语言中构造多行字符串，一般就是两个方法：要么使用多个字符串的自然拼接，要么需要结合续行符\"\"。但因为有转义字符的存在，我们很难控制好格式。<strong>Go语言就简单多了，</strong>通过一对反引号原生支持构造“所见即所得”的原始字符串（Raw String）。而且，Go语言原始字符串中的任意转义字符都不会起到转义的作用。比如下面这段代码：</p><pre><code>var s string = `         ,_---~~~~~----._\n    _,,_,*^____      _____*g*\\&quot;*,--,\n   / __/ /'     ^.  /      \\ ^@q   f\n  [  @f | @))    |  | @))   l  0 _/\n   \\/   \\~____ / __ \\_____/     \\\n    |           _l__l_           I\n    }          [______]           I\n    ]            | | |            |\n    ]             ~ ~             |\n    |                            |\n     |                           |`\nfmt.Println(s)\n</code></pre><p>你可以看到，字符串变量s被赋值了一个由一对反引号包裹的Gopher图案。这个Gopher图案由诸多ASCII字符组成，其中就包括了转义字符。这个时候，如果我们通过Println函数输出这个字符串，得到的图案和上面的图案并无二致。</p><p><strong>第四点：对非ASCII字符提供原生支持，消除了源码在不同环境下显示乱码的可能。</strong></p><p>Go语言源文件默认采用的是Unicode字符集，Unicode字符集是目前市面上最流行的字符集，它囊括了几乎所有主流非ASCII字符（包括中文字符）。Go字符串中的每个字符都是一个Unicode字符，并且这些Unicode字符是以UTF-8编码格式存储在内存当中的。在接下来讲解Go字符串的组成时，我们还会对这部分内容做进一步讲解。</p><p>知道了Go原生支持字符串类型带来的诸多变化和好处后，我们接下来就要深入到Go字符串的机制里看看，看看Go字符串是由什么组成的。</p><h2>Go字符串的组成</h2><p>Go语言在看待Go字符串组成这个问题上，有两种视角。一种是<strong>字节视角</strong>，也就是和所有其它支持字符串的主流语言一样，<strong>Go语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意。</strong></p><p>比如在下面代码中，我们输出了字符串中的每个字节，以及整个字符串的长度：</p><pre><code class=\"language-plain\">var s = \"中国人\"\nfmt.Printf(\"the length of s = %d\\n\", len(s)) // 9\n\nfor i := 0; i &lt; len(s); i++ {\n\tfmt.Printf(\"0x%x \", s[i]) // 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba\n}\nfmt.Printf(\"\\n\")\n</code></pre><p>我们看到，由“中国人”构成的字符串的字节序列长度为9。并且，仅从某一个输出的字节来看，它是不能与字符串中的任一个字符对应起来的。</p><p>如果要表意，我们就需要从字符串的另外一个视角来看，也就是<strong>字符串是由一个可空的字符序列构成</strong>。这个时候我们再看下面代码：</p><pre><code class=\"language-plain\">var s = \"中国人\"\nfmt.Println(\"the character count in s is\", utf8.RuneCountInString(s)) // 3\n\nfor _, c := range s {\n\tfmt.Printf(\"0x%x \", c) // 0x4e2d 0x56fd 0x4eba\n}\nfmt.Printf(\"\\n\")\n</code></pre><p>在这段代码中，我们输出了字符串中的字符数量，也输出了这个字符串中的每个字符。前面说过，Go采用的是Unicode字符集，每个字符都是一个Unicode字符，那么这里输出的0x4e2d、0x56fd和0x4eba就应该是某种Unicode字符的表示了。没错，以0x4e2d为例，它是汉字“中”在Unicode字符集表中的码点（Code Point）。</p><p>那么，什么是Unicode码点呢？</p><p>Unicode字符集中的每个字符，都被分配了统一且唯一的字符编号。所谓 <strong>Unicode码点</strong>，就是指将Unicode字符集中的所有字符“排成一队”，字符在这个“队伍”中的<strong>位次</strong>，就是它在Unicode字符集中的码点。也就说，一个码点唯一对应一个字符。“码点”的概念和我们马上要讲的rune类型有很大关系。</p><h3>rune类型与字符字面值</h3><p>Go使用rune这个类型来表示一个Unicode码点。rune本质上是int32类型的别名类型，它与int32类型是完全等价的，在Go源码中我们可以看到它的定义是这样的：</p><pre><code class=\"language-plain\">// $GOROOT/src/builtin.go\ntype rune = int32\n</code></pre><p>由于一个Unicode码点唯一对应一个Unicode字符。所以我们可以说，<strong>一个rune实例就是一个Unicode字符，一个Go字符串也可以被视为rune实例的集合。我们可以通过字符字面值来初始化一个rune变量。</strong></p><p>在Go中，字符字面值有多种表示法，最常见的是<strong>通过单引号括起的字符字面值</strong>，比如：</p><pre><code class=\"language-plain\">'a'  // ASCII字符\n'中' // Unicode字符集中的中文字符\n'\\n' // 换行字符\n'\\'' // 单引号字符\n</code></pre><p>我们还可以使用<strong>Unicode专用的转义字符\\u或\\U作为前缀，</strong>来表示一个Unicode字符，比如：</p><pre><code class=\"language-plain\">'\\u4e2d'     // 字符：中\n'\\U00004e2d' // 字符：中\n'\\u0027'     // 单引号字符\n</code></pre><p>这里，我们要注意，\\u后面接四个十六进制数。如果是用四个十六进制数无法表示的Unicode字符，我们可以使用\\U，\\U后面可以接八个十六进制数来表示一个Unicode字符。</p><p>而且，由于表示码点的rune本质上就是一个整型数，所以我们还可<strong>用整型值来直接作为字符字面值给rune变量赋值</strong>，比如下面代码：</p><pre><code class=\"language-plain\">'\\x27'  // 使用十六进制表示的单引号字符\n'\\047'  // 使用八进制表示的单引号字符\n</code></pre><h3>字符串字面值</h3><p>字符串是字符的集合，了解了字符字面值后，字符串的字面值也就很简单了。只不过字符串是多个字符，所以我们需要<strong>把表示单个字符的单引号，换为表示多个字符组成的字符串的双引号</strong>就可以了。我们可以看下面这些例子：</p><pre><code class=\"language-plain\">\"abc\\n\"\n\"中国人\"\n\"\\u4e2d\\u56fd\\u4eba\" // 中国人\n\"\\U00004e2d\\U000056fd\\U00004eba\" // 中国人\n\"中\\u56fd\\u4eba\" // 中国人，不同字符字面值形式混合在一起\n\"\\xe4\\xb8\\xad\\xe5\\x9b\\xbd\\xe4\\xba\\xba\" // 十六进制表示的字符串字面值：中国人\n</code></pre><p>我们看到，将单个Unicode字符字面值一个接一个地连在一起，并用双引号包裹起来就构成了字符串字面值。甚至，我们也可以像倒数第二行那样，将不同字符字面值形式混合在一起，构成一个字符串字面值。</p><p>不过，这里你可能发现了一个问题，上面示例代码的最后一行使用的是十六进制形式的字符串字面值，但每个字节的值与前面几行的码点值完全对应不上啊，这是为什么呢？</p><p>这个字节序列实际上是“中国人”这个Unicode字符串的UTF-8编码值。什么是UTF-8编码？它又与Unicode字符集有什么关系呢？</p><h3>UTF-8编码方案</h3><p>UTF-8编码解决的是Unicode码点值在计算机中如何存储和表示（位模式）的问题。那你可能会说，码点唯一确定一个Unicode字符，直接用码点值不行么？</p><p>这的确是可以的，并且UTF-32编码标准就是采用的这个方案。UTF-32编码方案固定使用4个字节表示每个Unicode字符码点，这带来的好处就是编解码简单，但缺点也很明显，主要有下面几点：</p><ul>\n<li>这种编码方案使用4个字节存储和传输一个整型数的时候，需要考虑不同平台的字节序问题;</li>\n<li>由于采用4字节的固定长度编码，与采用1字节编码的ASCII字符集无法兼容；</li>\n<li>所有Unicode字符码点都用4字节编码，显然空间利用率很差。</li>\n</ul><p>针对这些问题，Go语言之父Rob Pike发明了UTF-8编码方案。和UTF-32方案不同，UTF-8方案使用变长度字节，对Unicode字符的码点进行编码。编码采用的字节数量与Unicode字符在码点表中的序号有关：表示序号（码点）小的字符使用的字节数量少，表示序号（码点）大的字符使用的字节数多。</p><p>UTF-8编码使用的字节数量从1个到4个不等。前128个与ASCII字符重合的码点（U+0000~U+007F）使用1个字节表示；带变音符号的拉丁文、希腊文、西里尔字母、阿拉伯文等使用2个字节来表示；而东亚文字（包括汉字）使用3个字节表示；其他极少使用的语言的字符则使用4个字节表示。</p><p>这样的编码方案是兼容ASCII字符内存表示的，这意味着采用UTF-8方案在内存中表示Unicode字符时，已有的ASCII字符可以被直接当成Unicode字符进行存储和传输，不用再做任何改变。</p><p>此外，UTF-8的编码单元为一个字节（也就是一次编解码一个字节），所以我们在处理UTF-8方案表示的Unicode字符的时候，就不需要像UTF-32方案那样考虑字节序问题了。相对于UTF-32方案，UTF-8方案的空间利用率也是最高的。</p><p>现在，UTF-8编码方案已经成为Unicode字符编码方案的事实标准，各个平台、浏览器等默认均使用UTF-8编码方案对Unicode字符进行编、解码。Go语言也不例外，采用了UTF-8编码方案存储Unicode字符，我们在前面按字节输出一个字符串值时看到的字节序列，就是对字符进行UTF-8编码后的值。</p><p>那么现在我们就使用Go在标准库中提供的UTF-8包，对Unicode字符（rune）进行编解码试试看：</p><pre><code class=\"language-plain\">// rune -&gt; []byte                                                                            \nfunc encodeRune() {                                                                          \n    var r rune = 0x4E2D                                                                      \n    fmt.Printf(\"the unicode charactor is %c\\n\", r) // 中                                     \n    buf := make([]byte, 3)                                                                   \n    _ = utf8.EncodeRune(buf, r) // 对rune进行utf-8编码                                                           \n    fmt.Printf(\"utf-8 representation is 0x%X\\n\", buf) // 0xE4B8AD                            \n}                                                                                            \n                                                                                             \n// []byte -&gt; rune                                                                            \nfunc decodeRune() {                                                                          \n    var buf = []byte{0xE4, 0xB8, 0xAD}                                                       \n    r, _ := utf8.DecodeRune(buf) // 对buf进行utf-8解码\n    fmt.Printf(\"the unicode charactor after decoding [0xE4, 0xB8, 0xAD] is %s\\n\", string(r)) // 中\n}\n</code></pre><p>这段代码中，encodeRune通过调用UTF-8的EncodeRune函数实现了对一个rune，也就是一个Unicode字符的编码，decodeRune则调用UTF-8包的decodeRune，将一段内存字节转换回一个Unicode字符。</p><p>好了，现在我们已经搞清楚Go语言中字符串类型的性质和组成了。有了这些基础之后，我们就可以看看Go是如何实现字符串类型的。也就是说，在Go的编译器和运行时中，一个字符串变量究竟是如何表示的？</p><h2>Go字符串类型的内部表示</h2><p>其实，我们前面提到的Go字符串类型的这些优秀的性质，Go字符串在编译器和运行时中的内部表示是分不开的。Go字符串类型的内部表示究竟是什么样的呢？在标准库的reflect包中，我们找到了答案，你可以看看下面代码：</p><pre><code class=\"language-plain\">// $GOROOT/src/reflect/value.go\n\n// StringHeader是一个string的运行时表示\ntype StringHeader struct {\n    Data uintptr\n    Len  int\n}\n</code></pre><p>我们可以看到，<strong>string类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。</strong>我也画了一张图，直观地展示了一个string类型变量在Go内存中的存储：</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/28/6c94a2f5a0f942e361792b26f5abfa28.jpg?wh=1920x1047\" alt=\"图片\"></p><p>你看，Go编译器把源码中的string类型映射为运行时的一个二元组（Data, Len），真实的字符串值数据就存储在一个被Data指向的底层数组中。通过Data字段，我们可以得到这个数组的内容，你可以看看下面这段代码：</p><pre><code class=\"language-plain\">func dumpBytesArray(arr []byte) {\n    fmt.Printf(\"[\")\n    for _, b := range arr {\n        fmt.Printf(\"%c \", b)\n    }\n    fmt.Printf(\"]\\n\")\n}\n\nfunc main() {\n    var s = \"hello\"\n    hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // 将string类型变量地址显式转型为reflect.StringHeader\n    fmt.Printf(\"0x%x\\n\", hdr.Data) // 0x10a30e0\n    p := (*[5]byte)(unsafe.Pointer(hdr.Data)) // 获取Data字段所指向的数组的指针\n    dumpBytesArray((*p)[:]) // [h e l l o ]   // 输出底层数组的内容\n}\n</code></pre><p>这段代码利用了unsafe.Pointer的通用指针转型能力，按照StringHeader给出的结构内存布局，“顺藤摸瓜”，一步步找到了底层数组的地址，并输出了底层数组内容。</p><p>知道了string类型的实现原理后，我们再回头看看Go字符串类型性质中“获取长度的时间复杂度是常数时间”那句，是不是就很好理解了？之所以是常数时间，那是因为字符串类型中包含了字符串长度信息，当我们用len函数获取字符串长度时，len函数只要简单地将这个信息提取出来就可以了。</p><p>了解了string类型的实现原理后，我们还可以得到这样一个结论，那就是<strong>我们直接将string类型通过函数/方法参数传入也不会带来太多的开销。</strong>因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</p><p>那么，了解了Go字符串的一些基本信息和原理后，我们从理论转向实际，看看日常开发中围绕字符串类型都有哪些常见操作。</p><h2>Go字符串类型的常见操作</h2><p>由于字符串的不可变性，针对字符串，我们更多是尝试对其进行读取，或者将它作为一个组成单元去构建其他字符串，又或是转换为其他类型。下面我们逐一来看一下这些字符串操作：</p><p><strong>第一个操作：下标操作。</strong></p><p>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作。我们在前面的代码中实际碰到过针对字符串的下标操作，形式是这样的：</p><pre><code class=\"language-plain\">var s = \"中国人\"\nfmt.Printf(\"0x%x\\n\", s[0]) // 0xe4：字符“中” utf-8编码的第一个字节\n</code></pre><p>我们可以看到，通过下标操作，我们获取的是字符串中特定下标上的字节，而不是字符。</p><p><strong>第二个操作：字符迭代。</strong></p><p>Go有两种迭代形式：常规for迭代与for range迭代。<strong>你要注意，通过这两种形式的迭代对字符串进行操作得到的结果是不同的</strong>。</p><p>通过常规for迭代对字符串进行的操作是一种字节视角的迭代，每轮迭代得到的的结果都是组成字符串内容的一个字节，以及该字节所在的下标值，这也等价于对字符串底层数组的迭代，比如下面代码：</p><pre><code class=\"language-plain\">var s = \"中国人\"\n\nfor i := 0; i &lt; len(s); i++ {\n\tfmt.Printf(\"index: %d, value: 0x%x\\n\", i, s[i])\n}\n</code></pre><p>运行这段代码，我们会看到，经过常规for迭代后，我们获取到的是字符串里字符的UTF-8编码中的一个字节：</p><pre><code class=\"language-plain\">index: 0, value: 0xe4\nindex: 1, value: 0xb8\nindex: 2, value: 0xad\nindex: 3, value: 0xe5\nindex: 4, value: 0x9b\nindex: 5, value: 0xbd\nindex: 6, value: 0xe4\nindex: 7, value: 0xba\nindex: 8, value: 0xba\n</code></pre><p>而像下面这样使用for range迭代，我们得到的又是什么呢？我们继续看代码：</p><pre><code class=\"language-plain\">var s = \"中国人\"\n\nfor i, v := range s {\n    fmt.Printf(\"index: %d, value: 0x%x\\n\", i, v)\n}\n</code></pre><p>同样运行一下这段代码，我们得到：</p><pre><code class=\"language-plain\">index: 0, value: 0x4e2d\nindex: 3, value: 0x56fd\nindex: 6, value: 0x4eba\n</code></pre><p>我们看到，通过for range迭代，我们每轮迭代得到的是字符串中Unicode字符的码点值，以及该字符在字符串中的偏移值。我们可以通过这样的迭代，获取字符串中的字符个数，而通过Go提供的内置函数len，我们只能获取字符串内容的长度（字节个数）。当然了，获取字符串中字符个数更专业的方法，是调用标准库UTF-8包中的RuneCountInString函数，这点你可以自己试一下。</p><p><strong>第三个操作：字符串连接。</strong></p><p>我们前面已经知道，字符串内容是不可变的，但这并不妨碍我们基于已有字符串创建新字符串。Go原生支持通过+/+=操作符进行字符串连接，这也是对开发者体验最好的字符串连接操作，你可以看看下面这段代码：</p><pre><code class=\"language-plain\">s := \"Rob Pike, \"\ns = s + \"Robert Griesemer, \"\ns += \" Ken Thompson\"\n\nfmt.Println(s) // Rob Pike, Robert Griesemer, Ken Thompson\n</code></pre><p>不过，虽然通过+/+=进行字符串连接的开发体验是最好的，但连接性能就未必是最快的了。除了这个方法外，Go还提供了strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作。关于这些方法的性能讨论，我放到了后面的思考题里，我想让你先去找一下答案。</p><p><strong>第四个操作：字符串比较。</strong></p><p>Go字符串类型支持各种比较关系操作符，包括= =、!= 、&gt;=、&lt;=、&gt; 和 &lt;。在字符串的比较上，Go采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。</p><p>当两个字符串之间出现了第一个不相同的元素，比较就结束了，这两个元素的比较结果就会做为串最终的比较结果。如果出现两个字符串长度不同的情况，长度比较小的字符串会用空元素补齐，空元素比其他非空元素都小。</p><p>这里我给了一个Go字符串比较的示例：</p><pre><code class=\"language-plain\">func main() {\n        // ==\n        s1 := \"世界和平\"\n        s2 := \"世界\" + \"和平\"\n        fmt.Println(s1 == s2) // true\n\n        // !=\n        s1 = \"Go\"\n        s2 = \"C\"\n        fmt.Println(s1 != s2) // true\n\n        // &lt; and &lt;=\n        s1 = \"12345\"\n        s2 = \"23456\"\n        fmt.Println(s1 &lt; s2)  // true\n        fmt.Println(s1 &lt;= s2) // true\n\n        // &gt; and &gt;=\n        s1 = \"12345\"\n        s2 = \"123\"\n        fmt.Println(s1 &gt; s2)  // true\n        fmt.Println(s1 &gt;= s2) // true\n}\n</code></pre><p>你可以看到，鉴于Go string类型是不可变的，所以说如果两个字符串的长度不相同，那么我们不需要比较具体字符串数据，也可以断定两个字符串是不同的。但是如果两个字符串长度相同，就要进一步判断，数据指针是否指向同一块底层存储数据。如果还相同，那么我们可以说两个字符串是等价的，如果不同，那就还需要进一步去比对实际的数据内容。</p><p><strong>第五个操作：字符串转换。</strong></p><p>在这方面，Go支持字符串与字节切片、字符串与rune切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换就可以了。我们看看下面代码：</p><pre><code class=\"language-plain\">var s string = \"中国人\"\n                      \n// string -&gt; []rune\nrs := []rune(s) \nfmt.Printf(\"%x\\n\", rs) // [4e2d 56fd 4eba]\n                \n// string -&gt; []byte\nbs := []byte(s) \nfmt.Printf(\"%x\\n\", bs) // e4b8ade59bbde4baba\n                \n// []rune -&gt; string\ns1 := string(rs)\nfmt.Println(s1) // 中国人\n                \n// []byte -&gt; string\ns2 := string(bs)\nfmt.Println(s2) // 中国人\n</code></pre><p>这样的转型看似简单，但无论是string转切片，还是切片转string，这类转型背后也是有着一定开销的。这些开销的根源就在于string是不可变的，运行时要为转换后的类型分配新内存。</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了。这一节课，我们学习了Go中另外一类最常用的基本数据类型：字符串类型。Go原生支持字符串类型，所有字符串变量、常量、字面值都统一设置为string类型，对string的原生支持使得Go字符串有了很多优秀性质。</p><p>我们可以使用两个视角来看待Go字符串的组成，一种是字节视角。Go字符串是由一个可空的字节序列组成，字节的个数称为字符串的长度；另外一种是字符视角。Go字符串是由一个可空的字符序列构成。Go字符串中的每个字符都是一个Unicode字符。</p><p>Go使用rune类型来表示一个Unicode字符的码点。为了传输和存储Unicode字符，Go还使用了UTF-8编码方案，UTF-8编码方案使用变长字节的编码方式，码点小的字符用较少的字节编码，码点大的字符用较多字节编码，这种编码方式兼容ASCII字符集，并且拥有很高的空间利用率。</p><p>Go语言在运行时层面通过一个二元组结构（Data, Len）来表示一个string类型变量，其中Data是一个指向存储字符串数据内容区域的指针值，Len是字符串的长度。因此，本质上，一个string变量仅仅是一个“描述符”，并不真正包含字符串数据。因此，我们即便直接将string类型变量作为函数参数，其传递的开销也是恒定的，不会随着字符串大小的变化而变化。</p><p>Go为其原生支持的string类型提供了许多原生操作类型，在进行字符串操作时你要注意以下几点：</p><ul>\n<li>通过常规for迭代与for range迭代所得到的结果不同，常规for迭代采用的是字节视角；而for range迭代采用的是字符视角；</li>\n<li>基于+/+=操作符的字符串连接是对开发者体验最好的字符串连接方式，但却不是性能最好的方式；</li>\n<li>无论是字符串转切片，还是切片转字符串，都会有内存分配的开销，这缘于Go字符串数据内容不可变的性质。</li>\n</ul><h2>思考题</h2><p>我们前面讲到，Go提供多种字符串连接服务，包括基于+/+=的字符连接、基于strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作。那么，哪种连接方式是性能最高的呢？期待在留言区看到你的想法。</p><p>欢迎把这节课分享给更多对Go语言字符串类型感兴趣的朋友。我是Tony Bai，我们下节课见。</p>","neighbors":{"left":{"article_title":"12｜基本数据类型：Go原生支持的数值类型有哪些？","id":439782},"right":{"article_title":"14｜常量：Go在“常量”设计上的创新有哪些？","id":442791}},"comments":[{"had_liked":false,"id":321019,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1636621796,"is_pvip":false,"replies":[{"id":116755,"content":"简直就是标准答案👍","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636929420,"ip_address":"","comment_id":321019,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"func plusConcat(n int, str string) string {\n\t&#47;&#47; +号拼接\n}\n\nfunc sprintfConcat(n int, str string) string {\n\t&#47;&#47;fmt.Sprintf拼接\n}\n\nfunc builderConcat(n int, str string) string {\n\tvar builder strings.Builder\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuilder.WriteString(str)\n\t}\n\treturn builder.String()\n}\n\nfunc bufferConcat(n int, s string) string {\n\tbuf := new(bytes.Buffer)\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuf.WriteString(s)\n\t}\n\treturn buf.String()\n}\n\nfunc byteConcat(n int, str string) string {\n\tbuf := make([]byte, 0)\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuf = append(buf, str...)\n\t}\n\treturn string(buf)\n}\nfunc preByteConcat(n int, str string) string {\n\tbuf := make([]byte, 0, n*len(str))\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuf = append(buf, str...)\n\t}\n\treturn string(buf)\n}\nfunc builderGrowConcat(n int, str string) string {\n\tvar builder strings.Builder\n\tbuilder.Grow(n * len(str))\n\t&#47;&#47; 与builderConcat相同\n}\nfunc bufferGrowConcat(n int, s string) string {\n\tbuf := new(bytes.Buffer)\n\tbuf.Grow(n * len(s))\n\t&#47;&#47; 与bufferConcat相同\n}\nbenchmem测试：\n    24          47124538 ns&#47;op        530996721 B&#47;op     10011 allocs&#47;op\n    13          81526461 ns&#47;op        834307836 B&#47;op     37463 allocs&#47;op\n 13263             90613 ns&#47;op          505841 B&#47;op         24 allocs&#47;op\n 12730             94213 ns&#47;op          423537 B&#47;op         13 allocs&#47;op\n 12992             94185 ns&#47;op          612338 B&#47;op         25 allocs&#47;op\n 23606             50058 ns&#47;op          212992 B&#47;op          2 allocs&#47;op\n 24326             49660 ns&#47;op          106496 B&#47;op          1 allocs&#47;op\n 16762             71860 ns&#47;op          212993 B&#47;op          2 allocs&#47;op\n 如果能知道拼接字符串的个数，那么使用bytes.Buffer和strings.Builder的Grows申请空间后，性能是最好的；如果不能确定长度，那么bytes.Buffer和strings.Builder也比“+”和fmt.Sprintf性能好很多。\n\n bytes.Buffer与strings.Builder，strings.Builder更合适，因为bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回了回来。\n\n bytes.Buffer 的注释中还特意提到了：\n\nTo build strings more efficiently, see the strings.Builder type.","like_count":148},{"had_liked":false,"id":330026,"user_name":"Vfeelit","can_delete":false,"product_type":"c1","uid":1501818,"ip_address":"","ucode":"F3FF2B069F347F","user_header":"https://static001.geekbang.org/account/avatar/00/16/ea/7a/d857723d.jpg","comment_is_top":false,"comment_ctime":1641738130,"is_pvip":false,"replies":[{"id":120489,"content":"好问题。这个问题我也曾想过，官方没有答案。但从社区给出的观点来看，主要考虑两点：1.int32足够表示unicode所有码点 2. int32可以为负数，便于检测溢出(overflow)或其他基于int32的计算错误。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642042652,"ip_address":"","comment_id":330026,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"rune 是 int32 别名  Unicode编码没有负的吧 为何不是 uint32的别名？","like_count":24,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530188,"discussion_content":"简直就是标准答案👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636929420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043824,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/70/dafc8858.jpg","nickname":"孟谦","note":"","ucode":"7504C438D973D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650834,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725704680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3904463,"avatar":"","nickname":"Geek_5759bc","note":"","ucode":"882F0A5AF1EE79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646910,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718982434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3554552,"avatar":"","nickname":"Geek_gofzw","note":"","ucode":"F5DFB1622C80BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608762,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678633831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336373,"user_name":"大大大大大泽","can_delete":false,"product_type":"c1","uid":2916508,"ip_address":"","ucode":"D9388E4777BA9F","user_header":"","comment_is_top":false,"comment_ctime":1646119198,"is_pvip":false,"replies":[{"id":122946,"content":"摘自网络:)\n\nunicode 符号范围 | utf-8 编码方式\n00000000 ~ 0000007F | 0xxxxxxx \n00000080 ~ 000007FF | 110xxxxx 10xxxxxx \n00000800 ~ 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx \n00010000 ~ 0010FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx \n\n总结下来，针对UTF8，编码规则其实只有两条：\n1）单字节规则： 对于 单字节 的符号，字节的第一位（最高位）设为 0，后面 7 位为这个符号的 unicode 码。\n2）n字节规则： 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646128890,"ip_address":"","comment_id":336373,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"有个问题不太懂。。。UTF-8 编码使用的字节数量从 1 个到 4 个不等。那么如何确定几个字节确定一个字符呢？\n比如说 中国人 是 \\xe4\\xb8\\xad\\xe5\\x9b\\xbd\\xe4\\xba\\xba，3个字节确定一个字符，分配为3 3 3。为什么不会分割成1 1 2 2 3","like_count":19,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545709,"discussion_content":"好问题。这个问题我也曾想过，官方没有答案。但从社区给出的观点来看，主要考虑两点：1.int32足够表示unicode所有码点 2. int32可以为负数，便于检测溢出(overflow)或其他基于int32的计算错误。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642042652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321169,"user_name":"你好呀, 朋友.","can_delete":false,"product_type":"c1","uid":2840465,"ip_address":"","ucode":"49E45F2E0AB679","user_header":"","comment_is_top":false,"comment_ctime":1636698605,"is_pvip":false,"replies":[{"id":116790,"content":"一个rune存储一个unicode码点或utf-32的四字节编码；从字节视角，string对应的底层存储存放的是utf8编码。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636965836,"ip_address":"","comment_id":321169,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"是不是可以理解成[]rune里存的是Unicode码点或者说UTF-32编码，而[]byte和string存的是UTF-8编码","like_count":13,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553902,"discussion_content":"摘自网络:)\n\nunicode 符号范围 | utf-8 编码方式\n00000000 ~ 0000007F | 0xxxxxxx \n00000080 ~ 000007FF | 110xxxxx 10xxxxxx \n00000800 ~ 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx \n00010000 ~ 0010FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx \n\n总结下来，针对UTF8，编码规则其实只有两条：\n1）单字节规则： 对于 单字节 的符号，字节的第一位（最高位）设为 0，后面 7 位为这个符号的 unicode 码。\n2）n字节规则： 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。\n\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1646128890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149221,"avatar":"https://static001.geekbang.org/account/avatar/00/11/89/25/02f1b5ec.jpg","nickname":"柳丁烧麦","note":"","ucode":"87F3F998277970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617679,"discussion_content":"“中”字为例，unicode为0x4e2d（0b0100 1110 0010 1101），位于00000800 ~ 0000FFFF区间。\n从右向左，依次替换 1110xxxx 10xxxxxx 10xxxxxx 中的“x”，不足补0，得:\n1110[0100] 10[111000] 10[101101]\n转为十六进制后即字节码：\ne4 b8 ad","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683773583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1197626,"avatar":"https://static001.geekbang.org/account/avatar/00/12/46/3a/20f80540.jpg","nickname":"Mr.增锋","note":"","ucode":"1D720DB133CA74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588815,"discussion_content":"可变长编码，幼麟实验室 有个讲解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664128586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321010,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1636619132,"is_pvip":true,"replies":[{"id":116598,"content":"反引号是唯一的“漏网之鱼”:)。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636668185,"ip_address":"","comment_id":321010,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"那么问题来了，raw string里要怎么使用反引号？","like_count":12,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530235,"discussion_content":"一个rune存储一个unicode码点或utf-32的四字节编码；从字节视角，string对应的底层存储存放的是utf8编码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636965836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336399,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1646128151,"is_pvip":false,"replies":[{"id":122947,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646128935,"ip_address":"","comment_id":336399,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"现代CPU计算时一次都能装载多个字节(如32位计算机一次装载4字节)，多字节的数值在内存中高低位的排列方式会影响所表示的数值，以数值0x01020304为例，在内存中用4个字节存储，4个字节的内容分别是0x01、0x02、0x03、0x04。根据字节高低位排序方式的不同，可以分为：大端字节序(big endian)和小端字节序(little endian)。\n\n大端字节序\n大端字节序是指一个整数的高位字节(如上例中的0x01)存储在内存的低地址处,高字节在前。\n\nC语言数组存储例：\n\n0x01020304\n\nbufe[0] = 0x01;\n\nbufe[1] = 0x02;\n\nbufe[2] = 0x03;\n\nbufe[3] = 0x04;\n\n小端字节序\n小端字节序把数值的低位字节(如上例中的0x04)存储在内存的低地址处，低字节在前。PC计算机和单片机常见都是小端字节序。\n\nC语言数组存储例：\n\n0x01020304\n\nbufe[0] = 0x04;\n\nbufe[1] = 0x03;\n\nbufe[2] = 0x02;\n\nbufe[3] = 0x01;\n\n常见的memcpy函数复制float字节到数组中，数组中的float就是小端字节序\n\nmemcpy(&amp;listDataSoft[0] ,&amp;f,sizeof(float));\n\n主机字节序\n现代计算机大多采用小端字节序，所以小端字节序又叫主机字节序。\n\n网络字节序\n不同的计算机可能会采用不同的字节序，甚至同一计算机上不同进程会采用不同的字节序，如JAVA虚拟机采用大端字节序，可能和采用小端字节序计算机上的其他进程不同。所以在网络通信(或进程间通信)时，如果都按自己存储的顺序收发数据，有可能会出现一些误解，为了避免这个问题，约定数据在不同计算机之间传递时都采用大端字节序，也叫作网络字节序。通信时，发送方需要把数据转换成网络字节序(大端字节序)之后再发送，接收方再把网络字节序转成自己的字节序。","like_count":10,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530184,"discussion_content":"反引号是唯一的“漏网之鱼”:)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636668185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111176,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/88/133bc14b.jpg","nickname":"c340","note":"","ucode":"D64CC3DDD09A0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583634,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660262546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322393,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1637342700,"is_pvip":false,"replies":[{"id":117171,"content":"没错，string 在内存中存的就是utf8编码后的字节。像for range这种循环得到的rune，是Go编译器在编译时做的替换。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1637565967,"ip_address":"","comment_id":322393,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师讲编码是我见过讲的最清晰的。有个小问题，就是 Go 中的 string 在内存中存的应该还是 UTF-8 编码之后的数据？而 rune 的方式是在我们使用的时候 Go 源码隐式的进行了转换？","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553903,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646128935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320836,"user_name":"布凡","can_delete":false,"product_type":"c1","uid":1202465,"ip_address":"","ucode":"346FCD332F8BFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","comment_is_top":false,"comment_ctime":1636527295,"is_pvip":false,"replies":[{"id":116730,"content":"点个赞。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902543,"ip_address":"","comment_id":320836,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"strings.Builder的效率要比+&#47;+=的效率高\n因为string.Builder 是先将第一个字符串的地址取出来，然后将builder的字符串拼接到后面，\nfunc (b *Builder) copyCheck() {\n\tif b.addr == nil {\n\t\t&#47;&#47; This hack works around a failing of Go&#39;s escape analysis\n\t\t&#47;&#47; that was causing b to escape and be heap allocated.\n\t\t&#47;&#47; See issue 23382.\n\t\t&#47;&#47; TODO: once issue 7921 is fixed, this should be reverted to\n\t\t&#47;&#47; just &quot;b.addr = b&quot;.\n\t\tb.addr = (*Builder)(noescape(unsafe.Pointer(b)))\n\t} else if b.addr != b {\n\t\tpanic(&quot;strings: illegal use of non-zero Builder copied by value&quot;)\n\t}\n}\n\n&#47;&#47; String returns the accumulated string.\nfunc (b *Builder) String() string {\n\treturn *(*string)(unsafe.Pointer(&amp;b.buf))\n}\n+&#47;+=是将两个字符串连接后分配一个新的空间，当连接字符串的数量少时，两者没有什么区别，但是当连接字符串多时，Builder的效率要比+&#47;+=的效率高很多。如有理解不正确的地方希望老师同学指正！(*^_^*)","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532276,"discussion_content":"没错，string 在内存中存的就是utf8编码后的字节。像for range这种循环得到的rune，是Go编译器在编译时做的替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637565967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322404,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1637371834,"is_pvip":false,"replies":[{"id":117174,"content":"对的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1637566920,"ip_address":"","comment_id":322404,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，关于 utf-8 不考虑字节序的问题。能否这么理解，utf-8 的一个字符是由 3 个字节逐个字节进行编码比较决定的，比如第一个字节编码的值在这个值之间，那肯定采用的是单字节编码，第二个字节编码的值在这之间，那肯定是双字节编码，而 utf-32 需要 4 字节一起考虑？那么，一旦 4 个字节一起考虑了的话，就需要涉及到这 4 个字节是大端序还是小端序？","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530136,"discussion_content":"点个赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329630,"user_name":"Elvis Lee","can_delete":false,"product_type":"c1","uid":2098270,"ip_address":"","ucode":"A4B26AFFE817FA","user_header":"https://static001.geekbang.org/account/avatar/00/20/04/5e/5d2e6254.jpg","comment_is_top":false,"comment_ctime":1641452555,"is_pvip":false,"replies":[{"id":120479,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642041487,"ip_address":"","comment_id":329630,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"string是一个8位字节的集合，通常但不一定代表UTF-8编码的文本。string可以为空，但是不能为nil。string的值是不能改变的。\nstring类型虽然是不能更改的，但是可以被替换，因为stringStruct中的str指针是可以改变的，只是指针指向的内容是不可以改变的，也就说每一个更改字符串，就需要重新分配一次内存，之前分配的空间会被gc回收。","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532283,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637566920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321019,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1636621796,"is_pvip":false,"replies":[{"id":116755,"content":"简直就是标准答案👍","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636929420,"ip_address":"","comment_id":321019,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"func plusConcat(n int, str string) string {\n\t&#47;&#47; +号拼接\n}\n\nfunc sprintfConcat(n int, str string) string {\n\t&#47;&#47;fmt.Sprintf拼接\n}\n\nfunc builderConcat(n int, str string) string {\n\tvar builder strings.Builder\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuilder.WriteString(str)\n\t}\n\treturn builder.String()\n}\n\nfunc bufferConcat(n int, s string) string {\n\tbuf := new(bytes.Buffer)\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuf.WriteString(s)\n\t}\n\treturn buf.String()\n}\n\nfunc byteConcat(n int, str string) string {\n\tbuf := make([]byte, 0)\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuf = append(buf, str...)\n\t}\n\treturn string(buf)\n}\nfunc preByteConcat(n int, str string) string {\n\tbuf := make([]byte, 0, n*len(str))\n\tfor i := 0; i &lt; n; i++ {\n\t\tbuf = append(buf, str...)\n\t}\n\treturn string(buf)\n}\nfunc builderGrowConcat(n int, str string) string {\n\tvar builder strings.Builder\n\tbuilder.Grow(n * len(str))\n\t&#47;&#47; 与builderConcat相同\n}\nfunc bufferGrowConcat(n int, s string) string {\n\tbuf := new(bytes.Buffer)\n\tbuf.Grow(n * len(s))\n\t&#47;&#47; 与bufferConcat相同\n}\nbenchmem测试：\n    24          47124538 ns&#47;op        530996721 B&#47;op     10011 allocs&#47;op\n    13          81526461 ns&#47;op        834307836 B&#47;op     37463 allocs&#47;op\n 13263             90613 ns&#47;op          505841 B&#47;op         24 allocs&#47;op\n 12730             94213 ns&#47;op          423537 B&#47;op         13 allocs&#47;op\n 12992             94185 ns&#47;op          612338 B&#47;op         25 allocs&#47;op\n 23606             50058 ns&#47;op          212992 B&#47;op          2 allocs&#47;op\n 24326             49660 ns&#47;op          106496 B&#47;op          1 allocs&#47;op\n 16762             71860 ns&#47;op          212993 B&#47;op          2 allocs&#47;op\n 如果能知道拼接字符串的个数，那么使用bytes.Buffer和strings.Builder的Grows申请空间后，性能是最好的；如果不能确定长度，那么bytes.Buffer和strings.Builder也比“+”和fmt.Sprintf性能好很多。\n\n bytes.Buffer与strings.Builder，strings.Builder更合适，因为bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回了回来。\n\n bytes.Buffer 的注释中还特意提到了：\n\nTo build strings more efficiently, see the strings.Builder type.","like_count":148,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530188,"discussion_content":"简直就是标准答案👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636929420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043824,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/70/dafc8858.jpg","nickname":"孟谦","note":"","ucode":"7504C438D973D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650834,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725704680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3904463,"avatar":"","nickname":"Geek_5759bc","note":"","ucode":"882F0A5AF1EE79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646910,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718982434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3554552,"avatar":"","nickname":"Geek_gofzw","note":"","ucode":"F5DFB1622C80BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608762,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678633831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330026,"user_name":"Vfeelit","can_delete":false,"product_type":"c1","uid":1501818,"ip_address":"","ucode":"F3FF2B069F347F","user_header":"https://static001.geekbang.org/account/avatar/00/16/ea/7a/d857723d.jpg","comment_is_top":false,"comment_ctime":1641738130,"is_pvip":false,"replies":[{"id":120489,"content":"好问题。这个问题我也曾想过，官方没有答案。但从社区给出的观点来看，主要考虑两点：1.int32足够表示unicode所有码点 2. int32可以为负数，便于检测溢出(overflow)或其他基于int32的计算错误。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642042652,"ip_address":"","comment_id":330026,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"rune 是 int32 别名  Unicode编码没有负的吧 为何不是 uint32的别名？","like_count":24,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545709,"discussion_content":"好问题。这个问题我也曾想过，官方没有答案。但从社区给出的观点来看，主要考虑两点：1.int32足够表示unicode所有码点 2. int32可以为负数，便于检测溢出(overflow)或其他基于int32的计算错误。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642042652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336373,"user_name":"大大大大大泽","can_delete":false,"product_type":"c1","uid":2916508,"ip_address":"","ucode":"D9388E4777BA9F","user_header":"","comment_is_top":false,"comment_ctime":1646119198,"is_pvip":false,"replies":[{"id":122946,"content":"摘自网络:)\n\nunicode 符号范围 | utf-8 编码方式\n00000000 ~ 0000007F | 0xxxxxxx \n00000080 ~ 000007FF | 110xxxxx 10xxxxxx \n00000800 ~ 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx \n00010000 ~ 0010FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx \n\n总结下来，针对UTF8，编码规则其实只有两条：\n1）单字节规则： 对于 单字节 的符号，字节的第一位（最高位）设为 0，后面 7 位为这个符号的 unicode 码。\n2）n字节规则： 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646128890,"ip_address":"","comment_id":336373,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"有个问题不太懂。。。UTF-8 编码使用的字节数量从 1 个到 4 个不等。那么如何确定几个字节确定一个字符呢？\n比如说 中国人 是 \\xe4\\xb8\\xad\\xe5\\x9b\\xbd\\xe4\\xba\\xba，3个字节确定一个字符，分配为3 3 3。为什么不会分割成1 1 2 2 3","like_count":19,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553902,"discussion_content":"摘自网络:)\n\nunicode 符号范围 | utf-8 编码方式\n00000000 ~ 0000007F | 0xxxxxxx \n00000080 ~ 000007FF | 110xxxxx 10xxxxxx \n00000800 ~ 0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx \n00010000 ~ 0010FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx \n\n总结下来，针对UTF8，编码规则其实只有两条：\n1）单字节规则： 对于 单字节 的符号，字节的第一位（最高位）设为 0，后面 7 位为这个符号的 unicode 码。\n2）n字节规则： 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。\n\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1646128890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149221,"avatar":"https://static001.geekbang.org/account/avatar/00/11/89/25/02f1b5ec.jpg","nickname":"柳丁烧麦","note":"","ucode":"87F3F998277970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617679,"discussion_content":"“中”字为例，unicode为0x4e2d（0b0100 1110 0010 1101），位于00000800 ~ 0000FFFF区间。\n从右向左，依次替换 1110xxxx 10xxxxxx 10xxxxxx 中的“x”，不足补0，得:\n1110[0100] 10[111000] 10[101101]\n转为十六进制后即字节码：\ne4 b8 ad","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683773583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1197626,"avatar":"https://static001.geekbang.org/account/avatar/00/12/46/3a/20f80540.jpg","nickname":"Mr.增锋","note":"","ucode":"1D720DB133CA74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588815,"discussion_content":"可变长编码，幼麟实验室 有个讲解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664128586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321169,"user_name":"你好呀, 朋友.","can_delete":false,"product_type":"c1","uid":2840465,"ip_address":"","ucode":"49E45F2E0AB679","user_header":"","comment_is_top":false,"comment_ctime":1636698605,"is_pvip":false,"replies":[{"id":116790,"content":"一个rune存储一个unicode码点或utf-32的四字节编码；从字节视角，string对应的底层存储存放的是utf8编码。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636965836,"ip_address":"","comment_id":321169,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"是不是可以理解成[]rune里存的是Unicode码点或者说UTF-32编码，而[]byte和string存的是UTF-8编码","like_count":13,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530235,"discussion_content":"一个rune存储一个unicode码点或utf-32的四字节编码；从字节视角，string对应的底层存储存放的是utf8编码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636965836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321010,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1636619132,"is_pvip":true,"replies":[{"id":116598,"content":"反引号是唯一的“漏网之鱼”:)。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636668185,"ip_address":"","comment_id":321010,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"那么问题来了，raw string里要怎么使用反引号？","like_count":12,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530184,"discussion_content":"反引号是唯一的“漏网之鱼”:)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636668185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111176,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/88/133bc14b.jpg","nickname":"c340","note":"","ucode":"D64CC3DDD09A0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583634,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660262546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336399,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1646128151,"is_pvip":false,"replies":[{"id":122947,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646128935,"ip_address":"","comment_id":336399,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"现代CPU计算时一次都能装载多个字节(如32位计算机一次装载4字节)，多字节的数值在内存中高低位的排列方式会影响所表示的数值，以数值0x01020304为例，在内存中用4个字节存储，4个字节的内容分别是0x01、0x02、0x03、0x04。根据字节高低位排序方式的不同，可以分为：大端字节序(big endian)和小端字节序(little endian)。\n\n大端字节序\n大端字节序是指一个整数的高位字节(如上例中的0x01)存储在内存的低地址处,高字节在前。\n\nC语言数组存储例：\n\n0x01020304\n\nbufe[0] = 0x01;\n\nbufe[1] = 0x02;\n\nbufe[2] = 0x03;\n\nbufe[3] = 0x04;\n\n小端字节序\n小端字节序把数值的低位字节(如上例中的0x04)存储在内存的低地址处，低字节在前。PC计算机和单片机常见都是小端字节序。\n\nC语言数组存储例：\n\n0x01020304\n\nbufe[0] = 0x04;\n\nbufe[1] = 0x03;\n\nbufe[2] = 0x02;\n\nbufe[3] = 0x01;\n\n常见的memcpy函数复制float字节到数组中，数组中的float就是小端字节序\n\nmemcpy(&amp;listDataSoft[0] ,&amp;f,sizeof(float));\n\n主机字节序\n现代计算机大多采用小端字节序，所以小端字节序又叫主机字节序。\n\n网络字节序\n不同的计算机可能会采用不同的字节序，甚至同一计算机上不同进程会采用不同的字节序，如JAVA虚拟机采用大端字节序，可能和采用小端字节序计算机上的其他进程不同。所以在网络通信(或进程间通信)时，如果都按自己存储的顺序收发数据，有可能会出现一些误解，为了避免这个问题，约定数据在不同计算机之间传递时都采用大端字节序，也叫作网络字节序。通信时，发送方需要把数据转换成网络字节序(大端字节序)之后再发送，接收方再把网络字节序转成自己的字节序。","like_count":10,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553903,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646128935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322393,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1637342700,"is_pvip":false,"replies":[{"id":117171,"content":"没错，string 在内存中存的就是utf8编码后的字节。像for range这种循环得到的rune，是Go编译器在编译时做的替换。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1637565967,"ip_address":"","comment_id":322393,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师讲编码是我见过讲的最清晰的。有个小问题，就是 Go 中的 string 在内存中存的应该还是 UTF-8 编码之后的数据？而 rune 的方式是在我们使用的时候 Go 源码隐式的进行了转换？","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532276,"discussion_content":"没错，string 在内存中存的就是utf8编码后的字节。像for range这种循环得到的rune，是Go编译器在编译时做的替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637565967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320836,"user_name":"布凡","can_delete":false,"product_type":"c1","uid":1202465,"ip_address":"","ucode":"346FCD332F8BFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","comment_is_top":false,"comment_ctime":1636527295,"is_pvip":false,"replies":[{"id":116730,"content":"点个赞。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902543,"ip_address":"","comment_id":320836,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"strings.Builder的效率要比+&#47;+=的效率高\n因为string.Builder 是先将第一个字符串的地址取出来，然后将builder的字符串拼接到后面，\nfunc (b *Builder) copyCheck() {\n\tif b.addr == nil {\n\t\t&#47;&#47; This hack works around a failing of Go&#39;s escape analysis\n\t\t&#47;&#47; that was causing b to escape and be heap allocated.\n\t\t&#47;&#47; See issue 23382.\n\t\t&#47;&#47; TODO: once issue 7921 is fixed, this should be reverted to\n\t\t&#47;&#47; just &quot;b.addr = b&quot;.\n\t\tb.addr = (*Builder)(noescape(unsafe.Pointer(b)))\n\t} else if b.addr != b {\n\t\tpanic(&quot;strings: illegal use of non-zero Builder copied by value&quot;)\n\t}\n}\n\n&#47;&#47; String returns the accumulated string.\nfunc (b *Builder) String() string {\n\treturn *(*string)(unsafe.Pointer(&amp;b.buf))\n}\n+&#47;+=是将两个字符串连接后分配一个新的空间，当连接字符串的数量少时，两者没有什么区别，但是当连接字符串多时，Builder的效率要比+&#47;+=的效率高很多。如有理解不正确的地方希望老师同学指正！(*^_^*)","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530136,"discussion_content":"点个赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322404,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1637371834,"is_pvip":false,"replies":[{"id":117174,"content":"对的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1637566920,"ip_address":"","comment_id":322404,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，关于 utf-8 不考虑字节序的问题。能否这么理解，utf-8 的一个字符是由 3 个字节逐个字节进行编码比较决定的，比如第一个字节编码的值在这个值之间，那肯定采用的是单字节编码，第二个字节编码的值在这之间，那肯定是双字节编码，而 utf-32 需要 4 字节一起考虑？那么，一旦 4 个字节一起考虑了的话，就需要涉及到这 4 个字节是大端序还是小端序？","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532283,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637566920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329630,"user_name":"Elvis Lee","can_delete":false,"product_type":"c1","uid":2098270,"ip_address":"","ucode":"A4B26AFFE817FA","user_header":"https://static001.geekbang.org/account/avatar/00/20/04/5e/5d2e6254.jpg","comment_is_top":false,"comment_ctime":1641452555,"is_pvip":false,"replies":[{"id":120479,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642041487,"ip_address":"","comment_id":329630,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"string是一个8位字节的集合，通常但不一定代表UTF-8编码的文本。string可以为空，但是不能为nil。string的值是不能改变的。\nstring类型虽然是不能更改的，但是可以被替换，因为stringStruct中的str指针是可以改变的，只是指针指向的内容是不可以改变的，也就说每一个更改字符串，就需要重新分配一次内存，之前分配的空间会被gc回收。","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545697,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642041487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323310,"user_name":"Bynow","can_delete":false,"product_type":"c1","uid":2735072,"ip_address":"","ucode":"1E4F3ADD65CF18","user_header":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","comment_is_top":false,"comment_ctime":1637828925,"is_pvip":false,"replies":[{"id":117585,"content":"以a:=1; var p = &amp;a为例，&amp;是取地址操作符。unsafe.Pointer是go语言中的通用指针类型，任何指针都可以转型为unsafe.Pointer类型，反之unsafe.Pointer也可以转回任意指针类型。例子：\n\ni := 11\nvar p = unsafe.Pointer(&amp;i) &#47;&#47; int指针 -&gt; unsafe.Pointer\npi := (*int)(p) &#47;&#47; unsafe.Pointer -&gt; int指针\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638263721,"ip_address":"","comment_id":323310,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"&amp; 和 unsafe.Pointer 有什么区别？","like_count":5},{"had_liked":false,"id":375529,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"广东","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1685594779,"is_pvip":false,"replies":[{"id":137070,"content":"这个世界上存储一个四字节长度（比如uint32）整型的变量(以0x12345678为例)有两种方案，一个是0x12 0x34 0x56 0x78，另一个则是0x78, 0x56, 0x34, 0x12。\n\n前者称为大端字节序(big endian)，后者称为小端字节序(little endian)。\n\nx86-64 架构下，使用的是小端字节序，我们可以验证一下：\n\nfunc dumpUint32(i uint32) {\n\tvar p *[4]byte = (*[4]byte)(unsafe.Pointer(&amp;i))\n\tfmt.Println(hex.Dump((*p)[:]))\n}\n\nfunc main() {\n\tdumpUint32(0x12345678)\n}\n\n这段程序输出：\n\n$go run testbigendian1.go\n00000000  78 56 34 12                                       |xV4.|\n\n问题来了：当在网络上传输这个int32时，如果对端使用的是大端字节序，就会将传来的整型数值认为是0x78563412。\n\n所以一些标准早就规定了：网络传输一律使用大端字节序(bigendian)。所以当x86-64上的服务要向网络上写入一个int32数值时，会将小端字节序转换为网络字节序(即大端字节序)。\n\n为什么utf-8编码不存在字节序问题，因为它的编码单元是单字节，在网络传输时，只需要一个字节一个字节的传就好了。这样发送端与接收端对数据的解释就是一致的。\n\n而utf-32的编码单元是用整型表示的“四个字节”，则需考虑字节序问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1685617601,"ip_address":"北京","comment_id":375529,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，文中说：“这种编码方案使用 4 个字节存储和传输一个整型数的时候，需要考虑不同平台的字节序问题 ;”。\n\n看了同学们的评论，还是没太理解，老师能够再详细说明一下么？ 感谢。","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534729,"discussion_content":"以a:=1; var p = &amp;a为例，&amp;是取地址操作符。unsafe.Pointer是go语言中的通用指针类型，任何指针都可以转型为unsafe.Pointer类型，反之unsafe.Pointer也可以转回任意指针类型。例子：\n\ni := 11\nvar p = unsafe.Pointer(&amp;i) // int指针 -&gt; unsafe.Pointer\npi := (*int)(p) // unsafe.Pointer -&gt; int指针\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638263721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321074,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1636646163,"is_pvip":false,"replies":[{"id":116781,"content":"1. 字面值(literal)就是源码中的一个固定的值，它直接写在源码中，不可变，且不需经过任何计算我们就能从字面上看出其“值”。在编程语&gt;言中，通常一个字面值都可以从其字面上大致推断出其类型。另外字面值可以用于初始化变量，也可以作为常量的值。\n\n2. unsafe包属于高级话题，本专栏作为入门专栏后续也不会太过深入。\n3. 嗯，用s:=&quot;中国人&quot;，估计编辑器就不会提示了\n4. 好建议！","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636953535,"ip_address":"","comment_id":321074,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"Tony Bai 老师的这篇关于Go字符串类型的讲解非常细致。\n\n但还是有以下困惑，麻烦老师看到了解答一下：\n\n1. 怎么理解：“字面值” 比较贴切？\n\n2. unsafe.Pointer这个用法，这个在源代码中挺常见的，本专栏会有讲解吗？\n\n3. var s string = &quot;中国人&quot;，像这种变量声明，最佳实践是删去掉string的类型声明吗？我这边编辑器直接提示我是多余的声明。\n\n4. 关于string 类型的数据是不可变的，由此带来的种种好处，感觉还可以深入讲讲，这里感觉还是比较抽象。","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530208,"discussion_content":"1. 字面值(literal)就是源码中的一个固定的值，它直接写在源码中，不可变，且不需经过任何计算我们就能从字面上看出其“值”。在编程语&amp;gt;言中，通常一个字面值都可以从其字面上大致推断出其类型。另外字面值可以用于初始化变量，也可以作为常量的值。\n\n2. unsafe包属于高级话题，本专栏作为入门专栏后续也不会太过深入。\n3. 嗯，用s:=&amp;quot;中国人&amp;quot;，估计编辑器就不会提示了\n4. 好建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636953535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321732,"user_name":"Geek_99b47c","can_delete":false,"product_type":"c1","uid":2049562,"ip_address":"","ucode":"D25E22C1D84E09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aQmhiahazRFUA4W3r1hdxxreSB5Pl54IwAJ8bwN6j02lzicydWAfPFbWx1LSFtzXH8MkI0jUKjlpUtmQBoZ4kReA/132","comment_is_top":false,"comment_ctime":1637028372,"is_pvip":false,"replies":[{"id":117131,"content":"复制的是“描述符”的值，不是描述符变量自身的地址。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1637551980,"ip_address":"","comment_id":321732,"utype":1}],"discussion_count":6,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"“了解了 string 类型的实现原理后，我们还可以得到这样一个结论，那就是我们直接将 string 类型通过函数 &#47; 方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。”\n\nfunc main() {\n\tvar a = &quot;chsir&quot;\n\n\tfmt.Printf(&quot;main:%p\\n&quot;, &amp;a)\n\thello(&amp;a)\n}\n\nfunc hello(a *string)  {\n\tfmt.Printf(&quot;hello:%p\\n&quot;, &amp;a)\n}\n\n请教一下，传入的“描述符”，为什么在main函数和hello函数打印的地址不一样啊，这样要怎么理解，是go复制了一份“描述符”吗？","like_count":3,"discussions":[{"author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534146,"discussion_content":"我感觉你的hello函数里面不应该那样打印，应该换成fmt.Printf(&#34;hello:%p\\n&#34;, a)，这是函数的形参和实参的关系，hello里面的a是形参，是个指针，指向了main函数里面的实参a，hello里面你打印(&amp;a)是打印的这个指针的地址，但实际上指针a的内容也就是(a)才是实参a的地址；ps：如果在hello里面打印(*a)就是打印的指针指向的地址块里面的内容啦，也就是实参a的地址里面的内容，这里会打印出&#34;chsir&#34;，应该是go会默认再去找实参a内部Data指向的具体字符串","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1638108964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546252,"discussion_content":"对的 &amp;a应该是指针的指针了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642255293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534146,"ip_address":"","group_id":0},"score":546252,"extra":""}]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532192,"discussion_content":"复制的是“描述符”的值，不是描述符变量自身的地址。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637551980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":534140,"discussion_content":"这句话没看懂...老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638107696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532192,"ip_address":"","group_id":0},"score":534140,"extra":""}]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602228,"discussion_content":"func hello(b *string)  {\n\tfmt.Printf(&#34;hello:%p\\n&#34;, &amp;b)\n}\n中打印的是形参b的地址，前面的是main()函数局部变量a的地址，自然是不一样的。\n重点是：局部变量a和形参都没有直接指向存储字符内容的地址，而是内部String间接指向的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675681489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553892,"discussion_content":"package main\n\nimport &#34;fmt&#34;\n\nfunc main() {\n\tvar a = &#34;chsir&#34;\n\n\tfmt.Printf(&#34;main-:%p\\n&#34;, &amp;a)\n\thello(&amp;a)\n\tworld(a)\n\thi(a)\n}\n\nfunc hello(a *string) {\n\tfmt.Printf(&#34;hello:%p\\n&#34;, a)\n\tfmt.Printf(&#34;hello:%p\\n&#34;, &amp;a)\n\tfmt.Printf(&#34;hello:%s\\n&#34;, *a)\n}\n\nfunc world(a string) {\n\tfmt.Printf(&#34;world:%p\\n&#34;, &amp;a)\n}\n\nfunc hi(a string) {\n\tfmt.Printf(&#34;hi---:%p\\n&#34;, &amp;a)\n}\n\n\n➜  golearning go run ./cmd\nmain-:0xc000096210\nhello:0xc000096210\nhello:0xc0000ac020\nhello:chsir\nworld:0xc000096230\nhi---:0xc000096240\n\n这里我理解的是，老师说的是，go底层复制的是“描述符”的值，但是我们没办法用go去输出，因为多个变量的地址，可以指向同一个vlaue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646127677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320819,"user_name":"在下宝龙、","can_delete":false,"product_type":"c1","uid":1618030,"ip_address":"","ucode":"0735B64EB61CAC","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","comment_is_top":false,"comment_ctime":1636521687,"is_pvip":false,"replies":[{"id":116728,"content":"utf8是变长编码，其编码单元是单个字节，不存在谁在高位、谁在低位的问题。而utf-16的编码单元是双字节，utf-32编码单元为4字节，均需要考虑字节序问题。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902478,"ip_address":"","comment_id":320819,"utype":1}],"discussion_count":7,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好，一个中文字 在utf-8编码之后是三个字节 ，那为什么会没有字节序问题，我有点弄不明白","like_count":3,"discussions":[{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531639,"discussion_content":"能否这么理解，utf-8 的一个字符是由 3 个字节逐个字节进行编码比较决定的，而 utf-16 需要 2 字节一起考虑？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637371471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":4,"child_discussions":[{"author":{"id":1618030,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","nickname":"在下宝龙、","note":"","ucode":"0735B64EB61CAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531668,"discussion_content":"我觉得这么理解不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637378476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531639,"ip_address":"","group_id":0},"score":531668,"extra":"{\"user_type\":1}"},{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541572,"discussion_content":"不是的。utf8是uicode的一种编码方式。在unicode字符集中，每个字符唯一对应一个码点。\nutf8编码是可变长度，那么它的可变长度如何能对应Unicode的字符编码呢？主要有两条规则。（1）如果是单字节字符，例如ASCII码，那么utf8的最高位是0。所以每次遇到最高位是0就肯定它是单字节字符了。（2）如果unicode字符是N字节，那么utf8的首字节的最高位的开头N位都是1，后面各字节都是以10开头。然后，Unicode字符编码的每一个字节放进utf8剩余的位置。\n所以，通过字节的形式就能确定传输的是多少字节的字符编码了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1640447131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531639,"ip_address":"","group_id":0},"score":541572,"extra":""},{"author":{"id":2028277,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","nickname":"Unknown element","note":"","ucode":"34A129800D0238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":590193,"discussion_content":"那字节之间还是有顺序的吧？比如一个Unicode字符通过UTF8编码之后是3个字节，那后两个字节开头都是10，这两个字节的顺序怎么确定呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665583016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":541572,"ip_address":"广东","group_id":0},"score":590193,"extra":""}]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530128,"discussion_content":"utf8是变长编码，其编码单元是单个字节，不存在谁在高位、谁在低位的问题。而utf-16的编码单元是双字节，utf-32编码单元为4字节，均需要考虑字节序问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636902478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175507,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/d3/241d0b84.jpg","nickname":"upup","note":"","ucode":"25DB114677EF58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574341,"discussion_content":"看一下：“大大大大大泽”同学评论下，老师的回复，“UTF-8”具体的编码格式，就知道“编码单元是单个字节”的含义了（通过字节开头，就知道谁在高位、低位，以及是几个字节）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653985427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360582,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"北京","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1666670330,"is_pvip":false,"replies":[{"id":131256,"content":"因为Data的类型是uintptr，而uintptr不是指针！GC只看指针！","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1666834458,"ip_address":"北京","comment_id":360582,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好 我本地的go sdk是1.17.3，在&#47;src&#47;reflect&#47;value.go文件中的stringHeader结构体前面有几行注释没看懂：\n&#47;&#47; Moreover, the Data field is not sufficient to guarantee the data\n&#47;&#47; it references will not be garbage collected, so programs must keep\n&#47;&#47; a separate, correctly typed pointer to the underlying data.\n我想问下go在垃圾回收的标记阶段不就是通过引用去标记活跃对象吗？为什么这里说string的Data字段的引用无法保证它指向的数据不会被回收？谢谢老师","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591805,"discussion_content":"因为Data的类型是uintptr，而uintptr不是指针！GC只看指针！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666834458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347927,"user_name":"Tristana","can_delete":false,"product_type":"c1","uid":1006227,"ip_address":"","ucode":"FC47CF6A5868D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5a/93/e081b4de.jpg","comment_is_top":false,"comment_ctime":1654588028,"is_pvip":false,"replies":[{"id":126808,"content":"可空，就是”可以为空“的意思😁。可空的字节序列，就是可以是零字节。可空的字符序列，就是可以是零字符。\n\nvar s string = &quot;&quot;  &#47;&#47;从字节视角，它是一个零字节的字节序列。从字符视角，它是一个零字符的字符序列。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654608775,"ip_address":"","comment_id":347927,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"hello，白老师，我看您在文章中多次提到 可空的字节序列 和 可空的字符序列，它们是什么意思啊？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575142,"discussion_content":"可空，就是”可以为空“的意思😁。可空的字节序列，就是可以是零字节。可空的字符序列，就是可以是零字符。\n\nvar s string = &#34;&#34;  //从字节视角，它是一个零字节的字节序列。从字符视角，它是一个零字符的字符序列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654608775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006227,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/93/e081b4de.jpg","nickname":"Tristana","note":"","ucode":"FC47CF6A5868D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575343,"discussion_content":"明白了，谢谢白老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654762489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345006,"user_name":"601073891","can_delete":false,"product_type":"c1","uid":2822078,"ip_address":"","ucode":"FD90354D83B08B","user_header":"","comment_is_top":false,"comment_ctime":1651928724,"is_pvip":false,"replies":[{"id":125918,"content":"好问题。\n\nlen(s)== 0实质是一个int比较，而s == &quot;&quot;实质也是一个byte比较，两者没啥差别。string比较是逐个byte比较的。之前写过一篇文章 ：https:&#47;&#47;tonybai.com&#47;2022&#47;04&#47;18&#47;inside-go-string-comparison 可以看看。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651985449,"ip_address":"","comment_id":345006,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师您好，\n      我这里看到这里的“获取长度的时间复杂度是常数时间”，这样按理来说如果需要判断字符串s是否为空，最好是用len(s) == 0,而不是用s == &quot;&quot;来判断，因为这样是直接判断string所映射的二元数组的len的内容，而不需要一步步的对比data的内容，但我按网上找的一个测试用例来进行性能比较，发现基本是没有区别的：\npackage kong_test\n\nimport (\n    &quot;testing&quot;\n)\nfunc isEmptyString0() bool {\n    var data string\n    if data == &quot;&quot; {\n        return true\n    }\n    return false\n}\n\nfunc isEmptyString1() bool {\n    var data string\n    if len(data) == 0 {\n        return true\n    }\n    return false\n}\nfunc BenchmarkIsEmptyString0(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        isEmptyString0()\n    }\n}\n\nfunc BenchmarkIsEmptyString1(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        isEmptyString1()\n    }\n}\n================测试结果如下：\n[root@VM-24-4-centos test0]# go test -bench=. -v -benchmem\ngoos: linux\ngoarch: amd64\npkg: example&#47;test0\ncpu: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz\nBenchmarkIsEmptyString0\nBenchmarkIsEmptyString0-2       1000000000               0.3359 ns&#47;op          0 B&#47;op          0 allocs&#47;op\nBenchmarkIsEmptyString1\nBenchmarkIsEmptyString1-2       1000000000               0.3312 ns&#47;op          0 B&#47;op          0 allocs&#47;op\nPASS\nok      example&#47;test0   0.748s\n====================\n所以想请问一下白老师这是什么原因导致的呢？还是说其实用len(s) == 0的方法判断和用s == &quot;&quot;来判断其实是没有区别的呢？k8s源码里大量使用的len(s) == 0而不是s == &quot;&quot;只是个人习惯或者巧合吗？\n感谢！","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570889,"discussion_content":"好问题。\n\nlen(s)== 0实质是一个int比较，而s == &#34;&#34;实质也是一个byte比较，两者没啥差别。string比较是逐个byte比较的。之前写过一篇文章 ：https://tonybai.com/2022/04/18/inside-go-string-comparison 可以看看。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651985449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341465,"user_name":"泥腿","can_delete":false,"product_type":"c1","uid":1309200,"ip_address":"","ucode":"EEEBF8ECE5AEEA","user_header":"https://static001.geekbang.org/account/avatar/00/13/fa/10/38d22c78.jpg","comment_is_top":false,"comment_ctime":1649643875,"is_pvip":false,"replies":[{"id":124907,"content":"字符串比较会进行从左到右做逐字节比较，而不是码点。按照你提到的例子，比较操作符会比较s1和s2的第一个字节，也就是&quot;1&quot;和&quot;2&quot;，发现&quot;1&quot; &lt; &quot;2&quot;，直接返回true。无需进行后续比较。\n下面例子改编自你的例子：\n\n      s1 := &quot;12345&quot;\n      s2 := &quot;2345&quot;\n      fmt.Println(s1 &lt; s2) &#47;&#47;true\n\n如果第一个字节相同，则会继续比较后面对位的字节，直到发现不同。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1649914573,"ip_address":"","comment_id":341465,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"s1 = &quot;12345&quot;\ns2 = &quot;23456&quot;\nfmt.Println(s1 &lt; s2)  &#47;&#47; true\nfmt.Println(s1 &lt;= s2) &#47;&#47; true\n\n老师您好，这里的比较值是比较字符串的每个Unicode字符码点么？\n比如：比较到 “2”的码点 大于 “1” 的码点， 则 fmt.Println(s1 &lt;= s2) &#47;&#47; true","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570889,"discussion_content":"好问题。\n\nlen(s)== 0实质是一个int比较，而s == &#34;&#34;实质也是一个byte比较，两者没啥差别。string比较是逐个byte比较的。之前写过一篇文章 ：https://tonybai.com/2022/04/18/inside-go-string-comparison 可以看看。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651985449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320791,"user_name":"羊羊","can_delete":false,"product_type":"c1","uid":1162597,"ip_address":"","ucode":"B220CE8D1CA5DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/65/fbdf4fc1.jpg","comment_is_top":false,"comment_ctime":1636511931,"is_pvip":false,"replies":[{"id":116722,"content":"s[0] = &#39;k&#39;  这个肯定不可以。go string是不可更改的。\ngo字符串下标操作只能获得第一个字节，而不是第一个字符。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636901925,"ip_address":"","comment_id":320791,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"var s string = &quot;hello&quot;\ns[0] = &#39;k&#39; \ns = &quot;gopher&quot; \n根据后面的内容知道s[0]是字符串s的第一个字节，不是第一个字符，是不是不能把字符k直接赋值给s[0]呢？go的字符串是不是，不能用index来获取其中的单个字符？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562954,"discussion_content":"字符串比较会进行从左到右做逐字节比较，而不是码点。按照你提到的例子，比较操作符会比较s1和s2的第一个字节，也就是\"1\"和\"2\"，发现\"1\" < \"2\"，直接返回true。无需进行后续比较。\n下面例子改编自你的例子：\n\n      s1 := \"12345\"\n      s2 := \"2345\"\n      fmt.Println(s1 < s2) //true\n\n如果第一个字节相同，则会继续比较后面对位的字节，直到发现不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649914573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323310,"user_name":"Bynow","can_delete":false,"product_type":"c1","uid":2735072,"ip_address":"","ucode":"1E4F3ADD65CF18","user_header":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","comment_is_top":false,"comment_ctime":1637828925,"is_pvip":false,"replies":[{"id":117585,"content":"以a:=1; var p = &amp;a为例，&amp;是取地址操作符。unsafe.Pointer是go语言中的通用指针类型，任何指针都可以转型为unsafe.Pointer类型，反之unsafe.Pointer也可以转回任意指针类型。例子：\n\ni := 11\nvar p = unsafe.Pointer(&amp;i) &#47;&#47; int指针 -&gt; unsafe.Pointer\npi := (*int)(p) &#47;&#47; unsafe.Pointer -&gt; int指针\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638263721,"ip_address":"","comment_id":323310,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"&amp; 和 unsafe.Pointer 有什么区别？","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534729,"discussion_content":"以a:=1; var p = &amp;a为例，&amp;是取地址操作符。unsafe.Pointer是go语言中的通用指针类型，任何指针都可以转型为unsafe.Pointer类型，反之unsafe.Pointer也可以转回任意指针类型。例子：\n\ni := 11\nvar p = unsafe.Pointer(&amp;i) // int指针 -&gt; unsafe.Pointer\npi := (*int)(p) // unsafe.Pointer -&gt; int指针\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638263721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375529,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"广东","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1685594779,"is_pvip":false,"replies":[{"id":137070,"content":"这个世界上存储一个四字节长度（比如uint32）整型的变量(以0x12345678为例)有两种方案，一个是0x12 0x34 0x56 0x78，另一个则是0x78, 0x56, 0x34, 0x12。\n\n前者称为大端字节序(big endian)，后者称为小端字节序(little endian)。\n\nx86-64 架构下，使用的是小端字节序，我们可以验证一下：\n\nfunc dumpUint32(i uint32) {\n\tvar p *[4]byte = (*[4]byte)(unsafe.Pointer(&amp;i))\n\tfmt.Println(hex.Dump((*p)[:]))\n}\n\nfunc main() {\n\tdumpUint32(0x12345678)\n}\n\n这段程序输出：\n\n$go run testbigendian1.go\n00000000  78 56 34 12                                       |xV4.|\n\n问题来了：当在网络上传输这个int32时，如果对端使用的是大端字节序，就会将传来的整型数值认为是0x78563412。\n\n所以一些标准早就规定了：网络传输一律使用大端字节序(bigendian)。所以当x86-64上的服务要向网络上写入一个int32数值时，会将小端字节序转换为网络字节序(即大端字节序)。\n\n为什么utf-8编码不存在字节序问题，因为它的编码单元是单字节，在网络传输时，只需要一个字节一个字节的传就好了。这样发送端与接收端对数据的解释就是一致的。\n\n而utf-32的编码单元是用整型表示的“四个字节”，则需考虑字节序问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1685617601,"ip_address":"北京","comment_id":375529,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，文中说：“这种编码方案使用 4 个字节存储和传输一个整型数的时候，需要考虑不同平台的字节序问题 ;”。\n\n看了同学们的评论，还是没太理解，老师能够再详细说明一下么？ 感谢。","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619921,"discussion_content":"这个世界上存储一个四字节长度（比如uint32）整型的变量(以0x12345678为例)有两种方案，一个是0x12 0x34 0x56 0x78，另一个则是0x78, 0x56, 0x34, 0x12。\n\n前者称为大端字节序(big endian)，后者称为小端字节序(little endian)。\n\nx86-64 架构下，使用的是小端字节序，我们可以验证一下：\n\nfunc dumpUint32(i uint32) {\n\tvar p *[4]byte = (*[4]byte)(unsafe.Pointer(&amp;i))\n\tfmt.Println(hex.Dump((*p)[:]))\n}\n\nfunc main() {\n\tdumpUint32(0x12345678)\n}\n\n这段程序输出：\n\n$go run testbigendian1.go\n00000000  78 56 34 12                                       |xV4.|\n\n问题来了：当在网络上传输这个int32时，如果对端使用的是大端字节序，就会将传来的整型数值认为是0x78563412。\n\n所以一些标准早就规定了：网络传输一律使用大端字节序(bigendian)。所以当x86-64上的服务要向网络上写入一个int32数值时，会将小端字节序转换为网络字节序(即大端字节序)。\n\n为什么utf-8编码不存在字节序问题，因为它的编码单元是单字节，在网络传输时，只需要一个字节一个字节的传就好了。这样发送端与接收端对数据的解释就是一致的。\n\n而utf-32的编码单元是用整型表示的“四个字节”，则需考虑字节序问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685617601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321074,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1636646163,"is_pvip":false,"replies":[{"id":116781,"content":"1. 字面值(literal)就是源码中的一个固定的值，它直接写在源码中，不可变，且不需经过任何计算我们就能从字面上看出其“值”。在编程语&gt;言中，通常一个字面值都可以从其字面上大致推断出其类型。另外字面值可以用于初始化变量，也可以作为常量的值。\n\n2. unsafe包属于高级话题，本专栏作为入门专栏后续也不会太过深入。\n3. 嗯，用s:=&quot;中国人&quot;，估计编辑器就不会提示了\n4. 好建议！","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636953535,"ip_address":"","comment_id":321074,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"Tony Bai 老师的这篇关于Go字符串类型的讲解非常细致。\n\n但还是有以下困惑，麻烦老师看到了解答一下：\n\n1. 怎么理解：“字面值” 比较贴切？\n\n2. unsafe.Pointer这个用法，这个在源代码中挺常见的，本专栏会有讲解吗？\n\n3. var s string = &quot;中国人&quot;，像这种变量声明，最佳实践是删去掉string的类型声明吗？我这边编辑器直接提示我是多余的声明。\n\n4. 关于string 类型的数据是不可变的，由此带来的种种好处，感觉还可以深入讲讲，这里感觉还是比较抽象。","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619921,"discussion_content":"这个世界上存储一个四字节长度（比如uint32）整型的变量(以0x12345678为例)有两种方案，一个是0x12 0x34 0x56 0x78，另一个则是0x78, 0x56, 0x34, 0x12。\n\n前者称为大端字节序(big endian)，后者称为小端字节序(little endian)。\n\nx86-64 架构下，使用的是小端字节序，我们可以验证一下：\n\nfunc dumpUint32(i uint32) {\n\tvar p *[4]byte = (*[4]byte)(unsafe.Pointer(&amp;i))\n\tfmt.Println(hex.Dump((*p)[:]))\n}\n\nfunc main() {\n\tdumpUint32(0x12345678)\n}\n\n这段程序输出：\n\n$go run testbigendian1.go\n00000000  78 56 34 12                                       |xV4.|\n\n问题来了：当在网络上传输这个int32时，如果对端使用的是大端字节序，就会将传来的整型数值认为是0x78563412。\n\n所以一些标准早就规定了：网络传输一律使用大端字节序(bigendian)。所以当x86-64上的服务要向网络上写入一个int32数值时，会将小端字节序转换为网络字节序(即大端字节序)。\n\n为什么utf-8编码不存在字节序问题，因为它的编码单元是单字节，在网络传输时，只需要一个字节一个字节的传就好了。这样发送端与接收端对数据的解释就是一致的。\n\n而utf-32的编码单元是用整型表示的“四个字节”，则需考虑字节序问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685617601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321732,"user_name":"Geek_99b47c","can_delete":false,"product_type":"c1","uid":2049562,"ip_address":"","ucode":"D25E22C1D84E09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aQmhiahazRFUA4W3r1hdxxreSB5Pl54IwAJ8bwN6j02lzicydWAfPFbWx1LSFtzXH8MkI0jUKjlpUtmQBoZ4kReA/132","comment_is_top":false,"comment_ctime":1637028372,"is_pvip":false,"replies":[{"id":117131,"content":"复制的是“描述符”的值，不是描述符变量自身的地址。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1637551980,"ip_address":"","comment_id":321732,"utype":1}],"discussion_count":6,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"“了解了 string 类型的实现原理后，我们还可以得到这样一个结论，那就是我们直接将 string 类型通过函数 &#47; 方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。”\n\nfunc main() {\n\tvar a = &quot;chsir&quot;\n\n\tfmt.Printf(&quot;main:%p\\n&quot;, &amp;a)\n\thello(&amp;a)\n}\n\nfunc hello(a *string)  {\n\tfmt.Printf(&quot;hello:%p\\n&quot;, &amp;a)\n}\n\n请教一下，传入的“描述符”，为什么在main函数和hello函数打印的地址不一样啊，这样要怎么理解，是go复制了一份“描述符”吗？","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530208,"discussion_content":"1. 字面值(literal)就是源码中的一个固定的值，它直接写在源码中，不可变，且不需经过任何计算我们就能从字面上看出其“值”。在编程语&amp;gt;言中，通常一个字面值都可以从其字面上大致推断出其类型。另外字面值可以用于初始化变量，也可以作为常量的值。\n\n2. unsafe包属于高级话题，本专栏作为入门专栏后续也不会太过深入。\n3. 嗯，用s:=&amp;quot;中国人&amp;quot;，估计编辑器就不会提示了\n4. 好建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636953535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320819,"user_name":"在下宝龙、","can_delete":false,"product_type":"c1","uid":1618030,"ip_address":"","ucode":"0735B64EB61CAC","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","comment_is_top":false,"comment_ctime":1636521687,"is_pvip":false,"replies":[{"id":116728,"content":"utf8是变长编码，其编码单元是单个字节，不存在谁在高位、谁在低位的问题。而utf-16的编码单元是双字节，utf-32编码单元为4字节，均需要考虑字节序问题。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902478,"ip_address":"","comment_id":320819,"utype":1}],"discussion_count":7,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好，一个中文字 在utf-8编码之后是三个字节 ，那为什么会没有字节序问题，我有点弄不明白","like_count":3,"discussions":[{"author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534146,"discussion_content":"我感觉你的hello函数里面不应该那样打印，应该换成fmt.Printf(&#34;hello:%p\\n&#34;, a)，这是函数的形参和实参的关系，hello里面的a是形参，是个指针，指向了main函数里面的实参a，hello里面你打印(&amp;a)是打印的这个指针的地址，但实际上指针a的内容也就是(a)才是实参a的地址；ps：如果在hello里面打印(*a)就是打印的指针指向的地址块里面的内容啦，也就是实参a的地址里面的内容，这里会打印出&#34;chsir&#34;，应该是go会默认再去找实参a内部Data指向的具体字符串","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1638108964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546252,"discussion_content":"对的 &amp;a应该是指针的指针了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642255293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534146,"ip_address":"","group_id":0},"score":546252,"extra":""}]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532192,"discussion_content":"复制的是“描述符”的值，不是描述符变量自身的地址。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637551980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":534140,"discussion_content":"这句话没看懂...老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638107696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532192,"ip_address":"","group_id":0},"score":534140,"extra":""}]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602228,"discussion_content":"func hello(b *string)  {\n\tfmt.Printf(&#34;hello:%p\\n&#34;, &amp;b)\n}\n中打印的是形参b的地址，前面的是main()函数局部变量a的地址，自然是不一样的。\n重点是：局部变量a和形参都没有直接指向存储字符内容的地址，而是内部String间接指向的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675681489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553892,"discussion_content":"package main\n\nimport &#34;fmt&#34;\n\nfunc main() {\n\tvar a = &#34;chsir&#34;\n\n\tfmt.Printf(&#34;main-:%p\\n&#34;, &amp;a)\n\thello(&amp;a)\n\tworld(a)\n\thi(a)\n}\n\nfunc hello(a *string) {\n\tfmt.Printf(&#34;hello:%p\\n&#34;, a)\n\tfmt.Printf(&#34;hello:%p\\n&#34;, &amp;a)\n\tfmt.Printf(&#34;hello:%s\\n&#34;, *a)\n}\n\nfunc world(a string) {\n\tfmt.Printf(&#34;world:%p\\n&#34;, &amp;a)\n}\n\nfunc hi(a string) {\n\tfmt.Printf(&#34;hi---:%p\\n&#34;, &amp;a)\n}\n\n\n➜  golearning go run ./cmd\nmain-:0xc000096210\nhello:0xc000096210\nhello:0xc0000ac020\nhello:chsir\nworld:0xc000096230\nhi---:0xc000096240\n\n这里我理解的是，老师说的是，go底层复制的是“描述符”的值，但是我们没办法用go去输出，因为多个变量的地址，可以指向同一个vlaue。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646127677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360582,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"北京","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1666670330,"is_pvip":false,"replies":[{"id":131256,"content":"因为Data的类型是uintptr，而uintptr不是指针！GC只看指针！","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1666834458,"ip_address":"北京","comment_id":360582,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师您好 我本地的go sdk是1.17.3，在&#47;src&#47;reflect&#47;value.go文件中的stringHeader结构体前面有几行注释没看懂：\n&#47;&#47; Moreover, the Data field is not sufficient to guarantee the data\n&#47;&#47; it references will not be garbage collected, so programs must keep\n&#47;&#47; a separate, correctly typed pointer to the underlying data.\n我想问下go在垃圾回收的标记阶段不就是通过引用去标记活跃对象吗？为什么这里说string的Data字段的引用无法保证它指向的数据不会被回收？谢谢老师","like_count":2,"discussions":[{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531639,"discussion_content":"能否这么理解，utf-8 的一个字符是由 3 个字节逐个字节进行编码比较决定的，而 utf-16 需要 2 字节一起考虑？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637371471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":4,"child_discussions":[{"author":{"id":1618030,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","nickname":"在下宝龙、","note":"","ucode":"0735B64EB61CAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531668,"discussion_content":"我觉得这么理解不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637378476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531639,"ip_address":"","group_id":0},"score":531668,"extra":"{\"user_type\":1}"},{"author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541572,"discussion_content":"不是的。utf8是uicode的一种编码方式。在unicode字符集中，每个字符唯一对应一个码点。\nutf8编码是可变长度，那么它的可变长度如何能对应Unicode的字符编码呢？主要有两条规则。（1）如果是单字节字符，例如ASCII码，那么utf8的最高位是0。所以每次遇到最高位是0就肯定它是单字节字符了。（2）如果unicode字符是N字节，那么utf8的首字节的最高位的开头N位都是1，后面各字节都是以10开头。然后，Unicode字符编码的每一个字节放进utf8剩余的位置。\n所以，通过字节的形式就能确定传输的是多少字节的字符编码了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1640447131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531639,"ip_address":"","group_id":0},"score":541572,"extra":""},{"author":{"id":2028277,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","nickname":"Unknown element","note":"","ucode":"34A129800D0238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1226968,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b8/d8/f81b5604.jpg","nickname":"hcyycb","note":"","ucode":"77FF6CA41F9E66","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":590193,"discussion_content":"那字节之间还是有顺序的吧？比如一个Unicode字符通过UTF8编码之后是3个字节，那后两个字节开头都是10，这两个字节的顺序怎么确定呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665583016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":541572,"ip_address":"广东","group_id":0},"score":590193,"extra":""}]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530128,"discussion_content":"utf8是变长编码，其编码单元是单个字节，不存在谁在高位、谁在低位的问题。而utf-16的编码单元是双字节，utf-32编码单元为4字节，均需要考虑字节序问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636902478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175507,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/d3/241d0b84.jpg","nickname":"upup","note":"","ucode":"25DB114677EF58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574341,"discussion_content":"看一下：“大大大大大泽”同学评论下，老师的回复，“UTF-8”具体的编码格式，就知道“编码单元是单个字节”的含义了（通过字节开头，就知道谁在高位、低位，以及是几个字节）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653985427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347927,"user_name":"Tristana","can_delete":false,"product_type":"c1","uid":1006227,"ip_address":"","ucode":"FC47CF6A5868D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5a/93/e081b4de.jpg","comment_is_top":false,"comment_ctime":1654588028,"is_pvip":false,"replies":[{"id":126808,"content":"可空，就是”可以为空“的意思😁。可空的字节序列，就是可以是零字节。可空的字符序列，就是可以是零字符。\n\nvar s string = &quot;&quot;  &#47;&#47;从字节视角，它是一个零字节的字节序列。从字符视角，它是一个零字符的字符序列。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654608775,"ip_address":"","comment_id":347927,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"hello，白老师，我看您在文章中多次提到 可空的字节序列 和 可空的字符序列，它们是什么意思啊？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591805,"discussion_content":"因为Data的类型是uintptr，而uintptr不是指针！GC只看指针！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666834458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345006,"user_name":"601073891","can_delete":false,"product_type":"c1","uid":2822078,"ip_address":"","ucode":"FD90354D83B08B","user_header":"","comment_is_top":false,"comment_ctime":1651928724,"is_pvip":false,"replies":[{"id":125918,"content":"好问题。\n\nlen(s)== 0实质是一个int比较，而s == &quot;&quot;实质也是一个byte比较，两者没啥差别。string比较是逐个byte比较的。之前写过一篇文章 ：https:&#47;&#47;tonybai.com&#47;2022&#47;04&#47;18&#47;inside-go-string-comparison 可以看看。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651985449,"ip_address":"","comment_id":345006,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师您好，\n      我这里看到这里的“获取长度的时间复杂度是常数时间”，这样按理来说如果需要判断字符串s是否为空，最好是用len(s) == 0,而不是用s == &quot;&quot;来判断，因为这样是直接判断string所映射的二元数组的len的内容，而不需要一步步的对比data的内容，但我按网上找的一个测试用例来进行性能比较，发现基本是没有区别的：\npackage kong_test\n\nimport (\n    &quot;testing&quot;\n)\nfunc isEmptyString0() bool {\n    var data string\n    if data == &quot;&quot; {\n        return true\n    }\n    return false\n}\n\nfunc isEmptyString1() bool {\n    var data string\n    if len(data) == 0 {\n        return true\n    }\n    return false\n}\nfunc BenchmarkIsEmptyString0(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        isEmptyString0()\n    }\n}\n\nfunc BenchmarkIsEmptyString1(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        isEmptyString1()\n    }\n}\n================测试结果如下：\n[root@VM-24-4-centos test0]# go test -bench=. -v -benchmem\ngoos: linux\ngoarch: amd64\npkg: example&#47;test0\ncpu: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz\nBenchmarkIsEmptyString0\nBenchmarkIsEmptyString0-2       1000000000               0.3359 ns&#47;op          0 B&#47;op          0 allocs&#47;op\nBenchmarkIsEmptyString1\nBenchmarkIsEmptyString1-2       1000000000               0.3312 ns&#47;op          0 B&#47;op          0 allocs&#47;op\nPASS\nok      example&#47;test0   0.748s\n====================\n所以想请问一下白老师这是什么原因导致的呢？还是说其实用len(s) == 0的方法判断和用s == &quot;&quot;来判断其实是没有区别的呢？k8s源码里大量使用的len(s) == 0而不是s == &quot;&quot;只是个人习惯或者巧合吗？\n感谢！","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575142,"discussion_content":"可空，就是”可以为空“的意思😁。可空的字节序列，就是可以是零字节。可空的字符序列，就是可以是零字符。\n\nvar s string = &#34;&#34;  //从字节视角，它是一个零字节的字节序列。从字符视角，它是一个零字符的字符序列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654608775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006227,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5a/93/e081b4de.jpg","nickname":"Tristana","note":"","ucode":"FC47CF6A5868D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575343,"discussion_content":"明白了，谢谢白老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654762489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341465,"user_name":"泥腿","can_delete":false,"product_type":"c1","uid":1309200,"ip_address":"","ucode":"EEEBF8ECE5AEEA","user_header":"https://static001.geekbang.org/account/avatar/00/13/fa/10/38d22c78.jpg","comment_is_top":false,"comment_ctime":1649643875,"is_pvip":false,"replies":[{"id":124907,"content":"字符串比较会进行从左到右做逐字节比较，而不是码点。按照你提到的例子，比较操作符会比较s1和s2的第一个字节，也就是&quot;1&quot;和&quot;2&quot;，发现&quot;1&quot; &lt; &quot;2&quot;，直接返回true。无需进行后续比较。\n下面例子改编自你的例子：\n\n      s1 := &quot;12345&quot;\n      s2 := &quot;2345&quot;\n      fmt.Println(s1 &lt; s2) &#47;&#47;true\n\n如果第一个字节相同，则会继续比较后面对位的字节，直到发现不同。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1649914573,"ip_address":"","comment_id":341465,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"s1 = &quot;12345&quot;\ns2 = &quot;23456&quot;\nfmt.Println(s1 &lt; s2)  &#47;&#47; true\nfmt.Println(s1 &lt;= s2) &#47;&#47; true\n\n老师您好，这里的比较值是比较字符串的每个Unicode字符码点么？\n比如：比较到 “2”的码点 大于 “1” 的码点， 则 fmt.Println(s1 &lt;= s2) &#47;&#47; true","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562954,"discussion_content":"字符串比较会进行从左到右做逐字节比较，而不是码点。按照你提到的例子，比较操作符会比较s1和s2的第一个字节，也就是\"1\"和\"2\"，发现\"1\" < \"2\"，直接返回true。无需进行后续比较。\n下面例子改编自你的例子：\n\n      s1 := \"12345\"\n      s2 := \"2345\"\n      fmt.Println(s1 < s2) //true\n\n如果第一个字节相同，则会继续比较后面对位的字节，直到发现不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649914573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320791,"user_name":"羊羊","can_delete":false,"product_type":"c1","uid":1162597,"ip_address":"","ucode":"B220CE8D1CA5DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/65/fbdf4fc1.jpg","comment_is_top":false,"comment_ctime":1636511931,"is_pvip":false,"replies":[{"id":116722,"content":"s[0] = &#39;k&#39;  这个肯定不可以。go string是不可更改的。\ngo字符串下标操作只能获得第一个字节，而不是第一个字符。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636901925,"ip_address":"","comment_id":320791,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"var s string = &quot;hello&quot;\ns[0] = &#39;k&#39; \ns = &quot;gopher&quot; \n根据后面的内容知道s[0]是字符串s的第一个字节，不是第一个字符，是不是不能把字符k直接赋值给s[0]呢？go的字符串是不是，不能用index来获取其中的单个字符？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530115,"discussion_content":"s[0] = &amp;#39;k&amp;#39;  这个肯定不可以。go string是不可更改的。\ngo字符串下标操作只能获得第一个字节，而不是第一个字符。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636901925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364497,"user_name":"子杨","can_delete":false,"product_type":"c1","uid":1236803,"ip_address":"辽宁","ucode":"EA7555EEE6DECE","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/43/1aa8708a.jpg","comment_is_top":false,"comment_ctime":1671031219,"is_pvip":false,"replies":[{"id":132518,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1671141031,"ip_address":"辽宁","comment_id":364497,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"小小的字符串，东西真不少","like_count":1},{"had_liked":false,"id":362477,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"北京","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1668565270,"is_pvip":false,"replies":[{"id":131850,"content":"好问题。\n\n实际测试并不是。\n\n共享底层string这个技术叫string interning。关于go对string interning的支持可以参见https:&#47;&#47;github.com&#47;golang&#47;go&#47;issues&#47;5160\n\n目前多数情况下，interning依旧无法得到支持。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1668664186,"ip_address":"北京","comment_id":362477,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"s1 := &quot;世界和平&quot; \ns2 := &quot;世界&quot;\ns3 := &quot;和平&quot;\ns4 := s2 + s3 \n请问s1, s2, s3, s4 是共用的一块底层数据“世界和平”吗？是否和数组和切片一个原理，s2, s3，s4 是 s1 的切片\n      ","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":593939,"discussion_content":"好问题。\n\n实际测试并不是。\n\n共享底层string这个技术叫string interning。关于go对string interning的支持可以参见https://github.com/golang/go/issues/5160\n\n目前多数情况下，interning依旧无法得到支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668664186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":619943,"discussion_content":"老师 如果 变量 a和变量b 都赋值为“世界” 那么A和b是否指向底层同1块数据？java的字符串常量池可以认为实现了string interning吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685628591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":593939,"ip_address":"北京","group_id":0},"score":619943,"extra":""}]}]},{"had_liked":false,"id":359399,"user_name":"不说话装糕手","can_delete":false,"product_type":"c1","uid":2922271,"ip_address":"辽宁","ucode":"6465E83F4E6F58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/97/1f/2a68c980.jpg","comment_is_top":false,"comment_ctime":1665497619,"is_pvip":false,"replies":[{"id":130725,"content":"的确有误，后续让编辑老师修改一下，感谢指出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1665547902,"ip_address":"辽宁","comment_id":359399,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"&#39;\\u4e2d&#39; &#47;&#47; 字符：中\n\\u是接四位的十六进制，\\U是8位吧","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":593939,"discussion_content":"好问题。\n\n实际测试并不是。\n\n共享底层string这个技术叫string interning。关于go对string interning的支持可以参见https://github.com/golang/go/issues/5160\n\n目前多数情况下，interning依旧无法得到支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668664186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":619943,"discussion_content":"老师 如果 变量 a和变量b 都赋值为“世界” 那么A和b是否指向底层同1块数据？java的字符串常量池可以认为实现了string interning吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685628591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":593939,"ip_address":"北京","group_id":0},"score":619943,"extra":""}]}]},{"had_liked":false,"id":359270,"user_name":"Geek_cf3cd4","can_delete":false,"product_type":"c1","uid":3196290,"ip_address":"辽宁","ucode":"B02270561F4894","user_header":"","comment_is_top":false,"comment_ctime":1665387277,"is_pvip":false,"replies":[{"id":130697,"content":"go语言就是这么规定的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1665431998,"ip_address":"辽宁","comment_id":359270,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"有一个疑惑，为什么for loop得到的是字符对应的utf8的编码字节，而for range得到的是一个Unicode浮点值，按照正常逻辑for range也是应该是得到一个字符得utf8得编码。还是说go中得for range内部实现就是这样的呢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589983,"discussion_content":"go语言就是这么规定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665431999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3196290,"avatar":"","nickname":"Geek_cf3cd4","note":"","ucode":"B02270561F4894","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589989,"discussion_content":"好的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665450064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354019,"user_name":"迈向架构师","can_delete":false,"product_type":"c1","uid":1637228,"ip_address":"北京","ucode":"2476594CF76001","user_header":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","comment_is_top":false,"comment_ctime":1660020147,"is_pvip":false,"replies":[{"id":128781,"content":"你的意思是比较两个字符串么？一个用\\r\\n作为结尾换行，一个用\\n作为结尾换行?\n\nfunc main() {\n\ts1 := &quot;abc\\ndef&quot;\n\ts2 := &quot;abcr\\r\\ndef&quot;\n\n\tprintln(s1 == s2) &#47;&#47; false\n}\n\n这样肯定不等。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1660042088,"ip_address":"北京","comment_id":354019,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"请教一下，如果是多行字符串的话，他换行好像只用了\\n  \n\n如果我有\\r\\n的文本做比对，要怎么操作呢\n\n（因为我发现别人好像这样对比没问题，而我这样对比有问题...）","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589983,"discussion_content":"go语言就是这么规定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665431999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3196290,"avatar":"","nickname":"Geek_cf3cd4","note":"","ucode":"B02270561F4894","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589989,"discussion_content":"好的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665450064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348446,"user_name":"W-T","can_delete":false,"product_type":"c1","uid":1088973,"ip_address":"","ucode":"834869DA80D95B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/cd/c21a01dd.jpg","comment_is_top":false,"comment_ctime":1655109120,"is_pvip":false,"replies":[{"id":126969,"content":"type rune = int32是别名语法，可以理解为rune完全等价于int32。\n\n而type rune int32则是define type的语法，基于int32类型定义一个新类型rune，int32称为rune的underlying type。\n\nrune和int32是不同的类型，相互赋值需要显式转型。\n\n并且在这种情况下，rune可以拥有自己的方法（前面的别名则不行）。这个在后面讲解类型的方法集合时有提及。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1655270680,"ip_address":"","comment_id":348446,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"问一个小白问题：\ntype rune = int32\ntype rune inte32 有什么区别","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576072,"discussion_content":"type rune = int32是别名语法，可以理解为rune完全等价于int32。\n\n而type rune int32则是define type的语法，基于int32类型定义一个新类型rune，int32称为rune的underlying type。\n\nrune和int32是不同的类型，相互赋值需要显式转型。\n\n并且在这种情况下，rune可以拥有自己的方法（前面的别名则不行）。这个在后面讲解类型的方法集合时有提及。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655270680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342091,"user_name":"ryanxw","can_delete":false,"product_type":"c1","uid":2119325,"ip_address":"","ucode":"0B91EAC8D06EED","user_header":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","comment_is_top":false,"comment_ctime":1650011354,"is_pvip":false,"replies":[{"id":125044,"content":"😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650108676,"ip_address":"","comment_id":342091,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"这货太干了，谢谢老师\nutf8编码那里和pb的变长编码原理一致","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576072,"discussion_content":"type rune = int32是别名语法，可以理解为rune完全等价于int32。\n\n而type rune int32则是define type的语法，基于int32类型定义一个新类型rune，int32称为rune的underlying type。\n\nrune和int32是不同的类型，相互赋值需要显式转型。\n\n并且在这种情况下，rune可以拥有自己的方法（前面的别名则不行）。这个在后面讲解类型的方法集合时有提及。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655270680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341979,"user_name":"flexiver","can_delete":false,"product_type":"c1","uid":2889691,"ip_address":"","ucode":"5D83DFA90826E1","user_header":"","comment_is_top":false,"comment_ctime":1649938204,"is_pvip":false,"replies":[{"id":125018,"content":"我们不说go string，我们就说代数上&gt;和&gt;=这两个比较操作符的语义：\n1&gt;0  &#47;&#47; true\n1&gt;=0 是不是也是true呢？显然是啊。&gt;=的语义就是&gt;或=都是true啊。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650011775,"ip_address":"","comment_id":341979,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师您好，关于字符串比较这个小节的知识点有一个疑惑，默认情况下，字符串的比较，其实是比较底层字节数组，如果两个字符串一个比较长，一个比较短，例如s1 := &quot;12345&quot;， s2 := &quot;123&quot;， 较短的字符串会nil表示，并且空最小，那按理来说在比较123对应的字节序列时是相等的，在比较下一个字符串时一个是4对应的字节，一个nil，那么应该是s1 &gt; s2 才为true, 为什么s1 &gt;= s2也为true呢？感觉有点矛盾","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563897,"discussion_content":"😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650108676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331894,"user_name":"光","can_delete":false,"product_type":"c1","uid":1284618,"ip_address":"","ucode":"BDA7F41566E4FE","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/0a/6c74e932.jpg","comment_is_top":false,"comment_ctime":1642856859,"is_pvip":false,"replies":[{"id":121608,"content":"valid是将一个合法的unicode字符串转换为utf8编码（通过string-&gt;切片的转型）。因此转换后的字节序列也是一个合法的utf8编码。invalid切片中三个字节不构成一个合法的unicode字符的utf8编码，所以invalid。\n\n如果你用下面代码\n      valid1 := []byte{231, 149, 140} &#47;&#47; unicode字符“界”的utf8编码\n则Valid也会输出true      \nfmt.Println(utf8.Valid(valid1)) &#47;&#47; true","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643540167,"ip_address":"","comment_id":331894,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"问下这两种写法有什么不一样么。\n\t\n\nvalid := []byte(&quot;Hello, 世界&quot;)\n\tinvalid := []byte{0xff, 0xfe, 0xfd}\n\n\tfmt.Println(valid)\n\tfmt.Println(invalid)\n\tfmt.Println(utf8.Valid(valid))\n\tfmt.Println(utf8.Valid(invalid))","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563501,"discussion_content":"我们不说go string，我们就说代数上&gt;和&gt;=这两个比较操作符的语义：\n1&gt;0  // true\n1&gt;=0 是不是也是true呢？显然是啊。&gt;=的语义就是&gt;或=都是true啊。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650011775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2889691,"avatar":"","nickname":"flexiver","note":"","ucode":"5D83DFA90826E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563761,"discussion_content":"我自己有点陷入牛角尖了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650074212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325356,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1638930300,"is_pvip":false,"replies":[{"id":118598,"content":"我继续努力😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639562191,"ip_address":"","comment_id":325356,"utype":1}],"discussion_count":1,"race_medal":2,"score":4,"product_id":100093501,"comment_content":"读过的最好的介绍字符串类型的文章！期待老师后面推出进阶的 Go 课程。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549068,"discussion_content":"valid是将一个合法的unicode字符串转换为utf8编码（通过string-&gt;切片的转型）。因此转换后的字节序列也是一个合法的utf8编码。invalid切片中三个字节不构成一个合法的unicode字符的utf8编码，所以invalid。\n\n如果你用下面代码\n      valid1 := []byte{231, 149, 140} // unicode字符“界”的utf8编码\n则Valid也会输出true      \nfmt.Println(utf8.Valid(valid1)) // true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643540168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364497,"user_name":"子杨","can_delete":false,"product_type":"c1","uid":1236803,"ip_address":"辽宁","ucode":"EA7555EEE6DECE","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/43/1aa8708a.jpg","comment_is_top":false,"comment_ctime":1671031219,"is_pvip":false,"replies":[{"id":132518,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1671141031,"ip_address":"辽宁","comment_id":364497,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"小小的字符串，东西真不少","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596621,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671141031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362477,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":2820643,"ip_address":"北京","ucode":"791BC042992385","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/23/c26f4e50.jpg","comment_is_top":false,"comment_ctime":1668565270,"is_pvip":false,"replies":[{"id":131850,"content":"好问题。\n\n实际测试并不是。\n\n共享底层string这个技术叫string interning。关于go对string interning的支持可以参见https:&#47;&#47;github.com&#47;golang&#47;go&#47;issues&#47;5160\n\n目前多数情况下，interning依旧无法得到支持。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1668664186,"ip_address":"北京","comment_id":362477,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"s1 := &quot;世界和平&quot; \ns2 := &quot;世界&quot;\ns3 := &quot;和平&quot;\ns4 := s2 + s3 \n请问s1, s2, s3, s4 是共用的一块底层数据“世界和平”吗？是否和数组和切片一个原理，s2, s3，s4 是 s1 的切片\n      ","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596621,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671141031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359399,"user_name":"不说话装糕手","can_delete":false,"product_type":"c1","uid":2922271,"ip_address":"辽宁","ucode":"6465E83F4E6F58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/97/1f/2a68c980.jpg","comment_is_top":false,"comment_ctime":1665497619,"is_pvip":false,"replies":[{"id":130725,"content":"的确有误，后续让编辑老师修改一下，感谢指出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1665547902,"ip_address":"辽宁","comment_id":359399,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"&#39;\\u4e2d&#39; &#47;&#47; 字符：中\n\\u是接四位的十六进制，\\U是8位吧","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590132,"discussion_content":"的确有误，后续让编辑老师修改一下，感谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665547902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359270,"user_name":"Geek_cf3cd4","can_delete":false,"product_type":"c1","uid":3196290,"ip_address":"辽宁","ucode":"B02270561F4894","user_header":"","comment_is_top":false,"comment_ctime":1665387277,"is_pvip":false,"replies":[{"id":130697,"content":"go语言就是这么规定的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1665431998,"ip_address":"辽宁","comment_id":359270,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"有一个疑惑，为什么for loop得到的是字符对应的utf8的编码字节，而for range得到的是一个Unicode浮点值，按照正常逻辑for range也是应该是得到一个字符得utf8得编码。还是说go中得for range内部实现就是这样的呢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590132,"discussion_content":"的确有误，后续让编辑老师修改一下，感谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665547902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354019,"user_name":"迈向架构师","can_delete":false,"product_type":"c1","uid":1637228,"ip_address":"北京","ucode":"2476594CF76001","user_header":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","comment_is_top":false,"comment_ctime":1660020147,"is_pvip":false,"replies":[{"id":128781,"content":"你的意思是比较两个字符串么？一个用\\r\\n作为结尾换行，一个用\\n作为结尾换行?\n\nfunc main() {\n\ts1 := &quot;abc\\ndef&quot;\n\ts2 := &quot;abcr\\r\\ndef&quot;\n\n\tprintln(s1 == s2) &#47;&#47; false\n}\n\n这样肯定不等。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1660042088,"ip_address":"北京","comment_id":354019,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"请教一下，如果是多行字符串的话，他换行好像只用了\\n  \n\n如果我有\\r\\n的文本做比对，要怎么操作呢\n\n（因为我发现别人好像这样对比没问题，而我这样对比有问题...）","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583341,"discussion_content":"你的意思是比较两个字符串么？一个用\\r\\n作为结尾换行，一个用\\n作为结尾换行?\n\nfunc main() {\n\ts1 := &#34;abc\\ndef&#34;\n\ts2 := &#34;abcr\\r\\ndef&#34;\n\n\tprintln(s1 == s2) // false\n}\n\n这样肯定不等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660042088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":603495,"discussion_content":"是这个问题：\ns1:=&#39;abc\ndef&#39;\ns2:=&#34;abc\\r\\ndef&#34;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676254393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":583341,"ip_address":"广东","group_id":0},"score":603495,"extra":""}]}]},{"had_liked":false,"id":348446,"user_name":"W-T","can_delete":false,"product_type":"c1","uid":1088973,"ip_address":"","ucode":"834869DA80D95B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/cd/c21a01dd.jpg","comment_is_top":false,"comment_ctime":1655109120,"is_pvip":false,"replies":[{"id":126969,"content":"type rune = int32是别名语法，可以理解为rune完全等价于int32。\n\n而type rune int32则是define type的语法，基于int32类型定义一个新类型rune，int32称为rune的underlying type。\n\nrune和int32是不同的类型，相互赋值需要显式转型。\n\n并且在这种情况下，rune可以拥有自己的方法（前面的别名则不行）。这个在后面讲解类型的方法集合时有提及。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1655270680,"ip_address":"","comment_id":348446,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"问一个小白问题：\ntype rune = int32\ntype rune inte32 有什么区别","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583341,"discussion_content":"你的意思是比较两个字符串么？一个用\\r\\n作为结尾换行，一个用\\n作为结尾换行?\n\nfunc main() {\n\ts1 := &#34;abc\\ndef&#34;\n\ts2 := &#34;abcr\\r\\ndef&#34;\n\n\tprintln(s1 == s2) // false\n}\n\n这样肯定不等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660042088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":603495,"discussion_content":"是这个问题：\ns1:=&#39;abc\ndef&#39;\ns2:=&#34;abc\\r\\ndef&#34;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676254393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":583341,"ip_address":"广东","group_id":0},"score":603495,"extra":""}]}]},{"had_liked":false,"id":342091,"user_name":"ryanxw","can_delete":false,"product_type":"c1","uid":2119325,"ip_address":"","ucode":"0B91EAC8D06EED","user_header":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","comment_is_top":false,"comment_ctime":1650011354,"is_pvip":false,"replies":[{"id":125044,"content":"😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650108676,"ip_address":"","comment_id":342091,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"这货太干了，谢谢老师\nutf8编码那里和pb的变长编码原理一致","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563897,"discussion_content":"😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650108676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341979,"user_name":"flexiver","can_delete":false,"product_type":"c1","uid":2889691,"ip_address":"","ucode":"5D83DFA90826E1","user_header":"","comment_is_top":false,"comment_ctime":1649938204,"is_pvip":false,"replies":[{"id":125018,"content":"我们不说go string，我们就说代数上&gt;和&gt;=这两个比较操作符的语义：\n1&gt;0  &#47;&#47; true\n1&gt;=0 是不是也是true呢？显然是啊。&gt;=的语义就是&gt;或=都是true啊。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650011775,"ip_address":"","comment_id":341979,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"老师您好，关于字符串比较这个小节的知识点有一个疑惑，默认情况下，字符串的比较，其实是比较底层字节数组，如果两个字符串一个比较长，一个比较短，例如s1 := &quot;12345&quot;， s2 := &quot;123&quot;， 较短的字符串会nil表示，并且空最小，那按理来说在比较123对应的字节序列时是相等的，在比较下一个字符串时一个是4对应的字节，一个nil，那么应该是s1 &gt; s2 才为true, 为什么s1 &gt;= s2也为true呢？感觉有点矛盾","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563501,"discussion_content":"我们不说go string，我们就说代数上&gt;和&gt;=这两个比较操作符的语义：\n1&gt;0  // true\n1&gt;=0 是不是也是true呢？显然是啊。&gt;=的语义就是&gt;或=都是true啊。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650011775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2889691,"avatar":"","nickname":"flexiver","note":"","ucode":"5D83DFA90826E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563761,"discussion_content":"我自己有点陷入牛角尖了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650074212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331894,"user_name":"光","can_delete":false,"product_type":"c1","uid":1284618,"ip_address":"","ucode":"BDA7F41566E4FE","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/0a/6c74e932.jpg","comment_is_top":false,"comment_ctime":1642856859,"is_pvip":false,"replies":[{"id":121608,"content":"valid是将一个合法的unicode字符串转换为utf8编码（通过string-&gt;切片的转型）。因此转换后的字节序列也是一个合法的utf8编码。invalid切片中三个字节不构成一个合法的unicode字符的utf8编码，所以invalid。\n\n如果你用下面代码\n      valid1 := []byte{231, 149, 140} &#47;&#47; unicode字符“界”的utf8编码\n则Valid也会输出true      \nfmt.Println(utf8.Valid(valid1)) &#47;&#47; true","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643540167,"ip_address":"","comment_id":331894,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"问下这两种写法有什么不一样么。\n\t\n\nvalid := []byte(&quot;Hello, 世界&quot;)\n\tinvalid := []byte{0xff, 0xfe, 0xfd}\n\n\tfmt.Println(valid)\n\tfmt.Println(invalid)\n\tfmt.Println(utf8.Valid(valid))\n\tfmt.Println(utf8.Valid(invalid))","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549068,"discussion_content":"valid是将一个合法的unicode字符串转换为utf8编码（通过string-&gt;切片的转型）。因此转换后的字节序列也是一个合法的utf8编码。invalid切片中三个字节不构成一个合法的unicode字符的utf8编码，所以invalid。\n\n如果你用下面代码\n      valid1 := []byte{231, 149, 140} // unicode字符“界”的utf8编码\n则Valid也会输出true      \nfmt.Println(utf8.Valid(valid1)) // true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643540168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325356,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1638930300,"is_pvip":false,"replies":[{"id":118598,"content":"我继续努力😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1639562191,"ip_address":"","comment_id":325356,"utype":1}],"discussion_count":1,"race_medal":2,"score":4,"product_id":100093501,"comment_content":"读过的最好的介绍字符串类型的文章！期待老师后面推出进阶的 Go 课程。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538950,"discussion_content":"我继续努力😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639562191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324649,"user_name":"扣剑书生","can_delete":false,"product_type":"c1","uid":2855599,"ip_address":"","ucode":"6F5FD189D2916C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/92/af/ad02ae4b.jpg","comment_is_top":false,"comment_ctime":1638525644,"is_pvip":false,"replies":[{"id":117955,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827648,"ip_address":"","comment_id":324649,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"连接 5万个 helloworld\n2.6157056s + 拼接方式\n994µs strings.Join()\n8.9755ms string.Builder","like_count":1},{"had_liked":false,"id":320796,"user_name":"羊羊","can_delete":false,"product_type":"c1","uid":1162597,"ip_address":"","ucode":"B220CE8D1CA5DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/65/fbdf4fc1.jpg","comment_is_top":false,"comment_ctime":1636513409,"is_pvip":false,"replies":[{"id":116724,"content":"1. 获取字符串字节长度的时间复杂度是O(1)么？ - 是的\n2. 使用utf8的库函数utf8.RuneCountInString()获取字符串字符长度的时间复杂度应该是o(n)。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902055,"ip_address":"","comment_id":320796,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"第二点：没有结尾’\\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。这里应该是获取字符串字节长度的时间复杂度是O(1)么？如果使用utf8的库函数utf8.RuneCountInString()获取字符串字符长度，不知道时间复杂度是多少呢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530118,"discussion_content":"1. 获取字符串字节长度的时间复杂度是O(1)么？ - 是的\n2. 使用utf8的库函数utf8.RuneCountInString()获取字符串字符长度的时间复杂度应该是o(n)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1627670,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d6/16/107f0d04.jpg","nickname":"山青","note":"","ucode":"904AE3C23D3B92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413624,"discussion_content":"后面的答案是直接取值的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636529791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320773,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1636509144,"is_pvip":false,"replies":[{"id":116721,"content":"这个没啥权威文章，自己写benchmark跑一下就大体能判断出那个性能更好了。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636901376,"ip_address":"","comment_id":320773,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"关于拼接性能，有没有权威的文章介绍，我对比测试发现的结果 fmt.Sprintf 基本都是最差的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530107,"discussion_content":"这个没啥权威文章，自己写benchmark跑一下就大体能判断出那个性能更好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636901376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320736,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1636475999,"is_pvip":false,"replies":[{"id":116720,"content":"建议自己写一个benchmark test，跑一下，验证一下。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636901302,"ip_address":"","comment_id":320736,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"我感觉是直接拿加号快，因为利用函数还需要调用外部函数，这样会浪费时间","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530107,"discussion_content":"这个没啥权威文章，自己写benchmark跑一下就大体能判断出那个性能更好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636901376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390482,"user_name":"人言有力","can_delete":false,"product_type":"c1","uid":1690736,"ip_address":"浙江","ucode":"3708FBBFB641FE","user_header":"https://static001.geekbang.org/account/avatar/00/19/cc/70/64045bc0.jpg","comment_is_top":false,"comment_ctime":1715426347,"is_pvip":false,"replies":[{"id":142090,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1715870120,"ip_address":"辽宁","comment_id":390482,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"本节介绍了go字符串的原生支持好处、两种视角、编码方式、内存存储结构、字符串操作等\n1.原生支持字符串，省去了C语言的类型检查、并发同步、缓冲区溢出、非ASCII码不支持的问题\n2.两种视角是字节序列视角和字符序列视角，分别是用utf-8编码和unicode编码的值，一个汉字通常3字节\n3.存储结构是定义一个stringHeader类型，存储实际内容数组的引用，以及字节长度，这样可以O（1）时间获取长度，并且参数传递开销小\n4.字符串的拼接可以用+&#47;+=，在声明阶段使用没有任何问题，但是如果在循环中频繁赋值会不断新增内存，需要用string.Builder等方法\n思考题\n性能最好的是string.Builder因为它不会额外开辟内存进行数据拷贝，而是在原始字符串片段上追加","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645211,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715870121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389516,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1712760370,"is_pvip":false,"replies":[{"id":141724,"content":"随着Go版本的演进，编译器优化的提升，benchmark结果会有变化。你的示例中原生+来连接两个string的确性能很好，其原因是因为你用了两个字符串字面值进行了连接，编译器在编译时会直接将其优化为一个字符串，并做赋值操作，真正执行时，根本没有执行“+”这个操作。\n\n你可以添加一个用例看一下：\n\nfunc BenchmarkSimpleJoin1(b *testing.B) {\n    var s = &quot;cluster_id&quot;\n    for i := 0; i &lt; b.N; i++ {\n        _ = s + &quot;9930037e-3ed6-4aff-b991-in01&quot;\n    }\n}\n\n在我的电脑上运行结果如下：\n\n$go test -bench .    \ngoos: darwin\ngoarch: amd64\npkg: demo\n\nBenchmarkBuilder-8       \t17140472\t        84.48 ns&#47;op\nBenchmarkJoin-8          \t25367179\t        45.25 ns&#47;op\nBenchmarkSprintf-8       \t13941495\t        82.84 ns&#47;op\nBenchmarkSimpleJoin-8    \t1000000000\t         0.2723 ns&#47;op\nBenchmarkSimpleJoin1-8   \t32210946\t        39.12 ns&#47;op\nPASS\nok  \tdemo\t5.714s\n\n我的go版本是1.22.0。\n\n不过在这个简单的场景下，&quot;+&quot;操作相对于join、builder，依旧是最快的那个！","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1712840564,"ip_address":"辽宁","comment_id":389516,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师，我的测试用例发现 + 连接符性能最高（小数据量），懵了都\n\n[root@localhost disk_usage]# cat join_test.go \npackage main\n\nimport (\n        &quot;fmt&quot;\n        &quot;strings&quot;\n        &quot;testing&quot;\n)\n\nfunc BenchmarkBuilder(b *testing.B) {\n        var buffer strings.Builder\n        for i := 0; i &lt; b.N; i++ {\n                buffer.WriteString(&quot;cluster_id,&quot;)\n                buffer.WriteString(&quot;9930037e-3ed6-4aff-b991-in01&quot;)\n                _ = buffer.String()\n        }\n}\n\nfunc BenchmarkJoin(b *testing.B) {\n        for i := 0; i &lt; b.N; i++ {\n                _ = strings.Join([]string{&quot;cluster_id,&quot;, &quot;9930037e-3ed6-4aff-b991-in01&quot;}, &quot;&quot;)\n        }\n}\n\nfunc BenchmarkSprintf(b *testing.B) {\n        for i := 0; i &lt; b.N; i++ {\n                _ = fmt.Sprintf(&quot;%s%s&quot;, &quot;cluster_id,&quot;, &quot;9930037e-3ed6-4aff-b991-in01&quot;)\n        }\n}\n\nfunc BenchmarkSimpleJoin(b *testing.B) {\n        for i := 0; i &lt; b.N; i++ {\n                _ = &quot;cluster_id,&quot; + &quot;9930037e-3ed6-4aff-b991-in01&quot;\n        }\n}\n[root@localhost disk_usage]# go test -bench .\ngoos: linux\ngoarch: amd64\npkg: disk_monitor\ncpu: Intel(R) Xeon(R) Silver 4210R CPU @ 2.40GHz\nBenchmarkBuilder-8               8110462               142.6 ns&#47;op\nBenchmarkJoin-8                 16885898                74.39 ns&#47;op\nBenchmarkSprintf-8               8070631               141.4 ns&#47;op\nBenchmarkSimpleJoin-8           1000000000               0.3576 ns&#47;op\nPASS\nok      disk_monitor        4.339s","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641641,"discussion_content":"随着Go版本的演进，编译器优化的提升，benchmark结果会有变化。你的示例中原生+来连接两个string的确性能很好，其原因是因为你用了两个字符串字面值进行了连接，编译器在编译时会直接将其优化为一个字符串，并做赋值操作，真正执行时，根本没有执行“+”这个操作。\n\n你可以添加一个用例看一下：\n\nfunc BenchmarkSimpleJoin1(b *testing.B) {\n    var s = &#34;cluster_id&#34;\n    for i := 0; i &lt; b.N; i++ {\n        _ = s + &#34;9930037e-3ed6-4aff-b991-in01&#34;\n    }\n}\n\n在我的电脑上运行结果如下：\n\n$go test -bench .    \ngoos: darwin\ngoarch: amd64\npkg: demo\n\nBenchmarkBuilder-8       \t17140472\t        84.48 ns/op\nBenchmarkJoin-8          \t25367179\t        45.25 ns/op\nBenchmarkSprintf-8       \t13941495\t        82.84 ns/op\nBenchmarkSimpleJoin-8    \t1000000000\t         0.2723 ns/op\nBenchmarkSimpleJoin1-8   \t32210946\t        39.12 ns/op\nPASS\nok  \tdemo\t5.714s\n\n我的go版本是1.22.0。\n\n不过在这个简单的场景下，&#34;+&#34;操作相对于join、builder，依旧是最快的那个！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712840564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379665,"user_name":"林十二XII","can_delete":false,"product_type":"c1","uid":1375054,"ip_address":"北京","ucode":"0C52FB9925A78C","user_header":"https://static001.geekbang.org/account/avatar/00/14/fb/4e/6762d56f.jpg","comment_is_top":false,"comment_ctime":1692259017,"is_pvip":true,"replies":[{"id":138319,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1692350633,"ip_address":"北京","comment_id":379665,"utype":1}],"discussion_count":1,"race_medal":1,"score":5,"product_id":100093501,"comment_content":"老师的课质量很高，但建议先大概过一遍Go官方文档和Go by Example后再看。不然有些概念一时或许理解不了。\n","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625948,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692350633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321079,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1636649163,"is_pvip":false,"replies":[{"id":116757,"content":"java中==是比较是否是同一对象。若要比内容，应该用equals方法。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636929805,"ip_address":"","comment_id":321079,"utype":1}],"discussion_count":4,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师您好，想请教下 Go 中的 == 字符串比较和 Java 中的有什么区别吗？\nJava 中好像是字符串内存地址的比较，因为 java.lang.String 是一个对象。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625948,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692350633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320925,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1636560511,"is_pvip":false,"replies":[{"id":116732,"content":"原文有问题，已更正，请用最新内容重试。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902619,"ip_address":"","comment_id":320925,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师，我复制并试了文章中的多行字符串例子，为什么报错的呢？\n\n[setup failed]\nstring_test.go:105:26: expected &#39;;&#39;, found `*g*\\&quot;*, \n &#47; __&#47; &#47;&#39;     ^.  &#47;      \\ ^@q   f \n[  @f | @))    |  | @))   l  0 _&#47;  \n \\`\nFAIL","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530166,"discussion_content":"原文有问题，已更正，请用最新内容重试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320921,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1636558951,"is_pvip":true,"replies":[{"id":116751,"content":"实话实说，这个多年了，我还没遇到过。除非你的环境使用的不是utf8编码方式。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636928514,"ip_address":"","comment_id":320921,"utype":1}],"discussion_count":1,"race_medal":4,"score":5,"product_id":100093501,"comment_content":"字符串是很常用的东西，不由得在想，go应该也有字符串乱码的问题吧？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530166,"discussion_content":"原文有问题，已更正，请用最新内容重试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324649,"user_name":"扣剑书生","can_delete":false,"product_type":"c1","uid":2855599,"ip_address":"","ucode":"6F5FD189D2916C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/92/af/ad02ae4b.jpg","comment_is_top":false,"comment_ctime":1638525644,"is_pvip":false,"replies":[{"id":117955,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1638827648,"ip_address":"","comment_id":324649,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"连接 5万个 helloworld\n2.6157056s + 拼接方式\n994µs strings.Join()\n8.9755ms string.Builder","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536581,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320796,"user_name":"羊羊","can_delete":false,"product_type":"c1","uid":1162597,"ip_address":"","ucode":"B220CE8D1CA5DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/65/fbdf4fc1.jpg","comment_is_top":false,"comment_ctime":1636513409,"is_pvip":false,"replies":[{"id":116724,"content":"1. 获取字符串字节长度的时间复杂度是O(1)么？ - 是的\n2. 使用utf8的库函数utf8.RuneCountInString()获取字符串字符长度的时间复杂度应该是o(n)。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902055,"ip_address":"","comment_id":320796,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"第二点：没有结尾’\\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。这里应该是获取字符串字节长度的时间复杂度是O(1)么？如果使用utf8的库函数utf8.RuneCountInString()获取字符串字符长度，不知道时间复杂度是多少呢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536581,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638827648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320773,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1636509144,"is_pvip":false,"replies":[{"id":116721,"content":"这个没啥权威文章，自己写benchmark跑一下就大体能判断出那个性能更好了。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636901376,"ip_address":"","comment_id":320773,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"关于拼接性能，有没有权威的文章介绍，我对比测试发现的结果 fmt.Sprintf 基本都是最差的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530118,"discussion_content":"1. 获取字符串字节长度的时间复杂度是O(1)么？ - 是的\n2. 使用utf8的库函数utf8.RuneCountInString()获取字符串字符长度的时间复杂度应该是o(n)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636902055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1627670,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d6/16/107f0d04.jpg","nickname":"山青","note":"","ucode":"904AE3C23D3B92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413624,"discussion_content":"后面的答案是直接取值的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636529791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320736,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1636475999,"is_pvip":false,"replies":[{"id":116720,"content":"建议自己写一个benchmark test，跑一下，验证一下。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636901302,"ip_address":"","comment_id":320736,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"我感觉是直接拿加号快，因为利用函数还需要调用外部函数，这样会浪费时间","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530095,"discussion_content":"建议自己写一个benchmark test，跑一下，验证一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636901302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390482,"user_name":"人言有力","can_delete":false,"product_type":"c1","uid":1690736,"ip_address":"浙江","ucode":"3708FBBFB641FE","user_header":"https://static001.geekbang.org/account/avatar/00/19/cc/70/64045bc0.jpg","comment_is_top":false,"comment_ctime":1715426347,"is_pvip":false,"replies":[{"id":142090,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1715870120,"ip_address":"辽宁","comment_id":390482,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"本节介绍了go字符串的原生支持好处、两种视角、编码方式、内存存储结构、字符串操作等\n1.原生支持字符串，省去了C语言的类型检查、并发同步、缓冲区溢出、非ASCII码不支持的问题\n2.两种视角是字节序列视角和字符序列视角，分别是用utf-8编码和unicode编码的值，一个汉字通常3字节\n3.存储结构是定义一个stringHeader类型，存储实际内容数组的引用，以及字节长度，这样可以O（1）时间获取长度，并且参数传递开销小\n4.字符串的拼接可以用+&#47;+=，在声明阶段使用没有任何问题，但是如果在循环中频繁赋值会不断新增内存，需要用string.Builder等方法\n思考题\n性能最好的是string.Builder因为它不会额外开辟内存进行数据拷贝，而是在原始字符串片段上追加","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530095,"discussion_content":"建议自己写一个benchmark test，跑一下，验证一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636901302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389516,"user_name":"Geek_73c432","can_delete":false,"product_type":"c1","uid":2869118,"ip_address":"广东","ucode":"3E11EB02B14DE0","user_header":"","comment_is_top":false,"comment_ctime":1712760370,"is_pvip":false,"replies":[{"id":141724,"content":"随着Go版本的演进，编译器优化的提升，benchmark结果会有变化。你的示例中原生+来连接两个string的确性能很好，其原因是因为你用了两个字符串字面值进行了连接，编译器在编译时会直接将其优化为一个字符串，并做赋值操作，真正执行时，根本没有执行“+”这个操作。\n\n你可以添加一个用例看一下：\n\nfunc BenchmarkSimpleJoin1(b *testing.B) {\n    var s = &quot;cluster_id&quot;\n    for i := 0; i &lt; b.N; i++ {\n        _ = s + &quot;9930037e-3ed6-4aff-b991-in01&quot;\n    }\n}\n\n在我的电脑上运行结果如下：\n\n$go test -bench .    \ngoos: darwin\ngoarch: amd64\npkg: demo\n\nBenchmarkBuilder-8       \t17140472\t        84.48 ns&#47;op\nBenchmarkJoin-8          \t25367179\t        45.25 ns&#47;op\nBenchmarkSprintf-8       \t13941495\t        82.84 ns&#47;op\nBenchmarkSimpleJoin-8    \t1000000000\t         0.2723 ns&#47;op\nBenchmarkSimpleJoin1-8   \t32210946\t        39.12 ns&#47;op\nPASS\nok  \tdemo\t5.714s\n\n我的go版本是1.22.0。\n\n不过在这个简单的场景下，&quot;+&quot;操作相对于join、builder，依旧是最快的那个！","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1712840564,"ip_address":"辽宁","comment_id":389516,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师，我的测试用例发现 + 连接符性能最高（小数据量），懵了都\n\n[root@localhost disk_usage]# cat join_test.go \npackage main\n\nimport (\n        &quot;fmt&quot;\n        &quot;strings&quot;\n        &quot;testing&quot;\n)\n\nfunc BenchmarkBuilder(b *testing.B) {\n        var buffer strings.Builder\n        for i := 0; i &lt; b.N; i++ {\n                buffer.WriteString(&quot;cluster_id,&quot;)\n                buffer.WriteString(&quot;9930037e-3ed6-4aff-b991-in01&quot;)\n                _ = buffer.String()\n        }\n}\n\nfunc BenchmarkJoin(b *testing.B) {\n        for i := 0; i &lt; b.N; i++ {\n                _ = strings.Join([]string{&quot;cluster_id,&quot;, &quot;9930037e-3ed6-4aff-b991-in01&quot;}, &quot;&quot;)\n        }\n}\n\nfunc BenchmarkSprintf(b *testing.B) {\n        for i := 0; i &lt; b.N; i++ {\n                _ = fmt.Sprintf(&quot;%s%s&quot;, &quot;cluster_id,&quot;, &quot;9930037e-3ed6-4aff-b991-in01&quot;)\n        }\n}\n\nfunc BenchmarkSimpleJoin(b *testing.B) {\n        for i := 0; i &lt; b.N; i++ {\n                _ = &quot;cluster_id,&quot; + &quot;9930037e-3ed6-4aff-b991-in01&quot;\n        }\n}\n[root@localhost disk_usage]# go test -bench .\ngoos: linux\ngoarch: amd64\npkg: disk_monitor\ncpu: Intel(R) Xeon(R) Silver 4210R CPU @ 2.40GHz\nBenchmarkBuilder-8               8110462               142.6 ns&#47;op\nBenchmarkJoin-8                 16885898                74.39 ns&#47;op\nBenchmarkSprintf-8               8070631               141.4 ns&#47;op\nBenchmarkSimpleJoin-8           1000000000               0.3576 ns&#47;op\nPASS\nok      disk_monitor        4.339s","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645211,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715870121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379665,"user_name":"林十二XII","can_delete":false,"product_type":"c1","uid":1375054,"ip_address":"北京","ucode":"0C52FB9925A78C","user_header":"https://static001.geekbang.org/account/avatar/00/14/fb/4e/6762d56f.jpg","comment_is_top":false,"comment_ctime":1692259017,"is_pvip":true,"replies":[{"id":138319,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1692350633,"ip_address":"北京","comment_id":379665,"utype":1}],"discussion_count":1,"race_medal":1,"score":5,"product_id":100093501,"comment_content":"老师的课质量很高，但建议先大概过一遍Go官方文档和Go by Example后再看。不然有些概念一时或许理解不了。\n","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641641,"discussion_content":"随着Go版本的演进，编译器优化的提升，benchmark结果会有变化。你的示例中原生+来连接两个string的确性能很好，其原因是因为你用了两个字符串字面值进行了连接，编译器在编译时会直接将其优化为一个字符串，并做赋值操作，真正执行时，根本没有执行“+”这个操作。\n\n你可以添加一个用例看一下：\n\nfunc BenchmarkSimpleJoin1(b *testing.B) {\n    var s = &#34;cluster_id&#34;\n    for i := 0; i &lt; b.N; i++ {\n        _ = s + &#34;9930037e-3ed6-4aff-b991-in01&#34;\n    }\n}\n\n在我的电脑上运行结果如下：\n\n$go test -bench .    \ngoos: darwin\ngoarch: amd64\npkg: demo\n\nBenchmarkBuilder-8       \t17140472\t        84.48 ns/op\nBenchmarkJoin-8          \t25367179\t        45.25 ns/op\nBenchmarkSprintf-8       \t13941495\t        82.84 ns/op\nBenchmarkSimpleJoin-8    \t1000000000\t         0.2723 ns/op\nBenchmarkSimpleJoin1-8   \t32210946\t        39.12 ns/op\nPASS\nok  \tdemo\t5.714s\n\n我的go版本是1.22.0。\n\n不过在这个简单的场景下，&#34;+&#34;操作相对于join、builder，依旧是最快的那个！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712840564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321079,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1636649163,"is_pvip":false,"replies":[{"id":116757,"content":"java中==是比较是否是同一对象。若要比内容，应该用equals方法。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636929805,"ip_address":"","comment_id":321079,"utype":1}],"discussion_count":4,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师您好，想请教下 Go 中的 == 字符串比较和 Java 中的有什么区别吗？\nJava 中好像是字符串内存地址的比较，因为 java.lang.String 是一个对象。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530210,"discussion_content":"java中==是比较是否是同一对象。若要比内容，应该用equals方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636929805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553894,"discussion_content":"文档内容：\n\n鉴于 Go string 类型是不可变的，所以说如果两个字符串的长度不相同，那么我们不需要比较具体字符串数据，也可以断定两个字符串是不同的。但是如果两个字符串长度相同，就要进一步判断，数据指针是否指向同一块底层存储数据。如果还相同，那么我们可以说两个字符串是等价的，如果不同，那就还需要进一步去比对实际的数据内容。\n\n已经回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646127788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414224,"discussion_content":"文中不是讲了go的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636695694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414225,"discussion_content":"Go的是只比较字符串字面值？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636697181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414224,"ip_address":"","group_id":0},"score":414225,"extra":""}]}]},{"had_liked":false,"id":320925,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1636560511,"is_pvip":false,"replies":[{"id":116732,"content":"原文有问题，已更正，请用最新内容重试。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636902619,"ip_address":"","comment_id":320925,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师，我复制并试了文章中的多行字符串例子，为什么报错的呢？\n\n[setup failed]\nstring_test.go:105:26: expected &#39;;&#39;, found `*g*\\&quot;*, \n &#47; __&#47; &#47;&#39;     ^.  &#47;      \\ ^@q   f \n[  @f | @))    |  | @))   l  0 _&#47;  \n \\`\nFAIL","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530210,"discussion_content":"java中==是比较是否是同一对象。若要比内容，应该用equals方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636929805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553894,"discussion_content":"文档内容：\n\n鉴于 Go string 类型是不可变的，所以说如果两个字符串的长度不相同，那么我们不需要比较具体字符串数据，也可以断定两个字符串是不同的。但是如果两个字符串长度相同，就要进一步判断，数据指针是否指向同一块底层存储数据。如果还相同，那么我们可以说两个字符串是等价的，如果不同，那就还需要进一步去比对实际的数据内容。\n\n已经回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646127788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414224,"discussion_content":"文中不是讲了go的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636695694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414225,"discussion_content":"Go的是只比较字符串字面值？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636697181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414224,"ip_address":"","group_id":0},"score":414225,"extra":""}]}]},{"had_liked":false,"id":320921,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1636558951,"is_pvip":true,"replies":[{"id":116751,"content":"实话实说，这个多年了，我还没遇到过。除非你的环境使用的不是utf8编码方式。","user_name":"作者回复","user_name_real":"Tony Bai","uid":1026224,"ctime":1636928514,"ip_address":"","comment_id":320921,"utype":1}],"discussion_count":1,"race_medal":4,"score":5,"product_id":100093501,"comment_content":"字符串是很常用的东西，不由得在想，go应该也有字符串乱码的问题吧？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530164,"discussion_content":"实话实说，这个多年了，我还没遇到过。除非你的环境使用的不是utf8编码方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636928514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320750,"user_name":"Aaron Liu","can_delete":false,"product_type":"c1","uid":1125662,"ip_address":"","ucode":"DECCD16350C2A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/1e/4a93ebb5.jpg","comment_is_top":false,"comment_ctime":1636504019,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"这是见过讲string最详细的，原理，实操，对比，背后的设计以及常用方法，很透彻，继续学习","like_count":30},{"had_liked":false,"id":350570,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1657008377,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"goos: windows\ngoarch: amd64\npkg: string-benchmark\ncpu: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz\nBenchmarkPlusConcat-8           22668925                68.85 ns&#47;op          160 B&#47;op          1 allocs&#47;op\nBenchmarkSprintfConcat-8         6583195               258.9 ns&#47;op            96 B&#47;op          1 allocs&#47;op\nBenchmarkBuilderConcat-8        20633268                55.04 ns&#47;op           80 B&#47;op          1 allocs&#47;op\nBenchmarkBufferConcat-8         10203872               113.0 ns&#47;op           160 B&#47;op          2 allocs&#47;op\nBenchmarkByteConcat-8           15657415               100.2 ns&#47;op           160 B&#47;op          2 allocs&#47;op\nBenchmarkPreByteConcat-8        14895951                91.24 ns&#47;op          160 B&#47;op          2 allocs&#47;op\nBenchmarkBuilderGrow-8             13224            194728 ns&#47;op         1064961 B&#47;op          1 allocs&#47;op\nBenchmarkBufferGrow-8              10000            112001 ns&#47;op          802819 B&#47;op          1 allocs&#47;op\nPASS\nok      string-benchmark        14.616s\n\n我的压测结果，和一楼童鞋有点差异","like_count":0},{"had_liked":false,"id":321371,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1636815875,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"这才是最靓的仔\n         ,_---~~~~~----._\n_,,_,*^____      _____*g*\\&quot;*,--,\n&#47; __&#47; &#47;&#39;     ^.  &#47;      \\ ^@q   f\n[  @f | @))    |  | @))   l  0 _&#47;\n\\&#47;   \\~____ &#47; __ \\_____&#47;     \\\n|           _l__l_           I\n}          [______]           I\n]            | | |            |\n]             ~ ~             |\n|                            |\n |                           |","like_count":0},{"had_liked":false,"id":320993,"user_name":"豆腐居士","can_delete":false,"product_type":"c1","uid":1100239,"ip_address":"","ucode":"F7C82FEB60C2B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cf/af720d94.jpg","comment_is_top":false,"comment_ctime":1636612698,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"催更。。。","like_count":0},{"had_liked":false,"id":320831,"user_name":"TonyGao","can_delete":false,"product_type":"c1","uid":2827964,"ip_address":"","ucode":"75E9F13CB7C66D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/26/bc/a73e4275.jpg","comment_is_top":false,"comment_ctime":1636525350,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"+，+= 和 fmt.Sprintf效率应该是最差的，strings.Builder和strings.Join性能应该不错，特别是strings.Join","like_count":0},{"had_liked":false,"id":320822,"user_name":"酥宝话不多","can_delete":false,"product_type":"c1","uid":2564698,"ip_address":"","ucode":"3B9BF256682504","user_header":"https://static001.geekbang.org/account/avatar/00/27/22/5a/873ac981.jpg","comment_is_top":false,"comment_ctime":1636522573,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"不加锁的性能强","like_count":0},{"had_liked":false,"id":320750,"user_name":"Aaron Liu","can_delete":false,"product_type":"c1","uid":1125662,"ip_address":"","ucode":"DECCD16350C2A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/1e/4a93ebb5.jpg","comment_is_top":false,"comment_ctime":1636504019,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"这是见过讲string最详细的，原理，实操，对比，背后的设计以及常用方法，很透彻，继续学习","like_count":30},{"had_liked":false,"id":350570,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1657008377,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"goos: windows\ngoarch: amd64\npkg: string-benchmark\ncpu: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz\nBenchmarkPlusConcat-8           22668925                68.85 ns&#47;op          160 B&#47;op          1 allocs&#47;op\nBenchmarkSprintfConcat-8         6583195               258.9 ns&#47;op            96 B&#47;op          1 allocs&#47;op\nBenchmarkBuilderConcat-8        20633268                55.04 ns&#47;op           80 B&#47;op          1 allocs&#47;op\nBenchmarkBufferConcat-8         10203872               113.0 ns&#47;op           160 B&#47;op          2 allocs&#47;op\nBenchmarkByteConcat-8           15657415               100.2 ns&#47;op           160 B&#47;op          2 allocs&#47;op\nBenchmarkPreByteConcat-8        14895951                91.24 ns&#47;op          160 B&#47;op          2 allocs&#47;op\nBenchmarkBuilderGrow-8             13224            194728 ns&#47;op         1064961 B&#47;op          1 allocs&#47;op\nBenchmarkBufferGrow-8              10000            112001 ns&#47;op          802819 B&#47;op          1 allocs&#47;op\nPASS\nok      string-benchmark        14.616s\n\n我的压测结果，和一楼童鞋有点差异","like_count":0},{"had_liked":false,"id":321371,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1636815875,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"这才是最靓的仔\n         ,_---~~~~~----._\n_,,_,*^____      _____*g*\\&quot;*,--,\n&#47; __&#47; &#47;&#39;     ^.  &#47;      \\ ^@q   f\n[  @f | @))    |  | @))   l  0 _&#47;\n\\&#47;   \\~____ &#47; __ \\_____&#47;     \\\n|           _l__l_           I\n}          [______]           I\n]            | | |            |\n]             ~ ~             |\n|                            |\n |                           |","like_count":0,"discussions":[{"author":{"id":1556406,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/iaXcnYOjwO39gSSyo0CprNeLxx6OF80KqPz69ErJKmibMSxn5YeM4VGD6ATBnUR045ibsYjQGlAAQo5r3iaTPydTbA/132","nickname":"docker131313","note":"","ucode":"5B24734D18B57C","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641235,"discussion_content":"不像go吉祥物","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712397187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414904,"discussion_content":"变形了\n……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636934812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320993,"user_name":"豆腐居士","can_delete":false,"product_type":"c1","uid":1100239,"ip_address":"","ucode":"F7C82FEB60C2B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cf/af720d94.jpg","comment_is_top":false,"comment_ctime":1636612698,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"催更。。。","like_count":0},{"had_liked":false,"id":320831,"user_name":"TonyGao","can_delete":false,"product_type":"c1","uid":2827964,"ip_address":"","ucode":"75E9F13CB7C66D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/26/bc/a73e4275.jpg","comment_is_top":false,"comment_ctime":1636525350,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"+，+= 和 fmt.Sprintf效率应该是最差的，strings.Builder和strings.Join性能应该不错，特别是strings.Join","like_count":0},{"had_liked":false,"id":320822,"user_name":"酥宝话不多","can_delete":false,"product_type":"c1","uid":2564698,"ip_address":"","ucode":"3B9BF256682504","user_header":"https://static001.geekbang.org/account/avatar/00/27/22/5a/873ac981.jpg","comment_is_top":false,"comment_ctime":1636522573,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"不加锁的性能强","like_count":0,"discussions":[{"author":{"id":1556406,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/iaXcnYOjwO39gSSyo0CprNeLxx6OF80KqPz69ErJKmibMSxn5YeM4VGD6ATBnUR045ibsYjQGlAAQo5r3iaTPydTbA/132","nickname":"docker131313","note":"","ucode":"5B24734D18B57C","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641235,"discussion_content":"不像go吉祥物","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712397187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414904,"discussion_content":"变形了\n……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636934812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}