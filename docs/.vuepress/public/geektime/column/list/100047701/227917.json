{"id":227917,"title":"19 | Spring框架：IoC和AOP是扩展的核心","content":"<p>你好，我是朱晔。今天，我们来聊聊Spring框架中的IoC和AOP，及其容易出错的地方。</p><p>熟悉Java的同学都知道，Spring的家族庞大，常用的模块就有Spring Data、Spring Security、Spring Boot、Spring Cloud等。其实呢，Spring体系虽然庞大，但都是围绕Spring Core展开的，而Spring Core中最核心的就是IoC（控制反转）和AOP（面向切面编程）。</p><p>概括地说，IoC和AOP的初衷是解耦和扩展。理解这两个核心技术，就可以让你的代码变得更灵活、可随时替换，以及业务组件间更解耦。在接下来的两讲中，我会与你深入剖析几个案例，带你绕过业务中通过Spring实现IoC和AOP相关的坑。</p><p>为了便于理解这两讲中的案例，我们先回顾下IoC和AOP的基础知识。</p><p>IoC，其实就是一种设计思想。使用Spring来实现IoC，意味着将你设计好的对象交给Spring容器控制，而不是直接在对象内部控制。那，为什么要让容器来管理对象呢？或许你能想到的是，使用IoC方便、可以实现解耦。但在我看来，相比于这两个原因，更重要的是IoC带来了更多的可能性。</p><p>如果以容器为依托来管理所有的框架、业务对象，我们不仅可以无侵入地调整对象的关系，还可以无侵入地随时调整对象的属性，甚至是实现对象的替换。这就使得框架开发者在程序背后实现一些扩展不再是问题，带来的可能性是无限的。比如我们要监控的对象如果是Bean，实现就会非常简单。所以，这套容器体系，不仅被Spring Core和Spring Boot大量依赖，还实现了一些外部框架和Spring的无缝整合。</p><!-- [[[read_end]]] --><p>AOP，体现了松耦合、高内聚的精髓，在切面集中实现横切关注点（缓存、权限、日志等），然后通过切点配置把代码注入合适的地方。切面、切点、增强、连接点，是AOP中非常重要的概念，也是我们这两讲会大量提及的。</p><p>为方便理解，我们把Spring AOP技术看作为蛋糕做奶油夹层的工序。如果我们希望找到一个合适的地方把奶油注入蛋糕胚子中，那应该如何指导工人完成操作呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/db/c71f2ec73901f7bcaa8332f237dfeddb.png?wh=1410*572\" alt=\"\"></p><ul>\n<li>首先，我们要提醒他，只能往蛋糕胚子里面加奶油，而不能上面或下面加奶油。这就是连接点（Join point），对于Spring AOP来说，连接点就是方法执行。</li>\n<li>然后，我们要告诉他，在什么点切开蛋糕加奶油。比如，可以在蛋糕坯子中间加入一层奶油，在中间切一次；也可以在中间加两层奶油，在1/3和2/3的地方切两次。这就是切点（Pointcut），Spring AOP中默认使用AspectJ查询表达式，通过在连接点运行查询表达式来匹配切入点。</li>\n<li>接下来也是最重要的，我们要告诉他，切开蛋糕后要做什么，也就是加入奶油。这就是增强（Advice），也叫作通知，定义了切入切点后增强的方式，包括前、后、环绕等。Spring AOP中，把增强定义为拦截器。</li>\n<li>最后，我们要告诉他，找到蛋糕胚子中要加奶油的地方并加入奶油。为蛋糕做奶油夹层的操作，对Spring AOP来说就是切面（Aspect），也叫作方面。切面=切点+增强。</li>\n</ul><p>好了，理解了这几个核心概念，我们就可以继续分析案例了。</p><p>我要首先说明的是，Spring相关问题的问题比较复杂，一方面是Spring提供的IoC和AOP本就灵活，另一方面Spring Boot的自动装配、Spring Cloud复杂的模块会让问题排查变得更复杂。因此，今天这一讲，我会带你先打好基础，通过两个案例来重点聊聊IoC和AOP；然后，我会在下一讲中与你分享Spring相关的坑。</p><h2>单例的Bean如何注入Prototype的Bean？</h2><p>我们虽然知道Spring创建的Bean默认是单例的，但当Bean遇到继承的时候，可能会忽略这一点。为什么呢？忽略这一点又会造成什么影响呢？接下来，我就和你分享一个由单例引起内存泄露的案例。</p><p>架构师一开始定义了这么一个SayService抽象类，其中维护了一个类型是ArrayList的字段data，用于保存方法处理的中间数据。每次调用say方法都会往data加入新数据，可以认为SayService是有状态，如果SayService是单例的话必然会OOM：</p><pre><code>@Slf4j\npublic abstract class SayService {\n    List&lt;String&gt; data = new ArrayList&lt;&gt;();\n\n    public void say() {\n        data.add(IntStream.rangeClosed(1, 1000000)\n                .mapToObj(__ -&gt; &quot;a&quot;)\n                .collect(Collectors.joining(&quot;&quot;)) + UUID.randomUUID().toString());\n        log.info(&quot;I'm {} size:{}&quot;, this, data.size());\n    }\n}\n</code></pre><p>但实际开发的时候，开发同学没有过多思考就把SayHello和SayBye类加上了@Service注解，让它们成为了Bean，也没有考虑到父类是有状态的：</p><pre><code>@Service\n@Slf4j\npublic class SayHello extends SayService {\n    @Override\n    public void say() {\n        super.say();\n        log.info(&quot;hello&quot;);\n    }\n}\n\n@Service\n@Slf4j\npublic class SayBye extends SayService {\n    @Override\n    public void say() {\n        super.say();\n        log.info(&quot;bye&quot;);\n    }\n}\n</code></pre><p>许多开发同学认为，@Service注解的意义在于，能通过@Autowired注解让Spring自动注入对象，就比如可以直接使用注入的List<sayservice>获取到SayHello和SayBye，而没想过类的生命周期：</sayservice></p><pre><code>@Autowired\nList&lt;SayService&gt; sayServiceList;\n\n@GetMapping(&quot;test&quot;)\npublic void test() {\n    log.info(&quot;====================&quot;);\n    sayServiceList.forEach(SayService::say);\n}\n</code></pre><p>这一个点非常容易忽略。开发基类的架构师将基类设计为有状态的，但并不知道子类是怎么使用基类的；而开发子类的同学，没多想就直接标记了@Service，让类成为了Bean，通过@Autowired注解来注入这个服务。但这样设置后，有状态的基类就可能产生内存泄露或线程安全问题。</p><p>正确的方式是，<strong>在为类标记上@Service注解把类型交由容器管理前，首先评估一下类是否有状态，然后为Bean设置合适的Scope</strong>。好在上线前，架构师发现了这个内存泄露问题，开发同学也做了修改，为SayHello和SayBye两个类都标记了@Scope注解，设置了PROTOTYPE的生命周期，也就是多例：</p><pre><code>@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n</code></pre><p>但，上线后还是出现了内存泄漏，证明修改是无效的。</p><p>从日志可以看到，第一次调用和第二次调用的时候，SayBye对象都是4c0bfe9e，SayHello也是一样的问题。从日志第7到10行还可以看到，第二次调用后List的元素个数变为了2，说明父类SayService维护的List在不断增长，不断调用必然出现OOM：</p><pre><code>[15:01:09.349] [http-nio-45678-exec-1] [INFO ] [.s.d.BeanSingletonAndOrderController:22  ] - ====================\n[15:01:09.401] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayBye@4c0bfe9e size:1\n[15:01:09.402] [http-nio-45678-exec-1] [INFO ] [t.commonmistakes.spring.demo1.SayBye:16  ] - bye\n[15:01:09.469] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayHello@490fbeaa size:1\n[15:01:09.469] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo1.SayHello           :17  ] - hello\n[15:01:15.167] [http-nio-45678-exec-2] [INFO ] [.s.d.BeanSingletonAndOrderController:22  ] - ====================\n[15:01:15.197] [http-nio-45678-exec-2] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayBye@4c0bfe9e size:2\n[15:01:15.198] [http-nio-45678-exec-2] [INFO ] [t.commonmistakes.spring.demo1.SayBye:16  ] - bye\n[15:01:15.224] [http-nio-45678-exec-2] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayHello@490fbeaa size:2\n[15:01:15.224] [http-nio-45678-exec-2] [INFO ] [o.g.t.c.spring.demo1.SayHello           :17  ] - hello\n</code></pre><p>这就引出了单例的Bean如何注入Prototype的Bean这个问题。Controller标记了@RestController注解，而@RestController注解=@Controller注解+@ResponseBody注解，又因为@Controller标记了@Component元注解，所以@RestController注解其实也是一个Spring Bean：</p><pre><code>//@RestController注解=@Controller注解+@ResponseBody注解@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {}\n\n//@Controller又标记了@Component元注解\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Controller {}\n</code></pre><p><strong>Bean默认是单例的，所以单例的Controller注入的Service也是一次性创建的，即使Service本身标识了prototype的范围也没用。</strong></p><p>修复方式是，让Service以代理方式注入。这样虽然Controller本身是单例的，但每次都能从代理获取Service。这样一来，prototype范围的配置才能真正生效：</p><pre><code>@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)\n</code></pre><p>通过日志可以确认这种修复方式有效：</p><pre><code>[15:08:42.649] [http-nio-45678-exec-1] [INFO ] [.s.d.BeanSingletonAndOrderController:22  ] - ====================\n[15:08:42.747] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayBye@3fa64743 size:1\n[15:08:42.747] [http-nio-45678-exec-1] [INFO ] [t.commonmistakes.spring.demo1.SayBye:17  ] - bye\n[15:08:42.871] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayHello@2f0b779 size:1\n[15:08:42.872] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo1.SayHello           :17  ] - hello\n[15:08:42.932] [http-nio-45678-exec-2] [INFO ] [.s.d.BeanSingletonAndOrderController:22  ] - ====================\n[15:08:42.991] [http-nio-45678-exec-2] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayBye@7319b18e size:1\n[15:08:42.992] [http-nio-45678-exec-2] [INFO ] [t.commonmistakes.spring.demo1.SayBye:17  ] - bye\n[15:08:43.046] [http-nio-45678-exec-2] [INFO ] [o.g.t.c.spring.demo1.SayService         :19  ] - I'm org.geekbang.time.commonmistakes.spring.demo1.SayHello@77262b35 size:1\n[15:08:43.046] [http-nio-45678-exec-2] [INFO ] [o.g.t.c.spring.demo1.SayHello           :17  ] - hello\n</code></pre><p>调试一下也可以发现，注入的Service都是Spring生成的代理类：</p><p><img src=\"https://static001.geekbang.org/resource/image/a9/30/a95f7a5f3a576b3b426c7c5625b29230.png?wh=2082*264\" alt=\"\"></p><p>当然，如果不希望走代理的话还有一种方式是，每次直接从ApplicationContext中获取Bean：</p><pre><code>@Autowired\nprivate ApplicationContext applicationContext;\n@GetMapping(&quot;test2&quot;)\npublic void test2() {\napplicationContext.getBeansOfType(SayService.class).values().forEach(SayService::say);\n}\n</code></pre><p>如果细心的话，你可以发现另一个潜在的问题。这里Spring注入的SayService的List，第一个元素是SayBye，第二个元素是SayHello。但，我们更希望的是先执行Hello再执行Bye，所以注入一个List Bean时，需要进一步考虑Bean的顺序或者说优先级。</p><p>大多数情况下顺序并不是那么重要，但对于AOP，顺序可能会引发致命问题。我们继续往下看这个问题吧。</p><h2>监控切面因为顺序问题导致Spring事务失效</h2><p>实现横切关注点，是AOP非常常见的一个应用。我曾看到过一个不错的AOP实践，通过AOP实现了一个整合日志记录、异常处理和方法耗时打点为一体的统一切面。但后来发现，使用了AOP切面后，这个应用的声明式事务处理居然都是无效的。你可以先回顾下<a href=\"https://time.geekbang.org/column/article/213295\">第6讲</a>中提到的，Spring事务失效的几种可能性。</p><p>现在我们来看下这个案例，分析下AOP实现的监控组件和事务失效有什么关系，以及通过AOP实现监控组件是否还有其他坑。</p><p>首先，定义一个自定义注解Metrics，打上了该注解的方法可以实现各种监控功能：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.TYPE})\npublic @interface Metrics {\n    /**\n     * 在方法成功执行后打点，记录方法的执行时间发送到指标系统，默认开启\n     *\n     * @return\n     */\n    boolean recordSuccessMetrics() default true;\n\n    /**\n     * 在方法成功失败后打点，记录方法的执行时间发送到指标系统，默认开启\n     *\n     * @return\n     */\n    boolean recordFailMetrics() default true;\n\n    /**\n     * 通过日志记录请求参数，默认开启\n     *\n     * @return\n     */\n    boolean logParameters() default true;\n\n    /**\n     * 通过日志记录方法返回值，默认开启\n     *\n     * @return\n     */\n    boolean logReturn() default true;\n\n    /**\n     * 出现异常后通过日志记录异常信息，默认开启\n     *\n     * @return\n     */\n    boolean logException() default true;\n\n    /**\n     * 出现异常后忽略异常返回默认值，默认关闭\n     *\n     * @return\n     */\n    boolean ignoreException() default false;\n}\n</code></pre><p>然后，实现一个切面完成Metrics注解提供的功能。这个切面可以实现标记了@RestController注解的Web控制器的自动切入，如果还需要对更多Bean进行切入的话，再自行标记@Metrics注解。</p><blockquote>\n<p>备注：这段代码有些长，里面还用到了一些小技巧，你需要仔细阅读代码中的注释。</p>\n</blockquote><pre><code>@Aspect\n@Component\n@Slf4j\npublic class MetricsAspect {\n    //让Spring帮我们注入ObjectMapper，以方便通过JSON序列化来记录方法入参和出参\n    \n    @Autowired\n    private ObjectMapper objectMapper;\n\n    //实现一个返回Java基本类型默认值的工具。其实，你也可以逐一写很多if-else判断类型，然后手动设置其默认值。这里为了减少代码量用了一个小技巧，即通过初始化一个具有1个元素的数组，然后通过获取这个数组的值来获取基本类型默认值\n    private static final Map&lt;Class&lt;?&gt;, Object&gt; DEFAULT_VALUES = Stream\n            .of(boolean.class, byte.class, char.class, double.class, float.class, int.class, long.class, short.class)\n            .collect(toMap(clazz -&gt; (Class&lt;?&gt;) clazz, clazz -&gt; Array.get(Array.newInstance(clazz, 1), 0)));\n    public static &lt;T&gt; T getDefaultValue(Class&lt;T&gt; clazz) {\n        return (T) DEFAULT_VALUES.get(clazz);\n    }\n\n    //@annotation指示器实现对标记了Metrics注解的方法进行匹配\n   @Pointcut(&quot;within(@org.geekbang.time.commonmistakes.springpart1.aopmetrics.Metrics *)&quot;)\n    public void withMetricsAnnotation() {\n    }\n\n    //within指示器实现了匹配那些类型上标记了@RestController注解的方法\n    @Pointcut(&quot;within(@org.springframework.web.bind.annotation.RestController *)&quot;)\n    public void controllerBean() {\n    }\n\n    @Around(&quot;controllerBean() || withMetricsAnnotation())&quot;)\n    public Object metrics(ProceedingJoinPoint pjp) throws Throwable {\n        //通过连接点获取方法签名和方法上Metrics注解，并根据方法签名生成日志中要输出的方法定义描述\n        MethodSignature signature = (MethodSignature) pjp.getSignature();\n        Metrics metrics = signature.getMethod().getAnnotation(Metrics.class);\n \n        String name = String.format(&quot;【%s】【%s】&quot;, signature.getDeclaringType().toString(), signature.toLongString());\n        //因为需要默认对所有@RestController标记的Web控制器实现@Metrics注解的功能，在这种情况下方法上必然是没有@Metrics注解的，我们需要获取一个默认注解。虽然可以手动实例化一个@Metrics注解的实例出来，但为了节省代码行数，我们通过在一个内部类上定义@Metrics注解方式，然后通过反射获取注解的小技巧，来获得一个默认的@Metrics注解的实例\n        if (metrics == null) {\n            @Metrics\n            final class c {}\n            metrics = c.class.getAnnotation(Metrics.class);\n        }\n        //尝试从请求上下文（如果有的话）获得请求URL，以方便定位问题\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        if (requestAttributes != null) {\n            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();\n            if (request != null)\n                name += String.format(&quot;【%s】&quot;, request.getRequestURL().toString());\n        }\n        //实现的是入参的日志输出\n        if (metrics.logParameters())\n            log.info(String.format(&quot;【入参日志】调用 %s 的参数是：【%s】&quot;, name, objectMapper.writeValueAsString(pjp.getArgs())));\n        //实现连接点方法的执行，以及成功失败的打点，出现异常的时候还会记录日志\n        Object returnValue;\n        Instant start = Instant.now();\n        try {\n            returnValue = pjp.proceed();\n            if (metrics.recordSuccessMetrics())\n                //在生产级代码中，我们应考虑使用类似Micrometer的指标框架，把打点信息记录到时间序列数据库中，实现通过图表来查看方法的调用次数和执行时间，在设计篇我们会重点介绍\n                log.info(String.format(&quot;【成功打点】调用 %s 成功，耗时：%d ms&quot;, name, Duration.between(start, Instant.now()).toMillis()));\n        } catch (Exception ex) {\n            if (metrics.recordFailMetrics())\n                log.info(String.format(&quot;【失败打点】调用 %s 失败，耗时：%d ms&quot;, name, Duration.between(start, Instant.now()).toMillis()));\n            if (metrics.logException())\n                log.error(String.format(&quot;【异常日志】调用 %s 出现异常！&quot;, name), ex);\n\n            //忽略异常的时候，使用一开始定义的getDefaultValue方法，来获取基本类型的默认值\n            if (metrics.ignoreException())\n                returnValue = getDefaultValue(signature.getReturnType());\n            else\n                throw ex;\n        }\n        //实现了返回值的日志输出\n        if (metrics.logReturn())\n            log.info(String.format(&quot;【出参日志】调用 %s 的返回是：【%s】&quot;, name, returnValue));\n        return returnValue;\n    }\n}\n</code></pre><p>接下来，分别定义最简单的Controller、Service和Repository，来测试MetricsAspect的功能。</p><p>其中，Service中实现创建用户的时候做了事务处理，当用户名包含test字样时会抛出异常，导致事务回滚。同时，我们为Service中的createUser标记了@Metrics注解。这样一来，我们还可以手动为类或方法标记@Metrics注解，实现Controller之外的其他组件的自动监控。</p><pre><code>@Slf4j\n@RestController //自动进行监控\n@RequestMapping(&quot;metricstest&quot;)\npublic class MetricsController {\n    @Autowired\n    private UserService userService;\n    @GetMapping(&quot;transaction&quot;)\n    public int transaction(@RequestParam(&quot;name&quot;) String name) {\n        try {\n            userService.createUser(new UserEntity(name));\n        } catch (Exception ex) {\n            log.error(&quot;create user failed because {}&quot;, ex.getMessage());\n        }\n        return userService.getUserCount(name);\n    }\n}\n\n@Service\n@Slf4j\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    @Transactional\n    @Metrics //启用方法监控\n    public void createUser(UserEntity entity) {\n        userRepository.save(entity);\n        if (entity.getName().contains(&quot;test&quot;))\n            throw new RuntimeException(&quot;invalid username!&quot;);\n    }\n\n    public int getUserCount(String name) {\n        return userRepository.findByName(name).size();\n    }\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository&lt;UserEntity, Long&gt; {\n    List&lt;UserEntity&gt; findByName(String name);\n}\n</code></pre><p>使用用户名“test”测试一下注册功能：</p><pre><code>[16:27:52.586] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :85  ] - 【入参日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.MetricsController】【public int org.geekbang.time.commonmistakes.spring.demo2.MetricsController.transaction(java.lang.String)】【http://localhost:45678/metricstest/transaction】 的参数是：【[&quot;test&quot;]】\n[16:27:52.590] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :85  ] - 【入参日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.UserService】【public void org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(org.geekbang.time.commonmistakes.spring.demo2.UserEntity)】【http://localhost:45678/metricstest/transaction】 的参数是：【[{&quot;id&quot;:null,&quot;name&quot;:&quot;test&quot;}]】\n[16:27:52.609] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :96  ] - 【失败打点】调用 【class org.geekbang.time.commonmistakes.spring.demo2.UserService】【public void org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(org.geekbang.time.commonmistakes.spring.demo2.UserEntity)】【http://localhost:45678/metricstest/transaction】 失败，耗时：19 ms\n[16:27:52.610] [http-nio-45678-exec-3] [ERROR] [o.g.t.c.spring.demo2.MetricsAspect      :98  ] - 【异常日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.UserService】【public void org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(org.geekbang.time.commonmistakes.spring.demo2.UserEntity)】【http://localhost:45678/metricstest/transaction】 出现异常！\njava.lang.RuntimeException: invalid username!\n\tat org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(UserService.java:18)\n\tat org.geekbang.time.commonmistakes.spring.demo2.UserService$$FastClassBySpringCGLIB$$9eec91f.invoke(&lt;generated&gt;)\n[16:27:52.614] [http-nio-45678-exec-3] [ERROR] [g.t.c.spring.demo2.MetricsController:21  ] - create user failed because invalid username!\n[16:27:52.617] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :93  ] - 【成功打点】调用 【class org.geekbang.time.commonmistakes.spring.demo2.MetricsController】【public int org.geekbang.time.commonmistakes.spring.demo2.MetricsController.transaction(java.lang.String)】【http://localhost:45678/metricstest/transaction】 成功，耗时：31 ms\n[16:27:52.618] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :108 ] - 【出参日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.MetricsController】【public int org.geekbang.time.commonmistakes.spring.demo2.MetricsController.transaction(java.lang.String)】【http://localhost:45678/metricstest/transaction】 的返回是：【0】\n</code></pre><p>看起来这个切面很不错，日志中打出了整个调用的出入参、方法耗时：</p><ul>\n<li>第1、8、9和10行分别是Controller方法的入参日志、调用Service方法出错后记录的错误信息、成功执行的打点和出参日志。因为Controller方法内部进行了try-catch处理，所以其方法最终是成功执行的。出参日志中显示最后查询到的用户数量是0，表示用户创建实际是失败的。</li>\n<li>第2、3和4~7行分别是Service方法的入参日志、失败打点和异常日志。正是因为Service方法的异常抛到了Controller，所以整个方法才能被@Transactional声明式事务回滚。在这里，MetricsAspect捕获了异常又重新抛出，记录了异常的同时又不影响事务回滚。</li>\n</ul><p>一段时间后，开发同学觉得默认的@Metrics配置有点不合适，希望进行两个调整：</p><ul>\n<li>对于Controller的自动打点，不要自动记录入参和出参日志，否则日志量太大；</li>\n<li>对于Service中的方法，最好可以自动捕获异常。</li>\n</ul><p>于是，他就为MetricsController手动加上了@Metrics注解，设置logParameters和logReturn为false；然后为Service中的createUser方法的@Metrics注解，设置了ignoreException属性为true：</p><pre><code>@Metrics(logParameters = false, logReturn = false) //改动点1\npublic class MetricsController {\n\n@Service\n@Slf4j\npublic class UserService {\n    @Transactional\n    @Metrics(ignoreException = true) //改动点2\n    public void createUser(UserEntity entity) {\n    ...\n</code></pre><p>代码上线后发现日志量并没有减少，更要命的是事务回滚失效了，从输出看到最后查询到了名为test的用户：</p><pre><code>[17:01:16.549] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :75  ] - 【入参日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.MetricsController】【public int org.geekbang.time.commonmistakes.spring.demo2.MetricsController.transaction(java.lang.String)】【http://localhost:45678/metricstest/transaction】 的参数是：【[&quot;test&quot;]】\n[17:01:16.670] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :75  ] - 【入参日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.UserService】【public void org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(org.geekbang.time.commonmistakes.spring.demo2.UserEntity)】【http://localhost:45678/metricstest/transaction】 的参数是：【[{&quot;id&quot;:null,&quot;name&quot;:&quot;test&quot;}]】\n[17:01:16.885] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :86  ] - 【失败打点】调用 【class org.geekbang.time.commonmistakes.spring.demo2.UserService】【public void org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(org.geekbang.time.commonmistakes.spring.demo2.UserEntity)】【http://localhost:45678/metricstest/transaction】 失败，耗时：211 ms\n[17:01:16.899] [http-nio-45678-exec-1] [ERROR] [o.g.t.c.spring.demo2.MetricsAspect      :88  ] - 【异常日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.UserService】【public void org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(org.geekbang.time.commonmistakes.spring.demo2.UserEntity)】【http://localhost:45678/metricstest/transaction】 出现异常！\njava.lang.RuntimeException: invalid username!\n\tat org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(UserService.java:18)\n\tat org.geekbang.time.commonmistakes.spring.demo2.UserService$$FastClassBySpringCGLIB$$9eec91f.invoke(&lt;generated&gt;)\n[17:01:16.902] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :98  ] - 【出参日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.UserService】【public void org.geekbang.time.commonmistakes.spring.demo2.UserService.createUser(org.geekbang.time.commonmistakes.spring.demo2.UserEntity)】【http://localhost:45678/metricstest/transaction】 的返回是：【null】\n[17:01:17.466] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :83  ] - 【成功打点】调用 【class org.geekbang.time.commonmistakes.spring.demo2.MetricsController】【public int org.geekbang.time.commonmistakes.spring.demo2.MetricsController.transaction(java.lang.String)】【http://localhost:45678/metricstest/transaction】 成功，耗时：915 ms\n[17:01:17.467] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo2.MetricsAspect      :98  ] - 【出参日志】调用 【class org.geekbang.time.commonmistakes.spring.demo2.MetricsController】【public int org.geekbang.time.commonmistakes.spring.demo2.MetricsController.transaction(java.lang.String)】【http://localhost:45678/metricstest/transaction】 的返回是：【1】\n</code></pre><p>在介绍<a href=\"https://time.geekbang.org/column/article/213295\">数据库事务</a>时，我们分析了Spring通过TransactionAspectSupport类实现事务。在invokeWithinTransaction方法中设置断点可以发现，在执行Service的createUser方法时，TransactionAspectSupport并没有捕获到异常，所以自然无法回滚事务。原因就是，<strong>异常被MetricsAspect吃掉了</strong>。</p><p>我们知道，切面本身是一个Bean，Spring对不同切面增强的执行顺序是由Bean优先级决定的，具体规则是：</p><ul>\n<li>入操作（Around（连接点执行前）、Before），切面优先级越高，越先执行。一个切面的入操作执行完，才轮到下一切面，所有切面入操作执行完，才开始执行连接点（方法）。</li>\n<li>出操作（Around（连接点执行后）、After、AfterReturning、AfterThrowing），切面优先级越低，越先执行。一个切面的出操作执行完，才轮到下一切面，直到返回到调用点。</li>\n<li>同一切面的Around比After、Before先执行。</li>\n</ul><p>对于Bean可以通过@Order注解来设置优先级，查看@Order注解和Ordered接口源码可以发现，默认情况下Bean的优先级为最低优先级，其值是Integer的最大值。其实，<strong>值越大优先级反而越低，这点比较反直觉</strong>：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})\n@Documented\npublic @interface Order {\n\n   int value() default Ordered.LOWEST_PRECEDENCE;\n\n}\npublic interface Ordered {\n   int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;\n   int LOWEST_PRECEDENCE = Integer.MAX_VALUE;\n   int getOrder();\n}\n</code></pre><p>我们再通过一个例子，来理解下增强的执行顺序。新建一个TestAspectWithOrder10切面，通过@Order注解设置优先级为10，在内部定义@Before、@After、@Around三类增强，三个增强的逻辑只是简单的日志输出，切点是TestController所有方法；然后再定义一个类似的TestAspectWithOrder20切面，设置优先级为20：</p><pre><code>@Aspect\n@Component\n@Order(10)\n@Slf4j\npublic class TestAspectWithOrder10 {\n    @Before(&quot;execution(* org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController.*(..))&quot;)\n    public void before(JoinPoint joinPoint) throws Throwable {\n        log.info(&quot;TestAspectWithOrder10 @Before&quot;);\n    }\n    @After(&quot;execution(* org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController.*(..))&quot;)\n    public void after(JoinPoint joinPoint) throws Throwable {\n        log.info(&quot;TestAspectWithOrder10 @After&quot;);\n    }\n    @Around(&quot;execution(* org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController.*(..))&quot;)\n    public Object around(ProceedingJoinPoint pjp) throws Throwable {\n        log.info(&quot;TestAspectWithOrder10 @Around before&quot;);\n        Object o = pjp.proceed();\n        log.info(&quot;TestAspectWithOrder10 @Around after&quot;);\n        return o;\n    }\n}\n\n@Aspect\n@Component\n@Order(20)\n@Slf4j\npublic class TestAspectWithOrder20 {\n\t...\n}\n</code></pre><p>调用TestController的方法后，通过日志输出可以看到，增强执行顺序符合切面执行顺序的三个规则：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/3e/3c687829083abebe1d6e347f5766903e.png?wh=782*676\" alt=\"\"></p><p>因为Spring的事务管理也是基于AOP的，默认情况下优先级最低也就是会先执行出操作，但是自定义切面MetricsAspect也同样是最低优先级，这个时候就可能出现问题：如果出操作先执行捕获了异常，那么Spring的事务处理就会因为无法捕获到异常导致无法回滚事务。</p><p>解决方式是，明确MetricsAspect的优先级，可以设置为最高优先级，也就是最先执行入操作最后执行出操作：</p><pre><code>//将MetricsAspect这个Bean的优先级设置为最高\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class MetricsAspect {\n    ...\n}\n</code></pre><p>此外，<strong>我们要知道切入的连接点是方法，注解定义在类上是无法直接从方法上获取到注解的</strong>。修复方式是，改为优先从方法获取，如果获取不到再从类获取，如果还是获取不到再使用默认的注解：</p><pre><code>Metrics metrics = signature.getMethod().getAnnotation(Metrics.class);\nif (metrics == null) {\n    metrics = signature.getMethod().getDeclaringClass().getAnnotation(Metrics.class);\n}\n</code></pre><p>经过这2处修改，事务终于又可以回滚了，并且Controller的监控日志也不再出现入参、出参信息。</p><p>我再总结下这个案例。利用反射+注解+Spring AOP实现统一的横切日志关注点时，我们遇到的Spring事务失效问题，是由自定义的切面执行顺序引起的。这也让我们认识到，因为Spring内部大量利用IoC和AOP实现了各种组件，当使用IoC和AOP时，一定要考虑是否会影响其他内部组件。</p><h2>重点回顾</h2><p>今天，我通过2个案例和你分享了Spring IoC和AOP的基本概念，以及三个比较容易出错的点。</p><p>第一，让Spring容器管理对象，要考虑对象默认的Scope单例是否适合，对于有状态的类型，单例可能产生内存泄露问题。</p><p>第二，如果要为单例的Bean注入Prototype的Bean，绝不是仅仅修改Scope属性这么简单。由于单例的Bean在容器启动时就会完成一次性初始化。最简单的解决方案是，把Prototype的Bean设置为通过代理注入，也就是设置proxyMode属性为TARGET_CLASS。</p><p>第三，如果一组相同类型的Bean是有顺序的，需要明确使用@Order注解来设置顺序。你可以再回顾下，两个不同优先级切面中@Before、@After和@Around三种增强的执行顺序，是什么样的。</p><p>最后我要说的是，文内第二个案例是一个完整的统一日志监控案例，继续修改就可以实现一个完善的、生产级的方法调用监控平台。这些修改主要是两方面：把日志打点，改为对接Metrics监控系统；把各种功能的监控开关，从注解属性获取改为通过配置系统实时获取。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>除了通过@Autowired注入Bean外，还可以使用@Inject或@Resource来注入Bean。你知道这三种方式的区别是什么吗？</li>\n<li>当Bean产生循环依赖时，比如BeanA的构造方法依赖BeanB作为成员需要注入，BeanB也依赖BeanA，你觉得会出现什么问题呢？又有哪些解决方式呢？</li>\n</ol><p>在下一讲中，我会继续与你探讨Spring核心的其他问题。我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？","id":225596},"right":{"article_title":"20 | Spring框架：框架帮我们做了很多工作也带来了复杂度","id":227918}},"comments":[{"had_liked":false,"id":211216,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1587916396,"is_pvip":true,"replies":[{"id":"78536","content":"👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻","user_name":"作者回复","comment_id":211216,"uid":"1001470","ip_address":"","utype":1,"ctime":1587947647,"user_name_real":"朱晔"}],"discussion_count":6,"race_medal":0,"score":"9.2233724378747003e+18","product_id":100047701,"comment_content":"一、注解区别<br>@Autowired<br>\t1、@Autowired是spring自带的注解，通过‘AutowiredAnnotationBeanPostProcessor’ 类实现的依赖注入；<br>\t2、@Autowired是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Qualifier；<br>\t3、@Autowired有个属性为required，可以配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛错；<br>\t4、@Autowired可以作用在变量、setter方法、构造函数上。<br><br>@Inject<br>\t1、@Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject;实现注入。<br>\t2、@Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；<br>\t3、@Inject可以作用在变量、setter方法、构造函数上。<br><br>@Resource<br>\t1、@Resource是JSR250规范的实现，需要导入javax.annotation实现注入。<br>\t2、@Resource是根据名称进行自动装配的，一般会指定一个name属性<br>\t3、@Resource可以作用在变量、setter方法上。<br><br>总结：<br>1、@Autowired是spring自带的，@Inject是JSR330规范实现的，@Resource是JSR250规范实现的，需要导入不同的包<br>2、@Autowired、@Inject用法基本一样，不同的是@Autowired有一个request属性<br>3、@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的<br>4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Name一起使用<br><br><br>二：循环依赖：<br>直观解决方法时通过set方法去处理，背后的原理其实是缓存。<br>主要解决方式：使用三级缓存<br>singletonObjects： 一级缓存， Cache of singleton objects: bean name --&gt; bean instance<br>earlySingletonObjects： 二级缓存， Cache of early singleton objects: bean name --&gt; bean instance  提前曝光的BEAN缓存<br>singletonFactories： 三级缓存， Cache of singleton factories: bean name --&gt; ObjectFactory","like_count":94,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493221,"discussion_content":"👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587947647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555746,"discussion_content":"🚩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647056603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381923,"discussion_content":"多兰大佬牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625299436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2251446,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5a/b6/abf52ebe.jpg","nickname":"guanine🍀","note":"","ucode":"8AFDD724F77C99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320586,"discussion_content":"@Autowired默认byType，找到多个类型一样的再byName，我记得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604407169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2251446,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5a/b6/abf52ebe.jpg","nickname":"guanine🍀","note":"","ucode":"8AFDD724F77C99","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379406,"discussion_content":"相同类型找到多个，会报错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623889971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320586,"ip_address":""},"score":379406,"extra":""}]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294562,"discussion_content":"课代表������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595928791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210633,"user_name":"Husiun","can_delete":false,"product_type":"c1","uid":1448664,"ip_address":"","ucode":"F783484743BFE4","user_header":"https://static001.geekbang.org/account/avatar/00/16/1a/d8/9ae1bdb9.jpg","comment_is_top":false,"comment_ctime":1587800117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70307276853","product_id":100047701,"comment_content":"问题2，循环依赖会抛出异常BeanCurrentlyInCreationException，官网的解决方案是由构造器注入改为setter注入","like_count":17},{"had_liked":false,"id":210571,"user_name":"norman","can_delete":false,"product_type":"c1","uid":1148747,"ip_address":"","ucode":"BEE517AEFB159F","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/4b/7f90f912.jpg","comment_is_top":false,"comment_ctime":1587788553,"is_pvip":false,"replies":[{"id":"78438","content":"👍🏻，也可以参考 https:&#47;&#47;stackoverflow.com&#47;questions&#47;20450902&#47;inject-and-resource-and-autowired-annotations 这里的回复","user_name":"作者回复","comment_id":210571,"uid":"1001470","ip_address":"","utype":1,"ctime":1587815381,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"31652559625","product_id":100047701,"comment_content":"@Resource 和 @Autowired @Inject 三者区别：<br>1 @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。<br>2 @Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合@Qualifier。这个注释是Spring特有的。<br>3 @Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493057,"discussion_content":"👍🏻，也可以参考 https://stackoverflow.com/questions/20450902/inject-and-resource-and-autowired-annotations 这里的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587815381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211134,"user_name":"左琪","can_delete":false,"product_type":"c1","uid":1468773,"ip_address":"","ucode":"6B797070168A12","user_header":"https://static001.geekbang.org/account/avatar/00/16/69/65/eb778125.jpg","comment_is_top":false,"comment_ctime":1587900387,"is_pvip":false,"replies":[{"id":"78525","content":"代理类会来判断是否需要创建新的对象","user_name":"作者回复","comment_id":211134,"uid":"1001470","ip_address":"","utype":1,"ctime":1587907326,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"27357704163","product_id":100047701,"comment_content":"这里的代理类不是单例么，还是说会在增强逻辑里不断创建被代理类？","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493205,"discussion_content":"代理类会来判断是否需要创建新的对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587907326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264036,"user_name":"和海明威下棋","can_delete":false,"product_type":"c1","uid":1400363,"ip_address":"","ucode":"567BA8167971A5","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/2b/1c158008.jpg","comment_is_top":false,"comment_ctime":1606316993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23081153473","product_id":100047701,"comment_content":"&#47;&#47;@annotation指示器实现对标记了Metrics注解的方法进行匹配<br>   @Pointcut(&quot;within(@org.geekbang.time.commonmistakes.springpart1.aopmetrics.Metrics *)&quot;<br><br>这里是不是有笔误？我试了下within无法拦截方法的注解，换成@annotation就可以了","like_count":6},{"had_liked":false,"id":214281,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1588693567,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18768562751","product_id":100047701,"comment_content":"很干货的文章，收获满满。<br>使用AOP时确实要注意执行顺序。A_Around-before -&gt; A_Before -&gt; B_Around-before -&gt; B_Before -&gt; B_Around-after -&gt; B_After -&gt; A_Around-after -&gt; A_After<br><br>课后答疑：<br>关于循环依赖，在单例模式下，Spring采用缓存提前暴露后初始化的方式进行解决。但是生产上出现过一次问题，当使用了@Repository注解时，循环依赖是解不了的。SpringBoot中对@Repository做了特殊处理。","like_count":4,"discussions":[{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381926,"discussion_content":"为什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625299881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210544,"user_name":"W","can_delete":false,"product_type":"c1","uid":1921315,"ip_address":"","ucode":"9434684DE2EFFB","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/23/36bc8745.jpg","comment_is_top":false,"comment_ctime":1587786616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18767655800","product_id":100047701,"comment_content":"MetricsAspect 这个类里面的小技巧学到了","like_count":5},{"had_liked":false,"id":241701,"user_name":"OneDy","can_delete":false,"product_type":"c1","uid":1160082,"ip_address":"","ucode":"BF0705E486994F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/92/6a20da3f.jpg","comment_is_top":false,"comment_ctime":1597393836,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14482295724","product_id":100047701,"comment_content":"关于循环依赖的解决，看到了三种处理方式：<br>1.使用@Lazy 对其中一个bean懒加载<br>2. 使用setter属性注入，而并不是构造器注入<br>3. 使用@PostConstruct在依赖注入后执行初始化<br>具体可以参考：https:&#47;&#47;www.baeldung.com&#47;circular-dependencies-in-spring","like_count":3},{"had_liked":false,"id":210682,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1587806767,"is_pvip":false,"replies":[{"id":"78431","content":"不错","user_name":"作者回复","comment_id":210682,"uid":"1001470","ip_address":"","utype":1,"ctime":1587809070,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"14472708655","product_id":100047701,"comment_content":"连接点: 程序执行过程中能够应用通知的所有点；通知（增强）: 即切面的工作，定义了What以及When；切点定义了Where，通知被应用的具体位置（哪些连接点）<br>----Spring实战（第4版）","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493085,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587809070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210711,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1587813688,"is_pvip":false,"replies":[{"id":"78439","content":"只是为了模拟SayService是有状态","user_name":"作者回复","comment_id":210711,"uid":"1001470","ip_address":"","utype":1,"ctime":1587815436,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10177748280","product_id":100047701,"comment_content":"老师，请教一下，那个sayservice里的data有啥用，那个单例是为了一种重复使用data对吧，那换成每次都生成一个新的bean，那个data还有效果吗。。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493091,"discussion_content":"只是为了模拟SayService是有状态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587815436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245498,"user_name":"龙行秀","can_delete":false,"product_type":"c1","uid":1351066,"ip_address":"","ucode":"2DA088D199EA9D","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/9a/7f064a9f.jpg","comment_is_top":false,"comment_ctime":1598960697,"is_pvip":false,"replies":[{"id":"90345","content":"容器维护了这个单例，回收不了","user_name":"作者回复","comment_id":245498,"uid":"1001470","ip_address":"","utype":1,"ctime":1599019413,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"5893927993","product_id":100047701,"comment_content":"“架构师一开始定义了这么一个 SayService 抽象类，其中维护了一个类型是 ArrayList 的字段 data，用于保存方法处理的中间数据。每次调用 say 方法都会往 data 加入新数据，可以认为 SayService 是有状态，如果 SayService 是单例的话必然会 OOM”<br>-----为什么单例就会OOM，多例就不会呢？没看懂","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504901,"discussion_content":"容器维护了这个单例，回收不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599019413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1879320,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ad/18/6e641cc8.jpg","nickname":"Simon","note":"","ucode":"81580164480ADC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571373,"discussion_content":"是不是可以这样理解： 因为是单例，大家都在往这个单例的对象中的data塞数据，量大的话就OOM；而多例情况下，每人往自己对象中的data塞数据，所以没出现OOM。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652187963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":504901,"ip_address":""},"score":571373,"extra":""}]},{"author":{"id":1256314,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/xOSB7nvK0BCPPDfYupD5gAPjNLWtGt1WAJqFNWlcnz1SajF18W13Pp069MlXy2slWARryqianwexetHjZKWvsXg/132","nickname":"爱蛇","note":"","ucode":"195D000CE20E3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302652,"discussion_content":"跟你一样，我没看到问题是什么.即使单例还是多例，每调用一次super.say就会增加一次长度，这不也会oom吗？不明白为什么老师弄完以后，两个子类调用super.say方法都只增加1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598986122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224878,"user_name":"Carisy","can_delete":false,"product_type":"c1","uid":1657429,"ip_address":"","ucode":"67E887967347BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwTZdUafC5YM7bCASt8icUnoyYfV4hUHulexibDI7B4eaokTxYXHFtoic97DBlCAU9j5Jw4QUuGhyZQ/132","comment_is_top":false,"comment_ctime":1591582267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886549563","product_id":100047701,"comment_content":"针对楼上做些补充说明：<br>1、@Resource 注解是通过CommonAnnotationBeanPostProcessor处理的，并且@Resource注解并不是“先去按名字找，找不到再按类型”而是&quot;根据类型筛选，筛选出的所有的bean根据名字获取&quot;<br>2、循环依赖可以通过@Lazy注解","like_count":2},{"had_liked":false,"id":216105,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1589190660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884157956","product_id":100047701,"comment_content":"项目也写过类似的日志打点切面,学到了一些小技巧，看后续加到项目里面","like_count":1},{"had_liked":false,"id":212863,"user_name":"David Mo","can_delete":false,"product_type":"c1","uid":1083504,"ip_address":"","ucode":"66C30A3CD7EDA6","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/70/32534e2d.jpg","comment_is_top":false,"comment_ctime":1588228215,"is_pvip":false,"replies":[{"id":"79058","content":"好吧","user_name":"作者回复","comment_id":212863,"uid":"1001470","ip_address":"","utype":1,"ctime":1588242197,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5883195511","product_id":100047701,"comment_content":"@sevice 的坑踩过，代理类一开始不行白，后来说动态创建就懂了。当时是用一个类似工厂类解决的","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493632,"discussion_content":"好吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588242197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212799,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1588212994,"is_pvip":false,"replies":[{"id":"79047","content":"不客气","user_name":"作者回复","comment_id":212799,"uid":"1001470","ip_address":"","utype":1,"ctime":1588227274,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5883180290","product_id":100047701,"comment_content":"很有收获谢谢老师","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493613,"discussion_content":"不客气","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588227274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308588,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1656956,"ip_address":"","ucode":"3A0940EBF94577","user_header":"https://static001.geekbang.org/account/avatar/00/19/48/7c/2aaf50e5.jpg","comment_is_top":false,"comment_ctime":1629692124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629692124","product_id":100047701,"comment_content":"干货太多了，老师太强了","like_count":0},{"had_liked":false,"id":272041,"user_name":"Devil May Cry","can_delete":false,"product_type":"c1","uid":2396435,"ip_address":"","ucode":"F06B99B71AA25D","user_header":"https://static001.geekbang.org/account/avatar/00/24/91/13/009f6a74.jpg","comment_is_top":false,"comment_ctime":1609916785,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1609916785","product_id":100047701,"comment_content":"没理解有状态是什么意思,老师可以解答一下吗","like_count":0,"discussions":[{"author":{"id":1242455,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","nickname":"天天向上","note":"","ucode":"0CCCA6F4DCC480","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340762,"discussion_content":"可以理解为，状态就是下次请求能保留上次请求的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610121266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253631,"user_name":"小学生","can_delete":false,"product_type":"c1","uid":1166994,"ip_address":"","ucode":"6EF88756389547","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/92/f53c41ee.jpg","comment_is_top":false,"comment_ctime":1602815939,"is_pvip":false,"replies":[{"id":"92649","content":"哪里不对？","user_name":"作者回复","comment_id":253631,"uid":"1001470","ip_address":"","utype":1,"ctime":1602835171,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"1602815939","product_id":100047701,"comment_content":"老师，您好，您讲 的切面执行顺序好像不对啊，我的执行顺序和你说的不一致！<br>[10:34:11.367] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder10:31  ] - TestAspectWithOrder10 @Around before<br>[10:34:11.377] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder10:21  ] - TestAspectWithOrder10 @Before<br>[10:34:11.377] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder20:31  ] - TestAspectWithOrder20 @Around before<br>[10:34:11.378] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder20:21  ] - TestAspectWithOrder20 @Before<br>[10:34:11.379] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.aopmetrics.MetricsAspect:79  ] - 【入参日志】调用 【class org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController】【public void org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController.test()】【http:&#47;&#47;localhost:45678&#47;test】 的参数是：【[]】<br>[10:34:11.379] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.aopmetrics.MetricsAspect:88  ] - 【成功打点】调用 【class org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController】【public void org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController.test()】【http:&#47;&#47;localhost:45678&#47;test】 成功，耗时：0 ms<br>[10:34:11.379] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.aopmetrics.MetricsAspect:107 ] - 【出参日志】调用 【class org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController】【public void org.geekbang.time.commonmistakes.springpart1.aopmetrics.TestController.test()】【http:&#47;&#47;localhost:45678&#47;test】 的返回是：【null】<br>[10:34:11.380] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder20:26  ] - TestAspectWithOrder20 @After<br>[10:34:11.380] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder20:33  ] - TestAspectWithOrder20 @Around after<br>[10:34:11.380] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder10:26  ] - TestAspectWithOrder10 @After<br>[10:34:11.380] [http-nio-45678-exec-4] [INFO ] [o.g.t.c.s.a.TestAspectWithOrder10:33  ] - TestAspectWithOrder10 @Around after<br>","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507131,"discussion_content":"哪里不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602835171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1327997,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/YqF3S64vHV7cuGIQLczgj4hgOxZlHEN7X48nIShQIiaN1cU4VsE9ia4VVmTibVKzMfRG7ibgibKOPJfA5S1SrYZNDyA/132","nickname":"InfoQ_aae1c4db19b4","note":"","ucode":"481665EAB720F5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590757,"discussion_content":"版本问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666064125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474579,"avatar":"https://static001.geekbang.org/account/avatar/00/16/80/13/df2a0ced.jpg","nickname":"郑思雨","note":"","ucode":"F1F4B08FC94E7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318559,"discussion_content":"我运行了一下代码，和老师的打印顺序是一样的，先执行 @Around after ，后执行的@After","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603780821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250025,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1600910216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600910216","product_id":100047701,"comment_content":"有一个需求，A依赖B中的某个属性，这个属性会通过配置中心变更进来，但是怎么可以做到当B的这个属性初始化完成了，才会对A初始化呢，现在通过注入方式，可能A初始化时用到的B属性是个空值","like_count":1},{"had_liked":false,"id":237123,"user_name":"xuyd","can_delete":false,"product_type":"c1","uid":1050847,"ip_address":"","ucode":"62E1E7D5201E89","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/df/866ed645.jpg","comment_is_top":false,"comment_ctime":1595683793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595683793","product_id":100047701,"comment_content":"直接在Metrics里边把异常跑出来可以嘛","like_count":0},{"had_liked":false,"id":232317,"user_name":"libocz","can_delete":false,"product_type":"c1","uid":1227392,"ip_address":"","ucode":"9DC917019EB2CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/ba/80/2b427c9c.jpg","comment_is_top":false,"comment_ctime":1593954901,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1593954901","product_id":100047701,"comment_content":"看不懂为什么Controller换成用@Metrics注解后就会与spring的事务发生顺序问题，而不用@Metrics去注解Controller的时候，能与spring的事务正确运行","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299400,"discussion_content":"你还没看懂，这和Controller的@Metrics无关，而是和UserService中的注解@Transactional和@Metrics(ignoreException=true)有关，这两个注解对应切面有顺序问题，原本事务切面优先级最低，但自定义的这个切面也是最低的，如果先执行Metrics切面并且异常被他吞掉，事务切面再执行的时候就捕获不到异常无法回滚，@Metrics默认是不捕获异常所以没有问题但如果标记@Metrics(ignoreException=true)时切面就会吃掉异常，解决办法就是把Metrics切面优先级调高，让其出操作在事务切面之后执行就好了","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1597673304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1227392,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ba/80/2b427c9c.jpg","nickname":"libocz","note":"","ucode":"9DC917019EB2CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302108,"discussion_content":"感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598792108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299400,"ip_address":""},"score":302108,"extra":""}]}]},{"had_liked":false,"id":226153,"user_name":"track6688","can_delete":false,"product_type":"c1","uid":1088040,"ip_address":"","ucode":"0A9E893F8FD379","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/28/03613c22.jpg","comment_is_top":false,"comment_ctime":1591964413,"is_pvip":false,"replies":[{"id":"83303","content":"意思是ExposeInvocationInterceptor需要在前面执行，最新的ExposeInvocationInterceptor已经是PriorityOrdered了，你是不是老版本的Spring？把自己的类优先级调低点","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591970276,"ip_address":"","comment_id":226153,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591964413","product_id":100047701,"comment_content":"老师，请教一个问题，我使用这个注解，@Order(Ordered.HIGHEST_PRECEDENCE)，使用@AfterThrowing这个时，报No MethodInvocation found: Check that an AOP invocation is in progress, and that the ExposeInvocationInterceptor is upfront in the interceptor chain. Specifically, note that advices with order HIGHEST_PRECEDENCE will execute before ExposeInvocationInterceptor!，怎么处理呢？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498125,"discussion_content":"意思是ExposeInvocationInterceptor需要在前面执行，最新的ExposeInvocationInterceptor已经是PriorityOrdered了，你是不是老版本的Spring？把自己的类优先级调低点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591970276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217777,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1589611318,"is_pvip":false,"replies":[{"id":"80549","content":"这不会，会编译为<br>final class MetricsAspect$1c {<br>    MetricsAspect$1c(MetricsAspect this$0) {<br>        this.this$0 = this$0;<br>    }<br>}","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589629617,"ip_address":"","comment_id":217777,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589611318","product_id":100047701,"comment_content":"感觉Spring Intercepter的执行顺序和Servlet Filter的执行过程是一样的，一个递归调用栈。<br>有个疑问想请老师解答一下。采用创建内部类的方式获取默认注解配置，这样不会每调用一次就会在元空间中生成一个c的Class信息吗？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495259,"discussion_content":"这不会，会编译为\nfinal class MetricsAspect$1c {\n    MetricsAspect$1c(MetricsAspect this$0) {\n        this.this$0 = this$0;\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589629617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}