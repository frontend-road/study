{"id":476717,"title":"37｜前端路由原理：vue-router源码剖析","content":"<p>你好，我是大圣。</p><p>上一讲我们学习了下一代Vuex框架Pinia的原理，今天我来带你分析Vue生态中另外一个重要的框架vue-router的源码。</p><p>课程中我们也实现过一个迷你的router，我们通过监听路由的变化，把路由数据包裹成响应式对象后，一旦路由发生变化，我们就去定义好的路由数据中查询当前路由对应的组件，在router-view中渲染即可。今天我们就进入到vue-router源码的内部，看一下实际的vue-router和我们实现的迷你版本有什么区别。</p><h2>vue-router入口分析</h2><p>vue-router提供了createRouter方法来创建路由配置，我们传入每个路由地址对应的组件后，使用app.use在Vue中加载vue-router插件，并且给Vue注册了两个内置组件，router-view负责渲染当前路由匹配的组件，router-link负责页面的跳转。</p><p><strong>我们先来看下createRouter如何实现</strong>，完整的代码你可以在<a href=\"https://github.com/vuejs/vue-router-next/blob/master/src/router.ts#L355\">GitHub</a>上看到。这个函数比较长，还好我们有TypeScript，我们先看下createRouter的参数。</p><p>在下面的代码中，参数RouterOptions是规范我们配置的路由对象，主要包含history、routes等数据。routes就是我们需要配置的路由对象，类型是RouteRecordRaw组成的数组，并且RouteRecordRaw的类型是三个类型的合并。然后返回值的类型Router就是包含了addRoute、push、beforeEnter、install方法的一个对象，<strong>并且维护了currentRoute和options两个属性</strong>。</p><!-- [[[read_end]]] --><p>并且每个类型方法还有详细的注释，这也极大降低了阅读源码的门槛，可以帮助我们在看到函数的类型时就知道函数大概的功能。我们知道Vue中app.use实际上执行的就是router对象内部的install方法，我们先进入到install方法看下是如何安装的。</p><pre><code class=\"language-javascript\">// createRouter传递参数的类型\nexport interface RouterOptions extends PathParserOptions {\n  history: RouterHistory\n  routes: RouteRecordRaw[]\n  scrollBehavior?: RouterScrollBehavior\n  ...\n}\n// 每个路由配置的类型\nexport type RouteRecordRaw =\n  | RouteRecordSingleView\n  | RouteRecordMultipleViews\n  | RouteRecordRedirect\n\n//... other config\n// Router接口的全部方法和属性\nexport interface Router {\n  readonly currentRoute: Ref&lt;RouteLocationNormalizedLoaded&gt;\n  readonly options: RouterOptions\n\n  addRoute(parentName: RouteRecordName, route: RouteRecordRaw): () =&gt; void\n  addRoute(route: RouteRecordRaw): () =&gt; void\n  Route(name: RouteRecordName): void\n  hasRoute(name: RouteRecordName): boolean\n\n  getRoutes(): RouteRecord[]\n  resolve(\n    to: RouteLocationRaw,\n    currentLocation?: RouteLocationNormalizedLoaded\n  ): RouteLocation &amp; { href: string }\n  push(to: RouteLocationRaw): Promise&lt;NavigationFailure | void | undefined&gt;\n  replace(to: RouteLocationRaw): Promise&lt;NavigationFailure | void | undefined&gt;\n  back(): ReturnType&lt;Router['go']&gt;\n  forward(): ReturnType&lt;Router['go']&gt;\n  go(delta: number): void\n  beforeEach(guard: NavigationGuardWithThis&lt;undefined&gt;): () =&gt; void\n  beforeResolve(guard: NavigationGuardWithThis&lt;undefined&gt;): () =&gt; void\n  afterEach(guard: NavigationHookAfter): () =&gt; void\n  onError(handler: _ErrorHandler): () =&gt; void\n  isReady(): Promise&lt;void&gt;\n  install(app: App): void\n}\n\n\n\n\n\nexport function createRouter(options: RouterOptions): Router {\n\n\n\n}\n</code></pre><h2>路由安装</h2><p>从下面的代码中我们可以看到，在createRouter的最后，创建了包含addRoute、push等方法的对象，并且install方法内部注册了RouterLink和RouterView两个组件。所以我们可以在任何组件内部直接使用&lt;router-view&gt;和&lt;router-link&gt;组件，然后注册全局变量$router和$route，其中$router就是我们通过createRouter返回的路由对象，包含addRoute、push等方法，$route使用defineProperty的形式返回currentRoute的值，可以做到和currentRoute值同步。</p><p>然后使用computed把路由变成响应式对象，存储在reactiveRoute对象中，再通过app.provide给全局注册了route和reactive包裹后的reactiveRoute对象。我们之前介绍provide函数的时候也介绍了，provide提供的数据并没有做响应式的封装，<strong>需要响应式的时候需要自己使用ref或者reactive封装为响应式对象</strong>，最后注册unmount方法实现vue-router的安装。</p><pre><code class=\"language-javascript\">export function createRouter(options: RouterOptions): Router {\n....\n  let started: boolean | undefined\n  const installedApps = new Set&lt;App&gt;()\n  // 路由对象\n  const router: Router = {\n    currentRoute,\n\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n\n    push,\n    replace,\n    go,\n    back: () =&gt; go(-1),\n    forward: () =&gt; go(1),\n\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n\n    onError: errorHandlers.add,\n    isReady,\n    // 插件按章\n    install(app: App) {\n      const router = this\n      // 注册全局组件 router-link和router-view\n      app.component('RouterLink', RouterLink)\n      app.component('RouterView', RouterView)\n\n      app.config.globalProperties.$router = router\n      Object.defineProperty(app.config.globalProperties, '$route', {\n        enumerable: true,\n        get: () =&gt; unref(currentRoute),\n      })\n      if (\n        isBrowser &amp;&amp;\n        !started &amp;&amp;\n        currentRoute.value === START_LOCATION_NORMALIZED\n      ) {\n        // see above\n        started = true\n        push(routerHistory.location).catch(err =&gt; {\n          if (__DEV__) warn('Unexpected error when starting the router:', err)\n        })\n      }\n\n      const reactiveRoute = {} as {\n        [k in keyof RouteLocationNormalizedLoaded]: ComputedRef&lt;\n          RouteLocationNormalizedLoaded[k]\n        &gt;\n      }\n      for (const key in START_LOCATION_NORMALIZED) {\n        // @ts-expect-error: the key matches\n        reactiveRoute[key] = computed(() =&gt; currentRoute.value[key])\n      }\n      // 提供全局配置\n      app.provide(routerKey, router)\n      app.provide(routeLocationKey, reactive(reactiveRoute))\n      app.provide(routerViewLocationKey, currentRoute)\n\n      const unmountApp = app.unmount\n      installedApps.add(app)\n      app.unmount = function () {\n        installedApps.delete(app)\n        // ...\n        unmountApp()\n      }\n\n      if ((__DEV__ || __FEATURE_PROD_DEVTOOLS__) &amp;&amp; isBrowser) {\n        addDevtools(app, router, matcher)\n      }\n    },\n  }\n\n  return router\n}\n</code></pre><p>路由对象创建和安装之后，我们<strong>下一步需要了解的就是router-link和router-view两个组件的实现方式</strong>。</p><p>通过下面的代码我们可以看到，RouterView的setup函数返回了一个函数，这个函数就是RouterView组件的render函数。大部分我们使用的方式就是一个&lt;router-view /&gt;组件，没有slot情况下返回的就是component变量。component使用h函数返回ViewComponent的虚拟DOM，而ViewComponent是根据matchedRoute.components[props.name]计算而来。</p><p>matchedRoute依赖的matchedRouteRef的计算逻辑在如下代码的第12～15行，数据来源injectedRoute就是上面我们注入的currentRoute对象。</p><pre><code class=\"language-javascript\">export const RouterViewImpl = /*#__PURE__*/ defineComponent({\n  name: 'RouterView',\n  props: {\n    name: {\n      type: String as PropType&lt;string&gt;,\n      default: 'default',\n    },\n    route: Object as PropType&lt;RouteLocationNormalizedLoaded&gt;,\n  },\n  // router-view组件源码\n  setup(props, { attrs, slots }) {\n    // 全局的reactiveRoute对象注入\n    const injectedRoute = inject(routerViewLocationKey)!\n    \n    const routeToDisplay = computed(() =&gt; props.route || injectedRoute.value)\n    const depth = inject(viewDepthKey, 0)\n    const matchedRouteRef = computed&lt;RouteLocationMatched | undefined&gt;(\n      () =&gt; routeToDisplay.value.matched[depth]\n    )\n    // 嵌套层级\n    provide(viewDepthKey, depth + 1)\n    // 匹配的router对象\n    provide(matchedRouteKey, matchedRouteRef)\n    provide(routerViewLocationKey, routeToDisplay)\n\n    const viewRef = ref&lt;ComponentPublicInstance&gt;()\n    // 返回的render函数\n    return () =&gt; {\n      const route = routeToDisplay.value\n      const matchedRoute = matchedRouteRef.value\n      const ViewComponent = matchedRoute &amp;&amp; matchedRoute.components[props.name]\n      const currentName = props.name\n\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, { Component: ViewComponent, route })\n      }\n\n      // props from route configuration\n      const routePropsOption = matchedRoute!.props[props.name]\n      const routeProps = routePropsOption\n        ? routePropsOption === true\n          ? route.params\n          : typeof routePropsOption === 'function'\n          ? routePropsOption(route)\n          : routePropsOption\n        : null\n\n      const onVnodeUnmounted: VNodeProps['onVnodeUnmounted'] = vnode =&gt; {\n        // remove the instance reference to prevent leak\n        if (vnode.component!.isUnmounted) {\n          matchedRoute!.instances[currentName] = null\n        }\n      }\n      // 创建需要渲染组件的虚拟dom\n      const component = h(\n        ViewComponent,\n        assign({}, routeProps, attrs, {\n          onVnodeUnmounted,\n          ref: viewRef,\n        })\n      )\n  \n      return (\n        // pass the vnode to the slot as a prop.\n        // h and &lt;component :is=\"...\"&gt; both accept vnodes\n        normalizeSlot(slots.default, { Component: component, route }) ||\n        component\n      )\n    }\n  },\n})\n</code></pre><h2>路由更新</h2><p>到这我们可以看出，RouterView渲染的组件是由当前匹配的路由变量matchedRoute决定的。接下来我们回到createRouter函数中，可以看到matcher对象是由createRouterMatcher创建，createRouterMatcher函数传入routes配置的路由数组，并且返回创建的RouterMatcher对象，内部遍历routes数组，通过addRoute挨个处理路由配置。</p><pre><code class=\"language-javascript\">export function createRouter(options: RouterOptions): Router {\n  const matcher = createRouterMatcher(options.routes, options)\n  ///....\n}\nexport function createRouterMatcher(\n  routes: RouteRecordRaw[],\n  globalOptions: PathParserOptions\n): RouterMatcher {\n  // matchers数组\n  const matchers: RouteRecordMatcher[] = []\n  // matcher对象\n  const matcherMap = new Map&lt;RouteRecordName, RouteRecordMatcher&gt;()\n  globalOptions = mergeOptions(\n    { strict: false, end: true, sensitive: false } as PathParserOptions,\n    globalOptions\n  )\n  function addRoute(){}\n  function remoteRoute(){}\n  function getRoutes(){\n    return matchers\n  }  \n  function insertMatcher(){}\n  function resolve(){}\n  // add initial routes\n  routes.forEach(route =&gt; addRoute(route))\n\n  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher }\n}\n</code></pre><p>在下面的代码中我们可以看到，addRoute函数内部通过createRouteRecordMatcher创建扩展之后的matcher对象，包括了record、parent、children等树形，可以很好地描述路由之间的嵌套父子关系。这样整个路由对象就已经创建完毕，那我们如何在路由切换的时候寻找到正确的路由对象呢？</p><pre><code class=\"language-javascript\">function addRoute(    \n  record: RouteRecordRaw,\n  parent?: RouteRecordMatcher,\n  originalRecord?: RouteRecordMatcher\n){\n  if ('alias' in record) {\n    // 标准化alias\n  }\n  for (const normalizedRecord of normalizedRecords) {\n    // ...\n    matcher = createRouteRecordMatcher(normalizedRecord, parent, options)\n    insertMatcher(matcher)\n      \n  }\n  return originalMatcher\n    ? () =&gt; {\n        // since other matchers are aliases, they should be removed by the original matcher\n        removeRoute(originalMatcher!)\n      }\n    : noop\n\n}\n\nexport function createRouteRecordMatcher(\n  record: Readonly&lt;RouteRecord&gt;,\n  parent: RouteRecordMatcher | undefined,\n  options?: PathParserOptions\n): RouteRecordMatcher {\n  const parser = tokensToParser(tokenizePath(record.path), options)\n  const matcher: RouteRecordMatcher = assign(parser, {\n    record,\n    parent,\n    // these needs to be populated by the parent\n    children: [],\n    alias: [],\n  })\n\n  if (parent) {\n    if (!matcher.record.aliasOf === !parent.record.aliasOf)\n      parent.children.push(matcher)\n  }\n\n  return matcher\n}\n\n</code></pre><p>在vue-router中，路由更新可以通过router-link渲染的链接实现，也可以使用router对象的push等方法实现。下面的代码中，router-link组件内部也是渲染一个a标签，并且注册了a标签的onClick函数，内部也是通过router.replace或者router.push来实现。</p><pre><code class=\"language-javascript\">\nexport const RouterLinkImpl = /*#__PURE__*/ defineComponent({\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: [String, Object] as PropType&lt;RouteLocationRaw&gt;,\n      required: true,\n    },\n      ...\n  },\n  // router-link源码\n  setup(props, { slots }) {\n    const link = reactive(useLink(props))\n    const { options } = inject(routerKey)!\n\n    const elClass = computed(() =&gt; ({\n      ...\n    }))\n\n    return () =&gt; {\n      const children = slots.default &amp;&amp; slots.default(link)\n      return props.custom\n        ? children\n        : h(\n            'a',\n            {\n              href: link.href,\n              onClick: link.navigate,\n              class: elClass.value,\n            },\n            children\n          )\n    }\n  },\n})\n//  跳转\n  function navigate(\n    e: MouseEvent = {} as MouseEvent\n  ): Promise&lt;void | NavigationFailure&gt; {\n    if (guardEvent(e)) {\n      return router[unref(props.replace) ? 'replace' : 'push'](\n        unref(props.to)\n        // avoid uncaught errors are they are logged anyway\n      ).catch(noop)\n    }\n    return Promise.resolve()\n  }\n\n</code></pre><p>现在我们回到createRouter函数中，可以看到push函数直接调用了pushWithRedirect函数来实现，内部通过resolve(to)生成targetLocation变量。这个变量会赋值给toLocation，然后执行navigate(toLocation)函数。而<strong>这个函数内部会执行一系列的导航守卫函数</strong>，最后会执行finalizeNavigation函数完成导航。</p><pre><code class=\"language-javascript\">function push(to: RouteLocationRaw | RouteLocation) {\n  return pushWithRedirect(to)\n}\n\nfunction replace(to: RouteLocationRaw | RouteLocationNormalized) {\n  return push(assign(locationAsObject(to), { replace: true }))\n}\n// 路由跳转函数\nfunction pushWithRedirect(\n  to: RouteLocationRaw | RouteLocation,\n  redirectedFrom?: RouteLocation\n): Promise&lt;NavigationFailure | void | undefined&gt; {\n  const targetLocation: RouteLocation = (pendingLocation = resolve(to))\n  const from = currentRoute.value\n  const data: HistoryState | undefined = (to as RouteLocationOptions).state\n  const force: boolean | undefined = (to as RouteLocationOptions).force\n  // to could be a string where `replace` is a function\n  const replace = (to as RouteLocationOptions).replace === true\n\n\n\n  const toLocation = targetLocation as RouteLocationNormalized\n\n  \n  return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\n    .catch((error: NavigationFailure | NavigationRedirectError) =&gt;\n      isNavigationFailure(error)\n        ? error\n        : // reject any unknown error\n          triggerError(error, toLocation, from)\n    )\n    .then((failure: NavigationFailure | NavigationRedirectError | void) =&gt; {\n\n        failure = finalizeNavigation(\n          toLocation as RouteLocationNormalizedLoaded,\n          from,\n          true,\n          replace,\n          data\n        )\n\n      triggerAfterEach(\n        toLocation as RouteLocationNormalizedLoaded,\n        from,\n        failure\n      )\n      return failure\n    })\n}\n</code></pre><p>在下面的代码中我们可以看到，finalizeNavigation函数内部通过routerHistory.push或者replace实现路由跳转，并且更新currentRoute.value。</p><p>currentRoute就是我们在install方法中注册的全局变量$route，每次页面跳转currentRoute都会更新为toLocation，在任意组件中都可以通过$route变量来获取当前路由的数据，<strong>最后在handleScroll设置滚动行为</strong>。</p><p>routerHistory在createRouter中通过option.history获取，就是我们创建vue-router应用时通过createWebHistory或者createWebHashHistory创建的对象。createWebHistory返回的是HTML5的history模式路由对象，createWebHashHistory是Hash模式的路由对象。</p><pre><code class=\"language-javascript\">  function finalizeNavigation(\n    toLocation: RouteLocationNormalizedLoaded,\n    from: RouteLocationNormalizedLoaded,\n    isPush: boolean,\n    replace?: boolean,\n    data?: HistoryState\n  ): NavigationFailure | void {\n\n\n\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED\n    const state = !isBrowser ? {} : history.state\n\n    if (isPush) {\n\n      if (replace || isFirstNavigation)\n        routerHistory.replace(\n          toLocation.fullPath\n        )\n      else routerHistory.push(toLocation.fullPath, data)\n    }\n\n    // accept current navigation\n    currentRoute.value = toLocation\n    handleScroll(toLocation, from, isPush, isFirstNavigation)\n\n    markAsReady()\n  }\n  \n  function markAsReady(err?: any): void {\n    if (ready) return\n    ready = true\n    setupListeners()\n    readyHandlers\n      .list()\n      .forEach(([resolve, reject]) =&gt; (err ? reject(err) : resolve()))\n    readyHandlers.reset()\n  }\n</code></pre><p>下面的代码中我们可以看到，createWebHashHistory和createWebHistory的实现，内部都是通过useHistoryListeners实现路由的监听，通过useHistoryStateNavigation实现路由的切换。useHistoryStateNavigation会返回push或者replace方法来更新路由，这两个函数你可以在<a href=\"https://github.com/vuejs/vue-router-next/blob/master/src/history/html5.ts#L57\">GitHub</a>上自行学习。</p><pre><code class=\"language-javascript\">export function createWebHashHistory(base?: string): RouterHistory {\n  base = location.host ? base || location.pathname + location.search : ''\n  // allow the user to provide a `#` in the middle: `/base/#/app`\n  if (!base.includes('#')) base += '#'\n  return createWebHistory(base)\n}\n\n\n\nexport function createWebHistory(base?: string): RouterHistory {\n  base = normalizeBase(base)\n\n  const historyNavigation = useHistoryStateNavigation(base)\n  const historyListeners = useHistoryListeners(\n    base,\n    historyNavigation.state,\n    historyNavigation.location,\n    historyNavigation.replace\n  )\n  function go(delta: number, triggerListeners = true) {\n    if (!triggerListeners) historyListeners.pauseListeners()\n    history.go(delta)\n  }\n\n  const routerHistory: RouterHistory = assign(\n    {\n      // it's overridden right after\n      location: '',\n      base,\n      go,\n      createHref: createHref.bind(null, base),\n    },\n\n    historyNavigation,\n    historyListeners\n  )\n\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () =&gt; historyNavigation.location.value,\n  })\n\n  Object.defineProperty(routerHistory, 'state', {\n    enumerable: true,\n    get: () =&gt; historyNavigation.state.value,\n  })\n\n  return routerHistory\n}\n\n</code></pre><h2>总结</h2><p>以上就是今天的主要内容，我们来总结一下。</p><p>这节课我们进入到vue-router的源码中分析了vue-router内部的执行逻辑，其实我们之前课上已经实现了迷你的vue-router，在掌握了前端路由实现的原理后，再来看实际的vue-router源码难度会下降不少。</p><p>首先我们分析了createRouter函数入口函数，createRouter函数返回了router对象，router对象提供了addRoute、push等方法，并且在install方法中实现了路由，注册了组件router-link和router-view。</p><p>然后通过createRouterMatcher创建路由匹配对象，并且在路由变化的时候维护currentRoute，让你可以在每个组件内部$router和$route获取路由匹配的数据，并且动态渲染当前路由匹配的组件到router-view组件内部，实现了前端的路由系统。</p><p>这一讲我们也能感受到，一个玩具的router和实际的vue-router的距离，也能体会到TypeScript在我们阅读代码时的好处。我们阅读源码的目的之一，就是要学习和模仿优秀框架内部的设计思路，然后去优化自己项目中的代码，学会模仿也是一个优秀程序员的优秀品质。</p><h2>思考</h2><p>最后留给你一个思考题，navigate函数负责执行路由守卫的功能，你知道它的内部是如何实现的吗？</p><p>欢迎在评论区分享你的答案，我们下一讲再见！</p>","comments":[{"had_liked":false,"id":330712,"user_name":"InfoQ_e521a4ce8a54","can_delete":false,"product_type":"c1","uid":2128328,"ip_address":"","ucode":"6D8988948DD291","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIkBhCDbibPDmDTEW6Uia1LAEOcFf75QxA897gcL4oXFMOwgsqFwf7rhPoUoJWgICl0xFT8Iz2cuWRg/132","comment_is_top":false,"comment_ctime":1642129454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5937096750","product_id":100094401,"comment_content":"navigate 函数主要是执行一个异步队列；核心代码<br>function runGuardQueue(guards: Lazy&lt;any&gt;[]): Promise&lt;void&gt; {<br>  return guards.reduce(<br>    (promise, guard) =&gt; promise.then(() =&gt; guard()),<br>    Promise.resolve()<br>  )<br>}","like_count":1},{"had_liked":false,"id":341510,"user_name":"Merlin_nil","can_delete":false,"product_type":"c1","uid":2815188,"ip_address":"","ucode":"92E49F737D9D70","user_header":"https://static001.geekbang.org/account/avatar/00/2a/f4/d4/b3edd36b.jpg","comment_is_top":false,"comment_ctime":1649666565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649666565","product_id":100094401,"comment_content":"大圣老师好，install逻辑中似乎有个小错误，文中「通过 app.provide 给全局注册了 route 和 reactive 包裹后的 reactiveRoute 对象」，应该把route改为router吧？","like_count":0}]}