{"id":722704,"title":"30｜函数式语法糖：如何使用Function 、Stream来编写函数式程序？","content":"<p>你好，我是康杨。</p><p>Java 作为一门面向对象的编程语言，在近年来也逐步拥抱了函数式编程。在 JDK 8 中，引入了 Lambda 表达式和 Stream API，为 Java 开发者提供了更简洁、更易读的编写方式。今天我们来详细聊聊JDK 对函数式编程的支持，以及 JDK 中的各种函数式接口，并通过丰富的场景案例和实践，让你轻松掌握 Java 的函数式编程。</p><h2>JDK 函数式接口</h2><p>函数式接口是Java 8引入的一种新特性，它有点像一种“超级接口”，因为它只有一个抽象方法，但却可以以Lambda表达式的形式被实例化和执行。在JDK中，Function、Predicate和Consumer是最常用的函数式接口。在开发过程中，有时候可能我们需要的功能在JDK中并没有现成的实现，但是借助于函数式接口，我们就可以很方便地自定义自己需要的功能。</p><p>首先，我们来看看<strong>Function接口</strong>。在我们的日常生活里也有类似的例子，比如能够把苹果转变为苹果汁的机器，其实就是一个Function，它把一个输入转变为一个输出。在Function接口中，有一个主要的方法，就是apply，它可以把输入的东西转变成输出的东西。例如，我们可以实现一个Function，把字符串变成整数。这个Function就像一个黑盒子，你给它一个字符串，它就会给你一个整数。</p><!-- [[[read_end]]] --><p>如果我们代码里有这样一个Function：</p><pre><code class=\"language-java\">Function&lt;String, Integer&gt; stringToInt =\n              s -&gt; Integer.parseInt(s);\n</code></pre><p>当我们调用&nbsp;<code>stringToInt.apply(\"123\")</code>&nbsp;的时候，就能得到整数123。<br>\n再来看看<strong>Predicate接口</strong>。Predicate接口就像一个门卫，它的测试方法test就像检查身份证一样，只有通过检查的才能进去。比如，我们可以写一个Predicate，判断一个字符串列表是否为空。</p><pre><code class=\"language-java\">Predicate&lt;List&lt;String&gt;&gt; listIsEmpty =\n              lst -&gt; lst.isEmpty();\n</code></pre><p>然后，我们可以使用这个Predicate，检查一个字符串列表。</p><pre><code class=\"language-plain\">List&lt;String&gt; names = Arrays.asList(\"张三\", \"李四\", \"王五\");\nSystem.out.println(listIsEmpty.test(names));\n</code></pre><p>这样，当字符串列表为空时，输出就是true，否则就是false。</p><p>最后，我们来看看<strong>Consumer接口</strong>。它的accept方法所做的就是消费输入的东西。比如我们可以写一个Consumer，打印出一个字符串列表里所有的名字。</p><pre><code class=\"language-plain\">Consumer&lt;String&gt; printName = name -&gt; System.out.println(name);\n</code></pre><p>然后我们就可以把这个Consumer应用到一个字符串列表里，打印出所有的名字。</p><pre><code class=\"language-plain\">List&lt;String&gt; names = Arrays.asList(\"张三\", \"李四\", \"王五\");\nnames.forEach(printName);\n</code></pre><p>以上就是JDK中的一些主要的函数式接口，通过这些接口，我们可以更加灵活、方便地进行各种编程任务。</p><h3>Function</h3><p>Function 接口只有一个方法：<code>apply(T t, R r)</code>，用来把一个输入映射成一个输出。它的实现类包括：</p><ul>\n<li>Identity：恒等映射，输出与输入相同。</li>\n<li>compose：组合两个函数。</li>\n<li>andThen：在输入经过第一个函数处理后，再经过第二个函数处理。</li>\n</ul><p>例如，使用 Function 接口，实现一个字符串转换为整数的函数。</p><pre><code class=\"language-java\">Function&lt;String, Integer&gt; stringToInt = new Function&lt;String, Integer&gt;() {\n    @Override\n    public Integer apply(String s) {\n        return Integer.parseInt(s);\n    }\n};\n</code></pre><h3>Predicate</h3><p>Predicate 接口只有一个方法：<code>test(T t)</code>，用来判断一个输入是否满足某个条件。它的实现类包括：</p><ul>\n<li>Always：始终返回 true。</li>\n<li>Never：始终返回 false。</li>\n<li>isTrue：输入为 null 或为空时返回 false，否则返回 true。</li>\n<li>isFalse：输入为 null 或为空时返回 true，否则返回 false。</li>\n</ul><p>例如，使用 Predicate 接口判断一个字符串列表是否为空。</p><pre><code class=\"language-java\">List&lt;String&gt; names = Arrays.asList(\"张三\", \"李四\", \"王五\");\nPredicate&lt;String&gt; isEmpty = Predicate.isTrue(names.isEmpty());\nSystem.out.println(isEmpty.test(names));\n</code></pre><h3>Consumer</h3><p>Consumer 接口只有一个方法：<code>void accept(T t)</code>，用来消费一个输入。它的实现类包括：</p><ul>\n<li>identity：消费输入并返回它本身。</li>\n<li>void：消费输入并返回 void。</li>\n</ul><p>例如，使用 Consumer 接口打印一个字符串列表。</p><pre><code class=\"language-plain\">List&lt;String&gt; names = Arrays.asList(\"张三\", \"李四\", \"王五\");\nConsumer&lt;String&gt; println = System.out::println;\nnames.forEach(println);\n</code></pre><h2>Stream API</h2><p>Java 的 Stream API 为我们提供了一种全新方便的处理数据的方式。它的特点是强大、灵活且简便，下面我们来详细介绍下。</p><p>首先，Stream API 有各种各样的操作，包括转换流、对每个元素进行映射、过滤元素、排序流、归约流以及将流转换回集合。每个操作都有其独特之处和使用场景。</p><p>比如说，<code>stream()</code> 是一种非常简单的把集合转化为 Stream 的方法。只需要在集合对象后面加上 <code>.stream()</code> 就可以了。接下来你就可以在这个 Stream 上进行各种操作，并且它不会改变原有的集合。比如，如果我们有一个整数列表，我们可以用 <code>.stream()</code> 把它转化为流，代码如下：</p><pre><code class=\"language-java\">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5); Stream&lt;Integer&gt; stream = numbers.stream();\n</code></pre><p>接着我们看看 <code>map()</code>，<code>map()</code> 非常有用，例如你有一组数据，你想对这些数据操作后得到一组新的数据，这个时候就可以用 <code>map()</code>。它的参数是一个函数，这个函数会被应用到流中的每一个元素上。比如，我们可以把上面流里的每个整数转换成它的平方数，代码如下：</p><pre><code class=\"language-java\">Stream&lt;Integer&gt; squareNums = stream.map(n -&gt; n * n);\n</code></pre><p><code>filter()</code> 则是从 Stream 中过滤出符合指定条件的元素。举个例子，如果你有一个整数列表，你想从中找出所有的奇数，那你就可以用 <code>filter((number) -&gt; number % 2 != 0)</code>。</p><p>另外，<code>sorted()</code> 可以对 Stream 里的元素进行排序，你可以传递一个自定义比较器或者直接使用默认的比较器。</p><p>减少操作的核心是 <code>reduce()</code>，这个操作可以从一堆元素中生成一个值。例如，你可以用 <code>reduce()</code> 来算出一组数字的总和，或者找到最大的一个数。</p><p>最后 <code>collect()</code> 就是把 Stream 再转回集合。可能你在 Stream 里做了各种操作，最后你想把它们收集起来放在一个新的集合里，那就用 <code>collect()</code>。<code>collect()</code> 可以让你把一个流转化为任何想要的数据结构，比如 List、Set 或者 Map。例如 <code>stream.collect(Collectors.toList())</code> 会将流转换回List集合。</p><p>以上描述的就是 Stream 主要的一些操作，你可能需要根据实际情况来选择使用哪一种。但是有一件事是肯定的，如果你要操作的是一系列数据，那 Stream API 一定是你的好帮手。</p><p>在日常开发过程中，熟练使用 Stream API 可以让我们的程序变得更加简洁，读写性能更加高效，代码级别的抽象程度也更高，这样可以大大提高我们的开发效率。所以说 Java的Stream API是函数式编程的核心，它以声明式的方式处理集合，简化了编程的复杂度，让代码看起来更加简洁明了。Stream API的运用涵盖了许多常用的操作，包括将集合转为流、将集合中的每个元素应用一个函数、筛选满足特定条件的元素、排序、归约操作以及将流转回集合。</p><h2>场景案例与最佳实践</h2><p>函数式接口在Java中具有重要的作用，它们的存在让我们的代码变得更加简洁而具有表现力。下面我们通过三个具体的示例，详细讲解Function、Predicate和Consumer接口在实际场景中的使用。</p><h3>案例1：计算列表中每个元素的平方</h3><p>这个案例中，我们使用Function接口来把整数列表里的每个元素转换成它的平方。代码如下：</p><pre><code class=\"language-java\">// 初始化一个整数列表\nList&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\n&nbsp;\n// 利用Function接口定义一个算法，输入一个整数，输出这个整数的平方\nFunction&lt;Integer,Integer&gt; square = n -&gt; n * n;\n&nbsp;\n// 利用Stream API的 map 方法，将算法应用到列表的每个元素\n// 用 collect 方法将结果收集到新的列表中\nList&lt;Integer&gt; squaredNumbers = numbers.stream()\n.map(square)\n.collect(Collectors.toList());\n&nbsp;\n// 打印结果\nSystem.out.println(squaredNumbers);\n</code></pre><p>在以上代码中，我们创建了一个Function接口的实例，然后把它应用于列表中的每个元素，得到了原列表元素平方后的新列表。</p><h3>案例2：过滤出字符串列表中偶数个字符的字符串</h3><p>这个案例中，我们使用Predicate接口过滤出字符串列表里具有偶数个字符的字符串。代码如下：</p><pre><code class=\"language-java\">// 初始化一个字符串列表\nList&lt;String&gt; names = Arrays.asList(\"张三\", \"李四\", \"王五\", \"赵六\");\n&nbsp;\n// 利用Predicate接口定义一个测试条件，只有字符串长度是偶数的才符合条件\nPredicate&lt;String&gt; hasEvenLength = n -&gt; n.length() % 2 == 0;\n&nbsp;\n// 利用Stream API的 filter 方法，对列表中每个元素进行测试，过滤出符合条件的元素\nList&lt;String&gt; evenLengthNames = names.stream()\n.filter(hasEvenLength)\n.collect(Collectors.toList());\n&nbsp;\n// 打印结果\nSystem.out.println(evenLengthNames);\n</code></pre><p>在以上代码中，Predicate接口是对符合特定条件的项进行选择的一种方式。在这个示例中，条件就是字符串的长度是偶数。</p><h3><strong>案例3：将字符串列表转换为字符串数组</strong></h3><p>这个案例中，我们使用Consumer接口将一个字符串列表转换为一个字符串数组。代码如下：</p><pre><code class=\"language-java\">// 初始化一个字符串列表\nList&lt;String&gt; names = Arrays.asList(\"张三\", \"李四\", \"王五\");\n&nbsp;\n// 利用Stream API的 toArray 方法，将列表转换为数组\nString[] nameArray = names.stream().toArray(String[]::new);\n&nbsp;\n// 用Consumer接口将每个元素打印出来\nConsumer&lt;String&gt; printConsumer = System.out::println;\nArrays.asList(nameArray).forEach(printConsumer);\n</code></pre><p>在上述代码中，Consumer接口与System.out::println方法结合使用，打印转换后的字符串数组。</p><p>以上就是我们如何在实际场景中使用Function、Predicate和Consumer这三个函数式接口的示例。借助这些接口，我们可以以更为简洁、通用的方式实现复杂的功能，无需显式地为每个需求定制特定的方法。</p><h2>开源框架中的应用</h2><h3>Spring Framework</h3><p>Spring Framework 提供了基于 Function 接口的 Web 请求处理函数式编程支持，例如：</p><pre><code class=\"language-java\">@GetMapping(\"/hello\")\npublic Function&lt;HttpServletRequest, String&gt; hello() {\n&nbsp; &nbsp; return request -&gt; \"Hello, \" + request.getRemoteUser();\n}\n</code></pre><h3>Apache Commons Lang</h3><p>Apache Commons Lang 提供了许多实用的工具类，例如：</p><ul>\n<li>FunctionUtils.compose()：组合两个函数。</li>\n<li>FunctionUtils.andThen()：在输入经过第一个函数处理后，再经过第二个函数处理。</li>\n<li>PredicateUtils.always()：始终返回 true。</li>\n<li>PredicateUtils.never()：始终返回 false。</li>\n</ul><h2>重点回顾</h2><p>Java作为一门面向对象的编程语言，近年来逐步拥抱了函数式编程，通过引入Lambda表达式、Stream API以及函数式接口等特性，提供了更简洁、易读的编写方式。</p><p>JDK中的函数式接口包括Function、Predicate和Consumer，它们分别具有将输入映射为输出、判断输入是否满足条件以及消费输入的功能。Stream API则是处理数据的一种强大、灵活且简便的方式，包括转换流、映射元素、过滤元素、排序流、归约流以及将流转换回集合等操作。在日常开发过程中，熟练使用Stream API和函数式接口可以让程序更加简洁、读写性能更高效，提高开发效率。</p><h2>思考题</h2><p>学而不思则罔，学完这节课之后，我给你留两个问题。</p><ol>\n<li>JDK提供了 哪些函数式的接口？</li>\n<li>尝试用JDK提供函数式接口改造一段现有代码。</li>\n</ol><p>希望你认真思考，然后把思考后的结果分享到评论区，我们一起讨论，如果有收获的话，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":383560,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"四川","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1699268517,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"能不能加餐讲下java新版本的虚拟线程呢。","like_count":1},{"had_liked":false,"id":383568,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1699278116,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教老师问题：\nQ1：案例1中，Function类型的square怎么没有apply？\nFunction接口只有一个方法apply，怎么定义的square没有apply?\nQ2：案例2中，Predict类型的hasEvenLength怎么没有test?\nPredict接口只有一个方法test，怎么定义的hasEvenLength没有test?","like_count":0,"discussions":[{"author":{"id":1673990,"avatar":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","nickname":"TableBear","note":"","ucode":"A2C0562EEA2725","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631195,"discussion_content":"这是语法糖来着，案例给出的都是Lambda表达式。编译器会自动降表达式包装成对应函数接口实现类对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699399964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383520,"user_name":"二九幂加八","can_delete":false,"product_type":"c1","uid":2054575,"ip_address":"北京","ucode":"CE9409D74FC545","user_header":"https://static001.geekbang.org/account/avatar/00/1f/59/af/d2107a67.jpg","comment_is_top":false,"comment_ctime":1699202575,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"老师，Stream API处理数据会不会造成OOM？如果会出现OOM的情况，应该如何处理这种情况？","like_count":0}]}