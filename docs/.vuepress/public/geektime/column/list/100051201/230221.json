{"id":230221,"title":"02 | 内存池：如何提升内存分配的效率？","content":"<p>你好，我是陶辉。</p><p>上一讲我们提到，高频地命中CPU缓存可以提升性能。这一讲我们把关注点从CPU转移到内存，看看如何提升内存分配的效率。</p><p>或许有同学会认为，我又不写底层框架，内存分配也依赖虚拟机，并不需要应用开发者了解。如果你也这么认为，我们不妨看看这个例子：在Linux系统中，用Xmx设置JVM的最大堆内存为8GB，但在近百个并发线程下，观察到Java进程占用了14GB的内存。为什么会这样呢？</p><p>这是因为，绝大部分高级语言都是用C语言编写的，包括Java，申请内存必须经过C库，而C库通过预分配更大的空间作为内存池，来加快后续申请内存的速度。这样，预分配的6GB的C库内存池就与JVM中预分配的8G内存池叠加在一起，造成了Java进程的内存占用超出了预期。</p><p>掌握内存池的特性，既可以避免写程序时内存占用过大，导致服务器性能下降或者进程OOM（Out Of Memory，内存溢出）被系统杀死，还可以加快内存分配的速度。在系统空闲时申请内存花费不了多少时间，但是对于分布式环境下繁忙的多线程服务，获取内存的时间会上升几十倍。</p><p>另一方面，内存池是非常底层的技术，当我们理解它后，可以更换适合应用场景的内存池。在多种编程语言共存的分布式系统中，内存池有很广泛的应用，优化内存池带来的任何微小的性能提升，都将被分布式集群巨大的主机规模放大，从而带来整体上非常可观的收益。</p><!-- [[[read_end]]] --><p>接下来，我们就通过对内存池的学习，看看如何提升内存分配的效率。</p><h2>隐藏的内存池</h2><p>实际上，在你的业务代码与系统内核间，往往有两层内存池容易被忽略，尤其是其中的C库内存池。</p><p>当代码申请内存时，首先会到达应用层内存池，如果应用层内存池有足够的可用内存，就会直接返回给业务代码，否则，它会向更底层的C库内存池申请内存。比如，如果你在Apache、Nginx等服务之上做模块开发，这些服务中就有独立的内存池。当然，Java中也有内存池，当通过启动参数Xmx指定JVM的堆内存为8GB时，就设定了JVM堆内存池的大小。</p><p>你可能听说过Google的TCMalloc和FaceBook的JEMalloc，它们也是C库内存池。当C库内存池无法满足内存申请时，才会向操作系统内核申请分配内存。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/89/6a/893edd82d03c628fae83b95bd4fbba6a.jpg?wh=2089*1745\" alt=\"\"></p><p>回到文章开头的问题，Java已经有了应用层内存池，为什么还会受到C库内存池的影响呢？这是因为，除了JVM负责管理的堆内存外，Java还拥有一些堆外内存，由于它不使用JVM的垃圾回收机制，所以更稳定、持久，处理IO的速度也更快。这些堆外内存就会由C库内存池负责分配，这是Java受到C库内存池影响的原因。</p><p>其实不只是Java，几乎所有程序都在使用C库内存池分配出的内存。C库内存池影响着系统下依赖它的所有进程。我们就以Linux系统的默认C库内存池Ptmalloc2来具体分析，看看它到底对性能发挥着怎样的作用。</p><p>C库内存池工作时，会预分配比你申请的字节数更大的空间作为内存池。比如说，当主进程下申请1字节的内存时，Ptmalloc2会预分配132K字节的内存（Ptmalloc2中叫Main Arena），应用代码再申请内存时，会从这已经申请到的132KB中继续分配。</p><p>如下所示（你可以在<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/2-memory/alloc_address\">这里</a>找到示例程序，注意地址的单位是16进制）：</p><pre><code># cat /proc/2891/maps | grep heap\n01643000-01664000 rw-p 00000000 00:00 0     [heap]\n</code></pre><p>当我们释放这1字节时，Ptmalloc2也不会把内存归还给操作系统。Ptmalloc2认为，与其把这1字节释放给操作系统，不如先缓存着放进内存池里，仍然当作用户态内存留下来，进程再次申请1字节的内存时就可以直接复用，这样速度快了很多。</p><p>你可能会想，132KB不多呀？为什么这一讲开头提到的Java进程，会被分配了几个GB的内存池呢？这是因为<strong>多线程与单线程的预分配策略并不相同</strong>。</p><p>每个<strong>子线程预分配的内存是64MB</strong>（Ptmalloc2中被称为Thread Arena，32位系统下为1MB，64位系统下为64MB）。如果有100个线程，就将有6GB的内存都会被内存池占用。当然，并不是设置了1000个线程，就会预分配60GB的内存，子线程内存池最多只能到8倍的CPU核数，比如在32核的服务器上，最多只会有256个子线程内存池，但这也非常夸张了，16GB（64MB * 256 = 16GB）的内存将一直被Ptmalloc2占用。</p><p>回到本文开头的问题，Linux下的JVM编译时默认使用了Ptmalloc2内存池，因此每个线程都预分配了64MB的内存，这造成含有上百个Java线程的JVM多使用了6GB的内存。在多数情况下，这些预分配出来的内存池，可以提升后续内存分配的性能。</p><p>然而，Java中的JVM内存池已经管理了绝大部分内存，确实不能接受莫名多出来6GB的内存，那该怎么办呢？既然我们知道了Ptmalloc2内存池的存在，就有两种解决办法。</p><p>首先可以调整Ptmalloc2的工作方式。<strong>通过设置MALLOC_ARENA_MAX环境变量，可以限制线程内存池的最大数量</strong>，当然，线程内存池的数量减少后，会影响Ptmalloc2分配内存的速度。不过由于Java主要使用JVM内存池来管理对象，这点影响并不重要。</p><p>其次可以更换掉Ptmalloc2内存池，选择一个预分配内存更少的内存池，比如Google的TCMalloc。</p><p>这并不是说Google出品的TCMalloc性能更好，而是在特定的场景中的选择不同。而且，盲目地选择TCMalloc很可能会降低性能，否则Linux系统早把默认的内存池改为TCMalloc了。</p><p>TCMalloc和Ptmalloc2是目前最主流的两个内存池，接下来我带你通过对比TCMalloc与Ptmalloc2内存池，看看到底该如何选择内存池。</p><h2>选择Ptmalloc2还是TCMalloc？</h2><p>先来看TCMalloc适用的场景，<strong>它对多线程下小内存的分配特别友好。</strong></p><p>比如，在2GHz的CPU上分配、释放256K字节的内存，Ptmalloc2耗时32纳秒，而TCMalloc仅耗时10纳秒（测试代码参见<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/2-memory/benchmark\">这里</a>）。<strong>差距超过了3倍，为什么呢？</strong>这是因为，Ptmalloc2假定，如果线程A申请并释放了的内存，线程B可能也会申请类似的内存，所以它允许内存池在线程间复用以提升性能。</p><p>因此，每次分配内存，Ptmalloc2一定要加锁，才能解决共享资源的互斥问题。然而，加锁的消耗并不小。如果你监控分配速度的话，会发现单线程服务调整为100个线程，Ptmalloc2申请内存的速度会变慢10倍。TCMalloc针对小内存做了很多优化，每个线程独立分配内存，无须加锁，所以速度更快！</p><p>而且，<strong>线程数越多，Ptmalloc2出现锁竞争的概率就越高。</strong>比如我们用40个线程做同样的测试，TCMalloc只是从10纳秒上升到25纳秒，只增长了1.5倍，而Ptmalloc2则从32纳秒上升到137纳秒，增长了3倍以上。</p><p>下图是TCMalloc作者给出的性能测试数据，可以看到线程数越多，二者的速度差距越大。所以，<strong>当应用场景涉及大量的并发线程时，换成TCMalloc库也更有优势！</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/56/37/56c77fdf3a130fce4c98943f494c9237.png?wh=448*336\" alt=\"\" title=\"图片来源：TCMalloc : Thread-Caching Malloc\"></p><p>那么，为什么GlibC不把默认的Ptmalloc2内存池换成TCMalloc呢？<strong>因为Ptmalloc2更擅长大内存的分配。</strong></p><p>比如，单线程下分配257K字节的内存，Ptmalloc2的耗时不变仍然是32纳秒，但TCMalloc就由10纳秒上升到64纳秒，增长了5倍以上！<strong>现在TCMalloc反过来比Ptmalloc2慢了1倍！</strong>这是因为TCMalloc特意针对小内存做了优化。</p><p>多少字节叫小内存呢？TCMalloc把内存分为3个档次，小于等于256KB的称为小内存，从256KB到1M称为中等内存，大于1MB的叫做大内存。TCMalloc对中等内存、大内存的分配速度很慢，比如我们用单线程分配2M的内存，Ptmalloc2耗时仍然稳定在32纳秒，但TCMalloc已经上升到86纳秒，增长了7倍以上。</p><p>所以，<strong>如果主要分配256KB以下的内存，特别是在多线程环境下，应当选择TCMalloc；否则应使用Ptmalloc2，它的通用性更好。</strong></p><h2>从堆还是栈上分配内存？</h2><p>不知道你发现没有，刚刚讨论的内存池中分配出的都是堆内存，如果你把在堆中分配的对象改为在栈上分配，速度还会再快上1倍（具体测试代码可以在<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/2-memory/benchmark\">这里</a>找到）！为什么？</p><p>可能有同学还不清楚堆和栈内存是如何分配的，我先简单介绍一下。</p><p>如果你使用的是静态类型语言，那么，不使用new关键字分配的对象大都是在栈中的。比如：</p><pre><code>C/C++/Java语言：int a = 10;\n</code></pre><p>否则，通过new或者malloc关键字分配的对象则是在堆中的：</p><pre><code>C语言：int * a = (int*) malloc(sizeof(int));\nC++语言：int * a = new int;\nJava语言：int a = new Integer(10);\n</code></pre><p>另外，对于动态类型语言，无论是否使用new关键字，内存都是从堆中分配的。</p><p>了解了这一点之后，我们再来看看，为什么从栈中分配内存会更快。</p><p>这是因为，由于每个线程都有独立的栈，所以分配内存时不需要加锁保护，而且栈上对象的尺寸在编译阶段就已经写入可执行文件了，执行效率更高！性能至上的Golang语言就是按照这个逻辑设计的，即使你用new关键字分配了堆内存，但编译器如果认为在栈中分配不影响功能语义时，会自动改为在栈中分配。</p><p>当然，在栈中分配内存也有缺点，它有功能上的限制。一是， 栈内存生命周期有限，它会随着函数调用结束后自动释放，在堆中分配的内存，并不随着分配时所在函数调用的结束而释放，它的生命周期足够使用。二是，栈的容量有限，如CentOS 7中是8MB字节，如果你申请的内存超过限制会造成栈溢出错误（比如，递归函数调用很容易造成这种问题），而堆则没有容量限制。</p><p><strong>所以，当我们分配内存时，如果在满足功能的情况下，可以在栈中分配的话，就选择栈。</strong></p><h2>小结</h2><p>最后我们对这一讲做个小结。</p><p>进程申请内存的速度，以及总内存空间都受到内存池的影响。知道这些隐藏内存池的存在，是提升分配内存效率的前提。</p><p>隐藏着的C库内存池，对进程的内存开销有很大的影响。当进程的占用空间超出预期时，你需要清楚你正在使用的是什么内存池，它对每个线程预分配了多大的空间。</p><p>不同的C库内存池，都有它们最适合的应用场景，例如TCMalloc对多线程下的小内存分配特别友好，而Ptmalloc2则对各类尺寸的内存申请都有稳定的表现，更加通用。</p><p>内存池管理着堆内存，它的分配速度比不上在栈中分配内存。只是栈中分配的内存受到生命周期和容量大小的限制，应用场景更为有限。然而，如果有可能的话，尽量在栈中分配内存，它比内存池中的堆内存分配速度快很多！</p><p>OK，今天我们从内存分配的角度聊了分布式系统性能提升的内容，希望学习过今天的内容后，你知道如何最快速地申请到内存，了解你正在使用的内存池，并清楚它对进程最终内存大小的影响。即使对第三方组件，我们也可以通过LD_PRELOAD环境变量，在程序启动时更换最适合的C库内存池（Linux中通过LD_PRELOAD修改动态库来更换内存池，参见<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/2-memory/benchmark\">示例代码</a>）。</p><p>内存分配时间虽然不起眼，但时刻用最快的方法申请内存，正是高手与初学者的区别，相似算法的性能差距就体现在这些编码细节上，希望你能够重视它。</p><h2>思考题</h2><p>最后，留给你一个思考题。分配对象时，除了分配内存，还需要初始化对象的数据结构。内存池对于初始化对象有什么帮助吗？欢迎你在留言区与大家一起探讨。</p><p>感谢阅读，如果你觉得这节课对你有一些启发，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"01 | CPU缓存：怎样写代码能够让CPU执行得更快？","id":230194},"right":{"article_title":"03 | 索引：如何用哈希表管理亿级对象？","id":232351}},"comments":[{"had_liked":false,"id":211596,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1587987340,"is_pvip":false,"replies":[{"id":"78662","content":"忆水寒同学说得对，享元模式这个词用得也很好！享元模式有广泛的应用，不只在应用层，在内核中也被广泛使用。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1587996146,"ip_address":"","comment_id":211596,"utype":1}],"discussion_count":6,"race_medal":0,"score":"177681646476","product_id":100051201,"comment_content":"1、思考题：内存池中可以利用享元模式将常用的对象一直保留着，减少重复申请导致的性能的顺耗。<br>2、最后一段话“内存分配时间虽然不起眼，但时刻用最快的方法申请内存，正是高手与初学者的区别。”说的很好，是的，真正的高手应该能够从算法到底层都能优化。","like_count":42,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493309,"discussion_content":"忆水寒同学说得对，享元模式这个词用得也很好！享元模式有广泛的应用，不只在应用层，在内核中也被广泛使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587996146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240465,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","nickname":"我能走多远","note":"","ucode":"07DF5D5DADFA3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251329,"discussion_content":"类似于内存池；缓存的感念。我现在搞sdn，dpdk+vpp相关。基本上都是内存池的应用。空间换时间。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588080579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064732,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/1c/1e4dfbc9.jpg","nickname":"远方","note":"","ucode":"244C74F9857196","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351814,"discussion_content":"java 的String和L就是用享元模式实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614475105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083600,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/d0/6e75f766.jpg","nickname":"有朋自远方来","note":"","ucode":"23A12829DEB119","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261664,"discussion_content":"享元模式。只知有这个模式，却没有用过。惭愧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588990559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240465,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","nickname":"我能走多远","note":"","ucode":"07DF5D5DADFA3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251204,"discussion_content":"享元模式，这词都没听过。受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588073356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1240465,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","nickname":"我能走多远","note":"","ucode":"07DF5D5DADFA3C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251294,"discussion_content":"一起交流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588078926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":251204,"ip_address":""},"score":251294,"extra":""}]}]},{"had_liked":false,"id":211555,"user_name":"ermaot","can_delete":false,"product_type":"c1","uid":1304459,"ip_address":"","ucode":"DD5AC5FFEAA9CC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1PyKtnO7QRIP8mlcGNu4wpYVjOo6ZZ7pNIxbmRSYK0KvbcXPVcsiba4ibo1GTjQrRYibiaPxrrTPtlGnzoDEP7tDBQ/132","comment_is_top":false,"comment_ctime":1587982788,"is_pvip":false,"replies":[{"id":"78666","content":"很高兴能帮到你，我跟编辑一直担心这个会不会讲得太深了呢，其实很多性能优先的组件都可以用得上","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1587996527,"ip_address":"","comment_id":211555,"utype":1}],"discussion_count":3,"race_medal":0,"score":"139026936260","product_id":100051201,"comment_content":"解决了我很多疑惑。比如mysql很多人建议把内存分配换成tcmalloc，就是因为mysql要支持大量并发，适合tcmalloc的应用场景。没有对比就没有发现，两库一比，知识点就出来了","like_count":33,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493297,"discussion_content":"很高兴能帮到你，我跟编辑一直担心这个会不会讲得太深了呢，其实很多性能优先的组件都可以用得上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587996527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1304459,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/1PyKtnO7QRIP8mlcGNu4wpYVjOo6ZZ7pNIxbmRSYK0KvbcXPVcsiba4ibo1GTjQrRYibiaPxrrTPtlGnzoDEP7tDBQ/132","nickname":"ermaot","note":"","ucode":"DD5AC5FFEAA9CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252309,"discussion_content":"你问老师的问题，我想了一下，不知道自己是否理解对了，你试试bcc的xfsslower和ext4slower工具。可以跟踪大于特定时长的延时。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588151810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1198281,"avatar":"https://static001.geekbang.org/account/avatar/00/12/48/c9/f4807e6e.jpg","nickname":"lily","note":"","ucode":"EF9E81B81C21E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251863,"discussion_content":"老师你好，我现在有个io的问题，之前遇到服务在特定时间下会偶发抖动的情况，但是通过调用链查看，方法真正执行时间很快，整个链路上可能耗时的也就是日志入盘了，通过观察io，发现在特定时间下iowait会有微量抖动，iotop抓到的进程也没看出有什么异常，后来发现所有抖动的节点操作系统版本都是centos7，文件系统是ext4，而其他正常的机器都是xfs的，不知道和这个有没有关系，看老师后面也有io方面的优化课程，在这里提前咨询下，是否有一些思路？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588122822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211797,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1588007942,"is_pvip":false,"replies":[{"id":"78733","content":"又添aoe大招了^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588040057,"ip_address":"","comment_id":211797,"utype":1}],"discussion_count":3,"race_medal":0,"score":"96077288454","product_id":100051201,"comment_content":"1. 原来Java堆的内存空间是通过C库内存池申请！<br>2. 第一次知道内存分配器的存在：Ptmalloc2、TCMalloc<br>3. 在栈中申请内存比堆中快是因为不需要加锁。<br>收获惊呆了！","like_count":23,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493368,"discussion_content":"又添aoe大招了^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588040057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625689,"avatar":"","nickname":"符号","note":"","ucode":"004DA7A96A2DD8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588085,"discussion_content":"第一点有问题吧，作者意思是说JVM堆外内存是通过c库内存池申请的，没有说堆内存是通过c库内存池申请的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663549712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1625689,"avatar":"","nickname":"符号","note":"","ucode":"004DA7A96A2DD8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":588092,"discussion_content":"谢谢纠正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663551298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":588085,"ip_address":"浙江"},"score":588092,"extra":""}]}]},{"had_liked":false,"id":212861,"user_name":"子不语","can_delete":false,"product_type":"c1","uid":1123186,"ip_address":"","ucode":"907AB44706467B","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/72/70190bc1.jpg","comment_is_top":false,"comment_ctime":1588227072,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"74602671104","product_id":100051201,"comment_content":"老师好，一直在学习老师的课程，发现出了性能的，赶紧来学习。学习这篇遇到几个问题，麻烦老师能解惑。<br>第一个问题:<br>文中提到: 预分配的 6GB 的 C 库内存池就与 JVM 中预分配的 8G 内存池叠加在一起，造成了 Java 进程的内存占用超出了预期。<br><br>这里预分配的6g内存池是虚拟地址空间吗？<br><br>第二个问题，如果我的虚拟机总共10g，jvm预分配了6g堆内存，那这6g内存是不是不能用作其他的地方了？","like_count":17,"discussions":[{"author":{"id":1123186,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/72/70190bc1.jpg","nickname":"子不语","note":"","ucode":"907AB44706467B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262729,"discussion_content":"这么多小伙伴点赞，肯定有和我一样的疑问，这些天查了些资料，大家一起讨论下。\n第一个问题，分配的是虚拟内存，原因是: Java 应用运行在 JVM 上，JVM 有自己的一套内存调用方式，一般不会使用到 glibc，但某些对象还是会调用 malloc，就是我们说的堆外内存，从而使用使用到 per thread  arenas 这个特性，缺省配置在64bit下面是每一个arena为64M，当然不会无限分配，文中老师也提到了，一个进程最多有 cores * 8个arena。假设你的机器是4核的，那么最多可以有4 * 8 = 32个arena，也就是使用32 * 64 = 2048M虚拟内存。\n第二个问题: 分配6G内存给jvm，但是如果服务刚启动，使用真实内存很少，同时服务器上还运行别的服务，非常吃内存的情况，会出现抢占内存的情况。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1589122715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1038574,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","nickname":"Only now","note":"","ucode":"C617473A03AE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1123186,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/72/70190bc1.jpg","nickname":"子不语","note":"","ucode":"907AB44706467B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325334,"discussion_content":"请教一下，与分配的应该是本地址空间的预留吧，是不是不会实际占用了物理内存？按照一般资料的说法，进程地址空间是隔离的。启动时不需要的内存分配是如何影响到其他的进程的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605274173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262729,"ip_address":""},"score":325334,"extra":""}]},{"author":{"id":1989922,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5d/22/2b41b7bf.jpg","nickname":"Alex🐒","note":"","ucode":"FE24192C56A176","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265166,"discussion_content":"所以Java使用堆外内存的时候才有影响是吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589378068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123186,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/72/70190bc1.jpg","nickname":"子不语","note":"","ucode":"907AB44706467B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1989922,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5d/22/2b41b7bf.jpg","nickname":"Alex🐒","note":"","ucode":"FE24192C56A176","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265310,"discussion_content":"对，堆内存是由jvm管理的，不会调用malloc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589383371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":265166,"ip_address":""},"score":265310,"extra":""}]}]},{"had_liked":false,"id":225534,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1591780325,"is_pvip":false,"replies":[{"id":"83139","content":"对小内存做优化，其实是会造成内存利用率下降的，特别是每个线程独立维护内存池，就拒绝线程之间共享内存池了。由于小内存的使用最为频繁，所以利用率的下降表现不明显。但对大内存做上述优化，就会造成利用率下降过多，性价比不划算。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1591837279,"ip_address":"","comment_id":225534,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53131387877","product_id":100051201,"comment_content":"老师你好，我有一个疑问<br>TCMalloc既然可以针对小内存做优化，为何不对中等内存和大内存一起做优化？是技术上实现有困难吗？能否从技术实现的角度来聊聊，为何它只优化了小内存的场景","like_count":12,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497883,"discussion_content":"对小内存做优化，其实是会造成内存利用率下降的，特别是每个线程独立维护内存池，就拒绝线程之间共享内存池了。由于小内存的使用最为频繁，所以利用率的下降表现不明显。但对大内存做上述优化，就会造成利用率下降过多，性价比不划算。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591837279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2085553,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d2/b1/c819fd7d.jpg","nickname":"发飙的蜗牛","note":"","ucode":"C807F5E6A9E46C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371104,"discussion_content":"我也有疑问，既然明确了大小中，为何不干脆小内存做小优化，大内存抄袭ptmalloc2？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619656426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244326,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1598485140,"is_pvip":false,"replies":[{"id":"90257","content":"对的，“加一层”缓存：-）","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1598942977,"ip_address":"","comment_id":244326,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27368288916","product_id":100051201,"comment_content":"计算机领域解决运算速度的两大法宝：1.加一层 2.化整为零。无论是cpu 寄存器， L1&#47;2&#47;3 cache，以及本节讲的glibc 内存池，都是通过“加一层”的方法，预先取得可能用到的资源，通过空间的代价来换得时间的效益。","like_count":7,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504552,"discussion_content":"对的，“加一层”缓存：-）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598942977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1538677,"avatar":"https://static001.geekbang.org/account/avatar/00/17/7a/75/69128049.jpg","nickname":"apdoer","note":"","ucode":"B9496BFE0B9F84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378035,"discussion_content":"化整为零怎么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623028131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244323,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1598483862,"is_pvip":false,"replies":[{"id":"90259","content":"谢谢万历十五年同学的分享！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1598943278,"ip_address":"","comment_id":244323,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27368287638","product_id":100051201,"comment_content":"解决ptmalloc2内存过大的三种方案（转自http:&#47;&#47;fengfu.io）：<br><br>第一种：控制分配区的总数上限。默认64位系统分配区数为：cpu核数*8，如当前环境16核系统分配区数为128个，每个64M上限的话最多可达8G，限制上限后，后续不够的申请会直接走mmap分配和munmap回收，不会进入ptmalloc2的buffer池。<br>所以第一种方案调整一下分配池上限个数到4：<br>export MALLOC_ARENA_MAX=4<br><br>第二种：之前讲到ptmalloc2默认会动态调整mmap分配阈值，因此对于较大的内存请求也会进入ptmalloc2的内存buffer池里，这里可以去掉ptmalloc的动态调整功能。可以设置 M_TRIM_THRESHOLD，M_MMAP_THRESHOLD，M_TOP_PAD 和 M_MMAP_MAX 中的任意一个。这里可以固定分配阈值为128K，这样超过128K的内存分配请求都不会进入ptmalloc的buffer池而是直接走mmap分配和munmap回收（性能上会有损耗，当前环境大概10%）。：<br>export MALLOC_MMAP_THRESHOLD_=131072<br>export MALLOC_TRIM_THRESHOLD_=131072<br>export MALLOC_TOP_PAD_=131072<br>export MALLOC_MMAP_MAX_=65536   <br><br>第三种：使用tcmalloc来替代默认的ptmalloc2。google的tcmalloc提供更优的内存分配效率，性能更好，ThreadCache会阶段性的回收内存到CentralCache里。 解决了ptmalloc2中arena之间不能迁移导致内存浪费的问题。","like_count":6,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504549,"discussion_content":"谢谢万历十五年同学的分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598943278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215366,"user_name":"唐朝首都","can_delete":false,"product_type":"c1","uid":1081233,"ip_address":"","ucode":"F72655AE0AE4CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/91/962eba1a.jpg","comment_is_top":false,"comment_ctime":1588982682,"is_pvip":true,"replies":[{"id":"79764","content":"1、是的。<br>2、不使用堆外内存即可。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589008547,"ip_address":"","comment_id":215366,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27358786458","product_id":100051201,"comment_content":"今天课程学习到了很多，感觉一整篇 的知识盲点，学完很受启发。另外有个问题：文中提到“预分配的 6GB 的 C 库内存池就与 JVM 中预分配的 8G 内存池叠加在一起，造成了 Java 进程的内存占用超出了预期。”中“预分配的6GB的C库内存池”为堆外内存么？如果代码中不适用堆外内存是不是就不会预分配6GB的C库内存池，还是说有那么多的线程就一定会使用到6GB的C库内存池？？","like_count":7,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494404,"discussion_content":"1、是的。\n2、不使用堆外内存即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589008547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623409,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c5/71/f7c43b49.jpg","nickname":"风向北吹","note":"","ucode":"2FD0BC5159E1C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404181,"discussion_content":"JVM预分配的8G内存也是从C库内存池分配，也就是C库内存池总共分配了14G","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634255181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214523,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1588761387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27358565163","product_id":100051201,"comment_content":"碰巧今天看一个CMS GC的问题，就点击到了一个作者的网站，其中一篇也是分析堆外内存的文章，更具体的解释了如何替换pt到tc ,地址如下：<br>http:&#47;&#47;fengfu.io&#47;2019&#47;01&#47;22&#47;%E8%BD%AC-Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5Case&#47;<br>只是分享哈，和作者无任何关系~~","like_count":6},{"had_liked":false,"id":212124,"user_name":"奥特曼","can_delete":false,"product_type":"c1","uid":1766145,"ip_address":"","ucode":"76BAC701319542","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f3/01/5a1416bc.jpg","comment_is_top":false,"comment_ctime":1588063574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23062900054","product_id":100051201,"comment_content":" 老师好，我有3个问题：<br>------------------问题1--------------------<br>讲义里面提到64位的环境下，一个子线程创建会有64M的内存申请，我最开始理解的这64M是这个子线程独有的。<br>在后面又提到“Ptmalloc2 假定，如果线程 A 申请并释放了的内存，线程 B 可能也会申请类似的内存，所以它允许内存池在线程间复用以提升性能。”，那是不是理解成每个子线程在创建的时候会有对应64M的内存申请给它，但是这64M的内存是所有子线程之间共享使用的？<br><br>------------------问题2--------------------<br>关于堆外内存：老师这里说到的堆外内存不单单是相对JVM来说的吧？这里指的堆外内存再具体一点，是指使用了Ptmalloc2，在创建进程&#47;线程时默认的分享的内存吗？<br><br>------------------问题3--------------------<br>讲义里面提到堆外内存“更稳定、持久，处理 IO 的速度也更快”。能理解更稳定、持久，是因为堆外内存是由Ptmalloc2去维护，基本和进程的生命周期一样。但是没理解为什么堆外内存在处理IO上的速度会更快？这里面的IO是指具体的磁盘IO？还是网络IO？<br><br>------------------问题4--------------------<br>老师提到过，进程里面的线程数要和CPU的核数对应上，不知道老师这里说的CPU核数是物理核，还是逻辑核？<br><br><br>分享一下学习到的内容：<br>1、之前只是知道创建&#47;销毁线程，会造成资源的浪费。而具体造成了那些资源的浪费其实是没有深究的。其实中很大一部分资源，应该就是老师提到的每个线程默认的C库内存池。<br>2、堆内存比栈内存更快，其实是快在管理，而不是快在使用。malloc&#47;new时会有共享的C库内存池内加锁申请，而释放的时候，也会加锁释放，并伴随着内存碎片的整理","like_count":5},{"had_liked":false,"id":213432,"user_name":"独孤魂","can_delete":false,"product_type":"c1","uid":1495951,"ip_address":"","ucode":"8EED2E8C474575","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/8f/c429c837.jpg","comment_is_top":false,"comment_ctime":1588412306,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18768281490","product_id":100051201,"comment_content":"1、“每个子线程预分配的内存是 64MB” 这个让我有点崩溃啊，<br>2、也有些文章也说“节约线程，因为启动一个消耗2MB内存“。  <br>3、但是亲测启动200个线程，实际内存RES没有多大变化，VIRT 也只增长了1.4G，并没有12G啊？ 求解","like_count":4,"discussions":[{"author":{"id":1112955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fb/7b/2d4b38fb.jpg","nickname":"Jialin","note":"","ucode":"12583269732A75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345174,"discussion_content":"老师在文章中说了，内存池的area数和CPU核数相关，比如说64位机器上，area数=8*CPU核数。所以可以分配的虚拟内存大小为64MB*area数，并不会随着线程数增加而无限增加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611675695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211859,"user_name":"码农桃花源","can_delete":false,"product_type":"c1","uid":1070008,"ip_address":"","ucode":"55455290871D54","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/b8/63ffa8f4.jpg","comment_is_top":false,"comment_ctime":1588032233,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18767901417","product_id":100051201,"comment_content":"TCMalloc 对中等内存、大内存的分配速度很慢，比如我们用单线程分配 2M 的内存，Ptmalloc2 耗时仍然稳定在 32 纳秒，但 TCMalloc 已经上升到 86 纳秒，增长了 7 倍以上。<br><br>老师你好，这块能展开说一下吗？对中等内存、大内存，为什么 TCMalloc 慢，而 Ptmalloc2 快呢？","like_count":4,"discussions":[{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260930,"discussion_content":"可能需要看源码了，现在对C/C++的代码还是比较触。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588914072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213481,"user_name":"Ken","can_delete":false,"product_type":"c1","uid":1120761,"ip_address":"","ucode":"9F829156E855C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/f9/62ae32d7.jpg","comment_is_top":false,"comment_ctime":1588429675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14473331563","product_id":100051201,"comment_content":"内存池可以使用享元模式加速对象的初始化速度","like_count":3},{"had_liked":false,"id":228994,"user_name":"Geek3340","can_delete":false,"product_type":"c1","uid":2028953,"ip_address":"","ucode":"C64D302CD53513","user_header":"","comment_is_top":false,"comment_ctime":1592876797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10182811389","product_id":100051201,"comment_content":"有Java实例吗？Java在哪些场景下，会触发ptmalloc进行分配，然后不释放呢？","like_count":2},{"had_liked":false,"id":222425,"user_name":"李志华","can_delete":false,"product_type":"c1","uid":2003154,"ip_address":"","ucode":"FE6D9D4D1900DE","user_header":"","comment_is_top":false,"comment_ctime":1590804408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180739000","product_id":100051201,"comment_content":"关于&quot;每个子线程预分配的内存是 64MB（Ptmalloc2 中被称为 Thread Arena，32 位系统下为 1MB，64 位系统下为 64MB）&quot;, <br>假设语言是java,  <br>这里预分配的内存是java堆内存, java栈内存(这可以通过-xss限制的), 还是C库内存, 操作系统内存? ","like_count":2},{"had_liked":false,"id":236395,"user_name":"Run","can_delete":false,"product_type":"c1","uid":1371941,"ip_address":"","ucode":"6738D2F36ACFF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMDBq7lqg9ZasC4f21R0axKJRVCBImPKlQF8yOicLLXIsNgsZxsVyN1mbvFOL6eVPluTNgJofwZeA/132","comment_is_top":false,"comment_ctime":1595406347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890373643","product_id":100051201,"comment_content":"不愧是有多门课的人","like_count":1},{"had_liked":false,"id":235762,"user_name":"一凡","can_delete":false,"product_type":"c1","uid":1897395,"ip_address":"","ucode":"5E9BE33452AF3B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","comment_is_top":false,"comment_ctime":1595174886,"is_pvip":false,"replies":[{"id":"88396","content":"首次申请内存时分配的","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1596503043,"ip_address":"","comment_id":235762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5890142182","product_id":100051201,"comment_content":"每个子线程预分配的内存是 64MB<br>预分配什么意思，就是线程生成时候就分配的么？<br>","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501825,"discussion_content":"首次申请内存时分配的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596503043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219635,"user_name":"Wienbc","can_delete":false,"product_type":"c1","uid":1273712,"ip_address":"","ucode":"BF4E736B3551F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/6f/70/db94799a.jpg","comment_is_top":false,"comment_ctime":1590053923,"is_pvip":false,"replies":[{"id":"81150","content":"你好Wienbl，两个原因，1、本质上就是路程越短，速度越快。比如A-&gt;B-&gt;C，肯定没有A-&gt;C块。而B就是JVM的内存，使用它处理IO会多出一次拷贝。2、JVM内存要GC，管理成本要比堆外内存高。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1590103399,"ip_address":"","comment_id":219635,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5885021219","product_id":100051201,"comment_content":"老师好，认真看完又涨姿势了，有个问题不太明白求解：为什么不受JVM管理的堆外内存的IO速度更快呢？","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495883,"discussion_content":"你好Wienbl，两个原因，1、本质上就是路程越短，速度越快。比如A-&amp;gt;B-&amp;gt;C，肯定没有A-&amp;gt;C块。而B就是JVM的内存，使用它处理IO会多出一次拷贝。2、JVM内存要GC，管理成本要比堆外内存高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590103399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1273712,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6f/70/db94799a.jpg","nickname":"Wienbc","note":"","ucode":"BF4E736B3551F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271325,"discussion_content":"谢谢老师，明白了o(*￣▽￣*)ブ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590116701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213521,"user_name":"子不语","can_delete":false,"product_type":"c1","uid":1123186,"ip_address":"","ucode":"907AB44706467B","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/72/70190bc1.jpg","comment_is_top":false,"comment_ctime":1588447863,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5883415159","product_id":100051201,"comment_content":"老师好，在jvm里面有个限制线程栈大小的，-XX:ThreadStackSize。您文中讲的每个子线程预分配的内存是 64MB（Ptmalloc2 中被称为 Thread Arena，32 位系统下为 1MB，64 位系统下为 64MB），如果java启动参数设置了限制线程栈大小，c库还会给每个子线程分配64m内存吗。","like_count":1,"discussions":[{"author":{"id":1140792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/68/38/62dad61c.jpg","nickname":"烟雨登","note":"","ucode":"8F5E1AEE46273C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321868,"discussion_content":"理解下来应该是不会的，c内存池应该是在使用堆外内存时才有用；-XX:ThreadStackSize 是配置线程栈的大小，默认1M，一般使用不了这么多，建议调小点256K差不多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604642951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282908,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592115951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212606,"user_name":"Geek_f9c246","can_delete":false,"product_type":"c1","uid":1951950,"ip_address":"","ucode":"822D9547A6AC2D","user_header":"","comment_is_top":false,"comment_ctime":1588162421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883129717","product_id":100051201,"comment_content":"对象初始化其实在程序中是很常见的操作，如果没有内存池，那么整个代码运行效率会很低。正因为这样jvm才会自动帮我们管理内存池，既解决申请内存效率问题，也解决内存申请释放管理问题","like_count":1},{"had_liked":false,"id":212078,"user_name":"weing","can_delete":false,"product_type":"c1","uid":1984655,"ip_address":"","ucode":"95701BDA31F6F6","user_header":"","comment_is_top":false,"comment_ctime":1588058039,"is_pvip":false,"replies":[{"id":"78847","content":"不好意思，因为最初我用8MB测试，后面改回1MB，但忘了改printf提示语句了。我现在已经把它更新过来了","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588062847,"ip_address":"","comment_id":212078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883025335","product_id":100051201,"comment_content":"alloc_address.cpp 代码中，分配的是1MB，还是8MB？ 感觉应该是1MB才对呢<br>\tprintf(&quot;接下来分配8MB内存\\n&quot;);<br>\tgetchar();<br>\taddr = (char*) malloc(1*1024*1024);<br>\tprintf(&quot;分配了8MB内存\\n&quot;);","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493426,"discussion_content":"不好意思，因为最初我用8MB测试，后面改回1MB，但忘了改printf提示语句了。我现在已经把它更新过来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588062847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211751,"user_name":"kofssl","can_delete":false,"product_type":"c1","uid":1475919,"ip_address":"","ucode":"714FEE8F8DA172","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLCrSITpN0Dzic0Ao4rYjV8ULicYWCo8I6ROnwt6bk0VibX8ibJicnUo1JkYRPPlpVc1uqf7XaXicDwqpUPw/132","comment_is_top":false,"comment_ctime":1588001094,"is_pvip":false,"replies":[{"id":"78707","content":"呵呵，谢谢kofssl的夸奖。在你构建出分布式系统的完整执行路径后，相信面临其他疑难杂症时都会有明确的方向，可以google上自行找答案！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588037049,"ip_address":"","comment_id":211751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882968390","product_id":100051201,"comment_content":"确实写的很清晰，前面处理三方组件内存问题时，开始以为内存泄漏了，占用内存一点一点上去，就不释放，后来查代码也都没有明显的错误，最后是通过同事提到的内存碎片解决的，就用到了jemalloc的替换方式，同事是高手，你也是，哈哈","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493354,"discussion_content":"呵呵，谢谢kofssl的夸奖。在你构建出分布式系统的完整执行路径后，相信面临其他疑难杂症时都会有明确的方向，可以google上自行找答案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588037049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353542,"user_name":"hillcat","can_delete":false,"product_type":"c1","uid":1633032,"ip_address":"德国","ucode":"A4BA5255C53DD6","user_header":"https://static001.geekbang.org/account/avatar/00/18/eb/08/68386ded.jpg","comment_is_top":false,"comment_ctime":1659530199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659530199","product_id":100051201,"comment_content":"这一章讲的非常透啊。由此我想以PostgreSQL的IO操作，不明白为何PG到现在仍然不支持DirectIO. 导致它现在仍然在用BufferCache(应用的cache)和pagecache, 双缓存，相当于是。这对于内存的利用来讲，并不占优势。<br>也许将来的版本实现可以将DirectIO做为可选项。<br>","like_count":0},{"had_liked":false,"id":339995,"user_name":"云海","can_delete":false,"product_type":"c1","uid":1365206,"ip_address":"","ucode":"0C6CA0BE58EA21","user_header":"https://static001.geekbang.org/account/avatar/00/14/d4/d6/1d4543ac.jpg","comment_is_top":false,"comment_ctime":1648530160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648530160","product_id":100051201,"comment_content":"可以给飞行中的飞机换发动机吗？ 生产环境 不停机更换 内存分配方式。","like_count":0},{"had_liked":false,"id":303564,"user_name":"OM","can_delete":false,"product_type":"c1","uid":1302746,"ip_address":"","ucode":"E33C66A70802A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoWfXendN7czHpsyaWKLPK6Na9P5czquJ7Wdre4TibZQ5SQib88edyuib3LpCVFkp0gII2wyvvR8tEIA/132","comment_is_top":false,"comment_ctime":1626856588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626856588","product_id":100051201,"comment_content":"陶老师如果用Java开发程序那么里面使用堆或栈使用频率不好确定的吧，那怎么让堆里面的到栈中？","like_count":0},{"had_liked":false,"id":290503,"user_name":"Bravery168","can_delete":false,"product_type":"c1","uid":1232973,"ip_address":"","ucode":"DB08AEFBD6DF2B","user_header":"https://static001.geekbang.org/account/avatar/00/12/d0/4d/2116c1a4.jpg","comment_is_top":false,"comment_ctime":1619593486,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1619593486","product_id":100051201,"comment_content":"赞,有深度。TCMalloc 和 Ptmalloc2在分配大内存上的性能差异，原因能再深入剖析一下就更好了。","like_count":0},{"had_liked":false,"id":259155,"user_name":"烟雨登","can_delete":false,"product_type":"c1","uid":1140792,"ip_address":"","ucode":"8F5E1AEE46273C","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/38/62dad61c.jpg","comment_is_top":false,"comment_ctime":1604642082,"is_pvip":false,"replies":[{"id":"94436","content":"不同的应用内存池策略是不同的。比如JVM并不是透明的内存池，它严格定义了堆内存大小。如果内存池只是用于加快分配 速度，则会继续向下申请内存，最终如果内核没有足够的内存，才会报OOM错误。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1604908627,"ip_address":"","comment_id":259155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604642082","product_id":100051201,"comment_content":"“当代码申请内存时，首先会到达应用层内存池，如果应用层内存池有足够的可用内存，就会直接返回给业务代码，否则，它会向更底层的 C 库内存池申请内存“<br>如果应用没有足够的可用内存，这时候不应该直接溢出了吗？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508863,"discussion_content":"不同的应用内存池策略是不同的。比如JVM并不是透明的内存池，它严格定义了堆内存大小。如果内存池只是用于加快分配 速度，则会继续向下申请内存，最终如果内核没有足够的内存，才会报OOM错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604908627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259103,"user_name":"烟雨登","can_delete":false,"product_type":"c1","uid":1140792,"ip_address":"","ucode":"8F5E1AEE46273C","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/38/62dad61c.jpg","comment_is_top":false,"comment_ctime":1604631261,"is_pvip":false,"replies":[{"id":"94437","content":"对java来说是的","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1604908761,"ip_address":"","comment_id":259103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604631261","product_id":100051201,"comment_content":"“进程申请内存的速度，以及总内存空间都受到内存池的影响。知道这些隐藏内存池的存在，是提升分配内存效率的前提“<br>老师好，这里的内存，在java应用中特指的是堆外内存吧？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508847,"discussion_content":"对java来说是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604908761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259091,"user_name":"烟雨登","can_delete":false,"product_type":"c1","uid":1140792,"ip_address":"","ucode":"8F5E1AEE46273C","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/38/62dad61c.jpg","comment_is_top":false,"comment_ctime":1604629152,"is_pvip":false,"replies":[{"id":"94438","content":"谢谢烟雨登的分享","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1604908779,"ip_address":"","comment_id":259091,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604629152","product_id":100051201,"comment_content":"http:&#47;&#47;goog-perftools.sourceforge.net&#47;doc&#47;tcmalloc.html，有详细的性能对比测试","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508846,"discussion_content":"谢谢烟雨登的分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604908779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244350,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1090784,"ip_address":"","ucode":"563C4A71D80DA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwQvLGE4dMsF4JU0svW3DtGbodpjskbY65FdwF13JdtBYZfgL2IXHlHrdejWzHdjT0RibEIfib4QYA/132","comment_is_top":false,"comment_ctime":1598490598,"is_pvip":false,"replies":[{"id":"90256","content":"GoLang就在使用TCMalloc，许多大厂的云端服务也在使用它","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1598942930,"ip_address":"","comment_id":244350,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598490598","product_id":100051201,"comment_content":"老师，有具体的TCMalloc使用场景吗","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504561,"discussion_content":"GoLang就在使用TCMalloc，许多大厂的云端服务也在使用它","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598942930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241731,"user_name":"hello world","can_delete":false,"product_type":"c1","uid":1080180,"ip_address":"","ucode":"DC5A5FF4B15F91","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/74/a4c4838f.jpg","comment_is_top":false,"comment_ctime":1597404084,"is_pvip":false,"replies":[{"id":"89650","content":"你是说ptmalloc2默认预分配的64MB吗？已经在代码中写死了。以下是glibc2.17的源代码，供你参考：<br># if __WORDSIZE == 32<br>#  define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)<br># else<br>#  define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))<br># endif<br>DEFAULT_MMAP_THRESHOLD_MAX 在64位系统中就是32MB。<br><br>#ifndef HEAP_MAX_SIZE<br># ifdef DEFAULT_MMAP_THRESHOLD_MAX<br>#  define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)<br># else<br>#  define HEAP_MAX_SIZE (1024*1024) &#47;* must be a power of two *&#47;<br># endif<br>#endif<br>HEAP_MAX_SIZE 就是预分配的64MB内存","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1597992763,"ip_address":"","comment_id":241731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597404084","product_id":100051201,"comment_content":"预分配内存大小可以通过参数调整么？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503828,"discussion_content":"你是说ptmalloc2默认预分配的64MB吗？已经在代码中写死了。以下是glibc2.17的源代码，供你参考：\n# if __WORDSIZE == 32\n#  define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)\n# else\n#  define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))\n# endif\nDEFAULT_MMAP_THRESHOLD_MAX 在64位系统中就是32MB。\n\n#ifndef HEAP_MAX_SIZE\n# ifdef DEFAULT_MMAP_THRESHOLD_MAX\n#  define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)\n# else\n#  define HEAP_MAX_SIZE (1024*1024) /* must be a power of two */\n# endif\n#endif\nHEAP_MAX_SIZE 就是预分配的64MB内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597992763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234854,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1594813170,"is_pvip":false,"replies":[{"id":"90750","content":"1、“回到文章开头的问题，Java 已经有了应用层内存池，为什么还会受到 C 库内存池的影响呢？这是因为，除了 JVM 负责管理的堆内存外，Java 还拥有一些堆外内存，由于它不使用 JVM 的垃圾回收机制，所以更稳定、持久，处理 IO 的速度也更快。这些堆外内存就会由 C 库内存池负责分配，这是 Java 受到 C 库内存池影响的原因。”<br>2、有上限的，“并不是设置了 1000 个线程，就会预分配 60GB 的内存，子线程内存池最多只能到 8 倍的 CPU 核数，比如在 32 核的服务器上，最多只会有 256 个子线程内存池”<br>3、“然而，Java 中的 JVM 内存池已经管理了绝大部分内存，确实不能接受莫名多出来 6GB 的内存，那该怎么办呢？既然我们知道了 Ptmalloc2 内存池的存在，就有两种解决办法。”","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599616346,"ip_address":"","comment_id":234854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594813170","product_id":100051201,"comment_content":"老师，这里的6g内存池是堆在内存吧，是为100并发线程分配的吧？jvm模型中有个线程栈，不应该只会用到jvm分配的内存吗？还需要分配c库内存池为了什么目的？还有一个问题，是否只要使用线程就会有c库内存池分配，那不是并发线程一多了就会占用大量内存？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501527,"discussion_content":"1、“回到文章开头的问题，Java 已经有了应用层内存池，为什么还会受到 C 库内存池的影响呢？这是因为，除了 JVM 负责管理的堆内存外，Java 还拥有一些堆外内存，由于它不使用 JVM 的垃圾回收机制，所以更稳定、持久，处理 IO 的速度也更快。这些堆外内存就会由 C 库内存池负责分配，这是 Java 受到 C 库内存池影响的原因。”\n2、有上限的，“并不是设置了 1000 个线程，就会预分配 60GB 的内存，子线程内存池最多只能到 8 倍的 CPU 核数，比如在 32 核的服务器上，最多只会有 256 个子线程内存池”\n3、“然而，Java 中的 JVM 内存池已经管理了绝大部分内存，确实不能接受莫名多出来 6GB 的内存，那该怎么办呢？既然我们知道了 Ptmalloc2 内存池的存在，就有两种解决办法。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599616346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232159,"user_name":"kingstar","can_delete":false,"product_type":"c1","uid":2015037,"ip_address":"","ucode":"54D8F9182B2785","user_header":"","comment_is_top":false,"comment_ctime":1593876857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593876857","product_id":100051201,"comment_content":"老师，TCMalloc需要g++版本太高了，是否还有其他（比如c++11）好的内存池开源项目推荐？","like_count":0},{"had_liked":false,"id":232119,"user_name":"坤哥","can_delete":false,"product_type":"c1","uid":2053749,"ip_address":"","ucode":"E0B2C6F35EB0FD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/56/75/6bf38a1e.jpg","comment_is_top":false,"comment_ctime":1593859647,"is_pvip":false,"replies":[{"id":"85908","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1594100857,"ip_address":"","comment_id":232119,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593859647","product_id":100051201,"comment_content":"陶哥！谢谢你，收获满满的","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500518,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594100857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229552,"user_name":"Carey","can_delete":false,"product_type":"c1","uid":1295041,"ip_address":"","ucode":"D31D1ECFAE0027","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/c1/48785057.jpg","comment_is_top":false,"comment_ctime":1593056018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593056018","product_id":100051201,"comment_content":"老师说，栈容量有限，centos7默认8M，这个大小与计算机是32位还是64位无关吗？","like_count":0},{"had_liked":false,"id":228900,"user_name":"耿长学","can_delete":false,"product_type":"c1","uid":1309948,"ip_address":"","ucode":"C7A262812854D4","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/fc/1e235814.jpg","comment_is_top":false,"comment_ctime":1592835801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592835801","product_id":100051201,"comment_content":"老师，买了你好几门课程，咨询一个问题，free -m看到的used和free列只和为啥小于total，那不够的部分内存是在哪里，透明大页属于used还是cache","like_count":0},{"had_liked":false,"id":219826,"user_name":"淡漠落寞","can_delete":false,"product_type":"c1","uid":1049550,"ip_address":"","ucode":"17FF0A02D13098","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","comment_is_top":false,"comment_ctime":1590108169,"is_pvip":false,"replies":[{"id":"81198","content":"你好淡漠落寞，每个线程都会独立的8MB的栈。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1590131449,"ip_address":"","comment_id":219826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590108169","product_id":100051201,"comment_content":"栈的容量有限，如 CentOS 7 中是 8MB 字节<br>请问老师，这8MB是指一个线程8MB还是所有线程共用8MB呀？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495950,"discussion_content":"你好淡漠落寞，每个线程都会独立的8MB的栈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590131449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218834,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1589883375,"is_pvip":true,"replies":[{"id":"90923","content":"是的","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599786346,"ip_address":"","comment_id":218834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589883375","product_id":100051201,"comment_content":"用对象池 来节省 频繁创建、初始化对象造成的时间开销，<br>忆水寒提到的享元模式思想是对细粒度对象的共享和复用， <br>对象池是对享元模式的升级， 维护装载对象的池子， 提供获取、释放资源的方法。<br>感觉思考题的场景用对象池更为合适。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495591,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599786346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218424,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589800646,"is_pvip":false,"replies":[{"id":"80915","content":"wiki里解释得很全面，可以参考下：https:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589935711,"ip_address":"","comment_id":218424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589800646","product_id":100051201,"comment_content":"我看很多同学都提到了享元模式？这个到底是啥呢？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495454,"discussion_content":"wiki里解释得很全面，可以参考下：https://zh.wikipedia.org/wiki/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589935711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216367,"user_name":"OlafOO","can_delete":false,"product_type":"c1","uid":1019254,"ip_address":"","ucode":"105F8B194ED37B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/76/994a9929.jpg","comment_is_top":false,"comment_ctime":1589247197,"is_pvip":true,"replies":[{"id":"90961","content":"你好，这节课讲的东西有点多，JAVA这个例子与栈无关，只与堆内存有关。JVM中有时会不使用GC管理的内存，而直接从操作系统里申请内存，这种内存就是堆外内存。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599811746,"ip_address":"","comment_id":216367,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1589247197","product_id":100051201,"comment_content":"回到文章开头的问题，Java 已经有了应用层内存池，为什么还会受到 C 库内存池的影响呢？这是因为，除了 JVM 负责管理的堆内存外，Java 还拥有一些堆外内存，由于它不使用 JVM 的垃圾回收机制，所以更稳定、持久，处理 IO 的速度也更快。这些堆外内存就会由 C 库内存池负责分配，这是 Java 受到 C 库内存池影响的原因。<br>——<br>8+6，如果是分配在6G内存池区域的对象就不受Java gc管理了么。老师我这快有点迷惑，这里说堆外内存，后面又在讲分配堆上和栈上的区别。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494791,"discussion_content":"你好，这节课讲的东西有点多，JAVA这个例子与栈无关，只与堆内存有关。JVM中有时会不使用GC管理的内存，而直接从操作系统里申请内存，这种内存就是堆外内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599811746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282901,"discussion_content":"栈是堆外内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592115106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216301,"user_name":"小斯","can_delete":false,"product_type":"c1","uid":1120328,"ip_address":"","ucode":"DD18726396FA66","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/48/5121c471.jpg","comment_is_top":false,"comment_ctime":1589237136,"is_pvip":false,"replies":[{"id":"90959","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599811239,"ip_address":"","comment_id":216301,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589237136","product_id":100051201,"comment_content":"思考题：一开始的回答，是想说内存池可以给对象初始化内存，避免后续申请会有锁的影响。<br>看了留言之后，发现专业的回答应该是：内存池中可以利用享元模式将常用的对象一直保留着，减少重复申请导致的性能的顺耗。。<br><br>学到了。<br>","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494760,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599811239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216021,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1675930,"ip_address":"","ucode":"BFA073D7CDD3FD","user_header":"https://static001.geekbang.org/account/avatar/00/19/92/9a/a3ff95cc.jpg","comment_is_top":false,"comment_ctime":1589168904,"is_pvip":false,"replies":[{"id":"90970","content":"你是说Java off-heap memory的申请方式吧？https:&#47;&#47;juejin.im&#47;post&#47;6844903710766661639这篇文章介绍了好几种，你可以试下","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599814491,"ip_address":"","comment_id":216021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589168904","product_id":100051201,"comment_content":"Java通过C库申请内存的逻辑是怎样的啊，C库6GB的内存空间都会被Java占用吗？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494641,"discussion_content":"你是说Java off-heap memory的申请方式吧？https://juejin.im/post/6844903710766661639这篇文章介绍了好几种，你可以试下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599814491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215268,"user_name":"谭俊杰","can_delete":false,"product_type":"c1","uid":1625510,"ip_address":"","ucode":"FA93EAAF5926F2","user_header":"https://static001.geekbang.org/account/avatar/00/18/cd/a6/420da5c9.jpg","comment_is_top":false,"comment_ctime":1588944319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588944319","product_id":100051201,"comment_content":"牛牛牛🐮","like_count":0},{"had_liked":false,"id":215144,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1588915118,"is_pvip":false,"replies":[{"id":"79623","content":"是的，有些难，其实能引起你的思考，我就很满意了^_^，课程外的知识更多，需要不停探索","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588926259,"ip_address":"","comment_id":215144,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1588915118","product_id":100051201,"comment_content":"求解老师的问题的答案，对java程序员来说真是需要下很深的功夫才能看到不同层面的东西。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494331,"discussion_content":"是的，有些难，其实能引起你的思考，我就很满意了^_^，课程外的知识更多，需要不停探索","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588926259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261000,"discussion_content":"前四篇文章已经反复的学习记忆了好多次，感觉这样只是学习了一些招式，其实这样已经很好，打开了一片天了，谢谢老师，就是想系统学习，又要从何开始呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588926376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214775,"user_name":"siupan","can_delete":false,"product_type":"c1","uid":1808630,"ip_address":"","ucode":"8C5DC5702507ED","user_header":"https://static001.geekbang.org/account/avatar/00/1b/98/f6/aa7ce80c.jpg","comment_is_top":false,"comment_ctime":1588817367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588817367","product_id":100051201,"comment_content":"老师，C#.dotnet 也是用的 Ptmalloc2 内存池吗？有什么好的方式进行验证？","like_count":0},{"had_liked":false,"id":213482,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1588429991,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588429991","product_id":100051201,"comment_content":"这下知道 node.js 中常说的堆外内存是什么意思了，不受v8内存的管理，原来是指底层的 c &#47; c++ 库内存池","like_count":0},{"had_liked":false,"id":213408,"user_name":"黄骏","can_delete":false,"product_type":"c1","uid":1849733,"ip_address":"","ucode":"3C41D02F4F712C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/39/85/c6110f83.jpg","comment_is_top":false,"comment_ctime":1588406134,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588406134","product_id":100051201,"comment_content":"内存池，我们在实际工作中，好像有个别称，对象池，核心就是预分配指定数量的某种数据结构的内存，应用用完了也不释放到系统，接下来的请求继续用，在用之前初始化下，这样就避免内存分配了。这个确实是高性能编程的一种方法吧。","like_count":0},{"had_liked":false,"id":213313,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1588383590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588383590","product_id":100051201,"comment_content":"老师想请教下，如果java多线程程序没有申请堆外内存，也要预分配64MB预留内存吗？另外如果我们通过-XX:MaxDirectMemorySize=40M 来限定堆外内存的大小，还会有预留内存吗？","like_count":0},{"had_liked":false,"id":213167,"user_name":"张华中-Blackc","can_delete":false,"product_type":"c1","uid":1392338,"ip_address":"","ucode":"CFDE6E945466A0","user_header":"https://static001.geekbang.org/account/avatar/00/15/3e/d2/624a3d59.jpg","comment_is_top":false,"comment_ctime":1588319992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588319992","product_id":100051201,"comment_content":"64位机子链接libtcmalloc.so时，需要libunwind<br>我虚拟机ptMalloc和TcMalloc数据对比<br>线程数      字节数      PtMalloc t&#47;ns  TcMalloc t&#47;ns<br>    1           262144        26.71                8.41<br>    2           262144        43.91               10.24<br>    40         262144        425.20             86.92<br>    1            262145        27.10                52.13<br>    10           262145       106.46              3795.66(循环分配内存10次)<br><br>留言说用到了享元模式，防止重复分配，让我想到业务层的内存池和对象池，业务层对象池是知道我要分配该对象，系统这里怎么知道分配的对象是我要的呢？什么原理来进行标识的？<br>","like_count":0},{"had_liked":false,"id":212851,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1588224909,"is_pvip":false,"replies":[{"id":"79142","content":"是的，比如第17讲提到的protobuf内存池就是用了这个原理","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588408265,"ip_address":"","comment_id":212851,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588224909","product_id":100051201,"comment_content":"涨姿势涨姿势，但是还是有点懵逼。老师把策略都讲了，还是感觉意犹未尽。所以是否可以理解为，如果想提升内存空间分配效率的话，根据实际场景去选择合适的内存池就行了？<br><br>看来可课下还得再补充一下能量，动手查查看，配一下试试","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493626,"discussion_content":"是的，比如第17讲提到的protobuf内存池就是用了这个原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588408265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212161,"user_name":"alan","can_delete":false,"product_type":"c1","uid":1083425,"ip_address":"","ucode":"2CA8D0B6B7D5A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/21/50b2418a.jpg","comment_is_top":false,"comment_ctime":1588068910,"is_pvip":false,"replies":[{"id":"78953","content":"你好 alan，每种java虚拟机都有自己独特的垃圾回收机制，有时为了时间更快就会牺牲更多的内存空间，这是正常的，我建议在服务器上长时间运行的java进程，一定要通过Xmx去明确内存占用，内存不可控很麻烦.","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588145616,"ip_address":"","comment_id":212161,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1588068910","product_id":100051201,"comment_content":"老师好，这节课真好，第一次了解到内存池也是有层次的。我遇到一个问题想请教一下：我有一个和数据库交互的groovy程序，运行起来后会占用很大内存，启动时，将Xmx设置为多少，该程序的内存占用就不会超过Xmx指定的上限。比如，Xmx=10g，程序就稳定占10g内存，但如果不限制的话，最高见过占用30G左右。这个您觉得有什么可能的原因吗？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493445,"discussion_content":"你好 alan，每种java虚拟机都有自己独特的垃圾回收机制，有时为了时间更快就会牺牲更多的内存空间，这是正常的，我建议在服务器上长时间运行的java进程，一定要通过Xmx去明确内存占用，内存不可控很麻烦.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588145616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251543,"discussion_content":"xmx是限制jvm堆最大大小，如果不限制，jvm会在一定条件下自动扩大jvm堆大小，内存占用自然而然就大了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588087529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211953,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1588040385,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588040385","product_id":100051201,"comment_content":"学到了一个新的名词享元模式，内存池是堆上分配的内存，可以在内存池里维护常用对象的cache，这样新生成对象时就可以直接拿来复用，初始化时可以减少初始化的成员变量","like_count":0},{"had_liked":false,"id":211761,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1588001920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588001920","product_id":100051201,"comment_content":"以前写c程序，会习惯性的使用bzero或memset初始化结构体数据。因为申请的里面可能有历史数据，使用不当会有莫名其妙的问题。<br>现在的golang所有未赋值的变量都会是默认值。<br>（也许有人会觉得go这个操作有点多余。）<br><br>在golang中，内存池对于初始化对象有没有什么帮助就不知道了。","like_count":0}]}