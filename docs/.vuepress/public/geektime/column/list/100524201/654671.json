{"id":654671,"title":"36｜快速排序：如何通过基准元素改进冒泡排序？","content":"<p>你好，我是王健伟。</p><p>前面我们一起学习了交换类排序中的冒泡排序，这次我们继续学习交换类排序中的快速排序。这两种排序算法的主要区别在于排序的效率和实现代码。</p><p>如果说冒泡排序是通过相邻元素的比较和交换达成排序，那么快速排序就是一种分而治之的思想，是对冒泡排序的改进。</p><h2>快速排序基本概念</h2><p>快速排序的英文名称是Quick Sort，他通过分而治之的思想，把待排序的表分隔成若干个子表，每个子表都以一个称为枢轴的元素为基准进行排序。</p><p>一般来说，在元素数量一定的内部排序算法中，快速排序算法平均性能是最优秀的，因此，C++标准库中也提供了qsort函数来实现快速排序功能（其实qsort的实现版本中，还可能会用到其他排序）。</p><p>快速排序的基本思想（按照从小到大排序）我们分两点说一下。</p><p>第一点，在待排序的表中选取任意一个元素作为<strong>枢轴</strong>（也叫<strong>基准元素</strong>），这个元素通常是首元素。之后，通过<strong>一趟排序</strong>将所有关键字小于枢轴的元素都放置在枢轴前面，大于枢轴的元素都放置在枢轴后面。</p><p>这样，这趟排序就将待排元素<strong>分割</strong>成了两个独立的部分。而且这个时候，枢轴元素所在的位置其实也就是该元素<strong>最终</strong>应该在的位置了。</p><p>现在核心的问题是如何实现这趟排序，这也是理解快速排序的最关键之处。基本做法是，引入两个指针low和high，low指针初始时指向待排序表最左侧元素，high指针初始指向待排序表最右侧元素。</p><!-- [[[read_end]]] --><ul>\n<li>首先，从high所指位置开始向前（向左侧）搜索，找到第一个关键字小于枢轴的记录并和枢轴记录交换。</li>\n<li>接着，从low所指位置开始向后（向右侧）搜索，找到第一个关键字大于枢轴的记录并和枢轴记录交换。</li>\n<li>最后，重复上面这两个步骤，直到low和high指向相同的位置。</li>\n</ul><p>我们以图1为例来说明。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/7f/a074cf03fc4a0fda03345ea7d8f0c47f.jpg?wh=1920x1132\" alt=\"图片\" title=\"图1 快速排序第一趟排序步骤\"></p><p>从图1可以看到这么几件事。</p><ul>\n<li>选择的枢轴为数组中第一个元素（值16），开始时low和high分别指向下标0和下标9的位置。</li>\n<li>high位置发现元素值10&lt;枢轴，因此元素10和16交换位置，如子图1。</li>\n<li>low向后搜索，发现下标为2的位置元素45&gt;枢轴，因此元素16和45交换位置，如子图2。</li>\n<li>high向前搜索，发现下标为5的位置元素2&lt;枢轴，因此元素2和16交换位置，如子图3。</li>\n<li>low向后搜索，发现下标为3的位置元素23&gt;枢轴，因此元素16和23交换位置，如子图4。</li>\n<li>high向前搜索，搜索到与low相同的位置（下标为3），本趟排序结束。</li>\n</ul><p>不难发现，本趟排序后，枢轴（元素）16所在的位置就是其最终应该在的位置。元素16左侧的元素都小于16，元素16右侧的元素都大于16。现在，枢轴16把待排序的表划分成了两个子表——子表1包含10、1、2共3个元素，子表2包含99、23、18、67、42、45共6个元素，如子图5。</p><p>好，再说<strong>第二点：再次用相同的方法对两个独立的子表做相同的分割</strong>。这种子表的分割其实是一个递归的过程，每次分割后子表中的元素数量都会减少，一直到每个独立的子表中只包含一个元素为止。此时，所有元素就都会被放在最终的位置上。</p><p>其实，我这里针对快速排序算法的描述中，枢轴所代表的元素会频繁地与其他元素交换位置，这样做并没有必要，只需要把枢轴元素记录下来，等一趟排序结束时，用low和high指针指向的那个位置保存枢轴元素即可，这样可以进一步提升快速排序算法的执行效率。注意，low和high指针指向的位置是相同的，这个位置也是整个排序完成后枢轴元素最终所在的位置。</p><h2>实现代码</h2><p>下面，让我们一起看一看快速排序的实现代码吧。</p><pre><code class=\"language-plain\">//分割函数：一趟快速排序的实现函数。该函数是快速排序算法实现的核心函数，返回枢轴位置下标\ntemplate&lt;typename T&gt;\nint Partition(T myarray[], int low, int high) //low：低位置。high：高位置\n{\t\n\tstatic int icount = 0;\n\ticount++;\n\tcout &lt;&lt;\"【当前Partition调用的次数是：\"&lt;&lt; icount &lt;&lt;\"】\"&lt;&lt; endl;\n\t\n\t//选取枢轴，就用最低位置指向的元素（首元素）作为枢轴即可\n\tT pivot = myarray[low]; //把枢轴保存起来\n\twhile (low &lt; high )\n\t{\t\t\t\n\t\t//先从高位置来\n\t\twhile (low &lt; high &amp;&amp; myarray[high] &gt;= pivot)&nbsp;\n\t\t\thigh--;\n\t\t\n\t\tif (low == high) //如果原始集合已经是从小到大排序，这个条件就会成立\n\t\t\tbreak;\n\t\t\n\t\tif(low &lt; high)\n\t\t\tmyarray[low] = myarray[high];\n\t\t\n\t\t//再从低位来\n\t\twhile (low &lt; high &amp;&amp; myarray[low] &lt; pivot)\n\t\t\tlow++;\n\t\t\n\t\tif (low == high) //如果原始集合已经是从大到小排序，这个条件就会成立\n\t\t\tbreak;\n\t\t\n\t\tif (low &lt; high)\n\t\t\tmyarray[high] = myarray[low];\n\t\t\n\t} //end while (low &lt; high)\n\t\n\tmyarray[low] = pivot; //此时low与high相等\n\treturn low;\n}\n\t\ntemplate&lt;typename T&gt;\nvoid QuickSort(T myarray[], int low, int high,int length,int lvl=1) //lvl用于统计递归调用深度\n{\n\t//断言low值一定是小于high值的\n\tassert(low &lt; high); //记得#include &lt;assert.h&gt;\n\t\n\t//调用者要保证low &lt; high\n\tcout &lt;&lt;\"【当前QuickSort递归调用深度是：\"&lt;&lt; lvl &lt;&lt;\"层】\" ;\n\t\t\t\t\t\n\tint pivotpos = Partition(myarray, low, high);&nbsp; //分割函数\n\t//输出中间结果看看：\n\tcout &lt;&lt;\"low = \"&lt;&lt; low &lt;&lt;\";high = \"&lt;&lt; high &lt;&lt;\";枢轴位置 = \"&lt;&lt; pivotpos &lt;&lt;\"。本趟快排结果为：\";\n\tfor (int i = 0; i &lt; length; ++i)&nbsp;\n\t\tcout &lt;&lt; myarray[i] &lt;&lt;\"\";\n\tcout &lt;&lt; endl;\n\t\t\n\tif(low &lt; (pivotpos - 1))\n\t\tQuickSort(myarray, low, pivotpos - 1,length,lvl+1);//枢轴左侧子表做快速排序，即继续分割\t\n\t\n\tif((pivotpos + 1)&lt; high)\n\t\tQuickSort(myarray, pivotpos + 1, high,length,lvl+1);//枢轴右侧子表做快速排序，即继续分割\n\t\n\treturn;\n}\n\n//快速排序（从小到大）\ntemplate&lt;typename T&gt;\nvoid QuickSort(T myarray[], int length)\n{\n\tif (length &lt;= 1) //不超过1个元素的数组，没必要排序\n\t\treturn;\n\t\n\tint low = 0;&nbsp; //低位置\n\tint high = length - 1; //高位置\n\t\n\t//调用重载函数\n\tQuickSort(myarray, low, high, length); //传递length值是为了显示中间的输出结果方便\n}\t\n</code></pre><p>在main主函数中，对代码做一些调整，调整后的代码为：</p><pre><code class=\"language-plain\">int arr[] = {16,1,45,23,99,2,18,67,42,10};\nint length = sizeof(arr) / sizeof(arr[0]);&nbsp; &nbsp;//数组中元素个数\nQuickSort(arr, length);//对数组元素进行快速排序\ncout &lt;&lt;\"快速排序结果为：\";\nfor (int i = 0; i &lt; length; ++i)\n{\n\tcout &lt;&lt; arr[i] &lt;&lt;\" \";\n}\ncout &lt;&lt; endl; //换行\n</code></pre><p>执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/8c/02/8cbfc4d731d542341f8487c75d75a002.png?wh=1083x573\" alt=\"图片\"></p><h2>快速排序算法效率分析</h2><p>从代码和显示的结果可以看到，Partition是核心的分割函数，一共被调用了七次。而递归函数QuickSort也被调用了七次，但这个递归函数所达到的最大深度是五层。</p><p>第一次Partition调用会将数组中的n个元素，也就是从low到high之间的数据全部扫描一次，时间复杂度为O(n)。第二次、第三次……，调用Partition函数所需要扫描的数据会越来越少，都会&lt;n，所以每次调用Partition的时间复杂度都不会超过O(n)。</p><p>以前面的图1为基础，你可以先仔细阅读和分析上面的源码，然后我们把分割步骤逐步拆解，得到图2：</p><p><img src=\"https://static001.geekbang.org/resource/image/76/4a/76e7fb459411b28876e2f9169a8b844a.jpg?wh=1920x983\" alt=\"图片\" title=\"图2 快速排序中调用Partition函数对数组元素的逐步分割展示\"></p><p>这里详细说一下图2。从上向下，针对数组{16,1,45,23,99,2,18,67,42,10}进行了怎么样的排序过程呢？</p><ul>\n<li>第一次调用Partition分割，元素16将整个数组分割成了两块，第一块包括元素10、1、2，第二块包括元素99、23、18、67、42、45。</li>\n<li>第二次调用Partition分割（第几次调用该函数如图中圆形编号所示），元素10将数组（这里的数组当然是上面已经分割开的子数组）分割出了第三块，第三块包含元素2、1。</li>\n<li>第三次调用Partition分割，元素2将数组分割出了第四块，第四块包含元素1。</li>\n<li>第四次调用Partition分割，元素99将数组分割出了第五块，第五块包含元素45、23、18、67、42。</li>\n<li>第五次调用Partition分割，元素45将数组分割出了第六块和第七块，第六块包含元素42、23、18，第七块包含元素67。</li>\n<li>第六次调动Partition分割，元素42将数组分割出了第八块，第八块包含元素18、23。</li>\n<li>第七次调用Partition分割，元素18将数组分割出了第九块，第九块包含元素23。</li>\n<li>至此，调用了七次Partition进行分割后，整个快速排序执行完毕。</li>\n</ul><p>上面说过，递归函数QuickSort被调用了七次，所达到的最大深度是五层。其实，通过统计Partition被调用的次数来求解快速排序算法的时间复杂度，与通过统计QuickSort递归函数的调用深度来求解快速排序算法的时间复杂度是一回事。</p><p>所以，整个快速排序算法的时间复杂度为O(n*递归调用深度)，这意味着快速排序算法的时间复杂度可以看成是和递归层数紧密相关。当然，快速排序算法的空间复杂度也和递归层数相关，因为每次递归都会用到栈空间来暂存很多信息。所以，快速排序算法的空间复杂度为O(递归调用深度)。</p><p>因为每次递归调用QuickSort都会把当前需要处理的区间再次划分成左右两个子区间。所以图2换一种绘制方式其实可以变成一棵二叉树，如图3所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/63/b0605228e0bf70be6bd137f726f11463.jpg?wh=1920x762\" alt=\"图片\" title=\"图3 快速排序针对每一层QuickSort函数的递归调用后对数组元素的分割可以组织成一棵二叉树\"></p><p>图3中，快速排序把数组中的n个元素组织成了一棵二叉树，二叉树的层数也就代表着递归调用的深度。所以<strong>快速排序算法的递归调用深度问题就可以转换为对二叉树高度范围的判断。</strong></p><p>前面曾经讲过，对于有n个节点的二叉树，它的最小高度是⌊$log_{2}^{n}$⌋ +1，最大高度是n（斜树）。所以，对于快速排序算法，最少的递归深度（递归层数）应该是⌊$log_{2}^{n}$⌋ +1，而最大的递归深度应该是n，才可以完成整个排序过程。</p><p>所以，根据前面所说——整个快速排序算法的时间复杂度为O(n*递归调用深度)。不难看到，快速排序算法最好情况时间复杂度为O(n$log_{2}^{n}$)，最坏情况时间复杂度为O($n^{2}$)，平均情况时间复杂度为O(n$log_{2}^{n}$)。而因为快速排序算法的空间复杂度为O(递归调用深度)，所以快速排序算法最好情况空间复杂度为O($log_{2}^{n}$)，最坏情况空间复杂度为O(n)，平均情况空间复杂度为O($log_{2}^{n}$)。</p><p>设想一下，如果每一趟快速排序选中的枢轴都能够将数组元素均匀的划分为两个部分，那么调用QuickSort递归的深度就会最小，算法效率就会达到最高。 但如果数组元素原本就是有序（顺序逆序都可以）的，比如数组元素是int arr[] = { 1,2,3,4,5,6,7,8,9,10 };，那么此时枢轴就完全无法将数组元素做均匀划分，此时递归调用的深度将达到9层，此时的算法效率会达到最低。</p><p>换句话说，如果给定的数组原本就是有序的（顺序或者逆序），此时快速排序算法的性能最差。这也称为快速排序算法的退化，退化成了冒泡排序算法。</p><p>试一试，如果以数组元素int arr[] = { 1,2,3,4,5,6,7,8,9,10 };做一下快速排序测试，看一看程序运行结果是什么，结果如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/5a/fa9eee80c7914ef39d4aed48a39dee5a.png?wh=1072x719\" alt=\"图片\"></p><p>好了，现在我们已经知道了什么时候快速排序算法的效率会达到最高或者最低，也明确了快速排序算法效率的好坏和所选择的枢轴关系密切。你会发现，目前的程序代码中，直接选择low指针所在位置的数组元素作为枢轴，是很难保证该值的大小正合适的。所以，我们可以对快速排序算法做一下优化，<strong>优化的思路主要是围绕枢轴的选取</strong>，有两种选取方案。</p><ul>\n<li>在待排序序列中选择开头、中间、末尾三个位置的元素并从这三个元素中取中间值作为枢轴。</li>\n<li>随机的在待排序序列中选择一个元素作为枢轴。</li>\n</ul><p>这两个方案能够在很大程度上改善快速排序算法在最坏情况下的性能，你可以尝试自己修改代码来实现这个需求。当然，快速排序算法还有其他的优化手段，如果有兴趣，你还可以通过搜索引擎了解。</p><p>最后，我想问你一个问题：快速排序算法的稳定性如何呢？</p><p>我们来看这么一组数据：{3,2,2}，排序后输出结果是{2,2,3}，但其实这两个2已经是互换位置的了。</p><p>所以，为了追踪算法的稳定性，我也对原有快速排序算法的代码增加了点内容：给排序后输出的数据元素增加一个下标。你可以参考这里<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/38%EF%BD%9C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E6%94%B9%E8%BF%9B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/MyProject.cpp\">提供的代码</a>。另外，也许你认为通过修改算法的代码能把快速排序算法写成稳定算法，我测试似乎是无法做到，如果你做到了，也欢迎你随时和我交流，非常感谢！</p><h2>小结</h2><p>本节详细介绍了快速排序算法。快速排序算法是对冒泡排序算法的改进。</p><p>快速排序算法需要在待排序的表中选取任意一个元素作为枢轴，通过一趟排序将所有关键字小于枢轴的元素都放置在枢轴前面，大于枢轴的元素都放置在枢轴后面，那么此时枢轴元素的所在的位置就是该元素最终应该在的位置。</p><p>枢轴会把待排序的表划分成两个子表，然后再次用相同的方法对两个独立的子表做相同的分割。重复这种子表的分割过程。因为每次分割后子表中的元素数量都会减少，那么一直到每个独立的子表中只包含一个元素为止。此时，所有元素就都会被放在最终的位置上，快速排序算法结束。</p><p>接着我们重点分析了快速排序算法的时间复杂度和空间复杂度问题，有两个结论你可以重点记忆一下。</p><ul>\n<li>快速排序算法最好情况时间复杂度为O(n$log_{2}^{n}$)，最坏情况时间复杂度为O($n^{2}$)，平均情况时间复杂度为O(n$log_{2}^{n}$)。</li>\n<li>最好情况空间复杂度为O($log_{2}^{n}$)，最坏情况空间复杂度为O(n)，平均情况空间复杂度为O($log_{2}^{n}$)。</li>\n</ul><p>在这节课的最后，我们还针对快速排序算法给出了两种方案以对算法做出进一步的优化，并给出了快速排序算法是不稳定算法的结论。</p><p>总结：快速排序算法的基本思想是一种分治的思想，也就是将一个大的问题拆分成多个小的问题，并通过递归的方式来解决这些小问题。</p><h2>思考题</h2><ol>\n<li>\n<p>请利用本节课编写的代码，对以下数组进行排序并输出排序结果：<br>\n{ 99，12，46，38，64，33，22，101，50，72 }。</p>\n</li>\n<li>\n<p>请分析快速排序算法的时间复杂度和空间复杂度，并给出如何进行优化的方案。</p>\n</li>\n</ol><p>欢迎你在留言区和我分享成果。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p>","neighbors":{"left":{"article_title":"35｜冒泡排序：大数下沉，小数上浮","id":653954},"right":{"article_title":"37｜简单选择排序与堆排序：多趟排序与利用有序完全二叉树进行排序","id":655458}},"comments":[{"had_liked":false,"id":396605,"user_name":"胡铭旭","can_delete":false,"product_type":"c1","uid":2272685,"ip_address":"湖北","ucode":"6123C7AAE12789","user_header":"https://static001.geekbang.org/account/avatar/00/22/ad/ad/75e4ca74.jpg","comment_is_top":false,"comment_ctime":1735092157,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"为什么说“通过统计 Partition 被调用的次数来求解快速排序算法的时间复杂度，与通过统计 QuickSort 递归函数的调用深度来求解快速排序算法的时间复杂度是一回事”？\n Partition 被调用的次数比递归深度要大啊，是因为Partition 被调用的次数跟递归深度是一个数量级，被忽略了吗？","like_count":0}]}