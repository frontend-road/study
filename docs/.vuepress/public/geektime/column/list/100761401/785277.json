{"id":785277,"title":"22｜自动内存管理：把程序员从内存缺陷的海洋里解放出来","content":"<p>你好，我是海纳。</p><p>在前边的课程中，我们对于对象的创建和释放是比较随意的，完全没有理会内存泄漏的问题。现在，虚拟机的大部分功能都已经搭建完了，是时候回过头来解决这个问题了。</p><p>之前，我曾提到过，解释器并不知道一个对象从操作数栈上拿出来以后，是不是还在其他地方被引用着（例如全局变量表等），所以就无法武断地使用 delete 来释放一个对象。为了解决这个问题，这节课我们就引入自动内存管理技术。</p><h2>自动内存管理</h2><p>自动内存管理的研究开始得比较早。上个世纪60年代，就已经有很多优秀的成果了。经过不断发展，直到今天，自动内存管理技术仍然是一个很热门也很重要的研究方向，每年都有不同的改进在各种会议上被提出来，在各种带有自动内存管理的编程语言社区里（如Java、Go），这也是一个大家普遍关心的技术点。</p><p>在研究自动内存管理算法的时候，人们经常把不存活的对象叫做垃圾（Garbage），所以自动内存管理技术在很多时候也被大家叫做垃圾回收技术（GC, Garbage Collection）。</p><p>GC算法中最重要的两个角色就是<strong>Mutator和Collector</strong>。</p><ul>\n<li><strong>Mutator</strong></li>\n</ul><p>Mutator的本义是改变者。这个词所表达的是通过程序来改变对象之间的引用关系。因为我们所写的所有 Python 代码，都有可能改变对象的存活和死亡状态，以及它们之间的引用关系，那么这些 Python 代码就是Mutator。</p><!-- [[[read_end]]] --><p>在多线程场景中，这些代码往往运行在业务线程中，所以在某些情况下，Mutator和业务线程这两个术语是可以混用的。在这节课中，我们使用Mutator这个术语。</p><ul>\n<li><strong>Collector</strong></li>\n</ul><p>Collector用于回收空间中的垃圾，所以叫做收集者。根据不同的GC算法，Collector的作用不仅仅是收集，比如在Mark-Sweep中，它还负责标记存活对象、识别垃圾对象。执行Collector的线程，一般叫做Collector线程或者GC线程。在某些GC算法中，业务线程也有可能帮助做垃圾回收的工作。所以，Mutator和Collector只是一种相对的说法，而不是精确的概念。</p><p>此外我们还需要理解堆的概念。由编程语言虚拟机管理起来的内存统称为虚拟机堆，在 Python 这个场景中，人们就会简称为 Python 堆，便于和进程堆进行区分。</p><p>进程堆是指进程中可以使用malloc和free进行分配和释放的一块用户态内存区域。而 Python 堆则专指创建普通 Python 对象的地方，这一段内存是由虚拟机所管理的。</p><p>最后一个要深入理解的概念是栈。函数调用的时候，虚拟机会不断地创建函数栈帧，每一层调用对应一个栈帧，这部分内存是栈空间。mutator 其实就活跃在这些内存空间里。你可以结合<a href=\"https://time.geekbang.org/column/article/774417\">第 8 节课</a>的内容，深入理解栈的概念。</p><p>明确了这些概念以后，我们就可以学习 GC 算法并从中找一个最合适的，然后实现它，让它帮我们把虚拟机里的内存全部掌管起来。</p><h2>引用计数算法</h2><p>我们介绍的第一种垃圾回收算法是<strong>引用计数</strong>。引用计数法是实现起来最简单的GC算法。在流行的编程语言中，CPython 虚拟机以及 swift 里都使用了引用计数法。</p><p>GC 算法一个重要的功能是要识别出内存中的哪些对象是垃圾。从定义来看，所谓垃圾对象，就是不再被其他对象所引用的对象。从这个定义出发，我们可以想办法统计一个对象是否被引用。如果它被引用的次数大于0，那它就是一个活跃对象；如果它被引用的次数为0，那它就是一个垃圾对象。</p><p>为了记录一个对象有没有被其他对象引用，我们可以在每个对象的头上添加一个叫做计数器的东西，用来记录有多少其他对象引用了它。Mutator在执行的时候会改变这个计数值，你可以看一下示例代码。</p><pre><code class=\"language-java\">A objA = new A();\nB objB = new B();\nobjA.ref = objB;\n</code></pre><p>执行到第三行的时候，它的引用关系就是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/73/fd/734ce05ed2df3f9f195cf1fd5a77dbfd.png?wh=1772x606\" alt=\"\"></p><p>在这段代码中，第1行创建了一个对象，我们记为对象a，objA这个变量指向对象a，所以这个对象的引用计数就是1。第2行创建了一个B对象，记为对象b，objB变量指向对象b，这个时候，它的引用计数为1；第3行objA的ref属性也指向对象b，所以对象b的引用计数最终是2。</p><p>Mutator在运行中还会不断地修改对象之间的引用关系，我们知道这种引用关系的变化都是发生在赋值的时候。比如，接着上面的例子，我们再执行这样一行代码：</p><pre><code class=\"language-plain\">objA.ref = null\n</code></pre><p>那么从objA到objB的引用就消失了，也就是图里那个从A的ref指向B的箭头就消失了。</p><p>以Python为例，赋值语句最终会被翻译成 STORE_XX 指令，那么我们就可以在执行 STORE 指令的时候，做一些手脚了。如果使用伪代码表示出来，就是这样的：</p><pre><code class=\"language-c++\">void do_oop_store(Value * obj, Value value) {\n&nbsp; &nbsp; inc_ref(&amp;value);\n&nbsp; &nbsp; dec_ref(obj);\n&nbsp; &nbsp; obj = &amp;value;\n}\n\nvoid inc_ref(Value * ptr) {\n&nbsp; &nbsp; ptr-&gt;ref_cnt++;\n}\n\nvoid dec_ref(Value * ptr) {\n&nbsp; &nbsp; ptr-&gt;ref_cnt--;\n&nbsp; &nbsp; if (ptr-&gt;ref_cnt == 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; collect(ptr);\n&nbsp; &nbsp; &nbsp; &nbsp; for (Value * ref = ptr-&gt;first_ref; ref != null; ref=ref-&gt;next)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dec_ref(ref);\n&nbsp; &nbsp; }\n}\n</code></pre><p>也就是说，在把 value 赋值给 obj 这个指针之前，我们可以先改变一下这两个对象的引用计数。</p><p>上面的代码展示了在把 value 赋值给 obj 这个指针之前，我们必须先改变两个对象的引用计数。一个是obj指针原来指向的对象，它的引用计数要减一，另一个是value对象，它的引用计数加一。如果某个对象的引用计数为0，就把这个对象回收掉，然后把这个对象所引用的所有对象的引用计数减1。注意，collect方法负责回收内存，根据GC算法的不同，collect的实现会有所不同，所以这里我们只要知道它的功能即可，不必在意它的实现。</p><p>我们在写一个对象的域的时候做了一些工作，就好比在更新对象域的时候，对这个动作进行了拦截。所以，GC中对这种特殊的操作起了一个比较形象的名字叫write barrier。这里的barrier是屏障、拦截的意思，中文翻译就是写屏障。</p><p>那在do_oop_store里，可不可以先做减，后做加呢？就是说第2行和第3行的先后顺序换过来有没有影响呢？答案是不行。因为当obj和value是同一个对象的时候，如果先减后加的话，这个对象就会被回收，内存有可能会被破坏。那么，这个对象就有可能发生数据错误。</p><p>到这里，引用计数算法的基本原理就讲完了。接下来，我们分析一下这种GC算法有什么样的优缺点，这样我们就能知道它适合用在什么场景中了。</p><p>从算法描述中容易推断出来，<strong>引用计数可以立即回收垃圾</strong>。因为每个对象在被引用次数为0的时候，是立即就可以知道的，所以一旦一个对象成为垃圾，它将立即被释放。此外，<strong>引用计数没有暂停时间</strong>。对象的回收根本不需要另外的GC线程专门去做，业务线程自己就搞定了，所以引用计数算法不需要停顿时间。</p><p>同时，引用计数也存在一些缺点。比如<strong>在每次赋值操作的时候都要做额外的计算</strong>。在多线程的情况下，为了正确地维护引用计数，需要同步和互斥操作，这往往需要通过锁来实现，这会给多线程程序性能带来比较大的损失。</p><p>其次，<strong>会有链式回收的情况</strong>。比如多个对象对链表形式串在一起，它们的引用计数都为1，当链表头被回收时，整个链表都会回收，这可能会导致一次回收所使用的时间过长。</p><p>另外，引用计数还容易引起<strong>循环引用</strong>的问题。如果 objA引用了objB，objB也引用了objA，但是除此之外，再没有其他的地方引用这两个对象了，这两个对象的引用计数就都是1。这种情况下，这两个对象是不能被回收的。如果说上面两条缺陷还可以克服的话，那么循环引用就是比较致命的。</p><p>在使用引用计数算法进行内存管理的语言中，比如Python和Swift，都会存在循环引用的问题。Python在引用计数之外，另外引入了三色标记算法，保证了在出现循环引用的情况下，垃圾对象也能被正常回收。</p><p>为了系统性地解决循环引用的问题，一类基于引用追踪的垃圾回收算法便应运而生了。</p><h2>基于引用追踪的垃圾回收算法</h2><p>接下来，我们重点关注垃圾回收的另外一个大类，也就是基于引用追踪的垃圾回收算法，简称Tracing GC。这类算法的特点是以根集合（root sets）作为起始点进行图的遍历，如果从根集合到某个对象是可达的，那么这个对象就叫做可达对象，也就是还活着的对象，否则就是不可达对象，可以被回收。</p><p>可以说主流的垃圾回收器都全部或者部分地使用了 Tracing GC，比如Hotspot、CPython、V8、ART等等。</p><p>我们在讨论 GC 算法时，都会遇到根集合这个概念。根集合是 GC 算法开始的地方，是指向对象的指针的起始点。在垃圾回收算法开始的时候，我们明确地知道某个对象是存活的，那它就可以认为是一个根对象。比如，所有的 FrameObject 就肯定是活跃对象，虚拟机的各种内建类型对象也是活跃对象，所以它们就应该被加入到根集合里。</p><p>根集合可以这样定义：<strong>所有不在堆里，指向堆内对象的引用的集合</strong>。我们来看个具体的例子。</p><pre><code class=\"language-python\">def buildObj():\n\tobjA = A()\n\tobjB = B()\n\tobjC = C()\n\n\tobjA.b = objB\n\tobjB.a = objA\n\n\tobjA.c = objC\n</code></pre><p>在这个例子中，当虚拟机执行到 buildObj 函数的时候，objA、objB、objC 在内存中的实际情况，你可以看一下示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/7d/86642eb21b73b6309eac43ca2d6b9d7d.png?wh=2214x944\" alt=\"\"></p><p>左边代表了栈空间，从栈上出发有三个指针指向堆里。前面我们已经解释过，栈里的对象都是活跃对象，所以从栈上出发，指向堆里的引用，就应该被放到根集合中。从根集合开始进行深度优先搜索，所有可以访问到的对象都是活跃对象，而访问不到的对象就是垃圾了，需要及时释放掉。</p><p>当 buildObj 执行完了以后，buildObj 所对应的栈空间就全部被回收掉了，也就是说图里的三个指针都消失了，那么堆里的这些对象，也就是 objA、objB、objC 就再也访问不到了。</p><p>Mark-Sweep 算法是 Tracing GC 的一个典型的算法。接下来，我就以这个算法为例来讲解 Tracing GC 的具体思路。就像它的名字所指示的，这个算法分为<strong>标记</strong>和<strong>清除</strong>两个步骤。</p><ul>\n<li><strong>标记（Mark）</strong></li>\n</ul><p>标记就是从根集合出发，根据对象之间的引用关系在整个图中进行搜索，能访问到的对象就标记为活跃的。基于此，我们就为每个对象添加一个额外的域来记录这个对象是否存活。</p><p>搜索的过程可以是深度优先遍历，也可以是广度优先遍历。等到遍历结束的时候，所有存活的对象就都被标记过了，而所有的不可达对象，也就是变成垃圾的对象都没有被标记。</p><p>这就是 Tracing GC 的标记阶段。这部分的核心在于<strong>对象图的遍历</strong>。</p><ul>\n<li><strong>清除（Sweep）</strong></li>\n</ul><p>清除阶段的主要任务是回收未标记的那些对象所占的空间。具体来说，看下面这张图，假如灰色的对象都是存活对象，而白色的对象都是垃圾。那么我们该怎样回收这两块空间呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/66/df/66210ef222d0e86a96ece837530cc2df.png?wh=1772x606\" alt=\"\"></p><p>维护这个信息最合适的数据结构应该就是链表了。在清除的阶段，我们从头开始逐个访问对象，如果一个对象被标记了，那就什么也不做（当然，要把标记信息清除一下，以备下一次 GC 时可用）。如果一个对象未被标记，例如图里的两个白色对象，那就把它们的起始地址和大小记录到一个链表中去就可以了。由于这个链表记录了未使用的空间，所以它有一个专门的名字叫 freelist。</p><p>这个算法，可以用以下伪代码来描述。</p><pre><code class=\"language-c++\">sweep() {\n&nbsp; &nbsp; p = heap_start;\n&nbsp; &nbsp; while (p &lt; heap_end) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (p.is_mark())\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.clear_mark();\n&nbsp; &nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collect(p);\n\n&nbsp; &nbsp; &nbsp; &nbsp; p += p.size();\n&nbsp; &nbsp; }\n}\n\ncollect(obj) {\n&nbsp; &nbsp; last_free_chunk = free_list.last_chunk();\n&nbsp; &nbsp; if (last_free_chunk.end() == obj)\n&nbsp; &nbsp; &nbsp; &nbsp; last_free_chunk.inc_size(obj.size());\n&nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; free_list.add_chunk(new chunk(obj, obj.size()));\n}\n</code></pre><p>collect 函数会把一块不使用的内存放到链表里，如果这块内存与链表中的最后一项靠在一起，也就是说有连续的两个对象一起被回收了，那就只要相应地增加 free_chunk 的 size 就可以了，这样就可以把两个对象的空间合并在一起。如果是分离的，那就再创建一个新的chunk，挂到链表中。</p><p>最后，我们再看一下对象的分配的问题。由于堆里未使用的空间都使用freelist管理起来了。在创建对象的时候去堆里分配内存，就需要去空闲链表中找一块可用的空间，分配给这个新的对象。</p><p>在找可用空间的时候，又有几种常见的策略。</p><ul>\n<li>遍历链表，找到第一块size大于或等于所需空间的，就立即返回这块chunk。这种方式叫做<strong>first-fit</strong>。</li>\n<li>从链表中找到符合条件的所有chunk，并从中挑选最小的那个。这种方式叫做<strong>best-fit</strong>。</li>\n<li>从链表中找到符合条件的所有chunk，并从中挑选最大的那个。这种方式叫做<strong>worst-fit</strong>。</li>\n</ul><p>这三种方式在某些特定情况下都会有比较好的表现，但并不能满足所有情况。关于这三种算法的优劣我们就不具体深入讨论了，欢迎你在评论区交流。</p><p>通过刚刚的分析我们知道 <strong>Mark-Sweep 算法的内存分配相对复杂</strong>。另外，Mark-Sweep 还有一个比较大的缺点，就是<strong>内存的碎片化</strong>。你可以看一下示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/57/f6aa26dd4fde6e3fbaf8b09cda6e3957.png?wh=2128x486\" alt=\"\"></p><p>假如现在 D 对象的大小为 2，这个空间内的空闲大小就是 4。如果现在要新建一个大小为 3 的对象，其实是放不下的，因为这两块空闲空间并不连续。虽然总的空闲空间是 4，但却无法分配出一块连续的大小为 3 的空间。这就造成了内存空间的浪费。</p><p>针对这两个缺点，下节课我将重点介绍一种可以解决这两个问题的算法，那就是<strong>复制算法</strong>。而复制算法也是我们的虚拟机最终所选择的算法。</p><h2>总结</h2><p>这节课我们介绍了自动内存管理，也就是垃圾回收算法的基础概念，带你理解了自动内存管理的基本思路。其中有几个非常重要的概念，我们来回顾一下。</p><ol>\n<li>Mutator，所有会修改对象之间的引用关系的代码都可以被叫做 Mutator。</li>\n<li>Collector，负责回收对象，释放内存。</li>\n<li>引用计数算法，通过记录有多少对象引用了本对象，来确定某个对象是否是垃圾对象。</li>\n<li>循环引用，两个对象相互引用对方，且无其他活跃对象再引用它们，它们的引用计数都是 1，这将导致这两个对象无法释放。</li>\n<li>基于 Tracing 的垃圾回收，使用图遍历的方式对全体对象进行遍历，能够到达的对象就是活跃对象，不能到达的就是垃圾对象。</li>\n<li>Mark-Sweep 算法，典型的两阶段垃圾回收算法，使用 freelist 维护空闲区域。分配时从 freelist 中找到可用区域，标记阶段使用深度优先算法对可达对象进行标记，回收阶段将不可达对象的内存区域再交还给 freelist 管理。</li>\n</ol><p>这节课我们分析了主流的垃圾回收算法的思想，下一节课我会重点介绍另外一个基于 Tracing 的垃圾回收算法，来解决 Mark-Sweep 算法的缺陷。</p><h2>思考题</h2><p>为了解决循环引用问题，人们提出了很多改进算法，这样引用计数算法也可以用于商用工程中，你知道有哪些解决循环引用的方法吗？欢迎你把你的解决方案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"21｜继承和多态：完善面向对象编程的两大特征","id":785249},"right":{"article_title":"23｜复制算法：最简单高效的垃圾回收算法","id":785300}},"comments":[{"had_liked":false,"id":396268,"user_name":"冯某","can_delete":false,"product_type":"c1","uid":3889476,"ip_address":"上海","ucode":"7E78ECA53DF453","user_header":"https://static001.geekbang.org/account/avatar/00/3b/59/44/727b90a8.jpg","comment_is_top":false,"comment_ctime":1733818231,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"记录一下","like_count":0},{"had_liked":false,"id":395457,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1730874770,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":392522,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"上海","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1721184127,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"从之前文章提到， python 代码上新建一个对象往往意味着在解释器c++ 层面有一个对应的HiObject，那么\n1. new HiObject(xx)  如何让其使用的内存就是free list里的内存呢？或者说如何基于free list分配的内存创建HiObject对象。\n2. new HiObject(xx)  之后，其使用的内存脱离free list的管理，是不是可以认为没有一个类似free list专门的内存结构 来维护HiObject的内存，也就是已经分配出去的内存，只是说这些HiObject对象都可以被 roots 遍历到，所以可以认为 对象引用关系图同时也是已分配内存的串联图？","like_count":0}]}