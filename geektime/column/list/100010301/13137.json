{"id":13137,"title":"12 | 垃圾回收（下）","content":"<p>在读博士的时候，我曾经写过一个统计Java对象生命周期的动态分析，并且用它来跑了一些基准测试。</p>\n<p>其中一些程序的结果，恰好验证了许多研究人员的假设，即大部分的Java对象只存活一小段时间，而存活下来的小部分Java对象则会存活很长一段时间。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/e2/89/e235d25ca15b60a511a2d90317eb9589.png?wh=892*502\" alt=\"\" /></p>\n<p>（pmd中Java对象生命周期的直方图，红色的表示被逃逸分析优化掉的对象）</p>\n<p>之所以要提到这个假设，是因为它造就了Java虚拟机的分代回收思想。简单来说，就是将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。</p>\n<p>Java虚拟机可以给不同代使用不同的回收算法。对于新生代，我们猜测大部分的Java对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。</p>\n<p>对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。</p>\n<p>这时候，Java虚拟机往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）</p><!-- [[[read_end]]] -->\n<p>今天这一篇我们来关注一下针对新生代的Minor GC。首先，我们来看看Java虚拟机中的堆具体是怎么划分的。</p>\n<h2>Java虚拟机的堆划分</h2>\n<p>前面提到，Java虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为Eden区，以及两个大小相同的Survivor区。</p>\n<p>默认情况下，Java虚拟机采取的是一种动态分配的策略（对应Java虚拟机参数-XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率，以及Survivor区的使用情况动态调整Eden区和Survivor区的比例。</p>\n<p>当然，你也可以通过参数-XX:SurvivorRatio来固定这个比例。但是需要注意的是，其中一个Survivor区会一直为空，因此比例越低浪费的堆空间将越高。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/2c/e5/2cc29b8de676d3747416416a3523e4e5.png?wh=1526*514\" alt=\"\" /></p>\n<p>通常来说，当我们调用new指令时，它会在Eden区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。</p>\n<p>否则，将有可能出现两个对象共用一段内存的事故。如果你还记得前两篇我用“停车位”打的比方的话，这里就相当于两个司机（线程）同时将车停入同一个停车位，因而发生剐蹭事故。</p>\n<p>Java虚拟机的解决方法是为每个司机预先申请多个停车位，并且只允许该司机停在自己的停车位上。那么当司机的停车位用完了该怎么办呢（假设这个司机代客泊车）？</p>\n<p>答案是：再申请多个停车位便可以了。这项技术被称之为TLAB（Thread Local Allocation Buffer，对应虚拟机参数-XX:+UseTLAB，默认开启）。</p>\n<p>具体来说，每个线程可以向Java虚拟机申请一段连续的内存，比如2048字节，作为线程私有的TLAB。</p>\n<p>这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向TLAB中空余内存的起始位置，一个则指向TLAB末尾。</p>\n<p>接下来的new指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。</p>\n<blockquote>\n<p><span class=\"reference\">我猜测会有留言问为什么不把bump the pointer翻译成指针碰撞。这里先解释一下，在英语中我们通常省略了bump up the pointer中的up。在这个上下文中bump的含义应为“提高”。另外一个例子是当我们发布软件的新版本时，也会说bump the version number。</span></p>\n</blockquote>\n<p>如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的TLAB。</p>\n<p>当Eden区的空间耗尽了怎么办？这个时候Java虚拟机便会触发一次Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到Survivor区。</p>\n<p>前面提到，新生代共有两个Survivor区，我们分别用from和to来指代。其中to指向的Survivior区是空的。</p>\n<p>当发生Minor GC时，Eden区和from指向的Survivor区中的存活对象会被复制到to指向的Survivor区中，然后交换from和to指针，以保证下一次Minor GC时，to指向的Survivor区还是空的。</p>\n<p>Java虚拟机会记录Survivor区中的对象一共被来回复制了几次。如果一个对象被复制的次数为15（对应虚拟机参数-XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个Survivor区已经被占用了50%（对应虚拟机参数-XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p>\n<p>总而言之，当发生Minor GC时，我们应用了标记-复制算法，将Survivor区中的老存活对象晋升到老年代，然后将剩下的存活对象和Eden区的存活对象复制到另一个Survivor区中。理想情况下，Eden区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记-复制算法的效果极好。</p>\n<p>Minor GC的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为GC Roots。</p>\n<p>这样一来，岂不是又做了一次全堆扫描呢？</p>\n<h2>卡表</h2>\n<p>HotSpot给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。</p>\n<p>在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。</p>\n<p>由于Minor GC伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，我们又会设置引用所在的卡的标识位。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。</p>\n<p>在Minor GC之前，我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。</p>\n<p>首先，如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p>\n<p>这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障（write barrier，注意不要和volatile字段的写屏障混淆）。</p>\n<p>写屏障需要尽可能地保持简洁。这是因为我们并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。</p>\n<p>因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。</p>\n<p>这么一来，写屏障便可精简为下面的伪代码[1]。这里右移9位相当于除以512，Java虚拟机便是通过这种方式来从地址映射到卡表中的索引的。最终，这段代码会被编译成一条移位指令和一条存储指令。</p>\n<pre><code>CARD_TABLE [this address &gt;&gt; 9] = DIRTY;\n</code></pre>\n<p>虽然写屏障不可避免地带来一些开销，但是它能够加大Minor GC的吞吐率（ 应用运行时间/(应用运行时间+垃圾回收时间) ）。总的来说还是值得的。不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题[2]。</p>\n<p>在介绍对象内存布局中我曾提到虚共享问题，讲的是几个volatile字段出现在同一缓存行里造成的虚共享。这里的虚共享则是卡表中不同卡的标识位之间的虚共享问题。</p>\n<p>在HotSpot中，卡表是通过byte数组来实现的。对于一个64字节的缓存行来说，如果用它来加载部分卡表，那么它将对应64张卡，也就是32KB的内存。</p>\n<p>如果同时有两个Java线程，在这32KB内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。</p>\n<p>为此，HotSpot引入了一个新的参数-XX:+UseCondCardMark，来尽量减少写卡表的操作。其伪代码如下所示：</p>\n<pre><code>if (CARD_TABLE [this address &gt;&gt; 9] != DIRTY) \n  CARD_TABLE [this address &gt;&gt; 9] = DIRTY;\n</code></pre>\n<h2>总结与实践</h2>\n<p>今天我介绍了Java虚拟机中垃圾回收具体实现的一些通用知识。</p>\n<p>Java虚拟机将堆分为新生代和老年代，并且对不同代采用不同的垃圾回收算法。其中，新生代分为Eden区和两个大小一致的Survivor区，并且其中一个Survivor区是空的。</p>\n<p>在只针对新生代的Minor GC中，Eden区和非空Survivor区的存活对象会被复制到空的Survivor区中，当Survivor区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。</p>\n<p>因为Minor GC只针对新生代进行垃圾回收，所以在枚举GC Roots的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。</p>\n<p>由于篇幅的原因，我没有讲解Java虚拟机中具体的垃圾回收器。我在文章的末尾附了一段简单的介绍，如果你有兴趣的话可以参阅一下。</p>\n<p>今天的实践环节，我们来看看Java对象的生命周期对垃圾回收的影响。</p>\n<p>前面提到，Java虚拟机的分代垃圾回收是基于大部分对象只存活一小段时间，小部分对象却存活一大段时间的假设的。</p>\n<p>然而，现实情况中并非每个程序都符合前面提到的假设。如果一个程序拥有中等生命周期的对象，并且刚移动到老年代便不再使用，那么将给默认的垃圾回收策略造成极大的麻烦。</p>\n<p>下面这段程序将生成64G的Java对象。并且，我通过ALIVE_OBJECT_SIZE这一变量来定义同时存活的Java对象的大小。这也是一种对于垃圾回收器来说比较直观的生命周期。</p>\n<p>当我们使用Java 8的默认GC，并且将新生代的空间限制在100M时，试着估算当ALIVE_OBJECT_SIZE为多少时，这段程序不会触发Full GC（提示一下，如果Survivor区没法存储所有存活对象，将发生什么。）。实际运行情况又是怎么样的？</p>\n<pre><code>// Run with java -XX:+PrintGC -Xmn100M -XX:PretenureSizeThreshold=10000 LifetimeTest\n// You may also try with -XX:+PrintHeapAtGC，-XX:-UsePSAdaptiveSurvivorSizePolicy or -XX:SurvivorRatio=N\npublic class LifetimeTest {\n  private static final int K = 1024;\n  private static final int M = K * K;\n  private static final int G = K * M;\n\n  private static final int ALIVE_OBJECT_SIZE = 32 * M;\n\n  public static void main(String[] args) {\n    int length = ALIVE_OBJECT_SIZE / 64;\n    ObjectOf64Bytes[] array = new ObjectOf64Bytes[length];\n    for (long i = 0; i &lt; G; i++) {\n      array[(int) (i % length)] = new ObjectOf64Bytes();\n    }\n  }\n}\n\nclass ObjectOf64Bytes {\n  long placeholder0;\n  long placeholder1;\n  long placeholder2;\n  long placeholder3;\n  long placeholder4;\n  long placeholder5;\n}\n</code></pre>\n<h2>附录：Java虚拟机中的垃圾回收器</h2>\n<p>针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge和Parallel New。这三个采用的都是标记-复制算法。其中，Serial是一个单线程的，Parallel New可以看成Serial的多线程版本。Parallel Scavenge和Parallel New类似，但更加注重吞吐率。此外，Parallel Scavenge不能与CMS一起使用。</p>\n<p>针对老年代的垃圾回收器也有三个：刚刚提到的Serial Old和Parallel Old，以及CMS。Serial Old和Parallel Old都是标记-压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p>\n<p>CMS采用的是标记-清除算法，并且是并发的。除了少数几个操作需要Stop-the-world之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于G1的出现，CMS在Java 9中已被废弃[3]。</p>\n<p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当Eden区、Survivor区或者老年代中的一个。它采用的是标记-压缩算法，而且和CMS一样都能够在应用程序运行过程中并发地进行垃圾回收。</p>\n<p>G1能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是G1名字的由来。</p>\n<p>即将到来的Java 11引入了ZGC，宣称暂停时间不超过10ms。如果你感兴趣的话，可参考R大的这篇文章[4]。</p>\n<p>[1]<br />\n<a href=\"http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\">http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html</a><br />\n[2]<br />\n<a href=\"https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking\">https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking</a><br />\n[3]<br />\n<a href=\"http://openjdk.java.net/jeps/291\">http://openjdk.java.net/jeps/291</a><br />\n[4]  <a href=\"https://www.zhihu.com/question/287945354/answer/458761494\">https://www.zhihu.com/question/287945354/answer/458761494</a></p>\n<p></p>\n","comments":[{"had_liked":false,"id":20935,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":true,"comment_ctime":1534818335,"is_pvip":false,"replies":[{"id":"7431","content":"好长的总结，赞一个","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534932156,"ip_address":"","comment_id":20935,"utype":1}],"discussion_count":4,"race_medal":0,"score":"9.2233722917926994e+18","product_id":100010301,"comment_content":"写的非常棒，又帮我看到了一个小黑盒中的天地。<br>小结：<br>1:二八法则-适用于许多的领域，对象在JVM对内存空间的生命周期也同样符合<br><br>2:为了更好的JVM性能以及充分利用对象生命周期的二八法则，JVM的作者将JVM的对内存空间进行了分代的处理<br><br>3:堆内存空间=年轻代+老年代<br><br>    年轻代=Eden+from+to<br>    年轻代用于分配新生的对象<br>    Eden-通常用于存储新创建的对象，对内存空间是共享的，所以，直接在这里面划分空间需要进行同步<br>     from-当Eden区的空间耗尽时，JVM便会出发一次Minor GC 来收集新生代的垃圾，会把存活下来的对象放入Survivor区，也就是from区<br>注意，from和to是变动的<br>      to-指向的Survivor区是空的，用于当发生Minor GC 时，存储Eden和from区中的存活对象，然后再交换from和to指针，以保证下一次Minor GC 时to指向的Survivor区还是空的。<br><br>      老年代-用于存储存活时间更久的对象，比如：15次Minor GC 还存活的对象就放入老年代中<br><br>4:堆内存分代后，会根据他们的不同特点来区别对待，进行垃圾回收的时候会使用不同的垃圾回收方式，针对新生代的垃圾回收器有如下三个：Serial、Parallel Scavenge、Parallel New，他们采用的都是标记-复制的垃圾回收算法。<br>针对老年代的垃圾回收器有如下三个：Serial Old 、Parallel Old 、CMS，他们使用的都是标记-压缩的垃圾回收算法。<br><br>5:TLAB（Thread Local Allocation Buffer）-这个技术是用于解决多线程竞争堆内存分配问题的，核心原理是对分配一些连续的内存空间<br><br>6:卡表-这个技术是用于解决减少老年代的全堆空间扫描<br>","like_count":59,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422463,"discussion_content":"好长的总结，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534932156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1151942,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/c6/ca5f2b72.jpg","nickname":"NullPointerException","note":"","ucode":"24705EF5BC9430","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":709,"discussion_content":"CMS用的是标记-清除算法，不是标记-压缩","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1561972277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153893,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/65/9045dc77.jpg","nickname":"慕云","note":"","ucode":"E7D6D2CD58249E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580095,"discussion_content":"卡表在老年代也有作用, 避免CMS这样的垃圾回收器,重新扫描阶段要扫描全表,重来一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657870900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267907,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589708132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21343,"user_name":"公子_小白","can_delete":false,"product_type":"c1","uid":1122226,"ip_address":"","ucode":"434122FFD38615","user_header":"","comment_is_top":false,"comment_ctime":1535035676,"is_pvip":false,"replies":[{"id":"7624","content":"HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535117855,"ip_address":"","comment_id":21343,"utype":1}],"discussion_count":5,"race_medal":0,"score":"237758236956","product_id":100010301,"comment_content":"老师您好<br>请问JVM分代收集新生代对象进入老年代，年龄为什么是15而不是其他的?<br>谢谢","like_count":56,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422639,"discussion_content":"HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535117855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","nickname":"涛涛","note":"","ucode":"747C4B1F20A2D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352103,"discussion_content":"如果关闭这个配置，在jdk8中，年轻代中的对象是怎么晋升到老年代中的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614601993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1961940,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ef/d4/6c212b5f.jpg","nickname":"Eason","note":"","ucode":"1A822C577675FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251371,"discussion_content":"MaxTenuringThreshold设置为超过15的值会发生什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588082330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1075038,"avatar":"https://static001.geekbang.org/account/avatar/00/10/67/5e/e0323566.jpg","nickname":"oyt","note":"","ucode":"E1E4F27FB3535F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1961940,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ef/d4/6c212b5f.jpg","nickname":"Eason","note":"","ucode":"1A822C577675FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388165,"discussion_content":"试一下就知道了，设置超过15会报错：must be between 0 and 15","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628641370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":251371,"ip_address":""},"score":388165,"extra":""},{"author":{"id":1153893,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/65/9045dc77.jpg","nickname":"慕云","note":"","ucode":"E7D6D2CD58249E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1961940,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/ef/d4/6c212b5f.jpg","nickname":"Eason","note":"","ucode":"1A822C577675FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580096,"discussion_content":"不能超过15,  因为只分配了4位, 最大是15了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657870940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":251371,"ip_address":""},"score":580096,"extra":""}]}]},{"had_liked":false,"id":40866,"user_name":"　素丶　　","can_delete":false,"product_type":"c1","uid":1081535,"ip_address":"","ucode":"883B7EDBE76104","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/bf/3041138b.jpg","comment_is_top":false,"comment_ctime":1542685032,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"87442030952","product_id":100010301,"comment_content":"可以配合R大的文章<br>http:&#47;&#47;rednaxelafx.iteye.com&#47;blog&#47;1042471<br>http:&#47;&#47;rednaxelafx.iteye.com&#47;blog&#47;174865<br>http:&#47;&#47;rednaxelafx.iteye.com&#47;blog&#47;1044951","like_count":20,"discussions":[{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301055,"discussion_content":"写几篇文章，水平不行，建议别浪费时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598374192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2423009,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f8/e1/319281c7.jpg","nickname":"陈平匡","note":"","ucode":"EB1F736DC3FC1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350822,"discussion_content":"别逗了大哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614041899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301055,"ip_address":""},"score":350822,"extra":""}]}]},{"had_liked":false,"id":20549,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1534518984,"is_pvip":true,"replies":[{"id":"7444","content":"根系统指的是？<br><br>GC roots分布在HotSpot中的每个子系统里。可以在源码中搜oops_do","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534933742,"ip_address":"","comment_id":20549,"utype":1}],"discussion_count":2,"race_medal":0,"score":"65959028424","product_id":100010301,"comment_content":"写得真好，搞清楚了之前没掌握透彻的概念：<br>（1）TLAB是为了避免对象分配时对内存的竞争<br>（2）卡表是为了处理minor gc时老年代对新生代的引用，为了避免整堆扫描而提出了卡表的概念<br><br>提个问题：JVM中堆内存根系统的物理内存是如何对应的，这个可以从哪里看？","like_count":15,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422294,"discussion_content":"根系统指的是？\n\nGC roots分布在HotSpot中的每个子系统里。可以在源码中搜oops_do","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534933742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153893,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/65/9045dc77.jpg","nickname":"慕云","note":"","ucode":"E7D6D2CD58249E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580097,"discussion_content":"卡表还能解决老年代 cms这种重新标记阶段的全盘扫描问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657870997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20715,"user_name":"herome","can_delete":false,"product_type":"c1","uid":1097654,"ip_address":"","ucode":"F00A539371C206","user_header":"https://static001.geekbang.org/account/avatar/00/10/bf/b6/ee3b4ef7.jpg","comment_is_top":false,"comment_ctime":1534687705,"is_pvip":true,"replies":[{"id":"7318","content":"多谢建议！","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534775954,"ip_address":"","comment_id":20715,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57369262553","product_id":100010301,"comment_content":"老师 建议是能画点图吗 😂  每一篇都是文字。 相信画了图 不仅能让文章通俗易懂，也能让老师的文笔更好。","like_count":13,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422376,"discussion_content":"多谢建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534775954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208265,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/c9/22022094.jpg","nickname":"丁奇老师的粉丝","note":"","ucode":"6341E0D78CF998","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617,"discussion_content":"说的太对了，都是字太费劲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561813850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20550,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1534519035,"is_pvip":false,"replies":[{"id":"7325","content":"对的。卡表就是为了避免探索整个老年代，而只将脏表中的对象作为GC roots。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534778787,"ip_address":"","comment_id":20550,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48779159291","product_id":100010301,"comment_content":"通过GC_roots探索存活对象的时候，有的对象在新生代，有的对象在老年代。如果当前对象处在老年代而且在赃卡中，需要继续深度遍历对象。若不在赃卡中，就没必要进一步深度遍历下去了。不知道我的理解对不？","like_count":11,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422295,"discussion_content":"对的。卡表就是为了避免探索整个老年代，而只将脏表中的对象作为GC roots。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534778787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175234,"user_name":"Hi Young","can_delete":false,"product_type":"c1","uid":1548645,"ip_address":"","ucode":"E1E9C88399F3C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","comment_is_top":false,"comment_ctime":1580625440,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40235331104","product_id":100010301,"comment_content":"个人读书笔记，欢迎批评指教<br>https:&#47;&#47;www.yuque.com&#47;zhaohaiyang&#47;notes&#47;jvm-basic-principles#2cqqW<br><br>【目录如下】<br><br>JVM基本原理<br>09 | 垃圾回收（GC）<br><br>垃圾<br><br>如何识别对象的存亡<br>》引用计数法（reference counting）<br>》可达性分析法<br>》Stop-the-world（STW）以及安全点（safepoint）<br>》》Stop-the-world（STW）<br>》》安全点（safepoint）<br><br>垃圾回收方式<br>》标记清除（mark-sweep）<br>》标记压缩（mark-compact）<br>》复制（copy）<br><br>JVM的分代回收<br>》分代回收的前提假设<br>》分代回收思想<br>》JVM的堆划分<br>》TLAB（Thread Local Allocation Buffer，线程本地分配缓冲区）<br>》堆空间的使用及分代回收<br>》卡表<br>》》用途<br>》》思想<br>》》逻辑结构<br>》》卡标识位的赋值<br>》》存在的问题","like_count":10,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323669,"discussion_content":"牛皮","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604979748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2387113,"avatar":"","nickname":"卢本伟","note":"","ucode":"01A22D3C5A3CB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584246,"discussion_content":"感觉写的到位啊，准备观摩观摩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660705056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322122,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2c/8a/257c130b.jpg","nickname":"項霸霸","note":"","ucode":"34F3D2CEA4EE6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354638,"discussion_content":"nb","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615305943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247461,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1599713848,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35959452216","product_id":100010301,"comment_content":"1. &quot;该技术将整个堆划分为一个个大小为 512 字节的卡&quot;<br><br>卡表是将 整个堆划分为一个个卡，还是把老年代划分为一个个卡？ <br>我的理解是，既然卡表的目的为了标识 老年代的对象指向新生代，那么只在老年代划分就好了呀？<br>老年代引用新生代的时候，虚拟机将卡对应的卡表元素设置为脏卡。<br><br><br>2. “当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。”<br><br>如果清零的话，那么第二次minor GC 判断新生代对象是否存活的时候，就找不到脏卡的内容了， 从而无法判断对象是否存活。<br><br>我的理解是， 老年代 Major GC  的时候，判断如果老年代 对象有指向新生代对象那么 标记对应的卡表 为脏吧？<br><br><br>反正 对我卡表的实现原理 很困惑，请老师给予解惑，谢谢谢谢","like_count":8},{"had_liked":false,"id":164680,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1039112,"ip_address":"","ucode":"8F5C7B354EAE33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/08/9ef64ff4.jpg","comment_is_top":false,"comment_ctime":1577071295,"is_pvip":false,"replies":[{"id":"65679","content":"会按对象年龄晋升最老的那些至老年代。极端情况，假设survivor 区大小为0，那就是直接把eden区的存活对象晋升过去了","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1578329668,"ip_address":"","comment_id":164680,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27346875071","product_id":100010301,"comment_content":"老师，有个疑问想请教一下：<br>如果Eden区和from指向的Survivor区存活对象大于to指向的Survivor区的大小，那么JVM会如何处理？","like_count":6,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478863,"discussion_content":"会按对象年龄晋升最老的那些至老年代。极端情况，假设survivor 区大小为0，那就是直接把eden区的存活对象晋升过去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578329668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397351,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","nickname":"zapup","note":"","ucode":"388D6BB5D7B137","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264916,"discussion_content":"分配担保","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589358207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68701,"user_name":"愤怒的虾干","can_delete":false,"product_type":"c1","uid":1266043,"ip_address":"","ucode":"CEBD1B2BE7BCEE","user_header":"https://static001.geekbang.org/account/avatar/00/13/51/7b/191a2112.jpg","comment_is_top":false,"comment_ctime":1550579008,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23025415488","product_id":100010301,"comment_content":"1、当默认开启动态分配时，若ALIVE_OBJECT_SIZE小于33M几乎无FULL GC，大于则出现FULL GC。动态分配时Eden区大小不能小于Survivor区，即最少为新生代内存的1&#47;3，单个Survivor区最大为新生代内存的1&#47;3。故当ALIVE_OBJECT_SIZE大于33M时，Survivor区小于ALIVE_OBJECT_SIZE，导致Minor GC时需要复制到to区的数据大于to区容量，从而使得一部分数据提前晋升到老年区，多次提前晋升导致老年区无多余空间从而导致Full GC；当ALIVE_OBJECT_SIZE小于33M时，Survivor区容量总是近似的接近ALIVE_OBJECT_SIZE大小，使得每次Minor GC有效对象都可以复制到Survivor区，而晋升到老年代的对象大多是年龄达到次数要求，短期内不会挤满老年代空间，在有限时间内运行结束不会引发Full GC。<br>2、当-XX:-UsePSAdaptiveSurvivorSizePolicy or -XX:SurvivorRatio=N关闭动态分配或指定Eden、Survivor比例时，只要ALIVE_OBJECT_SIZE小于Survivor容量，有限时间运行结束不会引发Full GC。反之会导致Full GC。<br>@郑老师 是否是这样？","like_count":5,"discussions":[{"author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136950,"discussion_content":"-XX:TargetSurvivorRatio默认是50%， 虾干指的是Adaptive之后，会变100%？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579172823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20564,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1534550399,"is_pvip":false,"replies":[{"id":"7324","content":"HotSpot不支持在栈上新建对象。<br><br>C2里的逃逸分析是静态分析，和TLAB没什么关系。它和标量替换一起使用，能够完全不分配对象，仅在寄存器中维护这个对象的字段。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534778699,"ip_address":"","comment_id":20564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23009386879","product_id":100010301,"comment_content":"看某些资料介绍说tlab是将对象创建在栈内存上，并且与逃逸分析一起用，这样在释放栈内存时就直接将这部分内存一起释放了，降低了gc成本。您讲解的说tlab是提前在堆内存中分配空间，这样没有降低gc成本呀！","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422302,"discussion_content":"HotSpot不支持在栈上新建对象。\n\nC2里的逃逸分析是静态分析，和TLAB没什么关系。它和标量替换一起使用，能够完全不分配对象，仅在寄存器中维护这个对象的字段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534778699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22122,"user_name":"abs","can_delete":false,"product_type":"c1","uid":1181674,"ip_address":"","ucode":"04CF4E57913A41","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/ea/b82fd545.jpg","comment_is_top":false,"comment_ctime":1535503889,"is_pvip":false,"replies":[{"id":"8010","content":"原本是的。但使用了脏卡技术之后，JVM只需要把脏卡中的对象当成GC roots","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535620223,"ip_address":"","comment_id":22122,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18715373073","product_id":100010301,"comment_content":"新声代回收的时候会把老年代的所有对象当做gcroot吗","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423007,"discussion_content":"原本是的。但使用了脏卡技术之后，JVM只需要把脏卡中的对象当成GC roots","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535620223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20644,"user_name":"Alex Rao","can_delete":false,"product_type":"c1","uid":1155143,"ip_address":"","ucode":"EE055938B44CC9","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/47/620308a3.jpg","comment_is_top":false,"comment_ctime":1534638594,"is_pvip":false,"replies":[{"id":"7437","content":"如果你说的是JMM中的工作内存，那是JMM抽象出来的一个概念，在现实的体系架构中可以映射为CPU中的缓存，属于硬件技术。<br><br>TLAB是用来优化多线程分配的，属于软件技术。两者没啥关系。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534932925,"ip_address":"","comment_id":20644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18714507778","product_id":100010301,"comment_content":"TLAB 和 工作内存是什么关系？","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422346,"discussion_content":"如果你说的是JMM中的工作内存，那是JMM抽象出来的一个概念，在现实的体系架构中可以映射为CPU中的缓存，属于硬件技术。\n\nTLAB是用来优化多线程分配的，属于软件技术。两者没啥关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534932925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20572,"user_name":"郭俊杰","can_delete":false,"product_type":"c1","uid":1095011,"ip_address":"","ucode":"3BA7F5CA0BA864","user_header":"https://static001.geekbang.org/account/avatar/00/10/b5/63/b66f3d37.jpg","comment_is_top":false,"comment_ctime":1534555324,"is_pvip":false,"replies":[{"id":"7439","content":"如果你把new后的对象发布出去，就是放到其他共享变量中，也会存在线程安全问题。如果new后只是在方法中使用该对象而不作为参数传出去(以它为调用者的实例方法也不会传出去)，那么没有问题。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534933398,"ip_address":"","comment_id":20572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18714424508","product_id":100010301,"comment_content":"老师，你好，一直想问个问题，多线程访问共享变量会存在线程安全问题，那么方法内部通过new的局部变量是不是也存在安全问题呢？希望老师帮忙回答下感谢","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422307,"discussion_content":"如果你把new后的对象发布出去，就是放到其他共享变量中，也会存在线程安全问题。如果new后只是在方法中使用该对象而不作为参数传出去(以它为调用者的实例方法也不会传出去)，那么没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534933398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132088,"user_name":"river","can_delete":false,"product_type":"c1","uid":1182055,"ip_address":"","ucode":"E7205D8B636C59","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/67/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1568021376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452923264","product_id":100010301,"comment_content":"总结与实践中的代码ObjectOf64Bytes的64=6*8(6个long类型字段)+16(该对象的对象头大小，不是说压缩后是12字节么？)","like_count":3},{"had_liked":false,"id":107092,"user_name":"0xTang","can_delete":false,"product_type":"c1","uid":1019659,"ip_address":"","ucode":"82F5282EF3044B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/0b/a438de52.jpg","comment_is_top":false,"comment_ctime":1561457903,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14446359791","product_id":100010301,"comment_content":"如果新生代晋升到老年代失败的时候如何处理？（可能原因：老年代内存不够，老年代碎片过多，晋升的新生代太大）","like_count":3,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244660,"discussion_content":"此时发生full gc，对于cms可能还伴随着一次压缩","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587619532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103091,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","nickname":"李二木","note":"","ucode":"30E03BB84ADB27","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536324,"discussion_content":"可能是先major GC再full GC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638759233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61919,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1547858024,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14432759912","product_id":100010301,"comment_content":"老师好，请问java8开始之后的元数据区的回收是如何呢？这部分属于堆外内存吗？","like_count":3,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356035,"discussion_content":"元空间在逻辑上仍然是归属于JVM，所以当元空间打满后，仍然要full gc。打满的标准或者触发时机你可以搜下高水位线相关知识点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615519555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64019,"discussion_content":"元数据不就是以前的方法区嘛。。。。。。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574930697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1114772,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/94/2bf394f3.jpg","nickname":"Numbpad1","note":"","ucode":"2F075AC7E3847D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226365,"discussion_content":"方法区只是jvm的规范，元空间属于具体实现，这部分已经放到了本地内存，不在堆中了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586432707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64019,"ip_address":""},"score":226365,"extra":""},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1114772,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/94/2bf394f3.jpg","nickname":"Numbpad1","note":"","ucode":"2F075AC7E3847D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240017,"discussion_content":"？？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587312332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":226365,"ip_address":""},"score":240017,"extra":""}]}]},{"had_liked":false,"id":27352,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1537876449,"is_pvip":false,"replies":[{"id":"10298","content":"1. 可以这么说。<br>2. 指的是这张卡上的对象很可疑，可能存在GC roots。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1538116460,"ip_address":"","comment_id":27352,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14422778337","product_id":100010301,"comment_content":"卡表中将堆划分为大小为512字节的卡，意思是将512字节的数据作为一个卡吗？然后用卡片中的比特位1,0代表是否存在GC root？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424888,"discussion_content":"1. 可以这么说。\n2. 指的是这张卡上的对象很可疑，可能存在GC roots。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538116460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26932,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1537778454,"is_pvip":false,"replies":[{"id":"10288","content":"严格来说应该是对象。像局部变量中存放的引用只是导致对象成为GC roots的原因。我个人倾向于将这些引用作为GC roots，因为GC是从这些地方出发开始探索的。看各人理解方便吧。<br><br>你可以参考eclipse MAT定义的GC roots:<br>https:&#47;&#47;help.eclipse.org&#47;luna&#47;index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1538115675,"ip_address":"","comment_id":26932,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14422680342","product_id":100010301,"comment_content":"老师，GC ROOT到底指的是对象本身，还是引用？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424759,"discussion_content":"严格来说应该是对象。像局部变量中存放的引用只是导致对象成为GC roots的原因。我个人倾向于将这些引用作为GC roots，因为GC是从这些地方出发开始探索的。看各人理解方便吧。\n\n你可以参考eclipse MAT定义的GC roots:\nhttps://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538115675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225953,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1591918604,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10181853196","product_id":100010301,"comment_content":"1.java将堆分成年轻代及年老代分别应对不同的对象生命周期消亡的特点<br>年轻代使用标记复制：年轻代对象存活时间短，垃圾回收后相应的存活对象少可用标记复制算法。并且年轻代用于分配新对象，所以要求有连续空的内存用于快速分配。这里涉及TLAB，即java线程会先申请线程单独有的内存。<br>年老代使用标记清除，年老代对象存活时间长，垃圾回收后会有大量对象还是在的，所以用标记复制的话复制成本比较大,相比直接清除成本理低。且老年代分配新对象的频率较小，是一个trade off的过程。<br><br>2.Minor gc垃圾回收涉及如何防止新生代有个对象在线程等gc root没有在用，但实际老年代对象存在新生代对象的引用。这个解法就是卡表，将内存划分512字节的卡页，卡页有标识是否为脏页的字段。<br>在Minor gc时如果发现新生代对象卡页为脏，则不会对该对象进行回收。<br>卡页设置的触发点是：在复制对象到老年代时需要更新对应引用，这时将引用所对应的卡页设置为脏标记。eg:对象C中引用了新生代对象B，对象C在Minor gc时需要移到老年代，这时需要更新新生代对象B所在卡表为脏页。<br><br>","like_count":2},{"had_liked":false,"id":21506,"user_name":"公子_小白","can_delete":false,"product_type":"c1","uid":1122226,"ip_address":"","ucode":"434122FFD38615","user_header":"","comment_is_top":false,"comment_ctime":1535118164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10125052756","product_id":100010301,"comment_content":"多谢老师的回复","like_count":2},{"had_liked":false,"id":315839,"user_name":"死磕郎一世","can_delete":false,"product_type":"c1","uid":1272996,"ip_address":"","ucode":"86C1197C3FB2A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","comment_is_top":false,"comment_ctime":1634019146,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5928986442","product_id":100010301,"comment_content":"郑老师，我一直以来有个很大的疑问，可达性分析都是从gc root开始分析的，如果老年代有存活对象，肯定也会分析到老年代，如果老年代还引用了年轻代，那么垮代引用也分析到了，而且这样分析更准确，这跟记忆集没有半毛钱关系啊！不管你有没有记忆集，都会分析到老年代，那么分代收集又如何谈起呢？如果只分析年轻代，gc root是如何过滤掉老年代的引用的呢？望老师解答！","like_count":1,"discussions":[{"author":{"id":1272996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","nickname":"死磕郎一世","note":"","ucode":"86C1197C3FB2A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403335,"discussion_content":"为什么还需要额外遍历老年代中的引用，如果从 GC Roots 开始,不是也能通过 GC Roots -> Old -> Young 完成遍历吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634050405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159655,"user_name":"老白","can_delete":false,"product_type":"c1","uid":1397031,"ip_address":"","ucode":"39881175152D49","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","comment_is_top":false,"comment_ctime":1575720149,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5870687445","product_id":100010301,"comment_content":"卡表用于堆内所有空间(新生代&#47;老年代&#47;永久代)，还是只存在于老年代？","like_count":1,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248256,"discussion_content":"卡表是用来优化快速判断老年代中是否引用新声代对象的技术，你说它是哪里","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587861000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132364,"user_name":"sososo425","can_delete":false,"product_type":"c1","uid":1067939,"ip_address":"","ucode":"F2009138EE9525","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/a3/3fd92ddb.jpg","comment_is_top":false,"comment_ctime":1568098570,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"5863065866","product_id":100010301,"comment_content":"郑老师，你好！<br>我想请教一个CMS收集器的问题，就是 CMS 在“重新标记”结束后，在进入“并发清除”时，这时候GC线程和应用线程同时在跑，如果在GC线程清理“垃圾”的时候，应用线程又将“垃圾”恢复为正常对象，怎么办呢？<br>会出现这种情况吗？是虚拟机采用了某种方式杜绝了这种情况的发生么？还是有什么其它处理机制呢？<br>谢谢！","like_count":1,"discussions":[{"author":{"id":1067939,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4b/a3/3fd92ddb.jpg","nickname":"sososo425","note":"","ucode":"F2009138EE9525","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18429,"discussion_content":"也就是说，为什么垃圾收集 只考虑 gc线程 【标记】 时，被 应用线程 干扰的情况?\n而不考虑 在【收集】时，被 应用线程 干扰的情况？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569058330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257046,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/56/aa3690ef.jpg","nickname":"云云","note":"","ucode":"1A08803F6EBD33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285357,"discussion_content":"既然是垃圾，那肯定是没人引用，既然没人引用又怎么会变成正常对象，引用都丢失了，JAVA不是C，没那么自由","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592814654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128510,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1566891541,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5861858837","product_id":100010301,"comment_content":"当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。<br>这里的交换指针不理解，仅仅只是让to区每次都是空的？","like_count":1,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244413,"discussion_content":"这不就是复制算法么，来回复制，你mingc一次复制了一次后，下次mingc复制时怎么办，当然要两个s区来回切","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587602198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179286,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/96/806c4043.jpg","nickname":"秦始皇","note":"","ucode":"A45397B393F46B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65225,"discussion_content":"这是标记复制算法，就是为了能分配一段连续的内存地址空间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574990337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1405884,"avatar":"https://static001.geekbang.org/account/avatar/00/15/73/bc/207db15c.jpg","nickname":"啊汀","note":"","ucode":"5E05CD0E531F37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6932,"discussion_content":"我理解为空应该只是gc的现象，from 到to的过程，一个是为了回收垃圾对象，一个是为了对象年龄计数。所以from复制完之后from 区就必须为空了(放不下就放老年代去了)，所以交换指针应该是为了下一次minorGC铺垫吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567178595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113738,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":1115724,"ip_address":"","ucode":"0420C5535DACB7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","comment_is_top":false,"comment_ctime":1563149617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858116913","product_id":100010301,"comment_content":"请教一个问题：<br>针对栈上的局部引用会由安全点生成的oopMap记录，实现快速枚举根节点，那么方法区的静态变量和常量的引用维护在哪里呢？<br>既然已经由oopMap维护局部变量引用，那为什么还需要卡表这个东西呢？直接使用oopmap的引用会存在什么问题吗？还是我对oopmap理解错了？<br><br><br><br>","like_count":1},{"had_liked":false,"id":108704,"user_name":"Dd","can_delete":false,"product_type":"c1","uid":1387750,"ip_address":"","ucode":"E1BD3A61D97974","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/e6/ed32ffcf.jpg","comment_is_top":false,"comment_ctime":1561861034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856828330","product_id":100010301,"comment_content":"郑老师好，对于针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 - 复制算法，其中Serial GC，新生代使用标记复制算法这个说法，有官方出处吗？因为我先看的官方说明地址如下（JDK1.7）https:&#47;&#47;www.oracle.com&#47;webfolder&#47;technetwork&#47;tutorials&#47;obe&#47;java&#47;gc01&#47;index.html，按照文档的定义<br>Young Generation对应minor garbage collection，Old Generation对应major garbage collection<br><br>然后在The Serial GC 收集器的说明中，有如下描述<br><br>1.The serial collector is the default for client style machines in Java SE 5 and 6. With the serial collector, （both minor and major garbage collections are done serially） (using a single virtual CPU). In addition, it uses （a mark-compact） collection method<br><br>对于Serial，算法到底是mark-compact 还是还是mark-copy？或者不同年代，还区分不同算法来进行垃圾收集？","like_count":1},{"had_liked":false,"id":98772,"user_name":"Hamlin","can_delete":false,"product_type":"c1","uid":1012666,"ip_address":"","ucode":"245DF2E7F9CBCE","user_header":"","comment_is_top":false,"comment_ctime":1559092925,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5854060221","product_id":100010301,"comment_content":"“当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。”<br>如果全部清零的话，下一次扫描时怎么知道该扫描哪些老年带区域？主要是指上一次遗留下的从老年带对新生代的引用。","like_count":1,"discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280178,"discussion_content":"个人理解是 脏卡不一定包含指向新生代对象的引用，因为每次更新引用时都默认当成有指向新生代。当新生代GC时，去找所有脏卡中是否含有直接的引用，如果有，放入Minor GC的 GC roots中，那么脏卡就没必要在记住了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591512216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89851,"user_name":"nero","can_delete":false,"product_type":"c1","uid":1078793,"ip_address":"","ucode":"038100ACA14B29","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/09/cf7513c8.jpg","comment_is_top":false,"comment_ctime":1556282933,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5851250229","product_id":100010301,"comment_content":"这也太狠了","like_count":1},{"had_liked":false,"id":82956,"user_name":"Theodore","can_delete":false,"product_type":"c1","uid":1055049,"ip_address":"","ucode":"0735C2A64295FC","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/49/9452b2fd.jpg","comment_is_top":false,"comment_ctime":1554358872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849326168","product_id":100010301,"comment_content":"老师您好，我想咨询一下，你是否研究过类的GC。<br>在大量反射、动态代理，CGLib等Bytecode框架、动态生成jsp 等动态类对象（非实例对象）在jdk1.8中是否是使用MethodHandle实现的？这些动态类的GC细节能给我提供点学习资料吗？","like_count":1},{"had_liked":false,"id":63483,"user_name":"rakitten","can_delete":false,"product_type":"c1","uid":1389789,"ip_address":"","ucode":"1B52DADEBA0F75","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLr1dfCcjyk2UzDX7COZzfPTME33vzDymQ4kb6zR5vgUXjAdQRKrk2p46v5xrmN2pp9zxa3UOn5Jg/132","comment_is_top":false,"comment_ctime":1548381748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843349044","product_id":100010301,"comment_content":"有两个问题想请教一下郑老师：<br>1、介绍GC的文档很多，我有个疑问：GC的代码哪里能看到？<br>2、我们的后台服务一天内偶尔出现一次YGC耗时很长的情况（超过100ms，正常只有20ms），而且很难复现。我在想，能不能在GC发生的时候，触发一个Linux脚本，记录现场的线程信息以及堆栈信息","like_count":1},{"had_liked":false,"id":51943,"user_name":"多巴胺老邮差","can_delete":false,"product_type":"c1","uid":1067231,"ip_address":"","ucode":"3DE40F289C6608","user_header":"https://static001.geekbang.org/account/avatar/00/10/48/df/0ecd8c36.jpg","comment_is_top":false,"comment_ctime":1545279928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840247224","product_id":100010301,"comment_content":"郑老师您好 ！ 一直想问问CMS收集器中并发标记这一个步骤的作用是什么 ？ 为什么还要在初始标记的基础上多进行一次Roots Tracing呢？ 希望您能有空能够回复下 thx <br>","like_count":1},{"had_liked":false,"id":48647,"user_name":"骑车吃火锅","can_delete":false,"product_type":"c1","uid":1303591,"ip_address":"","ucode":"6C00EEB90AD539","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/27/73359af3.jpg","comment_is_top":false,"comment_ctime":1544506024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839473320","product_id":100010301,"comment_content":"请问老师，java类是如何被卸载的？","like_count":1},{"had_liked":false,"id":38930,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1542160030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837127326","product_id":100010301,"comment_content":"记载来自一个刚刚迈进程序世界的coder<br><br>java对象的生存周期<br><br>大部分对象的生命周期都很短，小部分对象的生命周期很长。<br><br>因为这个特点，可以对jvm内存分代，不同代采用不同的回收方式。<br><br>年轻代要采用频繁的回收方式，快速回收大部分垃圾。老年代则采用不频繁但彻底的回收方式。<br><br>JVM堆的划分<br><br>因为对象以上的特点，将堆分为两个代，老年代和新生代。新生代分为Eden和两个Survivor区。可以使用参数 “”，会动态的根据对象的生成速率以及survivor区的使用情况，调整Eden区和survivor区的比例。也可以使用参数“”，来固定Eden和survivor的比例。<br><br>如何保证内存分配的线程安全<br><br>堆是共享的，所有的线程都会在堆上分配内存，那么jvm是如何保证内存分配是线程安全的？答案是，每个线程都会有TLAB(thread local allocation buffer)，这个是线程私有的。首先会在TLAB上分配，如果TLAB不够用，就需要通过加锁的方式，申请TLAB。<br><br>Eden区满了<br><br>触发minor GC，eden和from依旧存活的对象会放置到to区。然后交换from to指针的指向。其中达到经历过一定回收次数的对象将会被晋升到老年代，对应JVM参数[]。同时如果也配置了[]参数，单个survivor区占用超过50%，经历次数较高的对象也会晋升到老年代。<br><br>先提前说一个结论，minor GC有一个好处，发生GC时不会遍历堆内存，只会遍历Eden+survivor区！讲道理，老年代很可能拥有Eden+survivor区对象的引用，那minor GC只遍历年轻代，是怎么做到GC的呢？<br><br>卡表<br><br>HotSpot会将堆分割成一个个512字节大小的卡，然后维护一张卡表，每个卡在表中占据一个卡位。<br><br>","like_count":1},{"had_liked":false,"id":23998,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1536744978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831712274","product_id":100010301,"comment_content":"老师你好，写屏障不会判断引用是否指向新生代的对象，这里会不会提高MinorGC的成本呢？","like_count":1},{"had_liked":false,"id":22444,"user_name":"小橙橙","can_delete":false,"product_type":"c1","uid":1054923,"ip_address":"","ucode":"4F467210A15F66","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/cb/edb5a0a0.jpg","comment_is_top":false,"comment_ctime":1535678700,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5830645996","product_id":100010301,"comment_content":"Minor GC 也会造成stop the world吗？","like_count":1,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64021,"discussion_content":"GC 都会啊。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574930774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22379,"user_name":"o","can_delete":false,"product_type":"c1","uid":1104326,"ip_address":"","ucode":"4028A59700647A","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/c6/a295275b.jpg","comment_is_top":false,"comment_ctime":1535637611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5830604907","product_id":100010301,"comment_content":"笔者您好！我想请问一个问题，就是jvm的survivor区如果满了。并且没有发生15次gc，也就是没有对象能够进入老年带的时候会发生什么问题？我今天遇到的问题，还在排查中。就是运行一段时间假死，然后java进程挂掉没有一点点信息留下。不是系统kilk，因为连kilk信息都没有。望您能给个方向和建议。","like_count":1},{"had_liked":false,"id":21120,"user_name":"潇潇","can_delete":false,"product_type":"c1","uid":1105352,"ip_address":"","ucode":"ECC5745C5D3931","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/c8/fc79c128.jpg","comment_is_top":false,"comment_ctime":1534928715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829896011","product_id":100010301,"comment_content":"有一个疑问，卡表是只运用在老年代这块内存吗？","like_count":1},{"had_liked":false,"id":20976,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1534848238,"is_pvip":false,"replies":[{"id":"7429","content":"对象内的引用","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534931921,"ip_address":"","comment_id":20976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5829815534","product_id":100010301,"comment_content":"这里老年代对象存在对新生代对象的引用，那么这个指的引用是栈里存储的reference 吗？ 还是对象内的引用","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422478,"discussion_content":"对象内的引用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534931921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20961,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1534833338,"is_pvip":false,"replies":[{"id":"7430","content":"1. 对的。还有一种可能，就是更新老年代对象的引用型字段，使之指向新生代对象。<br><br>2. (我的理解) 应用程序只设置脏位而不清除，垃圾回收前需要强制flush CPU缓存。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534932114,"ip_address":"","comment_id":20961,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5829800634","product_id":100010301,"comment_content":"疑问🤔️<br><br>1:什么场景下老年代的对象会引用新生代的对象？是有些对象可以移到老年代了但是他引用的对象还不能是吗？<br><br>2:我觉得卡表的维护很重要，并发环境怎么保证卡表的健壮性？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422471,"discussion_content":"1. 对的。还有一种可能，就是更新老年代对象的引用型字段，使之指向新生代对象。\n\n2. (我的理解) 应用程序只设置脏位而不清除，垃圾回收前需要强制flush CPU缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534932114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20544,"user_name":"爪哇夜未眠","can_delete":false,"product_type":"c1","uid":1006025,"ip_address":"","ucode":"BBEB80EB670770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","comment_is_top":false,"comment_ctime":1534517577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829484873","product_id":100010301,"comment_content":"希望老师多画些图，更好理解","like_count":1},{"had_liked":false,"id":353800,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"广东","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1659793791,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659793791","product_id":100010301,"comment_content":"思考题：年轻代默认比例：8:1:1，即Eden区要达到80M才会触发YGC。根据题目，数组中的对象最多是32MB，只不过会频繁覆盖，产生垃圾对象。无非就是要求YGC能够清理掉垃圾对象。但这里有个坑：题目中是通过求余来覆盖原数组元素，这意味着之前这个位置的对象变成垃圾对象。换句话说，只要有对象进入老年代，就可能变成垃圾对象，久而久之就会触发FGC。在不使用自动调整情况下，按照默认比例，S0&#47;S1都只有10M，Eden区80M，要想达到该目的，就要求数组中的对象必须能在S0&#47;S1存得下，并且不能存活太久，使之在晋升老年代之前被回收调。因此是10M。在使用自动调整的情况下，从第一次触发FGC开始就自动调整为1：1：1，那也就是最多就是100&#47;3M，大概就是33MB","like_count":0},{"had_liked":false,"id":341292,"user_name":"Geek_3b4ae8","can_delete":false,"product_type":"c1","uid":2044544,"ip_address":"","ucode":"D590CE490249D4","user_header":"","comment_is_top":false,"comment_ctime":1649504938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649504938","product_id":100010301,"comment_content":"垃圾收集器讲的好笼统","like_count":0},{"had_liked":false,"id":339273,"user_name":"כן אני אמריקאי","can_delete":false,"product_type":"c1","uid":1527429,"ip_address":"","ucode":"56C5C2B369121B","user_header":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","comment_is_top":false,"comment_ctime":1648018661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648018661","product_id":100010301,"comment_content":"你知道为什么要有两个 Survivor吗？关于卡表技术又有多少了解？欢迎大家阅读：https:&#47;&#47;juejin.cn&#47;post&#47;7076077613654999048","like_count":0},{"had_liked":false,"id":339172,"user_name":"xiaoma1325","can_delete":false,"product_type":"c1","uid":1784625,"ip_address":"","ucode":"70CA476828A0F2","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3b/31/a322ea1a.jpg","comment_is_top":false,"comment_ctime":1647955412,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647955412","product_id":100010301,"comment_content":"老师，想问下，java通过jni调用c++的动态库，java层的gc卡顿的时候，会影响c++动态库里面的线程调度么","like_count":0},{"had_liked":false,"id":334933,"user_name":"~@^_^@~","can_delete":false,"product_type":"c1","uid":1127943,"ip_address":"","ucode":"44C5A4CACDC8B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/07/3055e983.jpg","comment_is_top":false,"comment_ctime":1645188447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645188447","product_id":100010301,"comment_content":"gc后，对象地址可能会变化。引用变化的对象，都要重新维护。这块的机制是什么样的？","like_count":0},{"had_liked":false,"id":291281,"user_name":"晨曦","can_delete":false,"product_type":"c1","uid":2444694,"ip_address":"","ucode":"94993724767BB8","user_header":"https://static001.geekbang.org/account/avatar/00/25/4d/96/c1835e16.jpg","comment_is_top":false,"comment_ctime":1620179846,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1620179846","product_id":100010301,"comment_content":"什么时候会触发fullgc呢？","like_count":0},{"had_liked":false,"id":271383,"user_name":"Arvin","can_delete":false,"product_type":"c1","uid":1636235,"ip_address":"","ucode":"E3DB5171058118","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/8b/854a9a7a.jpg","comment_is_top":false,"comment_ctime":1609587486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609587486","product_id":100010301,"comment_content":"将对象从Eden区移动到survivor区时，会更新引用指向的地址嘛？如果是这样的话，使用什么工具查看引用地址的变化呢？","like_count":0},{"had_liked":false,"id":258003,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1604240422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604240422","product_id":100010301,"comment_content":"最近跟着学极客时间的Java进阶训练营，现在看垃圾回收的部分，感觉又有新的理解了，更好懂了","like_count":0},{"had_liked":false,"id":250030,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1600911653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600911653","product_id":100010301,"comment_content":"老师好，一些文章讲G1内存利用率不高 因为g1有卡表占了很大内存，这种说法是正确的吗。","like_count":0},{"had_liked":false,"id":228541,"user_name":"sunshine","can_delete":false,"product_type":"c1","uid":1185140,"ip_address":"","ucode":"2B1B3967311D64","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/74/a3ad7af7.jpg","comment_is_top":false,"comment_ctime":1592730087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592730087","product_id":100010301,"comment_content":"如果为指定了 TLABSize，这句话 “否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB”中，重新申请的TLAB会和原来的合并吗还是有其他逻辑处理呢","like_count":0},{"had_liked":false,"id":226055,"user_name":"Benjamin","can_delete":false,"product_type":"c1","uid":1082014,"ip_address":"","ucode":"7837F6E47546E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/9e/bb6f7229.jpg","comment_is_top":false,"comment_ctime":1591938208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591938208","product_id":100010301,"comment_content":"在第一次 Minor GC 之前，老年代的所有卡都是脏的吗？","like_count":0},{"had_liked":false,"id":218973,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1589905749,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1589905749","product_id":100010301,"comment_content":"对 card table 中的 false sharing 问题写了个 测试的 demo, 有兴趣的可以看下<br>https:&#47;&#47;github.com&#47;giraffe-tree&#47;boom-java&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;me&#47;giraffetree&#47;java&#47;boomjava&#47;concurrent&#47;problem&#47;falseShare&#47;cardtable","like_count":0,"discussions":[{"author":{"id":1440772,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","nickname":"Kevin⚡️Zhou","note":"","ucode":"C0FC2673705212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294514,"discussion_content":"请教一下, 你的代码中建立两个new object之后就没有再新建对象, 按道理eden区域没有发生minor gc啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595912860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1182802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","nickname":"长脖子树","note":"","ucode":"D9090EF67EEB1B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1440772,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","nickname":"Kevin⚡️Zhou","note":"","ucode":"C0FC2673705212","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294576,"discussion_content":"有没有发生 young gc 和卡表的false sharing 没关系呀，不管有没有发生都要记录在卡表上的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595930234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294514,"ip_address":""},"score":294576,"extra":""}]}]},{"had_liked":false,"id":216485,"user_name":"单俊宁","can_delete":false,"product_type":"c1","uid":1855289,"ip_address":"","ucode":"403678A72C3305","user_header":"https://static001.geekbang.org/account/avatar/00/1c/4f/39/cb4df994.jpg","comment_is_top":false,"comment_ctime":1589270126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589270126","product_id":100010301,"comment_content":"为什么老年代用标记-清楚算法，新生代使用复制算法？","like_count":0},{"had_liked":false,"id":208906,"user_name":"ward-wolf","can_delete":false,"product_type":"c1","uid":1031845,"ip_address":"","ucode":"BC41D01301263A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/a5/df917d18.jpg","comment_is_top":false,"comment_ctime":1587462889,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587462889","product_id":100010301,"comment_content":"老师你为什么说“-XX:SurvivorRatio 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。”，这个比例越低Survivor 区不是越小么？那浪费空间不就也小么？","like_count":0,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248219,"discussion_content":"XX:SurvivorRatio这个值默认为8，也就是伊甸区比S区的比例是8：2，或者8：1：1，如果降低这个比例，就是指的是，变为比8小的数，比如6或者7，如果设置为6表示，比例变为6：4，或者6：2：2，也就意味着s区变大，这样当存活对象非常少的时候，你还指定这么大的s区，不就是浪费么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587858712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164432,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1576988863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576988863","product_id":100010301,"comment_content":"思考题不知道怎么做，老师能稍微讲解下吗？","like_count":0},{"had_liked":false,"id":163393,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1576716584,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576716584","product_id":100010301,"comment_content":"在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存。<br><br>老师，问个问题，64字节为什么是32KB的内存？","like_count":0,"discussions":[{"author":{"id":1812912,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/b0/0c701ef3.jpg","nickname":"吃鱼","note":"","ucode":"848835584F6099","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295896,"discussion_content":"64*512B=32KB","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596377964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163185,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1576667160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576667160","product_id":100010301,"comment_content":"当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。<br>老师，这是第几次Minor GC","like_count":0},{"had_liked":false,"id":138440,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1570243784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570243784","product_id":100010301,"comment_content":"老师有两个问题请教。<br>1.TLAB可是设置大小么?有时候一个方法中可能需要好几M的内存。吐过TLAB每次申请很少申请次数太多，对性能影响大么?还是hotSpot有优化，会递增每次申请的内存大小以减少申请次数?<br>2.对像地址何时放入卡表中不太清楚。是老年代对象的局部变量被赋值就会把这个对象地址放入卡表么?方法中只有右移没写是否会判断当前对象是否是老年带对象。年轻带对象不会进入卡表的吧?<br>3.遍历卡表时如果发现这个卡表内没有引用年轻代对象。会从卡表中删除么?","like_count":0},{"had_liked":false,"id":130166,"user_name":"[etartnecnoC]H","can_delete":false,"product_type":"c1","uid":1243555,"ip_address":"","ucode":"EA7E0DF5FFA07B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/a3/5bbf0635.jpg","comment_is_top":false,"comment_ctime":1567395386,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1567395386","product_id":100010301,"comment_content":"请问老师，from指针和to指针每次交换位置是什么缘由？有点晕。","like_count":0,"discussions":[{"author":{"id":1470766,"avatar":"https://static001.geekbang.org/account/avatar/00/16/71/2e/0d18ea65.jpg","nickname":"外星小小盆友🍓","note":"","ucode":"FE517609D955E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7164,"discussion_content":"为了标记对象存活的“年龄”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567410456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122940,"user_name":"believe me","can_delete":false,"product_type":"c1","uid":1101427,"ip_address":"","ucode":"7BF9A3C7BF6A9B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/73/cded8343.jpg","comment_is_top":false,"comment_ctime":1565576212,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1565576212","product_id":100010301,"comment_content":"老师您说HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15，那么JAM参数-XX:MaxTenuringThreshold用来指定对象进入老年代的年龄阀值，倘若这个参数指定的值大于15，JVM会怎么处理呢？","like_count":0,"discussions":[{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6702,"discussion_content":"最大只能配置 15","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567060229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115525,"user_name":"N","can_delete":false,"product_type":"c1","uid":1133657,"ip_address":"","ucode":"3791619172D64F","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/59/c75cb36d.jpg","comment_is_top":false,"comment_ctime":1563612563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563612563","product_id":100010301,"comment_content":"老师您好，公司ES服务器设置最大最小堆内存26个G，G1GC, XX:MaxGCPauseMillis =500，一段时间内old gc 都会稳定在500ms以内，但每天总会有1-2次old gc 时间很长，大概3000ms.请问该如何优化呢？","like_count":0},{"had_liked":false,"id":78844,"user_name":"Jadic","can_delete":false,"product_type":"c1","uid":1005121,"ip_address":"","ucode":"C6DE22C449B911","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/41/050144c7.jpg","comment_is_top":false,"comment_ctime":1553255890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553255890","product_id":100010301,"comment_content":"hi，想了解下，当前线程在申请TLAB的时候是如何决定本次申请的空间大小的，如何尽量不浪费又少申请次数？谢谢。","like_count":0},{"had_liked":false,"id":77482,"user_name":"XuYJ","can_delete":false,"product_type":"c1","uid":1462141,"ip_address":"","ucode":"CE1C65E49A2C4A","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/7d/930b2957.jpg","comment_is_top":false,"comment_ctime":1552955498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552955498","product_id":100010301,"comment_content":"cms不是标记清除吗","like_count":0},{"had_liked":false,"id":53042,"user_name":"小泷哥","can_delete":false,"product_type":"c1","uid":1255252,"ip_address":"","ucode":"128C9C4B0AFE7F","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/54/d38c34a0.jpg","comment_is_top":false,"comment_ctime":1545574506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545574506","product_id":100010301,"comment_content":"可以这么理解吗：<br>1、卡表记录老年代执行新生代的引用<br>2、老年代的引用变更都会被当做堆新生代的引用，记录在卡表中。<br>3、只需要在老年代GC的时候，执行一次minor GC就行了，清理card table(包括CMS和G1)。","like_count":0},{"had_liked":false,"id":38322,"user_name":"QlDoors","can_delete":false,"product_type":"c1","uid":1005911,"ip_address":"","ucode":"394F3E6CE39392","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/57/449e76fb.jpg","comment_is_top":false,"comment_ctime":1542021320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542021320","product_id":100010301,"comment_content":"&lt; 1&#47;2 Suvivors 时，不会发生Full GC","like_count":0},{"had_liked":false,"id":34334,"user_name":"杨陆伟","can_delete":false,"product_type":"c1","uid":1108457,"ip_address":"","ucode":"3BC968447406EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/e9/1f95e422.jpg","comment_is_top":false,"comment_ctime":1540114785,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540114785","product_id":100010301,"comment_content":"也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。———这句话不太理解，做可达性分析时，就是从gcroots一层层向下找，肯定有可能从根到老年代的对象，可能再到新生代区域，为什么要单独考虑维护和处理这个老年代到新生代的引用呢？","like_count":0},{"had_liked":false,"id":30404,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1538828928,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1538828928","product_id":100010301,"comment_content":"老师你好，练习题里你的问题是存活对象为多大时不发生Full GC，请问问题是不是问错了，是Minor GC？如果按照8 1 1原则，存活对象不超过10M应该就不会发生Minor GC了，不知是否正确。还有一个问题，如果在发生复制时Eden和Survivor中对象空间超过To空间，但还是第一次复制，这时JVM怎么处理呢？会晋升到老年代吗？","like_count":0,"discussions":[{"author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136957,"discussion_content":"jdk8开始，默认是自适应调整， 不是固定   8 11吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579173280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28852,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1538181414,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1538181414","product_id":100010301,"comment_content":"请问个问题，网上找不到好的答案，两个线程同时运行，其中一个oom而终止了，另一个还可以正常运行，这个oom是什么内存？单个线程可分配的内存是否有限制多少？","like_count":0,"discussions":[{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248322,"discussion_content":"从原理上解读，线程共用堆内存，你可以这样，这两个线程在跑时，你用jstate等命令去监控下堆内存，看看一个线程在oom之前，堆是否已经达到极限了，如果发现了频繁的fullgc，那么说明堆内存是不够的，这样你就从另一个侧面去判断出虚拟机对线程是否有限制，有的时候通过原理无法解答问题的时候，就需要去通过实践去理解原理，去解答疑问。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587863089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25055,"user_name":"白院伟","can_delete":false,"product_type":"c1","uid":1187420,"ip_address":"","ucode":"CE6AC96814DA9E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/5c/6de299ba.jpg","comment_is_top":false,"comment_ctime":1537239558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537239558","product_id":100010301,"comment_content":"郑老师，你好，请问一下，怎么计算出一个线程向虚拟机申请了多少内存？","like_count":0},{"had_liked":false,"id":21125,"user_name":"潇潇","can_delete":false,"product_type":"c1","uid":1105352,"ip_address":"","ucode":"ECC5745C5D3931","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/c8/fc79c128.jpg","comment_is_top":false,"comment_ctime":1534930024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534930024","product_id":100010301,"comment_content":"希望老师在这个基础上也讲一下G1的内容","like_count":0},{"had_liked":false,"id":21116,"user_name":"道法自然","can_delete":false,"product_type":"c1","uid":1063627,"ip_address":"","ucode":"E4DFD0415A6291","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/cb/97dee373.jpg","comment_is_top":false,"comment_ctime":1534925140,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1534925140","product_id":100010301,"comment_content":"老师，还有一个问题，对于实验程序，按理说，active object size 大小略小于 survivor区大小的话，就不应该有对象会被复制到老年代，因为没有对象会被复制15次，可是实际程序运行中，老年代也有对象被复制过去，请问这是什么原因？多谢！","like_count":0},{"had_liked":false,"id":21112,"user_name":"道法自然","can_delete":false,"product_type":"c1","uid":1063627,"ip_address":"","ucode":"E4DFD0415A6291","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/cb/97dee373.jpg","comment_is_top":false,"comment_ctime":1534922568,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1534922568","product_id":100010301,"comment_content":"当ACTIVE_OBJECT_SIZE小于SURVIVOR区的大小时，就不会发生full gc 了，不知道对否？","like_count":0},{"had_liked":false,"id":20978,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1534848754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534848754","product_id":100010301,"comment_content":"因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。—意思是更新引用指向时，要是之前是指向新时代的 对象的那么就是赃卡,不管之后是否有变成老年代对象呢？","like_count":0},{"had_liked":false,"id":20872,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1534781269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534781269","product_id":100010301,"comment_content":"如何防止频繁的进行full gc","like_count":0},{"had_liked":false,"id":20749,"user_name":"imfenglei","can_delete":false,"product_type":"c1","uid":1170778,"ip_address":"","ucode":"03A877C862BDEA","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/5a/936e228d.jpg","comment_is_top":false,"comment_ctime":1534726889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534726889","product_id":100010301,"comment_content":"郑老师，什么时候维护卡表中的卡是不是脏卡呢？","like_count":0},{"had_liked":false,"id":20696,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1534675298,"is_pvip":false,"replies":[{"id":"7322","content":"Copy对象指的是垃圾回收器的copy吗？垃圾回收时会更新卡表的。<br><br>或者你说的是克隆？我认为Object.clone也会更新卡表。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534777775,"ip_address":"","comment_id":20696,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534675298","product_id":100010301,"comment_content":"你好，请问在copy对象的时候，card table也需要更新吧？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422365,"discussion_content":"Copy对象指的是垃圾回收器的copy吗？垃圾回收时会更新卡表的。\n\n或者你说的是克隆？我认为Object.clone也会更新卡表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534777775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20600,"user_name":"赤云","can_delete":false,"product_type":"c1","uid":1093258,"ip_address":"","ucode":"67476D582D8B6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/8a/e67def95.jpg","comment_is_top":false,"comment_ctime":1534578656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534578656","product_id":100010301,"comment_content":"请求方法为线程私有，上面那个问方法局部变量的，，，搞清楚了，，，n个线程会复制n份。不冲突，只有多线程写成员变量才会出现。","like_count":0},{"had_liked":false,"id":20505,"user_name":"John(易筋)","can_delete":false,"product_type":"c1","uid":1180202,"ip_address":"","ucode":"BB4E58DD4B8F15","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/2a/90e38b94.jpg","comment_is_top":false,"comment_ctime":1534493627,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1534493627","product_id":100010301,"comment_content":"第二条只能用这个通过<br>java -XX:+PrintHeapAtGC -XX:-UsePSAdaptiveSurvivorSizePolicy  LifetimeTest","like_count":0}]}