{"id":308399,"title":"16 | Semaphore：一篇文章搞懂信号量","content":"<p>你好，我是鸟窝。</p><p>在前面的课程里，我们学习了标准库的并发原语、原子操作和Channel，掌握了这些，你就可以解决80%的并发编程问题了。但是，如果你要想进一步提升你的并发编程能力，就需要学习一些第三方库。</p><p>所以，在接下来的几节课里，我会给你分享Go官方或者其他人提供的第三方库，这节课我们先来学习信号量，信号量（Semaphore）是用来控制多个goroutine同时访问多个资源的并发原语。</p><h1>信号量是什么？都有什么操作？</h1><p>信号量的概念是荷兰计算机科学家Edsger Dijkstra在1963年左右提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态。未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。</p><p>最简单的信号量就是一个变量加一些并发控制的能力，这个变量是0到n之间的一个数值。当goroutine完成对此信号量的等待（wait）时，该计数值就减1，当goroutine完成对此信号量的释放（release）时，该计数值就加1。当计数值为0的时候，goroutine调用wait等待该信号量是不会成功的，除非计数器又大于0，等待的goroutine才有可能成功返回。</p><!-- [[[read_end]]] --><p>更复杂的信号量类型，就是使用抽象数据类型代替变量，用来代表复杂的资源类型。实际上，大部分的信号量都使用一个整型变量来表示一组资源，并没有实现太复杂的抽象数据类型，所以你只要知道有更复杂的信号量就行了，我们这节课主要是学习最简单的信号量。</p><p>说到这儿呢，我想借助一个生活中的例子，来帮你进一步理解信号量。</p><p>举个例子，图书馆新购买了10本《Go并发编程的独家秘籍》，有1万个学生都想读这本书，“僧多粥少”。所以，图书馆管理员先会让这1万个同学进行登记，按照登记的顺序，借阅此书。如果书全部被借走，那么，其他想看此书的同学就需要等待，如果有人还书了，图书馆管理员就会通知下一位同学来借阅这本书。这里的资源是《Go并发编程的独家秘籍》这十本书，想读此书的同学就是goroutine，图书管理员就是信号量。</p><p>怎么样，现在是不是很好理解了？那么，接下来，我们来学习下信号量的P/V操作。</p><h2>P/V操作</h2><p>Dijkstra在他的论文中为信号量定义了两个操作P和V。P操作（descrease、wait、acquire）是减少信号量的计数值，而V操作（increase、signal、release）是增加信号量的计数值。</p><p>使用伪代码表示如下（中括号代表原子操作）：</p><pre><code>function V(semaphore S, integer I):\n    [S ← S + I]\n\nfunction P(semaphore S, integer I):\n    repeat:\n        [if S ≥ I:\n        S ← S − I\n        break]\n</code></pre><p>可以看到，初始化信号量S有一个指定数量（<strong>n</strong>）的资源，它就像是一个有n个资源的池子。P操作相当于请求资源，如果资源可用，就立即返回；如果没有资源或者不够，那么，它可以不断尝试或者阻塞等待。V操作会释放自己持有的资源，把资源返还给信号量。信号量的值除了初始化的操作以外，只能由P/V操作改变。</p><p>现在，我们来总结下信号量的实现。</p><ul>\n<li>初始化信号量：设定初始的资源的数量。</li>\n<li>P操作：将信号量的计数值减去1，如果新值已经为负，那么调用者会被阻塞并加入到等待队列中。否则，调用者会继续执行，并且获得一个资源。</li>\n<li>V操作：将信号量的计数值加1，如果先前的计数值为负，就说明有等待的P操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行。</li>\n</ul><p>讲到这里，我想再稍微说一个题外话，我们在<a href=\"https://time.geekbang.org/column/article/295850\">第2讲</a>提到过饥饿，就是说在高并发的极端场景下，会有些goroutine始终抢不到锁。为了处理饥饿的问题，你可以在等待队列中做一些“文章”。比如实现一个优先级的队列，或者先入先出的队列，等等，保持公平性，并且照顾到优先级。</p><p>在正式进入实现信号量的具体实现原理之前，我想先讲一个知识点，就是信号量和互斥锁的区别与联系，这有助于我们掌握接下来的内容。</p><p>其实，信号量可以分为计数信号量（counting semaphore）和二进位信号量（binary semaphore）。刚刚所说的图书馆借书的例子就是一个计数信号量，它的计数可以是任意一个整数。在特殊的情况下，如果计数值只能是0或者1，那么，这个信号量就是二进位信号量，提供了互斥的功能（要么是0，要么是1），所以，有时候互斥锁也会使用二进位信号量来实现。</p><p>我们一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接、几个打印机资源，等等。如果信号量蜕变成二进位信号量，那么，它的P/V就和互斥锁的Lock/Unlock一样了。</p><p>有人会很细致地区分二进位信号量和互斥锁。比如说，有人提出，在Windows系统中，互斥锁只能由持有锁的线程释放锁，而二进位信号量则没有这个限制（<a href=\"https://stackoverflow.com/questions/62814/difference-between-binary-semaphore-and-mutex\">Stack Overflow</a>上也有相关的讨论）。实际上，虽然在Windows系统中，它们的确有些区别，但是对Go语言来说，互斥锁也可以由非持有的goroutine来释放，所以，从行为上来说，它们并没有严格的区别。</p><p>我个人认为，没必要进行细致的区分，因为互斥锁并不是一个很严格的定义。实际在遇到互斥并发的问题时，我们一般选用互斥锁。</p><p>好了，言归正传，刚刚我们掌握了信号量的含义和具体操作方式，下面，我们就来具体了解下官方扩展库的实现。</p><h1>Go官方扩展库的实现</h1><p>在运行时，Go内部使用信号量来控制goroutine的阻塞和唤醒。我们在学习基本并发原语的实现时也看到了，比如互斥锁的第二个字段：</p><pre><code>type Mutex struct {\n\t\tstate int32\n\t\tsema  uint32\n}\n</code></pre><p>信号量的P/V操作是通过函数实现的：</p><pre><code>func runtime_Semacquire(s *uint32)\nfunc runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)\nfunc runtime_Semrelease(s *uint32, handoff bool, skipframes int)\n</code></pre><p>遗憾的是，它是Go运行时内部使用的，并没有封装暴露成一个对外的信号量并发原语，原则上我们没有办法使用。不过没关系，Go在它的扩展包中提供了信号量<a href=\"https://godoc.org/golang.org/x/sync/semaphore\">semaphore</a>，不过这个信号量的类型名并不叫Semaphore，而是叫Weighted。</p><p>之所以叫做Weighted，我想，应该是因为可以在初始化创建这个信号量的时候设置权重（初始化的资源数），其实我觉得叫Semaphore或许会更好。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/b0/1a13a551346cd6b910f38f5ed2bfc6b0.png?wh=702*174\" alt=\"\"></p><p>我们来分析下这个信号量的几个实现方法。</p><ol>\n<li><strong>Acquire方法</strong>：相当于P操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是Context，这就意味着，你可以通过Context增加超时或者cancel的机制。如果是正常获取了资源，就返回nil；否则，就返回ctx.Err()，信号量不改变。</li>\n<li><strong>Release方法</strong>：相当于V操作，可以将n个资源释放，返还给信号量。</li>\n<li><strong>TryAcquire方法</strong>：尝试获取n个资源，但是它不会阻塞，要么成功获取n个资源，返回true，要么一个也不获取，返回false。</li>\n</ol><p>知道了信号量的实现方法，在实际的场景中，我们应该怎么用呢？我来举个Worker Pool的例子，来帮助你理解。</p><p>我们创建和CPU核数一样多的Worker，让它们去处理一个4倍数量的整数slice。每个Worker一次只能处理一个整数，处理完之后，才能处理下一个。</p><p>当然，这个问题的解决方案有很多种，这一次我们使用信号量，代码如下：</p><pre><code>var (\n    maxWorkers = runtime.GOMAXPROCS(0)                    // worker数量\n    sema       = semaphore.NewWeighted(int64(maxWorkers)) //信号量\n    task       = make([]int, maxWorkers*4)                // 任务数，是worker的四倍\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    for i := range task {\n        // 如果没有worker可用，会阻塞在这里，直到某个worker被释放\n        if err := sema.Acquire(ctx, 1); err != nil {\n            break\n        }\n\n        // 启动worker goroutine\n        go func(i int) {\n            defer sema.Release(1)\n            time.Sleep(100 * time.Millisecond) // 模拟一个耗时操作\n            task[i] = i + 1\n        }(i)\n    }\n\n    // 请求所有的worker,这样能确保前面的worker都执行完\n    if err := sema.Acquire(ctx, int64(maxWorkers)); err != nil {\n        log.Printf(&quot;获取所有的worker失败: %v&quot;, err)\n    }\n\n    fmt.Println(task)\n}\n</code></pre><p>在这段代码中，main goroutine相当于一个dispatcher，负责任务的分发。它先请求信号量，如果获取成功，就会启动一个goroutine去处理计算，然后，这个goroutine会释放这个信号量（有意思的是，信号量的获取是在main goroutine，信号量的释放是在worker goroutine中），如果获取不成功，就等到有信号量可以使用的时候，再去获取。</p><p>需要提醒你的是，其实，在这个例子中，还有一个值得我们学习的知识点，就是最后的那一段处理（第25行）。<strong>如果在实际应用中，你想等所有的Worker都执行完，就可以获取最大计数值的信号量</strong>。</p><p>Go扩展库中的信号量是使用互斥锁+List实现的。互斥锁实现其它字段的保护，而List实现了一个等待队列，等待者的通知是通过Channel的通知机制实现的。</p><p>我们来看一下信号量Weighted的数据结构：</p><pre><code>type Weighted struct {\n\t\tsize    int64         // 最大资源数\n\t\tcur     int64         // 当前已被使用的资源\n\t\tmu      sync.Mutex    // 互斥锁，对字段的保护\n\t\twaiters list.List     // 等待队列\n}\n</code></pre><p>在信号量的几个实现方法里，Acquire是代码最复杂的一个方法，它不仅仅要监控资源是否可用，而且还要检测Context的Done是否已关闭。我们来看下它的实现代码。</p><pre><code>func (s *Weighted) Acquire(ctx context.Context, n int64) error {\n\t\ts.mu.Lock()\n        // fast path, 如果有足够的资源，都不考虑ctx.Done的状态，将cur加上n就返回\n\t\tif s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == 0 {\n\t\t\ts.cur += n\n\t\t\ts.mu.Unlock()\n\t\t\treturn nil\n\t\t}\n\t\n        // 如果是不可能完成的任务，请求的资源数大于能提供的最大的资源数\n\t\tif n &gt; s.size {\n\t\t\ts.mu.Unlock()\n            // 依赖ctx的状态返回，否则一直等待\n\t\t\t&lt;-ctx.Done()\n\t\t\treturn ctx.Err()\n\t\t}\n\t\n        // 否则就需要把调用者加入到等待队列中\n        // 创建了一个ready chan,以便被通知唤醒\n\t\tready := make(chan struct{})\n\t\tw := waiter{n: n, ready: ready}\n\t\telem := s.waiters.PushBack(w)\n\t\ts.mu.Unlock()\n\t\n\n        // 等待\n\t\tselect {\n\t\tcase &lt;-ctx.Done(): // context的Done被关闭\n\t\t\terr := ctx.Err()\n\t\t\ts.mu.Lock()\n\t\t\tselect {\n\t\t\tcase &lt;-ready: // 如果被唤醒了，忽略ctx的状态\n\t\t\t\terr = nil\n\t\t\tdefault: 通知waiter\n\t\t\t\tisFront := s.waiters.Front() == elem\n\t\t\t\ts.waiters.Remove(elem)\n\t\t\t\t// 通知其它的waiters,检查是否有足够的资源\n\t\t\t\tif isFront &amp;&amp; s.size &gt; s.cur {\n\t\t\t\t\ts.notifyWaiters()\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t\treturn err\n\t\tcase &lt;-ready: // 被唤醒了\n\t\t\treturn nil\n\t\t}\n\t}\n</code></pre><p>其实，为了提高性能，这个方法中的fast path之外的代码，可以抽取成acquireSlow方法，以便其它Acquire被内联。</p><p>Release方法将当前计数值减去释放的资源数n，并唤醒等待队列中的调用者，看是否有足够的资源被获取。</p><pre><code>func (s *Weighted) Release(n int64) {\n\t\ts.mu.Lock()\n\t\ts.cur -= n\n\t\tif s.cur &lt; 0 {\n\t\t\ts.mu.Unlock()\n\t\t\tpanic(&quot;semaphore: released more than held&quot;)\n\t\t}\n\t\ts.notifyWaiters()\n\t\ts.mu.Unlock()\n}\n</code></pre><p>notifyWaiters方法就是逐个检查等待的调用者，如果资源不够，或者是没有等待者了，就返回：</p><pre><code>func (s *Weighted) notifyWaiters() {\n\t\tfor {\n\t\t\tnext := s.waiters.Front()\n\t\t\tif next == nil {\n\t\t\t\tbreak // No more waiters blocked.\n\t\t\t}\n\t\n\n\t\t\tw := next.Value.(waiter)\n\t\t\tif s.size-s.cur &lt; w.n {\n\t\t\t\t//避免饥饿，这里还是按照先入先出的方式处理\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\ts.cur += w.n\n\t\t\ts.waiters.Remove(next)\n\t\t\tclose(w.ready)\n\t\t}\n\t}\n</code></pre><p>notifyWaiters方法是按照先入先出的方式唤醒调用者。当释放100个资源的时候，如果第一个等待者需要101个资源，那么，队列中的所有等待者都会继续等待，即使有的等待者只需要1个资源。这样做的目的是避免饥饿，否则的话，资源可能总是被那些请求资源数小的调用者获取，这样一来，请求资源数巨大的调用者，就没有机会获得资源了。</p><p>好了，到这里，你就知道了官方扩展库的信号量实现方法，接下来你就可以使用信号量了。不过，在此之前呢，我想给你讲几个使用时的常见错误。这部分内容可是帮助你避坑的，我建议你好好学习。</p><h1>使用信号量的常见错误</h1><p>保证信号量不出错的前提是正确地使用它，否则，公平性和安全性就会受到损害，导致程序panic。</p><p>在使用信号量时，最常见的几个错误如下：</p><ul>\n<li>请求了资源，但是忘记释放它；</li>\n<li>释放了从未请求的资源；</li>\n<li>长时间持有一个资源，即使不需要它；</li>\n<li>不持有一个资源，却直接使用它。</li>\n</ul><p>不过，即使你规避了这些坑，在同时使用多种资源，不同的信号量控制不同的资源的时候，也可能会出现死锁现象，比如<a href=\"https://en.wikipedia.org/wiki/Dining_philosophers_problem\">哲学家就餐问题</a>。</p><p>就Go扩展库实现的信号量来说，在调用Release方法的时候，你可以传递任意的整数。但是，如果你传递一个比请求到的数量大的错误的数值，程序就会panic。如果传递一个负数，会导致资源永久被持有。如果你请求的资源数比最大的资源数还大，那么，调用者可能永远被阻塞。</p><p>所以，<strong>使用信号量遵循的原则就是请求多少资源，就释放多少资源</strong>。你一定要注意，必须使用正确的方法传递整数，不要“耍小聪明”，而且，请求的资源数一定不要超过最大资源数。</p><h1>其它信号量的实现</h1><p>除了官方扩展库的实现，实际上，我们还有很多方法实现信号量，比较典型的就是使用Channel来实现。</p><p>根据之前的Channel类型的介绍以及Go内存模型的定义，你应该能想到，使用一个buffer为n的Channel很容易实现信号量，比如下面的代码，我们就是使用chan struct{}类型来实现的。</p><p>在初始化这个信号量的时候，我们设置它的初始容量，代表有多少个资源可以使用。它使用Lock和Unlock方法实现请求资源和释放资源，正好实现了Locker接口。</p><pre><code>\t// Semaphore 数据结构，并且还实现了Locker接口\n\ttype semaphore struct {\n\t\tsync.Locker\n\t\tch chan struct{}\n\t}\n\t\n\t// 创建一个新的信号量\n\tfunc NewSemaphore(capacity int) sync.Locker {\n\t\tif capacity &lt;= 0 {\n\t\t\tcapacity = 1 // 容量为1就变成了一个互斥锁\n\t\t}\n\t\treturn &amp;semaphore{ch: make(chan struct{}, capacity)}\n\t}\n\t\n\t// 请求一个资源\n\tfunc (s *semaphore) Lock() {\n\t\ts.ch &lt;- struct{}{}\n\t}\n\t\n\t// 释放资源\n\tfunc (s *semaphore) Unlock() {\n\t\t&lt;-s.ch\n\t}\n</code></pre><p>当然，你还可以自己扩展一些方法，比如在请求资源的时候使用Context参数（Acquire(ctx)）、实现TryLock等功能。</p><p>看到这里，你可能会问，这个信号量的实现看起来非常简单，而且也能应对大部分的信号量的场景，为什么官方扩展库的信号量的实现不采用这种方法呢？其实，具体是什么原因，我也不知道，但是我必须要强调的是，官方的实现方式有这样一个功能：<strong>它可以一次请求多个资源，这是通过Channel实现的信号量所不具备的</strong>。</p><p>除了Channel，<a href=\"https://github.com/marusama/semaphore\">marusama/semaphore</a>也实现了一个可以动态更改资源容量的信号量，也是一个非常有特色的实现。如果你的资源数量并不是固定的，而是动态变化的，我建议你考虑一下这个信号量库。</p><h1>总结</h1><p>这是一个很奇怪的现象：标准库中实现基本并发原语（比如Mutex）的时候，强烈依赖信号量实现等待队列和通知唤醒，但是，标准库中却没有把这个实现直接暴露出来放到标准库，而是通过第三库提供。</p><p>不管怎样，信号量这个并发原语在多资源共享的并发控制的场景中被广泛使用，有时候也会被Channel类型所取代，因为一个buffered chan也可以代表n个资源。</p><p>但是，官方扩展的信号量也有它的优势，就是可以一次获取多个资源。<strong>在批量获取资源的场景中，我建议你尝试使用官方扩展的信号量</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/73/674bc464d4e3d11c96fa1ac71d317e73.jpg?wh=2250*1413\" alt=\"\"></p><h1>思考题</h1><ol>\n<li>你能用Channel实现信号量并发原语吗？你能想到几种实现方式？</li>\n<li>为什么信号量的资源数设计成int64而不是uint64呢？</li>\n</ol><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"15 | 内存模型：Go如何保证并发读写的顺序？","id":307469},"right":{"article_title":"17 | SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？","id":309098}},"comments":[{"had_liked":false,"id":271253,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1609493326,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"66034002766","product_id":100061801,"comment_content":"补充说明下 信号量 p&#47;v的含义：<br>P—— passeren，中文译为&quot;通过&quot;，V—— vrijgeven，中文译为&quot;释放&quot; （因为作者是荷兰人，上面单词为荷兰语）","like_count":16,"discussions":[{"author":{"id":1172050,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/52/56dbb738.jpg","nickname":"牙小木","note":"","ucode":"E5C12D37A62949","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362575,"discussion_content":"通过和释放一个意⁽⁽◝( ˙ ꒳ ˙ )◜⁾⁾so what","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616984712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261695,"user_name":"myrfy","can_delete":false,"product_type":"c1","uid":1169401,"ip_address":"","ucode":"2814BAE5D70098","user_header":"","comment_is_top":false,"comment_ctime":1605491583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31670262655","product_id":100061801,"comment_content":"第一个问题:<br>至少两种，写入ch算获取，自己读取ch算获取<br><br>第二个问题应该是防止错误获取或者释放信号量时，出现负数溢出到无穷大的问题。如果溢出到无穷大，就会让信号量失效，从而导致1被保护资源更大规模的破坏","like_count":7},{"had_liked":false,"id":267761,"user_name":"木头发芽","can_delete":false,"product_type":"c1","uid":1419723,"ip_address":"","ucode":"657B381C5DA963","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","comment_is_top":false,"comment_ctime":1607915198,"is_pvip":false,"replies":[{"id":"97554","content":"atomic和gopark,参考runtime&#47;sema.go","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1608468195,"ip_address":"","comment_id":267761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10197849790","product_id":100061801,"comment_content":"semaphore是用Mutex和Channel通知实现的,而Mutex又依赖于go内部的信号量实现,那这个内部的信号量又是用什么实现的?","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511733,"discussion_content":"atomic和gopark,参考runtime/sema.go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608468195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263025,"user_name":"大漠胡萝卜","can_delete":false,"product_type":"c1","uid":1198953,"ip_address":"","ucode":"FBE51E4A13EF4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/69/c02eac91.jpg","comment_is_top":false,"comment_ctime":1605951500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10195886092","product_id":100061801,"comment_content":"在日常开发中，没怎么使用信号量semaphore，一般使用channel来解决这种问题。<br>另外，并发的时候使用池化技术感觉更加通用吧。","like_count":2},{"had_liked":false,"id":261851,"user_name":"刚子","can_delete":false,"product_type":"c1","uid":1017080,"ip_address":"","ucode":"7B55EC80A7A4A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/f8/c22d32b4.jpg","comment_is_top":false,"comment_ctime":1605538024,"is_pvip":false,"replies":[{"id":"95056","content":"意思是通过一次调用，只能从chan中获取一个值，多个。goroutine需要调用多次才能得到n个值","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605575224,"ip_address":"","comment_id":261851,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10195472616","product_id":100061801,"comment_content":"不是很理解这句话 ：&quot;一次请求多个资源，这是通过 Channel 实现的信号量所不具备的。&quot;<br>Channel 也可以开启多个goroutine 去请求多个资源","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509637,"discussion_content":"意思是通过一次调用，只能从chan中获取一个值，多个。goroutine需要调用多次才能得到n个值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605575224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353219,"user_name":"Geek_a6104e","can_delete":false,"product_type":"c1","uid":1711967,"ip_address":"北京","ucode":"29A56792216DC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GJXKh8OG00U5ial64plAIibbIuwkzhPc8uYic9Hibl8SbqvhnS2JImHgCD4JGvTktiaVnCjHQWbA5wicaxRUN5aTEWnQ/132","comment_is_top":false,"comment_ctime":1659274484,"is_pvip":false,"replies":[{"id":"128580","content":"等于你的资源数。预先确定好","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1659660512,"ip_address":"北京","comment_id":353219,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659274484","product_id":100061801,"comment_content":"return &amp;semaphore{ch: make(chan struct{}, capacity)} 请问一下最后一个例子semaphore结构初始化为啥会多个capacity","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582756,"discussion_content":"等于你的资源数。预先确定好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659660513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329615,"user_name":"8.13.3.27.30","can_delete":false,"product_type":"c1","uid":1556358,"ip_address":"","ucode":"2DE3CE3E338BAB","user_header":"https://static001.geekbang.org/account/avatar/00/17/bf/86/c0cb35f0.jpg","comment_is_top":false,"comment_ctime":1641446746,"is_pvip":false,"replies":[{"id":"120140","content":"👍🏻👍🏻👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1641554932,"ip_address":"","comment_id":329615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641446746","product_id":100061801,"comment_content":"打卡完成","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544541,"discussion_content":"👍🏻👍🏻👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641554932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308275,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1629511399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629511399","product_id":100061801,"comment_content":"https:&#47;&#47;github.com&#47;zzm996-zzm&#47;go-concurrent&#47;blob&#47;main&#47;semaphore&#47;semaphore.go<br>基于chan实现的信号量 其实和文章中的思路是一样的 不过全都是自己实现的","like_count":0},{"had_liked":false,"id":308239,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1629465429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629465429","product_id":100061801,"comment_content":"总结一下，阻塞的操作就是依靠读取无缓冲chan来的，唤醒的操作就是把chan close掉。为了避免饥饿需要严格遵守队列条件，不会因为小就放行，必须先满足队列的第一个的需求 才会开始第二个。<br>两个select 就是为了双重检查，即使超时了也检查看看是否获取到了信号量。<br>对比纯chan的优势是 ，chan一次就只能读取一个,但是这个只需要给一个int就可以获取到对应数量是信号量 <br>","like_count":0},{"had_liked":false,"id":263348,"user_name":"伟伟","can_delete":false,"product_type":"c1","uid":1060937,"ip_address":"","ucode":"F0B393FC6E1098","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/49/f9e37ced.jpg","comment_is_top":false,"comment_ctime":1606111676,"is_pvip":true,"replies":[{"id":"95573","content":"唯一存在的问题是可能出现死锁。<br>比如信号量是10，同时有两个goroutine请求8个资源。","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1606133298,"ip_address":"","comment_id":263348,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1606111676","product_id":100061801,"comment_content":"type Semaphore chan struct{}<br><br>func NewSemaphore(cap int) Semaphore {<br>\treturn make(chan struct{}, cap)<br>}<br><br>func (s Semaphore) Acquire(n int) {<br>\tfor i := 0; i &lt; n; i++ {<br>\t\ts &lt;- struct{}{}<br>\t}<br>}<br><br>func (s Semaphore) Release(n int) {<br>\tfor i := 0; i &lt; n; i++ {<br>\t\t&lt;-s<br>\t}<br>}<br><br>func NewSemaphore2(cap int) Semaphore {<br>\tsem := make(chan struct{}, cap)<br>\tfor i := 0; i &lt; cap; i++ {<br>\t\tsem &lt;- struct{}{}<br>\t}<br>\treturn sem<br>}<br><br>func (s Semaphore) Acquire2(n int) {<br>\tfor i := 0; i &lt; n; i++ {<br>\t\t&lt;-s<br>\t}<br>}<br><br>func (s Semaphore) Release2(n int) {<br>\tfor i := 0; i &lt; n; i++ {<br>\t\ts &lt;- struct{}{}<br>\t}<br>}","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510155,"discussion_content":"唯一存在的问题是可能出现死锁。\n比如信号量是10，同时有两个goroutine请求8个资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606133298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046604,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3a/8c/fc2c3e5c.jpg","nickname":"xl666","note":"","ucode":"CF9A8086F91053","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550547,"discussion_content":"要加锁吧哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644583231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389913,"discussion_content":"之前信号量上面的例子都是判断 ，是否足够，不足够则会休眠。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629503942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1060937,"avatar":"https://static001.geekbang.org/account/avatar/00/10/30/49/f9e37ced.jpg","nickname":"伟伟","note":"","ucode":"F0B393FC6E1098","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328933,"discussion_content":"type Semaphore struct {\n\tch chan struct{}\n}\n\nfunc NewSemaphore(cap int) *Semaphore {\n\treturn &amp;Semaphore{\n\t\tch: make(chan struct{}, cap),\n\t}\n}\n\nfunc (s *Semaphore) Acquire(n int) error {\n\t// todo 这里是否需要锁操作\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase s.ch <- struct{}{}:\n\n\t\tdefault:\n\t\t\treturn errors.New(&#34;acquire failed&#34;)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *Semaphore) Release(n int) {\n\tfor i := 0; i < n; i++ {\n\t\t<-s.ch\n\t}\n}\n\n老师这里todo处是否需要，如果有10个信号量，两个goroutinue都想要8个，同时都会获取5个了，都不能成功。如果加锁性能有影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606275153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1229778,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c3/d2/3c3382e1.jpg","nickname":"想飞的鱼","note":"","ucode":"1BDED70ACF0505","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1060937,"avatar":"https://static001.geekbang.org/account/avatar/00/10/30/49/f9e37ced.jpg","nickname":"伟伟","note":"","ucode":"F0B393FC6E1098","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":337274,"discussion_content":"不用竞争，你自己都会死锁。你循环获取，到一半发现不够直接return了？你已经拿的不吐出来？永远消失？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608859467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328933,"ip_address":""},"score":337274,"extra":""}]}]},{"had_liked":false,"id":262498,"user_name":"虫子樱桃","can_delete":false,"product_type":"c1","uid":1226331,"ip_address":"","ucode":"F8244A9E9BC5A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/5b/4486e4f9.jpg","comment_is_top":false,"comment_ctime":1605751621,"is_pvip":false,"replies":[{"id":"95272","content":"这个更多是用ratelimiter,信号量主要并发访问n个资源的场景","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605765978,"ip_address":"","comment_id":262498,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605751621","product_id":100061801,"comment_content":"老师的例子里面，是通过 计算机的协程 runtime.GOMAXPROCS(0) 来模拟有限的资源（比喻例子里面的书），那么这个semaphore的场景是不是就是比较适用于请求有流量或者调用次数限制的场景呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509859,"discussion_content":"这个更多是用ratelimiter,信号量主要并发访问n个资源的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605765978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262021,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1605607609,"is_pvip":true,"replies":[{"id":"95089","content":"理解了ctx,也就理解select。当外部context通知取消请求时，会在检查一下当前是否请求成功了","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605611248,"ip_address":"","comment_id":262021,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1605607609","product_id":100061801,"comment_content":"老师，Acquire函数为什么还会有第二个select语句？这部分逻辑是什么啊？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509689,"discussion_content":"理解了ctx,也就理解select。当外部context通知取消请求时，会在检查一下当前是否请求成功了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605611248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2730577,"avatar":"","nickname":"kdocs服务组2","note":"","ucode":"F1B0D5EB2E4B31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":532097,"discussion_content":"可以理解成再给一次复活的机会吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637512762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":509689,"ip_address":""},"score":532097,"extra":"{\"user_type\":1}"}]},{"author":{"id":1368768,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e2/c0/e7a59706.jpg","nickname":"chongsheng","note":"","ucode":"859DF328FCA608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544298,"discussion_content":"我的理解是，如果ctx和ready恰好同时收到消息，如果select选了ctx的执行，就会错过这次的ready。所以在ctx的分支里再判断一次是否ready","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641460647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261696,"user_name":"容易","can_delete":false,"product_type":"c1","uid":1430110,"ip_address":"","ucode":"E89208FA6815EA","user_header":"https://static001.geekbang.org/account/avatar/00/15/d2/5e/f7f45406.jpg","comment_is_top":false,"comment_ctime":1605492844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605492844","product_id":100061801,"comment_content":"老师的题还是有难度的","like_count":0},{"had_liked":false,"id":261657,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1605482855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605482855","product_id":100061801,"comment_content":"打卡。","like_count":0}]}