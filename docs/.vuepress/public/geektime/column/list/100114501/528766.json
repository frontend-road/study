{"id":528766,"title":"08｜视频：入门篇实操总结","content":"<p>你好，我是Chrono。</p><p>今天的课程和前面的不太一样，变成了视频的形式。之前也讲过很多次学习Kubernetes要以动手实操为主，加上专栏里单纯的文字配图的形式还是不太直观，所以每到一个学习阶段，我们就会来一个视频总结，把之前学习的内容以视频的形式展现出来，这样也许会让学习的效果更好。</p><p>这次视频课程的主要内容和第7讲差不多，是对“入门篇”的回顾与总结，但侧重点是对Docker的实际操作，不会再重复讲那些理论知识。每个视频后都会附上操作要点，供你快速定位和做笔记。</p><p>好了，我们正式开始吧。</p><hr><h2>一. 熟悉Docker的使用</h2><p><video poster=\"https://static001.geekbang.org/resource/image/25/55/25af57e246123f14a6cfd3c1769eee55.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4c51568-181665185d1-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/9a4443aa451e4e52bc47e835d4982575/e508af03a78646e6a609c1675b3b4eaf-18ed73d12a22be0dedc6e110038bdc7d-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>首先来操作一下Docker Engine。</p><p>（有了<a href=\"https://time.geekbang.org/column/article/528614\">课前准备</a>的基础）在这台机器上，Docker已经安装好了，我给你用 <code>docker version</code> 和 <code>docker info</code> 看一下它的信息。</p><p><code>docker version</code> 显示的是Docker Engine 20.10.12，系统是Linux，硬件架构是arm64，也就是Apple M1。</p><p><code>docker info</code> 显示的是当前系统相关的信息，例如CPU、内存、容器数量、镜像数量、容器运行时、存储文件系统等等。这里存储用的文件系统是overlay2，Linux内核是5.13，操作系统是Ubuntu 22.04 Jammy Jellyfish，硬件是aarch64，两个CPU，内存4G。</p><!-- [[[read_end]]] --><p>现在我们用 <code>docker ps</code> 看一下容器列表，应该是空的。</p><p>然后用 <code>docker pull</code> 拉取busybox镜像，再用 <code>docker images</code> 看镜像列表。</p><p>使用 <code>docker run</code> 启动busybox镜像，执行最简单的hello world：</p><pre><code class=\"language-plain\">docker run busybox echo hello world\n</code></pre><p>然后再用 <code>docker ps -a</code> 查看已经结束的容器列表，应该可以看到刚刚运行完毕的Busybox容器，可以用 <code>docker rm</code> 再加上容器ID删除它。</p><h2>二. 镜像和容器</h2><p><video poster=\"https://static001.geekbang.org/resource/image/b4/e6/b49b55222fb8f7edfa90b353665976e6.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/5a397d17-181665181d0-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/4c0937f2f02e48919df26de95d3c677f/46ab2d64899941ec964f40efe9812f7a-cc0e523e3afd2b218d24e278e36d4830-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>我们再来拉取另一个镜像，操作系统Alpine：</p><pre><code class=\"language-plain\">docker pull alpine\n</code></pre><p>然后用 <code>docker run</code>，加上it参数，运行它里面的shell：</p><pre><code class=\"language-plain\">docker run -it alpine sh\n</code></pre><p>这样就暂时离开当前的Ubuntu操作系统，进入了容器内部的Alpine系统，可以在里面执行任意的命令，比如 <code>cat /etc/os-release</code> 。</p><p>这个容器环境与外面是完全隔离的，进程、文件系统都独立，不过也有没有隔离的部分，比如时间和内核。</p><p>使用exit退出容器，然后在宿主机环境执行date、uname -a，你就可以看到它与容器里是一致的。</p><p>让我们再运行一个容器：</p><pre><code class=\"language-plain\">docker run -d --rm nginx:alpine\n</code></pre><p>在宿主机里用 <code>ps -ef|grep nginx</code> 可以看到有3个Nginx进程，它们其实就是容器里的Nginx进程，用docker stop停止后再用ps，就能发现它们已经消失了。</p><p>这就证明，容器其实就是操作系统里的进程，只是被容器运行环境加上了namespace、cgroup、chroot的限制，所以容器和普通进程在资源的使用方面是没有什么区别的，也因为没有虚拟机的成本，启动更迅速，资源利用率也就更高。</p><h2>三. 构建自己的镜像</h2><p><video poster=\"https://static001.geekbang.org/resource/image/81/76/810c79a88d283ac8231252578f7e2176.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/5afa4eec-18166517d5b-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/b095f9aee4fe483f9de80a3fd9b38c02/1e0e936531324001a869c4607f4cebea-d4e2fceb2adfb0b1de22540bd48af3e9-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>现在让我们来尝试编写Dockerfile，构建一个自己的镜像。</p><p>这个Dockerfile先用arg指令定义了IMAGE_BASE、IMAGE_TAG两个变量，然后使用from指令指定了构建的基础镜像，把这两个变量结合起来就是 <code>nginx:1.21-alpine</code> 。</p><p>后面的两个env指令定义了PATH和DEBUG两个环境变量。arg指令定义的变量只能在构建镜像的时候使用，而env定义的变量则会在容器运行的时候以环境变量的形式出现，让进程运行时使用。</p><p>接下来是copy指令，它会把构建上下文里的./default.conf拷贝到镜像的/etc/nginx/conf.d/，注意copy指令不能使用绝对路径，必须是构建上下文的相对路径，而且Docker会把构建上下文里的所有文件打包传递给docker daemon，所有尽量只包含必要的文件。</p><p>run指令就是构建镜像时要执行的shell命令，可以是安装软件、创建目录、编译程序等等，这里只是简单地用echo命令生成了一个文本文件。</p><p>最后两条指令是 <code>expose</code> 和 <code>workdir</code>，<code>expose</code> 是声明容器对外服务的端口号，而 <code>workdir</code> 是容器的工作目录。</p><p>了解了Dockerfile的内容之后，我们就要用 <code>docker build</code> 来构建镜像了，使用 <code>-t</code> 打上标签，再加上构建上下文路径，当前目录就用一个点号 <code>.</code>：</p><pre><code class=\"language-plain\">docker build -t ngx-app:1.0 .\n</code></pre><p>构建完成，生成镜像文件，我们可以用 <code>docker run</code> 从镜像启动容器，验证镜像里的文件是否正确生成：</p><pre><code class=\"language-plain\">docker run -it --rm ngx-app:1.0 sh\n</code></pre><p>然后我们还可以用 <code>docker save/load</code> 命令把它导出成压缩包，方便保存和传输：</p><pre><code class=\"language-plain\">docker save ngx-app:1.0 -o ngx.tar\ndocker load -i ngx.tar\n</code></pre><h2>四. 与外部系统互通的操作</h2><p><video poster=\"https://static001.geekbang.org/resource/image/a8/30/a8e77be641768257973d358108f5fc30.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2e56a0f-1816651784d-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/fc59f80b70d649b5a419cb501c38ec3d/84530275ba9342eea09b1c625abc92c6-5d237100c7ca337e30679ca010665c0f-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>接下来我们看看容器与外部系统互通的一些操作。</p><p>首先是 <code>docker cp</code> 命令。让我们先启动一个Redis容器：</p><pre><code class=\"language-plain\">docker run -d --rm redis\n</code></pre><p>然后用 <code>echo</code> 命令生成一个简单的文本文件：</p><pre><code class=\"language-plain\">echo 'aaa' &gt; a.txt\n</code></pre><p>用 <code>docker ps</code> 命令看看容器的ID，就可以使用 <code>docker cp</code> 命令把这个文件拷贝进容器里了：</p><pre><code class=\"language-plain\">docker cp a.txt 062:/tmp\n</code></pre><p>使用 <code>docker exec</code> 可以进入容器内部，查看文件是否已经正确拷贝：</p><pre><code class=\"language-plain\">docker exec -it 062 sh\nls /tmp\n</code></pre><p>退出容器，我们再把这个文件改个名字，拷贝出来：</p><pre><code class=\"language-plain\">docker cp 062:/tmp/a.txt ./b.txt\n</code></pre><p>现在我们再看看用 <code>-v</code> 参数直接挂载本地目录，把文件直接映射到容器内部：</p><pre><code class=\"language-plain\">docker run -d --rm -v /tmp:/tmp redis\n</code></pre><p>用 <code>docker exec</code> 进入容器，查看一下容器内的“/tmp”目录，应该就可以看到文件与宿主机是完全一致的。</p><pre><code class=\"language-plain\">docker exec -it b5a sh    # b5a是容器ID\n</code></pre><p><code>-p</code> 参数是映射本机端口到容器端口，我们启动一个Nginx容器，把本机的80端口映射到容器的80端口：</p><pre><code class=\"language-plain\">docker run -d -p 80:80 --rm nginx:alpine\n</code></pre><p><code>docker ps</code> 可以看到端口的映射情况，我们也可以使用curl直接访问容器里的Nginx服务：</p><pre><code class=\"language-plain\">curl 127.1:80&nbsp; &nbsp;-I\n</code></pre><p>再使用exec就可以看到容器里的网卡情况：</p><pre><code class=\"language-plain\">docker exec xxx ip addr\n</code></pre><p>可以发现容器里的网卡设置与宿主机完全不同，eth0是一个虚拟网卡，IP地址是B类私有地址“172.17.0.2”。</p><h2>五. 搭建WordPress</h2><p><video poster=\"https://static001.geekbang.org/resource/image/69/48/690b86fd45b8f1230114baa1544c9e48.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/56fd1dc1-18166517561-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/07d309caab5d44a58b71ae70196f73ca/a6ac52dd3c924285baa73513dba793c1-17d1dceebc373ab88398d3629492520d-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>视频操作要点：</p><p>最后演示一下使用Docker搭建WordPress的过程。</p><p>因为在Docker命令里写环境变量很麻烦，命令很长，所以我把搭建的过程写成了一个脚本。</p><p>一共有三条命令，首先启动MariaDB，设置数据库名、用户名、密码等环境变量，然后启动WordPress，使用刚才的MariaDB的用户名、密码，db_host必须是MariaDB的IP地址，然后再启动Nginx，它需要在配置文件里指定WordPress的地址，然后用-v参数挂载进容器里。</p><p>执行这个脚本之后，我们用 <code>docker ps</code> 看一下容器的状态。</p><p>确认容器都运行正常，我们就可以在浏览器里输入IP地址，访问WordPress网站了。</p><h2>课下作业</h2><p>今天是动手操作课，作业就是一定记得让自己实际上手操作一遍哦。</p><p>欢迎在留言区分享自己的实操感受，如果有什么疑问也欢迎留言分享参与讨论。我们下节课初级篇见。</p>","neighbors":{"left":{"article_title":"07｜实战演练：玩转Docker","id":528740},"right":{"article_title":"09｜走近云原生：如何在本机搭建小巧完备的Kubernetes环境","id":529780}},"comments":[]}