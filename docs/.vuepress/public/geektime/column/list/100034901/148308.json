{"id":148308,"title":"20 | 存储和并发：万人群聊系统设计中的几个难点","content":"<p>你好，我是袁武林。</p><p>我在场景篇的第10讲<a href=\"https://time.geekbang.org/column/article/137000\">“自动智能扩缩容：直播互动场景中峰值流量的应对”</a>中，分析了直播互动场景中，容易出现瓶颈的原因主要在于：“直播间人数多，短时间内活跃度高，消息的扇出量巨大”。</p><p>那么，对于同样属于多人互动的群聊场景来说，虽然在“群人数”等方面与高热度的直播间相比要少一些，但由于同时开播的直播间数量一般不会太多，所以群在数量上的总体量级相对要大得多，可能上百万个群同时会有消息收发的情况发生。因此，在整体的流量方面，群聊场景的消息扇出也是非常大的。</p><p>而且和直播互动场景不太一样的是，直播互动中，热度高的直播活动持续时间都比较短，可以借助上云，来进行短时间的扩容解决，成本方面也比较可控；但群聊的场景，一般是流量总量高，但是峰值没有那么明显，靠扩容解决不太现实。因此，更多地需要我们从架构和设计层面来优化。</p><p>今天，我们就一起从架构设计层面，来聊一聊万人群聊系统中的几个难点，以及相应的解决方案。</p><h2>群聊消息怎么存储？</h2><p>首先来看一看群聊消息存储的问题。</p><p>关于点对点聊天场景，我在第2课<a href=\"https://time.geekbang.org/column/article/127978\">“消息收发架构：为你的App，加上实时通信功能”</a>中也有讲到：我们在一条消息发出后，会针对消息收发的双方，各自存储一条索引，便于双方进行查询、删除、撤回等操作。</p><!-- [[[read_end]]] --><p>那么，对于群聊消息来说，是不是也需要给群里的每一个用户，都存储一条消息索引呢？</p><p>这里需要注意的是：对于点对点聊天来说，针对消息收发双方进行用户维度的索引存储，能便于后续会话维度的消息查看和离线消息的获取，但如果群聊场景也采取这种方式，那么假设一个群有一万个人，就需要针对这一万个人都进行这一条消息的存储，一方面会使写入并发量巨大，另一方面也存在存储浪费的问题。</p><p>所以，业界针对群聊消息的存储，一般采取“读扩散”的方式。也就是一条消息只针对群维度存储一次，群里用户需要查询消息时，都通过这个群维度的消息索引来获取。</p><p>用户查询群聊消息的大概流程，你可以参考下图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/90/4e/90d8e743b86a2db8474cc00a7cd2d14e.png?wh=640*440\" alt=\"\"></p><p>系统先查询这个用户加入的所有群，根据这些群的最新一条消息的ID（消息ID与时间相关），或者最新一条消息的产生时间，来进行“最近联系人”维度的排序，再根据这些群ID获取每个群维度存储的消息。</p><h3>怎么保证新加入群的用户只看到新消息？</h3><p>群聊用户共用群维度的消息存储，能大幅降低用户维度消息的写入。</p><p>但这里有一个问题：如果群消息是共享的，怎么保证新加入群的用户看不到加群前的群聊消息呢？</p><p>解决这个问题其实比较简单，你可以采取下图这个方案：<br>\n<img src=\"https://static001.geekbang.org/resource/image/a1/ce/a19de4332253082f0324c2e6cdc294ce.png?wh=640*440\" alt=\"\"></p><p>我们只需要在用户加群的时候，记录一个“用户加群的信息”，把用户加群时间、用户加群时该群最新一条消息的ID等信息存储起来，当用户查询消息时，根据这些信息来限制查询的消息范围就可以了。</p><h3>单个用户删除消息怎么办？</h3><p>除了新加群用户消息查询范围的问题，群消息共享存储方案在实现时，还有一个比较普遍的问题：如果群里的某一个用户删除了这个群里的某条消息，我们应该怎么处理？</p><p>首先，由于群消息是共用的，我们肯定不能直接删除群消息索引中的记录。</p><p>一个可行的办法是：在用户删除消息的时候，把这条被删除消息加入到当前用户和群维度的一个删除索引中；当用户查询消息时，我们对群维度的所有消息，以及对这个“用户和群维度”的删除索引进行聚合剔除就可以了。</p><p>同样的处理，你还可以用在其他一些私有类型的消息中。比如，只有自己能看到的一些系统提示类消息等。</p><h2>未读数合并变更</h2><p>解决了群聊消息存储的问题，还有一个由于群聊消息高并发扇出而引起的问题。</p><p>我在<a href=\"https://time.geekbang.org/column/article/132598\">“07 | 分布式锁和原子性：你看到的未读消息提醒是真的吗？”</a>这一篇中讲到过：针对每一个用户，我们一般会维护两个未读数，用于记录用户在某个群的未读消息数和所有未读数。</p><p>也就是说，当群里有人发言时，我们需要对这个群里的每一个人都进行“加未读”操作。因此，对于服务端和未读数存储资源来说，整体并发的压力会随着群人数和发消息频率的增长而成倍上升。</p><p>以一个5000人的群为例：假设这个群平均每秒有10个人发言，那么每秒针对未读资源的变更QPS就是5w；如果有100个这样的群，那么对未读资源的变更压力就是500w，所以整体上需要消耗的资源是非常多的。</p><p>解决这个问题的一个可行方案是：在应用层对未读数采取<strong>合并变更</strong>的方式，来降低对存储资源的压力。</p><p>合并变更的思路大概如下图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/15/70/151bc6eb9ddb5b85ee10cc499d2a9370.png?wh=768*1142\" alt=\"\"></p><p>未读变更服务接收群聊的加未读请求，将这些加未读请求按照群ID进行归类，并暂存到群ID维度的多个“暂存队列”中；这些“暂存队列”的请求会通过一个Timer组件和一个Flusher组件来负责处理。</p><p>Timer组件负责定时刷新这些队列中的请求，比如，每一秒从这些“暂存队列”取出数据，然后交给Aggregator进行合并处理；Flusher组件则会根据这些“暂存队列”的长度来进行刷新，比如，当队列长度到达100时，Flusher就从队列中取出数据，再交给Aggregator来进行合并处理。</p><p>所以，Timer和Flusher的触发条件是：这些队列的请求中有任意一个到达，均会进行刷新操作。</p><p>提交给Aggregator的加未读请求会进行合并操作。比如针对群里的每一个用户，将多个归属于该群的加未读请求合并成一个请求，再提交给底层资源。</p><p>如上图所示，群ID为gid1里的用户uid1和uid2，通过合并操作，由4次加未读操作incr 1合并成了各自一条的加未读操作incr 2。</p><p>通过这种方式，就将加未读操作QPS降低了一半。如果每秒群里发消息的QPS是10的话，理论上我们通过这种“合并”的方式，能将QPS降低到1/10。</p><p>当然，这里需要注意的是：由于加未读操作在应用层的内存中会暂存一定时间，因此会存在一定程度的加未读延迟的问题；而且如果此时服务器掉电或者重启，可能会丢失掉一部分加未读操作。</p><p>为了提升“合并变更”操作的合并程度，我们可以通过群ID哈希的方式，将某一个群的所有未读变更操作都路由到某一台服务器，这样就能够提升最终合并的效果。</p><h3>离线Buffer只存消息ID</h3><p>通过“合并变更”，我们解决了万人群聊系统中，未读数高并发的压力问题。</p><p>接下来我们看一下，在离线推送环节中，针对群聊场景还有哪些可优化的点。</p><p>我在第9课<a href=\"https://time.geekbang.org/column/article/136020\">“分布式一致性：让你的消息支持多终端漫游？”</a>中有讲到，为了解决用户离线期间收不到消息的问题，我们会在服务端按照接收用户维度，暂存用户离线期间的消息，等该用户下次上线时再进行拉取同步。</p><p>这里的离线Buffer是用户维度的，因此对于群聊中的每一条消息，服务端都会在扇出后进行暂存。</p><p>假设是一个5000人的群，一条消息可能会暂存5000次，这样一方面对离线Buffer的压力会比较大，另外针对同一条消息的多次重复暂存，对资源的浪费也是非常大的。</p><p>要解决多次暂存导致离线Buffer并发压力大的问题，一种方案是可以参考“未读数合并变更”的方式，对群聊离线消息的存储也采用“合并暂存”进行优化，所以这里我就不再细讲了。</p><p>另一种解决方案是：我们可以对群聊离线消息的暂存进行限速，必要时可以丢弃一些离线消息的暂存，来保护后端资源。</p><p>因为通过“版本号的链表机制”，我们可以在用户上线时发现“离线消息”不完整的问题，然后再从后端消息存储中重新分页获取离线消息，从而可以将一部分写入压力延迟转移到读取压力上来。</p><p>不过这里你需要注意的是：这种降级限流方式存在丢失一些操作信令的问题，是有损降级，所以非必要情况下尽量不用。</p><p>另外，针对群聊消息重复暂存的问题，我们可以只在离线Buffer中暂存“消息ID”，不暂存消息内容，等到真正下推离线消息的时候，再通过消息ID来获取内容进行下推，以此优化群聊消息对离线Buffer资源过多占用的情况。</p><h3>离线消息批量ACK</h3><p>在群聊离线消息场景中，还有一个相对并发量比较大的环节就是：离线消息的ACK处理。</p><p>我在<a href=\"https://time.geekbang.org/column/article/129751\">“04 | ACK机制：如何保证消息的可靠投递？”</a>这节课中讲到，我们会通过ACK机制来保证在线消息和离线消息的可靠投递。但是对于群的活跃度较高的情况来说，当用户上线时，服务端针对这个群的离线消息下推量会比较大。</p><p>以微博场景中的超大规模的粉丝群为例：本来群内的用户就已经比较活跃了，如果该群隶属的明星突然空降进来，可能会导致大量离线用户被激活，同一时间会触发多个用户的离线消息下推和这些离线消息的ACK；针对离线消息接收端的ACK回包，服务端需要进行高并发的处理，因而对服务端压力会比较大。</p><p>但实际上，由于群聊离线消息的下推发生在用户刚上线时，这个时候的连接刚建立，稳定性比较好，一般消息下推的成功率是比较高的，所以对ACK回包处理的及时性其实不需要太高。</p><p>因此，一种优化方案是：<strong>针对离线消息接收端进行批量ACK</strong>。</p><p>参照TCP的Delay ACK（延迟确认）机制，我们可以在接收到离线推送的消息后，“等待”一定的时间，如果有其他ACK包需要返回，那么可以对这两个回包的ACK进行合并，从而降低服务端的处理压力。</p><p>需要注意的是：接收端的Delay ACK，可能会在一定程度上加剧消息重复下推的概率。比如，ACK由于延迟发出，导致这时的服务端可能会触发超时重传，重复下推消息。</p><p>针对这个问题，我们可以通过接收端去重来解决，也并不影响用户的整体体验。</p><h3>不记录全局的在线状态</h3><p>群聊场景下的超大消息扇出，除了会加大对离线消息的资源消耗，也会对消息的在线下推造成很大的压力。</p><p>举个例子：在点对点聊天场景中，我们通常会在用户上线时，记录一个“用户连接所在的网关机”的在线状态，而且为了和接入服务器解耦，这个在线状态一般会存储在中央资源中；当服务端需要下推消息时，我们会通过这个“中央的在线状态”来查询接收方所在的接入网关机，然后把消息投递给这台网关机，来进行最终消息的下推。</p><p>在群聊场景中，很多实现也会采用类似方式进行在线消息的精准下推，这种方案在群人数较少的时候是没问题的，但是当群成员规模很大时，这种方式就会出现瓶颈。</p><p>一个瓶颈在于，用户上线时对“在线状态”的写入操作；另一个瓶颈点在于，服务端有消息下推时，对“在线状态”的高并发查询。</p><p>因此，针对万人群聊的场景，我们可以采取类似直播互动中的优化方式，不维护全局的中央“在线状态”，而是让各网关机“自治”，来维护接入到本机的连接和群的映射。你可以参考下图所示的实现过程：<br>\n<img src=\"https://static001.geekbang.org/resource/image/24/cd/2427222d320850a08e76f7200cf094cd.png?wh=768*1142\" alt=\"\"></p><p>比如同一个群的用户A、B、C，分别通过网关机1、2、3上线建立长连，处理建连请求时，网关机1、2、3 会分别在各自的本地内存维护当前登录的用户信息。</p><p>上线完成后，用户A在群里发了一条消息，业务逻辑处理层会针对这条消息进行处理，查询出当前这条消息所归属群的全部用户信息，假设查询到这个群一共有3人，除去发送方用户A，还有用户B和用户C。</p><p>然后业务逻辑处理层把消息扇出到接收人维度，投递到全局的消息队列中；每一台网关机在启动后都会订阅这个全局的Topic，因此都能获取到这条消息；接着，各网关机查询各自本地维护的“在线用户”的信息，把归属本机的用户的消息，通过长连下推下去。</p><p>通过这种方式，消息下推从“全局的远程依赖”变成了“分片的本地内存依赖”，性能上会快很多，避免了服务端维护全局在线状态的资源开销和压力。</p><h2>小结</h2><p>今天的课程，我主要是分析了一些在万人群聊场景中比较突出和难解决的问题，并给出了针对性的应对方案。比如以下几种：</p><ul>\n<li>针对群聊消息的存储，我们可以从点对点的<strong>“写扩散”优化成“读扩散”</strong>，以解决存储写入并发大和资源开销大的问题；</li>\n<li>针对高热度的群带来的“高并发未读变更”操作，我们可以通过<strong>应用层的“合并变更”</strong>，来缓解未读资源的写入压力；</li>\n<li>对于离线消息的优化，我们只需要存储消息ID，避免重复的消息内容存储浪费离线Buffer资源，还可以参考TCP的Delay ACK机制，<strong>在接收方层面进行批量ACK</strong>，降低服务端的处理并发压力；</li>\n<li>对于单聊场景中依赖“中央全局的在线状态”，来进行消息下推的架构瓶颈，我们可以在群聊场景中优化成<strong>“网关机本地自治维护”</strong>的方式，以此解决高并发下推时，依赖全局资源容易出现瓶颈的问题，从而提升群聊消息在线下推的性能和稳定性。</li>\n</ul><p>针对大规模群聊系统的架构优化，一直是即时消息场景中非常重要和必要的部分，也是体现我们架构能力和功底的环节。</p><p>今天课程中介绍的针对万人群聊系统优化的一些应对方案，很多都具备普适性，比如“未读合并变更”的方案，实际上也能应用在很多有写入瓶颈的业务上（如DB的写入瓶颈），在微博的线上业务中，目前也被大范围使用。你也可以看一看，自己的业务中是否也有类似可优化的场景，可以尝试来参考这个方案进行优化。</p><p>最后给大家留一个思考题：<strong>点对点消息的在线下推，也适合采用“网关机自治维护本地在线状态”的方式吗？说说你的看法吧。</strong></p><p>以上就是今天课程的内容，欢迎你给我留言，我们可以在留言区一起讨论，感谢你的收听，我们下期再见。</p><p></p>","neighbors":{"left":{"article_title":"19 | 端到端Trace：消息收发链路的监控体系搭建","id":146995},"right":{"article_title":"21 | 期末实战：为你的简约版IM系统，加上功能","id":149644}},"comments":[{"had_liked":false,"id":139950,"user_name":"clip","can_delete":false,"product_type":"c1","uid":1019244,"ip_address":"","ucode":"D0E142605A5BD5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/6c/0c2a26c7.jpg","comment_is_top":false,"comment_ctime":1570772284,"is_pvip":true,"replies":[{"id":"54450","content":"基本没错，不过这里有一点说一下：不管是不是网关机维护本地状态的方式，消息最终下发都是需要通过网关机推下去的哈，只是网关机本地维护状态的方式会浪费掉一些其他网关机的计算。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571056888,"ip_address":"","comment_id":139950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40225477948","product_id":100034901,"comment_content":"思考题：<br>看情况考虑。<br>不好的地方：<br>所有网关机都要从消息队列消费这条数据，但最终只有一台机器处理，比较浪费处理资源。对这条消息而言本来可以直接下推，结果要多经过了网关机，实时性可能会受到大群的影响。<br>好的地方：<br>不过采用网关机方案可以省去维护中央的在线状态。<br>决定：<br>可以根据业务的特点权衡一下，如果主要的会话都发生在群聊，私聊极少且实时性要求低那可以采用网关机维护的方案，反之不采用。","like_count":10,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470188,"discussion_content":"基本没错，不过这里有一点说一下：不管是不是网关机维护本地状态的方式，消息最终下发都是需要通过网关机推下去的哈，只是网关机本地维护状态的方式会浪费掉一些其他网关机的计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571056888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139921,"user_name":"zhxh","can_delete":false,"product_type":"c1","uid":1015791,"ip_address":"","ucode":"40C3CC0A0A3028","user_header":"","comment_is_top":false,"comment_ctime":1570766299,"is_pvip":false,"replies":[{"id":"54441","content":"不需要建连时耦合群信息相关内容，这个问题可以采用分批下发给网关来解决，比如一批100这样。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571056477,"ip_address":"","comment_id":139921,"utype":1}],"discussion_count":5,"race_medal":0,"score":"31635537371","product_id":100034901,"comment_content":"如果通过订阅的方式，那么这条消息应该也需要把群成员列表带给网关吧，否则网关怎么筛选，可是万人群成员比较多，会导致这个消息包比较大，如果不带成员列表信息到网关，那么要求用户在和网关建立连接的时候，就要把自己加入的群列表信息带过来，绑定到网关，这样逻辑似乎和网关耦合比较严重，老师能详细解释一下么","like_count":7,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470174,"discussion_content":"不需要建连时耦合群信息相关内容，这个问题可以采用分批下发给网关来解决，比如一批100这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571056477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64395,"discussion_content":"原文提到：\n假设查询到这个群一共有 3 人，除去发送方用户 A，还有用户 B 和用户 C。\n然后业务逻辑处理层把消息扇出到『接收人维度』，投递到全局的消息队列中；……\n接着，各网关机把归属本机的用户的消息，通过长连下推下去。\n\n\n万人群的消息推送，假设群里除了发送者，还有 10000 人。则业务层需要发 10000 条消息到 mq。\ngid1, msg1, uid1\ngid1, msg1, uid2\ngid1, msg1, uid3\n…\ngid1, msg1, uid10000\n\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574947359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024994,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/e2/5cb4f43f.jpg","nickname":"laolinshi","note":"","ucode":"269B879389D7D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558851,"discussion_content":"由于网关机不关注用户属于哪个群，所以推送给网关机的消息不需要带群ID的，为了减少各个网关机订阅的消息量，可以采用批量下发的方式，比如100个用户作为一批:\nmsg1，userid1,userid2,userid3,...........userid100\nmsg1,   userid101,.............userid200\n................\n网关机接收到队列中消息后，从信息中解析出用户ID列表，根据用户ID获得这个用户对应的长连接通道，最后把聊天消息推送给用户。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648484466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f6/bd/b37fc892.jpg","nickname":"薛新荣","note":"","ucode":"60BD2DD1C68F8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226077,"discussion_content":"这种离线推送怎么处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586419194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30546,"discussion_content":"我也有这个疑问.\n\n如果是万人群, 用户唯一编号按4字节/16字节,该用户信息也有39KB/156KB.\n这个信息肯定比消息本事的内容大多了.\n\n除非该群会话的聊天消息也做缓存,比如0.5s/1s推送一次, 否则每条消息都加这个头,开销有点大啊.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570842056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140090,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1570805388,"is_pvip":false,"replies":[{"id":"54461","content":"之前有提到微信手机端应该走的是tcp私有协议，不是websocket。另外你提到的websocket弱网下容易掉线这个得具体case分析一下，不能把这个归结到websocket协议本身，底层一样都是基于tcp来传输的。连接不稳定和很多因素有关，连接入口的是否够快，有没有故障转移通道，能否快速识别到连接断开然后快速进行重连，网络传输的数据是否够小够精简，这些都有关系。微信有一些公开对外演讲的资料，可以查一下。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571057776,"ip_address":"","comment_id":140090,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23045641868","product_id":100034901,"comment_content":"老师 用websocket做长链接通信在网络较好情况下没什么问题 但在弱网下如2g 3g下就会频繁掉线，但是微信却做的这么好，地铁里仍然很稳定，它走的绝对不是websocket，它怎么做到的这么稳定通畅呢？有什么资料可以查看学习吗。","like_count":5,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470240,"discussion_content":"之前有提到微信手机端应该走的是tcp私有协议，不是websocket。另外你提到的websocket弱网下容易掉线这个得具体case分析一下，不能把这个归结到websocket协议本身，底层一样都是基于tcp来传输的。连接不稳定和很多因素有关，连接入口的是否够快，有没有故障转移通道，能否快速识别到连接断开然后快速进行重连，网络传输的数据是否够小够精简，这些都有关系。微信有一些公开对外演讲的资料，可以查一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571057776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137203,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5a/33/9a66d0b8.jpg","nickname":"Csquare","note":"","ucode":"23CAC353A82D1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31796,"discussion_content":"基础篇里好像有提到，是基于TCP 长连接定制的私有协议吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570958399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1258474,"avatar":"","nickname":"墙角儿的花","note":"","ucode":"EE5CAD76175CCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1137203,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5a/33/9a66d0b8.jpg","nickname":"Csquare","note":"","ucode":"23CAC353A82D1D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":31839,"discussion_content":"嗯 你有更多资料吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570962272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":31796,"ip_address":""},"score":31839,"extra":""}]}]},{"had_liked":false,"id":139946,"user_name":"clip","can_delete":false,"product_type":"c1","uid":1019244,"ip_address":"","ucode":"D0E142605A5BD5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/6c/0c2a26c7.jpg","comment_is_top":false,"comment_ctime":1570771729,"is_pvip":true,"replies":[{"id":"54445","content":"嗯，是的，私有消息是聚合，删除是剔除。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571056716,"ip_address":"","comment_id":139946,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14455673617","product_id":100034901,"comment_content":"群聊的私有类型消息是不是要采用补齐而不是剔除的逻辑？因为加了一条仅自己可见的消息给其他人都创建不可见索引就得不偿失了。","like_count":3,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470185,"discussion_content":"嗯，是的，私有消息是聚合，删除是剔除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571056716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30541,"discussion_content":"跟我的疑问一样,正准备提出来的.谢谢你已经提了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570841880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019244,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/6c/0c2a26c7.jpg","nickname":"clip","note":"","ucode":"D0E142605A5BD5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30709,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570853761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":30541,"ip_address":""},"score":30709,"extra":""}]}]},{"had_liked":false,"id":203822,"user_name":"🐒子","can_delete":false,"product_type":"c1","uid":1270633,"ip_address":"","ucode":"46072075475E7F","user_header":"https://static001.geekbang.org/account/avatar/00/13/63/69/7275dccc.jpg","comment_is_top":false,"comment_ctime":1586270430,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10176205022","product_id":100034901,"comment_content":"老师 你好 我之前也做过im系统 但是在存储部分用 数据库选型有什么推荐吗","like_count":2,"discussions":[{"author":{"id":1203563,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5d/6b/3d42593f.jpg","nickname":"聪少","note":"","ucode":"AB8301B752AC30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286834,"discussion_content":"foundationdb了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593307964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178756,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/84/9f8afa9b.jpg","nickname":"瑜斌","note":"","ucode":"171FAF5736F334","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273087,"discussion_content":"同问，群聊或聊天室记录怎么存储合理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590409505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139987,"user_name":"我行我素","can_delete":false,"product_type":"c1","uid":1224678,"ip_address":"","ucode":"4C69542FAB0671","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg","comment_is_top":false,"comment_ctime":1570780826,"is_pvip":false,"replies":[{"id":"54452","content":"其实就是把群聊消息删除这个单独记录一下，比如一个list里面，key是 uid_群id，value是这个uid在这个群删除的消息id。最后这个用户获取群消息时，从群维度的全量消息里剔除掉这个用户在这个群删除的这些消息id。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571057040,"ip_address":"","comment_id":139987,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10160715418","product_id":100034901,"comment_content":"老师，想请问下：在用户删除消息的时候，把这条被删除消息加入到当前用户和群维度的一个删除索引中，这一步不是很明白","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470200,"discussion_content":"其实就是把群聊消息删除这个单独记录一下，比如一个list里面，key是 uid_群id，value是这个uid在这个群删除的消息id。最后这个用户获取群消息时，从群维度的全量消息里剔除掉这个用户在这个群删除的这些消息id。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571057040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1649662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","nickname":"pdf","note":"","ucode":"A44250955878BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551922,"discussion_content":"老师，如果查询的时候没有办法连表的话，该怎么查询呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645174298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":470200,"ip_address":""},"score":551922,"extra":""}]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30537,"discussion_content":"尝试回答下,不一定对.\n\n可以在另外一个表中记录,某个用户,在某个群中,删除了哪些消息.\n这样在查询该群消息时,根据已删除的消息去做过滤.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570841833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139854,"user_name":"🐾","can_delete":false,"product_type":"c1","uid":1087256,"ip_address":"","ucode":"D0AD0260351C31","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/18/a5218104.jpg","comment_is_top":false,"comment_ctime":1570756745,"is_pvip":false,"replies":[{"id":"54433","content":"1. 是的。<br>2. 一般这种情况可以只下推离线消息，历史消息通过用户来触发拉取。<br>3. 不保存消息记录是指客户端不在本地存储所有消息？这种方式不太好呀，要不没网就看不了所有聊天记录了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571056181,"ip_address":"","comment_id":139854,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10160691337","product_id":100034901,"comment_content":"老师上午好、有些疑惑想跟您确认一下，消息多终端漫游，为解决用户离线期间收不到消息的问题，我们会在服务端按照接收用户维度，暂存用户离线期间的消息，等该用户下次上线时再进行拉取同步。<br>1、这里的同步，实际上是把服务端的消息同步到客户端，客户端也保存这些消息吧？<br>2、假如用户重新安装了APP，把客户端保存的数据也清空了，像这种情况下，一般处理是只同步离线消息，不同步历史数据吗？<br>3、如果客户端不保存消息记录，但又要显示所有历史数据，是不是不需要设计这个离线存储了，直接读取会话维度的所有消息就好？","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470143,"discussion_content":"1. 是的。\n2. 一般这种情况可以只下推离线消息，历史消息通过用户来触发拉取。\n3. 不保存消息记录是指客户端不在本地存储所有消息？这种方式不太好呀，要不没网就看不了所有聊天记录了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571056181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139846,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1570755546,"is_pvip":false,"replies":[{"id":"54443","content":"这个是个问题，实际上也可以不需要按照uid维度来存储消息，按照消息维度存储已上报过 阅读事件的uid就可以。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571056660,"ip_address":"","comment_id":139846,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10160690138","product_id":100034901,"comment_content":"群聊信息如果不采用收发箱的方式存储，碰见钉钉这种需要记录查看一条群消息哪些成员已阅，哪些未阅，就无能为力了","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470139,"discussion_content":"这个是个问题，实际上也可以不需要按照uid维度来存储消息，按照消息维度存储已上报过 阅读事件的uid就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571056660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211987,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/53/c29c2fc9.jpg","nickname":"sdjdd","note":"","ucode":"512F2338DFF793","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29276,"discussion_content":"和消息删除一样，再维护一个已阅表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570758998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1258474,"avatar":"","nickname":"墙角儿的花","note":"","ucode":"EE5CAD76175CCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211987,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7e/53/c29c2fc9.jpg","nickname":"sdjdd","note":"","ucode":"512F2338DFF793","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29918,"discussion_content":"一样的 已阅表会比较大 存储省不下来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570790781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":29276,"ip_address":""},"score":29918,"extra":""}]}]},{"had_liked":false,"id":187476,"user_name":"kamida","can_delete":false,"product_type":"c1","uid":1904146,"ip_address":"","ucode":"16D7CA59870AC0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jXbwicoDwia7ooDfwBTRyvNYQkefnVwF1CMicMS8FqKfuFAdvVZo2pqc4ic0R9kSdHTIxaE6YyqxwX8BdNGv5PqSIw/132","comment_is_top":false,"comment_ctime":1584128526,"is_pvip":false,"replies":[{"id":"72532","content":"timer和flusher是共用的，因为加未读是uid维度的，所以最终执行时按照uid来归并就可以了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1584279948,"ip_address":"","comment_id":187476,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879095822","product_id":100034901,"comment_content":"老师 timer和flusher是所有群共用一个吗 那他们是怎么分别track不同的群的呢","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487115,"discussion_content":"timer和flusher是共用的，因为加未读是uid维度的，所以最终执行时按照uid来归并就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584279948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153850,"user_name":"yic","can_delete":false,"product_type":"c1","uid":1201577,"ip_address":"","ucode":"C8DC471B7C28B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/55/a9/5282a560.jpg","comment_is_top":false,"comment_ctime":1574318342,"is_pvip":false,"replies":[{"id":"59885","content":"像微博是千万级在线，微信具体数据不太清楚。单台网关机虽然理论上能到百万级别，但线上一般控制在几十万比较正常，如果是类似直播的业务会控制在更低水平。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1574771878,"ip_address":"","comment_id":153850,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869285638","product_id":100034901,"comment_content":"老师，看了这么多节课程，突然有个问题想问：像微博、微信等这些APP一般的实时在线人数大概是什么量级？一台网关机大概能承载多少在线用户呀？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475296,"discussion_content":"像微博是千万级在线，微信具体数据不太清楚。单台网关机虽然理论上能到百万级别，但线上一般控制在几十万比较正常，如果是类似直播的业务会控制在更低水平。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574771878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141215,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1571129699,"is_pvip":false,"replies":[{"id":"54737","content":"哈哈，感谢支持和肯定~","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571225330,"ip_address":"","comment_id":141215,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866096995","product_id":100034901,"comment_content":"    其实点对点的在线下推：个人理解就是非常考验中间件存储&#47;数据系统的设计，不合理的设计必然造成某块的负载过大，如何合理的设计和使用这些东西会成为关键。<br>   老师的图中就有MQ和RMDB其实还有Nosql DB：刚好今天李玥老师的MQ刚刚完课，看完了老师的21课反向来学习这课的；看过国内的一些IM，其实这块真实的设计都被隐藏了；个人觉得这块如何修正成为自己的东西如何利用和设计好中间件存储应当是IM设计的一块重点和难点。<br>    IM有听闻说简单的可是老师的课程学到现在：我发现如何合理的设计应用架构、数据系统、以及配合合适的监控应当是系统成败的关键。谢谢老师辛勤的分享以及困惑时的提点和教诲。","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470698,"discussion_content":"哈哈，感谢支持和肯定~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571225330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140555,"user_name":"黄海","can_delete":false,"product_type":"c1","uid":1011156,"ip_address":"","ucode":"AC45303035622E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/L8Hia5sfiafASmBa3eTLMH8C25gMCHLTXddMkIiaCb0ky48FowibUrLQ9WSeTxSIS3prFsSjiaarwbRp1kTXDbug9eQ/132","comment_is_top":false,"comment_ctime":1570984455,"is_pvip":false,"replies":[{"id":"54464","content":"这个方案的问题在于：群聊的使用场景并不存在说“某个用户在某个群在线”这么个说法，和直播的房间概念是不一样的。可以认为只要用户上线就应该处理所有群的消息。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571058159,"ip_address":"","comment_id":140555,"utype":1}],"discussion_count":5,"race_medal":0,"score":"5865951751","product_id":100034901,"comment_content":"请袁老师看一下这样的方案行吗：把各台网关机上的在线群(在线群成员数&gt;0）的群 uid 作为 key，把网关机的消息队列 topic 作为 value，写入 redis set 中，发送群消息时，根据 key 群 uid 从 redis set 中查出群成员分布在哪些网关机上，然后通过消息队列，精准的向这些网关机推送群聊消息","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470437,"discussion_content":"这个方案的问题在于：群聊的使用场景并不存在说“某个用户在某个群在线”这么个说法，和直播的房间概念是不一样的。可以认为只要用户上线就应该处理所有群的消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571058159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1011156,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/L8Hia5sfiafASmBa3eTLMH8C25gMCHLTXddMkIiaCb0ky48FowibUrLQ9WSeTxSIS3prFsSjiaarwbRp1kTXDbug9eQ/132","nickname":"黄海","note":"","ucode":"AC45303035622E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32919,"discussion_content":"谢谢回复，个人表达有误，乱取了“群在线”的说法，应该称为“本网关机上在线群成员所属的群 uid ”。举个例子说明这个方案的使用场景：假如有十个网关机（1，2，…10），两个（在同一个群 uid 是 111  的）在线用户A和B，A连在1号网关机上，B连在10号网关机上，就把 key = 111 ，value = [ 1, 10 ] 写入 redis set 中。A 或 B 发群聊消息时，根据 redis set 中的值 [ 1，10 ] 可知，向1或10号网关机推送消息即可，不需要向2，3，…9 号网关机推送消息。我正在做微信群聊的功能，想请老师帮忙审核一下这个方案可行吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571066488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1011156,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/L8Hia5sfiafASmBa3eTLMH8C25gMCHLTXddMkIiaCb0ky48FowibUrLQ9WSeTxSIS3prFsSjiaarwbRp1kTXDbug9eQ/132","nickname":"黄海","note":"","ucode":"AC45303035622E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64444,"discussion_content":"你这个设计，是不是又回到了“中央在线状态”的设计方案了？\n\n线上环境，用户基数较大的情况，可以近似认为，用户被均分到每台网关机上。同时，也很大概率，群成员是分散在每台网关机上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574948371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":32919,"ip_address":""},"score":64444,"extra":""}]},{"author":{"id":1350159,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","nickname":"芒果少侠","note":"","ucode":"98D0BBB52BB80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207558,"discussion_content":"从几点考虑吧。如果网关机个数确实很多（比如说成千上万个），并且设法把同一群（直播间）的用户尽量集中到网关机上，可以提升一部分性能。但是，需要额外的中央状态维护，开发稍微复杂了一点。而且线上环境，大概率网关机不会那么多个，而且用户也很大概率是分散的。所以可以权衡下利弊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584503391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201577,"avatar":"https://static001.geekbang.org/account/avatar/00/12/55/a9/5282a560.jpg","nickname":"yic","note":"","ucode":"C8DC471B7C28B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54830,"discussion_content":"感觉你这个思路对于网关机个数很多，而每个群总人数不大的情况下可以考了，如果是&#34;万人群&#34;这种场景，这么考虑其实性能上没有什么帮助，反而业务上复杂了。-- 个人观点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574317766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139884,"user_name":"木槿花开","can_delete":false,"product_type":"c1","uid":1068781,"ip_address":"","ucode":"7DD06CDB91A8ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/ed/e99fc0f9.jpg","comment_is_top":false,"comment_ctime":1570759988,"is_pvip":false,"replies":[{"id":"54426","content":"这里的意思是一个群有一万人的这种超大规模群。只有在线的用户才会建立长连","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571055907,"ip_address":"","comment_id":139884,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5865727284","product_id":100034901,"comment_content":"万人群聊，系统是维护了万个TCP链接吗？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470158,"discussion_content":"这里的意思是一个群有一万人的这种超大规模群。只有在线的用户才会建立长连","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571055907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30549,"discussion_content":"在线用户才需要维护tcp连接.\n\n一个网关可以很容易的做到支持百万socket在线的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570842193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182631,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","nickname":"Keep-Moving","note":"","ucode":"76F33C06E07A27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30054,"discussion_content":"万人群聊，不一定是万人同时在线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570797197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334899,"user_name":"pdf","can_delete":false,"product_type":"c1","uid":1649662,"ip_address":"","ucode":"A44250955878BB","user_header":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","comment_is_top":false,"comment_ctime":1645174363,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645174363","product_id":100034901,"comment_content":"老师，如果群消息删除使用另外一个表记录删除操作，在没有连表的情况下该怎么查询呢？","like_count":0},{"had_liked":false,"id":334636,"user_name":"pdf","can_delete":false,"product_type":"c1","uid":1649662,"ip_address":"","ucode":"A44250955878BB","user_header":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","comment_is_top":false,"comment_ctime":1645026207,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645026207","product_id":100034901,"comment_content":"老师，各位同学。<br>如果消息按天分表，某天群解散的时候，这个消息删除怎么实现比较好呢？","like_count":0},{"had_liked":false,"id":323056,"user_name":"Geek_d18bea","can_delete":false,"product_type":"c1","uid":2050473,"ip_address":"","ucode":"F8250913E5AD50","user_header":"https://static001.geekbang.org/account/avatar/00/1f/49/a9/d6ec336d.jpg","comment_is_top":false,"comment_ctime":1637716914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637716914","product_id":100034901,"comment_content":"原文提到：<br>假设查询到这个群一共有 3 人，除去发送方用户 A，还有用户 B 和用户 C。<br>然后业务逻辑处理层把消息扇出到『接收人维度』，投递到全局的消息队列中；……<br>接着，各网关机把归属本机的用户的消息，通过长连下推下去。<br><br><br>万人群的消息推送，假设群里除了发送者，还有 10000 人。则业务层需要发 10000 条消息到 mq。<br>gid1, msg1, uid1<br>gid1, msg1, uid2<br>gid1, msg1, uid3<br>…<br>gid1, msg1, uid10000<br><br><br>同问这个问题，请问老师是这样一个群消息，扇出多个mq消息吗？","like_count":0},{"had_liked":false,"id":276842,"user_name":"土娃娃","can_delete":false,"product_type":"c1","uid":1375163,"ip_address":"","ucode":"E51B999BB7E1BB","user_header":"https://static001.geekbang.org/account/avatar/00/14/fb/bb/51c50432.jpg","comment_is_top":false,"comment_ctime":1612151277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612151277","product_id":100034901,"comment_content":"群成员基础数据的存储缓存结构用什么呢？进群和退群时怎么对缓存进行处理。如何根据版本号获取到删除的成员，例如：如果用redis的SortedSet，是用一个set保持所有的成员增删的版本号（这样set会变得很大，如果频繁有人退群的话）？还是用两个set，其中一个保存当前群的所有有效成员，另外一个保存删除的成员，按版本号获取的时候对两个set中的结果进行合并？","like_count":0},{"had_liked":false,"id":267389,"user_name":"唯我天棋","can_delete":false,"product_type":"c1","uid":1015960,"ip_address":"","ucode":"B925246C92727A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/98/5591d99d.jpg","comment_is_top":false,"comment_ctime":1607702251,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607702251","product_id":100034901,"comment_content":"老师，一般用什么存储去存群成员关系比较合适。<br>用mysql存，查询有性能问题。<br>用redis存 zset + hash，需要保证数据一致性。而且redis不支持条件查询，比如想查所有管理员。<br>而且，比如一个6000人的群，拉取群列表，性能压力特别大。","like_count":0},{"had_liked":false,"id":221903,"user_name":"倔强小德普","can_delete":false,"product_type":"c1","uid":1180884,"ip_address":"","ucode":"4795B744BDDBDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/d4/7173785e.jpg","comment_is_top":false,"comment_ctime":1590630501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590630501","product_id":100034901,"comment_content":"由各网管机维护数据，这个数据读的是哪边的？如果是本地内存 节点挂了 咋办","like_count":0},{"had_liked":false,"id":204971,"user_name":"李先生","can_delete":false,"product_type":"c1","uid":1237614,"ip_address":"","ucode":"D9039715F7D290","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/6e/0a300829.jpg","comment_is_top":false,"comment_ctime":1586502718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586502718","product_id":100034901,"comment_content":"有个问题：对于直播间场景，网关机(im客户端)维护长链接和用户信息，假如一场直播持续1小时，直播累计uv是300万，直播同时在线uv是100万，需要对网关机进行扩容，比如使用32g的服务器，需要多少台网关机才可能使直播正常进行，还有弹幕的发送与下推应如何处理呢(为了保证弹幕的实时性，是否可以直接展示，异步存储弹幕呢)？","like_count":0},{"had_liked":false,"id":203171,"user_name":"kamida","can_delete":false,"product_type":"c1","uid":1904146,"ip_address":"","ucode":"16D7CA59870AC0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jXbwicoDwia7ooDfwBTRyvNYQkefnVwF1CMicMS8FqKfuFAdvVZo2pqc4ic0R9kSdHTIxaE6YyqxwX8BdNGv5PqSIw/132","comment_is_top":false,"comment_ctime":1586147839,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586147839","product_id":100034901,"comment_content":"老师 在您给的最后的群聊消息写到消息队列的例子里 写的消息是不是只有一条 里面包含了消息内容 群id和A、B、C这三个用户的id啊<br>还是分成三条消息 一个用户一条","like_count":0,"discussions":[{"author":{"id":1904146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jXbwicoDwia7ooDfwBTRyvNYQkefnVwF1CMicMS8FqKfuFAdvVZo2pqc4ic0R9kSdHTIxaE6YyqxwX8BdNGv5PqSIw/132","nickname":"kamida","note":"","ucode":"16D7CA59870AC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224358,"discussion_content":"老师能回答一下吗 对这个问题很困惑啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586293448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198013,"user_name":"0xTang","can_delete":false,"product_type":"c1","uid":1019659,"ip_address":"","ucode":"82F5282EF3044B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/0b/a438de52.jpg","comment_is_top":false,"comment_ctime":1585406797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585406797","product_id":100034901,"comment_content":"可以用读者扩散结合，一些消息是给特定的人看的，例如领取红包通知。","like_count":0},{"had_liked":false,"id":195701,"user_name":"Geek_d7590a","can_delete":false,"product_type":"c1","uid":1651033,"ip_address":"","ucode":"CBA16803CA36EB","user_header":"","comment_is_top":false,"comment_ctime":1585213414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585213414","product_id":100034901,"comment_content":"有个疑问想老师解答一下：<br>1、广播消息下推，系统推送一条消息给网站的所有用户，这个场景是不是相当于群聊里的某一个人发了一条消息，所有群里的人都能接收到？<br>2、目前我搭建了im系统用于推送消息，暂时没有涉及到聊天业务，我在学习了前面的篇章后，有几个问题比较混乱：<br>(1)、消息的存储是否和聊天的差不多，但是如果只是系统推送，感觉没有会话这个层面，只是我系统创建了一条消息后，直接下推<br>(2)、用户不在线时，是不是都需要离线buffer，一般不直接读取数据库的，而当用户上线时，是使用拉的方式读取离线buffer，还是服务器读取离线buffer通过长连接推送<br>(3)好像整个设计中，没有涉及到标记哪条消息是已经读了的，哪些未读，那客户端在获取了消息后，我怎么标志哪条消息是已经读了的，哪些消息是未读显示红点","like_count":0},{"had_liked":false,"id":156524,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1574905910,"is_pvip":false,"replies":[{"id":"60938","content":"理论上出现极端情况是会的，但在我们的实践里很少出现大量用户删除某个群的群消息的情况。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1575626190,"ip_address":"","comment_id":156524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574905910","product_id":100034901,"comment_content":"老师，如果用户将群消息全删除，是存全部的消息索引到消息删除表么了？如果这样的话，当存在较多用户删除群消息时，消息删除表，就成了用户维度的群消息存储表了。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476140,"discussion_content":"理论上出现极端情况是会的，但在我们的实践里很少出现大量用户删除某个群的群消息的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575626190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150594,"user_name":"独酌相思解千愁","can_delete":false,"product_type":"c1","uid":1653628,"ip_address":"","ucode":"578995696A1482","user_header":"https://static001.geekbang.org/account/avatar/00/19/3b/7c/a977d9a9.jpg","comment_is_top":false,"comment_ctime":1573565056,"is_pvip":false,"replies":[{"id":"58812","content":"没问题的，非扇出类型的场景可以直接通过在线状态来精确下发，减少网关机负载。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1574149083,"ip_address":"","comment_id":150594,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573565056","product_id":100034901,"comment_content":"思考题：个人觉得对于点对点消息下推不适合采用网关自治维护本地在线状态。原因是本来采用中央维护的模式点对点只需要涉及个别网关机就能完成下推，采用自治维护后由于在线状态对于其他网关机是不可见的，在消息下推时就要采用类似广播的方式，将消息下推给每个网关机，这些网关机再再自己的维护的在线状态表中找这个目标用户，如果有就下推给他，如果没有就结束（自己意想的过程）。这个过程中会会浪费很对网关机的资源，且做了太多无用工。另外想问下，真实场景比如说QQ，微博这些是两种模式结合的么，点对点就查询中央，若识别出来是群聊就优先查网关自治的么？","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474211,"discussion_content":"没问题的，非扇出类型的场景可以直接通过在线状态来精确下发，减少网关机负载。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574149083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142281,"user_name":"天天向善","can_delete":false,"product_type":"c1","uid":1108250,"ip_address":"","ucode":"6AE57FB2B15043","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/1a/6ba207a3.jpg","comment_is_top":false,"comment_ctime":1571324651,"is_pvip":true,"replies":[{"id":"54998","content":"整个这个buffer组件是一个in jvm的组件，timer和flusher是两个功能实现类。可以参考我们前同事开源出去的一个实现：github搜bufferslayer。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571404352,"ip_address":"","comment_id":142281,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571324651","product_id":100034901,"comment_content":"末读变更服务下的buffer queue是中间件吗，timer，flusher也是单独应用?没有明白，能不能再详细介绍下","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471059,"discussion_content":"整个这个buffer组件是一个in jvm的组件，timer和flusher是两个功能实现类。可以参考我们前同事开源出去的一个实现：github搜bufferslayer。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571404352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}