{"id":837437,"title":"10｜网络通信：不改业务代码，如何降低延时？","content":"<p>你好，我是徐逸。</p><p>在上节课的内容中，我们一起学习了网络编程技术，并了解了框架底层不同的网络IO模型是如何影响到服务性能的。</p><p>不过呢，当服务调用的IO延时比较长时，除了框架本身网络IO模型的优化之外，我们还可以使用其它方式，来降低服务调用的网络IO延时。今天我就来聊聊如何在不改业务代码的情况下，降低服务调用的IO延时。</p><h2>跨机通信优化</h2><p>就像下面的图展示的一样，两个服务之间的请求调用会经过网络上的很多节点。服务之间的物理距离越远，经过的网络节点越多，两个服务之间的网络通信延时就会越高。</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/e3/bae050cb46e8b90ed4bddd76d1593ae3.jpg?wh=4217x762\" alt=\"\" title=\"图1 服务调用网络链路\"></p><p>因此，为了降低网络IO的延时，咱们的第一个优化思路是——让通信的Client和Server物理距离尽可能近一点。怎么才能达到这一目标呢？</p><p>为了让进行通信的Client和Server尽可能近，在流量调度上，我们可以采取下面两个优化策略。</p><p>第一个策略是，当两个服务在多地域有部署时，Client和Server<strong>不进行跨地域调用</strong>。比如，以下面的图为例，服务A在华北区域的服务器，只调用服务B在华北区域部署的服务器，尽量不要跨地域去调用服务B在华东区域部署的服务器。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/c5/67c7905091e2089b4c37cc66d69245c5.jpg?wh=1289x886\" alt=\"\" title=\"图2 同地域调用\"></p><p>当然，如果同地域内的下游服务出现故障或不可用时，在延时满足要求的情况下，出于容灾上的考虑，我们可以允许短期的跨地域调用。<br>\n<img src=\"https://static001.geekbang.org/resource/image/5f/c2/5f9f60dafe887a86cf60c95092d732c2.jpg?wh=2413x1805\" alt=\"\" title=\"图3 跨地域容灾调用\"></p><!-- [[[read_end]]] --><p>第二个优化策略是，当两个服务在同地域多机房有部署时，Client和Server<strong>不进行跨机房调用。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/11/89/11b8deb3e4fb93f66bd9e355e581de89.jpg?wh=2898x1846\" alt=\"\" title=\"图4 同机房调用\"></p><p>和跨区域容灾调用类似，如果同机房内的服务出现故障或不可用时，在延时满足要求的情况下，我们也可以允许短期的跨机房调用。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/48/4a286146bd5035303e158a53b2c02a48.jpg?wh=2900x2062\" alt=\"\" title=\"图5 容灾跨机房调用\"></p><h2>亲和性部署</h2><p>除了同地域、同机房调用外，我们还有没有办法让Client和Server的物理距离更近呢？</p><p>就像下面的图展示的一样，你还可以将两个服务，尽可能地部署到一台物理机上，这样当Client发起请求调用时，可以优先调用同一个物理机上的Server，从而达到完全消除网络传输开销的目的，这就是<strong>亲和性部署策略</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/87/5c95a5a729e55dc828b4aeec5a6ae887.jpg?wh=3000x1631\" alt=\"\" title=\"图6 同节点调用\"></p><p>亲和性部署策略除了将服务之间的远程通信变成同机通信之外，为了减少复杂TCP协议通信所产生的开销，它还会将通信方式换成IPC通信（也就是进程间通信），比如共享内存通信，从而使两个服务之间的数据传输更为高效，数据传输的资源消耗也更低。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/dd/33791a93d659a4fac58e9b5b125737dd.jpg?wh=2731x1761\" alt=\"\" title=\"图7 TCP 通信转 IPC 通信\"></p><p>当然，如果我们要使用亲和性部署策略，达到降低网络IO延时的目的，公司的多个组件都需要进行一定的改造才能支持。</p><p>改造主要包括以下三个层次。</p><ol>\n<li>\n<p>首先，容器调度系统需要基于我们配置的服务合并关系以及上下游服务的实例情况，进行亲和性调度，将上下游的实例尽可能部署到同一个物理机上。</p>\n</li>\n<li>\n<p>接着，流量调度层需要识别上游服务实例有哪些同机下游，并根据下游服务的全局负载，计算单个上游实例访问下游实例的动态权重。值得注意的是，在权重计算的具体流程中，流量调度层对下游同机实例所赋予的权重，相较其它实例而言会适当增大，从而尽可能让更多的流量可以进行本地通信。</p>\n</li>\n<li>\n<p>最后，服务框架需要扩展定制支持亲和性部署的IPC通信方式，这样基于流量调度层的计算结果将请求发给同机实例时，通信效率会更高。当然，由于物理机容量的限制，对于单个物理机上的服务调用，同机的下游实例未必能承受住所有流量，所以还是会有部分跨机调用流量，因此框架层面仍需要保留采用TCP协议的远程通信方式。</p>\n</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/5f/9d/5fb581b04d9bf0707b087964fa9a3b9d.jpg?wh=3000x2096\" alt=\"\" title=\"图8 亲和性部署\"></p><h2>合并编译</h2><p>通过亲和性部署，我们将两个服务之间的调用，变成了同机调用。那同机调用的两个服务，还有没有办法继续降低通信延时呢？</p><p>我们先来梳理一下同机服务进行RPC调用的过程，看看里面还有什么可以优化的地方。就像下面的图展示的一样，同机RPC调用的过程分为下面几个核心环节。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/26/f9f642012b53b769b2e9519a7a062826.jpg?wh=2900x2220\" alt=\"\" title=\"图9 client-server 同机通信过程\"></p><ol>\n<li>首先，Client需要用Protobuf等协议将数据编码。</li>\n<li>接着，Client要做系统调用，将数据写入内核缓冲区。</li>\n<li>然后，Server通过系统调用，从内核缓冲区读取数据。</li>\n<li>之后，Server需要通过Protobuf等协议，将数据解码成请求对象。</li>\n<li>最后，Server调用业务逻辑代码处理请求。</li>\n</ol><p>实际上，编解码操作和操作系统调用，属于性能开销比较大的操作，特别是请求或响应的包比较大时。如果我们有办法去除这两类操作，服务调用性能会进一步提升。</p><p>那在实践中，有没有办法去除这两类操作呢？</p><p>业界的前沿实践中有一种叫做合并编译的方案。就像下面的图展示的一样，<strong>合并编译</strong>将下游服务编译成SDK，并将上游服务对下游服务的RPC调用，替换成本地SDK的函数调用，从而完全消除RPC调用的编解码操作和系统调用开销**。</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/29/bacc087edda1472cd2daba9ab59ed329.jpg?wh=2900x1210\" alt=\"\" title=\"图10 合并编译\"></p><p>当然，合并编译对服务调用极致的性能优化，核心目标是解决微服务过微导致的整体CPU资源成本过高的问题。为了能拿到较大的资源成本收益，只有当两个服务之间的调用QPS比较高，编解码操作消耗的CPU比较多时，才适合用合并编译方案。</p><p>除了资源成本收益之外，当我们采用合并编译方案时，还需要考虑合并之后的服务稳定性问题。由于合并编译是把两个服务打包编译，部署到一个Pod里面，所以两个服务会共用一个Pod的资源。因此，如果服务本身的CPU或内存负载比较高，由于容器规格是有上限的，对于这样的服务就不太适合采用合并编译方案。</p><p>合并编译既能满足服务各自迭代的优点，又能消除服务拆分所增加的性能损耗，那它到底是怎么实现把两个服务的代码编译成一个二进制文件的呢？</p><p>以<a href=\"https://www.infoq.cn/article/uFkSGrwXuGjlsAf8pLb3\">字节合并编译的实现方案</a>为例，在实现合并编译方案时，需要解决两个基本的挑战。</p><p>第一个挑战是，当两个服务需要依赖相同的包且版本不一样时，如何保证两个服务的依赖不冲突？</p><p>为了保证依赖不冲突，在编译时，我们可以按下面的步骤实现依赖隔离。首先，我们可以将两个服务的依赖下载到本地各自不同的目录。</p><pre><code class=\"language-shell\">tmp\n├── servicea\n│   └── github.com\n│       └── kitex\n└── serviceb\n    └── github.com\n        └── kitex\n</code></pre><p>接着，就像下面的图展示的一样，我们需要给两个服务代码里的import path，加个不同的前缀方便区分。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/b4/1dc0bbfe769026yy8e27f091313cbeb4.jpg?wh=2800x1008\" alt=\"\" title=\"图11 import 加前缀\"></p><p>最后，我们需要在go.mod文件里，将远程tmp目录替换成本地目录，从而将代码里各个文件import的远程依赖，改成本地文件依赖。</p><pre><code class=\"language-shell\">replace tmp =&gt; ./tmp\n</code></pre><p>通过这三个步骤，我们就可以实现两个服务的依赖隔离。</p><p>除了依赖冲突问题，我们需要应对的第二个挑战是，如何将Client对Server的RPC调用，替换成本地函数调用？</p><p>为了将RPC调用，替换成本地SDK函数调用，我们的编译脚本可以按下面的步骤实现调用替换。</p><p>首先，我们需要改写server端的main函数，将它变成export函数，并去除服务启动逻辑，返回服务端的请求处理对象。</p><pre><code class=\"language-go\">// 改写前\nfunc main(){\n    mysql.init()\n    server := kitex.NewServer(handler)\n    server.run() // 服务启动\n}\n\n// 改写后\nfunc Main() kitex.ServerInfo{\n    mysql.init()\n    server := kitex.NewServer(handler)\n    return server.ServiceInfo()\n    //server.run() // 服务启动\n}\n</code></pre><p>接着，在Client端，我们需要定义一个实现了rpc调用接口Client的ServerServiceClient结构体，它的底层会直接调用server端的函数。</p><pre><code class=\"language-go\">// client rpc调用抽象接口\ntype Client interface {\n    Call(ctx context.Context, method string, request, response interface{}) error\n}\n\ntype ServerServiceClient struct{\n    serverInfo *kitex.ServerInfo\n}\n// 传入的是server请求处理对象\nfunc NewServerServiceClient(serverInfo *kitex.ServerInfo) *Client{\n    return &amp;ServerServiceClient{serverInfo:serverInfo}\n}\nfunc (impl *ServerServiceClient) Call(ctx context.Context, method string, request, response interface{}) error{\n    // 直接调用server端的函数\n    return impl.serverInfo.handler(ctx,method,request,response)\n}\n</code></pre><p>最后，在之前实例化Client对象的地方，我们需要替换成实例化ServerServiceClient对象，这样替换之后，咱们所有调用Call方法的地方，底层都从原先的RPC调用，变成了本地函数调用。</p><pre><code class=\"language-go\">// client:=NewClient() 原先的生成Client的方法\n\n// 替换之后生成Client的方法\nserverInfo:=server.Main()\nclient:=NewServerServiceClient(serverInfo)\n</code></pre><h2>小结</h2><p>今天这节课，我们一起学习了在不改业务代码的情况下，降低服务调用IO延时的方法。现在让我们来回顾一下今天学到的知识。</p><p>首先是跨机通信优化。为了降低网络传输延时，我们需要让服务调用的物理距离更近一点，尽量<strong>不跨地域、不跨机房调用</strong>。</p><p>其次是跨机转同机的调整，为了进一步降低网络传输延时，我们可以采用<strong>亲和性部署方案</strong>。把上下游服务部署到一台物理机里，优先进行同机调用，从而消除网络传输开销。</p><p>最后，我们探讨了从RPC调用转为函数调用的极致性能优化。为了消除服务调用的编解码开销，我们可以采用<strong>合并编译方案。</strong>将Server编译成SDK，并将Client对Server的RPC调用，变成本地SDK的函数调用，从而消除服务调用的编解码开销。</p><p>希望你好好体会这些策略的应用。当遇到服务调用IO瓶颈时，在公司基建满足的条件下，别忘了尝试这些策略，降低网络IO延时。</p><h2>思考题</h2><p>在实践中，如果单纯为了降低延时，很少使用合并编译的方案，这是为什么呢？</p><p>欢迎你把你的答案分享在评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"开篇词｜如何成为Go服务开发高手？","id":830531},"right":[]},"comments":[{"had_liked":false,"id":396722,"user_name":"lJ","can_delete":false,"product_type":"c1","uid":2562558,"ip_address":"江苏","ucode":"CC29D06A16FF93","user_header":"https://static001.geekbang.org/account/avatar/00/27/19/fe/d31344db.jpg","comment_is_top":false,"comment_ctime":1735526532,"is_pvip":false,"replies":[{"id":143986,"content":"👏确实是破坏了隔离性，两个服务会互相影响，比如下游服务panic，会导致上游服务也挂掉","user_name":"作者回复","user_name_real":"编辑","uid":1313417,"ctime":1735564439,"ip_address":"广东","comment_id":396722,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100843701,"comment_content":"合并编译在微服务架构中并非一种普适的优化手段，而是针对特定场景下服务优化的一种策略。\n从《字节跳动合并编译实践》中的收益公式来看，合并编译的收益与服务的资源量、调用关系的密切度、编解码开销以及服务治理开销密切相关。适合合并编译的服务需要符合「资源量大、调用关系密切、编解码开销大」这些条件外，还要满足非缓存、固定开销类型的服务、容器负载不能太高、编解码大于 3% 的服务。\n合并编译能够带来一定的性能提升，但也并非没有局限，它破坏了服务自治、可扩展性和故障隔离设计原则。","like_count":2,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655671,"discussion_content":"👏确实是破坏了隔离性，两个服务会互相影响，比如下游服务panic，会导致上游服务也挂掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1735564440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396718,"user_name":"Realm","can_delete":false,"product_type":"c1","uid":1081299,"ip_address":"浙江","ucode":"30CBEBE619D1A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","comment_is_top":false,"comment_ctime":1735515956,"is_pvip":true,"replies":[{"id":143987,"content":"1.合并编译会导致服务之间的隔离失效，产生一些稳定性问题。比如当下游服务panic时，上游服务也会挂掉，无法提供服务。再比如，如果下游服务导致容器负载变高，由于两者共用容器资源，上游服务也会受影响。2.应用层代码不需要做什么，主要是编译脚本要做代码改写","user_name":"作者回复","user_name_real":"编辑","uid":1313417,"ctime":1735564587,"ip_address":"广东","comment_id":396718,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100843701,"comment_content":"思考题：\n1. 不符合统一的规范；\n2. 不便于横向扩容；\n\n请教老师，编译成rpc服务和编译成sdk，源代码层面需要修改什么吗？\n","like_count":0,"discussions":[{"author":{"id":1313417,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0a/89/eb8c28a4.jpg","nickname":"徐逸","note":"","ucode":"DCFDEE08FD263A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655672,"discussion_content":"1.合并编译会导致服务之间的隔离失效，产生一些稳定性问题。比如当下游服务panic时，上游服务也会挂掉，无法提供服务。再比如，如果下游服务导致容器负载变高，由于两者共用容器资源，上游服务也会受影响。2.应用层代码不需要做什么，主要是编译脚本要做代码改写","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1735564587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}