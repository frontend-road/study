{"id":819213,"title":"06｜LLaMA 3多轮推理应用：对话系统和自动化任务建模系统","content":"<p>你好，我是Tyler。</p><p>今天，我们将深入探讨多轮对话的应用场景，并重点了解LLaMA 3在这一领域的能力。LLaMA 3作为当前最强大的语言模型之一，特别适合应用于复杂的对话系统和自动化任务流程中。我们将通过两个典型案例——对话系统和自动化任务建模系统，来展示Llama-3如何在这些复杂场景中表现出色。</p><h2>多轮对话的核心能力</h2><p>多轮对话系统的核心包括两个重要功能：<strong>与人的互动和自动化推理</strong>。LLaMA 3作为当前最强大的语言模型之一，凭借其深度学习能力，可以不断地理解对话上下文、记住对话历史，并基于这些信息生成符合逻辑和语境的回应。这使得它不仅能够处理简单的问答任务，还能在复杂的对话场景和任务流程自动化中表现出色。</p><h2>对话系统：ChatGPT</h2><h3>对话状态应用设计</h3><p>多轮对话是AIGC（人工智能生成内容）产品的主要形式，它显著提升了人机交互的效率和自然度。在对话系统中，LLaMA 3的典型应用之一就是像ChatGPT这样的智能助手。设计和维护对话状态是系统面临的核心挑战。对话状态指的是模型在多轮对话中对用户输入的理解和记忆。一个设计良好的对话状态管理系统对于保持对话的连贯性和逻辑性至关重要。</p><p>在一个典型的购票对话中，用户可能会先询问航班信息，然后选择航班并完成支付。在这个过程中，模型需要维护用户的需求、偏好和上下文信息，以便在后续对话中做出合适的回应。LLaMA 3凭借其强大的自然语言理解能力，能够准确捕捉并记住这些信息，从而生成符合上下文的回应。</p><!-- [[[read_end]]] --><h3>示例 1：ChatGPT 客服对话</h3><p>以下是一个示例代码，展示如何使用Llama-3模型进行多轮对话，以模拟客服对话系统。</p><pre><code class=\"language-python\">import ollama\n\ndef customer_service_chat(history: str, user_input: str, max_turns: int = 3) -&gt; tuple[str, str]:\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 与客服进行对话，并维护对话历史。\n\n&nbsp; &nbsp; 参数:\n&nbsp; &nbsp; history (str): 先前的对话历史。\n&nbsp; &nbsp; user_input (str): 用户当前的输入。\n&nbsp; &nbsp; max_turns (int): 需要保留的最大对话轮数。\n\n&nbsp; &nbsp; 返回:\n&nbsp; &nbsp; tuple[str, str]: 更新后的对话历史和客服的回复。\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; # 分割历史对话成列表，保留最近 max_turns 轮对话\n&nbsp; &nbsp; history_lines = history.split(\"\\n\")\n&nbsp; &nbsp; recent_history = \"\\n\".join(history_lines[-max_turns * 2:])&nbsp; # 每轮对话包含用户和客服两句\n\n&nbsp; &nbsp; # 更新历史记录，拼接对话\n&nbsp; &nbsp; recent_history += f\"\\n用户: {user_input}\\n客服:\"\n\n&nbsp; &nbsp; # 使用 Ollama 进行对话，要求用中文回答，并明确指示上下文\n&nbsp; &nbsp; messages = [\n&nbsp; &nbsp; &nbsp; &nbsp; {'role': 'system', 'content': '请根据以下对话历史，用中文回答问题。'},\n&nbsp; &nbsp; &nbsp; &nbsp; {'role': 'user', 'content': recent_history}\n&nbsp; &nbsp; ]\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; response = ollama.chat(model='llama3', messages=messages)\n\n&nbsp; &nbsp; # 提取并清理模型的回复\n&nbsp; &nbsp; reply = response['message']['content'].strip()\n\n&nbsp; &nbsp; # 更新历史，保留全量历史记录\n&nbsp; &nbsp; history += f\"\\n用户: {user_input}\\n客服: {reply}\"\n\n&nbsp; &nbsp; return history, reply\n\n# 示例对话\nhistory = \"客服: 欢迎使用在线客服系统！请问有什么可以帮您？\"\nuser_input = \"我想预订一张飞往纽约的机票。\"\nhistory, reply = customer_service_chat(history, user_input)\nprint(f\"用户: {user_input}\\n客服: {reply}\")\n\nuser_input = \"有哪些航班可以选择？\"\nhistory, reply = customer_service_chat(history, user_input)\nprint(f\"用户: {user_input}\\n客服: {reply}\")\n</code></pre><p>这个代码模拟了一个用户与客服系统的对话。初始对话历史包含助手的欢迎消息，用户请求预订机票，模型生成的回复被添加到对话历史中，接着用户询问航班选择，模型再生成新的回复。代码展示了如何初始化Llama-3模型、处理对话历史和生成响应。</p><h3>对话状态的维护</h3><p>在多轮对话中，如何高效地维护对话状态至关重要。对于长时间对话，历史对话记录可能变得冗长且不必要。将整个历史记录传递给模型不仅会增加计算开销，还可能导致模型在大量无关信息中“迷失方向”，从而降低提示语的工作效率。因此，必须针对性地选择历史记录中的关键部分。</p><p>LLaMA 3在对话状态维护过程中，主要考虑了<strong>近时性和相关性</strong>。近时性指的是优先选择最近的对话记录，因为它们通常与当前上下文更为相关。相关性要求模型筛选出与当前任务密切相关的信息，避免被无关内容干扰。如果希望获得兼顾这两个特性的历史记录，需要结合检索增强生成的方法，这部分内容将在后续章节进行详细展开。</p><p>这里先带你学习另一项高效的提示语工程技巧，那就是<strong>对话压缩</strong>，我们可以将历史对话在特定的触发条件下（如完成10轮对话后）进行历史对话摘要压缩，比如将前十轮的对话内容传输给大模型，让它生成这段对话的摘要。</p><pre><code class=\"language-python\">import ollama\n\ndef summarize_dialogue(dialogue_history):\n&nbsp; &nbsp; # 历史对话压缩，提取关键信息\n&nbsp; &nbsp; relevant_dialogue = \"\\n\".join(line for line in dialogue_history.split(\"\\n\") if \"用户:\" in line or \"客服:\" in line)\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; # 生成对话摘要的提示词，强调保留数字和地点等关键信息\n&nbsp; &nbsp; prompt = (\n&nbsp; &nbsp; &nbsp; &nbsp; f\"请提取以下对话的关键信息，并生成摘要，保留数字和地点等重要信息，去除不必要的细节:\\n\\n{relevant_dialogue}\"\n&nbsp; &nbsp; )\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; # 使用 Ollama 进行对话摘要生成，并指定用中文回答\n&nbsp; &nbsp; messages = [\n&nbsp; &nbsp; &nbsp; &nbsp; {'role': 'user', 'content': prompt},\n&nbsp; &nbsp; &nbsp; &nbsp; {'role': 'system', 'content': '请用中文回答'}\n&nbsp; &nbsp; ]\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; response = ollama.chat(model='llama3', messages=messages)\n\n&nbsp; &nbsp; # 提取并清理模型的回复\n&nbsp; &nbsp; summary = response['message']['content'].strip()\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; return summary\n\n# 示例对话记录\ndialogue_history = (\n&nbsp; &nbsp; \"用户: 你好，你怎么样？\\n\"\n&nbsp; &nbsp; \"客服: 我很好，谢谢！请问今天有什么可以帮助您的？\\n\"\n&nbsp; &nbsp; \"用户: 我需要帮助处理我的账户。您能查看我的余额吗？\\n\"\n&nbsp; &nbsp; \"客服: 当然可以！请提供您的账户号码。\\n\"\n&nbsp; &nbsp; \"用户: 我的账户号码是123456。\\n\"\n&nbsp; &nbsp; \"客服: 让我为您查一下...\\n\"\n&nbsp; &nbsp; \"客服: 您的当前余额是$500。\\n\"\n&nbsp; &nbsp; \"用户: 谢谢！您能告诉我最近的交易吗？\\n\"\n&nbsp; &nbsp; \"客服: 我需要验证您的身份才能提供交易详细信息。\\n\"\n&nbsp; &nbsp; \"用户: 好的，这里是我有的详细信息。\\n\"\n)\n\n# 生成摘要\nsummary = summarize_dialogue(dialogue_history)\nprint(\"对话摘要:\", summary)\n\n# 压缩历史对话信息\ndialogue_history = summary\n</code></pre><p>这样不仅可以有效地压缩模型的输入长度，也可以让模型更集中在关键的历史信息上。</p><p>这一切都表明LLaMA 3具备在复杂对话场景中有效管理对话状态的能力，使得它能够在多轮对话中保持一致性并生成高质量的回应。</p><h2>有限状态机：FSM</h2><p>任务流程建模是流程自动化的关键技术之一。在 FSM 系统中，任务流程被建模为多个状态的转换，这些状态之间的转换通常需要复杂的条件判断和搜索算法的支持。LLaMA 3凭借其强大的自然语言处理（NLP）能力，能够为这些任务流程提供智能化的支持。</p><h3>任务流程建模</h3><p>在复杂任务流程中，LLaMA 3不仅能够理解自然语言指令，还能够将这些指令转化为可执行的任务操作。例如，在一个文件处理系统中，用户可能会要求系统根据文件类型、内容和需求进行不同的处理。LLaMA 3可以自动理解这些要求，并选择合适的处理方式，最终实现整个流程的自动化执行。</p><p>任务流程建模的核心在于如何将一个复杂的任务拆分为多个状态，并定义这些状态之间的转换规则。LLaMA 3通过自然语言理解（NLU）和自然语言生成（NLG）技术，可以在理解用户意图的基础上，自动构建有限状态机，并在不同状态之间智能地进行转换。比如，在一个多步骤的流程中，LLaMA 3能够根据当前的状态，自动决定下一步操作，并在需要时调整流程路径。</p><h3>示例 2：有限状态机（FSM）任务流程建模</h3><p>这个代码示例展示了如何使用有限状态机（FSM）来建模一个任务流程系统，该系统用于根据用户的输入推荐金融产品。</p><pre><code class=\"language-python\">import json\nfrom ollama import chat\n\nclass FinancialProductFSM:\n&nbsp; &nbsp; def __init__(self):\n&nbsp; &nbsp; &nbsp; &nbsp; self.states = {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'START': 'START',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'YOUNG': 'YOUNG',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'OLD': 'OLD',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'LOW_RISK': 'LOW_RISK',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'HIGH_RISK': 'HIGH_RISK',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'HIGH_INCOME': 'HIGH_INCOME',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'LOW_INCOME': 'LOW_INCOME'\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; self.current_state = self.states['START']\n\n&nbsp; &nbsp; &nbsp; &nbsp; self.transitions = {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['START'], 'young'): self.states['YOUNG'],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['START'], 'old'): self.states['OLD'],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['YOUNG'], 'low_risk'): self.states['LOW_RISK'],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['YOUNG'], 'high_risk'): self.states['HIGH_RISK'],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['OLD'], 'low_risk'): self.states['LOW_RISK'],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['OLD'], 'high_risk'): self.states['HIGH_RISK'],\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; self.product_recommendations = {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['LOW_RISK'], self.states['HIGH_INCOME']): '高收益储蓄账户',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['HIGH_RISK'], self.states['HIGH_INCOME']): '股票和共同基金',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['LOW_RISK'], self.states['LOW_INCOME']): '定期存款（CD）',\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (self.states['HIGH_RISK'], self.states['LOW_INCOME']): '高风险投资基金',\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; def process_input(self, user_info):\n&nbsp; &nbsp; &nbsp; &nbsp; age = user_info.get('age')\n&nbsp; &nbsp; &nbsp; &nbsp; risk = user_info.get('risk')\n&nbsp; &nbsp; &nbsp; &nbsp; income = user_info.get('income')\n\n&nbsp; &nbsp; &nbsp; &nbsp; new_state = self.update_state(age, risk)\n&nbsp; &nbsp; &nbsp; &nbsp; if new_state is None:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return '输入无效'\n\n&nbsp; &nbsp; &nbsp; &nbsp; self.current_state = new_state\n&nbsp; &nbsp; &nbsp; &nbsp; return self.get_recommendation(income)\n\n&nbsp; &nbsp; def update_state(self, age, risk):\n&nbsp; &nbsp; &nbsp; &nbsp; if age in ['young', 'old']:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state_after_age = self.transitions.get((self.states['START'], age))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return self.transitions.get((state_after_age, risk)) if state_after_age else None\n&nbsp; &nbsp; &nbsp; &nbsp; return None\n\n&nbsp; &nbsp; def get_recommendation(self, income):\n&nbsp; &nbsp; &nbsp; &nbsp; for (risk_state, income_state), product in self.product_recommendations.items():\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if self.current_state == risk_state:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return product if income_state == (self.states['HIGH_INCOME'] if income == 'high_income' else self.states['LOW_INCOME']) else None\n&nbsp; &nbsp; &nbsp; &nbsp; return '没有合适的产品推荐'\n\ndef get_user_info_from_ollama(dialogue):\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; 与 Ollama 模型对话，要求返回用户的关键信息，以 JSON 格式返回。\n&nbsp; &nbsp; 指定 age、risk、income 的可能枚举值。\n&nbsp; &nbsp; \"\"\"\n&nbsp; &nbsp; prompt = f\"\"\"\n&nbsp; &nbsp; 请从以下对话中提取用户的年龄、风险偏好和收入水平，并以 JSON 格式返回。只输出 JSON，不要附加任何其他文字。\n&nbsp; &nbsp; 格式如下：\n&nbsp; &nbsp; {{\n&nbsp; &nbsp; &nbsp; &nbsp; \"age\": \"young\" 或 \"old\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"risk\": \"low_risk\" 或 \"high_risk\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"income\": \"high_income\" 或 \"low_income\"\n&nbsp; &nbsp; }}\n\n&nbsp; &nbsp; 对话内容如下：\n&nbsp; &nbsp; {dialogue}\n&nbsp; &nbsp; \"\"\"\n\n&nbsp; &nbsp; # 调用 Ollama API 进行对话，返回结构化的 JSON 响应\n&nbsp; &nbsp; response = chat(model='llama3', messages=[{'role': 'user', 'content': prompt}])\n\n&nbsp; &nbsp; # 获取 Ollama 返回的响应\n&nbsp; &nbsp; ollama_response = response['message']['content'].strip()\n\n&nbsp; &nbsp; # 将响应字符串转换为 Python 字典\n&nbsp; &nbsp; try:\n&nbsp; &nbsp; &nbsp; &nbsp; user_info = json.loads(ollama_response)&nbsp; # 使用 json.loads 安全解析 JSON\n&nbsp; &nbsp; except json.JSONDecodeError:\n&nbsp; &nbsp; &nbsp; &nbsp; return None\n\n&nbsp; &nbsp; return user_info\n\ndef main():\n&nbsp; &nbsp; fsm = FinancialProductFSM()\n&nbsp; &nbsp; print(\"欢迎来到金融产品推荐系统！\")\n\n&nbsp; &nbsp; # 假设对话记录来自 Ollama 的自然语言对话\n&nbsp; &nbsp; dialogue_history = \"\"\"\n&nbsp; &nbsp; 用户: 我年轻，喜欢高风险投资，而且收入挺高的。\n&nbsp; &nbsp; \"\"\"\n\n&nbsp; &nbsp; # 使用 Ollama 提取用户信息（年龄、风险偏好、收入水平）\n&nbsp; &nbsp; user_info = get_user_info_from_ollama(dialogue_history)\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; if user_info:\n&nbsp; &nbsp; &nbsp; &nbsp; # 显示提取的用户信息\n&nbsp; &nbsp; &nbsp; &nbsp; print(f\"提取的用户信息: {json.dumps(user_info, ensure_ascii=False)}\")\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; # 处理提取的信息并推荐金融产品\n&nbsp; &nbsp; &nbsp; &nbsp; recommendation = fsm.process_input(user_info)\n&nbsp; &nbsp; &nbsp; &nbsp; print(f\"推荐的产品: {recommendation}\")\n&nbsp; &nbsp; else:\n&nbsp; &nbsp; &nbsp; &nbsp; print(\"无法根据用户输入生成推荐。\")\n\nif __name__ == \"__main__\":\n&nbsp; &nbsp; main()\n</code></pre><p>这个示例展示了如何定义一个有限状态机来推荐金融产品。代码通过状态转换和条件判断，根据用户的输入动态更新状态并提供推荐。这个示例有助于理解复杂状态流转的过程，后续章节我会介绍如何用LangGraph完成更高效的任务建模和状态管理。</p><p>这一能力使LLaMA 3在流程自动化的广泛应用中大展身手，不仅可以处理复杂的任务，还能够灵活应对各种突发情况。</p><h3>任务状态的维护</h3><p>在流程自动化中，任务状态的维护与对话状态有着相似之处，但更为复杂。任务状态指的是系统在执行自动化流程时，各个环节的执行情况和当前状态。随着流程的推进，Llama-3需要实时更新这些状态，并根据最新的状态做出决策。这种状态维护能力确保了整个自动化流程的连续性和准确性。</p><p>例如，在一个多步骤的文件处理流程中，每一步操作之后，LLaMA 3都需要更新当前的任务状态，如文件的处理进度、操作成功与否以及下一步可能的选择。通过对任务状态的精准维护，LLaMA 3能够在整个流程中保持高度一致性，避免因状态信息错误或遗漏而导致的流程中断或错误决策。</p><p>此外，LLaMA 3还能够在任务状态维护中融入更复杂的逻辑和判断条件。例如，某些流程步骤可能依赖于前一步操作的成功与否，或者需要根据外部数据源的实时更新来调整任务状态。在这些场景中，LLaMA 3的能力可以进一步扩展，涵盖更广泛的自动化工作流。</p><h2>总结</h2><p>这节课我们深入探讨了LLaMA 3在多轮对话中的能力边界，并通过ChatGPT和LangGraph两个典型案例，展示了其在复杂人机交互和任务流程自动化中的强大应用。通过对话状态和任务状态的有效管理，LLaMA 3能够在广泛的应用场景中提供高质量的智能服务。</p><h2>思考题</h2><ol>\n<li>为什么说多步推理过程的本质是一台状态机？</li>\n<li>你是否能想到有哪些多步推理不能解决的问题？</li>\n</ol><p>欢迎你把思考后的结果分享到留言区，也欢迎你把这节课分享给需要的朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":395937,"user_name":"小虎子🐯","can_delete":false,"product_type":"c1","uid":2843479,"ip_address":"北京","ucode":"4C9530B3FB407B","user_header":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","comment_is_top":true,"comment_ctime":1732500652,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100828301,"comment_content":"课程代码地址：https:&#47;&#47;github.com&#47;tylerelyt&#47;LLaMa-in-Action","like_count":0},{"had_liked":false,"id":395425,"user_name":"凌yu","can_delete":false,"product_type":"c1","uid":1010481,"ip_address":"广东","ucode":"3C7E84BE703E43","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/31/b5b3d997.jpg","comment_is_top":false,"comment_ctime":1730730201,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100828301,"comment_content":"确实存在一些问题，即使是多步推理也无法解决，这些问题通常涉及以下几个方面：\n\n1. **直觉和创造力问题**：\n   - **艺术创作**：创作一幅画或一首乐曲往往需要直觉和创造力，而不是单纯的逻辑推理。\n   - **创新发明**：发明新产品或新技术往往需要跳出现有思维框架，这超出了多步推理的范畴。\n\n2. **情感和主观性问题**：\n   - **情感决策**：决定是否爱一个人或是否原谅某人，这些决策通常涉及情感和个人价值观，而不是逻辑推理。\n   - **审美判断**：评价一个艺术品的美丑，这种判断很大程度上是主观的，不受逻辑推理的直接影响。\n\n3. **不确定性和随机性问题**：\n   - **预测未来**：尽管可以使用统计和概率进行预测，但未来事件的不确定性和随机性使得完全准确的预测成为不可能。\n   - **量子物理现象**：在量子层面，某些现象如量子纠缠和不确定性原理，其本质是概率性的，无法通过经典逻辑推理来完全解释。\n\n4. **复杂系统问题**：\n   - **经济预测**：经济系统是一个高度复杂的系统，涉及众多变量和相互作用，其预测往往超出了多步推理的能力。\n   - **生态系统变化**：生态系统的变化受到多种因素的影响，这些因素相互作用，使得预测和推理变得极其复杂。\n\n5. **道德和伦理问题**：\n   - **道德困境**：如经典的“电车问题”，在道德和伦理上做出选择往往涉及价值观和原则，而不是简单的逻辑推理。\n\n6. **个人偏好和选择**：\n   - **选择职业**：选择职业路径往往涉及个人兴趣、能力和市场需求，这些因素的组合使得决策超出了逻辑推理的范围。\n\n这些问题通常需要综合考虑多种因素，包括情感、直觉、经验、价值观和创造力，而不仅仅是逻辑推理。","like_count":1}]}