{"id":230194,"title":"01 | CPU缓存：怎样写代码能够让CPU执行得更快？","content":"<p>你好，我是陶辉。</p><p>这是课程的第一讲，我们先从主机最重要的部件CPU开始，聊聊如何通过提升CPU缓存的命中率来优化程序的性能。</p><p>任何代码的执行都依赖CPU，通常，使用好CPU是操作系统内核的工作。然而，当我们编写计算密集型的程序时，CPU的执行效率就开始变得至关重要。由于CPU缓存由更快的SRAM构成（内存是由DRAM构成的），而且离CPU核心更近，如果运算时需要的输入数据是从CPU缓存，而不是内存中读取时，运算速度就会快很多。所以，了解CPU缓存对性能的影响，便能够更有效地编写我们的代码，优化程序性能。</p><p>然而，很多同学并不清楚CPU缓存的运行规则，不知道如何写代码才能够配合CPU缓存的工作方式，这样，便放弃了可以大幅提升核心计算代码执行速度的机会。而且，越是底层的优化，适用范围越广，CPU缓存便是如此，它的运行规则对分布式集群里各种操作系统、编程语言都有效。所以，一旦你能掌握它，集群中巨大的主机数量便能够放大优化效果。</p><p>接下来，我们就看看，CPU缓存结构到底是什么样的，又该如何优化它？</p><h2>CPU的多级缓存</h2><p>刚刚我们提到，CPU缓存离CPU核心更近，由于电子信号传输是需要时间的，所以离CPU核心越近，缓存的读写速度就越快。但CPU的空间很狭小，离CPU越近缓存大小受到的限制也越大。所以，综合硬件布局、性能等因素，CPU缓存通常分为大小不等的三级缓存。</p><!-- [[[read_end]]] --><p>CPU缓存的材质SRAM比内存使用的DRAM贵许多，所以不同于内存动辄以GB计算，它的大小是以MB来计算的。比如，在我的Linux系统上，离CPU最近的一级缓存是32KB，二级缓存是256KB，最大的三级缓存则是20MB（Windows系统查看缓存大小可以用wmic cpu指令，或者用<a href=\"https://www.cpuid.com/softwares/cpu-z.html\">CPU-Z</a>这个工具）。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/87/deff13454dcb6b15e1ac4f6f538c4987.png?wh=1379*352\" alt=\"\"></p><p>你可能注意到，三级缓存要比一、二级缓存大许多倍，这是因为当下的CPU都是多核心的，每个核心都有自己的一、二级缓存，但三级缓存却是一颗CPU上所有核心共享的。</p><p>程序执行时，会先将内存中的数据载入到共享的三级缓存中，再进入每颗核心独有的二级缓存，最后进入最快的一级缓存，之后才会被CPU使用，就像下面这张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/92/0c/9277d79155cd7f925c27f9c37e0b240c.jpg?wh=3749*2433\" alt=\"\"></p><p>缓存要比内存快很多。CPU访问一次内存通常需要100个时钟周期以上，而访问一级缓存只需要4~5个时钟周期，二级缓存大约12个时钟周期，三级缓存大约30个时钟周期（对于2GHZ主频的CPU来说，一个时钟周期是0.5纳秒。你可以在LZMA的<a href=\"https://www.7-cpu.com/\">Benchmark</a>中找到几种典型CPU缓存的访问速度）。</p><p>如果CPU所要操作的数据在缓存中，则直接读取，这称为缓存命中。命中缓存会带来很大的性能提升，<strong>因此，我们的代码优化目标是提升CPU缓存的命中率。</strong></p><p>当然，缓存命中率是很笼统的，具体优化时还得一分为二。比如，你在查看CPU缓存时会发现有2个一级缓存（比如Linux上就是上图中的index0和index1），这是因为，CPU会区别对待指令与数据。比如，“1+1=2”这个运算，“+”就是指令，会放在一级指令缓存中，而“1”这个输入数字，则放在一级数据缓存中。虽然在冯诺依曼计算机体系结构中，代码指令与数据是放在一起的，但执行时却是分开进入指令缓存与数据缓存的，因此我们要分开来看二者的缓存命中率。</p><h2>提升数据缓存的命中率</h2><p>我们先来看数据的访问顺序是如何影响缓存命中率的。</p><p>比如现在要遍历二维数组，其定义如下（这里我用的是伪代码，在GitHub上我为你准备了可运行验证的C/C++、Java<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/1-cpu_cache/traverse_2d_array\">示例代码</a>，你可以参照它们编写出其他语言的可执行代码）：</p><pre><code>       int array[N][N];\n</code></pre><p>你可以思考一下，用array[j][i]和array[i][j]访问数组元素，哪一种性能更快？</p><pre><code>       for(i = 0; i &lt; N; i+=1) {\n           for(j = 0; j &lt; N; j+=1) {\n               array[i][j] = 0;\n           }\n       }\n</code></pre><p>在我给出的GitHub地址上的C++代码实现中，前者array[j][i]执行的时间是后者array[i][j]的8倍之多（请参考<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/1-cpu_cache/traverse_2d_array\">traverse_2d_array.cpp</a>，如果使用Python代码，traverse_2d_array.py由于数组容器的差异，性能差距不会那么大）。</p><p>为什么会有这么大的差距呢？这是因为二维数组array所占用的内存是连续的，比如若长度N的值为2，那么内存中从前至后各元素的顺序是：</p><pre><code>array[0][0]，array[0][1]，array[1][0]，array[1][1]。\n</code></pre><p>如果用array[i][j]访问数组元素，则完全与上述内存中元素顺序一致，因此访问array[0][0]时，缓存已经把紧随其后的3个元素也载入了，CPU通过快速的缓存来读取后续3个元素就可以。如果用array[j][i]来访问，访问的顺序就是：</p><pre><code>array[0][0]，array[1][0]，array[0][1]，array[1][1]\n</code></pre><p>此时内存是跳跃访问的，如果N的数值很大，那么操作array[j][i]时，是没有办法把array[j+1][i]也读入缓存的。</p><p>到这里我们还有2个问题没有搞明白：</p><ol>\n<li>为什么两者的执行时间有约7、8倍的差距呢？</li>\n<li>载入array[0][0]元素时，缓存一次性会载入多少元素呢？</li>\n</ol><p>其实这两个问题的答案都与CPU Cache Line相关，它定义了缓存一次载入数据的大小，Linux上你可以通过coherency_line_size配置查看它，通常是64字节。</p><p><img src=\"https://static001.geekbang.org/resource/image/7d/de/7dc8d0c5a1461d9aed086e7a112c01de.png?wh=1226*64\" alt=\"\"></p><p>因此，我测试的服务器一次会载入64字节至缓存中。当载入array[0][0]时，若它们占用的内存不足64字节，CPU就会顺序地补足后续元素。顺序访问的array[i][j]因为利用了这一特点，所以就会比array[j][i]要快。也正因为这样，当元素类型是4个字节的整数时，性能就会比8个字节的高精度浮点数时速度更快，因为缓存一次载入的元素会更多。</p><p><strong>因此，遇到这种遍历访问数组的情况时，按照内存布局顺序访问将会带来很大的性能提升。</strong></p><p>再来看为什么执行时间相差8倍。在二维数组中，其实第一维元素存放的是地址，第二维存放的才是目标元素。由于64位操作系统的地址占用8个字节（32位操作系统是4个字节），因此，每批Cache Line最多也就能载入不到8个二维数组元素，所以性能差距大约接近8倍。（用不同的步长访问数组，也能验证CPU Cache Line对性能的影响，可参考我给你准备的<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/1-cpu_cache/traverse_1d_array\">Github</a>上的测试代码）。</p><p>关于CPU Cache Line的应用其实非常广泛，如果你用过Nginx，会发现它是用哈希表来存放域名、HTTP头部等数据的，这样访问速度非常快，而哈希表里桶的大小如server_names_hash_bucket_size，它默认就等于CPU Cache Line的值。由于所存放的字符串长度不能大于桶的大小，所以当需要存放更长的字符串时，就需要修改桶大小，但Nginx官网上明确建议它应该是CPU Cache Line的整数倍。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/2b/4fa0080e0f688bd484fe701686e6262b.png?wh=1124*211\" alt=\"\"></p><p>为什么要做这样的要求呢？就是因为按照cpu cache line（比如64字节）来访问内存时，不会出现多核CPU下的伪共享问题，可以<strong>尽量减少访问内存的次数</strong>。比如，若桶大小为64字节，那么根据地址获取字符串时只需要访问一次内存，而桶大小为50字节，会导致最坏2次访问内存，而70字节最坏会有3次访问内存。</p><p>如果你在用Linux操作系统，可以通过一个名叫Perf的工具直观地验证缓存命中的情况（可以用yum install perf或者apt-get install perf安装这个工具，这个<a href=\"http://www.brendangregg.com/perf.html\">网址</a>中有大量案例可供参考）。</p><p>执行perf stat可以统计出进程运行时的系统信息（通过-e选项指定要统计的事件，如果要查看三级缓存总的命中率，可以指定缓存未命中cache-misses事件，以及读取缓存次数cache-references事件，两者相除就是缓存的未命中率，用1相减就是命中率。类似的，通过L1-dcache-load-misses和L1-dcache-loads可以得到L1缓存的命中率），此时你会发现array[i][j]的缓存命中率远高于array[j][i]。</p><p>当然，perf stat还可以通过指令执行速度反映出两种访问方式的优劣，如下图所示（instructions事件指明了进程执行的总指令数，而cycles事件指明了运行的时钟周期，二者相除就可以得到每时钟周期所执行的指令数，缩写为IPC。如果缓存未命中，则CPU要等待内存的慢速读取，因此IPC就会很低。array[i][j]的IPC值也比array[j][i]要高得多）：</p><p><img src=\"https://static001.geekbang.org/resource/image/29/1c/29d4a9fa5b8ad4515d7129d71987b01c.png?wh=1662*235\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/94/3d/9476f52cfc63825e7ec836580e12c53d.png?wh=1646*242\" alt=\"\"></p><h2>提升指令缓存的命中率</h2><p>说完数据的缓存命中率，再来看指令的缓存命中率该如何提升。</p><p>我们还是用一个例子来看一下。比如，有一个元素为0到255之间随机数字组成的数组：</p><pre><code>int array[N];\nfor (i = 0; i &lt; TESTN; i++) array[i] = rand() % 256;\n</code></pre><p>接下来要对它做两个操作：一是循环遍历数组，判断每个数字是否小于128，如果小于则把元素的值置为0；二是将数组排序。那么，先排序再遍历速度快，还是先遍历再排序速度快呢？</p><pre><code>for(i = 0; i &lt; N; i++) {\n       if (array [i] &lt; 128) array[i] = 0;\n}\nsort(array, array +N);\n</code></pre><p>我先给出答案：先排序的遍历时间只有后排序的三分之一（参考GitHub中的<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/1-cpu_cache/branch_predict\">branch_predict.cpp代码</a>）。为什么会这样呢？这是因为循环中有大量的if条件分支，而CPU<strong>含有分支预测器</strong>。</p><p>当代码中出现if、switch等语句时，意味着此时至少可以选择跳转到两段不同的指令去执行。如果分支预测器可以预测接下来要在哪段代码执行（比如if还是else中的指令），就可以提前把这些指令放在缓存中，CPU执行时就会很快。当数组中的元素完全随机时，分支预测器无法有效工作，而当array数组有序时，分支预测器会动态地根据历史命中数据对未来进行预测，命中率就会非常高。</p><p>究竟有多高呢？我们还是用Linux上的perf来做个验证。使用 -e选项指明branch-loads事件和branch-load-misses事件，它们分别表示分支预测的次数，以及预测失败的次数。通过L1-icache-load-misses也能查看到一级缓存中指令的未命中情况。</p><p>下图是我在GitHub上为你准备的验证程序执行的perf分支预测统计数据（代码见<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/1-cpu_cache/branch_predict\">这里</a>），你可以看到，先排序的话分支预测的成功率非常高，而且一级指令缓存的未命中率也有大幅下降。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/72/2902b3e08edbd1015b1e9ecfe08c4472.png?wh=554*90\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/95/60/9503d2c8f7deb3647eebb8d68d317e60.png?wh=554*96\" alt=\"\"></p><p>C/C++语言中编译器还给应用程序员提供了显式预测分支概率的工具，如果if中的条件表达式判断为“真”的概率非常高，我们可以用likely宏把它括在里面，反之则可以用unlikely宏。当然，CPU自身的条件预测已经非常准了，仅当我们确信CPU条件预测不会准，且我们能够知晓实际概率时，才需要加入这两个宏。</p><pre><code>#define likely(x) __builtin_expect(!!(x), 1) \n#define unlikely(x) __builtin_expect(!!(x), 0)\nif (likely(a == 1)) …\n</code></pre><h2>提升多核CPU下的缓存命中率</h2><p>前面我们都是面向一个CPU核心谈数据及指令缓存的，然而现代CPU几乎都是多核的。虽然三级缓存面向所有核心，但一、二级缓存是每颗核心独享的。我们知道，即使只有一个CPU核心，现代分时操作系统都支持许多进程同时运行。这是因为操作系统把时间切成了许多片，微观上各进程按时间片交替地占用CPU，这造成宏观上看起来各程序同时在执行。</p><p>因此，若进程A在时间片1里使用CPU核心1，自然也填满了核心1的一、二级缓存，当时间片1结束后，操作系统会让进程A让出CPU，基于效率并兼顾公平的策略重新调度CPU核心1，以防止某些进程饿死。如果此时CPU核心1繁忙，而CPU核心2空闲，则进程A很可能会被调度到CPU核心2上运行，这样，即使我们对代码优化得再好，也只能在一个时间片内高效地使用CPU一、二级缓存了，下一个时间片便面临着缓存效率的问题。</p><p>因此，操作系统提供了将进程或者线程绑定到某一颗CPU上运行的能力。如Linux上提供了sched_setaffinity方法实现这一功能，其他操作系统也有类似功能的API可用。我在GitHub上提供了一个示例程序（代码见<a href=\"https://github.com/russelltao/geektime_distrib_perf/tree/master/1-cpu_cache/cpu_migrate\">这里</a>），你可以看到，当多线程同时执行密集计算，且CPU缓存命中率很高时，如果将每个线程分别绑定在不同的CPU核心上，性能便会获得非常可观的提升。Perf工具也提供了cpu-migrations事件，它可以显示进程从不同的CPU核心上迁移的次数。</p><h2>小结</h2><p>今天我给你介绍了CPU缓存对程序性能的影响。这是很底层的性能优化，它对各种编程语言做密集计算时都有效。</p><p>CPU缓存分为数据缓存与指令缓存，对于数据缓存，我们应在循环体中尽量操作同一块内存上的数据，由于缓存是根据CPU Cache Line批量操作数据的，所以顺序地操作连续内存数据时也有性能提升。</p><p>对于指令缓存，有规律的条件分支能够让CPU的分支预测发挥作用，进一步提升执行效率。对于多核系统，如果进程的缓存命中率非常高，则可以考虑绑定CPU来提升缓存命中率。</p><h2>思考题</h2><p>最后请你思考下，多线程并行访问不同的变量，这些变量在内存布局是相邻的（比如类中的多个变量），此时CPU缓存就会失效，为什么？又该如何解决呢？欢迎你在留言区与大家一起探讨。</p><p>感谢阅读，如果你觉得这节课对你有一些启发，也欢迎把它分享给你的朋友。</p>","comments":[{"had_liked":false,"id":211576,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1587985672,"is_pvip":false,"replies":[{"id":"78667","content":"讲得非常好！忆水寒同学对底层知识理解地很透彻！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1587996863,"ip_address":"","comment_id":211576,"utype":1}],"discussion_count":4,"race_medal":0,"score":"362365238536","product_id":100051201,"comment_content":"因为在多核CPU时代，CPU有“缓存一致性”原则，也就是说每个处理器（核）都会通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了。如果过期了，则失效。比如声明volitate，当变量被修改，则会立即要求写入系统内存。","like_count":85,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493305,"discussion_content":"讲得非常好！忆水寒同学对底层知识理解地很透彻！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587996863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2397964,"avatar":"","nickname":"小胡","note":"","ucode":"1E0DD4138E9D0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392328,"discussion_content":"可以啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630969588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172056,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","nickname":"杨春鹏","note":"","ucode":"518F38232F97B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254165,"discussion_content":"确定不是volatile？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588298986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1172056,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","nickname":"杨春鹏","note":"","ucode":"518F38232F97B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":254281,"discussion_content":"写错了....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588309184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":254165,"ip_address":""},"score":254281,"extra":""}]}]},{"had_liked":false,"id":211762,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1588001950,"is_pvip":false,"replies":[{"id":"78708","content":"完全正确！二星球同学用过填充法写代码么？或者看到过这样的开源代码？","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588037324,"ip_address":"","comment_id":211762,"utype":1}],"discussion_count":11,"race_medal":0,"score":"297940745374","product_id":100051201,"comment_content":"一片连续的内存被加载到不同cpu核心中（就是同一个cache line在不同的cpu核心），其中一个cpu核心中修改cache line,其它核心都失效，加锁也是加在cache  line上，其它核心线程也被锁住，降低了性能。解决办法是填充无用字节数，使分开","like_count":70,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493357,"discussion_content":"完全正确！二星球同学用过填充法写代码么？或者看到过这样的开源代码？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588037324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1493954,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/c2/abd584db.jpg","nickname":"pythonista","note":"","ucode":"CE117439281B93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338358,"discussion_content":"private:\n  // make sure head &amp; tail don&#39;t share a cacheline\n  union {\n    char padding_[GPR_CACHELINE_SIZE];\n    Atomic<Node*> head_;\n  };\n  Node* tail_;\n\ngrpc里的代码，实现了一个多生产者单消费者的队列，由于队列的头节点和尾节点会被不同的线程并发访问，为了避免伪共享问题，增加填充字节，确保头节点和尾节点分布于不同的cacheline.","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1609247292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258444,"discussion_content":"disruptor框架便是其中一个，做了很多cache line的优化。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1588687783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1951950,"avatar":"","nickname":"Geek_f9c246","note":"","ucode":"822D9547A6AC2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252380,"discussion_content":"jdk8中新增的LongAdder原子操作就是缓存行填充，使用多个long属性字段，系统的位数不一样，填充也不一样","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588161087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284279,"avatar":"https://static001.geekbang.org/account/avatar/00/13/98/b7/2c725922.jpg","nickname":"了无痕","note":"","ucode":"E066E72F0CB4B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285427,"discussion_content":"温故而知新，nginx的一些锁和记录运行状态的变量每个都是128字节，用的就是填充法吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592833139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623575,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/17/651e8d72.jpg","nickname":"Persist","note":"","ucode":"203596C835EAF2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251095,"discussion_content":"java的jdk1.7的LinkedTransferQueue就是基于填充法补足64字节","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588064924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237280,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/20/04f1db8f.jpg","nickname":"lich0079","note":"","ucode":"A6A46620E43C2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357659,"discussion_content":"disruptor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615850060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260131,"discussion_content":"填充无用字符经常用到，这么用还真的很巧妙啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588850284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1984655,"avatar":"","nickname":"weing","note":"","ucode":"95701BDA31F6F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251735,"discussion_content":"厉害！\n非常专业，对如何实现感兴趣，求教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588115754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003327,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","nickname":"王坤祥","note":"","ucode":"FB988B9F381A33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250828,"discussion_content":"是disruptor嘛？我之前看资料了解过，这个框架可以填充缓存行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588042764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1983655,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/44/a7/11668a40.jpg","nickname":"不重要","note":"","ucode":"4E3EAABE68F956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250725,"discussion_content":"是个好办法，怎么每次保证预取到cache中两者是分开的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588036930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212151,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1588067461,"is_pvip":true,"replies":[{"id":"78940","content":"你好一步，这里的原理其实与思考题是一致的，因为当所有bucket连续时，某个50字节的bucket一定会横跨2个cpu cache line，比如第2个bucket在内存上占用50-100字节，这样当CPU1访问第1个bucket时，会把第2个bucket的数据也载入，这样CPU2访问第2个bucket时，若第1个bucket发生变化，就会导致CPU2必须重新读入bucket。类似的，某个70个字节的bucket一定会占用到3个cpu cache line。文章中写得不够细，我再稍微调整补充下好了。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588138999,"ip_address":"","comment_id":212151,"utype":1}],"discussion_count":1,"race_medal":0,"score":"177681726597","product_id":100051201,"comment_content":"配置 nginx server_names_bucket_siz 的大小<br>而桶大小为 50 字节，会导致最坏 2 次访问内存，而 70 字节最坏会有 3 次访问内存。<br>----------------------------------------------------<br>为什么 50字节会访问2次内存呢？ 不是可以加载 64k数据到缓存，包含了 50个字节，一次不就够了吗？<br>70k 也是同样的问题，为什么是3次啊","like_count":42,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493440,"discussion_content":"你好一步，这里的原理其实与思考题是一致的，因为当所有bucket连续时，某个50字节的bucket一定会横跨2个cpu cache line，比如第2个bucket在内存上占用50-100字节，这样当CPU1访问第1个bucket时，会把第2个bucket的数据也载入，这样CPU2访问第2个bucket时，若第1个bucket发生变化，就会导致CPU2必须重新读入bucket。类似的，某个70个字节的bucket一定会占用到3个cpu cache line。文章中写得不够细，我再稍微调整补充下好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588138999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211577,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1587985839,"is_pvip":false,"replies":[{"id":"78669","content":"最初这篇文章有6千字，想在一篇文章中讲清楚CPU缓存太难啦，后来编辑小姐姐协助我一点点删下来，还是担心读者看不懂，找不到重点。<br>忆水寒同学的知识很扎实，你点赞我就放心啦^_^。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1587997040,"ip_address":"","comment_id":211577,"utype":1}],"discussion_count":3,"race_medal":0,"score":"108962168239","product_id":100051201,"comment_content":"这个文章其实讲解的很细致，来龙去脉都说清楚了。不错！<br>其实每篇文章能讲到这个地步，作为读者（也可以称为学生）每篇能够学到一个哪怕很小的知识点，那也是值得的。","like_count":25,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493306,"discussion_content":"最初这篇文章有6千字，想在一篇文章中讲清楚CPU缓存太难啦，后来编辑小姐姐协助我一点点删下来，还是担心读者看不懂，找不到重点。\n忆水寒同学的知识很扎实，你点赞我就放心啦^_^。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587997040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170670,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dc/ee/8fb92613.jpg","nickname":"晏鹏","note":"","ucode":"D23BC3B61C257E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363148,"discussion_content":"删除后还变简单了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617116622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250373,"discussion_content":"小姐姐好厉害，居然懂CPU缓存！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588000664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211663,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1587993363,"is_pvip":false,"replies":[{"id":"78905","content":"是的，路阳同学思路完全正确！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588122549,"ip_address":"","comment_id":211663,"utype":1}],"discussion_count":8,"race_medal":0,"score":"100372241171","product_id":100051201,"comment_content":"思考题：<br>数据从内存加载到高速缓存中，以块为基本单元（一个块64字节），相邻的两个变量很可能在同一块中，当这个数据块分别加载到两颗cpu的高速缓存中时，只要一个cpu对该块（高速缓存中缓存的块）进行写操作，那么另一cpu缓存的该块将失效。<br>可以通过将两个变量放到不同的缓存块中，来解决这个问题","like_count":23,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493327,"discussion_content":"是的，路阳同学思路完全正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588122549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291861,"discussion_content":"这个答案比较合理， 老师回复的时候可以有针对性的评价下，有很多答案都不错，或者答得比较偏，这样很好，知识点可以更多得发散，但是对应问题的，最准确得答案，还是有必要专门提一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594977891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110113,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","nickname":"无名","note":"","ucode":"2D2E877CF97138","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261743,"discussion_content":"具体怎么实现呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589001020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1080180,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7b/74/a4c4838f.jpg","nickname":"hello world","note":"","ucode":"DC5A5FF4B15F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110113,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","nickname":"无名","note":"","ucode":"2D2E877CF97138","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298324,"discussion_content":"缓存行填充","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597245085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":261743,"ip_address":""},"score":298324,"extra":""}]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260128,"discussion_content":"优秀呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588850157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1580279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/f7/d47f070f.jpg","nickname":"令年月未枉过","note":"","ucode":"F29C5C82E6FF76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251199,"discussion_content":"ThreadLocal合理利用就是这个道理吧，netty疯狂使用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588073223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1983655,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/44/a7/11668a40.jpg","nickname":"不重要","note":"","ucode":"4E3EAABE68F956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250703,"discussion_content":"将两个变量放入到不同的缓存快中，你的意思是说每个线程各自维护自己的变量？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588036287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1983655,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/44/a7/11668a40.jpg","nickname":"不重要","note":"","ucode":"4E3EAABE68F956","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251041,"discussion_content":"你可以看老师对@二星球的留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588059498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250703,"ip_address":""},"score":251041,"extra":""}]}]},{"had_liked":false,"id":212353,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1588088601,"is_pvip":true,"replies":[{"id":"78945","content":"你好长脖子树，你的答案完全正确，而且非常详细，长脖子树提到的Intel MESIF 协议，以及Java中的@Contended注解非常专业，请其他同学参考！！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588141746,"ip_address":"","comment_id":212353,"utype":1}],"discussion_count":5,"race_medal":0,"score":"87487434521","product_id":100051201,"comment_content":"多线程并行访问不同的变量,  cpu 缓存的失效需要基于其中有一个 core 将 L1&#47;L2 cache 写回主存, 但这个时间是不固定的. 除非你使用  lock 等强制刷新到 主存 , 而其他 core 上的缓存行会置为 Invalid , 这就要提到 缓存一致性 MESIF 协议 <br>如果这些变量在内存布局中相邻的, 很有可能在同一个 cache line 中,  要避免竞争, 就要避免在同一个 缓存行中, 比如 java 中的方法:  手动在这个变量前后 padding 间隔开一定字节(一般 64 字节) 或者 @Contended 标记这个变量 ","like_count":21,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493481,"discussion_content":"你好长脖子树，你的答案完全正确，而且非常详细，长脖子树提到的Intel MESIF 协议，以及Java中的@Contended注解非常专业，请其他同学参考！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588141746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322455,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/d7/74fc8f38.jpg","nickname":"灿烂明天","note":"","ucode":"07DA56B0680D0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286632,"discussion_content":"你好，我想问下那个注解加的时候有什么讲究吗？不可能每个变量都加吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593250391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1182802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","nickname":"长脖子树","note":"","ucode":"D9090EF67EEB1B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1322455,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/d7/74fc8f38.jpg","nickname":"灿烂明天","note":"","ucode":"07DA56B0680D0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286770,"discussion_content":"一般只有多个 Volatile 变量共同竞争一个缓存行才会导致 false  sharing，但这种情况很少会遇到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593274742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286632,"ip_address":""},"score":286770,"extra":""}]},{"author":{"id":1527079,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4d/27/5b9670aa.jpg","nickname":"钱程","note":"","ucode":"813F2B06B92CCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284979,"discussion_content":"学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592704411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178247,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/87/75f8783a.jpg","nickname":"行知老王","note":"","ucode":"DD0CBFFA420D15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276774,"discussion_content":"不错，拿小本本记下来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590936504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211615,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1587989006,"is_pvip":false,"replies":[{"id":"78660","content":"你好海罗，这门课虽然只有30讲，但会涵盖绝大部分性能优化点，所以每篇文章都会涉及不同的知识。这一篇我希望你能明白CPU缓存的用途，这是成为高手必须了解的知识。<br>比如，我在protobuf那一讲中，还会讲到protobuf是怎么利用缓存的。所以，你可以先有这么一个概念，在后续用到的时候，再回过头来看，就更容易理解了。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1587995886,"ip_address":"","comment_id":211615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"78897400334","product_id":100051201,"comment_content":"第一篇就进入知识盲区了","like_count":19,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493314,"discussion_content":"你好海罗，这门课虽然只有30讲，但会涵盖绝大部分性能优化点，所以每篇文章都会涉及不同的知识。这一篇我希望你能明白CPU缓存的用途，这是成为高手必须了解的知识。\n比如，我在protobuf那一讲中，还会讲到protobuf是怎么利用缓存的。所以，你可以先有这么一个概念，在后续用到的时候，再回过头来看，就更容易理解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587995886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212012,"user_name":"好吃不贵","can_delete":false,"product_type":"c1","uid":1316993,"ip_address":"","ucode":"6576E2BECE4F7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/81/83b6ade2.jpg","comment_is_top":false,"comment_ctime":1588046211,"is_pvip":true,"replies":[{"id":"78799","content":"是的，好吃不贵的答案更加简洁！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588053800,"ip_address":"","comment_id":212012,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61717588355","product_id":100051201,"comment_content":"思考题猜测是False sharing导致的，非常热的数据最好cache line对齐。","like_count":14,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493408,"discussion_content":"是的，好吃不贵的答案更加简洁！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588053800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221124,"user_name":"二进制之路","can_delete":false,"product_type":"c1","uid":1008395,"ip_address":"","ucode":"67C84B013147B1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/0b/ad56aeb4.jpg","comment_is_top":false,"comment_ctime":1590410556,"is_pvip":false,"replies":[{"id":"81569","content":"谢谢二进制之路的全面总结！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1590453221,"ip_address":"","comment_id":221124,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48835050812","product_id":100051201,"comment_content":"CPU性能优化的4个点：<br>1.按顺序访问数据（操作连续内存）：利用数据缓存，提高读数据缓存的命中率。<br>2.有规律的条件分支（如数据集先排序再处理）：利用指令缓存，提高读指令缓存的命中率。<br>3.数据按缓存行大小填充&#47;对齐（通常为64字节）：防止伪共享，提高并发处理能力和缓存命中率。<br>4.对于多核处理器，如果缓存命中率很高，可以考虑进行CPU绑定。","like_count":11,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496343,"discussion_content":"谢谢二进制之路的全面总结！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590453221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211570,"user_name":"鲤鲤鱼","can_delete":false,"product_type":"c1","uid":1192046,"ip_address":"","ucode":"D299814DDE1F6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/30/6e/581b0307.jpg","comment_is_top":false,"comment_ctime":1587984791,"is_pvip":false,"replies":[{"id":"78673","content":"解决性能问题，一般有两种方法：经验派和“理论”派，前者就是基于自己的经验概率，将能想到的优化方法都试一遍，这种方式通常又有效又快速，但无法解决复杂的问题。<br>所谓理论派，就是沿着固定的思路，使用二分法，从高至低慢慢下沉到细节。具体到你的问题，我建议你先看看，CPU占用是用户态还是系统态，用户态的话就要分析代码了，系统态还要进一步分析。火焰图通常是个很好的办法，虽然搭能画火焰图的环境很麻烦，但这种底层方法很有效的。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1587997794,"ip_address":"","comment_id":211570,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40242690455","product_id":100051201,"comment_content":"陶老师我们集群有一个问题，某一台物理机的CPU会被Hadoop yarn的查询任务打满，并且占用最多的pid在不停的变化，我查看了TIME_WAIT的个数好像也不是很多，在顶峰的时候还没达到一万，能够持续一两个小时。这个问题您有没有什么思路呢？","like_count":9,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493302,"discussion_content":"解决性能问题，一般有两种方法：经验派和“理论”派，前者就是基于自己的经验概率，将能想到的优化方法都试一遍，这种方式通常又有效又快速，但无法解决复杂的问题。\n所谓理论派，就是沿着固定的思路，使用二分法，从高至低慢慢下沉到细节。具体到你的问题，我建议你先看看，CPU占用是用户态还是系统态，用户态的话就要分析代码了，系统态还要进一步分析。火焰图通常是个很好的办法，虽然搭能画火焰图的环境很麻烦，但这种底层方法很有效的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587997794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250546,"discussion_content":"老师，我能收集到火焰图，但是，并不是每次都能有收获，后面，请老师给出一些更加有效的使用和分析火焰图的方法呗，谢谢老师先！么么哒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588024623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238245,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/e5/82132920.jpg","nickname":"亦知码蚁","note":"","ucode":"400344A6E1207F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250779,"discussion_content":"linux性能优化这门课有这个部分 你可以去看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588039584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250546,"ip_address":""},"score":250779,"extra":""}]}]},{"had_liked":false,"id":211779,"user_name":"赖阿甘","can_delete":false,"product_type":"c1","uid":1351988,"ip_address":"","ucode":"77493FE85CBAF8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICBNZjA9hW65x6g9b2iaicKUJW5gxFxtgPXH9Cqp6eyFfY1sD2hVY4dZrY5pmoK2r1KZEiaaIKocdZQ/132","comment_is_top":false,"comment_ctime":1588003548,"is_pvip":false,"replies":[{"id":"78755","content":"你好赖阿甘，你读得很仔细，完全正确，我笔误啦，非常感谢你的提醒，稍候我会联系编辑小姐姐更正的。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588042161,"ip_address":"","comment_id":211779,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31652774620","product_id":100051201,"comment_content":"此时内存是跳跃访问的，如果 N 的数值很大，那么操作 array[j][i]时，是没有办法把 array[j][i+1]也读入缓存的。<br>---------------------------------------------------------------------------------------------<br>老师是不是写错了，应该是”那么操作 array[j][i]时，是没有办法把 array[j+1][i]（而不是array[j][i+1]）也读入缓存的。”","like_count":7,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493362,"discussion_content":"你好赖阿甘，你读得很仔细，完全正确，我笔误啦，非常感谢你的提醒，稍候我会联系编辑小姐姐更正的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588042161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513070,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibb1HJTBX85TuIYRQv3eUxib5Zdc5paH1mULBaLFZf0N6C1WxLrw6ZUc4oiaEPQEdfrQMkIjIYtTib66l8VfgrtHRQ/132","nickname":"Geek_71d4ac","note":"","ucode":"81FBA4DA79F5E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250678,"discussion_content":"我也觉得老师写错了，缓存以连续地址单元数据加载的，跳跃访问意味着连续性使用率降低，而随着数据增多，后面的数据反而没法立刻填入缓存区，进而产生缓存区替换问题，性能大大下降。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588035623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212877,"user_name":"罗帮奎","can_delete":false,"product_type":"c1","uid":1271773,"ip_address":"","ucode":"8598D116E1FC3C","user_header":"https://static001.geekbang.org/account/avatar/00/13/67/dd/55aa6e07.jpg","comment_is_top":false,"comment_ctime":1588230328,"is_pvip":false,"replies":[{"id":"79141","content":"正确！^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588408180,"ip_address":"","comment_id":212877,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27358034104","product_id":100051201,"comment_content":"多线程并发，如果一个core上的线程改变了变量，而其他core正好映射到相同的cacheLine上，则底层硬件会宣布所有其他core的缓存行失效。其它core下次需要重新去从主存中读取数据，来获取新的cacheLine。在多核系统上，这样会有严重的性能问题","like_count":6,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493637,"discussion_content":"正确！^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588408180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212326,"user_name":"+1day","can_delete":false,"product_type":"c1","uid":1299743,"ip_address":"","ucode":"ADF6576F46B8E6","user_header":"https://static001.geekbang.org/account/avatar/00/13/d5/1f/9fbd95ac.jpg","comment_is_top":false,"comment_ctime":1588086402,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"27357890178","product_id":100051201,"comment_content":"陶老师您好，不太熟悉底层的知识，问题可能有点小白，没有在网上搜索到答案，希望您能解答，感谢。<br>1. 执行时间相差 8 倍中，64 位操作系统缓存一次载入 64 字节数据的话，为什么每批 Cache Line 最多只能载入不到 8 个二维数组元素呢？元素类型是整型，大小为 4 字节的话，一次不是可以读取 16 个元素的吗？<br>2. Nginx 的例子中，桶的大小为 50 字节，一次载入 64 字节不应该可以一次访问就加载到缓存中了吗？是不是这里所说的缓存单纯指的一级缓存呢？","like_count":6,"discussions":[{"author":{"id":1289318,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ac/66/a256008b.jpg","nickname":"SuperDai","note":"","ucode":"0CA86D253754CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301163,"discussion_content":"指针+数据本身","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598429976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1706081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKqKBP4UXlpDa9JuHP8icQnrJRNyGib3nzWeibgpoxGA9jKLmnKuHYobqrNib6BGeokPxSqibSDwMet55w/132","nickname":"hanjc","note":"","ucode":"6E53FED35995A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1289318,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ac/66/a256008b.jpg","nickname":"SuperDai","note":"","ucode":"0CA86D253754CA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388316,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628693281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301163,"ip_address":""},"score":388316,"extra":""}]},{"author":{"id":1613505,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9e/c1/ff754fa8.jpg","nickname":"Justin","note":"","ucode":"FC6E2BD6EA0637","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256425,"discussion_content":"同问第一题","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588479294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476450,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","nickname":"曙光","note":"","ucode":"04D65BF7F19845","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262371,"discussion_content":"同问第一题","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589082915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748503,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/17/136fead2.jpg","nickname":"さようなら","note":"","ucode":"027E0741A14B87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309393,"discussion_content":"第一题有人想通了吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601278506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1706081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKqKBP4UXlpDa9JuHP8icQnrJRNyGib3nzWeibgpoxGA9jKLmnKuHYobqrNib6BGeokPxSqibSDwMet55w/132","nickname":"hanjc","note":"","ucode":"6E53FED35995A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388317,"discussion_content":"想想一维数组和二维数组的区别，就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628693325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2638449,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/n9b6MBUWrzPL62CfN56qmqjLQyWWtYaVXTthJOiblyq5GpnFkS64cyWChpYwKhaBCzgyIY89YXRZib1vkFmo4m8Q/132","nickname":"Geek_aa12d0","note":"","ucode":"B81CA1ED66F75D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1706081,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKqKBP4UXlpDa9JuHP8icQnrJRNyGib3nzWeibgpoxGA9jKLmnKuHYobqrNib6BGeokPxSqibSDwMet55w/132","nickname":"hanjc","note":"","ucode":"6E53FED35995A1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406208,"discussion_content":"二维数组存储方式和一维数组相同，访问二维数组需要载入地址的话，那么不管是a[i][j]还是a[j][i]的形式不都需要载入地址吗？所以差别可能是因为cache命中导致的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634721327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":388317,"ip_address":""},"score":406208,"extra":""}]},{"author":{"id":2280790,"avatar":"","nickname":"第七","note":"","ucode":"C773EF16E6EE3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350210,"discussion_content":"第一题应该是会先加载第一维的cache line数据(地址)进入L1，随后再加载第二维的cache line数据(int 数值)进入L1。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613747278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1970475,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/11/2b/042cfcd3.jpg","nickname":"Chauncy J.","note":"","ucode":"E5DC9DA3A5E64B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264119,"discussion_content":"二维数组是不是需要存储两个值，一个4个一节，两个就是8个字节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589290203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211769,"user_name":"王坤祥","can_delete":false,"product_type":"c1","uid":1003327,"ip_address":"","ucode":"FB988B9F381A33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","comment_is_top":false,"comment_ctime":1588002529,"is_pvip":false,"replies":[{"id":"78742","content":"你好ByiProX，能够从留言中感受到你最近的进步，非常棒！      你的理解都是正确的，关于思考题你可以看下二星球的留言，他说得很清楚^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588041514,"ip_address":"","comment_id":211769,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27357806305","product_id":100051201,"comment_content":"前几天学习了一下计算机组成原理。大部分都能听懂，开心~~~<br><br>本节讲到的性能优化实际上是涉及到了计算机组成原理中的【内存的局部性原理】以及【cpu的分支预测】。<br><br>对于课后的问题，因为多线程操作某些共享变量，涉及到变量的有效性问题（是否过期），如果变量在一个线程被修改，其他核心中的缓存失效啦。其他线程调用该变量的时候会从内存中重新加载到缓存。<br><br>所谓的如何解决，应该是解决缓存失效和保持数据一致性的问题，应该满足两点：<br>1. 写传播，即通知其他核心，某个缓存失效，需要从内存读取一下<br>2. 保证事务串行化，事务请求的顺序不能变化<br>我看资料了解到解决方案是基于总线嗅探机制的MESI协议来解决数据一致性问题。<br><br>在Java中，volatile 会确保我们对于这个变量的读取和写入，都一定会同步到主内存里，而不是从 Cache 里面读取，保证了数据一致性问题。 <br><br>这是我最近学习计算机组成原理后见解，不知道自己理解的有没有问题。有问题希望陶辉老师指正一下。","like_count":6,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493359,"discussion_content":"你好ByiProX，能够从留言中感受到你最近的进步，非常棒！      你的理解都是正确的，关于思考题你可以看下二星球的留言，他说得很清楚^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588041514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003327,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","nickname":"王坤祥","note":"","ucode":"FB988B9F381A33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250836,"discussion_content":"看到二星球说的缓存行填充，我想到了disruptor，我之前看资料了解过，这个工具可以做缓存行填充。\n\n突然意识到，原来缓存失效的单位是cache line，之前一直理解错了，多谢陶辉老师~~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588043268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211744,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1588000466,"is_pvip":false,"replies":[{"id":"78736","content":"我来也同学每篇必有留言被编辑小姐姐选为精品，^_^<br>perf没有侵入性，使用简单，效果非常棒，值得你投入精力好好学一学！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588040401,"ip_address":"","comment_id":211744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23062836946","product_id":100051201,"comment_content":"老师代码准备的真多！<br><br>思考题有同学已经回答的非常准确了。<br>虽然已经看过了 linux性能优化 计算机组成原理 和 性能工程高手课 ，但看起老师的文章还是很有意思。<br>一些知识也加深了印象。<br><br>perf工具看来是要找个时间好好看看了。<br>最早是在linux性能优化专栏看到用到，今天在一篇公众号上看别人用这个快速定位了线上有问题的死循环函数，今天老师又提到了用它看命中率。<br><br>工具用好了真的是方便，lsof之前也没用过，后来用了几次觉得非常好用，现在就经常用了。","like_count":5,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493352,"discussion_content":"我来也同学每篇必有留言被编辑小姐姐选为精品，^_^\nperf没有侵入性，使用简单，效果非常棒，值得你投入精力好好学一学！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588040401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212739,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1588205501,"is_pvip":false,"replies":[{"id":"79032","content":"完全正确！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588209615,"ip_address":"","comment_id":212739,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18768074685","product_id":100051201,"comment_content":"内存伪共享问题，可以通过填充无效数据解决。<br>伪共享：假设cache line是64字节，我们在一个64字节的并且和cache line 对齐后的内存中放入两个4字节的整数A和B，然后线程a和b分别访问A和B，在内存层面的语义是这两个线程分别独享一块内存区域，操作时互不干扰，但是在缓存cache line层面他们是共享一个cache line的，是一个&quot;原子的数&quot;，这就是伪共享。<br>         缓存层面的伪共享的一致性由硬件保证，对程序员透明，也就是对这个&quot;原子数&quot;的操作不用显式加锁，但是伪共享降低程序效率。","like_count":4,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493597,"discussion_content":"完全正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588209615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212044,"user_name":"Oliver","can_delete":false,"product_type":"c1","uid":1349942,"ip_address":"","ucode":"E82BAFD6E027CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/99/36/80d3f12b.jpg","comment_is_top":false,"comment_ctime":1588051226,"is_pvip":false,"replies":[{"id":"78816","content":"你好Oliver，第1讲的初稿是有提的，但因为numa架构其实是讲访问非本地主存时，性能的降低问题，所以与CPU缓存关系不太直接，后面删除了。本来后面也不会再提到，不过中间有个10道面试题，我跟编辑商量下能不能放在那里提下。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588055277,"ip_address":"","comment_id":212044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14472953114","product_id":100051201,"comment_content":"对比开篇树图，numa架构貌似还没说，后续会提到吗？","like_count":3,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493416,"discussion_content":"你好Oliver，第1讲的初稿是有提的，但因为numa架构其实是讲访问非本地主存时，性能的降低问题，所以与CPU缓存关系不太直接，后面删除了。本来后面也不会再提到，不过中间有个10道面试题，我跟编辑商量下能不能放在那里提下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588055277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211887,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1588035754,"is_pvip":true,"replies":[{"id":"78728","content":"谢谢分享！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588039727,"ip_address":"","comment_id":211887,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14472937642","product_id":100051201,"comment_content":"https:&#47;&#47;zxs.io&#47;s&#47;o 我之前写过一篇博客详细介绍了cpu分支预测和性能差异，有兴趣可以参考下。 ","like_count":3,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493388,"discussion_content":"谢谢分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588039727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239081,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1596430087,"is_pvip":true,"replies":[{"id":"88322","content":"对的","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1596440046,"ip_address":"","comment_id":239081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10186364679","product_id":100051201,"comment_content":"因为cache-line的大小是64kb，由于单个变量站的大小占用的缓存大小达不到64kb。所以存在多个内存变量共享一个缓存行。导致多线程访问不同变量的时候 缓存行失效。解决方法是采用缓存行填充的方式，让每个线程的不同变量，占用不同的缓存行，提高命中率。","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502971,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596440046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215694,"user_name":"扁舟","can_delete":false,"product_type":"c1","uid":1818287,"ip_address":"","ucode":"486C0D0FAB15C8","user_header":"https://static001.geekbang.org/account/avatar/00/1b/be/af/93e14e9d.jpg","comment_is_top":false,"comment_ctime":1589079178,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10179013770","product_id":100051201,"comment_content":"老师，您前面回答了评论中的 ”而桶大小为 50 字节，会导致最坏 2 次访问内存，而 70 字节最坏会有 3 次访问内存。”，但我仍然有几个不解<br>1.想问一下缓存行加载数据时 每一次加载数据都会加载 一个缓存行大小的数据吗？每次加载都会直到填满这个缓存行为止吗？如果所有缓存行满了的话，是LRU那样的替换吗？<br>2. 64字节恰好符合一个缓存行大小于是只要1个字节，54字节小于一个缓存行，他又是怎么加载的呢，70字节大于1个小于2个又是如何加载的呢。<br>希望老师能过解答一下这心中的疑问。谢谢老师","like_count":2,"discussions":[{"author":{"id":1039204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","nickname":"中年男子","note":"","ucode":"027C86B3370150","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269209,"discussion_content":"“我测试的服务器一次会载入 64 字节至缓存中。当载入 array[0][0]时，若它们占用的内存不足 64 字节，CPU 就会顺序地补足后续元素”， 文中原话， 应该能解答你第一个问题。没有缓存行满了的说法， 一次缓存就是载入64字节， 缓存失效是重新载入64字节。\n第二个问题好好读读 前面老师回复的评论， 讲的很清楚了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589879273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215126,"user_name":"卓明","can_delete":false,"product_type":"c1","uid":1167468,"ip_address":"","ucode":"6AB57EE1DF3CEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/d0/6c/2e7dd298.jpg","comment_is_top":false,"comment_ctime":1588909329,"is_pvip":false,"replies":[{"id":"90982","content":"谢谢卓明的分享！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817674,"ip_address":"","comment_id":215126,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10178843921","product_id":100051201,"comment_content":"在jdk1.7以下的版本中，linkedTransferQueue有这方面的优化，使用追加字节的方式，来避免缓存行的竞争导致入队和出队的效率低下的问题，应该是同一个原因","like_count":2,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494324,"discussion_content":"谢谢卓明的分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273984,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1610777171,"is_pvip":false,"replies":[{"id":"99543","content":"你好Douglas，你是指类似Fortran这样的编程语言，将二维数组的内存布局改为列优先布局吗？因为Fortran这样的语言很小众，现在少有人使用，这里就没有展开。感兴趣的话，可以看下这篇文章：https:&#47;&#47;eli.thegreenplace.net&#47;2015&#47;memory-layout-of-multi-dimensional-arrays","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1610933759,"ip_address":"","comment_id":273984,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5905744467","product_id":100051201,"comment_content":" a[i][j]   和    a[j][i]  孰优孰劣 需要看情况， 是 行 优先 还是列 优先？这一块老师是不是漏掉了？   ","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513883,"discussion_content":"你好Douglas，你是指类似Fortran这样的编程语言，将二维数组的内存布局改为列优先布局吗？因为Fortran这样的语言很小众，现在少有人使用，这里就没有展开。感兴趣的话，可以看下这篇文章：https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610933759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343036,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610933965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228896,"user_name":"了无痕","can_delete":false,"product_type":"c1","uid":1284279,"ip_address":"","ucode":"E066E72F0CB4B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/b7/2c725922.jpg","comment_is_top":false,"comment_ctime":1592835501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887802797","product_id":100051201,"comment_content":"总结：（1）cpu数据缓存。（注意多核，多线程，缓存一致性）（2）cpu指令缓存。（分支规律，提高分支预测）。（3）cpu线程绑定，提高缓存命中。","like_count":1},{"had_liked":false,"id":215303,"user_name":"ZP","can_delete":false,"product_type":"c1","uid":1007856,"ip_address":"","ucode":"93B957C33363B4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/f0/41047878.jpg","comment_is_top":false,"comment_ctime":1588950422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883917718","product_id":100051201,"comment_content":"数据先进入L3缓存再进入L2缓存说错了，现在服务器常用的Skylake架构的CPU是Non-inclusive的缓存架构，数据直接进入L2，L3只作为L2的victim cache使用","like_count":1},{"had_liked":false,"id":212041,"user_name":"Geek_David","can_delete":false,"product_type":"c1","uid":1897719,"ip_address":"","ucode":"9B9F30BB2F2C68","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/f7/871ff71d.jpg","comment_is_top":false,"comment_ctime":1588050802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883018098","product_id":100051201,"comment_content":"不同线程使用的CPU核心会存在差异，虽然访问的都是同一块连续的变量，但是仅仅只是其中的一个，将后面连续的变量读入缓存没有任何的作用。<br>另外就算是在同一个cpu上运行的不同线程，访问变量大概率也是有跳跃性的，所以缓存基本就失效了。<br><br>不知道理解对不对，请老师指正","like_count":1},{"had_liked":false,"id":211975,"user_name":"卒迹","can_delete":false,"product_type":"c1","uid":1202095,"ip_address":"","ucode":"FAE1AA6038402C","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/af/0b39cab7.jpg","comment_is_top":false,"comment_ctime":1588041827,"is_pvip":false,"replies":[{"id":"78778","content":"哈哈，不是说，咱们这行业只看能力，学历、专业都不看的，要想保持目前IT行业相对其他行业的高薪资，就得提升入行门槛啊^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588046307,"ip_address":"","comment_id":211975,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883009123","product_id":100051201,"comment_content":"要学的课程太多了，一入IT深似海。","like_count":1,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493402,"discussion_content":"哈哈，不是说，咱们这行业只看能力，学历、专业都不看的，要想保持目前IT行业相对其他行业的高薪资，就得提升入行门槛啊^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588046307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211807,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1588024648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882991944","product_id":100051201,"comment_content":"老师，我能收集到火焰图，但是，并不是每次都能有收获，后面，请老师给出一些更加有效的使用和分析火焰图的方法呗，谢谢老师先！么么哒<br>","like_count":1},{"had_liked":false,"id":354048,"user_name":"上杉夏香","can_delete":false,"product_type":"c1","uid":1521568,"ip_address":"北京","ucode":"9FDDE0979BCC8C","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/a0/032d0828.jpg","comment_is_top":false,"comment_ctime":1660040829,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660040829","product_id":100051201,"comment_content":"说到缓存失效，我能想到两个可能：1、真的没有缓存，还没加载到Cache里面；2、Cache里面的数据失效了。从问题看来，应该不是1，那就是2了。什么时候缓存会失效？让我想起来了MESI，也就是多核CPU的缓存一致性协议。别的核心对某Cache Line进行更新，其他核心上的同一段Cache Line，就会是失效状态。表现出来便是『缓存失效』了。","like_count":0},{"had_liked":false,"id":326002,"user_name":"黎","can_delete":false,"product_type":"c1","uid":1127534,"ip_address":"","ucode":"B09EBFC0CEDC68","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/6e/60a3a0e1.jpg","comment_is_top":false,"comment_ctime":1639301936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639301936","product_id":100051201,"comment_content":"在二维数组，一维是地址，二维是目标元素。这句话没有听懂，请问是什么意思？二维数组内存不是连续的吗？只是[0][0]和[1][0]不连续罢了。","like_count":0},{"had_liked":false,"id":322879,"user_name":"Siren","can_delete":false,"product_type":"c1","uid":2850569,"ip_address":"","ucode":"A1C54EFF2FD6D9","user_header":"https://static001.geekbang.org/account/avatar/00/2b/7f/09/5d51fda4.jpg","comment_is_top":false,"comment_ctime":1637641399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637641399","product_id":100051201,"comment_content":"我在4核心的机器上做了cpu亲和性的实验，无论是在本人的mac里面的ubuntu docker上，还是在aws ec2上，结果都显示没有绑定亲和性的行为比绑定亲和性的行为快。这是为什么啊？","like_count":0},{"had_liked":false,"id":322523,"user_name":"Wade_阿伟","can_delete":false,"product_type":"c1","uid":1688629,"ip_address":"","ucode":"5AE2E846A13443","user_header":"https://static001.geekbang.org/account/avatar/00/19/c4/35/2cc10d43.jpg","comment_is_top":false,"comment_ctime":1637463370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637463370","product_id":100051201,"comment_content":"以前都是在系统层面为业务进行性能分析与优化。老师的课程打开了我的知识盲区，期待跟着老师的课程，每节课解锁一个知识点。","like_count":0},{"had_liked":false,"id":313618,"user_name":"川流不息","can_delete":false,"product_type":"c1","uid":2112841,"ip_address":"","ucode":"AD9705A72B2E9B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xV5ChOHDo5XXX9YQB2rJCNDCGLMZGcgP46RJLuYxH8DZnibSHHicqxeQY2Nw6jfx7MGYYvbw0oGxavVo2rYk003g/132","comment_is_top":false,"comment_ctime":1632559835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632559835","product_id":100051201,"comment_content":"老师你好，对于traverse_1d_array这个例子，以128步长和以1024步长访问性能差距挺大的，我理解，对于64B的cache line，每次访问再加上预取，可以有128B的数据在cpu cache中，那以步长为128遍历还是以1024遍历，我理解每次几乎都不会命中cache，遍历次数又一样的情况下，为啥会有这么大差距呢？<br>以步长为128遍历数组<br>.&#47;traverse_1d_array -s 128 消耗时间（毫秒）：280<br><br>以步长为1024遍历数组<br>.&#47;traverse_1d_array -s 1024 消耗时间（毫秒）：1850","like_count":0},{"had_liked":false,"id":313596,"user_name":"川流不息","can_delete":false,"product_type":"c1","uid":2112841,"ip_address":"","ucode":"AD9705A72B2E9B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xV5ChOHDo5XXX9YQB2rJCNDCGLMZGcgP46RJLuYxH8DZnibSHHicqxeQY2Nw6jfx7MGYYvbw0oGxavVo2rYk003g/132","comment_is_top":false,"comment_ctime":1632547482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632547482","product_id":100051201,"comment_content":"老师你好，我在测试的时候发现cache-misses大于cache-references的情况，请问是什么原因出现这种情况呢？<br>perf stat -e cache-references,cache-misses,instructions,cycles,L1-dcache-load-misses,L1-dcache-loads .&#47;traverse_2d_array -f<br>arr[i][j]<br>10<br><br> Performance counter stats for &#39;.&#47;traverse_2d_array -f&#39;:<br><br>            10,047      cache-references:u                                            (80.54%)<br>            16,055      cache-misses:u            #  159.799 % of all cache refs      (60.99%)<br>        51,627,439      instructions:u            #    1.55  insn per cycle           (80.49%)<br>        33,341,260      cycles:u                                                      (85.16%)<br>            28,385      L1-dcache-load-misses:u   #    0.17% of all L1-dcache hits    (87.00%)<br>        16,908,823      L1-dcache-loads:u                                             (86.31%)<br><br>       0.015954673 seconds time elapsed<br><br>       0.011639000 seconds user<br>       0.003280000 seconds sys","like_count":0},{"had_liked":false,"id":311426,"user_name":"古古惑惑","can_delete":false,"product_type":"c1","uid":1039710,"ip_address":"","ucode":"37724A018564FF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/5e/2354204d.jpg","comment_is_top":false,"comment_ctime":1631234746,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631234746","product_id":100051201,"comment_content":"内存布局中相邻的变量大概率会被加载到cpu缓存的一个cacheline中，多线程并行访问时，这些变量同时存在于多个CPU的缓存中，涉及缓存一致性问题。可以参考MOESI和MESIF协议。","like_count":0},{"had_liked":false,"id":310887,"user_name":"小胡","can_delete":false,"product_type":"c1","uid":2397964,"ip_address":"","ucode":"1E0DD4138E9D0E","user_header":"","comment_is_top":false,"comment_ctime":1630969728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630969728","product_id":100051201,"comment_content":"CPU cache line到底是个什么东西呢","like_count":0},{"had_liked":false,"id":308308,"user_name":"金蝉子","can_delete":false,"product_type":"c1","uid":1180714,"ip_address":"","ucode":"F4FC2E67125F83","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/2a/462d01db.jpg","comment_is_top":false,"comment_ctime":1629528441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629528441","product_id":100051201,"comment_content":"请问老师个问题，数字类型的array二维数组遍历可以理解为CPU数据缓存命中率的问题。那么，如果是Java对象二维数组呢？应该不存在先排序还是后排序的问题吧？","like_count":0},{"had_liked":false,"id":285983,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1617093285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617093285","product_id":100051201,"comment_content":"原来如此<br>Cpu缓存执行命中是这样的<br>居然还有分支预测器","like_count":0},{"had_liked":false,"id":285934,"user_name":"刘易宁","can_delete":false,"product_type":"c1","uid":1566569,"ip_address":"","ucode":"EE337683D08B9A","user_header":"https://static001.geekbang.org/account/avatar/00/17/e7/69/0c426b52.jpg","comment_is_top":false,"comment_ctime":1617079300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617079300","product_id":100051201,"comment_content":"“而桶大小为 50 字节，会导致最坏 2 次访问内存”请问老师，桶的大小为50字节，什么情况下会导致2次访问内存？","like_count":0},{"had_liked":false,"id":267927,"user_name":"林腾","can_delete":false,"product_type":"c1","uid":1963793,"ip_address":"","ucode":"8E2438E56BF677","user_header":"","comment_is_top":false,"comment_ctime":1607998458,"is_pvip":false,"replies":[{"id":"97598","content":"1、需要基于JNA（https:&#47;&#47;github.com&#47;java-native-access&#47;jna），比如使用这个库https:&#47;&#47;github.com&#47;OpenHFT&#47;Java-Thread-Affinity。<br>2、没明白，你是想问2个string对象并发访问的问题吗？要看内存布局，是紧邻着吗？","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1608517808,"ip_address":"","comment_id":267927,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1607998458","product_id":100051201,"comment_content":"请教两个java层面运用cpu缓存的场景： 1. java api如何指定线程绑定一颗cpu运行？ 2.如果采用string对象有什么方式可以减少由cpu缓存一致性带来的缓存失效的问题？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511794,"discussion_content":"1、需要基于JNA（https://github.com/java-native-access/jna），比如使用这个库https://github.com/OpenHFT/Java-Thread-Affinity。\n2、没明白，你是想问2个string对象并发访问的问题吗？要看内存布局，是紧邻着吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608517808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1963793,"avatar":"","nickname":"林腾","note":"","ucode":"8E2438E56BF677","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336966,"discussion_content":"string类型似乎不像int之类的对象有固定的大小，如果一个类紧邻两个string对象，并发访问是不是容易造成缓存失效呢?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608735481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266528,"user_name":"knight劉先生","can_delete":false,"product_type":"c1","uid":2036705,"ip_address":"","ucode":"CEE9BFC8D3D969","user_header":"https://static001.geekbang.org/account/avatar/00/1f/13/e1/6939ae4f.jpg","comment_is_top":false,"comment_ctime":1607386901,"is_pvip":false,"replies":[{"id":"97607","content":"是的","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1608519029,"ip_address":"","comment_id":266528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607386901","product_id":100051201,"comment_content":"列表遍历的区别，Python几乎没差别，思考了下，这个应该跟Python是通过引用指向对象有关","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511296,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608519029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261246,"user_name":"Only now","can_delete":false,"product_type":"c1","uid":1038574,"ip_address":"","ucode":"C617473A03AE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","comment_is_top":false,"comment_ctime":1605249790,"is_pvip":false,"replies":[{"id":"94987","content":"是的","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1605507006,"ip_address":"","comment_id":261246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605249790","product_id":100051201,"comment_content":"这个失效，应该是在有读情况下才会吧。只读的情况下应该不会失效。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509432,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605507006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249133,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1600443668,"is_pvip":false,"replies":[{"id":"91411","content":"L1有数据缓存和指令缓存2种，课程讲到的指令预测就是在用l1i","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1600483986,"ip_address":"","comment_id":249133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600443668","product_id":100051201,"comment_content":"我查看了我自己的 <br><br>hw.l1icachesize:32768;<br>hw.l1dcachesize:32768;<br><br>为什么l1有两个？<br>","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505844,"discussion_content":"L1有数据缓存和指令缓存2种，课程讲到的指令预测就是在用l1i","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600483986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244201,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1598427534,"is_pvip":false,"replies":[{"id":"90260","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1598943296,"ip_address":"","comment_id":244201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598427534","product_id":100051201,"comment_content":"打卡第1天：<br>1.cpu一级缓存分数据缓存和指令缓存<br>2.顺序访问连续的内存可提高数据缓存命中率,<br>有规律的条件分支可以提高指令缓存命中率<br>3.对于计算密集型任务，可以绑定cpu以提高缓存命中率","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504519,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598943296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244145,"user_name":"一路向西","can_delete":false,"product_type":"c1","uid":1309718,"ip_address":"","ucode":"59D044DFE23D30","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/16/97592232.jpg","comment_is_top":false,"comment_ctime":1598409913,"is_pvip":false,"replies":[{"id":"90261","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1598943307,"ip_address":"","comment_id":244145,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598409913","product_id":100051201,"comment_content":"结合老师讲的，再加上评论区同学们的分享，感觉把自己的视野一下打开了。点赞了","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504501,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598943307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241666,"user_name":"木头发芽","can_delete":false,"product_type":"c1","uid":1419723,"ip_address":"","ucode":"657B381C5DA963","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","comment_is_top":false,"comment_ctime":1597386398,"is_pvip":false,"replies":[{"id":"89652","content":"就是这样学习最有收获！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1597993007,"ip_address":"","comment_id":241666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597386398","product_id":100051201,"comment_content":"这一篇边学边思考再加看C++&#47;java的代码花了1小时,看评论后引申出的缓存一致性,volitate用法等去查资料学习又花了1小时. 满满的收货","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503806,"discussion_content":"就是这样学习最有收获！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597993007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240848,"user_name":"李新龙","can_delete":false,"product_type":"c1","uid":2062265,"ip_address":"","ucode":"72C1B0F07EE526","user_header":"","comment_is_top":false,"comment_ctime":1597104424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597104424","product_id":100051201,"comment_content":"总的缓存cache-miss,9%比0.4%,为何和一级缓存dcache-load-misses，为何结果相对？","like_count":0},{"had_liked":false,"id":235757,"user_name":"一凡","can_delete":false,"product_type":"c1","uid":1897395,"ip_address":"","ucode":"5E9BE33452AF3B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f3/b3/0ba7a760.jpg","comment_is_top":false,"comment_ctime":1595172885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595172885","product_id":100051201,"comment_content":"很强 谢谢老师","like_count":0},{"had_liked":false,"id":235242,"user_name":"LindaWang","can_delete":false,"product_type":"c1","uid":1800128,"ip_address":"","ucode":"45368868C3980B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/77/c0/22872965.jpg","comment_is_top":false,"comment_ctime":1594950470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594950470","product_id":100051201,"comment_content":"关于CPU Cache优化，除了上述您讲的代码层面的优化，有没有调度层级的优化手段呢？比如cache分区（将多核共享的L3级Cache分给不同的进程分组或CPU分组单独使用，达到Cache隔离，避免不同进程之间的cache竞争）之类的技术呢？效果如何？","like_count":0},{"had_liked":false,"id":235240,"user_name":"LindaWang","can_delete":false,"product_type":"c1","uid":1800128,"ip_address":"","ucode":"45368868C3980B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/77/c0/22872965.jpg","comment_is_top":false,"comment_ctime":1594950256,"is_pvip":false,"replies":[{"id":"88424","content":"是的，如果是部署在虚拟机之上的云服务器，不支持的事件更多","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1596523738,"ip_address":"","comment_id":235240,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1594950256","product_id":100051201,"comment_content":"请问老师，这是跟系统内核版本有关吗？我的当前系统X86 Ubuntu 16.04 内核 4.4.0-21-generic， 不支持L1-dcache-load-misses、L1-dcache-loads这些events<br>perf stat -e cache-references,cache-misses,instructions,cycles,L1-dcache-load-misses,L1-dcache-loads .&#47;branch_predict -<br> 1127<br><br> Performance counter stats for &#39;.&#47;branch_predict -&#39;:<br><br>         5,205,676      cache-references<br>         4,595,532      cache-misses              #   88.279 % of all cache refs<br>     1,631,836,685      instructions              #    0.50  insns per cycle<br>     3,268,533,223      cycles<br>   &lt;not supported&gt;      L1-dcache-load-misses<br>   &lt;not supported&gt;      L1-dcache-loads<br><br>       1.201545784 seconds time elapsed<br>","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501652,"discussion_content":"是的，如果是部署在虚拟机之上的云服务器，不支持的事件更多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596523738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1525277,"avatar":"https://static001.geekbang.org/account/avatar/00/17/46/1d/83021ef5.jpg","nickname":"大哈","note":"","ucode":"5B4D6D21C11953","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333338,"discussion_content":"那云服务器上如何支持这些事件呢？事件有分硬件事件、软件事件等，硬件事件可能确实没办法支持，软件事件应该都是可以支持的吧，这个需要怎么配置呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607504053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232773,"user_name":"LindaWang","can_delete":false,"product_type":"c1","uid":1800128,"ip_address":"","ucode":"45368868C3980B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/77/c0/22872965.jpg","comment_is_top":false,"comment_ctime":1594114309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594114309","product_id":100051201,"comment_content":"陶辉老师，除了在代码层面提升缓存命中率，有没有调度层面的优化技术？比如cache分区等类似于调度层面的。","like_count":0},{"had_liked":false,"id":229588,"user_name":"chimission","can_delete":false,"product_type":"c1","uid":1258845,"ip_address":"","ucode":"B29276DDA9CEF0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erAwcfNMMg2rW4ROTF5icIic4h1OibuicZdxdibQLyXcrwALzmdKNaAGiapQWibXND8x5EIYngtRqHbfE5xQ/132","comment_is_top":false,"comment_ctime":1593067751,"is_pvip":false,"replies":[{"id":"90783","content":"^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599641721,"ip_address":"","comment_id":229588,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593067751","product_id":100051201,"comment_content":"一个好的教程在读第一篇的时候就可以感受到，很不错的教程。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499548,"discussion_content":"^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599641721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228895,"user_name":"了无痕","can_delete":false,"product_type":"c1","uid":1284279,"ip_address":"","ucode":"E066E72F0CB4B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/b7/2c725922.jpg","comment_is_top":false,"comment_ctime":1592835452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592835452","product_id":100051201,"comment_content":"总结：（1）cpu数据缓存。（注意多核，多线程，缓存一致性）（2）cpu指令缓存。（分支规律，提高分支预测）。（3）cpu线程绑定，提高缓存命中。","like_count":0},{"had_liked":false,"id":228893,"user_name":"了无痕","can_delete":false,"product_type":"c1","uid":1284279,"ip_address":"","ucode":"E066E72F0CB4B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/b7/2c725922.jpg","comment_is_top":false,"comment_ctime":1592835230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592835230","product_id":100051201,"comment_content":"总结：（1）cpu数据缓存cache line（注意多线程，缓存一致性）。（2）cpu指令缓存（具有分支判断规律，提高分支预测）。（3）cpu绑定提高cpu缓存命中。","like_count":0},{"had_liked":false,"id":219815,"user_name":"DY-杨","can_delete":false,"product_type":"c1","uid":1105546,"ip_address":"","ucode":"C84C0250F1A053","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/8a/8b4d7dbd.jpg","comment_is_top":false,"comment_ctime":1590106314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590106314","product_id":100051201,"comment_content":"老师好，咨询个问题。<br>问题一：我们常说的高并发，请问它是指1000万&#47;s用户读写的并发，还是指在有限的机器数量内，单个核心的并发处理能力呢?比如32核机器，如果一个任务1秒，那岂不要堆很多机器了。<br>问题二：CPU的最小处理单位是线程，那请问无论是并发也好还是设计线程池也罢，我们在选择合理的多线程时，除了需要经过测试后计算外，我们还需要考虑内核线程吗。因为在并发时我们理想的是假如单个核心可以处理20个，但实际上并不一定，因为还有内核线程要用CPU资源的。像这种情况，请问您那边都是怎么去估算的呢。","like_count":0},{"had_liked":false,"id":219156,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1589956956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589956956","product_id":100051201,"comment_content":"多线程并行访问不同变量时，多线程可能会分配到不同的cpu，这些变量在内存布局是相邻的，所以这些变量会加载到多个CPU的同一缓存行。并行访问，根据缓存一致性协议会使缓存行失效，就得重新从内存中再次读取。解决方法 1.对其变量填充缓存行，2.老师说的将多线程绑定到同一cpu核心","like_count":0},{"had_liked":false,"id":218804,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1589878557,"is_pvip":true,"replies":[{"id":"81074","content":"希望能满载而归^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1590042495,"ip_address":"","comment_id":218804,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589878557","product_id":100051201,"comment_content":"触及知识盲区， 相见恨晚， 专栏早就订阅了，一直没来的及看， 第一篇就这么硬核，还好不算晚，nginx 100也是前段时间一起订阅的，必须得快点安排时间学习了。 又发现一枚宝藏老师。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495580,"discussion_content":"希望能满载而归^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590042495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217396,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1589478805,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589478805","product_id":100051201,"comment_content":"陶辉老师有一个疑问，缓存有三级，这个应该只在三级共享缓存中存在这个问题，这样理解对吗","like_count":0},{"had_liked":false,"id":217262,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1589450923,"is_pvip":false,"replies":[{"id":"80417","content":"与操作系统无关，与CPU相关。目前Intel、AMD等厂商的CPU都含有1、2级缓存","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1589498707,"ip_address":"","comment_id":217262,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1589450923","product_id":100051201,"comment_content":"看不太懂，每核都有一二级缓存吗，不管什么操作系统的电脑？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495093,"discussion_content":"与操作系统无关，与CPU相关。目前Intel、AMD等厂商的CPU都含有1、2级缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589498707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763395,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","nickname":"小童","note":"","ucode":"300444B520E79D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266881,"discussion_content":"了解一点了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589557846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217090,"user_name":"是小毛吖","can_delete":false,"product_type":"c1","uid":1363547,"ip_address":"","ucode":"B14B176DA1C989","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/5b/d7e523c2.jpg","comment_is_top":false,"comment_ctime":1589419219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589419219","product_id":100051201,"comment_content":"对于排序那个除了指令缓存，感觉也有排序算法原因。先排序的话数组基本无序，排序算法应该比基本有序时更好","like_count":0},{"had_liked":false,"id":217003,"user_name":"Geek_486b63","can_delete":false,"product_type":"c1","uid":1984458,"ip_address":"","ucode":"831C21A4E8B915","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKzGoQh5DC2g6EAKYBOiafHVKHibmzUMPZPdxCsIq429bHAylQa7Ds7iayrXOcQLRNRemdJuGVELsvXQ/132","comment_is_top":false,"comment_ctime":1589383664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589383664","product_id":100051201,"comment_content":"老师，有一个问题请教。线程与cpu绑定，调度是尽可能满足还是一定满足绑定。这方面除了源码，有没有一些文档资料","like_count":0},{"had_liked":false,"id":216872,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1589359363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589359363","product_id":100051201,"comment_content":"老师，实际开发中tlb miss考虑的多吗？ 还是重点考虑cache miss问题？","like_count":0},{"had_liked":false,"id":215745,"user_name":"RISE","can_delete":false,"product_type":"c1","uid":1201956,"ip_address":"","ucode":"00E99CCA142E83","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/24/909bb6ef.jpg","comment_is_top":false,"comment_ctime":1589094731,"is_pvip":false,"replies":[{"id":"90979","content":"yes!","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1599817339,"ip_address":"","comment_id":215745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589094731","product_id":100051201,"comment_content":"第一个问题：如果一个核心已经访问过某个变量并把相邻变量读入缓存中时，另外一个核心上的线程对涉及到的这些变量在内存中做了修改，那么前面读入的缓存会自动失效，其实也可以理解为CPU对内存数据的一致性进行维护的机制<br>第二个问题：可以通过手动填充padding的方式对这些元素进行隔断，让相邻元素不会被同时读入一个cache line中即可解决","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494541,"discussion_content":"yes!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599817339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215719,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1589083196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589083196","product_id":100051201,"comment_content":"再来看为什么执行时间相差 8 倍。在二维数组中，其实第一维元素存放的是地址，第二维存放的才是目标元素。由于 64 位操作系统的地址占用 8 个字节（32 位操作系统是 4 个字节），因此，每批 Cache Line 最多也就能载入不到 8 个二维数组元素，所以性能差距大约接近 8 倍。 <br>-----------<br>我的理解是，加载8个数组元素（如果一个元素是8字节）","like_count":0},{"had_liked":false,"id":215167,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1588919631,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588919631","product_id":100051201,"comment_content":"1.既然有MESI协议可以实现CPU缓存一致性，为什么JAVA还提出了volatile实现可见性？<br>2.既然volatile可以实现类似MESI协议的缓存一致，为什么还只是保证了可见性，而不能保证原子性？","like_count":0,"discussions":[{"author":{"id":1167468,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d0/6c/2e7dd298.jpg","nickname":"卓明","note":"","ucode":"6AB57EE1DF3CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278454,"discussion_content":"Mesi保证缓存数据在处理器之间的数据一致性，但是如果你的数据还没到缓存，比如写缓冲区 无效化队列等等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591188379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215064,"user_name":"唐朝首都","can_delete":false,"product_type":"c1","uid":1081233,"ip_address":"","ucode":"F72655AE0AE4CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/91/962eba1a.jpg","comment_is_top":false,"comment_ctime":1588899423,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588899423","product_id":100051201,"comment_content":"尝试分析如下：<br>比如：<br>volatile int a;<br>volatile int b;<br>（1）为什么会失效?<br>由于缓存行的原因，线程1访问变量a，线程2访问变量b，运行线程1的cpu会同时加载a，b，如果线程1变更变量a会使得a，b在内存中均实现，导致变量b在cpu缓存中失效，运行线程2的cpu需重新加载b。<br>（2）如何解决？<br>volatile int a,a1,a2,a3,a4,a5,a6,a7;<br>volatile int b;<br>这样运行线程1的cpu在加载变量a时就不会加载b了，这样a变更之后就不会影响b了，不会造成b的反复失效。","like_count":0},{"had_liked":false,"id":214994,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1588864801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588864801","product_id":100051201,"comment_content":"再来看为什么执行时间相差 8 倍。在二维数组中，其实第一维元素存放的是地址，第二维存放的才是目标元素。由于 64 位操作系统的地址占用 8 个字节（32 位操作系统是 4 个字节），因此，每批 Cache Line 最多也就能载入不到 8 个二维数组元素<br>--------------------------<br>老师，二维数组在内存中的大小应该是一维元素的地址大小+二维元素的大小吧。所以每个cache line应该远远不足8个元素吧","like_count":0},{"had_liked":false,"id":214904,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1588845804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588845804","product_id":100051201,"comment_content":"从代码优化，到系统优化。CPU的缓存命中率在看这个课之前就只是概念，没想到，也能用在实战中优化速度，感谢老师带来如此优秀的课程","like_count":0},{"had_liked":false,"id":214505,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1588759289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588759289","product_id":100051201,"comment_content":"前两个专栏还没看完，这次一定紧跟陶辉老师的脚步。","like_count":0},{"had_liked":false,"id":214309,"user_name":"边城路远","can_delete":false,"product_type":"c1","uid":1286741,"ip_address":"","ucode":"214ECD8981E87F","user_header":"https://static001.geekbang.org/account/avatar/00/13/a2/55/1092ebb8.jpg","comment_is_top":false,"comment_ctime":1588720385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588720385","product_id":100051201,"comment_content":"想跟陶老师再探讨一下cpu软绑定和硬绑定的区别，cpu硬绑定了就不能被抢占了吗，一般线上怎么用？","like_count":0},{"had_liked":false,"id":214250,"user_name":"董和平","can_delete":false,"product_type":"c1","uid":1763896,"ip_address":"","ucode":"725AF56B5D238F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ea/38/61c608fd.jpg","comment_is_top":false,"comment_ctime":1588684401,"is_pvip":false,"replies":[{"id":"79348","content":"你好阿Q，坚持下来完成网状知识的构建，收获会更大，加油！","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588725982,"ip_address":"","comment_id":214250,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1588684401","product_id":100051201,"comment_content":"老师你好，我是看极客时间的推荐购买的老师的课程，在这之前并不了解老师，但是今天一口气看了老师的序章和这一章，觉得受益匪浅！评论区各位同学也特别棒！真心是太开心了！古话说一日为师终身为父，真的特别感谢老师的分享，平时工作中对性能优化没有接触，有些时候这种经验是有钱也学不到的，真心感谢老师的分享！😃","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493999,"discussion_content":"你好阿Q，坚持下来完成网状知识的构建，收获会更大，加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588725982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763896,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ea/38/61c608fd.jpg","nickname":"董和平","note":"","ucode":"725AF56B5D238F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260649,"discussion_content":"是的，老师，肯定会坚持学习完的，老师那么尽心的教，我肯定会用心的学，不能枉负老师的成果呀，😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588873489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213573,"user_name":"Justin","can_delete":false,"product_type":"c1","uid":1613505,"ip_address":"","ucode":"FC6E2BD6EA0637","user_header":"https://static001.geekbang.org/account/avatar/00/18/9e/c1/ff754fa8.jpg","comment_is_top":false,"comment_ctime":1588480091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588480091","product_id":100051201,"comment_content":"老师，性能相差8倍那里不是很明白， 麻烦老师再详细讲一下， 64 位操作系统的地址占用 8 个字节，我的理解是如果二维数组元素越大，一次缓存读取个数越少，就不会提升8倍这么高了，而且还会与操作系统的位数有关，64位的比32位要提升多，不知道我的理解对不对","like_count":0},{"had_liked":false,"id":213493,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1588432492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588432492","product_id":100051201,"comment_content":"老师好，请教下，您的图上的一个核心，代表的是一个物理核心，其实，逻辑上是2个cpu，对吗？","like_count":0},{"had_liked":false,"id":213057,"user_name":"黄骏","can_delete":false,"product_type":"c1","uid":1849733,"ip_address":"","ucode":"3C41D02F4F712C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/39/85/c6110f83.jpg","comment_is_top":false,"comment_ctime":1588291281,"is_pvip":true,"replies":[{"id":"79103","content":"你好黄骏，这首思考题的答案是伪共享问题，你可以看下二星球的答案","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588326068,"ip_address":"","comment_id":213057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588291281","product_id":100051201,"comment_content":"一直觉得性能优化离自己很远。可这个确实是我们存储后台开发的核心技能。多线程缓存命中率低，是不是变量数据其实会复制一份，因为缓存大小有限，导致未命中？如果是共享变量，可能会高一些？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493679,"discussion_content":"你好黄骏，这首思考题的答案是伪共享问题，你可以看下二星球的答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588326068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212889,"user_name":"201200936","can_delete":false,"product_type":"c1","uid":1900820,"ip_address":"","ucode":"C933D99C13730D","user_header":"","comment_is_top":false,"comment_ctime":1588233071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588233071","product_id":100051201,"comment_content":"再来看为什么执行时间相差 8 倍。在二维数组中，其实第一维元素存放的是地址，第二维存放的才是目标元素。由于 64 位操作系统的地址占用 8 个字节（32 位操作系统是 4 个字节），因此，每批 Cache Line 最多也就能载入不到 8 个二维数组元素，所以性能差距大约接近 8 倍。<br>&gt;&gt;老师，您好！！！请问加载到cache里面的是地址（行地址）而不是具体的值，那么如果是一维数组的话，加载进cache里的是具体的值还是地址？","like_count":0},{"had_liked":false,"id":212817,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1588215128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588215128","product_id":100051201,"comment_content":"cache line 就是三级缓存吗?","like_count":0},{"had_liked":false,"id":212776,"user_name":"feitian","can_delete":false,"product_type":"c1","uid":1123623,"ip_address":"","ucode":"56167A8210F48F","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/27/5aef841d.jpg","comment_is_top":false,"comment_ctime":1588209536,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588209536","product_id":100051201,"comment_content":"如果仅仅只是读取一段连续的缓存数据而修改它，就不会出现缓存不一致的情况。多线程访问内存相邻的变量也不会出现缓存失效的情况。只有在某个值被修改了，缓存一致性才会生效，才会通知其他CPU缓存失效。","like_count":0},{"had_liked":false,"id":212756,"user_name":"了无痕","can_delete":false,"product_type":"c1","uid":1284279,"ip_address":"","ucode":"E066E72F0CB4B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/b7/2c725922.jpg","comment_is_top":false,"comment_ctime":1588207179,"is_pvip":false,"replies":[{"id":"79033","content":"你好了无痕，又在这门性能课见面啦，恭喜你已经从应用进入了Nginx源码的学习阶段！Nginx的单机性能优化已经到了极致，可以参考着学习这门课。","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588209737,"ip_address":"","comment_id":212756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588207179","product_id":100051201,"comment_content":"超级赞，之前看了nginx的源码，里面的这些知识都是这里查一点，那里看一点，现在有系统的梳理啦，回头重新温故知新下nginx源码。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493601,"discussion_content":"你好了无痕，又在这门性能课见面啦，恭喜你已经从应用进入了Nginx源码的学习阶段！Nginx的单机性能优化已经到了极致，可以参考着学习这门课。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588209737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212463,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1588128312,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588128312","product_id":100051201,"comment_content":"perf stat ls <br> &lt;not supported&gt;      cycles<br>   &lt;not supported&gt;      instructions<br>   &lt;not supported&gt;      branches<br>   &lt;not supported&gt;      branch-misses<br>这里提示  事件不支持啊 <br>CentOS Linux release 7.7.1908<br>perf version 3.10.0-1062.18.1.el7.x86_64.debug ","like_count":0},{"had_liked":false,"id":212443,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1588124779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588124779","product_id":100051201,"comment_content":"老师您好，我有两个问题：<br>1.怎么判断什么时候该使用cpu? 缓存优化呢？cache的miss率达到多少就认为应该优化了？<br>2.CPU从内存中加载数据，会影响CPU使用率吗？比如CPU cache的miss率是10%，是不是一定比miss率是40%的cpu使用率更高？(假设都是cpu密集型的，都没有额外的io操作)。<br>","like_count":0},{"had_liked":false,"id":212135,"user_name":"Persist","can_delete":false,"product_type":"c1","uid":1623575,"ip_address":"","ucode":"203596C835EAF2","user_header":"https://static001.geekbang.org/account/avatar/00/18/c6/17/651e8d72.jpg","comment_is_top":false,"comment_ctime":1588064751,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588064751","product_id":100051201,"comment_content":"这是因为在多处理器开发中为了保证共享变量的“可见性”。比如声明了volitate的变量，会向处理器发送一条Lock指令。Lock指令会将处理器缓存行中的数据刷回内存，并使其他cpu核心存储了该内存地址的缓存行失效。","like_count":0},{"had_liked":false,"id":212018,"user_name":"走马","can_delete":false,"product_type":"c1","uid":1251016,"ip_address":"","ucode":"EEFE8F7590FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/c8/980776fc.jpg","comment_is_top":false,"comment_ctime":1588046944,"is_pvip":false,"replies":[{"id":"78798","content":"你好走马，会的，不过目前二星球的答案已经非常准确啦","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588053749,"ip_address":"","comment_id":212018,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588046944","product_id":100051201,"comment_content":"老师，思考题您最后会给一个“官方”的答案吗？","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493412,"discussion_content":"你好走马，会的，不过目前二星球的答案已经非常准确啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588053749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211886,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1588035431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588035431","product_id":100051201,"comment_content":"回答完问题，从文章整体的角度又简单理解一下，有些疑惑:<br>1，关于cpu缓存这块儿老师重点剖析了一级缓存的数据缓存和指令缓存，简单来说呢，数据缓存的大体意思就是尽量访问同一块内存上数据；指令缓存呢就是尽量像cpu的分支预测上面靠。这两个点呢，感觉还是比较薄，要达到这种预期，实际情况下也需要注意一些基础的编程规范。当然可能是我理解的比较浅显哈！请问老师在一级缓存这块儿，还有什么大神级的骚操作吗？毕竟这篇专栏的题目是怎样写代码才……<br>2，关于cpu二级缓存,三级缓存的优化还会聊到吗？","like_count":0},{"had_liked":false,"id":211880,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1588034503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588034503","product_id":100051201,"comment_content":"这应该是涉及并发编程要解决的可见性问题吧，虽说被缓存了(还是相邻的)，但是为了保证可见性的话这种缓存也是不可用的。所以如果要保证并发安全也只能是按需禁用缓存了","like_count":0},{"had_liked":false,"id":211863,"user_name":"大飞哥","can_delete":false,"product_type":"c1","uid":1046810,"ip_address":"","ucode":"DEBAE3967CA0D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/1a/d289c2ac.jpg","comment_is_top":false,"comment_ctime":1588032794,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1588032794","product_id":100051201,"comment_content":"设置cpu亲和性的时候，如果不同线程处于不同CPU，而又有需要共享的变量，线程切换的时候会造成cache miss，重新加载，性能反而下降。","like_count":0,"discussions":[{"author":{"id":1046810,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f9/1a/d289c2ac.jpg","nickname":"大飞哥","note":"","ucode":"DEBAE3967CA0D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250858,"discussion_content":"我是说绑定到不同的CPU，如果有共享的变量反而会性能下降，而且设置了亲和性，其实是设置调度器的倾向，并不保证线程一定处于你绑定的CPU运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588045182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1983655,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/44/a7/11668a40.jpg","nickname":"不重要","note":"","ucode":"4E3EAABE68F956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250711,"discussion_content":"绑定cpu了，该线程应该不会被调度到其他核上了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588036572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211834,"user_name":"DY-杨","can_delete":false,"product_type":"c1","uid":1105546,"ip_address":"","ucode":"C84C0250F1A053","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/8a/8b4d7dbd.jpg","comment_is_top":false,"comment_ctime":1588028380,"is_pvip":false,"replies":[{"id":"78946","content":"你好DY-杨，推荐你看下长脖子树的答案，可以用Contended注解，或者通过其他对象隔开它们","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588144039,"ip_address":"","comment_id":211834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588028380","product_id":100051201,"comment_content":"老师好，看到第一篇文章让我受益匪浅，但我想咨询个问题，1、缓存行填充时，对于我们写的Java类是如何填充的，比如类中有double，long和object等类型。2、缓存行填充与Java中方法有关吗。3、方法中定义或使用的变量，常量和引用也会填到缓存行中吗。谢谢老师","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493376,"discussion_content":"你好DY-杨，推荐你看下长脖子树的答案，可以用Contended注解，或者通过其他对象隔开它们","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588144039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211808,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1588026396,"is_pvip":true,"replies":[{"id":"78947","content":"我不使用macbook，一直是windows和linux系统。能否给我看下你的测试代码？具体的硬件参数也给我看下。我的邮箱是russelltao@foxmail.com","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588144129,"ip_address":"","comment_id":211808,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588026396","product_id":100051201,"comment_content":"老师，为啥我的机器上，二维数组N设置10000，则两种速度相差30倍（array[i][j]大约40ms，而array[j][i]大约是1100ms）。我的机子是macbookpro 2019，查了下cachelinesize也是64byte","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493375,"discussion_content":"我不使用macbook，一直是windows和linux系统。能否给我看下你的测试代码？具体的硬件参数也给我看下。我的邮箱是russelltao@foxmail.com","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588144129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211793,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1588007349,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588007349","product_id":100051201,"comment_content":"看了disruptor的源码，是在数据前后填充，满足64的倍数，从而填充缓存行，这样，就不会是其他的数据失效了，消除伪共享。","like_count":0},{"had_liked":false,"id":211778,"user_name":"赖阿甘","can_delete":false,"product_type":"c1","uid":1351988,"ip_address":"","ucode":"77493FE85CBAF8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICBNZjA9hW65x6g9b2iaicKUJW5gxFxtgPXH9Cqp6eyFfY1sD2hVY4dZrY5pmoK2r1KZEiaaIKocdZQ/132","comment_is_top":false,"comment_ctime":1588003455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588003455","product_id":100051201,"comment_content":"此时内存是跳跃访问的，如果 N 的数值很大，那么操作 array[j][i]时，是没有办法把 array[j][i+1]也读入缓存的。<br>----------------------------------------------------------------------------------------------","like_count":0},{"had_liked":false,"id":211777,"user_name":"郭郭","can_delete":false,"product_type":"c1","uid":1517814,"ip_address":"","ucode":"E358C980AB9555","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/f6/7fa61d68.jpg","comment_is_top":false,"comment_ctime":1588003370,"is_pvip":false,"replies":[{"id":"78743","content":"对的，填充法很好使，可以看下二星球的留言","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588041551,"ip_address":"","comment_id":211777,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588003370","product_id":100051201,"comment_content":"这个应该会涉及到缓层一致性的问题，我的解决办法就是使用不同cache line分别处理不同变量。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493361,"discussion_content":"对的，填充法很好使，可以看下二星球的留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588041551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211764,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1588002059,"is_pvip":false,"replies":[{"id":"78709","content":"我和编辑小姐姐都是在石墨上共享编辑的，所以不是以互传稿件方式协作的，没有原稿哈。而且，这是我的第1个文字专栏的第1篇，当时是把它当成写《深入理解Nginx》这本书时的写作逻辑来写的，篇幅长但完全不适合现在的碎片化屏读时代^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588037865,"ip_address":"","comment_id":211764,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588002059","product_id":100051201,"comment_content":"老师，你没有删除的原稿能发下不，想看看更细的讲解，别怕我们看不懂啊","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493358,"discussion_content":"我和编辑小姐姐都是在石墨上共享编辑的，所以不是以互传稿件方式协作的，没有原稿哈。而且，这是我的第1个文字专栏的第1篇，当时是把它当成写《深入理解Nginx》这本书时的写作逻辑来写的，篇幅长但完全不适合现在的碎片化屏读时代^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588037865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211753,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1588001150,"is_pvip":false,"replies":[{"id":"78706","content":"希望这门课的每一讲都能在你的aoe大招库里添个新成员^_^<br>CPU分支预测器也在一直进化呢，现在的分支预测器就比10年前要准确的多。<br>","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588036895,"ip_address":"","comment_id":211753,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588001150","product_id":100051201,"comment_content":"今天知道了“CPU 分支预测器”，感觉好厉害。好比游戏里，准备放大招，增加了预判功能，提升杀伤力。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493355,"discussion_content":"希望这门课的每一讲都能在你的aoe大招库里添个新成员^_^\nCPU分支预测器也在一直进化呢，现在的分支预测器就比10年前要准确的多。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588036895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211736,"user_name":"奥特曼","can_delete":false,"product_type":"c1","uid":1766145,"ip_address":"","ucode":"76BAC701319542","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f3/01/5a1416bc.jpg","comment_is_top":false,"comment_ctime":1587999916,"is_pvip":false,"replies":[{"id":"78741","content":"你好奥特曼，前2门课中常看到你的精品留言哈。<br>1、完全正确，批量读取导致缓存命中率提升。<br>2、理论上可以。这个真实场景能描述下吗？好奇^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1588041192,"ip_address":"","comment_id":211736,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1587999916","product_id":100051201,"comment_content":"老师好。我有2个问题：<br>-------------------问题1----------------------<br>我在数据缓存命中率这有个地方没看懂。<br>DRAM的特性就是访问时间和位置无关。讲义中N=2时，array[j][i]，array[i][j]。分别都是都是对同一块内存做4次访问，只是array[j][i]是间隔为1为跳跃访问，就因为跳跃访问就存在时间差，这个和DRAM的特性是悖论？<br><br>我在想这个时间差，是不是不是差在DRAM的读取上，而是差在从DRAM读取数据，再存到SRAM时，一个是批量操作(一次性完成)，一个是单次操作(4次完成)？如果真的是这样，那就是交互次数带来的时差。<br><br>-------------------问题2----------------------<br>讲义中的一句：“当载入 array[0][0]时，若它们占用的内存不足 64 字节，CPU 就会顺序地补足后续元素。”<br>如果一个数组a[64*2]，是coherency_line_size的2倍。访问：a[0]，a[64]，是需要读2次数据缓存才达到访问这个下标吗？<br>如果是这样，能通过，再起一个数组b[64*2]，b[0]=a[0]，b[1]=a[64]；再访问b[0]，b[1]来达到数据访问加速吗？(忽略中间复制的操作时间)","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493348,"discussion_content":"你好奥特曼，前2门课中常看到你的精品留言哈。\n1、完全正确，批量读取导致缓存命中率提升。\n2、理论上可以。这个真实场景能描述下吗？好奇^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588041192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1766145,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/f3/01/5a1416bc.jpg","nickname":"奥特曼","note":"","ucode":"76BAC701319542","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250993,"discussion_content":"回复老师问题2的回答：其实没有真实场景。我就是想经常使用hash table，而hash里面的下标基本上不可能是连续的，那如果我从hash里面取出value，再顺序的放到一段内存，达到时间/空间的上限再去处理，理论要应该要比一个一个的去处理value要快，就需要一定业务延迟时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588056759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211574,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1587985371,"is_pvip":false,"replies":[{"id":"78663","content":"谢谢大俊，^_^","user_name":"作者回复","user_name_real":"陶辉","uid":"1283912","ctime":1587996194,"ip_address":"","comment_id":211574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587985371","product_id":100051201,"comment_content":"最喜欢看陶老师的课了。","like_count":0,"discussions":[{"author":{"id":1283912,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/48/550271b0.jpg","nickname":"陶辉","note":"","ucode":"F81A9087435953","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493304,"discussion_content":"谢谢大俊，^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587996194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}