{"id":472516,"title":"17 | 模块系统：为什么Java需要模块化？","content":"<p>你好，我是范学雷。今天，我们一起来讨论Java平台模块系统（Java Platform Module System，JPMS）。</p><p>Java平台模块系统是在JDK 9正式发布的。为了沟通起来方便，我们有时候就直接简称为Java模块。Java平台模块系统，可以说是自Java诞生以来最重要的新软件工程技术了。模块化可以帮助各级开发人员在构建、维护和演进软件系统时提高工作效率。软件系统规模越大，我们越需要这样的工程技术。</p><p>实现Java平台的模块化是具有挑战性的，Java模块系统（Module System）的最初设想可以追溯到2005年的Java 7，但是最后的发布，是在2017年的  JDK 9。它的设计和实现，花了十多年时间，我们可以想象它的复杂性。</p><p>令人满意的是，Java平台模块系统最终呈现的结果是简单、直观的。我们并不需要太长的时间，就能快速掌握这一技术。</p><p>我们先来了解Java模块化背后的动力，和它能够带来的工程效率提升。除非特别说明，这一次的讨论，说的都是JDK 8及以前的版本的事情。下一次，我们再来讨论JDK 9之后，我们应该怎么使用Java平台模块系统。</p><h2>缺失的访问控制</h2><p>我们都清楚并且能够熟练地使用Java的访问修饰符。这样的访问修饰符一共有三个：public、protected，以及private。如果什么修饰符都不使用，那就是缺省的访问修饰符，这也算是一种访问控制。所以，Java语言一共定义了四种类型的访问控制。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/b6/95/b64cbe2ee5f5b264849dfe0908dc1e95.jpg?wh=1920x1062\" alt=\"图片\"></p><p>private访问修饰符修饰的对象，在同一个类里是可见的；缺省访问修饰符修饰的对象，在同一个Java包里是可见的；pubic访问修饰符修饰的对象，在不同的Java包里也是可见的。有了private、public和缺省的访问修饰符，看起来我们已经能解决大部分的问题了。不过这里还欠缺了重要的一环。</p><p>当我们设计对象的扩展能力的时候，我们可能期待扩展的子类处于不同的Java包里。但是，其中的一些数据信息，子类需要访问，但又因为它们是接口实现的细节，不应该对外公开。所以这时候，就需要一个能够穿越Java包，传递到子类的访问修饰符。这个访问修饰符就是protected。protected访问修饰符，在Java包之间打通了一条继承类之间的私密通道。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/de/2b0fbb9b8af00927bed57b5f340986de.jpg?wh=1920x1077\" alt=\"图片\"></p><p>我们可以用下面这张表来总结Java语言访问修饰符的控制区域。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/a5/45b0872081465e8d62d6d828a05f8ca5.jpg?wh=1920x921\" alt=\"图片\"></p><p>从这个列表看，Java语言访问修饰符似乎覆盖了所有的可能性，这好像是一个完备的定义。遗憾的是，Java语言访问修饰符遗漏了很重要的一种情况，那就是Java包之间的关系。Java包之间的关系，并不是要么全开放，要么全封闭这么简单。</p><p>类似于继承类之间的私密通道，Java包之间也有这种类似私密通道的需求。比如说，我们在JDK的标准类库里，可以看到像java.net这样的放置公开接口的包，也可以看到像sun.net这样的放置实现代码的包。</p><p>公开接口，当然需要定义能够广泛使用的类，比如public修饰的Socket类。</p><pre><code class=\"language-plain\">package java.net;\n\npublic class Socket implements java.io.Closeable {\n    // snipped\n}\n</code></pre><p>让人遗憾的是，放置公开接口实现代码的包里，也需要定义public的类。这就让本来只应该由某个公开接口独立使用的代码变得所有人都可以使用了。</p><p>比如说，用来实现公开接口Socket类的PlatformSocketImpl类，就是一个使用public修饰的类。</p><pre><code class=\"language-plain\">package sun.net;\n\npublic interface PlatformSocketImpl {\n    // snipped\n}\n</code></pre><p>虽然PlatformSocketImpl是一个public修饰的类，但是我们并不期望所有的开发者都能够使用它。这是一个用来支持公开接口Socket实现的类。除了实现公开接口Socket的代码之外，它不应该被任何其他的代码和开发者调用。</p><p>然而，PlatformSocketImpl是一个public修饰的类。这也就意味着任何代码和开发者都可以使用它。这显然是不符合设计者的预期的。</p><p>在JDK 8及以前的版本里，一个对象在两个包之间的访问控制，要么是全封闭的，要么是全开放的。所以，JDK 9之前的Java世界里，它的设计者没有办法强制性地设定PlatformSocketImpl，给出一个恰当的访问控制范围。</p><p>两个包之间，没有一个定向的私密通道。换句话说，JDK 9之前的Java语言没有描述和定义包之间的依赖关系，也没有描述和定义基于<strong>包的依赖关系</strong>的访问控制规则。 这是一个缺失的访问控制。</p><p>这种缺失的关系，带来了严重的后果。</p><h2>松散的使用合约</h2><p>按照JDK的期望，一个开发者应该只使用公开接口（比如上面提到的Socket类），而不能使用实现细节的内部接口（比如上面提到的PlatformSocketImpl接口）。无论是公开接口，还是内部接口，都可以使用public修饰符。那么，该怎么判断一个接口是公开接口，还是内部接口呢？</p><p>解决的办法，是依靠Java接口的使用规范这样的纪律性合约，而不是依靠编译器强制性的检查。<strong>在JDK里，以java或者javax命名开头的Java包，是公开的接口；其他的包是内部的接口。按照Java接口的使用规范，一个开发者应该只使用公开的接口，而不能使用内部的接口。</strong>不过，这是一个完全依靠自觉的纪律性约束；Java的编译器和解释器，并不会禁止开发者使用内部接口。</p><p>内部接口的维护者可能会随时修改甚至删除内部的接口。使用内部接口的代码，它的兼容性是不受保护的。这是一个危险的依赖，应该被禁止。</p><p>遗憾的是，这种纪律性合约是松散的，它很难禁止开发者使用内部接口。我们能够看到大量的、没有遵守内部接口使用合约的应用程序。内部接口的不合规使用，也成了Java版本升级的重要障碍之一。松散的纪律性合约既伤害了内部接口的设计者，也伤害了它的使用者和最终用户。</p><p>我们前面提到过，Java平台模块化的设计和实现，花了十多年时间。而内部接口的不合规使用，就是这项工作复杂性的主要来源。</p><p>我们认为，<strong>如果一件事情应该禁止，那么最好的办法就是让这件事情没有办法发生；而不是警告发生以后的的后果，或者依靠事后的惩罚。</strong></p><p>那怎么能够更有效的限制内部接口的使用，提高Java语言的可维护能力呢？这是Java语言要解决的一个重要问题。</p><h2>手工的依赖管理</h2><p>Java语言没有描述和定义包之间的依赖关系，这就直接增加了应用程序部署的复杂性。</p><p>公开接口的定义和实现，并不一定是放置在同一个Java包。比如上面我们提到的Socket类和PlatformSocketImpl类就位于不同的Java包。</p><p>因为通常情况下，我们使用Jar文件来分发和部署Java应用，所以，公开接口的定义和实现，也不一定是放置在同一个Jar文件里。比如一个加密算法的实现，它的公开接口一般是由JDK定义的；但是它的实现，可能是由一个第三方的类库完成的。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/8e/2c17383bebd8ae2b5d928ce7d0548d8e.jpg?wh=1920x1090\" alt=\"图片\"></p><p>Java的编译器只需要知道公开接口的规范，并不会去检查实现的代码，也不会去链接实现的代码。可是，Java在运行时，不仅需要知道公开接口的字节码，还需要知道实现的字节码。这就导致了编译和运行的脱节。一个能通过编译的代码，运行时可能也会遇到找不到实现代码的错误。</p><p>而且，Java的编译器不会在字节码里添加类和包的依赖关系。我们在编译期设置的依赖类库，在运行期还需要重新设置。编译器环节和运行环节是由两个独立的Java命令执行的，所以这种依赖关系也不会从编译期传导到运行期。</p><p>由于依赖关系的缺失，Java运行的时候，可能不会完全按照它的设计者的意图工作。这就给Java应用的部署带来很多问题。这一类的问题如此让人讨厌，以至于它还有一个让人亲切不起来的外号，Jar地狱。</p><p>为了解决依赖关系的缺失带来的种种问题，业界现在也有了一些解决方案，比如使用Maven和Gradle来管理项目。然而，由于Java没有内在的依赖关系规范，现有的解决方案也就只能依赖人工。依赖人工的手段，也就意味着效率和质量上的潜在风险。</p><h2>缓慢的实现加载</h2><p>Java语言没有描述和定义包之间的依赖关系，还直接影响了Java应用程序的启动效率。</p><p>我们都知道像Spring这样的框架，它缓慢的启动一直都是一个大问题。影响Java应用启动速度的最主要原因，就是类的加载。导致类加载缓慢的一个重要原因，就是很难查找到要加载的类的实现代码。</p><p>假设我们设置的class path里有很多Jar文件，对于一个给定名称的class，Java怎么才能找到实现这个类的字节码呢？由于Jar文件里没有描述类的依赖关系的内容，Java的类加载器只能线性地搜索class path下的Jar文件，直到发现了给定的类和方法。这种线性搜索方法当然不是高效的。class path下的Jar文件越多，类加载得就越慢。</p><p>更糟糕的是，这种线性搜索的方式，还带来了不可预测的副作用。其中，影子类（Shadowing classes）和版本冲突是最常见的两个副作用。</p><p>因为在不同的Jar文件里，可能会存在两个有着相同命名，但是行为不同的类。给定了类的名称，哪一个Jar文件里的类会被首先加载呢？这依赖于Jar文件被检索的顺序。在不同的运行空间，class path的设置可能是不同的，Jar文件被检索的顺序可能也是不同的；所以，实际加载的类就有可能是不同的，最终的运行结果当然也是不同的。这样的问题，可能会导致难以预料的结果，而且非常难以排查。</p><p>如果一个类的不同版本的实现都出现在了 class path 里，也会出现类似的问题。</p><h2>新的思路</h2><p>我们可以看到，这些问题的根源，都来自于Java语言没有描述和定义包之间的依赖关系。那么，我们能不能通过扩展访问修饰符来解决这些问题呢？</p><p>答案可能没有这么简单。多个节点之间的依赖关系描述，需要使用的是数学逻辑图。而单个的修饰符，不足以表达复杂的图的逻辑。</p><p>另外，Jar文件虽然是Java语言的一种必不可少的代码组织方式，但是它却不是由我们编写的代码直接控制的。我们编写的代码，可以控制Java包，可以控制Java类，但是管不了Jar文件的内容和形式。</p><p>所以，要解决这些问题，需要新的思路。而JDK 9发布的Java平台模块系统，就是解决这些问题的一个尝试。</p><h2>总结</h2><p>好，到这里，我来做个小结。前面，我们讨论了JDK 8及其以前版本的访问控制缺陷，以及由此带来的种种问题。</p><p>总体来说，Java语言没有描述和定义包之间的依赖关系。这个缺失，导致了无法有效地封闭实现的细节；无法有效地管理应用的部署；无法精准地控制类的检索和加载，也影响了应用启动的效率。</p><p>那能不能在Java语言里添加进来这个缺失的关系呢？该怎么做？这是我们下一次要讨论的话题。</p><p>如果面试的时候，讨论到了Java的访问修饰符，你不妨聊一聊这个缺失的环节，以及Jar地狱这样的问题。我相信，这是一个有意思、有深度的话题。</p><h2>思考题</h2><p>在前面的讨论中，我们提到了使用Maven或者Gradle来管理项目，以此解决依赖关系的缺失。但是，我们并没有展开讨论这些问题是怎么解决的。</p><p>如果熟悉Maven、Gradle或者类似的工具的话，你能不能聊一聊，这样的工具，是怎么解决依赖关系缺失这样的问题的？它们哪些地方做得比较好，哪些地方还有待改进？这样的讨论，也许有助于我们深入了解我们这一次讨论到的问题。</p><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及你对Maven或者Gradle的了解。我们下节课见！</p>","neighbors":{"left":{"article_title":"16 | 改进的废弃，怎么避免使用废弃的特性？","id":470882},"right":{"article_title":"18 | 模块系统：怎么模块化你的应用程序？","id":473204}},"comments":[{"had_liked":false,"id":330474,"user_name":"第二少","can_delete":false,"product_type":"c1","uid":1004264,"ip_address":"","ucode":"4A09D1E7589F67","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","comment_is_top":false,"comment_ctime":1641989695,"is_pvip":true,"replies":[{"id":"120461","content":"学到新东西了，谢谢🙏。","user_name":"作者回复","comment_id":330474,"uid":"1111315","ip_address":"","utype":1,"ctime":1642017353,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"31706760767","product_id":100097301,"comment_content":"Maven、Gradle是怎么解决依赖关系缺失这样的问题的？<br><br>首先，这些工具都只能在jar包的粒度来解决依赖关系，而无法达到java package的粒度，当然你可以通过刻意的设计，比如一个jar包里只有一个package，来变相的达到java package级别，这些工具的打包方式也非常灵活，就算要一个jar包里只有一个package，也不需要在源码的组织上做到一个project只有一个package，源码仍然可以都放在一个project，打包时可以打多个jar包；<br><br>然后再来回答这个问题，maven的解决方案是：<br>1. 通过一个构建描述文件（pom.xml）来描述jar之间的依赖关系；<br>2. 通过给每个&lt;dependency&gt;定义&lt;scope&gt;来限制一个jar的作用域（是编译时可用，还是只在运行时可用，还是只有测试用例代码可用）；<br>3. 通过内建的一些原则（如“最短路径原则”）以及外部的可自定义的dependencyManagement来解决版本&#47;作用域冲突；<br>4. 通过各种打包插件来灵活打包jar<br><br>gradle的解决方案跟maven类似，不过gradle支持更灵活的构建描述文件，这正好也是maven的很大短板；gradle支持使用groovy和kotlin作为dsl来写构建描述文件，groovy和kotlin是完备的编程语言，其表达能力跟xml比那就强太多了，写起来也简洁太多；<br><br>不过这一点也是双刃剑，maven内建了“构建生命周期”，所有的构建过程都必需在这套生命周期的框架之内，即便你自己写一个maven plugin，也必须把你自定义的goal绑定到maven的生命周期上去，无法随意修改构建顺序、构建步骤，也就规范了构建描述文件的写法，不会出现一千个人有一千种写法；而gradle就没有强制遵守的生命周期，限制就放开了，加上用编程语言来写构建描述文件，能玩的花活就多了，只要你愿意，你可以在构建描述文件里编程实现复杂的自定义构建流程，这在maven里通常需要用java写一个maven plugin来实现（甚至都未必能实现，因为maven有生命周期需要强制遵守）","like_count":7,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545651,"discussion_content":"学到新东西了，谢谢🙏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642017353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328306,"user_name":"娄江国","can_delete":false,"product_type":"c1","uid":1018479,"ip_address":"","ucode":"6C2AAE4E409286","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/6f/3d4f7e31.jpg","comment_is_top":false,"comment_ctime":1640660159,"is_pvip":false,"replies":[{"id":"119594","content":"谢谢分享！","user_name":"作者回复","comment_id":328306,"uid":"1111315","ip_address":"","utype":1,"ctime":1640727840,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"5935627455","product_id":100097301,"comment_content":"通过Maven管理依赖，会存在依赖传递导致的版本冲突问题。<br>如：<br>1、我的工程为ProjectMain，依赖了ProjectA和ProjectB；<br>2、ProjectA依赖了ProjectC，依赖的ProjectC的版本为1.0；<br>3、ProjectB依赖了ProjectC，依赖的ProjectC的版本为2.0；<br>4、启动ProjectMain时，只会加载1版本的个ProjectC。<br>可能会出现下面问题（假如加载的是ProjectC的1.0版本）：<br>1、如果ProjectB调用了ProjectC的2.0版本中的新增方法，则运行时会抛出NoSuchMethodError的异常；<br>2、如果ProjectB调用的ProjectC的2.0版本中的方法签名，在ProjectC的1.0版本中都有，但内部实现做了修改，这样实际执行时，还是按ProjectC的1.0版本的逻辑执行，不符合ProjectB的目的。","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542331,"discussion_content":"谢谢分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640727840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004264,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/e8/92a2e66d.jpg","nickname":"第二少","note":"","ucode":"4A09D1E7589F67","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545529,"discussion_content":"这种情形，根据“最短路径”原则，ProjectMain最终依赖的一定是ProjectC-1.0；\n可以通过 mvn dependency:tree 看到最终maven自动解决版本冲突（最短路径原则）后的结果，如果希望ProjectMain最终依赖ProjectC-2.0，可以在ProjectMain的pom里用&lt;dependencyManagement&gt;来强制ProjectC的版本为2.0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641986859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359669,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1665738935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665738935","product_id":100097301,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":328946,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1640947871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640947871","product_id":100097301,"comment_content":"先回答问题<br><br>其实现在都有工具，所以包冲突这个事比以前好排太多了。但是依旧需要人工，只要没有自动化，就依旧会有效率问题和风险。<br><br>这篇开头我就有个痛点，虽然增加包维度控制的解决方案能解我的痛点，但看样子并不能很快支持。<br><br>我的痛点是，包范围的访问权限缺少对子包的访问权限。这就导致我要么摊平，所有类都放在这个包目录下；要么就都只能用开放的访问权限。这对于有点洁癖想要分包结构整理类的我实在是种折磨。 类权限的发散也是项目腐化的源头，放现在看，能不能说他是个bug？<br><br>这个痛点我觉得其实不难解，如果不用增加包维度访问控制这个解决方案的话。 那么临时方案可不可以？定义好修饰符实现对于使用方又无感，后面长期方案上了，完全可以平滑过度。<br><br>","like_count":0},{"had_liked":false,"id":328118,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1640560831,"is_pvip":false,"replies":[{"id":"119481","content":"是的，还是需要考虑兼用性的问题。","user_name":"作者回复","comment_id":328118,"uid":"1111315","ip_address":"","utype":1,"ctime":1640577266,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1640560831","product_id":100097301,"comment_content":"另外，JDK9之后模块化这种并不是强制的，可以通过添加VM参数放开限制(--illegal-access=permit)。<br><br>例如： 放开之后，在运行时可以通过反射修改String类的value数组，达到动态修改String值的目的。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541833,"discussion_content":"是的，还是需要考虑兼用性的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640577266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328117,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1640560547,"is_pvip":false,"replies":[{"id":"119480","content":"谢谢经验分享！","user_name":"作者回复","comment_id":328117,"uid":"1111315","ip_address":"","utype":1,"ctime":1640577206,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1640560547","product_id":100097301,"comment_content":"平常用Maven，在集中管理方面做的很好。比如找一个库，只需要在Maven仓库中搜索，并添加XML配置到项目即可。在依赖加载方面也有很多镜像可以使用。<br><br>不足的是，不同依赖的不同版本可能会导致一些未知的问题。而Spring Boot Starts刚好就解决了这个问题。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541832,"discussion_content":"谢谢经验分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640577206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","nickname":"听雨","note":"","ucode":"252754F9FCFF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542073,"discussion_content":"springboot比较扯的是，有相同版本的starter依赖的第三方类库版本不一致，只能说差强人意吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640658591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}