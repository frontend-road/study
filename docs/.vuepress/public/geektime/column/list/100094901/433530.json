{"id":433530,"title":"04 | 深入理解栈：从CPU和函数的视角看栈的管理","content":"<p>你好，我是海纳。</p><p>上节课，我们讲到，栈被操作系统安排在进程的高地址处，它是向下增长的。但这只是对栈相关知识的“浅尝辄止”。那我们今天这节课，就会跟着前面的脉络，让你可以更深刻地理解栈的运行原理。</p><p>栈是每一个程序员都很熟悉的话题，但你敢说你真的完全了解它吗？我相信，你在工作中肯定遇到过栈溢出（StackOverflow）的错误，比如在写递归函数的时候，当漏掉退出条件，或者退出条件不小心写错了，就会出现栈溢出错误。我们也经常听说缓冲区溢出带来的严重的安全问题，这在日常的工作中都是要避免的。</p><p>所以，今天这节课，我们继续深入探讨一下栈这个话题，我会带你基于“符合人的直观思维”，也就是函数的层面和CPU的机器指令层面，多角度来理解栈相关的概念。这样，你以后遇到与栈相关的问题的时候，才知道如何着手进行排查。最后，我们还会通过一个缓冲区溢出攻击栈的案例，看看我们在日常工作中如何提升代码的健壮度和安全性。</p><h2>函数与栈帧</h2><p>当我们在调用一个函数的时候，CPU会在栈空间（这当然是线性空间的一部分）里开辟一小块区域，这个函数的局部变量都在这一小块区域里存活。当函数调用结束的时候，这一小块区域里的局部变量就会被回收。</p><p>这一小块区域很像一个框子，所以大家就命名它为stack frame。frame本意是框子的意思，在翻译的时候被译为帧，现在它的中文名字就是栈帧了。</p><!-- [[[read_end]]] --><p>所以，我们可以说，<strong>栈帧本质上是一个函数的活动记录。</strong>当某个函数正在执行时，它的活动记录就会存在，当函数执行结束时，活动记录也被销毁。</p><p>不过，你要注意的是，在一个函数执行的时候，它可以调用其他函数，这个时候它的栈帧还是存在的。例如，A函数调用B函数，此时A的栈帧不会被销毁，而是会在A栈帧的下方，再去创建B函数的栈帧。只有当B函数执行完了，B的栈帧也被销毁了，CPU才会回到A的栈帧里继续执行。</p><p>我们举个例子说明一下，就很好理解了。你可以看一下这个代码：</p><pre><code>#include &lt;stdio.h&gt;\n\nvoid swap(int a, int b) {\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid main() {\n    int a = 2;\n    int b = 3;\n    swap(a, b);\n    printf(&quot;a is %d, b is %d\\n&quot;, a, b);\n}\n</code></pre><p>你可以看到，在swap函数中，a和b的值做了一次交换，但是在main函数里，打印a和b的值，a还是2，b还是3。这是为什么呢？从栈帧的角度，这个问题就非常容易理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/3a/68/3a1d6eed77df6233ef0b527c37d34f68.jpg?wh=2284x946\" alt=\"\"></p><p>在main函数执行的时候，main的栈帧里存在变量a和b。当main在调用swap方法的时候，会在main的帧下面新建swap的栈帧。swap的帧里也有局部变量a和b，但是明显这个a、b与main函数里的a、b没有任何关系，不管对swap的帧里的a/b变量做任何操作都不会影响main函数的栈帧。</p><p>接下来，我们再通过一个递归的例子来加深对栈的理解。由于递归执行的过程会出现函数自己调用自己的情况，也就是说，一个函数会对应多个同时活跃的记录（即栈帧）。所以，理解了递归函数的执行过程，我们就能更加深刻地理解栈帧与函数的关系。</p><h2>当我们在谈递归时，我们在谈什么</h2><p>我们先看一下最经典的递归问题：<strong>汉诺塔</strong>。汉诺塔问题是这样描述的：有三根柱子，记为A、B、C，其中A柱子上有n个盘子，从上到下的编号依次为1到n，且上面的盘子一定比下面的盘子小。要求一次只能移动一只盘子，且大的盘子不能压在小的盘子上，那么将所有盘子从A移到C总共需要多少步？</p><p>这道题的详细分析过程是一种递归推导的过程，不是我们这节课的重点，如果你对解法感兴趣的话，可以自己查找相关资料。我们这里，重点来讲解递归程序执行的过程中，栈是怎么样变化的，这样可以帮助我们理解栈的基本工作原理。</p><p>你先看一下汉诺塔问题的求解程序：</p><pre><code>#include &lt;stdio.h&gt;\n\nvoid move(char src, char dst, int n) {\n    printf(&quot;move plate %d form %c to %c\\n&quot;, n, src, dst);\n}\n\nvoid hanoi(char src, char dst, char aux, int n) {\n    if (n == 1) {\n        move(src, dst, 1);\n        return;\n    }\n\n    hanoi(src, aux, dst, n-1);\n    move(src, dst, n);\n    hanoi(aux, dst, src, n-1);\n}\n\nint main() {\n    hanoi('A', 'C', 'B', 5);\n}\n</code></pre><p>这段代码可以打印出借由B柱子将5个盘子从A搬移到C的所有步骤。这个的核心是hanoi函数，在深入分析代码的执行过程之前，我们可以先从符合直观思维的角度尝试理解hanoi函数。</p><p>hanoi函数有四个参数。第一个src代表要搬的起始柱子（开始时是A），第二个代表目标柱子（开始时是C），第三个代表可以借用的中间的那个柱子（开始时是B），第四个参数代表一共要搬的盘子总数（开始时是5）。</p><p>代码的第13行的意义是，如果要从A搬5个盘子到C，可以先将4个盘子搬到B上，然后第14行代表将第5个盘子从A搬到C，第15行代表把B上面的4个盘子搬到C上去。第8行的判断是说当只搬一个盘子的时候，就可以直接调用move方法。</p><p>以上就是递归程序的设计思路。下面我们再具体分析这个代码的执行过程。为了简便起见，我们选择n=3进行分析。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/4b/c252544e2dcf7fb2049b7dc32009a34b.jpg?wh=2284x1471\" alt=\"\"></p><p>可以看到，当程序在执行hanoi(A, C, B, 3)时，CPU会为其创建一个栈帧，这一帧里记录着变量src、dst、aux和n。</p><p>此时n为3，所以，代码可以执行到第13行，然后就会调用执行hanoi(A, B, C, 2)。这代表着将2个盘子从A搬到B，同样CPU也会为这次调用创建一个栈帧；当这一次调用执行到第13行时，会再调用执行hanoi(A, C, B, 1)，代表把一个盘子从A搬到C。不过，由于这一次调用n为1，所以会直接调用move函数，打印第一个步骤“把盘子1从A搬到C”。</p><p>接下来，程序就会回到hanoi(A, B, C, 2)的栈帧，继续执行第14行，打印第二个步骤”把盘子2从A搬到B”。然后再执行第15行，也就是执行hanoi(C, B, A, 1)。这一步的栈帧变化，你可以看下面这张图。</p><p><img src=\"https://static001.geekbang.org/resource/image/51/72/515de73500c959923c737274a1d67572.jpg?wh=2284x1378\" alt=\"\"></p><p>我们看到，在调用hanoi(C, B, A, 1)的时候，由于n等于1，所以就会打印第三个步骤“把盘子1从C搬到B”，此时hanoi(C, B, A, 1)就执行完了。</p><p>那么接下来，程序就退回到hanoi(A, B, C, 2)的第15行的下一行继续执行，也就是函数的结束，这就意味着hanoi(A, B, C, 2)也执行完了。这个时候，程序就会回退到最高的一层hanoi(A, C, B, 3)的第14行继续执行。这一次就打印了第四个步骤“把盘子3从A搬到C”，此时的栈帧如上图(b)所示。</p><p>然后，程序会执行第15行，再次进入递归调用，创建hanoi(B, C, A, 2)的栈帧。当它执行到第13行时，就会再创建hanoi(B, A, C, 1)的栈帧，此时栈的结构如上图（c）所示。由于n等于1，这一次调用就会打印第五个步骤“把盘子1从B搬到A”。</p><p>再接着就开始退栈了，回到hanoi(B, C, A, 2)的栈帧，继续执行第14行，打印第六个步骤“把盘子2从B搬到C”。然后执行第15行，也就是hanoi(A, C, B, 1)，此时n等于1，直接打印第七个步骤“把盘子1从A搬到C”。接下来就执行退栈，这一次每一个栈帧都执行到了最后一行，所以会一直退到main函数的栈帧中去。退栈的过程比较简单，你自己思考一下就好了。</p><p>这样我们就完成了一次汉诺塔的求解过程。在这个过程中呢，我们观察到，<strong>先创建的帧最后才销毁，后创建的帧最先被销毁</strong>，这就是<strong>先入后出</strong>的规律，也是程序执行时的活跃记录要被叫做栈的原因。</p><p>那么在这里呢，我还想让你做一个小练习。我想让你试着用我们上面分析栈变化的方法，来分析使用深度优先算法打印全排列的程序，这会让你更加深入地理解栈的运行规律，同时掌握深度优先算法的递归写法。</p><pre><code>res = []\n\ndef make(n, level):\n    if n == level:\n        print(res)\n        return\n        \n    for i in range(1, n+1):\n        if i not in res:\n            res.append(i)\n            make(n, level+1)\n            res.pop()\n            \nmake(3, 0)\n</code></pre><h2>从指令的角度理解栈</h2><p>好了，前面递归的例子，是从人的直观思维的角度去理解栈，但是在CPU层面，机器指令又是怎样去理解栈的呢？我们还是通过一个例子来考察一下：</p><pre><code>int fac(int n) {\n    return n == 1 ? 1 : n * fac(n-1);\n}\n</code></pre><p>这是一个使用递归的写法求阶乘的例子，源码是比较简单的，我们可以使用gcc对其进行编译，然后使用objdump对其反编译，观察它编译后的机器码。</p><pre><code># gcc -o fac fac.c\n# objdump -d fac\n</code></pre><p>然后你可以得到以下输出：</p><pre><code>  40052d:       55                      push   %rbp\n  40052e:       48 89 e5                mov    %rsp,%rbp\n  400531:       48 83 ec 10             sub    $0x10,%rsp\n  400535:       89 7d fc                mov    %edi,-0x4(%rbp)\n  400538:       83 7d fc 01             cmpl   $0x1,-0x4(%rbp)\n  40053c:       74 13                   je     400551 &lt;fac+0x24&gt;\n  40053e:       8b 45 fc                mov    -0x4(%rbp),%eax\n  400541:       83 e8 01                sub    $0x1,%eax\n  400544:       89 c7                   mov    %eax,%edi\n  400546:       e8 e2 ff ff ff          callq  40052d &lt;fac&gt;\n  40054b:       0f af 45 fc             imul   -0x4(%rbp),%eax\n  40054f:       eb 05                   jmp    400556 &lt;fac+0x29&gt;\n  400551:       b8 01 00 00 00          mov    $0x1,%eax\n  400556:       c9                      leaveq\n  400557:       c3                      retq\n</code></pre><p>我们来分析一下这段汇编代码。</p><p>第1行是将当前栈基址指针存到栈顶，第2行是把栈指针保存到栈基址寄存器，这两行的作用是把当前函数的栈帧创建在调用者的栈帧之下。保存调用者的栈基址是为了在return时可以恢复这个寄存器。</p><p>第3行的作用呢，是把栈向下增长0x10，这是为了给局部变量预留空间。从这里，你可以看出来运行fac函数要是消耗栈空间的。</p><p>试想一下，如果我们不加n==1的判断，那么fac函数将无法正常返回，会出现一直递归调用回不来的情况，这样栈上就会出现很多fac的帧栈，会造成栈空间耗尽，出现StackOverflow。这里的原理是，操作系统会在栈空间的尾部设置一个禁止读写的页，一旦栈增长到尾部，操作系统就可以通过中断探知程序在访问栈末端。</p><p>第4行是把变量n存到栈上。其中变量n一开始是存储在寄存器edi中的，存储的目标地址是栈基址加上0x4的位置，也就是这个函数栈帧的第一个局部变量的位置。变量n在寄存器edi中是X86的ABI决定的，第一个整型参数一定要使用edi来传递。</p><p>第5行将变量n与常量0x1进行比较。在第6行，如果比较的结果是相等的，那么程序就会跳转到0x400551位置继续执行。我们看到，在这块代码里，0x400551是第13行，它把0x1送到寄存器eax中，然后返回，就是说当n==1时，返回值为1。</p><p>如果第5行的比较结果是不相等的，又会怎么办呢？那第6行就不会跳转，而是继续执行第7行。7、8、9这三行的作用，就是把n-1送到edi寄存器中，也就是说以n-1为参数调用fac函数。这个时候，调用的返回值在eax中，第11行会把返回值与变量n相乘，结果仍然存储在eax中。然后程序就可以跳转到0x400556处结束这次调用。</p><p>理解了fac函数的汇编指令以后，我们再重点讨论callq指令。</p><p>执行callq指令时，CPU会把rip寄存器中的内容，也就是call的下一条指令的地址放到栈上（在这个例子中就是0x40054b），然后跳转到目标函数处执行。当目标函数执行完成后，会执行ret指令，这个指令会从栈上找到刚才存的那条指令，然后继续恢复执行。</p><p>栈空间中的rbp、rsp，以及返回时所用的指令都是非常敏感的数据，一旦被破坏就会造成不可估量的损失。</p><p>不过，你在重现这个例子一定要注意，我们使用不同的优化等级，产生的汇编代码也是不同的。比如如果你用以下命令进行编译，得到的二进制文件中将不再使用rbp寄存器。</p><pre><code># gcc -O1 -o fac fac.c\n</code></pre><p>至于这个结果，我这里就不再展示了，我想让你自己动手试一下，然后在留言区和我们分享。</p><p>到这里，我们已经从人的大脑的理解角度和机器指令的角度，让你加深了对栈和栈帧的理解。现在，我们就从理论转向实操，举一个通过缓冲区溢出来破坏栈的例子。通过这个例子，你就知道在平时的工作中，应该如何避免写出被黑客攻击的不安全代码。</p><h2>栈溢出</h2><p>下面这个测试是我精心构造的例子。因为是演示用的，所以我就把各种无关的代码去掉了，只保留了关键路径上的代码。你先看一下代码：</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define BUFFER_LEN 24\n\nvoid bad() {\n    printf(&quot;Haha, I am hacked.\\n&quot;);\n    exit(1);\n}\n\nvoid copy(char* dst, char* src, int n) {\n    int i;\n    for (i = 0; i &lt; n; i++) {\n        dst[i] = src[i];\n    }\n}\n\nvoid test(char* t, int n) {\n    char s[16];\n    copy(s, t, n);\n}\n\nint main() {\n    char t[BUFFER_LEN] = {\n        'w', 'o', 'l', 'd',\n        'a', 'b', 'a', 'b', 'a', 'b',\n        'a', 'b', 'a', 'b', 'a', 'b',\n    };\n    int n = BUFFER_LEN - 8;\n    int i = 0;\n    for (; i &lt; 8; i++) {\n        t[n+i] = (char)((((long)(&amp;bad)) &gt;&gt; (i*8)) &amp; 0xff);\n    }\n\n    test(t, BUFFER_LEN);\n    printf(&quot;hello\\n&quot;);\n}\n</code></pre><p>你可以用gcc编译器来编译上面这个程序：</p><pre><code>gcc -O1 -o bad bad.c -g -fno-stack-protector\n</code></pre><p>执行它，你可以看到，虽然在main函数里我们并没有调用bad函数，但它却执行了。最后运行结果是“Haha, I am hacked”。</p><p><strong>我们首先来分析一下，这个程序为什么会有这样的运行结果。</strong></p><p>当我们在调用test函数的时候，会把返回地址，也就是rip寄存器中的值，放到栈上，然后就进入了test的栈帧，CPU接着就开始执行test函数了。</p><p>test函数在执行时，会先在自己的栈帧里创建数组s，数组s的长度是16。此时，栈上的布局是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/97/e394bda6b98b8306c15e5a39c6d72897.jpg?wh=2284x985\" alt=\"\"></p><p>通过计算，我们可以知道返回地址是变量s的地址 + 16的地方，<strong>这就是我们要攻击的目标</strong>。我们只要在这个地方把原来的地址替换为函数bad的入口地址（第26至34行所做的事情），就可以改变程序的执行顺序，实现了一次<strong>缓冲区溢出</strong>。</p><p>简单地说，数组s的长度是16，理论上我们只能修改以s的地址开始、长度为16的数据。但是我们现在通过copy函数操作了大于16的数据，从而破坏了栈上的关键数据。也就是说我们针对函数调用的返回地址发起了一次攻击。所以，test函数的实现是不安全的。</p><p>其实这种缓冲区溢出，就是指通过一定的手段，来达成修改不属于本函数栈帧的变量的目的，而这种手段多是通过往字符串变量或者数组中写入错误的值而造成的。</p><p><strong>有两种常见的手段可以对这一类攻击进行防御。</strong></p><p>第一，对入参进行检查，尽量使用strncpy来代替strcpy。因为strcpy不对参数长度做限制，而strncpy则会做检查。比如上述例子中，如果我们对参数n做检查，要求它的值必须大于0且小于缓冲区长度，就可以阻击缓冲区溢出攻击了。</p><p>第二，可以使用gcc自带的栈保护机制，这就是-fstack-protector选项。你查gcc手册（在Linux系统使用“man gcc”就能查到）可以看到它的一些相关信息。</p><p>当-fstack-protector启用时，当其检测到缓冲区溢出时(例如，缓冲区溢出攻击）时会立即终止正在执行的程序，并提示其检测到缓冲区存在的溢出的问题。这种机制是通过在函数中的易被受到攻击的目标上下文添加保护变量来完成的。这些函数包括使用了alloca函数以及缓冲区大小超过8bytes的函数。这些保护变量在进入函数的时候进行初始化，当函数退出时进行检测，如果某些变量检测失败，那么会打印出错误提示信息并且终止当前的进程。</p><p>从4.8版本开始，gcc中的这个选项是默认打开的。如果我们在编译时，不加-fno-stack-protector，gcc就会给可执行程序增加栈保护的功能。这样的话，运行结果就会出现Segment Fault，导致进程崩溃。不过，你要知道，在遇到攻击时自己崩溃，相比起去执行攻击者的恶意代码，影响可就小多了。</p><p>这里，我们为了演示的方便，使用-fno-stack-protector关闭了这个选项。不过，在日常开发中，这个选项虽然使得栈的安全大大加强了，但它也有巨大的性能损耗。在一个实际的线上例子中，关闭这个选项可以提升8%至10%的性能。</p><p>当然这个选项也不是万能的，攻击者依然能通过精心构造数据来达成它的目标。所以在写代码的时候，你还是应该对缓冲区安全多加注意。</p><h2>总结</h2><p>这节课，我们一起学习了栈帧的作用，并通过汉诺塔程序的求解过程，来分析了栈帧的创建和销毁的过程，以此揭示了函数和栈帧的关系。栈帧就是函数的活动记录，当函数被调用时，栈帧创建，当函数调用结束后，栈帧消失。</p><p>在程序的执行过程中，尤其是递归程序的执行过程中，你可以清楚地观察到栈帧的创建销毁，满足后入先出的规律。这也是人们把管理函数的活跃记录的区域称为栈的原因。</p><p>除了用人的直观思维来理解栈帧之外，我还带你看了在汇编代码级别，栈帧是怎么真实地被创建和销毁的，或者说栈是怎么增长和收缩的。这会进一步加深你对栈的理解。</p><p>这节课的最后，我也通过一个缓冲区溢出的例子说明了，在栈空间内使用缓冲区的时候，你必须要十分小心，要避免恶意的输入对缓冲区进行越界读写，破坏栈的结构，从而导致关键数据被修改。我们演示了一个破坏了调用者返回地址的例子，以此来说明当返回地址被破坏以后，攻击者可以让程序的控制流转向我们不希望的地方。</p><p>很多人以为安全和攻击是做安全的同事才应该关心的问题，这个想法是不对的。要想提高软件的整体水平，每一个程序员都应该写出健壮而安全的代码。只有每一块砖都足够坚固，我们才有可能建成一个安全可靠的建筑物。</p><h2>思考题</h2><p>我们这节课前面讲的swap函数的例子，是很多新手会犯的错误。在C语言中，为了使swap可以交换main函数里的a/b两个变量的值，我们可以使用指针：</p><pre><code>#include &lt;stdio.h&gt;\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid main() {\n    int a = 2;\n    int b = 3;\n    swap(&amp;a, &amp;b);\n    printf(&quot;a is %d, b is %d\\n&quot;, a, b);\n}\n</code></pre><p>或者在C++中，直接使用引用，<strong>引用可以看成是一个能自动解引用的指针</strong>：</p><pre><code>#include &lt;stdio.h&gt;\n\nvoid swap(int&amp; a, int&amp; b) {\n    int t = a;\n    a = b;\n    b = t;\n}\n\nvoid main() {\n    int a = 2;\n    int b = 3;\n    swap(a, b);\n    printf(&quot;a is %d, b is %d\\n&quot;, a, b);\n}\n</code></pre><p>那么，我想请你从汇编代码层面思考，这是怎么做到的？（提示：要从“传入栈帧的参数到底是什么”这个角度去思考）另外，如果你对Java程序比较熟悉，你也可以思考一下Java能不能实现类似的功能？欢迎你在留言区和我交流你的想法，我在留言区等你。</p><p><img src=\"https://static001.geekbang.org/resource/image/15/c4/153e87bf17b61efb61609a264192c1c4.jpg?wh=2284x3407\" alt=\"\"></p><p>好，这节课到这就结束啦。欢迎你把这节课分享给更多对计算机内存感兴趣的朋友。我是海纳，我们下节课再见！</p>","neighbors":{"left":{"article_title":"03 | 内存布局：应用程序是如何安排数据的？","id":431904},"right":{"article_title":"05 | 栈的魔法：从栈切换的角度理解进程和协程","id":435493}},"comments":[{"had_liked":false,"id":319263,"user_name":"🐮","can_delete":false,"product_type":"c1","uid":2112298,"ip_address":"","ucode":"3FAD9EA59E1713","user_header":"https://static001.geekbang.org/account/avatar/00/20/3b/2a/f05e546a.jpg","comment_is_top":false,"comment_ctime":1635727356,"is_pvip":true,"replies":[{"id":"115749","content":"是的。可以这么说。不过我们在说expand这个词的时候，往往用于栈空间不足了，需要对栈进行动态扩展这种场景。你说的很对，rsp指针的上移并没有真的把栈上的数据清空掉，所以我们在使用局部变量的时候一定要初始化，否则就有可能访问到上次释放的栈内存。你掌握的很好！","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635732084,"ip_address":"","comment_id":319263,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31700498428","product_id":100094901,"comment_content":"老师，出堆后栈空间里的数据还是保留的啊，是不是叫栈空间扩展和收缩形象点","like_count":7,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529561,"discussion_content":"是的。可以这么说。不过我们在说expand这个词的时候，往往用于栈空间不足了，需要对栈进行动态扩展这种场景。你说的很对，rsp指针的上移并没有真的把栈上的数据清空掉，所以我们在使用局部变量的时候一定要初始化，否则就有可能访问到上次释放的栈内存。你掌握的很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635732084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320025,"user_name":"keepgoing","can_delete":false,"product_type":"c1","uid":1471387,"ip_address":"","ucode":"A2FE0687FB17E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","comment_is_top":false,"comment_ctime":1636041209,"is_pvip":false,"replies":[{"id":"116146","content":"是的。是这样的。就是通过把bad函数的地址写到栈上，然后就使得ret指令跑进bad函数里面运行了。两个要素：一是越界读写，一是覆盖栈上的返回地址。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636279122,"ip_address":"","comment_id":320025,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10225975801","product_id":100094901,"comment_content":"又看了一遍老师这一课，没太看懂栈溢出攻击这一块的细节，想多请教一下：<br><br>执行test函数后，字符串数组s中从0元素到15元素在栈中存储地址是从高向低的吗？随后call copy方法后，会压栈下一条指令地址到栈上，这条指令存储地址更低。所以最后让栈溢出时多拷贝地址是把地址数值的低位放在内存地址高位、数值的高位放在内存地址低位满足小端序顺利解析到这条地址的数值。<br><br>不知道这样理解对吗，因为对老师举的这个例子比较感兴趣，所以想把细节搞清楚，如果没理解对不知道能不能辛苦老师多讲一下，感谢！","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529846,"discussion_content":"是的。是这样的。就是通过把bad函数的地址写到栈上，然后就使得ret指令跑进bad函数里面运行了。两个要素：一是越界读写，一是覆盖栈上的返回地址。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636279122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2019536,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d0/d0/a6c6069d.jpg","nickname":"坚","note":"","ucode":"C02AB1CDE39D1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556242,"discussion_content":"老师，有个问题，ret指令跑进bad函数，跑完bad函数会怎么样呢？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647261785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319676,"user_name":"鵼","can_delete":false,"product_type":"c1","uid":1101766,"ip_address":"","ucode":"F6561743835F7E","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/c6/6a2d0a5e.jpg","comment_is_top":false,"comment_ctime":1635907722,"is_pvip":false,"replies":[{"id":"115862","content":"对的。这说明你真的动手实践过了。这就掌握得很好了。你的看法都是对的。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635923749,"ip_address":"","comment_id":319676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10225842314","product_id":100094901,"comment_content":"老师好，栈溢出的例子，在栈桢上不是先保存基地址rbp，然后分配rsp保存参数和局部变量吗？所以在参数的栈高位应该还有rbp，然后才是rip。但是代码本地运行一下是可以的，通过objdump看，发现没有push %rbp，mov %rsp，%rbp了。这是因为gcc加了-o1的优化参数。这个是不是有点类似方法内敛呢？不加-o1,就还会先保存rbp了，在执行即使段错误。<br>然后，思考题答案，通过objdump看，发现参数寄存器rdi和rsi保存的不再是值了，而是通过lea把参数的栈地址传递过去了。因此修改就等于是修改了main的栈桢上的值。","like_count":2,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529719,"discussion_content":"对的。这说明你真的动手实践过了。这就掌握得很好了。你的看法都是对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635923749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319453,"user_name":"费城的二鹏","can_delete":false,"product_type":"c1","uid":1101293,"ip_address":"","ucode":"DE768A0CC3053D","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ed/825d84ee.jpg","comment_is_top":false,"comment_ctime":1635819504,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10225754096","product_id":100094901,"comment_content":"吊打面试官的配图很清晰，点赞！","like_count":2,"discussions":[{"author":{"id":2767338,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/39/ea/6466ec81.jpg","nickname":"小可爱是我","note":"","ucode":"7465CBCBC67EEF","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411184,"discussion_content":"谢谢二鹏的夸奖～希望你持续支持内存课，早日成为编程高手～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635861998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330900,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1642260787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5937228083","product_id":100094901,"comment_content":"copy 越界处理了数组，导致 copy 函数栈帧的返回地址变成了 bad 函数的地址，所以 bad 函数执行了～～","like_count":1},{"had_liked":false,"id":319484,"user_name":"GL","can_delete":false,"product_type":"c1","uid":1125950,"ip_address":"","ucode":"EB14AF83184E85","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/3e/5ae876fd.jpg","comment_is_top":false,"comment_ctime":1635832249,"is_pvip":false,"replies":[{"id":"115814","content":"Right! Java没有指向栈上的指针，这个设计很重要。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635844532,"ip_address":"","comment_id":319484,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5930799545","product_id":100094901,"comment_content":"swap函数在C传入指针或C++的引用 是拿到了操作数的存放地址 所以可以改变对应的值，Java语言的入参如果基本数据类型是没法改变外部变量的值，如果是引用类型是可以改变引用对象内的属性值。","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529650,"discussion_content":"Right! Java没有指向栈上的指针，这个设计很重要。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635844532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2821060,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/0b/c4/599ac348.jpg","nickname":"tt","note":"","ucode":"55D316DAB074B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413036,"discussion_content":"从这个回复引出个问题... 我们这个专栏讲的是c的内存布局 其他语言当然是大同小异 但是Java、Python这些常见语言和C的差别是不是也可以讲讲呢。比如Java没有指向栈上的指针这个点其实就想要更深入的讲解。没有指向栈上的指针，就操作不了保存在栈里的数据，所以保存在栈里的基本数据类型的局部变量就不会影响外部的变量吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636368267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319307,"user_name":"威","can_delete":false,"product_type":"c1","uid":1068542,"ip_address":"","ucode":"C921CDCB22B9A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","comment_is_top":false,"comment_ctime":1635738437,"is_pvip":false,"replies":[{"id":"115773","content":"往往无意识的缓冲区溢出，因为会拿随机值覆盖有效值，所以会带来segment fault，覆盖了本栈帧的关键数据，或者覆盖了其他栈帧的数据都有可能造成segment fault。但是精心构造的缓冲区溢出，就像课程里对test函数的攻击，是可以把控制流导向恶意代码的。保护机制其实是在关键位置，比如栈帧开始处，编译器自动插入变量，函数结束时再检查一下，如果变化了就主动触发fault，以增强安全性，所以不一定是溢出到别的栈帧，两者之间没有必然联系","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635754281,"ip_address":"","comment_id":319307,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5930705733","product_id":100094901,"comment_content":"老师您好，缓冲区溢出的Segment Fault，是指一个栈桢里溢出，还是栈桢之间的溢出。我理解是按照文章说的保护机制，应该是溢出到了别的栈桢，才会出现Segment Fault。不知道这样的理解正不正确呢？","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529585,"discussion_content":"往往无意识的缓冲区溢出，因为会拿随机值覆盖有效值，所以会带来segment fault，覆盖了本栈帧的关键数据，或者覆盖了其他栈帧的数据都有可能造成segment fault。但是精心构造的缓冲区溢出，就像课程里对test函数的攻击，是可以把控制流导向恶意代码的。保护机制其实是在关键位置，比如栈帧开始处，编译器自动插入变量，函数结束时再检查一下，如果变化了就主动触发fault，以增强安全性，所以不一定是溢出到别的栈帧，两者之间没有必然联系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635754281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359019,"user_name":"Spoon","can_delete":false,"product_type":"c1","uid":1959822,"ip_address":"浙江","ucode":"2FF9193AD482C2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","comment_is_top":false,"comment_ctime":1665157529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665157529","product_id":100094901,"comment_content":"可以在test前加一下这个代码<br>    printf(&quot;The bad  address:%p\\n&quot;, &amp;bad);<br>    printf(&quot;The t[~] address:0x&quot;);<br>    for (int j = BUFFER_LEN - 1; j &gt;= BUFFER_LEN - 8; j--)<br>    {<br>        printf(&quot;%x&quot;, (t[j] &amp; 0xff));<br>    }<br>    printf(&quot;\\n&quot;);<br>使用-O1不会有push rbp;mov rsp rbp;这样的操作<br>copy溢出的原理是应为eip压栈时占用8字节，copy调用完以后，现在s之上，元old eip压栈地址变为bad函数地址<br>","like_count":0},{"had_liked":false,"id":357256,"user_name":"程序猿","can_delete":false,"product_type":"c1","uid":1169296,"ip_address":"北京","ucode":"3DF3CD71E7A306","user_header":"https://static001.geekbang.org/account/avatar/00/11/d7/90/f63eb1da.jpg","comment_is_top":false,"comment_ctime":1663121781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663121781","product_id":100094901,"comment_content":"BUFFER_LEN 不是24吗？为什么栈里面值预留了初始化的16个字节？","like_count":0},{"had_liked":false,"id":352245,"user_name":"边城路远","can_delete":false,"product_type":"c1","uid":1286741,"ip_address":"","ucode":"214ECD8981E87F","user_header":"https://static001.geekbang.org/account/avatar/00/13/a2/55/1092ebb8.jpg","comment_is_top":false,"comment_ctime":1658478491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658478491","product_id":100094901,"comment_content":"我用的高版本的gcc-11.3.0，没有出现栈溢出，原因是编译器自动做了处理，反汇编后test函数第一条指令是“sub    $0x18,%rsp”， 而在另外一台低版本机器上，反汇编后test函数第一条指令是“sub    $0x10,%rsp”","like_count":0},{"had_liked":false,"id":338730,"user_name":"进化论","can_delete":false,"product_type":"c1","uid":1124107,"ip_address":"","ucode":"2865A23392B9F9","user_header":"https://static001.geekbang.org/account/avatar/00/11/27/0b/12dee5ed.jpg","comment_is_top":false,"comment_ctime":1647687998,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647687998","product_id":100094901,"comment_content":"400531: 48 83 ec 10 sub $0x10,%rsp %rsp存储的地址-16  这16单位是？ 参数n不是4字节吗为啥是16？ 还有返回地址，返回值，那这16也没想明白都包括的什么数据<br><br>400535: 89 7d fc mov %edi,-0x4(%rbp).  这里代表%rbp存储的地址减了4字节吗？","like_count":0},{"had_liked":false,"id":336944,"user_name":"会爆炸的小米Note","can_delete":false,"product_type":"c1","uid":2150023,"ip_address":"","ucode":"1DA0B740A7C7B7","user_header":"https://static001.geekbang.org/account/avatar/00/20/ce/87/41c44923.jpg","comment_is_top":false,"comment_ctime":1646484262,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646484262","product_id":100094901,"comment_content":"由于main函数向swap函数传递的参数小于6个 只会使用用寄存器传参 不会在main函数的参数构建区存放a,b,&amp;a,&amp;b的值<br>main函数调用swap(a,b)时会用mov把在main函数局部变量区存放的a，b的值复制到rdi，rsi<br>main函数调用swap(&amp;a,&amp;b)时会用leaq把在main函数局部变量区存放的a，b的地址值复制到rdi，rsi<br>这样在swap的时候相当于对main函数局部变量区的a，b直接操作<br>leaveq相当于 mov rbp,rsp <br>                   pop rbp<br>retq相当于    pop rip<br>都是AT&amp;T格式的<br><br><br>","like_count":0},{"had_liked":false,"id":333419,"user_name":"jferic","can_delete":false,"product_type":"c1","uid":2069779,"ip_address":"","ucode":"55877400ED5F94","user_header":"https://static001.geekbang.org/account/avatar/00/1f/95/13/ea2584d3.jpg","comment_is_top":false,"comment_ctime":1644335144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644335144","product_id":100094901,"comment_content":"# gcc -O1 -o fac fac.c<br><br>000000000040052d &lt;fac&gt;:<br>  40052d:       53                      push   %rbx<br>  40052e:       89 fb                   mov    %edi,%ebx<br>  400530:       b8 01 00 00 00          mov    $0x1,%eax<br>  400535:       83 ff 01                cmp    $0x1,%edi<br>  400538:       74 0b                   je     400545 &lt;fac+0x18&gt;<br>  40053a:       8d 7f ff                lea    -0x1(%rdi),%edi<br>  40053d:       e8 eb ff ff ff          callq  40052d &lt;fac&gt;<br>  400542:       0f af c3                imul   %ebx,%eax<br>  400545:       5b                      pop    %rbx<br>  400546:       c3                      retq<br><br>-O1 优化后：<br>使用 push %rbx 通过 %rbx 寄存器在计算 fac(n-1) 的时先把 n 在 push 到 栈 上，<br>接着通过 callq 算出 fac(n-1) 结果存入 %eax，<br>然后使用 pop %rbx 把 n 存入 %rbx 寄存器，<br>其后执行 imul   %ebx,%eax  计算 n * fac(n-1)","like_count":0},{"had_liked":false,"id":333400,"user_name":"jferic","can_delete":false,"product_type":"c1","uid":2069779,"ip_address":"","ucode":"55877400ED5F94","user_header":"https://static001.geekbang.org/account/avatar/00/1f/95/13/ea2584d3.jpg","comment_is_top":false,"comment_ctime":1644326657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644326657","product_id":100094901,"comment_content":"文中：“第 1 行是将当前栈基址指针存到栈顶，第 2 行是把栈指针保存到栈基址寄存器，这两行的作用是把当前函数的栈帧创建在调用者的栈帧之下。保存调用者的栈基址是为了在 return 时可以恢复这个寄存器。”<br><br>请问老师，是 14 行的 leaveq 指令恢复调用者的寄存器吗？可以展开讲一下这个 leaveq 指令吗？","like_count":0},{"had_liked":false,"id":327977,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1640431038,"is_pvip":true,"replies":[{"id":"119524","content":"编译器在做编译优化的过程中会计算的。具体地说就是寄存器分配这一步就能统计出来需要多大的栈空间。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1640618406,"ip_address":"","comment_id":327977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640431038","product_id":100094901,"comment_content":"第 3 行的作用呢，是把栈向下增长 0x10，这是为了给局部变量预留空间。从这里，你可以看出来运行 fac 函数要是消耗栈空间的。<br>==========================&gt;<br>请问栈增长多少是如何预估出来的？ ","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542005,"discussion_content":"编译器在做编译优化的过程中会计算的。具体地说就是寄存器分配这一步就能统计出来需要多大的栈空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640618406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325868,"user_name":"ZR2021","can_delete":false,"product_type":"c1","uid":1707352,"ip_address":"","ucode":"4F685C7516F057","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","comment_is_top":false,"comment_ctime":1639205543,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1639205543","product_id":100094901,"comment_content":"老师，为什么栈溢出就会崩溃呢，栈帧里面存放的都是数据，权限基本都一样的吧，应该不是出现覆盖了权限不同的数据导致崩溃吧， 还是说栈溢出了就是会崩溃，那是谁检测栈溢出的，又是怎么通知到内核，然后内核发信号让这个进程主动崩溃的","like_count":0,"discussions":[{"author":{"id":1432830,"avatar":"https://static001.geekbang.org/account/avatar/00/15/dc/fe/f11f25dd.jpg","nickname":"左星辰","note":"","ucode":"A67D772F6AA584","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545832,"discussion_content":"栈溢出不一定会崩溃的，比如文中的例子，就是执行到精心构造的代码了。如果是意外导致的栈溢出，情况会有很多，也可能像该例子一样进程还在继续运行，只是结果已经不符合预期了；也有可能栈上的关键数据被覆盖导致程序无法继续执行，就会报Segment Fault","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642062509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325183,"user_name":"喵吉豆豆","can_delete":false,"product_type":"c1","uid":1144651,"ip_address":"","ucode":"1F3322FF5EDF58","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/4b/ede8aa13.jpg","comment_is_top":false,"comment_ctime":1638853422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638853422","product_id":100094901,"comment_content":"40052d:       55                      push   %rbp  <br>40052e:       48 89 e5                mov    %rsp,%rbp  <br>400531:       48 83 ec 10             sub    $0x10,%rsp<br><br>第2个例子里一开始栈为什么要扩0x10呢？只算到一个局部变量需要的0x04，还有一条imul语句，加起来也不到0x10，不知道是哪里理解的不对","like_count":0},{"had_liked":false,"id":323632,"user_name":"Geek_a5edac","can_delete":false,"product_type":"c1","uid":1954784,"ip_address":"","ucode":"A47341B4DB9C8E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132","comment_is_top":false,"comment_ctime":1638036488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638036488","product_id":100094901,"comment_content":"看了四章，基本上没有什么理解的压力，都很快掌握老师讲的要点，主要是因为本人之前已经看了《深入理解计算机操作系统》《linux 0.11 源码》相关数据，大体上有了一个基本的认识。但还是感谢老师这么课程，我认为这么课程很好把握之前的知识点比较系统地做了梳理，并在一些细节上突出了下。","like_count":0},{"had_liked":false,"id":321687,"user_name":"拭心","can_delete":false,"product_type":"c1","uid":1024819,"ip_address":"","ucode":"66BDB8959A4C59","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/33/b404a199.jpg","comment_is_top":false,"comment_ctime":1636992984,"is_pvip":true,"replies":[{"id":"117070","content":"其实这是本科阶段的三节课：汇编原理，计算机组成和计算机体系结构的内容。我们学了三个学期的呀。一下子记不住很正常。慢慢来。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1637375167,"ip_address":"","comment_id":321687,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1636992984","product_id":100094901,"comment_content":"看的有点晕，尤其是各个汇编指令和他们操作的寄存器的作用，不知道您是怎么记忆这些晦涩的内容呢？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531650,"discussion_content":"其实这是本科阶段的三节课：汇编原理，计算机组成和计算机体系结构的内容。我们学了三个学期的呀。一下子记不住很正常。慢慢来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637375167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1024819,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/33/b404a199.jpg","nickname":"拭心","note":"","ucode":"66BDB8959A4C59","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":531688,"discussion_content":"本科也是计算机，汇编这部分记忆为零，看来我是学渣😥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637386609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531650,"ip_address":""},"score":531688,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":321666,"user_name":"🙃","can_delete":false,"product_type":"c1","uid":2170263,"ip_address":"","ucode":"6E41B3D10A33CA","user_header":"https://static001.geekbang.org/account/avatar/00/21/1d/97/9a8b2d0c.jpg","comment_is_top":false,"comment_ctime":1636985379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636985379","product_id":100094901,"comment_content":"提一个小建议：可以在每篇文章后面附上作者决定不错的文章或者paper，这样既可以在作者的专栏里对整体有一个完整的印象，也可以根据作者推荐的文章来深入理解！","like_count":0},{"had_liked":false,"id":319884,"user_name":"keepgoing","can_delete":false,"product_type":"c1","uid":1471387,"ip_address":"","ucode":"A2FE0687FB17E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","comment_is_top":false,"comment_ctime":1635997823,"is_pvip":false,"replies":[{"id":"116005","content":"汇编代码往右拖😂，我也看不懂机器码，哈哈","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1636017933,"ip_address":"","comment_id":319884,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1635997823","product_id":100094901,"comment_content":"老师想提个小建议，能不能把汇编代码也贴上来比较方便理解，n*(n-1)那个例子因为示例代码只有机器码，只能看着您的文字理解，我们这种刚开始入门的同学看着可能比较抽象，不过这一课又把栈更深入地理解了一遍，谢谢老师","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529800,"discussion_content":"汇编代码往右拖😂，我也看不懂机器码，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636017933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1471387,"avatar":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","nickname":"keepgoing","note":"","ucode":"A2FE0687FB17E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411940,"discussion_content":"好的。。。我的错。。。手机屏幕太窄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636035768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319695,"user_name":"柒","can_delete":false,"product_type":"c1","uid":2419502,"ip_address":"","ucode":"D41241629321A1","user_header":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","comment_is_top":false,"comment_ctime":1635914050,"is_pvip":false,"replies":[{"id":"115852","content":"其实基本上都是C语言。python呢就当伪代码看吧，你看最后结尾的吊打面试官里，其实也是伪代码。自己转换成可执行的C或者Java代码是个很好的练习哦。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635920660,"ip_address":"","comment_id":319695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635914050","product_id":100094901,"comment_content":"老师，我觉得你一下用python，一下用c语言，不太好。","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529727,"discussion_content":"其实基本上都是C语言。python呢就当伪代码看吧，你看最后结尾的吊打面试官里，其实也是伪代码。自己转换成可执行的C或者Java代码是个很好的练习哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635920660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319525,"user_name":"Rovebiy","can_delete":false,"product_type":"c1","uid":1518152,"ip_address":"","ucode":"E45B02264F180E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/nUUviatibFtUzic3XibFPWFbV0k9rX0ZLb1QibY0pmeUO4yGK3wMKFsZtDwZbs1rRSRXwOFOFMj7SZdgofdggQTGF3Q/132","comment_is_top":false,"comment_ctime":1635842332,"is_pvip":false,"replies":[{"id":"115844","content":"嗯，是我。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635910313,"ip_address":"","comment_id":319525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635842332","product_id":100094901,"comment_content":"老师，是不是曾经在知乎写过专栏进击的Java新人？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529660,"discussion_content":"嗯，是我。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635910313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319354,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1635757086,"is_pvip":false,"replies":[{"id":"115778","content":"请文字描述，哈哈","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635786234,"ip_address":"","comment_id":319354,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1635757086","product_id":100094901,"comment_content":"思考题：反汇编结果显示传递的是地址<br>000000000040052d &lt;swap&gt;:<br>  40052d:\t55                   \tpush   %rbp<br>  40052e:\t48 89 e5             \tmov    %rsp,%rbp<br>  400531:\t48 89 7d e8          \tmov    %rdi,-0x18(%rbp)<br>  400535:\t48 89 75 e0          \tmov    %rsi,-0x20(%rbp)<br>  400539:\t48 8b 45 e8          \tmov    -0x18(%rbp),%rax<br>  40053d:\t8b 00                \tmov    (%rax),%eax<br>  40053f:\t89 45 fc             \tmov    %eax,-0x4(%rbp)<br>  400542:\t48 8b 45 e0          \tmov    -0x20(%rbp),%rax<br>  400546:\t8b 10                \tmov    (%rax),%edx<br>  400548:\t48 8b 45 e8          \tmov    -0x18(%rbp),%rax<br>  40054c:\t89 10                \tmov    %edx,(%rax)<br>  40054e:\t48 8b 45 e0          \tmov    -0x20(%rbp),%rax<br>  400552:\t8b 55 fc             \tmov    -0x4(%rbp),%edx<br>  400555:\t89 10                \tmov    %edx,(%rax)<br>  400557:\t5d                   \tpop    %rbp<br>  400558:\tc3                   \tretq   <br><br>0000000000400559 &lt;main&gt;:<br>  400559:\t55                   \tpush   %rbp<br>  40055a:\t48 89 e5             \tmov    %rsp,%rbp<br>  40055d:\t48 83 ec 10          \tsub    $0x10,%rsp<br>  400561:\tc7 45 fc 02 00 00 00 \tmovl   $0x2,-0x4(%rbp)<br>  400568:\tc7 45 f8 03 00 00 00 \tmovl   $0x3,-0x8(%rbp)<br>  40056f:\t48 8d 55 f8          \tlea    -0x8(%rbp),%rdx<br>  400573:\t48 8d 45 fc          \tlea    -0x4(%rbp),%rax<br>  400577:\t48 89 d6             \tmov    %rdx,%rsi<br>  40057a:\t48 89 c7             \tmov    %rax,%rdi<br>  40057d:\te8 ab ff ff ff       \tcallq  40052d &lt;swap&gt;<br>  400582:\t8b 55 f8             \tmov    -0x8(%rbp),%edx<br>  400585:\t8b 45 fc             \tmov    -0x4(%rbp),%eax<br>  400588:\t89 c6                \tmov    %eax,%esi<br>  40058a:\tbf 30 06 40 00       \tmov    $0x400630,%edi<br>  40058f:\tb8 00 00 00 00       \tmov    $0x0,%eax<br>","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529604,"discussion_content":"请文字描述，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635786234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803259,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","nickname":"linker","note":"","ucode":"6C5799F2FC2C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411141,"discussion_content":"40056f 这一行，lea指令去取到栈中局部变量的地址，放入rdx,再通过rsi传入子函数，然后子函数只能使用间接寻址访问里面的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635856456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319315,"user_name":"杨军","can_delete":false,"product_type":"c1","uid":1988156,"ip_address":"","ucode":"AF881224E54C14","user_header":"https://static001.geekbang.org/account/avatar/00/1e/56/3c/f9ff3ed8.jpg","comment_is_top":false,"comment_ctime":1635740028,"is_pvip":false,"replies":[{"id":"115774","content":"赞，我不知道还有这个。我去查了一下，应该是lab3，attack。","user_name":"作者回复","user_name_real":"海纳","uid":"1360512","ctime":1635755399,"ip_address":"","comment_id":319315,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635740028","product_id":100094901,"comment_content":"这个就是csapp 中 lab2 的内容，好亲切","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529589,"discussion_content":"赞，我不知道还有这个。我去查了一下，应该是lab3，attack。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635755399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}