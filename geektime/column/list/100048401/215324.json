{"id":215324,"title":"03 | 哈希检索：如何根据用户ID快速查询用户信息？","content":"<p>你好，我是陈东。</p><p>在实际应用中，我们经常会面临需要根据键（Key）来查询数据的问题。比如说，给你一个用户ID，要求你查出该用户的具体信息。这样的需求我们应该如何实现呢？你可能会想到，使用有序数组和二叉检索树都可以来实现。具体来说，我们可以将用户ID和用户信息作为一个整体的元素，然后以用户ID作为Key来排序，存入有序数组或者二叉检索树中，这样我们就能通过二分查找算法快速查询到用户信息了。</p><p>但是，不管是有序数组、二叉检索树还是跳表，它们的检索效率都是O(log n)。那有没有更高效的检索方案呢？也就是说，有没有能实现O(1)级别的查询方案呢？今天，我们就一起来探讨一下这个问题。</p><h2>使用Hash函数将Key转换为数组下标</h2><p>在第1讲中我们说过，数组具有随机访问的特性。那给定一个用户ID，想要查询对应的用户信息，我们能否利用数组的随机访问特性来实现呢？</p><p>我们先来看一个例子。假设系统中的用户ID是从1开始的整数，并且随着注册数的增加而增加。如果系统中的用户数是有限的，不会大于10万。那么用户的ID范围就会被固定在1到10万之间。在数字范围有限的情况下，我们完全可以申请一个长度为10万的数组，然后将用户ID作为数组下标，从而实现O(1)级别的查询能力。<br>\n<img src=\"https://static001.geekbang.org/resource/image/bb/cf/bb7ac50d85287e55dde85490a02080cf.jpg?wh=1920*606\" alt=\"\"></p><!-- [[[read_end]]] --><center><span class=\"reference\">将用户ID直接作为下标查询 ，由于数组下标从0开始，因此查询时ID要减1  </span></center><p>注意，刚才我们举的这个例子中有一个假设：用户的ID是一个数字，并且范围有限。符合这种假设的用户ID才能作为数组下标，使用数组的随机访问特性，达到O(1)时间代价的高效检索能力。那如果用户的ID数字范围很大，数组无法申请这么大的空间该怎么办呢？或者，用户的ID不是数字而是字符串，还能作为数组下标吗？</p><p>我们假设有一个系统使用字符串作为用户ID。如果有一个用户的ID是“tom”，我们该怎么处理呢？我们能否将它转换为一个数字来表示呢？你可以先想一想解决方案，再和我继续往下分析。</p><p>我们来考虑这样一种方案：字母表是有限的，只有26个，我们可以用字母在字母表中的位置顺序作为数值。于是，就有：“t” = 20，“o” = 15，“m” = 13。我们可以把这个ID看作是26进制的数字，那么对于“tom”这个字符串，把它转为对应的数值就是20 * 26^2 + 15*26 + 13 =149123，这是一个小于26^4 = 456976‬的数。</p><p>如果所有用户的ID都不超过3个字符，使用这个方法，我们用一个可以存储456976‬个元素的数组就可以存储所有用户的信息了。实际上，工业界有许多更复杂的将字符串转为整数的哈希算法，但核心思想都是利用每个字符的编码和位置信息进行计算，这里我就不展开了。</p><p>那如果内存空间有限，我们只能开辟一个存储10000个元素的数组该怎么办呢？这个时候，我们可以使用“tom”对应的数值149123除以数组长度10000，得到余数9123，用这个余数作为数组下标。</p><p>这种将对象转为有限范围的正整数的表示方法，就叫作<strong>Hash</strong>，翻译过来叫<strong>散列</strong>，也可以直接音译为<strong>哈希</strong>。而我们常说的Hash函数就是指具体转换方法的函数。我们将对象进行Hash，用得到的Hash值作为数组下标，将对应元素存在数组中。这个数组就叫作<strong>哈希表</strong>。这样我们就可以利用数组的随机访问特性，达到O(1)级别的查询性能。</p><p>说到这里，你可能会有疑问了，Hash函数真的这么神奇吗？如果两个对象的哈希值是相同的怎么办？事实上，任何Hash函数都有可能造成对象不同，但Hash值相同的冲突。而且，数组空间是有限的，只要被Hash的元素个数大于数组上限，就一定会产生冲突。</p><p>对于哈希冲突这个问题，我们有两类解决方案: 一类是构造尽可能理想的Hash函数，使得Hash以后得到的数值尽可能平均分布，从而减少冲突发生的概率；另一类是在冲突发生以后，通过“提供冲突解决方案”来完成存储和查找。最常用的两种冲突解决方案是“开放寻址法”和“链表法”。下面，我就来介绍一下这两种方法，并且重点看看它们对检索效率的影响。</p><h2>如何利用开放寻址法解决Hash冲突？</h2><p>所谓“开放寻址法”，就是在冲突发生以后，最新的元素需要寻找新空闲的数组位置完成插入。那我们该如何寻找新空闲的位置呢？我们可以使用一种叫作“线性探查”（Linear Probing）的方案来进行查找。</p><p>“线性探查”的插入逻辑很简单：在当前位置发现有冲突以后，就顺序去查看数组的下一个位置，看看是否空闲。如果有空闲，就插入；如果不是空闲，再顺序去看下一个位置，直到找到空闲位置插入为止。</p><p>查询逻辑也和插入逻辑相似。我们先根据Hash值去查找相应数组下标的元素，如果该位置不为空，但是存储元素的Key和查询的Key不一致，那就顺序到数组下一个位置去检索，就这样依次比较Key。如果访问元素的Key和查询Key相等，我们就在哈希表中找到了对应元素；如果遍历到空闲处，依然没有元素的Key和查询Key相等，则说明哈希表中不存在该元素。</p><p>为了帮助你更好地理解，我们来看一个例子。</p><p>假设一个哈希表中已经插入了两个Key，key1和key2。其中Hash(key1) = 1, Hash(key2) = 2。这时，如果我们要插入一个Hash值为1的key3。根据线性探查的插入逻辑，通过3步，我们就可以将key3插入到哈希表下标为3的位置中。插入的过程如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/8b/d0/8b0de808f6485bde014019e9d158b0d0.jpg?wh=1920*965\" alt=\"\"><br>\n在查找key3的时候，因为Hash（key3）= 1，我们会从哈希表下标为1的位置开始顺序查找，经过3步找到key3，查询结束。</p><p>讲到这里，你可能已经发现了一个问题：当我们插入一个Key时，如果哈希表已经比较满了，这个Key就会沿着数组一直顺序遍历，直到遇到空位置才会成功插入。查询的时候也一样。但是，顺序遍历的代价是O(n)，这样的检索性能很差。</p><p>更糟糕的是，如果我们在插入key1后，先插入key3再插入key2，那key3就会抢占key2的位置，影响key2的插入和查询效率。<strong>因此，“线性探查”会影响哈希表的整体性能，而不只是Hash值冲突的Key</strong>。</p><p>为了解决这个问题，我们可以使用“二次探查”（Quadratic Probing）和“双散列”（Double Hash）这两个方法进行优化。下面，我来分别解释一下这两个方法的优化原理。</p><p>二次探查就是将线性探查的步长从i改为i^2：第一次探查，位置为Hash(key) + 1^2；第二次探查，位置为Hash(key) +2^2；第三次探查，位置为Hash(key) + 3^2，依此类推。</p><p>双散列就是使用多个Hash函数来求下标位置，当第一个Hash函数求出来的位置冲突时，启用第二个Hash函数，算出第二次探查的位置；如果还冲突，则启用第三个Hash函数，算出第三次探查的位置，依此类推。</p><p>无论是二次探查还是双散列，核心思路其实都是在发生冲突的情况下，将下个位置尽可能地岔开，让数据尽可能地随机分散存储，来降低对不相干Key的干扰，从而提高整体的检索效率。</p><p>但是，对于开放寻址法来说，无论使用什么优化方案，随着插入的元素越多、哈希表越满，插入和检索的性能也就下降得越厉害。在极端情况下，当哈希表被写满的时候，为了保证能插入新元素，我们只能重新生成一个更大的哈希表，将旧哈希表中的所有数据重新Hash一次写入新的哈希表，也就是<strong>Re-Hash</strong>，这样会造成非常大的额外开销。因此，在数据动态变化的场景下，使用开放寻址法并不是最合适的方案。</p><h2>如何利用链表法解决Hash冲突？</h2><p>相比开放寻址法，还有一种更常见的冲突解决方案，链表法。所谓“链表法”，就是在数组中不存储一个具体元素，而是存储一个链表头。如果一个Key经过Hash函数计算，得到了对应的数组下标，那么我们就将它加入该位置所存的链表的尾部。</p><p>这样做的好处是，如果key3和key1发生了冲突，那么key3会通过链表的方式链接在key1的后面，而不是去占据key2的位置。这样当key2插入时，就不会有冲突了。最终效果如下图。<br>\n<img src=\"https://static001.geekbang.org/resource/image/b9/07/b91d6e394af24935f67dc21293bc0c07.jpg?wh=1552*944\" alt=\"\"></p><center><span class=\"reference\">链表法</span></center><p>讲到这里，你可能已经发现了，其实链表法就是将我们前面讲过的数组和链表进行结合，既利用了数组的随机访问特性，又利用了链表的动态修改特性，同时提供了快速查询和动态修改的能力。</p><p>想要查询时，我们会先根据查询Key的Hash值，去查找相应数组下标的链表。如果链表为空，则表示不存在该元素；如果链表不为空，则遍历链表，直到找到Key相等的对应元素为止。</p><p>但是，如果链表很长，遍历代价还是会很高。那我们有没有更好的检索方案呢？你可以回想一下，在上一讲中我们就是用二叉检索树或跳表代替链表，来提高检索效率的。</p><p>实际上，在JDK1.8 之后，Java中HashMap的实现就是在链表到了一定的长度时，将它转为红黑树；而当红黑树中的节点低于一定阈值时，就将它退化为链表。<br>\n<img src=\"https://static001.geekbang.org/resource/image/8c/f2/8c5c5054e92ec24de3bde1ca15946af2.jpg?wh=1920*1080\" alt=\"\"></p><center><span class=\"reference\">链表法：用红黑树来优化长链表</span></center><p>第一个阶段，通过Hash函数将要查询的Key转为数组下标，去查询对应的位置。这个阶段的查询代价是O(1)级别。</p><p>第二阶段，将数组下标所存的链表头或树根取出。如果是链表，就使用遍历的方式查找，这部分查询的时间代价是O(n)。由于链表长度是有上限的，因此实际开销并不会很大，可以视为常数级别时间。如果是红黑树，则用二分查找的方式去查询，时间代价是O(log n)。如果哈希表中冲突的元素不多，那么落入红黑树的数据规模也不会太大，红黑树中的检索代价也可以视为常数级别时间。</p><h2>哈希表有什么缺点？</h2><p>哈希表既有接近O(1)的检索效率，又能支持动态数据的场景，看起来非常好，那是不是在任何场景下，我们都可以用它来代替有序数组和二叉检索树呢？答案是否定的。前面我们说了这么多哈希表的优点，下面我们就来讲讲它的缺点。</p><p>首先，哈希表接近O(1)的检索效率是有前提条件的，就是哈希表要足够大和有足够的空闲位置，否则就会非常容易发生冲突。我们一般用<strong>装载因子（load factor）</strong>来表示哈希表的填充率。装载因子 = 哈希表中元素个数/哈希表的长度。</p><p>如果频繁发生冲突，大部分的数据会被持续地添加到链表或二叉检索树中，检索也会发生在链表或者二叉检索树中，这样检索效率就会退化。因此，为了保证哈希表的检索效率，我们需要预估哈希表中的数据量，提前生成足够大的哈希表。按经验来说，我们一般要预留一半以上的空闲位置，哈希表才会有足够优秀的检索效率。这就让哈希表和有序数组、二叉检索树相比，需要的存储空间更多了。</p><p>另一方面，尽管哈希表使用Hash值直接进行下标访问，带来了O(1)级别的查询能力，但是也失去了“有序存储”这个特点。因此，如果我们的查询场景需要遍历数据，或者需要进行范围查询，那么哈希表本身是没有什么加速办法的。比如说，如果我们在一个很大的哈希表中存储了少数的几个元素，为了知道存储了哪些元素，我们只能从哈希表的第一个位置开始遍历，直到结尾，这样性能并不好。</p><h2>重点回顾</h2><p>好了，关于哈希检索我们就讲到这里。你会看到，哈希表的本质是一个数组，它通过Hash函数将查询的Key转为数组下标，利用数组的随机访问特性，使得我们能在O(1)的时间代价内完成检索。</p><p>尽管哈希检索没有使用二分查找，但无论是设计理想的哈希函数，还是保证哈希表有足够的空闲位置，包括解决冲突的“二次探查”和“双散列”方案，本质上都是希望数据插入哈希表的时候，分布能均衡，这样检索才能更高效。从这个角度来看，其实哈希检索提高检索效率的原理，和二叉检索树需要平衡左右子树深度的原理是一样的，也就是说，高效的检索需要均匀划分检索空间。</p><p>另一方面，你会看到，复杂的数据结构和检索算法其实都是由最基础的数据结构和算法组成的。比如说JDK1.8中哈希表的实现，就是使用了数组、链表、红黑树这三种数据结构和相应的检索算法。因此，对于这些基础的数据结构，我们需要深刻地理解它们的检索原理和适用场景，这也为我们未来学习更复杂的系统打下了扎实的基础。</p><h2>课堂讨论</h2><p>假设一个哈希表是使用开放寻址法实现的，如果我们需要删除其中一个元素，可以直接删除吗？为什么呢？如果这个哈希表是使用链表法实现的会有不同吗？</p><p>欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":197447,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1585378846,"is_pvip":true,"replies":[{"id":"74600","content":"是的。这种加一个flag记录状态的设计，其实在许多算法和系统中都有出现。是我们可以学习和掌握的一种方法。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585383789,"ip_address":"","comment_id":197447,"utype":1}],"discussion_count":3,"race_medal":0,"score":"87484724766","product_id":100048401,"comment_content":"我这几天刚好看过一个C语言的哈希表实现源代码khash.h，它用的就是open addressing方法。 在删除元素的时候 不会真正的删除，会有一个flag记录状态。后续插入新的元素还能用。否则就会导致每次就要重新申请内存，rehash，计算量太大。链表法的话，删除的是对应的node ，时间复杂度是O(1) 所以删除很快","like_count":21,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489526,"discussion_content":"是的。这种加一个flag记录状态的设计，其实在许多算法和系统中都有出现。是我们可以学习和掌握的一种方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585383789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219013,"discussion_content":" 在删除元素的时候 不会真正的删除，会有一个flag记录状态。后续插入新的元素还能用。否则就会导致每次就要重新申请内存，rehash，计算量太大\n-------\n请问开放地址法为什么会重新申请内存呢，这种方案不是拉链法，value不都是预先分配好的吗，难道value的地方只是存一个真正数据的地址吗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585724156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1314643,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","nickname":"徐洲更","note":"","ucode":"F8A323CB732D05","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219128,"discussion_content":"这是我读khash源代码的笔记。http://xuzhougeng.top/archives/khash-in-depth-reading 应该能解答你的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585738291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":219013,"ip_address":""},"score":219128,"extra":""}]}]},{"had_liked":false,"id":197397,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1585373617,"is_pvip":false,"replies":[{"id":"74599","content":"没错！这种增加一个删除标识的做法，其实在许多算法和系统的设计中都有出现。也是一种常见的设计思路。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585383709,"ip_address":"","comment_id":197397,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40240079281","product_id":100048401,"comment_content":"链表法可以直接删除，开放寻址法不行。<br>开放寻址法在 hash 冲突后会继续往后面看，如果为空，就放到后面，这样会存在连续的几个值的 hash 值都相同的情况，但如果想删除的数据在中间的话，就会影响对后面数据的查询了<br>可以增加一个删除标识，这种添加删除标识的在数据库中也常用","like_count":10,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489512,"discussion_content":"没错！这种增加一个删除标识的做法，其实在许多算法和系统的设计中都有出现。也是一种常见的设计思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585383709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032932,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c2/e4/ad418d90.jpg","nickname":"风","note":"","ucode":"2DEDB586E625C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391791,"discussion_content":"elasticsearch的shard 数确定了之后，无法修改，是不是也是和doc路由到具体shard需要hash的原因呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630635931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268547,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1608254158,"is_pvip":false,"replies":[{"id":"97573","content":"你的这个思考很棒！我在前面的课程和后面的课程都会提到，不同的高效检索算法，其实本质都是快速划分检索空间，然后在子检索空间中再用合适的算法去检索。<br>因此，可以hash + 二叉树，或者数组 + bitmap，这些都是可能的解决方案。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1608479287,"ip_address":"","comment_id":268547,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18788123342","product_id":100048401,"comment_content":"感觉当使用链表法时，哈希算法就不再是完整的搜索算法了，而只是为下一步搜索算法减少搜索范围的算法，至于下一步算法是什么，其实没啥限制，既可以是链表或平衡树，也可以是另一个哈希算法。","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511966,"discussion_content":"你的这个思考很棒！我在前面的课程和后面的课程都会提到，不同的高效检索算法，其实本质都是快速划分检索空间，然后在子检索空间中再用合适的算法去检索。\n因此，可以hash + 二叉树，或者数组 + bitmap，这些都是可能的解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608479287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196419,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1585279843,"is_pvip":true,"replies":[{"id":"74426","content":"哈希表在查找元素的时候，不是只看下标的，还要对比下标位置的元素值，相同才算找到。这也是为什么会有线性探查等方法。<br>不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585282682,"ip_address":"","comment_id":196419,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18765149027","product_id":100048401,"comment_content":"通过开放寻址法是不可以简单的删除元素的，如果要删除的元素是通过寻址法找的存储下标，那么该元素所在的下标不是本身 hash 后的位置<br><br>链表法是可以的：因为元素本身的 hash 值和存储位置的下标 值是一致的<br><br>","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489292,"discussion_content":"哈希表在查找元素的时候，不是只看下标的，还要对比下标位置的元素值，相同才算找到。这也是为什么会有线性探查等方法。\n不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585282682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196343,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585274526,"is_pvip":false,"replies":[{"id":"74416","content":"对于有基础和经验的工程师，可以当做回顾。同时也思考一下工业界的实际实现方案。<br>在后面，我准备写几篇加餐，补充更多的实践工程内容。让有经验的工程师更有收获。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585277883,"ip_address":"","comment_id":196343,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18765143710","product_id":100048401,"comment_content":"今天的内容权当回顾吧，期待后续的干货。","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489270,"discussion_content":"对于有基础和经验的工程师，可以当做回顾。同时也思考一下工业界的实际实现方案。\n在后面，我准备写几篇加餐，补充更多的实践工程内容。让有经验的工程师更有收获。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585277883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324237,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/EvqrQ1wMs4SzC8dSBjAfVdEZ3yDT0bDUMicfRLq6BOSzjGFhCownt3S5MERXLpOpLmyJXCuyWbeOQG3ibzy0b4ibA/132","nickname":"jkhcw","note":"","ucode":"300F1FEAEA9EB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215515,"discussion_content":"出于体系完整性的需要，这部分是绕不开的。作者也是挺为难的。同时要考虑一下大众的接受度。这里支持一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585328309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218937,"avatar":"https://static001.geekbang.org/account/avatar/00/12/99/79/74d4f24f.jpg","nickname":"anker","note":"","ucode":"6EDF1FB9D45238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386728,"discussion_content":"温故而知新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627746884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229839,"user_name":"研发","can_delete":false,"product_type":"c1","uid":1385864,"ip_address":"","ucode":"E662D2478AEBB6","user_header":"https://static001.geekbang.org/account/avatar/00/15/25/88/ed596222.jpg","comment_is_top":false,"comment_ctime":1593160169,"is_pvip":false,"replies":[{"id":"84799","content":"有序存储，你可以理解为按某种规则排序然后依次存储，然后访问时也能按这个次序依次取出。比如说，我们可以按数值排序从小到大存储，或者按数据进入时间排序从旧往新存储，这些都可以看做有序存储。<br>数组本身是支持有序存储的。但是，如果你给数组加上了限定条件，那么数组就会损失一部分能力了。比如说，栈也是使用数组实现的，但是它限定了只能后进先出，这样就失去了数组的随机访问能力(也失去了按值从小到大有序输出的能力)。<br>而哈希表限定了“用对象的哈希值作为下标直接存储和访问”，因此，哈希表中的数据是零散的，不连续的，也无法按照存入时间或者大小有序访问。如果你把数据进行了整理，那么就会失去哈希表的“用对象的哈希值作为下标直接存储和访问”的特点了。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1593172141,"ip_address":"","comment_id":229839,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14478062057","product_id":100048401,"comment_content":"为什么哈希表没有有序存储的能力？<br>有序存储指的不是存入和取出元素的顺序是一致的吗？哈希表本质是数组，数组是有序存储的，为什么哈希表不是？","like_count":4,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499662,"discussion_content":"有序存储，你可以理解为按某种规则排序然后依次存储，然后访问时也能按这个次序依次取出。比如说，我们可以按数值排序从小到大存储，或者按数据进入时间排序从旧往新存储，这些都可以看做有序存储。\n数组本身是支持有序存储的。但是，如果你给数组加上了限定条件，那么数组就会损失一部分能力了。比如说，栈也是使用数组实现的，但是它限定了只能后进先出，这样就失去了数组的随机访问能力(也失去了按值从小到大有序输出的能力)。\n而哈希表限定了“用对象的哈希值作为下标直接存储和访问”，因此，哈希表中的数据是零散的，不连续的，也无法按照存入时间或者大小有序访问。如果你把数据进行了整理，那么就会失去哈希表的“用对象的哈希值作为下标直接存储和访问”的特点了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593172141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2053679,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/56/2f/4518f8e1.jpg","nickname":"放不下荣华富贵","note":"","ucode":"9FE29C22B9ABE3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578362,"discussion_content":"想象ABC三个key，A映射到数组位置3,B映射到7,C又映射到3,如何确定你插入的顺序？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656670424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204471,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1586404190,"is_pvip":false,"replies":[{"id":"76467","content":"你的思考很细致！非常好！<br>1.链表保持一个虚的链表头，这样会更易于操作。<br>2.扩容时机其实不是等到数组满时才扩容，而是在装载因子超过一定阈值时就会触发。否则哈希表的效率会很差了。<br>3.一般来说，哈希表是不允许插入重复的key的，会覆盖。不过也有改造的支持重复key的哈希表，如multiHashMap。<br>4.关于多个哈希函数的问题，其实有两个哈希函数就可以生成多个不相关的哈希函数。假设有两个哈希函数f1和f2，那么f3=f1+2*f2，f4=f1+3*f2，以此类推。因此，双散列的具体公式应该是<br>h(key，i) =( h1(key) + i*h2(key) ) % 数组长度<br><br>","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586413652,"ip_address":"","comment_id":204471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10176338782","product_id":100048401,"comment_content":"看了一下评论区和老师的回复，先回答问题：<br>1. 链表法删除元素: 用Hash(Key)找到对应的下标，根据下标在数组找到了这个节点 node = table[index]，那删除就可以直接 node = node.next；这里数组里存的不是虚头节点呀，是真实的元素呀？<br><br>2. 开放寻址法中的 线性探测、二次线性探测、双散列也好，都是在得到的index 对应的table[index] != null 的情况下，以不同形式继续找，<br>那我想问一下老师，这里table[index] != null 的时候，会比较 已存在元素 和 待插入元素的 key 吗? 也就是说， 开放寻址法是否允许key相同的元素存在呢?<br>因为我看文章，在开放寻址法中，只是判断 计算出来位置对应的元素是否存在，并没有比较存在时，两者的key是否相同。 如果允许元素的key相同，这样会影响删除方式。<br><br>如果允许key相同的元素存在，删除的时候应该用同样的开放寻址法找到最后一个不为空 且key相同的元素置为null。<br>如果不允许key相同的元素存在，那就像老师给其他同学评论的，a b c计算出的hash值相同，位置连续， 删除b，会出现空洞的情况，影响这一局部元素的插入 删除 查询。老师给出的方法是：增加标记位，删除为true，<br>查询、删除遇到删除=true的情况可以继续往后找，新增元素 遇到 删除=true的时候可以直接替换，并修改状态为false;<br><br>疑问:<br>a. 不管是 线性探测法、二次探测法、双散列，只要到了数组最后一个元素发现是满的时候，就会扩容 产生rehash吗？<br>b. 不论是 线性探测法、二次探测法、双散列，他们在插入元素的时候，会比较已存在元素和待插入元素的key是否相同吗？也就是说允许key重复的元素出现吗？<br>c. 线性探测法步长为1，二次探测法采用index = index + 2^i (i为第几次探测)进行探测、<br>我想问的是双散列，第一次通过Hash(Key)得到的index位置上有元素，那么第二次的Hash函数是不是就是上一次用到的Hash函数呢? 另外，每次Hash的时候，其中的key是怎么变的啊？<br><br>字有点多，恳请老师见谅～！","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491192,"discussion_content":"你的思考很细致！非常好！\n1.链表保持一个虚的链表头，这样会更易于操作。\n2.扩容时机其实不是等到数组满时才扩容，而是在装载因子超过一定阈值时就会触发。否则哈希表的效率会很差了。\n3.一般来说，哈希表是不允许插入重复的key的，会覆盖。不过也有改造的支持重复key的哈希表，如multiHashMap。\n4.关于多个哈希函数的问题，其实有两个哈希函数就可以生成多个不相关的哈希函数。假设有两个哈希函数f1和f2，那么f3=f1+2*f2，f4=f1+3*f2，以此类推。因此，双散列的具体公式应该是\nh(key，i) =( h1(key) + i*h2(key) ) % 数组长度\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586413652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201370,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1585756853,"is_pvip":false,"replies":[{"id":"75350","content":"“立个flag”其实是蛮有用的事情。你会发现，在许多系统中，删除其实代价都不小，因此，许多系统对于删除操作都分为了“立flag”，“事后清理”的机制。<br>比如说，操作系统删除文件，就会先放入垃圾箱；<br>再比如说，数据库设计时，也经常会为数据设立一个“是否有效”的字段，删除其实是将字段状态修改。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585788585,"ip_address":"","comment_id":201370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175691445","product_id":100048401,"comment_content":"原来处理冲突还可以用“开放寻址”的方法！又学习了通过flag标记可以解决删除问题。强大的flag，环形数组也用了这个标记，让实现变简单了，还给flag起了个拉风的名字“哨兵”","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490314,"discussion_content":"“立个flag”其实是蛮有用的事情。你会发现，在许多系统中，删除其实代价都不小，因此，许多系统对于删除操作都分为了“立flag”，“事后清理”的机制。\n比如说，操作系统删除文件，就会先放入垃圾箱；\n再比如说，数据库设计时，也经常会为数据设立一个“是否有效”的字段，删除其实是将字段状态修改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585788585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196224,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1585262290,"is_pvip":true,"replies":[{"id":"74418","content":"是的。直接删除会有问题。探查链条会被终止。<br>局部敏感哈希能在距离信息进行一定的保留，因此在近似检索中是一个方案。在进阶篇我会介绍。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585281272,"ip_address":"","comment_id":196224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175196882","product_id":100048401,"comment_content":"不能，这样不能和数据不存在的情况区分，链表法就可以了，核心考量是冲突元素是否是聚集的。<br>hash 表中的hash 是一个将key 转化成数组下标的映射关系，我们这里只讲到这个转化尽可能的均匀的散列，但如果加上尽可能保留原始key 空间的距离大小信息(以前我学降维得出的结论是数据降维要做的事情是把你想从高维空间保留的信息尽可能在数据的低维表示上同样成立)，是否就可以在一定程度上解决hash 完全没法做范围查询的缺陷，好早之前看过点局部敏感hash 的一些东东，想来应该可以结合。","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489244,"discussion_content":"是的。直接删除会有问题。探查链条会被终止。\n局部敏感哈希能在距离信息进行一定的保留，因此在近似检索中是一个方案。在进阶篇我会介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585281272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196342,"user_name":"柏油","can_delete":false,"product_type":"c1","uid":1604468,"ip_address":"","ucode":"92BFEEEE8BBFA0","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/74/9b88e040.jpg","comment_is_top":false,"comment_ctime":1585274417,"is_pvip":false,"replies":[{"id":"74422","content":"很正确。直接删除会打断探查序列。因此，需要加入特殊标志，表示这是被删除的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585282329,"ip_address":"","comment_id":196342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880241713","product_id":100048401,"comment_content":"开放寻址法从理论上讲应该也是可以删除的，不过稍微麻烦些，需要保证同一hash值删除的key前后元素串联性，以保证此hash值在删除当前key之后的元素能被寻址到，可以用特殊值代替，但是在检索时可能会遍历这些特殊值 效率上更低；而链表法则可以很好的支持删除","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489269,"discussion_content":"很正确。直接删除会打断探查序列。因此，需要加入特殊标志，表示这是被删除的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585282329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300405,"user_name":"快跑","can_delete":false,"product_type":"c1","uid":1564645,"ip_address":"","ucode":"90ED7E6D40C58E","user_header":"https://static001.geekbang.org/account/avatar/00/17/df/e5/65e37812.jpg","comment_is_top":false,"comment_ctime":1625143328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625143328","product_id":100048401,"comment_content":"在 JDK1.8 之后，Java 中 HashMap 的实现就是在链表到了一定的长度时，将它转为红黑树<br>这块有几个疑问，我也没从源码中找到答案<br>1、链表到了一定的长度时这个长度是多长？<br>2、用红黑树结构，是因为这个场景需要用树结构，然后红黑树是最适合在内存中查询的原因吗","like_count":0},{"had_liked":false,"id":290886,"user_name":"benny","can_delete":false,"product_type":"c1","uid":1123043,"ip_address":"","ucode":"E2F30AF0C808D9","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","comment_is_top":false,"comment_ctime":1619834077,"is_pvip":false,"replies":[{"id":"105516","content":"是的。空间越大，空闲位置越多，散列就有可能可能均匀分布。否则很容易发生冲突。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1620221346,"ip_address":"","comment_id":290886,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1619834077","product_id":100048401,"comment_content":"就是哈希表要足够大和有足够的空闲位置 这里空间大也是为了进行hash计算时可以更好的散列吧？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519306,"discussion_content":"是的。空间越大，空闲位置越多，散列就有可能可能均匀分布。否则很容易发生冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620221346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287062,"user_name":"森林木","can_delete":false,"product_type":"c1","uid":1220089,"ip_address":"","ucode":"79A06FCC43673B","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/f9/b98d9c40.jpg","comment_is_top":false,"comment_ctime":1617763980,"is_pvip":true,"replies":[{"id":"104266","content":"是的，开放寻址法如果直接删除，会影响到后续元素的检索。因此对于开放寻址法的删除操作是通过加上标识来解决。这也是一种很经典的处理删除数据的方法。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1617809473,"ip_address":"","comment_id":287062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617763980","product_id":100048401,"comment_content":"如果使用开放寻址法，不能直接删除否则会影响后面的检索;如果是链表法则无所谓","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518180,"discussion_content":"是的，开放寻址法如果直接删除，会影响到后续元素的检索。因此对于开放寻址法的删除操作是通过加上标识来解决。这也是一种很经典的处理删除数据的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617809473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275329,"user_name":"一粒","can_delete":false,"product_type":"c1","uid":1582813,"ip_address":"","ucode":"FB5F583CC6AE3C","user_header":"https://static001.geekbang.org/account/avatar/00/18/26/dd/d58156b1.jpg","comment_is_top":false,"comment_ctime":1611473958,"is_pvip":true,"replies":[{"id":"102772","content":"是的。数组是不便于动态改变的，因此需要改变时往往需要做全量重新计算。<br>另一个常用方案是做一个删除标志，先不修改数组，而是等删除标志累计到一定程度再统一处理。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1615713244,"ip_address":"","comment_id":275329,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611473958","product_id":100048401,"comment_content":"数组（哈希表）的大小不能被改变，否则该位置之后存储的元素就找不到了。这和分布式系统中数据分片不能被改变的道理一样。<br>所以，当装载因子过大，需要更换更大的数组时，已存元素的哈希值都要被重新计算才行。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514313,"discussion_content":"是的。数组是不便于动态改变的，因此需要改变时往往需要做全量重新计算。\n另一个常用方案是做一个删除标志，先不修改数组，而是等删除标志累计到一定程度再统一处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615713244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263744,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1606259655,"is_pvip":false,"replies":[{"id":"95727","content":"其实所谓的持久化，就是将内存数据按一定的格式写入文件，然后能解析回到内存。<br>你可以尝试使用hash表的序列化函数，将hash表写入文件完成持久化，然后反序列化读回内存。<br>如果觉得自己实现麻烦，那也可以考虑Redis，Redis是可以持久化到磁盘的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1606319974,"ip_address":"","comment_id":263744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606259655","product_id":100048401,"comment_content":"hash表如何持久化，特别是拉链方式的哈希表的持久化，老师可以给个思路吗？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510284,"discussion_content":"其实所谓的持久化，就是将内存数据按一定的格式写入文件，然后能解析回到内存。\n你可以尝试使用hash表的序列化函数，将hash表写入文件完成持久化，然后反序列化读回内存。\n如果觉得自己实现麻烦，那也可以考虑Redis，Redis是可以持久化到磁盘的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606319974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259322,"user_name":"蚂蚁码代码","can_delete":false,"product_type":"c1","uid":1482973,"ip_address":"","ucode":"6B285A3DC334B3","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/dd/3fccd15e.jpg","comment_is_top":false,"comment_ctime":1604680565,"is_pvip":false,"replies":[{"id":"94577","content":"没错，没有万能的数据结构，只有合适的数据结构。因此只有彻底了解每种数据结构的优缺点，才能将它用在合适的地方。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1605018655,"ip_address":"","comment_id":259322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604680565","product_id":100048401,"comment_content":"搞懂哈希的优缺点 才能将其应用于真正有价值的地方","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508906,"discussion_content":"没错，没有万能的数据结构，只有合适的数据结构。因此只有彻底了解每种数据结构的优缺点，才能将它用在合适的地方。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605018655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229020,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1592881107,"is_pvip":false,"replies":[{"id":"84524","content":"对于开放寻址法实现的哈希表，的确不能直接删除元素，否则会打断探查序列。不过如果每次删除一个元素都要重建后续元素的话，这样的调整代价会过大，因此更常见的解决方案是增加一个flag标志，标明这个元素是被删除的，这样就不需要直接重建后续元素，而是可能等到删除标志积累到了一定量以后统一做一次哈希表重建。<br>链表法的确可以直接删除，这是因为链表或红黑树的调整代价都比较小。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1592911645,"ip_address":"","comment_id":229020,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592881107","product_id":100048401,"comment_content":"假设一个哈希表是使用开放寻址法实现的，如果我们需要删除其中一个元素，可以直接删除吗？为什么呢？如果这个哈希表是使用链表法实现的会有不同吗？<br><br>1、不能直接删除，需要重建后续元素。因为直接删除导致Key位置上没有值，下次检索导致查不到对应Key的Value。<br>2、链表法可以找到对应的Key删除，但要重建冲突Key的链表或树。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499301,"discussion_content":"对于开放寻址法实现的哈希表，的确不能直接删除元素，否则会打断探查序列。不过如果每次删除一个元素都要重建后续元素的话，这样的调整代价会过大，因此更常见的解决方案是增加一个flag标志，标明这个元素是被删除的，这样就不需要直接重建后续元素，而是可能等到删除标志积累到了一定量以后统一做一次哈希表重建。\n链表法的确可以直接删除，这是因为链表或红黑树的调整代价都比较小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592911645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227301,"user_name":"揭萍","can_delete":false,"product_type":"c1","uid":1875704,"ip_address":"","ucode":"8EE72B71173258","user_header":"https://static001.geekbang.org/account/avatar/00/1c/9e/f8/6dd8b072.jpg","comment_is_top":false,"comment_ctime":1592355282,"is_pvip":false,"replies":[{"id":"83793","content":"如果key2的位置没有被抢占，那么key2的插入和查询都是一次寻址操作就可以了。但如果key2的位置被key3抢占了，那么当key2要插入时，第1次寻址是失败的(因为位置被key3占了)，需要进行第2次寻址，找到空位才能插入。因此插入时的寻址代价就会变高。查询时也一样，第一次寻址发现值是key3，因此需要第二次寻址，找到key2才能读取数据。<br>更恶劣的情况是，假设key1，key3，key4三个元素的哈希值是一样的。那么在插入了这三个元素后再插入key2，那么key2要进行三次寻址才能找到空位(key3和key4会占据key2应在的位置，使得key2的寻址时间增加)。<br>这种情况叫做聚集效应，你会看到整个系统中key2的哈希值是唯一的，但是它依然会受到key1，key3，key4的影响。因此我们才需要使用“二次探查”和“双散列”来解决这个问题。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1592360106,"ip_address":"","comment_id":227301,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592355282","product_id":100048401,"comment_content":"如果我们在插入 key1 后，先插入 key3 再插入 key2，那 key3 就会抢占 key2 的位置，影响 key2 的插入和查询效率。<br>请问为什么会影响key2呢?","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498582,"discussion_content":"如果key2的位置没有被抢占，那么key2的插入和查询都是一次寻址操作就可以了。但如果key2的位置被key3抢占了，那么当key2要插入时，第1次寻址是失败的(因为位置被key3占了)，需要进行第2次寻址，找到空位才能插入。因此插入时的寻址代价就会变高。查询时也一样，第一次寻址发现值是key3，因此需要第二次寻址，找到key2才能读取数据。\n更恶劣的情况是，假设key1，key3，key4三个元素的哈希值是一样的。那么在插入了这三个元素后再插入key2，那么key2要进行三次寻址才能找到空位(key3和key4会占据key2应在的位置，使得key2的寻址时间增加)。\n这种情况叫做聚集效应，你会看到整个系统中key2的哈希值是唯一的，但是它依然会受到key1，key3，key4的影响。因此我们才需要使用“二次探查”和“双散列”来解决这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592360106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205543,"user_name":"阿斯蒂芬","can_delete":false,"product_type":"c1","uid":1024164,"ip_address":"","ucode":"61D5E3BDA4EBC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","comment_is_top":false,"comment_ctime":1586668620,"is_pvip":false,"replies":[{"id":"76777","content":"你的思考非常好！你提的这两点都是在工程中需要考虑到的效率问题。你往下看第四讲，你就会发现，为了节省一次哈希计算，我们可以在合适的场景下直接用位图；还有布隆过滤器其实就是使用开放寻址法解决冲突的思路。<br>就如你所说，所有的实现都有利有弊，我们要熟悉它们，然后考虑“实际场景”，才能做出合理的设计和实现","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586678160,"ip_address":"","comment_id":205543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586668620","product_id":100048401,"comment_content":"哈希（散列）算得上是基础常用的top3数据结构了吧。<br>写几点感悟：<br>一：散列函数的耗时为什么被「忽略」？<br>之前在阅读《算法图解》中，散列表有一段这样的描述：<br>「你结合使用散列函数和数组创建了一种被称为散列表（hashtable）的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构」<br>我觉得这个「包含额外逻辑」从一个特别的角度描述了散列表的特性。比起数组和链表家族，散列表的存取阶段都多了一步「计算散列（哈希）值并映射」的过程，其实这个就是额外的逻辑。然而经常在讨论散列表的性能时，通常会「达成共识忽略」这一步的性能和具体实现细节。其实为什么呢？<br>尝试理解下：就如老师举例说明的使用英文字母序号做系数再加上二十六进制指数的「魔法」一样，散列值的本质就是「计算」，而恰恰现代计算机最强的功能之一就是计算，感谢数学家和计算机科学家的努力，发明高效且分布均匀的散列函数，可以说几乎对大多数程序员的大多数场景下都是透明的，我们可以接近将这一步骤当作常数级别的耗时，因此在分析散列表的总耗时的时候，可以愉快地忽略，而只需要关注真正用于检索的耗时，比如定位到了索引后可能需要的内存交互甚至磁盘交互的耗时。<br><br>二：开放寻址法如此「不堪」，有什么应用场景？<br>虽然讲到散列冲突的解决方案，开放寻址法总是第一个拿出来被「锤」，但是既然天天被吊打，为什么还要学，实际有什么用处？这里又到了应用「实际场景」的思维模型了。Java的ThreadLocal用来存储线程隔离的本地变量，其中有个ThreadLocalMap散列结构，内部解决散列冲突的策略就是开放寻址法。为什么它会这么淡定使用呢，个人理解还是因为它的使用场景相对简单，一般往ThreadLocal中存放的数据量不大，使用开放寻址而不是链表法，节省了链表的指针开销，而且兼顾了效率，ThreadLocalMap的场景非常契合开放寻址的优点。<br><br>以上两点感悟还处于自我总结阶段，没有很多查证，还望老师指点。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491508,"discussion_content":"你的思考非常好！你提的这两点都是在工程中需要考虑到的效率问题。你往下看第四讲，你就会发现，为了节省一次哈希计算，我们可以在合适的场景下直接用位图；还有布隆过滤器其实就是使用开放寻址法解决冲突的思路。\n就如你所说，所有的实现都有利有弊，我们要熟悉它们，然后考虑“实际场景”，才能做出合理的设计和实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586678160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199026,"user_name":"与你一起学算法","can_delete":false,"product_type":"c1","uid":1318001,"ip_address":"","ucode":"A7E03B3E41828E","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/71/f7a7f70f.jpg","comment_is_top":false,"comment_ctime":1585476494,"is_pvip":false,"replies":[{"id":"74741","content":"结论是正确的。不过删除元素并不会改变哈希表的长度。哈希表的长度是固定的。<br>不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585480972,"ip_address":"","comment_id":199026,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585476494","product_id":100048401,"comment_content":"开放寻址法的话应该是不可以的，因为一旦删除的话就会改变哈希表的长度，那样的话所有的元素的位置都会发生改变，不过删除的时候可以把这个位置赋予某个特定的值，用以表示此位置为空。<br>对于链表法的话就不存在上述问题了，就和链表中删除某一个元素一样了。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489779,"discussion_content":"结论是正确的。不过删除元素并不会改变哈希表的长度。哈希表的长度是固定的。\n不能直接删除的问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585480972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198138,"user_name":"阿郑","can_delete":false,"product_type":"c1","uid":1495155,"ip_address":"","ucode":"BBAC6BFCAFC762","user_header":"https://static001.geekbang.org/account/avatar/00/16/d0/73/06ed7823.jpg","comment_is_top":false,"comment_ctime":1585411627,"is_pvip":false,"replies":[{"id":"74679","content":"对于有经验的工程师而言，基础篇可以当做是梳理自己的知识点，并做总结和深入思考。比如说，哈希表结合遍历需求，是一个怎么样的数据结构?在实际场景中能怎么使用?（比如缓存）<br>此外，我会提供基础篇的加餐，你会发现，原来工业界的许多高效实现，都是基于基础篇中的知识完成的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585446093,"ip_address":"","comment_id":198138,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585411627","product_id":100048401,"comment_content":"期待后续的干货","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489653,"discussion_content":"对于有经验的工程师而言，基础篇可以当做是梳理自己的知识点，并做总结和深入思考。比如说，哈希表结合遍历需求，是一个怎么样的数据结构?在实际场景中能怎么使用?（比如缓存）\n此外，我会提供基础篇的加餐，你会发现，原来工业界的许多高效实现，都是基于基础篇中的知识完成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585446093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196415,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1585279534,"is_pvip":true,"replies":[{"id":"74421","content":"本质是要把key作为数组下标。而数组下标是正整数。<br>只要能满足这个目的就好。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585282275,"ip_address":"","comment_id":196415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585279534","product_id":100048401,"comment_content":"哈希表的本质是一个数组，它通过 Hash 函数将查询的 Key 转为数组下标<br>----------------------------<br>这里有个以为 通过Hash 函数计算的结果一定是一个正整数吗？ 还是说可以通过不同的进制，当做正整数","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489291,"discussion_content":"本质是要把key作为数组下标。而数组下标是正整数。\n只要能满足这个目的就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585282275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196382,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1585277456,"is_pvip":false,"replies":[{"id":"74424","content":"即使是这样，也是会出问题的。直接删除会把探查序列中断。<br>举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。<br>因此，真有删除需求的话，我们会通过将删除的元素做一个标志区别，而不是真正删除，这样就能保留探查序列了。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585282510,"ip_address":"","comment_id":196382,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1585277456","product_id":100048401,"comment_content":"老师，如果开放寻址法是采用的二次探查或者双重散列解决冲突，可以直接删除嘛？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489281,"discussion_content":"即使是这样，也是会出问题的。直接删除会把探查序列中断。\n举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。\n因此，真有删除需求的话，我们会通过将删除的元素做一个标志区别，而不是真正删除，这样就能保留探查序列了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585282510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215090,"discussion_content":"如果打破查找不存在的元素时遇到空就不继续查找的前提就可以吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585282922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220572,"discussion_content":"这个追问很好~你可以想想，如果遇到空继续查找，那么查找结束的条件是什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585898626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215090,"ip_address":""},"score":220572,"extra":""}]}]},{"had_liked":false,"id":196314,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1585271901,"is_pvip":false,"replies":[{"id":"74420","content":"结论是正确的。不过理由还不够充分。开放寻址是可以通过线性探查等方式确认映射位置的。问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585282183,"ip_address":"","comment_id":196314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585271901","product_id":100048401,"comment_content":"链表法可以删除，因为key对应的hash都映射到一个节点，所有的值都存在链表上。<br>开放寻址不可以，无法判断key的hash被映射到哪里。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489265,"discussion_content":"结论是正确的。不过理由还不够充分。开放寻址是可以通过线性探查等方式确认映射位置的。问题在于，直接删除会把探查序列中断。举个例子:有三个元素a，b，c的hash值是冲突的，那么探查序列会把他们放在三个位置上，比如1，2，3（探查序列是123），如果我们把b删了，那么2这个位置就空了。这时候，要查询c，探查序列就会在2的位置中断，查不到c。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585282183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196302,"user_name":"千里之行","can_delete":false,"product_type":"c1","uid":1792692,"ip_address":"","ucode":"B2A09E8CA0E059","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEGtB7lUzH66b3nibVu3Xat4C0Wfp0umU3slsN32TF3icBwDOpShgdzMhaLW9z5LDFg3TTh0H62qAA/132","comment_is_top":false,"comment_ctime":1585271136,"is_pvip":false,"replies":[{"id":"74419","content":"是的。很细心。直接删除会造成探查链条被中断，导致本来后面可以查到的，但由于被中断返回了无结果。一般来说，会加一个状态位区分，而不是真正删除。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585281590,"ip_address":"","comment_id":196302,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585271136","product_id":100048401,"comment_content":"Hash表使用开放寻址法的时候，不能直接删除数据。直接删除的话可能形成查询无结果的假象，出现漏查的情况，链表法就不存在这个问题，但应该注意容错，可能会造成空值报错","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489262,"discussion_content":"是的。很细心。直接删除会造成探查链条被中断，导致本来后面可以查到的，但由于被中断返回了无结果。一般来说，会加一个状态位区分，而不是真正删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585281590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196297,"user_name":"刘凯","can_delete":false,"product_type":"c1","uid":1350608,"ip_address":"","ucode":"EFDC932CAE61A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg","comment_is_top":false,"comment_ctime":1585270807,"is_pvip":false,"replies":[{"id":"74404","content":"基础篇主要是介绍一些检索相关的重要数据结构和算法。不过这部分内容和课本上相比，会融入更多工业界的例子。<br>而在后面进阶篇的课程，重点会介绍各种业务中的查询解决方案了。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585271913,"ip_address":"","comment_id":196297,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585270807","product_id":100048401,"comment_content":"老师，后边的课程全是理论吗，有没有讲讲实现某种查询的方案加工具啊，必竞学课的不完全是研究算法的。肯定也有像我这样用于应用的，","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489261,"discussion_content":"基础篇主要是介绍一些检索相关的重要数据结构和算法。不过这部分内容和课本上相比，会融入更多工业界的例子。\n而在后面进阶篇的课程，重点会介绍各种业务中的查询解决方案了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585271913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196293,"user_name":"刘凯","can_delete":false,"product_type":"c1","uid":1350608,"ip_address":"","ucode":"EFDC932CAE61A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg","comment_is_top":false,"comment_ctime":1585270425,"is_pvip":false,"replies":[{"id":"74406","content":"你的直觉很好。结论是正确的。不过理由不够充分哦。你可以再想想，包括好好看看前面两课。<br>其实对于工程师而言，基础还是很重要的。否则，如果使用ES或Lucene，但是不清楚支持它的技术，那么想优化可能都无从下手。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585272388,"ip_address":"","comment_id":196293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585270425","product_id":100048401,"comment_content":"不太理解算法，但感觉在有序的问题上，插入不是其优点，那么感觉删除也不是优点。链表在插上就改变个指针，那么删除肯定也没任何问题。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489260,"discussion_content":"你的直觉很好。结论是正确的。不过理由不够充分哦。你可以再想想，包括好好看看前面两课。\n其实对于工程师而言，基础还是很重要的。否则，如果使用ES或Lucene，但是不清楚支持它的技术，那么想优化可能都无从下手。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585272388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}