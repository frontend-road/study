{"id":484149,"title":"春节刷题计划（二）| 一题三解，搞定版本号判断","content":"<p>你好，我是朱涛。今天是除夕夜，先祝你虎年春节快乐！</p><p>在上节刷题课中，我给你留了一个作业，那就是：用Kotlin来完成 <a href=\"https://leetcode-cn.com/problems/compare-version-numbers/\">LeetCode的165号题《版本号判断》</a>。那么今天这节课，我就来讲讲我的解题思路，希望能给你带来一些启发。</p><p>这道题目其实跟我们平时的工作息息相关。给你两个字符串代表的版本号，需要你判断哪个版本号是新的，哪个版本号是旧的。比如，2.0与1.0对比的话，2.0肯定是新版本，1.0肯定是旧版本。对吧？</p><p>不过，这里面还有一些问题需要留意，这些都是我们在正式写代码之前要弄清楚的。</p><ul>\n<li>首先，版本号是可能以0开头的。比如0.1、1.01，这些都是合理的版本号。</li>\n<li>另外，如果是以0开头的话，1个0和多个0，它们是等价的，比如1.01、1.001、1.00001之间就是等价的，也就是说这几个版本号其实是相等的。</li>\n<li>还有，1.0、1.0.0、1.0.0.0它们之间也是等价的，也就是说这几个版本号也是相等的。</li>\n</ul><h2>思路一</h2><p>好了，理解了题意以后，我们就可以开始写代码了，LeetCode上面给了我们一个待实现的方法，大致如下：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int {\n    // 待完善\n}\n</code></pre><!-- [[[read_end]]] --><p>分析完题目以后，也许你已经发现了，这道题目其实并不需要什么特殊的数据结构和算法基础，这是一道单纯的“模拟题”。我们脑子里是如何对比两个版本号的，我们的代码就可以怎么写。<br>\n下面我做了一个动图，展示了版本号对比的整体流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/25/ab/25a423b14908721aef1dd36082d345ab.gif?wh=1080x608\" alt=\"图片\"></p><p>我们可以看到，这个对比的流程，大致可以分为以下几个步骤。</p><ul>\n<li>第一步，将版本号的字符串用“点号”进行分割，得到两个字符串的列表。</li>\n<li>第二步，同时遍历这两个列表，将列表中的每一个元素转换成整数，比如，当遍历到第二位的时候，5、05这两个字符串，都会转换成数字5。这里<strong>有个细节</strong>，那就是当版本号的长度不一样的时候，比如，遍历到7.05.002.2的最后一位时，7.5.2其实已经越界了，这时候我们需要进行补零，然后再转换成数字。</li>\n<li>第三步，根据转换后的数字进行对比，如果两者相等的话，我们就继续遍历下一位。如果不相等的话，我们就能直接返回对比的结果了。</li>\n<li>第四步，如果两个版本号都遍历到了末尾，仍然没有对比出大小的差异，那么我们就认为这两个版本号相等，返回0即可。</li>\n</ul><p>所以，按照上面的思路，我们可以把compareVersion()这个函数分为以下几个部分：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int {\n    // ① 使用“.”，分割 version1 和 version2，得到list1、list2\n    // ② 同时遍历list1、list2，取出的元素v1、v2，并将其转换成整数，这里注意补零操作\n    // ③ 对比v1、v2的大小，如果它们两者不一样，我们就可以终止流程，直接返回结果。\n    // ④ 当遍历完list1、list2后仍然没有判断出大小话，说明两个版本号其实是相等的，这时候应该返回0\n}\n</code></pre><p>那么接下来，其实就很简单了。我们只需要将注释里面的自然语言，用代码写出来就行了。具体代码如下：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int {\n    // ① 分割\n    val list1 = version1.split(\".\")\n    val list2 = version2.split(\".\")\n\n    var i = 0\n    while (i &lt; list1.size || i &lt; list2.size) {\n        // ② 遍历元素\n        val v1 = list1.getOrNull(i)?.toInt()?:0\n        val v2 = list2.getOrNull(i)?.toInt()?:0\n\n        // ③ 对比\n        if (v1 != v2) {\n            return v1.compareTo(v2)\n        }\n        i++\n    }\n\n    // ④ 相等\n    return 0\n}\n</code></pre><p>在上面的代码中，有两个地方需要格外注意。</p><p><strong>一个是while循环的条件</strong>。由于list1、list2的长度可能是不一样的，所以，我们的循环条件是：list1、list2当中只要有一个没有遍历完的话，我们就要继续遍历。</p><p>还有一个需要注意的地方，<strong>getOrNull(i)，这是Kotlin独有的库函数</strong>。使用这个方法，我们不必担心越界问题，当index越界以后，这个方法会返回null，在这里我们把它跟 <a href=\"https://time.geekbang.org/column/article/472154\">Elvis表达式</a>结合起来，就实现了自动补零操作。这也体现出了Kotlin表达式语法的优势。</p><p>好，到这里，我们就用第一种思路实现了版本号对比的算法。下面我们再来看看第二种思路。</p><h2>思路二</h2><p>前面的思路，我们是使用的Kotlin的库函数split()进行分割，然后对列表进行遍历来判断的版本号。其实，这种思路还可以<strong>进一步优化</strong>，那就是我们自己遍历字符串，来模拟split的过程，然后在遍历过程中，我们顺便就把比对的工作一起做完了。</p><p>思路二的整体过程比较绕，我同样是制作了一个动图来描述这个算法的整体流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/67/dd6a09c1428892c7dc5a52623842d067.gif?wh=1080x608\" alt=\"图片\"></p><p>以上的整体算法过程，是典型的“<strong>双指针</strong>”思想。运用这样的思想，我们大致可以写出下面这样的代码：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int {\n    val length1 = version1.length\n    val length2 = version2.length\n\n    // ①\n    var i = 0\n    var j = 0\n    // ②\n    while (i &lt; length1 || j &lt; length2) {\n        // ③\n        var x = 0\n        while (i &lt; length1 &amp;&amp; version1[i] != '.') {\n            x = x * 10 + version1[i].toInt() - '0'.toInt()\n            i++\n        }\n        i++\n\n        // ④\n        var y = 0\n        while (j &lt; length2 &amp;&amp; version2[j] != '.') {\n            y = y * 10 + version2[j].toInt() - '0'.toInt()\n            j++\n        }\n        j++\n\n        // ⑤\n        if (x != y) {\n            return x.compareTo(y)\n        }\n    }\n    // ⑥\n    return 0\n}\n</code></pre><p>这段代码一共有6个注释，我们来一个个解释。</p><ul>\n<li>注释①，代表的就是我们遍历两个版本号的index，双指针，指的就是它们两个。</li>\n<li>注释②，最外层的while循环，其实就是为了确保双指针可以遍历到两个字符串的末尾。你注意下这里的循环条件，只要version1、version2当中有一个没到末尾，就会继续遍历。</li>\n<li>注释③，这里就是在遍历version1，一直到字符串末尾，或者遇到“点号”。在同一个循环当中，我们会对x的值进行累加，这个做法其实就是把字符串的数字转换成十进制的数字。</li>\n<li>注释④，这里和注释③的逻辑一样，只是遍历的对象是version2。</li>\n<li>注释⑤，这里会对累加出来的x、y进行对比，不相同的话，我们就可以返回结果了。</li>\n<li>注释⑥，如果遍历到末尾还没有结果，这就说明version1、version2相等。</li>\n</ul><p>现在，我们就已经用Kotlin写出了两个题解，使用的思路都是命令式的编程方式。也许你会好奇，<strong>这个问题能用函数式的思路来实现吗？</strong></p><p>答案当然是可以的！</p><h2>思路三</h2><p>我们在前面就提到过，Kotlin是支持多范式的，我们可以根据实际场景来灵活选择编程范式。那么在这里，我们可以借鉴一下前面第一种解法的思路。</p><p>其实，想要解决这个问题，我们只要能把version1、version2转换成两个整数的列表，就可以很好地进行对比了。我制作了一个动图，方便你理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/32/eea4765d618437d7145ae77c8e404a32.gif?wh=1080x608\" alt=\"图片\"></p><p>根据这个流程，我们可以大致写出下面这样的代码：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(\".\")\n        .zipLongest(version2.split(\".\"), \"0\") // ①\n        .onEach { // ②\n            with(it) {\n                if (first != second) {\n                    return first.compareTo(second)\n                }\n            }\n        }.run { return 0 }\n</code></pre><p>这段代码看起来很简洁，核心的逻辑在两个方法当中，我分别用注释标注了。</p><ul>\n<li>注释①，zipLongest()这个方法，它的作用是将version1、version2对应的列表合并到一起，它返回值的类型是List&lt;Pair&lt;Int, Int&gt;&gt;。</li>\n<li>注释②，onEach()，其实它是一个高阶函数，它的作用就是遍历List当中的每一个Pair，将其中的整型版本号拿出来对比，如果不一样，就可以直接返回结果。</li>\n</ul><p>现在，你可能会感慨，这代码看起来真香啊！这个嘛……别高兴得太早。虽然Kotlin支持基础的zip语法，但它目前还不支持zipLongest()这么高级的操作符。</p><p>那么这该怎么办呢？我们只能自己来实现zipLongest()了！为了让前面的代码通过编译，我们必须要自己动手实现下面三个扩展函数。</p><pre><code class=\"language-plain\">private fun Iterable&lt;String&gt;.zipLongest(\n    other: Iterable&lt;String&gt;,\n    default: String\n): List&lt;Pair&lt;Int, Int&gt;&gt; {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() || second.hasNext()) {\n        val v1 = (first.nextOrNull() ?: default).toInt()\n        val v2 = (second.nextOrNull() ?: default).toInt()\n        list.add(Pair(v1, v2))\n    }\n    return list\n}\n\nprivate fun &lt;T&gt; Iterable&lt;T&gt;.collectionSizeOrDefault(default: Int): Int =\n        if (this is Collection&lt;*&gt;) this.size else default\n\nprivate fun &lt;T&gt; Iterator&lt;T&gt;.nextOrNull(): T? = if (hasNext()) next() else null\n\n// Pair 是Kotlin标准库提供的一个数据类\n// 专门用于存储两个成员的数据\n// 提交代码的时候，Pair不需要拷贝进去\npublic data class Pair&lt;out A, out B&gt;(\n    public val first: A,\n    public val second: B\n) : Serializable {\n    public override fun toString(): String = \"($first, $second)\"\n}\n</code></pre><p>这三个扩展函数实现起来还是比较简单的，zipLongest()其实就是合并了两个字符串列表，然后将它们按照index合并成Pair，另外那两个扩展函数都只是起了辅助作用。</p><p>这样，我们把前面的代码一起粘贴到LeetCode当中，其实代码是可以通过的。不过呢，我们的代码当中其实还有一个<strong>比较深的嵌套</strong>，看起来不是很顺眼：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(\".\")\n        .zipLongest(version2.split(\".\"), \"0\")\n        .onEach {\n            // 这里的嵌套比较深\n            with(it) {\n                if (first != second) {\n                    return first.compareTo(second)\n                }\n            }\n        }.run { return 0 }\n</code></pre><p>你可以注意到，在onEach当中，有一个代码块，它有两层嵌套，这看起来有点丑陋。那么，我们能不能对它进一步优化呢？</p><p>当然是可以的。</p><p>这里，我们只需要想办法让onEach当中的Lambda，变成<a href=\"https://time.geekbang.org/column/article/476637\">带接收者的函数类型</a>即可。具体做法就是，我们自己实现一个新的onEachWithReceiver()的高阶函数。</p><pre><code class=\"language-plain\">//                                                        注意这里\n//                                                           ↓\ninline fun &lt;T, C : Iterable&lt;T&gt;&gt; C.onEachWithReceiver(action: T.() -&gt; Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n//                                                   注意这里\n// Kotlin库函数当中的onEach                                ↓\npublic inline fun &lt;T, C : Iterable&lt;T&gt;&gt; C.onEach(action: (T) -&gt; Unit): C {\n    return apply { for (element in this) action(element) }\n}\n</code></pre><p>上面的代码展示了onEach()和onEachWithReceiver()之间的差别，可以看到，它们两个的函数体其实没有任何变化，区别只是action的函数类型而已。</p><p>所以在这里，借助onEachWithReceiver()，就可以进一步简化我们的代码：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(\".\")\n        .zipLongest(version2.split(\".\"), \"0\")\n        .onEachWithReceiver {\n            // 减少了一层嵌套\n            if (first != second) {\n                return first.compareTo(second)\n            }\n        }.run { return 0 }\n</code></pre><p>在这段代码中，我们把onEach()改成了onEachWithReceiver()，因为它里面的Lambda是带有接收者，原本的Pair对象变成了this对象，这样，我们就可以直接使用first、second来访问Pair当中的成员了。</p><p>现在，就让我们来看看整体的代码吧：</p><pre><code class=\"language-plain\">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(\".\")\n        .zipLongest(version2.split(\".\"), \"0\")\n        .onEachWithReceiver {\n            if (first != second) {\n                return first.compareTo(second)\n            }\n        }.run { return 0 }\n\nprivate inline fun &lt;T, C : Iterable&lt;T&gt;&gt; C.onEachWithReceiver(action: T.() -&gt; Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\nprivate fun &lt;T&gt; Iterable&lt;T&gt;.collectionSizeOrDefault(default: Int): Int =\n    if (this is Collection&lt;*&gt;) this.size else default\n\nprivate fun &lt;T&gt; Iterator&lt;T&gt;.nextOrNull(): T? = if (hasNext()) next() else null\n\nprivate fun Iterable&lt;String&gt;.zipLongest(\n    other: Iterable&lt;String&gt;,\n    default: String\n): List&lt;Pair&lt;Int, Int&gt;&gt; {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() || second.hasNext()) {\n        val v1 = (first.nextOrNull() ?: default).toInt()\n        val v2 = (second.nextOrNull() ?: default).toInt()\n        list.add(Pair(v1, v2))\n    }\n    return list\n}\n</code></pre><p>好了，这就是我们的第三种思路。看完这三种思路以后，你会更倾向于哪种思路呢？</p><h2>小结</h2><p>这节课，我们使用了三种思路，实现了<a href=\"https://leetcode-cn.com/problems/compare-version-numbers/\">LeetCode的165号题《版本号判断》</a>。其中，前两种思路，是命令式的编程方式，第三种是偏函数式的方式。在我看来呢，这三种方式各有优劣。</p><ul>\n<li>思路一，代码逻辑比较清晰，代码量小，时间复杂度、空间复杂度较差。</li>\n<li>思路二，代码逻辑比较复杂，代码量稍大，时间复杂度、空间复杂度非常好。</li>\n<li>思路三，代码主逻辑非常清晰，代码量大，时间复杂度、空间复杂度较差。</li>\n</ul><p>第三个思路其实还有一个额外的优势，那就是，我们自己实现的扩展函数，可以用于以后解决其他问题。这就相当于沉淀出了有用的工具。</p><h2>小作业</h2><p>好，最后，我还是给你留一个小作业，请你用Kotlin来完成<a href=\"https://leetcode-cn.com/problems/solve-the-equation/\">LeetCode的640号题《求解方程》</a>。这道题目我同样会在下节课给出答案解析。</p><p>欢迎继续给我留言，我们下节课再见。</p>","neighbors":{"left":{"article_title":"春节刷题计划（一）| 当Kotlin遇上LeetCode","id":482822},"right":{"article_title":"春节刷题计划（三）| 一题双解，搞定求解方程","id":484366}},"comments":[{"had_liked":false,"id":332791,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1643610863,"is_pvip":true,"replies":[{"id":"121647","content":"嗯，完全理解你的意思。解法三，我写出来的目的也是想让大家看到Kotlin也有不擅长的领域，也是为了展示它丑陋的一面。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643720491,"ip_address":"","comment_id":332791,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23118447343","product_id":100103401,"comment_content":"方法三有点一言难尽吧...<br><br>尝试写一个python的版本：<br><br>```python<br>class Solution:<br>    def compareVersion(self, ver1: str, ver2: str) -&gt; int:<br>        to_nums = lambda ver: map(int, ver.split(&#39;.&#39;))<br>        zipped = zip_longest(*map(to_nums, [ver1, ver2]), fillvalue=0)<br>        cmp = lambda a, b: (a &gt; b) - (a &lt; b) <br>        return next((i for i in starmap(cmp, zipped) if i != 0), 0)<br>        # return next(filter(lambda x: x != 0, starmap(cmp, zipped)), 0)<br>```<br><br>文中的zipLongest实现接受Iterable&lt;String&gt;，返回List&lt;Pair&lt;Int, Int&gt;&gt;。这意味：<br><br>1. 输入是Iterable，输出成了List。这样就不适用于输入长度无限的情况，或是可以惰性求值的情况。在本题中，因为只要遇到第一个不相同的子版本号就可以返回，所以可以不用生成完整的List，正好是可以利用惰性求值的情况；<br><br>2. 输入Iterable的基类型是String，输出Pair的基类型是Int，这就把类型转换写死在了实现里，让实现失去了通用性，即便沉淀出来可能用途也有限吧；<br><br>3. 文中的实现只支持一个Iterable与另一个Iterable进行zip，而python的实现支持任意多个。<br><br>这里不是要抬杠，只是想说各种语言的不同特性会形成不同的惯用法，强行使用另一种语言的惯用法可能会显得不伦不类。如有冒犯还请见谅。","like_count":6,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549199,"discussion_content":"嗯，完全理解你的意思。解法三，我写出来的目的也是想让大家看到Kotlin也有不擅长的领域，也是为了展示它丑陋的一面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643720491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338754,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1647700586,"is_pvip":true,"replies":[{"id":"124019","content":"很不错，毕竟标准库里就有zip，省事。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648031101,"ip_address":"","comment_id":338754,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647700586","product_id":100103401,"comment_content":"这样写也算比较简洁把：<br> val list1 = version1.split(&quot;.&quot;)<br>        val list2 = version2.split(&quot;.&quot;)<br>        val result = list1.zip(list2) { v1, v2 -&gt; Pair(v1.toInt(), v2.toInt()) }<br>            .onEach {<br>                if (it.first != it.second) {<br>                   return it.first.compareTo(it.second)<br>                }<br>            }.run { return  list1.size - list2.size }","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557965,"discussion_content":"很不错，毕竟标准库里就有zip，省事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648031101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2261626,"avatar":"","nickname":"Geek_0386e5","note":"","ucode":"40AF296ED8CC3D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":581640,"discussion_content":"“0.0” vs “0.0.0” 会错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658905659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":557965,"ip_address":""},"score":581640,"extra":""}]}]},{"had_liked":false,"id":336573,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1646220096,"is_pvip":false,"replies":[{"id":"123029","content":"哈哈哈~仅用于学习用途。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646275673,"ip_address":"","comment_id":336573,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646220096","product_id":100103401,"comment_content":"工作中谁敢用方法三，我保准让他默写十遍！","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554233,"discussion_content":"哈哈哈~仅用于学习用途。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646275673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336570,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1646219358,"is_pvip":false,"replies":[{"id":"123028","content":"这思路不错。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646275627,"ip_address":"","comment_id":336570,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646219358","product_id":100103401,"comment_content":"解法二稍加封装了一下<br><br>fun compareVersion(version1: String, version2: String): Int {<br>    val v1 = Version(0, 0, version1)<br>    val v2 = Version(0, 0, version2)<br><br>    while (v1.index &lt; version1.length || v2.index &lt; version2.length) {<br>        v1.dealVersion()<br>        v2.dealVersion()<br>        if (v1.subValue != v2.subValue) {<br>            return v1.subValue.compareTo(v2.subValue)<br>        }<br>    }<br>    return 0<br>}<br><br>data class Version(var index: Int, var subValue: Int, var text: String) {<br>    fun dealVersion(): Version {<br>        subValue = 0<br>        while (index &lt; text.length &amp;&amp; text[index] != &#39;.&#39;) {<br>            subValue = subValue * 10 + text[index].toInt() - &#39;0&#39;.toInt()<br>            index++<br>        }<br>        index++<br>        return this<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554232,"discussion_content":"这思路不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646275628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335061,"user_name":"Geek_Adr","can_delete":false,"product_type":"c1","uid":2876897,"ip_address":"","ucode":"129E17B7D3EB88","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e5/e1/a5064f88.jpg","comment_is_top":false,"comment_ctime":1645280094,"is_pvip":false,"replies":[{"id":"122415","content":"这个思路有点意思，大家可以来看看。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645370540,"ip_address":"","comment_id":335061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645280094","product_id":100103401,"comment_content":"class Solution {<br>    &#47;&#47; ax+b<br>    &#47;&#47; symbol 和 tmp 都是处理表达式临时变量<br>    data class Expr(var a: Int, var b: Int, var symbol: Int, var tmp: String)<br><br>    fun solveEquation(equation: String): String {<br>        return equation<br>            .split(&quot;=&quot;)&#47;&#47; 1、分成前后两个部分<br>            .map {&#47;&#47; 2、处理表达式为 ax+b<br>                &quot;$it+&quot;&#47;&#47;骚操作加&quot;+&quot;：防止表达式最后一点丢失处理<br>                    .fold(Expr(0, 0, 1, &quot;&quot;)) { acc, c -&gt;<br>                        when (c) {<br>                            &#39;+&#39;, &#39;-&#39; -&gt; {<br>                                if (acc.tmp.contains(&quot;x&quot;)) {<br>                                    acc.a += acc.symbol * acc.tmp.replace(&quot;x&quot;, &quot;&quot;).ifBlank { &quot;1&quot; }.toInt()<br>                                } else {<br>                                    acc.b += acc.symbol * acc.tmp.ifBlank { &quot;0&quot; }.toInt()<br>                                }<br>                                acc.symbol = if (c == &#39;+&#39;) 1 else -1<br>                                acc.tmp = &quot;&quot;<br>                            }<br>                            else -&gt; {<br>                                acc.tmp += c<br>                            }<br>                        }<br>                        acc<br>                    }<br><br>            }.reduce { acc, expr -&gt; &#47;&#47; 3、前段 减 后段<br>                acc.a -= expr.a<br>                acc.b -= expr.b<br>                acc<br>            }.run {<br>                when {<br>                    a == 0 &amp;&amp; b != 0 -&gt; &quot;No solution&quot;<br>                    a == 0 -&gt; &quot;Infinite solutions&quot;<br>                    else -&gt; &quot;x=${-1 * b &#47; a}&quot;<br><br>                }<br>            }<br>    }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552275,"discussion_content":"这个思路有点意思，大家可以来看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645370540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334733,"user_name":"苹果是我咬的","can_delete":false,"product_type":"c1","uid":2065541,"ip_address":"","ucode":"4C79D0A9454A7D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/84/85/0a75ada7.jpg","comment_is_top":false,"comment_ctime":1645093912,"is_pvip":false,"replies":[{"id":"122300","content":"代码写的不错，条理清晰，最后的if判断可以考虑换成when哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645151166,"ip_address":"","comment_id":334733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645093912","product_id":100103401,"comment_content":"class Solution {<br>    fun solveEquation(equation: String): String {<br>        val eq = equation.replace(&quot;-&quot;, &quot;+-&quot;).split(&quot;=&quot;)<br>        val (lx, ln) = parse(eq[0])<br>        val (rx, rn) = parse(eq[1])<br>        val x = lx - rx<br>        val n = rn - ln<br>        return if (x == 0 &amp;&amp; n != 0) {<br>            &quot;No solution&quot;<br>        } else if (x == 0 &amp;&amp; n == 0) {<br>            &quot;Infinite solutions&quot;<br>        } else {<br>            &quot;x=${ n &#47; x }&quot;<br>        }<br>    }<br><br>    fun parse(eq: String): Pair&lt;Int, Int&gt; {<br>        val exp = eq.split(&quot;+&quot;)<br>        var (x, n) = 0 to 0<br>        exp.filter { !it.contains(&quot;x&quot;) &amp;&amp; it != &quot;&quot; }<br>            .forEach { n += it.toInt() }<br>        exp.filter { it.contains(&quot;x&quot;) }<br>            .forEach {<br>                x += if (it.length == 1 || it.length == 2 &amp;&amp; it[0] == &#39;-&#39;) it.replace(&quot;x&quot;, &quot;1&quot;).toInt()<br>                else it.replace(&quot;x&quot;, &quot;&quot;).toInt()<br>            }<br>        return x to n<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551835,"discussion_content":"代码写的不错，条理清晰，最后的if判断可以考虑换成when哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645151167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332817,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1643688433,"is_pvip":false,"replies":[{"id":"121649","content":"不错，思路清晰，集合操作符用的很灵活，注释也恰到好处。return部分的if逻辑可以考虑用when来替代。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643721434,"ip_address":"","comment_id":332817,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643688433","product_id":100103401,"comment_content":"```Kotlin<br><br>fun solveEquation(equation: String): String {<br>  val (left, right) = equation.split(&quot;=&quot;).take(2)<br>  val (lx, ln) = parse(left)<br>  val (rx, rn) = parse(right)<br>  if (lx == rx) return if (ln == rn) &quot;Infinite solutions&quot; else &quot;No solution&quot;<br>  if ((rn - ln) % (lx - rx) != 0) return &quot;No solution&quot;<br>  return &quot;x=&quot; + (rn - ln) &#47; (lx - rx)<br>}<br><br>@OptIn(ExperimentalStdlibApi::class)<br>fun parse(exp: String): Pair&lt;Int, Int&gt; {<br>  &#47;&#47; Split operands and operators<br>  val operands = exp.split(&quot;[+-]&quot;.toRegex())<br>  val operators = buildList&lt;Int&gt; {<br>    add(1) &#47;&#47; Add leading + to align with operands<br>    addAll(exp.filter { it == &#39;+&#39; || it == &#39;-&#39; }.map { if (it == &#39;+&#39;) 1 else -1 })<br>  }<br><br>  var (x, n) = 0 to 0<br><br>  &#47;&#47; Calculate x and n<br>  for (i in operands.indices) {<br>    if (operands[i].isEmpty()) continue<br>    if (operands[i].last() == &#39;x&#39;) {<br>      x += operators[i] * (operands[i].dropLast(1).toIntOrNull() ?: 1)<br>    } else {<br>      n += operators[i] * operands[i].toInt()<br>    }<br>  }<br><br>  return x to n<br>}<br><br>```","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549202,"discussion_content":"不错，思路清晰，集合操作符用的很灵活，注释也恰到好处。return部分的if逻辑可以考虑用when来替代。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643721435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}