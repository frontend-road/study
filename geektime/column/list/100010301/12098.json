{"id":12098,"title":"05 | JVM是如何执行方法调用的？（下）","content":"<p>我在读博士的时候，最怕的事情就是被问有没有新的Idea。有一次我被老板问急了，就随口说了一个。</p><p>这个Idea究竟是什么呢，我们知道，设计模式大量使用了虚方法来实现多态。但是虚方法的性能效率并不高，所以我就说，是否能够在此基础上写篇文章，评估每一种设计模式因为虚方法调用而造成的性能开销，并且在文章中强烈谴责一下？</p><p>当时呢，我老板教的是一门高级程序设计的课，其中有好几节课刚好在讲设计模式的各种好处。所以，我说完这个Idea，就看到老板的神色略有不悦了，脸上写满了“小郑啊，你这是舍本逐末啊”，于是，我就连忙挽尊，说我是开玩笑的。</p><p>在这里呢，我犯的错误其实有两个。第一，我不应该因为虚方法的性能效率，而放弃良好的设计。第二，通常来说，Java虚拟机中虚方法调用的性能开销并不大，有些时候甚至可以完全消除。第一个错误是原则上的，这里就不展开了。至于第二个错误，我们今天便来聊一聊Java虚拟机中虚方法调用的具体实现。</p><p>首先，我们来看一个模拟出国边检的小例子。</p><pre><code>abstract class Passenger {\n  abstract void passThroughImmigration();\n  @Override\n  public String toString() { ... }\n}\nclass ForeignerPassenger extends Passenger {\n\t @Override\n \tvoid passThroughImmigration() { /* 进外国人通道 */ }\n}\nclass ChinesePassenger extends Passenger {\n  @Override\n  void passThroughImmigration() { /* 进中国人通道 */ }\n  void visitDutyFreeShops() { /* 逛免税店 */ }\n}\n\nPassenger passenger = ...\npassenger.passThroughImmigration();\n</code></pre><p>这里我定义了一个抽象类，叫做Passenger，这个类中有一个名为passThroughImmigration的抽象方法，以及重写自Object类的toString方法。</p><!-- [[[read_end]]] --><p>然后，我将Passenger粗暴地分为两种：ChinesePassenger和ForeignerPassenger。</p><p>两个类分别实现了passThroughImmigration这个方法，具体来说，就是中国人走中国人通道，外国人走外国人通道。由于咱们储蓄较多，所以我在ChinesePassenger这个类中，还特意添加了一个叫做visitDutyFreeShops的方法。</p><p>那么在实际运行过程中，Java虚拟机是如何高效地确定每个Passenger实例应该去哪条通道的呢？我们一起来看一下。</p><h2>1.虚方法调用</h2><p>在上一篇中我曾经提到，Java里所有非私有实例方法调用都会被编译成invokevirtual指令，而接口方法调用都会被编译成invokeinterface指令。这两种指令，均属于Java虚拟机中的虚方法调用。</p><p>在绝大多数情况下，Java虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为动态绑定。那么，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。</p><p>在Java虚拟机中，静态绑定包括用于调用静态方法的invokestatic指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的invokespecial指令。如果虚方法调用指向一个标记为final的方法，那么Java虚拟机也可以静态绑定该虚方法调用的目标方法。</p><p>Java虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。那么方法表具体是怎样实现的呢？</p><h2>2.方法表</h2><p>在介绍那篇类加载机制的链接部分中，我曾提到类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。</p><p>这个数据结构，便是Java虚拟机实现动态绑定的关键所在。下面我将以invokevirtual所使用的虚方法表（virtual method table，vtable）为例介绍方法表的用法。invokeinterface所使用的接口方法表（interface method table，itable）稍微复杂些，但是原理其实是类似的。</p><p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。</p><p>这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。</p><p>我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。</p><p>在执行过程中，Java虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/c3/f1ff9dcb297a458981bd1d189a5b04c3.png?wh=671*420\" alt=\"\"></p><p>在我们的例子中，Passenger类的方法表包括两个方法：</p><ul>\n<li>toString</li>\n<li>passThroughImmigration，</li>\n</ul><p>它们分别对应0号和1号。之所以方法表调换了toString方法和passThroughImmigration方法的位置，是因为toString方法的索引值需要与Object类中同名方法的索引值一致。为了保持简洁，这里我就不考虑Object类中的其他方法。</p><p>ForeignerPassenger的方法表同样有两行。其中，0号方法指向继承而来的Passenger类的toString方法。1号方法则指向自己重写的passThroughImmigration方法。</p><p>ChinesePassenger的方法表则包括三个方法，除了继承而来的Passenger类的toString方法，自己重写的passThroughImmigration方法之外，还包括独有的visitDutyFreeShops方法。</p><pre><code>Passenger passenger = ...\npassenger.passThroughImmigration();\n</code></pre><p>这里，Java虚拟机的工作可以想象为导航员。每当来了一个乘客需要出境，导航员会先问是中国人还是外国人（获取动态类型），然后翻出中国人/外国人对应的小册子（获取动态类型的方法表），小册子的第1页便写着应该到哪条通道办理出境手续（用1作为索引来查找方法表所对应的目标方法）。</p><p>实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化Java栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。</p><p>那么我们是否可以认为虚方法调用对性能没有太大影响呢？</p><p>其实是不能的，上述优化的效果看上去十分美好，但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。这是因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）。下面我便来介绍第一种内联缓存。</p><h2>3.内联缓存</h2><p>内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。</p><p>在我们的例子中，这相当于导航员记住了上一个出境乘客的国籍和对应的通道，例如中国人，走了左边通道出境。那么下一个乘客想要出境的时候，导航员会先问是不是中国人，是的话就走左边通道。如果不是的话，只好拿出外国人的小册子，翻到第1页，再告知查询结果：右边。</p><p>在针对多态的优化手段中，我们通常会提及以下三个术语。</p><ol>\n<li>单态（monomorphic）指的是仅有一种状态的情况。</li>\n<li>多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。</li>\n<li>超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。</li>\n</ol><p>对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。</p><p>多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。</p><p>一般来说，我们会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。为了节省内存空间，Java虚拟机只采用单态内联缓存。</p><p>前面提到，当内联缓存没有命中的情况下，Java虚拟机需要重新使用方法表进行动态绑定。对于内联缓存中的内容，我们有两种选择。一是替换单态内联缓存中的纪录。这种做法就好比CPU中的数据缓存，它对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存。</p><p>因此，在最坏情况下，我们用两种不同类型的调用者，轮流执行该方法调用，那么每次进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有用缓存的性能提升。</p><p>另外一种选择则是劣化为超多态状态。这也是Java虚拟机的具体实现方式。处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相比，它牺牲了优化的机会，但是节省了写缓存的额外开销。</p><p>具体到我们的例子，如果来了一队乘客，其中外国人和中国人依次隔开，那么在重复使用的单态内联缓存中，导航员需要反复记住上个出境的乘客，而且记住的信息在处理下一乘客时又会被替换掉。因此，倒不如一直不记，以此来节省脑细胞。</p><p>虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p><p>对于极其简单的方法而言，比如说getter/setter，这部分固定开销占据的CPU时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性，我们会在专栏的第二部分详细介绍方法内联的内容。</p><h2>总结与实践</h2><p>今天我介绍了虚方法调用在Java虚拟机中的实现方式。</p><p>虚方法调用包括invokevirtual指令和invokeinterface指令。如果这两种指令所声明的目标方法被标记为final，那么Java虚拟机会采用静态绑定。</p><p>否则，Java虚拟机将采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。</p><p>Java虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。</p><p>在解析虚方法调用时，Java虚拟机会纪录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。</p><p>Java虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。</p><p>当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。</p><p>否则，Java虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。</p><p>在今天的实践环节，我们来观测一下单态内联缓存和超多态内联缓存的性能差距。为了消除方法内联的影响，请使用如下的命令。</p><pre><code>// Run with: java -XX:CompileCommand='dontinline,*.passThroughImmigration' Passenger\npublic abstract class Passenger {\n\t abstract void passThroughImmigration();\n  public static void main(String[] args) {\n  \tPassenger a = new ChinesePassenger();\n\tPassenger b = new ForeignerPassenger();\n    long current = System.currentTimeMillis();\n    for (int i = 1; i &lt;= 2_000_000_000; i++) {\n      if (i % 100_000_000 == 0) {\n        long temp = System.currentTimeMillis();\n        System.out.println(temp - current);\n        current = temp;\n      }\n      Passenger c = (i &lt; 1_000_000_000) ? a : b;\n      c.passThroughImmigration();\n\t}\n  }\n}\nclass ChinesePassenger extends Passenger {\n  @Override void passThroughImmigration() {} \n}\nclass ForeignerPassenger extends Passenger {\n  @Override void passThroughImmigration() {}\n}\n</code></pre><p></p>","comments":[{"had_liked":false,"id":17947,"user_name":"啊一大狗","can_delete":false,"product_type":"c1","uid":1003926,"ip_address":"","ucode":"0D7629E65A61A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/96/53ffbb95.jpg","comment_is_top":true,"comment_ctime":1533045993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233721457620009e+18","product_id":100010301,"comment_content":"这套课很好，谢谢！","like_count":26},{"had_liked":false,"id":17726,"user_name":"Tony","can_delete":false,"product_type":"c1","uid":1178153,"ip_address":"","ucode":"99989941BB84A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/29/f1ede67b.jpg","comment_is_top":false,"comment_ctime":1532913288,"is_pvip":false,"replies":[{"id":"6162","content":"多谢建议！<br><br>原本是英文的，录音的时候觉得老要切换，就给换了。。","user_name":"作者回复","comment_id":17726,"uid":"1176688","ip_address":"","utype":1,"ctime":1532939651,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"293590689416","product_id":100010301,"comment_content":"同提建议，代码使用英文。刚学java基础时，有老师为了便于理解用中文命名。现在都来学jvm，对java很熟悉了，看到中文不仅不会觉得通俗易懂，反而特别别扭。","like_count":69,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421246,"discussion_content":"多谢建议！\n\n原本是英文的，录音的时候觉得老要切换，就给换了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532939651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18224,"user_name":"lxz","can_delete":false,"product_type":"c1","uid":1182582,"ip_address":"","ucode":"D0FE6660E62BC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/76/e5ffbdf1.jpg","comment_is_top":false,"comment_ctime":1533196344,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"117497313336","product_id":100010301,"comment_content":"建议结合java代码及其对应的字节码来讲解，比如常量池，方法表在字节码中对应的位置，干讲一点印象也没有","like_count":28,"discussions":[{"author":{"id":2238635,"avatar":"https://static001.geekbang.org/account/avatar/00/22/28/ab/b8905658.jpg","nickname":"AsYouWish99","note":"","ucode":"A5CE38DAD56115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579645,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657593491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17699,"user_name":"C_love","can_delete":false,"product_type":"c1","uid":1043613,"ip_address":"","ucode":"F268D1867C90C0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/9d/4d705f03.jpg","comment_is_top":false,"comment_ctime":1532890108,"is_pvip":false,"replies":[{"id":"6163","content":"谢谢建议！","user_name":"作者回复","comment_id":17699,"uid":"1176688","ip_address":"","utype":1,"ctime":1532939664,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"104612105212","product_id":100010301,"comment_content":"提个小建议，能否在代码中都使用英文？毕竟使用中文作对象名不值得提倡","like_count":24,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421236,"discussion_content":"谢谢建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532939664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19863,"user_name":"杨军","can_delete":false,"product_type":"c1","uid":1191730,"ip_address":"","ucode":"43C1636CF69A9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/2f/32/db8e5674.jpg","comment_is_top":false,"comment_ctime":1534126244,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"100318374052","product_id":100010301,"comment_content":"一直不太理解一个问题：“Java的动态类型运行期才可知”，在编译期代码写完之后应该就已经确定了吧，比如A是B的子类，“B b = new B();   b= new A()”这种情况下b的动态类型是A，Java编译器在编译阶段就可以确定啊，为什么说动态类型直到运行期才可知?<br>诚心求老师解惑，这个问题对我理解Java的动态绑定机制很关键-.-","like_count":23,"discussions":[{"author":{"id":1447739,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","nickname":"寥若晨星","note":"","ucode":"2E87E43687DE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261750,"discussion_content":"那你看我下面这段伪代码，告诉我如何在编译器给我确定A的动态类型\nA a = null;\nint i = 随机数;\nif(i  是奇数){\n     a = new B();\n}else{\n    a = new C();\n}\na.fun();","likes_number":36,"is_delete":false,"is_hidden":false,"ctime":1589001794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239058,"discussion_content":"我觉得可以按照前面同学说的“你这个是写死了。当是方法调用的时候，给的变量是一个接口类型，你并不知道实际传进来的具体类型”这种说法理解，不考虑方法内内联的影响，jvm在处理方法时采用的是压栈处理，即只有在压栈后虚拟机根据传参才能知道方法内部那些虚方法的接口到底是什么实现类。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1587269652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221195,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a2/4b/b72f724f.jpg","nickname":"zxk","note":"","ucode":"4BB2BD9D2BCD04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2307,"discussion_content":"个人理解是，编译后生成的是字节码，字节码里的只是符号引用，运行的时候才会解析为实际引用，此时才知道真正的动态类型","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1563446808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169431,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/17/367943f4.jpg","nickname":"吴永祺","note":"","ucode":"294ADA49541AAE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1747,"discussion_content":"有时候需要根据外部传入的参数决定实现类","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1562889280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94972,"discussion_content":"当形参是接口类型，然后实参 是具体的实现类","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577003794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070051,"avatar":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","nickname":"来碗绿豆汤","note":"","ucode":"B0AB63B8D9729F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42518,"discussion_content":"你这个是写死了。当是方法调用的时候，给的变量是一个接口类型，你并不知道实际传进来的具体类型","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572687454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","nickname":"乘风","note":"","ucode":"0420C5535DACB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1666,"discussion_content":"比如使用IOC","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1562804480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2421889,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f4/81/7a3eaa9b.jpg","nickname":"omega","note":"","ucode":"BAEFC62975DC53","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348318,"discussion_content":"引用在指向实例时实例也会根据业务动态变化，在使用父类引用指向子类时，invokevirtual可能调用任何一个子类的方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612510943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018240,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/80/3666ced3.jpg","nickname":"黄浩特","note":"","ucode":"C3A4BBF4FB8519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30757,"discussion_content":"考虑一下工厂模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570857457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339022,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","nickname":"拯救地球好累","note":"","ucode":"7643439601EF4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8400,"discussion_content":"我也有疑问，是因为类的加载、链接等过程是在运行时进行的吗，因而在运行时才能找到其动态类型？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567996521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1178888,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","nickname":"小鳄鱼","note":"","ucode":"9C30CAFB41A263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339022,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","nickname":"拯救地球好累","note":"","ucode":"7643439601EF4C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581098,"discussion_content":"类加载是按需加载的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658493265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8400,"ip_address":""},"score":581098,"extra":""}]}]},{"had_liked":false,"id":17813,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1532963653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87432309573","product_id":100010301,"comment_content":"1:虚方法<br>方法重写的方法，可认为就是虚方法<br><br>2:JVM怎么执行虚方法<br>通过方法表，一个二维表结构，标示出类的类型、虚方法的序号。当调用虚方法的时候，先确定类型，再根据类型找方法<br>","like_count":20},{"had_liked":false,"id":17727,"user_name":"左岸🌸开","can_delete":false,"product_type":"c1","uid":1080256,"ip_address":"","ucode":"1BBBBE724ECDE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/c0/517781b8.jpg","comment_is_top":false,"comment_ctime":1532913598,"is_pvip":false,"replies":[{"id":"6178","content":"通过super关键字来调用父类方法，本意就是想要调用父类的特定方法，而不是根据具体类型决定目标方法。","user_name":"作者回复","comment_id":17727,"uid":"1176688","ip_address":"","utype":1,"ctime":1532974077,"user_name_real":"郑雨迪"}],"discussion_count":7,"race_medal":0,"score":"70252390334","product_id":100010301,"comment_content":"为什么调用超类非私有实例方法会属于静态绑定呢？","like_count":16,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421247,"discussion_content":"通过super关键字来调用父类方法，本意就是想要调用父类的特定方法，而不是根据具体类型决定目标方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532974077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2313724,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/drctCc7ys2K91CKqc1OgBeAJWgx0wvGvtlgCo8gmtobmVicu1W9Z89RCqaHW86emMRt17Cr1RHaQvnR7QqUUPfg/132","nickname":"Geek_edc76d","note":"","ucode":"E6B9E1930C3AAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348243,"discussion_content":"使用super调用父类方法时,可以确定的是调用者一定是当前类,那么就相应地可以确定父类是哪个类,进而可以根据父类的方法表找到相应方法的内存地址.如果不是super调用的话,那么调用者的具体类型无法确定,如sub.test()方法,无法确定sub是哪一个类,(因为sub可以代表Sub类,也可以代表它的子类)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612489784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337829,"discussion_content":"java 只允许单继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609082606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/7f/7b22f12b.jpg","nickname":"乔","note":"","ucode":"1286F8742B4A01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306503,"discussion_content":"同样无法理解，虽然super关键字是调用父类，但是本身子类的具体类型就需要runtime类型检查才能判断啊。那对应的父类调用在编译的时候不是无法确认具体的调用方法吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600305038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2323862,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/96/b3ddc5df.jpg","nickname":"保安队长","note":"","ucode":"7D96E23AA987DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1622655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/7f/7b22f12b.jpg","nickname":"乔","note":"","ucode":"1286F8742B4A01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329023,"discussion_content":"java是单继承语法，使用super时，就可以找到父类的方法呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606298149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306503,"ip_address":""},"score":329023,"extra":""},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1622655,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/7f/7b22f12b.jpg","nickname":"乔","note":"","ucode":"1286F8742B4A01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337831,"discussion_content":"class A { void test()} \nclass B extends A {\nvoid test1(){\n  super.test()// 由于java是单继承，所以编译器当然知道super指定的是A\n}\n\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609082740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306503,"ip_address":""},"score":337831,"extra":""}]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41577,"discussion_content":"super","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572454403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164481,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1577004199,"is_pvip":true,"replies":[{"id":"65682","content":"可以被子类覆盖的方法。例如，某段程序调用父类的方法A.foo()，由于调用者(receiver)是子类B的实例，实际执行的是子类的同名同参数方法B.foo()。那么A.foo就是一个虚方法，因为你不知道会调到哪里去<br><br>这是面向对象编程的一个重要概念，用来实现多态的","user_name":"作者回复","comment_id":164481,"uid":"1176688","ip_address":"","utype":1,"ctime":1578332141,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":1,"score":"57411579047","product_id":100010301,"comment_content":"老师问一个概念性的问题： 虚方法 到底在指什么样的 方法？<br>也就是什么样的方法，才叫做虚方法？","like_count":14,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478785,"discussion_content":"可以被子类覆盖的方法。例如，某段程序调用父类的方法A.foo()，由于调用者(receiver)是子类B的实例，实际执行的是子类的同名同参数方法B.foo()。那么A.foo就是一个虚方法，因为你不知道会调到哪里去\n\n这是面向对象编程的一个重要概念，用来实现多态的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578332141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54841,"user_name":"J","can_delete":false,"product_type":"c1","uid":1341858,"ip_address":"","ucode":"00BF667DBA5FBC","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/a2/18815f9c.jpg","comment_is_top":false,"comment_ctime":1545968585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44495641545","product_id":100010301,"comment_content":"win10:<br>java -XX:CompileCommand=dontinline,*.exit Passenger     这样是对的<br>java -XX:CompileCommand=‘dontinline,*.exit’ Passenger   这样是错的","like_count":11},{"had_liked":false,"id":17787,"user_name":"MARK","can_delete":false,"product_type":"c1","uid":1126900,"ip_address":"","ucode":"9F429C9C5FEE6A","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/f4/467cf5d7.jpg","comment_is_top":false,"comment_ctime":1532953013,"is_pvip":false,"replies":[{"id":"6174","content":"哈，我以前也认为无法编译，直到有一次我看到一个俄语的方法名。。<br><br>另外，如果你用javap -v查看常量池的话，你会发现类名方法名以及方法描述符都是用UTF8来存的。","user_name":"作者回复","comment_id":17787,"uid":"1176688","ip_address":"","utype":1,"ctime":1532963307,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"44482625973","product_id":100010301,"comment_content":"没用过中文写代码，居然认为中文会编译错误T﹏T<br>老师是为了课件方便这样写，自己写作业就改下呗，又没规定要每个字照抄<br>[root@localhost cqq]# javac Passenger.java <br>[root@localhost cqq]# java Passenger<br>cost time : 1167<br>cost time : 3156<br>[root@localhost cqq]# java -XX:CompileCommand=&#39;dontinline,*.exit&#39; Passenger<br>CompilerOracle: dontinline *.exit<br>cost time : 3709<br>cost time : 7557","like_count":10,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421272,"discussion_content":"哈，我以前也认为无法编译，直到有一次我看到一个俄语的方法名。。\n\n另外，如果你用javap -v查看常量池的话，你会发现类名方法名以及方法描述符都是用UTF8来存的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532963307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17826,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1532969420,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40187675084","product_id":100010301,"comment_content":"关于单态内联缓存中的记录，hotspot采用了超多态。也就是如果该调用者的动态类型不是缓存中的类型的话，直接通过基于方法表来找到具体的目标方法。那么内联缓存中的类型是永久不变，一直是第一次缓存的那个调用者类型吗？","like_count":9,"discussions":[{"author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375466,"discussion_content":"内联缓存应该会失效，实验结果a:5105，b:6578，a:6711","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621672613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174213,"user_name":"没有昵称","can_delete":false,"product_type":"c1","uid":1763208,"ip_address":"","ucode":"565783BDD01CE4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e7/88/c8b4ad9c.jpg","comment_is_top":false,"comment_ctime":1580092166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35939830534","product_id":100010301,"comment_content":"JVM本身比较抽象，建议老师多用图形和示例描述，单纯的文字容易造成感觉明白了，但实际没有深入理解的情况。","like_count":8},{"had_liked":false,"id":20051,"user_name":"吾是锋子","can_delete":false,"product_type":"c1","uid":1183799,"ip_address":"","ucode":"2945C716FFBD61","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/37/6c6b5e32.jpg","comment_is_top":false,"comment_ctime":1534239771,"is_pvip":false,"replies":[{"id":"7060","content":"HotSpot里有String.indexOf intrinsic，用了很多向量化指令，所以性能会快很多的。<br><br>关于intrinsic的概念，你可以理解为HotSpot识别指定方法后，将其替代为语意等价的高效实现。","user_name":"作者回复","comment_id":20051,"uid":"1176688","ip_address":"","utype":1,"ctime":1534322701,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"31599010843","product_id":100010301,"comment_content":"郑老师，您好。有个具体的问题想请教下，String类里面indexOf(String str)调用的是自己类里面indexOf(String str, int fromIndex)方法，但我自己在测试的时候却发现两个方法的速度有很明显的差异，看字节码也没有发现什么特殊。<br>不知道是不是我忽略了什么，希望您能抽空点拨下，感谢！","like_count":8,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422085,"discussion_content":"HotSpot里有String.indexOf intrinsic，用了很多向量化指令，所以性能会快很多的。\n\n关于intrinsic的概念，你可以理解为HotSpot识别指定方法后，将其替代为语意等价的高效实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534322701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59659,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1547396677,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23022233157","product_id":100010301,"comment_content":"一直不太理解一个问题：“Java的动态类型运行期才可知”，在编译期代码写完之后应该就已经确定了吧，比如A是B的子类，“B b = new B(); b= new A()”这种情况下b的动态类型是A，Java编译器在编译阶段就可以确定啊，为什么说动态类型直到运行期才可知?<br>诚心求老师解惑，这个问题对我理解Java的动态绑定机制很关键-.-<br><br><br>@杨军，我的理解是，假设C是B的另外一个子类，你的上述两句代码有可能运行在多线程环境中。假设第二行代码运行之后切换到了另外一个线程中，且b = new C()<br>这个情况下，线程再切换到你的那两行代码后面的时候就不一定是A了，刘必须要在运行过程中才能确定了。","like_count":5,"discussions":[{"author":{"id":1153893,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9b/65/9045dc77.jpg","nickname":"慕云","note":"","ucode":"E7D6D2CD58249E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580061,"discussion_content":"根据参数去拼接Bean 就是运行的时候才知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657855187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2323862,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/96/b3ddc5df.jpg","nickname":"保安队长","note":"","ucode":"7D96E23AA987DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329062,"discussion_content":"你得区分两个不同的阶段，一个是加载，一个是运行。对于实例 b 而言，它可以指向任何子类对象。仅在加载阶段，它无法知道自己指向谁的，只有执行方法调用时，才能得知 b 的具体类型，我想你把加载和运行混为一谈了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606306025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239054,"discussion_content":"我感觉不是这样的，你这种说法就属于并发问题的范畴了，换句话说，单线程环境下就不存在动态绑定的问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587269242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339022,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","nickname":"拯救地球好累","note":"","ucode":"7643439601EF4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8402,"discussion_content":"多线程下动态修改绑定的问题，感觉有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567996879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18021,"user_name":"方枪枪","can_delete":false,"product_type":"c1","uid":1066385,"ip_address":"","ucode":"1E77368726255F","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/91/246c7698.jpg","comment_is_top":false,"comment_ctime":1533089177,"is_pvip":false,"replies":[{"id":"6320","content":"合法性检测是根据编译器能找到的class文件来判定的。你可以在编译后，移除掉相应的class文件或者库文件，就会出现你所说的不存在的方法的情况了。<br><br>第二个问题，在各自的编译器中已经作出区分了。在Java字节码中就只是根据类名，方法名和方法描述符来定位方法的。","user_name":"作者回复","comment_id":18021,"uid":"1176688","ip_address":"","utype":1,"ctime":1533157792,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"23007925657","product_id":100010301,"comment_content":"一直不能明确一个问题，执行哪个方法，是不是都是在运行的时候确定的，如果是的话，coding的时候，写一个不存在的方法or传入不存在的参数，编译会报错，那这个合法性的检测，是一个什么逻辑？另外关于方法的确定，对于Java来说，是按照传入的形参确定执行哪个重写的方法，对于 groovy 是按照实际类型确定执行哪个方法，这两个区别在JVM层面是如何实现的？","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421362,"discussion_content":"合法性检测是根据编译器能找到的class文件来判定的。你可以在编译后，移除掉相应的class文件或者库文件，就会出现你所说的不存在的方法的情况了。\n\n第二个问题，在各自的编译器中已经作出区分了。在Java字节码中就只是根据类名，方法名和方法描述符来定位方法的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533157792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64867,"user_name":"加久","can_delete":false,"product_type":"c1","uid":1063407,"ip_address":"","ucode":"FF61BBAEAA73BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo7gP4Nibo4m4MOvbqd4yuK1Bf4ULQeSb3d37zyw5nKAHlHze89yTp4NWRLEbq72iaiaO8NKpOUnHw3g/132","comment_is_top":false,"comment_ctime":1548930782,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14433832670","product_id":100010301,"comment_content":"任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和...<br><br>命中内联缓存后，不用开辟新的栈帧了？？","like_count":3,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41576,"discussion_content":"要开启啊，你要先知道方法内联的是啥意思，就是直接用方法的内容替换方法调用处，所以你想想看，这不就不用创建新的栈帧了吗？？\n\n内联缓存并没有发生方法内联，还是要创建栈帧的！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572454366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94974,"discussion_content":"内联缓存和方法内联是两个概念","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577003996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57130,"user_name":"哎呦，不错哦","can_delete":false,"product_type":"c1","uid":1031430,"ip_address":"","ucode":"752C4E571F419C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/06/a0b1cfb3.jpg","comment_is_top":false,"comment_ctime":1546656210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14431558098","product_id":100010301,"comment_content":"建议举个经典虚拟机实现中方法表对应的具体数据结构等，只有总结出来的文字没有实际代码为证，很难深入了解你的意思","like_count":3},{"had_liked":false,"id":17772,"user_name":"和风暖林","can_delete":false,"product_type":"c1","uid":1183812,"ip_address":"","ucode":"3FF31DB24C2065","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/44/e7437824.jpg","comment_is_top":false,"comment_ctime":1532947051,"is_pvip":false,"replies":[{"id":"6175","content":"哈，多谢支持。不过汉语编程有个问题，没办法区分大小写，因此变量名和类名容易混淆","user_name":"作者回复","comment_id":17772,"uid":"1176688","ip_address":"","utype":1,"ctime":1532973213,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14417848939","product_id":100010301,"comment_content":"代码用汉语也挺好的呀。来这都是学jvm的，没有来学编码规范的吧……","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421267,"discussion_content":"哈，多谢支持。不过汉语编程有个问题，没办法区分大小写，因此变量名和类名容易混淆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532973213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180907,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1582441000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172375592","product_id":100010301,"comment_content":"对于接口的方法表有点疑惑，如果一个子类实现多个接口，那么子类的方法表的索引和接口方法表的索引还是相同的吗？不同接口的方法表的索引不会重复吗？","like_count":2},{"had_liked":false,"id":147271,"user_name":"男朋友","can_delete":false,"product_type":"c1","uid":1401707,"ip_address":"","ucode":"9818176E0BBD31","user_header":"https://static001.geekbang.org/account/avatar/00/15/63/6b/34b89fae.jpg","comment_is_top":false,"comment_ctime":1572852974,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10162787566","product_id":100010301,"comment_content":"suxiansen@suxiansendeMacBook-Pro:~&#47;geektime&#47;demo&#47;src&#47;main&#47;java|<br>⇒  java -XX:CompileCommand=&#39;dontinline,*.passThrouguImmigration&#39; com.example.demo.Passenger<br>CompilerOracle: dontinline *.passThrouguImmigration<br>70<br>97<br>99<br>99<br>98<br>95<br>97<br>96<br>98<br>96<br>124<br>119<br>123<br>122<br>124<br>125<br>126<br>126<br>126<br>120<br>suxiansen@suxiansendeMacBook-Pro:~&#47;geektime&#47;demo&#47;src&#47;main&#47;java|<br>⇒  java -XX:CompileCommand=&#39;inline,*.passThrouguImmigration&#39; com.example.demo.Passenger<br>CompilerOracle: inline *.passThrouguImmigration<br>75<br>98<br>93<br>101<br>105<br>101<br>102<br>102<br>100<br>98<br>127<br>124<br>126<br>128<br>126<br>124<br>123<br>128<br>127<br>119<br>suxiansen@suxiansendeMacBook-Pro:~&#47;geektime&#47;demo&#47;src&#47;main&#47;java|<br>我的怎么看起来没啥区别","like_count":2,"discussions":[{"author":{"id":2028950,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/96/e963b41b.jpg","nickname":"Geek8819","note":"","ucode":"521AEDAB2EED81","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301227,"discussion_content":"我的mac环境下也没看到区别\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598446918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028950,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/96/e963b41b.jpg","nickname":"Geek8819","note":"","ucode":"521AEDAB2EED81","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337839,"discussion_content":"把100_000_000改成1_000_000_000","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609084216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301227,"ip_address":""},"score":337839,"extra":""}]}]},{"had_liked":false,"id":131973,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1567997284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10157931876","product_id":100010301,"comment_content":"动态绑定：根据调用者的动态类型，来确定虚方法调用的目标方法（JVM中通过方法表定位目标方法）<br>方法表创建时间：链接时的准备阶段<br>方法表数据结构：数组（每个数组元素指向一个当前类及其祖先类中非私有的实例方法）<br>动态绑定过程：在解析过程中，访问栈上的调用者-&gt;读取调用者的实际类型-&gt;读取该类型的方法表-&gt;读取方法表中某个索引值所对应的目标方法<br>内联缓存：通过缓存调用者的动态类型和该类型对应的目标方法以期加快动态绑定","like_count":2},{"had_liked":false,"id":17705,"user_name":"vimfun","can_delete":false,"product_type":"c1","uid":1007359,"ip_address":"","ucode":"EAB2281FC0552A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/ff/295bcf2c.jpg","comment_is_top":false,"comment_ctime":1532908921,"is_pvip":false,"replies":[{"id":"6165","content":"你是指课后作业吗？<br><br>打印语句每一亿次循环只会运行一次，相对来说并不耗时。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532942679,"ip_address":"","comment_id":17705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10122843513","product_id":100010301,"comment_content":"老师，打印耗时的System.out.println 用的太多了吧？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421238,"discussion_content":"你是指课后作业吗？\n\n打印语句每一亿次循环只会运行一次，相对来说并不耗时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532942679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340272,"user_name":"Geek_42f729","can_delete":false,"product_type":"c1","uid":1600341,"ip_address":"","ucode":"76CFFF9DEDDF96","user_header":"https://static001.geekbang.org/account/avatar/00/18/6b/55/2b0f219b.jpg","comment_is_top":false,"comment_ctime":1648712367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5943679663","product_id":100010301,"comment_content":"哈哈哈，22年才来学JVM。","like_count":1},{"had_liked":false,"id":230005,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1593239621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888206917","product_id":100010301,"comment_content":"这个单态和多态是《深入理解java虚拟机》那本书说的单分派和多分派的意思嘛","like_count":1},{"had_liked":false,"id":224815,"user_name":"宿臾洛城","can_delete":false,"product_type":"c1","uid":1564267,"ip_address":"","ucode":"362CC728E256F7","user_header":"https://static001.geekbang.org/account/avatar/00/17/de/6b/adee88bb.jpg","comment_is_top":false,"comment_ctime":1591545563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886512859","product_id":100010301,"comment_content":"这篇比较好理解，感觉就是和Map一个道理，单个值的时候查找很快，多个值查找对应的value性能就会下降了","like_count":1},{"had_liked":false,"id":186748,"user_name":"Arjen","can_delete":false,"product_type":"c1","uid":1042539,"ip_address":"","ucode":"929563BF07E8B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/6b/0b48c0f9.jpg","comment_is_top":false,"comment_ctime":1583916966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878884262","product_id":100010301,"comment_content":"还可以扩展一下，Passenger c = (i &lt; 1_000_000_000) ? a : b;这行的条件改成(i % 2) == 0，模拟两个不同类型的对象轮流调用，也就是文中说的内联缓存只有写开销没有使用到的最坏情况。<br>自己测试下来这种情况下关闭内联缓存确实要比开启内联缓存要快。","like_count":1},{"had_liked":false,"id":75779,"user_name":"寥若晨星","can_delete":false,"product_type":"c1","uid":1447739,"ip_address":"","ucode":"2E87E43687DE72","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","comment_is_top":false,"comment_ctime":1552467694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847434990","product_id":100010301,"comment_content":"我也建议老师变量名使用英文，因为习惯了，看到中文变量觉得别扭，反而增加了写入大脑缓存的时间哈哈哈","like_count":1},{"had_liked":false,"id":28541,"user_name":"ZY","can_delete":false,"product_type":"c1","uid":1228486,"ip_address":"","ucode":"35704C4BC05017","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/c6/8a92bd2e.jpg","comment_is_top":false,"comment_ctime":1538101039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833068335","product_id":100010301,"comment_content":"不太明白这段代码为啥体现了单态内联缓存和超多态内联缓存的性能差距？。。既然说了Java虚拟机只用了单态内联缓存。。为什么后面的b.出境()没有被替换之前的缓存？","like_count":1},{"had_liked":false,"id":17990,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1533083819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828051115","product_id":100010301,"comment_content":"3:缓存<br>凡是需要提高性能的地方都需要使用，这个方法也是人类经常使用的方式，计算机中使用的也比较多，使用缓存的基本理念是，一将需要的东西提前加工好，二将加工好的东西放在获取速度更快更方便的地方<br><br>4:内联缓存<br>是JVM为了提高动态绑定或者根据动态的类类型找目标方法的一种方式，这是以空间换时间的优化思路，需要权衡利弊，视场景使用","like_count":1},{"had_liked":false,"id":17732,"user_name":"礼貌","can_delete":false,"product_type":"c1","uid":1178679,"ip_address":"","ucode":"4B93DAE9AAC5C2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/37/ea588860.jpg","comment_is_top":false,"comment_ctime":1532914825,"is_pvip":false,"replies":[{"id":"6164","content":"哈，这个对于VM实现者来说可是feature，毕竟要存储UTF8。不过以后的代码会换到英文的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532939762,"ip_address":"","comment_id":17732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5827882121","product_id":100010301,"comment_content":"汉语编程？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421250,"discussion_content":"哈，这个对于VM实现者来说可是feature，毕竟要存储UTF8。不过以后的代码会换到英文的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532939762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347935,"user_name":"Geek_d1bbb0","can_delete":false,"product_type":"c1","uid":2850164,"ip_address":"","ucode":"026DCACA44DAF2","user_header":"","comment_is_top":false,"comment_ctime":1654592720,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654592720","product_id":100010301,"comment_content":"小白请教：<br>&#47;&#47; Run with: java -XX:CompileCommand=&#39;dontinline,*.passThroughImmigration&#39; Passenger<br><br>这行命令怎么执行，在linux执行报错<br>run :command not found","like_count":0},{"had_liked":false,"id":337760,"user_name":"枫林血舞","can_delete":false,"product_type":"c1","uid":2809867,"ip_address":"","ucode":"EE7F6DA78D21EA","user_header":"https://static001.geekbang.org/account/avatar/00/2a/e0/0b/6f667b2c.jpg","comment_is_top":false,"comment_ctime":1647013757,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647013757","product_id":100010301,"comment_content":"这两节课让我彻底明白了方法调用～","like_count":0},{"had_liked":false,"id":299245,"user_name":"滴答丶滴","can_delete":false,"product_type":"c1","uid":1181206,"ip_address":"","ucode":"2093C2948B4327","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","comment_is_top":false,"comment_ctime":1624527125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624527125","product_id":100010301,"comment_content":"这里的 “任何方法调用除非被内联，否则都会有固定开销”这句话有问题吧 应该是“任何动态方法调用除非被内联，否则都会有固定开销”","like_count":0},{"had_liked":false,"id":293138,"user_name":"爱吾尚","can_delete":false,"product_type":"c1","uid":2602405,"ip_address":"","ucode":"049C04B6BD9D11","user_header":"https://static001.geekbang.org/account/avatar/00/27/b5/a5/1c62fe9c.jpg","comment_is_top":false,"comment_ctime":1621240719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621240719","product_id":100010301,"comment_content":"老师您好，我想问一下静态绑定时引用方法内存位置也是通过方法表确定的吗","like_count":0},{"had_liked":false,"id":283734,"user_name":"大宋王朝","can_delete":false,"product_type":"c1","uid":1384765,"ip_address":"","ucode":"224063815AC8E0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLicwhaSVJxBVXGyvJu2xNh03icGzPEzibmk9cQEXGqBnUJHI0xibFVsqibFTicTKOY7p7XnjdrhH8HXEjw/132","comment_is_top":false,"comment_ctime":1615899213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615899213","product_id":100010301,"comment_content":"老师，请教一个问题：最近开始需要做js虚拟机开发，之前没有接触js java,虚拟机怎么入门？谢谢","like_count":0},{"had_liked":false,"id":281874,"user_name":"青年祭司","can_delete":false,"product_type":"c1","uid":1259156,"ip_address":"","ucode":"C88EDAE3FF09AE","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/94/0b969588.jpg","comment_is_top":false,"comment_ctime":1614930774,"is_pvip":false,"discussion_count":0,"race_medal":5,"score":"1614930774","product_id":100010301,"comment_content":"老师，单态内联缓存劣化成超多态内敛缓存的阈值是什么，就是说单态内联缓存在多少次没命中的情况下会劣化成超多态内敛缓存？","like_count":0},{"had_liked":false,"id":264175,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1606372842,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1606372842","product_id":100010301,"comment_content":"老师我想问一下，讲方法表的例子那块，方法表的顺序和父子类索引值相同有啥关系呀，方法表存的不是索引吗，为什么顺序还能影响","like_count":0,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337838,"discussion_content":"避免浪费空间吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609084133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1260141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","nickname":"Wheat","note":"","ucode":"7D99EA149B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337844,"discussion_content":"换了一下方法表中两个方法的位置，和空间有啥关系呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609086164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337838,"ip_address":""},"score":337844,"extra":""}]}]},{"had_liked":false,"id":244312,"user_name":"Geek8819","can_delete":false,"product_type":"c1","uid":2028950,"ip_address":"","ucode":"521AEDAB2EED81","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/96/e963b41b.jpg","comment_is_top":false,"comment_ctime":1598455993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598455993","product_id":100010301,"comment_content":"老师，想提问一下 ：<br>1、JVM中单态内联缓存内容是何时放置的？<br>2、存不存在对于多态的方法，JVM开始时只调用一个实现类，这时候是单台内联缓存，后面又调用了其他的实现类，才退化为超多态内联缓存？","like_count":0},{"had_liked":false,"id":243101,"user_name":"xmeng","can_delete":false,"product_type":"c1","uid":1731543,"ip_address":"","ucode":"C0CA2182BA3B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","comment_is_top":false,"comment_ctime":1597966889,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597966889","product_id":100010301,"comment_content":"动态绑定：根据调用者的动态类型，来确定虚方法调用的目标方法（JVM中通过方法表定位目标方法）<br>方法表创建时间：链接时的准备阶段<br>方法表数据结构：数组（每个数组元素指向一个当前类及其祖先类中非私有的实例方法）<br>动态绑定过程：在解析过程中，访问栈上的调用者-&gt;读取调用者的实际类型-&gt;读取该类型的方法表-&gt;读取方法表中某个索引值所对应的目标方法<br>内联缓存：通过缓存调用者的动态类型和该类型对应的目标方法以期加快动态绑定","like_count":0},{"had_liked":false,"id":241940,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1597509778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597509778","product_id":100010301,"comment_content":"请问老师，文中提到被final修饰的方法可以静态绑定，这个是怎么实现的呢，字节码没什么编号的啊，也是invokevirtual，没太理解静态绑定到底是只的什么呢，谢谢","like_count":0},{"had_liked":false,"id":237633,"user_name":"Kevin⚡️Zhou","can_delete":false,"product_type":"c1","uid":1440772,"ip_address":"","ucode":"C0FC2673705212","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","comment_is_top":false,"comment_ctime":1595905905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595905905","product_id":100010301,"comment_content":"打印循环的判断条件100000000这里是少了一个0把, 按照示例代码会打印20次","like_count":0},{"had_liked":false,"id":226346,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1592042989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592042989","product_id":100010301,"comment_content":"这节课学到蛮多东西，要是老师多画点图就更好了<br>","like_count":0},{"had_liked":false,"id":225992,"user_name":"Mr.zhang","can_delete":false,"product_type":"c1","uid":1503968,"ip_address":"","ucode":"52BEF6493C3444","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/e0/9577744e.jpg","comment_is_top":false,"comment_ctime":1591925245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591925245","product_id":100010301,"comment_content":"请问老师，有没有什么方法能够看到各个类的方法表以及对应的序号呢？我这边用javap -v看到的字节码文件中，并没有发现类似的方法表数组结构。谢谢了。","like_count":0},{"had_liked":false,"id":225238,"user_name":"芋头","can_delete":false,"product_type":"c1","uid":1070287,"ip_address":"","ucode":"390438CFF71F0A","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/cf/fddcf843.jpg","comment_is_top":false,"comment_ctime":1591689808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591689808","product_id":100010301,"comment_content":"老师，既然写到了数据结构，文中提到的数据结构、以及其他的抽象的描述，能否增加一些画图来帮助理解呢，单纯文字实在是难以理解","like_count":0},{"had_liked":false,"id":223595,"user_name":"海无语","can_delete":false,"product_type":"c1","uid":1308200,"ip_address":"","ucode":"0BCBDC09283C0F","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/28/96e030aa.jpg","comment_is_top":false,"comment_ctime":1591141448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591141448","product_id":100010301,"comment_content":"虚方法：<br>1. 非私有方法<br>2. 可以被子类重写的方法<br>3. 可以被外部访问的方法","like_count":0},{"had_liked":false,"id":222834,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590924275,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590924275","product_id":100010301,"comment_content":"有一点不太理解，如果子类B重写了父类A的一个buy方法<br>在子类B的虚方法表中对应buy方法的索引值如果和父类A的buy方法索引值相同的话，那在实际调用的时候怎么去执行B重写后buy方法的代码?","like_count":0},{"had_liked":false,"id":214996,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1588865167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588865167","product_id":100010301,"comment_content":"老师问个问题<br>内联缓存 缓存了一种动态类型以及它所对应的目标方法<br>这指的是不是 缓存了一个类和其所有的方法？","like_count":0},{"had_liked":false,"id":208934,"user_name":"43252","can_delete":false,"product_type":"c1","uid":1937922,"ip_address":"","ucode":"F744CF88041126","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK44Raw4pHAQCfzm1TIZPicQnNTbChqHFEqcZ292DGBLZ33JqTribLtr5hmIr5DtwcagHgZomcWOrQw/132","comment_is_top":false,"comment_ctime":1587466767,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1587466767","product_id":100010301,"comment_content":"请问老师，既然都是直接访问方法表，那超多态内联缓存有什么意义吗？","like_count":0,"discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274927,"discussion_content":"我更纠结的是，正常应该是先快后慢，我变超多态后反而更快了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590633242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274925,"discussion_content":"我个人理解是 超多态是先进行了单态的缓存，然后发现调用者不同时进入的状态，跟直接访问方法表算是有点区别吧。有点锁升降级的那种感觉，不知道理解对不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590632400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178216,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1581611070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581611070","product_id":100010301,"comment_content":"“虽然内联缓存附带内联二字，但是它并没有内联目标方法”<br> 不是说缓存了调用者类型和对应的目标方法了吗？ 为什么没有内联目标方法？","like_count":0},{"had_liked":false,"id":158016,"user_name":"高家祥","can_delete":false,"product_type":"c1","uid":1634993,"ip_address":"","ucode":"31EB448EA2E441","user_header":"https://static001.geekbang.org/account/avatar/00/18/f2/b1/f765cb62.jpg","comment_is_top":false,"comment_ctime":1575297937,"is_pvip":false,"replies":[{"id":"60614","content":"在20 21有讲","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1575365688,"ip_address":"","comment_id":158016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575297937","product_id":100010301,"comment_content":"方法内联  怎么没有说呀","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476606,"discussion_content":"在20 21有讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575365688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152664,"user_name":"会飞的鱼","can_delete":false,"product_type":"c1","uid":1257205,"ip_address":"","ucode":"BA3FC4E0BF7B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erloYzyia2hRy19E3aCtc0pf10MiaGmzEcXw8UZ3jC3LAibD8icWAFVCXGAlAic3mpjBUrHvyreyhAjIFw/132","comment_is_top":false,"comment_ctime":1574058986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574058986","product_id":100010301,"comment_content":"感觉还是有些不全面，单分派和多分派似乎没有提到","like_count":0},{"had_liked":false,"id":152146,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1573891935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573891935","product_id":100010301,"comment_content":"内联缓存的这个单态指的是一个java虚拟机只能缓存一个，还是每个类缓存一个","like_count":0},{"had_liked":false,"id":149085,"user_name":"胡楚坚","can_delete":false,"product_type":"c1","uid":1120212,"ip_address":"","ucode":"225883EDF35BED","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/d4/d7a4e6f5.jpg","comment_is_top":false,"comment_ctime":1573139227,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573139227","product_id":100010301,"comment_content":"周志明第二版书中179页最下方，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。----这句话跟您文中例子Passenger类的例子完全不一样，按书中讲法，子类方法表不应该有toString()。请问到底是什么情况呢","like_count":0,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":134909,"discussion_content":"如果没有重写父类方法，子类方法表中是不会出现改方法的索引的，只有重写了才有哦，在Passenger中已经重写了toString()；这是我的理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579054991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146138,"user_name":"陌臣","can_delete":false,"product_type":"c1","uid":1643898,"ip_address":"","ucode":"EC1B2DA7483F11","user_header":"https://static001.geekbang.org/account/avatar/00/19/15/7a/db9879e1.jpg","comment_is_top":false,"comment_ctime":1572439287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572439287","product_id":100010301,"comment_content":"多看两遍，将前面的内容结合起来有助于理解，当然还需要自己上网查才能懂，加油","like_count":0},{"had_liked":false,"id":136630,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1569485506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569485506","product_id":100010301,"comment_content":"jdk1.8 运行的时候，我这里要把单引号换成双引号。<br>java -XX:CompileCommand=&#39;dontinline,*.passThroughImmigration&#39; Passenger<br><br>说下根据课程的理解：由于java虚拟机只采用单态内联，而这里前一半都是中国旅客，后一半都是外国旅客，可以使用内联缓存，因而使用内联缓存执行效率大概提高了一杯。","like_count":0},{"had_liked":false,"id":130610,"user_name":"余焱林ॐ","can_delete":false,"product_type":"c1","uid":1040436,"ip_address":"","ucode":"01234897C5AFB4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/34/0a229e32.jpg","comment_is_top":false,"comment_ctime":1567494066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567494066","product_id":100010301,"comment_content":"2019.09.03回顾一遍","like_count":0},{"had_liked":false,"id":118126,"user_name":"懵懂的Java","can_delete":false,"product_type":"c1","uid":1312151,"ip_address":"","ucode":"19D3BE0AA1410B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELTaqicWVpIsOpha9icy6LLJrrd24lGlwsBYhBTkBUdGHIGFXRbyZicNbSafvhMATDBjX6NSGLam9bag/132","comment_is_top":false,"comment_ctime":1564269054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564269054","product_id":100010301,"comment_content":"您好，请教一个问题，我们现在做环境迁移中间件版本相同，迁移后一直报空指针的错误，对比发现正常的累加载是按照lib下abcd开头顺序加载的。我想是不是跟这个有关，有什么方法让类这么加载，正常运行的也没有什么参数，为什么两台机器的加载顺序不一样呢。谢谢老师！","like_count":0},{"had_liked":false,"id":117382,"user_name":"Jacen","can_delete":false,"product_type":"c1","uid":1378332,"ip_address":"","ucode":"A1EC8D8FE11230","user_header":"https://static001.geekbang.org/account/avatar/00/15/08/1c/ab50923c.jpg","comment_is_top":false,"comment_ctime":1564036435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564036435","product_id":100010301,"comment_content":"WIN10 JDK 8的运行结果如下：<br>D:\\Workspace\\Ucar\\demo\\src\\main\\java&gt;java -XX:CompileCommand=dontinline,*.passThroughImmigration Passenger<br>CompilerOracle: dontinline *.passThroughImmigration<br>282<br>288<br>280<br>314<br>271<br>284<br>290<br>332<br>294<br>285<br>359<br>334<br>336<br>385<br>332<br>364<br>328<br>331<br>380<br>336<br><br>D:\\Workspace\\Ucar\\demo\\src\\main\\java&gt;java -XX:CompileCommand=inline,*.passThroughImmigration Passenger<br>CompilerOracle: inline *.passThroughImmigration<br>103<br>128<br>191<br>150<br>156<br>153<br>124<br>124<br>127<br>177<br>183<br>190<br>191<br>169<br>234<br>178<br>155<br>162<br>169<br>176","like_count":0},{"had_liked":false,"id":104928,"user_name":"lmtoo","can_delete":false,"product_type":"c1","uid":1133918,"ip_address":"","ucode":"FCD5B9C941D448","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","comment_is_top":false,"comment_ctime":1560872289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560872289","product_id":100010301,"comment_content":"我想问一下，这个内联缓存是一个线程一个还是一个进程一个？还有这个缓存是在调用栈里吗？如果不是那存放在哪里？","like_count":0},{"had_liked":false,"id":92186,"user_name":"Geek_8b249c","can_delete":false,"product_type":"c1","uid":1520950,"ip_address":"","ucode":"7285481C43558B","user_header":"","comment_is_top":false,"comment_ctime":1557197740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557197740","product_id":100010301,"comment_content":"结果：<br>inline<br>170 &#47;&#47; a<br>...<br>170<br>210 &#47;&#47; b<br>...<br>210<br><br>dontinline<br>360 &#47;&#47; a<br>...<br>360<br>420 &#47;&#47; b<br>...<br>420<br><br>结果如上，有两个问题<br>1、使用内联（inline），执行a的时候用了cache，所以比b快。那为什么不使用内联（dontinline）的时候a还是比b快，不是应该ab一样了吗？<br>2、使用内联时候的b（已经退化为超多态）的时间，为什么和不使用内联的a或b时间都不相同？（如果我的问题1无误，则内联b与非内联ab三者时间相同）<br>","like_count":0},{"had_liked":false,"id":76809,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552716042,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552716042","product_id":100010301,"comment_content":"简单通俗易懂，厉害厉害！","like_count":0},{"had_liked":false,"id":75737,"user_name":"在路上的小胖胖","can_delete":false,"product_type":"c1","uid":1074906,"ip_address":"","ucode":"4F34EBA3B4BD05","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/da/b1d9c2e6.jpg","comment_is_top":false,"comment_ctime":1552461182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552461182","product_id":100010301,"comment_content":"子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同，这个怎么理解？","like_count":0},{"had_liked":false,"id":66946,"user_name":"cafebabe","can_delete":false,"product_type":"c1","uid":1068863,"ip_address":"","ucode":"A4CC63708A2629","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/3f/43b56751.jpg","comment_is_top":false,"comment_ctime":1550045953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550045953","product_id":100010301,"comment_content":"郑老师，本节文中提到的内联缓存，请问是用内存来实现？","like_count":0},{"had_liked":false,"id":63454,"user_name":"川川","can_delete":false,"product_type":"c1","uid":1382517,"ip_address":"","ucode":"DA092CAC7F294D","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/75/68487e89.jpg","comment_is_top":false,"comment_ctime":1548377741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548377741","product_id":100010301,"comment_content":"这一堂课算精品，再也没有云里开雾里去的感觉了","like_count":0},{"had_liked":false,"id":61282,"user_name":"original","can_delete":false,"product_type":"c1","uid":1367120,"ip_address":"","ucode":"0E864BAFD45374","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/50/bcbfaf3a.jpg","comment_is_top":false,"comment_ctime":1547651590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547651590","product_id":100010301,"comment_content":"学C++过来的，刚过了一边java语法就来看看jvm，跟c++的多态实现差不多，就是讲的有点不太详细","like_count":0},{"had_liked":false,"id":59648,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1547396073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547396073","product_id":100010301,"comment_content":"其实是不能的，上述优化的效果看上去十分美好，但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。<br><br>这里的  最坏  是不是  应该是 最好？","like_count":0},{"had_liked":false,"id":55812,"user_name":"尔东","can_delete":false,"product_type":"c1","uid":1360829,"ip_address":"","ucode":"C0983536C63E2A","user_header":"https://static001.geekbang.org/account/avatar/00/14/c3/bd/ec8b3044.jpg","comment_is_top":false,"comment_ctime":1546314201,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1546314201","product_id":100010301,"comment_content":"那么我们是否可以认为虚方法调用对性能没有太大影响呢？ 其实是...<br><br>这段话不太能理解，上面介绍了查方法表的开销，结论是对性能并没有太大影响，下面又讲了对查表的优化方法，所以查表形式的虚方法调用开销大吗","like_count":0,"discussions":[{"author":{"id":1411447,"avatar":"https://static001.geekbang.org/account/avatar/00/15/89/77/1f0d3095.jpg","nickname":"Fantasybaby","note":"","ucode":"A0261F221C1CA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579825,"discussion_content":"这套课程 很多句子读不明白 头大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657703550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51686,"user_name":"客户程序员จุ๊บ","can_delete":false,"product_type":"c1","uid":1333397,"ip_address":"","ucode":"AD2DB3623183ED","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/95/672bf5aa.jpg","comment_is_top":false,"comment_ctime":1545223930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545223930","product_id":100010301,"comment_content":"您好郑老师 问一个问题 在发生方法重写的时候 既然子类会覆盖父类方法索引 那如果在子类中调用super.重写方法 会发生什么呢","like_count":0},{"had_liked":false,"id":50347,"user_name":"小泷哥","can_delete":false,"product_type":"c1","uid":1255252,"ip_address":"","ucode":"128C9C4B0AFE7F","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/54/d38c34a0.jpg","comment_is_top":false,"comment_ctime":1544958737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544958737","product_id":100010301,"comment_content":"有点没明白为什么非接口，非继承实例也属于虚方法？","like_count":0},{"had_liked":false,"id":48772,"user_name":"zhyuan源","can_delete":false,"product_type":"c1","uid":1284207,"ip_address":"","ucode":"12028F9EDDBD25","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/6f/47188f43.jpg","comment_is_top":false,"comment_ctime":1544533541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544533541","product_id":100010301,"comment_content":"老师您好，想问下B类继承A类，A类跟B类都有成员变量a，那A a = new B(); System.out.println(a.a); 打印出来的是A类中a的值。想问下虚拟机这一块是怎么处理的呢？","like_count":0},{"had_liked":false,"id":46712,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1543973350,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543973350","product_id":100010301,"comment_content":"哇偶，我的结果很迷...<br>PS C:\\JavaTestCase\\border&gt; java Passenger<br>7034<br>6761<br>PS C:\\JavaTestCase\\border&gt; java -XX:CompileCommand=&#39;dontinline,*. getAborded&#39; Passenger<br>CompilerOracle: dontinline *.getAborded<br>7002<br>6688<br><br>没有大的性能差距..... win 10, JDK 8;","like_count":0},{"had_liked":false,"id":37653,"user_name":"依然","can_delete":false,"product_type":"c1","uid":1142684,"ip_address":"","ucode":"BF63D22A2740D0","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/9c/14560e94.jpg","comment_is_top":false,"comment_ctime":1541667067,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1541667067","product_id":100010301,"comment_content":"➜  src java -XX:CompileCommand=&#39;dontinline,*.exit&#39; com.hza.jike.test05.Passenger<br>CompilerOracle: dontinline *.exit<br>coste 0 ms<br>coste 2643 ms<br>➜  src java com.hza.jike.test05.Passenger                                       <br>coste 0 ms<br>coste 803 ms<br>➜  src<br><br>差距确认大，不过我的第一次都是0吗","like_count":0},{"had_liked":false,"id":37257,"user_name":"李奋斗","can_delete":false,"product_type":"c1","uid":1068509,"ip_address":"","ucode":"0E2E39E733B9BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/dd/912b52ed.jpg","comment_is_top":false,"comment_ctime":1541509628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541509628","product_id":100010301,"comment_content":"小改，代码如下，可运行。<br>&#47;&#47; Run with: java -XX:CompileCommand=&#39;dontinline,*.depart&#39; Passenger<br>public abstract class Passenger {<br>    abstract void depart();<br>    public static void main(String[] args) {<br>        Passenger a = new ChinesePassenger();<br>        Passenger b = new ForeignerPassenger();<br>        long current = System.currentTimeMillis();<br>        for (int i = 1; i &lt;= 2_000_000_000; i++) {<br>            if (i % 100_000_000 == 0) {<br>                long temp = System.currentTimeMillis();<br>                System.out.println(temp - current);<br>                current = temp;<br>            }<br>            Passenger c = (i &lt; 1_000_000_000) ? a : b;<br>            c.depart();<br>        }<br>    }<br>}<br><br>class ChinesePassenger extends Passenger {<br>    @Override<br>    void depart() {<br>    }<br>}<br><br>class ForeignerPassenger extends Passenger {<br>    @Override<br>    void depart() {<br>    }<br>}","like_count":0},{"had_liked":false,"id":35113,"user_name":"liuyitao","can_delete":false,"product_type":"c1","uid":1048898,"ip_address":"","ucode":"9DAD087C3DD74E","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/42/39fa3b84.jpg","comment_is_top":false,"comment_ctime":1540428638,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1540428638","product_id":100010301,"comment_content":"老师，方法表为什么是数组呢？用哈希结构不是更快吗？因为此时空间更重要？","like_count":0,"discussions":[{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40997,"discussion_content":"查找方法，方法表依靠整型索引查找，不需要再哈希了，用数组减少了哈希时间，会更快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572320616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1124914,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/32/6354a589.jpg","nickname":"小卡向前冲","note":"","ucode":"1C8908A61FA00B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26725,"discussion_content":"弱弱问句，hash结构好像也用的数组吧。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570615411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32586,"user_name":"有时也，命也，运也，如之奈何？","can_delete":false,"product_type":"c1","uid":1181147,"ip_address":"","ucode":"792624AA1B2D9C","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/db/1bd78419.jpg","comment_is_top":false,"comment_ctime":1539616575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539616575","product_id":100010301,"comment_content":"豁然开朗，拆解的够透彻。","like_count":0},{"had_liked":false,"id":30668,"user_name":"likun","can_delete":false,"product_type":"c1","uid":1030816,"ip_address":"","ucode":"9145ED059CCC6D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/a0/f03d20cd.jpg","comment_is_top":false,"comment_ctime":1538969454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538969454","product_id":100010301,"comment_content":"你好 复习测试遇到了一个问题 课后题修改了一下当类型又切回已缓存的单态类型时耗时介于两者之间且有明显的跨度 这是为什么呢？望有空可以解答一下 谢谢","like_count":0},{"had_liked":false,"id":29218,"user_name":"崔不武","can_delete":false,"product_type":"c1","uid":1063083,"ip_address":"","ucode":"91A4D942D1E967","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/ab/6cb799ea.jpg","comment_is_top":false,"comment_ctime":1538291320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538291320","product_id":100010301,"comment_content":"请问郑老师，单态内联缓存什么时候触发呢？这个缓存的作用范围是单线程还是全虚拟机呢？","like_count":0},{"had_liked":false,"id":28544,"user_name":"ZY","can_delete":false,"product_type":"c1","uid":1228486,"ip_address":"","ucode":"35704C4BC05017","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/c6/8a92bd2e.jpg","comment_is_top":false,"comment_ctime":1538101385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538101385","product_id":100010301,"comment_content":"- 单态(monomorphic)内联缓存：（缓存遇到的第一个，永不替换）<br>- 多态(polymorphic)内联缓存：（HotSpot里不存在，猜想就是缓存前N个，估计也永不替换）<br>- 超多态状态&#47;超太态内联缓存：（直接方法表）<br><br>这是我的想法。。不知道对不对","like_count":0},{"had_liked":false,"id":28542,"user_name":"ZY","can_delete":false,"product_type":"c1","uid":1228486,"ip_address":"","ucode":"35704C4BC05017","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/c6/8a92bd2e.jpg","comment_is_top":false,"comment_ctime":1538101230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538101230","product_id":100010301,"comment_content":"前5个为有内联缓存的情况，后5个被劣化为超多态内联缓存（其实就是方法表访问），这个缓存压根没有替换的过程。。这个超多态内联缓存。。是挂羊头卖狗肉吗。。","like_count":0},{"had_liked":false,"id":22196,"user_name":"之外^Excepts","can_delete":false,"product_type":"c1","uid":1035331,"ip_address":"","ucode":"FD2284F65DB22F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/43/59a9b4ae.jpg","comment_is_top":false,"comment_ctime":1535548117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535548117","product_id":100010301,"comment_content":"告诉了我：打老板脸有多爽😂<br>","like_count":0},{"had_liked":false,"id":21419,"user_name":"allwmh","can_delete":false,"product_type":"c1","uid":1031572,"ip_address":"","ucode":"8B596EEFE9083A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/94/d4499319.jpg","comment_is_top":false,"comment_ctime":1535074905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535074905","product_id":100010301,"comment_content":"问下方法的内联缓存 是什么样的结构，它的作用范围是什么（全vm，类或者其他）？","like_count":0},{"had_liked":false,"id":20496,"user_name":"乔毅","can_delete":false,"product_type":"c1","uid":1196561,"ip_address":"","ucode":"7AAA209C173AEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/42/11/f26d89fd.jpg","comment_is_top":false,"comment_ctime":1534483318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534483318","product_id":100010301,"comment_content":"感觉还是没理解。虚函数调用开销主要是查表带来的，文中又说查表只是内存解引用成本可以忽略不计。但从课后的例子看有没有查表的缓存，差距有小一倍，所以结论是查表的影响还是挺大的？","like_count":0},{"had_liked":false,"id":19707,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1533982191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533982191","product_id":100010301,"comment_content":"清晰易懂，赞","like_count":0},{"had_liked":false,"id":19691,"user_name":"hacker time","can_delete":false,"product_type":"c1","uid":1017296,"ip_address":"","ucode":"41F0870C832ECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/d0/71bc9d31.jpg","comment_is_top":false,"comment_ctime":1533972779,"is_pvip":false,"replies":[{"id":"7069","content":"这里指的是HotSpot的情况，它不存在多态内联缓存。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534327644,"ip_address":"","comment_id":19691,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1533972779","product_id":100010301,"comment_content":"单态的用内联缓存，超多态的劣化为方法表+索引，那多态的呢？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421941,"discussion_content":"这里指的是HotSpot的情况，它不存在多态内联缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534327644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18686,"user_name":"Bale","can_delete":false,"product_type":"c1","uid":1189349,"ip_address":"","ucode":"F9AABEA9ED24C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/25/e5/921492c1.jpg","comment_is_top":false,"comment_ctime":1533549557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533549557","product_id":100010301,"comment_content":"老师，我只有第一次能成功出现，关掉inline 功能会变的慢一些。<br>如果我不清除缓存的，执行命令和不带命令的时间几乎相等。<br>但是我清除内存，就会重现结果。<br>Jvm会缓存 我执行过的java类嘛？","like_count":0},{"had_liked":false,"id":18542,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1533438359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533438359","product_id":100010301,"comment_content":"为什么在我电脑上运行实验的结果是这样<br>java 乘客<br><br>打印:<br>961<br>1740<br><br>java -XX:CompileCommand=&quot;dontinline, *.*&quot; 乘客<br><br>打印:<br>3164<br>3506<br><br>禁止方法内联之后，反而差别不大了","like_count":0},{"had_liked":false,"id":18532,"user_name":"一只智障","can_delete":false,"product_type":"c1","uid":1134906,"ip_address":"","ucode":"AAEDAE771516E0","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/3a/95168093.jpg","comment_is_top":false,"comment_ctime":1533434265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533434265","product_id":100010301,"comment_content":"内联缓存再碰到没有缓存的目标类以及目标方法，那么会去方法表中寻找，那为什么内联表不把这个没有命中的方法缓存下来供下次使用呢？","like_count":0},{"had_liked":false,"id":18520,"user_name":"丝竹悠扬","can_delete":false,"product_type":"c1","uid":1178606,"ip_address":"","ucode":"BD8B2EC8D362F2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/ee/269c6a96.jpg","comment_is_top":false,"comment_ctime":1533406384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533406384","product_id":100010301,"comment_content":"挺好的，好想可以听懂点","like_count":0},{"had_liked":false,"id":18391,"user_name":"蠢蠢欲动的腹肌","can_delete":false,"product_type":"c1","uid":1007326,"ip_address":"","ucode":"B10550BF463017","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/de/4e7ec66d.jpg","comment_is_top":false,"comment_ctime":1533288437,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1533288437","product_id":100010301,"comment_content":"老师，请问下，在准备阶段生成的方法表存储在哪里？","like_count":0,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337833,"discussion_content":"方法表在编译的时候就生成了，就在class字节码中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609082953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18245,"user_name":"Grubby🐑","can_delete":false,"product_type":"c1","uid":1181905,"ip_address":"","ucode":"26B9256226F919","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/d1/3c7747ef.jpg","comment_is_top":false,"comment_ctime":1533210487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533210487","product_id":100010301,"comment_content":"内联缓存是针对每个类的吗？就是说两个不同父类的子类，在jvm里有两个内联缓存？","like_count":0},{"had_liked":false,"id":18184,"user_name":"熊猫酒仙","can_delete":false,"product_type":"c1","uid":1112078,"ip_address":"","ucode":"17002C7A355EC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/0e/de697f9b.jpg","comment_is_top":false,"comment_ctime":1533177484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533177484","product_id":100010301,"comment_content":"想问下老师，方法作为参数传递，传递的是方法地址吗？这种情况，执行时是否不存在查找方法的过程？<br>另外假如两个类的方法互相调用，互相需要对方的方法信息，(排除其他依赖的情况)那么这两个类的加载是并行还是串行呢？","like_count":0}]}