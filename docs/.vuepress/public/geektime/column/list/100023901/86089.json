{"id":86089,"title":"08 | 管程：并发编程的万能钥匙","content":"<p>并发编程这个技术领域已经发展了半个世纪了，相关的理论和技术纷繁复杂。那有没有一种核心技术可以很方便地解决我们的并发问题呢？这个问题如果让我选择，我一定会选择<strong>管程技术</strong>。Java语言在1.5之前，提供的唯一的并发原语就是管程，而且1.5之后提供的SDK并发包，也是以管程技术为基础的。除此之外，C/C++、C#等高级语言也都支持管程。</p><p>可以这么说，管程就是一把解决并发问题的万能钥匙。</p><h2>什么是管程</h2><p>不知道你是否曾思考过这个问题：为什么Java在1.5之前仅仅提供了synchronized关键字及wait()、notify()、notifyAll()这三个看似从天而降的方法？在刚接触Java的时候，我以为它会提供信号量这种编程原语，因为操作系统原理课程告诉我，用信号量能解决所有并发问题，结果我发现不是。后来我找到了原因：Java采用的是管程技术，synchronized关键字及wait()、notify()、notifyAll()这三个方法都是管程的组成部分。而<strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。</strong>但是管程更容易使用，所以Java选择了管程。</p><p>管程，对应的英文是Monitor，很多Java领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”。</p><!-- [[[read_end]]] --><p>所谓<strong>管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发</strong>。翻译为Java领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。那管程是怎么管的呢？</p><h2>MESA模型</h2><p>在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen模型、Hoare模型和MESA模型。其中，现在广泛应用的是MESA模型，并且Java管程的实现参考的也是MESA模型。所以今天我们重点介绍一下MESA模型。</p><p>在并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。</p><p>我们先来看看管程是如何解决<strong>互斥</strong>问题的。</p><p>管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。假如我们要实现一个线程安全的阻塞队列，一个最直观的想法就是：将线程不安全的队列封装起来，对外提供线程安全的操作方法，例如入队操作和出队操作。</p><p>利用管程，可以快速实现这个直观的想法。在下图中，管程X将共享变量queue这个线程不安全的队列和相关的操作入队操作enq()、出队操作deq()都封装起来了；线程A和线程B如果想访问共享变量queue，只能通过调用管程提供的enq()、deq()方法来实现；enq()、deq()保证互斥性，只允许一个线程进入管程。</p><p>不知你有没有发现，管程模型和面向对象高度契合的。估计这也是Java选择管程的原因吧。而我在前面章节介绍的互斥锁用法，其背后的模型其实就是它。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/c4/592e33c4339c443728cdf82ab3d318c4.png?wh=1142*714\" alt=\"\" title=\"管程模型的代码化语义\"></p><p>那管程如何解决线程间的<strong>同步</strong>问题呢？</p><p>这个就比较复杂了，不过你可以借鉴一下我们曾经提到过的就医流程，它可以帮助你快速地理解这个问题。为进一步便于你理解，在下面，我展示了一幅MESA管程模型示意图，它详细描述了MESA模型的主要组成部分。</p><p>在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。这个过程类似就医流程的分诊，只允许一个患者就诊，其他患者都在门口等待。</p><p>管程里还引入了条件变量的概念，而且<strong>每个条件变量都对应有一个等待队列，</strong>如下图，条件变量A和条件变量B分别都有自己的等待队列。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/65/839377608f47e7b3b9c79b8fad144065.png?wh=1142*765\" alt=\"\" title=\"MESA管程模型\"></p><p>那<strong>条件变量</strong>和<strong>条件变量等待队列</strong>的作用是什么呢？其实就是解决线程同步问题。你可以结合上面提到的阻塞队列的例子加深一下理解（阻塞队列的例子，是用管程来实现线程安全的阻塞队列，这个阻塞队列和管程内部的等待队列没有关系，本文中<strong>一定要注意阻塞队列和等待队列是不同的</strong>）。</p><p>假设有个线程T1执行阻塞队列的出队操作，执行出队操作，需要注意有个前提条件，就是阻塞队列不能是空的（空队列只能出Null值，是不允许的），<strong>阻塞队列不空</strong>这个前提条件对应的就是管程里的条件变量。 如果线程T1进入管程后恰好发现阻塞队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的<strong>等待队列</strong>里面等。此时线程T1就去“队列不空”这个条件变量的等待队列中等待。这个过程类似于大夫发现你要去验个血，于是给你开了个验血的单子，你呢就去验血的队伍里排队。线程T1进入条件变量的等待队列后，是允许其他线程进入管程的。这和你去验血的时候，医生可以给其他患者诊治，道理都是一样的。</p><p>再假设之后另外一个线程T2执行阻塞队列的入队操作，入队操作执行成功之后，<strong>“阻塞队列不空”<strong>这个条件对于线程T1来说已经满足了，此时线程T2要通知T1，告诉它需要的条件已经满足了。当线程T1得到通知后，会从</strong>等待队列</strong>里面出来，但是出来之后不是马上执行，而是重新进入到<strong>入口等待队列</strong>里面。这个过程类似你验血完，回来找大夫，需要重新分诊。</p><p>条件变量及其等待队列我们讲清楚了，下面再说说wait()、notify()、notifyAll()这三个操作。前面提到线程T1发现“阻塞队列不空”这个条件不满足，需要进到对应的<strong>等待队列</strong>里等待。这个过程就是通过调用wait()来实现的。如果我们用对象A代表“阻塞队列不空”这个条件，那么线程T1需要调用A.wait()。同理当“阻塞队列不空”这个条件满足时，线程T2需要调用A.notify()来通知A等待队列中的一个线程，此时这个等待队列里面只有线程T1。至于notifyAll()这个方法，它可以通知等待队列中的所有线程。</p><p>这里我还是来一段代码再次说明一下吧。下面的代码用管程实现了一个线程安全的阻塞队列（再次强调：这个阻塞队列和管程内部的等待队列没关系，示例代码只是用管程来实现阻塞队列，而不是解释管程内部等待队列的实现原理）。阻塞队列有两个操作分别是入队和出队，这两个方法都是先获取互斥锁，类比管程模型中的入口。</p><ol>\n<li>对于阻塞队列的入队操作，如果阻塞队列已满，就需要等待直到阻塞队列不满，所以这里用了<code>notFull.await();</code>。</li>\n<li>对于阻塞出队操作，如果阻塞队列为空，就需要等待直到阻塞队列不空，所以就用了<code>notEmpty.await();</code>。</li>\n<li>如果入队成功，那么阻塞队列就不空了，就需要通知条件变量：阻塞队列不空<code>notEmpty</code>对应的等待队列。</li>\n<li>如果出队成功，那就阻塞队列就不满了，就需要通知条件变量：阻塞队列不满<code>notFull</code>对应的等待队列。</li>\n</ol><pre><code>public class BlockedQueue&lt;T&gt;{\n  final Lock lock =\n    new ReentrantLock();\n  // 条件变量：队列不满  \n  final Condition notFull =\n    lock.newCondition();\n  // 条件变量：队列不空  \n  final Condition notEmpty =\n    lock.newCondition();\n\n  // 入队\n  void enq(T x) {\n    lock.lock();\n    try {\n      while (队列已满){\n        // 等待队列不满 \n        notFull.await();\n      }  \n      // 省略入队操作...\n      //入队后,通知可出队\n      notEmpty.signal();\n    }finally {\n      lock.unlock();\n    }\n  }\n  // 出队\n  void deq(){\n    lock.lock();\n    try {\n      while (队列已空){\n        // 等待队列不空\n        notEmpty.await();\n      }\n      // 省略出队操作...\n      //出队后，通知可入队\n      notFull.signal();\n    }finally {\n      lock.unlock();\n    }  \n  }\n}\n</code></pre><p>在这段示例代码中，我们用了Java并发包里面的Lock和Condition，如果你看着吃力，也没关系，后面我们还会详细介绍，这个例子只是先让你明白条件变量及其等待队列是怎么回事。需要注意的是：<strong>await()和前面我们提到的wait()语义是一样的；signal()和前面我们提到的notify()语义是一样的</strong>。</p><h2>wait()的正确姿势</h2><p>但是有一点，需要再次提醒，对于MESA管程来说，有一个编程范式，就是需要在一个while循环里面调用wait()。<strong>这个是MESA管程特有的</strong>。</p><pre><code>\nwhile(条件不满足) {\n  wait();\n}\n</code></pre><p>Hasen模型、Hoare模型和MESA模型的一个核心区别就是当条件满足后，如何通知相关线程。管程要求同一时刻只允许一个线程执行，那当线程T2的操作使线程T1等待的条件满足时，T1和T2究竟谁可以执行呢？</p><ol>\n<li>Hasen模型里面，要求notify()放在代码的最后，这样T2通知完T1后，T2就结束了，然后T1再执行，这样就能保证同一时刻只有一个线程执行。</li>\n<li>Hoare模型里面，T2通知完T1后，T2阻塞，T1马上执行；等T1执行完，再唤醒T2，也能保证同一时刻只有一个线程执行。但是相比Hasen模型，T2多了一次阻塞唤醒操作。</li>\n<li>MESA管程里面，T2通知完T1后，T2还是会接着执行，T1并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是notify()不用放到代码的最后，T2也没有多余的阻塞唤醒操作。但是也有个副作用，就是当T1再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。</li>\n</ol><h2>notify()何时可以使用</h2><p>还有一个需要注意的地方，就是notify()和notifyAll()的使用，前面章节，我曾经介绍过，<strong>除非经过深思熟虑，否则尽量使用notifyAll()</strong>。那什么时候可以使用notify()呢？需要满足以下三个条件：</p><ol>\n<li>所有等待线程拥有相同的等待条件；</li>\n<li>所有等待线程被唤醒后，执行相同的操作；</li>\n<li>只需要唤醒一个线程。</li>\n</ol><p>比如上面阻塞队列的例子中，对于“阻塞队列不满”这个条件变量，其等待线程都是在等待“阻塞队列不满”这个条件，反映在代码里就是下面这3行代码。对所有等待线程来说，都是执行这3行代码，<strong>重点是 while 里面的等待条件是完全相同的</strong>。</p><pre><code>\nwhile (阻塞队列已满){\n  // 等待队列不满\n  notFull.await();\n}\n</code></pre><p>所有等待线程被唤醒后执行的操作也是相同的，都是下面这几行：</p><pre><code>\n// 省略入队操作...\n// 入队后,通知可出队\nnotEmpty.signal();\n</code></pre><p>同时也满足第3条，只需要唤醒一个线程。所以上面阻塞队列的代码，使用signal()是可以的。</p><h2>总结</h2><p>管程是一个解决并发问题的模型，你可以参考医院就医的流程来加深理解。理解这个模型的重点在于理解条件变量及其等待队列的工作原理。</p><p>Java参考了MESA模型，语言内置的管程（synchronized）对MESA模型进行了精简。MESA模型中，条件变量可以有多个，Java语言内置的管程里只有一个条件变量。具体如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/57/fa/57e4d94e90226b70be3d57024f5333fa.png?wh=1142*714\" alt=\"\" title=\"Java中的管程示意图\"></p><p>Java内置的管程方案（synchronized）使用简单，synchronized关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而Java SDK并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。</p><p>并发编程里两大核心问题——互斥和同步，都可以由管程来帮你解决。学好管程，理论上所有的并发问题你都可以解决，并且很多并发工具类底层都是管程实现的，所以学好管程，就是相当于掌握了一把并发编程的万能钥匙。</p><h2>课后思考</h2><p>wait()方法，在Hasen模型和Hoare模型里面，都是没有参数的，而在MESA模型里面，增加了超时参数，你觉得这个参数有必要吗？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"07 | 安全性、活跃性以及性能问题","id":85702},"right":{"article_title":"09 | Java线程（上）：Java线程的生命周期","id":86366}},"comments":[{"had_liked":false,"id":119622,"user_name":"Geek_be4cec","can_delete":false,"product_type":"c1","uid":1581294,"ip_address":"","ucode":"C87642D655EAC3","user_header":"","comment_is_top":false,"comment_ctime":1564639986,"is_pvip":false,"replies":[{"id":"44016","content":"👍","user_name":"作者回复","comment_id":119622,"uid":"1269969","ip_address":"","utype":1,"ctime":1564719406,"user_name_real":"王宝令"}],"discussion_count":33,"race_medal":0,"score":"1444673651442","product_id":100023901,"comment_content":"本节说的可能并不好。该篇我看了三遍也没能完全看懂，于是自己搜索java管程相关的技术文章，才大致对管程有了个认知，总结如下：<br>1.管程是一种概念，任何语言都可以通用。<br>2.在java中，每个加锁的对象都绑定着一个管程（监视器）<br>3.线程访问加锁对象，就是去拥有一个监视器的过程。如一个病人去门诊室看医生，医生是共享资源，门锁锁定医生，病人去看医生，就是访问医生这个共享资源，门诊室其实是监视器（管程）。<br>4.所有线程访问共享资源，都需要先拥有监视器。就像所有病人看病都需要先拥有进入门诊室的资格。<br>5.监视器至少有两个等待队列。一个是进入监视器的等待队列一个是条件变量对应的等待队列。后者可以有多个。就像一个病人进入门诊室诊断后，需要去验血，那么它需要去抽血室排队等待。另外一个病人心脏不舒服，需要去拍胸片，去拍摄室等待。<br>6.监视器要求的条件满足后，位于条件变量下等待的线程需要重新在门诊室门外排队，等待进入监视器。就像抽血的那位，抽完后，拿到了化验单，然后，重新回到门诊室等待，然后进入看病，然后退出，医生通知下一位进入。<br><br>总结起来就是，管程就是一个对象监视器。任何线程想要访问该资源，就要排队进入监控范围。进入之后，接受检查，不符合条件，则要继续等待，直到被通知，然后继续进入监视器。","like_count":337,"discussions":[{"author":{"id":2029333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLujLByemCGmjp9rIicdoC59XUh99WiargBmxOMtsLlmntyEklh3LyiahtzAz3fnUu0tWwvibTqOFt5A/132","nickname":"hammer","note":"","ucode":"D98A31ACE2158F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292287,"discussion_content":"这章讲的确实不好","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1595167141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87153,"discussion_content":"为什么我觉得一下就懂了~","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1576647634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1475385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/83/39/f9623363.jpg","nickname":"竹马彦四郎的好朋友影法師","note":"","ucode":"A9555AEFF90CDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","nickname":"淞淞同学","note":"","ucode":"529A326B898008","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":349323,"discussion_content":"因为的确很好懂啊~ ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613057915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87153,"ip_address":""},"score":349323,"extra":""}]},{"author":{"id":1907867,"avatar":"","nickname":"Geek_f8b226","note":"","ucode":"6FCAA1B0E65018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356877,"discussion_content":"这节你总结比老师好多，老师讲的会误解人，如果没有一定技术的情况下","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1615694441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318356,"discussion_content":"建议看一下Monitor的内部实现而不是只去搜索Monitor的概念，再回头看这篇文章，就清晰多了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603717324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2129391,"avatar":"","nickname":"常正午","note":"","ucode":"5F463160C0FDFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361023,"discussion_content":"这节看完，我也没完全看懂，特别是举的医院排队的例子。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616581626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1428043,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","nickname":"蚝不鱿鱼","note":"","ucode":"5DB98E406F1D3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306094,"discussion_content":"我也看了三遍了，但还是有点懵","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600168151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460985,"discussion_content":"👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564719406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1387088,"avatar":"","nickname":"再次遇见你","note":"","ucode":"09FC74C305F870","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552738,"discussion_content":"老师还是有格局，能虚心接受","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645582704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":460985,"ip_address":""},"score":552738,"extra":""},{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1387088,"avatar":"","nickname":"再次遇见你","note":"","ucode":"09FC74C305F870","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588619,"discussion_content":"确实不好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663912083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552738,"ip_address":"北京"},"score":588619,"extra":""}]},{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367074,"discussion_content":"看完synchronized和reentrantlock的实现后，第二次看这篇文章，有种恍然大悟的感觉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618243243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603420,"avatar":"https://static001.geekbang.org/account/avatar/00/18/77/5c/5d6fb47b.jpg","nickname":"小强（jacky）","note":"","ucode":"C6C26A2FE0F767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309389,"discussion_content":"这样解释会更好理解点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601277929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3191095,"avatar":"","nickname":"Geek_27e511","note":"","ucode":"68FE63A2F8A520","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589382,"discussion_content":"对大多数的JAVA 程序员来说， 其实已经接受了监视器的概念。 再回来看老师的这一节， 监视器突然变成了一个叫管程的东西，反而被搞糊涂了。 这也是很多人觉得这一节讲得不好的原因。 感觉是刻意想把管程套过来一样， 大概因为篇幅有限吧，感觉细节不够， 跳跃。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664787622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055475,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","nickname":"iLeGeND","note":"","ucode":"4055A628A6E97C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588617,"discussion_content":"很不好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663911836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033503,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/1f/485fcff9.jpg","nickname":"良记","note":"","ucode":"F78CC56BB32D8F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583897,"discussion_content":"进入诊室的资格，应该是类似挂号吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660473854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2055809,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","nickname":"码小呆","note":"","ucode":"44532D6ABF9340","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577603,"discussion_content":"这么说就懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656226188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153068,"avatar":"https://static001.geekbang.org/account/avatar/00/11/98/2c/8bca12a6.jpg","nickname":"playgame","note":"","ucode":"4A8FC3B39B7ECB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575003,"discussion_content":"不是必须两个队列吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654518743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2179936,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIT0yX4KniaW8CjDmtRxXz1XhBWYicV8ice4fAycvx9CxticYAfw0AlSymk1HYKCUn1m3JTukKNqC8ZTg/132","nickname":"白马啸西风","note":"","ucode":"EDF0A2BD3DC8DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571216,"discussion_content":"这个评论优秀了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652142572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109640,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","nickname":"chris","note":"","ucode":"6663E3E09457E3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568556,"discussion_content":"确实老师没太懂，你的清晰明了多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651160445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2051293,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","nickname":"Bumblebee","note":"","ucode":"B879C8A511D08D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550866,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644763181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1802784,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/82/20/cecac9e1.jpg","nickname":"Distant","note":"","ucode":"8C092C0A1F9EEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534997,"discussion_content":"这个评论很优秀，一下就看懂了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638329645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405701,"discussion_content":" 原来不止我一个人看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634626501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372722,"discussion_content":"或许看第四遍的时候就懂了;\n我的感觉是每看一遍, 都有收获, 并且每看一遍, 都体会到作者整篇专栏的脉络.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620442486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364962,"discussion_content":"一遍就过了，打好基础，看啥都快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617672672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256923,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkeBKshjwVKcpVTs1kGkPibsD5j8odoY6oHrMU1EHqDVjHoLLqzknOd8Q0aWxTDCJjvK1NJIX5Ncg/132","nickname":"Summer","note":"","ucode":"6E51D5574C1EFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356527,"discussion_content":"写的真好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615617438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1773471,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/0f/9f/caae319d.jpg","nickname":"max","note":"","ucode":"91DDE86511DCDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292997,"discussion_content":"66","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595407266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLujLByemCGmjp9rIicdoC59XUh99WiargBmxOMtsLlmntyEklh3LyiahtzAz3fnUu0tWwvibTqOFt5A/132","nickname":"hammer","note":"","ucode":"D98A31ACE2158F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292289,"discussion_content":"”每个被当做锁的对象都有一个监视器”， 这样讲是不是更好，还是我理解的有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595167310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1075398,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/IqH9OdFUEicicrfrePKh0b5ASCqZAMjuJjvexNqicaET8icWByuibyVTBeoibQpD7fDNyW4ia0nkXJDLficykBkZiadqibXQ/132","nickname":"正哥","note":"","ucode":"46BD08EE09C4D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2029333,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erLujLByemCGmjp9rIicdoC59XUh99WiargBmxOMtsLlmntyEklh3LyiahtzAz3fnUu0tWwvibTqOFt5A/132","nickname":"hammer","note":"","ucode":"D98A31ACE2158F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333946,"discussion_content":"这里的“监视器”就是“管程”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607677506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292289,"ip_address":""},"score":333946,"extra":""}]},{"author":{"id":1323652,"avatar":"","nickname":"sibyl","note":"","ucode":"0D142011860D69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289417,"discussion_content":"不赞同管程就是一个对象监视器这种说法，这就把管城的概念降到信号量的层次了，以信号量来说，共享产量的方法不是线程安全的，需要调用方自己使用信号量来保证线程安全，那对调用方来说很可能用错，而管程要求共享变量提供线程安全的方法，更加安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594094191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1495977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d3/a9/36e59707.jpg","nickname":"行道有德","note":"","ucode":"92B2A5A6E8E7C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282304,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591937060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276133,"discussion_content":"总结得不错，清晰了不少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590824634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275401,"discussion_content":"确实清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590713684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/73/9ab38243.jpg","nickname":"xiaoxionga","note":"","ucode":"2BB02B54C31EBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193085,"discussion_content":"惊了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583121932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78879,"user_name":"Hour","can_delete":false,"product_type":"c1","uid":1448748,"ip_address":"","ucode":"AA1045ACABC0BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","comment_is_top":false,"comment_ctime":1553266285,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"839071889005","product_id":100023901,"comment_content":"今天又用代码验证了下，终于明白为啥用while了！<br><br>当线程被唤醒后，是从wait命令后开始执行的(不是从头开始执行该方法，这点上老师的示意图容易让人产生歧义)，而执行时间点往往跟唤醒时间点不一致，所以条件变量此时不一定满足了，所以通过while循环可以再验证，而if条件却做不到，它只能从wait命令后开始执行，所以要用while<br><br>百看不一练😂😂😂😂<br>","like_count":196,"discussions":[{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289685,"discussion_content":"是需要重新排队获取锁的，因为wait肯定会释放锁，不然别的线程肯定进不来，既然别的线程进来了，肯定是要释放锁的，既然释放了，再次进来的时候肯定是要获取锁的。但是肯定是从wait之后的代码开始运行的，因为线程在放弃cpu执行权之前，会把相关寄存器--包括PC寄存器（保存的是下一次要执行的指令地址）保存在TCB（线程控制块），因为当该线程被唤醒后，重新获取锁后，开始执行时，从TCB中重新家在PC寄存器的值，一次是从wait之后开始运行的，所以需要while交验的（因为从唤醒到正式只执行是有一段时间的，此时状态可能已经发生变化）","likes_number":38,"is_delete":false,"is_hidden":false,"ctime":1594178892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105306,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/9a/abb7bfe3.jpg","nickname":"敏感的松散四维生物","note":"","ucode":"69CAAD84A6DD14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376523,"discussion_content":"“从wait命令后开始执行”这个也能被误解嘛？这边只是线程的阻塞和唤醒，线程的程序计数器和栈肯定不会改变啊，怎么有重新执行的误解呢。。。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1622173262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042218,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e7/2a/ff9eb2af.jpg","nickname":"Ztiany","note":"","ucode":"B1FF494F246F27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8206,"discussion_content":"图中的意思应该是需要重新排队获取锁。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1567829841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334377,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5c/69/1a4fa7d9.jpg","nickname":"beslet","note":"","ucode":"6A95C896558C11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320609,"discussion_content":"了解一下虚假唤醒，Linux的唤醒就有点类似notify all，有可能被其他的线程唤醒执行，导致条件不满足","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1604412009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1334377,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5c/69/1a4fa7d9.jpg","nickname":"beslet","note":"","ucode":"6A95C896558C11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560467,"discussion_content":"竟然还有虚假唤醒！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649340005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320609,"ip_address":""},"score":560467,"extra":""}]},{"author":{"id":1253310,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1f/be/551454e0.jpg","nickname":"zxy","note":"","ucode":"FFAA3F6667305D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45444,"discussion_content":"jdk的api中特意说过用while，当初看api时看到的。当时就有了notify虚假唤醒的概念","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573039405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368841,"discussion_content":"说的不对吧，当线程被唤醒后，是再次到入口等待对列等待cpu调度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618842302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372124,"discussion_content":"会去等待队列，等待成功后（获取到锁）会从wait的下一句开始执行呢。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1620203182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368841,"ip_address":""},"score":372124,"extra":""},{"author":{"id":2963434,"avatar":"","nickname":"Geek_94fa0e","note":"","ucode":"15BC7D4E130E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560468,"discussion_content":"再次尝试获得锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649340025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368841,"ip_address":""},"score":560468,"extra":""}]},{"author":{"id":1050114,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoG7YWJ0WsYoLalnJvPmKktLlfMicFg1fEzzgDgCcBgYoiaqILD4yAGwicWVC7iberRlAqNflL67Ju1g/132","nickname":"无意","note":"","ucode":"BD1A58F6F981BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346839,"discussion_content":"所以作者在前面讲的，唤醒之后，条件曾满足，这个曾是重点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612079167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1175383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/57/935c0ea1.jpg","nickname":"0+1","note":"","ucode":"03E5A11F8A3D37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283563,"discussion_content":"操作系统会由于中断引起伪唤醒，所以判断地方需要用while循环判断，避免是由于为唤醒引起的，因为伪唤醒不能修改notfull我们自己定义的条件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592297715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132392,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/68/5ca63fbe.jpg","nickname":"吴渣渣","note":"","ucode":"448638EEEEAF7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75844,"discussion_content":"应该是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575787973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193735,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/07/bbfe8989.jpg","nickname":"Louis","note":"","ucode":"36AA7B39587D5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64313,"discussion_content":"百看不如一练","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574945258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76718,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1552695934,"is_pvip":false,"replies":[{"id":"27997","content":"我觉得你真的理解了！！！！","user_name":"作者回复","comment_id":76718,"uid":"1269969","ip_address":"","utype":1,"ctime":1552705602,"user_name_real":"王宝令"}],"discussion_count":9,"race_medal":0,"score":"589963215486","product_id":100023901,"comment_content":"有hasen 是执行完，再去唤醒另外一个线程。能够保证线程的执行。hoare，是中断当前线程，唤醒另外一个线程，执行玩再去唤醒，也能够保证完成。而mesa是进入等待队列，不一定有机会能够执行。","like_count":137,"discussions":[{"author":{"id":1154315,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/CCxtruicg96320pfFbSiaLreNGqKhPiclgW7QibnXDCAv4MNc9uGfibby4kTSZaKaZP2YrxdFqh641TjP8ubkq6vIbQ/132","nickname":"alienhe","note":"","ucode":"69C36A4A557C39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8340,"discussion_content":"借个楼表达一下我的疑惑～～楼主的回答是基于管程模型来回答，但在Java中的wait方法参数只是为了防止其他线程没有执行notify操作导致永久阻塞是吗，但wait超时之后仍然是加入到管程的入口队列中，那岂不是意味着还是有可能出现竞争不过锁导致永远没有机会执行的可能？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567931122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154315,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/CCxtruicg96320pfFbSiaLreNGqKhPiclgW7QibnXDCAv4MNc9uGfibby4kTSZaKaZP2YrxdFqh641TjP8ubkq6vIbQ/132","nickname":"alienhe","note":"","ucode":"69C36A4A557C39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22724,"discussion_content":"原本应该有人叫你去食堂吃饭，wait加参数就是等了段时间，没人叫也去食堂排队了。。。但是即便去了如果一直有人插队，依然打不到饭，这个是饥饿问题http://ifeve.com/starvation-and-fairness/","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1569676032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8340,"ip_address":""},"score":22724,"extra":""},{"author":{"id":1177801,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/c9/17ec5476.jpg","nickname":"睡觉","note":"","ucode":"D60808857FE2FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326474,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605603398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":22724,"ip_address":""},"score":326474,"extra":""},{"author":{"id":1193167,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","nickname":"蝴蝶","note":"","ucode":"8019924D99182F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1154315,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/CCxtruicg96320pfFbSiaLreNGqKhPiclgW7QibnXDCAv4MNc9uGfibby4kTSZaKaZP2YrxdFqh641TjP8ubkq6vIbQ/132","nickname":"alienhe","note":"","ucode":"69C36A4A557C39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555467,"discussion_content":"我的理解，是 wait 设置等待时间，如果没有在等待时间内被唤醒，那就超时后会唤醒，进入入口等待队列，有概率获取到锁。如果不设置时间，那也许就永远不会有线程主动唤醒，那就完犊子了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1646920067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8340,"ip_address":""},"score":555467,"extra":""}]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443419,"discussion_content":"我觉得你真的理解了！！！！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1552705602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351012,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/64/272dc1b7.jpg","nickname":"圆滚滚","note":"","ucode":"E4D81822A87D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4653,"discussion_content":"超时时间过了以后，会怎么样？立即执行？还是继续等待？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565621199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446300,"avatar":"https://static001.geekbang.org/account/avatar/00/25/53/dc/11615706.jpg","nickname":"BattleMan1994","note":"","ucode":"9529E03AE789B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386558,"discussion_content":"哇，这个回答很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627635690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323621,"discussion_content":"������������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604975886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5857,"discussion_content":"学习学习，赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566488204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76913,"user_name":"三圆","can_delete":false,"product_type":"c1","uid":1322691,"ip_address":"","ucode":"22CA3D59BCACA3","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/c3/c690e719.jpg","comment_is_top":false,"comment_ctime":1552748775,"is_pvip":false,"replies":[{"id":"28074","content":"例子选的不好，让你误解了...","user_name":"作者回复","comment_id":76913,"uid":"1269969","ip_address":"","utype":1,"ctime":1552791148,"user_name_real":"王宝令"}],"discussion_count":13,"race_medal":0,"score":"409574641895","product_id":100023901,"comment_content":"看了三遍，终于明白了管程MESA模型了，刚开始一直在想线程T1执行出队是什么意思？到底是哪个队列，是入口等待队列，还是条件等待队列，后来理解了都不是。这个队列应该理解为JDK里面的阻塞队列，里面存在的是共享数据，线程T1,T2分别去操作里面的共享数据，执行数据的入队，出队操作，当然这些操作是阻塞操作。当线程T1对阻塞队列执行数据出队操作时，进入管程，发现阻塞队列为空，此时线程T1进入阻塞队列不为空这个条件的条件等待队列，此时，其他线程还是可以进入管程的，比如T2进来了，对阻塞队列执行数据插入操作，这时就会致使线程T1从条件等待队列出来，进入入口等待队列，准备再一次进入管程……至于wait方法的参数，还是有必要的，因为可能线程需要的条件可能一直无法满足！","like_count":95,"discussions":[{"author":{"id":1272321,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","nickname":"这得从我捡到一个鼠标垫开始说起","note":"","ucode":"2FF4347B4E7A9B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35728,"discussion_content":"那个例子很容易产生误会，建议重构一下","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571300853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2228,"discussion_content":"我已经习惯了，每次看不懂专栏的时候，就会先来看评论，果不其然，高手总是在评论区，^_^！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1563370131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098600,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/68/63fabc34.jpg","nickname":"流氓兔","note":"","ucode":"1A6AC1177BC17E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217355,"discussion_content":"看了半天真的没看懂，在评论区找到了，我也理解成管程里面的出队了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585548111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443498,"discussion_content":"例子选的不好，让你误解了...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1552791148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009220,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/44/f8032c04.jpg","nickname":"uangguan","note":"","ucode":"6FEDC33B452D4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":125423,"discussion_content":"怎么办，我还是看不懂～～～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578486402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624157,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c8/5d/1e3685e6.jpg","nickname":"Morse","note":"","ucode":"B09A716D79AE3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46554,"discussion_content":"感谢评论+1，一直以为是自己水平欠缺，看老师的例子反复看了几遍一直没明白，看了评论看懂了，高手啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573180594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323898,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSnNick0rxdU48sgQoRIX7ibm6zIMOUdg1FTJYQL7PACvIIyS8mr9Z9Uvu7oTiaFXZYsCAZvBwUqYcw/132","nickname":"zhouma","note":"","ucode":"0D26F2C671AF10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1509,"discussion_content":"同样是看评论看懂了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562668833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039112,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/db/08/9ef64ff4.jpg","nickname":"Ben","note":"","ucode":"8F5C7B354EAE33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1373,"discussion_content":"感谢评论，这个例子看了两遍都没看明白，看了评论才懂。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562587713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","nickname":"test","note":"","ucode":"9A4973E591DD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263661,"discussion_content":"我也是刚开始看没看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589240065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162790,"discussion_content":"有个问题，就是共享数据的那个阻塞队列为什么会出现队列已满的情况呢？出队入队操作我得理解就是共享数据就一份，当有线程把这个数据拿走了其他线程就获取不到了，感觉就和上锁一样，而当线程把数据给归还（入队）以后，共享数据又能被其他线程获取了，相当于释放锁，这个共享数据原本就是存在阻塞队列里的，不可能比阻塞队列的容量大呀？还是说我整体就理解错了，希望大佬们能够给解答一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581004578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326712,"discussion_content":"这就是一个生产者-消费者模式，把这个这个队列可以理解为是一个仓库，当生产者生产速度大于消费速度时，仓库有可能堆满，当仓库满时，生产者就只能等待仓库有空间了，才可以把产品放入仓库。当消费的速度大于生产速度时，仓库可能为空，没有产品可消费，消费者就只能等待。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605666048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162790,"ip_address":""},"score":326712,"extra":""},{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354919,"discussion_content":"共享数据的等待队列里面存的数据不是一直不变的，出队操作就是将阻塞队列中的一个数据取走，队列的这个位置就会空出来，不是像你说的把这个数据锁上，后面线程用完了再解锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615362239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162790,"ip_address":""},"score":354919,"extra":""}]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5709,"discussion_content":"我第一次就看懂了，可能之前看了一些并发相关的书，理解起来比较快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566443574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78650,"user_name":"Hour","can_delete":false,"product_type":"c1","uid":1448748,"ip_address":"","ucode":"AA1045ACABC0BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","comment_is_top":false,"comment_ctime":1553210937,"is_pvip":false,"replies":[{"id":"28667","content":"code1；<br>if (条件不满足)<br>  wait()<br>code2；<br><br>当调用wait()时，阻塞。被唤醒时，就直接执行code2了，没机会重新判断。","user_name":"作者回复","comment_id":78650,"uid":"1269969","ip_address":"","utype":1,"ctime":1553264138,"user_name_real":"王宝令"}],"discussion_count":14,"race_medal":0,"score":"289316019769","product_id":100023901,"comment_content":"老师，针对条件变量的while循环，还是不太理解，您说是范式，那它一定是为了解决特定的场景而强烈推荐的，也有评论说是为了解决虚假唤醒，但唤醒后，不也是从条件的等待队列进入到入口的等待队列，抢到锁后，重新进行条件变量的判断，用if完全可以啊，为什么必须是while，并且是范式？<br><br>望老师赐教！","like_count":67,"discussions":[{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199072,"discussion_content":"被唤醒后，从条件的等待队列进入到入口的等待队列，目的只是为了获取管程对应的锁，而不是重新进入管程提供的方法。\n所以抢到锁后，被唤醒的线程会从wait()的地方开始继续执行，而不是重新执行整个函数","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1583552973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1189580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/26/cc/719aec6d.jpg","nickname":"24","note":"","ucode":"F09DF49B6254E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277310,"discussion_content":"说的很对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591025415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199072,"ip_address":""},"score":277310,"extra":""},{"author":{"id":1186089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/19/29/4a8214b7.jpg","nickname":"Bug Killer","note":"","ucode":"2741A206F504E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307505,"discussion_content":"对的。关键是唤醒的线程会从wait()的地方开始执行","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600672181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199072,"ip_address":""},"score":307505,"extra":""},{"author":{"id":1002139,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/9b/62860a18.jpg","nickname":"飞鸿雪泥","note":"","ucode":"2DB1D631944805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341111,"discussion_content":"画龙点睛了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610293013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199072,"ip_address":""},"score":341111,"extra":""}]},{"author":{"id":1010943,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/ff/704ab221.jpg","nickname":"瞿晓峰","note":"","ucode":"E48F4FBD2FC410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345578,"discussion_content":"我觉得你理解的误区是；唤醒后是从await后开始执行，而不是从临界区入口开始执行","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1611745636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344281,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","nickname":"Evan","note":"","ucode":"B877ABD0CF4661","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204551,"discussion_content":"if（不满足条件）{ obj.wait() } 第一次执行是没有问题的，但没有机制再判断。因为notify 通知时是满足条件的，但唤醒线程再执行时，不一定满足条件，还需要再次判断（条件），所以就等相当获取CPU让渡执行操作   ","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584191256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444177,"discussion_content":"code1；\nif (条件不满足)\n  wait()\ncode2；\n\n当调用wait()时，阻塞。被唤醒时，就直接执行code2了，没机会重新判断。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1553264138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249827,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/23/d024dbdf.jpg","nickname":"放空","note":"","ucode":"A52C3B5D3A872D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284223,"discussion_content":"棒棒的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592476473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811236,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/24/66ea4fc7.jpg","nickname":"DK","note":"","ucode":"8C1F6949ECB534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236197,"discussion_content":"那不是有多个线程在执行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587081966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1587666,"avatar":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","nickname":"送过快递的码农","note":"","ucode":"66EA81B3BADC73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211042,"discussion_content":"仔细想想，终于明白了，有这个评论功能真的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584801317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/b0/260f41f0.jpg","nickname":"loris","note":"","ucode":"00842745CF4B31","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174119,"discussion_content":"这个解释很重要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581869438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83456,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1554608375,"is_pvip":false,"replies":[{"id":"30266","content":"总结很全面！","user_name":"作者回复","comment_id":83456,"uid":"1269969","ip_address":"","utype":1,"ctime":1554709309,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"250662711543","product_id":100023901,"comment_content":"管程的组成锁和0或者多个条件变量，java用两种方式实现了管程①synchronized+wait、notify、notifyAll②lock+内部的condition，第一种只支持一个条件变量，即wait，调用wait时会将其加到等待队列中，被notify时，会随机通知一个线程加到获取锁的等待队列中，第二种相对第一种condition支持中断和增加了时间的等待，lock需要自己进行加锁解锁，更加灵活，两个都是可重入锁，但是lock支持公平和非公平锁，synchronized支持非公平锁，老师，不知道理解的对不对","like_count":58,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446031,"discussion_content":"总结很全面！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554709309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053921,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","nickname":"Zend","note":"","ucode":"80EBB0B6772E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198070,"discussion_content":"synchronized为什么说是可重入锁的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583468886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053921,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","nickname":"Zend","note":"","ucode":"80EBB0B6772E27","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326718,"discussion_content":"这个你可以看看 synchronized的实现原理，在某个线程获取到锁后，会在锁的对象头中的Lock word 指向当前获取锁的线程的 Lock Record，表名当前线程拥有了该锁，当此线程再次进入时，判断对象头中存储的线程锁记录和当前线程一致，则允许进入，但是所记录数会加1。可参考 http://yby.ink/?p=16","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1605666775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198070,"ip_address":""},"score":326718,"extra":""}]}]},{"had_liked":false,"id":83216,"user_name":"白马居士","can_delete":false,"product_type":"c1","uid":1402543,"ip_address":"","ucode":"FEC41448BCDA4B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoEicva8I9I6jJONRUJuNQZCeNVUjXWSrlJLDMjGgFIgib36EDDvQtkT0PlBZc5jj3ib6dRJ3MtiaOgCw/132","comment_is_top":false,"comment_ctime":1554469414,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"181943095846","product_id":100023901,"comment_content":"第一次看到MESA管程模型的时候很膈应，为什么要满足队列不空才能出队，在对照了《Java并发编程艺术》后，现在再看这一章才意识到“队列不空”只是人为的设置的条件A，只是为了说明管程支持多条件控制并发而自己设置控制条件的一个特例，是自己的设置，具体是什么与模型无关；初次看到这段还以为是MESA管程模型规定了“队列不空”这个出队条件，所以特别混乱。","like_count":42,"discussions":[{"author":{"id":1178651,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/1b/7fa5823c.jpg","nickname":"在下令狐冲","note":"","ucode":"6228893CCF8C09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295051,"discussion_content":"两个条件命名换成canEenter和canOuter会比较好理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596075619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2220763,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e2/db/97c6f756.jpg","nickname":"_patrick","note":"","ucode":"B24C6EEBCABB94","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572291,"discussion_content":"“阻塞队列不空”  仅仅是一个条件A的例子。 实际上 这个条件可以是其他的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652693323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230031,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c4/cf/6e1205cc.jpg","nickname":"马晨阳","note":"","ucode":"344ACC3BF7F14A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383849,"discussion_content":"这个不赖老师吧，都说了是阻塞队列，这是阻塞队列的实现啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626253983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335725,"discussion_content":"优秀  我看的懵逼就是因为这个条件  我以为是MESA模型自己的一个条件呢  越看越懵逼了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608285090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83225,"user_name":"小李子","can_delete":false,"product_type":"c1","uid":1196293,"ip_address":"","ucode":"C5593E33CA6F4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/05/5ba603f2.jpg","comment_is_top":false,"comment_ctime":1554472720,"is_pvip":false,"replies":[{"id":"30120","content":"挺形象，就诊机会不一定大，但是能避免没人叫的时候傻等","user_name":"作者回复","comment_id":83225,"uid":"1269969","ip_address":"","utype":1,"ctime":1554539897,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"177648131856","product_id":100023901,"comment_content":"wait() 不加超时参数，相当于得一直等着别人叫你去门口排队，加了超时参数，相当于等一段时间，再没人叫的话，我就受不了自己去门口排队了，这样就诊的机会会大一点，是这样理解吧？","like_count":42,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445926,"discussion_content":"挺形象，就诊机会不一定大，但是能避免没人叫的时候傻等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554539897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142096,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/50/ec20d7d8.jpg","nickname":"梁起健","note":"","ucode":"D71ED6DA298309","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376554,"discussion_content":"但是会导致线程安全问题吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622188990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1084993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","nickname":"袁帅","note":"","ucode":"A71A89B9F1BD69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1142096,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/50/ec20d7d8.jpg","nickname":"梁起健","note":"","ucode":"D71ED6DA298309","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387783,"discussion_content":"不会有线程安全的问题，超时后自动唤醒，然后去检查条件是否满足，如果不满足又再次去条件变量里排队了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1628409691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376554,"ip_address":""},"score":387783,"extra":""}]},{"author":{"id":1168504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/78/66b3f2a2.jpg","nickname":"斯盖丸","note":"","ucode":"B881D14B028F14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346031,"discussion_content":"你的答案是最棒的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611843749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78224,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1553095951,"is_pvip":false,"replies":[{"id":"28687","content":"对","user_name":"作者回复","comment_id":78224,"uid":"1269969","ip_address":"","utype":1,"ctime":1553268973,"user_name_real":"王宝令"}],"discussion_count":6,"race_medal":0,"score":"147581984015","product_id":100023901,"comment_content":"老师，您好，结合第六讲，我的理解是：简单来说，一个锁实际上对应两个队列，一个是就绪队列，对应本节的入口等待队列，一个是阻塞队列，实际对应本节的条件变量等待队列，wait操作是把当前线程放入条件变量的等待队列中，而notifyall是将条件变量等待队列中的所有线程唤醒到就绪队列（入口等待队列）中，实际上哪个线程执行由jvm操作，我这样的理解对吗？","like_count":35,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444012,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553268973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2286802,"avatar":"","nickname":"Geek_072f8a","note":"","ucode":"830D4594E19D45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324040,"discussion_content":"条件等待队列不是阻塞队列，这两者无关文中已经说了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605029700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018706,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/52/6659dc1b.jpg","nickname":"黑米","note":"","ucode":"E7DBEA7867862A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2286802,"avatar":"","nickname":"Geek_072f8a","note":"","ucode":"830D4594E19D45","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391147,"discussion_content":"我觉得用阻塞队列来讲解这个本身有队列的东西就很混乱，本来简单的东西变复杂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630315684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324040,"ip_address":""},"score":391147,"extra":""}]},{"author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19983,"discussion_content":"其实在JDK中的管程是一个队列但阻塞和等待队列的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569246191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302960,"discussion_content":"是两个, _waitSet    _EntryList","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599098702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":19983,"ip_address":""},"score":302960,"extra":""}]},{"author":{"id":1430163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","nickname":"HUANGKAIHANG","note":"","ucode":"F3871C5142AE52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2954,"discussion_content":"按照热评第一的说法，条件变量等待队列不是阻塞队列，阻塞队列在文章的例子里，算是第三种队列了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564061205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77014,"user_name":"CCC","can_delete":false,"product_type":"c1","uid":1003738,"ip_address":"","ucode":"2E254444098267","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/da/ed4803cb.jpg","comment_is_top":false,"comment_ctime":1552804934,"is_pvip":false,"replies":[{"id":"28092","content":"内定都出来了，真是理论联系生活","user_name":"作者回复","comment_id":77014,"uid":"1269969","ip_address":"","utype":1,"ctime":1552813914,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"104632020038","product_id":100023901,"comment_content":"MESA模型和其他两种模型相比可以实现更好的公平性，因为唤醒只是把你放到队列里而不保证你一定可以执行，最后能不能执行还是要看你自己可不可以抢得到执行权也就是入口，其他两种模型是显式地唤醒，有点内定的意思了。","like_count":24,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443542,"discussion_content":"内定都出来了，真是理论联系生活","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552813914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290222,"discussion_content":"不公平的意思，可能你永远轮不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594380769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481963,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/eb/9ae21793.jpg","nickname":"🌊","note":"","ucode":"1A75E22D2628C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":686,"discussion_content":"有点钦定的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561960805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1481963,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/eb/9ae21793.jpg","nickname":"🌊","note":"","ucode":"1A75E22D2628C2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174725,"discussion_content":"ha","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581938821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":686,"ip_address":""},"score":174725,"extra":""}]}]},{"had_liked":false,"id":79976,"user_name":"红衣闪闪亮晶晶","can_delete":false,"product_type":"c1","uid":1442879,"ip_address":"","ucode":"34DE6E9D94CA18","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIZTw0bzR4licHwZW59AoJNzwN0oANiaYUWdTfmib9nfhMw6ubxEMDibwAeOWXkiad4FoALb5TOGTstYVw/132","comment_is_top":false,"comment_ctime":1553586787,"is_pvip":false,"replies":[{"id":"29492","content":"如果没超时，A线程wait了，由于代码的bug，没有其他线程notify，就会导致A一直wait。增加超时之后，A线程可以自己来决定是否继续等待。这样代码的健壮性会更好","user_name":"作者回复","comment_id":79976,"uid":"1269969","ip_address":"","utype":1,"ctime":1553907271,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"87452932707","product_id":100023901,"comment_content":"老师，我能明白如果t1线程被唤醒后再次进入等待队列，但是可能再次走到条件变量那里再次因为条件不满足随后再次开始等待，所以需要增加超时，所以当我给wait加了超时，时间到了以后t1再次开始while中的判断，如果满足便自己回到入口等待队列？<br>我这样理解对吗？","like_count":20,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444709,"discussion_content":"如果没超时，A线程wait了，由于代码的bug，没有其他线程notify，就会导致A一直wait。增加超时之后，A线程可以自己来决定是否继续等待。这样代码的健壮性会更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553907271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76784,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552707946,"is_pvip":false,"replies":[{"id":"28026","content":"我觉得你已经能把管程的运作在大脑里演绎出来了！","user_name":"作者回复","comment_id":76784,"uid":"1269969","ip_address":"","utype":1,"ctime":1552730104,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"78862119274","product_id":100023901,"comment_content":"重新回答思考题，问题变成wait的timeout参数是否必要。<br><br>在MESA模型中，线程T1被唤醒，从条件A的等待队列中（其实是一个set，list的话可能会重复）移除，并加入入口等待队列，重新与其他的线程竞争锁的控制权。那么有这样一种可能，线程T1的优先级比较低，并且经常地有高优先级的线程加入入口等待队列。每次当它获得锁的时候，条件已经不满足了（被高优先级的线程抢先破坏了条件）。即使T1可以得到调度，但是也没办法继续执行下去。<br><br>最后T1被饿死了（有点冷。。。）<br><br>另外我刚才的问题想通了。不需要实现像lock一样的条件对象，并调用condition.await(). Synchronized用判断条件+wait（）就可以了。<br>","like_count":18,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443444,"discussion_content":"我觉得你已经能把管程的运作在大脑里演绎出来了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552730104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439120,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f5/90/e08bbe1f.jpg","nickname":"Wheres the Love?","note":"","ucode":"8851FB40976AB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339848,"discussion_content":"我有点不明白，等待超时的线程应该还是回到管程的入口队列等待吧，那同样也会遇到被高优先级线程抢走调度机会导致饥饿的情况啊，感觉提供超时只是增加了线程判断条件是否满足的机会，主要还是和老师说的一样从健壮性考虑更多。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609822087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206489,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1586869321,"is_pvip":true,"replies":[{"id":"77238","content":"👍","user_name":"作者回复","comment_id":206489,"uid":"1269969","ip_address":"","utype":1,"ctime":1586944266,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"74601313353","product_id":100023901,"comment_content":"没有看懂的可以看下 coursera 上北京大学陈老师讲的课程 MESA 管程<br>https:&#47;&#47;www.coursera.org&#47;lecture&#47;os-pku&#47;mesaguan-cheng-Fya0t","like_count":17,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491811,"discussion_content":"👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586944266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78928,"user_name":"江南豆沙包","can_delete":false,"product_type":"c1","uid":1061596,"ip_address":"","ucode":"4B7833260F9F2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/dc/d3e3847f.jpg","comment_is_top":false,"comment_ctime":1553301629,"is_pvip":false,"replies":[{"id":"28731","content":"没用到条件变量，只有调用wait和notify的时候才会用到","user_name":"作者回复","comment_id":78928,"uid":"1269969","ip_address":"","utype":1,"ctime":1553313370,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"61682843773","product_id":100023901,"comment_content":"老师，有个疑问，文中说到的条件变量，假如 synchronized(instance)｛做一些事情｝，这样一段代码，程序实际运行过程中条件变量是什么呢","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444293,"discussion_content":"没用到条件变量，只有调用wait和notify的时候才会用到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553313370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290223,"discussion_content":"此时只能有一个条件变量，就是instance","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594381031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76871,"user_name":"Healtheon","can_delete":false,"product_type":"c1","uid":1206751,"ip_address":"","ucode":"B564B1FC4456E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","comment_is_top":false,"comment_ctime":1552733604,"is_pvip":false,"replies":[{"id":"28079","content":"是的，管程只是一种解决并发问题的模型而已。","user_name":"作者回复","comment_id":76871,"uid":"1269969","ip_address":"","utype":1,"ctime":1552791803,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"61682275748","product_id":100023901,"comment_content":"感谢老师的精彩分享，谈一下个人对信号量和管程的理解。<br><br>信号量机制是可以解决同步&#47;互斥的问题的，但是信号量的操作分散在各个进程或线程中，不方便进行管理，因每次需调用PV操作，还可能导致死锁或破坏互斥请求的问题。<br><br>管程是定义了一个数据结构和能为并发所执行的一组操作，这组操作能够进行同步和改变管程中的数据。这相当于对临界资源的同步操作都集中进行管理，凡是要访问临界资源的进程或线程，都必须先通过管程，由管程的这套机制来实现多进程或线程对同一个临界资源的互斥访问和使用。管程的同步主要通过condition类型的变量（条件变量），条件变量可执行操作wait()和signal()。管程一般是由语言编译器进行封装，体现出OOP中的封装思想，也如老师所讲的，管程模型和面向对象高度契合的。","like_count":14,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443482,"discussion_content":"是的，管程只是一种解决并发问题的模型而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","nickname":"Geek_c22199","note":"","ucode":"1CE5B65513E360","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216914,"discussion_content":"不大懂操作系统，管程是定义了一个数据结构和能为并发所执行的一组操作。没明白这组操作是指什么呢，数据结构是什么样的，大佬有空指点下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585491976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116379,"user_name":"大圣","can_delete":false,"product_type":"c1","uid":1066582,"ip_address":"","ucode":"A9CDFEDA3C069D","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/56/67e74ca8.jpg","comment_is_top":false,"comment_ctime":1563845415,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40218551079","product_id":100023901,"comment_content":"管程提出的太突兀了，没有从理论上给管程一个明确的定义，导致本章晦涩难懂。管程是一个理念还是一个工具？是JVM既定的实现还是需要人为自己实现，很多人会误以为管程是一个工具，用“管程”就能解决多线程问题。","like_count":9,"discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5710,"discussion_content":"模型懂不？多读几遍，好好理解下吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566443893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342647,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIMXEAN5E36GHAVguQnbNOIicT0IXDk1aYw4l0crtMIRibyBdAicyJo8u1Bqol8qbQso4J0CRd4y4YdA/132","nickname":"Geek_2e8900","note":"","ucode":"ABB7B4977AC7CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3786,"discussion_content":"管程是一模型啊，，或者可以理解为synchronizd关键字的内部实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564809315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189556,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1584528680,"is_pvip":false,"replies":[{"id":"73437","content":"猜出来这个境界很重要","user_name":"作者回复","comment_id":189556,"uid":"1269969","ip_address":"","utype":1,"ctime":1584792876,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"35944267048","product_id":100023901,"comment_content":"JUC AQS 就是这么实现的，它有两个队列，一个是同步队列，一个是等待队列：<br><br>1. 同步队列：锁被占用时，会将该线程添加到同步队列中。当锁释放后，会从队列中唤醒一个线程，又分为公平和非公平两种。<br>2. 等待队列：当调用 await 是，会将该线程添加到等待队列中。当其它线程调用 notify 时，会将该线程从等待队列移动到同步队列中，重新竞争锁。<br><br>后来又了解了一下 synchronized 的实现原理，ObjectMonitor 结构也差不多，原来这就是管程 MESA 模型，一切都套路，有章可循。<br>以前读源码，基本上是看什么忘什么，主要还是不了解代码背后的设计原理。如果了解原理后，这样不用看代码，基本上能猜出来是怎么实现的，以后还是要加强理论的学习。计算机理论的学习也非常枯燥，大家一起共勉。","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487733,"discussion_content":"猜出来这个境界很重要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584792876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573493,"discussion_content":"线程不可能同时在同步队列和等待队列中吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653465832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297559,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/97/ae4d1400.jpg","nickname":"林枫","note":"","ucode":"38B9CBE7F42174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387264,"discussion_content":"当年通读了AQS和ObjectMonitor,当时感觉这玩意的思路不就是一样的么，，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628075943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2598274,"avatar":"","nickname":"Geek_97d1b0","note":"","ucode":"B8FF1ED262B612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373583,"discussion_content":"AQS中没有 notify,虽然我理解你要表达什么,但是还是严谨一点,AQS 中的是 signal唤醒线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620790091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108226,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1561701226,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"35921439594","product_id":100023901,"comment_content":"看了很多遍，终于看明白了。文章里都是在用一个阻塞队列来举例子，而这个阻塞队列跟monitor里的队列没有关系。说清楚些会更好理解。","like_count":8,"discussions":[{"author":{"id":1542037,"avatar":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","nickname":"卢","note":"","ucode":"B6A9F41AEE348C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403073,"discussion_content":"其实就是说wait notify的原理吧，采用了BlockingQueue、Lock/Condition来分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634003516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251125,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588067572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94048,"user_name":"饮识止渴(Vilin)","can_delete":false,"product_type":"c1","uid":1077527,"ip_address":"","ucode":"E48E115ED3AE31","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/17/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1557710245,"is_pvip":false,"replies":[{"id":"33580","content":"会","user_name":"作者回复","comment_id":94048,"uid":"1269969","ip_address":"","utype":1,"ctime":1557719625,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"35917448613","product_id":100023901,"comment_content":"线程wait超时后，会重新被放入入口队列，去争取锁吗？","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449890,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557719625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89884,"user_name":"英耀","can_delete":false,"product_type":"c1","uid":1113425,"ip_address":"","ucode":"5E886F004BF6C2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/51/7f75a232.jpg","comment_is_top":false,"comment_ctime":1556295754,"is_pvip":true,"replies":[{"id":"32337","content":"https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Monitor_(synchronization) 这个比较全面","user_name":"作者回复","comment_id":89884,"uid":"1269969","ip_address":"","utype":1,"ctime":1556464655,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"35916034122","product_id":100023901,"comment_content":"王老师您好，我想请问一下文章中提到的是三种管程模型“hasen，hoare，mesa”是在什么资料（书籍、论文）中提到的呢？我想再深入了解这些管程模型的思想和原理，希望老师可以答疑解惑，感谢。","like_count":8,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448304,"discussion_content":"https://en.wikipedia.org/wiki/Monitor_(synchronization) 这个比较全面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556464655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1347588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/90/04/d23ef2d6.jpg","nickname":"李疯子","note":"","ucode":"05C5D0F6C39133","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223096,"discussion_content":"操作系统里面都会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586185748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78923,"user_name":"zhaozp","can_delete":false,"product_type":"c1","uid":1099706,"ip_address":"","ucode":"BF390F5ED762CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","comment_is_top":false,"comment_ctime":1553300876,"is_pvip":false,"replies":[{"id":"28859","content":"阻塞在2，唤醒后当然是继续执行while了，这个就是单线程的逻辑<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553388978,"ip_address":"","comment_id":78923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31618071948","product_id":100023901,"comment_content":"&#47;&#47; 入队<br>  void enq(T x) {<br>    lock.lock();                   1<br>    try {<br>      while (队列已满){<br>        &#47;&#47; 等待队列不满 <br>        notFull.await();         2<br>      }  <br>      &#47;&#47; 省略入队操作...<br>      &#47;&#47; 入队后, 通知可出队<br>      notEmpty.signal();      3<br><br>老师，我想问下，线程从入口等待队列重新被唤醒后是从line-1入队方法enq开始执行，还是直接从line-3开始执行signal方法。我在想如果从line-1执行是不是可以用if 不用while呢？这里不太明白","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444291,"discussion_content":"阻塞在2，唤醒后当然是继续执行while了，这个就是单线程的逻辑\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553388978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90273,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1556464671,"is_pvip":false,"replies":[{"id":"32351","content":"不是，对象头只是解决锁的问题，不是条件变量。你可以对比sdk里面的lock.newCondition()来理解。wait&#47;notify是和条件变量绑定的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556498875,"ip_address":"","comment_id":90273,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23031301151","product_id":100023901,"comment_content":"请问老师，“synchronized仅支持一个条件变量”，这句话不是太明白。<br>我理解，sync是在对象头加入线程ID，当对象头没有线程ID时，代表资源没被锁定，因此这里的条件变量是固定为，判断对象头是否有线程ID。所以这就是sync原语的条件变量？是这样理解么","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448451,"discussion_content":"不是，对象头只是解决锁的问题，不是条件变量。你可以对比sdk里面的lock.newCondition()来理解。wait/notify是和条件变量绑定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556498875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286282,"discussion_content":"sync都没有理解，能理解condition？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593100675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364401,"discussion_content":"condition 比 sync 简单，condition 是基于 java 实现的，代码层面的。而 sync 是 C++，你说哪个好懂？他们原理其实是一样的，底层实现方式。所以可以相互借鉴","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617462679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286282,"ip_address":""},"score":364401,"extra":""}]},{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162134,"discussion_content":"我感觉意思是不是说在加锁的代码块或者方法里只能调用一次wait或者notify方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580962891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89097,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1556076398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23030912878","product_id":100023901,"comment_content":"这一章给我的感觉是，告诉我们MESA的模型，然后可以自己手动实现管程了，说白了，当synchronize不满足我的需求时，可以自己写代码实现管程，还有并发包下的一些工具类可以辅助实现。","like_count":5},{"had_liked":false,"id":79225,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1553407940,"is_pvip":false,"replies":[{"id":"28914","content":"有可能会不满足，多个线程同时消费同时生产就有可能不满足，wait的线程没有优先权，有可能唤醒到入口等待队列里时，又有新新新新新新新新新新新新新新新新的线程进入管程破坏曾经满足的条件<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553418742,"ip_address":"","comment_id":79225,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23028244420","product_id":100023901,"comment_content":"class BoundedBuffer {<br>   final Lock lock = new ReentrantLock();<br>   final Condition notFull  = lock.newCondition(); <br>   final Condition notEmpty = lock.newCondition(); <br><br>   final Object[] items = new Object[100];<br>   int putptr, takeptr, count;<br><br>   public void put(Object x) throws InterruptedException {<br>     lock.lock();<br>     try {<br>       while (count == items.length)<br>         notFull.await();<br>       items[putptr] = x;<br>       if (++putptr == items.length) putptr = 0;<br>       ++count;<br>       notEmpty.signal();<br>     } finally {<br>       lock.unlock();<br>     }<br>   }<br><br>   public Object take() throws InterruptedException {<br>     lock.lock();<br>     try {<br>       while (count == 0)<br>         notEmpty.await();<br>       Object x = items[takeptr];<br>       if (++takeptr == items.length) takeptr = 0;<br>       --count;<br>       notFull.signal();<br>       return x;<br>     } finally {<br>       lock.unlock();<br>     }<br>   }<br> }<br>老师生产者消费者，就上面代码将while换成if感觉没影响，然后老师说MESA里条件需要while，为了防止线程在执行的时候，条件已经不满足，但是要是在这个模型中，Condition满足，虽然当前线程是从阻塞的那段开始执行，但是应该不会出现条件已经不满足的情况，然后我是感觉有可能是不在这个模型中的其他线程对其条件状态进行改变，不知道理解的对不对","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444406,"discussion_content":"有可能会不满足，多个线程同时消费同时生产就有可能不满足，wait的线程没有优先权，有可能唤醒到入口等待队列里时，又有新新新新新新新新新新新新新新新新的线程进入管程破坏曾经满足的条件\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553418742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78521,"user_name":"InfoQ_e1793abc1304","can_delete":false,"product_type":"c1","uid":1287723,"ip_address":"","ucode":"CF339F8B519290","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUOC0ftZuklLCFPxtPSA6zeOtbKnewib8u2Aic9b46XePic5d5ibDkhk1icIU57P5vgc0nkicpqBubSoqA/132","comment_is_top":false,"comment_ctime":1553165819,"is_pvip":false,"replies":[{"id":"28600","content":"你运行一下，会异常的。只能调用this.wait()，没有持有锁的对象，是不允许调用wait()方法的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553185307,"ip_address":"","comment_id":78521,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18733035003","product_id":100023901,"comment_content":"&gt; Java 语言内置的管程里只有一个条件变量<br>这个不可以通过多个object 对象实现吗？类似于：<br>Obejct condition1 = new Obejct();<br>Obejct condition2 = new Obejct();<br>...<br>synchronized(this) {<br>     while(&#47;*条件*&#47;) {<br>          condition1.wait();<br>     }<br>     condition2.notifyAll();<br>}<br><br>synchronized(this) {<br>     while(&#47;*条件*&#47;) {<br>          condition2.wait();<br>     }<br>     condition1.notifyAll();<br>}","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444130,"discussion_content":"你运行一下，会异常的。只能调用this.wait()，没有持有锁的对象，是不允许调用wait()方法的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553185307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77922,"user_name":"次郎","can_delete":false,"product_type":"c1","uid":1134620,"ip_address":"","ucode":"446499E130A66A","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/1c/26dc1927.jpg","comment_is_top":false,"comment_ctime":1553042404,"is_pvip":false,"replies":[{"id":"28493","content":"以后少回点😃<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553083891,"ip_address":"","comment_id":77922,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732911588","product_id":100023901,"comment_content":"老师是我见过专栏里回复率最高的一位了","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443897,"discussion_content":"以后少回点😃\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553083891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106384,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1561285143,"is_pvip":false,"replies":[{"id":"38531","content":"是的，你再看看管程那章","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561347154,"ip_address":"","comment_id":106384,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14446187031","product_id":100023901,"comment_content":"老师，看到后面又看回来，有一个问题搞晕了：T1调用lock.lock()，然后condition1.await()；T2再调用lock.lock()，此时锁不是被T1占用了么，难道是condition1.await()相当于释放了锁？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455071,"discussion_content":"是的，你再看看管程那章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561347154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79078,"user_name":"life is short, enjoy more.","can_delete":false,"product_type":"c1","uid":1074805,"ip_address":"","ucode":"3B5F37D30790A7","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/75/54bb858e.jpg","comment_is_top":false,"comment_ctime":1553345228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14438247116","product_id":100023901,"comment_content":"好记性不如烂笔头<br>管程定义：<br>管理共享内存和操作共享内存的过程，令其支持并发。<br><br>并发编程领域两大难题，互斥和同步。<br><br>互斥如何保证：封装共享数据及其对应操作，每个操作任意时刻只允许一个线程执行。<br><br>同步如何保证：使用MESA模型。<br><br>MESA模型之前没接触过，只是能够按照老师的思路顺下来，还没有深刻的理解，希望老师在接下来的文章中，加深MESA的使用😄<br><br>","like_count":3},{"had_liked":false,"id":76930,"user_name":"sakura","can_delete":false,"product_type":"c1","uid":1449550,"ip_address":"","ucode":"D382C3325F2F59","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/4e/56a0b904.jpg","comment_is_top":false,"comment_ctime":1552755224,"is_pvip":false,"replies":[{"id":"28081","content":"我觉得程序员免不了写出有并发问题的程序，增加一个超时参数，更保险一些","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552792159,"ip_address":"","comment_id":76930,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14437657112","product_id":100023901,"comment_content":"假设当前运行线程为t2 阻塞线程（在条件变量等待队列中的线程）t1<br>Hasen 条件变量满足 t2唤醒t1 此时t2也即将结束因为notify在t2执行末尾 t1可以立刻执行<br>Hoare 条件变量满足 t2唤醒t1 t2阻塞 t1执行 <br>MESA 条件变量满足 t2唤醒t1 t2继续执行 t1进到【入口等待队列 】，当t1再次获得互斥锁时可能条件变量已经改变如是这样t1会再次进入阻塞队列  如果如此反复，将一直在while循环里 所以需要wait中添加时间参数很有必要","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443508,"discussion_content":"我觉得程序员免不了写出有并发问题的程序，增加一个超时参数，更保险一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552792159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268156,"user_name":"秀秀","can_delete":false,"product_type":"c1","uid":1376242,"ip_address":"","ucode":"4601FF39F8FE6A","user_header":"","comment_is_top":false,"comment_ctime":1608085747,"is_pvip":false,"replies":[{"id":"98620","content":"分析的相当到位，我学到了������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609917143,"ip_address":"","comment_id":268156,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10198020339","product_id":100023901,"comment_content":"这里的队列不空和队列不满其实可以用双重否定变肯定来描述会更容易理解一些；<br>1. 线程T1执行出队操作，也就是代码里的deq()方法，deq()方法首先判断队列是否是空的，<br>如果队列不空不满足，变成肯定语句: 队列空了，那就wait等待；<br>如果队列不空满足，则代码继续往下执行出队操作，既然T1执行出队了，那队列肯定就不满了，最后notFull.signal()通知T2该执行入队了。<br><br>2. 线程T2执行入队操作，也就是代码里的enq()方法，enq()方法首先判断队列是否满了，<br>如果队列不满不满足，变成肯定语句：队列满了，那就wait等待；<br>如果队列不满，则代码继续往下执行如果操作，既然T2执行了入队了，那队列肯定就不空了，最后notEmpty.signal()通知T1该执行出队了。<br><br>至于判断语句为什么要用while，因为signal通知唤醒对方了，但是对方条件不一定满足啊，所以需要循环判断；","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511862,"discussion_content":"分析的相当到位，我学到了������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609917143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018706,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/52/6659dc1b.jpg","nickname":"黑米","note":"","ucode":"E7DBEA7867862A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391148,"discussion_content":"我看的时候也是双重否定变肯定来理解的，差点晕了哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630315954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223828,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1591192311,"is_pvip":false,"replies":[{"id":"82612","content":"会执行wait之后的代码","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1591414919,"ip_address":"","comment_id":223828,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10181126903","product_id":100023901,"comment_content":"while(条件)经典写法的原因，MESA模型导致的。<br>MESA模型中T2唤醒T1时，T2继续执行，只是将T1从条件等待队列放到入口队列中。当T2执行完成后，T1的条件可能不满足了（可能被其他线程捷足先登了）。<br><br>此处有个疑问，T1虽然被放到入口队列去了，但是和原来就在入口队列的线程有不同之处，就是T1一旦获得锁就会执行wait之后 的代码。我的理解没错吧","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497251,"discussion_content":"会执行wait之后的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591414919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279781,"discussion_content":"谢谢老师，我看后面的回复，了解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591415317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148215,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1572959299,"is_pvip":false,"replies":[{"id":"57434","content":"队列不为空这个前提条件不满足，其执行线程就会进入对应条件变量的等待队列里，前提条件和条件变量有对应关系。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573217807,"ip_address":"","comment_id":148215,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10162893891","product_id":100023901,"comment_content":"文中有一句话没理解：而队列不为空这个前提条件就是管程里的条件变量，希望老师能进一步解释一下？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473434,"discussion_content":"队列不为空这个前提条件不满足，其执行线程就会进入对应条件变量的等待队列里，前提条件和条件变量有对应关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573217807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573494,"discussion_content":"比如线程队列执行出队列操作，但是队列为空，则直接进入队列不为空的条件队列等待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653466028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142723,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571479573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10161414165","product_id":100023901,"comment_content":"管程，<br><br>class  Minitor{<br>同步队列(一个)<br>条件队列(多个)<br>入队<br>出队<br>}","like_count":2},{"had_liked":false,"id":85644,"user_name":"pjmike","can_delete":false,"product_type":"c1","uid":1053062,"ip_address":"","ucode":"C02B02268302F6","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/86/c51eea36.jpg","comment_is_top":false,"comment_ctime":1555156484,"is_pvip":false,"replies":[{"id":"30762","content":"管程的英文就是monitor，至于synchronized底层的实现还挺复杂的，尤其是1.6优化之后。你可以参考《java并发编程的艺术》的第二章，详细描述了具体实现。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555163422,"ip_address":"","comment_id":85644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10145091076","product_id":100023901,"comment_content":"老师您好，我有个疑问，以前看书称synchronized的重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，而这个monitor是不是就是对应管程呢，那Java中的管程与Mutex Lock的联系是怎样的呢？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446750,"discussion_content":"管程的英文就是monitor，至于synchronized底层的实现还挺复杂的，尤其是1.6优化之后。你可以参考《java并发编程的艺术》的第二章，详细描述了具体实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555163422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81643,"user_name":"夕阳下海滩边","can_delete":false,"product_type":"c1","uid":1284350,"ip_address":"","ucode":"5FFBAB9BB3F7C6","user_header":"https://static001.geekbang.org/account/avatar/00/13/98/fe/aa4c44cf.jpg","comment_is_top":false,"comment_ctime":1553994688,"is_pvip":false,"replies":[{"id":"29622","content":"ObjectMonitor就是Java语言层面提供的管程，也就是文中提到的synchronized+wait&#47;notify方案","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554030770,"ip_address":"","comment_id":81643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143929280","product_id":100023901,"comment_content":"老师，你好，我看了管程这篇文章后发现没有ObjectMonitor相关的介绍，文中提到的MESA模型和这个有啥区别呢？我看网上很多文章都说Java中是ObjectMonitor(JVM源码中C++实现)来实现管程","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445282,"discussion_content":"ObjectMonitor就是Java语言层面提供的管程，也就是文中提到的synchronized+wait/notify方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554030770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77239,"user_name":"萧一狼","can_delete":false,"product_type":"c1","uid":1266160,"ip_address":"","ucode":"35CC9C8FC8DDD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/51/f0/9b7d40fc.jpg","comment_is_top":false,"comment_ctime":1552894826,"is_pvip":false,"replies":[{"id":"28198","content":"看来真没必要讲源码了，都已经看懂了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552917459,"ip_address":"","comment_id":77239,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142829418","product_id":100023901,"comment_content":"看了本章再去看源码的ArrayBlockingQueue和LinkedBlockingQueue还有一些其他源码，恍然大悟","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443651,"discussion_content":"看来真没必要讲源码了，都已经看懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552917459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76855,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1552730523,"is_pvip":false,"replies":[{"id":"28073","content":"同意","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552791066,"ip_address":"","comment_id":76855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10142665115","product_id":100023901,"comment_content":"我觉得超时参数很有必要，老师说wait()的正确姿势是：<br>while(条件不满足) {<br>  wait();<br>}<br>有可能条件永远不满足，一直等下去<br>","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443473,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338218,"user_name":"小宝儿","can_delete":false,"product_type":"c1","uid":1152805,"ip_address":"","ucode":"EF641095083111","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/25/eaa3132e.jpg","comment_is_top":false,"comment_ctime":1647356552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5942323848","product_id":100023901,"comment_content":"其实就和排队使用公共厕所门一样，门把手相当于管程条件。<br>1. 当有人（线程）使用厕所（并发资源）后，门把手由绿色变成红色（管程条件变化：允许出厕所, 不允许入厕所），其他人排队（阻塞队列）；<br>2. 当有人离开厕所（线程释放资源）后，门把手由红色变为绿色（管程条件变化：允许入厕所，不允许出厕所），下一个人入厕所。<br>","like_count":1},{"had_liked":false,"id":247528,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1599732199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5894699495","product_id":100023901,"comment_content":"管程是一种并发编程的模型，java中重量级锁的加锁解锁，都是借助管程Monitor，Monitior底层是用c++实现的，直接和系统内核交户，线程的切换，加锁解锁，都需借助操作系统才能完成，开销很大，所以java在并发包中，也提供了并发包，其实就是解决重量级锁线程阻塞带来的开销问题，并发包中的AQS 就是管程的翻版，只不过把线程的阻塞，换成了自旋，这样避免了线程阻塞的开销，同时在并发包中也提供了公平和非公平锁的接口，java 原生的管程模型，进行加锁解锁，是非公平的，会导致饥饿问题。<br>","like_count":1},{"had_liked":false,"id":225273,"user_name":"马建新（zerosbg）","can_delete":false,"product_type":"c1","uid":1112387,"ip_address":"","ucode":"A97A9E2B7D27B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/43/91c358f2.jpg","comment_is_top":false,"comment_ctime":1591701894,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886669190","product_id":100023901,"comment_content":"老师好,回答课后思考<br>在MESA 模型中,条件等待队列的线程如果是在notify()通知时,由于其只能唤醒一个线程,有可能永远不会处理一些低优先级的线程,所以可能造成线程“饥饿”<br>但是也注意一下wait如果传参数为零的话,不代表着立即唤醒进入入口队列,而是一直等待被唤醒,没有超时设置","like_count":1},{"had_liked":false,"id":201137,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1585722233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880689529","product_id":100023901,"comment_content":"讲管程的例子和示意图看了几遍也没有很好理解，主要是例子中的队列及条件队列和方法及变量的指代并不明确。虽然作者心里明白指代的是什么，但是在读者看来就有疑问了，这看起来更像是管程里的数据结构，就好像《如何读一本书》里讲作者跟读者理解的指代有出入，例如作者讲的是古代的哥哥指的是父亲的意思，但是在大多数读者读起来认为指的就是兄弟的意思。","like_count":1},{"had_liked":false,"id":190602,"user_name":"灰太狼","can_delete":false,"product_type":"c1","uid":1066046,"ip_address":"","ucode":"C17DD5D5ED9DC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/3e/493e73fa.jpg","comment_is_top":false,"comment_ctime":1584671962,"is_pvip":false,"replies":[{"id":"73429","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1584792373,"ip_address":"","comment_id":190602,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879639258","product_id":100023901,"comment_content":"自己写了代码验证，如何死锁，如何使用管程解决，现在理解感觉好多了","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488012,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584792373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138871,"user_name":"245864982","can_delete":false,"product_type":"c1","uid":1238485,"ip_address":"","ucode":"AC47075A95B759","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/d5/680402fd.jpg","comment_is_top":false,"comment_ctime":1570496409,"is_pvip":false,"replies":[{"id":"53561","content":"只是给了一个处理无限等待的机会而已，还是需要我们自己处理，处理不好就可能死循环","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570536550,"ip_address":"","comment_id":138871,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865463705","product_id":100023901,"comment_content":"有些不理解，wait加了超时参数只能避免了没有其他线程notify时候能自己唤醒避免了无限等待吧。那会不会存在一直不满足条件变量一直在while哪里死循环的情况呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469678,"discussion_content":"只是给了一个处理无限等待的机会而已，还是需要我们自己处理，处理不好就可能死循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570536550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108182,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1561691619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856658915","product_id":100023901,"comment_content":"并发编程中的两大核心问题：互斥和同步。synchronized 和 wait()、notify()、notifyall()是monitor的两个组成部分，其中synchronized 解决互斥问题， wait()、notify()、notifyall()解决同步问题。<br><br>","like_count":1},{"had_liked":false,"id":91389,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1557021781,"is_pvip":false,"replies":[{"id":"34456","content":"调用wait方法的句柄就是条件变量","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558362459,"ip_address":"","comment_id":91389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851989077","product_id":100023901,"comment_content":"原文：Java 内置的管程方案（synchronized）使用简单，synchronized 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量<br><br>-----<br><br>老师，“synchronized 仅支持一个条件变量”，请问这一个条件变量是啥？也是编译期自动生成么？谢谢","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448900,"discussion_content":"调用wait方法的句柄就是条件变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558362459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90737,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1489979,"ip_address":"","ucode":"B3FF6617F4CEC1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/5Z6cR9cK0icIhujF4kPMqMblnKyBpzfRcUQNHEJEgFI8Sy6e9LoEGOdliac7ibbwKGAnoxcSiaB9qIyqYCJicJyaRug/132","comment_is_top":false,"comment_ctime":1556620243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851587539","product_id":100023901,"comment_content":"class BoundedBuffer {<br>   final Lock lock = new ReentrantLock();&#47;&#47;锁对象<br>   final Condition notFull  = lock.newCondition();&#47;&#47;写线程条件 <br>   final Condition notEmpty = lock.newCondition();&#47;&#47;读线程条件 <br><br>   final Object[] items = new Object[100];&#47;&#47;缓存队列<br>   int putptr&#47;*写索引*&#47;, takeptr&#47;*读索引*&#47;, count&#47;*队列中存在的数据个数*&#47;;<br><br>   public void put(Object x) throws InterruptedException {<br>     lock.lock();<br>     try {<br>       while (count == items.length)&#47;&#47;如果队列满了 <br>         notFull.await();&#47;&#47;阻塞写线程<br>       items[putptr] = x;&#47;&#47;赋值 <br>       if (++putptr == items.length) putptr = 0;&#47;&#47;如果写索引写到队列的最后一个位置了，那么置为0<br>       ++count;&#47;&#47;个数++<br>       notEmpty.signal();&#47;&#47;唤醒读线程<br>     } finally {<br>       lock.unlock();<br>     }<br>   }<br><br>   public Object take() throws InterruptedException {<br>     lock.lock();<br>     try {<br>       while (count == 0)&#47;&#47;如果队列为空<br>         notEmpty.await();&#47;&#47;阻塞读线程<br>       Object x = items[takeptr];&#47;&#47;取值 <br>       if (++takeptr == items.length) takeptr = 0;&#47;&#47;如果读索引读到队列的最后一个位置了，那么置为0<br>       --count;&#47;&#47;个数--<br>       notFull.signal();&#47;&#47;唤醒写线程<br>       return x;<br>     } finally {<br>       lock.unlock();<br>     }<br>   } <br> }","like_count":1},{"had_liked":false,"id":89487,"user_name":"Hello,Hello,Hello Kitty","can_delete":false,"product_type":"c1","uid":1185329,"ip_address":"","ucode":"8769FB28FE6399","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/31/929f811e.jpg","comment_is_top":false,"comment_ctime":1556183988,"is_pvip":false,"replies":[{"id":"32010","content":"jdk monitor是管程模型的实现，共享变量不会入队的，入队出队不是管程里的，是阻塞队列里的，例子是用管程实现阻塞队列<br>用posix api实现管程，也看不到入口等待队列和条件队列，但它也是管程<br><br>共享变量可以有多个<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556193839,"ip_address":"","comment_id":89487,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851151284","product_id":100023901,"comment_content":"老师你好 <br>1.关于管程的介绍 是不是不是jdk中实现的原理而是操作系统中的管程原理？ 因为我看jdk monitor的源码 monitor也不是您介绍的共享变量以及入队出队 而且jdk中的monitor应该是对象内置的 只代表该对象吧？  您所说的管程 共享变量可以有多个 看起来有点类似jdk中的synchronized了 <br>2.共享变量只有一个还是有多个？  您例子中就医流程 排队等候医生 取得医生资源进入管程后 医生开化验单 然后去化验队列排队等候 这时候等候的资源 应该是化验资源 而不是主治医生的资源了  所以您所说的&quot;队列不空&quot;是指的是哪个资源呢？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448151,"discussion_content":"jdk monitor是管程模型的实现，共享变量不会入队的，入队出队不是管程里的，是阻塞队列里的，例子是用管程实现阻塞队列\n用posix api实现管程，也看不到入口等待队列和条件队列，但它也是管程\n\n共享变量可以有多个\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556193839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85321,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1555036420,"is_pvip":true,"replies":[{"id":"30660","content":"await也需要，mesa管程都需要这样。if判断如果条件不满足怎么办，还是需要继续等待，所以还是个while<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555118322,"ip_address":"","comment_id":85321,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850003716","product_id":100023901,"comment_content":"老师 个人感觉管程的while编程范式只是针对于wait()的，如果是await()和signal()组合的话，可以不使用这个范式使用if判断也可以。以为叫醒的和等待的都是特定的任务，不会出现条件不匹配的情况，。不知道我的理解对吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446628,"discussion_content":"await也需要，mesa管程都需要这样。if判断如果条件不满足怎么办，还是需要继续等待，所以还是个while\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555118322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85128,"user_name":"crudBoy","can_delete":false,"product_type":"c1","uid":1442091,"ip_address":"","ucode":"D2C94247152ADE","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/2b/2bc4f35b.jpg","comment_is_top":false,"comment_ctime":1554986105,"is_pvip":false,"replies":[{"id":"30521","content":"不好意思，例子选的有问题让你误解了，入队出队和管程里面的队列没关系。文中的例子只是用管程实现一个阻塞队列而已，空，满都是阻塞队列里的，和管程里面的队列没关系。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554987817,"ip_address":"","comment_id":85128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849953401","product_id":100023901,"comment_content":"先给你在文章中说的两个队列起个别名以便我清晰地描述我的问题。<br>A队列：线程队列<br>B队列：条件变量队列。<br><br>我的第一个问题： <br>如果A队列中只有一个线程该线程也是这个管程的第一个线程， 那么按你讲的A队列的出队条件是B队列不能为空，是否A队列中的那仅有的一个线程永远无法出队了？<br><br>第二个问题：<br>你文章中提到，只有调用wait的时候管程中的线程才会进入B队列，那么如果我管程对应的代码里没有调用wait而是直接结束了方法的调用的话，那么B队列会一直为空，也就会导致A队列中的线程无法出队也就无法进入管程？<br><br>我估计是我理解错了，希望老师梦指点下。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446566,"discussion_content":"不好意思，例子选的有问题让你误解了，入队出队和管程里面的队列没关系。文中的例子只是用管程实现一个阻塞队列而已，空，满都是阻塞队列里的，和管程里面的队列没关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554987817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78457,"user_name":"坯子蔡","can_delete":false,"product_type":"c1","uid":1243531,"ip_address":"","ucode":"D1142A9FE03175","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/8b/01bcf23c.jpg","comment_is_top":false,"comment_ctime":1553153434,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5848120730","product_id":100023901,"comment_content":"线程T1 进行出队操作，发现队列为空，进入不为空条件等待队列，线程T2进行入队操作完后，唤醒T1，T1从新进入入口等待队列，当再次获取互斥锁，进入队列是否为空条件判断，当不满足条件再次进入条件等待队列，为什么要用while进行循环判断， 始终不明白，看了ArrayBlockQueue源码也是用while 循环判断？请老师解惑一下！！！","like_count":1},{"had_liked":false,"id":78302,"user_name":"kyle","can_delete":false,"product_type":"c1","uid":1179158,"ip_address":"","ucode":"DB05C0F7D2C472","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/16/0f096793.jpg","comment_is_top":false,"comment_ctime":1553128251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848095547","product_id":100023901,"comment_content":"文章中管程同步的例子，管程的入口队列和管程里的共享队列容易让人产生误解，可能是上下文承接的原因，看了三遍才明白入队，出队是指共享队列的操作，才串起来！😢","like_count":1},{"had_liked":false,"id":77553,"user_name":"Vickygu","can_delete":false,"product_type":"c1","uid":1371330,"ip_address":"","ucode":"85E3C158EF6B6F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLUdGtTfe4kBzS6EwvyNkqBGZpKE0vpic8zgZXgoJE3pgHfa2iaulictROn3NsICbZOjz1ELybdf5P6g/132","comment_is_top":false,"comment_ctime":1552962452,"is_pvip":false,"replies":[{"id":"28387","content":"有道理","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552997586,"ip_address":"","comment_id":77553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847929748","product_id":100023901,"comment_content":"我觉得MESA增加超时参数应该是预防死锁，在2个线程分别占着一个资源并都在等待另一个资源的情况下，增加超时机制可以打破死锁状态。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443776,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552997586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77404,"user_name":"SA","can_delete":false,"product_type":"c1","uid":1099635,"ip_address":"","ucode":"3978B81AB9D145","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/73/744a2212.jpg","comment_is_top":false,"comment_ctime":1552919296,"is_pvip":false,"replies":[{"id":"28209","content":"最高兴的是大家学会了写并发程序，而不仅仅是面试通过了。你的鼓励就是我的动力，我也努力的！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552920546,"ip_address":"","comment_id":77404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847886592","product_id":100023901,"comment_content":"认真拜读了前面这几章后受益匪浅，今天用所学知识解决了项目的一个实际问题，对这个专栏真是相见恨晚，对后续章节充满期待！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443712,"discussion_content":"最高兴的是大家学会了写并发程序，而不仅仅是面试通过了。你的鼓励就是我的动力，我也努力的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552920546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77394,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552918395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847885691","product_id":100023901,"comment_content":"不加超时时间可能会一直不满足条件一直不跳出","like_count":1},{"had_liked":false,"id":77166,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1552874268,"is_pvip":false,"replies":[{"id":"28128","content":"前面转账的例子，必须用","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552880221,"ip_address":"","comment_id":77166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847841564","product_id":100023901,"comment_content":"老师  能举一个必须用notifyAll的代码例子吗？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443614,"discussion_content":"前面转账的例子，必须用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552880221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77153,"user_name":"boyxie","can_delete":false,"product_type":"c1","uid":1018342,"ip_address":"","ucode":"FD55E5C569AC58","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/e6/ab403ccb.jpg","comment_is_top":false,"comment_ctime":1552872205,"is_pvip":false,"replies":[{"id":"28132","content":"就是mesa的实现<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552881295,"ip_address":"","comment_id":77153,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847839501","product_id":100023901,"comment_content":"想起来前段时间看的AQS，很像是MESA的具体实现哈，不知道是否理解正确，以前看到监视器模型就没有深究它的理论模型，看来还是要追根溯源，这样才能真正理解，比如看了很多并发包的源码，但是现在加上老师的理论，理解起来会豁然开朗。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443608,"discussion_content":"就是mesa的实现\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552881295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76976,"user_name":"yes","can_delete":false,"product_type":"c1","uid":1386201,"ip_address":"","ucode":"612BF6884ED6CC","user_header":"https://static001.geekbang.org/account/avatar/00/15/26/d9/f7e96590.jpg","comment_is_top":false,"comment_ctime":1552791586,"is_pvip":false,"replies":[{"id":"28084","content":"我疏忽了，这就改过来","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552805914,"ip_address":"","comment_id":76976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847758882","product_id":100023901,"comment_content":"While没加大括号当时就把我看蒙了","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443525,"discussion_content":"我疏忽了，这就改过来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552805914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76926,"user_name":"墨名次","can_delete":false,"product_type":"c1","uid":1330267,"ip_address":"","ucode":"926EDC57291C09","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/5b/5499d6e6.jpg","comment_is_top":false,"comment_ctime":1552752773,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5847720069","product_id":100023901,"comment_content":"老师，我觉得自己理解错然后死循环了，😂，这一段：“假设有个线程 T1 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。 如果线程 T1 进入管程后恰好发现队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的等待队列里面等。此时线程 T1 就去“队列不空”这个条件变量的等待队列中等待。”。<br><br>线程T1出列，正好发现队列为空，那么T1会进入条件变量对应的队列等待，假设一个进程只有一个线程T1，那线程T1不是要一直在条件变量队列里面等待吗，往下看，wait是有超时时间的，超时后，线程T1重新进入入口队列，入队成功后，T1再次出队，这时发现队列为空，又要进入条件变量队列等待……这不是死循环了吗😂<br><br>","like_count":1,"discussions":[{"author":{"id":1309759,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fc/3f/7e95156a.jpg","nickname":"啊勇","note":"","ucode":"CB403DD04F920A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300,"discussion_content":"只有一个线程就不存在并发了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561435673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76921,"user_name":"小黄","can_delete":false,"product_type":"c1","uid":1049839,"ip_address":"","ucode":"519BF8191D3A6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/ef/fea0fdbd.jpg","comment_is_top":false,"comment_ctime":1552751427,"is_pvip":false,"replies":[{"id":"28075","content":"JVM保证，或者并发包里的AQS也能保证","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552791247,"ip_address":"","comment_id":76921,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847718723","product_id":100023901,"comment_content":"不理解，notify会把条件队列里线程移到入口队列。其他线程会因为锁阻塞在入口队列，那入口队列怎么保证线程安全的？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443502,"discussion_content":"JVM保证，或者并发包里的AQS也能保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76740,"user_name":"银时空de梦","can_delete":false,"product_type":"c1","uid":1179017,"ip_address":"","ucode":"EC707B6CF7F287","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/89/cbca1b8e.jpg","comment_is_top":false,"comment_ctime":1552699063,"is_pvip":false,"replies":[{"id":"27994","content":"等待的条件不成立，出什么问题要看应用场景。例如转账就可能转错。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552705463,"ip_address":"","comment_id":76740,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847666359","product_id":100023901,"comment_content":"用while循环那儿还是不理解，能举例说明，如果不用会出什么问题吗","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443426,"discussion_content":"等待的条件不成立，出什么问题要看应用场景。例如转账就可能转错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552705463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353045,"user_name":"向显","can_delete":false,"product_type":"c1","uid":2102748,"ip_address":"陕西","ucode":"DD6B3D61D39000","user_header":"https://static001.geekbang.org/account/avatar/00/20/15/dc/45f68b76.jpg","comment_is_top":false,"comment_ctime":1659089184,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659089184","product_id":100023901,"comment_content":"假设有个线程 T1 执行阻塞队列的出队操作，执行出队操作，需要注意有个前提条件，就是阻塞队列不能是空的（空队列只能出 Null 值，是不允许的），阻塞队列不空这个前提条件对应的就是管程里的条件变量。 如果线程 T1 进入管程后恰好发现阻塞队列是空的，那怎么办呢？等待啊，去哪里等呢？<br><br>有个疑问,进入管程 发现阻塞队列是空的? 为啥要等待?","like_count":0},{"had_liked":false,"id":349682,"user_name":"码小呆","can_delete":false,"product_type":"c1","uid":2055809,"ip_address":"","ucode":"44532D6ABF9340","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","comment_is_top":false,"comment_ctime":1656226128,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656226128","product_id":100023901,"comment_content":"看的懵逼了","like_count":0},{"had_liked":false,"id":348064,"user_name":"JooKS","can_delete":false,"product_type":"c1","uid":2381003,"ip_address":"","ucode":"A1A5940F4E9987","user_header":"https://static001.geekbang.org/account/avatar/00/24/54/cb/8d74b66c.jpg","comment_is_top":false,"comment_ctime":1654699188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654699188","product_id":100023901,"comment_content":"感觉AQS就是典型的管程模型","like_count":0},{"had_liked":false,"id":346796,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1653442381,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653442381","product_id":100023901,"comment_content":"什么是管程<br>\t管理类的成员变量和方法 让这个类是线程安全的<br>MESA 模型<br>\t两大核心问题<br>\t\t互斥<br>\t\t\t同一时刻只有一个线程能够访问对应资源<br>\t\t同步<br>\t\t\t线程间的通信 协作<br>\t管程解决互斥问题<br>\t\t将共享变量与操作封装加锁<br>\t管程解决同步问题<br>\t\t模拟阻塞队列的出队入队过程<br>\t\t\t伪代码<br>wait的正确姿势<br>\tMESA模型独有 需要在while里面用wait 防止虚假唤醒<br>\t\t本质上是因为wait等待后 线程被唤醒后需要再次判断 因为条件变量可能发生了变化 if就做不到了<br>\t三种模型通知执行<br>\t\tHasen<br>\t\t\tt2通知完结束 t1再去执行 保证同步<br>\t\tHoare<br>\t\t\tt2通知完阻塞 t1马上执行 t1执行完 唤醒t2<br>\t\t\t\t多了一次阻塞唤醒<br>\t\tMesa<br>\t\t\tt2通知完 继续执行 t1再去排队<br>\t\t\t\t之前可能t1满足了条件 但现在又要验证了 所以要用while判断<br>notify什么时候用<br>\t之前说过了 除非深思熟虑 否则一律使用notifyAll<br>\t条件<br>\t\t所有线程拥有相同的等待条件<br>\t\t\t如上面阻塞队列满了 等待<br>\t\t所有线程被唤醒 执行相同的操作<br>\t\t\t唤醒后 干活 通知<br>\t\t只需要唤醒一个线程<br>总结<br>\t重点理解阻塞队列 加锁解锁 出队入队的条件变量 等待唤醒操作<br>\t注意新模型是通知后 另一个线程是再去排队而不是立刻执行的","like_count":0},{"had_liked":false,"id":340579,"user_name":"龙行天下","can_delete":false,"product_type":"c1","uid":1231302,"ip_address":"","ucode":"90BEED7A164ADE","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/c6/16136ab3.jpg","comment_is_top":false,"comment_ctime":1648948119,"is_pvip":true,"replies":[{"id":"124570","content":"有道理有道理","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1649077318,"ip_address":"","comment_id":340579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648948119","product_id":100023901,"comment_content":"作者在管程模型解释时把下文（文中说是上文，其实是下文）提到的阻塞队列放在一起解释，提高了理解的难度。如果把阻塞队列里的不空和不满条件理解为入队操作和出队操作，往队列里放数据（入队方法），如果满了，入队操作就阻塞；如果没满，就放入对列，并唤醒出队操作","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559952,"discussion_content":"有道理有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649077319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334525,"user_name":"徐富献","can_delete":false,"product_type":"c1","uid":2568689,"ip_address":"","ucode":"D1E901376F8D49","user_header":"https://static001.geekbang.org/account/avatar/00/27/31/f1/1ff57b9d.jpg","comment_is_top":false,"comment_ctime":1644986900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644986900","product_id":100023901,"comment_content":"感觉这里面如果产生疑惑，主要是没有分清入口等待队列和条件变量队列的区别：<br>入口等待队列：相当于医生诊室门口排队的病人。一次只能进入一个。这个过程类似于对代码块加锁，病人就是需要执行代码块的线程。当病人进入诊室（线程拿到锁后，根据条件变量的不同，会有下面集几种情况）：<br>1. 医生直接为病人诊断、治疗，病人离开诊室，回家--&gt; （不需要条件变量，或者条件变量已经满足）线程直接执行代码块中的内容，并释放锁（synchronized自动完成释放锁过程）。<br>2. 医生让病人去做个CT，病人去CT室进行排队 --&gt; 对应着管程模型中条件变量不满足的情况，线程进入到条件变量的等待队列中。<br>3. 当病人做完CT，又需要重新回到诊室门口排队 --&gt; 线程条件满足，重新进行管程模型的入口等待队列（这里和2中的条件变量等待队列不是一回事）<br>4. 重复2-3的过程，直到所有医生为病人诊断、治疗 --&gt; 线程执行代码块中的内容 ","like_count":0},{"had_liked":false,"id":334228,"user_name":"Geek-Pax","can_delete":false,"product_type":"c1","uid":1447512,"ip_address":"","ucode":"60F9DB1FC4B000","user_header":"https://static001.geekbang.org/account/avatar/00/16/16/58/0ef55c6a.jpg","comment_is_top":false,"comment_ctime":1644822061,"is_pvip":false,"replies":[{"id":"122153","content":"当有并发冲突的时候，不能保证有序入队，也就不能保证有序出队了，其实就是不能保证公平。对外展示的现象是随机出队了","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1644922521,"ip_address":"","comment_id":334228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644822061","product_id":100023901,"comment_content":"1.java中synchronized的等待队列,或是Wait()的等待队列,说是队列其实并不是FIFO 对吗?<br>2.关于notify()唤醒条件等待队列说是随机但其实依赖于jvm具体实现,hotpot就是按照FIFO唤醒的<br>3.那么基于第二问notify()唤醒后 ,synchronized的入口等待队列是否还会发生锁的竞争了(假设多线程),还是synchronzed的等待队列也是依赖于具体的JVM实现,也存在FIFO呢?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551195,"discussion_content":"当有并发冲突的时候，不能保证有序入队，也就不能保证有序出队了，其实就是不能保证公平。对外展示的现象是随机出队了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644922522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332477,"user_name":"う猪小小℡　　","can_delete":false,"product_type":"c1","uid":2433448,"ip_address":"","ucode":"2AFB889B0B76BD","user_header":"https://static001.geekbang.org/account/avatar/00/25/21/a8/6c3065ec.jpg","comment_is_top":false,"comment_ctime":1643271658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643271658","product_id":100023901,"comment_content":"这章看得是真累，非常不易理解。我的语文水平阅读理解能力已经是相当好的看起来都非常吃力...怎么突然间写成这样，看了几次都昏昏欲睡","like_count":0},{"had_liked":false,"id":325765,"user_name":"koby","can_delete":false,"product_type":"c1","uid":2154554,"ip_address":"","ucode":"16F596A9A963DF","user_header":"","comment_is_top":false,"comment_ctime":1639122409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639122409","product_id":100023901,"comment_content":"我觉得不是有没有必要加超时时间，而是hasen和horea不支持加超时时间，这两种通过控制顺序，所以不用while，结果没人通知你，你自己觉得时间长了，就去执行，那还不乱套了。MESA支持加超时时间，作用吗，就是一直没人通知我，我就自己去瞄一下","like_count":0},{"had_liked":false,"id":324728,"user_name":"rusess","can_delete":false,"product_type":"c1","uid":1029051,"ip_address":"","ucode":"C6F46B368F3392","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/bb/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1638590938,"is_pvip":false,"replies":[{"id":"118192","content":"sleep是出让CPU使用权，改变线程状态，不会进入java的任何队列里面，交给操作系统管理的。","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1639203576,"ip_address":"","comment_id":324728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638590938","product_id":100023901,"comment_content":"老师问一下， thread 执行sleep 是进入哪个队列了？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537811,"discussion_content":"sleep是出让CPU使用权，改变线程状态，不会进入java的任何队列里面，交给操作系统管理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639203576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323509,"user_name":"denofiend","can_delete":false,"product_type":"c1","uid":1594508,"ip_address":"","ucode":"FC9A750C96E01C","user_header":"https://static001.geekbang.org/account/avatar/00/18/54/8c/a3b98f6c.jpg","comment_is_top":false,"comment_ctime":1637940772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637940772","product_id":100023901,"comment_content":"阻塞队列 是入口的阻塞队列，只能一个个来。 看医生<br>等待队列 是条件的等待队列，条件不满足，就放到等待队列中。 各项检查结果。<br><br>管程：解决的是线程互斥（只能一个线程在工作），线程同步的技术（线程之前的状态同步，线程A干完了，通知线程B开始干）。","like_count":0},{"had_liked":false,"id":319455,"user_name":"ฅSlekฅ","can_delete":false,"product_type":"c1","uid":2436755,"ip_address":"","ucode":"B732C672B3D301","user_header":"https://static001.geekbang.org/account/avatar/00/25/2e/93/81e3e4ca.jpg","comment_is_top":false,"comment_ctime":1635819969,"is_pvip":false,"replies":[{"id":"116130","content":"🙀","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1636264062,"ip_address":"","comment_id":319455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635819969","product_id":100023901,"comment_content":"同事把“对象等待池”解释为“前男友池”，把“锁池”解释成“备胎池”仔细一想真是妙啊！ <br>— 我曾拥有过你，但是因为达不到某些条件我暂时失去了你（释放锁进入前男友池）但是经过我的努力（又达到了某些条件）我又获得了拥有你的资格然后我进入了备胎池，和众多备胎一起争夺你（非公平）哈哈哈，笑不活了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529640,"discussion_content":"🙀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636264062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316961,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1634629276,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1634629276","product_id":100023901,"comment_content":"我画了张图 供大家理解阻塞对列的入队出队操作 <br>https:&#47;&#47;www.processon.com&#47;view&#47;link&#47;616e76037d9c0870404d644e","like_count":0},{"had_liked":false,"id":315110,"user_name":"官宝儿","can_delete":false,"product_type":"c1","uid":2110827,"ip_address":"","ucode":"03B4312475A984","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5eicXFWltiaF9ibsEh2nNC80OYoHibhhE0X1hPHZ5KuAtY4Yxp5dQ4LsciaDxUHFBPlJM7kgQwkspzsQ/132","comment_is_top":false,"comment_ctime":1633690184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633690184","product_id":100023901,"comment_content":"MESA加入合适的超时可以让部分资源回归，返回失败的结果，可以避免线程过多地等待时刻，而调用方也可以发起重试，这样更活性的一点","like_count":0},{"had_liked":false,"id":315109,"user_name":"官宝儿","can_delete":false,"product_type":"c1","uid":2110827,"ip_address":"","ucode":"03B4312475A984","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5eicXFWltiaF9ibsEh2nNC80OYoHibhhE0X1hPHZ5KuAtY4Yxp5dQ4LsciaDxUHFBPlJM7kgQwkspzsQ/132","comment_is_top":false,"comment_ctime":1633689962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633689962","product_id":100023901,"comment_content":"队列满了锁定资源，后续入队线程进入等待队列，队列空了锁定出队锁资源，等待入队解锁，进度等待会释放持有锁资源，后续访问线程可以一直进入等待队列，当入队等待线程被唤醒会重新持有锁资源执行入队操作，当然，如之前不可避免的还会进行一次while检查，如果用if这里会被跳过，这种资源一开一合应该就是MESA模型的特点吧，while循环是为了保证开合条件成立的合理性吧","like_count":0},{"had_liked":false,"id":315030,"user_name":"官宝儿","can_delete":false,"product_type":"c1","uid":2110827,"ip_address":"","ucode":"03B4312475A984","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5eicXFWltiaF9ibsEh2nNC80OYoHibhhE0X1hPHZ5KuAtY4Yxp5dQ4LsciaDxUHFBPlJM7kgQwkspzsQ/132","comment_is_top":false,"comment_ctime":1633665826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633665826","product_id":100023901,"comment_content":"上一章还是小学，这一章突然变成了高中，理解了原理但没理解代码","like_count":0},{"had_liked":false,"id":310019,"user_name":"到道可道","can_delete":false,"product_type":"c1","uid":1031181,"ip_address":"","ucode":"12B94B6C26BE0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/0d/00424e81.jpg","comment_is_top":false,"comment_ctime":1630459093,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1630459093","product_id":100023901,"comment_content":"因为MESA模型中，T2执行notify后不是马上唤醒T1，还有可能T2notify后续代码耗时很长，可能轮到T1执行时，已满足的条件就已经不再满足了，加上一个超时参数，可以让T1更快的执行","like_count":0},{"had_liked":false,"id":309736,"user_name":"黑米","can_delete":false,"product_type":"c1","uid":1018706,"ip_address":"","ucode":"E7DBEA7867862A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/52/6659dc1b.jpg","comment_is_top":false,"comment_ctime":1630315752,"is_pvip":false,"replies":[{"id":"112419","content":"没有","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1630590625,"ip_address":"","comment_id":309736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630315752","product_id":100023901,"comment_content":"所以JAVA自己实现了一个管程的模型，跟操作系统层面的管程没有半毛钱关系吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525988,"discussion_content":"没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630590625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294905,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1622127316,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622127316","product_id":100023901,"comment_content":"入口队列和条件队列的线程状态都不一样吧","like_count":0},{"had_liked":false,"id":293233,"user_name":"Franklin","can_delete":false,"product_type":"c1","uid":1530379,"ip_address":"","ucode":"E4580C46DB00EE","user_header":"https://static001.geekbang.org/account/avatar/00/17/5a/0b/ff309add.jpg","comment_is_top":false,"comment_ctime":1621299361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621299361","product_id":100023901,"comment_content":"阻塞队列是针对共享变量的存取，等待队列是访问共享变量的队列，等待队列可以有多个，阻塞队列和共享变量个数有关","like_count":0},{"had_liked":false,"id":292285,"user_name":"北京小妞","can_delete":false,"product_type":"c1","uid":2192295,"ip_address":"","ucode":"5A327F761E2DFA","user_header":"https://static001.geekbang.org/account/avatar/00/21/73/a7/c8ea0a62.jpg","comment_is_top":false,"comment_ctime":1620756152,"is_pvip":false,"replies":[{"id":"105884","content":"对","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1620819156,"ip_address":"","comment_id":292285,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1620756152","product_id":100023901,"comment_content":"我理解wait加超时时间，是一种防止饥饿的方式，对吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519758,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620819156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379707,"discussion_content":"不加超时时间只能等着靠别人通知，加了超时时间就可以自己去看是否满足条件\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624088071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289393,"user_name":"絆","can_delete":false,"product_type":"c1","uid":1618328,"ip_address":"","ucode":"52D965461314DB","user_header":"https://static001.geekbang.org/account/avatar/00/18/b1/98/11b22d79.jpg","comment_is_top":false,"comment_ctime":1618995973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618995973","product_id":100023901,"comment_content":"老师文中的阻塞队列一直都是在讲解决互斥中提到的阻塞队列,后面的很多例子也都是和等待队列相结合来讲的是吧~","like_count":0},{"had_liked":false,"id":289084,"user_name":"saiuna","can_delete":false,"product_type":"c1","uid":2434363,"ip_address":"","ucode":"8DB9C47C965195","user_header":"https://static001.geekbang.org/account/avatar/00/25/25/3b/864c5115.jpg","comment_is_top":false,"comment_ctime":1618848122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618848122","product_id":100023901,"comment_content":"典型的生产消费: <br><br>生产者生产了（有资源了），该通知消费者消费。<br><br>消费者来消费了（资源了消耗），该通知生产者生产。","like_count":0},{"had_liked":false,"id":284595,"user_name":"Geek_256e80","can_delete":false,"product_type":"c1","uid":1805157,"ip_address":"","ucode":"37F6425A005F76","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3pP1iaBmkdXtbo6VS7B8xJBbxXFXNBWcwm1dWzd53s94o4wBUwhaZDdavialVVMprNpeLhEFpHzspNMFOGWxV8Vg/132","comment_is_top":false,"comment_ctime":1616379927,"is_pvip":false,"replies":[{"id":"103331","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616499591,"ip_address":"","comment_id":284595,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616379927","product_id":100023901,"comment_content":"wait()方法，加了超时参数，可以防止线程无限等待消耗资源，在生产环境环境很重要！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517400,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616499591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283896,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1615975229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615975229","product_id":100023901,"comment_content":"超时参数是为了降低CPU的活跃程度，如果条件变量判断消耗资源的情况下，适当降低资源消耗。","like_count":0},{"had_liked":false,"id":279720,"user_name":"ben harden","can_delete":false,"product_type":"c1","uid":1512500,"ip_address":"","ucode":"6F1AAD00DA1B1B","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/34/6e58aebe.jpg","comment_is_top":false,"comment_ctime":1613923802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613923802","product_id":100023901,"comment_content":"while (阻塞队列已满){ &#47;&#47; 等待队列不满 notFull.await();}<br>老师，如果把while换成if会有什么影响吗？","like_count":0},{"had_liked":false,"id":277280,"user_name":"漂泊者及其影子","can_delete":false,"product_type":"c1","uid":1119979,"ip_address":"","ucode":"13FE760FE8B111","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/eb/30864e40.jpg","comment_is_top":false,"comment_ctime":1612343176,"is_pvip":false,"replies":[{"id":"100817","content":"借助信号量，能实现这些需求","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1612599683,"ip_address":"","comment_id":277280,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612343176","product_id":100023901,"comment_content":"文章中说“管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。”，信号量是否也支持允许线程临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514983,"discussion_content":"借助信号量，能实现这些需求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612599683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276125,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1611802418,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1611802418","product_id":100023901,"comment_content":"如何用synchronzied实现一个柱塞队列呢？ synchronized 好像是没有可重入性的原因、。。<br>使用两个对象来进行操作会比较好？但是这样子的话，put和take 之间就不存在锁竞争关系了。。？但是如果用一个锁的话，同一时间就只能有一个put （）或者一个take（）<br>class BoundedBuffer {<br>    final Object[] items = new Object[100];<br>    int putptr, takeptr, count;<br><br><br>    final Object notFull = new Object();<br>    final Object notEmpty = new Object();<br><br>    &#47;*队列满了wait，不满进队列，并且释放所有的出队线程*&#47;<br>    public void put(Object x) throws InterruptedException {<br>        synchronized (notFull){<br>            try {<br>                while (count == items.length)<br>                    notFull.wait();<br>                items[putptr] = x;<br>                if (++putptr == items.length) putptr = 0;<br>                ++count;<br>                notEmpty.notifyAll();<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>    &#47;&#47;队列为空进wait ，不为空出队列，并且释放所有的进队线程<br>    public Object take() throws InterruptedException {<br>        Object x = null;<br>        synchronized (notEmpty){<br>            try {<br>                while (count == 0)<br>                    notEmpty.wait();<br>                x = items[takeptr];<br>                if (++takeptr == items.length) takeptr = 0;<br>                --count;<br>                notFull.notifyAll();<br>                return x;<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    return x;<br>    }<br>}","like_count":0},{"had_liked":false,"id":275682,"user_name":"成电帅才","can_delete":false,"product_type":"c1","uid":2139604,"ip_address":"","ucode":"DDE757138F41D2","user_header":"","comment_is_top":false,"comment_ctime":1611644545,"is_pvip":false,"replies":[{"id":"100068","content":"可以这么理解，公用一个等待队列","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1611666566,"ip_address":"","comment_id":275682,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611644545","product_id":100023901,"comment_content":"大佬，synchronized中的wait应该也是对应了条件变量的等待队列，这个队列是公用的，可以这么理解么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514438,"discussion_content":"可以这么理解，公用一个等待队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611666566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272953,"user_name":"子杰","can_delete":false,"product_type":"c1","uid":1025250,"ip_address":"","ucode":"717D10394391BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/e2/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1610362963,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610362963","product_id":100023901,"comment_content":"前面几章在好多知识点都引用了管程，但是管程这一章真的讲的很晦涩，甚至埋了陷阱，干扰理解","like_count":0},{"had_liked":false,"id":272556,"user_name":"kingsoo","can_delete":false,"product_type":"c1","uid":1033328,"ip_address":"","ucode":"8BF8A39A13035A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/70/39b1ea90.jpg","comment_is_top":false,"comment_ctime":1610143166,"is_pvip":true,"replies":[{"id":"98988","content":"可以改为不足三个，这个是开发人员根据具体需求定义的，这个条件变量就是个变量，就是个对象，具体代表什么，开发根据场景自己定义","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1610499369,"ip_address":"","comment_id":272556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610143166","product_id":100023901,"comment_content":"老师，我对这个等待条件还是有一些疑惑的地方。<br>1. 任何条件都可以被作为条件变量而被管程初始化吗？比如我可以将阻塞队列的条件改为元素不足三个的时候进入管程的条件变量等待队列吗？<br>2. 这个管程中的条件变量及等待队列是一开始就全部都初始化好不能变动的，还是全部都初始化好之后还可以再动态加新的条件变量及相应的等待队列上去的？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513307,"discussion_content":"可以改为不足三个，这个是开发人员根据具体需求定义的，这个条件变量就是个变量，就是个对象，具体代表什么，开发根据场景自己定义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610499369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271990,"user_name":"陈新卫","can_delete":false,"product_type":"c1","uid":2213774,"ip_address":"","ucode":"6EF232730D0FD7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWlndLduM3SGiauJvia0oVdhH8FhbviaS9EsD0fM93PwEKg0Syk1I5strKbsZNoXE0klauTGAwW1DGQ/132","comment_is_top":false,"comment_ctime":1609902966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609902966","product_id":100023901,"comment_content":"这个条件变量等待队列有点像观察者模式，进入队列后，如果是这样条件满足时，会被通知到，然后重新去排队","like_count":0},{"had_liked":false,"id":263292,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1606094046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606094046","product_id":100023901,"comment_content":"入口变量队列是什么维度的？一个cpu还是一个线程？","like_count":0},{"had_liked":false,"id":261290,"user_name":"Geek_c75d82","can_delete":false,"product_type":"c1","uid":2286012,"ip_address":"","ucode":"81202A016FC5D2","user_header":"","comment_is_top":false,"comment_ctime":1605259295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605259295","product_id":100023901,"comment_content":"条件变量如果一直不能满足，会导致条件变量队列的线程越来越多，线程阻塞，大量的线程会导致内存和CPU占用比较多，影响业务正常使用","like_count":0},{"had_liked":false,"id":259776,"user_name":"抽象","can_delete":false,"product_type":"c1","uid":1433952,"ip_address":"","ucode":"7B06C3146FCD78","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/60/7607a6f3.jpg","comment_is_top":false,"comment_ctime":1604830315,"is_pvip":false,"replies":[{"id":"94421","content":"调用wait的线程被唤醒，不一定100%能通过条件测试，所以需要再次测试，如果不能通过，while可以继续调用wait等待，但是if就做不到了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1604897822,"ip_address":"","comment_id":259776,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1604830315","product_id":100023901,"comment_content":"这一节主要讲的就是管程模型，以及其工作原理。老师提到了三个模型 Hasen，Hoare和MESA模型，主要讲了MESA模型。并发的核心问题是 互斥 + 同步。通过封装共享变量和共享变量的操作，然后线程通过竞争获取monitor获取锁，如果没有抢到缩，线程进入等待队列。获得锁之后，线程进行条件变量判断，如果条件不符合，调用wait方法进入条件变量等待队列并释放锁资源，如果条件符合执行后续操作。在变量条件变化的时候调用notify方法唤醒条件等待队列中线程入入口等待队列。这个模型和这两个队列完全把我的多线程编码实践给点亮了，知道编码的时候要注意什么，以及如何使用wait 和 notify 配合自己的编码逻辑完成并发，太nice了，感谢老师。但是我还有一点困惑。 线程进入临界区要以循环的方式进行条件变量判断，那老师我这里的条件判断不用while 用 if 可以嘛？？反正线程之前的条件满足过，现在可能不满足，while判断OK，那我 if 判断也是可以的啊，对吧。求老师翻牌。感谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509022,"discussion_content":"调用wait的线程被唤醒，不一定100%能通过条件测试，所以需要再次测试，如果不能通过，while可以继续调用wait等待，但是if就做不到了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604897822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379708,"discussion_content":"if判断，下次就要重头开始了，syschronized里面是从wait()后面开始执行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624088559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256369,"user_name":"蚝不鱿鱼","can_delete":false,"product_type":"c1","uid":1428043,"ip_address":"","ucode":"5DB98E406F1D3E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","comment_is_top":false,"comment_ctime":1603610826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603610826","product_id":100023901,"comment_content":"第二遍了这篇，得多看相关文章，尽管每个大佬都有自己的理解，也许他说的并不准确，但其实最终理解到什么程度还是得靠自己悟。","like_count":0},{"had_liked":false,"id":255978,"user_name":"bidinggong","can_delete":false,"product_type":"c1","uid":1898806,"ip_address":"","ucode":"789A1FBA8408F3","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f9/36/f44b633e.jpg","comment_is_top":false,"comment_ctime":1603490397,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603490397","product_id":100023901,"comment_content":"所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。","like_count":0},{"had_liked":false,"id":254441,"user_name":"隔壁老李","can_delete":false,"product_type":"c1","uid":1145294,"ip_address":"","ucode":"1069E913FF69D9","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/ce/89d87a1c.jpg","comment_is_top":false,"comment_ctime":1603116565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603116565","product_id":100023901,"comment_content":"这一篇看的有点懵。","like_count":0},{"had_liked":false,"id":249291,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1600573009,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1600573009","product_id":100023901,"comment_content":"1、mesa模型，T2通知T1后，T2还是可以接着执行，T1并不会立即执行，仅仅从条件变量队列转入了入口等待队列。这样notify就不需要放在最后，T2也没有多余的唤醒操作。不过有副作用，就是当T1再次执行的时候，可能曾经满足的条件，现在已经不满足，所以必须在循环中校验条件变量<br>2、hasen模型，要求notify必须放在最后，这样T2通知T1后，T2就结束了，然后T1再执行，这样就能保证同一时刻只有一个线程在执行。<br>3、hoare模型，T2通知完T1后，T2马上阻塞，T1马上执行。等T1执行完后再唤醒T2，也能保证同一时刻只有一个线程在执行。不过T2这样就比hasen模型多了一次唤醒操作。","like_count":0},{"had_liked":false,"id":246369,"user_name":"Geek_d6dc46","can_delete":false,"product_type":"c1","uid":2064920,"ip_address":"","ucode":"F196E1DF86C232","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epxtS2pw4g1tQGnYtGoiaxO0nfvl0N2u1By3DYZY14PcosqjwYTqLib9Tib18kRrx30USHbADH0DAIWw/132","comment_is_top":false,"comment_ctime":1599297767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599297767","product_id":100023901,"comment_content":"public class demo1 {<br><br>    final Lock lock = new ReentrantLock();<br><br>    final Condition notfull = lock.newCondition();<br><br>    final Condition notEmpty = lock.newCondition();<br><br>    private static volatile int flag = 0;<br><br><br>    public void inQue(){<br>        lock.lock();<br>        try{<br>            while (flag &gt; 5){<br>                System.out.println(&quot;入栈没有获取锁,进入等待.&quot;);<br>                notfull.await();<br>            };<br>            System.out.println(&quot;入栈线程开始运行&quot;+Thread.currentThread().getName());<br>            ++flag;<br>            notfull.signal();<br>        }catch (Exception e){<br>            System.out.println(e.getMessage());<br>        }finally {<br>            System.out.println(&quot;flag=====&quot;+flag);<br>            lock.unlock();<br>        }<br>    }<br><br>    public void outQue(){<br>        lock.lock();<br>        try{<br>            while (flag &lt;= 0){<br>                System.out.println(&quot;出站没有获取锁,进入等待.&quot;);<br>                notEmpty.await();<br>            };<br>            System.out.println(&quot;出站线程开始运行&quot;+Thread.currentThread().getName());<br>            --flag;<br>            notEmpty.signal();<br>        }catch (Exception e){<br>            System.out.println(e.getMessage());<br>        }finally {<br>            System.out.println(&quot;flag=====&quot;+flag);<br>            lock.unlock();<br>        }<br>    }<br><br>    public static void main(String[] args) {<br><br>        demo1 demo = new demo1();<br><br>        for (int i = 0; i &lt; 10; i++) {<br>            new Thread(()-&gt;{<br>                demo.inQue();<br>                demo.outQue();<br>            }).start();<br>        }<br><br>    }<br><br>}<br>","like_count":0},{"had_liked":false,"id":246349,"user_name":"Geek_4d9ee8","can_delete":false,"product_type":"c1","uid":2157134,"ip_address":"","ucode":"5B1F73DF7AEBDA","user_header":"","comment_is_top":false,"comment_ctime":1599291666,"is_pvip":false,"replies":[{"id":"91346","content":"line1 不会执行了。管程来保证互斥性，不需要开发再写获取锁的代码了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1600347410,"ip_address":"","comment_id":246349,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599291666","product_id":100023901,"comment_content":"有地方不太明白，请教下老师：<br><br>&#47;&#47; 入队  <br>void enq(T x) {    <br>    lock.lock();    ---------------line1<br>    try {      <br>          while (队列已满){        <br>          &#47;&#47; 等待队列不满         <br>          notFull.await(); <br>      }        <br>      &#47;&#47; 省略入队操作...      <br>      &#47;&#47;入队后,通知可出队      <br>      notEmpty.signal();    <br>}finally {      <br>   lock.unlock();    <br>  }  <br>}<br><br>当队列已满时，notFull进入wait，释放锁，当被唤醒时，重新执行while循环。那line1处的lock.lock()是不是就不再执行了？那唤醒之后的线程是如何获取锁的呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505120,"discussion_content":"line1 不会执行了。管程来保证互斥性，不需要开发再写获取锁的代码了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600347410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243379,"user_name":"王圣军","can_delete":false,"product_type":"c1","uid":1395602,"ip_address":"","ucode":"1E13CF683137D1","user_header":"https://static001.geekbang.org/account/avatar/00/15/4b/92/03338a22.jpg","comment_is_top":false,"comment_ctime":1598081133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598081133","product_id":100023901,"comment_content":"这节课应该就是按照AQS的基础来说的，和AQS的实现基本一致的","like_count":0},{"had_liked":false,"id":242928,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597894930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597894930","product_id":100023901,"comment_content":"有必要<br>在 Hasen 模型和 Hoare 模型中，线程wait()后，被唤醒后是一定会被执行的。但是MESA模型中，线程wait()后，进入到条件等待队列中，如果使用条件等待队列中有多条线程的时候，执行notify()方法后只能唤醒一个线程，有可能会有线程一直不能被唤醒。wait()方法加了超时时间，超过这个时间，就会把该线程从等待队列中移除。","like_count":0},{"had_liked":false,"id":242921,"user_name":"地平线","can_delete":false,"product_type":"c1","uid":1482026,"ip_address":"","ucode":"F50717D6244867","user_header":"https://static001.geekbang.org/account/avatar/00/16/9d/2a/3e57b54a.jpg","comment_is_top":false,"comment_ctime":1597893865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597893865","product_id":100023901,"comment_content":"MESA 模型里面，增加了超时参数是有必要的。因为在MESA 模型里面，notify()方法会唤醒所有等待队列里面的某个线程，包括它自己，都会去重新获取管程，如果此时是它自己再次获得管程，则会应条件不满进入等待队列，这时就会出现等待队列里面的线程不会再被唤醒，它自己也进去了一个“死等”状态。","like_count":0},{"had_liked":false,"id":237653,"user_name":"关羽","can_delete":false,"product_type":"c1","uid":1057179,"ip_address":"","ucode":"6FC2CDA20191DB","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/9b/347301f6.jpg","comment_is_top":false,"comment_ctime":1595915031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595915031","product_id":100023901,"comment_content":"await方法添加时间，看jdk的说明，大致意思是如果时间一过，该线程会继续执行，意思难道是为了防止该线程“饥饿”？","like_count":0},{"had_liked":false,"id":237465,"user_name":"max","can_delete":false,"product_type":"c1","uid":1773471,"ip_address":"","ucode":"91DDE86511DCDC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/0f/9f/caae319d.jpg","comment_is_top":false,"comment_ctime":1595838360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595838360","product_id":100023901,"comment_content":"老师的文章例子虽然不好，但其他地方思路都很清晰","like_count":0},{"had_liked":false,"id":233382,"user_name":"Geek_2f3efa","can_delete":false,"product_type":"c1","uid":2059571,"ip_address":"","ucode":"A5F2BB67C94E60","user_header":"","comment_is_top":false,"comment_ctime":1594304067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594304067","product_id":100023901,"comment_content":"写的真好，重要的点都提出来了！","like_count":0},{"had_liked":false,"id":232266,"user_name":"PANDA","can_delete":false,"product_type":"c1","uid":2011252,"ip_address":"","ucode":"5FB53544EC5FEF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b0/74/767f9183.jpg","comment_is_top":false,"comment_ctime":1593939020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593939020","product_id":100023901,"comment_content":"疑惑点：MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。<br>问题：1.当T2通知完T1,T2继续执行。此时按理T2尚未释放互斥锁，那入口等待队列中线程还是无法竞争到锁对象。对么？<br>2.T1被T2通知后进入入口等待队列，如果等待队列中已有其他线程在等待，那么T1是获取不到机会执行的，只有T1进入队列时是空队列才能保证可以执行。对否？<br>","like_count":0},{"had_liked":false,"id":229240,"user_name":"刘清斌","can_delete":false,"product_type":"c1","uid":1123103,"ip_address":"","ucode":"775B053AF87B53","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/1f/6452b2e8.jpg","comment_is_top":false,"comment_ctime":1592928839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592928839","product_id":100023901,"comment_content":"老师讲的真的很通俗易懂，以前看这部分内容，有点懵逼，现在好很多了","like_count":0},{"had_liked":false,"id":223633,"user_name":"Autom","can_delete":false,"product_type":"c1","uid":1309819,"ip_address":"","ucode":"AFEA394264CDAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcZh2daicchElHxuLLZrQ6gZKY5ErPg8NDzXLGHicxnWQAolgPAZLKbp48Kv2VfGw9Z5It6K6ZZqlA/132","comment_is_top":false,"comment_ctime":1591146430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591146430","product_id":100023901,"comment_content":"老师你好，我还是不太明白为什么能用notify代替notifyAll?  如果一个线程被唤醒，然后又改变了判断条件，那么被唤醒的线程执行后又会重新进入阻塞状态，这时候就饿死了，没人能再唤醒。所以老师说的那三个条件有什么作用？","like_count":0},{"had_liked":false,"id":219565,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1590043545,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1590043545","product_id":100023901,"comment_content":"文里说：管程要求同一时刻只允许一个线程执行 那多核cpu跑一个程序的时候是怎么执行的？一个cpu跑，其他的闲着吗？","like_count":0},{"had_liked":false,"id":214634,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1588775607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588775607","product_id":100023901,"comment_content":"因为MEMA管程模型中等待的线程再次执行的时候曾经满足的条件不再满足，线程又要陷入等待状态，所以需要设置超时时间防止线程老是陷入等待状态。","like_count":0},{"had_liked":false,"id":213421,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588410176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588410176","product_id":100023901,"comment_content":"管程就是管理共享变量以及共享变量的操作过程，使其能够并发。<br>而java中synchronize  wait  notify  notifyAll是管程的一部分，但是只支持一个条件变量。<br>管程解决的是并发编程的安全性。","like_count":0},{"had_liked":false,"id":209992,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1587648177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587648177","product_id":100023901,"comment_content":"wait加超时时间，时间到了后，线程会进入就绪队列，其实它需要的条件可能仍然不满足，类似于，医生让你去验血，你看了下今天验血是不开门，我先回到等待就诊，重新让医生看看。mesa模型避免了等待条件满足后，因为线程优先级和资源紧缺一直没有被唤醒阻塞","like_count":0},{"had_liked":false,"id":209364,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1587541361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587541361","product_id":100023901,"comment_content":"老师，这点不理解。<br>假设有个线程 T1 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。 如果线程 T1 进入管程后恰好发现队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的等待队列里面等。此时线程 T1 就去“队列不空”这个条件变量的等待队列中等待。<br><br>我的疑问：<br>线程T1进入管程发现条件变量对应的队列为空的，为什么要去队列为空的等待队列中等待呢，而不是去判断条件变量是否满足，不满足才进到条件变量对应的等待队列中？<br><br>","like_count":0},{"had_liked":false,"id":207010,"user_name":"zxy","can_delete":false,"product_type":"c1","uid":1253310,"ip_address":"","ucode":"FFAA3F6667305D","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/be/551454e0.jpg","comment_is_top":false,"comment_ctime":1586995076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586995076","product_id":100023901,"comment_content":"课后回答，MESA模型中T2时是去唤醒了等待的线程T1，并没有释放锁。待T1获取到锁后，可能出现条件又不满足的情况，这样又进入了条件变量等待队列。因此加一个超时是为了让其能自醒，防止一直死等","like_count":0},{"had_liked":false,"id":206505,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1586871715,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586871715","product_id":100023901,"comment_content":"wait 里加 时间参数非常有必要, 因为当某些线程在产生相关条件的信号之前失败时, 那么等待该条件的进程就会被无限制地推迟而处于饥饿状态","like_count":0},{"had_liked":false,"id":202018,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1585887985,"is_pvip":false,"replies":[{"id":"76113","content":"理论上，如果代码没bug是可以不使用while检查条件的，不过这个检查就像非空判断一样，更安全","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586257416,"ip_address":"","comment_id":202018,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585887985","product_id":100023901,"comment_content":"MESA模型中，线程T1通知线程T2之后，T2并不立即执行，是因为通知线程时仅仅是将等待线程放入到入口队列中，此时线程T1并未释放锁，因此T2未进入管程（即没有立即执行）；之所以需要使用while是因为通知线程时，使用notifyAll会通知所有等待线程，因此T2开始执行时有可能条件已经被其他等待线程处理了，此时不满足条件；如果是使用notify来通知线程的话，可以不使用while检查条件。<br><br>不知道我的理解对不对，恳请老师解答下，谢谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490483,"discussion_content":"理论上，如果代码没bug是可以不使用while检查条件的，不过这个检查就像非空判断一样，更安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586257416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108159,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/bf/39042a46.jpg","nickname":"牙医","note":"","ucode":"27791DFF11EF45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242035,"discussion_content":"就是避免伪唤醒吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587460226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201360,"user_name":"苏暮沉觞","can_delete":false,"product_type":"c1","uid":1577580,"ip_address":"","ucode":"532B816D4EF47B","user_header":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","comment_is_top":false,"comment_ctime":1585755712,"is_pvip":false,"replies":[{"id":"75457","content":"线程1和线程2的执行路径是一样的，都会重新争抢锁，如果不出意外，迟早会拿到锁的，拿到锁后执行的路径也是一样的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1585872938,"ip_address":"","comment_id":201360,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585755712","product_id":100023901,"comment_content":"老师，在这里我有一个问题，假如最开始有线程1进入方法中，因为条件不满足，调用wait（），进入条件变量等待队列，然后又有个线程2.也跟线程1 一样，进入方法，调用wait（），进入条件变量等待队列（这时这个队列里有2个等待的线程）。当有另外一个线程3调用了notifyAll（），唤醒条件变量等待队列的两个线程。按照文中的讲解，这个时候线程1和2都会进入入口等待队列。假设线程1先获取到锁进入方法，但是因为条件判断不满足，又进入了条件等待队列，那么线程2还会跟线程1一样，进入方法运行，判断条件是否满足，还是说线程2 在线程 1进入方法以后就直接阻塞了，要再次等待其他线程的唤醒？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490312,"discussion_content":"线程1和线程2的执行路径是一样的，都会重新争抢锁，如果不出意外，迟早会拿到锁的，拿到锁后执行的路径也是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585872938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200612,"user_name":"幸福就在不远处","can_delete":false,"product_type":"c1","uid":1622408,"ip_address":"","ucode":"1643DE193A7310","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/88/66e1f886.jpg","comment_is_top":false,"comment_ctime":1585624059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585624059","product_id":100023901,"comment_content":"老师的图画的特别优秀，不管再复杂模型，一看图就明白了。。。","like_count":0},{"had_liked":false,"id":200593,"user_name":"InfoQ_e077cb303519","can_delete":false,"product_type":"c1","uid":1390669,"ip_address":"","ucode":"2CCA309DB2EF46","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAK6F4BFT5ewhJEeZrjmRx5HxP8tvnNpJcpLlotHiadp0s6aL3d7LfMHEuQP6tibu80wUy8micVu4oQ/132","comment_is_top":false,"comment_ctime":1585622097,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585622097","product_id":100023901,"comment_content":"老师，问下，await是是释放锁的，sleep不会释放锁的，是的吧","like_count":0,"discussions":[{"author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286284,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593100754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199855,"user_name":"Geek_c22199","can_delete":false,"product_type":"c1","uid":1441876,"ip_address":"","ucode":"1CE5B65513E360","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2vn8hyjICTCletGs0omz28lhriaZKX2XX9icYzAEon2IEoRnlXqyOia2bEPP0j7T6xexTnr77JJic8w/132","comment_is_top":false,"comment_ctime":1585497004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585497004","product_id":100023901,"comment_content":"管程一种概念，解决线程互斥与同步问题的思路。互斥：Java通过synchronized 关键字实现，操作同时只有一个线程进入，其他进入等待队列等待。至于synchronized 关键字的实现参考其他博客应该是jvm的实现，对象计数器与设置当前执行线程。<br>同步：通过条件队列与等待队列，wait进入条件队列，notify唤醒条件队列进入等待队列。这没啥好说的","like_count":0},{"had_liked":false,"id":191837,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1584799547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584799547","product_id":100023901,"comment_content":"了解管程模型","like_count":0},{"had_liked":false,"id":191448,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1584774310,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584774310","product_id":100023901,"comment_content":"这点稍微有点难，要死扣。特别是对synchronized只有一个条件变量的理解。","like_count":0,"discussions":[{"author":{"id":2046055,"avatar":"","nickname":"杜总","note":"","ucode":"C6600875A265E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286286,"discussion_content":"条件变量就是锁对象调用await,将该线程放入了等待队列，当收到notifyall通知，该线程移出等待队列，放入同步队列去竞争锁，也就是只有一个条件变量的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593100991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190180,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1584610887,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584610887","product_id":100023901,"comment_content":"我觉得是有必要的，MESA中T1现在在等待队列中被唤醒，再次执行进程的时候，并不是马上就可以运行，二十先要进入到等待队列中，等待获取锁才能进入管程。这里设置一个设置一个超时时间就是为了防止T1线程进入条件变量等待队列长时间没有被唤醒。","like_count":0},{"had_liked":false,"id":189754,"user_name":"torres","can_delete":false,"product_type":"c1","uid":1108761,"ip_address":"","ucode":"34DABCFC7B74EA","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","comment_is_top":false,"comment_ctime":1584545883,"is_pvip":false,"replies":[{"id":"73989","content":"不用写try finally 了，更灵活了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1585049256,"ip_address":"","comment_id":189754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584545883","product_id":100023901,"comment_content":"MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。<br><br>老师，这段不是很明白？ 为什么说好处是notify() 不用放到代码的最后？ 放在最后和不放在最好有什么本质区别？请老师指点","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487784,"discussion_content":"不用写try finally 了，更灵活了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585049256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187576,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1584161453,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584161453","product_id":100023901,"comment_content":"&#47;&#47; 出队 void deq(){ lock.lock(); try { while (队列已空){ &#47;&#47; 等待队列不空 notEmpty.await(); } &#47;&#47; 省略出队操作... &#47;&#47;出队后，通知可入队 notFull.signal(); }finally { lock.unlock(); }    <br><br><br>这个出队操作，是不是有一个对象一直处理等待操作？","like_count":0},{"had_liked":false,"id":185030,"user_name":"Zend","can_delete":false,"product_type":"c1","uid":1053921,"ip_address":"","ucode":"80EBB0B6772E27","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","comment_is_top":false,"comment_ctime":1583467817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583467817","product_id":100023901,"comment_content":"看过多次终于弄明白了我们在用的Lock是Java SKD实现的，为什么在lock.lock后会有个while循环，以及wait()、notify()、notifyAll() 的来由，以及具体干什么，以及notify()和notifyAll()的异同。也明白了synchronized关键字是JVM实现的，底层是基于操作系统Mutex Lock实现；但他们都是基于MESA模型实现的。<br>----<br>课后作业：我觉得MESA模型中wait方法支持超时参数，是对不满足条件的线程提供了一种可以自行退出的机制。","like_count":0},{"had_liked":false,"id":184188,"user_name":"Airsaid","can_delete":false,"product_type":"c1","uid":1115302,"ip_address":"","ucode":"5B90BC0044F376","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","comment_is_top":false,"comment_ctime":1583244721,"is_pvip":false,"replies":[{"id":"71683","content":"一个是理论，一个是java里的具体实现","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1583647441,"ip_address":"","comment_id":184188,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583244721","product_id":100023901,"comment_content":"「管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。」<br><br>老师您好，请问这里的信号量和 Java 中的 Semaphore 又有什么关系呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485922,"discussion_content":"一个是理论，一个是java里的具体实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583647441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182279,"user_name":"Kevin⚡️Zhou","can_delete":false,"product_type":"c1","uid":1440772,"ip_address":"","ucode":"C0FC2673705212","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","comment_is_top":false,"comment_ctime":1582760617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582760617","product_id":100023901,"comment_content":"关于MESA模型, 我个人的理解是, 如果我们建立了BlockedQueue的单例, 然后多个线程操作这个单例, 那个当满足队列不空的条件时, 系统中可能有多个线程排队等在进行出队操作, 那么这种情况, A线程出队操作完了, 队列中下一个B线程就没法出队了, 所以需要while检查","like_count":0},{"had_liked":false,"id":179879,"user_name":"Geek_bb89c3","can_delete":false,"product_type":"c1","uid":1331828,"ip_address":"","ucode":"0F97B5B0F2DDD6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","comment_is_top":false,"comment_ctime":1582116898,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582116898","product_id":100023901,"comment_content":"对于 while(条件){condition.await();}这里的操作。<br>这里使用了messa模型。如果t2.notify()唤醒了t1。使得ti中的条件满足了。<br>这个时候t2还没有结束，还需要收尾。t1需要开始执行。这里的使用的方式是：<br>先将t1放到等待锁的入口当中。然后让t2执行完成。然后t2获取到锁，进入到执行区间去。<br>但是进入以后，可能的情况t1原本满足的条件以及不满足了。","like_count":0},{"had_liked":false,"id":178804,"user_name":"CharAt","can_delete":false,"product_type":"c1","uid":1813207,"ip_address":"","ucode":"D7D44B48FC4E79","user_header":"https://static001.geekbang.org/account/avatar/00/1b/aa/d7/a417ad5b.jpg","comment_is_top":false,"comment_ctime":1581830419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581830419","product_id":100023901,"comment_content":"void enq(T x) {   <br> lock.lock();  <br>  try {  <br>    while (队列已满){       <br> &#47;&#47; 等待队列不满       <br>  notFull.await();    <br>  }      <br>  &#47;&#47; 省略入队操作...      <br>&#47;&#47;入队后,通知可出队    <br>  notEmpty.signal();    <br>}finally {    <br>  lock.unlock();  <br> }  <br>}<br><br>上面这段代码：线程A先进入等待队列 后来从条件等待队列中唤醒，继续向下执行。<br>那 MESA模式 不是将等待队列中唤醒以后再到入口等待队列中排队吗？ 看代码的话 从条件等待队列唤醒后并没有返回到入口等待队列，而是继续执行。就像挂号以后去验血 验血回来直接进 没有再挂号。","like_count":0},{"had_liked":false,"id":176801,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1581170227,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581170227","product_id":100023901,"comment_content":"老师您好，我想问一下如果while(条件不满足) wait;当有人提示notify的话，他会接着往下走，我本意就是希望他继续往下走的啊？还要重新回去再判断吗？","like_count":0},{"had_liked":false,"id":176061,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1580927529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580927529","product_id":100023901,"comment_content":"老师想问一下这里的线程T1出队和线程T2入队的队列是共享变量的那个队列吗？如果是的话感觉这个入队和出队是不是和lock和unlock很相似？","like_count":0},{"had_liked":false,"id":175236,"user_name":"薯片","can_delete":false,"product_type":"c1","uid":1072044,"ip_address":"","ucode":"FE757E1248EFF5","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/ac/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1580625849,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580625849","product_id":100023901,"comment_content":"synchronized仅支持一个条件变量 这个怎么理解呢，是哪个条件变量呢。","like_count":0},{"had_liked":false,"id":175127,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1580565746,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580565746","product_id":100023901,"comment_content":"老师，管程和aqs有什么区别","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379709,"discussion_content":"管程是模型、aqs是实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624089183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165769,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577320471,"is_pvip":false,"replies":[{"id":"64065","content":"会","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577608489,"ip_address":"","comment_id":165769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577320471","product_id":100023901,"comment_content":"  请问下      在mesa模型中notEmpty.await();会释放lock中的锁吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479276,"discussion_content":"会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577608489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154891,"user_name":"土地公公","can_delete":false,"product_type":"c1","uid":1599207,"ip_address":"","ucode":"E79EA96485D532","user_header":"https://static001.geekbang.org/account/avatar/00/18/66/e7/684bad28.jpg","comment_is_top":false,"comment_ctime":1574592176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574592176","product_id":100023901,"comment_content":"package my.java.thread;<br><br>import java.util.concurrent.locks.Condition;<br>import java.util.concurrent.locks.Lock;<br>import java.util.concurrent.locks.ReentrantLock;<br><br>public class BlockingArrayWithCondition&lt;T&gt; {<br>    private final T[] array;<br><br>    private int head;<br><br>    private int tail;<br><br>    private int count;<br><br>    private Lock lock = new ReentrantLock();<br>    private Condition isFull = lock.newCondition();<br>    private Condition isEmpty = lock.newCondition();<br><br>    public BlockingArrayWithCondition(int size) {<br>        array = (T[]) new Object[size];<br>    }<br><br>    public void put (T item) throws InterruptedException {<br>        lock.lock();<br>        try {<br>            while (count == array.length) {<br>                isFull.await();<br>            }<br>            array[tail] = item;<br>            if (++tail == array.length) {<br>                tail = 0;<br>            }<br>            count++;<br>            System.out.println(&quot;Add Item: &quot;+item);<br>            isEmpty.signal();<br>        } finally {<br>            lock.unlock();<br>        }<br>    }<br><br>    public T take() throws InterruptedException {<br>        lock.lock();<br>        try {<br>            while (count == 0) {<br>                isEmpty.await();<br>            }<br>            T item = array[head];<br>            if (++head == array.length) {<br>                head = 0;<br>            }<br>            count --;<br>            System.out.println(&quot;Take Item: &quot;+item);<br>            isFull.signal();<br>            return item;<br>        } finally {<br>            lock.unlock();<br>        }<br>    }<br><br>}<br>","like_count":0},{"had_liked":false,"id":154675,"user_name":"JustdoitZhang","can_delete":false,"product_type":"c1","uid":1443019,"ip_address":"","ucode":"C17CB5FD292FF7","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/cb/edd7795d.jpg","comment_is_top":false,"comment_ctime":1574507336,"is_pvip":false,"replies":[{"id":"59682","content":"可以看官方的文档，这里提到的用法是基于管程模型的，适用于所有实现。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1574727986,"ip_address":"","comment_id":154675,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574507336","product_id":100023901,"comment_content":"我看过其它资料，如果是synchronize锁的话，没有特殊要求是使用notifyAll()，但是显示锁建议使用signal()吧，因为显示锁是基于aqs实现的，如果使用signalAll()就需要队列重新排序，不知道我看到的资料有没有问题？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475545,"discussion_content":"可以看官方的文档，这里提到的用法是基于管程模型的，适用于所有实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574727986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149585,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1316843,"ip_address":"","ucode":"7D440AFAA78678","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/eb/8bfd69b0.jpg","comment_is_top":false,"comment_ctime":1573283182,"is_pvip":false,"replies":[{"id":"65938","content":"感觉是没理解正确，对比一下SDK提供的Lock如何创建条件变量，以及条件变量如何使用吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1578488665,"ip_address":"","comment_id":149585,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573283182","product_id":100023901,"comment_content":"第二次看，还是有点问题不理解，文中“Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。”在等待-通知机制代码中，java可以加入多个while(条件){wait();} 这样做判断，算是管程里有多个条件变量吗？ 还是说我没理解正确 在synchronized方法内再次使用条件+wait的方式已经是自己新加的条件变量了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473908,"discussion_content":"感觉是没理解正确，对比一下SDK提供的Lock如何创建条件变量，以及条件变量如何使用吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578488665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147057,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1572780437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572780437","product_id":100023901,"comment_content":"MESA 的那种notify的策略是不是为了提升效率的？感觉提前进入抢对象队列中，执行的效率会高一些。","like_count":0},{"had_liked":false,"id":142541,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1618607,"ip_address":"","ucode":"8179D167D99CB9","user_header":"https://static001.geekbang.org/account/avatar/00/18/b2/af/81303f5a.jpg","comment_is_top":false,"comment_ctime":1571390361,"is_pvip":false,"replies":[{"id":"54992","content":"是","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571402717,"ip_address":"","comment_id":142541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571390361","product_id":100023901,"comment_content":"老师代码演示的阻塞队列是和生产者-消费者模型所用的队列一个道理吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471168,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571402717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141246,"user_name":"邢宇超","can_delete":false,"product_type":"c1","uid":1105246,"ip_address":"","ucode":"3113F55E60ADE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","comment_is_top":false,"comment_ctime":1571132008,"is_pvip":false,"replies":[{"id":"54607","content":"接着上次运行的那一行继续执行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571142386,"ip_address":"","comment_id":141246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571132008","product_id":100023901,"comment_content":"就是线程wait后，下次再到runnable状态的时候，是接着上次运行的那行继续执行的对吧  不是重头开始运行呢对吧  老师  你一定要回答我哈  不然我后面的看不下去了  谢谢您","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470700,"discussion_content":"接着上次运行的那一行继续执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571142386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140899,"user_name":"wecleek","can_delete":false,"product_type":"c1","uid":1072112,"ip_address":"","ucode":"2F187CB43990AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/f0/497ee9a3.jpg","comment_is_top":false,"comment_ctime":1571069342,"is_pvip":false,"replies":[{"id":"54612","content":"可以用jstack看看为什么阻塞，我也不了解unix的实现有什么区别😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571142910,"ip_address":"","comment_id":140899,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571069342","product_id":100023901,"comment_content":"老师，我们项目在使用ibatis的一个老版本时出现一个奇怪的问题，下面的代码运行一段时间后，会有大量的线程阻塞了，但是只有unix系统才有这个问题，linux的系统的没出现过，请问jvm在unix系统和linux的并发实现上有什么不一样吗<br><br><br>public class Throttle<br><br>{<br><br>private final Object LOCK = new Object(); <br><br>private int count; <br><br>private int limit; <br><br>private long maxWait;<br><br>public Throttle(int limit)<br><br>{<br><br>this.limit = limit;<br><br>this.maxWait = 0L;<br><br>}<br><br>public Throttle(int limit, long maxWait)<br><br>{<br><br>this.limit = limit;<br><br>this.maxWait = maxWait;<br><br>}<br><br>public void increment()<br><br>{<br><br>synchronized (this.LOCK) {<br><br>long totalWaitTime = 0L;<br><br>while (this.count &gt;= this.limit) {<br><br>if (this.maxWait &gt; 0L) {<br><br>long waitTime = System.currentTimeMillis();<br><br>try {<br><br>this.LOCK.wait(this.maxWait - totalWaitTime);<br><br>}<br><br>catch (InterruptedException e) {}<br><br>totalWaitTime += System.currentTimeMillis() - waitTime;<br><br>if (totalWaitTime &gt; this.maxWait) {<br><br>throw new RuntimeException(&quot;Throttle waited too long (&quot; + totalWaitTime + &quot; milliseconds) for lock.&quot;);<br><br>}<br><br>} else {<br><br>try {<br><br>this.LOCK.wait();<br><br>}<br><br>catch (InterruptedException e) {}<br><br>}<br><br>}<br><br>this.count += 1;<br><br>}<br><br>}<br><br>public void decrement()<br><br>{<br><br>synchronized (this.LOCK) {<br><br>this.count -= 1;<br><br>this.LOCK.notify();<br><br>}<br><br>}<br><br>}<br><br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470615,"discussion_content":"可以用jstack看看为什么阻塞，我也不了解unix的实现有什么区别😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571142910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072112,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/f0/497ee9a3.jpg","nickname":"wecleek","note":"","ucode":"2F187CB43990AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34062,"discussion_content":"jstack看了，几乎所有线程都lock.wait()阻塞了。我记得unix的用户线程和系统轻量进程的是n:m的，而linux是1:1的，不知道是否和这个有关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571155052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136089,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1618607,"ip_address":"","ucode":"8179D167D99CB9","user_header":"https://static001.geekbang.org/account/avatar/00/18/b2/af/81303f5a.jpg","comment_is_top":false,"comment_ctime":1569342336,"is_pvip":false,"replies":[{"id":"53606","content":"不会立即执行，但是会进去就绪队列，如果没有超时，如果代码写的有bug，可能没有机会进入就绪队列，这样问题就比较大了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570580613,"ip_address":"","comment_id":136089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569342336","product_id":100023901,"comment_content":"对于思考题：mesa模型中，调用wait会使线程进入等待队列，下一次唤醒只是重新进入就绪队列，此时是否有机会被执行依赖于调度算法，有可能造成饥饿，所以需要设置超时，但是我有一个疑问，这个超时计时结束是会被立即执行吗？如果是进入就绪队列，那岂不是一样有可能造成饥饿？请老师解答一下！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468453,"discussion_content":"不会立即执行，但是会进去就绪队列，如果没有超时，如果代码写的有bug，可能没有机会进入就绪队列，这样问题就比较大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570580613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134578,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568870591,"is_pvip":true,"replies":[{"id":"51655","content":"java管程不能跨进程使用,不知道你说的资源级别是什么概念😂，传统意义上的监控很少会监控线程级别，代价太大","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1568896600,"ip_address":"","comment_id":134578,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568870591","product_id":100023901,"comment_content":"虽然理解了这节课的思想，队列实现公平，条件+while解决通知等待的问题，但是还需要一些实践才可以理解真正的实现吧。至于wait需不需要超时参数，我觉得是必要的的，wait状态的线程本就是在浪费系统资源，因为不同线程的切换会有不小的代价(线程上下文，内核区域甚至是辅存再次寻址)，所以在等待的代价低于切换线程的时候，等待就是最优解，不然切换以让出CPU资源给别的线程就是最优解。也就是一切都是为了更充分利用CPU吧了。最后有个问题想请教老师，管程这里的资源级别应该是线程吧，线程是程序执行的最小单位，再细粒度的监控是不是会带来更大的维护难度和代价？个人猜测的，如有不对的请老师指正。<br>真是一门很好的课程，解决了好多不知道的疑问。感谢老师的辛苦付出","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467814,"discussion_content":"java管程不能跨进程使用,不知道你说的资源级别是什么概念😂，传统意义上的监控很少会监控线程级别，代价太大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568896600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1233193,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","nickname":"DFighting","note":"","ucode":"F3BA2426FF8582","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16560,"discussion_content":"老师，那在一个进程中的管程是如何实现锁机制的呢？我理解的管程是有两个队列，然后线程需要请求共享资源，按照不同的时机进入两个队列，管程类似一个controller，负责分配资源的机会。这么说的话管程监控的不是这个进程里的线程资源吗？个儿理解，有偏差欢迎指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568900364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130624,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1567496329,"is_pvip":false,"replies":[{"id":"48832","content":"我觉得aqs更底层一些","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567500086,"ip_address":"","comment_id":130624,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567496329","product_id":100023901,"comment_content":"我觉得JUC里面的AQS是按照MESA管程来实现的，王老师，是这样吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466035,"discussion_content":"我觉得aqs更底层一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567500086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126807,"user_name":"菜鸟和谐号","can_delete":false,"product_type":"c1","uid":1632108,"ip_address":"","ucode":"649BD61DC406C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/6c/aa73b7a7.jpg","comment_is_top":false,"comment_ctime":1566481810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566481810","product_id":100023901,"comment_content":"看了一遍没看懂，看了下评论不是我的理解能力有问题，写的抽象","like_count":0},{"had_liked":false,"id":125555,"user_name":"启炜","can_delete":false,"product_type":"c1","uid":1606147,"ip_address":"","ucode":"0C3DAE062F8D56","user_header":"https://static001.geekbang.org/account/avatar/00/18/82/03/adfccf66.jpg","comment_is_top":false,"comment_ctime":1566203048,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566203048","product_id":100023901,"comment_content":"老师，我觉得notify()如何使用那里不是很明白，如果【出队的操作】顺便唤醒一个【出队的线程】，由于循环唤醒，可以只用notify()，但是【出队的操作】分明唤醒的是【入队的线程】，如果只唤醒一个，【入队的操作】是不会唤醒【入队的线程】的，后续又没有【出队的操作】，那么在【队列不满的条件队列】等待的其它线程不就被饿死了？","like_count":0},{"had_liked":false,"id":121634,"user_name":"绅士","can_delete":false,"product_type":"c1","uid":1583859,"ip_address":"","ucode":"5B58E5A958F489","user_header":"https://static001.geekbang.org/account/avatar/00/18/2a/f3/b9607a15.jpg","comment_is_top":false,"comment_ctime":1565172120,"is_pvip":false,"replies":[{"id":"53798","content":"条件变量是一个实实在在的变量，不是某种情况","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570670246,"ip_address":"","comment_id":121634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565172120","product_id":100023901,"comment_content":"    这里的队列是阻塞队列的意思，顺便简单温习下阻塞队列(拿经典的例子生产者和消费来说)：<br>    比如生产者每生产一个产品就放到一个仓库中，消费者去这个仓库消费这个产品，对应到java中就是，<br>    产品属于共享数据，仓库属于队列。当仓库（队列）满了，就会让生产者先停止生产，就是让线程先阻塞，<br>    当消费者消费一个产品后，仓库（队列）不满了，就会唤醒一个线程（生产者）去生产产品；同理，当消费者太多<br>    出现供不应求，就是仓库的产品被消费完了，就会让线程（消费者）阻塞，直到仓库（队列）中有产品为止，再重新唤醒<br>    消费者线程去消费<br>    对文中管程例子的理解：条件变量a，条件变量b是不是就可以理解为仓库没有产品，不能消费，仓库满了不能生产的情况<br>    如果理解的不对，希望指正，同时也希望老师能看到这条评论，进而给出指导，看不到也没关系，谁让我打卡太晚了呢。。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461886,"discussion_content":"条件变量是一个实实在在的变量，不是某种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570670246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117369,"user_name":"方凌霄","can_delete":false,"product_type":"c1","uid":1323313,"ip_address":"","ucode":"F31A662F0451D8","user_header":"https://static001.geekbang.org/account/avatar/00/14/31/31/cab0d6e5.jpg","comment_is_top":false,"comment_ctime":1564035295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564035295","product_id":100023901,"comment_content":"老师提个小小的建议，感觉如果举例生产者消费者模式更容易理解，当队列没有数据（为空）的情况下，消费者自动挂起阻塞，直到队列有数据！（类似于条件变量：队列不空）当队列数据满的情况下，生产者会被阻塞（类似于 条件变量：队列不满）老师这个案例是不是就是模拟阻塞队列BlockingQueue。我可以这样理解么","like_count":0},{"had_liked":false,"id":115250,"user_name":"unanao","can_delete":false,"product_type":"c1","uid":1510485,"ip_address":"","ucode":"8F81ECF05D420C","user_header":"http://thirdwx.qlogo.cn/mmopen/ajNVdqHZLLAZUMxZDXiaVdiaEq6wK8XMBBXiaA6icoQykatgybzeqicLUv3420cCPqONmTwTZBydJG5V1TiamIyeiaTxw/132","comment_is_top":false,"comment_ctime":1563518318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563518318","product_id":100023901,"comment_content":"BlockingQueue的代码示例中:<br>入队操作时，只有之前是空队列，才进行notEmpty.signal.","like_count":0},{"had_liked":false,"id":113675,"user_name":"赵小洛","can_delete":false,"product_type":"c1","uid":1592232,"ip_address":"","ucode":"A326C12B1A1ABA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/a8/14b8a860.jpg","comment_is_top":false,"comment_ctime":1563114017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563114017","product_id":100023901,"comment_content":"加时间  为的是有机会 让调用wait方法的线程 能够有机会重新运行。hasen 是执行完，再去唤醒另外一个线程。能够保证线程的执行。hoare，是中断当前线程，唤醒另外一个线程，执行玩再去唤醒，也能够保证完成。而mesa是进入等待队列，不一定有机会能够执行。","like_count":0},{"had_liked":false,"id":108184,"user_name":"dingdongfm","can_delete":false,"product_type":"c1","uid":1564213,"ip_address":"","ucode":"7D17D2BC392A66","user_header":"","comment_is_top":false,"comment_ctime":1561691821,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1561691821","product_id":100023901,"comment_content":"为什么 Object.wait() 方法一定要在 synchronized内使用？<br>或者说<br>为什么拿到锁才能调用wait，notify等方法呢？<br><br><br><br>","like_count":0,"discussions":[{"author":{"id":1468298,"avatar":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","nickname":"锦","note":"","ucode":"CB0EB4B68C468B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88640,"discussion_content":"因为wait和notify是操作synchronized上的条件变量的啊。不拿到锁怎么能操作呢？\n我的问题是这个条件变量怎么使用呢？一个条件变量怎么实现多线程之间的同步呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576722315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107895,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1561630916,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1561630916","product_id":100023901,"comment_content":"我学习这篇文章后的理解是，hasen 的策略是优先执行持有资源的操作，hoare优先执行被阻塞的操作，mesa有机会两个都同时执行，但也有可能被阻塞的不被执行","like_count":0},{"had_liked":false,"id":103349,"user_name":"Alvan","can_delete":false,"product_type":"c1","uid":1002468,"ip_address":"","ucode":"D6529DC67898BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/e4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1560418090,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1560418090","product_id":100023901,"comment_content":"有些书说当通知线程调用了notify()方法后，被唤醒的线程去竞争对象锁不成功的时候才会进入入口等待队列，这里说的却是线程被唤醒了就直接移到了入口等待队列，两种不同的说法让我有点糊涂了","like_count":0},{"had_liked":false,"id":99772,"user_name":"Ace","can_delete":false,"product_type":"c1","uid":1119014,"ip_address":"","ucode":"CBC5C5EED89708","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/26/ea36255d.jpg","comment_is_top":false,"comment_ctime":1559296132,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559296132","product_id":100023901,"comment_content":"个人理解Java中的管程实现可分为两种：synchronized+wait&#47;notify&#47;notifyAll 和 Lock+await&#47;signal&#47;signalAll，二者实现也是类似的，只是前者在语法层面，而后者是API层面。<br>PS: 之前看过AQS和ArrayBlockingQueue的代码，对主队列和条件队列不是很理解，原来是MESA模型！感谢老师！","like_count":0},{"had_liked":false,"id":98979,"user_name":"“B仔！","can_delete":false,"product_type":"c1","uid":1126560,"ip_address":"","ucode":"208BB8A051C879","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/a0/09ec0f21.jpg","comment_is_top":false,"comment_ctime":1559123229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559123229","product_id":100023901,"comment_content":"老师这个模型结合生产者和消费者来讲解会更好理解些。一开始看模型的时候很蒙，还以为是代码内置了什么模型呢。看了两遍才触摸到重点。","like_count":0},{"had_liked":false,"id":95007,"user_name":"渡码","can_delete":false,"product_type":"c1","uid":1348536,"ip_address":"","ucode":"8FD8B863D1DA0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/93/b8/6510592e.jpg","comment_is_top":false,"comment_ctime":1557937267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557937267","product_id":100023901,"comment_content":"mesa是从入口队列从新开始所以超时后也能保证只有一个线程进管程内部，但另两种模式不是从头开始可能出现多个线程在管程内","like_count":0},{"had_liked":false,"id":93745,"user_name":"HelloBoy","can_delete":false,"product_type":"c1","uid":1007102,"ip_address":"","ucode":"A25F49A4422283","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/fe/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1557578147,"is_pvip":true,"replies":[{"id":"33806","content":"wait后，其他线程可以进去","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557844076,"ip_address":"","comment_id":93745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557578147","product_id":100023901,"comment_content":"老师，实际情况只有一个线程从入口进入，不会有其他线程进入的话。这个线程不就一直不能被执行了，一直wait()，即便超时也会在进入while等待？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449756,"discussion_content":"wait后，其他线程可以进去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557844076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91194,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1556900779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556900779","product_id":100023901,"comment_content":"课后习题思考：<br>mesa 模型不同于另外两种模型，另外两种模型，线程被唤醒后一定能成功执行。而 mesa 模型，线程被唤醒后，只说明曾经满足条件，现在不一定满足，并且当只有 notify 而不是 notifyAll，有可能会永远得不到执行的机会。这时如果是 wait 一个时间，主动去探测条件是否成立，增加被执行的机会","like_count":0},{"had_liked":false,"id":90111,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1556417200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556417200","product_id":100023901,"comment_content":"使用while替换if是为了防止虚假唤醒,因为synchronized等待队列跟wait阻塞队列不是同一个,如果notifyAll唤醒了synchronized队列中的一个操作变量,然后if语句中的数据并不符合了,但是此时唤醒wait会继续向下执行,while是运行wait唤醒会再次进行判断条件是否满足,if就不会再次判断而是直接向下运行了","like_count":0},{"had_liked":false,"id":89833,"user_name":"Geek_bbbda3","can_delete":false,"product_type":"c1","uid":1504651,"ip_address":"","ucode":"737394CE472C21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDKOCoZvCqoYVM1t97Q77QPLmRBGvOLYzFsh8073RicycoIuwGrIsCXpAFEyVBOxcyE3Ih1mr6Vw/132","comment_is_top":false,"comment_ctime":1556278184,"is_pvip":false,"replies":[{"id":"32361","content":"建议按照最佳实践来","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556499820,"ip_address":"","comment_id":89833,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556278184","product_id":100023901,"comment_content":"老师：例子中使用signal()通知，是否可以不用while()循环这种方式了，每次只通知一个线程，不存在执行时条件不满足。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448280,"discussion_content":"建议按照最佳实践来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556499820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88956,"user_name":":)","can_delete":false,"product_type":"c1","uid":1239198,"ip_address":"","ucode":"23D505949442B6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/9e/6550a051.jpg","comment_is_top":false,"comment_ctime":1556032140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556032140","product_id":100023901,"comment_content":"锁解决互斥问题，条件变量解决同步问题。如果只需要解决对临界资源的互斥访问，用锁就够了。","like_count":0},{"had_liked":false,"id":88165,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555863621,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555863621","product_id":100023901,"comment_content":"有必要。MESA如果不加超时参数，则只能等待唤醒，针对synchronized关键字，如果是notifyAll还好，可以唤醒对应等待条件的所有线程，如果是notify则可能某个线程一直不能被唤醒(唤醒机制可能是不公平的)。那还不如加个超时时间，隔一段时间从对应的条件等待队列出来，进入到入口等待队列尝试获取锁，获取到之后做条件判断，条件满足则往下执行，不满足则继续等待一段时间","like_count":0},{"had_liked":false,"id":87640,"user_name":"roaming","can_delete":false,"product_type":"c1","uid":1039232,"ip_address":"","ucode":"2736679690AB81","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/80/6b7629d7.jpg","comment_is_top":false,"comment_ctime":1555646488,"is_pvip":false,"replies":[{"id":"31554","content":"对，不过区别不止是这些<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555676872,"ip_address":"","comment_id":87640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555646488","product_id":100023901,"comment_content":"管程模型支持多个条件变量。Java内置方案synchronized仅支持一个条件变量；Java SDK并发包通过Condition支持多个条件变量，这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447542,"discussion_content":"对，不过区别不止是这些\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555676872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85821,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1460415,"ip_address":"","ucode":"04B803AED7C22F","user_header":"https://static001.geekbang.org/account/avatar/00/16/48/bf/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1555247409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555247409","product_id":100023901,"comment_content":"所谓“管程”既就是synchronized。线程在调用obj.wait&#47;notify&#47;notifyAll时都需要先获取obj的锁。当调用obj.wait()后就在条件变量的等待队列上等待，当条件满足另一线程调用obj.notify()后在条件变量队列中的线程就会进入到总得获取obj锁的等待队列中等待获取锁并继续执行（lock的condition同理）","like_count":0},{"had_liked":false,"id":85668,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1555168572,"is_pvip":false,"replies":[{"id":"30815","content":"1. 阻塞队列内部的数组或者链表是共享变量。阻塞队列就是个普通对象，作用域是你自己控制的。<br>2.管程内部的阻塞队列，不同的管程是不同的。<br>3. 加锁释放锁，可能会操作入口等待队列。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555209576,"ip_address":"","comment_id":85668,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555168572","product_id":100023901,"comment_content":"非常棒，解惑了之前困扰问题又衍生了新的问题，请老师解惑哈。<br>1阻塞队列出队和入队操作的元素是共享变量？即队列里是什么，JVM共享一个阻塞队列吗？<br>2管程中的阻塞队列的出队和入队，与线程给锁对象加锁和释放锁的关系","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446760,"discussion_content":"1. 阻塞队列内部的数组或者链表是共享变量。阻塞队列就是个普通对象，作用域是你自己控制的。\n2.管程内部的阻塞队列，不同的管程是不同的。\n3. 加锁释放锁，可能会操作入口等待队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555209576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85479,"user_name":"carter","can_delete":false,"product_type":"c1","uid":1119188,"ip_address":"","ucode":"942851357CB603","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJwicoopV8ZJu8HwyjQ7FthBQpRj6Y8ibrrv0Zn5cx3exqsk0feVZNdwVWUhokCYqcS9YhTgIgG0ZBQ/132","comment_is_top":false,"comment_ctime":1555072678,"is_pvip":false,"replies":[{"id":"30658","content":"语言级别内置的，不是sdk","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555117147,"ip_address":"","comment_id":85479,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555072678","product_id":100023901,"comment_content":"不是说Java内置的管程里面有一个条件变量吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446681,"discussion_content":"语言级别内置的，不是sdk","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555117147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85327,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1555037770,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555037770","product_id":100023901,"comment_content":"管程：就是多线程对一段共享变量 的互斥（锁）和同步（通信和协调）<br>java中内置的管程 就是 synchronized(互斥) 和 wati(),notify(),notityall() (多线程之间的通信与协调)<br>java的sdk Condition(互斥) await()、signal()等（通信与协调，可以具体的指定 条件进行协调与通信）<br>Hasen模型就是 A线程执行完 再去醒B线程执行<br>Hoare模型是 A线程进行中断去叫醒B线程执行，执行完之后再去唤醒。<br>MESA模型其实是 A线程执行完之后 去叫醒B线程 但是不会释放自己拿到的锁资源 需要判断不满足条件之后才会去释放当前锁的资源。至于被叫醒的线程就需要到门口去排队，去抢占自己需要的资源。","like_count":0},{"had_liked":false,"id":84984,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1554952103,"is_pvip":true,"replies":[{"id":"30500","content":"管程里的队列和阻塞队列没关系，只是用管程解决阻塞队列的问题，你可以先了解一下什么是阻塞队列<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554956237,"ip_address":"","comment_id":84984,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554952103","product_id":100023901,"comment_content":"&quot;假设有个线程 T1 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。 如果线程 T1 进入管程后恰好发现队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的等待队列里面等。&quot;为什么发现队列为空,就要等待呢,而不是直接去执行呢?这个队列为空具体指的是入口的队列为空还是变量等待队列为空吗?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446518,"discussion_content":"管程里的队列和阻塞队列没关系，只是用管程解决阻塞队列的问题，你可以先了解一下什么是阻塞队列\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554956237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84982,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1554951817,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1554951817","product_id":100023901,"comment_content":"队列不空,队列不满,又想通过就医故事讲明白,又说了一堆逻辑,不知道在说什么...","like_count":0,"discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5733,"discussion_content":"这就是你自己理解能力的问题了，我们很多人看一遍都能理解，老师讲的很好的。！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566454967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83620,"user_name":"Geek_53bccf","can_delete":false,"product_type":"c1","uid":1481179,"ip_address":"","ucode":"1818C97E5D1CCC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/UfqEYrR3cQXUhPEibnXD3kPSc8f0ibR4bdz6JnibjOBibfcxWrkVlz4iaCAAutOSotiaP2ROYX5esYfhAB3vj4avnYqQ/132","comment_is_top":false,"comment_ctime":1554686036,"is_pvip":true,"replies":[{"id":"30264","content":"对，但是调用是不是交叉，一般都不是程序能控制的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554702930,"ip_address":"","comment_id":83620,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1554686036","product_id":100023901,"comment_content":"老师 我有一个疑问 就是 如果系统只有两个线程为t1和t2线程分别执行出队操作 ，那这两个线程都在等待队列里等待 那是不是永远等待下去啦 那程序不是死了吗 所以加个超时时间，避免一定程度出现上面的问题。如果想系统绝不可能发生上面的情况，那出队列和入队列,必须让t1和t2两个线程分别属于两个线程池并且分别调用不交叉，这样就可以永远避免程序死等待的问题 ，老师你觉得我说得对吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446099,"discussion_content":"对，但是调用是不是交叉，一般都不是程序能控制的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554702930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82394,"user_name":"虎爷","can_delete":false,"product_type":"c1","uid":1024907,"ip_address":"","ucode":"42E8339F183055","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8b/e7389cf5.jpg","comment_is_top":false,"comment_ctime":1554200397,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554200397","product_id":100023901,"comment_content":"我再回复一次，我发现和我别人想的差不多。","like_count":0},{"had_liked":false,"id":82393,"user_name":"虎爷","can_delete":false,"product_type":"c1","uid":1024907,"ip_address":"","ucode":"42E8339F183055","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8b/e7389cf5.jpg","comment_is_top":false,"comment_ctime":1554200350,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554200350","product_id":100023901,"comment_content":"我觉得，加入超时时间选项，应该是为了让线程在wait的时候发生如下情况，避免死等的情况。<br>1：notify的时候，一直都没有notify到这个线程；<br>2：条件变量，就没满足过，或者满足了，被别的线程抢去了。<br>不知道对不对。我去看看别人怎么想的。","like_count":0},{"had_liked":false,"id":82043,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1554109279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554109279","product_id":100023901,"comment_content":"我觉得真正开发的话，用等待时间这种方式解决竞争大造成的长等待有种不太严谨的直觉，到底多少合适呢？因为等待队列线程唤醒仍然要竞争锁，如果竞争足够大的话，我觉得应该调整设计了比如并发量。","like_count":0},{"had_liked":false,"id":81321,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1553860511,"is_pvip":false,"replies":[{"id":"29487","content":"没有其他线程调用notify()的情况下，没有权利管程入口等待队列中。这个线程就会死等下去，再也没有机会执行了。<br>所有模型没有notify，都会死等下去","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553906160,"ip_address":"","comment_id":81321,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553860511","product_id":100023901,"comment_content":"没有实际并发开发经验，单从文中介绍的模型去分析，如果只启动了一个线程，并且进入wait()状态，那么在没有其他线程调用notify()的情况下，该线程会被执行吗？是不是在没有notify()的情况下，条件变量的等待队列中的线程也会依次进入管程入口等待队列中？？？不然没有wait超时时间，HasenHoare模型中的最后一个进入wait()的线程会永久wait()？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445152,"discussion_content":"没有其他线程调用notify()的情况下，没有权利管程入口等待队列中。这个线程就会死等下去，再也没有机会执行了。\n所有模型没有notify，都会死等下去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553906160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80504,"user_name":"右耳听海","can_delete":false,"product_type":"c1","uid":1022011,"ip_address":"","ucode":"E0B9F1083F4F98","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/3b/5af90c80.jpg","comment_is_top":false,"comment_ctime":1553671560,"is_pvip":false,"replies":[{"id":"29296","content":"你可以对此一下sdk里面的阻塞队列和文中例子差异有多大，文中的例子本来就是实践抽象出来的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553687349,"ip_address":"","comment_id":80504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553671560","product_id":100023901,"comment_content":"原理和实践脱离，能不能结合java的商业产品比如阻塞队列讲讲java在运用管程思想实现阻塞队列的具体例子","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444884,"discussion_content":"你可以对此一下sdk里面的阻塞队列和文中例子差异有多大，文中的例子本来就是实践抽象出来的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553687349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80417,"user_name":"隋科磊","can_delete":false,"product_type":"c1","uid":1023073,"ip_address":"","ucode":"7ACA2E9B979846","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/61/947a3a45.jpg","comment_is_top":false,"comment_ctime":1553658370,"is_pvip":true,"replies":[{"id":"29308","content":"后面介绍线程部门有","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553694666,"ip_address":"","comment_id":80417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553658370","product_id":100023901,"comment_content":"请问，线程被notify后，线程 除了 从 条件变量的等待队列 移动到 入口等待队列，线程状态有没有发生变化? 下面情况的哪一种？<br>1. 从BLOCKED 会变成 RUNNABLE，如果调用notify的线程，没执行完，没释放锁，所以，被notify的线程又变成BLOCKED了<br>2. 一直保持BLOCKED不动<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444855,"discussion_content":"后面介绍线程部门有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553694666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79770,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1553555738,"is_pvip":false,"replies":[{"id":"29310","content":"不是，一把锁能有多个条件变量，后面介绍并发包回讲<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553694903,"ip_address":"","comment_id":79770,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553555738","product_id":100023901,"comment_content":"Synchronized只能有一个条件变量，是不是它只能有一把锁的原因。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444615,"discussion_content":"不是，一把锁能有多个条件变量，后面介绍并发包回讲\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553694903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79228,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1553409486,"is_pvip":false,"replies":[{"id":"28913","content":"不是，lock,condition底层调用park实现","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553418341,"ip_address":"","comment_id":79228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553409486","product_id":100023901,"comment_content":"老师，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，这个也是基于管程实现的么？和wait的区别是wait阻塞时会在对象的管程队列里排队，\b等待通知，park只是阻塞单个线程？老师能帮忙解答下么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444407,"discussion_content":"不是，lock,condition底层调用park实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553418341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78882,"user_name":"Hour","can_delete":false,"product_type":"c1","uid":1448748,"ip_address":"","ucode":"AA1045ACABC0BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","comment_is_top":false,"comment_ctime":1553267942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553267942","product_id":100023901,"comment_content":"对这一节的内容深有感触，看了差不多5遍，每次都能领会多一点，多谢老师！<br><br>不过对于wait加参这个问题，我说下我的体会吧，加参可以防止线程一直阻塞，但也有不加参的场景：<br><br>比如针对non-web应用，要保证服务一直启着，既服务起来后要hold住，看下如何实现：<br><br>Class ServerLauncher{<br>       <br>       static void main() {<br><br>         do something 比如启动spring容器<br><br>         &#47;&#47;通过无参wait来hold住服务<br>         synchronize (ServerLauncher.class){<br>               while(true){<br>                      ServerLauncher.class.wait();<br>                }<br>         }<br><br>         }<br><br>}","like_count":0},{"had_liked":false,"id":78354,"user_name":"JGOS","can_delete":false,"product_type":"c1","uid":1237592,"ip_address":"","ucode":"46A905A169408F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/58/2468a5e9.jpg","comment_is_top":false,"comment_ctime":1553132993,"is_pvip":false,"replies":[{"id":"28566","content":"和这俩队列没关系，只是个应用管程的例子而已<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553166865,"ip_address":"","comment_id":78354,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553132993","product_id":100023901,"comment_content":"老师,讲到管程MESA模型,假设有个线程 T1 执行出队操作,T2执行入队操作,这个队列具体指的是哪个队列,是入口等待队列,还是条件变量对应的队列啊? ","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444062,"discussion_content":"和这俩队列没关系，只是个应用管程的例子而已\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553166865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78254,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1553106015,"is_pvip":true,"replies":[{"id":"28685","content":"管程的实现方做的，和你的代码没关系。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553268896,"ip_address":"","comment_id":78254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553106015","product_id":100023901,"comment_content":"请问老师   “假设线程1 wait在lock上 进入该lock的等待队列  线程2执行notify唤醒线程1  线程1从等待队列中移除”  <br>这个过程中线程1进入队列及从中移除是怎么实现的？   <br>是线程1调用wait之后执行代码把自己加到队列中 线程2调用notify后执行代码把线程1从队列中移除；   还是说会有一个其他的调度线程在执行这些操作？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444021,"discussion_content":"管程的实现方做的，和你的代码没关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553268896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77936,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1553043720,"is_pvip":false,"replies":[{"id":"28488","content":"队列只是方法之一<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553083278,"ip_address":"","comment_id":77936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553043720","product_id":100023901,"comment_content":"是不是 管程 解决并发问题 采用的 是 队列 这个数据结构 ？或者所有解决并发问题的技术都是通过队列这个数据结构？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443904,"discussion_content":"队列只是方法之一\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553083278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77934,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1553043648,"is_pvip":false,"replies":[{"id":"28489","content":"等待队列不空才能出的来","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553083387,"ip_address":"","comment_id":77934,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1553043648","product_id":100023901,"comment_content":"不明白为什么 出队 要满足 队列不空这个条件变量 ？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443903,"discussion_content":"等待队列不空才能出的来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553083387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379713,"discussion_content":"医生都不在，你去了也没用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624090137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77918,"user_name":"次郎","can_delete":false,"product_type":"c1","uid":1134620,"ip_address":"","ucode":"446499E130A66A","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/1c/26dc1927.jpg","comment_is_top":false,"comment_ctime":1553041643,"is_pvip":false,"replies":[{"id":"28491","content":"随便找本操作系统的教材都会有，比如操作系统精髓与设计原理","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553083764,"ip_address":"","comment_id":77918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553041643","product_id":100023901,"comment_content":"老师，信号量相关的，能推荐一些资料么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443895,"discussion_content":"随便找本操作系统的教材都会有，比如操作系统精髓与设计原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553083764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77684,"user_name":"seele","can_delete":false,"product_type":"c1","uid":1224708,"ip_address":"","ucode":"1824AA95FF1DF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZpzZqvib4bzgfFb6Wt7fP2k4wefKYaoPwza1L19UGalddjREELPd6zAjyibdHJ7jxB2xtZmSuJjuA/132","comment_is_top":false,"comment_ctime":1552981542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552981542","product_id":100023901,"comment_content":"按照一个哥们的推荐去看了看ArrayBlockingQueue 发现明白了老师要讲的意思了。<br>要补补ReentrantLock 还有 Condition 的知识点了","like_count":0},{"had_liked":false,"id":77588,"user_name":"youngitachi","can_delete":false,"product_type":"c1","uid":1214582,"ip_address":"","ucode":"88717CA8B8ED64","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","comment_is_top":false,"comment_ctime":1552966279,"is_pvip":true,"replies":[{"id":"28449","content":"这个等介绍并发包里锁你就能明白了，解锁不会调用notify<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553042615,"ip_address":"","comment_id":77588,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552966279","product_id":100023901,"comment_content":"老师好，想问一下synchronized是怎么实现管程的呢？<br>如果synchronized锁的对象就对应着管程的共享变量，那么管程的条件变量又是对应着什么呢？<br>是只有一个synchronized锁的对象是否被加锁？被加锁就进入条件队列，monitorexit执行的时候就会解锁并调用signal吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443790,"discussion_content":"这个等介绍并发包里锁你就能明白了，解锁不会调用notify\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553042615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77510,"user_name":"果然如此","can_delete":false,"product_type":"c1","uid":1210003,"ip_address":"","ucode":"C7543BD0A67505","user_header":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","comment_is_top":false,"comment_ctime":1552957980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552957980","product_id":100023901,"comment_content":"管程看了两遍，还是找不到逻辑！我还需要多加修炼！<br>不过以前做的网页抓取程序经常用这个模型等待页面加载线程执行完毕，主线程再做其他操作：<br>while(条件不满足) {<br>  wait(时间);<br>}","like_count":0},{"had_liked":false,"id":77495,"user_name":"Paul","can_delete":false,"product_type":"c1","uid":1445466,"ip_address":"","ucode":"85653228A7AF5E","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/5a/617f28bf.jpg","comment_is_top":false,"comment_ctime":1552956782,"is_pvip":false,"replies":[{"id":"28295","content":"会限制线程池大小，不是限制它","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552958730,"ip_address":"","comment_id":77495,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1552956782","product_id":100023901,"comment_content":"生产环境需要设置等待队列大小吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443748,"discussion_content":"会限制线程池大小，不是限制它","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552958730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77291,"user_name":"吕","can_delete":false,"product_type":"c1","uid":1210890,"ip_address":"","ucode":"8F08E2CB81C4C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/7a/0a/0ce5c232.jpg","comment_is_top":false,"comment_ctime":1552902527,"is_pvip":false,"replies":[{"id":"28190","content":"不好意思，排版和{}有点问题。已经改过来了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552916830,"ip_address":"","comment_id":77291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552902527","product_id":100023901,"comment_content":"对于文章的BlockedQueue不太明白，while判断中，只能在while循环里边才能进行入队和出队的操作么？如果队列不满，就不能入队了么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443675,"discussion_content":"不好意思，排版和{}有点问题。已经改过来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552916830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77163,"user_name":"boyxie","can_delete":false,"product_type":"c1","uid":1018342,"ip_address":"","ucode":"FD55E5C569AC58","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/e6/ab403ccb.jpg","comment_is_top":false,"comment_ctime":1552873717,"is_pvip":false,"replies":[{"id":"28187","content":"我也这么想的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552916786,"ip_address":"","comment_id":77163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552873717","product_id":100023901,"comment_content":"关于思考题超时，这三个模型都是判断条件然后再执行，不同的是前两个都是马上执行，而MESA模型唤醒后是进入等待队列，如果队列为空，那跟前两个一样，如果不为空，则要考虑是否会等待过长时间，这样看更多的是考虑是给业务代码多一种选择吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443612,"discussion_content":"我也这么想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552916786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77149,"user_name":"鲁班大师","can_delete":false,"product_type":"c1","uid":1179156,"ip_address":"","ucode":"4F9615DF87B031","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg","comment_is_top":false,"comment_ctime":1552871600,"is_pvip":false,"replies":[{"id":"28127","content":"你的机器也创建不出100万个线程来，所以这个队列不用限制大小","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552880171,"ip_address":"","comment_id":77149,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552871600","product_id":100023901,"comment_content":"管程等待队列的容量多大了？还是内存的上限？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443606,"discussion_content":"你的机器也创建不出100万个线程来，所以这个队列不用限制大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552880171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77137,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1552868022,"is_pvip":false,"replies":[{"id":"28124","content":"不仅仅是这些","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552879847,"ip_address":"","comment_id":77137,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552868022","product_id":100023901,"comment_content":"这管程映射成字节码是不是就是monitorenter&#47;monitorexit？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443599,"discussion_content":"不仅仅是这些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552879847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77054,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1552818206,"is_pvip":false,"replies":[{"id":"28096","content":"1. 如果队列满了之后，又有5个线程尝试入队，这个时候这个5个线程都会阻塞；当有一个出队操作，会唤醒5个中的1个，这个是没问题的，因为即便都唤醒，也只有一个线程入队成功，其余四个还是要阻塞。当再有一个出队的时候，会再次唤醒一个。所以这里没有必要使用notifyall，当然使用notifyall也不错，仅仅是性能慢。<br><br>2. Java 并发包里有await()、也有await(long time, TimeUnit unit)，时间参数不是mesa模型内部自己加上去。是调用的时候自己指定的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552831997,"ip_address":"","comment_id":77054,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552818206","product_id":100023901,"comment_content":"老师， 看了下代码后，我自己脑补了一下入队的流程  ，有一点点疑惑希望老师指点一下 。<br><br>1.  （队列满的）线程1入队，先用 lock 锁住资源， 判断队列满，则线程1进入等待队列<br>2.   await() 操作会释放锁资源，允许其他线程进入，  此时线程2入队操作获得锁资源， 发现对列是满的，则线程2进入等待队列 <br>3.   此时线程3获得锁资源执行出队操作 ， 这时候用 signal() 操作 。<br><br>疑问 ： <br><br>1. 这时候等待队列里已经有两个线程等待了 ， signal()  == notify() 只能唤醒一个线程是不是不太好 .. <br>2. while（）里面调用 wait() , 相当于 使用了await() 方法， 但是我们并没有加时间参数， 老师末尾说的时间参数，是mesa模型内部自己加上去的么 ？？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443564,"discussion_content":"1. 如果队列满了之后，又有5个线程尝试入队，这个时候这个5个线程都会阻塞；当有一个出队操作，会唤醒5个中的1个，这个是没问题的，因为即便都唤醒，也只有一个线程入队成功，其余四个还是要阻塞。当再有一个出队的时候，会再次唤醒一个。所以这里没有必要使用notifyall，当然使用notifyall也不错，仅仅是性能慢。\n\n2. Java 并发包里有await()、也有await(long time, TimeUnit unit)，时间参数不是mesa模型内部自己加上去。是调用的时候自己指定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552831997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76972,"user_name":"钱不购","can_delete":false,"product_type":"c1","uid":1446539,"ip_address":"","ucode":"D88F66BFC22C6B","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/8b/b4cda563.jpg","comment_is_top":false,"comment_ctime":1552790536,"is_pvip":false,"replies":[{"id":"28082","content":"指的是BlockedQueue，不是管程里的等待队列","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552805671,"ip_address":"","comment_id":76972,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552790536","product_id":100023901,"comment_content":"老师，出队入队，具体是那个队列，没看明白，文中说有两个队列","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443522,"discussion_content":"指的是BlockedQueue，不是管程里的等待队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552805671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76907,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1552746528,"is_pvip":true,"replies":[{"id":"28077","content":"有的医院是化验回来，还要重新排队的，比如儿研所","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552791595,"ip_address":"","comment_id":76907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552746528","product_id":100023901,"comment_content":"根排队就医类似，如果一直排队都还轮不到自己，肯定不能永久的等下去的，一个是只能等并且什么也干不了（占用资源），另一个是耽误病情（真正需要执行的代码或者运行的功能没有被执行）。另外感觉排队就医对于mesa模型有点不准确，每次医生看完当前的患者，都是随便抽取一个排队中的患者来就诊的。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443496,"discussion_content":"有的医院是化验回来，还要重新排队的，比如儿研所","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76853,"user_name":"哲民","can_delete":false,"product_type":"c1","uid":1031059,"ip_address":"","ucode":"CADC8EAB0B641A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfkFogCZmVEmm2qRQR6j48TIzicEd4daaRcU4YgibORiaBSYaEPnW8Ke4KibpsU0MsaISZ6UAM1uTbmA/132","comment_is_top":false,"comment_ctime":1552728528,"is_pvip":false,"replies":[{"id":"28078","content":"你可以看看并发包里AQS","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552791714,"ip_address":"","comment_id":76853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552728528","product_id":100023901,"comment_content":"文中说：enq()、deq() 保证互斥性，只允许一个线程进入管程。<br><br>请问互斥性具体怎么保证呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443472,"discussion_content":"你可以看看并发包里AQS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76847,"user_name":"iron_man","can_delete":false,"product_type":"c1","uid":1099883,"ip_address":"","ucode":"C0053A59442910","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/6b/0f3876ef.jpg","comment_is_top":false,"comment_ctime":1552727738,"is_pvip":false,"replies":[{"id":"28072","content":"1. 内置的管程 synchronized 锁定的是什么，就会相应有一套条件变量和等待队列<br>2. 是这样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552791025,"ip_address":"","comment_id":76847,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552727738","product_id":100023901,"comment_content":"管程中的条件变量和等待队列，和锁的作用域是一样的。那对java而言，内置的管程 synchronized 锁定的是什么，就会相应有一套条件变量和等待队列？<br>然后如果mesa模型的通知，仅仅把等待队列中的线程放到入口队列中，那后续线程的执行还是依赖于java虚拟机的线程调度了，其实没有任何主动去唤醒等待线程的动作了。我的理解对吗，老师","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443469,"discussion_content":"1. 内置的管程 synchronized 锁定的是什么，就会相应有一套条件变量和等待队列\n2. 是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552791025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76828,"user_name":"aksonic","can_delete":false,"product_type":"c1","uid":1003633,"ip_address":"","ucode":"B6F3348F6714DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/71/e8229703.jpg","comment_is_top":false,"comment_ctime":1552721647,"is_pvip":false,"replies":[{"id":"28016","content":"用while是为了防止虚假唤醒问题。wait()如果不加超时参数，触发被notify，否则不会被唤醒","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552728968,"ip_address":"","comment_id":76828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552721647","product_id":100023901,"comment_content":"老师，我记得wait外层为什么一定要用循环而不用if是为了防止虚假唤醒问题，否则线程自己是有可能自己醒过来的。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443460,"discussion_content":"用while是为了防止虚假唤醒问题。wait()如果不加超时参数，触发被notify，否则不会被唤醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552728968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76819,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1552719455,"is_pvip":false,"replies":[{"id":"28020","content":"实现hoare模型的编程语言，我没用过......","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552729301,"ip_address":"","comment_id":76819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552719455","product_id":100023901,"comment_content":"那就是说，hoare模型里的notify()之后的代码，编译会报unreachable ?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443457,"discussion_content":"实现hoare模型的编程语言，我没用过......","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552729301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76796,"user_name":"轻歌赋","can_delete":false,"product_type":"c1","uid":1251574,"ip_address":"","ucode":"22F62446208805","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg","comment_is_top":false,"comment_ctime":1552711317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552711317","product_id":100023901,"comment_content":"前两种不需要的原因是唤醒了一定会执行，但是此时条件可能不满足，却执行了。<br><br>因此不能超时唤醒。<br><br>最后一种唤醒后会进入入口队列，然后继续在循环里面判断条件。<br><br>因此不满足仍然不满足，会wait，不会出现bug","like_count":0},{"had_liked":false,"id":76795,"user_name":"海鸿","can_delete":false,"product_type":"c1","uid":1104275,"ip_address":"","ucode":"7074EF94EA70AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/93/098e5ef5.jpg","comment_is_top":false,"comment_ctime":1552710937,"is_pvip":false,"replies":[{"id":"28027","content":"原因是：线程从入口等待队列中被唤醒之后，有可能依赖的条件并不满足了。你结合《06 | 用“等待-通知”机制优化循环等待》里notifyall的例子重新再想想。<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552730444,"ip_address":"","comment_id":76795,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552710937","product_id":100023901,"comment_content":"MESA 管程特有的编程范式，在while循环中调用wait方法，还是搞不懂，调用wait方法后线程就进入某条件变量的等待队列，等待同步信号或超时来唤醒从而进入锁等待队列，这样理解有问题吗?<br>如果是这样的话，调用wait之后就应该不会再进入while条件判断了吧?<br>难道这样写的缘故是调用wait方法是不一定让线程进入等待状态?","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443449,"discussion_content":"原因是：线程从入口等待队列中被唤醒之后，有可能依赖的条件并不满足了。你结合《06 | 用“等待-通知”机制优化循环等待》里notifyall的例子重新再想想。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552730444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76785,"user_name":"好牙","can_delete":false,"product_type":"c1","uid":1117320,"ip_address":"","ucode":"F36A824C1AB19A","user_header":"","comment_is_top":false,"comment_ctime":1552708149,"is_pvip":false,"replies":[{"id":"28022","content":"1. 是否公平要看实现，Java并发包里的Lock支持公平锁<br>2. notify会把条件变量等待队列里的线程送到入口等待队列。你说的问题，可以仔细想想while(条件不满足) 这个。然后再重新看一看之前有个notifyall的介绍，在 06 | 用“等待-通知”机制优化循环等待 这一章里。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552729637,"ip_address":"","comment_id":76785,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552708149","product_id":100023901,"comment_content":"老师您好，今天第一次听到管程的概念，获益匪浅。有两个问题请指点一下:<br>1.管程入口是一个队列，则永远是先入队的线程先拿到锁，那么非公平锁又是怎么实现的呢？<br>2.还是这个队列，是否notify是通知队列出队一次，如果是这样的话，为什么会存在有线程永远无法获取到锁呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443445,"discussion_content":"1. 是否公平要看实现，Java并发包里的Lock支持公平锁\n2. notify会把条件变量等待队列里的线程送到入口等待队列。你说的问题，可以仔细想想while(条件不满足) 这个。然后再重新看一看之前有个notifyall的介绍，在 06 | 用“等待-通知”机制优化循环等待 这一章里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552729637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76770,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1552704718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552704718","product_id":100023901,"comment_content":"思考题：首先，这里的notify()带参数，这应该说的是指操作系统的管程，在java中我没有找到。那这种带超时机制的notify在mesa模型中有必要，原因有两点:<br>1.由于是while 循环，所以就算超时自动唤醒也会去重新检查条件，所以不存在逻辑错误问题<br>2.假设另外一个线程在唤醒之前因为某些原因退出了，那带参数的notify可以超时而进去就绪状态。<br><br>参考了操作系统原理课程，如有错误还请老师同学们指正。","like_count":0},{"had_liked":false,"id":76768,"user_name":"小黄","can_delete":false,"product_type":"c1","uid":1049839,"ip_address":"","ucode":"519BF8191D3A6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/ef/fea0fdbd.jpg","comment_is_top":false,"comment_ctime":1552704059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552704059","product_id":100023901,"comment_content":"因为MESA notify是将线程从条件队列转移到入口队列，如果入口队列是阻塞队列，则会循环等待而死锁。不知理解对吗？","like_count":0},{"had_liked":false,"id":76764,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552703507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552703507","product_id":100023901,"comment_content":"思考题 我觉得是因为 Hasen和Hoare 模型中T2线程notify T1线程之后中止或阻塞。而在MESA模型中，T2会继续执行，那么T2不能无限期的占有锁，从性能和活跃性上都不合适，所以需要超时参数。<br><br>问题：管程方案 Synchronized 怎么实现condition呢？","like_count":0},{"had_liked":false,"id":76759,"user_name":"我行我素","can_delete":false,"product_type":"c1","uid":1224678,"ip_address":"","ucode":"4C69542FAB0671","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/e6/9c77acff.jpg","comment_is_top":false,"comment_ctime":1552702522,"is_pvip":false,"replies":[{"id":"28025","content":"我觉得是给开发人员一个机会去避免线程饥饿。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552729893,"ip_address":"","comment_id":76759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552702522","product_id":100023901,"comment_content":"感觉是必要的，因为在MESA模型中，使用的是循环方式校验条件变量，如果不做超时参数的设置就可能会导致曾经满足的条件此后都不满足而一直循环","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443437,"discussion_content":"我觉得是给开发人员一个机会去避免线程饥饿。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552729893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76750,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1552701113,"is_pvip":false,"replies":[{"id":"27983","content":"感谢感谢，是wait<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552704185,"ip_address":"","comment_id":76750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552701113","product_id":100023901,"comment_content":"老师好，我想问下notify会有参数吗？是在哪里能找到呢，好像我只看到wait才有参数","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443433,"discussion_content":"感谢感谢，是wait\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552704185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76747,"user_name":"花蛋壳","can_delete":false,"product_type":"c1","uid":1111006,"ip_address":"","ucode":"917BB219120BD2","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/de/c6509355.jpg","comment_is_top":false,"comment_ctime":1552700501,"is_pvip":false,"replies":[{"id":"27995","content":"不是，这个指的是BlockedQueue","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552705527,"ip_address":"","comment_id":76747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552700501","product_id":100023901,"comment_content":"对这一课的内容理解起来有些费劲！“假设有个线程 T1 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。”老师所说的这个队列不为空的队列指的只是一个判断条件吧？应该不是指管程里所指的等待队列吧？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443430,"discussion_content":"不是，这个指的是BlockedQueue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552705527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76723,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1552696951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552696951","product_id":100023901,"comment_content":"有必要合理的控制线程，避免阻塞和长时间资源占用","like_count":0},{"had_liked":false,"id":76714,"user_name":"Monica","can_delete":false,"product_type":"c1","uid":1071644,"ip_address":"","ucode":"42C29619355A9B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/1c/310ec503.jpg","comment_is_top":false,"comment_ctime":1552695182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552695182","product_id":100023901,"comment_content":"紧跟上学习步伐","like_count":0}]}