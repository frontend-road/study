{"id":101244,"title":"12 | 多线程之锁优化（上）：深入了解Synchronized同步锁的优化方法","content":"<p>你好，我是刘超。从这讲开始，我们就正式进入到第三模块——多线程性能调优。</p><p><strong>在并发编程中，多个线程访问同一个共享资源时，我们必须考虑如何维护数据的原子性。</strong>在JDK1.5之前，Java是依靠Synchronized关键字实现锁功能来做到这点的。Synchronized是JVM实现的一种内置锁，锁的获取和释放是由JVM隐式实现。</p><p>到了JDK1.5版本，并发包中新增了Lock接口来实现锁功能，它提供了与Synchronized关键字类似的同步功能，只是在使用时需要显式获取和释放锁。</p><p>Lock同步锁是基于Java实现的，而Synchronized是基于底层操作系统的Mutex Lock实现的，每次获取和释放锁操作都会带来用户态和内核态的切换，从而增加系统性能开销。因此，在锁竞争激烈的情况下，Synchronized同步锁在性能上就表现得非常糟糕，它也常被大家称为重量级锁。</p><p><span class=\"orange\">特别是在单个线程重复申请锁的情况下，JDK1.5版本的Synchronized锁性能要比Lock的性能差很多。</span>例如，在Dubbo基于Netty实现的通信中，消费端向服务端通信之后，由于接收返回消息是异步，所以需要一个线程轮询监听返回信息。而在接收消息时，就需要用到锁来确保request session的原子性。如果我们这里使用Synchronized同步锁，那么每当同一个线程请求锁资源时，都会发生一次用户态和内核态的切换。</p><!-- [[[read_end]]] --><p>到了JDK1.6版本之后，Java对Synchronized同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了Lock同步锁。这一讲我们就来看看Synchronized同步锁究竟是通过了哪些优化，实现了性能地提升。</p><h2>Synchronized同步锁实现原理</h2><p>了解Synchronized同步锁优化之前，我们先来看看它的底层实现原理，这样可以帮助我们更好地理解后面的内容。</p><p><strong>通常Synchronized实现同步锁的方式有两种，一种是修饰方法，一种是修饰方法块。</strong>以下就是通过Synchronized实现的两种同步方法加锁的方式：</p><pre><code>// 关键字在实例方法上，锁为当前实例\n\tpublic synchronized void method1() {\n\t    // code\n\t}\n\t\n\t// 关键字在代码块上，锁为括号里面的对象\n\tpublic void method2() {\n\t    Object o = new Object();\n\t    synchronized (o) {\n\t        // code\n\t    }\n\t}\n</code></pre><p>下面我们可以通过反编译看下具体字节码的实现，运行以下反编译命令，就可以输出我们想要的字节码：</p><pre><code>javac -encoding UTF-8 SyncTest.java  //先运行编译class文件命令\n</code></pre><pre><code>javap -v SyncTest.class //再通过javap打印出字节文件\n</code></pre><p>通过输出的字节码，你会发现：Synchronized在修饰同步代码块时，是由 monitorenter和monitorexit指令来实现同步的。进入monitorenter 指令后，线程将持有Monitor对象，退出monitorenter指令后，线程将释放该Monitor对象。</p><pre><code>  public void method2();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=4, args_size=1\n         0: new           #2                  \n         3: dup\n         4: invokespecial #1                  \n         7: astore_1\n         8: aload_1\n         9: dup\n        10: astore_2\n        11: monitorenter //monitorenter 指令\n        12: aload_2\n        13: monitorexit  //monitorexit  指令\n        14: goto          22\n        17: astore_3\n        18: aload_2\n        19: monitorexit\n        20: aload_3\n        21: athrow\n        22: return\n      Exception table:\n         from    to  target type\n            12    14    17   any\n            17    20    17   any\n      LineNumberTable:\n        line 18: 0\n        line 19: 8\n        line 21: 12\n        line 22: 22\n      StackMapTable: number_of_entries = 2\n        frame_type = 255 /* full_frame */\n          offset_delta = 17\n          locals = [ class com/demo/io/SyncTest, class java/lang/Object, class java/lang/Object ]\n          stack = [ class java/lang/Throwable ]\n        frame_type = 250 /* chop */\n          offset_delta = 4\n</code></pre><p>再来看以下同步方法的字节码，你会发现：当Synchronized修饰同步方法时，并没有发现monitorenter和monitorexit指令，而是出现了一个ACC_SYNCHRONIZED标志。</p><p><span class=\"orange\">这是因为JVM使用了ACC_SYNCHRONIZED访问标志来区分一个方法是否是同步方法。</span>当方法调用时，调用指令将会检查该方法是否被设置ACC_SYNCHRONIZED访问标志。如果设置了该标志，执行线程将先持有Monitor对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该Mointor对象，当方法执行完成后，再释放该Monitor对象。</p><pre><code>   public synchronized void method1();\n    descriptor: ()V\n    flags: ACC_PUBLIC, ACC_SYNCHRONIZED // ACC_SYNCHRONIZED 标志\n    Code:\n      stack=0, locals=1, args_size=1\n         0: return\n      LineNumberTable:\n        line 8: 0\n\n</code></pre><p>通过以上的源码，我们再来看看Synchronized修饰方法是怎么实现锁原理的。</p><p>JVM中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个Monitor，Monitor可以和对象一起创建、销毁。Monitor是由ObjectMonitor实现，而ObjectMonitor是由C++的ObjectMonitor.hpp文件实现，如下所示：</p><pre><code>ObjectMonitor() {\n   _header = NULL;\n   _count = 0; //记录个数\n   _waiters = 0,\n   _recursions = 0;\n   _object = NULL;\n   _owner = NULL;\n   _WaitSet = NULL; //处于wait状态的线程，会被加入到_WaitSet\n   _WaitSetLock = 0 ;\n   _Responsible = NULL ;\n   _succ = NULL ;\n   _cxq = NULL ;\n   FreeNext = NULL ;\n   _EntryList = NULL ; //处于等待锁block状态的线程，会被加入到该列表\n   _SpinFreq = 0 ;\n   _SpinClock = 0 ;\n   OwnerIsThread = 0 ;\n}\n</code></pre><p>当多个线程同时访问一段同步代码时，多个线程会先被存放在ContentionList和_EntryList 集合中，处于block状态的线程，都会被加入到该列表。接下来当线程获取到对象的Monitor时，Monitor是依靠底层操作系统的Mutex Lock来实现互斥的，线程申请Mutex成功，则持有该Mutex，其它线程将无法获取到该Mutex，竞争失败的线程会再次进入ContentionList被挂起。</p><p>如果线程调用wait() 方法，就会释放当前持有的Mutex，并且该线程会进入WaitSet集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放Mutex。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/08/f78e6979c424cce677add97080811308.jpg?wh=2354*784\" alt=\"\"></p><p>看完上面的讲解，相信你对同步锁的实现原理已经有个深入的了解了。总结来说就是，同步锁在这种实现方式中，因Monitor是依赖于底层的操作系统实现，存在用户态与内核态之间的切换，所以增加了性能开销。</p><h2>锁升级优化</h2><p>为了提升性能，JDK1.6引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的Java对象头实现了锁升级功能。</p><p>当Java对象被Synchronized关键字修饰成为同步锁后，围绕这个锁的一系列升级操作都将和Java对象头有关。</p><h3>Java对象头</h3><p>在JDK1.6 JVM中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中Java对象头由Mark Word、指向类的指针以及数组长度三部分组成。</p><p>Mark Word记录了对象和锁有关的信息。Mark Word在64位JVM中的长度是64bit，我们可以一起看下64位JVM的存储结构是怎么样的。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/f8/fd86f1b5cbac1f652bea58b039fbc8f8.jpg?wh=1426*478\" alt=\"\"></p><p>锁升级功能主要依赖于Mark Word中的锁标志位和释放偏向锁标志位，<span class=\"orange\">Synchronized同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。</span>下面我们就沿着这条优化路径去看下具体的内容。</p><h3>1.偏向锁</h3><p>偏向锁主要用来优化同一线程多次申请同一个锁的竞争。在某些情况下，大部分时间是同一个线程竞争锁资源，例如，在创建一个线程并在线程中执行循环监听的场景下，或单线程操作一个线程安全集合时，同一线程每次都需要获取和释放锁，每次操作都会发生用户态与内核态的切换。</p><p>偏向锁的作用就是，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头的Mark Word中去判断一下是否有偏向锁指向它的ID，无需再进入Monitor去竞争对象了。<strong>当对象被当做同步锁并有一个线程抢到了锁时，锁标志位还是01，“是否偏向锁”标志位设置为1，并且记录抢到锁的线程ID，表示进入偏向锁状态。</strong></p><p>一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。</p><p><strong>下图中红线流程部分为偏向锁获取和撤销流程：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/d9/a2/d9f1e7fae6996a940e9471c47a455ba2.png?wh=1045*2091\" alt=\"\"></p><p>因此，在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生stop the word后， 开启偏向锁无疑会带来更大的性能开销，这时我们可以通过添加JVM参数关闭偏向锁来调优系统性能，示例代码如下：</p><pre><code>-XX:-UseBiasedLocking //关闭偏向锁（默认打开）\n</code></pre><p>或</p><pre><code>-XX:+UseHeavyMonitors  //设置重量级锁\n</code></pre><h3>2.轻量级锁</h3><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头Mark Word中的线程ID不是自己的线程ID，就会进行CAS操作获取锁，如果获取成功，直接替换Mark Word中的线程ID为自己的ID，该锁会保持偏向锁状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。</p><p>轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。</p><p><strong>下图中红线流程部分为升级轻量级锁及操作流程：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/84/f0/84f4d5dd908788fec0940431b4b912f0.png?wh=1053*2076\" alt=\"\"></p><h3>3.自旋锁与重量级锁</h3><p>轻量级锁CAS抢锁失败，线程将会被挂起进入阻塞状态。如果正在持有锁的线程在很短的时间内释放资源，那么进入阻塞状态的线程无疑又要申请锁资源。</p><p>JVM提供了一种自旋锁，可以通过自旋方式不断尝试获取锁，从而避免线程被挂起阻塞。这是基于大多数情况下，线程持有锁的时间都不会太长，毕竟线程被挂起阻塞可能会得不偿失。</p><p>从JDK1.7开始，自旋锁默认启用，自旋次数由JVM设置决定，这里我不建议设置的重试次数过多，因为CAS重试操作意味着长时间地占用CPU。</p><p>自旋锁重试之后如果抢锁依然失败，同步锁就会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会进入Monitor，之后会被阻塞在_WaitSet队列中。</p><p><strong>下图中红线流程部分为自旋后升级为重量级锁的流程：</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/2e/99/2e912fc6de6faeb1713a10959e5f1e99.png?wh=1041*2075\" alt=\"\"></p><p><span class=\"orange\">在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能。</span>一旦锁竞争激烈或锁占用的时间过长，自旋锁将会导致大量的线程一直处于CAS重试状态，占用CPU资源，反而会增加系统性能开销。所以自旋锁和重量级锁的使用都要结合实际场景。</p><p>在高负载、高并发的场景下，我们可以通过设置JVM参数来关闭自旋锁，优化系统性能，示例代码如下：</p><pre><code>-XX:-UseSpinning //参数关闭自旋锁优化(默认打开) \n-XX:PreBlockSpin //参数修改默认的自旋次数。JDK1.7后，去掉此参数，由jvm控制\n</code></pre><h2>动态编译实现锁消除/锁粗化</h2><p>除了锁升级优化，Java还使用了编译器对锁进行优化。JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。</p><p>确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 Java7 之后的版本就不需要手动配置了，该操作可以自动实现。</p><p>锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁”所带来的性能开销。</p><h2>减小锁粒度</h2><p>除了锁内部优化和编译器优化之外，我们还可以通过代码层来实现锁优化，减小锁粒度就是一种惯用的方法。</p><p>当我们的锁对象是一个数组或队列时，集中竞争一个对象的话会非常激烈，锁也会升级为重量级锁。<span class=\"orange\">我们可以考虑将一个数组和队列对象拆成多个小对象，来降低锁竞争，提升并行度。</span></p><p>最经典的减小锁粒度的案例就是JDK1.8之前实现的ConcurrentHashMap版本。我们知道，HashTable是基于一个数组+链表实现的，所以在并发读写操作集合时，存在激烈的锁资源竞争，也因此性能会存在瓶颈。而ConcurrentHashMap就很很巧妙地使用了分段锁Segment来降低锁资源竞争，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/92/c8306510d7562eb96c6f6b22a75e7592.png?wh=1042*650\" alt=\"\"></p><h2>总结</h2><p>JVM在JDK1.6中引入了分级锁机制来优化Synchronized，当一个线程获取锁时，首先对象锁将成为一个偏向锁，这样做是为了优化同一线程重复获取导致的用户态与内核态的切换问题；其次如果有多个线程竞争锁资源，锁将会升级为轻量级锁，它适用于在短时间内持有锁，且分锁有交替切换的场景；轻量级锁还使用了自旋锁来避免线程用户态与内核态的频繁切换，大大地提高了系统性能；但如果锁竞争太激烈了，那么同步锁将会升级为重量级锁。</p><p><span class=\"orange\">减少锁竞争，是优化Synchronized同步锁的关键。</span>我们应该尽量使Synchronized同步锁处于轻量级锁或偏向锁，这样才能提高Synchronized同步锁的性能；通过减小锁粒度来降低锁竞争也是一种最常用的优化方法；另外我们还可以通过减少锁的持有时间来提高Synchronized同步锁在自旋时获取锁资源的成功率，避免Synchronized同步锁升级为重量级锁。</p><p>这一讲我们重点了解了Synchronized同步锁优化，这里由于字数限制，也为了你能更好地理解内容，目录中12讲的内容我拆成了两讲，在下一讲中，我会重点讲解Lock同步锁的优化方法。</p><h2>思考题</h2><p>请问以下Synchronized同步锁对普通方法和静态方法的修饰有什么区别？</p><pre><code>// 修饰普通方法\n\tpublic synchronized void method1() {\n\t    // code\n\t}\n\t\n\t// 修饰静态方法\n\tpublic  synchronized static void method2() {\n\t    // code\n\t}\n</code></pre><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg?wh=1110*659\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":104829,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1560849339,"is_pvip":false,"replies":[{"id":"38057","content":"赞","user_name":"作者回复","comment_id":104829,"uid":"1228576","ip_address":"","utype":1,"ctime":1560908182,"user_name_real":"刘超"}],"discussion_count":6,"race_medal":0,"score":"400992807867","product_id":100028001,"comment_content":"Synchronized锁升级步骤<br><br>1. 偏向锁:JDK6中引入的一项锁优化,它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能 ,<br>2. 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁<br>3. 当锁对象第一次被线程获取的时候，线程使用CAS操作把这个锁的线程ID记录再对象Mark Word之中，同时置偏向标志位1。以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。<br>4. 如果线程使用CAS操作时失败则表示该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁的所有权。当到达全局安全点（safepoint，这个时间点上没有正在执行的字节码）时获得偏向锁的线程被挂起，膨胀为轻量级锁（涉及Monitor Record，Lock Record相关操作，这里不展开），同时被撤销偏向锁的线程继续往下执行同步代码。<br>5. 当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束 <br>6. 线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录(Lock Record)的空间，并将对象头中的Mard Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。如果自旋失败则锁会膨胀成重量级锁。如果自旋成功则依然处于轻量级锁的状态<br>7. 轻量级锁的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中赋值的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了，如果替换失败，就说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程<br>8. 轻量级锁提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的（区别于偏向锁）。这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢<br>简单概括为:<br>1. 检测Mark Word里面是不是当前线程ID,如果是,表示当前线程处于偏向锁<br>2. 如果不是,则使用CAS将当前线程ID替换到Mark Word,如果成功则表示当前线程获得偏向锁,设置偏向标志位1<br>3. 如果失败,则说明发生了竞争,撤销偏向锁,升级为轻量级锁<br>4. 当前线程使用CAS将对象头的mark Word锁标记位替换为锁记录指针,如果成功,当前线程获得锁<br>5. 如果失败,表示其他线程竞争锁,当前线程尝试通过自旋获取锁 for(;;)<br>6. 如果自旋成功则依然处于轻量级状态<br>7. 如果自旋失败,升级为重量级锁<br>   - 索指针:在当前线程的栈帧中划出一块空间,作为该锁的锁记录,并且将锁对象的标记字段复制到改锁记录中!<br>","like_count":93,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454443,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560908182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338010,"discussion_content":"我明白了...是cas过于激烈导致的失败","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609152893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338008,"discussion_content":"老师我看完锁升级的步骤有点困惑,当线程A试图自己占有偏向锁时cas修改线程id失败,这个可以理解为已经有线程B占有了偏向锁了.而在此时线程B还在方法执行中,需要升级为轻量级锁,此时线程B是占有着偏向锁的,cas获取轻量级锁失败的原因我不太明白.难道此时还有一个线程C占有着轻量级锁吗?然后此时线程B从偏向锁升级为轻量级锁失败.线程C持有的轻量级锁就会升级为重量级锁吗?我感到困惑的点是,在这个过程中,为什么会有线程B占有着偏向锁,线程C又占有着轻量级锁.为什么一个同步代码块会同时被两个线程访问呢? 老师恳请您的指点.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609152455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1372119,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ef/d7/2f700986.jpg","nickname":"calvin sheng","note":"","ucode":"D992BDA50DACC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1580,"discussion_content":"👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562717239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476477,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/7d/5b331647.jpg","nickname":"逻各斯与努斯","note":"","ucode":"148F124E649B0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119749,"discussion_content":"还是看流程图来的直观","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578236257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309592,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fb/98/6f238b8e.jpg","nickname":"半个柚子","note":"","ucode":"CF5D1190D970A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36351,"discussion_content":"大佬大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571366757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105033,"user_name":"学无止境0033","can_delete":false,"product_type":"c1","uid":1443365,"ip_address":"","ucode":"6332DA0B9FF989","user_header":"https://static001.geekbang.org/account/avatar/00/16/06/25/5461385f.jpg","comment_is_top":false,"comment_ctime":1560907180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"160474697132","product_id":100028001,"comment_content":"很少评论，但今天看的这个mark word对象和锁升级的图画的真是倍儿棒，一目了然，目前看过synchronized锁机制中最好理解的","like_count":37},{"had_liked":false,"id":103878,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1560558690,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"113229708386","product_id":100028001,"comment_content":"非静态方法是对象锁，静态方法是类锁","like_count":26,"discussions":[{"author":{"id":1445907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/10/13/a5194058.jpg","nickname":"陈磊","note":"","ucode":"F69485EA1DCC7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351167,"discussion_content":"静态方法也是对象锁，是class对象锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614170664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2238635,"avatar":"https://static001.geekbang.org/account/avatar/00/22/28/ab/b8905658.jpg","nickname":"AsYouWish99","note":"","ucode":"A5CE38DAD56115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578077,"discussion_content":"静态方法比非静态方法字节码中多一个 STATIC 且二者都包含 ACC_SYNCHRONIZED","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656496129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223808,"discussion_content":"老哥讲的通俗易懂，透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586255923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1205697,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","nickname":"程序员二师兄","note":"","ucode":"C9E3B5B3358BDF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":292727,"discussion_content":"偶遇~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595318779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223808,"ip_address":""},"score":292727,"extra":""}]}]},{"had_liked":false,"id":105365,"user_name":"不靠谱～","can_delete":false,"product_type":"c1","uid":1161163,"ip_address":"","ucode":"BC34F33FB437BD","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/cb/18f12eae.jpg","comment_is_top":false,"comment_ctime":1560990357,"is_pvip":false,"replies":[{"id":"38131","content":"JDK1.8之后ConcurrentHashMap就放弃了分段锁策略，而是直接使用CAS+Synchronized方式保证性能，这里的锁是指锁table的首个Node节点。在添加数据的时候，如果Node数组没有值的情况，则会使用CAS添加数据，CAS成功则添加成功，失败则进入锁代码块执行插入链表或红黑树或转红黑树操作。","user_name":"作者回复","comment_id":105365,"uid":"1228576","ip_address":"","utype":1,"ctime":1560994371,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"78870401685","product_id":100028001,"comment_content":"1.课后作业：实际对象锁和类对象锁的区别，锁对象不一样。<br>2.  1.8后CurrentHashmap已经不用segment策略了，想请教一下老师1.8后是怎样保证性能的呢？<br>3.对锁升级不太了解的同学可以看一下《Java并发编程的艺术》。里面有很详细的介绍，不过也是比较难理解，多看几遍。","like_count":18,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454648,"discussion_content":"JDK1.8之后ConcurrentHashMap就放弃了分段锁策略，而是直接使用CAS+Synchronized方式保证性能，这里的锁是指锁table的首个Node节点。在添加数据的时候，如果Node数组没有值的情况，则会使用CAS添加数据，CAS成功则添加成功，失败则进入锁代码块执行插入链表或红黑树或转红黑树操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560994371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103895,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1560560753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65985070193","product_id":100028001,"comment_content":"加在普通方法锁对象是当前对象，其ObjectMonitor就是对象的，而静态方法上，锁对象就是字节码对象，静态方法是所有对象共享的，锁粒度比较大","like_count":15},{"had_liked":false,"id":139230,"user_name":"承香墨影","can_delete":false,"product_type":"c1","uid":1023750,"ip_address":"","ucode":"4D6A4D6E1ED29F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","comment_is_top":false,"comment_ctime":1570589191,"is_pvip":false,"replies":[{"id":"54279","content":"这里老师纠正下，当竞争Monitor失败后，是去到ContentionList队列，而运行中的线程调用了wait方法会进入到WaitSet队列，等调用notify方法，会去队列中唤醒相应的线程，进入到EntryList队列中。文中已更新。","user_name":"作者回复","comment_id":139230,"uid":"1228576","ip_address":"","utype":1,"ctime":1570959486,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"61700131335","product_id":100028001,"comment_content":"老师，对我 waitSet 的理解也有歧义。<br>按您的在留言中的说法以及本文的内容，那等于进入 waitSet 会有两种情况，竞争 Monitor 失败，以及调用了 wait() 方法。<br>那何时会唤醒呢？<br>竞争 Monitor 失败的线程会在之前线程退出 Monitor 的时候再去竞争 Monitor，但是因外 wait() 方法也会进入 waitSet 的线程，就需要等待有线程退出的时候调用 notify() 方法，这一部分的细节和数据转换是怎么一回事？如何保证两种情况进入 waitSet 的线程，都拥有再次竞争 Monitor 的权利？","like_count":14,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469847,"discussion_content":"这里老师纠正下，当竞争Monitor失败后，是去到ContentionList队列，而运行中的线程调用了wait方法会进入到WaitSet队列，等调用notify方法，会去队列中唤醒相应的线程，进入到EntryList队列中。文中已更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570959486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1403179,"avatar":"https://static001.geekbang.org/account/avatar/00/15/69/2b/2b167857.jpg","nickname":"包子","note":"","ucode":"7F259526D835BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79481,"discussion_content":"查了下其他资料，有的说是竞争Monitor失败后会进入entrylist中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576076644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104195,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1560679514,"is_pvip":false,"replies":[{"id":"37786","content":"在获取到参与锁资源竞争的线程会进入entrylist，线程monitorenter失败后会进入到waitset，此时说明已经有线程获取到锁了，所以需要进入等待。调用wait方法也会进入到waitset。","user_name":"作者回复","comment_id":104195,"uid":"1228576","ip_address":"","utype":1,"ctime":1560737126,"user_name_real":"刘超"}],"discussion_count":7,"race_medal":0,"score":"61690221658","product_id":100028001,"comment_content":"entrylist和waitset那个地方不太理解，monitorenter失败后会进入entrylist吧，只有调用wait方法才会进入waitset吧，还请老师指点下","like_count":14,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454168,"discussion_content":"在获取到参与锁资源竞争的线程会进入entrylist，线程monitorenter失败后会进入到waitset，此时说明已经有线程获取到锁了，所以需要进入等待。调用wait方法也会进入到waitset。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560737126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2406845,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b9/bd/7fef12c8.jpg","nickname":"张新亮","note":"","ucode":"B68A71CDEA551A","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378370,"discussion_content":"作者确实说错了，waitset只用来保存调用wait后释放锁资源的情况","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623199736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121557,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/15/8ad4e24a.jpg","nickname":"yaomon","note":"","ucode":"4742547EB92BCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267052,"discussion_content":"作者回复的不对吧，跟自己的正文对不起来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589593730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585841,"discussion_content":"这条评论不对哈，看下面那条","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661847687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1462843,"avatar":"https://static001.geekbang.org/account/avatar/00/16/52/3b/f1501d79.jpg","nickname":"不工","note":"","ucode":"A8725E6D0E1765","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299640,"discussion_content":"和流程图对不上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597757335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2017324,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/P6JsN8S0vpe4YibqAe6YCeY9NxhCCqFQJ67wPGhcOPltp1Ex3PxSEtibRztALjXM5cNoLyG4nbXF5iblVjZ2Qvib5g/132","nickname":"Geek_3cbb96","note":"","ucode":"3B33BA699A94DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281528,"discussion_content":"作者这块和正文对不上呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591759707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048661,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/55/3f0bc345.jpg","nickname":"Ghost","note":"","ucode":"CC6FD1D460ED10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82895,"discussion_content":"他说错了，你理解是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576396900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109422,"user_name":"浩瀚有边","can_delete":false,"product_type":"c1","uid":1087384,"ip_address":"","ucode":"B4540E94EAFFE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/98/5ef15aa0.jpg","comment_is_top":false,"comment_ctime":1562031130,"is_pvip":false,"replies":[{"id":"51665","content":"锁状态只能升级不能降级。","user_name":"作者回复","comment_id":109422,"uid":"1228576","ip_address":"","utype":1,"ctime":1568898068,"user_name_real":"刘超"}],"discussion_count":6,"race_medal":0,"score":"57396605978","product_id":100028001,"comment_content":"老师，您好，synchronized锁只会升级，不会降级吧？如果系统只在某段时间高并发，升级到了重量级锁，然后系统变成低并发了，就一直是重量级锁了吗？请老师解惑，谢谢🙏","like_count":13,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456403,"discussion_content":"锁状态只能升级不能降级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568898068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337067,"discussion_content":"对的，来自杨晓峰老师的引用------“我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608789519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590646,"discussion_content":"不能降级这个肯定是不合理的。。就最简单的一个服务白天晚上竞争激烈程度不一样，那么晚上依旧用重量级锁是有问题的。。所以肯定是能降级的，无非考虑 如何判断需要降级，降级在什么时间发生。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665970662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1088594,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6ADlY3IFt3Rs1aVDyrTO2ytQZDiciaXVKgxCnsqZJUQHzH6I0I6PYvdoiaI6rkm7OLOxHia7t1icDyBQ/132","nickname":"yinwenping","note":"","ucode":"90310F95D8B72F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565625,"discussion_content":"可以降级","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650505279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2081651,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c3/73/c28b5d8c.jpg","nickname":"六月的雨","note":"","ucode":"41922FC245BA99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542830,"discussion_content":"重量级锁释放锁后会变成无锁状态。参考https://ac.nowcoder.com/discuss/607272?type=1&amp;order=0&amp;pos=17&amp;page=1&amp;channel=-1&amp;source_id=discuss_center_1_nctrack","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640856861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330917,"discussion_content":"锁能否降级jvm规范没有写明吧..\nhttps://time.geekbang.org/column/article/9042\n这边就有不同的解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606730355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208270,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587310940,"is_pvip":false,"replies":[{"id":"78614","content":"不应该叫锁降级，只是在垃圾回收阶段，即STW时，没有Java线程竞争锁的情况下，会将锁状态重置。","user_name":"作者回复","comment_id":208270,"uid":"1228576","ip_address":"","utype":1,"ctime":1587989057,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"48831951196","product_id":100028001,"comment_content":"老师在其他的回复中提到：synchronized锁只会升级，不会降级。如果系统只在某段时间高并发，升级到了重量级锁，然后系统变成低并发了，那还是重量锁，那岂不是很影响性能。","like_count":11,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492396,"discussion_content":"不应该叫锁降级，只是在垃圾回收阶段，即STW时，没有Java线程竞争锁的情况下，会将锁状态重置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587989057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208272,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587311466,"is_pvip":false,"replies":[{"id":"78615","content":"JVM在编译代码为字节码时，在字节码的边界都可以放一个安全点（safepoint），从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，暂停也就是我们说的发生stop-the-world（STW）。","user_name":"作者回复","comment_id":208272,"uid":"1228576","ip_address":"","utype":1,"ctime":1587989451,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"40242017130","product_id":100028001,"comment_content":"偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法。对此，有疑问，全局安全点指的是什么？什么情况下会出现暂停了该线程，该线程还在执行该方法？","like_count":9,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492397,"discussion_content":"JVM在编译代码为字节码时，在字节码的边界都可以放一个安全点（safepoint），从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，暂停也就是我们说的发生stop-the-world（STW）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587989451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222765,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1590908505,"is_pvip":false,"replies":[{"id":"82338","content":"如果不暂停就不能正确判断线程是否正在持有偏向锁，暂停的目的是保证能正确判断线程持有偏向锁状态以及线程执行代码块的情况。","user_name":"作者回复","comment_id":222765,"uid":"1228576","ip_address":"","utype":1,"ctime":1591100797,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"27360712281","product_id":100028001,"comment_content":"老师您好，想问一下，偏向锁的撤销为什么要在SafePoint暂停该线程呢，是因为要改变锁对象的头信息吗，那在线程运行时撤销偏向锁会出现什么问题呢","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496908,"discussion_content":"如果不暂停就不能正确判断线程是否正在持有偏向锁，暂停的目的是保证能正确判断线程持有偏向锁状态以及线程执行代码块的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591100797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204167,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1586345503,"is_pvip":false,"replies":[{"id":"77116","content":"队列就是有序的，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立了EntryList。<br><br>sync的公平和非公平提现在进入ContentionList队列之前，有一个cas自旋获取锁操作，获取不到再进入队列。","user_name":"作者回复","comment_id":204167,"uid":"1228576","ip_address":"","utype":1,"ctime":1586864745,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"27356149279","product_id":100028001,"comment_content":"entryList有序吗？感觉这个结果多余，sync没有实现公平锁。","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491096,"discussion_content":"队列就是有序的，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立了EntryList。\n\nsync的公平和非公平提现在进入ContentionList队列之前，有一个cas自旋获取锁操作，获取不到再进入队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586864745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132032,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568009191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18747878375","product_id":100028001,"comment_content":"课后思考及问题<br>首先，给老师的画图点个赞<br>这个太重要了，老师讲的相当棒，不过还是有些东西未消化，所以，特意多刷几遍。<br>再刷新时有如下疑问：<br>1：Mark Word 在 64 位 JVM 中的长度是 64bit，老师给出的图我计算了几次都不到64bit，是配图有问题嘛？另外，31bit21bit未使用和下面的54bit及2bit，那块没懂是什么意思？<br>2：在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the word 后， 开启偏向锁无疑会带来更大的性能开销。<br>为啥发生 stop the word ？<br> 开启偏向锁无疑会带来更大的性能开销，这个怎么理解，是因为发生了 stop the word，所以，才带来更大的性能开销还是别的什么带来的更大的性能开销？<br>3：JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。<br>确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。<br>老师逃逸分析不太理解是啥意思？能否稍微再讲解一下？<br>4：锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。<br>发现第一次理解的锁粗化是错误的，锁粗化——粗化主要体现在将同一个锁实例相邻的同步代码快合并到了一起，使同步代码块的粒度变大了，不过减少了反复申请和释放同一个锁所带来的性能开销。","like_count":4},{"had_liked":false,"id":131489,"user_name":"张海鹏","can_delete":false,"product_type":"c1","uid":1227121,"ip_address":"","ucode":"58ED5F306600D0","user_header":"https://static001.geekbang.org/account/avatar/00/12/b9/71/f6bf2b61.jpg","comment_is_top":false,"comment_ctime":1567765615,"is_pvip":false,"replies":[{"id":"49877","content":"不是的，一旦锁消除了，就不会再使用该锁了。逃逸分析一般是对一个对象的作用域的分析，例如一个对象只能被一个线程访问到时，则会消除锁。","user_name":"作者回复","comment_id":131489,"uid":"1228576","ip_address":"","utype":1,"ctime":1567771286,"user_name_real":"刘超"}],"discussion_count":3,"race_medal":0,"score":"18747634799","product_id":100028001,"comment_content":"老师，您文中提到的锁消除一块没有十分理解，意思是若只有一个线程正在使用同步块，synchronized关键字就不被编译，就不加锁，当有新的线程也调用这个代码块的时候再加锁，是这样么？另外这个“借助了一种被称为逃逸分析的技术”可以扩展讲解一下么？","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466481,"discussion_content":"不是的，一旦锁消除了，就不会再使用该锁了。逃逸分析一般是对一个对象的作用域的分析，例如一个对象只能被一个线程访问到时，则会消除锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567771286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1494622,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","nickname":"大明猩","note":"","ucode":"61D330B42AE3C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537343,"discussion_content":"锁消除：你用synchronized去锁Stringbuffer的append这种就会发生锁消除，因为本身就是线程安全的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639037708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215066,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg","nickname":"shen","note":"","ucode":"AE5737B0C7DC4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341582,"discussion_content":"锁消除就是锁是私有的，比如在局部方法里（栈中）不会被其他线程共享，那么就是线程安全的，锁在这里也没有意义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610457250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104225,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1560689258,"is_pvip":false,"replies":[{"id":"37788","content":"如果哪里不懂的，可以多提问，希望我能帮助到你。","user_name":"作者回复","comment_id":104225,"uid":"1228576","ip_address":"","utype":1,"ctime":1560737185,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"18740558442","product_id":100028001,"comment_content":"感觉讲得有点晦涩啊，不知道其他人什么感觉","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454177,"discussion_content":"如果哪里不懂的，可以多提问，希望我能帮助到你。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560737185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1677206,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/96/843956c1.jpg","nickname":"NightWatch","note":"","ucode":"437F76B010C149","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41432,"discussion_content":"这一节是我见过讲的最好的，其他人的更晦涩，以前怎么看都看不懂偏向锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572425845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258061,"user_name":"袁春栋","can_delete":false,"product_type":"c1","uid":2266474,"ip_address":"","ucode":"B46274DD9F3AD2","user_header":"https://static001.geekbang.org/account/avatar/00/22/95/6a/5e4106de.jpg","comment_is_top":false,"comment_ctime":1604282370,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14489184258","product_id":100028001,"comment_content":"老师您好，轻量级锁升级重量级锁的时候，是否会有这种情况，就是①偏向锁会在jvm启动时延迟4秒开启。②等待进行cas操作的线程数大于cpu核心线程数的二分之一将直接升级重量级锁","like_count":3},{"had_liked":false,"id":226842,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592214212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14477116100","product_id":100028001,"comment_content":"contentionList和EntryList有什么区别","like_count":3},{"had_liked":false,"id":133737,"user_name":"Young","can_delete":false,"product_type":"c1","uid":1619635,"ip_address":"","ucode":"B6CD7E4CF3220D","user_header":"https://static001.geekbang.org/account/avatar/00/18/b6/b3/f626885f.jpg","comment_is_top":false,"comment_ctime":1568644096,"is_pvip":true,"replies":[{"id":"51392","content":"主要区别是获取锁的方式，如果没有自旋，轻量级锁是通过cas来获取锁的，cas失败则直接升级为重量级锁。","user_name":"作者回复","comment_id":133737,"uid":"1228576","ip_address":"","utype":1,"ctime":1568721218,"user_name_real":"刘超"}],"discussion_count":2,"race_medal":0,"score":"14453545984","product_id":100028001,"comment_content":"请问老师，如果取消自旋，那轻量级锁和重量级锁还有什么区别吗","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467491,"discussion_content":"主要区别是获取锁的方式，如果没有自旋，轻量级锁是通过cas来获取锁的，cas失败则直接升级为重量级锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568721218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2742520,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d8/f8/a775cde7.jpg","nickname":"太阳与冰","note":"","ucode":"C2B97279BD66C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555031,"discussion_content":"不是总有一个线程抢锁会成功么？这个cas失败是指其余线程抢锁执行cas失败么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646724805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131948,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1567990661,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14452892549","product_id":100028001,"comment_content":"课后思考及问题<br>1：Synchronized 是基于底层操作系统的 Mutex Lock 实现的，每次获取和释放锁操作都会带来用户态和内核态的切换，从而增加系统性能开销。<br>老师这段没完全明白能细致的描述一下嘛？<br>2：接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。<br>Monitor对象和Mutex这两个具体又是什么？以及怎么实现的？<br>3：Synchronized同步锁的优化思路？<br>3-1：为啥要优化Synchronized同步锁？<br>因为它太重了，影响了系统的性能<br>3-2：Synchronized同步锁为啥这么重？<br>因为它底层的锁实现是依赖操作系统的Mutex锁实现的，依赖操作系统的底层锁实现，存在用户态和内核态的切换，因而会增加系统的开销。<br>3-3：用户态和内核态的切换为什么会增加系统的开销？<br>因为，线程从内核态切换到用户态时，需要保留线程当前的执行信息，待下一次切换回来后可以继续执行，所以，比较耗性能。正文老师没有讲到此点，评论区回复有这个信息，不过能给出更细致一些的描述就更好了，比如：都需要保存什么信息，保存这些信息花费的时间大概多少，花费的时间应该也有大有小吧。<br>3-4：理解了Synchronized同步锁为啥那么慢，那么耗性能，下面的锁优化其实就好理解了，他们所做的工作都在于减少做那些耗性能的事情。<br>3-5：偏向锁——自己获取自己加的锁，也需要用户态和内核态的切换，没必要，只有判断出自己在和自己竞争就不切换了，通过这种方式减少了用户态和内核态的切换。<br>3-6：轻量锁——使用CAS的方式尝试无锁操作是否OK，如果OK，也不需要用户态和内核态的切换，还是偏向锁，否则升级为轻量锁，轻量级锁采用是CAS的方式来操作，所以，也不会进行用户态和内核态的切换。不过它只适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。<br>3-7：自旋锁——获取琐时，认为再等一会儿，其他线程就会释放锁了，所以，先等一下下。自旋就是空跑几圈CPU时钟周期不断的尝试获取锁，若获取到，则OK，否则就会升级为重量级锁。这是基于大多数情况下，线程持有锁的时间都不会太长，毕竟线程被挂起阻塞可能会得不偿失。<br>3-8：重量锁——这个本质和Synchronized就一样了，上面做了这么多尝试依据避免不了用户态和内核态的切换，那就只能切换了，慢一点总比错了强。<br>3-9：锁粗化——坦白讲上面的锁优化思路基本是投机取巧的策略，所以，具有一定的适用条件，如果取巧不成反而会更慢，于是又出现了这个锁优化，明确知道取巧的思路是不可行的那还是老老实实的进行用户态和内核态的切换吧!<br><br>再请教几个问题，操作系统层面是怎么实现锁的？另外，站在JVM的角度是不清楚锁什么时候被释放的嘛？如果能比较的清楚锁什么时候被释放，待其被释放的时候去获取或者多个线程竞争获取，这些性能是否更好一些。<br>WaitSet中的等待线程被唤醒重新进入EntryList，是有序进入还是无限的，我指的是在WaitSet中的次序？另外，所有竞争锁的线程都必须先进入EntryList嘛？进入后再获取监控器对象时就是有序的啦嘛？那公平锁和非公平锁，怎么提现和实现的？","like_count":3,"discussions":[{"author":{"id":2421369,"avatar":"https://static001.geekbang.org/account/avatar/00/24/f2/79/b2012f53.jpg","nickname":"余生","note":"","ucode":"AEF6C96738F03B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383219,"discussion_content":"mutex lock是原子变量初始0+fluex机制: 上锁，原子变量++，结果是1上锁成功无需进内核，结果大于1上锁失败进内核休眠让出cpu；释放锁，原子变量--，结果0无其它线程等锁无需进内核，结果大于0进内核wake up等待锁的进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625995140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1598229,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg","nickname":"纯风","note":"","ucode":"CCA837A3E9BF2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261043,"discussion_content":"老师咋没给你评论 其实我也不知道\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588933011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104675,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560817225,"is_pvip":false,"replies":[{"id":"37874","content":"老师没有看懂你问的具体问题，麻烦再描述一下你的问题。","user_name":"作者回复","comment_id":104675,"uid":"1228576","ip_address":"","utype":1,"ctime":1560822826,"user_name_real":"刘超"}],"discussion_count":1,"race_medal":0,"score":"14445719113","product_id":100028001,"comment_content":"老师好!获取偏斜锁和轻量级锁的时候使用的CAS操作预期值传的是null(希望锁已释放)，替换后值是当前线程什么?","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454369,"discussion_content":"老师没有看懂你问的具体问题，麻烦再描述一下你的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560822826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215221,"user_name":"纯风","can_delete":false,"product_type":"c1","uid":1598229,"ip_address":"","ucode":"CCA837A3E9BF2A","user_header":"https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg","comment_is_top":false,"comment_ctime":1588932187,"is_pvip":false,"replies":[{"id":"79917","content":"在14讲中重点介绍了CAS：CAS 是实现乐观锁的核心算法，它包含了 3 个参数：V（需要更新的变量）、E（预期值）和 N（最新值）。只有当需要更新的变量等于预期值时，需要更新的变量才会被设置为最新值，如果更新值和预期值不同，则说明已经有其它线程更新了需要更新的变量，此时当前线程不做操作，返回 V 的真实值。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1589165504,"ip_address":"","comment_id":215221,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10178866779","product_id":100028001,"comment_content":"老师 cas操作是什么 不能理解","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494359,"discussion_content":"在14讲中重点介绍了CAS：CAS 是实现乐观锁的核心算法，它包含了 3 个参数：V（需要更新的变量）、E（预期值）和 N（最新值）。只有当需要更新的变量等于预期值时，需要更新的变量才会被设置为最新值，如果更新值和预期值不同，则说明已经有其它线程更新了需要更新的变量，此时当前线程不做操作，返回 V 的真实值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589165504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1598229,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg","nickname":"纯风","note":"","ucode":"CCA837A3E9BF2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263035,"discussion_content":"谢谢老师  祝老师身体健康  发发发发  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589165582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185804,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1583681901,"is_pvip":false,"replies":[{"id":"72178","content":"JVM中monitorenter和monitorexit字节码指令是依赖于底层的操作系统的Mutex Lock来实现的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584014730,"ip_address":"","comment_id":185804,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10173616493","product_id":100028001,"comment_content":"老师，sychronized底层实现是操作系统里的mutex lock，这个和反汇编后的monitorenter monitorexit指令有什么关系么","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486507,"discussion_content":"JVM中monitorenter和monitorexit字节码指令是依赖于底层的操作系统的Mutex Lock来实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584014730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110045,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1562159542,"is_pvip":false,"replies":[{"id":"39955","content":"对的，普通方法中的锁时锁对象，而修饰静态方法是类锁","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562208561,"ip_address":"","comment_id":110045,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152094134","product_id":100028001,"comment_content":"普通方法中锁的是当前对象，静态方法锁的是静态类","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456697,"discussion_content":"对的，普通方法中的锁时锁对象，而修饰静态方法是类锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562208561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108189,"user_name":"拉可里啦","can_delete":false,"product_type":"c1","uid":1230293,"ip_address":"","ucode":"26E20DF096BDAF","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/d5/90ca8efe.jpg","comment_is_top":false,"comment_ctime":1561692570,"is_pvip":false,"replies":[{"id":"39349","content":"对的，理解正确","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862226,"ip_address":"","comment_id":108189,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10151627162","product_id":100028001,"comment_content":"在使用偏向锁中，进行cas替换失败的原因是什么？我认为有两点：1.被替换的线程目前还在执行中 2.被替换的线程已执行完毕，但是有其它线程同时获取到了偏向锁。 不知我理解的是否合理，还请老师指点。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455864,"discussion_content":"对的，理解正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2682279,"avatar":"","nickname":"陈建飞","note":"","ucode":"6671F0E70FFFF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385742,"discussion_content":"我有点不懂，偏向锁的实现是写入之前曾持有线程的id，这id可以记录多个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627259647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26233,"discussion_content":"那其实是一个意思，就是当前获取偏向锁的线程，正在运行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570589611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105628,"user_name":"余冲","can_delete":false,"product_type":"c1","uid":1175598,"ip_address":"","ucode":"162AF434FA753B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/2e/b3c880b8.jpg","comment_is_top":false,"comment_ctime":1561044895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150979487","product_id":100028001,"comment_content":"老师感觉锁级别的优化，总结下来，就是为了防止线程因争取锁对象的monitor对象，而进入monitor的waitset队列中。因为monitor需要进行系统调用，发生用户态到内核态的切换。那","like_count":2},{"had_liked":false,"id":104825,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1560848732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150783324","product_id":100028001,"comment_content":"修饰普通方法是改类的对象,比如class A 创建了两个对象 class A1 跟class A2,对于method1来说A1,A2直接不是互斥的,但是对于静态方法或者synchronized(A.class)表示加锁对象为.class文件,一个项目只有唯一一个class文件,所以是互斥的","like_count":2},{"had_liked":false,"id":103969,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1560577289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150511881","product_id":100028001,"comment_content":"1.8后，可以尽量采用并发包中的无锁或则称乐观锁来实现。读写极端场景可以看情况选用读写锁或票据锁。<br>课后题，前者锁实例，后者锁类的字节码对象。后者力度太大应该结合业务场景尽量规避。","like_count":2},{"had_liked":false,"id":274937,"user_name":"dream","can_delete":false,"product_type":"c1","uid":1117793,"ip_address":"","ucode":"65B33D32FA8BE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/61/ae68f8eb.jpg","comment_is_top":false,"comment_ctime":1611222581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906189877","product_id":100028001,"comment_content":"老师，问一些问题呀。<br>java 的 synchronized 对象的实现依赖于 monitor 对象，monitor 通过 c++ 的 ObjectMonitor 实现。<br>很多资料都说，任何一个对象都有一个 monitor 对象与之关联。<br>这个关联是 synchronized 轻量级锁或者重量级锁的时候，synchronized 锁的对象(如 synchronized(obj){} 中) obj 对象的对象头中 mark word 指向 monitor 的指针吗(那么monitor中指向obj对象的字段是哪一个呢)？<br>那么这个 monitor 是什么时候创建的呢？gc 的时候，monitor 对象会被回收吗？<br>synchronized 对象处于重量级锁的时候，对象头中的 hashcode 和 gc 年龄代等会存储哪里呢(ObjectMonitor 中的 _header 吗？)？这个 gc 的时候年龄怎么判断与处理呢(年龄段的增加与从Eden到老年代等)？<br>还有就是有些资料中有说 Object 类中的 wait()、notify() 等方法与 monitor 有关，那么一个普通的 java 对象(里面并没有 synchronized 关键字)， 它会有对应的 monitor 对象吗?如果有，monitor 对象是好久创建的呢？<br>锁降级的时候怎么处理的呢？<br>","like_count":1},{"had_liked":false,"id":130726,"user_name":"SDL","can_delete":false,"product_type":"c1","uid":1438734,"ip_address":"","ucode":"AC46F5A8B4B704","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/0e/e200dd34.jpg","comment_is_top":false,"comment_ctime":1567519900,"is_pvip":false,"replies":[{"id":"49135","content":"减少锁占用时间和减小锁粒度是最直观的减少锁竞争的方式了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567596348,"ip_address":"","comment_id":130726,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5862487196","product_id":100028001,"comment_content":"默默问句怎么减少锁竞争呢？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466093,"discussion_content":"减少锁占用时间和减小锁粒度是最直观的减少锁竞争的方式了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438734,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/0e/e200dd34.jpg","nickname":"SDL","note":"","ucode":"AC46F5A8B4B704","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7828,"discussion_content":"好的 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567686068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123086,"user_name":"ddddd🐳","can_delete":false,"product_type":"c1","uid":1451640,"ip_address":"","ucode":"EFEA2FBB27ECFE","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/78/ed0252c2.jpg","comment_is_top":false,"comment_ctime":1565602904,"is_pvip":false,"replies":[{"id":"45282","content":"如果一个线程还没有撤销偏向锁，也就是还没有释放锁，这时候另一个线程尝试获取偏向锁，这个时候CAS就会失败","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565661373,"ip_address":"","comment_id":123086,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5860570200","product_id":100028001,"comment_content":"偏向锁真的没理解，cas更新线程ID什么情况下认为失败？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462532,"discussion_content":"如果一个线程还没有撤销偏向锁，也就是还没有释放锁，这时候另一个线程尝试获取偏向锁，这个时候CAS就会失败","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565661373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1110461,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/bd/049a06b0.jpg","nickname":"ziven","note":"","ucode":"D13AC3D2D27A6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588575,"discussion_content":"老师，这句话这里不太理解，当前线程还没有撤销偏向锁，另一个线程通过CAS替换线程ID，为啥会失败？是因为CAS的时候，set的参数包含了锁状态、线程ID吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663857202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":462532,"ip_address":"广东"},"score":588575,"extra":""}]}]},{"had_liked":false,"id":108528,"user_name":"拉可里啦","can_delete":false,"product_type":"c1","uid":1230293,"ip_address":"","ucode":"26E20DF096BDAF","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/d5/90ca8efe.jpg","comment_is_top":false,"comment_ctime":1561792707,"is_pvip":false,"replies":[{"id":"39370","content":"这个时候是无法获取到偏向锁的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561867636,"ip_address":"","comment_id":108528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856760003","product_id":100028001,"comment_content":"老师你好，在偏向锁中，如果另一个线程通过cas获取到了偏向锁，那么之前获取到的偏向锁的线程还在执行中，是否被中断了，还是执行完","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456027,"discussion_content":"这个时候是无法获取到偏向锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561867636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106076,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1561166789,"is_pvip":false,"replies":[{"id":"38420","content":"是的，理解没问题","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561255067,"ip_address":"","comment_id":106076,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856134085","product_id":100028001,"comment_content":"老师，请教一个问题：是不是多个线程执行同步代码时，这些线程一开始都是先进入entrylist，然后执行monitorenter指令向操作系统申请monitor对象，申请成功的获取代码执行权，申请失败的其他线程都进入waitset。如果已经申请到monitor的线程执行wait方法也会进入waitset。如果释放锁了就应该从entrylist移出，再次申请锁时也是先进入entrylist，执行monitorenter，申请失败进入waitset...","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454938,"discussion_content":"是的，理解没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561255067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105547,"user_name":"余冲","can_delete":false,"product_type":"c1","uid":1175598,"ip_address":"","ucode":"162AF434FA753B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/2e/b3c880b8.jpg","comment_is_top":false,"comment_ctime":1561026780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855994076","product_id":100028001,"comment_content":"老师请问偏向锁的章节中，锁的状态，那个判断框，为什么没有偏向锁的路径。如果线程a占有了对象object，object就变为了偏向锁。当线程b再获取object的锁时，object此时应该为偏向锁了吧。锁的状态那个菱形框，应该有一个偏向锁的分支吧。","like_count":1},{"had_liked":false,"id":104310,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1560731501,"is_pvip":true,"replies":[{"id":"37873","content":"回答正确。<br><br>WaitSet中的线程最终唤醒是进入到EntrySet再次排队获取锁，不会直接唤醒就去获取锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560822786,"ip_address":"","comment_id":104310,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855698797","product_id":100028001,"comment_content":"普通方法是获取的是该对象的管程，静态方法获取的是该类对象的管程。<br>问题： 同步块中调用wait进入waitset，那么waitset和entryset不是都在等锁释放吗，为什么老师第一个图中有个waitset到entryset的箭头？ 难道对象在这个过程中会转移？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454217,"discussion_content":"回答正确。\n\nWaitSet中的线程最终唤醒是进入到EntrySet再次排队获取锁，不会直接唤醒就去获取锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560822786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104303,"user_name":"黑崽","can_delete":false,"product_type":"c1","uid":1024159,"ip_address":"","ucode":"F31A4102EE4DA8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/9f/71345740.jpg","comment_is_top":false,"comment_ctime":1560730593,"is_pvip":false,"replies":[{"id":"37865","content":"是的，感谢黑崽同学的提醒。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560821367,"ip_address":"","comment_id":104303,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855697889","product_id":100028001,"comment_content":"锁升级的图中显示markword是否存储线程ID的图中，两个路径是与不是，是不是画反了？是的话，要cas替换成自己。不是，那么就直接获取偏向锁","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454214,"discussion_content":"是的，感谢黑崽同学的提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560821367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104081,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1560618159,"is_pvip":false,"replies":[{"id":"37652","content":"对的，Monitor对象是JVM根据关键字创建的一个管程。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560648960,"ip_address":"","comment_id":104081,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5855585455","product_id":100028001,"comment_content":"“JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。”<br>---------------<br>老师，这里的对象实例指的是共享资源吧，也就是那个被锁的对象，即文中代码synchronized (o) 中的o，那Monitor对象又是哪个？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454117,"discussion_content":"对的，Monitor对象是JVM根据关键字创建的一个管程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560648960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103888,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1560560383,"is_pvip":false,"replies":[{"id":"37656","content":"是的，切换相当于一个中断响应过程。涉及到进程信息的进栈出栈等操作以及用户栈和内核栈的切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560650160,"ip_address":"","comment_id":103888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855527679","product_id":100028001,"comment_content":"用户态和内核态的切换，是不是也类似于一种中断？<br>由于需要保护现场，遂将该线程的相关信息入栈，等到再执行的时候出栈？<br>这个动作很消耗系统资源吗？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454040,"discussion_content":"是的，切换相当于一个中断响应过程。涉及到进程信息的进栈出栈等操作以及用户栈和内核栈的切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560650160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360963,"user_name":"柳十三","can_delete":false,"product_type":"c1","uid":1385852,"ip_address":"浙江","ucode":"FE50C9778914C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tKvmZ3Vs4t6RZ3X7cAliaW47Zatxhn1aV5PcCYT9NZ9k9WWqRrEBGHicGtRWvsG6yQqHnaWw6cGNSbicNLjZebcHA/132","comment_is_top":false,"comment_ctime":1667037561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667037561","product_id":100028001,"comment_content":"轻量级锁升为重量级锁会不会STW呢?","like_count":0},{"had_liked":false,"id":355922,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"湖南","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1661852939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661852939","product_id":100028001,"comment_content":"老师，什么是偏向锁的批量重偏向（bulk rebias） 机制 和批量重撤销机制？","like_count":0},{"had_liked":false,"id":354475,"user_name":"@蓉城🐬","can_delete":false,"product_type":"c1","uid":1542009,"ip_address":"安徽","ucode":"AE35D76AC72D9A","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/79/427f807c.jpg","comment_is_top":false,"comment_ctime":1660452719,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660452719","product_id":100028001,"comment_content":"请问后两位锁标识为啥没有从00开始标识无锁，而是从01开始标识的，","like_count":0},{"had_liked":false,"id":345446,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1652274893,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652274893","product_id":100028001,"comment_content":"总结<br>一、jvm命令&amp;&amp;参数<br>        ①  javac -encoding UTF-8 SyncTest.java  （将类文件编译成class文件）；<br>       ②  javap -v SyncTest.class （输出字节码文件）；<br>      ③ -XX:-UseBiasedLocking （关闭偏向锁，默认是打开的）；<br>      ④  -XX:+UseHeavyMonitors  （设置重量级锁）；<br> <br>二、synchronized锁原理<br>       ①  synchronized是基于操作系统（Mutex  Lock）实现的锁，每次获取和释放锁都会带来用户态与内核态的切换，影响系统性能，因此也被成为重量级锁；<br>       ②  synchronized是jvm实现的内置锁，获取锁与释放锁都是隐式操作；<br>      ③  synchronized修饰同步代码块时是通过monitorexit指令来实现同步的（进入monitorexit指令线程持有monitor对象（获取锁）退出monitorexit指令线程释放monitor对象（释放锁））；<br>      ④  synchronized修饰同步方法是通过 ACC_SYNCHRONIZED标志来实现同步的（线程执行此方法是会判断方法是否存在 ACC_SYNCHRONIZED标志，存在则需要获取monitor对象再执行，执行完后释放monitor对象）；<br>       ⑤  jvm中同步是基于进入和退出管程（monitor）实现的，每个实例对象都会有一个monitor，monitor随对象的一起创建和销毁，monitor是由ObjectMonitor实现，而ObjectMonitor是由C++ObjectMonitor.hpp文件实现； <br>      ⑥  多个线程进入同一同步代码块时会先存放在ContentionList 和 EntryList 集合中处于block状态的线程都会加入到该列表中，获取monitor成功的线程移出集合，竞争锁失败的线程会再次进入ContentionList中，被挂起，如果线程调用wait方法会该线程会进入waitset集合中等待下一次被唤醒；<br><br>三、锁优化<br>       ①  偏向锁（使用场景：长时间都是同一个线程持有锁）；<br>       ②  轻量级锁（自旋锁）（使用场景：每个线程持有锁时间短）；<br>       ③  重量级锁<br>       ④  动态编译锁消除（借助逃逸分析及时判断同步代码活是否只会被一个线程执行，确认是的话，编译后的代码会消除锁）；<br>       ⑤  锁粗化（JIT编译器动态编译时讲相邻且获取同一个锁的同步代码块合并，避免现场反复获取与释放同一把锁带来的性能开销）；<br>       ⑥   使用时减小锁粒度；<br><br><br>思考题<br>1.锁对象是this；<br>2.锁对象是静态方法所属类的Class对象；<br>    ","like_count":0},{"had_liked":false,"id":343910,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1651116600,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651116600","product_id":100028001,"comment_content":"“自旋锁重试之后如果抢锁依然失败，同步锁就会升级至重量级锁，锁标志位改为 10。在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在 _WaitSet 队列中”。这段话最后有问题，抢锁失败，应该是放在_EntryList队列中,在线程获取了monitor后，调用wait,才会进入_WaitSet队列中。","like_count":0},{"had_liked":false,"id":337569,"user_name":"caoy","can_delete":false,"product_type":"c1","uid":2737271,"ip_address":"","ucode":"E9E9AD435B8B21","user_header":"https://static001.geekbang.org/account/avatar/00/29/c4/77/278bad22.jpg","comment_is_top":false,"comment_ctime":1646898240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646898240","product_id":100028001,"comment_content":"思考题：synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。","like_count":0},{"had_liked":false,"id":337412,"user_name":"呢喃","can_delete":false,"product_type":"c1","uid":1036803,"ip_address":"","ucode":"1593EBA25F794B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/03/aeaec5bf.jpg","comment_is_top":false,"comment_ctime":1646812341,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646812341","product_id":100028001,"comment_content":"请问jvm锁支持锁降级吗？看了一些资料说法不一，有个说可以在只存在vmthread时，重量级锁降级为偏向锁","like_count":0},{"had_liked":false,"id":322503,"user_name":"花臂Seven","can_delete":false,"product_type":"c1","uid":2506417,"ip_address":"","ucode":"DBF07141BDE7A5","user_header":"https://static001.geekbang.org/account/avatar/00/26/3e/b1/46f42c7e.jpg","comment_is_top":false,"comment_ctime":1637425456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637425456","product_id":100028001,"comment_content":"老师 这里轻量级锁是没有自旋的 这个图应该改下","like_count":0},{"had_liked":false,"id":322477,"user_name":"花臂Seven","can_delete":false,"product_type":"c1","uid":2506417,"ip_address":"","ucode":"DBF07141BDE7A5","user_header":"https://static001.geekbang.org/account/avatar/00/26/3e/b1/46f42c7e.jpg","comment_is_top":false,"comment_ctime":1637406748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637406748","product_id":100028001,"comment_content":"讲的很好 解决了我的疑问 赞","like_count":0},{"had_liked":false,"id":308069,"user_name":"古 月","can_delete":false,"product_type":"c1","uid":2707245,"ip_address":"","ucode":"AA1819E7DA36B2","user_header":"","comment_is_top":false,"comment_ctime":1629377476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629377476","product_id":100028001,"comment_content":"一直有个问题，monitor enter这个指令 对应到 锁升级过程 中的哪一步呢？","like_count":0},{"had_liked":false,"id":297858,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1623819380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623819380","product_id":100028001,"comment_content":"静态方法锁在类定义头里面标识，普通方法锁在对象头里面标识，所以锁的范围就不一样了","like_count":0},{"had_liked":false,"id":290264,"user_name":"Mr.Brooks","can_delete":false,"product_type":"c1","uid":1118650,"ip_address":"","ucode":"D47A6B0236A79F","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/ba/2175bc50.jpg","comment_is_top":false,"comment_ctime":1619458555,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619458555","product_id":100028001,"comment_content":"文中出现了很多次cas，能否按锁的类别分别说明一下cas的参数和行为？","like_count":0},{"had_liked":false,"id":289695,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"","ucode":"4FA289E084B789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYNBIwAj3KdIXaXbeMBUjTMz31zAToHIJSdo7oQk8bfsibwViaLobVQ8miatwBlC5spLS9kVCzHMjUA/132","comment_is_top":false,"comment_ctime":1619146215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619146215","product_id":100028001,"comment_content":"老师，有一点一直很困惑<br>在偏向锁阶段，如果线程A持有了偏向锁，此时线程B来了<br>线程B会去CAS设置自己的线程id<br>虚拟机是开始撤销偏向锁的时机是在线程B 进行CAS操作的什么阶段啊？<br>看图里我理解应该是设置之前对吧<br>撤销会等到线程A执行到安全点时候<br>然后判断线程A是否正在执行同步方法，如果没有则释放偏向锁到无锁状态<br>接着线程B. CAS获取偏向锁成功对吗？<br>","like_count":0},{"had_liked":false,"id":289399,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1618997577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618997577","product_id":100028001,"comment_content":"老师， ContentionList 列表是 ObjectMonitor._cxq 变量么？","like_count":0},{"had_liked":false,"id":286075,"user_name":"郝希军","can_delete":false,"product_type":"c1","uid":2390479,"ip_address":"","ucode":"38CCE6B9BAF529","user_header":"https://static001.geekbang.org/account/avatar/00/24/79/cf/211f0208.jpg","comment_is_top":false,"comment_ctime":1617150931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617150931","product_id":100028001,"comment_content":"非静态方法是锁这个对象，静态方法是锁这个类，影响所有这个类的对象","like_count":0},{"had_liked":false,"id":276965,"user_name":"Kingrocy","can_delete":false,"product_type":"c1","uid":1837518,"ip_address":"","ucode":"9C18BD99131B33","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIANNsQtwyubBfRzqiamMmcxEfhWhJWBYBIsZ3eRxoYZNAX84HZA413pN0fwMhdicrOo5MlR3xloSeQ/132","comment_is_top":false,"comment_ctime":1612193756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612193756","product_id":100028001,"comment_content":"写的真心不错","like_count":0},{"had_liked":false,"id":270913,"user_name":"猪大强","can_delete":false,"product_type":"c1","uid":1542577,"ip_address":"","ucode":"2DD393D247798C","user_header":"https://static001.geekbang.org/account/avatar/00/17/89/b1/9f9cfc19.jpg","comment_is_top":false,"comment_ctime":1609316973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609316973","product_id":100028001,"comment_content":"老是你好，“在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the word 后， 开启偏向锁无疑会带来更大的性能开销” 我没看懂这一句是什么意思，为什么会有更大的新能开销","like_count":0},{"had_liked":false,"id":270534,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609152449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609152449","product_id":100028001,"comment_content":"老师我看完锁升级的步骤有点困惑,当线程A试图自己占有偏向锁时cas修改线程id失败,这个可以理解为已经有线程B占有了偏向锁了.而在此时线程B还在方法执行中,需要升级为轻量级锁,此时线程B是占有着偏向锁的,cas获取轻量级锁失败的原因我不太明白.难道此时还有一个线程C占有着轻量级锁吗?然后此时线程B从偏向锁升级为轻量级锁失败.线程C持有的轻量级锁就会升级为重量级锁吗?我感到困惑的点是,在这个过程中,为什么会有线程B占有着偏向锁,线程C又占有着轻量级锁.为什么一个同步代码块会同时被两个线程访问呢? 老师恳请您的指点.","like_count":0},{"had_liked":false,"id":262573,"user_name":"金传权","can_delete":false,"product_type":"c1","uid":2302878,"ip_address":"","ucode":"36013C18B92F9D","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/9e/7a287c61.jpg","comment_is_top":false,"comment_ctime":1605771638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605771638","product_id":100028001,"comment_content":"课后题 加了static锁的就是类.class了","like_count":0},{"had_liked":false,"id":260748,"user_name":"Geek_94f887","can_delete":false,"product_type":"c1","uid":1902367,"ip_address":"","ucode":"8AFAB4D4511A80","user_header":"","comment_is_top":false,"comment_ctime":1605094710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605094710","product_id":100028001,"comment_content":"Synchronized支持锁重入，是通过锁对象的引用计数来实现的，但是为何对象头的标记字段中，没有引用计数的字段？？","like_count":0},{"had_liked":false,"id":260464,"user_name":"Tree","can_delete":false,"product_type":"c1","uid":1064664,"ip_address":"","ucode":"F53C863FF9159C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/d8/8608ec03.jpg","comment_is_top":false,"comment_ctime":1605014234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605014234","product_id":100028001,"comment_content":"老师，我想问下 如果线程调用了sleep（）或者yield（）方法后，线程是进入到waitSet,还是contentionList还是entryList?","like_count":0},{"had_liked":false,"id":257606,"user_name":"zbz","can_delete":false,"product_type":"c1","uid":1067539,"ip_address":"","ucode":"CD5742AEF3A63A","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/13/a56ddf01.jpg","comment_is_top":false,"comment_ctime":1604041770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604041770","product_id":100028001,"comment_content":"还有不同策略QMode什么情况下是是1 2 3 之类，添加到entry_list的头或者尾部？","like_count":0},{"had_liked":false,"id":257601,"user_name":"zbz","can_delete":false,"product_type":"c1","uid":1067539,"ip_address":"","ucode":"CD5742AEF3A63A","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/13/a56ddf01.jpg","comment_is_top":false,"comment_ctime":1604040650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604040650","product_id":100028001,"comment_content":"文章基本原理了解差不多，你的文章注意疑问点感觉不清楚的地方：<br> 队列就是有序的，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立了EntryList。<br><br>sync的公平和非公平提现在进入ContentionList队列之前，有一个cas自旋获取锁操作，获取不到再进入队列。<br><br><br>这里说的为了降低对ContentionList队尾的争用，如何就降低争用具体是什么情况，能有例子吗？<br>ContentionList是先进先出还是后出？<br>我实际代码一个线程获取锁阻塞后，多个线程排队获取锁后，释放锁后，阻塞线程好像是先进后出获取锁。源码看了些entry_list好像是头插法放入。","like_count":0},{"had_liked":false,"id":244383,"user_name":"杨杨杨Ray","can_delete":false,"product_type":"c1","uid":1645267,"ip_address":"","ucode":"C2F01C4E07238D","user_header":"https://static001.geekbang.org/account/avatar/00/19/1a/d3/375aea2a.jpg","comment_is_top":false,"comment_ctime":1598499168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598499168","product_id":100028001,"comment_content":"假如只有两个线程A和B，A先执行获得了偏向锁，B后来执行的时候，由于除了A和B没有其他线程，那B的CAS操作一定会成功的吧？这样的话，B就获得了偏向锁吗？那A怎么办呢？","like_count":0},{"had_liked":false,"id":242734,"user_name":"程序员二师兄","can_delete":false,"product_type":"c1","uid":1205697,"ip_address":"","ucode":"C9E3B5B3358BDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/c1/afcd981b.jpg","comment_is_top":false,"comment_ctime":1597826306,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597826306","product_id":100028001,"comment_content":"Synchronized 同步锁对普通方法和静态方法的区别：<br>颗粒度不同，普通方法是针对实例对象，静态方法是针对类对象。","like_count":0},{"had_liked":false,"id":238167,"user_name":"Lambor","can_delete":false,"product_type":"c1","uid":1275494,"ip_address":"","ucode":"0E3C3C39A22495","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/66/cbd6013c.jpg","comment_is_top":false,"comment_ctime":1596085292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596085292","product_id":100028001,"comment_content":"偏向锁的撤销需要等待全局安全点，这个等待全局安全点是否可以理解为：等待持有该锁的线程 代码执行到某个字节码的边界（即安全点），然后暂停这个线程？这里的 stop-the-world 跟 GC 的 stop-the-world 是同一个意思吗？这里的 STW 应该是只暂停持有锁的这一个线程？","like_count":0},{"had_liked":false,"id":237929,"user_name":"别问","can_delete":false,"product_type":"c1","uid":1500187,"ip_address":"","ucode":"B24480E6E5792B","user_header":"https://static001.geekbang.org/account/avatar/00/16/e4/1b/76d3b44c.jpg","comment_is_top":false,"comment_ctime":1596006991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596006991","product_id":100028001,"comment_content":"老师讲的很棒 收获颇丰","like_count":0},{"had_liked":false,"id":236110,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1595319515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595319515","product_id":100028001,"comment_content":"对象锁和类锁~","like_count":0},{"had_liked":false,"id":234251,"user_name":"Geek_3cbb96","can_delete":false,"product_type":"c1","uid":2017324,"ip_address":"","ucode":"3B33BA699A94DE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/P6JsN8S0vpe4YibqAe6YCeY9NxhCCqFQJ67wPGhcOPltp1Ex3PxSEtibRztALjXM5cNoLyG4nbXF5iblVjZ2Qvib5g/132","comment_is_top":false,"comment_ctime":1594630215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594630215","product_id":100028001,"comment_content":"老师：我想跟您确认下，在synchronized1.6版本调整后，线程执行到monitorenter或发现类有ACC_SYNCHRONIZED标识后，还是会首先去持有对象的Monitor吗？","like_count":0},{"had_liked":false,"id":232979,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1594180299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594180299","product_id":100028001,"comment_content":"静态方法时针对类的，同一时刻只能有一个线程执行该类；普通方法是针对类的对象，只要不是同一个对象就能同一时刻执行该方法！","like_count":0},{"had_liked":false,"id":225463,"user_name":"Geek_3cbb96","can_delete":false,"product_type":"c1","uid":2017324,"ip_address":"","ucode":"3B33BA699A94DE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/P6JsN8S0vpe4YibqAe6YCeY9NxhCCqFQJ67wPGhcOPltp1Ex3PxSEtibRztALjXM5cNoLyG4nbXF5iblVjZ2Qvib5g/132","comment_is_top":false,"comment_ctime":1591759985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591759985","product_id":100028001,"comment_content":"contentionlist在objectmonitor中没有看到定义，请问这个是什么作用，contenttionlist中的线程什么时候进入到entrylist","like_count":0},{"had_liked":false,"id":222416,"user_name":"HYS","can_delete":false,"product_type":"c1","uid":1663961,"ip_address":"","ucode":"15BB22D00E0D33","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ONIogicHLw4qYdzjVlm5SS87r47Y0nKibEdIBqIVSed56mjSPhyy1bRTVHhxK9M18cTo5xeK03gg2tQr4iclmAicuw/132","comment_is_top":false,"comment_ctime":1590801354,"is_pvip":false,"replies":[{"id":"82339","content":"ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立了EntryList。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1591100909,"ip_address":"","comment_id":222416,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590801354","product_id":100028001,"comment_content":"Synchronized 锁竞争 有了 _EntryList 集合存放竞争的线程，为什么还要有ContentionList 呢？分两个列表设计的意义是什么呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496788,"discussion_content":"ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立了EntryList。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591100909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220679,"user_name":"来需求了，很忙","can_delete":false,"product_type":"c1","uid":1926122,"ip_address":"","ucode":"B77D1846FC9EED","user_header":"https://static001.geekbang.org/account/avatar/00/1d/63/ea/1a128e67.jpg","comment_is_top":false,"comment_ctime":1590307591,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590307591","product_id":100028001,"comment_content":"老师你好，<br><br>JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。<br><br>这里我有点疑问，我了解到的是只有对象升级为重量级锁时，才会创建monitor对象，并不是所有状态都有一个monitor对象，如果任何状态下，都有一个monitor对象，那在重量级锁的时候把指针指向monitor对象又有什么意义呢？<br><br>希望能得到解答<br>","like_count":0},{"had_liked":false,"id":213300,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1588380406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588380406","product_id":100028001,"comment_content":"看完jvm的逃逸分析之后，再看这个锁消除，又是另外一番体会；<br>synchronized的锁升级和对应对象头的锁标记信息和记录偏向锁的线程id，偏向锁标记位等流程很详细","like_count":0},{"had_liked":false,"id":212879,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1588230759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588230759","product_id":100028001,"comment_content":"当锁升级为轻量级锁和重量级锁后，对象头中存储的hashcode和分代年龄会被存在什么地方呢？","like_count":0},{"had_liked":false,"id":208314,"user_name":"gerry pang","can_delete":false,"product_type":"c1","uid":1068169,"ip_address":"","ucode":"54BD1D8DE1DBBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/89/e698c0a9.jpg","comment_is_top":false,"comment_ctime":1587339606,"is_pvip":false,"replies":[{"id":"78618","content":"无锁的标志位是01，偏向锁是11，轻量级锁是00","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1587990126,"ip_address":"","comment_id":208314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587339606","product_id":100028001,"comment_content":"老师，您画的mark word结构中的无锁、偏向锁和轻量级锁标志位有点问题，无锁和偏向锁应该是01吧。轻量级锁是00吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492415,"discussion_content":"无锁的标志位是01，偏向锁是11，轻量级锁是00","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587990126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208256,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587309366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587309366","product_id":100028001,"comment_content":"偏向锁的撤销需要等待全局安全点，这个全局安全点是什么","like_count":0},{"had_liked":false,"id":203864,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1586277209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586277209","product_id":100028001,"comment_content":"回答问题：<br>不加static的方法，锁对象是this，也就是实例化的对象。而加了static的锁对象是class类。从锁粒度来讲，不加static的锁粒度更小。因为锁的只是本对象。","like_count":0},{"had_liked":false,"id":201092,"user_name":"慌张而黑糖","can_delete":false,"product_type":"c1","uid":1638878,"ip_address":"","ucode":"B4416885A301C8","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","comment_is_top":false,"comment_ctime":1585714081,"is_pvip":false,"replies":[{"id":"75240","content":"属于轻量级锁","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585740478,"ip_address":"","comment_id":201092,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585714081","product_id":100028001,"comment_content":"对于图中先判断目前锁状态，偏向锁却在无锁状态的下面，是说偏向锁不算真正意义上的锁吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490236,"discussion_content":"属于轻量级锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585740478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196555,"user_name":"蘭","can_delete":false,"product_type":"c1","uid":1764584,"ip_address":"","ucode":"AB9742A75CE287","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ec/e8/41a9d0d8.jpg","comment_is_top":false,"comment_ctime":1585292817,"is_pvip":false,"replies":[{"id":"75247","content":"无论是Synchronized 还是 Lock，底层实现是有CAS操作","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585741934,"ip_address":"","comment_id":196555,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585292817","product_id":100028001,"comment_content":"Synchronized 不是悲观锁吗，这么会有CAS操作","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489329,"discussion_content":"无论是Synchronized 还是 Lock，底层实现是有CAS操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585741934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195337,"user_name":"will","can_delete":false,"product_type":"c1","uid":1156207,"ip_address":"","ucode":"7A7DBE3E0EEAEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/6f/672a27d4.jpg","comment_is_top":false,"comment_ctime":1585181818,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585181818","product_id":100028001,"comment_content":"加深了对同步的理解，里面画的图真棒，得多吸收几遍","like_count":0},{"had_liked":false,"id":191941,"user_name":".","can_delete":false,"product_type":"c1","uid":1083502,"ip_address":"","ucode":"83F583994F4F72","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/6e/3bd860d3.jpg","comment_is_top":false,"comment_ctime":1584804928,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584804928","product_id":100028001,"comment_content":"Lock 同步锁是基于 Java 实现的，而 Synchronized 是基于底层操作系统的 Mutex Lock 实现的，每次获取和释放锁操作都会带来用户态和内核态的切换，从而增加系统性能开销。因此，在锁竞争激烈的情况下，Synchronized 同步锁在性能上就表现得非常糟糕，它也常被大家称为重量级锁。","like_count":0},{"had_liked":false,"id":185011,"user_name":"Zend","can_delete":false,"product_type":"c1","uid":1053921,"ip_address":"","ucode":"80EBB0B6772E27","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","comment_is_top":false,"comment_ctime":1583465660,"is_pvip":false,"replies":[{"id":"72181","content":"新请求锁的线程会首先被加入到ConetentionList中，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立了EntryList。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584015749,"ip_address":"","comment_id":185011,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583465660","product_id":100028001,"comment_content":"老师：“当多个线程同时访问一段同步代码时，多个线程会先被存放在 ContentionList 和 _EntryList 集合中，处于 block 状态的线程，都会被加入到该列表。”这其中的_EntryList我能理解是同时多个访问的线程，但为什么又有ContentionList ？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486212,"discussion_content":"新请求锁的线程会首先被加入到ConetentionList中，ContentionList会被线程并发访问，为了降低对ContentionList队尾的争用，而建立了EntryList。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584015749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180963,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1582449825,"is_pvip":true,"replies":[{"id":"70515","content":"是的，重量级锁会带来用户态和内核态切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1582720750,"ip_address":"","comment_id":180963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582449825","product_id":100028001,"comment_content":"偏向锁，CAS替换线程ID，失败的话就升级；<br>轻量级锁：CAS替换，失败的话，就自旋，自旋失败了就升级；<br>重量级锁（这块不是很懂）：新来的线程直接被阻塞，存在一个集合中；<br><br>所以现在的锁都是围绕存着的线程ID来处理的，只不过处理方式不一样。这个重量级锁，是先开始说的用户态和内核态切换的那种吗？还是与那个无关了呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484865,"discussion_content":"是的，重量级锁会带来用户态和内核态切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582720750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172307,"user_name":"停三秒","can_delete":false,"product_type":"c1","uid":1442497,"ip_address":"","ucode":"C9D8F39F24672E","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/c1/80e68043.jpg","comment_is_top":false,"comment_ctime":1579146459,"is_pvip":false,"replies":[{"id":"67211","content":"抱歉，数字写错了，是56。这里的25bit unused表示没有使用的位。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1579522328,"ip_address":"","comment_id":172307,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579146459","product_id":100028001,"comment_content":"那个锁升级优化的图，怎么数都没有64位，还有图上标记31bit(25bit unused)的含义，看不太懂，希望老师指定迷津。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481692,"discussion_content":"抱歉，数字写错了，是56。这里的25bit unused表示没有使用的位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579522328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172154,"user_name":"codefire","can_delete":false,"product_type":"c1","uid":1066247,"ip_address":"","ucode":"8022698D62AB53","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/07/69e486e1.jpg","comment_is_top":false,"comment_ctime":1579096859,"is_pvip":true,"replies":[{"id":"67215","content":"对的，感谢提醒，现在已经标出来了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1579523124,"ip_address":"","comment_id":172154,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579096859","product_id":100028001,"comment_content":"老师好，我瞅了半天markword的图例，发现对象头markword在无锁和偏向锁时，有一位是未使用的，图例中并没有标出来。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481643,"discussion_content":"对的，感谢提醒，现在已经标出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579523124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166716,"user_name":"sudo","can_delete":false,"product_type":"c1","uid":1188517,"ip_address":"","ucode":"EA0F8116999557","user_header":"http://thirdwx.qlogo.cn/mmopen/g7TWmGqjoiaSFWknFpTPAia5rPOmzEZiaGK8icd5HGEXlfaYJBoKvLn5BkqGkyTZOqDTC3NMHXUbH3tdLJzicAyickRYdP4xcM3ajia/132","comment_is_top":false,"comment_ctime":1577551756,"is_pvip":false,"replies":[{"id":"70532","content":"旧值是之前获取到锁的线程id。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1582724387,"ip_address":"","comment_id":166716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577551756","product_id":100028001,"comment_content":"有一点比较迷惑，还望老师解惑。偏向锁时，发展mark word 里的线程id不是自己的，使用cas替换线程id，这个替换是怎么操作的。（旧值是什么，新值为当前线程id）","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479601,"discussion_content":"旧值是之前获取到锁的线程id。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582724387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163405,"user_name":"td901105","can_delete":false,"product_type":"c1","uid":1348830,"ip_address":"","ucode":"32D42A4F36FA02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132","comment_is_top":false,"comment_ctime":1576717833,"is_pvip":false,"replies":[{"id":"62981","content":"会直接成功获取到锁，偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1577189213,"ip_address":"","comment_id":163405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576717833","product_id":100028001,"comment_content":"老师，有一个问题。在一个线程A已经获取偏向锁了之后，并且已经执行完同步方法了。此时另外一个线程B过来竞争锁，此时CAS是直接成功还是在发生A清除偏向锁之后通知B，然后B再次CAS操作成功获取锁？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478383,"discussion_content":"会直接成功获取到锁，偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577189213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162273,"user_name":"HeGuang","can_delete":false,"product_type":"c1","uid":1256762,"ip_address":"","ucode":"2B938BCB4B82FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/3a/ffa02c6d.jpg","comment_is_top":false,"comment_ctime":1576489798,"is_pvip":false,"replies":[{"id":"61973","content":"升级为重量级锁并没有获取到锁，所以只能通过挂起等待，通过排队再次获取锁，才能执行同步代码。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1576669037,"ip_address":"","comment_id":162273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576489798","product_id":100028001,"comment_content":"老师那个锁升级的图我有点看不懂，就是在升级为重量级锁后线程被挂起等待，按照我的理解，升级为重量级锁不应该是直接执行同步代码块了吗","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477998,"discussion_content":"升级为重量级锁并没有获取到锁，所以只能通过挂起等待，通过排队再次获取锁，才能执行同步代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576669037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160383,"user_name":"Mr wind","can_delete":false,"product_type":"c1","uid":1217874,"ip_address":"","ucode":"484F02D1962239","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","comment_is_top":false,"comment_ctime":1575943587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575943587","product_id":100028001,"comment_content":"锁优化真实讲得清晰","like_count":0},{"had_liked":false,"id":153322,"user_name":"coderbee","can_delete":false,"product_type":"c1","uid":1005530,"ip_address":"","ucode":"02339998217473","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/da/0adccef5.jpg","comment_is_top":false,"comment_ctime":1574216321,"is_pvip":false,"replies":[{"id":"72188","content":"被覆盖了，回到无锁状态会再添加","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584016461,"ip_address":"","comment_id":153322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574216321","product_id":100028001,"comment_content":"请教一个问题：当对象加了偏向锁后，原来的哈希值放到哪里去了？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475120,"discussion_content":"被覆盖了，回到无锁状态会再添加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149022,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573128341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573128341","product_id":100028001,"comment_content":"老师画的这图真是绝了！见过最好的介绍分级锁的图片。","like_count":0},{"had_liked":false,"id":142505,"user_name":"shanshan123","can_delete":false,"product_type":"c1","uid":1153593,"ip_address":"","ucode":"F06DD03DB2962B","user_header":"","comment_is_top":false,"comment_ctime":1571381383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571381383","product_id":100028001,"comment_content":"感觉就像撒了一地的珠子被老师一点点串起来了  手动赞！","like_count":0},{"had_liked":false,"id":139893,"user_name":"一只纠结的锦鲤","can_delete":false,"product_type":"c1","uid":1157773,"ip_address":"","ucode":"41CF4D32BC6382","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/8d/15e70d60.jpg","comment_is_top":false,"comment_ctime":1570761330,"is_pvip":false,"replies":[{"id":"54272","content":"是的，持有锁升级为轻量级锁之后，其他线程会通过自旋竞争锁","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570955968,"ip_address":"","comment_id":139893,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570761330","product_id":100028001,"comment_content":"有个步骤不明白，就是[升级轻量锁，原持有偏向锁的线程获得轻量级锁] 它的下一步到[CAS]  <br>我感觉 是不是因为由于有锁竞争，当前持有偏向锁的线程没有执行完任务，然后升级后，它持有轻量级锁继续执行任务。而其他跟这个线程竞争的锁是不是应该走自旋这一步骤。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470163,"discussion_content":"是的，持有锁升级为轻量级锁之后，其他线程会通过自旋竞争锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570955968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134053,"user_name":"man1s","can_delete":false,"product_type":"c1","uid":1466953,"ip_address":"","ucode":"FFDB6B52F65A1B","user_header":"https://static001.geekbang.org/account/avatar/00/16/62/49/6332c99b.jpg","comment_is_top":false,"comment_ctime":1568729071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568729071","product_id":100028001,"comment_content":"对于jvm来说类和对象相当于两种不同的对象，静态方法相当于对类这个对象加锁，普通方法对类实例加锁","like_count":0},{"had_liked":false,"id":130965,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567584711,"is_pvip":false,"replies":[{"id":"49124","content":"因为同步锁是基于JVM实现，依赖了底层操作系统。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567596003,"ip_address":"","comment_id":130965,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567584711","product_id":100028001,"comment_content":" 老师，sychronized 会进行用户态和核心态的切换具体是因为什么","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466217,"discussion_content":"因为同步锁是基于JVM实现，依赖了底层操作系统。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567596003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129697,"user_name":"枕边书","can_delete":false,"product_type":"c1","uid":1004044,"ip_address":"","ucode":"BCA0478D161754","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLX62j3MqZu6QYnjiaEAAjjpnjsrNKicoZz91iacGx4BjYbjzhhYUEyaZQZPJQp4KQr8S44xuodAC43w/132","comment_is_top":false,"comment_ctime":1567222195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567222195","product_id":100028001,"comment_content":"“如果一个线程还没有撤销偏向锁，也就是还没有释放锁，这时候另一个线程尝试获取偏向锁，这个时候CAS就会失败。”<br>首先，线程不会去主动撤销偏向锁吧，另外CAS获取偏向锁时期待markword原来的值是什么？","like_count":0},{"had_liked":false,"id":126839,"user_name":"SDL","can_delete":false,"product_type":"c1","uid":1438734,"ip_address":"","ucode":"AC46F5A8B4B704","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/0e/e200dd34.jpg","comment_is_top":false,"comment_ctime":1566487845,"is_pvip":false,"replies":[{"id":"47072","content":"Java基础以及多线程编程基础","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566610803,"ip_address":"","comment_id":126839,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566487845","product_id":100028001,"comment_content":"感觉都好深奥啊 有点看不懂 不知道要有什么基础下才能看这个咧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464194,"discussion_content":"Java基础以及多线程编程基础","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566610803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123080,"user_name":"ddddd🐳","can_delete":false,"product_type":"c1","uid":1451640,"ip_address":"","ucode":"EFEA2FBB27ECFE","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/78/ed0252c2.jpg","comment_is_top":false,"comment_ctime":1565602293,"is_pvip":false,"replies":[{"id":"45281","content":"CAS不一定失败，CAS的作用提升获取偏向锁的成功率。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565661269,"ip_address":"","comment_id":123080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565602293","product_id":100028001,"comment_content":"老师，不知道是不是我的理解有问题，我一直觉得偏向锁只会有一个线程id,如果第二个线程来做cas一定是失败，不会更新线程id;","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462527,"discussion_content":"CAS不一定失败，CAS的作用提升获取偏向锁的成功率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565661269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123076,"user_name":"ddddd🐳","can_delete":false,"product_type":"c1","uid":1451640,"ip_address":"","ucode":"EFEA2FBB27ECFE","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/78/ed0252c2.jpg","comment_is_top":false,"comment_ctime":1565601417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565601417","product_id":100028001,"comment_content":"我觉得“检查markword是否存储线程ID”应该是在cas的时候一起进行的；所以图中“检查markword是否存储线程ID”是不是“判断是否是偏向锁”？而且我觉得图中这里的操作，如果是否的情况下，会有并发问题；所以感觉流程可能不是这样子的；","like_count":0},{"had_liked":false,"id":123072,"user_name":"ddddd🐳","can_delete":false,"product_type":"c1","uid":1451640,"ip_address":"","ucode":"EFEA2FBB27ECFE","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/78/ed0252c2.jpg","comment_is_top":false,"comment_ctime":1565601046,"is_pvip":false,"replies":[{"id":"45280","content":"是判断偏向锁的意思，两者的含义差不多。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565661103,"ip_address":"","comment_id":123072,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565601046","product_id":100028001,"comment_content":"锁升级的图中显示markword是否存储线程ID的图中，&quot;markword是否存储线程ID&quot;是不是应该改成&quot;是否是偏向锁&quot;；","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462524,"discussion_content":"是判断偏向锁的意思，两者的含义差不多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565661103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122046,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1565275004,"is_pvip":false,"replies":[{"id":"44857","content":"这个激烈程度与锁持有的时间有关系，如果锁持有时间比较长，三个线程也是在激烈的争夺锁资源，只是由于线程比较少，上下文切换会少一些。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565313205,"ip_address":"","comment_id":122046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565275004","product_id":100028001,"comment_content":"请问老师多少个线程才算竞争激烈呢？比如我三个线程来争夺锁","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462073,"discussion_content":"这个激烈程度与锁持有的时间有关系，如果锁持有时间比较长，三个线程也是在激烈的争夺锁资源，只是由于线程比较少，上下文切换会少一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565313205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118193,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1564286635,"is_pvip":false,"replies":[{"id":"44481","content":"这个优化跟指令没有什么关系，强调的是锁升级的优化，锁升级的优化跟JVM中的对象头的改造有关系。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565055764,"ip_address":"","comment_id":118193,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564286635","product_id":100028001,"comment_content":"老师， 前面的 Monitor 对象看懂了 ， 后面的锁优化也看懂了 ，但是我没有理解二者的联系。 再 1.6 后引入锁优化， 但是编译成字节码还是存在   monitorenter 和 monitorexit 。 那过程还是线程先去争取 Monitor 对象，和优化有什么关联么， 还是这个指令的含义变成了 锁优化的过程？？？？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460294,"discussion_content":"这个优化跟指令没有什么关系，强调的是锁升级的优化，锁升级的优化跟JVM中的对象头的改造有关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565055764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108732,"user_name":"拉可里啦","can_delete":false,"product_type":"c1","uid":1230293,"ip_address":"","ucode":"26E20DF096BDAF","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/d5/90ca8efe.jpg","comment_is_top":false,"comment_ctime":1561866824,"is_pvip":false,"replies":[{"id":"39613","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562032697,"ip_address":"","comment_id":108732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561866824","product_id":100028001,"comment_content":"在高并发的场景下，只能使用重量锁了吧 因为锁最终会升级到重量级锁，那么就需要提前关闭偏向锁和自旋锁","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456095,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562032697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108162,"user_name":"拉可里啦","can_delete":false,"product_type":"c1","uid":1230293,"ip_address":"","ucode":"26E20DF096BDAF","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/d5/90ca8efe.jpg","comment_is_top":false,"comment_ctime":1561688913,"is_pvip":false,"replies":[{"id":"39211","content":"同一个线程，线程ID是一样的，是根据线程ID区别的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561694605,"ip_address":"","comment_id":108162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561688913","product_id":100028001,"comment_content":"有个偏向锁的疑问：偏向锁认为自始至终只有一个线程访问，那么是怎么确定请求过来的是同一个线程呢？因为每次请求线程都是不同的线程ID啊","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455848,"discussion_content":"同一个线程，线程ID是一样的，是根据线程ID区别的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561694605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107596,"user_name":"Geek_ebda96","can_delete":false,"product_type":"c1","uid":1134862,"ip_address":"","ucode":"02912E6D95A5A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132","comment_is_top":false,"comment_ctime":1561562160,"is_pvip":false,"replies":[{"id":"39198","content":"是的，理解没问题。偏向锁适合当个永久线程下或有嵌套锁的资源锁操作。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561693494,"ip_address":"","comment_id":107596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561562160","product_id":100028001,"comment_content":"因此，在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the word 后， 开启偏向锁无疑会带来更大的性能开销，老师，这句话的意思是说撤销偏向锁的过程，发生stoop the word非常耗时影响性能吗？偏向锁不适合高并发场景，但低并发但场景，用偏向锁的意义在哪里呢？低并发关闭偏向锁，直接获取轻量级的锁，这个也没啥问题吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455579,"discussion_content":"是的，理解没问题。偏向锁适合当个永久线程下或有嵌套锁的资源锁操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561693494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106772,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1561385523,"is_pvip":true,"replies":[{"id":"38837","content":"最开始CurrentHashmap只有一个table[]数组，如果要操作该CurrentHashmap，则需要锁住table[]对象，这个时候所有的操作都来竞争一个table[]对象锁。<br><br>而分段锁则是将table[]数组分解称为了一个Segment[]数组，每个Segment[]的元素里面包含了一个HashEntry&lt;K,V&gt;[]数组，在第一次写入Segment[]数组时是CAS操作，如果CAS失败或Segment[]数组中的值不为null，则通过tryLock()将该Segment[]的这个元素锁住。而不是锁住整个Segment[]数组。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561516565,"ip_address":"","comment_id":106772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561385523","product_id":100028001,"comment_content":"老师能否解释下CurrentHashmap分段锁的那张图，不是很了解分段锁的实现","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455213,"discussion_content":"最开始CurrentHashmap只有一个table[]数组，如果要操作该CurrentHashmap，则需要锁住table[]对象，这个时候所有的操作都来竞争一个table[]对象锁。\n\n而分段锁则是将table[]数组分解称为了一个Segment[]数组，每个Segment[]的元素里面包含了一个HashEntry&amp;lt;K,V&amp;gt;[]数组，在第一次写入Segment[]数组时是CAS操作，如果CAS失败或Segment[]数组中的值不为null，则通过tryLock()将该Segment[]的这个元素锁住。而不是锁住整个Segment[]数组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561516565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106741,"user_name":"VIC","can_delete":false,"product_type":"c1","uid":1114064,"ip_address":"","ucode":"3B3E6D344488B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","comment_is_top":false,"comment_ctime":1561381884,"is_pvip":false,"replies":[{"id":"38836","content":"JVM默认情况下会使用偏向锁和轻量级锁，只有在竞争锁资源非常激烈的情况下，才会升级到重量级锁。<br><br>所以我们可以减少锁竞争来保持synchronized使用偏向锁，轻量级锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561515444,"ip_address":"","comment_id":106741,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561381884","product_id":100028001,"comment_content":"怎么让synchronized使用偏向锁，轻量级锁呢？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455200,"discussion_content":"JVM默认情况下会使用偏向锁和轻量级锁，只有在竞争锁资源非常激烈的情况下，才会升级到重量级锁。\n\n所以我们可以减少锁竞争来保持synchronized使用偏向锁，轻量级锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561515444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106314,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1561262489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561262489","product_id":100028001,"comment_content":"还没看完，看到了图我反手一个赞","like_count":0},{"had_liked":false,"id":105882,"user_name":"郭小菜","can_delete":false,"product_type":"c1","uid":1017297,"ip_address":"","ucode":"C4044C80BB331B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYfcUOVhf3vhEBUNGHgtIcw8ujMZnkabicLzzjn3xwdeeic2PJSe7ibJgMx2UjF0d7L4B4gsRpaqe2A/132","comment_is_top":false,"comment_ctime":1561098630,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561098630","product_id":100028001,"comment_content":"讲得特别棒，把java锁讲这么深的真的很少，值回票价。<br>课后习题<br>普通方法只会对申请新建的那个对象加锁，如果是创建的两个对象，他们的锁不干扰<br>静态方法的锁是对这个类对象加锁，任何申请了该类对象都使用的是同一把锁。","like_count":0},{"had_liked":false,"id":105630,"user_name":"余冲","can_delete":false,"product_type":"c1","uid":1175598,"ip_address":"","ucode":"162AF434FA753B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/2e/b3c880b8.jpg","comment_is_top":false,"comment_ctime":1561045399,"is_pvip":false,"replies":[{"id":"38426","content":"升级到了重量级锁，导致线程阻塞会引起用户态和内核态的切换。自旋是为了避免升级到重量级锁而引起用户态和内核态的切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561255940,"ip_address":"","comment_id":105630,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561045399","product_id":100028001,"comment_content":"我其实想弄明白的是:多线程场景下，哪些场景可以导致用户态和内核态切换。比如:线程阻塞后，被唤醒再次竞争锁，老师文章中介绍自旋时说会发生切换。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454745,"discussion_content":"升级到了重量级锁，导致线程阻塞会引起用户态和内核态的切换。自旋是为了避免升级到重量级锁而引起用户态和内核态的切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561255940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105153,"user_name":"草帽路飞","can_delete":false,"product_type":"c1","uid":1401733,"ip_address":"","ucode":"7416D1D82E3456","user_header":"https://static001.geekbang.org/account/avatar/00/15/63/85/9ccf1b19.jpg","comment_is_top":false,"comment_ctime":1560931085,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1560931085","product_id":100028001,"comment_content":"老师，您好，偏向锁-&gt;轻量级锁-&gt;自旋锁-&gt;重量级锁 这种思想和解决方式除了 JVM 的自动实现，在实际工作中有场景用到这种方案去解决问题么？","like_count":0,"discussions":[{"author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81313,"discussion_content":"红绿灯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576239840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104828,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1560849281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560849281","product_id":100028001,"comment_content":"获取偏斜锁和轻量级锁的时候使用的CAS操作预期值传的是null(希望锁已释放)，替换后值是当前线程什么?<br>偏向锁替换成功后设置Mark Word头中的偏向线程为当前线程的ID值,<br>轻量级锁是在当前线程栈帧中创建用于存储锁记录的空间,并将对象头中Mark word复制到锁记录中,然后线程尝试使用CAS将对象头中的Mark word中指向轻量级锁的指针指向锁记录的指针","like_count":0},{"had_liked":false,"id":104789,"user_name":"孙志强","can_delete":false,"product_type":"c1","uid":1325997,"ip_address":"","ucode":"9C070F1E4EC6FF","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/ad/31193b83.jpg","comment_is_top":false,"comment_ctime":1560838115,"is_pvip":true,"replies":[{"id":"38048","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560907222,"ip_address":"","comment_id":104789,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560838115","product_id":100028001,"comment_content":"stop the word 是指“偏向锁被撤销时，需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之，被其他线程抢占。” 全局安全点发生在偏向锁升级成轻量级锁的过程中吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454425,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560907222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104602,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1560783006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560783006","product_id":100028001,"comment_content":"Java并发编程实战的王宝令老师也讲了管程，和今天的课程互相印证，体验非常更好。老师今天课程中的优化思路讲的比较透彻，受益良多。","like_count":0},{"had_liked":false,"id":104411,"user_name":"MZC","can_delete":false,"product_type":"c1","uid":1399853,"ip_address":"","ucode":"46278027D522FB","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/2d/226a3631.jpg","comment_is_top":false,"comment_ctime":1560747268,"is_pvip":false,"replies":[{"id":"37856","content":"如果是长时间自旋，消耗的性能大于用户态和内核态的切换。尽量减小锁代码块中执行的时间，短时间的CAS要比用户态和内核态的切换要划算。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560819865,"ip_address":"","comment_id":104411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560747268","product_id":100028001,"comment_content":"老师  轻量级锁的自旋操作 有点不太明白  自旋的话会占用CPU  如果不自旋的话就是频繁的切换用户态到内核态  是切换后者的开销比自旋大吗   那1.7之后取消了设置自旋的参数 交给jvm来控制的话  我们该怎么去优化这个项呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454264,"discussion_content":"如果是长时间自旋，消耗的性能大于用户态和内核态的切换。尽量减小锁代码块中执行的时间，短时间的CAS要比用户态和内核态的切换要划算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560819865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104231,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1560693561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560693561","product_id":100028001,"comment_content":"第一个方法持有的是对象锁，第二个方法持有的是类锁","like_count":0},{"had_liked":false,"id":104119,"user_name":"powell","can_delete":false,"product_type":"c1","uid":1100292,"ip_address":"","ucode":"5C1B42EF6AE13F","user_header":"","comment_is_top":false,"comment_ctime":1560656502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560656502","product_id":100028001,"comment_content":"java1.8后及以后，  concurrenthashmap抛弃了分段锁，直接node加锁，node链表在 size超过默认8后改成红黑树","like_count":0},{"had_liked":false,"id":104057,"user_name":"Alpha","can_delete":false,"product_type":"c1","uid":1001861,"ip_address":"","ucode":"60CA15A25EC796","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","comment_is_top":false,"comment_ctime":1560606446,"is_pvip":false,"replies":[{"id":"37651","content":"你好，文末是轻量级锁使用了自旋锁来避免线程用户态与内核态的频繁切换。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560648874,"ip_address":"","comment_id":104057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560606446","product_id":100028001,"comment_content":"文中流程图里，自旋锁是在获取轻量级锁之后进行的；而文末总结里说 “偏向锁还使用了自旋锁来避免线程用户态与内核态的频繁切换…”。有点迷茫，这不是矛盾吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454106,"discussion_content":"你好，文末是轻量级锁使用了自旋锁来避免线程用户态与内核态的频繁切换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560648874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103992,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1560584373,"is_pvip":false,"replies":[{"id":"37654","content":"偏向锁消除是有触发条件的，在有一定竞争的情况下，会消除偏向锁，升级为轻量级锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560649736,"ip_address":"","comment_id":103992,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560584373","product_id":100028001,"comment_content":"老师请问一下, 所谓的释放偏向锁是不是就是把是否偏向锁的标记位改成0? 为什么不在释放锁的时候把原来的线程ID一并擦除呢?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454083,"discussion_content":"偏向锁消除是有触发条件的，在有一定竞争的情况下，会消除偏向锁，升级为轻量级锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560649736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103886,"user_name":"Only now","can_delete":false,"product_type":"c1","uid":1038574,"ip_address":"","ucode":"C617473A03AE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","comment_is_top":false,"comment_ctime":1560559986,"is_pvip":false,"replies":[{"id":"37657","content":"即使JVM运行时编译优化偏向锁，但这也是需要一个过程的。在一些按时抢购的场景中，我们对系统的提前预热，可以使用这个禁用。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560650377,"ip_address":"","comment_id":103886,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560559986","product_id":100028001,"comment_content":"关于偏向锁，hotsport文档说了，偏向锁被撤销一定次数后，该类对象就会禁用偏向锁了，按照这个说法，jvm会在运行时自我修复偏向锁额外的消耗了，那么请问老师，显式关闭jvm偏向锁来提高性能是有效且必要的吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454039,"discussion_content":"即使JVM运行时编译优化偏向锁，但这也是需要一个过程的。在一些按时抢购的场景中，我们对系统的提前预热，可以使用这个禁用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560650377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103864,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1560555010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560555010","product_id":100028001,"comment_content":"静态方法属于类，monitor肯定是加在类上的，所有调用该方法的都抢这一把锁，普通方法是加载对象上的。子类重写了自类方法不加同步关键字就没同步效果。","like_count":0},{"had_liked":false,"id":103859,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1560552962,"is_pvip":false,"replies":[{"id":"37659","content":"正确","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1560650500,"ip_address":"","comment_id":103859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560552962","product_id":100028001,"comment_content":"静态方法加锁实际上相当于在class上加同步锁了吧","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454026,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560650500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}