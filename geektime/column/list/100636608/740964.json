{"id":740964,"title":"练习：B- 树","content":"\n<p><strong>6.14</strong> 假设在一棵三层树中，总共可以在内存中保存 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" alt=\"a\" inline-img=\"true\" /> 条链接。每个页中可以保存 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01884.gif\" alt=\"b\\sim2b\" inline-img=\"true\" /> 条指向内部结点的链接和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01885.gif\" alt=\"c\\sim2c\" inline-img=\"true\" /> 条指向外部结点中的链接。在这样一棵树中最多可以含有多少个项（作为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" alt=\"a\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00806.gif\" alt=\"b\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00823.gif\" alt=\"c\" inline-img=\"true\" /> 的函数）？</p>\n<p><strong>6.15</strong> 开发一个 <code>Page</code> 的实现，将 B- 树的结点表示为一个 <code>BinarySearchST</code> 类的对象。</p>\n<p><strong>6.16</strong> 扩展 <code>BTreeSET</code> 来实现能够关联键和值的 <code>BTreeST</code> 类，并完整支持有序符号表 API，包括 <code>min()</code>、<code>max()</code>、<code>floor()</code>、<code>ceiling()</code>、<code>deleteMin()</code>、<code>deleteMax()</code>、<code>select()</code>、<code>rank()</code> 方法以及接受两个参数的 <code>size()</code> 和 <code>get()</code> 方法。</p>\n<p><strong>6.17</strong> 编写一个程序，使用 StdDraw 将 B- 树的生长过程可视化，如同正文描述的方式一样。</p>\n<p><strong>6.18</strong> 在一个有缓存的典型系统中，估计对 B- 树的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01304.gif\" alt=\"S\" inline-img=\"true\" /> 次随机查找中，每次查找的平均探查次数。缓存可以将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00850.gif\" alt=\"T\" inline-img=\"true\" /> 个最近访问的页保存在内存中（因此无需探查）。假设 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01304.gif\" alt=\"S\" inline-img=\"true\" /> 远大于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00850.gif\" alt=\"T\" inline-img=\"true\" />。</p>\n<p><strong>6.19</strong> <strong>网络搜索</strong>。开发一个 <code>Page</code> 类的实现，为了索引网页，用 B- 树的结点表示网页中的文本。用一个文件表示搜索的关键字。从标准输入接受被索引的网页。为了控制规模，接受命令行参数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01886.gif\" alt=\"m\" inline-img=\"true\" /> 并将内部结点的数量限制在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01887.gif\" alt=\"10^m\" inline-img=\"true\" /> 内。（在使用较大的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01886.gif\" alt=\"m\" inline-img=\"true\" /> 前请联系系统管理员。）使用一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01886.gif\" alt=\"m\" inline-img=\"true\" /> 位的数字来表示内部结点。例如，当 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01886.gif\" alt=\"m\" inline-img=\"true\" /> 为 4 时，结点名可以是 <code>BTreeNode0000</code>、<code>BTreeNode0001</code>、<code>BTreeNode0002</code> 等。在页中保存成对的字符串。向 API 中添加一个 <code>close()</code> 操作来排序并写入数据。为了测试实现，尝试在你的学校的网站上搜索你和朋友的名字。</p><!-- [[[read_end]]] -->\n<p><strong>6.20</strong> B*- <strong>树</strong>。在 B- 树中启发式地分裂兄弟结点：当某个结点含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 个条目并需要分裂时，将它和它的一个兄弟结点合并。如果该兄弟结点只含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 个条目且 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01888.gif\" alt=\"k&lt;M-1\" inline-img=\"true\" />，可以重新分配并使得两者都只含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01889.gif\" alt=\"(M+k)/2\" inline-img=\"true\" /> 个条目。否则，我们创建一个新结点并使 3 个结点中都只含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01890.gif\" alt=\"2M/3\" inline-img=\"true\" /> 个条目。同时，我们允许根结点保存 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01891.gif\" alt=\"4M/3\" inline-img=\"true\" /> 个条目，并在它饱和时将它分裂并创建一个只含有两个条目的新根结点。找出在含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 阶 B*- 树中每次查找或插入所需的探查数的上下界限。将你的结果和 B- 树的相应上下界（请见命题 B）进行比较。实现 <strong>B* 树</strong>中的插入<strong>操作</strong>。</p>\n<p><strong>6.21</strong> 编写一段程序，计算在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 次随机插入所构造的一棵 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 阶 B- 树中外部页的平均数量。用合理的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 值运行你的程序。</p>\n<p><strong>6.22</strong> 如果你的系统支持虚拟内存，设计并用实验比较 B- 树和二分查找在一张庞大的符号表中的随机查找性能。</p>\n<p><strong>6.23</strong> 对于你为练习 6.15 给出的保存在内存中的 <code>Page</code> 的实现，用实验确定能够使 B- 树在一张庞大的符号表中的使随机查找操作速度最快的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 值。特别注意 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 为 <code>100</code> 的倍数的情况。</p>\n<p><strong>6.24</strong> 运行实验比较保存在内存中的 B- 树（使用练习 6.23 中确定的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 值）、线性探测散列法和红黑树在一张庞大的符号表中的随机查找用时。</p>\n","comments":[]}