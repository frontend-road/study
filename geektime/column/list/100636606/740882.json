{"id":740882,"title":"第 11 章 Web 开发进阶(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>Spring MVC 中实现 AOP 与异常处理的方式</li>\n<li>Spring Boot 内嵌 Web 容器的配置方法</li>\n<li>分布式 Session 的实现方案与 Spring Session 的基本用法</li>\n<li>WebFlux 及 WebClient 的基本用法</li>\n</ul>\n</blockquote>\n<p>开发 Web 项目过程中除了完成基本的需求，总会有些非功能性的需求，例如：统一用日志记录所有的请求；使用一个集群对外提供服务时，要在集群中保持会话状态；使用 HTTP/2 提供更安全高效的服务，等等。基于 Spring 提供的一系列框架能够满足我们项目中的各种需求吗？在这一章里就让我们一起来了解一下。</p>\n<h2 id=\"nav_point_173\">11.1　在 Spring MVC 中实现 AOP</h2>\n<p>在第 3 章中，我们大致了解了 AOP 相关的知识，以及如何在基于 Spring Framework 的项目中开发自己的 AOP 代码，那么在一个 Web 项目里，又该怎么通过 AOP 实现一些通用的功能呢？最直观的做法是参考第 3 章介绍的内容，直接拦截 <code>@Controller</code> 类里的方法，但这样做可能会丢失 HTTP 请求中的部分细节（比如，假设方法的参数里没有 <code>HttpServletRequest</code>，就无法在 AOP 里拿到请求）。Spring MVC 自然也考虑到了 Web 项目中存在类似的需求，提供了解决方案。</p>\n<h3 id=\"nav_point_174\">11.1.1　使用 <code>HandlerInterceptor</code> 实现 AOP</h3>\n<p>Spring MVC 的 <code>HandlerInterceptor</code> 接口为我们定义了几个拦截的切入点：</p>\n<ul>\n<li><code>preHandle()</code>，在处理器开始处理前介入，类似于带有 <code>@Before</code> 注解的前置通知。返回 <code>true</code> 表示可以继续处理，返回 <code>false</code> 则会中断后续的处理；</li>\n<li><code>postHandle()</code>，在处理器处理结束但尚未进行视图呈现时介入，可以修改 <code>ModelMap</code> 或者 <code>ModelAndView</code> 里的内容；</li>\n<li><code>afterCompletion()</code>，在完成视图呈现后介入，可以用来做些资源清理的工作。</li>\n</ul>\n<p>这个接口从 2003 年就出现在 Spring MVC 里了，不过随着 Java 版本的发展，接口的定义虽然没有变化，但增加了默认实现，省去了实现类继承 <code>HandlerInterceptorAdapter</code> 的麻烦：</p>\n<pre class=\"code-rows\"><code>public interface HandlerInterceptor {\n    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        return true;\n    }\n\n    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n        @Nullable ModelAndView modelAndView)throws Exception {\n    }\n\n    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n        @Nullable Exception ex) throws Exception {\n    }\n}</code></pre>\n<p>对于 Servlet 3.0 后增加的异步请求，请求开始处理后就返回了，真正的处理逻辑在另一个线程里继续，我们还拿不到结果，正因如此，<code>DispatcherServlet</code> 并不会调用 <code>postHandler()</code> 和 <code>afterCompletion()</code>。这时可以用 <code>AsyncHandlerInterceptor</code>，启动处理后会调用 <code>afterConcurrentHandlingStarted()</code>，待处理结束又会分发回 Servlet 容器里，调用 <code>preHandle()</code>、<code>postHandle()</code> 和 <code>afterCompletion()</code>。在这几个方法里，我们该怎么区分请求到底是同步的还是异步的呢？Servlet 3.0 自然也提供了判断方法：调用 <code>ServletRequest.getDispatcherType()</code>，根据返回的枚举值判断。</p><!-- [[[read_end]]] -->\n<p>日志打印、认证鉴权等功能是 AOP 的常见应用场景，通过通用的切面为代码增加特定能力，二进制奶茶店的系统自然也有这样的需求，让我们来看看该如何实现。</p>\n<blockquote>\n<p><strong>需求描述</strong>　每个顾客在店里看了什么，做了什么；店员又相应地执行了哪些操作……经营需要分析很多定量信息来改进店铺的运营情况。俗话说，巧妇难为无米之炊，没有数据如何支撑后面的分析？二进制奶茶店的程序自然也需要具备这个功能。另外，如果以后要上市，除了财务报表，总要有些能给四大会计事务所做审计的东西。</p>\n</blockquote>\n<p>日志是程序的重要组成部分，除了能帮我们了解程序在做什么，更重要的是在生产系统出问题时能够辅助我们定位原因，毕竟我们没有办法在线上轻松地调试，所以有清晰的日志是很有必要的。要实现上面提到的审计，可以在每个请求的处理逻辑里加上一段日志，但这样做显然费时费力，还容易遗漏信息，用 AOP 来做再合适不过了。</p>\n<p>用来做审计的摘要日志一般最好是结构化的，方便后续程序做处理。我们要记录不少信息，所以写一个 <code>LogDetails</code> 类来保存具体的内容，如代码示例 11-1 所示。<span class=\"comment-number\">1</span></p>\n\n<blockquote>\n<p><strong>代码示例 11-1</strong>　存储摘要日志具体信息的 <code>LogDetails</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Getter\n@Setter\npublic class LogDetails {\n    private long startTime; // 开始处理的时间\n    private long processTime; // 结束处理的时间\n    private long endTime; // 完成视图呈现的时间\n    private int code; // 返回的HTTP响应码\n    private String handler; // 具体的处理器\n    private String method; // 请求的HTTP方法\n    private String uri; // 请求的URI\n    private String remoteAddr; // 发起请求的对端地址\n    private String exception; // 发生的异常类\n    private String user; // 登录的用户信息\n}</code></pre>\n<p>这里暂时只考虑同步请求，所以整个请求的处理是在一个线程里完成的，可以通过 <code>ThreadLocal</code> 在方法间传递 <code>LogDetails</code>。在 <code>preHandle()</code> 中对 <code>ThreadLocal</code> 的内容做了初始化，记录了开始时间、请求来源、访问的 URI 和方法，还有具体的处理器，如果是 <code>HandlerMethod</code>，再找出详细的类和方法名。具体如代码示例 11-2 所示。</p>\n<blockquote>\n<p><strong>代码示例 11-2</strong>　日志拦截器的代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class LogHandlerInterceptor implements HandlerInterceptor {\n    private ThreadLocal&lt;LogDetails&gt; logDetails = new ThreadLocal&lt;&gt;();\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,\n                             Object handler) throws Exception {\n        LogDetails details = new LogDetails();\n        logDetails.set(details);\n        details.setStartTime(System.currentTimeMillis());\n        details.setRemoteAddr(StringUtils.defaultIfBlank(request.getRemoteAddr(), \"-\"));\n        details.setUri(StringUtils.defaultIfBlank(request.getRequestURI(), \"-\"));\n        if (handler instanceof HandlerMethod) {\n            HandlerMethod hm = (HandlerMethod) handler;\n            details.setHandler(hm.getBeanType().getSimpleName() + \".\" + hm.getMethod().getName() + \"()\");\n        } else {\n            details.setHandler(handler.getClass().getSimpleName());\n        }\n        details.setMethod(request.getMethod());\n        return true;\n    }\n    // 省略其他代码\n}</code></pre>\n<p><code>postHandle()</code> 记录了方法处理完成的时间。<code>afterCompletion()</code> 中记录视图呈现完成的时间，如果处理过程中抛出了异常，记录异常名，此外还有返回的 HTTP 响应码和当前登录的用户信息。最后，打印日志，通常我们都会选择将摘要日志输出到单独的日志文件里，具体的配置方法可以参考对应日志框架的文档。这两个方法的代码如代码示例 11-3 所示。</p>\n<blockquote>\n<p><strong>代码示例 11-3</strong>　<code>LogHandlerInterceptor</code> 中的 <code>postHandle()</code> 和 <code>afterCompletion()</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class LogHandlerInterceptor implements HandlerInterceptor {\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response,\n                           Object handler, ModelAndView modelAndView) throws Exception {\n        LogDetails details = logDetails.get();\n        if (details != null) {\n            details.setProcessTime(System.currentTimeMillis());\n        }\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n                                Object handler, Exception ex) throws Exception {\n        LogDetails details = logDetails.get();\n        if (details != null) {\n            details.setEndTime(System.currentTimeMillis());\n            details.setException(ex == null ? \"-\" : ex.getClass().getSimpleName());\n            details.setCode(response.getStatus());\n            details.setUser(\"-\");\n            if (isAuthenticated() &amp;&amp; isUser()) {\n                Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n                User user = (User) authentication.getPrincipal();\n                details.setUser(StringUtils.defaultIfBlank(user.getUsername(), \"-\"));\n            }\n            printLog(details);\n        }\n        logDetails.remove();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>代码示例 11-3 只是打印日志的主逻辑，其中用到了好几个辅助方法——判断用户是否经过认证的 <code>isAuthenticated()</code>，判断用户认证信息是否是 <code>User</code> 类型的 <code>isUser()</code>，只有 <code>User</code> 类型的才可以提取信息，还有通过 SLF4J 的 <code>Logger</code> 打印日志的 <code>printLog()</code>。这几个方法的实现如代码示例 11-4 所示。</p>\n<blockquote>\n<p><strong>代码示例 11-4</strong>　<code>afterCompletion()</code> 中用到的辅助方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class LogHandlerInterceptor implements HandlerInterceptor {\n    private boolean isAuthenticated() {\n        return SecurityContextHolder.getContext() != null &amp;&amp;\n                SecurityContextHolder.getContext().getAuthentication() != null &amp;&amp;\n                SecurityContextHolder.getContext().getAuthentication().isAuthenticated();\n    }\n\n    private boolean isUser() {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        return authentication.getPrincipal() != null\n             &amp;&amp; authentication.getPrincipal() instanceof User;\n    }\n\n    private void printLog(LogDetails details) {\n        log.info(\"{},{},{},{},{},{},{},{}ms,{}ms\",\n            details.getRemoteAddr(), details.getMethod(), details.getUri(),\n            details.getHandler(), details.getCode(), details.getException(), details.getUser(),\n            details.getEndTime() - details.getStartTime(), // 总时间\n            details.getProcessTime() - details.getStartTime()); // 处理时间\n    }\n\n    // 省略其他代码\n}</code></pre>\n<p>完成了代码的开发，最后就是配置 Spring MVC，让它知道对哪些请求进行拦截。此处需要让配置类实现 <code>WebMvcConfigurer</code> 接口，但不要在配置类上添加 <code>@EnableWebMvc</code> 注解，我们需要保留 Spring Boot 的自动配置。只需像代码示例 11-5 那样，简单修改一下 <code>BinaryTeaApplication</code> 就能完成配置了。添加完拦截器后通过 <code>addPathPatterns()</code> 和 <code>excludePathPatterns()</code> 能方便地设置想要拦截和排除的路径。</p>\n<blockquote>\n<p><strong>代码示例 11-5</strong>　修改后的 <code>BinaryTeaApplication</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\npublic class BinaryTeaApplication implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(logHandlerInterceptor())\n                 .addPathPatterns(\"/**\")\n                 .excludePathPatterns(\"/static/**\");\n    }\n\n    @Bean\n    public LogHandlerInterceptor logHandlerInterceptor() {\n        return new LogHandlerInterceptor();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>在程序运行后，每接收一个请求，都能在日志里看到类似下面的内容，根据日志就能得知谁在具体做什么。例如，下面这个请求就是 <code>LiLei</code> 在本地发起的 <code>POST</code> 请求，访问 <code>/order</code>，具体由 <code>OrderController</code> 类的 <code>createNewOrder()</code> 方法处理，成功返回了 <code>201 Created</code>，没有异常，整个处理过程耗时 39 毫秒，方法处理时间为 38 毫秒：</p>\n<pre class=\"code-rows\"><code>2022-03-17 21:50:13.801 INFO 65019 --- [nio-8080-exec-7] l.s.b.support.log.LogHandlerInterceptor :\n127.0.0.1,POST,/order,OrderController.createNewOrder(),201,-,LiLei,39ms,38ms</code></pre>\n<h3 id=\"nav_point_175\">11.1.2　完善异常处理逻辑</h3>\n<p>在正常的代码开发过程中，我们无时无刻都会提醒自己，要注意处理异常。有些特定的异常我们需要自己捕获并做针对性的处理，而有些则让它抛到上层，将这些工作交给上层。到了最外层，建议再放一个 try-catch 的代码块兜底，以免有什么意料之外的异常。</p>\n<p>在 Spring MVC 中，框架还提供了专门的异常处理器，本节就让我们一起来了解一下 <code>@ExceptionHandler</code> 的用法。</p>\n<ol>\n<li><p><strong>在单个控制器类中使用 @ExceptionHandler</strong></p>\n<p>在 <code>@Controller</code> 类中，可以定义一个带有 <code>@ExceptionHandler</code> 注解的方法，处理本类中其他的控制器方法抛出的异常。为了能精准地匹配想要处理的异常，可以将异常类定义在注解里，也可以将其定义在方法的参数列表里，就像下面这样：</p>\n<pre class=\"code-rows\"><code>@ExceptionHandler\npublic String handleExceptionA(IOException e) {\n  ...\n}\n\n@ExceptionHandler()\npublic String handleExceptionB(IOException e) {\n  ...\n}</code></pre>\n<p>这里的方法定义非常灵活，与 9.2.2 节中的请求处理方法定义有异曲同工之处。在参数方面，除了上面提到的可以传入具体抛出的异常，还可以有其他的类型，例如表 11-1 里列出的几个。</p>\n<p><strong>表 11-1　<code>@ExceptionHandler</code> 方法可以接受的部分参数类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数类型</th><th>说明</th></tr><tr><td><code>WebRequest</code>、<code>NativeWebRequest</code> 与 <code>ServletRequest</code></td><td>具体的请求信息</td></tr><tr><td><code>ServletResponse</code>、<code>OutputStream</code>、<code>Writer</code></td><td>要返回的应答内容，后两个则可以直接输出应答的正文</td></tr><tr><td><code>HttpSession</code></td><td>当前的会话信息</td></tr><tr><td><code>HandlerMethod</code></td><td>具体处理请求的处理器方法，就像代码示例 11-2 中的那样</td></tr><tr><td><code>HttpMethod</code></td><td>当前请求的 HTTP 方法</td></tr><tr><td><code>Principal</code></td><td>当前登录的用户信息</td></tr><tr><td><code>@SessionAttribute</code> 与 <code>@RequestAttribute</code></td><td>带了这两个注解的参数，会对应到会话或请求中的属性</td></tr><tr><td><code>Map</code>、<code>Model</code> 与 <code>ModelMap</code></td><td>如果 <code>@ExceptionHandler</code> 方法最后要呈现具体的视图，可以用这些参数来传递视图所需的信息（注意这里不是请求处理方法的模型）</td></tr></table>\n\n<p>方法的返回值类型也是一样的，可以有多种类型选择，例如表 11-2 中的那些。</p>\n<p><strong>表 11-2　<code>@ExceptionHandler</code> 方法可以返回的部分类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>返回值类型</th><th>说明</th></tr><tr><td><code>@ResponseBody</code></td><td>返回的对象直接由 <code>HttpMessageConverter</code> 转换为应答的正文</td></tr><tr><td><code>HttpEntity&lt;B&gt;</code> 与 <code>ResponseEntity&lt;B&gt;</code></td><td>返回完整的应答，其中包含 HTTP 头与正文（<code>B</code> 类型的对象由 <code>HttpMessageConverter</code> 转换为正文）</td></tr><tr><td><code>String</code>、<code>View</code> 与 <code>ModelAndView</code></td><td>字符串是视图名，也可以直接返回 View 视图对象，<code>ModelAndView</code> 中既包含呈现视图用的模型，也有视图</td></tr><tr><td><code>Map</code> 与 <code>Model</code></td><td>呈现视图所需要的模型，视图名会由 <code>RequestToViewNameTranslator</code> 根据请求进行推测</td></tr><tr><td>空</td><td>如果方法的参数中有应答相关的参数，或者控制器通过了 <code>ETag</code> 和 <code>lastModified</code> 时间戳校验，空返回表示在方法里已经完成了应答的处理；否则空返回就代表 <code>REST</code> 请求无响应正文，<code>HTML</code> 请求使用默认视图名</td></tr><tr><td>其他返回值</td><td>非基础类型的返回值会作为模型的一部分加入视图模型中</td></tr></table>\n\n<p>如果不用 <code>HttpEntity&lt;B&gt;</code> 和 <code>ResponseEntity&lt;B&gt;</code>，给方法加上 <code>@ResponseStatus</code> 注解，也可以直接指定请求返回时的 HTTP 响应码，默认的响应码是 <code>500 Internal Server Error</code>。</p>\n<p>接下来，让我们看看如何通过异常处理的功能为二进制奶茶店优化一下用户体验。</p>\n<blockquote>\n<p><strong>需求描述</strong>　店铺在每天开门前会做准备工作。如果在尚未准备就绪前，二进制奶茶店的客户端就发来下单请求，那会让顾客等待很久。所以在开门前店铺不接受下单，要拒绝此时的各种订单类请求，给顾客一个友好的说明。</p>\n</blockquote>\n<p>先来拆解一下这个需求：</p>\n<ul>\n<li>店里的准备工作没完成，不接受下单请求；</li>\n<li>给顾客一个友好的说明。</li>\n</ul>\n<p>对于第一个需求，我们可以采用 11.1.1 中介绍的拦截器来实现。由于只是拦截客户端发来的订单请求，所以要做些简单的判断。判断准备工作是否就绪就用配置文件中的 <code>binarytea.ready</code> 配置，具体如代码示例 11-6 所示<span class=\"comment-number\">2</span>。其中，浏览器访问时会要求返回 <code>text/html</code> 格式的内容，所以除此之外的请求都要检查 <code>binarytea.ready</code> 是否为 <code>true</code>，如果尚未就绪就抛出 <code>ShopNotReadyException</code>。</p>\n<blockquote>\n<p><strong>代码示例 11-6</strong>　判断准备工作是否就绪的 <code>ReadyStateCheckHandlerInterceptor</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class ReadyStateCheckHandlerInterceptor implements HandlerInterceptor {\n    @Autowired(required = false)\n    private Optional&lt;BinaryTeaProperties&gt; binaryTeaProperties;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,\n                             Object handler) throws Exception {\n        if (!MediaType.TEXT_HTML_VALUE.equalsIgnoreCase(request.getHeader(HttpHeaders.ACCEPT))) {\n            boolean isReady = binaryTeaProperties.orElse(new BinaryTeaProperties()).isReady();\n            if (!isReady) {\n                log.debug(\"Shop is NOT ready!\");\n                throw new ShopNotReadyException(\"NOT Ready\");\n            }\n        }\n        log.debug(\"Shop is ready, continue.\");\n        return true;\n    }\n}</code></pre>\n<p>这个拦截器只拦截 <code>/order</code> 及其目录下的请求，所以在配置 <code>InterceptorRegistry</code> 时只需要这个路径就好了，简单修改一下 <code>BinaryTeaApplication</code>，如代码示例 11-7 所示。</p>\n<blockquote>\n<p><strong>代码示例 11-7</strong>　增加了 <code>ReadyStateCheckHandlerInterceptor</code> 的配置类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\npublic class BinaryTeaApplication implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(logHandlerInterceptor())\n                 .addPathPatterns(\"/**\")\n                 .excludePathPatterns(\"/static/**\");\n        registry.addInterceptor(readyStateCheckHandlerInterceptor())\n                 .addPathPatterns(\"/order\", \"/order/**\");\n    }\n\n    @Bean\n    public ReadyStateCheckHandlerInterceptor readyStateCheckHandlerInterceptor() {\n        return new ReadyStateCheckHandlerInterceptor();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>现在只要 <code>application.properties</code> 中的 <code>binarytea.ready=false</code>，客户端访问 <code>/order</code> 时就会抛出异常。那么如何返回友好的提示呢？这时就该 <code>@ExceptionHandler</code> 出场了，在 <code>OrderController</code> 中增加一个 <code>handleException()</code> 方法，让它专门处理 <code>ShopNotReadyException</code>，将返回的 HTTP 响应码设置为 <code>403 Forbidden</code>，正文是一段 JSON 消息，就像代码示例 11-8 那样。</p>\n<blockquote>\n<p><strong>代码示例 11-8</strong>　<code>OrderController</code> 中的 <code>handleException()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @ExceptionHandler\n    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleException(ShopNotReadyException e) {\n        ResponseEntity&lt;Map&lt;String, String&gt;&gt; entity = ResponseEntity.status(HttpStatus.FORBIDDEN)\n                .contentType(MediaType.APPLICATION_JSON)\n                .body(Collections.singletonMap(\"message\",\n                        \"Binarytea is NOT ready yet. Please come later.\"));\n        log.warn(\"NOT ready yet! Can NOT accept requests.\");\n        return entity;\n    }\n\n    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)\n    @ResponseBody\n    public List&lt;Order&gt; listOrders() {\n        return orderService.getAllOrders();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>简单用 curl 命令来代替客户端发起一个请求，只要尚未准备就绪就会看到类似下面这样的输出：</p>\n<pre class=\"code-rows\"><code>▸ curl -v -H \"Accept: application/json\" -u LiLei:binarytea http://localhost:8080/order\n&gt; 省略内容\n&gt;\n&lt; HTTP/1.1 403\n&lt; 省略内容\n{\"message\":\"Binarytea is NOT ready yet. Please come later.\"}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>全局适用的@ExceptionHandler</strong></p>\n<p>针对有共性的异常处理逻辑，如果在每个 <code>@Controller</code> 类里都要写上一个 <code>handleException()</code> 方法，哪怕是内部逻辑都剥离到公共类里也是无法让人接受的。其实，我们完全可以将这个带有 <code>@ExceptionHandler</code> 的方法完整地放到一个公共的地方，让它对我们所期望的控制器都生效。<code>@ControllerAdvice</code> 就是起这个作用的 <span class=\"comment-number\">3</span>，正如名字中的 Advice 所暗示的，它的作用跟 AOP 通知类似。如果是针对 <code>REST</code> 接口的，那可以使用 <code>@RestControllerAdvice</code>，它组合了 <code>@ResponseBody</code> 和 <code>@ControllerAdvice</code>。<code>@ControllerAdvice</code> 注解可以接受如表 11-3 所示的一些参数。</p>\n<p><strong>表 11-3　<code>@ControllerAdvice</code> 中的参数</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数</th><th>说明</th></tr><tr><td><code>basePackages</code> 与 <code>basePackageClasses</code></td><td>拦截特定包下的控制器</td></tr><tr><td><code>assignableTypes</code></td><td>拦截特定类型的控制器，这里可以指定父类或者接口</td></tr><tr><td><code>annotations</code></td><td>拦截带有特定注解的控制器</td></tr></table>\n\n<p>假设我们要扩大一下前面提到的店铺准备工作的拦截范围，不仅包括订单相关的请求，连菜单的也要拦下来，可以像下面这样：</p>\n<pre class=\"code-rows\"><code>registry.addInterceptor(readyStateCheckHandlerInterceptor())\n         .addPathPatterns(\"/menu\", \"/menu/**\", \"/order\", \"/order/**\");</code></pre>\n<p>这时最好的做法不是在 <code>MenuController</code> 里复制一个 <code>handleException()</code>，而是将它抽到一个带有 <code>@ControllerAdvice</code> 的类里，就像代码示例 11-9 那样。这个类仅会处理 <code>learning.spring.binarytea.controller</code> 包下的控制器，其他逻辑与代码示例 11-8 中的一样。</p>\n<blockquote>\n<p><strong>代码示例 11-9</strong>　独立出来的 <code>ReadyStateControllerAdvice</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@ControllerAdvice(\"learning.spring.binarytea.controller\")\n@Slf4j\npublic class ReadyStateControllerAdvice {\n    @ExceptionHandler\n    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleException(ShopNotReadyException e) {\n        ResponseEntity&lt;Map&lt;String, String&gt;&gt; entity = ResponseEntity.status(HttpStatus.FORBIDDEN)\n                .contentType(MediaType.APPLICATION_JSON)\n                .body(Collections.singletonMap(\"message\",\n                        \"Binarytea is NOT ready yet. Please come later.\"));\n        log.warn(\"NOT ready yet! Can NOT accept requests.\");\n        return entity;\n    }\n}</code></pre>\n</li>\n</ol>\n\n\n","comments":[]}