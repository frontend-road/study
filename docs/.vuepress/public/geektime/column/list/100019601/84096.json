{"id":84096,"title":"26 | 有哪些招惹麻烦的性能陷阱？","content":"<p>前面，我们讨论了改善代码性能的最基本的办法。接下来，我们讨论一些最佳实践，让我们先从一些容易被忽略的性能陷阱开始。</p><h2>使用性能测试工具</h2><p>今天我们的讲解需要用到一个工具，它就是JMH。JMH是为Java语言或者其他基于JVM的编程语言设计的一个基准测试工具。这一节，我们会使用这个工具来分析一些性能的陷阱。这里我们简单地介绍下，这个工具该怎么使用。</p><p>第一步，使用Maven工具建立一个基准测试项目（需要使用Maven工具）：</p><pre><code>$ mvn archetype:generate \\\n          -DinteractiveMode=false \\\n          -DarchetypeGroupId=org.openjdk.jmh \\\n          -DarchetypeArtifactId=jmh-java-benchmark-archetype \\\n          -DgroupId=com.example \\\n          -DartifactId=myJmh \\\n          -Dversion=1.0\n</code></pre><p>这个命令行，会生成一个myJmh的工程目录，和一个基准测试模板文件（myJmh/src/main/java/com/example/MyBenchmark.java）。通过更改这个测试模板，就可以得到你想要的基准测试了。</p><p>比如，你可以使用后面我们用到的基准测试代码，替换掉模板中的基准测试方法（measureStringApend）。</p><pre><code>package com.example;\n\nimport org.openjdk.jmh.annotations.Benchmark;\n\npublic class MyBenchmark {\n    @Benchmark\n    public String measureStringApend() {\n        String targetString = &quot;&quot;;\n        for (int i = 0; i &lt; 10000; i++) {\n            targetString += &quot;hello&quot;;\n        }\n\n        return targetString;\n    }\n}\n</code></pre><p>第二步，编译基准测试：</p><pre><code>$ cd myJmh\n$ mvn clean install\n</code></pre><p>第三步，运行你的基准测试：</p><pre><code>$ cd myJmh\n$ Java -jar target/benchmarks.jar\n</code></pre><p>稍微等待，基准测试结果就出来了。我们需要关注的是\"Score\"这一栏，它表示的是每秒钟可以执行的基准测试方法的次数。</p><!-- [[[read_end]]] --><pre><code>Benchmark                Mode  Cnt        Score          Error  Units\nMyBenchmark.testMethod  thrpt   25        35.945 ▒       0.694  ops/s\n</code></pre><p>这是JMH工具基本的使用流程，有关这个工具更多的选项和更详细的使用，需要你参考JMH的相关文档。</p><p>下面，我们通过字符串连接操作和哈希值的例子，来谈论一下这个工具要怎么使用，以及对应的性能问题。同时，我们再看看其他影响性能的一些小陷阱，比如内存的泄露、未关闭的资源和遗漏的hashCode。</p><h2>字符串的操作</h2><p>在Java的核心类库里，有三个字符串操作的类，分别问String、StringBuilder和StringBuffer。通过下面的基准测试，我们来了解下这三种不同的字符串操作的性能差异。为了方便，我把JMH测试的数据，标注在每个基准测试的方法注释里了。</p><pre><code>    // JMH throughput benchmark: about 32 operations per second\n    @Benchmark\n    public String measureStringApend() {\n        String targetString = &quot;&quot;;\n        for (int i = 0; i &lt; 10000; i++) {\n            targetString += &quot;hello&quot;;\n        }\n\n        return targetString;\n    }\n</code></pre><pre><code>    // JMH throughput benchmark: about 5,600 operations per second\n    @Benchmark\n    public String measureStringBufferApend() {\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i &lt; 10000; i++) {\n            buffer.append(&quot;hello&quot;);\n        }\n\n        return buffer.toString();\n    }\n</code></pre><pre><code>    // JMH throughput benchmark: about 21,000 operations per second\n    @Benchmark\n    public String measureStringBuilderApend() {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i &lt; 10000; i++) {\n            builder.append(&quot;hello&quot;);\n        }\n\n        return builder.toString();\n    }\n</code></pre><p>对于字符串连接的操作，这个基准测试结果显示，使用StringBuffer的字符串连接操作，比使用String的操作快了近200倍；使用StringBuilder 的字符串连接操作，比使用String的操作快了近700倍。</p><p>String的字符串连接操作为什么慢呢？ 这是因为每一个字符串连接的操作（targetString += “hello”），都需要创建一个新的String对象，然后再销毁，再创建。这种模式对CPU和内存消耗都比较大。</p><p>StringBuilder和StringBuffer为什么快呢？因为StringBuilder和StringBuffer的内部实现，预先分配了一定的内存。字符串操作时，只有预分配内存不足，才会扩展内存，这就大幅度减少了内存分配、拷贝和释放的频率。</p><p>StringBuilder为什么比StringBuffer还要快呢？StringBuffer的字符串操作是多线程安全的，而StringBuilder的操作就不是。如果我们看这两个方法的实现代码，除了线程安全的同步以外，几乎没有差别。</p><pre><code>public final class StringBuffer\n    extends AbstractStringBuilder\n    implements java.io.Serializable, Comparable&lt;StringBuffer&gt;, CharSequence {\n    // snipped\n\n    @Override\n    @HotSpotIntrinsicCandidate\n    public synchronized StringBuffer append(String str) {\n        toStringCache = null;\n        super.append(str);\n        return this;\n    }\n\n    //  snipped\n}\n</code></pre><pre><code>public final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, Comparable&lt;StringBuilder&gt;, CharSequence {\n    // snipped\n\n    @Override\n    @HotSpotIntrinsicCandidate\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n\n    // snipped\n}\n</code></pre><p>JMH的基准测试，并没有涉及到线程同步问题，难道使用synchronized关键字也会有性能损耗吗？</p><p>我们再来看看另外一个基准测试。这个基准测试，使用线程不安全的StringBuilder以及同步的字符串连接，部分模拟了线程安全的StringBuffer.append()方法的实现。为了方便你对比，我把没有使用同步的代码也拷贝在下面。</p><pre><code>    // JMH throughput benchmark: about 21,000 operations per second\n    @Benchmark\n    public String measureStringBuilderApend() {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i &lt; 10000; i++) {\n            builder.append(&quot;hello&quot;);\n        }\n\n        return builder.toString();\n    }\n</code></pre><pre><code>    // JMH throughput benchmark: about 16,000 operations per second\n    @Benchmark\n    public String measureStringBuilderSynchronizedApend() {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i &lt; 10000; i++) {\n            synchronized (this) {\n                builder.append(&quot;hello&quot;);\n            }\n        }\n\n        return builder.toString();\n    }\n</code></pre><p>这个基准测试结果显示，虽然基准测试并没有使用多个线程，但是使用了线程同步的代码比不使用线程同步的代码慢。线程同步，就是StringBuffer比StringBuilder慢的原因之一。</p><p>通过上面的基准测试，我们可以得出这样的结论：</p><ol>\n<li>\n<p>频繁的对象创建、销毁，有损代码的效率；</p>\n</li>\n<li>\n<p>减少内存分配、拷贝、释放的频率，可以提高代码的效率；</p>\n</li>\n<li>\n<p>即使是单线程环境，使用线程同步依然有损代码的效率。</p>\n</li>\n</ol><p>从上面的基准测试结果，是不是可以得出结论，我们应该使用StringBuilder来进行字符串操作呢？我们再来看几个基准测试的例子。</p><p>下面的例子，测试的是常量字符串的连接操作。从测试结果，我们可以看出，使用String的连接操作，要比使用StringBuilder的字符串连接快5万倍，这是一个让人惊讶的性能差异。</p><pre><code>    // JMH throughput benchmark: about 1,440,000,000 operations per second\n    @Benchmark\n    public void measureSimpleStringApend() {\n        for (int i = 0; i &lt; 10000; i++) {\n            String targetString = &quot;Hello, &quot; + &quot;world!&quot;;\n        }\n    }\n</code></pre><pre><code>    // JMH throughput benchmark: about 26,000 operations per second\n    @Benchmark\n    public void measureSimpleStringBuilderApend() {\n        for (int i = 0; i &lt; 10000; i++) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(&quot;hello, &quot;);\n            builder.append(&quot;world!&quot;);\n        }\n    }\n</code></pre><p>这个巨大的差异，主要来自于Java编译器和JVM对字符串处理的优化。\" Hello, \" + \" world! \" 这样的表达式，并没有真正执行字符串连接。编译器会把它处理成一个连接好的常量字符串\"Hello, world!\"。这样，也就不存在反复的对象创建和销毁了，常量字符串的连接显示了超高的效率。</p><p>如果字符串的连接里，出现了变量，编译器和JVM就没有办法进行优化了。这时候，StringBuilder的效率优势才能体现出来。下面的两个基准测试结果，就显示了变量对于字符长连接操作效率的影响。</p><pre><code>    // JMH throughput benchmark: about 9,000 operations per second\n    @Benchmark\n    public void measureVariableStringApend() {\n        for (int i = 0; i &lt; 10000; i++) {\n            String targetString = &quot;Hello, &quot; + getAppendix();\n        }\n    }\n</code></pre><pre><code>    // JMH throughput benchmark: about 26,000 operations per second\n    @Benchmark\n    public void measureVariableStringBuilderApend() {\n        for (int i = 0; i &lt; 10000; i++) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(&quot;hello, &quot;);\n            builder.append(getAppendix());\n        }\n    }\n\n</code></pre><pre><code>    private String getAppendix() {\n       return &quot;World!&quot;;\n    }\n</code></pre><p>通过上面的基准测试，我们可以总结出下面的几条最佳实践：</p><ol>\n<li>\n<p>Java的编译器会优化常量字符串的连接，我们可以放心地把长的字符串换成多行；</p>\n</li>\n<li>\n<p>带有变量的字符串连接，StringBuilder效率更高。如果效率敏感的代码，建议使用StringBuilder。String的连接操作可读性更高，效率不敏感的代码可以使用，比如异常信息、调试日志、使用不频繁的代码；</p>\n</li>\n<li>\n<p>如果涉及大量的字符串操作，使用StringBuilder效率更高；</p>\n</li>\n<li>\n<p>除非有线程安全的需求，不推荐使用线程安全的StringBuffer。</p>\n</li>\n</ol><h2>内存的泄露</h2><p>内存泄漏是C语言的一个大问题。为了更好地管理内存，Java提供了自动的内存管理和垃圾回收机制。但是，Java依然会泄露内存。这种内存泄漏的主要表现是，如果一个对象不再有用处，而且它的引用还没有清零，垃圾回收器就意识不到这个对象需要及时回收，这时候就引发了内存泄露。</p><p>生命周期长的集合，是Java容易发生内存泄漏的地方。比如，可以扩张的静态的集合，或者存活时间长的缓存等。如果不能及时清理掉集合里没有用处的对象，就会造成内存的持续增加，引发内存泄漏问题。</p><p>比如下面这两个例子，就容易发生内存泄露。</p><p>静态的集合：</p><pre><code>static final List&lt;Object&gt;\n         staticCachedObjects = new LinkedList&lt;&gt;();\n\n// snipped\nstaticCachedObjects.add(...);\n</code></pre><p>长寿的缓存：</p><pre><code>final List&lt;Object&gt;\n        longLastingCache = new LinkedList&lt;&gt;();\n\n// snipped\nlongLastingCache.add(...);\n</code></pre><p>解决这个问题的办法通常是使用SoftReference和WeakReference来存储对象的引用，或者主动地定期清理。</p><p>静态的集合：</p><pre><code>static final List&lt;WeakReference&lt;Object&gt;&gt;\n        staticCachedObjects = new LinkedList&lt;&gt;();\n\n// snipped\nstaticCachedObjects.add(...);\n</code></pre><p>长寿的缓存：</p><pre><code>final List&lt;WeakReference&lt;Object&gt;&gt;\n        longLastingCache = new LinkedList&lt;&gt;();\n\n// snipped\nlongLastingCache.add(...);\n</code></pre><p>需要注意的是，缓存的处理是一个复杂的问题，使用SoftReference和WeakReference未必能够满足你的业务需求。更有效的缓存解决方案，依赖于具体的使用场景。</p><h2>未关闭的资源</h2><p>有很多系统资源，需要明确地关闭，要不然，占用的系统资源就不能有效地释放。比如说，数据库连接、套接字连接和 I/O  操作等。原则上，所有实现了Closable接口的对象，都应该调用close()操作；所有需要明确关闭的类，都应该实现Closable接口。</p><p>需要注意的是，close()操作，一定要使用try-finally或者try-with-resource语句。要不然，关闭资源的代码可能很复杂。</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/53/c8f705647492b0faccbfff026eb88d53.png?wh=627*420\" alt=\"\"><br>\n如果一个类需要关闭，但是又没有实现Closable接口，就比较麻烦，比如URLConnection. URLConnection.connect()能够建立连接，该连接需要关闭，但是URLConnection没有实现Closable接口，关闭的办法只能是关闭对应的I/O接口，可是关闭I/O输入和输出接口中的一个，还不能保证整个连接会完全关闭。谨慎的代码，需要把I/O输入和输出都关闭掉，哪怕不需要输入或者输出。但是这样一来，我们的编码负担就会加重。所以最好的方法就是实现Closable接口。</p><p>双向关闭I/O：</p><pre><code>URL url = new URL(&quot;http://www.google.com/&quot;);\nURLConnection conn = url.openConnection();\nconn.connect();\n\ntry (InputStream is = conn.getInputStream()) {\n    // sinnped\n}\n\ntry (OutputStream os = conn.getOutputStream()) {\n    // sinnped\n}\n</code></pre><p>单向关闭I/O：</p><pre><code>URL url = new URL(&quot;http://www.google.com/&quot;);\nURLConnection conn = url.openConnection();\nconn.connect();\n\ntry (InputStream is = conn.getInputStream()) {\n    // sinnped\n}\n\n// The output strean is not close, the connection may be still alive.\n</code></pre><h2>遗漏的hashCode</h2><p>在使用Hashtbale、HashMap、HashSet这样的依赖哈希（hash）值的集合时，有时候我们会忘记要检查产生哈希值的对象，一定要实现hashCode()和equals()这两个方法。缺省的hashCode()实现，返回值是每一个对象都不同的数值。即使是相等的对象，不同的哈希值，使用基于哈希值的集合时，也会被看作不同的对象。这样的行为，可能不符合我们的预期。而且，使用没有实现hashCode()和equals()这两个方法的对象，可能会造成集合的尺寸持续增加，无端地占用内存，甚至会造成内存的泄漏。</p><p>所以，我们使用基于hash的集合时，一定要确保集合里的对象，都正确地实现了hashCode()和equals()这两个方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/82/bf4fd2108a994b6bbfa7845dc65b1d82.jpg?wh=625*1235\" alt=\"\"></p><h2>撞车的哈希值</h2><p>实现hashCode()这个方法的，并没有要求不相等对象的返回值也必须是不相等的。但是如果返回的哈希值不同，对集合的性能就会有比较大的影响。</p><p>下面的两个基准测试结果显示，如果10,000个对象，只有10个不同的哈希值，它的集合运算的性能是令人担忧的。和使用了不用哈希值的实现相比，性能有几百倍的差异。</p><p>这种性能差异，主要是由基于哈希值的集合的实现方式决定的。哈希值如果相同，就要调用其他的方法来识别一个对象。哈希值如果不同，哈希值本身就可以确定一个对象的索引。如果哈希值撞车比例大，这种检索和计算的差距就会很大。</p><pre><code>    // JMH throughput benchmark: about 5,000 operations per second\n    @Benchmark\n    public void measureHashMap() throws IOException {\n        Map&lt;HashedKey, String&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) {\n            map.put(new HashedKey(i), &quot;value&quot;);\n        }\n    }\n\n    private static class HashedKey {\n        final int key;\n\n        HashedKey(int key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) {\n                return true;\n            }\n\n            if (obj instanceof HashedKey) {\n                return key == ((HashedKey)obj).key;\n            }\n\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            return key;\n        }\n    }\n</code></pre><pre><code>    // JMH throughput benchmark: about 9.5 operations per second\n    @Benchmark\n    public void measureCollidedHashMap() throws IOException {\n        Map&lt;CollidedKey, String&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) {\n            map.put(new CollidedKey(i), &quot;value&quot;);\n        }\n    }\n\n    private static class CollidedKey {\n        final int key;\n\n        CollidedKey(int key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) {\n                return true;\n            }\n\n            if (obj instanceof CollidedKey) {\n                return key == ((CollidedKey)obj).key;\n            }\n\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            return key % 10;\n        }\n    }\n</code></pre><h2>小结</h2><p>今天，我们主要讨论了一些容易被忽略的性能陷阱。比如，字符串怎么操作才是高效的；Java常见的内存泄漏；资源关闭的正确方法以及集合的相关性能问题。</p><p>我们虽然使用了Java作为示例，但是像集合和字符串操作这样的性能问题，并不局限于特定的编程语言，你也可以看看你熟悉的编程语言有没有类似的问题。</p><h2>一起来动手</h2><p>这一次的练手题，我们来练习使用JMH工具，分析更多的性能问题。在“撞车的哈希值”这一小节，我们测试了HashMap的put方法，你能不能测试下其他方法以及其他基于哈希值的集合（HashSet，Hashtable）？我们测试的是10,000个对象，只有10个哈希值。如果10,000个对象，有5,000个哈希值，性能影响有多大？</p><p>下面的这段代码，你能够找到它的性能问题吗？</p><pre><code>package com.example;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class UserId {\n    private static final Random random = new Random();\n\n    private final byte[] userId = new byte[32];\n\n    public UserId() {\n        random.nextBytes(userId);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n\n        if (obj instanceof UserId) {\n            return Arrays.equals(this.userId, ((UserId)obj).userId);\n        }\n\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int retVal = 0;\n\n        for (int i = 0; i &lt; userId.length; i++) {\n            retVal += userId[i];\n        }\n\n        return retVal;\n    }\n}\n</code></pre><p>我们前面讨论了下面这段代码的性能问题，你能够使用JMH测试一个你的改进方案带来的效率提升吗？</p><pre><code>import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    /**\n     * Given an array of integers, return indices of the two numbers\n     * such that they add up to a specific target.\n     */\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(&quot;No two sum solution&quot;);\n    }\n}\n\n</code></pre><p>另外，你也可以检查一下你手头的代码，看看有没有踩到类似的坑。如果遇到类似的陷阱，看一看能不能改进。</p><p>容易被忽略的性能陷阱，有很多种。这些大大小小的经验，需要我们日复一日的积累。如果你有这方面的经验，或者看到这方面的技术，请你分享在留言区，我们一起来学习、积累这些经验。</p><p>也欢迎点击“请朋友读”，把这篇文章分享给你的朋友或者同事，一起交流一下。</p><p></p>","neighbors":{"left":{"article_title":"25 | 使用有序的代码，调动异步的事件","id":83897},"right":{"article_title":"27 | 怎么编写可持续发展的代码？","id":84488}},"comments":[{"had_liked":false,"id":96645,"user_name":"熊猫","can_delete":false,"product_type":"c1","uid":1080238,"ip_address":"","ucode":"23C85117A16BEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/7b/ae/66ae403d.jpg","comment_is_top":false,"comment_ctime":1558484027,"is_pvip":false,"replies":[{"id":"34603","content":"可以参考下面的链接。https:&#47;&#47;openjdk.java.net&#47;projects&#47;code-tools&#47;jmh&#47;<br>http:&#47;&#47;tutorials.jenkov.com&#47;java-performance&#47;jmh.html<br>https:&#47;&#47;blog.goyello.com&#47;2017&#47;06&#47;19&#47;testing-code-performance-jmh-tool&#47;<br>https:&#47;&#47;www.baeldung.com&#47;java-microbenchmark-harness<br><br>其中，第一个链接里，还可以深入看一下JMH官方的例子：<br>https:&#47;&#47;hg.openjdk.java.net&#47;code-tools&#47;jmh&#47;file&#47;tip&#47;jmh-samples&#47;src&#47;main&#47;java&#47;org&#47;openjdk&#47;jmh&#47;samples&#47;<br><br>中文的，请参考：<br>http:&#47;&#47;blog.dyngr.com&#47;blog&#47;2016&#47;10&#47;29&#47;introduction-of-jmh&#47;<br>https:&#47;&#47;www.xncoding.com&#47;2018&#47;01&#47;07&#47;java&#47;jmh.html<br>","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1558490690,"ip_address":"","comment_id":96645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23033320507","product_id":100019601,"comment_content":"老师，能推荐JMH快速入门的博客吗？减少大家查找信息成本。","like_count":5,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450951,"discussion_content":"可以参考下面的链接。https://openjdk.java.net/projects/code-tools/jmh/\nhttp://tutorials.jenkov.com/java-performance/jmh.html\nhttps://blog.goyello.com/2017/06/19/testing-code-performance-jmh-tool/\nhttps://www.baeldung.com/java-microbenchmark-harness\n\n其中，第一个链接里，还可以深入看一下JMH官方的例子：\nhttps://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/\n\n中文的，请参考：\nhttp://blog.dyngr.com/blog/2016/10/29/introduction-of-jmh/\nhttps://www.xncoding.com/2018/01/07/java/jmh.html\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558490690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73342,"user_name":"夕夏洛克","can_delete":false,"product_type":"c1","uid":1259439,"ip_address":"","ucode":"603BFB9AE7BC5E","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/af/d72f4cba.jpg","comment_is_top":false,"comment_ctime":1551863565,"is_pvip":false,"replies":[{"id":"26776","content":"首先要点赞动手使用JMH测试代码性能，这就迈开了步子，这一步最难的。<br><br>测试代码什么样的？使用的是文章中的代码吗？数据是每秒执行操作数，越大越好。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1551899442,"ip_address":"","comment_id":73342,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18731732749","product_id":100019601,"comment_content":"老师这是我用jmh 跑出的性能数据 为什么 string的性能是最好的呢<br>MyBenchmark.stringMethod  thrpt   25  15.036 ± 1.045  ops&#47;s<br>MyBenchmark.stringBufferMethod  thrpt   25  7689.300 ± 367.812  ops&#47;s<br>MyBenchmark.stringBuilderMethod  thrpt   25  7690.659 ± 251.793  ops&#47;s","like_count":4,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442032,"discussion_content":"首先要点赞动手使用JMH测试代码性能，这就迈开了步子，这一步最难的。\n\n测试代码什么样的？使用的是文章中的代码吗？数据是每秒执行操作数，越大越好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551899442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73596,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1551935939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436837827","product_id":100019601,"comment_content":"@夕夏洛克 查了下 JMH有四种模式,Throughput是吞吐量,单位时间内处理请求数,越大越好, 注解@BenchmarkMode(Mode.Throughput)可以修改模式 ","like_count":3},{"had_liked":false,"id":352613,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1658811307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658811307","product_id":100019601,"comment_content":"生命周期长的集合，是 Java 容易发生内存泄漏的地方。--记下来","like_count":0},{"had_liked":false,"id":72843,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1551747044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551747044","product_id":100019601,"comment_content":"存在拆箱和装箱的转换问题，比较耗费资源","like_count":0}]}