{"id":481908,"title":"36｜打稳根基：怎么实现一个TCP服务器？（上）","content":"<p>你好，我是Tony Bai。欢迎来到这门课的最后一个部分：实战篇。</p><p>在进入正文之前，我先来说点题外话。去年我读过一本名为<a href=\"https://book.douban.com/subject/26935989/\">《陪孩子走过初中三年》</a>的书，书中作者女儿的初中班主任有一句“名言”：“跟上了！”作者对这句名言的解读是：学习上，她强调孩子们学习的时候不要掉队，意思是一要跟上老师的步子，上课认真听讲，课后老师留的作业要不打折扣地去完成；二也要跟上年级和班级的进度。只要能紧紧地跟上，学习就不会有太大的问题。</p><p>在前面课程的留言区，我也经常用“<strong>跟上了</strong>”作为学习这门课的建议，和我一起同步走到这里的同学，都是践行“跟上了”这句“名言”的典范，从开篇词到现在，你是不是已经感受到了自己在Go语言方面的进步了呢？</p><p>好了，我们言归正传。关于最后一篇写啥，我也想了许久。开篇词中提过，实战篇的职责是带着你走完Go语言学习的“最后一公里”，那究竟什么是“最后一公里呢？该如何理解这最后一公里呢？</p><p>我的理解是，在掌握了前面的Go语言语法的前提下，这“最后一公里”就是<strong>面对一个实际问题的解决思路</strong>。很多语言初学者都有这样一个问题，即便学完了语法，面对一个实际问题时，还是也不知道该从何处着手。</p><p>其实这个事并没有那么难，尤其是程序员这一行，遇到一个实际问题，我们通常使用这个思路：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/2e/94/2e9979276111eac4e55689dfb4de0a94.jpg?wh=1126x586\" alt=\"图片\"></p><p>我们简单解释一下这张图。</p><p>首先是要理解问题。解决实际问题的过程起始于对问题的理解。我们要搞清楚为什么会有这个问题，问题究竟是什么。对于技术人员来说，最终目的是识别出可能要用到的技术点。</p><p>然后我们要对识别出的技术点，做相应的技术预研与储备。怎么做技术预研呢？我们至少要了解技术诞生的背景、技术的原理、技术能解决哪些问题以及不能解决哪些问题，还有技术的优点与不足，等等。当然，如果没有新技术点，可以忽略这一步。</p><p>最后，我们要基于技术预研和储备的结果，进行解决方案的设计与实现，这个是技术人最擅长的。</p><p>那为什么这个解决实际问题的步骤是一个循环呢？这是由问题的难易程度，以及人的认知能力有差别所决定的。如果问题简单或人的认知能力很强，我们可以一次性解决这个实际问题；如果问题复杂或人的认知能力稍弱，那么一个循环可能无法彻底解决这个问题，我们就会再一次进入该循环，直到问题得到完美解决。</p><p>你也看到了，这事儿说起来有些枯燥，那我们就来实践一下。在实战篇的这三讲中，我们就来“走一遍”这个过程。</p><p>那我们选一个什么例子呢？我们还是从 <a href=\"https://go.dev/blog/survey2020-results\">Go官方用户2020调查报告</a>中寻找答案，看看“我用Go在哪些领域开展工作”的调查结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/a4/1dd60015a47425a050142859c14c61a4.png?wh=1048x1242\" alt=\"图片\"></p><p>我们看到，“<strong>Web编程</strong>”和“<strong>网络编程</strong>”分别位列第一名和第四名，我们在09讲的小实战项目中曾接触过简单的Web编程，因此这里，我们选择一个不同于Web编程的网络编程的例子，做为实战篇的实战项目。在实战篇的三讲中，我们就参照这个实际问题解决过程循环，逐步来解决一个网络编程类的实际问题。</p><h3>什么是网络编程</h3><p>什么是网络编程呢？网络编程的范围很大，因为我们熟知的网络是分层的，OSI规定了七层参考模型，而实际上我们使用的主流网络模型实现，是TCP/IP模型，它只有四层：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/26/1339ef73cbd62791byy28821fd5ed926.jpg?wh=1920x1047\" alt=\"图片\"></p><p>通常来说，我们更多关注OSI网络模型中的传输层（四层）与应用层（七层），也就是TCP/IP网络模型中的最上面两层。</p><p>TCP/IP网络模型，实现了两种传输层协议：TCP和UDP。TCP是面向连接的流协议，为通信的两端提供稳定可靠的数据传输服务；而UDP则提供了一种无需建立连接就可以发送数据包的方法。两种协议各有擅长的应用场景。</p><p>我们日常开发中使用最多的是TCP协议。基于TCP协议，我们实现了各种各样的满足用户需求的应用层协议。比如，我们常用的HTTP协议就是应用层协议的一种，而且是使用得最广泛的一种。而基于HTTP的Web编程就是一种针对应用层的网络编程。我们还可以<strong>基于传输层暴露给开发者的编程接口，实现应用层的自定义应用协议</strong>。</p><p>这个传输层暴露给开发者的编程接口，究竟是什么呢？目前各大主流操作系统平台中，最常用的传输层暴露给用户的网络编程接口，就是套接字（socket）。<strong>直接基于socket编程实现应用层通信业务，也是最常见的一种网络编程形式</strong>。</p><p>所以，这一节课，我们就使用一个基于socket网络编程的例子，我们先来看看这个例子对应的实际问题是什么。</p><h2>问题描述</h2><p>我们面临的实际问题是这样的：<strong>实现一个基于TCP的自定义应用层协议的通信服务端</strong>。仅仅这一句话，你可能还不是很清楚，我们展开说明一下。</p><p>我们的输入，是一个基于传输层自定义的应用层协议规范。由于TCP是面向连接的流协议传输机制，数据流本身没有明显的边界，这样定义协议时，就需要自行定义确定边界的方法，因此，基于TCP的自定义应用层协议通常有两种常见的定义模式：</p><ul>\n<li>\n<p><strong>二进制模式：</strong>采用长度字段标识独立数据包的边界。采用这种方式定义的常见协议包括MQTT（物联网最常用的应用层协议之一）、SMPP（短信网关点对点接口协议）等；</p>\n</li>\n<li>\n<p><strong>文本模式</strong>：采用特定分隔符标识流中的数据包的边界，常见的包括HTTP协议等。</p>\n</li>\n</ul><p>相比之下，二进制模式要比文本模式编码更紧凑也更高效，所以我们这个问题中的自定义协议也采用了<strong>二进制模式</strong>，协议规范内容如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/21/70b43197100a790f3a78db50997c1d21.jpg?wh=1980x1080\" alt=\"\"></p><p>关于协议内容的分析，我们放到设计与实现的那一讲中再细说，这里我们再看一下使用这个协议的通信两端的通信流程：</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/1e/bbf6078436ff91207cf6232ce7a66b1e.jpg?wh=1920x1047\" alt=\"图片\"></p><p>我们看到，这是一个典型的“请求/响应”通信模型。连接由客户端发起，建立连接后，客户端发起请求，服务端收到请求后处理并返回响应，就这样一个请求一个响应的进行下去，直到客户端主动断开连接为止。</p><p><strong>而我们的任务，就是实现支持这个协议通信的服务端。</strong></p><p>我们先假设各位小伙伴都没有亲自开发过类似的通信服务器，所以当理解完这个问题后，我们需要识别出解决这一问题可能使用到的技术点。不过这个问题并不复杂，我们可以很容易地识别出其中的技术点。</p><p>首先，前面说过socket是传输层给用户提供的编程接口，我们要进行的网络通信绕不开socket，因此我们首先需要了解socket编程模型。</p><p>其次，一旦通过socket将双方的连接建立后，剩下的就是通过网络I/O操作在两端收发数据了，学习基本网络I/O操作的方法与注意事项也必不可少。</p><p>最后，任何一端准备发送数据或收到数据后都要对数据进行操作，由于TCP是流协议，我们需要了解针对字节的操作。</p><p>按照问题解决循环，一旦识别出技术点，接下来我们要做的就是技术预研与储备。在Go中，字节操作基本上就是byte切片的操作，这些用法我们在第15讲中已经学过了。所以，这一讲，我们就来学习一下<strong>socket编程模型以及网络I/O操作</strong>，为后两讲的设计与实现打稳根基，做好铺垫。</p><h2>TCP Socket编程模型</h2><p>TCP Socket诞生以来，它的编程模型，也就是网络I/O模型已几经演化。网络I/O模型定义的是应用线程与操作系统内核之间的交互行为模式。我们通常用<strong>阻塞（Blocking）</strong>/<strong>非阻塞（Non-Blocking）</strong>来描述网络I/O模型。</p><p>阻塞/非阻塞，是以内核是否等数据全部就绪后，才返回（给发起系统调用的应用线程）来区分的。如果内核一直等到全部数据就绪才返回，这种行为模式就称为<strong>阻塞</strong>。如果内核查看数据就绪状态后，即便没有就绪也立即返回错误（给发起系统调用的应用线程），那么这种行为模式则称为<strong>非阻塞</strong>。</p><p>常用的网络I/O模型包括下面这几种：</p><ul>\n<li><strong>阻塞I/O(Blocking I/O)</strong></li>\n</ul><p>阻塞I/O是最常用的模型，这个模型下应用线程与内核之间的交互行为模式是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/66/70/66e154f76d647a51b45fcfddf4697c70.jpg?wh=1920x1047\" alt=\"图片\"></p><p>我们看到，在<strong>阻塞I/O模型</strong>下，当用户空间应用线程，向操作系统内核发起I/O请求后（一般为操作系统提供的I/O系列系统调用），内核会尝试执行这个I/O操作，并等所有数据就绪后，将数据从内核空间拷贝到用户空间，最后系统调用从内核空间返回。而在这个期间内，用户空间应用线程将阻塞在这个I/O系统调用上，无法进行后续处理，只能等待。</p><p>因此，在这样的模型下，一个线程仅能处理一个网络连接上的数据通信。即便连接上没有数据，线程也只能阻塞在对Socket的读操作上（以等待对端的数据）。虽然这个模型对应用整体来说是低效的，但对开发人员来说，这个模型却是最容易实现和使用的，所以，各大平台在默认情况下都将Socket设置为阻塞的。</p><ul>\n<li><strong>非阻塞I/O（Non-Blocking I/O）</strong></li>\n</ul><p>非阻塞I/O模型下，应用线程与内核之间的交互行为模式是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/b3/4c5e3980f756e03b9ca023185b91b5b3.jpg?wh=1920x1047\" alt=\"图片\"></p><p>和阻塞I/O模型正相反，在<strong>非阻塞模型</strong>下，当用户空间线程向操作系统内核发起I/O请求后，内核会执行这个I/O操作，如果这个时候数据尚未就绪，就会立即将“未就绪”的状态以错误码形式（比如：EAGAIN/EWOULDBLOCK），返回给这次I/O系统调用的发起者。而后者就会根据系统调用的返回状态来决定下一步该怎么做。</p><p>在非阻塞模型下，位于用户空间的I/O请求发起者通常会通过轮询的方式，去一次次发起I/O请求，直到读到所需的数据为止。不过，这样的轮询是对CPU计算资源的极大浪费，因此，非阻塞I/O模型单独应用于实际生产的比例并不高。</p><ul>\n<li><strong>I/O多路复用（I/O Multiplexing）</strong></li>\n</ul><p>为了避免非阻塞I/O模型轮询对计算资源的浪费，同时也考虑到阻塞I/O模型的低效，开发人员首选的网络I/O模型，逐渐变成了建立在内核提供的多路复用函数select/poll等（以及性能更好的epoll等函数）基础上的<strong>I/O多路复用模型</strong>。</p><p>这个模型下，应用线程与内核之间的交互行为模式如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/93/b9/9389908c507b5efea24bf961b1d594b9.jpg?wh=1920x1047\" alt=\"图片\"></p><p>从图中我们看到，在这种模型下，应用线程首先将需要进行I/O操作的Socket，都添加到多路复用函数中（这里以select为例），然后阻塞，等待select系统调用返回。当内核发现有数据到达时，对应的Socket具备了通信条件，这时select函数返回。然后用户线程会针对这个Socket再次发起网络I/O请求，比如一个read操作。由于数据已就绪，这次网络I/O操作将得到预期的操作结果。</p><p>我们看到，相比于阻塞模型一个线程只能处理一个Socket的低效，I/O多路复用模型中，一个应用线程可以同时处理多个Socket。同时，I/O多路复用模型由内核实现可读/可写事件的通知，避免了非阻塞模型中轮询，带来的CPU计算资源浪费的问题。</p><p>目前，主流网络服务器采用的都是“I/O多路复用”模型，有的也结合了多线程。不过，<strong>I/O多路复用</strong>模型在支持更多连接、提升I/O操作效率的同时，也给使用者带来了不小的复杂度，以至于后面出现了许多高性能的I/O多路复用框架，比如：<a href=\"http://libevent.org/\">libevent</a>、<a href=\"http://software.schmorp.de/pkg/libev.html\">libev</a>、<a href=\"https://github.com/libuv/libuv\">libuv</a> 等，以帮助开发者简化开发复杂性，降低心智负担。</p><p>那么，在这三种socket编程模型中，Go语言使用的是哪一种呢？我们继续往下看。</p><h2>Go语言socket编程模型</h2><p>Go语言设计者考虑得更多的是Gopher的开发体验。前面我们也说过，阻塞I/O模型是对开发人员最友好的，也是心智负担最低的模型，而<strong>I/O多路复用</strong>的这种<strong>通过回调割裂执行流</strong>的模型，对开发人员来说还是过于复杂了，于是Go选择了为开发人员提供<strong>阻塞I/O模型</strong>，Gopher只需在Goroutine中以最简单、最易用的<strong>“阻塞I/O模型”</strong>的方式，进行Socket操作就可以了。</p><p>再加上，Go没有使用基于线程的并发模型，而是使用了开销更小的Goroutine作为基本执行单元，这让每个Goroutine处理一个TCP连接成为可能，并且在高并发下依旧表现出色。</p><p>不过，网络I/O操作都是系统调用，Goroutine执行I/O操作的话，一旦阻塞在系统调用上，就会导致M也被阻塞，为了解决这个问题，Go设计者将这个“复杂性”隐藏在Go运行时中，他们在运行时中实现了网络轮询器（netpoller），netpoller的作用，就是只阻塞执行网络I/O操作的Goroutine，但不阻塞执行Goroutine的线程（也就是M）。</p><p>这样一来，对于Go程序的用户层（相对于Go运行时层）来说，它眼中看到的goroutine采用了“阻塞I/O模型”进行网络I/O操作，Socket都是“阻塞”的。</p><p>但实际上，这样的“假象”，是通过Go运行时中的netpoller <strong>I/O多路复用机制</strong>，“模拟”出来的，对应的、真实的底层操作系统Socket，实际上是非阻塞的。只是运行时拦截了针对底层Socket的系统调用返回的错误码，并通过<strong>netpoller</strong> 和Goroutine调度，让Goroutine“阻塞”在用户层所看到的Socket描述符上。</p><p>比如：当用户层针对某个Socket描述符发起<code>read</code>操作时，如果这个Socket对应的连接上还没有数据，运行时就会将这个Socket描述符加入到netpoller中监听，同时发起此次读操作的Goroutine会被挂起。</p><p>直到Go运行时收到这个Socket数据可读的通知，Go运行时才会重新唤醒等待在这个Socket上准备读数据的那个Goroutine。而这个过程，从Goroutine的视角来看，就像是read操作一直阻塞在那个Socket描述符上一样。</p><p>而且，Go语言在网络轮询器（netpoller）中采用了I/O多路复用的模型。考虑到最常见的多路复用系统调用select有比较多的限制，比如：监听Socket的数量有上限（1024）、时间复杂度高，等等，Go运行时选择了在不同操作系统上，使用操作系统各自实现的高性能多路复用函数，比如：Linux上的epoll、Windows上的iocp、FreeBSD/MacOS上的kqueue、Solaris上的event port等，这样可以最大程度提高netpoller的调度和执行性能。</p><p>了解完Go socket编程模型后，接下来，我们就深入到几个常用的基于socket的网络I/O操作中，逐一了解一下这些操作的机制与注意事项。</p><h2>socket监听（listen）与接收连接（accept）</h2><p>socket编程的核心在于服务端，而服务端有着自己一套相对固定的套路：Listen+Accept。在这套固定套路的基础上，我们的服务端程序通常采用一个Goroutine处理一个连接，它的大致结构如下：</p><pre><code class=\"language-plain\"> func handleConn(c net.Conn) {\n     defer c.Close()\n     for {\n         // read from the connection\n         // ... ...\n         // write to the connection\n         //... ...\n     }\n }\n \n func main() {\n     l, err := net.Listen(\"tcp\", \":8888\")\n     if err != nil {\n         fmt.Println(\"listen error:\", err)\n         return\n     }\n \n     for {\n         c, err := l.Accept()\n         if err != nil {\n             fmt.Println(\"accept error:\", err)\n             break\n         }\n         // start a new goroutine to handle\n         // the new connection.\n         go handleConn(c)\n     }\n }\n</code></pre><p>在这个服务端程序中，我们在第12行使用了net包的Listen函数绑定（bind）服务器端口8888，并将它转换为监听状态，Listen返回成功后，这个服务会进入一个循环，并调用net.Listener的Accept方法接收新客户端连接。</p><p>在没有新连接的时候，这个服务会阻塞在Accept调用上，直到有客户端连接上来，Accept方法将返回一个net.Conn实例。通过这个net.Conn，我们可以和新连上的客户端进行通信。这个服务程序启动了一个新Goroutine，并将net.Conn传给这个Goroutine，这样这个Goroutine就专职负责处理与这个客户端的通信了。</p><p>而net.Listen函数很少报错，除非是监听的端口已经被占用，那样程序将输出类似这样的错误：</p><pre><code class=\"language-plain\">bind: address already in use\n</code></pre><p>当服务程序启动成功后，我们可以通过netstat命令，查看端口的监听情况：</p><pre><code class=\"language-plain\">$netstat -an|grep 8888    \ntcp46       0      0  *.8888                 *.*                    LISTEN     \n</code></pre><p>了解了服务端的“套路”后，我们再来看看客户端。</p><h2>向服务端建立TCP连接</h2><p>一旦服务端按照上面的 <code>Listen + Accept</code> 结构成功启动，客户端便可以使用<code>net.Dial</code>或 <code>net.DialTimeout</code> 向服务端发起连接建立的请求：</p><pre><code class=\"language-plain\">conn, err := net.Dial(\"tcp\", \"localhost:8888\")\nconn, err := net.DialTimeout(\"tcp\", \"localhost:8888\", 2 * time.Second)\n</code></pre><p>Dial函数向服务端发起TCP连接，这个函数会一直阻塞，直到连接成功或失败后，才会返回。而DialTimeout带有超时机制，如果连接耗时大于超时时间，这个函数会返回超时错误。 对于客户端来说，连接的建立还可能会遇到几种特殊情形。</p><p><strong>第一种情况：网络不可达或对方服务未启动。</strong></p><p>如果传给 <code>Dial</code>的服务端地址是网络不可达的，或者服务地址中端口对应的服务并没有启动，端口未被监听（Listen），<code>Dial</code> 几乎会立即返回类似这样的错误：</p><pre><code class=\"language-plain\">dial error: dial tcp :8888: getsockopt: connection refused\n</code></pre><p><strong>第二种情况：对方服务的listen backlog队列满。</strong></p><p>当对方服务器很忙，瞬间有大量客户端尝试向服务端建立连接时，服务端可能会出现listen backlog队列满，接收连接（accept）不及时的情况，这就会导致客户端的<code>Dial</code>调用阻塞，直到服务端进行一次accept，从backlog队列中腾出一个槽位，客户端的Dial才会返回成功。</p><p>而且，不同操作系统下backlog队列的长度是不同的，在macOS下，这个默认值如下：</p><pre><code class=\"language-plain\">$sysctl -a|grep kern.ipc.somaxconn\nkern.ipc.somaxconn: 128\n</code></pre><p>在Ubuntu Linux下，backlog队列的长度值与系统中 <code>net.ipv4.tcp_max_syn_backlog</code> 的设置有关。</p><p>那么，极端情况下，如果服务端一直不执行 <code>accept</code> 操作，那么客户端会一直阻塞吗？</p><p>答案是不会！我们看一个实测结果。如果服务端运行在macOS下，那么客户端会阻塞大约1分多钟，才会返回超时错误：</p><pre><code class=\"language-plain\">dial error: dial tcp :8888: getsockopt: operation timed out\n</code></pre><p>而如果服务端运行在Ubuntu上，客户端的 <code>Dial</code> 调用大约在2分多钟后提示超时错误，这个结果也和Linux的系统设置有关。</p><p><strong>第三种情况：若网络延迟较大，Dial将阻塞并超时。</strong></p><p>如果网络延迟较大，TCP连接的建立过程（三次握手）将更加艰难坎坷，会经历各种丢包，时间消耗自然也会更长，这种情况下，<code>Dial</code>函数会阻塞。如果经过长时间阻塞后依旧无法建立连接，那么 <code>Dial</code> 也会返回类似 <code>getsockopt: operation timed out</code> 的错误。</p><p>在连接建立阶段，多数情况下 <code>Dial</code> 是可以满足需求的，即便是阻塞一小会儿也没事。但对于那些需要有严格的连接时间限定的Go应用，如果一定时间内没能成功建立连接，程序可能会需要执行一段“错误”处理逻辑，所以，这种情况下，我们使用 <code>DialTimeout</code> 函数更适合。</p><h2>全双工通信</h2><p>一旦客户端调用Dial成功，我们就在客户端与服务端之间建立起了一条全双工的通信通道。通信双方通过各自获得的Socket，可以在向对方发送数据包的同时，接收来自对方的数据包。下图展示了系统层面对这条全双工通信通道的实现原理：</p><p><img src=\"https://static001.geekbang.org/resource/image/37/b0/370808418c01bf37967cdb505848e3b0.jpg?wh=1920x616\" alt=\"图片\"></p><p>任何一方的操作系统，都会为已建立的连接分配一个发送缓冲区和一个接收缓冲区。</p><p>以客户端为例，客户端会通过成功连接服务端后得到的conn（封装了底层的socket）向服务端发送数据包。这些数据包会先进入到己方的发送缓冲区中，之后，这些数据会被操作系统内核通过网络设备和链路，发到服务端的接收缓冲区中，服务端程序再通过代表客户端连接的conn读取服务端接收缓冲区中的数据，并处理。</p><p>反之，服务端发向客户端的数据包也是先后经过服务端的发送缓冲区、客户端的接收缓冲区，最终到达客户端的应用的。</p><p>理解了这个通信原理，我们再理解下面的Socket操作就容易许多了。</p><h2>Socket读操作</h2><p>连接建立起来后，我们就要在连接上进行读写以完成业务逻辑。我们前面说过，Go运行时隐藏了<strong>I/O多路复用</strong>的复杂性。Go语言使用者只需采用 <strong>Goroutine+阻塞I/O模型</strong>，就可以满足大部分场景需求。Dial连接成功后，会返回一个net.Conn接口类型的变量值，这个接口变量的底层类型为一个*TCPConn：</p><pre><code class=\"language-plain\">//$GOROOT/src/net/tcpsock.go\ntype TCPConn struct {\n    conn\n}\n</code></pre><p>TCPConn内嵌了一个非导出类型：<code>conn</code>（封装了底层的socket），因此，TCPConn“继承”了 <code>conn</code> 类型的 <code>Read</code> 和 <code>Write</code> 方法，后续通过 <code>Dial</code> 函数返回值调用的 <code>Read</code> 和 <code>Write</code> 方法都是net.conn的方法，它们分别代表了对socket的读和写。</p><p>接下来，我们先来通过几个场景来总结一下Go中从socket读取数据的行为特点。</p><p><strong>首先是Socket中无数据的场景。</strong></p><p>连接建立后，如果客户端未发送数据，服务端会阻塞在Socket的读操作上，这和前面提到的“阻塞I/O模型”的行为模式是一致的。执行该这个操作的Goroutine也会被挂起。Go运行时会监视这个Socket，直到它有数据读事件，才会重新调度这个Socket对应的Goroutine完成读操作。</p><p><strong>第二种情况是Socket中有部分数据。</strong></p><p>如果Socket中有部分数据就绪，且数据数量小于一次读操作期望读出的数据长度，那么读操作将会成功读出这部分数据，并返回，而不是等待期望长度数据全部读取后，再返回。</p><p>举个例子，服务端创建一个长度为10的切片作为接收数据的缓冲区，等待Read操作将读取的数据放入切片。当客户端在已经建立成功的连接上，成功写入两个字节的数据（比如：hi）后，服务端的Read方法将成功读取数据，并返回 <code>n=2，err=nil</code> ，而不是等收满10个字节后才返回。</p><p><strong>第三种情况是Socket中有足够数据。</strong></p><p>如果连接上有数据，且数据长度大于等于一次 <code>Read</code> 操作期望读出的数据长度，那么 <code>Read</code> 将会成功读出这部分数据，并返回。这个情景是最符合我们对 <code>Read</code> 的期待的了。</p><p>我们以上面的例子为例，当客户端在已经建立成功的连接上，成功写入15个字节的数据后，服务端进行第一次 <code>Read</code> 时，会用连接上的数据将我们传入的切片缓冲区（长度为10）填满后返回：<code>n = 10, err = nil</code>。这个时候，内核缓冲区中还剩5个字节数据，当服务端再次调用 <code>Read</code> 时，就会把剩余数据全部读出。</p><p><strong>最后一种情况是设置读操作超时。</strong></p><p>有些场合，对socket的读操作的阻塞时间有严格限制的，但由于Go使用的是阻塞I/O模型，如果没有可读数据，Read操作会一直阻塞在对Socket的读操作上。</p><p>这时，我们可以通过net.Conn提供的SetReadDeadline方法，设置读操作的超时时间，当超时后仍然没有数据可读的情况下，Read操作会解除阻塞并返回超时错误，这就给Read方法的调用者提供了进行其他业务处理逻辑的机会。</p><p>SetReadDeadline方法接受一个绝对时间作为超时的deadline。一旦通过这个方法设置了某个socket的Read deadline，当发生超时后，如果我们不重新设置Deadline，那么后面与这个socket有关的所有读操作，都会返回超时失败错误。</p><p>下面是结合SetReadDeadline设置的服务端一般处理逻辑：</p><pre><code class=\"language-plain\">func handleConn(c net.Conn) {\n    defer c.Close()\n    for {\n        // read from the connection\n        var buf = make([]byte, 128)\n        c.SetReadDeadline(time.Now().Add(time.Second))\n        n, err := c.Read(buf)\n        if err != nil {\n            log.Printf(\"conn read %d bytes,  error: %s\", n, err)\n            if nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() {\n                // 进行其他业务逻辑的处理\n                continue\n            }\n            return\n        }\n        log.Printf(\"read %d bytes, content is %s\\n\", n, string(buf[:n]))\n    }\n}\n</code></pre><p>如果我们要取消超时设置，可以使用SetReadDeadline（time.Time{}）实现。</p><h2>Socket写操作</h2><p>通过net.Conn实例的Write方法，我们可以将数据写入Socket。当Write调用的返回值n的值，与预期要写入的数据长度相等，且err = nil时，我们就执行了一次成功的Socket写操作，这是我们在调用Write时遇到的最常见的情形。</p><p>和Socket的读操作一些特殊情形相比，Socket写操作遇到的特殊情形同样不少，我们也逐一看一下。</p><p><strong>第一种情况：写阻塞。</strong></p><p>TCP协议通信两方的操作系统内核，都会为这个连接保留数据缓冲区，调用Write向Socket写入数据，实际上是将数据写入到操作系统协议栈的数据缓冲区中。TCP是全双工通信，因此每个方向都有独立的数据缓冲。当发送方将对方的接收缓冲区，以及自身的发送缓冲区都写满后，再调用Write方法就会出现阻塞的情况。</p><p>我们来看一个具体例子。这个例子的客户端代码如下：</p><pre><code class=\"language-plain\">func main() {\n    log.Println(\"begin dial...\")\n    conn, err := net.Dial(\"tcp\", \":8888\")\n    if err != nil {\n        log.Println(\"dial error:\", err)\n        return\n    }\n    defer conn.Close()\n    log.Println(\"dial ok\")\n\n    data := make([]byte, 65536)\n    var total int\n    for {\n        n, err := conn.Write(data)\n        if err != nil {\n            total += n\n            log.Printf(\"write %d bytes, error:%s\\n\", n, err)\n            break\n        }\n        total += n\n        log.Printf(\"write %d bytes this time, %d bytes in total\\n\", n, total)\n    }\n\n    log.Printf(\"write %d bytes in total\\n\", total)\n}\n</code></pre><p>客户端每次调用Write方法向服务端写入65536个字节，并在Write方法返回后，输出此次Write的写入字节数和程序启动后写入的总字节数量。</p><p>服务端的处理程序逻辑，我也摘录了主要部分，你可以看一下：</p><pre><code class=\"language-plain\">... ...\nfunc handleConn(c net.Conn) {\n    defer c.Close()\n    time.Sleep(time.Second * 10)\n    for {\n        // read from the connection\n        time.Sleep(5 * time.Second)\n        var buf = make([]byte, 60000)\n        log.Println(\"start to read from conn\")\n        n, err := c.Read(buf)\n        if err != nil {\n            log.Printf(\"conn read %d bytes,  error: %s\", n, err)\n            if nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() {\n                continue\n            }\n        }\n\n        log.Printf(\"read %d bytes, content is %s\\n\", n, string(buf[:n]))\n    }\n}\n... ...\n</code></pre><p>我们可以看到，服务端在前10秒中并不读取数据，因此当客户端一直调用Write方法写入数据时，写到一定量后就会发生阻塞。你可以看一下客户端的执行输出：</p><pre><code class=\"language-plain\">2022/01/14 14:57:33 begin dial...\n2022/01/14 14:57:33 dial ok\n2022/01/14 14:57:33 write 65536 bytes this time, 65536 bytes in total\n... ...\n2022/01/14 14:57:33 write 65536 bytes this time, 589824 bytes in total\n2022/01/14 14:57:33 write 65536 bytes this time, 655360 bytes in total  &lt;-- 之后，写操作将阻塞\n</code></pre><p>后续当服务端每隔5秒进行一次读操作后，内核socket缓冲区腾出了空间，客户端就又可以写入了：</p><pre><code class=\"language-plain\">服务端：\n\n2022/01/14 15:07:01 accept a new connection\n2022/01/14 15:07:16 start to read from conn\n2022/01/14 15:07:16 read 60000 bytes, content is\n2022/01/14 15:07:21 start to read from conn\n2022/01/14 15:07:21 read 60000 bytes, content is\n2022/01/14 15:07:26 start to read from conn\n2022/01/14 15:07:26 read 60000 bytes, content is\n....\n\n\n\n客户端(得以继续写入)：\n\n2022/01/14 15:07:01 write 65536 bytes this time, 720896 bytes in total\n2022/01/14 15:07:06 write 65536 bytes this time, 786432 bytes in total\n2022/01/14 15:07:16 write 65536 bytes this time, 851968 bytes in total\n2022/01/14 15:07:16 write 65536 bytes this time, 917504 bytes in total\n2022/01/14 15:07:27 write 65536 bytes this time, 983040 bytes in total\n2022/01/14 15:07:27 write 65536 bytes this time, 1048576 bytes in total\n.... ...\n</code></pre><p><strong>第二种情况：写入部分数据。</strong></p><p>Write操作存在写入部分数据的情况，比如上面例子中，当客户端输出日志停留在“write 65536 bytes this time, 655360 bytes in total”时，我们杀掉服务端，这时我们就会看到客户端输出以下日志：</p><pre><code class=\"language-plain\">...\n2022/01/14 15:19:14 write 65536 bytes this time, 655360 bytes in total\n2022/01/14 15:19:16 write 24108 bytes, error:write tcp 127.0.0.1:62245-&gt;127.0.0.1:8888: write: broken pipe\n2022/01/14 15:19:16 write 679468 bytes in total\n</code></pre><p>显然，<code>Write</code> 并不是在655360这个地方阻塞的，而是后续又写入24108个字节后发生了阻塞，服务端Socket关闭后，我们看到客户端又写入24108字节后，才返回的 <code>broken pipe</code> 错误。由于这24108字节数据并未真正被服务端接收到，程序需要考虑妥善处理这些数据，以防数据丢失。</p><p><strong>第三种情况：写入超时。</strong></p><p>如果我们非要给Write操作增加一个期限，可以调用SetWriteDeadline方法。比如，我们可以将上面例子中的客户端源码拷贝一份，然后在新客户端源码中的Write调用之前，增加一行超时时间设置代码：</p><pre><code class=\"language-plain\">conn.SetWriteDeadline(time.Now().Add(time.Microsecond * 10))\n</code></pre><p>然后先后启动服务端与新客户端，我们可以看到写入超时的情况下，Write方法的返回结果：</p><pre><code class=\"language-plain\">客户端输出：\n\n2022/01/14 15:26:34 begin dial...\n2022/01/14 15:26:34 dial ok\n2022/01/14 15:26:34 write 65536 bytes this time, 65536 bytes in total\n... ...\n2022/01/14 15:26:34 write 65536 bytes this time, 655360 bytes in total\n2022/01/14 15:26:34 write 24108 bytes, error:write tcp 127.0.0.1:62325-&gt;127.0.0.1:8888: i/o timeout\n2022/01/14 15:26:34 write 679468 bytes in total\n</code></pre><p>我们可以看到，在Write方法写入超时时，依旧存在<strong>数据部分写入（仅写入24108个字节）</strong>的情况。另外，和SetReadDeadline一样，只要我们通过SetWriteDeadline设置了写超时，那无论后续Write方法是否成功，如果不重新设置写超时或取消写超时，后续对Socket的写操作都将以超时失败告终。</p><p>综合上面这些例子，虽然Go给我们提供了阻塞I/O的便利，但在调用 <code>Read</code> 和 <code>Write</code> 时，依旧要综合函数返回的 <code>n</code> 和 <code>err</code> 的结果以做出正确处理。</p><p>不过，前面说的Socket读与写都是限于单Goroutine下的操作，如果多个Goroutine并发读或写一个socket会发生什么呢？我们继续往下看。</p><h2>并发Socket读写</h2><p>Goroutine的网络编程模型，决定了存在着不同Goroutine间共享<code>conn</code>的情况，那么<code>conn</code>的读写是否是Goroutine并发安全的呢？不过，在深入这个问题之前，我们先从应用的角度上，看看并发read操作和write操作的Goroutine安全的必要性。</p><p>对于Read操作而言，由于TCP是面向字节流，<code>conn.Read</code> 无法正确区分数据的业务边界，因此，多个Goroutine对同一个conn进行read的意义不大，Goroutine读到不完整的业务包，反倒增加了业务处理的难度。</p><p>但对于Write操作而言，倒是有多个Goroutine并发写的情况。不过conn读写是否是Goroutine安全的测试并不是很好做，我们先深入一下运行时代码，从理论上给这个问题定个性。</p><p>首先，<code>net.conn</code> 只是<code>*netFD</code> 的外层包裹结构，最终Write和Read都会落在其中的 <code>fd</code> 字段上：</p><pre><code class=\"language-plain\">//$GOROOT/src/net/net.go\ntype conn struct {\n    fd *netFD\n}\n</code></pre><p>另外，netFD在不同平台上有着不同的实现，我们以 <code>net/fd_posix.go</code> 中的 <code>netFD</code> 为例看看：</p><pre><code class=\"language-go\">// $GOROOT/src/net/fd_posix.go\n\n// Network file descriptor.\ntype netFD struct {\n    pfd poll.FD \n    \n    // immutable until Close\n    family      int\n    sotype      int\n    isConnected bool // handshake completed or use of association with peer\n    net         string\n    laddr       Addr\n    raddr       Addr\n}  \n\n\n\n</code></pre><p>netFD中最重要的字段是poll.FD类型的pfd，它用于表示一个网络连接。我也把它的结构摘录了一部分：</p><pre><code class=\"language-go\">// $GOROOT/src/internal/poll/fd_unix.go\n\n// FD is a file descriptor. The net and os packages use this type as a\n// field of a larger type representing a network connection or OS file.\ntype FD struct {\n    // Lock sysfd and serialize access to Read and Write methods.\n    fdmu fdMutex\n    \n    // System file descriptor. Immutable until Close.\n    Sysfd int\n    \n    // I/O poller.\n    pd pollDesc \n\n    // Writev cache.\n    iovecs *[]syscall.Iovec\n    ... ...    \n}\n</code></pre><p>我们看到，<code>FD</code>类型中包含了一个运行时实现的 <code>fdMutex</code> 类型字段。从它的注释来看，这个 <code>fdMutex</code> 用来串行化对字段 <code>Sysfd</code>的Write和Read操作。也就是说，所有对这个FD所代表的连接的Read和Write操作，都是由 <code>fdMutex</code> 来同步的。从<code>FD</code>的Read和Write方法的实现，也证实了这一点：</p><pre><code class=\"language-go\">// $GOROOT/src/internal/poll/fd_unix.go\n\nfunc (fd *FD) Read(p []byte) (int, error) {\n    if err := fd.readLock(); err != nil {\n        return 0, err\n    }\n    defer fd.readUnlock()\n    if len(p) == 0 {\n        // If the caller wanted a zero byte read, return immediately\n        // without trying (but after acquiring the readLock).\n        // Otherwise syscall.Read returns 0, nil which looks like\n        // io.EOF.\n        // TODO(bradfitz): make it wait for readability? (Issue 15735)\n        return 0, nil\n    }\n    if err := fd.pd.prepareRead(fd.isFile); err != nil {\n        return 0, err\n    }\n    if fd.IsStream &amp;&amp; len(p) &gt; maxRW {\n        p = p[:maxRW]\n    }\n    for {\n        n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)\n        if err != nil {\n            n = 0\n            if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {\n                if err = fd.pd.waitRead(fd.isFile); err == nil {\n                    continue\n                }\n            }\n        }\n        err = fd.eofError(n, err)\n        return n, err\n    }\n}\n\nfunc (fd *FD) Write(p []byte) (int, error) {\n    if err := fd.writeLock(); err != nil {\n        return 0, err\n    }\n    defer fd.writeUnlock()\n    if err := fd.pd.prepareWrite(fd.isFile); err != nil {\n        return 0, err\n    }\n    var nn int\n    for {\n        max := len(p)\n        if fd.IsStream &amp;&amp; max-nn &gt; maxRW {\n            max = nn + maxRW\n        }\n        n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])\n        if n &gt; 0 {\n            nn += n\n        }\n        if nn == len(p) {\n            return nn, err\n        }\n        if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {\n            if err = fd.pd.waitWrite(fd.isFile); err == nil {\n                continue\n            }\n        }\n        if err != nil {\n            return nn, err\n        }\n        if n == 0 {\n            return nn, io.ErrUnexpectedEOF\n        }\n    }\n}\n</code></pre><p>你看，每次Write操作都是受lock保护，直到这次数据全部写完才会解锁。因此，在应用层面，要想保证多个Goroutine在一个 <code>conn</code> 上write操作是安全的，需要一次write操作完整地写入一个“业务包”。一旦将业务包的写入拆分为多次write，那也无法保证某个Goroutine的某“业务包”数据在 <code>conn</code> 发送的连续性。</p><p>同时，我们也可以看出即便是Read操作，也是有lock保护的。多个Goroutine对同一 <code>conn</code> 的并发读，不会出现读出内容重叠的情况，但就像前面讲并发读的必要性时说的那样，一旦采用了不恰当长度的切片作为buf，很可能读出不完整的业务包，这反倒会带来业务上的处理难度。</p><p>比如一个完整数据包：<code>world</code>，当Goroutine的读缓冲区长度 &lt; 5时，就存在这样一种可能：一个Goroutine读出了“worl”，而另外一个Goroutine读出了\"d\"。</p><p>最后我们再来看看Socket关闭。</p><h2>Socket关闭</h2><p>通常情况下，当客户端需要断开与服务端的连接时，客户端会调用net.Conn的Close方法关闭与服务端通信的Socket。如果客户端主动关闭了Socket，那么服务端的<code>Read</code>调用将会读到什么呢？这里要分“有数据关闭”和“无数据关闭”两种情况。</p><p>“有数据关闭”是指在客户端关闭连接（Socket）时，Socket中还有服务端尚未读取的数据。在这种情况下，服务端的Read会成功将剩余数据读取出来，最后一次Read操作将得到<code>io.EOF</code>错误码，表示客户端已经断开了连接。如果是在“无数据关闭”情形下，服务端调用的Read方法将直接返回<code>io.EOF</code>。</p><p>不过因为Socket是全双工的，客户端关闭Socket后，如果服务端Socket尚未关闭，这个时候服务端向Socket的写入操作依然可能会成功，因为数据会成功写入己方的内核socket缓冲区中，即便最终发不到对方socket缓冲区也会这样。因此，当发现对方socket关闭后，己方应该正确合理处理自己的socket，再继续write已经没有任何意义了。</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了，从这一讲开始我们开启了实战篇的学习。</p><p>在实战篇中，我会带着你“走完最后一公里”，所谓“最后一公里”，我的理解是从空有一身Go“绝技”到可以解决实际问题的进化，在这个过程中，我们需要怎么做？我们可以跟着理解问题、技术预研与储备，以及设计、实现与优化这三个循环解决思路，完成这个进化。</p><p>这一讲，我们的实际问题聚焦在<strong>实现一个基于TCP的自定义应用层协议的通信服务端</strong>，我们分析了通信协议与通信过程，并识别出若干技术点，其中以socket编程模型与网络I/O操作为重点，对这两个技术点进行了预研与储备。</p><p>虽然目前主流socket网络编程模型是I/O多路复用模型，但考虑到这个模型在使用时的体验较差，Go语言将这种复杂性隐藏到运行时层，并结合Goroutine的轻量级特性，在用户层提供了基于I/O阻塞模型的Go socket网络编程模型，这一模型就大大降低了gopher在编写socket应用程序时的心智负担。</p><p>而且，Go在net包中提供了针对socket的各种操作函数与方法，在这一讲中我们详细分析了其中的重要函数的使用，以及这些函数在特殊场景下需要注意的事项，你一定要掌握这一部分，因为这是我们下一讲进行设计与实现的根基与铺垫。</p><h2>思考题</h2><p>这一讲内容比较多，针对Go net包提供的各种操作，我建议你自己编写代码，逐个去实现这一讲中各个操作里的示例代码，为下一讲做好充分的准备。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是Tony Bai，我们下节课见。</p>","neighbors":{"left":{"article_title":"35｜即学即练：如何实现一个轻量级线程池？","id":479171},"right":{"article_title":"37｜代码操练：怎么实现一个TCP服务器？（中）","id":482658}},"comments":[{"had_liked":false,"id":363500,"user_name":"撕影","can_delete":false,"product_type":"c1","uid":3222094,"ip_address":"辽宁","ucode":"8DC169F8B8E653","user_header":"https://static001.geekbang.org/account/avatar/00/31/2a/4e/a3f53cae.jpg","comment_is_top":false,"comment_ctime":1669737717,"is_pvip":false,"replies":[{"id":132153,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669901992,"ip_address":"辽宁","comment_id":363500,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"由于go的GPM模型存在，实现多路复用简直就是降维打击。只挂起G而不挂起M，在G的视角里就是个阻塞模型而已，妙啊","like_count":5},{"had_liked":false,"id":332059,"user_name":"在下宝龙、","can_delete":false,"product_type":"c1","uid":1618030,"ip_address":"","ucode":"0735B64EB61CAC","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","comment_is_top":false,"comment_ctime":1643003169,"is_pvip":false,"replies":[{"id":121516,"content":"io多路复用顾名思义，一个线程可以处理多个socket，只要有一个socket上可读或可写，线程就会忙碌起来。当然如果所有socket都不可读，也不可写，那么该线程的确是处理阻塞状态。但这和一个线程仅能处理一个socket，还阻塞在该socket的读&#47;写上相比，是有质的飞跃的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643379354,"ip_address":"","comment_id":332059,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师我想问一下 按照老师你的图，select不是也阻塞了线程么，应用线程也不能做其他的事情，难道应用线程和select的线程不是同一个吗","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595293,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669901992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332034,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1642991548,"is_pvip":true,"replies":[{"id":121515,"content":"我最初是看了这篇文章 https:&#47;&#47;morsmachine.dk&#47;netpoller ，之后自己read source code的。只有自己读代码，结果才深刻。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643378180,"ip_address":"","comment_id":332034,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，有没有netpoller的相关实现资料参考？","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548808,"discussion_content":"io多路复用顾名思义，一个线程可以处理多个socket，只要有一个socket上可读或可写，线程就会忙碌起来。当然如果所有socket都不可读，也不可写，那么该线程的确是处理阻塞状态。但这和一个线程仅能处理一个socket，还阻塞在该socket的读/写上相比，是有质的飞跃的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643379354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347877,"user_name":"Aeins","can_delete":false,"product_type":"c1","uid":1045910,"ip_address":"","ucode":"D5BF220767541D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","comment_is_top":false,"comment_ctime":1654531055,"is_pvip":false,"replies":[{"id":126800,"content":"这里仅是介绍了并发下网络I&#47;O的可能存在的极端情况。实际设计中，尽量避免对一个socket的并发读和并发写。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654578882,"ip_address":"","comment_id":347877,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"读完，好多细节还抓不住\n\n1. go 中的 Socket 是操作系统 socket 的封装。go 通过 netpoller 模拟了阻塞式的I&#47;O，运行时还是使用的I&#47;O多路复用(不同操作系统提供了不同的系统调用，epoll等)\n\n连接复用的情况\n\n0. 读写都有锁保护\n\n1. 多 goroutine 并发读，如何正确的指定度多少数据呢，给少了，会读不全，被其他 goroutine 读走，给多了，会读取不属于自己的数据吧。\n\n2. 多 goroutine 并发写，如果一次写入一个完整的”业务包“，一般能保证单个业务包的完整\n，如果写超时，会有部分写入问题吗？\n一次写入一个业务包，TCP会从面向数据流，退化到面向业务包码？\n读的一端，为了区分不同goroutine(共用连接，数据不共享)的数据，要采取特殊的读取方式吗，需要以包为单位读取？","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575066,"discussion_content":"这里仅是介绍了并发下网络I/O的可能存在的极端情况。实际设计中，尽量避免对一个socket的并发读和并发写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654578882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332026,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1642989732,"is_pvip":true,"replies":[{"id":121318,"content":"👍。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643012253,"ip_address":"","comment_id":332026,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"谢谢老师。我跟上了。还特意买了你新出的Go语言精进之路1，2，打算过年继续精进。","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548051,"discussion_content":"👍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643012253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1979090,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/x3gOkI2Dl1Gb3WRic44roicJMILgHfdFRic8nfR7oh0asf0KONEj7U2or6YHMmCcyibskvVE5Pjypz2ALGwBXRyMPA/132","nickname":"中年编程人员","note":"","ucode":"8692C6FA9B0ED3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577920,"discussion_content":"Go语言精进之路1，2的课程在哪里，我怎么找不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656412453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1006452,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5b/74/cccc2b82.jpg","nickname":"wuzhq","note":"","ucode":"491918051F5C24","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1979090,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/x3gOkI2Dl1Gb3WRic44roicJMILgHfdFRic8nfR7oh0asf0KONEj7U2or6YHMmCcyibskvVE5Pjypz2ALGwBXRyMPA/132","nickname":"中年编程人员","note":"","ucode":"8692C6FA9B0ED3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579016,"discussion_content":"是书","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657125801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":577920,"ip_address":"","group_id":0},"score":579016,"extra":""}]}]},{"had_liked":false,"id":359278,"user_name":"Mew151","can_delete":false,"product_type":"c1","uid":1002201,"ip_address":"辽宁","ucode":"D4793F5874F345","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","comment_is_top":false,"comment_ctime":1665390957,"is_pvip":false,"replies":[{"id":130696,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1665431933,"ip_address":"辽宁","comment_id":359278,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"本节课的代码参见：https:&#47;&#47;github.com&#47;dgqypl&#47;tcpprogramming","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589982,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665431934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604966,"discussion_content":"已fork","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676530368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350630,"user_name":"一打七","can_delete":false,"product_type":"c1","uid":1241197,"ip_address":"","ucode":"D242C5EF70C176","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/6d/3e570bb8.jpg","comment_is_top":false,"comment_ctime":1657069706,"is_pvip":false,"replies":[{"id":127552,"content":"tcp仅是传输层协议。如何识别应用层协议包的是应用层协议来规定的。\n\n像你提到的，如果某个应用层请求包存在数据异常，如果异常会导致后续所有请求均处理失败，那么意味着这个连接存在的意义不大了，断连是最好的选择。后续的请求由于没有得到服务端的应答，所以client端应该选择重发。\n\n如果数据异常的请求对后续新请求没有太大影响，服务端可以选择将请求的剩余数据读取后，回复特定的失败应答。然后继续读取和处理后续的新请求。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1657092702,"ip_address":"","comment_id":350630,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，有个地方想不清楚，请教一下。现在都是长连接复用一个tcp连接，这时服务端读取一个请求的部分数据后异常了，还有一部分数据未读取，这时下一个请求过来了，服务端应该怎么处理上一个请求遗留的那部分数据？因为tcp层面是没有业务语义的，怎么区分这部分数据要不要丢弃。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578922,"discussion_content":"tcp仅是传输层协议。如何识别应用层协议包的是应用层协议来规定的。\n\n像你提到的，如果某个应用层请求包存在数据异常，如果异常会导致后续所有请求均处理失败，那么意味着这个连接存在的意义不大了，断连是最好的选择。后续的请求由于没有得到服务端的应答，所以client端应该选择重发。\n\n如果数据异常的请求对后续新请求没有太大影响，服务端可以选择将请求的剩余数据读取后，回复特定的失败应答。然后继续读取和处理后续的新请求。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657092702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334672,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1645068537,"is_pvip":false,"replies":[{"id":122600,"content":"很高兴又看到lesserror回来学习了！\n\n我来说说你提出的问题。\n\n1. 输入：指的是我们要实现的tcp服务器的输入，就是服务器要接收的数据。这些数据符合某种应用层协议的规范。\n2. 系统调用后，线程便进入内核空间执行了，即进入内核态。在内核态的系统调用代码将获得的数据从内核层的缓存中copy到用户层的内存中，执行结束后，从内核态返回用户态。用户便可以在用户层的内存中看到已经返回的数据了。可以参考一下《深入理解计算机系统3rd》这本书对计算机整体做了一个全面深入了解。\n3. EAGAIN&#47;EWOULDBLOCK 是两个系统级的错误。E是前缀，以EAGAIN为例，即Error Again，即告知调用者重试。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645598544,"ip_address":"","comment_id":334672,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"以前没接触过socket编程，只是经常看到这个知识点。感谢Tony Bai老师的细致讲解。有几点疑惑，烦请老师解答。\n\n1. 我们的输入，是一个基于传输层自定义的应用层协议规范。 这里的输入该怎么理解呢？\n\n2. 在阻塞 I&#47;O 模型下，并等所有数据就绪后，将数据从内核空间拷贝到用户空间，最后系统调用从内核空间返回。为什么不是用户空间返回呢？\n\n3. 文中的非阻塞 I&#47;O 模型架构图中的：EAGAIN&#47;EWOULDBLOCK 这几个英文单词是什么意思，没查出来。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578922,"discussion_content":"tcp仅是传输层协议。如何识别应用层协议包的是应用层协议来规定的。\n\n像你提到的，如果某个应用层请求包存在数据异常，如果异常会导致后续所有请求均处理失败，那么意味着这个连接存在的意义不大了，断连是最好的选择。后续的请求由于没有得到服务端的应答，所以client端应该选择重发。\n\n如果数据异常的请求对后续新请求没有太大影响，服务端可以选择将请求的剩余数据读取后，回复特定的失败应答。然后继续读取和处理后续的新请求。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657092702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332391,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1643197104,"is_pvip":false,"replies":[{"id":121502,"content":"1. 是的，文中链接好像多了一个空格，导致无效了。\n2. 确实。感谢提醒。我让编辑老师改一下。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643360983,"ip_address":"","comment_id":332391,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，文章中“I&#47;O 多路复用框架”的举例中：\n1、libev 的链接点击没反应（是 http:&#47;&#47;software.schmorp.de&#47;pkg&#47;libev.html 这个链接吗？）；\n2、libuv 的链接对应的 github 仓库貌似已经迁移到 https:&#47;&#47;github.com&#47;libuv&#47;libuv 了。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552806,"discussion_content":"很高兴又看到lesserror回来学习了！\n\n我来说说你提出的问题。\n\n1. 输入：指的是我们要实现的tcp服务器的输入，就是服务器要接收的数据。这些数据符合某种应用层协议的规范。\n2. 系统调用后，线程便进入内核空间执行了，即进入内核态。在内核态的系统调用代码将获得的数据从内核层的缓存中copy到用户层的内存中，执行结束后，从内核态返回用户态。用户便可以在用户层的内存中看到已经返回的数据了。可以参考一下《深入理解计算机系统3rd》这本书对计算机整体做了一个全面深入了解。\n3. EAGAIN/EWOULDBLOCK 是两个系统级的错误。E是前缀，以EAGAIN为例，即Error Again，即告知调用者重试。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645598545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332010,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1642981317,"is_pvip":false,"replies":[{"id":121611,"content":"你的业务场景中有并发写一个conn的情况么？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643540945,"ip_address":"","comment_id":332010,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"并发往 socket 中写数据时，需要一次 write 操作完整的写入一个“业务包”，这实现有点难呀，万一只成功写入一部分，这可不能回滚呀。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548769,"discussion_content":"1. 是的，文中链接好像多了一个空格，导致无效了。\n2. 确实。感谢提醒。我让编辑老师改一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643360983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551637,"discussion_content":"同学你的libev能打开吗？ 我试了下还是不能打开。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645069809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363500,"user_name":"撕影","can_delete":false,"product_type":"c1","uid":3222094,"ip_address":"辽宁","ucode":"8DC169F8B8E653","user_header":"https://static001.geekbang.org/account/avatar/00/31/2a/4e/a3f53cae.jpg","comment_is_top":false,"comment_ctime":1669737717,"is_pvip":false,"replies":[{"id":132153,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669901992,"ip_address":"辽宁","comment_id":363500,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"由于go的GPM模型存在，实现多路复用简直就是降维打击。只挂起G而不挂起M，在G的视角里就是个阻塞模型而已，妙啊","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595293,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669901992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332059,"user_name":"在下宝龙、","can_delete":false,"product_type":"c1","uid":1618030,"ip_address":"","ucode":"0735B64EB61CAC","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg","comment_is_top":false,"comment_ctime":1643003169,"is_pvip":false,"replies":[{"id":121516,"content":"io多路复用顾名思义，一个线程可以处理多个socket，只要有一个socket上可读或可写，线程就会忙碌起来。当然如果所有socket都不可读，也不可写，那么该线程的确是处理阻塞状态。但这和一个线程仅能处理一个socket，还阻塞在该socket的读&#47;写上相比，是有质的飞跃的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643379354,"ip_address":"","comment_id":332059,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师我想问一下 按照老师你的图，select不是也阻塞了线程么，应用线程也不能做其他的事情，难道应用线程和select的线程不是同一个吗","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548808,"discussion_content":"io多路复用顾名思义，一个线程可以处理多个socket，只要有一个socket上可读或可写，线程就会忙碌起来。当然如果所有socket都不可读，也不可写，那么该线程的确是处理阻塞状态。但这和一个线程仅能处理一个socket，还阻塞在该socket的读/写上相比，是有质的飞跃的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643379354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332034,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1642991548,"is_pvip":true,"replies":[{"id":121515,"content":"我最初是看了这篇文章 https:&#47;&#47;morsmachine.dk&#47;netpoller ，之后自己read source code的。只有自己读代码，结果才深刻。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643378180,"ip_address":"","comment_id":332034,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，有没有netpoller的相关实现资料参考？","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548804,"discussion_content":"我最初是看了这篇文章 https://morsmachine.dk/netpoller ，之后自己read source code的。只有自己读代码，结果才深刻。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643378181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347877,"user_name":"Aeins","can_delete":false,"product_type":"c1","uid":1045910,"ip_address":"","ucode":"D5BF220767541D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","comment_is_top":false,"comment_ctime":1654531055,"is_pvip":false,"replies":[{"id":126800,"content":"这里仅是介绍了并发下网络I&#47;O的可能存在的极端情况。实际设计中，尽量避免对一个socket的并发读和并发写。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654578882,"ip_address":"","comment_id":347877,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"读完，好多细节还抓不住\n\n1. go 中的 Socket 是操作系统 socket 的封装。go 通过 netpoller 模拟了阻塞式的I&#47;O，运行时还是使用的I&#47;O多路复用(不同操作系统提供了不同的系统调用，epoll等)\n\n连接复用的情况\n\n0. 读写都有锁保护\n\n1. 多 goroutine 并发读，如何正确的指定度多少数据呢，给少了，会读不全，被其他 goroutine 读走，给多了，会读取不属于自己的数据吧。\n\n2. 多 goroutine 并发写，如果一次写入一个完整的”业务包“，一般能保证单个业务包的完整\n，如果写超时，会有部分写入问题吗？\n一次写入一个业务包，TCP会从面向数据流，退化到面向业务包码？\n读的一端，为了区分不同goroutine(共用连接，数据不共享)的数据，要采取特殊的读取方式吗，需要以包为单位读取？","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548804,"discussion_content":"我最初是看了这篇文章 https://morsmachine.dk/netpoller ，之后自己read source code的。只有自己读代码，结果才深刻。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643378181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332026,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1642989732,"is_pvip":true,"replies":[{"id":121318,"content":"👍。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643012253,"ip_address":"","comment_id":332026,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"谢谢老师。我跟上了。还特意买了你新出的Go语言精进之路1，2，打算过年继续精进。","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575066,"discussion_content":"这里仅是介绍了并发下网络I/O的可能存在的极端情况。实际设计中，尽量避免对一个socket的并发读和并发写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654578882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359278,"user_name":"Mew151","can_delete":false,"product_type":"c1","uid":1002201,"ip_address":"辽宁","ucode":"D4793F5874F345","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","comment_is_top":false,"comment_ctime":1665390957,"is_pvip":false,"replies":[{"id":130696,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1665431933,"ip_address":"辽宁","comment_id":359278,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"本节课的代码参见：https:&#47;&#47;github.com&#47;dgqypl&#47;tcpprogramming","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548051,"discussion_content":"👍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643012253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1979090,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/x3gOkI2Dl1Gb3WRic44roicJMILgHfdFRic8nfR7oh0asf0KONEj7U2or6YHMmCcyibskvVE5Pjypz2ALGwBXRyMPA/132","nickname":"中年编程人员","note":"","ucode":"8692C6FA9B0ED3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577920,"discussion_content":"Go语言精进之路1，2的课程在哪里，我怎么找不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656412453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1006452,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5b/74/cccc2b82.jpg","nickname":"wuzhq","note":"","ucode":"491918051F5C24","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1979090,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/x3gOkI2Dl1Gb3WRic44roicJMILgHfdFRic8nfR7oh0asf0KONEj7U2or6YHMmCcyibskvVE5Pjypz2ALGwBXRyMPA/132","nickname":"中年编程人员","note":"","ucode":"8692C6FA9B0ED3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579016,"discussion_content":"是书","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657125801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":577920,"ip_address":"","group_id":0},"score":579016,"extra":""}]}]},{"had_liked":false,"id":350630,"user_name":"一打七","can_delete":false,"product_type":"c1","uid":1241197,"ip_address":"","ucode":"D242C5EF70C176","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/6d/3e570bb8.jpg","comment_is_top":false,"comment_ctime":1657069706,"is_pvip":false,"replies":[{"id":127552,"content":"tcp仅是传输层协议。如何识别应用层协议包的是应用层协议来规定的。\n\n像你提到的，如果某个应用层请求包存在数据异常，如果异常会导致后续所有请求均处理失败，那么意味着这个连接存在的意义不大了，断连是最好的选择。后续的请求由于没有得到服务端的应答，所以client端应该选择重发。\n\n如果数据异常的请求对后续新请求没有太大影响，服务端可以选择将请求的剩余数据读取后，回复特定的失败应答。然后继续读取和处理后续的新请求。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1657092702,"ip_address":"","comment_id":350630,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，有个地方想不清楚，请教一下。现在都是长连接复用一个tcp连接，这时服务端读取一个请求的部分数据后异常了，还有一部分数据未读取，这时下一个请求过来了，服务端应该怎么处理上一个请求遗留的那部分数据？因为tcp层面是没有业务语义的，怎么区分这部分数据要不要丢弃。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589982,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665431934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604966,"discussion_content":"已fork","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676530368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334672,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1645068537,"is_pvip":false,"replies":[{"id":122600,"content":"很高兴又看到lesserror回来学习了！\n\n我来说说你提出的问题。\n\n1. 输入：指的是我们要实现的tcp服务器的输入，就是服务器要接收的数据。这些数据符合某种应用层协议的规范。\n2. 系统调用后，线程便进入内核空间执行了，即进入内核态。在内核态的系统调用代码将获得的数据从内核层的缓存中copy到用户层的内存中，执行结束后，从内核态返回用户态。用户便可以在用户层的内存中看到已经返回的数据了。可以参考一下《深入理解计算机系统3rd》这本书对计算机整体做了一个全面深入了解。\n3. EAGAIN&#47;EWOULDBLOCK 是两个系统级的错误。E是前缀，以EAGAIN为例，即Error Again，即告知调用者重试。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645598544,"ip_address":"","comment_id":334672,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"以前没接触过socket编程，只是经常看到这个知识点。感谢Tony Bai老师的细致讲解。有几点疑惑，烦请老师解答。\n\n1. 我们的输入，是一个基于传输层自定义的应用层协议规范。 这里的输入该怎么理解呢？\n\n2. 在阻塞 I&#47;O 模型下，并等所有数据就绪后，将数据从内核空间拷贝到用户空间，最后系统调用从内核空间返回。为什么不是用户空间返回呢？\n\n3. 文中的非阻塞 I&#47;O 模型架构图中的：EAGAIN&#47;EWOULDBLOCK 这几个英文单词是什么意思，没查出来。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552806,"discussion_content":"很高兴又看到lesserror回来学习了！\n\n我来说说你提出的问题。\n\n1. 输入：指的是我们要实现的tcp服务器的输入，就是服务器要接收的数据。这些数据符合某种应用层协议的规范。\n2. 系统调用后，线程便进入内核空间执行了，即进入内核态。在内核态的系统调用代码将获得的数据从内核层的缓存中copy到用户层的内存中，执行结束后，从内核态返回用户态。用户便可以在用户层的内存中看到已经返回的数据了。可以参考一下《深入理解计算机系统3rd》这本书对计算机整体做了一个全面深入了解。\n3. EAGAIN/EWOULDBLOCK 是两个系统级的错误。E是前缀，以EAGAIN为例，即Error Again，即告知调用者重试。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645598545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332391,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1643197104,"is_pvip":false,"replies":[{"id":121502,"content":"1. 是的，文中链接好像多了一个空格，导致无效了。\n2. 确实。感谢提醒。我让编辑老师改一下。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643360983,"ip_address":"","comment_id":332391,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师，文章中“I&#47;O 多路复用框架”的举例中：\n1、libev 的链接点击没反应（是 http:&#47;&#47;software.schmorp.de&#47;pkg&#47;libev.html 这个链接吗？）；\n2、libuv 的链接对应的 github 仓库貌似已经迁移到 https:&#47;&#47;github.com&#47;libuv&#47;libuv 了。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548769,"discussion_content":"1. 是的，文中链接好像多了一个空格，导致无效了。\n2. 确实。感谢提醒。我让编辑老师改一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643360983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551637,"discussion_content":"同学你的libev能打开吗？ 我试了下还是不能打开。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645069809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332010,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1642981317,"is_pvip":false,"replies":[{"id":121611,"content":"你的业务场景中有并发写一个conn的情况么？","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643540945,"ip_address":"","comment_id":332010,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"并发往 socket 中写数据时，需要一次 write 操作完整的写入一个“业务包”，这实现有点难呀，万一只成功写入一部分，这可不能回滚呀。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549071,"discussion_content":"你的业务场景中有并发写一个conn的情况么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643540945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1320487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","nickname":"罗杰","note":"","ucode":"96BAFAA147341F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":549119,"discussion_content":"没有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643589748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":549071,"ip_address":"","group_id":0},"score":549119,"extra":""},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1320487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","nickname":"罗杰","note":"","ucode":"96BAFAA147341F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568480,"discussion_content":"哈哈哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651149383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":549119,"ip_address":"","group_id":0},"score":568480,"extra":""}]}]},{"had_liked":false,"id":361020,"user_name":"X","can_delete":false,"product_type":"c1","uid":1760295,"ip_address":"北京","ucode":"0B0FA86372A621","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKEDxLO0wLibic5WkVl1x7TIL0fsxX1zl2GbRjutYQ89fGRrv2VKJtNmmJb32iarbcHROlmW8SOQsHag/132","comment_is_top":false,"comment_ctime":1667118904,"is_pvip":true,"replies":[{"id":131344,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1667210723,"ip_address":"北京","comment_id":361020,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"能把复杂的东西讲的老少皆宜,各层次人都能看懂，可见基础扎实,内功深厚,感谢老师！","like_count":1},{"had_liked":false,"id":357249,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"北京","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1663119178,"is_pvip":false,"replies":[{"id":130025,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663135794,"ip_address":"北京","comment_id":357249,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"网络编程是自己的弱项，老师的这篇文章解决了我不少疑惑，需要再次消化。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592221,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667210723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348129,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654762720,"is_pvip":false,"replies":[{"id":126863,"content":"火眼金睛啊。的确是代码中的fd_unix.go有问题，netFD定义在fd_posix.go中，一会让编辑老师改一下这块。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654829619,"ip_address":"","comment_id":348129,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"文中“我们以net&#47;fd_posix.go中的netFD为例看看”这里的fd_posix.go是不是有问题呀，我看下面代码引用注释里是fd_unix.go","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587537,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663135794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348121,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654761369,"is_pvip":false,"replies":[{"id":126862,"content":"嗯。你的理解没错。超时后，如果没有重新设置，后续所有读操作才都会一直返回读超时错误。这块的确表述不清，我调整一下，之后让编辑老师更新下。感谢指出，手动抱拳:)","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654829181,"ip_address":"","comment_id":348121,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，文中的socket读设置超时时间的这个地方，“一旦通过这个方法设置了某个 socket 的 Read deadline，那么无论后续的 Read 操作是否超时，只要我们不重新设置 Deadline，那么后面与这个 socket 有关的所有读操作，都会返回超时失败错误。”这里是不是应该是“设置了某个socket的Read deadline，然后再发生了读超时，这个读超时后面如果不从新设置，后面所有的读操作都会返回超时失败错误呢？”。这里先是设置了，应该要发生读超时，才行吧？这里没看大懂","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575433,"discussion_content":"火眼金睛啊。的确是代码中的fd_unix.go有问题，netFD定义在fd_posix.go中，一会让编辑老师改一下这块。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654829619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343954,"user_name":"ddh","can_delete":false,"product_type":"c1","uid":2806043,"ip_address":"","ucode":"8E852375365F16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","comment_is_top":false,"comment_ctime":1651141990,"is_pvip":false,"replies":[{"id":125652,"content":"哈哈😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651269462,"ip_address":"","comment_id":343954,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师什么时候出Go语言第二课","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575431,"discussion_content":"嗯。你的理解没错。超时后，如果没有重新设置，后续所有读操作才都会一直返回读超时错误。这块的确表述不清，我调整一下，之后让编辑老师更新下。感谢指出，手动抱拳:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654829181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2732243,"avatar":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","nickname":"功夫熊猫","note":"","ucode":"D124F4FA4E816F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":577519,"discussion_content":"老师你的意思是不是说只要有一次读操作超时，那么这个读操作后的所有读操作无论超没超时都返回超时的错误","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1656161548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":575431,"ip_address":"","group_id":0},"score":577519,"extra":""}]}]},{"had_liked":false,"id":332553,"user_name":"River","can_delete":false,"product_type":"c1","uid":1915496,"ip_address":"","ucode":"F194C87D8AA306","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/68/373b90c8.jpg","comment_is_top":false,"comment_ctime":1643338866,"is_pvip":false,"replies":[{"id":121500,"content":"接口的type assert(类型断言)语法。看核心篇28讲中的接口语法部分有说明。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643360540,"ip_address":"","comment_id":332553,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师，tc, ok := c.(*TCPConn) 这是什么用法？ 是把变量 c 强制转换成一个新的*TCPConn类型变量吗，并返回一个布尔值（表示强转是否成功吗？），变量后跟“.()”的用法既不像调用变量的属性也不想调用变量的方法，这种用法是go语言内置的吗？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568933,"discussion_content":"哈哈😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651269462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332037,"user_name":"Da Vinci","can_delete":false,"product_type":"c1","uid":1061671,"ip_address":"","ucode":"DB3B7F6A6028C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/27/e5a74107.jpg","comment_is_top":false,"comment_ctime":1642992185,"is_pvip":true,"replies":[{"id":121507,"content":"哈哈😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361525,"ip_address":"","comment_id":332037,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"整个课程下来，感觉自己还是收获不少的，以前很多比较模糊的东西，学习完课程后很明了了，被白老师圈粉了。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548766,"discussion_content":"接口的type assert(类型断言)语法。看核心篇28讲中的接口语法部分有说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643360540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383666,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699426354,"is_pvip":false,"replies":[{"id":139864,"content":"好问题！关于网络通信异常情况的处理的确是最难确定的。\n\n对于服务端而言，如果是读超时，那么继续读就ok了。如果是写超时，多半客户端出问题了，关闭连接，等待客户端重连是底限。\n\n对于客户端，如果是读超时，同样可以继续读。如果是写超时，可以关闭连接，重连，然后重发请求。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699450341,"ip_address":"辽宁","comment_id":383666,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师我想问下这里具体的错误处理是怎么做的，\n比如客户端和服务端 遇到读写超时的具体应该怎么处理，\n\n像文中提到 的客户端已经关闭socket， 而服务端还在写数据的时候，这个时候 服务端收到socket关闭的信息了 是不是首先应该停止写入，再关掉socket。\n因为继续写入已经没有意义，如果写缓冲区满了 还会造成写超时。\n\n关于读写超时： 我的理解是服务端 \n如果遇到 读超时 这个时候应该认为客户端不活跃了，应该关闭socket\n写超时的话。 有可能是网络不好，也有可能客户端下线了 ，是不是也是关闭socket。\n\n\n客户端的处理是不是要复杂一些？\n客户端遇到读超时，一般是因为发起了请求，而请求没有得到回应，这个时候是不是应该关闭socket，然后重新建立socket连接，与此同时还要做一些额外的状态恢复操作。\n写超时是不是同样如此，\n烦请老师解惑， 有关于这方面好的文章和书籍都可以推荐给我细看，谢谢","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631305,"discussion_content":"好问题！关于网络通信异常情况的处理的确是最难确定的。\n\n对于服务端而言，如果是读超时，那么继续读就ok了。如果是写超时，多半客户端出问题了，关闭连接，等待客户端重连是底限。\n\n对于客户端，如果是读超时，同样可以继续读。如果是写超时，可以关闭连接，重连，然后重发请求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699450341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333997,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1644659387,"is_pvip":false,"replies":null,"discussion_count":4,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"终于明白用 Go 替换 Java 做 IO 密集型压测为什么没有压到性的优势。因为多个 Goroutine 从 conn 中读写时都有锁保护，没有逃出枷锁。\n","like_count":8,"discussions":[{"author":{"id":1297559,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/97/ae4d1400.jpg","nickname":"林枫","note":"","ucode":"38B9CBE7F42174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561919,"discussion_content":"基于goroutine同步阻塞+netpoller的多路复用，除了降低了编码复杂度，性能上感觉没有提升。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649746738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1297559,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/97/ae4d1400.jpg","nickname":"林枫","note":"","ucode":"38B9CBE7F42174","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562056,"discussion_content":"应该是底层实现受到了锁的限制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649770203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":561919,"ip_address":"","group_id":0},"score":562056,"extra":""}]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589729,"discussion_content":"java要有绿色线程了，go更没优势了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665288975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","nickname":"梁中华","note":"","ucode":"52FE40242CBAD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569058,"discussion_content":"如果用netty这种NIO框架，性能应该是差不多的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651304929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359145,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"广东","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1665288912,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"go最搞笑的地方，非要把fd藏起来，每次要拿他都贼麻烦","like_count":0},{"had_liked":false,"id":361020,"user_name":"X","can_delete":false,"product_type":"c1","uid":1760295,"ip_address":"北京","ucode":"0B0FA86372A621","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKEDxLO0wLibic5WkVl1x7TIL0fsxX1zl2GbRjutYQ89fGRrv2VKJtNmmJb32iarbcHROlmW8SOQsHag/132","comment_is_top":false,"comment_ctime":1667118904,"is_pvip":true,"replies":[{"id":131344,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1667210723,"ip_address":"北京","comment_id":361020,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"能把复杂的东西讲的老少皆宜,各层次人都能看懂，可见基础扎实,内功深厚,感谢老师！","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592221,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667210723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357249,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"北京","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1663119178,"is_pvip":false,"replies":[{"id":130025,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663135794,"ip_address":"北京","comment_id":357249,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"网络编程是自己的弱项，老师的这篇文章解决了我不少疑惑，需要再次消化。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587537,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663135794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348129,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654762720,"is_pvip":false,"replies":[{"id":126863,"content":"火眼金睛啊。的确是代码中的fd_unix.go有问题，netFD定义在fd_posix.go中，一会让编辑老师改一下这块。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654829619,"ip_address":"","comment_id":348129,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"文中“我们以net&#47;fd_posix.go中的netFD为例看看”这里的fd_posix.go是不是有问题呀，我看下面代码引用注释里是fd_unix.go","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575433,"discussion_content":"火眼金睛啊。的确是代码中的fd_unix.go有问题，netFD定义在fd_posix.go中，一会让编辑老师改一下这块。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654829619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348121,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1654761369,"is_pvip":false,"replies":[{"id":126862,"content":"嗯。你的理解没错。超时后，如果没有重新设置，后续所有读操作才都会一直返回读超时错误。这块的确表述不清，我调整一下，之后让编辑老师更新下。感谢指出，手动抱拳:)","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654829181,"ip_address":"","comment_id":348121,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师，文中的socket读设置超时时间的这个地方，“一旦通过这个方法设置了某个 socket 的 Read deadline，那么无论后续的 Read 操作是否超时，只要我们不重新设置 Deadline，那么后面与这个 socket 有关的所有读操作，都会返回超时失败错误。”这里是不是应该是“设置了某个socket的Read deadline，然后再发生了读超时，这个读超时后面如果不从新设置，后面所有的读操作都会返回超时失败错误呢？”。这里先是设置了，应该要发生读超时，才行吧？这里没看大懂","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575431,"discussion_content":"嗯。你的理解没错。超时后，如果没有重新设置，后续所有读操作才都会一直返回读超时错误。这块的确表述不清，我调整一下，之后让编辑老师更新下。感谢指出，手动抱拳:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654829181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2732243,"avatar":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","nickname":"功夫熊猫","note":"","ucode":"D124F4FA4E816F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":577519,"discussion_content":"老师你的意思是不是说只要有一次读操作超时，那么这个读操作后的所有读操作无论超没超时都返回超时的错误","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1656161548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":575431,"ip_address":"","group_id":0},"score":577519,"extra":""}]}]},{"had_liked":false,"id":343954,"user_name":"ddh","can_delete":false,"product_type":"c1","uid":2806043,"ip_address":"","ucode":"8E852375365F16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","comment_is_top":false,"comment_ctime":1651141990,"is_pvip":false,"replies":[{"id":125652,"content":"哈哈😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1651269462,"ip_address":"","comment_id":343954,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师什么时候出Go语言第二课","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568933,"discussion_content":"哈哈😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651269462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332553,"user_name":"River","can_delete":false,"product_type":"c1","uid":1915496,"ip_address":"","ucode":"F194C87D8AA306","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/68/373b90c8.jpg","comment_is_top":false,"comment_ctime":1643338866,"is_pvip":false,"replies":[{"id":121500,"content":"接口的type assert(类型断言)语法。看核心篇28讲中的接口语法部分有说明。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643360540,"ip_address":"","comment_id":332553,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师，tc, ok := c.(*TCPConn) 这是什么用法？ 是把变量 c 强制转换成一个新的*TCPConn类型变量吗，并返回一个布尔值（表示强转是否成功吗？），变量后跟“.()”的用法既不像调用变量的属性也不想调用变量的方法，这种用法是go语言内置的吗？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548766,"discussion_content":"接口的type assert(类型断言)语法。看核心篇28讲中的接口语法部分有说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643360540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332037,"user_name":"Da Vinci","can_delete":false,"product_type":"c1","uid":1061671,"ip_address":"","ucode":"DB3B7F6A6028C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/27/e5a74107.jpg","comment_is_top":false,"comment_ctime":1642992185,"is_pvip":true,"replies":[{"id":121507,"content":"哈哈😁","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643361525,"ip_address":"","comment_id":332037,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"整个课程下来，感觉自己还是收获不少的，以前很多比较模糊的东西，学习完课程后很明了了，被白老师圈粉了。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548774,"discussion_content":"哈哈😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643361525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383666,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699426354,"is_pvip":false,"replies":[{"id":139864,"content":"好问题！关于网络通信异常情况的处理的确是最难确定的。\n\n对于服务端而言，如果是读超时，那么继续读就ok了。如果是写超时，多半客户端出问题了，关闭连接，等待客户端重连是底限。\n\n对于客户端，如果是读超时，同样可以继续读。如果是写超时，可以关闭连接，重连，然后重发请求。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699450341,"ip_address":"辽宁","comment_id":383666,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"老师我想问下这里具体的错误处理是怎么做的，\n比如客户端和服务端 遇到读写超时的具体应该怎么处理，\n\n像文中提到 的客户端已经关闭socket， 而服务端还在写数据的时候，这个时候 服务端收到socket关闭的信息了 是不是首先应该停止写入，再关掉socket。\n因为继续写入已经没有意义，如果写缓冲区满了 还会造成写超时。\n\n关于读写超时： 我的理解是服务端 \n如果遇到 读超时 这个时候应该认为客户端不活跃了，应该关闭socket\n写超时的话。 有可能是网络不好，也有可能客户端下线了 ，是不是也是关闭socket。\n\n\n客户端的处理是不是要复杂一些？\n客户端遇到读超时，一般是因为发起了请求，而请求没有得到回应，这个时候是不是应该关闭socket，然后重新建立socket连接，与此同时还要做一些额外的状态恢复操作。\n写超时是不是同样如此，\n烦请老师解惑， 有关于这方面好的文章和书籍都可以推荐给我细看，谢谢","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548774,"discussion_content":"哈哈😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643361525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333997,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1644659387,"is_pvip":false,"replies":null,"discussion_count":4,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"终于明白用 Go 替换 Java 做 IO 密集型压测为什么没有压到性的优势。因为多个 Goroutine 从 conn 中读写时都有锁保护，没有逃出枷锁。\n","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631305,"discussion_content":"好问题！关于网络通信异常情况的处理的确是最难确定的。\n\n对于服务端而言，如果是读超时，那么继续读就ok了。如果是写超时，多半客户端出问题了，关闭连接，等待客户端重连是底限。\n\n对于客户端，如果是读超时，同样可以继续读。如果是写超时，可以关闭连接，重连，然后重发请求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699450341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359145,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"广东","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1665288912,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"go最搞笑的地方，非要把fd藏起来，每次要拿他都贼麻烦","like_count":0,"discussions":[{"author":{"id":1297559,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/97/ae4d1400.jpg","nickname":"林枫","note":"","ucode":"38B9CBE7F42174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561919,"discussion_content":"基于goroutine同步阻塞+netpoller的多路复用，除了降低了编码复杂度，性能上感觉没有提升。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649746738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1297559,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/97/ae4d1400.jpg","nickname":"林枫","note":"","ucode":"38B9CBE7F42174","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562056,"discussion_content":"应该是底层实现受到了锁的限制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649770203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":561919,"ip_address":"","group_id":0},"score":562056,"extra":""}]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589729,"discussion_content":"java要有绿色线程了，go更没优势了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665288975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","nickname":"梁中华","note":"","ucode":"52FE40242CBAD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569058,"discussion_content":"如果用netty这种NIO框架，性能应该是差不多的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651304929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}