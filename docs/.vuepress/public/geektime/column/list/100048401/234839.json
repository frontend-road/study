{"id":234839,"title":"18 | 搜索引擎：输入搜索词以后，搜索引擎是怎么工作的？","content":"<p>你好，我是陈东。今天我来讲讲搜索引擎的核心架构。</p><p>搜索引擎你应该非常熟悉，它是我们学习和工作中非常重要的一个工具。它的特点是能在万亿级别的网页中，快速寻找出我们需要的信息。可以说，以搜索引擎为代表的检索技术，是所有基于文本和关键词的检索系统都可以学习和参考的。</p><p>那今天，我们就一起来聊一聊，在输入搜索词以后，搜索引擎是怎么工作的。</p><p>首先，我们一起来了解一下搜索引擎的核心架构和工作过程。然后再重点分析其中的检索系统。</p><h2>搜索引擎的整体架构和工作过程</h2><p>搜索引擎会涉及非常多技术领域。其中，比较重要的有网页抓取、文本分析、检索模型、索引技术、链接分析、反作弊、云存储和云计算。正是因为涉及的领域非常多，所以搜索引擎完整的系统架构也非常复杂，会由许多子系统组成。</p><p>不过，我们可以从功能结构上，把搜索引擎的核心系统分为三部分，分别是爬虫系统、索引系统和检索系统。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c4/07/c4ad7eff4b692d25921d54c785197e07.jpg?wh=1920*829\" alt=\"\" title=\"搜索引擎核心架构示意图\"></p><p>接下来，我们就分别说说，这三部分子系统具体的作用和工作过程。</p><p><strong>首先是爬虫系统。</strong></p><p>一个好的搜索引擎，必须要能采集足够多的网页。因此，我们需要通过高性能的爬虫系统来完成持续的网页抓取，并且将抓取到的网页存入存储平台中。一般来说，我们可以将抓取到的网页存放在基于LSM树的HBase中，以便支持数据的高效读写。</p><!-- [[[read_end]]] --><p><strong>其次是索引系统。</strong></p><p>在爬虫系统抓取到网页之后，我们需要对这些网页进行一系列的处理，它们才可以变成可用的索引。处理可以分为两个阶段，首先是对网页进行预处理，主要的手段包括相似网页去重、网页质量分析、分词处理等工作，然后是对网页进行反作弊的分析工作，来避免一些作弊网页干扰搜索结果。</p><p>处理好网页之后，我们就要为搜索引擎生成索引，索引的生成过程主要可以分为三步。</p><p><strong>第一步，索引拆分</strong>。由于抓取到的网页量级非常大，把它们全部都生成索引不太现实，因此我们会在离线阶段，根据之前的网页预处理结果，进行计算和筛选，分别分离出高质量和普通质量的网页集合。这样，我们就能进行分层索引了（<a href=\"https://time.geekbang.org/column/article/227161\">第12讲</a>）。当然，无论是高质量的网页集合还是普通质量的网页集合，数据量都不小。因此，我们还需要进行基于文档的拆分（<a href=\"https://time.geekbang.org/column/article/225869\">第10讲</a>），以便生成索引。</p><p><strong>第二步，索引构建</strong>。在确认了索引的分片机制以后，我们可以使用Map Reduce服务，来为每个索引分片生成对应的任务，然后生成相应的倒排索引文件（<a href=\"https://time.geekbang.org/column/article/222810\">第8讲</a>）。每个倒排索引文件代表一个索引分片，它们都可以加载到线上的服务器中，来提供检索服务。</p><p><strong>第三步，索引更新</strong>。为了保证能实时更新数据，搜索引擎会使用全量索引结合增量索引的机制来完成索引更新。并且由于搜索引擎的全量索引数据量巨大，因此，我们一般使用滚动合并法来完成索引更新（<a href=\"https://time.geekbang.org/column/article/222807\">第9讲</a>）。</p><p>有了这样创建出来的索引之后，搜索引擎就可以为万亿级别的网页提供高效的检索服务了。</p><p><strong>最后是检索系统。</strong></p><p>在检索阶段，如果用户搜索了一个关键词，那么搜索引擎首先需要做查询分析，也就是通过分析查询词本身以及用户行为特征，找出用户的真实查询意图。如果发现查询词有误或者结果很少，搜索引擎还会进行拼写纠正或相关查询推荐，然后再以改写后的查询词去检索服务中查询结果。</p><p>在检索服务中，搜索引擎会将查询词发送给相应的索引分片，索引分片通过倒排索引的检索机制，将自己所负责的分片结果返回。对于返回的结果，搜索引擎再根据相关性分析和质量分析，使用机器学习进行打分，选出Top K个结果（<a href=\"https://time.geekbang.org/column/article/226100\">第11讲</a>）来完成检索。</p><p>以上就是一个搜索引擎的完整的工作机制了。那与广告引擎和推荐引擎相比，<strong>搜索引擎最大的特点，就是它有一个很强的检索约束条件，那就是用户输入的查询词。可以说，查询词是搜索引擎进行检索的最核心的信息。</strong>但是很多时候，用户输入的查询词是含糊的、不精准的，甚至是带有错误的。还有一种可能是，用户输入的查询词不在倒排索引中。</p><p>这些问题也都是搜索引擎要解决的核心问题。因此，接下来，我们就以搜索“极客时间”为例，来讲讲搜索引擎的解决方案。</p><h2>搜索引擎是如何进行查询分析的？</h2><p>一般来说，用户在搜索的时候，搜索词往往会非常简短，很难完全体现用户的实际意图。而如果我们无法准确地理解用户的真实意图，那搜索结果的准确性就无从谈起了。因此，搜索引擎中检索系统的第一步，一定是进行查询分析。具体来说，就是理解用户输入的搜索词，并且对输错的查询词进行查询纠正，以及对意图不明的查询词进行查询推荐。那查询分析具体该怎么做呢？</p><p>在查询分析的过程中，我们主要会对搜索词进行分词粒度分析、词的属性分析、用户需求分析等工作。其中，分词粒度分析直接关系到我们以什么key去倒排索引中检索，而属性分析和需求分析则可以帮助我们在打分排序时，有更多的因子可以考虑。因此，<strong>分词粒度分析是查询分析的基础</strong>。那什么是分词粒度分析呢？<br>\n<img src=\"https://static001.geekbang.org/resource/image/60/11/602bdfacb4e902835ece292fc8b04e11.jpg?wh=1920*939\" alt=\"\" title=\"查询分析工作示意图\"></p><p>分词粒度分析是中文搜索中特有的一个环节。因为中文词和英文词相比，最大的区别是词与词之间没有明确的分隔标志（空格）。因此，对于中文的搜索输入，我们要做的第一件事情，是使用分词工具进行合理的分词。但分词，就会带来一个分词粒度的问题。</p><p>比如说，当用户输入“极客时间”时：如果我们按单字来切分，这个搜索词就会变成“极/客/时/间”这四个检索词；如果是按“极客/时间”来切分，就会变成两个检索词的组合；如果是不做任何分词，将“极客时间”当成一个整体，那就是一个搜索短语。切分的方式这么多，到底我们该怎么选择呢？</p><p>一般来说，我们会使用默认的标准分词粒度再结合整个短语，作为我们的检索关键词去倒排索引中检索，这就叫作混合粒度的分词方式。那“极客时间”就会被分为【极客、时间、极客时间】这样的检索词组合。如果检索后返回的结果数量不足，那我们还会去查询【极、客、时、间】这样的更细粒度的单字组合。<br>\n<img src=\"https://static001.geekbang.org/resource/image/3c/0f/3c7269d52b0062b336565c4d8e63630f.jpg?wh=1920*898\" alt=\"\" title=\"中文分词粒度分析示意图\"></p><h2>搜索引擎是如何进行查询纠错的？</h2><p>以上，都是在用户输入正确搜索词时的查询分析。那如果用户的输入有误，比如说，将“极客时间”输成了“即可时间”，或者是“级可时间”，搜索引擎又会怎么办呢？这个时候，我们就需要用到查询纠错功能和查询推荐功能了。</p><p>我们先来说一说查询纠错功能是如何使用的。查询纠错的过程一般会分为三个步骤，分别是错误判断、候选召回和打分排序。<br>\n<img src=\"https://static001.geekbang.org/resource/image/2a/21/2ae5ac04a082e1926d6e0cc692759b21.jpg?wh=1920*808\" alt=\"\" title=\"查询纠错过程示意图\"></p><p>一般来说，在错误判断阶段，我们会根据人工编辑以及对搜索日志进行数据挖掘，得到常见字典和混淆字典。然后，我们使用哈希表或者字典树等结构来对字典进行索引，使得这两个字典具有高效的检索能力。如果某个分词后的检索词，我们无法在常用字典中查询到，或者它出现在了混淆字典中，那就说明这个词很可能是错误的。因此，我们还需要启动后续的候选召回和打分排序步骤。</p><p>不过，近年来，基于语言模型和机器学习的错误判断方式被广泛地使用。这种判断方式具体来说就是，我们会在用户输入检索词后，先对其进行置信度判断，如果得分过低，再进入后续的纠错过程。这能帮助我们更好地进行纠错。为什么这么说呢？我们来看一个例子，如果我们将“极客”错误地输入成了“级可”，通过检索常用字典和混淆字典，我们是有可能发现这个错误的。但如果我们错输成“即可”，由于“即可”本身也是一个合理的词，因此我们就需要使用基于语言模型和机器学习的方法，计算“即可”这个词出现在这个上下文中的置信度，才能发现有错。</p><p>在错误判断完成之后，就进入候选召回阶段了。在候选召回中，我们会预估查询词出错的每种可能性，提前准备好可能的正确结果。一般情况下，中文输入有2种常见的出错情况。</p><p>第1种，拼音相同但是字不同。这时，我们就要将相同拼音的词作为候选集，以拼音为Key进行检索。第2种是字形相似，那我们就生成一个相似字型的词典，通过该词典召回候选集。此外，还有根据编辑距离进行相似召回，根据机器学习得到候选集进行召回等。通过这些不同的纠错方式，我们就能得到可能的纠错结果集合了。</p><p>最后，我们要对众多的纠错结果进行打分排序。在这个过程中，我们可以使用各种常见的机器学习和深度学习算法进行打分判断（你可以回忆一下11讲，我们讲过的那些方法），将得分最高的纠错结果返回。这样就完成了整个查询纠错过程。</p><p>好了，到这里，我们就把查询纠错的过程说完了。至于查询推荐，则更多的是分析搜索日志的结果，用“查询会话”“点击图”等技术，来分析哪些检索词之间有相关性。比如说，如果检索“极客时间”和检索“极客邦”的用户都会浏览相同的网页，那么“极客邦”就很有可能出现在“极客时间”的相关推荐中。</p><p>因此，查询推荐可以提供出更多的关键词，帮助搜索引擎召回更多的结果。它一般会在关键词不足的场景下被启用，或是作为补充提示出现。所以，关于查询推荐我就不再多说了，你只要记住查询推荐的原理就可以了。</p><p>总的来说，通过查询分析、查询纠错、查询推荐的过程，搜索引擎就能对用户的意图有一个更深入的理解。那接下来，我们就通过得到的一系列关键词，也就是【极客、时间、极客时间】，去查询倒排索引了。</p><h2>搜索引擎是如何完成短语检索的？</h2><p>首先，我们可以使用“极客时间”作为一个完整的关键词去倒排索引中查找。如果倒排索引中能查询到这个关键词，并且返回的结果集足够，那这样的检索结果是非常精准的。但是，这依赖于我们在构建索引的时候，必须将“极客时间”作为一个关键词进行处理。</p><p>可是在构建倒排索引的时候，我们一般是通过分析搜索日志，将一些常见的热门短语作为关键词加入倒排索引中。由于能被直接作为关键词的短语数量不会太多，因此，如果“极客时间”没有被识别为热门短语进行单独处理的话，那我们拿着“极客时间”这个短语作为关键词，直接查询的结果就是空的。</p><p>在这种情况下，我们就会使用更细粒度的分词结果，也就是使用“极客”和“时间”这两个关键词，去做两次检索，然后将得到的结果求交集合并。不过，这样做就会有一个问题：如果只是简单地将这两个关键词检索出来的文档列表求交集合并，那我们最终得到的结果并不一定会包含带有“极客时间”的文档。这又是为什么呢？</p><p>你可以考虑一下这种情况：如果有一个网页中有一句话是“一个极客往往没有时间打游戏”。那我们搜索“极客”“时间”这两个关键词的时候，这个网页就会被检索出来。但这是我们期望的检索结果吗？并不是。因为“极客”和“时间”的位置离得太远了。</p><p>那如果我们能记录下关键词出现在文档中的位置，并且在合并文档列表的时候，判断两个关键词是否接近，不就可以解决这个问题？没错，这种方法就叫作<strong>位置信息索引法</strong>。我们会通过两个关键词的位置关系来判断该文档和检索词的相关性。位置越远，相关性就越小，如果位置直接邻接在一起，相关性就最高。</p><p>如果是两个以上的关键词联合查询，那我们会将同时包含所有关键词的最小片段称为最小窗口，然后通过衡量查询结果中最小窗口的长度，来判断多个关键词是否接近。这么说比较抽象，我们来举个例子。当我们分别以“极”“客”“时”“间”这四个字作为关键词查询时，如果一个文档中有这么一句话“<strong>极</strong>多<strong>客</strong>人，一<strong>时</strong>之<strong>间</strong>”，那字符“极”到字符“间”之间就是9个字符。也就是说，在这句话中覆盖“极”“客”“时”“间”这四个关键词的最小窗口长度就是9。</p><p>有了这个方法，我们就可以将搜索结果按照最小窗口长度排序，然后留下相关性最高的一批结果了。这样，我们就完成“极客时间”的短语检索了。</p><h2>重点回顾</h2><p>今天，我们主要讲了搜索引擎的整体架构和工作原理。并且，由于搜索引擎的业务特点会非常依赖用户输入的查询词，因此，我们还重点讨论了搜索引擎对查询词进行的一系列特殊处理技术。</p><p>通常的流程是，先对查询词进行查询分析，搜索引擎通过对查询词进行不同粒度的分词，得到多个检索词。在这个过程中，搜索引擎还会通过查询纠错和相似推荐，拓展出更多的检索词候选。</p><p>然后，搜索引擎会利用得到的检索词在倒排索引中进行短语检索。这个时候，搜索引擎会通过位置信息索引法，来判断检索结果和检索词的相关性。最后，搜索引擎会通过对搜索结果中最小窗口的长度排序，留下相关性最高的结果。</p><p>除此之外，你还会看到很有意思的一点：查询纠错中也存在候选召回和打分排序这两个环节。实际上，许多业务的核心检索过程，都可以抽象为候选召回和打分排序这两个阶段，包括我们后面会讲到的广告系统和推荐系统也是一样。因此，如何将一个业务根据自身的特点，抽象成合适的检索过程，是 一个很重要的设计能力。那这部分内容我希望你能多看几遍，来加深理解，后面的课程中，我们也会继续学习相关的内容。</p><h2>课堂讨论</h2><ol>\n<li>在使用位置信息索引法中，我们在计算最小窗口的时候需要保证关键词是有序的。如果这个时候有两个关键词的话，我们可以先固定第一个关键词，然后只找它和第二个关键词的距离就可以了。那如果有3个关键词，我们又该如何保证次序呢？</li>\n<li>对于搜索引擎的检索技术，你还有什么想要了解和讨论的？</li>\n</ol><p>欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这一讲分享给你的朋友。</p>","comments":[{"had_liked":false,"id":217912,"user_name":"李","can_delete":false,"product_type":"c1","uid":1396623,"ip_address":"","ucode":"426288EBB410C2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfQFSpQJNKeqW5Q9PfciaLyDDFm9heqW5SHQCzlrajXO8f38RCH3BE5k8QHGPMictbbAM9IGvicj5EQ/132","comment_is_top":false,"comment_ctime":1589645296,"is_pvip":false,"replies":[{"id":80628,"content":"搜索引擎方面的书籍，其实《信息检索导论》是可以作为基础学习的。因为其中一个作者就是Google的副总裁，书中就以搜索引擎为例子。包括还有《搜索引擎:信息检索实践》。\n国内还有《这就是搜索引擎:核心技术详解》这类书籍，都可以看看。\n至于网络爬虫，这更偏向于实践和工程。可能要结合你使用的编程语言。比如说Python的scrapy，或者Java相关的网络爬虫书籍。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589697950,"ip_address":"","comment_id":217912,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师有没有爬虫或者搜索方面的书籍推荐的","like_count":6},{"had_liked":false,"id":215984,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589163718,"is_pvip":false,"replies":[{"id":79974,"content":"page rank是Google很重要的一个专利，不过它的核心思想其实不复杂。它通过分析不同网页之间的相互链接关系，来判断网页的质量。打个比方，就像论文引用一样，被大量高质量论文引用的论文，应该也是高质量论文。page rank就是通过这样的方式，对每个网页赋予了一个质量分。\n那具体会在哪些环节使用page rank质量分呢？\n1.在进行索引分层时，高质量网页和普通质量网页需要区分，这时候page rank质量分就是一个很重要的参考。\n2.打分排序阶段，page rank质量分也是很重要的因子。\n3.在进行锚文本分析时，高质量网页出来的锚文本更重要。\n4.在爬虫抓取网页时，可以优先抓取高质量的网页链接出来的网页。\n以上是我想到的一些场景，供参考","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589191405,"ip_address":"","comment_id":215984,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"请问老师，我们经常听说的page rank算法在搜索引擎中是怎么具体应用的？","like_count":6,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495289,"discussion_content":"搜索引擎方面的书籍，其实《信息检索导论》是可以作为基础学习的。因为其中一个作者就是Google的副总裁，书中就以搜索引擎为例子。包括还有《搜索引擎:信息检索实践》。\n国内还有《这就是搜索引擎:核心技术详解》这类书籍，都可以看看。\n至于网络爬虫，这更偏向于实践和工程。可能要结合你使用的编程语言。比如说Python的scrapy，或者Java相关的网络爬虫书籍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589697950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217906,"user_name":"林苏荣","can_delete":false,"product_type":"c1","uid":1918867,"ip_address":"","ucode":"CD15A1B31B9A2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epH88PRR85bKsjwIBjo4wclgiaj4AJeoq8Lx3Af21xFxXibpAiaAkLBJAN8jx97Zic8kuP1iatEkj6C23g/132","comment_is_top":false,"comment_ctime":1589643637,"is_pvip":false,"replies":[{"id":80622,"content":"其实复杂的系统都是由简单的子系统和技术构成的。\n架构设计的目的，就是希望能将复杂系统拆解成更简单的子系统，使得我们可以更容易去开发实现。\n而在子系统中，在我们了解了对应的原理和解决方案以后，我相信开发起来会容易上手得多。\n\n当然，技术也是一直在进化的，专业的技术和算法优化肯定也是一直在前进。比如说排序算法，就从bm25到机器学习再到深度学习，这就是典型的例子。工业系统中的具体优化细节有很多，肯定不是一个专栏能写得完的。但这些新技术的根源还是从原理和解决问题出发演化出来的。因此，我们要更好地去理解原理和场景，这能帮助我们更好地理解和学习新技术。\n\n还有，关于是否堆机器的问题，现在许多大型系统都是采用分布式架构，一个好处就是可以堆机器，大家也的确都会堆机器。但是我们也不能无脑堆机器。比如说，网页的数量每年增长30%，那难道搜索引擎的服务器就要每年加30%?这是不现实的。因此，我们需要使用分层索引的设计，来保证我们不需要堆太多的机器。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589688106,"ip_address":"","comment_id":217906,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"首先，感谢老师这么多课程的专业讲解。这些课程都是从很基础的原理开始，构建出整个技术架构。请问老师，在实际工业的应用中，是否都是基于这些基础原理，结合具体的业务场景做组合优化来实现。还是有其他更加专业的算法优化和设计呢？毕竟光是考虑搜索引擎所涉及的数据量就已经是天文数字了，再考虑各种处理逻辑，，，依据这些基础原理真的足以应对吗？还是一个老套路，性能不够机器来凑^O^，用超大规模的集群来完成的，谢谢。","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494630,"discussion_content":"page rank是Google很重要的一个专利，不过它的核心思想其实不复杂。它通过分析不同网页之间的相互链接关系，来判断网页的质量。打个比方，就像论文引用一样，被大量高质量论文引用的论文，应该也是高质量论文。page rank就是通过这样的方式，对每个网页赋予了一个质量分。\n那具体会在哪些环节使用page rank质量分呢？\n1.在进行索引分层时，高质量网页和普通质量网页需要区分，这时候page rank质量分就是一个很重要的参考。\n2.打分排序阶段，page rank质量分也是很重要的因子。\n3.在进行锚文本分析时，高质量网页出来的锚文本更重要。\n4.在爬虫抓取网页时，可以优先抓取高质量的网页链接出来的网页。\n以上是我想到的一些场景，供参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589191405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263201,"discussion_content":"page rank 算法 是给每个文档的重要性进行打分， 在搜索引擎中 就是文档的静态质量分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589187031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215948,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589158551,"is_pvip":false,"replies":[{"id":79925,"content":"是的。这其实是一个贪心算法。局部最优一定是全局最优。\n首先，第一个词可能会出现在n个位置。我们遍历第一个词的所有位置。\n然后，当第一个词固定位置时，我们寻找这个位置后面的最近的第二个词的位置。这样就能固定第二个词的位置。\n接着，在第二个词固定以后，我们再在第二个词后面，找最近的第三个词的位置。那么，这个位置和第一个词的位置结合，就是这次计算得到的最小窗口长度。(之所以说是贪心算法，是因为我们不需要穷举所有第二个词和第三个词的位置组合，而是只需要找最近的就可以了)\n然后我们把第一个词的这n个位置的最小窗口长度都算出来，取最小的一个，就得到了最终结果。\n当然，在求第一个词的n个位置的n个最小窗口的过程中，我们还能利用之前计算的结果。比如说第一个词的第二个位置，其实也在第二个词的前面，那么第二个词的位置不用变，第三个词的位置也不用变了。\n整体来说，你会看到，位置信息索引法，计算代价会比较大，因此，对于热门短语，能直接作为key加入倒排索引是更高效的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589166960,"ip_address":"","comment_id":215948,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"先固定第一个词，然后找第二个词的距离。第二个词距离固定以后，找第三个词和第二个词的距离。","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495287,"discussion_content":"其实复杂的系统都是由简单的子系统和技术构成的。\n架构设计的目的，就是希望能将复杂系统拆解成更简单的子系统，使得我们可以更容易去开发实现。\n而在子系统中，在我们了解了对应的原理和解决方案以后，我相信开发起来会容易上手得多。\n\n当然，技术也是一直在进化的，专业的技术和算法优化肯定也是一直在前进。比如说排序算法，就从bm25到机器学习再到深度学习，这就是典型的例子。工业系统中的具体优化细节有很多，肯定不是一个专栏能写得完的。但这些新技术的根源还是从原理和解决问题出发演化出来的。因此，我们要更好地去理解原理和场景，这能帮助我们更好地理解和学习新技术。\n\n还有，关于是否堆机器的问题，现在许多大型系统都是采用分布式架构，一个好处就是可以堆机器，大家也的确都会堆机器。但是我们也不能无脑堆机器。比如说，网页的数量每年增长30%，那难道搜索引擎的服务器就要每年加30%?这是不现实的。因此，我们需要使用分层索引的设计，来保证我们不需要堆太多的机器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589688106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225483,"user_name":"李小龙","can_delete":false,"product_type":"c1","uid":1158263,"ip_address":"","ucode":"1B64CB66AF0765","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","comment_is_top":false,"comment_ctime":1591764622,"is_pvip":false,"replies":[{"id":83110,"content":"如果是从零开始，进行文本搜索的话，最简单的做法是使用MySQL的全文检索功能，但是效果会比较差。\n如果想更精准地进行关键词检索，那么可以使用elastic search来搭建你们的系统。当然，如果想定制各种功能，那么可以走上自研的方向。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1591797519,"ip_address":"","comment_id":225483,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师公司怎么从零搭建搜索","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494618,"discussion_content":"是的。这其实是一个贪心算法。局部最优一定是全局最优。\n首先，第一个词可能会出现在n个位置。我们遍历第一个词的所有位置。\n然后，当第一个词固定位置时，我们寻找这个位置后面的最近的第二个词的位置。这样就能固定第二个词的位置。\n接着，在第二个词固定以后，我们再在第二个词后面，找最近的第三个词的位置。那么，这个位置和第一个词的位置结合，就是这次计算得到的最小窗口长度。(之所以说是贪心算法，是因为我们不需要穷举所有第二个词和第三个词的位置组合，而是只需要找最近的就可以了)\n然后我们把第一个词的这n个位置的最小窗口长度都算出来，取最小的一个，就得到了最终结果。\n当然，在求第一个词的n个位置的n个最小窗口的过程中，我们还能利用之前计算的结果。比如说第一个词的第二个位置，其实也在第二个词的前面，那么第二个词的位置不用变，第三个词的位置也不用变了。\n整体来说，你会看到，位置信息索引法，计算代价会比较大，因此，对于热门短语，能直接作为key加入倒排索引是更高效的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589166960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310984,"user_name":"dakingkong","can_delete":false,"product_type":"c1","uid":1247568,"ip_address":"","ucode":"6B492887E7E4A2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/J1ADsCjfat7ibMcup6DV9DhH3lzKo2lIeBqCjuBa5nIWYu7u8NYDFb3iaPRp9cia9uH4464GDaGKcd7c0d0dkhibbA/132","comment_is_top":false,"comment_ctime":1631009120,"is_pvip":false,"replies":[{"id":113595,"content":"不需要加锁。memtable使用了巧妙的无锁设计，使得性能能更优。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1632579731,"ip_address":"","comment_id":310984,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，请问下Leveldb，是一写多读的吗？内存中的memtable在一写多读时，需要加锁吗？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526424,"discussion_content":"不需要加锁。memtable使用了巧妙的无锁设计，使得性能能更优。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632579731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216049,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589174430,"is_pvip":false,"replies":[{"id":79983,"content":"其实不需要动态规划法，使用贪心法就够了。\n首先我们算出来锁定A1时的最小窗口。然后我们再去计算当第一个关键词取A2位置时的最小窗口。\n在计算A2的最小窗口的时候，我们可以先判断A2的位置是否小于B1,如果小于的话，那么最小窗口就是A2-B1－C1。如果A2大于B1的话，那么就重新往后找到B2。以此类推。这样，对于每个关键词的位置，我们都不会回头重复计算。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589207573,"ip_address":"","comment_id":216049,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"关于第一个讨论题，开始的想法，使用位置信息索引法中，对于3个关键词的情况，可以锁定第一个关键词，找到最小窗口的第二关键词，然后锁定这个第二个关键词，寻找最小窗口的第三个关键词。但是老师文章中提到`如果是两个以上的关键词联合查询，那我们会将同时包含所有关键词的最小片段称为最小窗口`，这个方法貌似跟这句话相违背。举个栗子，假设这三个关键词是A B C，某一篇文章中有两处含有这三个关键词，他们之间最小窗口距离是 A1~2~B1~5~C1 （A1和B1之间距离是2，B1和C1之间距离是5）, A2~3~B2~3~C2。按照开始想法的解法是，锁定A，找到最小窗口的B，是B1，因最小距离是2。然后锁定B1，找到最小距离是C1（假设B1和C2之间距离远大于5）。但是单独看B和C之间的距离，B2与C2应该是最小的。另外，如果看包含所有关键词的话，A2 B2 C2之间最小窗口是最优的，如此的话，得使用动态规划方法来计算了，但是这样一来复杂度变高了。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494652,"discussion_content":"其实不需要动态规划法，使用贪心法就够了。\n首先我们算出来锁定A1时的最小窗口。然后我们再去计算当第一个关键词取A2位置时的最小窗口。\n在计算A2的最小窗口的时候，我们可以先判断A2的位置是否小于B1,如果小于的话，那么最小窗口就是A2-B1－C1。如果A2大于B1的话，那么就重新往后找到B2。以此类推。这样，对于每个关键词的位置，我们都不会回头重复计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589207573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263259,"discussion_content":"你这个例子中的最小窗口距离是： A2~3~B2~3~C2， 因为这里会遍历所有第一个关键词求出所有的窗口距离，然后取最小的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589193495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1150927,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","nickname":"那时刻","note":"","ucode":"B0D150856C3A4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263282,"discussion_content":"这么取值的话，应该不是锁定关键词的意思吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589195476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263259,"ip_address":"","group_id":0},"score":263282,"extra":""},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1150927,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","nickname":"那时刻","note":"","ucode":"B0D150856C3A4A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263760,"discussion_content":"每篇文章，每个关键词都有可能出现多次，只需要找到距离最小的就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589245936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263282,"ip_address":"","group_id":0},"score":263760,"extra":""}]}]},{"had_liked":false,"id":258121,"user_name":"森森森","can_delete":false,"product_type":"c1","uid":1354906,"ip_address":"","ucode":"691BCB70327CBA","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/9a/6dda1d4f.jpg","comment_is_top":false,"comment_ctime":1604305671,"is_pvip":false,"replies":[{"id":94104,"content":"一般来说，我们会采用微服务架构来搭建系统。系统中有一个排序模型的服务，专门负责排序功能。这个服务可以使用逻辑回归模型来实现，也能使用深度学习模型，但是不管内部怎么实现，对外提供一个统一的服务接口即可。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1604417598,"ip_address":"","comment_id":258121,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师如果使用深度学习进行排序，那么深度学习的线上预测模型是需要在搜索的排序阶段进行接口调用就可以了吗？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508557,"discussion_content":"一般来说，我们会采用微服务架构来搭建系统。系统中有一个排序模型的服务，专门负责排序功能。这个服务可以使用逻辑回归模型来实现，也能使用深度学习模型，但是不管内部怎么实现，对外提供一个统一的服务接口即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604417598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216125,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1589193117,"is_pvip":false,"replies":[{"id":79984,"content":"在标准的短语查询中，窗口的定义就是第一个词到最后一个词的距离。\n你提出的两两之间的距离也是有意思的一个提法，也许在某些场景下是有效的，不过这样的判断可能会造成第一个词和最后一个词距离太远，在短语查询这个例子中可能不是很合适。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589207754,"ip_address":"","comment_id":216125,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"在进行查询次窗口计算的时候：是只计算查询词的第一个词和最后的一个词的距离吗？ 还是计算查询词中两两词之间的的距离？\n我认为计算查询次中两两词之间的窗口距离推荐的效果会更好一些","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494681,"discussion_content":"在标准的短语查询中，窗口的定义就是第一个词到最后一个词的距离。\n你提出的两两之间的距离也是有意思的一个提法，也许在某些场景下是有效的，不过这样的判断可能会造成第一个词和最后一个词距离太远，在短语查询这个例子中可能不是很合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589207754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373044,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1681966369,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100048401,"comment_content":"学习打卡","like_count":1},{"had_liked":false,"id":217912,"user_name":"李","can_delete":false,"product_type":"c1","uid":1396623,"ip_address":"","ucode":"426288EBB410C2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfQFSpQJNKeqW5Q9PfciaLyDDFm9heqW5SHQCzlrajXO8f38RCH3BE5k8QHGPMictbbAM9IGvicj5EQ/132","comment_is_top":false,"comment_ctime":1589645296,"is_pvip":false,"replies":[{"id":80628,"content":"搜索引擎方面的书籍，其实《信息检索导论》是可以作为基础学习的。因为其中一个作者就是Google的副总裁，书中就以搜索引擎为例子。包括还有《搜索引擎:信息检索实践》。\n国内还有《这就是搜索引擎:核心技术详解》这类书籍，都可以看看。\n至于网络爬虫，这更偏向于实践和工程。可能要结合你使用的编程语言。比如说Python的scrapy，或者Java相关的网络爬虫书籍。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589697950,"ip_address":"","comment_id":217912,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师有没有爬虫或者搜索方面的书籍推荐的","like_count":6,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495289,"discussion_content":"搜索引擎方面的书籍，其实《信息检索导论》是可以作为基础学习的。因为其中一个作者就是Google的副总裁，书中就以搜索引擎为例子。包括还有《搜索引擎:信息检索实践》。\n国内还有《这就是搜索引擎:核心技术详解》这类书籍，都可以看看。\n至于网络爬虫，这更偏向于实践和工程。可能要结合你使用的编程语言。比如说Python的scrapy，或者Java相关的网络爬虫书籍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589697950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215984,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589163718,"is_pvip":false,"replies":[{"id":79974,"content":"page rank是Google很重要的一个专利，不过它的核心思想其实不复杂。它通过分析不同网页之间的相互链接关系，来判断网页的质量。打个比方，就像论文引用一样，被大量高质量论文引用的论文，应该也是高质量论文。page rank就是通过这样的方式，对每个网页赋予了一个质量分。\n那具体会在哪些环节使用page rank质量分呢？\n1.在进行索引分层时，高质量网页和普通质量网页需要区分，这时候page rank质量分就是一个很重要的参考。\n2.打分排序阶段，page rank质量分也是很重要的因子。\n3.在进行锚文本分析时，高质量网页出来的锚文本更重要。\n4.在爬虫抓取网页时，可以优先抓取高质量的网页链接出来的网页。\n以上是我想到的一些场景，供参考","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589191405,"ip_address":"","comment_id":215984,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"请问老师，我们经常听说的page rank算法在搜索引擎中是怎么具体应用的？","like_count":6,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494630,"discussion_content":"page rank是Google很重要的一个专利，不过它的核心思想其实不复杂。它通过分析不同网页之间的相互链接关系，来判断网页的质量。打个比方，就像论文引用一样，被大量高质量论文引用的论文，应该也是高质量论文。page rank就是通过这样的方式，对每个网页赋予了一个质量分。\n那具体会在哪些环节使用page rank质量分呢？\n1.在进行索引分层时，高质量网页和普通质量网页需要区分，这时候page rank质量分就是一个很重要的参考。\n2.打分排序阶段，page rank质量分也是很重要的因子。\n3.在进行锚文本分析时，高质量网页出来的锚文本更重要。\n4.在爬虫抓取网页时，可以优先抓取高质量的网页链接出来的网页。\n以上是我想到的一些场景，供参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589191405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263201,"discussion_content":"page rank 算法 是给每个文档的重要性进行打分， 在搜索引擎中 就是文档的静态质量分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589187031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217906,"user_name":"林苏荣","can_delete":false,"product_type":"c1","uid":1918867,"ip_address":"","ucode":"CD15A1B31B9A2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epH88PRR85bKsjwIBjo4wclgiaj4AJeoq8Lx3Af21xFxXibpAiaAkLBJAN8jx97Zic8kuP1iatEkj6C23g/132","comment_is_top":false,"comment_ctime":1589643637,"is_pvip":false,"replies":[{"id":80622,"content":"其实复杂的系统都是由简单的子系统和技术构成的。\n架构设计的目的，就是希望能将复杂系统拆解成更简单的子系统，使得我们可以更容易去开发实现。\n而在子系统中，在我们了解了对应的原理和解决方案以后，我相信开发起来会容易上手得多。\n\n当然，技术也是一直在进化的，专业的技术和算法优化肯定也是一直在前进。比如说排序算法，就从bm25到机器学习再到深度学习，这就是典型的例子。工业系统中的具体优化细节有很多，肯定不是一个专栏能写得完的。但这些新技术的根源还是从原理和解决问题出发演化出来的。因此，我们要更好地去理解原理和场景，这能帮助我们更好地理解和学习新技术。\n\n还有，关于是否堆机器的问题，现在许多大型系统都是采用分布式架构，一个好处就是可以堆机器，大家也的确都会堆机器。但是我们也不能无脑堆机器。比如说，网页的数量每年增长30%，那难道搜索引擎的服务器就要每年加30%?这是不现实的。因此，我们需要使用分层索引的设计，来保证我们不需要堆太多的机器。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589688106,"ip_address":"","comment_id":217906,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"首先，感谢老师这么多课程的专业讲解。这些课程都是从很基础的原理开始，构建出整个技术架构。请问老师，在实际工业的应用中，是否都是基于这些基础原理，结合具体的业务场景做组合优化来实现。还是有其他更加专业的算法优化和设计呢？毕竟光是考虑搜索引擎所涉及的数据量就已经是天文数字了，再考虑各种处理逻辑，，，依据这些基础原理真的足以应对吗？还是一个老套路，性能不够机器来凑^O^，用超大规模的集群来完成的，谢谢。","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495287,"discussion_content":"其实复杂的系统都是由简单的子系统和技术构成的。\n架构设计的目的，就是希望能将复杂系统拆解成更简单的子系统，使得我们可以更容易去开发实现。\n而在子系统中，在我们了解了对应的原理和解决方案以后，我相信开发起来会容易上手得多。\n\n当然，技术也是一直在进化的，专业的技术和算法优化肯定也是一直在前进。比如说排序算法，就从bm25到机器学习再到深度学习，这就是典型的例子。工业系统中的具体优化细节有很多，肯定不是一个专栏能写得完的。但这些新技术的根源还是从原理和解决问题出发演化出来的。因此，我们要更好地去理解原理和场景，这能帮助我们更好地理解和学习新技术。\n\n还有，关于是否堆机器的问题，现在许多大型系统都是采用分布式架构，一个好处就是可以堆机器，大家也的确都会堆机器。但是我们也不能无脑堆机器。比如说，网页的数量每年增长30%，那难道搜索引擎的服务器就要每年加30%?这是不现实的。因此，我们需要使用分层索引的设计，来保证我们不需要堆太多的机器。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589688106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215948,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589158551,"is_pvip":false,"replies":[{"id":79925,"content":"是的。这其实是一个贪心算法。局部最优一定是全局最优。\n首先，第一个词可能会出现在n个位置。我们遍历第一个词的所有位置。\n然后，当第一个词固定位置时，我们寻找这个位置后面的最近的第二个词的位置。这样就能固定第二个词的位置。\n接着，在第二个词固定以后，我们再在第二个词后面，找最近的第三个词的位置。那么，这个位置和第一个词的位置结合，就是这次计算得到的最小窗口长度。(之所以说是贪心算法，是因为我们不需要穷举所有第二个词和第三个词的位置组合，而是只需要找最近的就可以了)\n然后我们把第一个词的这n个位置的最小窗口长度都算出来，取最小的一个，就得到了最终结果。\n当然，在求第一个词的n个位置的n个最小窗口的过程中，我们还能利用之前计算的结果。比如说第一个词的第二个位置，其实也在第二个词的前面，那么第二个词的位置不用变，第三个词的位置也不用变了。\n整体来说，你会看到，位置信息索引法，计算代价会比较大，因此，对于热门短语，能直接作为key加入倒排索引是更高效的。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589166960,"ip_address":"","comment_id":215948,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"先固定第一个词，然后找第二个词的距离。第二个词距离固定以后，找第三个词和第二个词的距离。","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494618,"discussion_content":"是的。这其实是一个贪心算法。局部最优一定是全局最优。\n首先，第一个词可能会出现在n个位置。我们遍历第一个词的所有位置。\n然后，当第一个词固定位置时，我们寻找这个位置后面的最近的第二个词的位置。这样就能固定第二个词的位置。\n接着，在第二个词固定以后，我们再在第二个词后面，找最近的第三个词的位置。那么，这个位置和第一个词的位置结合，就是这次计算得到的最小窗口长度。(之所以说是贪心算法，是因为我们不需要穷举所有第二个词和第三个词的位置组合，而是只需要找最近的就可以了)\n然后我们把第一个词的这n个位置的最小窗口长度都算出来，取最小的一个，就得到了最终结果。\n当然，在求第一个词的n个位置的n个最小窗口的过程中，我们还能利用之前计算的结果。比如说第一个词的第二个位置，其实也在第二个词的前面，那么第二个词的位置不用变，第三个词的位置也不用变了。\n整体来说，你会看到，位置信息索引法，计算代价会比较大，因此，对于热门短语，能直接作为key加入倒排索引是更高效的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589166960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225483,"user_name":"李小龙","can_delete":false,"product_type":"c1","uid":1158263,"ip_address":"","ucode":"1B64CB66AF0765","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","comment_is_top":false,"comment_ctime":1591764622,"is_pvip":false,"replies":[{"id":83110,"content":"如果是从零开始，进行文本搜索的话，最简单的做法是使用MySQL的全文检索功能，但是效果会比较差。\n如果想更精准地进行关键词检索，那么可以使用elastic search来搭建你们的系统。当然，如果想定制各种功能，那么可以走上自研的方向。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1591797519,"ip_address":"","comment_id":225483,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师公司怎么从零搭建搜索","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497862,"discussion_content":"如果是从零开始，进行文本搜索的话，最简单的做法是使用MySQL的全文检索功能，但是效果会比较差。\n如果想更精准地进行关键词检索，那么可以使用elastic search来搭建你们的系统。当然，如果想定制各种功能，那么可以走上自研的方向。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591797519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158263,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","nickname":"李小龙","note":"","ucode":"1B64CB66AF0765","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281721,"discussion_content":"老师如果是想快速搭建搜索的话，怎么使用es快速搭建，没有思路，老师能提供下思路么，没有搭建搜索的相关经验。不知道怎么下手我们是做电商的，主要是针对商品这块的搜索。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591797726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1158263,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","nickname":"李小龙","note":"","ucode":"1B64CB66AF0765","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281942,"discussion_content":"如果你们是电商的话，那么网上搜索一下“elastic search 电商”，应该会有许多实战案例和文章，供参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591844890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281721,"ip_address":"","group_id":0},"score":281942,"extra":""},{"author":{"id":1158263,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","nickname":"李小龙","note":"","ucode":"1B64CB66AF0765","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":282012,"discussion_content":"好的呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591861079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281942,"ip_address":"","group_id":0},"score":282012,"extra":""}]}]},{"had_liked":false,"id":310984,"user_name":"dakingkong","can_delete":false,"product_type":"c1","uid":1247568,"ip_address":"","ucode":"6B492887E7E4A2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/J1ADsCjfat7ibMcup6DV9DhH3lzKo2lIeBqCjuBa5nIWYu7u8NYDFb3iaPRp9cia9uH4464GDaGKcd7c0d0dkhibbA/132","comment_is_top":false,"comment_ctime":1631009120,"is_pvip":false,"replies":[{"id":113595,"content":"不需要加锁。memtable使用了巧妙的无锁设计，使得性能能更优。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1632579731,"ip_address":"","comment_id":310984,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，请问下Leveldb，是一写多读的吗？内存中的memtable在一写多读时，需要加锁吗？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497862,"discussion_content":"如果是从零开始，进行文本搜索的话，最简单的做法是使用MySQL的全文检索功能，但是效果会比较差。\n如果想更精准地进行关键词检索，那么可以使用elastic search来搭建你们的系统。当然，如果想定制各种功能，那么可以走上自研的方向。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591797519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158263,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","nickname":"李小龙","note":"","ucode":"1B64CB66AF0765","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281721,"discussion_content":"老师如果是想快速搭建搜索的话，怎么使用es快速搭建，没有思路，老师能提供下思路么，没有搭建搜索的相关经验。不知道怎么下手我们是做电商的，主要是针对商品这块的搜索。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591797726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1158263,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","nickname":"李小龙","note":"","ucode":"1B64CB66AF0765","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281942,"discussion_content":"如果你们是电商的话，那么网上搜索一下“elastic search 电商”，应该会有许多实战案例和文章，供参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591844890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281721,"ip_address":"","group_id":0},"score":281942,"extra":""},{"author":{"id":1158263,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/77/fbca9f8b.jpg","nickname":"李小龙","note":"","ucode":"1B64CB66AF0765","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":282012,"discussion_content":"好的呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591861079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281942,"ip_address":"","group_id":0},"score":282012,"extra":""}]}]},{"had_liked":false,"id":216049,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589174430,"is_pvip":false,"replies":[{"id":79983,"content":"其实不需要动态规划法，使用贪心法就够了。\n首先我们算出来锁定A1时的最小窗口。然后我们再去计算当第一个关键词取A2位置时的最小窗口。\n在计算A2的最小窗口的时候，我们可以先判断A2的位置是否小于B1,如果小于的话，那么最小窗口就是A2-B1－C1。如果A2大于B1的话，那么就重新往后找到B2。以此类推。这样，对于每个关键词的位置，我们都不会回头重复计算。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589207573,"ip_address":"","comment_id":216049,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"关于第一个讨论题，开始的想法，使用位置信息索引法中，对于3个关键词的情况，可以锁定第一个关键词，找到最小窗口的第二关键词，然后锁定这个第二个关键词，寻找最小窗口的第三个关键词。但是老师文章中提到`如果是两个以上的关键词联合查询，那我们会将同时包含所有关键词的最小片段称为最小窗口`，这个方法貌似跟这句话相违背。举个栗子，假设这三个关键词是A B C，某一篇文章中有两处含有这三个关键词，他们之间最小窗口距离是 A1~2~B1~5~C1 （A1和B1之间距离是2，B1和C1之间距离是5）, A2~3~B2~3~C2。按照开始想法的解法是，锁定A，找到最小窗口的B，是B1，因最小距离是2。然后锁定B1，找到最小距离是C1（假设B1和C2之间距离远大于5）。但是单独看B和C之间的距离，B2与C2应该是最小的。另外，如果看包含所有关键词的话，A2 B2 C2之间最小窗口是最优的，如此的话，得使用动态规划方法来计算了，但是这样一来复杂度变高了。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526424,"discussion_content":"不需要加锁。memtable使用了巧妙的无锁设计，使得性能能更优。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632579731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258121,"user_name":"森森森","can_delete":false,"product_type":"c1","uid":1354906,"ip_address":"","ucode":"691BCB70327CBA","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/9a/6dda1d4f.jpg","comment_is_top":false,"comment_ctime":1604305671,"is_pvip":false,"replies":[{"id":94104,"content":"一般来说，我们会采用微服务架构来搭建系统。系统中有一个排序模型的服务，专门负责排序功能。这个服务可以使用逻辑回归模型来实现，也能使用深度学习模型，但是不管内部怎么实现，对外提供一个统一的服务接口即可。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1604417598,"ip_address":"","comment_id":258121,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师如果使用深度学习进行排序，那么深度学习的线上预测模型是需要在搜索的排序阶段进行接口调用就可以了吗？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494652,"discussion_content":"其实不需要动态规划法，使用贪心法就够了。\n首先我们算出来锁定A1时的最小窗口。然后我们再去计算当第一个关键词取A2位置时的最小窗口。\n在计算A2的最小窗口的时候，我们可以先判断A2的位置是否小于B1,如果小于的话，那么最小窗口就是A2-B1－C1。如果A2大于B1的话，那么就重新往后找到B2。以此类推。这样，对于每个关键词的位置，我们都不会回头重复计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589207573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263259,"discussion_content":"你这个例子中的最小窗口距离是： A2~3~B2~3~C2， 因为这里会遍历所有第一个关键词求出所有的窗口距离，然后取最小的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589193495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1150927,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","nickname":"那时刻","note":"","ucode":"B0D150856C3A4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263282,"discussion_content":"这么取值的话，应该不是锁定关键词的意思吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589195476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263259,"ip_address":"","group_id":0},"score":263282,"extra":""},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"奕","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1150927,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","nickname":"那时刻","note":"","ucode":"B0D150856C3A4A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263760,"discussion_content":"每篇文章，每个关键词都有可能出现多次，只需要找到距离最小的就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589245936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263282,"ip_address":"","group_id":0},"score":263760,"extra":""}]}]},{"had_liked":false,"id":216125,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1589193117,"is_pvip":false,"replies":[{"id":79984,"content":"在标准的短语查询中，窗口的定义就是第一个词到最后一个词的距离。\n你提出的两两之间的距离也是有意思的一个提法，也许在某些场景下是有效的，不过这样的判断可能会造成第一个词和最后一个词距离太远，在短语查询这个例子中可能不是很合适。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589207754,"ip_address":"","comment_id":216125,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"在进行查询次窗口计算的时候：是只计算查询词的第一个词和最后的一个词的距离吗？ 还是计算查询词中两两词之间的的距离？\n我认为计算查询次中两两词之间的窗口距离推荐的效果会更好一些","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508557,"discussion_content":"一般来说，我们会采用微服务架构来搭建系统。系统中有一个排序模型的服务，专门负责排序功能。这个服务可以使用逻辑回归模型来实现，也能使用深度学习模型，但是不管内部怎么实现，对外提供一个统一的服务接口即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604417598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373044,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1681966369,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100048401,"comment_content":"学习打卡","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494681,"discussion_content":"在标准的短语查询中，窗口的定义就是第一个词到最后一个词的距离。\n你提出的两两之间的距离也是有意思的一个提法，也许在某些场景下是有效的，不过这样的判断可能会造成第一个词和最后一个词距离太远，在短语查询这个例子中可能不是很合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589207754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363393,"user_name":"追逐繁星的孩纸~","can_delete":false,"product_type":"c1","uid":1593884,"ip_address":"上海","ucode":"69DC37A9E39C7E","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/1c/e902de0f.jpg","comment_is_top":false,"comment_ctime":1669623528,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师你好，请问下关于搜索引擎的检索性能方面，我们有衡量标准不？对不同阶段的要求是不是也不一样，比如检索阶段分为查询理解、召回和排序，不同阶段的耗时是不是有不同的耗时配比？","like_count":0},{"had_liked":false,"id":363393,"user_name":"追逐繁星的孩纸~","can_delete":false,"product_type":"c1","uid":1593884,"ip_address":"上海","ucode":"69DC37A9E39C7E","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/1c/e902de0f.jpg","comment_is_top":false,"comment_ctime":1669623528,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师你好，请问下关于搜索引擎的检索性能方面，我们有衡量标准不？对不同阶段的要求是不是也不一样，比如检索阶段分为查询理解、召回和排序，不同阶段的耗时是不是有不同的耗时配比？","like_count":0}]}