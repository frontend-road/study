{"id":41186,"title":"33 | Java Agent与字节码注入","content":"<p>关于Java agent，大家可能都听过大名鼎鼎的<code>premain</code>方法。顾名思义，这个方法指的就是在<code>main</code>方法之前执行的方法。</p>\n<pre><code>package org.example;\n\npublic class MyAgent {\n  public static void premain(String args) {\n    System.out.println(&quot;premain&quot;);\n  }\n}\n</code></pre>\n<p>我在上面这段代码中定义了一个<code>premain</code>方法。这里需要注意的是，Java虚拟机所能识别的<code>premain</code>方法接收的是字符串类型的参数，而并非类似于<code>main</code>方法的字符串数组。</p>\n<p>为了能够以Java agent的方式运行该<code>premain</code>方法，我们需要将其打包成jar包，并在其中的MANIFEST.MF配置文件中，指定所谓的<code>Premain-class</code>。具体的命令如下所示：</p>\n<pre><code># 注意第一条命令会向manifest.txt文件写入两行数据，其中包括一行空行\n$ echo 'Premain-Class: org.example.MyAgent\n' &gt; manifest.txt\n$ jar cvmf manifest.txt myagent.jar org/\n$ java -javaagent:myagent.jar HelloWorld\npremain\nHello, World\n</code></pre>\n<p>除了在命令行中指定Java agent之外，我们还可以通过Attach API远程加载。具体用法如下面的代码所示：</p>\n<pre><code>import java.io.IOException;\n\nimport com.sun.tools.attach.*;\n\npublic class AttachTest {\n  public static void main(String[] args)\n      throws AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException {\n    if (args.length &lt;= 1) {\n      System.out.println(&quot;Usage: java AttachTest &lt;PID&gt; /PATH/TO/AGENT.jar&quot;);\n      return;\n    }\n    VirtualMachine vm = VirtualMachine.attach(args[0]);\n    vm.loadAgent(args[1]);\n  }\n}\n\n</code></pre>\n<p>使用Attach API远程加载的Java agent不会再先于<code>main</code>方法执行，这取决于另一虚拟机调用Attach API的时机。并且，它运行的也不再是<code>premain</code>方法，而是名为<code>agentmain</code>的方法。</p>\n<pre><code>public class MyAgent { \n  public static void agentmain(String args) {\n    System.out.println(&quot;agentmain&quot;);\n  }\n}\n</code></pre>\n<p>相应的，我们需要更新jar包中的manifest文件，使其包含<code>Agent-Class</code>的配置，例如<code>Agent-Class: org.example.MyAgent</code>。</p><!-- [[[read_end]]] -->\n<pre><code>$ echo 'Agent-Class: org.example.MyAgent\n' &gt; manifest.txt\n$ jar cvmf manifest.txt myagent.jar org/\n$ java HelloWorld\nHello, World\n$ jps\n$ java AttachTest &lt;pid&gt; myagent.jar\nagentmain\n// 最后一句输出来自于运行HelloWorld的Java进程\n</code></pre>\n<p>Java虚拟机并不限制Java agent的数量。你可以在java命令后附上多个<code>-javaagent</code>参数，或者远程attach多个Java agent，Java虚拟机会按照定义顺序，或者attach的顺序逐个执行这些Java agent。</p>\n<p>在<code>premain</code>方法或者<code>agentmain</code>方法中打印一些字符串并不出奇，我们完全可以将其中的逻辑并入<code>main</code>方法，或者其他监听端口的线程中。除此之外，Java agent还提供了一套instrumentation机制，允许应用程序拦截类加载事件，并且更改该类的字节码。</p>\n<p>接下来，我们来了解一下基于这一机制的字节码注入。</p>\n<h2>字节码注入</h2>\n<pre><code>package org.example;\n\nimport java.lang.instrument.*;\nimport java.security.ProtectionDomain;\n\npublic class MyAgent {\n  public static void premain(String args, Instrumentation instrumentation) {\n    instrumentation.addTransformer(new MyTransformer());\n  }\n\n  static class MyTransformer implements ClassFileTransformer {\n    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,\n        ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n      System.out.printf(&quot;Loaded %s: 0x%X%X%X%X\\n&quot;, className, classfileBuffer[0], classfileBuffer[1],\n          classfileBuffer[2], classfileBuffer[3]);\n      return null;\n    }\n  }\n}\n</code></pre>\n<p>我们先来看一个例子。在上面这段代码中，<code>premain</code>方法多出了一个<code>Instrumentation</code>类型的参数，我们可以通过它来注册类加载事件的拦截器。该拦截器需要实现<code>ClassFileTransformer</code>接口，并重写其中的<code>transform</code>方法。</p>\n<p><code>transform</code>方法将接收一个byte数组类型的参数，它代表的是正在被加载的类的字节码。在上面这段代码中，我将打印该数组的前四个字节，也就是Java class文件的魔数（magic number）0xCAFEBABE。</p>\n<p><code>transform</code>方法将返回一个byte数组，代表更新过后的类的字节码。当方法返回之后，Java虚拟机会使用所返回的byte数组，来完成接下来的类加载工作。不过，如果<code>transform</code>方法返回null或者抛出异常，那么Java虚拟机将使用原来的byte数组完成类加载工作。</p>\n<p>基于这一类加载事件的拦截功能，我们可以实现字节码注入（bytecode instrumentation），往正在被加载的类中插入额外的字节码。</p>\n<p>在工具篇中我曾经介绍过字节码工程框架ASM的用法。下面我将演示它的<a href=\"https://search.maven.org/artifact/org.ow2.asm/asm-tree/7.0-beta/jar\">tree包</a>（依赖于<a href=\"https://search.maven.org/artifact/org.ow2.asm/asm/7.0-beta/jar\">基础包</a>），用面向对象的方式注入字节码。</p>\n<pre><code>package org.example;\n\nimport java.lang.instrument.*;\nimport java.security.ProtectionDomain;\nimport org.objectweb.asm.*;\nimport org.objectweb.asm.tree.*;\n\npublic class MyAgent {\n  public static void premain(String args, Instrumentation instrumentation) {\n    instrumentation.addTransformer(new MyTransformer());\n  }\n\n  static class MyTransformer implements ClassFileTransformer, Opcodes {\n    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,\n        ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n      ClassReader cr = new ClassReader(classfileBuffer);\n      ClassNode classNode = new ClassNode(ASM7);\n      cr.accept(classNode, ClassReader.SKIP_FRAMES);\n\n      for (MethodNode methodNode : classNode.methods) {\n        if (&quot;main&quot;.equals(methodNode.name)) {\n          InsnList instrumentation = new InsnList();\n          instrumentation.add(new FieldInsnNode(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;));\n          instrumentation.add(new LdcInsnNode(&quot;Hello, Instrumentation!&quot;));\n          instrumentation\n              .add(new MethodInsnNode(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false));\n\n          methodNode.instructions.insert(instrumentation);\n        }\n      }\n\n      ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n      classNode.accept(cw);\n      return cw.toByteArray();\n    }\n  }\n}\n</code></pre>\n<p>上面这段代码不难理解。我们将使用<code>ClassReader</code>读取所传入的byte数组，并将其转换成<code>ClassNode</code>。然后我们将遍历<code>ClassNode</code>中的<code>MethodNode</code>节点，也就是该类中的构造器和方法。</p>\n<p>当遇到名字为<code>&quot;main&quot;</code>的方法时，我们会在方法的入口处注入<code>System.out.println(&quot;Hello, Instrumentation!&quot;);</code>。运行结果如下所示：</p>\n<pre><code>$ java -javaagent:myagent.jar -cp .:/PATH/TO/asm-7.0-beta.jar:/PATH/TO/asm-tree-7.0-beta.jar HelloWorld\nHello, Instrumentation!\nHello, World!\n</code></pre>\n<p>Java agent还提供了另外两个功能<code>redefine</code>和<code>retransform</code>。这两个功能针对的是已加载的类，并要求用户传入所要<code>redefine</code>或者<code>retransform</code>的类实例。</p>\n<p>其中，<code>redefine</code>指的是舍弃原本的字节码，并替换成由用户提供的byte数组。该功能比较危险，一般用于修复出错了的字节码。</p>\n<p><code>retransform</code>则将针对所传入的类，重新调用所有已注册的<code>ClassFileTransformer</code>的<code>transform</code>方法。它的应用场景主要有如下两个。</p>\n<p>第一，在执行<code>premain</code>或者<code>agentmain</code>方法前，Java虚拟机早已加载了不少类，而这些类的加载事件并没有被拦截，因此也没有被注入。使用<code>retransform</code>功能可以注入这些已加载但未注入的类。</p>\n<p>第二，在定义了多个Java agent，多个注入的情况下，我们可能需要移除其中的部分注入。当调用<code>Instrumentation.removeTransformer</code>去除某个注入类后，我们可以调用<code>retransform</code>功能，重新从原始byte数组开始进行注入。</p>\n<p>Java agent的这些功能都是通过JVMTI agent，也就是C agent来实现的。JVMTI是一个事件驱动的工具实现接口，通常，我们会在C agent加载后的入口方法<code>Agent_OnLoad</code>处注册各个事件的钩子（hook）方法。当Java虚拟机触发了这些事件时，便会调用对应的钩子方法。</p>\n<pre><code>JNIEXPORT jint JNICALL\nAgent_OnLoad(JavaVM *vm, char *options, void *reserved);\n</code></pre>\n<p>举个例子，我们可以为JVMTI中的<code>ClassFileLoadHook</code>事件设置钩子，从而在C层面拦截所有的类加载事件。关于JVMTI的其他事件，你可以参考该<a href=\"https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html#EventIndex\">链接</a>。</p>\n<h2>基于字节码注入的profiler</h2>\n<p>我们可以利用字节码注入来实现代码覆盖工具（例如<a href=\"https://www.jacoco.org/jacoco/\">JaCoCo</a>），或者各式各样的profiler。</p>\n<p>通常，我们会定义一个运行时类，并在某一程序行为的周围，注入对该运行时类中方法的调用，以表示该程序行为正要发生或者已经发生。</p>\n<pre><code>package org.example;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class MyProfiler {\n  public static ConcurrentHashMap&lt;Class&lt;?&gt;, AtomicInteger&gt; data = new ConcurrentHashMap&lt;&gt;();\n\n  public static void fireAllocationEvent(Class&lt;?&gt; klass) {\n    data.computeIfAbsent(klass, kls -&gt; new AtomicInteger())\n        .incrementAndGet();\n  }\n\n  public static void dump() {\n    data.forEach((kls, counter) -&gt; {\n      System.err.printf(&quot;%s: %d\\n&quot;, kls.getName(), counter.get());\n    });\n  }\n\n  static {\n    Runtime.getRuntime().addShutdownHook(new Thread(MyProfiler::dump));\n  }\n}\n</code></pre>\n<p>举个例子，上面这段代码便是一个运行时类。该类维护了一个<code>HashMap</code>，用来统计每个类所新建实例的数目。当程序退出时，我们将逐个打印出每个类的名字，以及其新建实例的数目。</p>\n<p>在Java agent中，我们会截获正在加载的类，并且在每条<code>new</code>字节码之后插入对<code>fireAllocationEvent</code>方法的调用，以表示当前正在新建某个类的实例。具体的注入代码如下所示：</p>\n<pre><code>package org.example;\n\nimport java.lang.instrument.*;\nimport java.security.ProtectionDomain;\n\nimport org.objectweb.asm.*;\nimport org.objectweb.asm.tree.*;\n\npublic class MyAgent {\n\n  public static void premain(String args, Instrumentation instrumentation) {\n    instrumentation.addTransformer(new MyTransformer());\n  }\n\n  static class MyTransformer implements ClassFileTransformer, Opcodes {\n    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,\n        ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n      if (className.startsWith(&quot;java&quot;)    ||\n          className.startsWith(&quot;javax&quot;)   || \n          className.startsWith(&quot;jdk&quot;)     ||\n          className.startsWith(&quot;sun&quot;)     ||\n          className.startsWith(&quot;com/sun&quot;) ||\n          className.startsWith(&quot;org/example&quot;)) {\n        // Skip JDK classes and profiler classes\n        return null;\n      }\n\n      ClassReader cr = new ClassReader(classfileBuffer);\n      ClassNode classNode = new ClassNode(ASM7);\n      cr.accept(classNode, ClassReader.SKIP_FRAMES);\n\n      for (MethodNode methodNode : classNode.methods) {\n        for (AbstractInsnNode node : methodNode.instructions.toArray()) {\n          if (node.getOpcode() == NEW) {\n            TypeInsnNode typeInsnNode = (TypeInsnNode) node;\n\n            InsnList instrumentation = new InsnList();\n            instrumentation.add(new LdcInsnNode(Type.getObjectType(typeInsnNode.desc)));\n            instrumentation.add(new MethodInsnNode(INVOKESTATIC, &quot;org/example/MyProfiler&quot;, &quot;fireAllocationEvent&quot;,\n                &quot;(Ljava/lang/Class;)V&quot;, false));\n\n            methodNode.instructions.insert(node, instrumentation);\n          }\n        }\n      }\n\n      ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n      classNode.accept(cw);\n      return cw.toByteArray();\n    }\n  }\n\n}\n</code></pre>\n<p>你或许已经留意到，我们不得不排除对JDK类以及该运行时类的注入。这是因为，对这些类的注入很可能造成死循环调用，并最终抛出<code>StackOverflowException</code>异常。</p>\n<p>举个例子，假设我们在<code>PrintStream.println</code>方法入口处注入<code>System.out.println(&quot;blahblah&quot;)</code>，由于<code>out</code>是<code>PrintStream</code>的实例，因此当执行注入代码时，我们又会调用<code>PrintStream.println</code>方法，从而造成死循环。</p>\n<p>解决这一问题的关键在于设置一个线程私有的标识位，用以区分应用代码的上下文以及注入代码的上下文。当即将执行注入代码时，我们将根据标识位判断是否已经位于注入代码的上下文之中。如果不是，则设置标识位并正常执行注入代码；如果是，则直接返回，不再执行注入代码。</p>\n<p>字节码注入的另一个技术难点则是命名空间。举个例子，不少应用程序都依赖于字节码工程库ASM。当我们的注入逻辑依赖于ASM时，便有可能出现注入使用最新版本的ASM，而应用程序使用较低版本的ASM的问题。</p>\n<p>JDK本身也使用了ASM库，如用来生成Lambda表达式的适配器类。JDK的做法是重命名整个ASM库，为所有类的包名添加<code>jdk.internal</code>前缀。我们显然不好直接更改ASM的包名，因此需要借助自定义类加载器来隔离命名空间。</p>\n<p>除了上述技术难点之外，基于字节码注入的工具还有另一个问题，那便是观察者效应（observer effect）对所收集的数据造成的影响。</p>\n<p>举个利用字节码注入收集每个方法的运行时间的例子。假设某个方法调用了另一个方法，而这两个方法都被注入了，那么统计被调用者运行时间的注入代码所耗费的时间，将不可避免地被计入至调用者方法的运行时间之中。</p>\n<p>再举一个统计新建对象数目的例子。我们知道，即时编译器中的逃逸分析可能会优化掉新建对象操作，但它不会消除相应的统计操作，比如上述例子中对<code>fireAllocationEvent</code>方法的调用。在这种情况下，我们将统计没有实际发生的新建对象操作。</p>\n<p>另一种情况则是，我们所注入的对<code>fireAllocationEvent</code>方法的调用，将影响到方法内联的决策。如果该新建对象的构造器调用恰好因此没有被内联，从而造成对象逃逸。在这种情况下，原本能够被逃逸分析优化掉的新建对象操作将无法优化，我们也将统计到原本不会发生的新建对象操作。</p>\n<p>总而言之，当使用字节码注入开发profiler时，需要辩证地看待所收集的数据。它仅能表示在被注入的情况下程序的执行状态，而非没有注入情况下的程序执行状态。</p>\n<h2>面向方面编程</h2>\n<p>说到字节码注入，就不得不提面向方面编程（Aspect-Oriented Programming，AOP）。面向方面编程的核心理念是定义切入点（pointcut）以及通知（advice）。程序控制流中所有匹配该切入点的连接点（joinpoint）都将执行这段通知代码。</p>\n<p>举个例子，我们定义一个指代所有方法入口的切入点，并指定在该切入点执行的“打印该方法的名字”这一通知。那么每个具体的方法入口便是一个连接点。</p>\n<p>面向方面编程的其中一种实现方式便是字节码注入，比如<a href=\"https://www.eclipse.org/aspectj/\">AspectJ</a>。</p>\n<p>在前面的例子中，我们也相当于使用了面向方面编程，在所有的<code>new</code>字节码之后执行了下面这样一段通知代码。</p>\n<pre><code>`MyProfiler.fireAllocationEvent(&lt;Target&gt;.class)`\n</code></pre>\n<p>我曾经参与开发过一个应用了面向方面编程思想的字节码注入框架<a href=\"https://disl.ow2.org/\">DiSL</a>。它支持用注解来定义切入点，用普通Java方法来定义通知。例如，在方法入口处打印所在的方法名，可以简单表示为如下代码：</p>\n<pre><code>@Before(marker = BodyMarker.class)\nstatic void onMethodEntry(MethodStaticContext msc) {\n  System.out.println(msc.thisMethodFullName());\n}\n</code></pre>\n<p>如果有同学对这个工具感兴趣，或者有什么需求或者建议，欢迎你在留言中提出。</p>\n<h2>总结与实践</h2>\n<p>今天我介绍了Java agent以及字节码注入。</p>\n<p>我们可以通过Java agent的类加载拦截功能，修改某个类所对应的byte数组，并利用这个修改过后的byte数组完成接下来的类加载。</p>\n<p>基于字节码注入的profiler，可以统计程序运行过程中某些行为的出现次数。如果需要收集Java核心类库的数据，那么我们需要小心避免无限递归调用。另外，我们还需通过自定义类加载器来解决命名空间的问题。</p>\n<p>由于字节码注入会产生观察者效应，因此基于该技术的profiler所收集到的数据并不能反映程序的真实运行状态。它所反映的是程序在被注入的情况下的执行状态。</p>\n<hr />\n<p>今天的实践环节，请你思考如何注入方法出口。除了正常执行路径之外，你还需考虑异常执行路径。</p>\n<p></p>\n","neighbors":{"left":{"article_title":"32 | JNI的运行机制","id":40839},"right":{"article_title":"34 | Graal：用Java编译Java","id":41245}},"comments":[{"had_liked":false,"id":32081,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1539407366,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"96028687878","product_id":100010301,"comment_content":"阅过留痕<br><br>1：Java agent 是啥玩意？<br>      这个概念老师没有详细讲解，我的理解是Java语言的一个特性，这个特性能够实现Java字节码的注入<br><br>2：Java字节码的注入有什么用处呢？<br>在平时编程几乎没有使用到这方面的功能，应该是在一些框架的设计的时候才使用吧！比如：专栏中提到的面相切面编程。<br><br>3：Java agent 本质上是通过 c agent 来实现的，那 c agent 本质上是怎么实现的呢？<br>C agent是一个事件驱动的工具实现接口，通常我们会在 C agent 加载后的入口方案 Agent_OnLoad处注册各个事件的钩子方法。当Java虚拟机触发了这些事件时，便会调用对应的钩子方法<br><br>4：留个话头<br>      写代码实现某些功能，我的理解有三个时间段<br>      第一个：源码阶段，最常用的，也是编程的主要活动时间<br>      第二个：字节码阶段，有些功能可能会在加载字节码时修改或者添加某些字节码，某些框架做的事情<br>      第三个：运行阶段，某些工具，在程序运行时修改代码，实现运行时功能分支的控制","like_count":23,"discussions":[{"author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376115,"discussion_content":"第二阶段：生成字节码\n第三阶段：加载字节码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621958774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40466,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1542623163,"is_pvip":false,"replies":[{"id":"15656","content":"你是在做redefine时出问题，还是没触发时便已出问题？<br><br>class redefinition需要爬每个线程的Java栈，检查有没有用到被redefine的类的方法，因此会stop-the-world。另外，redefine后，JIT’ed代码会被抛弃，重新解释执行","user_name":"作者回复","comment_id":40466,"uid":"1176688","ip_address":"","utype":1,"ctime":1543311254,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"44492296123","product_id":100010301,"comment_content":"用attach的方式注入字节码的时候遇到了99线升高的性能问题，看一些资料说 class redefinition 的时候会阻塞线程。请问能详细讲下吗？","like_count":10,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429532,"discussion_content":"你是在做redefine时出问题，还是没触发时便已出问题？\n\nclass redefinition需要爬每个线程的Java栈，检查有没有用到被redefine的类的方法，因此会stop-the-world。另外，redefine后，JIT’ed代码会被抛弃，重新解释执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543311254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30546,"user_name":"feng","can_delete":false,"product_type":"c1","uid":1022939,"ip_address":"","ucode":"5E9D36F9BC1697","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEI0ia2Dz6NRBNZIwOLbIDJQZ5dRrhMVKj8JKic3Qibh7M8Uz1Sf1akuOJSSyHUQnrbZ0OmtmRm9yGvCw/132","comment_is_top":false,"comment_ctime":1538918703,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35898657071","product_id":100010301,"comment_content":"第一个实验做的不严谨，第一，木有定义HelloWord类，第二，没有执行编译操作，不知道是有意为之，还是不小心把步骤漏掉了","like_count":8,"discussions":[{"author":{"id":1187010,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/05Wiazxo0OS5w9KdJ4OQAe3ezwaCXNY4DGoE0noPFzXtUhOGejgGKFR6WmMxr0KcEGOSahnjbOwxPSib88h0E6zA/132","nickname":"linsen","note":"","ucode":"1DBBBA0988DB63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350254,"discussion_content":"你自己本地可以嘛？我定义了HelloWord类之后还是说找不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613787036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177837,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1581512965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14466414853","product_id":100010301,"comment_content":"大概说一下我自己的理解(望老师指正):<br>1. Agent就是一个调用JVMTI函数的一个程序。<br>2. JVMTI能够提供的函数能够获得JVM的运行信息，还可以修改JVM的运行态。<br>3. JVMTI能够修改JVM运行态是因为JVM已经在运行流程中埋下了钩子函数，JVMTI中的函数可以传递具体逻辑给钩子函数。<br>4. JVMTI函数是C语言实现的JNI方法。<br>5. 通过Instrumentation我们可以用Java语言调用大部分JVMTI函数。<br>6. JVM在启动时会加载Agent 入口函数Agent_OnLoad,我们可以在此函数中注册Agent。<br>7. JVM在运行中可以通过Agent_OnAttach函数来加载Agent,我们可以在此函数中注册Agent。<br>8. B虚拟机调用attach方法attach到A虚拟机后，可以将Agent程序作为参数调用A虚拟机的Agent_OnAttach函数。<br>9. premain方法中的程序逻辑会被注册到Agent_OnLoad函数中。<br>10. agentmain方法中的程序逻辑会被注册到Agent_OnAttach函数中。<br>11. 在premain或agentmain方法中的拿到的Instrumentation引用，可以理解成拿到了JVMTI的引用(大部分函数)。<br><br>以上全是个人抽象理解，不是具体实现。","like_count":4},{"had_liked":false,"id":30430,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1538839968,"is_pvip":false,"replies":[{"id":"11049","content":"Instrumentation包并没有所有JVMTI功能","user_name":"作者回复","comment_id":30430,"uid":"1176688","ip_address":"","utype":1,"ctime":1538987376,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14423741856","product_id":100010301,"comment_content":"我看到了jvmti可以回调异常事件，但是java.lang.instrument包下没有处理这个事件的，只能在load时回调，处理异常究竟是怎么做的？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425998,"discussion_content":"Instrumentation包并没有所有JVMTI功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538987376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30429,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1538839316,"is_pvip":false,"replies":[{"id":"11048","content":"其实不用管有没有catch块，有没有throw，直接给所有代码罩一个catch any的异常处理就行了","user_name":"作者回复","comment_id":30429,"uid":"1176688","ip_address":"","utype":1,"ctime":1538987321,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14423741204","product_id":100010301,"comment_content":"出方法时需要注入的字节码除了返回，还有几种情况，如果没有catch块，就拦截throw，如果有，但是catch块里面可能有很多层，只是遍历inst应该是不可以的","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425997,"discussion_content":"其实不用管有没有catch块，有没有throw，直接给所有代码罩一个catch any的异常处理就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538987321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166651,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1577533178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872500474","product_id":100010301,"comment_content":"profiler 示例，文中省略了 HelloWorld.java 和编译提及下更好。<br># cat HelloWorld.java <br><br>public class HelloWorld {<br><br>    public static void main(String[] args) {<br>        System.out.println(&quot;Hello World!&quot;);<br>        HelloWorld w = new HelloWorld();<br>    }<br>}<br><br># java -javaagent:myagent.jar -cp $CLASS_PATH:.&#47;asm-7.0-beta.jar:.&#47;asm-tree-7.0-beta.jar HelloWorld<br>Hello World!<br>HelloWorld: 1","like_count":1},{"had_liked":false,"id":146694,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1572607957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5867575253","product_id":100010301,"comment_content":"把老师给的程序都跑了一篇，发现想要彻底搞懂，还需要多学习，C&#47;C++的知识不能丢了，因为HotSpot JVM 的源码基本上都是用它来实现的。<br>不过跑了一下代码，最起码可以表面上搞懂了像Lombok，AOP这些都是如何实现的。","like_count":1},{"had_liked":false,"id":111121,"user_name":"一缕阳光","can_delete":false,"product_type":"c1","uid":1391255,"ip_address":"","ucode":"19C6BCE47681EE","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/97/c4493e91.jpg","comment_is_top":false,"comment_ctime":1562481588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5857448884","product_id":100010301,"comment_content":"实习的时候有幸做过一个利用Instrumentation实现自动打点和性能监控的项目。受益匪浅啊  哈哈哈哈  ，不得不说里面坑还是挺多的","like_count":1},{"had_liked":false,"id":90537,"user_name":"奇奇","can_delete":false,"product_type":"c1","uid":1399097,"ip_address":"","ucode":"BC86B0CB55E35A","user_header":"","comment_is_top":false,"comment_ctime":1556550012,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5851517308","product_id":100010301,"comment_content":"ASM7 GETSTATIC这些常量是哪里来的？","like_count":1,"discussions":[{"author":{"id":1121459,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/b3/6d10ba4f.jpg","nickname":"Running Man","note":"","ucode":"4DD2F6AF71327E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315198,"discussion_content":"org.objectweb.asm.Opcodes","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603251175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277062,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1612250716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612250716","product_id":100010301,"comment_content":"https:&#47;&#47;www.jianshu.com&#47;p&#47;b72f66da679f 可参考","like_count":0},{"had_liked":false,"id":30547,"user_name":"feng","can_delete":false,"product_type":"c1","uid":1022939,"ip_address":"","ucode":"5E9D36F9BC1697","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEI0ia2Dz6NRBNZIwOLbIDJQZ5dRrhMVKj8JKic3Qibh7M8Uz1Sf1akuOJSSyHUQnrbZ0OmtmRm9yGvCw/132","comment_is_top":false,"comment_ctime":1538918866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538918866","product_id":100010301,"comment_content":"还有个问题想请教下，每次启动的时候都会打印如下信息，objc[2614]: Class JavaLaunchHelper is implemented in both &#47;Library&#47;Java&#47;JavaVirtualMachines&#47;jdk1.8.0_31.jdk&#47;Contents&#47;Home&#47;bin&#47;java (0x102f6f4c0) and &#47;Library&#47;Java&#47;JavaVirtualMachines&#47;jdk1.8.0_31.jdk&#47;Contents&#47;Home&#47;jre&#47;lib&#47;libinstrument.dylib (0x104f384e0). One of the two will be used. Which one is undefined.<br><br>请问怎么可以消除，谢谢","like_count":0}]}