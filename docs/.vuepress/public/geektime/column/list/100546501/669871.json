{"id":669871,"title":"27｜初识认证机制：认证机制能解决哪些问题？","content":"<p>你好，我是Barry。今天是端午假期，祝你节日快乐，给假期仍然在学习的你点赞。</p><p>在<a href=\"https://time.geekbang.org/column/article/669369\">上节课</a>，我们利用Flask-Restful实现了接口规范化开发，相信你已经可以根据功能需求独立开发接口了。</p><p>但是在项目开发中，我们单独考虑开发功能还不够，还要在用户使用系统期间，保护用户隐私和数据安全。例如在系统中需要验证用户的身份，保护用户的个人信息和隐私。这就引出了我们这节课的核心—— Flask认证机制。</p><h2>认证机制能解决什么问题</h2><p>接下来，我们主要从四个维度来看看，在系统中认证机制都能够解决哪些问题。</p><p>首先是<strong>保护用户隐私和访问权限。</strong>如果一个系统没有身份认证机制，用户提交的个人信息和敏感数据等就会暴露在公共网络上。这样操作会存在大量风险，例如黑客可能会利用这些信息来进行诈骗、恶意攻击以及其他非法活动。此外，系统如果没有足够的访问控制，也可能导致用户无法访问他们需要的资源或服务。</p><h4></h4><p>其次，要<strong>防止异常访问和攻击</strong>。在系统中有了认证机制，只有经过认证的用户才可以访问特定的资源，从而保护应用程序免受未经授权的访问和攻击。比较典型的案例就是防止恶意的 CSRF攻击，保护系统免受盗用用户身份的攻击等。</p><p>第三，就是<strong>建立用户对系统的信任。</strong>认证机制可以为系统用户提供更安全的使用体验。对用户的各类数据做好严密保护，这有助于我们建立系统和用户之间的信任关系，否则将无法留存用户。</p><!-- [[[read_end]]] --><p>第四是<strong>优化程序流程</strong>。一个有效的认证机制，可以让用户和应用程序之间的交互过程更加规范，这有助于提高应用程序的可靠性、稳定性和可扩展性。此外，认证机制还可以简化代码和减少开发难度，提高我们的开发效率。</p><p>通过前面这四个维度的分析，我们认识到系统中认证机制的重要性。我们这就来了解一下在Flask中都有哪些认证方式。</p><h2>认证方式详解</h2><p>在Flask中，我们可以根据具体应用需求选择合适的认证方式，常用的认证方式包括Cookie、Session和Token。那么三者之间在使用上有什么区别呢？只有充分了解了这三种方式，我们才能选出最适合在线视频项目的方案。</p><p>Cookie是存储在客户端浏览器中的小段文本。它的作用是保存客户端的状态信息，最主要的功能就是存储用户的认证信息。有了Cookie的帮助，请求响应结束后，服务器仍然能保存一些信息，例如记录用户登录状态等。</p><p>但是，因为在浏览器中Cookie可以轻易被修改，将明文认证信息存储在Cookie中可能存在安全风险。所以，在Flask中通常使用Session对象来加密存储Cookie数据。当然，Session对象也可以用于存储认证信息，它提供了一种轻量级的会话管理机制。同时，Session数据存储在服务器端，无法被客户端直接修改。</p><p>Session的使用当然也会存在风险，因为Session机制是基于Cookie的，Cookie被拦截时，用户容易被跨站攻击。Session一般存储在内存中，每个用户通过认证之后，都会将Session数据保存在服务器的内存中，所以用户量达到一定程度时就会给服务器造成负担。</p><p>了解了Cookie和Session的认证方式，接下来我们再看看Token的认证方式。基于Token的认证机制工作原理是将认证信息返回给客户端，由客户端自己保存，等待访问服务器请求资源的同时，带上Token认证信息就可以。</p><p>如果我们采用这样的方式，服务器端就不需要保留用户的认证或者是会话等信息。对用户而言，不需要指定请求存储了用户认证信息的某个特定服务器，可以在多个服务器之间使用APP，在增加更多的用户或者更多的功能时，就更容易扩展应用程序。</p><p>综合前面的分析，我们的项目中最终选择Token的认证方式。</p><h2>认识Token</h2><p>在Flask中，Token可以分为两种类型，分别是JWT（JSON Web Token）和自定义Token。</p><p>JWT是一种开放标准，它提供了一种轻量级且安全的身份验证方法。JWT分成三个部分，分别是header（头部）、payload（载荷）和signature（签名）。具体含义和用途你可以参考后面的表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/c5/d5b7e3d8f19e91f39162510c6a34d7c5.jpg?wh=1920x747\" alt=\"\"></p><p>在项目中使用JWT完成Token认证的好处是：它可以在不同系统之间传递，并且不需要依赖数据库或其他身份验证机制。</p><p>在了解了JWT之后，我们紧接着来认识一下自定义Token，对比一下二者的区别。自定义Token是我们根据应用程序需求自己设计的Token。它通常包含用户ID、过期时间、角色等信息，同时还可以包括用于验证Token完整性和真实性的签名。当然了，我们也可以结合自己的需求自定义其他参数进行传递。</p><p>我们之所以使用自定义Token，是因为它可以根据项目需求去灵活设计Token的组成结构和验证机制。我们在使用的过程中还需要注意，<strong>自定义Token需要实现完整的Token验证逻辑，其中包括签名验证、过期时间检查、防止Token泄露等安全措施。</strong></p><p>说完了两种Token形式之后，接下来，我们看看如何通过Token实现认证机制。</p><h2>Token的认证流程</h2><p>在Flask中，Token认证机制可以用于保护项目的敏感资源，限制用户只有经过身份验证后才能访问与其相关的资源。</p><p>Token认证是一种基于令牌的身份验证方法，它在客户端和服务器之间传递一个加密的令牌，以此来实现用户信息的认证。为了帮你直观理解认证流程。我为你准备了后面这张认证机制流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/5f/cc78de622dfa2476c50a45b302e6ea5f.jpg?wh=2672x1350\" alt=\"\"></p><p>首先我们需要<strong>生成Token</strong>。在用户成功登录系统后，后端会生成相应的Token，并将Token存储在服务器端，这里可以选择数据库或内存缓存来存储。</p><p>紧接着，在用户访问需要认证的资源时，服务端将 <strong>Token发送给客户端</strong>。这一步传送的实现方式就是将Token存储在Cookie或HTTP Header中。在客户端发送请求时，服务端可以通过解析Token、检查过期时间、验证签名等方式来<strong>验证Token的完整性和真实性</strong>，从而建立起认证机制。</p><p>当然我们为了确保Token的安全性，服务端需要<strong>实现Token的过期时间和失效机制</strong>。当Token过期或被篡改时，应用程序需要更新或删除相应的Token，从而保证认证的时效性。</p><p>这里还需要注意的一个地方就是，Token 认证中有两个必要组件——日志和内存，它们分别用于记录认证过程、存储令牌及用户信息。两者有助于保证系统的安全性，让系统正常运行。接下来我们就一起了解一下日志和内存的工作原理。</p><h2>日志和内存的工作原理</h2><p>日志主要用来记录认证过程中的一些事件，例如系统中的用户访问受保护的资源事件、用户信息认证成功或失败等等。通过记录这些信息，可以让我们更好地了解应用程序的安全性和可能潜在的攻击问题。当发生异常或攻击时，日志还可以帮助开发人员快速定位问题并采取相应的措施。</p><h3>实现日志记录</h3><p>那么如何在项目中实现日志的记录呢？在Flask中我们可以使用 Python 的内置 logging 模块来实现记录日志。你可以对照表格看看具体的日志级别分类，从上往下级别依次升高，最高的是CRITICAL。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/e4/698799ee6f6a5d731a39ece976ff87e4.jpg?wh=3338x1621\" alt=\"\"></p><p>话不多说，我们进入实操环节。首先，我们需要安装logging的扩展，执行后面的命令即可。</p><pre><code class=\"language-python\">pip install logging\n</code></pre><p>完成安装之后，要在config.config配置文件中配置日志级别，这里我们配置INFO等级。</p><pre><code class=\"language-python\">LEVEL_LOG = logging.INFO\n</code></pre><p>还有一步不能忘记，就是给生产环境的config也设置日志级别。</p><pre><code class=\"language-python\">class ProConfig(Config):\n    LEVEL_LOG = logging.ERROR\n    DEBUG = False\n    SQLALCHEMY_DATABASE_URI = \"mysql+pymysql://root:flask_project@127.0.0.1:3306/aaa\"\n</code></pre><p>紧接着，我们在api/utils目录下，新建log_utils.py文件。在文件中定义三种不同的日志格式和输出方式，用来满足不同的日志记录需求。</p><p>三种输出模式都是什么作用呢？setup_log函数将日志记录到文件中，setup_logger函数同时记录日志到文件和控制台上，而json_log函数则是将日志以json格式记录到文件中。</p><p>接下来。我们再来看看它们是如何将日志文件写入文件中的。这里主要借助RotatingFileHandle函数，它是Python 的logging模块中的一个处理器，可以把日志信息写到文件中，并且支持日志滚动，也就是当文件大小达到一定阈值时，会自动创建一个新的日志文件，避免单个日志文件过大造成的存储问题。</p><p>对于日志文件过多而导致存储空间被占用的这个问题，通过日志的滚动就能解决。日志滚动是指将旧的日志文件删除，并将新的日志文件添加到日志滚动组中。</p><p>通过指定文件的最大量、备份数量等参数，就可以控制日志的滚动。具体的日志应用代码案例如下所示。</p><pre><code class=\"language-python\">def setup_log(logger_name=None, log_file='logs/log', level=logging.INFO):\n    \"\"\"根据创建app时的配置环境，加载日志等级\"\"\"\n    # 设置日志的记录等级\n    logging.basicConfig(level=level)  # 调试debug级\n    # 创建日志记录器，指明日志保存的路径、每个日志文件的最大量、保存的日志文件个数上限\n    file_log_handler = RotatingFileHandler(log_file, maxBytes=1024 * 1024 * 100, backupCount=10)\n    # 创建日志记录的格式      日志等级    输入日志信息的文件名 行数    日志信息\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s %(filename)s:%(lineno)d %(message)s')\n    # 为刚创建的日志记录器设置日志记录格式\n    file_log_handler.setFormatter(formatter)\n    # 为全局的日志工具对象（flask app使用的）添加日志记录器\n    logging.getLogger(logger_name).addHandler(file_log_handler)\n</code></pre><p>在上面代码中，我们首先要设置日志的记录等级为INFO。随后再创建一个 <code>RotatingFileHandler</code> 对象来记录日志，里面需要设置日志文件的路径、每个日志文件的最大量为 100 MB，最多保存 10 个文件。随后是创建日志记录的格式，这里采用字符串的格式。最后，将日志记录器添加到全局的日志工具对象中，这样我们就完成了日志应用的配置代码。</p><p>那么如何同时记录日志到文件和控制台上呢？这时我们可以使用logging模块中的FileHandler和StreamHandle，将日志同时写入文件和控制台，具体的代码实现是后面这样。</p><pre><code class=\"language-python\">def setup_logger(logger_name, log_file, level=logging.INFO):\n    \"\"\"\n    %(asctime)s 即日志记录时间，精确到毫秒\n    %(levelname)s 即此条日志级别\n    %(filename)s 即触发日志记录的python文件名\n    %(funcName)s 即触发日志记录的函数名\n    %(lineno)s 即触发日志记录代码的行号\n    %(message)s 这项即调用如app.logger.info(‘info log’)中的参数，即message\n    :param logger_name:\n    :param log_file:\n    :param level:\n    :return:\n    \"\"\"\n    log = logging.getLogger(logger_name)\n    # 创建日志对象\n    formatter = logging.Formatter('%(asctime)s : %(message)s')\n    # 设置格式，'% (asctime) s: %(message) s'，即日志记录时间和日志内容\n    file_handler = logging.FileHandler(log_file, mode='w')\n    # 创建一个文件处理器，将日志内容输出到名为log_file的文件中。\n    file_handler.setFormatter(formatter)\n    # 将日志格式设置为文件处理器的格式\n    stream_handler = logging.StreamHandler()\n    # 创建一个流处理器，将日志内容输出到控制台\n    stream_handler.setFormatter(formatter)\n    # 将日志格式设置为流处理器的格式\n    log.setLevel(level)\n    # 将日志级别设置为传入的参数level\n    log.addHandler(file_handler)\n    log.addHandler(stream_handler)\n    # 将文件处理器和流处理器添加至日志对象中\n</code></pre><p>代码整体的流程和将日志文件写入文件是类似的，setup_logger函数会把日志记录器的名称、记录文件的名称和记录级别作为参数。我们先创建日志对象，然后再设置日志格式。紧接着就是创建文件处理器和流处理器，最后将两个处理器添加到日志对象中。</p><p>我们将日志内容输出到文件时，设置了参数mode=‘w’，这表示以写入方式打开文件，这种模式会先清空文件中的内容，然后写入新的内容。如果写入的时候发现文件不存在，系统就会创建一个新文件。</p><p>当然，mode的值除了是 ‘W’ 以外还包括其他的类型，例如后面这些。</p><p>1.mode= ‘a’ 表示以追加模式打开日志文件，新写入的日志会添加到文件末尾。<br>\n2.mode=‘x’ 表示以排他模式打开日志文件，如果文件已经存在就会抛出 FileExistsError 异常。<br>\n3.mode=‘b’ 表示以二进制模式打开日志文件，适用于 Windows 文件系统。</p><h3>Redis存储</h3><p>清楚了日志的作用具体用法，我们继续来看Token认证中的内存。</p><p>Token 认证通常使用一个内存存储来保存生成的 Token。项目中对内存部分的操作，我们借助选用Redis来实现。使用Redis可以用来存储用户Token和相关的用户信息。</p><p>我们先来了解一下它的工作原理，当用户登录成功后，服务器会生成一个Token并将其存储到Redis中，同时将Token返回给客户端。客户端在后续的请求中，需要在请求头中携带该Token，服务器在接收到请求后，会检查该Token是否在Redis中存在，并获取相关的用户信息。</p><p>如果Token验证成功，即认为该请求是来自已登录的用户，服务器会返回相应的数据；否则服务器就要返回相应的错误信息。</p><p>使用Redis可以简单而高效地实现Token认证操作，避免在每个接口请求中都需要去查询数据库的开销，这样会大大提高系统的性能。</p><p>我们这就来看看具体的配置实现。第一步就是在config.config配置文件中进行设置。后续我们还会使用到Session来存储客户端与服务器交互时的一些信息，这里我们一并配置完成。具体的代码是后面这样。</p><pre><code class=\"language-python\">REDIS_HOST = '127.0.0.1'\n# Redis服务器的IP地址和端口号\nREDIS_PORT = 6379\n\n# 指定session使用什么来存储\nSESSION_TYPE = 'redis'\n# 指定session数据存储在后端的位置\nSESSION_REDIS = StrictRedis(host=REDIS_HOST, port=REDIS_PORT)\n# 是否使用secret_key签名你的sessin\nSESSION_USE_SIGNER = True\n# 设置过期时间，要求'SESSION_PERMANENT', True。而默认就是31天\nPERMANENT_SESSION_LIFETIME = 60 * 60 * 24  # 一天有效期\n</code></pre><p>第二步，我们需要在api/<strong>init</strong>.py文件中，设置创建Redis的连接对象。</p><pre><code class=\"language-python\">redis_store = None\nglobal redis_store\n# 创建redis的连接对象\nredis_store = StrictRedis(host=config.REDIS_HOST, port=config.REDIS_PORT, decode_responses=True)\n</code></pre><p>到这里，我们就完成了使用Token进行认证的前置工作。通过上面的学习，你已经掌握了Token认证的两个核心配置应用。日志用来记录认证过程中的一些事件，而Redis用来存储用户Token和相关的用户信息。</p><h2>总结</h2><p>又到了课程的尾声，我们来总结一下这节课重点。</p><p>认证机制在项目中不可或缺，它极大地保护了用户在平台内的安全性。Flask里常用的认证方式包括使用Cookie、Session和Token。</p><p>Session和Cookie的方式下，服务器必须存储用户的认证信息，这样用户量增加时服务器负荷就会增加。而Token很好地解决了这一问题，只在用户登录时，将Token临时存放在内存中，用于快速验证。把Token发给各个客户端，解决了应用程序的扩展问题。</p><p>随后，我们学习了Token里的三个重要部分，主要信息存储在payload中，我们借助JWT中的encode函数并且使用密钥来生成Token。解码时则要借助函数decode，这个过程同样需要使用到密钥。</p><p>日志和Redis内存是Token认证中的重点。日志方面，你需要重点掌握编写日志的几种模式对应的代码。内存方面，使用redis_store扩展管理内存的过程里，我们重点要关注如何在config配置文件中做好设置，建议你自己在课后也尝试练习一下。</p><h2>思考题</h2><p>既然我们要通过Token进行用户认证，请你思考一下在调用接口的时候怎样实现统一化管理呢？这样我们不用每次请求都需要在代码中写一遍Token参数，然后再传递给服务端了。</p><p>欢迎你在留言区和我交流互动，如果这节课对你有启发，也推荐你把这节课分享给更多朋友。</p><h2></h2>","neighbors":{"left":{"article_title":"26｜RESTful API与Flask-Restful：如何实现后端接口的开发与封装？","id":669369},"right":{"article_title":"28｜认证机制：Flask认证机制设计与实现","id":670130}},"comments":[{"had_liked":false,"id":376823,"user_name":"ZENG","can_delete":false,"product_type":"c1","uid":1136797,"ip_address":"广东","ucode":"4F9A006DA78074","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/9d/91d795cf.jpg","comment_is_top":false,"comment_ctime":1687509828,"is_pvip":false,"replies":[{"id":137379,"content":"1、是的，当用户量增加时，服务端需要分配更多的内存来存储所有的token。然而，可以通过一些技术来减轻内存压力，当然可以通过一些方法来进行优化：可以通过设置较短的过期时间可以减少服务端内存的使用。\n2、可以使用HTTPOnly和Secure属性来防止token被恶意获取。HTTPOnly属性可以防止JavaScript访问cookie，而Secure属性可以确保只有在安全情况下才能发送cookie。当然UA的方式也是OK的\n3、通过这样的方式你需要确保Redis中保存的token是经过加密的，以确保其安全性，如果Redis和MySQL之间的数据同步出现故障或错误，可能会导致安全漏洞和其他问题。所以这种方式还是存在一定的风险。","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1687692449,"ip_address":"北京","comment_id":376823,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"思考题：使用请求拦截，每次请求接口可以带上token等信息\n\n老师，我这边有几点不太明白\n1、使用token服务端不需要保存用户认证和会话，但是又需要内存存token，在过期时间之前都会保存这个token吗，理论上如果用户量太多内存也会有压力吧\n\n2、如果发给客户端的token保存在cookie中，可能也会被其他人拿到伪造用户登录行为，这个如何避免呢(我想到就是可以在荷载数据中加入ADDR、UA这样的信息来识别)\n\n3、前端发来的token如果还没到过期时间，但是redis又查不到，可不可以通过解密token然后根据荷载数据的某些信息通过mysql去查数据返回呢","like_count":1,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621841,"discussion_content":"1、是的，当用户量增加时，服务端需要分配更多的内存来存储所有的token。然而，可以通过一些技术来减轻内存压力，当然可以通过一些方法来进行优化：可以通过设置较短的过期时间可以减少服务端内存的使用。\n2、可以使用HTTPOnly和Secure属性来防止token被恶意获取。HTTPOnly属性可以防止JavaScript访问cookie，而Secure属性可以确保只有在安全情况下才能发送cookie。当然UA的方式也是OK的\n3、通过这样的方式你需要确保Redis中保存的token是经过加密的，以确保其安全性，如果Redis和MySQL之间的数据同步出现故障或错误，可能会导致安全漏洞和其他问题。所以这种方式还是存在一定的风险。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687692449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376834,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1687527431,"is_pvip":false,"replies":[{"id":137515,"content":"1、在使用 Flask 框架构建认证机制时，OAuth2 是一个常见的选择，但它并不是唯一的选择。OAuth2 是一种开放授权标准，它允许用户授权第三方应用程序访问其账户信息，而无需共享其用户名和密码。这个你可以尝试进行应用，项目中主要还是通过token来实现。\n2、在 HTTP header 中，通常会将token保存在一个特殊的字段中，这个字段被称为 &quot;Authorization&quot; 字段。当使用 OAuth2 等认证协议时，Authorization 字段通常会被用来传递访问令牌，以便客户端可以向服务器证明其身份并获取访问权限。\n3、对于Token和session的区别，Token 通常是基于 JSON Web Token（JWT）标准的，它包含了用户的标识符和其他相关信息，以及签名来确保令牌的安全性。Session（会话）是一种服务器端的身份验证机制，服务器为每个用户创建一个会话对象，该对象包含了用户的身份验证信息和会话状态。\n这是二者的区别\n\n\n","user_name":"作者回复","user_name_real":"编辑","uid":3050845,"ctime":1688398930,"ip_address":"北京","comment_id":376834,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100546501,"comment_content":"请教老师两个问题：\nQ1：OAuth2会用到吗？\nQ2：http header中保存token，是保存在哪个字段？\n另外，token保存在cookie中，session也是基于cookie，token与session有什么区别？","like_count":0,"discussions":[{"author":{"id":3050845,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8d/5d/9a86007c.jpg","nickname":"Barry","note":"","ucode":"82175C78B4CAED","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622560,"discussion_content":"1、在使用 Flask 框架构建认证机制时，OAuth2 是一个常见的选择，但它并不是唯一的选择。OAuth2 是一种开放授权标准，它允许用户授权第三方应用程序访问其账户信息，而无需共享其用户名和密码。这个你可以尝试进行应用，项目中主要还是通过token来实现。\n2、在 HTTP header 中，通常会将token保存在一个特殊的字段中，这个字段被称为 &#34;Authorization&#34; 字段。当使用 OAuth2 等认证协议时，Authorization 字段通常会被用来传递访问令牌，以便客户端可以向服务器证明其身份并获取访问权限。\n3、对于Token和session的区别，Token 通常是基于 JSON Web Token（JWT）标准的，它包含了用户的标识符和其他相关信息，以及签名来确保令牌的安全性。Session（会话）是一种服务器端的身份验证机制，服务器为每个用户创建一个会话对象，该对象包含了用户的身份验证信息和会话状态。\n这是二者的区别\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688398930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}