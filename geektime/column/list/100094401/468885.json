{"id":468885,"title":"26｜文档：如何给你的组件库设计一个可交互式文档？","content":"<p>你好，我是大圣。</p><p>在我们实现了组件库核心的组件内容之后，我们就需要提供一个可交互的组件文档给用户使用和学习了。这个文档页面主要包含组件的描述，组件Demo示例的展示、描述和代码，并且每个组件都应该有详细的参数文档。</p><p>现在，我们从上述文档页包含的信息来梳理一下我们的需求。我们需要用最简洁的语法来写页面，还需要用最简洁的语法来展示 Demo + 源代码 + 示例描述。那么从语法上来说，首选就是 Markdown 无疑了，因为它既简洁又强大。</p><p>那在我们正式开始设计文档之前，我们还需要对齐一下。如果要展示 Demo 和源码的话，为了能更高效且低成本的维护，我们会把一个示例的 Demo + 源码 + 示例描述放到一个文件里，尽量多的去复用，这样可以减少需要维护的代码。而做示例展示的话，本质上可以说是跟 Markdown 的转译一致，都是 Markdown -&gt; HTML，只是转译的规则我们需要拓展一下。接下来我们就正式开始。</p><h2>VuePress</h2><p>首先我们需要一个能基于Markdown构建文档的工具，我推荐VuePress。它是Vue官网团队维护的在线技术文档工具，样式和Vue的官方文档保持一致。</p><p>VuePress内置了Markdown的扩展，写文档的时候就是用Markdown语法进行渲染的。最让人省心的是，它可以直接在Markdown里面使用Vue组件，这就意味着我们可以直接在Markdown中写上一个个的组件库的使用代码，就可以直接展示运行效果了。</p><!-- [[[read_end]]] --><p>我们可以在项目中执行下面的代码安装VuePress的最新版本：</p><pre><code class=\"language-bash\">yarn add -D vuepress@next\n</code></pre><p>然后我们新建docs目录作为文档目录，新建docs/README.md文件作为文档的首页。除了Markdown之外，我们可以直接使用VuePress的语法扩展对组件进行渲染。</p><pre><code class=\"language-yaml\">\n---\nhome: true\nheroImage: /theme.png\ntitle: 网站快速成型工具\ntagline: 一套为开发者、设计师和产品经理准备的基于 Vue 3 的桌面端组件库\nheroText: 网站快速成型工具\nactions:\n  - text: 快速上手\n    link: /install\n    type: primary\n  - text: 项目简介\n    link: /button\n    type: secondary\nfeatures:\n  - title: 简洁至上\n    details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n  - title: Vue 驱动\n    details: 享受 Vue 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。\n  - title: 高性能\n    details: VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。\nfooter: powdered by vuepress and me\n---\n# 额外的信息\n\n\n\n</code></pre><p>我们在README.md中输入上面的内容，通过title配置网站的标题、actions配置快捷链接、features配置详情介绍，这样我们就拥有了下面的首页样式：</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/ba/d8cd69f08b0932a670c74c80ef6699ba.png?wh=1920x1785\" alt=\"图片\"></p><p>然后我们进入docs/.vuepress/目录下，新建文件config.js，这是这个网站的配置页面。下面的代码我们配置了logo和导航navbar，页面顶部右侧就会有首页和安装两个导航。</p><pre><code class=\"language-javascript\">module.exports = {\n  themeConfig:{\n    title:\"Element3\",\n    description:\"vuepress搭建的Element3文档\",\n    logo:\"/element3.svg\",\n    navbar:[\n      {\n        link:\"/\",\n        text:\"首页\"\n      },{\n        link:\"/install\",\n        text:\"安装\"\n      },\n    ]\n\n  }\n}\n</code></pre><p>然后我们创建docs/install.md文件，点击顶部导航之后，就会显示install.md的信息。我们在文稿中就可以直接写上介绍Element3如何安装的文档了，下面的文稿就是Element3的安装使用说明。</p><pre><code class=\"language-markdown\">## 安装\n### npm 安装\n推荐使用 npm 的方式安装，它能更好地和 [webpack](https://webpack.js.org/) 打包工具配合使用。\n```shell\nnpm i element3 -S\n```\n### CDN\n目前可以通过 [unpkg.com/element3](https://unpkg.com/element3) 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。\n```html\n&lt;!-- 引入样式 --&gt;\n&lt;link\n  rel=\"stylesheet\"\n  href=\"https://unpkg.com/element3/lib/theme-chalk/index.css\"\n/&gt;\n&lt;!-- 引入组件库 --&gt;\n&lt;script src=\"https://unpkg.com/element3\"&gt;&lt;/script&gt;\n```\n:::tip\n我们建议使用 CDN 引入 Element3 的用户在链接地址上锁定版本，以免将来 Element3 升级时受到非兼容性更新的影响。锁定版本的方法请查看 [unpkg.com](https://unpkg.com)。\n:::\n### Hello world\n\n通过 CDN 的方式我们可以很容易地使用 Element3 写出一个 Hello world 页面。[在线演示](https://codepen.io/imjustaman/pen/abZajYg)\n\n&lt;iframe height=\"265\" style=\"width: 100%;\" scrolling=\"no\" title=\"Element3 Demo\" src=\"https://codepen.io/imjustaman/embed/abZajYg?height=265&amp;theme-id=light&amp;default-tab=html,result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\"&gt;\n  See the Pen &lt;a href='https://codepen.io/imjustaman/pen/abZajYg'&gt;Element3 Demo&lt;/a&gt; by ImJustAMan\n  (&lt;a href='https://codepen.io/imjustaman'&gt;@imjustaman&lt;/a&gt;) on &lt;a href='https://codepen.io'&gt;CodePen&lt;/a&gt;.\n&lt;/iframe&gt;\n如果是通过 npm 安装，并希望配合 webpack 使用，请阅读下一节：[快速上手](/#/zh-CN/component/quickstart)。\n\n</code></pre><p>然后我们在浏览器里点击安装后，就会看到下图的页面显示。Markdown已经成功渲染为在线文档了，并且代码也自带了高亮显示。</p><p><img src=\"https://static001.geekbang.org/resource/image/09/c3/09d16ddc1080b4d8d4b04b934bdyy3c3.png?wh=1920x1655\" alt=\"图片\"></p><p>然后我们需要在这个文档系统中支持Element3，首先执行下面的代码安装Element3：</p><pre><code class=\"language-bash\">npm i element3 -D\n</code></pre><p>然后在项目根目录下的docs/.vuepress文件夹中新建文件clientAppEnhance.js，这是VuerPress的客户端扩展文件。我们导入了defineClientAppEnhance来返回客户端的扩展配置。这个函数中会传递Vue的实例App以及路由配置Router，我们使用app.use来全局注册Element3组件，就可以直接在Markdown中使用Element3的组件了。</p><pre><code class=\"language-javascript\">\nimport { defineClientAppEnhance } from '@vuepress/client'\n\nimport element3 from 'element3'\n\nexport default defineClientAppEnhance(({ app, router, siteData }) =&gt; {\n  app.use(element3)\n})\n</code></pre><p>这样VuePress就内置了Element3。我们在docs下面新建button.md文件，可以直接在Markdown中使用Element3的组件进行演示。下面的文稿中我们直接使用了el-button组件演示效果。</p><pre><code class=\"language-markdown\">## Button 按钮\n\n常用的操作按钮。\n### 基础用法\n基础的按钮用法。\n\n&lt;el-button type=\"primary\"&gt;\n按钮\n&lt;/el-button&gt;\n\n```html\n&lt;el-button type=\"primary\"&gt;\n按钮\n&lt;/el-button&gt;\n```\n</code></pre><p>然后进入docs/.vuepress/config.js中，新增侧边栏sidebar的配置之后，就可以看到下图的效果了。</p><pre><code class=\"language-javascript\">    sidebar:[\n      {\n        text:'安装',\n        link:'/install'\n      },\n      {\n        text:'按钮',\n        link:'/button'\n      },\n    ]\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/d2/6d/d267f5d33cc9652c145d737f8f4dc96d.png?wh=1920x846\" alt=\"图片\"></p><p>这样我们就基于VuePress支持了Element3组件库的文档功能，剩下的就是给每个组件写好文档即可。</p><p>但是这样的话，el-button的源码就写了两次，如果我们想更好地定制组件库文档，就需要自己解析Markdown文件，在内部支持Vue组件的效果显示和源码展示，也就相当于定制了一个自己的VuePress。</p><pre><code class=\"language-markdown\">:::demo 使用`type`、`plain`、`round`和`circle`属性来定义 Button 的样式。\n\n```html\n&lt;template&gt;\n  &lt;el-row&gt;\n    &lt;el-button&gt;默认按钮&lt;/el-button&gt;\n    &lt;el-button type=\"primary\"&gt;主要按钮&lt;/el-button&gt;\n    &lt;el-button type=\"success\"&gt;成功按钮&lt;/el-button&gt;\n    &lt;el-button type=\"info\"&gt;信息按钮&lt;/el-button&gt;\n    &lt;el-button type=\"warning\"&gt;警告按钮&lt;/el-button&gt;\n    &lt;el-button type=\"danger\"&gt;危险按钮&lt;/el-button&gt;\n  &lt;/el-row&gt;\n&lt;/template&gt;\n```\n\n:::\n</code></pre><p>它能直接使用下面的:::demo语法，在标记内部代码的同时，显示渲染效果和源码，也就是下图Element3官网的渲染效果。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/c6/85c611ff85c7d69773e41c546f4eb3c6.png?wh=1920x1462\" alt=\"图片\"></p><p>那么接下来我们就看看如何定制，具体操作一下。</p><h2>解析Markdown</h2><p>我们需要自己实现一个Markdown-loader，对Markdown语法进行扩展。</p><p>Element3中使用Markdown-it进行Markdown语法的解析和扩展。Markdown-it导出一个函数，这个函数可以把Markdown语法解析为HTML标签。这里我们需要做的就是解析出Markdown中的demo语法，渲染其中的Vue组件，并且同时能把源码也显示在组件下方，这样就完成了扩展任务。</p><p>Element3中对Markdown的扩展源码都可以在<a href=\"https://github.com/hug-sun/element3/tree/master/packages/md-loader/src\">GitHub</a>上看到。</p><p>下面的代码就是全部解析的逻辑：首先我们使用md.render把Markdown渲染成为HTML，并且获取内部demo子组件；在获取了demo组件内部的代码之后，调用genInlineComponentText，把组件通过Vue的compiler解析成待执行的代码，这一步就是模拟了Vue组件解析的过程；然后使用script标签包裹编译之后的Vue组件；最后再把组件的源码放在后面，demo组件的解析就完成了。</p><pre><code class=\"language-javascript\">const { stripScript, stripTemplate, genInlineComponentText } = require('./util')\n\tconst md = require('./config')\n\t\n\tmodule.exports = function (source) {\n\t  const content = md.render(source)\n\t\n\t  const startTag = '&lt;!--element-demo:'\n\t  const startTagLen = startTag.length\n\t  const endTag = ':element-demo--&gt;'\n\t  const endTagLen = endTag.length\n\t\n\t  let componenetsString = ''\n\t  let id = 0 // demo 的 id\n\t  const output = [] // 输出的内容\n\t  let start = 0 // 字符串开始位置\n\t\n\t  let commentStart = content.indexOf(startTag)\n\t  let commentEnd = content.indexOf(endTag, commentStart + startTagLen)\n\t  while (commentStart !== -1 &amp;&amp; commentEnd !== -1) {\n\t    output.push(content.slice(start, commentStart))\n\t\n\t    const commentContent = content.slice(commentStart + startTagLen, commentEnd)\n\t    const html = stripTemplate(commentContent)\n\t    const script = stripScript(commentContent)\n\t\n\t    const demoComponentContent = genInlineComponentText(html, script)\n\t\n\t    const demoComponentName = `element-demo${id}`\n\t    output.push(`&lt;template #source&gt;&lt;${demoComponentName} /&gt;&lt;/template&gt;`)\n\t    componenetsString += `${JSON.stringify(\n\t      demoComponentName\n\t    )}: ${demoComponentContent},`\n\t\n\t    // 重新计算下一次的位置\n\t    id++\n\t    start = commentEnd + endTagLen\n\t    commentStart = content.indexOf(startTag, start)\n\t    commentEnd = content.indexOf(endTag, commentStart + startTagLen)\n\t  }\n\t\n\t  // 仅允许在 demo 不存在时，才可以在 Markdown 中写 script 标签\n\t  // todo: 优化这段逻辑\n\t  let pageScript = ''\n\t  if (componenetsString) {\n\t    pageScript = `&lt;script&gt;\n\t      import hljs from 'highlight.js'\n\t      import * as Vue from \"vue\"\n\t      export default {\n\t        name: 'component-doc',\n\t        components: {\n\t          ${componenetsString}\n\t        }\n\t      }\n\t    &lt;/script&gt;`\n\t  } else if (content.indexOf('&lt;script&gt;') === 0) {\n\t    // 硬编码，有待改善\n\t    start = content.indexOf('&lt;/script&gt;') + '&lt;/script&gt;'.length\n\t    pageScript = content.slice(0, start)\n\t  }\n\t\n\t  output.push(content.slice(start))\n\t  return `\n\t    &lt;template&gt;\n\t      &lt;section class=\"content element-doc\"&gt;\n\t        ${output.join('')}\n\t      &lt;/section&gt;\n\t    &lt;/template&gt;\n\t    ${pageScript}\n\t  `\n\t}\n</code></pre><p>然后我们还要把渲染出来的Vue组件整体封装成为demo-block组件。在下面的代码中，我们使用扩展Markdown的render函数，内部使用demo-block组件，把Markdown渲染的结果渲染在浏览器上。</p><pre><code class=\"language-javascript\">const mdContainer = require('markdown-it-container')\n\nmodule.exports = (md) =&gt; {\n  md.use(mdContainer, 'demo', {\n    validate(params) {\n      return params.trim().match(/^demo\\s*(.*)$/)\n    },\n    render(tokens, idx) {\n      const m = tokens[idx].info.trim().match(/^demo\\s*(.*)$/)\n      if (tokens[idx].nesting === 1) {\n        const description = m &amp;&amp; m.length &gt; 1 ? m[1] : ''\n        const content =\n          tokens[idx + 1].type === 'fence' ? tokens[idx + 1].content : ''\n        return `&lt;demo-block&gt;\n        ${description ? `&lt;div&gt;${md.render(description)}&lt;/div&gt;` : ''}\n        &lt;!--element-demo: ${content}:element-demo--&gt;\n        `\n      }\n      return '&lt;/demo-block&gt;'\n    }\n  })\n\n  md.use(mdContainer, 'tip')\n  md.use(mdContainer, 'warning')\n}\n\n</code></pre><p>然后我们就实现了demo-block组件。接下来我们新建DemoBlock.vue，在下面的代码中我们通过slot实现了组件的渲染结果和源码高亮的效果，至此我们就成功了实现了Markdown中源码演示的效果。</p><pre><code class=\"language-javascript\">&lt;!-- DemoBlock.vue --&gt;\n&lt;template&gt;\n&nbsp; &lt;div class=\"demo-block\"&gt;\n&nbsp; &nbsp; &lt;div class=\"source\"&gt;\n&nbsp; &nbsp; &nbsp; &lt;slot name=\"source\"&gt;&lt;/slot&gt;\n&nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;div class=\"meta\" ref=\"meta\"&gt;\n&nbsp; &nbsp; &nbsp; &lt;div class=\"description\" v-if=\"$slots.default\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;slot&gt;&lt;/slot&gt;\n&nbsp; &nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &nbsp; &lt;div class=\"highlight\"&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &lt;slot name=\"highlight\"&gt;&lt;/slot&gt;\n&nbsp; &nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &nbsp; &lt;div\n&nbsp; &nbsp; &nbsp; class=\"demo-block-control\"\n&nbsp; &nbsp; &nbsp; ref=\"control\"\n&nbsp; &nbsp; &nbsp; @click=\"isExpanded = !isExpanded\"\n&nbsp; &nbsp; &gt;\n&nbsp; &nbsp; &nbsp; &lt;span&gt;{{ controlText }}&lt;/span&gt;\n&nbsp; &nbsp; &lt;/div&gt;\n&nbsp; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { ref, computed, watchEffect, onMounted } from 'vue'\nexport default {\n&nbsp; setup() {\n&nbsp; &nbsp; const meta = ref(null)\n&nbsp; &nbsp; const isExpanded = ref(false)\n&nbsp; &nbsp; const controlText = computed(() =&gt;\n&nbsp; &nbsp; &nbsp; isExpanded.value ? '隐藏代码' : '显示代码'\n&nbsp; &nbsp; )\n&nbsp; &nbsp; const codeAreaHeight = computed(() =&gt;\n&nbsp; &nbsp; &nbsp; [...meta.value.children].reduce((t, i) =&gt; i.offsetHeight + t, 56)\n&nbsp; &nbsp; )\n&nbsp; &nbsp; onMounted(() =&gt; {\n&nbsp; &nbsp; &nbsp; watchEffect(() =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; meta.value.style.height = isExpanded.value\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? `${codeAreaHeight.value}px`\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : '0'\n&nbsp; &nbsp; &nbsp; })\n&nbsp; &nbsp; })\n\n&nbsp; &nbsp; return {\n&nbsp; &nbsp; &nbsp; meta,\n&nbsp; &nbsp; &nbsp; isExpanded,\n&nbsp; &nbsp; &nbsp; controlText\n&nbsp; &nbsp; }\n&nbsp; }\n}\n&lt;/script&gt;\n</code></pre><h2>总结</h2><p>我们来总结一下今天学到的内容。</p><p>首先我们使用Vue官网文档的构建工具VuePress来搭建组件库文档，VuePress提供了很好的上手体验，Markdown中可以直接注册使用Vue组件，我们在.vuepress中可以扩展对Element3的支持。</p><p>如果我们定制需求更多一些，就需要自己解析Markdown并且实现对Vue组件的支持了，我们可以使用Markdown-it插件解析，支持Vue组件和代码高亮，这也是现在Element3文档的渲染方式。</p><h2>思考题</h2><p>最后留给你一道思考题：现在很多组件库开始尝试使用Storybook来搭建组件库的文档，那么这个Storybook相比于我们实现的文档有什么特色呢？</p><p>欢迎你在评论区分享你的看法，也欢迎你把这节课的内容分享给你的同事和朋友们，我们下一讲再见！</p>","comments":[{"had_liked":false,"id":329901,"user_name":"Geek_e1b932","can_delete":false,"product_type":"c1","uid":2864067,"ip_address":"","ucode":"CC87FBD441937B","user_header":"","comment_is_top":false,"comment_ctime":1641635042,"is_pvip":false,"replies":[{"id":"120219","content":"vitepress是未来，新的vue文档也正在用vitepress重构  ，现在vuepress比较成熟一些","user_name":"作者回复","comment_id":329901,"uid":"1003715","ip_address":"","utype":1,"ctime":1641774132,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5936602338","product_id":100094401,"comment_content":"vuepress和vitepress用哪个好？","like_count":1,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544893,"discussion_content":"vitepress是未来，新的vue文档也正在用vitepress重构  ，现在vuepress比较成熟一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641774132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339435,"user_name":"、轻","can_delete":false,"product_type":"c1","uid":1625453,"ip_address":"","ucode":"30713196ED1AA6","user_header":"https://static001.geekbang.org/account/avatar/00/18/cd/6d/928b0ffd.jpg","comment_is_top":false,"comment_ctime":1648101816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648101816","product_id":100094401,"comment_content":"这种文档方式厉害了","like_count":0},{"had_liked":false,"id":338922,"user_name":"我执","can_delete":false,"product_type":"c1","uid":1372261,"ip_address":"","ucode":"54A052C54BDE91","user_header":"https://static001.geekbang.org/account/avatar/00/14/f0/65/e1340d42.jpg","comment_is_top":false,"comment_ctime":1647788545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647788545","product_id":100094401,"comment_content":"Storybook 默认生产的文档 可以直接交互修改组件属性。 扩展也很丰富。 各家生态都支持","like_count":0},{"had_liked":false,"id":329221,"user_name":"DOKE","can_delete":false,"product_type":"c1","uid":1706666,"ip_address":"","ucode":"85E35749B367CF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0a/aa/c9063c09.jpg","comment_is_top":false,"comment_ctime":1641218389,"is_pvip":false,"replies":[{"id":"120856","content":"md-loader是element3文档使用的，代码在这里<br>https:&#47;&#47;github.com&#47;hug-sun&#47;element3&#47;tree&#47;master&#47;packages&#47;md-loader","user_name":"作者回复","comment_id":329221,"uid":"1003715","ip_address":"","utype":1,"ctime":1642339909,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1641218389","product_id":100094401,"comment_content":"没看懂这个Markdown-loader的代码是放在哪执行的？整个源码有么？","like_count":0,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546561,"discussion_content":"md-loader是element3文档使用的，代码在这里\nhttps://github.com/hug-sun/element3/tree/master/packages/md-loader","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642339910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}