{"id":464209,"title":"10 | Flow，是异步编程的终极选择吗？","content":"<p>你好，我是范学雷。今天，我们讨论反应式编程。</p><p>反应式编程曾经是一个很热门的话题。它是代码的控制的一种模式。如果不分析其他的模式，我们很难识别反应式编程的好与坏，以及最合适它的使用场景。所以，我们今天的讨论，和以往有很大的不同。</p><p>除了反应式编程之外，我们还会花很大的篇幅讨论其他的编程模式，包括现在的和未来的。希望这样的安排，能够帮助你根据具体的场景，选择最合适的模式。</p><p>我们从阅读案例开始，先来看一看最传统的模式，然后一步一步地过渡到反应式编程，最后我们再来稍微聊几句Java尚未发布的协程模式。</p><h2>阅读案例</h2><p>我想，你和我一样，无论是学习C语言，还是Java语言，都是从打印\"Hello, world!\"这个简单的例子开始的。我们再来看看这个我们熟悉的代码。</p><pre><code class=\"language-java\">System.out.println(\"Hello, World!\");\n</code></pre><p>这段代码就是使用了最常用的代码控制模式：指令式编程模型。<strong>所谓指令式编程模型，需要我们通过代码发布指令，然后等待指令的执行以及指令执行带来的状态变化。我们还要根据目前的状态，来确定下一次要发布的指令，并且用代码把下一个指令表示出来。</strong></p><p>上面的代码里，我们发布的指令就是：标准输出打印“Hello, World!”这句话。然后，我们就等待指令的执行结果，验证我们编写的代码有没有按照我们的指令工作。</p><!-- [[[read_end]]] --><h3><strong>指令式编程模型</strong></h3><p><strong>指令式编程模型关注的重点就在于控制状态。</strong>\"Hello, world!\"这个例子能看出来一点端倪，但是要了解状态变化和控制，我们需要看两行以上的代码。</p><pre><code class=\"language-java\">try {\n    Digest messageDigest = Digest.of(\"SHA-256\");\n    byte[] digestValue =\n            messageDigest.digest(\"Hello, world!\".getBytes());\n} catch (NoSuchAlgorithmException ex) {\n    System.out.println(\"Unsupported algorithm: SHA-256\");\n}\n</code></pre><p>在上面的这段代码里，我们首先调用Digest.of方法，得到一个Digest实例；然后调用这个实例的方法Digest.digest，获得一个返回值。第一个方法执行完成后，获得了第一个方法执行后的状态，第二个方法才能接着执行。</p><p>这种顺序执行的模式，逻辑简单直接。简单直接本身就有着巨大的能量，特别是实现精确控制方面。所以，这种模式在通用编程语言设计和一般的应用程序开发中，占据着压倒性的优势。</p><p>但是，这种模式需要维护和同步状态。如果状态数量大，我们就要把大的代码块分解成小的代码块；这样，我们编写的代码才能更容易阅读，更容易维护。而更大的问题来自于状态同步需要的顺序执行。</p><p>比如说吧，上面的例子中，Digest.of这个方法实现，可能效率很高，执行得很快；而Digest.digest这个方法的实现，它的执行速度可能就是毫秒级的，甚至是秒一级别的。在要求低延迟、高并发的环境下，等待Digest.digest调用的返回结果，可能就不是一个好的选择。换句话说，阻塞在方法的调用上，增加了系统的延迟，降低了系统能够支持的吞吐量。</p><p>这种顺序执行的模式带来的延迟后果，在互联网时代的很多场景下是无法忍受的（比如春节的火车票预售系统，或者网上购物节的订购系统等）。存在这种问题最典型的场景之一，就是客户端-服务器这种架构下的传统的套接字编程接口。它也引发了大约20年前提出的C10K问题（支持1万个并发用户）。</p><p>怎样解决C10K问题呢？一个主要方向，就是使用非阻塞的异步编程。</p><h3><strong>声明式编程模型</strong></h3><p>非阻塞的异步编程，并不是可以通过编程语言或者标准类库就可以得到的。支持非阻塞的异步编程，需要大幅度地更改代码，转换代码编写的思维习惯。</p><p>我们可以使用打电话来做个比方。</p><p>传统的指令式编程模型，就像我们通常打电话一样。我们拨打对方的电话号码，然后等待接听，然后通话，然后挂断。当我们挂断电话的时候，打电话这一个过程也就结束了，我们也拿到了想要的结果。</p><p>而非阻塞的异步编程，更像是电话留言。我们拨打对方的电话，告诉对方方便的时候，回拨电话，然后就挂断了。当我们挂断电话的时候，打电话这一个过程当然也是结束了，但是我们没有拿到想要的结果。想要的结果，还要依靠回拨电话，才能够得到。</p><p>而类似于回拨电话的逻辑，正是非阻塞的异步编程的关键模型。映射到代码上，就是使用回调函数或者方法。</p><p>当我们试图使用回调函数时，我们编写代码的思想和模型都会产生巨大的变化。我们关注的重点，就会从指令式编程模型的“控制状态”转变到“控制目标”。这时候，我们编程模型也就转变到了<strong>声明式的编程模型</strong>。</p><p><strong>如果指令式编程模型的逻辑是告诉计算机“该怎么做”，那么声明式的编程模型的逻辑就是告诉计算机“要做什么”。</strong>指令式编程模型的代码像是流水线作业的工程师，事无巨细，拧好每一个螺丝；而声明式的编程模型的代码，更像是稳坐在军帐中的军师，布置任务，运筹帷幄。</p><p>我们前面讨论的Digest，能不能实现非阻塞的异步编程呢？答案是肯定的，不过我们需要彻底地更改代码，从API到实现都要转换思路。下面这段代码里声明的API，就是我们尝试使用声明式编程的一个例子。</p><pre><code class=\"language-java\">public sealed abstract class Digest {\n    public static void of(String algorithm,\n        Consumer&lt;Digest&gt; onSuccess, Consumer&lt;Integer&gt; onFailure) {\n        // snipped\n    }\n\n    public abstract void digest(byte[] message,\n        Consumer&lt;byte[]&gt; onSuccess, Consumer&lt;Integer&gt; onFailure);\n}\n</code></pre><p>转化了思路的Digest.of方法，就像是布置任务：如果执行成功，请继续执行A计划（也就是onSuccess这个回调函数）；否则，就继续执行B计划（也就是onFailure这个回调函数）。其实，这也就是我们前面提到的，告诉计算机“要做什么”的概念。</p><p>有了回调函数的设计，代码的实现方式就放开了管制。无论是回调函数的实现，还是回调函数的调用，都可以自由地选择是采用异步的模式，还是同步的模式。不用说，这种自由很具有吸引力。从JDK 7引入NIO新特性开始，这种模式开始进入Java的工业实践，并且取得了巨大的成功。出现了一大批的明星项目。</p><p>不过，回调函数的设计也有着天生的缺陷。这个缺陷，就是回调地狱（Callback Hell，常被译为回调地狱。为了更直观地表达，我更喜欢把它叫做回调堆挤）。什么意思呢？通常地，我们需要布置多个小的任务，才能完成一项大的任务。这些小任务还有可能是有因果关系的任务，这时候，就需要小任务的配合，或者按顺序执行。</p><p>比如说，上面的Digest设计，我们先要判断of方法能不能成功；如果成功的话，那么就使用这个Digest实例，调用它的Digest.digest方法。而Digest.digest方法的调用，也要作出A计划和B计划。这样，两个回调函数的使用，就会堆积起来。如果回调函数的嵌套增多，代码看起来就像挤在一块一样，形式上不美观，阅读起来很费解，维护起来难度很大。</p><p>下面的这段代码，就是我们使用回调函数设计的Digest的一个用例。这个用例里，回调函数的嵌套仅仅有两层，代码的形式已经变得很难阅读了。你可以尝试编写一个3层或者5层的回调函数的嵌套，体验一下深度嵌套的代码是什么样子的。</p><pre><code class=\"language-java\">Digest.of(\"SHA-256\",\n    md -&gt; {\n        System.out.println(\"SHA-256 is not supported\");\n        md.digest(\"Hello, world!\".getBytes(),\n            values -&gt; {\n                System.out.println(\"SHA-256 is available\");\n            },\n            errorCode -&gt; {\n                System.out.println(\"SHA-256 is not available\");\n            });\n    },\n    errorCode -&gt; {\n        System.out.println(\"Unsupported algorithm: SHA-256\");\n    });\n</code></pre><p>如果说，回调函数带来的形式的堆积我们还可以克服的话；那这种形式上的堆积带来的逻辑堆积，我们就几乎不可承受了。<strong>逻辑上的堆积，意味着代码的深度耦合。而深度耦合，意味着代码维护困难。深度嵌套里的一点点代码修改，都可能通过嵌套层层朝上传递，最后牵动全局。</strong></p><p>这就导致，使用回调函数的声明式编程模型有着严重的场景适应问题。我们通常只使用回调函数解决性能影响最大的模块，比如说网络数据的传输；而大部分的代码，依然使用传统的、顺序执行的指令式模型。</p><p>好在，业界也有很多努力，试图改善回调函数的使用困境。其中最出色也是影响最大的一个，就是反应式编程。</p><h2>反应式编程</h2><p>反应式编程的基本逻辑，仍然是告诉计算机“要做什么”；但是它的关注点转移到了数据的变化以及数据和变化的传递上，或者说，是转移到了对数据变化的反应上。所以，<strong>反应式编程的核心是数据流和变化传递。</strong></p><p>如果我们从数据的流向角度来看的话，数据有两种基本的形式： 数据的输入和数据的输出。从这两种基本的形式，能够衍生出三种过程：最初的来源，数据的传递和最终的结局。</p><h3><strong>数据的输出</strong></h3><p>在Java的反应式编程模型的设计里，数据的输出使用只有一个参数的Flow.Publisher来表示。</p><pre><code class=\"language-java\">@FunctionalInterface\npublic static interface Publisher&lt;T&gt; {\n&nbsp; &nbsp; public void subscribe(Subscriber&lt;? super T&gt; subscriber);\n}\n</code></pre><p>在Flow.Publisher的接口设计里，泛型T表示的就是数据的类型。 数据输出的对象，是使用Flow.Subscriber来表示的。换句话说，数据的发布者通过授权订阅者，来实现数据从发布者到订阅者的传递。一个数据的发布者，可以有多个数据的订阅者。</p><p>需要注意的是，订阅的接口，安排在了Flow.Publisher这个接口里。这也就意味着，订阅者的订阅行为，是由数据的发布者发起的，而不是订阅者发起的。</p><p>数据最初的来源，就是一种形式的数据输出；它只有数据输出这一个传递方向，而不能接收数据的输入。</p><p>比如下面的代码，就是一个表示数据最初来源的例子。在这段代码里，数据的类型是字节数组；而数据发布的实现，我们使用了Java标准类库的参考性实现SubmissionPublisher这个类。</p><pre><code class=\"language-java\">SubmissionPublisher&lt;byte[]&gt; publisher = new SubmissionPublisher&lt;&gt;();\n</code></pre><h3><strong>数据的输入</strong></h3><p>下面，我们再来看下数据的输入。</p><p>在Java的反应式编程模型的设计里，数据的输入用只有一个参数的Flow.Subscriber来表示。也就是我们前面提到的订阅者。</p><pre><code class=\"language-java\">public static interface Subscriber&lt;T&gt; {\n&nbsp; &nbsp; public void onSubscribe(Subscription subscription);\n\n&nbsp; &nbsp; public void onNext(T item);\n\n&nbsp; &nbsp; public void onError(Throwable throwable);\n\n&nbsp; &nbsp; public void onComplete();\n}\n</code></pre><p>在Flow.Subscriber的接口设计里，泛型T表示的就是数据的类型。 这个接口里一共定义了四种任务，并分别规定了下面四种情形下的反应：</p><ol>\n<li>如果接收到订阅邀请该怎么办？这个行为由onSubscribe这个方法的实现确定。</li>\n<li>如果接收到数据该怎么办？这个行为由onNext这个方法的实现确定。</li>\n<li>如果遇到了错误该怎么办？这个行为由onError这个方法的实现确定。</li>\n<li>如果数据传输完毕该怎么办？这个行为由onComplete这个方法的实现确定。</li>\n</ol><p>数据最终的结局，就是一种形式的数据输入；它只有数据输入这一个传递方向，而不能产生数据的输出。</p><p>比如下面的代码，就是一个表示数据最终结果的例子。在这段代码里，我们使用一个泛型来表示数据的类型；然后，使用了一个Consumer函数来表示我们该怎么处理接收到的数据。这样的安排让这个例子具有了普遍的意义。只要稍作修改，就可以把它使用到实际场景中去了。</p><pre><code class=\"language-java\">package co.ivi.jus.flow.reactive;\n\nimport java.util.concurrent.Flow;\nimport java.util.function.Consumer;\n\npublic class Destination&lt;T&gt; implements Flow.Subscriber&lt;T&gt;{\n    private Flow.Subscription subscription;\n    private final Consumer&lt;T&gt; consumer;\n    \n    public Destination(Consumer&lt;T&gt; consumer) {\n        this.consumer = consumer;\n    }\n    \n    @Override\n    public void onSubscribe(Flow.Subscription subscription) {\n        this.subscription = subscription;\n        subscription.request(1);\n    }\n    \n    @Override\n    public void onNext(T item) {\n        subscription.request(1);\n        consumer.accept(item);\n    }\n    \n    @Override\n    public void onError(Throwable throwable) {\n        throwable.printStackTrace();\n    }\n    \n    @Override\n    public void onComplete() {\n        System.out.println(\"Done\");\n    }\n}\n</code></pre><h3><strong>数据的控制</strong></h3><p>你可能已经注意到了，Flow.Subscriber接口，并没有和Flow.Publisher直接联系。取而代之地出现了一个中间代理Flow.Subscription。Flow.Subscription管理、控制着Flow.Publisher和Flow.Subscriber之间的连接，以及数据的传递。</p><p>也就是说，在Java的反应式编程模型里，数据的传递控制从数据和数据的变化里分离了出来。这样的分离，对于降低功能之间的耦合意义重大。</p><pre><code class=\"language-java\">public static interface Subscription {\n&nbsp; &nbsp; public void request(long n);\n\n&nbsp; &nbsp; public void cancel();\n}\n</code></pre><p>在Flow.Subscription的接口设计里，我们定义了两个方法。一个方法表示订阅者希望接收的数据数量，也就是Subscription.request这个方法。另一个方法表示订阅者希望取消订阅，也就是Subscription.cancel这个方法。</p><h3><strong>数据的传递</strong></h3><p>除了最初的来源和最终的结局，数据表现还有一个过程，就是数据的传递。数据的传递这个过程，既包括接收输入数据，也包括发送输出数据。在数据传递这个环节，数据的内容可能会发生变化，数据的数量也可能会发生变化（比如，过滤掉一部分的数据，或者修改输入的数据，甚至替换掉输入的数据）。</p><p>在Java的反应式编程模型的设计里，这样的过程是由Flow.Processor表示的。Flow.Processor是一个扩展了Flow.Publisher和Flow.Subscriber的接口。所以，Flow.Processor有两个数据类型，泛型T表述输入数据的类型，泛型R表述输出数据的类型。</p><pre><code class=\"language-java\">public static interface Processor&lt;T,R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {\n}\n</code></pre><p>下面的代码，就是一个表示数据传递的例子。在这段代码里，我们使用泛型来表示输入数据和输出数据的类型；然后，我们使用了一个Function函数，来表示该怎么处理接收到的数据，并且输出处理的结果。这样的安排让这个例子具有了普遍的意义。稍作修改，你就可以把它用到实际场景中去了。</p><pre><code class=\"language-java\">package co.ivi.jus.flow.reactive;\n\nimport java.util.concurrent.Flow;\nimport java.util.concurrent.SubmissionPublisher;\nimport java.util.function.Function;\n\npublic class Transform&lt;T, R&gt; extends SubmissionPublisher&lt;R&gt;\n        implements Flow.Processor&lt;T, R&gt; {\n    private Function&lt;T, R&gt; transform;\n    private Flow.Subscription subscription;\n    \n    public Transform(Function&lt;T, R&gt; transform) {\n        super();\n        this.transform = transform;\n    }\n    \n    @Override\n    public void onSubscribe(Flow.Subscription subscription) {\n        this.subscription = subscription;\n        subscription.request(1);\n    }\n    \n    @Override\n    public void onNext(T item) {\n        submit(transform.apply(item));\n        subscription.request(1);\n    }\n    \n    @Override\n    public void onError(Throwable throwable) {\n        closeExceptionally(throwable);\n    }\n    \n    @Override\n    public void onComplete() {\n        close();\n    }\n}\n</code></pre><h3><strong>过程的串联</strong></h3><p>既然数据的表述方式分为输入和输出两种基本的形式，而且还提供了由此衍生出来的三种过程，我们就能够把数据的处理过程，很方便地串联起来了。</p><p>下面的代码，就是我们试图把最初的来源、数据的传递和最终的结局这三个过程，串联成一个更大的过程的例子。当然，你也可以试着串联进更多的数据处理过程。</p><pre><code class=\"language-java\">private static void transform(byte[] message,\n          Function&lt;byte[], byte[]&gt; transformFunction) {\n    SubmissionPublisher&lt;byte[]&gt; publisher =\n            new SubmissionPublisher&lt;&gt;();\n\n    // Create the transform processor\n    Transform&lt;byte[], byte[]&gt; messageDigest =\n            new Transform&lt;&gt;(transformFunction);\n\n    // Create subscriber for the processor\n    Destination&lt;byte[]&gt; subscriber = new Destination&lt;&gt;(\n            values -&gt; System.out.println(\n                    \"Got it: \" + Utilities.toHexString(values)));\n\n    // Chain processor and subscriber\n    publisher.subscribe(messageDigest);\n    messageDigest.subscribe(subscriber);\n    publisher.submit(message);\n\n    // Close the submission publisher.\n    publisher.close();\n}\n</code></pre><p>串联的形式，接藕了不同环节的关联；而且每个环节的代码也可以换个场景复用。支持过程的串联，是反应式编程模型强大的最大动力之一。像Scala这样的编程语言，甚至把过程串联提升到了编程语言的层面来支持。这样做，毫无疑问大幅度地提高了编码的效率和代码的美观程度。</p><h2>简洁的重构</h2><p>介绍完Java的反应式编程模型设计，我们要回头看看我们在阅读案例里提出的问题了。反应式编程，是怎么解决顺序执行的模式带来的延迟后果的呢？ 反应式编程，怎么解决回调函数带来的堆挤问题呢？</p><p>我们还是先看一眼使用反应式编程模型的代码，然后再来讨论这些问题吧。下面的代码，就是我们对阅读案例里Digest用法的改进。</p><pre><code class=\"language-java\">Returned&lt;Digest&gt; rt = Digest.of(\"SHA-256\");\nswitch (rt) {\n    case Returned.ReturnValue rv -&gt; {\n        // Get the returned value\n        if (rv.returnValue() instanceof Digest d) {\n            // Call the transform method for the message digest.\n            transform(\"Hello, World!\".getBytes(), d::digest);\n\n            // Wait for completion\n            Thread.sleep(20000);\n        } else {  // unlikely\n            System.out.println(\"Implementation error: SHA-256\");\n        }\n    }\n    case Returned.ErrorCode ec -&gt;\n            System.out.println(\"Unsupported algorithm: SHA-256\");\n}\n\n</code></pre><p>在这个例子里，我们没有发现类似于回调函数一样的堆挤现象。这里面，起重要作用的就是我们上面提到的过程的串联这种形式。Java的反应式编程模型里的过程串联和数据控制的设计，以及数据输入和输出的分离，降低了代码的耦合，不再需要嵌套的调用了。</p><p>在这个例子里，我们还看到了Digest.digest方法的直接使用。为了能够使用反应式编程模型，我们没有必要去修改Digest代码。只要把Digest原来的设计和实现，恰当地放到反应式编程模型里来，就能够实现异步非阻塞的设想了。这一点，无疑具有极大的吸引力。如果不是被逼无奈，谁会去颠覆已有的代码呢？</p><p>那到底反应式编程模型是怎么支持异步非阻塞的呢？其实，和回调函数一样，反应式编程既能够支持同步阻塞的模式，也能够支持异步非阻塞的模式。如果这些接口实现是异步非阻塞模式的，这些实现的调用，也就是异步非阻塞的。当然，反应式编程模型的主要使用场景，目前还是异步非阻塞模式。</p><p>比如我们例子中的SubmissionPublisher，就是一个异步非阻塞模式的实现。在上面的代码里，如果没有调用Thread.sleep，我们可能还看不到Digest的处理结果，主线程就退出了。这就是一个非阻塞的实现表现出来的现象。</p><h2>缺陷与对策</h2><p>到目前为止，反应式编程模型看起来还很完美。可是，反应式编程模型的缺陷也很要命。其中最要命的缺陷，就是错误很难排查，这是异步编程的通病。而反应式编程模型的解耦设计，加剧了错误排查的难度，这会严重影响开发的效率，降低代码的可维护性。</p><p>目前来看，解决反应式编程模型的缺陷，或者说是异步编程的缺陷的方向，似乎又要回到了指令式编程模型这条老路上来了。这里最值得提及的就是协程（Fiber）这个概念（目前，Java的协程模式还没有发布，但是我可以带你先了解一下）。</p><p>我们再来看看阅读案例里提到的这段代码。为了方便你阅读，我把它拷贝粘贴到这里来了。</p><pre><code class=\"language-java\">try {\n    Digest messageDigest = Digest.of(\"SHA-256\");\n    byte[] digestValue =\n            messageDigest.digest(\"Hello, world!\".getBytes());\n} catch (NoSuchAlgorithmException ex) {\n    System.out.println(\"Unsupported algorithm: SHA-256\");\n}\n</code></pre><p>在Java的指令式编程模型里，这段代码要在一个线程里执行。我们首先调用Digest.of方法，得到一个Digest实例；然后调用这个实例的方法Digest.digest，获得一个返回值。在每个方法返回之前，线程都会处于等待状态。而线程的等待，是造成资源浪费的最大因素。</p><p>而协程的处理方式，消除了线程的等待。如果调用阻塞，就会把资源切换出去，执行其他的操作。这就节省了大量的计算资源，使得系统在阻塞的模式下，支持大规模的并发。如果指令式编程模型能够通过协程的方式支持大规模的并发，也许它是一个颠覆现有高并发架构的新技术。</p><p>目前，Java的协程模式还没有发布。它能够给反应式编程模型带来什么样的影响，能够给我们实现大规模并发系统带来多大的便利？这些问题的答案，我们还需要等待一段时间。</p><h2>总结</h2><p>好，到这里，我来做个小结。前面，我们讨论了指令式编程模型和声明式编程模型，回调函数以及回调地狱，以及Java反应式编程模型的基本组件。</p><p>限于篇幅，我们不能展开讨论Java反应式编程模型的各种潜力和变化，比如“反应式宣言”“背压”这样的热门词汇。我建议你继续深入地了解反应式编程的这些要求（比如反应式宣言和反应式系统），以及成熟的明星产品（比如Akka和Spring 5+）。</p><p>由于Java的协程模式还没有发布，我对反应式编程的未来还没有清晰的判断。也欢迎你在留言区里留言、讨论反应式编程的现在和未来。</p><p>另外，我还拎出了几个今天讨论过的技术要点，这些都可能在你们面试中出现哦。通过这一次学习，你应该能够：</p><ul>\n<li>了解指令式编程模型和声明式编程模型这两个术语；\n<ul>\n<li>面试问题：你知道声明式编程模型吗，它是怎么工作的？</li>\n</ul>\n</li>\n<li>了解Java反应式编程模型的基本组件，以及它们的组合方式；\n<ul>\n<li>面试问题：你知道怎么使用Java反应式编程模型吗？</li>\n</ul>\n</li>\n<li>知道回调函数的形式，以及回调地狱这个说法。\n<ul>\n<li>面试问题：你知道回调函数有什么问题吗？</li>\n</ul>\n</li>\n</ul><p>反应式编程是目前主流的支持高并发的技术架构思路。学会反应式编程，意味着你有能力处理高并发应用这样的需求。能够编写高并发的代码，现在很重要，以后更重要。学会使用Java反应式编程模型这样一个高度抽象的接口，毫无疑问能够提升你的技术深度。</p><h2>思考题</h2><p>今天的思考题，我们来试着使用一下Java反应式编程模型。在讨论反应式编程的时候，计算a = b + c是一个常用的范例。在这个计算里，b和c随着时间的推移，会发生变化。而每一次的变化，都会影响a的计算结果。</p><p>现在我们假设a表示的数据是一件事情结束的时候是星期几，b表示的数据是一件事情开始的时候是星期几，c表示处理完这件事情需要多少天。你会怎么使用Java反应式编程模型来处理这个问题？</p><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及你的设计和代码。我们下节课见！</p><p>注：本文使用的完整的代码可以从<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/flow\">GitHub</a>下载，你可以通过修改<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/flow\">GitHub</a>上<a href=\"https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/flow/review/xuelei\">review template</a>代码，完成这次的思考题。如果你想要分享你的修改或者想听听评审的意见，请提交一个 GitHub的拉取请求（Pull Request），并把拉取请求的地址贴到留言里。这一小节的拉取请求代码，请在<a href=\"https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/flow/review\">反应式编程专用的代码评审目录</a>下，建一个以你的名字命名的子目录，代码放到你专有的子目录里。比如，我的代码，就放在flow/review/xuelei的目录下面。</p>","comments":[{"had_liked":false,"id":325181,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1638852584,"is_pvip":false,"replies":[{"id":"118044","content":"是的，现在看，反应式编程是高并发场景的主流选择。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638894773,"ip_address":"","comment_id":325181,"utype":1}],"discussion_count":5,"race_medal":0,"score":"14523754472","product_id":100097301,"comment_content":"虽然反应式编程编写起来复杂，但是因其是针对并发场景设计的，有机会还是很想体验一下威力，因为：<br><br>1. 数据传递时具有不可变的特性，天然支持线程安全；<br>2. 令人崩溃的多线程操作由 JDK 团队负责处理，降低了并发编程门槛<br>3. 《响应式架构  消息模式Actor实现与Scala.Akka应用集成》这本书中提到使用“反应式架构”的设计普通服务器的吞吐量可以轻松达到 300 ~ 500 万&#47;秒（记不清具体数值了），有这么高的吞吐量很多公司的业务就不需要微服务了，相对编写微服务的代码，也算简单了很多；<br>4. 《Java编程方法论:响应式Spring Reactor 3设计与实现》这本书入门还是挺好的，跟着书中示例运行一遍代码，差不多就入门了。","like_count":3,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536935,"discussion_content":"是的，现在看，反应式编程是高并发场景的主流选择。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638894773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537320,"discussion_content":"也不一定就要复制，否则数据拷贝的开销在一部分场景会影响性能。这要看具体的使用办法，有的要复制，有的要共享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639033156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537385,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639047189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537320,"ip_address":""},"score":537385,"extra":""}]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536943,"discussion_content":"哥们，“数据传递时具有不可变的特性”这句话怎么理解？为什么说是不可变的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638902587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536951,"discussion_content":"数据传递时，是复制一份相同的数据进行值传递，接收的函数可以随意更改收到的参数，不影响原来的值，就像String、LocalDate类。详见《图解Java多线程设计模式》第二章Immutable 模式-想破坏也破坏不了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638919574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536943,"ip_address":""},"score":536951,"extra":""}]}]},{"had_liked":false,"id":325268,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","comment_is_top":false,"comment_ctime":1638885972,"is_pvip":false,"replies":[{"id":"118053","content":"有时间看看Apache Spark, Akka, 或者Kafka。现在主流的高并发架构里，都有反应式的影子在。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638928475,"ip_address":"","comment_id":325268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10228820564","product_id":100097301,"comment_content":"老师，这个感觉有点抽象和复杂，有没有什么现成的已经在使用的业务场景的例子可以介绍来看看吗？加深下印象。<br>PS：思考题 PR：https:&#47;&#47;github.com&#47;XueleiFan&#47;java-up&#47;pull&#47;18","like_count":2,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536983,"discussion_content":"有时间看看Apache Spark, Akka, 或者Kafka。现在主流的高并发架构里，都有反应式的影子在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638928476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325527,"user_name":"bigben","can_delete":false,"product_type":"c1","uid":1169313,"ip_address":"","ucode":"DBD15A6C8E2590","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkeOAC8k7aPMfQZ4ickiavpfR9mTQs1wGhGtIicotzAoszE5qkLfFTabkDU2E39ovSgoibJ1IiaLXtGicg/132","comment_is_top":false,"comment_ctime":1639016480,"is_pvip":false,"replies":[{"id":"118117","content":"其实，这也许恰恰是精妙的地方。想一想数据流和控制权，可能感觉就好一点了。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639032644,"ip_address":"","comment_id":325527,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5933983776","product_id":100097301,"comment_content":"感觉这个api设计的不好理解也不合理，我觉得subscribe方法应该在subsciber上面，而不是publisher上面，太别扭了！","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537318,"discussion_content":"其实，这也许恰恰是精妙的地方。想一想数据流和控制权，可能感觉就好一点了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639032644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325402,"user_name":"worry","can_delete":false,"product_type":"c1","uid":1047773,"ip_address":"","ucode":"AF2BDAF6F6370E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/dd/0e17bf09.jpg","comment_is_top":false,"comment_ctime":1638945627,"is_pvip":true,"replies":[{"id":"118084","content":"我想是的，但是还需要时间验证。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638993845,"ip_address":"","comment_id":325402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5933912923","product_id":100097301,"comment_content":"go语言本身就支持协程，go语言在云服务上的成功是不是能证明协程这种模式是未来呢。spring是强烈推荐反应式编程模式的。","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537217,"discussion_content":"我想是的，但是还需要时间验证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638993846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325264,"user_name":"TableBear","can_delete":false,"product_type":"c1","uid":1673990,"ip_address":"","ucode":"A2C0562EEA2725","user_header":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","comment_is_top":false,"comment_ctime":1638883961,"is_pvip":true,"replies":[{"id":"118052","content":"下一个长期支持版可能就看到苗头了。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638928199,"ip_address":"","comment_id":325264,"utype":1}],"discussion_count":2,"race_medal":3,"score":"5933851257","product_id":100097301,"comment_content":"协程看起来很强，不知道啥时候能用上呢","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536982,"discussion_content":"下一个长期支持版可能就看到苗头了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638928199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1689344,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c7/00/fc131268.jpg","nickname":"尘曦。","note":"","ucode":"8EB13CA7560FDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546477,"discussion_content":"那得还等3年，不知道Java还能不能顶住","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642314193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536982,"ip_address":""},"score":546477,"extra":""}]}]},{"had_liked":false,"id":359350,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1665461930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665461930","product_id":100097301,"comment_content":"反应式编程模型的解耦设计，加剧了错误排查的难度，这会严重影响开发的效率，降低代码的可维护性。--记下来","like_count":0},{"had_liked":false,"id":346267,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1652960663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652960663","product_id":100097301,"comment_content":"这套Flow框架是不是从glassfish那拷贝过来的？<br>","like_count":0},{"had_liked":false,"id":328252,"user_name":"LeaveStyle","can_delete":false,"product_type":"c1","uid":1360256,"ip_address":"","ucode":"110B02D7969974","user_header":"https://static001.geekbang.org/account/avatar/00/14/c1/80/36245147.jpg","comment_is_top":false,"comment_ctime":1640623213,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640623213","product_id":100097301,"comment_content":"kotlin相比较于java和go，是不是一门更现代化的语言，感觉这些特性kotlin都有支持。","like_count":0},{"had_liked":false,"id":326253,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1639450332,"is_pvip":false,"replies":[{"id":"118531","content":"1. 声明式编程是一个大箩筐，有不同的偏好，反应式和回调式是不同的选择。<br>2. 也许吧，还不太明白资源模型和回调函数的结合。需要学习。<br>3. 反应式的可读性可能依赖于框架的选择，我看Akka的代码很舒服。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639524013,"ip_address":"","comment_id":326253,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639450332","product_id":100097301,"comment_content":"以下仅个人观点，不一定对，只是明确的表达不同的观点。<br><br>1.如果讲究声明式编程的话 Digest.of() 不该传入成功与失败时的执行函数。使用方只感知 Digest.of() 这个目标，不关心内部的执行细节（包括成功失败的分支流转），对应成功失败走什么逻辑封装在 Digest 的子类或实现类。只要在有必要时才会打开 Digest 的子类去看对应的实现细节。<br><br>2.回调函数的写法应当遵循超文本的风格。仅包含，数据信息&#47;执行某个动作&#47;获取新的超文本(带有回调函数的实体)。如此一来，代码实现就不会存在逻辑上的堆积，将会以资源模型为载体各自独立收敛。如果你发现有避不开的堆积，可能不是回调函数的问题，而是你在这里缺失了某种资源模型。<br><br>3.反应式编程模型错误难排查的问题，靠链路追踪的日志体系其实可以缓解，没有指令式那么直观，但排查耗时也不会差很多。反倒是实现的结构降低了可读性，加剧了代码维护难度，这个问题比较大。同步写异步执行会是一个更舒服的方向，所以同样是提高性能，如果协程能满足需求，应该会更推崇协程。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538790,"discussion_content":"1. 声明式编程是一个大箩筐，有不同的偏好，反应式和回调式是不同的选择。\n2. 也许吧，还不太明白资源模型和回调函数的结合。需要学习。\n3. 反应式的可读性可能依赖于框架的选择，我看Akka的代码很舒服。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639524014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326225,"user_name":"黑","can_delete":false,"product_type":"c1","uid":1784474,"ip_address":"","ucode":"96D0F91F8A6FCA","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3a/9a/8b6aaa39.jpg","comment_is_top":false,"comment_ctime":1639445765,"is_pvip":false,"replies":[{"id":"118465","content":"没太明白这个问题。要不，你换个说法，看看我能不能理解你的问题？","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1639454144,"ip_address":"","comment_id":326225,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639445765","product_id":100097301,"comment_content":"一直有个疑惑，新版的jdk使用flow的话，回调函数是否还是存放和唤醒逻辑是什么样的呢。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538604,"discussion_content":"没太明白这个问题。要不，你换个说法，看看我能不能理解你的问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639454144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325683,"user_name":"许灵","can_delete":false,"product_type":"c1","uid":1059926,"ip_address":"","ucode":"0296EC9929B570","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/56/ff7a9730.jpg","comment_is_top":false,"comment_ctime":1639098419,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639098419","product_id":100097301,"comment_content":"https:&#47;&#47;github.com&#47;XueleiFan&#47;java-up&#47;pull&#47;19<br>反应式编程里，这个实现可能还有些问题。希望老师指点，这里随着数据变更，如果没有sleep会出现计算结果相同的问题，不知道有没有好的处理方式。","like_count":0},{"had_liked":false,"id":325117,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1638835165,"is_pvip":false,"replies":[{"id":"117988","content":"是的， 会是JDK的一部分。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638841346,"ip_address":"","comment_id":325117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638835165","product_id":100097301,"comment_content":"Java 的虚拟线程,尾调用优化等来自<br> OpenJDK的 loom 项目。刚去看了下,目前依然只支持 Mac 和 Linux 系统。老师,如果正式发布了,是否会内置到 JDK 中呢?","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536648,"discussion_content":"是的， 会是JDK的一部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638841346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325113,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1638833712,"is_pvip":false,"replies":[{"id":"117990","content":"异步一定要再封装一层， 否则太难用了。  JDK没有提供进一步的封装，就显得比较复杂。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638841556,"ip_address":"","comment_id":325113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638833712","product_id":100097301,"comment_content":"换成反应式增加了不少代码。之前看过一些Spring提供的反应式编程，但碍于生态问题，那会很难用到生产环境中，现在也许成熟多了。<br><br>在JavaScript里面，很早就用异步请求了，但很简单和方便。<br><br>说起回调地狱，可以去看看Flutter的嵌套地狱，还好在IDE端做了提示优化，不然很难分清哪个括号对应的代码。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536653,"discussion_content":"异步一定要再封装一层， 否则太难用了。  JDK没有提供进一步的封装，就显得比较复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638841556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324952,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1638754303,"is_pvip":false,"replies":[{"id":"117891","content":"的确要复杂很多，不过可以再抽象出来一层简化。如果你看看Akka的设计，总体感觉是应用层的代码可以更少、更简单。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638761884,"ip_address":"","comment_id":324952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638754303","product_id":100097301,"comment_content":"感觉原来三行代码,换成响应式复杂了许多","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536335,"discussion_content":"的确要复杂很多，不过可以再抽象出来一层简化。如果你看看Akka的设计，总体感觉是应用层的代码可以更少、更简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638761884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}