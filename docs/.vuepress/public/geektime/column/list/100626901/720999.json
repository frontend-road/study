{"id":720999,"title":"06｜复合类型（下）：枚举与模式匹配","content":"<p>你好，我是Mike。今天我们一起来学习Rust中的枚举（enum）和模式匹配（pattern matching）。</p><p>枚举是Rust中非常重要的复合类型，也是最强大的复合类型之一，广泛用于属性配置、错误处理、分支流程、类型聚合等场景中。学习完这节课后，你会对Rust的地道风格有新的认识。</p><h2>枚举：强大的复合类型</h2><p>枚举是这样一种类型，它容纳选项的可能性，每一种可能的选项都是一个变体（variant）。Rust中的枚举使用关键字 <strong>enum</strong>定义，这点与Java、C++都是一样的。与它们不同的是，Rust中的枚举具有更强大的表达能力。</p><p>在Rust中，枚举中的所有条目被叫做这个枚举的变体。比如：</p><pre><code class=\"language-plain\">enum Shape {\n    Rectangle,\n    Triangle,\n    Circle,\n}\n</code></pre><p>定义了一个形状（Shape）枚举，它有三个变体：长方形Rectangle、三角形Triangle和圆形Circle。</p><p>枚举与结构体不同，<strong>结构体的实例化需要所有字段一起起作用，而枚举的实例化只需要且只能是其中一个变体起作用</strong>。</p><h3>负载</h3><p>Rust中枚举的强大之处在于，enum中的变体可以挂载各种形式的类型。所有其他类型，比如字符串、元组、结构体等等，都可以作为enum的负载（payload）被挂载到其中一个变体上。比如，扩展一下上面的代码示例。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">enum Shape {\n    Rectangle { width: u32, height: u32},\n    Triangle((u32, u32), (u32, u32), (u32, u32)),\n    Circle { origin: (u32, u32), radius: u32 },\n}\n</code></pre><p>我们给Shape枚举的三个变体都挂载了不同的负载。Rectangle挂载了一个结构体负载表示宽和高的属性。</p><pre><code class=\"language-plain\">{width: u32, height: u32}\n</code></pre><p>为了看得更清楚，你也可以单独定义一个结构体，然后把它挂载到Rectangle变体上。</p><pre><code class=\"language-plain\">struct Rectangle {\n  width: u32, \n  height: u32\n}\n\nenum Shape {\n  Rectangle(Rectangle),\n  // ...\n}\n</code></pre><p>Triangle变体挂载了一个元组负载 <code>((u32, u32), (u32, u32), (u32, u32))</code>，表示三个顶点。</p><p>Circle变体挂载了一个结构体负载 <code>{ origin: (u32, u32), radius: u32 }</code>，表示一个原点加半径长度。</p><p>枚举的变体能够挂载各种类型的负载，是Rust中的枚举超强能力的来源，你可以通过上面例子来细细品味Rust的这种表达力。enum就像一个筐，什么都能往里面装。</p><p>为了让你更熟悉Rust的枚举表达形式，我再举一个例子。下面的示例中WebEvent表示浏览器里面的Web事件。</p><pre><code class=\"language-plain\">enum WebEvent {\n    PageLoad,\n    PageUnload,\n    KeyPress(char),\n    Paste(String),\n    Click { x: i64, y: i64 },\n}\n</code></pre><p>你可以表述出不同变体的意义，还有每个变体所挂载的负载类型吗？期待看到你的答案。</p><h3>枚举的实例化</h3><p>枚举的实例化实际是枚举变体的实例化。比如：</p><pre><code class=\"language-plain\">let a = WebEvent::PageLoad;\nlet b = WebEvent::PageUnload;\nlet c = WebEvent::KeyPress('c');\nlet d = WebEvent::Paste(String::from(\"batman\"));\nlet e = WebEvent::Click { x: 320, y: 240 };\n</code></pre><p>可以看到，不带负载的变体实例化和带负载的变体实例化不一样。带负载的变体实例化要根据不同变体附带的类型做特定的实例化。</p><h3>类C枚举</h3><p>Rust中也可以定义类似C语言中的枚举。</p><p>示例：</p><pre><code class=\"language-plain\">// 给枚举变体一个起始数字值 \nenum Number {\n    Zero = 0,\n    One,\n    Two,\n}\n\n// 给枚举每个变体赋予不同的值\nenum Color {\n    Red = 0xff0000,\n    Green = 0x00ff00,\n    Blue = 0x0000ff,\n}\n\nfn main() {\n    // 使用 as 进行类型的转化\n    println!(\"zero is {}\", Number::Zero as i32);\n    println!(\"one is {}\", Number::One as i32);\n\n    println!(\"roses are #{:06x}\", Color::Red as i32);\n    println!(\"violets are #{:06x}\", Color::Blue as i32);\n}\n// 输出 \nzero is 0\none is 1\nroses are #ff0000\nviolets are #0000ff\n</code></pre><p>可以看到，我们能够像C语言那样，在定义枚举变体的时候，指定具体的值。这在底层系统级开发、协议栈开发、嵌入式开发的场景会经常用到。</p><p>打印的时候，只需要使用 as 操作符将变体转换为具体的数值类型即可。</p><p>代码中的 <code>println!</code> 里的 <code>{:06x}</code> 是格式化参数，这里表示打印出值的16进制形式，占位6个宽度，不足的用0补齐。你可以顺便了解一下 println 打印语句中<a href=\"https://doc.rust-lang.org/std/fmt/index.html\">格式化参数</a>的详细内容。格式化参数相当丰富，我们可以在以后不断地实践中去熟悉和掌握它。</p><h3>空枚举</h3><p>Rust中也可以定义空枚举。比如 <code>enum MyEnum {};</code>。它其实与单元结构体一样，都表示一个类型。但是它不能被实例化。目前看起来好像没什么作用，我们只需要了解这种表示形式就可以了。</p><pre><code class=\"language-plain\">enum Foo {}  \n\nlet a = Foo {}; // 错误的\n\n// 提示\nexpected struct, variant or union type, found enum `Foo`\nnot a struct, variant or union type\n</code></pre><h3>impl 枚举</h3><blockquote>\n<p>Rust有个关键字 <strong>impl</strong>可以用来给结构体或其他类型实现方法，也就是关联在某个类型上的函数。——第5讲</p>\n</blockquote><p>枚举同样能够被 impl。比如：</p><pre><code class=\"language-plain\">enum MyEnum {\n    Add,\n    Subtract,\n}\n\nimpl MyEnum {\n    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {\n        match self {                  // match 语句\n            Self::Add =&gt; x + y,\n            Self::Subtract =&gt; x - y,\n        }\n    }\n}\n\nfn main() {\n    // 实例化枚举\n    let add = MyEnum::Add;\n    // 实例化后执行枚举的方法\n    add.run(100, 200);\n}\n</code></pre><p>但是不能对枚举的变体直接 impl。</p><pre><code class=\"language-plain\">enum Foo {\n  AAA,\n  BBB,\n  CCC\n}\n\nimpl Foo::AAA {   // 错误的\n}\n</code></pre><p>一般情况下，枚举会用来做配置，并结合 match 语句使用来做分支管理。<strong>如果要定义一个新类型，在Rust中主要还是使用结构体。</strong></p><h2>match</h2><p>接下来我们开始学习和枚举搭配使用的match语句。</p><h3>match + 枚举</h3><p>其实在上面的示例中，就已经出现 match 关键字了。它的作用是判断或匹配值是哪一个枚举的变体。下面我们看一个例子。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nenum Shape {\n  &nbsp; Rectangle,\n  &nbsp; Triangle,\n  &nbsp; Circle,\n}\n\nfn main() {\n  &nbsp; let shape_a = Shape::Rectangle;  // 创建实例\n  &nbsp; match shape_a {                  // 匹配实例\n    &nbsp; &nbsp; Shape::Rectangle =&gt; {\n    &nbsp; &nbsp; &nbsp;   println!(\"{:?}\", Shape::Rectangle);  // 进了这个分支\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; Shape::Triangle =&gt; {\n    &nbsp; &nbsp; &nbsp;   println!(\"{:?}\", Shape::Triangle);\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; Shape::Circle =&gt; {\n    &nbsp; &nbsp; &nbsp;   println!(\"{:?}\", Shape::Circle);\n    &nbsp; &nbsp; }\n  &nbsp; }&nbsp;&nbsp;\n}\n// 输出\nRectangle\n</code></pre><p>你可以试着改变实例为另外两种变体，看看打印出的信息有没有变化，然后判断上面的代码走了哪个分支。</p><h3>match可返回值</h3><p>就像大多数Rust语法一样，match 语法也是可以有返回值的，所以也叫做match表达式，我们来看一下示例。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nenum Shape {\n  &nbsp; Rectangle,\n  &nbsp; Triangle,\n  &nbsp; Circle,\n}\n\nfn main() {\n  &nbsp; let shape_a = Shape::Rectangle;  // 创建实例\n  &nbsp; let ret = match shape_a {        // 匹配实例，并返回结果给ret\n    &nbsp; &nbsp; Shape::Rectangle =&gt; {\n    &nbsp; &nbsp; &nbsp;   1\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; Shape::Triangle =&gt; {\n    &nbsp; &nbsp; &nbsp;   2\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; Shape::Circle =&gt; {\n    &nbsp; &nbsp; &nbsp;   3\n    &nbsp; &nbsp; }\n  &nbsp; };\n    println!(\"{}\", ret);&nbsp;&nbsp;\n}\n// 输出\n1\n</code></pre><p>因为 <code>shape_a</code> 被赋值为 <code>Shape::Rectangle</code>，所以程序匹配到第一个分支并返回 1，变量ret的值为 1。</p><pre><code class=\"language-plain\">let ret = match shape_a {   \n</code></pre><p>这种写法就是比较地道的Rust写法，可以让代码显得更紧凑。</p><p>注意，<strong>match表达式中各个分支返回的值的类型必须相同</strong>。</p><h3>所有分支都必须处理</h3><p>match表达式里所有的分支都必须处理，不然Rustc小助手会拦住你，不让你通过。这是怎么回事呢？你可以看一下示例代码。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nenum Shape {\n  &nbsp; Rectangle,\n  &nbsp; Triangle,\n  &nbsp; Circle,\n}\n\nfn main() {\n  &nbsp; let shape_a = Shape::Rectangle;&nbsp; // 创建实例\n  &nbsp; let ret = match shape_a {&nbsp; &nbsp; &nbsp; &nbsp; // 匹配实例\n    &nbsp; &nbsp; Shape::Rectangle =&gt; {\n    &nbsp; &nbsp; &nbsp;   1\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; Shape::Triangle =&gt; {\n    &nbsp; &nbsp; &nbsp;   2\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; // Shape::Circle =&gt; {\n    &nbsp; &nbsp; //&nbsp; &nbsp;  3\n    &nbsp; &nbsp; // }\n  &nbsp; };\n  &nbsp; println!(\"{}\", ret);&nbsp;&nbsp;\n}\n</code></pre><p>上面这段代码在编译的时候会出错。</p><pre><code class=\"language-plain\">error[E0004]: non-exhaustive patterns: `Shape::Circle` not covered\n  --&gt; src/main.rs:10:19\n   |\n10 |   let ret = match shape_a {                  // 匹配实例\n   |                   ^^^^^^^ pattern `Shape::Circle` not covered\n   |\nnote: `Shape` defined here\n  --&gt; src/main.rs:5:3\n   |\n2  | enum Shape {\n   |      -----\n...\n5  |   Circle,\n   |   ^^^^^^ not covered\n   = note: the matched value is of type `Shape`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n   |\n16 ~     },\n17 +     Shape::Circle =&gt; todo!()\n   |\n</code></pre><p>小助手提示说，<code>Shape::Circle</code> 分支没有覆盖到，不允许通过，然后直接贴心地给出了修改建议！Rustc小助手如此贴心，这种保姆级服务是你在Java、C++等其他语言中感受不到的。</p><h3>_ 占位符</h3><p>有时，你确实想测试一些东西，或者就是不想处理一些分支，可以用 _ 偷懒。</p><p>比如上面代码可以修改成这样：</p><pre><code class=\"language-plain\">#[derive(Debug)]\nenum Shape {\n  &nbsp; Rectangle,\n  &nbsp; Triangle,\n  &nbsp; Circle,\n}\n\nfn main() {\n  &nbsp; let shape_a = Shape::Rectangle;&nbsp; \n  &nbsp; let ret = match shape_a {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n    &nbsp; &nbsp; Shape::Rectangle =&gt; {\n    &nbsp; &nbsp; &nbsp;   1\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; _ =&gt; {\n    &nbsp; &nbsp; &nbsp;   10\n    &nbsp; &nbsp; }\n  &nbsp; };\n  &nbsp; println!(\"{}\", ret);&nbsp;&nbsp;\n}\n</code></pre><p>相当于除 <code>Shape::Rectangle</code> 之外的分支我们都统一用 _ 占位符进行处理了。</p><h3>更广泛的分支</h3><p>match除了配合枚举进行分支管理外，还可以与其他基础类型结合进行分支分派。我们可以看一个 The Book里的示例。</p><pre><code class=\"language-plain\">fn main() {\n    let number = 13;\n    // 你可以试着修改上面的数字值，看看下面走哪个分支\n\n    println!(\"Tell me about {}\", number);\n    match number {\n        // 匹配单个数字\n        1 =&gt; println!(\"One!\"),\n        // 匹配几个数字\n        2 | 3 | 5 | 7 | 11 =&gt; println!(\"This is a prime\"),\n        // 匹配一个范围，左闭右闭区间\n        13..=19 =&gt; println!(\"A teen\"),\n        // 处理剩下的情况\n        _ =&gt; println!(\"Ain't special\"),\n    }\n}\n</code></pre><p>可以看到，match可以用来匹配一个具体的数字、一个数字的列表，或者一个数字的区间等等，非常灵活。在这点上，可比C、C++，或者Java 的 <code>switch .. case</code> 灵活多了。</p><h2>模式匹配</h2><p>match实际是模式匹配的入口，从match表达式我们可引出模式匹配的概念。模式匹配就是<strong>按对象值的结构</strong>进行匹配，并且可以取出符合模式的值。下面我们通过一些示例来解释这句话。</p><p>模式匹配不限于在 match 中使用。除了match外，Rust还给模式匹配提供了其他一些语法层面的设施。</p><h3>if let</h3><p>当要匹配的分支只有两个或者在这个位置只想先处理一个分支的时候，可以直接用 if let。</p><p>比如下面这段代码就可以使用 if let。</p><pre><code class=\"language-plain\">  let shape_a = Shape::Rectangle;  \n  match shape_a {                  \n    Shape::Rectangle =&gt; {\n      println!(\"1\");\n    }\n    _ =&gt; {\n      println!(\"10\");\n    }\n  };\n</code></pre><p>改写为：</p><pre><code class=\"language-plain\">  let shape_a = Shape::Rectangle;  \n  if let Shape::Rectangle = shape_a {                  \n    println!(\"1\");\n  } else {\n    println!(\"10\");\n  }\n</code></pre><p>是不是相比于match，使用 if let 的代码量有所简化？</p><h3>while let</h3><p>while 后面也可以跟 let，实现模式匹配。比如：</p><pre><code class=\"language-plain\">#[derive(Debug)]\nenum Shape {\n    Rectangle,\n    Triangle,\n    Circle,\n}\n\nfn main() {\n    let mut shape_a = Shape::Rectangle; \n    let mut i = 0;\n    while let Shape::Rectangle = shape_a {    // 注意这一句\n        if i &gt; 9 {\n            println!(\"Greater than 9, quit!\");\n            shape_a = Shape::Circle;\n        } else {\n            println!(\"`i` is `{:?}`. Try again.\", i);\n            i += 1;\n        }\n    }\n}\n// 输出\n`i` is `0`. Try again.\n`i` is `1`. Try again.\n`i` is `2`. Try again.\n`i` is `3`. Try again.\n`i` is `4`. Try again.\n`i` is `5`. Try again.\n`i` is `6`. Try again.\n`i` is `7`. Try again.\n`i` is `8`. Try again.\n`i` is `9`. Try again.\nGreater than 9, quit!\n</code></pre><p>上面示例构造了一个while循环，手动维护计数器 i，递增到9之后，退出循环。</p><p>看起来，在条件判断语句那里用 <code>while Shape::Rectangle == shape_a</code> 也行，好像用 while let 的意义不大。我们来试一下，编译之后，报错了。</p><pre><code class=\"language-plain\">error[E0369]: binary operation `==` cannot be applied to type `Shape`\n</code></pre><p>说 == 号不能作用在类型 Shape 上，你可以思考一下为什么。</p><p>如果一个枚举变体带负载，使用模式匹配可以把这个负载取出来，这点就比较方便了，下面我们使用带负载的枚举来举例。</p><h3>let</h3><p>let本身就支持模式匹配。其实前面的 if let、while let 本身使用的就是 let 模式匹配的能力。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nenum Shape {\n  &nbsp; Rectangle {width: u32, height: u32},\n  &nbsp; Triangle,\n  &nbsp; Circle,\n}\n\nfn main() {\n    // 创建实例\n&nbsp; &nbsp; let shape_a = Shape::Rectangle {width: 10, height: 20};&nbsp;\n&nbsp; &nbsp; // 模式匹配出负载内容\n    let Shape::Rectangle {width, height} = shape_a else {\n&nbsp; &nbsp; &nbsp; &nbsp; panic!(\"Can't extract rectangle.\");\n&nbsp; &nbsp; };\n&nbsp; &nbsp; println!(\"width: {}, height: {}\", width, height);\n}\n\n// 输出\nwidth: 10, height: 20\n</code></pre><p>在这个示例中，我们利用模式匹配解开了shape_a 中带的负载（结构体负载），同时定义了 width 和 height 两个局部变量，并初始化为枚举变体的实例负载的值。这两个局部变量在后续的代码块中可以使用。</p><p>注意第12行代码。</p><pre><code class=\"language-plain\">let Shape::Rectangle {width, height} = shape_a else {\n</code></pre><p>这种语法是匹配结构体负载，获取字段值的方式。</p><h3>匹配元组</h3><p>元组也可以被匹配，比如下面这个例子。</p><pre><code class=\"language-plain\">fn main() {\n    let a = (1,2,'a');\n    \n    let (b,c,d) = a;\n    \n    println!(\"{:?}\", a);\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n    println!(\"{}\", d);\n}\n</code></pre><p>这种用法叫做元组的析构，常用来从函数的多个返回值里取出数据。</p><pre><code class=\"language-plain\">fn foo() -&gt; (u32, u32, char) {\n    (1,2,'a')\n}\n\nfn main() {\n    let (b,c,d) = foo();\n    \n    println!(\"{}\", b);\n    println!(\"{}\", c);\n    println!(\"{}\", d);\n}\n</code></pre><h3>匹配枚举</h3><p>前面已经讲过如何使用 let 把枚举里变体的负载解出来，这里我们再来看一个例子。</p><pre><code class=\"language-plain\">struct Rectangle {\n  &nbsp; width: u32,&nbsp;\n  &nbsp; height: u32\n}\n\nenum Shape {\n  &nbsp; Rectangle(Rectangle),\n  &nbsp; Triangle((u32, u32), (u32, u32), (u32, u32)),\n  &nbsp; Circle { origin: (u32, u32), radius: u32 },\n}\n\nfn main() {\n  &nbsp; let a_rec = Rectangle {\n    &nbsp; &nbsp; width: 10,\n    &nbsp; &nbsp; height: 20,\n  &nbsp; };\n  \n    // 请打开下面这一行进行实验\n  &nbsp; //let shape_a = Shape::Rectangle(a_rec);\n    // 请打开下面这一行进行实验\n    //let shape_a = Shape::Triangle((0, 1), (3,4), (3, 0));\n    \n    let shape_a = Shape::Circle { origin: (0, 0), radius: 5 };\n  &nbsp;&nbsp;\n    // 这里演示了在模式匹配中将枚举的负载解出来的各种形式\n  &nbsp; match shape_a {\n    &nbsp; &nbsp; Shape::Rectangle(a_rec) =&gt; {  // 解出一个结构体\n    &nbsp; &nbsp; &nbsp; &nbsp; println!(\"Rectangle {}, {}\", a_rec.width, a_rec.height);\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; Shape::Triangle(x, y, z) =&gt; {  // 解出一个元组\n    &nbsp; &nbsp; &nbsp; &nbsp; println!(\"Triangle {:?}, {:?}, {:?}\", x, y, z);\n    &nbsp; &nbsp; }\n    &nbsp; &nbsp; Shape::Circle {origin, radius} =&gt; {  // 解出一个结构体的字段\n    &nbsp; &nbsp; &nbsp; &nbsp; println!(\"Circle {:?}, {:?}\", origin, radius);\n    &nbsp; &nbsp; }\n  &nbsp; }\n}\n// 输出\nCircle (0, 0), 5\n</code></pre><p>这个示例展示了如何将变体中的结构体整体、元组各部分、结构体各字段解析出来的方式。</p><p>用这种方式，我们可以在做分支处理的时候，顺便处理携带的信息，让代码变得相当紧凑而有意义（高内聚）。你需要熟悉并掌握这些写法，这样写起Rust代码来才会更加顺手。</p><h3>匹配结构体</h3><p>下面我们再看一个例子，了解结构体字段匹配过程中的一个细节。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct User {\n    name: String,\n    age: u32,\n    student: bool\n}\n\nfn main() {\n    let a = User {\n        name: String::from(\"mike\"),\n        age: 20,\n        student: false,\n    };\n    let User {\n        name,\n        age,\n        student,\n    } = a;\n    \n    println!(\"{}\", name);\n    println!(\"{}\", age);\n    println!(\"{}\", student);\n    println!(\"{:?}\", a);\n}\n</code></pre><p>编译输出：</p><pre><code class=\"language-plain\">error[E0382]: borrow of partially moved value: `a`\n  --&gt; src/main.rs:24:22\n   |\n16 |         name,\n   |         ---- value partially moved here\n...\n24 |     println!(\"{:?}\", a);\n   |                      ^ value borrowed here after partial move\n   |\n   = note: partial move occurs because `a.name` has type `String`, which does not implement the `Copy` trait\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: borrow this binding in the pattern to avoid moving the value\n   |\n16 |         ref name,\n   |         +++\n</code></pre><p>编译提示出错了，在模式匹配的过程中发生了partially moved。关于partially moved我们在上节课已经讲过。模式匹配过程中新定义的三个变量 name、age、student 分别得到了对应User实例a的三个字段值的所有权。</p><p>age 和 student 采用了复制所有权的形式（参考<a href=\"https://time.geekbang.org/column/article/718916\">第 2 讲</a>移动还是复制部分），而 name 字符串值则是采用了移动所有权的形式。a.name被部分移动到了新的变量 name ，所以接下来 a.name 就无法直接使用了。</p><p>这个示例说明<strong>Rust中的模式匹配是一种释放原对象的所有权的方式</strong>。</p><p>从Rust小助手的建议里我们看到了一个关键字：ref。</p><h3>ref 关键字</h3><p>Rustc AI小助手建议我们添加一个关键字ref，我们按它说的改改。</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct User {\n    name: String,\n    age: u32,\n    student: bool\n}\n\nfn main() {\n    let a = User {\n        name: String::from(\"mike\"),\n        age: 20,\n        student: false,\n    };\n    let User {\n        ref name,    // 这里加了一个ref\n        age,\n        student,\n    } = a;\n    \n    println!(\"{}\", name);\n    println!(\"{}\", age);\n    println!(\"{}\", student);\n    println!(\"{:?}\", a);\n}\n// 输出 \nmike\n20\nfalse\nUser { name: \"mike\", age: 20, student: false }\n</code></pre><p>可以看到，打印出了正确的值。</p><p>有些情况下，我们只是需要读取一下字段的值而已，不需要获得它的所有权，这时就可以通过 ref 这个关键字修饰符告诉Rust编译器，我现在只需要获得那个字段的引用，不要给我所有权。这就是 ref 出现的原因，用来<strong>在模式匹配过程中提供一个额外的信息</strong>。</p><p>使用了ref后，新定义的 name 变量的值其实是 &amp;a.name ，而不是 a.name，Rust就不会再把所有权给move出来了，因此也不会发生partially moved这种事情，原来的User实例a还有效，因此就能被打印出来了。你可以体会一下其中的区别。</p><p>相应的，还有 ref mut 的形式。它是用于在模式匹配中获得目标的可变引用。</p><pre><code class=\"language-plain\">let User {\n    ref mut name,    // 这里加了一个ref mut\n    age,\n    student,\n} = a;\n</code></pre><p>你可以做做实验体会一下。</p><p>Rust中强大的模式匹配这个概念并不是Rust原创的，它来自于函数式语言。你如果感兴趣的话，可以了解一下Ocaml、Haskell或Scala中模式匹配的相关概念。</p><h3>函数参数中的模式匹配</h3><p>函数参数其实就是定义局部变量，因此模式匹配的能力在这里也能得到体现。</p><p>示例1：</p><pre><code class=\"language-plain\">fn foo((a, b, c): (u32, u32, char)) {  // 注意这里的定义\n    println!(\"{}\", a);\n    println!(\"{}\", b);\n    println!(\"{}\", c);  \n}\n\nfn main() {\n    let a = (1,2, 'a');\n    foo(a); \n}\n</code></pre><p>上例，我们把元组a传入了函数 <code>foo()</code>，<code>foo()</code> 的参数直接定义成模式匹配，解析出了 a、b、c 三个元组元素的内容，并在函数中使用。</p><p>示例2：</p><pre><code class=\"language-plain\">#[derive(Debug)]\nstruct User {\n    name: String,\n    age: u32,\n    student: bool\n}\n\nfn foo(User {        // 注意这里的定义\n    name,\n    age,\n    student\n}: User) {\n    println!(\"{}\", name);\n    println!(\"{}\", age);\n    println!(\"{}\", student);  \n}\n\nfn main() {\n    let a = User {\n        name: String::from(\"mike\"),\n        age: 20,\n        student: false,\n    };\n    foo(a);\n}\n</code></pre><p>上例，我们把结构体a传入了函数 <code>foo()</code>，<code>foo()</code> 的参数直接定义成对结构体的模式匹配，解析出了 name、age、student 三个字段的内容，并在函数中使用。</p><h2>小结</h2><p>枚举是Rust中的重要概念，广泛用于属性配置、错误处理、分支流程、类型聚合等。在实际场景中，我们一般把结构体作为模型的主体承载，把枚举作为周边的辅助配置和逻辑分类。它们经常会搭配使用。</p><p>模式匹配是Rust里非常有特色的语言特性，我们在做分支逻辑处理的时候，可以通过模式匹配带上要处理的相关信息，还可以把这些信息解析出来，让代码的逻辑和数据内聚得更加紧密，让程序看起来更加赏心悦目。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/9b/ab7b1637e9f52a7dc4327db56f99e29b.jpg?wh=1458x1670\" alt=\"\"></p><h2>思考题</h2><p>match表达式的各个分支中，如果有不同的返回类型的情况，应该如何处理？欢迎你在评论区留下自己的答案，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p><h2>参考资料</h2><ul>\n<li>格式化参数：<a href=\"https://shimo.im/outlink/gray?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstd%2Ffmt%2Findex.html\">https://shimo.im/outlink/gray?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstd%2Ffmt%2Findex.html</a></li>\n<li>match的语法规则：<a href=\"https://doc.rust-lang.org/reference/expressions/match-expr.html\">https://doc.rust-lang.org/reference/expressions/match-expr.html</a></li>\n</ul>","neighbors":{"left":{"article_title":"05｜复合类型（上）：结构体与面向对象特性","id":720991},"right":{"article_title":"07｜类型与类型参数：给Rust小助手提供更多信息","id":722240}},"comments":[{"had_liked":false,"id":383346,"user_name":"古明地觉","can_delete":false,"product_type":"c1","uid":1528298,"ip_address":"中国台湾","ucode":"31DA063A17FC27","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/ea/d9a83bb3.jpg","comment_is_top":false,"comment_ctime":1698904833,"is_pvip":false,"replies":[{"id":139676,"content":"非常用心的思考。反过来回答：\n3. match的时候，rust做了自动解引用，就是自动加了*self。这点上Rust就是与C不同，Rust有点猜测程序员的意图的味道。比如看如下代码，也是类似做了自动解引用。\n```\nfn foo(a: &amp;u32, b: &amp;u32) {\n    if a &gt; b {\n        println!(&quot;111&quot;);\n    } else {\n        println!(&quot;222&quot;);\n    }\n}\n\nfn main() {\n    foo(&amp;5, &amp;4);\n}\n```\n2.  match枚举时，这里不存在对负载的匹配捕获，因此不存在“再赋值”的操作，只是比对一下，于是跟它是Copy的还是Move的就没关系了。\n1. 对，因为做了“再赋值”的操作。跟 Copy的还是Move的就有关系，所以就是你那样理解的。\n\nRust内部做了很多逻辑自洽的推理。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699003147,"ip_address":"重庆","comment_id":383346,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师，看到里面的一个例子，我产生了一些疑问。我先举个例子：\n```\nfn main() {\n    let s = String::from(&quot;Hello&quot;);\n    let p = &amp;s;\n    let s2 = *p;\n}\n```\n如果直接将 s 赋值给 s2，那么毫无疑问会发生移动，s 不再有效。但如果是对 s 的引用进行解引用，那么编译器会提示无法移动，这是啥原因呀。我自己有一个猜测，因为 Rust 默认不会深度拷贝数据，所以如果 let s2 = *p 这条语句成立，就意味着要夺走 s 的所有权。但我们之所以要获取引用，就是为了不夺走原有变量（s）的所有权，于是在这种情况下，Rust 干脆提示不允许我们移动，除非它实现了 Copy trait，数据全部在栈上，浅拷贝之后数据彼此独立。\n这样理解是正确的吗？Rust 的一些概念比较相似，容易出现混乱，所以想问问老师。\n\n基于上面这个例子，再来看看文中的一个例子。\n```\nenum MyEnum {\n    Add,\n    Subtract,\n}\n\nimpl MyEnum {\n    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {\n        &#47;&#47; 这里的 self 显然是枚举的某个变体的引用\n        &#47;&#47; 因为 MyEnum 没有实现 Copy trait，所以它和字符串一样，不能通过解引用赋值\n        &#47;&#47; let obj = *self; 这里是不合法的，由于不是可 Copy 的，因此无法移动\n        &#47;&#47; 但问题来了，为啥下面的代码是合法的，原文是 match self，但改成 match *self 也可以\n        match *self {\n            Self::Add =&gt; x + y,\n            Self::Subtract =&gt; x - y,\n        }\n    }\n}\n```\n因此这是我的第二个疑问，为啥 let obj = *self 不合法，但 match *self 就是合法的。\n\n还有第三个疑问，可能是受到 C 的影响，因为变量和指针是无法比较的。所以在看到 match self 的一瞬间，就忍不住试了一下 match *self，因为参数是 &amp;self，所以 self 是枚举变体的引用。而 Self::Add 和 Self::Subtract 是具体的枚举变体，它们之间比较总觉得有些别扭，还是 match *self 看着顺眼。所以想问一下老师，为啥这两者能够比较。\n\n以上就是我的一些疑问，还麻烦唐老师指导一下，Rust 的一些概念有点让人头晕。","like_count":12,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630883,"discussion_content":"非常用心的思考。反过来回答：\n3. match的时候，rust做了自动解引用，就是自动加了*self。这点上Rust就是与C不同，Rust有点猜测程序员的意图的味道。比如看如下代码，也是类似做了自动解引用。\n```\nfn foo(a: &amp;u32, b: &amp;u32) {\n    if a &gt; b {\n        println!(&#34;111&#34;);\n    } else {\n        println!(&#34;222&#34;);\n    }\n}\n\nfn main() {\n    foo(&amp;5, &amp;4);\n}\n```\n2.  match枚举时，这里不存在对负载的匹配捕获，因此不存在“再赋值”的操作，只是比对一下，于是跟它是Copy的还是Move的就没关系了。\n1. 对，因为做了“再赋值”的操作。跟 Copy的还是Move的就有关系，所以就是你那样理解的。\n\nRust内部做了很多逻辑自洽的推理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1699003147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1979955,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/36/33/3411df0d.jpg","nickname":"seven9t","note":"","ucode":"B7CA7D62C56938","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635102,"discussion_content":"按字面意思来理解就好了，东西你既然是&#39;借用&#39;的当然无法&#39;赠与&#39;别人。所有这类底层逻辑是如果允许这么做了，会有什么风险，比如这里就是可能导致多个owner，重复释放啥的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704420956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383619,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1699358148,"is_pvip":false,"replies":[{"id":139812,"content":"非常棒的叙述，思路极其清晰。👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699412151,"ip_address":"重庆","comment_id":383619,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"作为静态类型语言，match 返回的类型必须在编译期就被确定，也就意味着 match 必须返回相同的类型。在这个前提下，如果要返回的类型，那么切入点就只能是：“返回同一个类型，但是这个类型能表示（承载）不同的类型”，那就只能是本节课将的枚举 enum 了。\n```rust\nenum Number {\n    Int(i32),\n    Float(f64),\n    None\n}\n\nfn get_number(condition: i32) -&gt; Number {\n    match condition {\n        1 =&gt; Number::Int(10),\n        2 =&gt; Number::Float(3.14),\n        _ =&gt; Number::None\n    }\n}\n\nfn main() {\n    let value = get_number(1);\n    match value {\n        Number::Int(i) =&gt; println!(&quot;int {}&quot;, i),\n        Number::Float(f) =&gt; println!(&quot;float {}&quot;, f),\n        Number::None =&gt; println!(&quot;not number&quot;),\n    }\n\n    let value = get_number(2);\n    match value {\n        Number::Int(i) =&gt; println!(&quot;int {}&quot;, i),\n        Number::Float(f) =&gt; println!(&quot;float {}&quot;, f),\n        Number::None =&gt; println!(&quot;not number&quot;),\n    }\n\n    let value = get_number(3);\n    match value {\n        Number::Int(i) =&gt; println!(&quot;int {}&quot;, i),\n        Number::Float(f) =&gt; println!(&quot;float {}&quot;, f),\n        Number::None =&gt; println!(&quot;not number&quot;),\n    }\n}\n\n```","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631224,"discussion_content":"非常棒的叙述，思路极其清晰。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699412152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481979,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/fb/7fe6df5b.jpg","nickname":"陈卧虫","note":"","ucode":"44BB84712436AB","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654285,"discussion_content":"写的真好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732331624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383287,"user_name":"一个人旅行","can_delete":false,"product_type":"c1","uid":2555864,"ip_address":"北京","ucode":"A708238B10B44B","user_header":"https://static001.geekbang.org/account/avatar/00/26/ff/d8/d48d6088.jpg","comment_is_top":false,"comment_ctime":1698818583,"is_pvip":false,"replies":[{"id":139635,"content":"可以的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698847017,"ip_address":"重庆","comment_id":383287,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"1.  默认情况下，struct不能进行比较，需要为Shape类型实现PartialEq trait特征。\n2.  方式一：使用枚举，该枚举类型的枚举值表示一个类型。\n     方式二：使用特征，所有的类型都需要实现该特征\n","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630757,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698847017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383304,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"湖北","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1698831565,"is_pvip":false,"replies":[{"id":139651,"content":"对，包，解包还是有点麻烦","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698893085,"ip_address":"重庆","comment_id":383304,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题：\npub enum Result&lt;T1,T2&gt;{\n    V1(T1),\n    V2(T2)\n}\n\nfn get_diff_value(number:i32) -&gt; Result&lt;i32,i32&gt;{\n   let r = match number {\n       1 =&gt; Result::V1(1),\n       _ =&gt; Result::V2(2)\n   };\n   r\n}\n\nfn main(){\n    let r  = get_diff_value(0);\n    match r {\n        Result::V1(x) =&gt; println!(&quot;V1={x}&quot;),\n        Result::V2(x) =&gt; println!(&quot;V2={x}&quot;)\n    }\n}\n\n聚合的代价是不是需要解聚合。。。。","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630791,"discussion_content":"对，包，解包还是有点麻烦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698893085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1765926,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLO6XvxfFPMGcVSSX8uIZY2yib29qlyat178pU4QM3gIic5GXZ8PC0tzRiazP3FiajXbTj19SE4ZhV0gQ/132","nickname":"PEtFiSh","note":"","ucode":"C4922398A92E05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630927,"discussion_content":"跟着问一个， 解包的步骤，是不是可以impl成枚举的一个方法，这样写起来是否合理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699070053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383573,"user_name":"水不要鱼","can_delete":false,"product_type":"c1","uid":2699481,"ip_address":"广东","ucode":"40F9B2BA2DD9C7","user_header":"https://static001.geekbang.org/account/avatar/00/29/30/d9/323ba366.jpg","comment_is_top":false,"comment_ctime":1699281317,"is_pvip":false,"replies":[{"id":139817,"content":"直接给的引用出来，没有再创建一份新实例。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699412216,"ip_address":"重庆","comment_id":383573,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师，我有个问题，那个 ref name 那里是不是等于 &amp;name，如果是的话，那不是相当于把一个 &amp;String 赋值给了 String 么，还是说 rust 会自动用 &amp;String 再去创建一个 String 然后给 name","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631229,"discussion_content":"直接给的引用出来，没有再创建一份新实例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699412216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383333,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"中国香港","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1698888270,"is_pvip":false,"replies":[{"id":139645,"content":"就是要得到引用才引入的ref","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698892846,"ip_address":"重庆","comment_id":383333,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"上面的 ref 章节中，User.name 是 String 类型，为什么可以通过ref给它赋值 a.name 的引用","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630784,"discussion_content":"就是要得到引用才引入的ref","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698892846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1118976,"avatar":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","nickname":"Michael","note":"","ucode":"35F4FFAC4A4B15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630793,"discussion_content":"我感觉类型不匹配啊，User.name 是 String类型，通过ref得到的是不是 &amp;String 类型","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1698893243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":630784,"ip_address":"上海","group_id":0},"score":630793,"extra":""}]}]},{"had_liked":false,"id":383299,"user_name":"plh","can_delete":false,"product_type":"c1","uid":1031828,"ip_address":"四川","ucode":"D79F2B87AC3AD2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erEHTaQDkWqEYib9iabib8rACYpSFBHTPFmgicUKaib79MB6VIxNwiajHUS8kYFEKCGOjpibf0dibhIjqhfzg/132","comment_is_top":false,"comment_ctime":1698829674,"is_pvip":false,"replies":[{"id":139644,"content":"对的，一个AI人类。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698892809,"ip_address":"重庆","comment_id":383299,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"这一节 就值回票价了.   \n文中: [Rustc 小助手如此贴心，这种保姆级服务是你在 Java、C++ 等其他语言中感受不到的。] \n个人感觉, Rustc 也像 大师样的,在编写代码的时候, 在人身边不厌其烦的指出潜在的问题,直到 编译成功.","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630783,"discussion_content":"对的，一个AI人类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698892809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383280,"user_name":"Taozi","can_delete":false,"product_type":"c1","uid":1021926,"ip_address":"上海","ucode":"DD6567A31B3E33","user_header":"","comment_is_top":false,"comment_ctime":1698812552,"is_pvip":false,"replies":[{"id":139630,"content":"1. 可以这样理解。但要注意，enum中的选项名称本身是 变体，variant，不是struct name；\n2。对的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698821483,"ip_address":"重庆","comment_id":383280,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"1. enum变体可以挂载的类型是否就是对应了结构体的三种形态：单元结构体、元组结构体和命名结构体。\n2. match表达式不同的返回类型可以使用enum进行聚合。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630734,"discussion_content":"1. 可以这样理解。但要注意，enum中的选项名称本身是 变体，variant，不是struct name；\n2。对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698821484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383278,"user_name":"付佳伟","can_delete":false,"product_type":"c1","uid":3541041,"ip_address":"北京","ucode":"9054B858B17293","user_header":"https://static001.geekbang.org/account/avatar/00/36/08/31/080b4a86.jpg","comment_is_top":false,"comment_ctime":1698809385,"is_pvip":false,"replies":[{"id":139632,"content":"你说这个方案后面会讲到。其它方案见其它同学说的有。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698821558,"ip_address":"重庆","comment_id":383278,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题：match各个分支返回值类型不同时，可以将各个类型实现同一个trait ，然后用Box将返回值包裹，返回值类型定义Box&lt;dyn trait&gt;。不知道还有没有其他办法","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630736,"discussion_content":"你说这个方案后面会讲到。其它方案见其它同学说的有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698821558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388069,"user_name":"fandream","can_delete":false,"product_type":"c1","uid":3697081,"ip_address":"浙江","ucode":"C2A18E7AEC5F6B","user_header":"https://static001.geekbang.org/account/avatar/00/38/69/b9/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1709278204,"is_pvip":false,"replies":[{"id":141756,"content":"这个探索很棒呀！这个示例说明Rust并不会去分析实例具体的值是什么，而只是在类型&#47;结构上做分析。所以才会出现这样的情况。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1713029011,"ip_address":"加拿大","comment_id":388069,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师， 关于match匹配有个疑问？\n```\n#[derive(Debug)]\nenum MyEnum {\n    Add,\n    Subtract,\n}\nfn main() {\n    let a = MyEnum::Add;\n\n    match a {\n        MyEnum::Add =&gt; println!(&quot;a&quot;),\n        MyEnum::Subtract =&gt; println!(&quot;b&quot;),\n    };\n    println!(&quot;a = {:?}&quot;, a);\n}\n```\n上面这种情况时，没有发生move，a还是可以使用\n但是如果给枚举添加了带有会移动的负载时，情况就不一样了，\n```\nfn main() {\n    let a = MyEnum::Add;\n\n    match a {\n        MyEnum::Add =&gt; println!(&quot;a&quot;),\n        MyEnum::Subtract =&gt; println!(&quot;b&quot;),\n        MyEnum::Mix(val) =&gt; println!(&quot;val = {val}&quot;),\n    };\n    println!(&quot;a = {:?}&quot;, a);\n}\n\n#[derive(Debug)]\nenum MyEnum {\n    Add,\n    Subtract,\n    Mix(String),\n}\n```\n这个带有负载的枚举发生了部分移动。\n这个是什么原因？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641838,"discussion_content":"这个探索很棒呀！这个示例说明Rust并不会去分析实例具体的值是什么，而只是在类型/结构上做分析。所以才会出现这样的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713029011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386970,"user_name":"RobinH","can_delete":false,"product_type":"c1","uid":1764303,"ip_address":"美国","ucode":"4D74D32C8D1FB8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/eb/cf/8fa3dd5a.jpg","comment_is_top":false,"comment_ctime":1706028457,"is_pvip":false,"replies":[{"id":141082,"content":"枚举自己就能强行聚合各种类型的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1706062457,"ip_address":"重庆","comment_id":386970,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"#[derive(Debug)]\nenum Type&lt;T&gt; {\n    A(T),\n    B(T),\n}\n\nfn match_type&lt;T&gt;(t1: Type&lt;T&gt;) -&gt; T {\n    let temp = match t1 {\n        Type::A(a) =&gt; {\n            a\n        }\n        Type::B(b) =&gt; {\n            b\n        }\n    };\n    return temp;\n}\n\n思考题 我尝试理解下了下 ，是想考 泛型么？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636386,"discussion_content":"枚举自己就能强行聚合各种类型的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706062457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386089,"user_name":"HdUIprince","can_delete":false,"product_type":"c1","uid":1262168,"ip_address":"湖北","ucode":"2510EBFACDBDB2","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/58/2286eca6.jpg","comment_is_top":false,"comment_ctime":1704047276,"is_pvip":false,"replies":[{"id":140725,"content":"https:&#47;&#47;doc.rust-lang.org&#47;std&#47;fmt&#47;index.html  这个,对的吧?","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704170652,"ip_address":"重庆","comment_id":386089,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"老师参考资料中的格式化参数的链接不太对？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634874,"discussion_content":"https://doc.rust-lang.org/std/fmt/index.html  这个,对的吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704170652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385648,"user_name":"tan","can_delete":false,"product_type":"c1","uid":1477463,"ip_address":"重庆","ucode":"20E176CB1EFD51","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/57/a3daeaae.jpg","comment_is_top":false,"comment_ctime":1703041490,"is_pvip":false,"replies":[{"id":140552,"content":"对的，Rust的枚举就是个多啦A梦的口袋。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703122373,"ip_address":"重庆","comment_id":385648,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"比java的枚举强大太多了","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634227,"discussion_content":"对的，Rust的枚举就是个多啦A梦的口袋。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703122373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385345,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702463716,"is_pvip":false,"replies":[{"id":140451,"content":"函数的返回值类型需要怎么写呢？","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702609453,"ip_address":"重庆","comment_id":385345,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"没太明白思考题， 返回类型不同执行不同逻辑呗","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633768,"discussion_content":"函数的返回值类型需要怎么写呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702609453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":2,"child_discussions":[{"author":{"id":3623568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","nickname":"superggn","note":"","ucode":"831CCD98B393FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":633780,"discussion_content":"类型不同正常写啊\nmatch some_value {\n    A =&gt; {do something compatible with type A}\n    B =&gt; {do something compatible with type B}\n}\n因为我觉得这俩 do something 默认就是定制化的， 返回类型不同是一件很正常的事情， 所以我没太明白嘛意思， \n\n思考题是不是说不同类型尽量别放到一个不能兼容多种类型的 _ pattern 里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702617579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":633768,"ip_address":"北京","group_id":0},"score":633780,"extra":""},{"author":{"id":3623568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","nickname":"superggn","note":"","ucode":"831CCD98B393FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":633829,"discussion_content":"啊我大概明白啥意思了， 是不是说因为 match 所有分支返回值必须一致， 所以要把不同类型的值归一化一下子？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702632064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":633768,"ip_address":"北京","group_id":0},"score":633829,"extra":""}]}]},{"had_liked":false,"id":385146,"user_name":"Joe Black","can_delete":false,"product_type":"c1","uid":1052528,"ip_address":"山东","ucode":"21FE222A286445","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/70/cdef7a3d.jpg","comment_is_top":false,"comment_ctime":1702197758,"is_pvip":false,"replies":[{"id":140395,"content":"对。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702251955,"ip_address":"重庆","comment_id":385146,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"Rust枚举其实更像C++ boost库中的variant","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633479,"discussion_content":"对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702251955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383931,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"湖北","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1699960516,"is_pvip":false,"replies":[{"id":140094,"content":"写的只接受isize 😢","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700015182,"ip_address":"重庆","comment_id":383931,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"老师，请教下，为啥这种不行呢？难道C风格枚举初始化只能用固定长度的？\n\nenum HttpResultCode {\n    Ok = &quot;200&quot;,\n    NotFound = &quot;404&quot;,\n    Teapot = &quot;418&quot;,\n}\n\n2 |     Ok = &quot;200&quot;,\n  |          ^^^^^ expected `isize`, found `&amp;str`\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631828,"discussion_content":"写的只接受isize 😢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700015182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1008315,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","nickname":"下雨天","note":"","ucode":"816B3792ECC50A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":631838,"discussion_content":"额…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700021317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":631828,"ip_address":"湖北","group_id":0},"score":631838,"extra":""}]},{"author":{"id":3538056,"avatar":"https://static001.geekbang.org/account/avatar/00/35/fc/88/7cafa477.jpg","nickname":"叫我最右君","note":"","ucode":"1D43690BDC5D5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635211,"discussion_content":"Rust里没有C风格的枚举初始化方式吧，这样写类型就是Rust的&amp;String，想要裸指针得应该是unsafe里才能用吧🤔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704549805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383629,"user_name":"Geek_bc2516","can_delete":false,"product_type":"c1","uid":2707349,"ip_address":"浙江","ucode":"D21822498443BE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Kn4AtheuVQXREBkibJHuALzon1HhtkCquYyelQaTAvneM2vREae0CxicsxAyLIxKVp1GmVbYRmKlDAumE8ZsNmVw/132","comment_is_top":false,"comment_ctime":1699370214,"is_pvip":false,"replies":[{"id":139815,"content":"对的。比js强多啦。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699412182,"ip_address":"重庆","comment_id":383629,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"这个匹配好像js中的解构赋值","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631227,"discussion_content":"对的。比js强多啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699412182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383449,"user_name":"不忘初心","can_delete":false,"product_type":"c1","uid":3737491,"ip_address":"上海","ucode":"8262D42405F4E2","user_header":"https://static001.geekbang.org/account/avatar/00/39/07/93/710c7ee2.jpg","comment_is_top":false,"comment_ctime":1699074484,"is_pvip":false,"replies":[{"id":139730,"content":"任何类型？你现在用的是序列化的方式，挺好的。更有技巧的是Any之类的，但是我不推荐。失去了rust的优势了。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699191412,"ip_address":"重庆","comment_id":383449,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"老师, 请教个问题.\n我需要在同一个HashMap里放任何类型的数据(如: i32,i64, String, HashMap). 目前是这样定义的:\nlet mut map: HashMap&lt;&amp;str, Box&lt;dyn erased_serde::Serialize&gt;&gt; = HashMap::new();\n还有更好的方式吗?","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630985,"discussion_content":"任何类型？你现在用的是序列化的方式，挺好的。更有技巧的是Any之类的，但是我不推荐。失去了rust的优势了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699191412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383344,"user_name":"古明地觉","can_delete":false,"product_type":"c1","uid":1528298,"ip_address":"中国台湾","ucode":"31DA063A17FC27","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/ea/d9a83bb3.jpg","comment_is_top":false,"comment_ctime":1698903258,"is_pvip":false,"replies":[{"id":139659,"content":"不错的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698939842,"ip_address":"重庆","comment_id":383344,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"思考题：最简单的做法就是使用枚举，比如处理 Excel，由于 Excel 的每个单元格（Cell）都可能是不同的类型，在 Go 里面读出来可以是一个 interface，但在 Rust 中读出来可以是一个枚举。\nenum Cell {\n    Integer(i32),\n    Float(f32),\n    String(text)\n}\n对每个单元格 match 一下，不同类型的值，执行不同的逻辑即可。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630835,"discussion_content":"不错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698939843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383332,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"中国香港","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1698887166,"is_pvip":false,"replies":[{"id":139646,"content":"细节🉑️就太多了，我后面单独开文章补充哈。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698892895,"ip_address":"重庆","comment_id":383332,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"还有一个 @ 绑定符号，老师补充讲讲呗","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630785,"discussion_content":"细节🉑️就太多了，我后面单独开文章补充哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698892895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118976,"avatar":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","nickname":"Michael","note":"","ucode":"35F4FFAC4A4B15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630794,"discussion_content":"嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698893678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383330,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"湖北","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1698882837,"is_pvip":false,"replies":[{"id":139647,"content":"对，有点。其实还好，反正你少✍️了一个括号，小助手会提醒你的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698892944,"ip_address":"重庆","comment_id":383330,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"枚举中定义元组结构体与元组，这两种写法上有点傻傻分不清楚","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630786,"discussion_content":"对，有点。其实还好，反正你少✍️了一个括号，小助手会提醒你的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698892944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383301,"user_name":"Geek_6fjt20","can_delete":false,"product_type":"c1","uid":1672482,"ip_address":"北京","ucode":"B7EB9B061E2C06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrbHib1v0wPRVHxrFK2CPQQX8Wg3rRMPiaZ5teMKu5klT48yns6yo4krZsIqHskwdEsibVvQ3QB7CUQ/132","comment_is_top":false,"comment_ctime":1698831031,"is_pvip":false,"replies":[{"id":139652,"content":"可以的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698893093,"ip_address":"重庆","comment_id":383301,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"如果返回不同类型，可以用Box&lt;dyn Xxx&gt;","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630792,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698893093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383277,"user_name":"不忘初心","can_delete":false,"product_type":"c1","uid":3737491,"ip_address":"上海","ucode":"8262D42405F4E2","user_header":"https://static001.geekbang.org/account/avatar/00/39/07/93/710c7ee2.jpg","comment_is_top":false,"comment_ctime":1698805846,"is_pvip":false,"replies":[{"id":139631,"content":"1好，2一般不会那样用。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698821509,"ip_address":"重庆","comment_id":383277,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"思考题: \n    第一种方案: 把不同类型封装在枚举中, 返回枚举.\n    第二种方案: 返回Box&lt;dyn Any&gt;.","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630735,"discussion_content":"1好，2一般不会那样用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698821510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383265,"user_name":"c","can_delete":false,"product_type":"c1","uid":1199438,"ip_address":"北京","ucode":"E1E383485EBF77","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/4e/5a20fe28.jpg","comment_is_top":false,"comment_ctime":1698794380,"is_pvip":false,"replies":[{"id":139622,"content":"沙发","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698806527,"ip_address":"重庆","comment_id":383265,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"一楼","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630710,"discussion_content":"沙发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698806527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383264,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1698794281,"is_pvip":false,"replies":[{"id":139621,"content":"确实牛👍，你起得真早。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1698806517,"ip_address":"重庆","comment_id":383264,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"打卡，模式匹配太牛了，结合了多种语言，还有析构功能","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630709,"discussion_content":"确实牛👍，你起得真早。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698806518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395856,"user_name":"坤","can_delete":false,"product_type":"c1","uid":1585570,"ip_address":"浙江","ucode":"AD2B2D6A4E5CBF","user_header":"https://static001.geekbang.org/account/avatar/00/18/31/a2/16c3318d.jpg","comment_is_top":false,"comment_ctime":1732264819,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"1. 添加ref那个,可以引用a对象,let ... = &amp;a; 这样是否等价于 ref name;\n2. fn foo(User { &#47;&#47; 注意这里的定义 name, age, student}: User) 对于这种函数定义,如果结构体增减字段,所有这样定义的地方都要跟着修改,算是一个弊端吧\n","like_count":0},{"had_liked":false,"id":390669,"user_name":"安石","can_delete":false,"product_type":"c1","uid":1508755,"ip_address":"浙江","ucode":"185AD0046CF1C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/05/93/3c3f2a6d.jpg","comment_is_top":false,"comment_ctime":1715925759,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"问个问题：\n我用rust写的一个http server\n```\n#[macro_use] extern crate rocket;\n\n#[get(&quot;&#47;hello&quot;)]\nfn hello() -&gt; &amp;&#39;static str {\n    &quot;Hello, world!&quot;\n}\n\n#[launch]\nfn rocket() -&gt; _ {\n    rocket::build().mount(&quot;&#47;&quot;, routes![hello])\n}\n```\n和用nodejs写的http server\n```\nconst Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\n&#47;&#47; 响应中间件\napp.use(ctx =&gt; {\n    ctx.body = &#39;Hello World&#39;;\n});\n\n&#47;&#47; 启动服务器\nconst PORT = 3000;\napp.listen(PORT, () =&gt; {\n    console.log(`Server is running on http:&#47;&#47;localhost:${PORT}`);\n});\n\n\n```\n使用autocannon测试\n为什么nodejs的性能要好于rust ,是我使用的姿势不对吗\n测试参数 10w次请求，并发1w","like_count":0},{"had_liked":false,"id":387473,"user_name":"冷石","can_delete":false,"product_type":"c1","uid":1523432,"ip_address":"广东","ucode":"2A2B056A83E963","user_header":"https://static001.geekbang.org/account/avatar/00/17/3e/e8/3736f3cd.jpg","comment_is_top":false,"comment_ctime":1707452438,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"666","like_count":0},{"had_liked":false,"id":383770,"user_name":"kylin","can_delete":false,"product_type":"c1","uid":1351248,"ip_address":"吉林","ucode":"3588B62A4F9534","user_header":"https://static001.geekbang.org/account/avatar/00/14/9e/50/21e0beca.jpg","comment_is_top":false,"comment_ctime":1699599606,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"结构体的三种形态：单元结构体、元组结构体和命名结构体","like_count":0},{"had_liked":false,"id":383298,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1698827135,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"没有Go传参中的复制，而是所有权的部分转移","like_count":0,"discussions":[{"author":{"id":1301143,"avatar":"https://static001.geekbang.org/account/avatar/00/13/da/97/e421b1ae.jpg","nickname":"周鹏","note":"","ucode":"3BDD7C9785AEC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639302,"discussion_content":"struct Rectangle {\n    width: u32, \n    height: u32\n}\n\nenum Shape {\n    Rectangle(Rectangle),\n    Triangle((u32, u32), (u32, u32), (u32, u32)),\n    Circle { origin: (u32, u32), radius: u32 },\n}\n\nfn main() {\n    let a_rec = Rectangle {\n        width: 10,\n        height: 20,\n    };\n  \n    // 请打开下面这一行进行实验\n    //let shape_a = Shape::Rectangle(a_rec);\n    // 请打开下面这一行进行实验\n    //let shape_a = Shape::Triangle((0, 1), (3,4), (3, 0));\n    \n    let shape_a = Shape::Circle { origin: (0, 0), radius: 5 };\n    \n    // 这里演示了在模式匹配中将枚举的负载解出来的各种形式\n    match shape_a {\n        Shape::Rectangle(a_rec) =&gt; {  // 解出一个结构体\n            println!(&#34;Rectangle {}, {}&#34;, a_rec.width, a_rec.height);\n        }\n        Shape::Triangle(x, y, z) =&gt; {  // 解出一个元组\n            println!(&#34;Triangle {:?}, {:?}, {:?}&#34;, x, y, z);\n        }\n        Shape::Circle {origin, radius} =&gt; {  // 解出一个结构体的字段\n            println!(&#34;Circle {:?}, {:?}&#34;, origin, radius);\n        }\n    }\n}\n// 输出\nCircle (0, 0), 5\n最上面的Triangle应该加上#[derive(Debug)]避免编译错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710472104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}