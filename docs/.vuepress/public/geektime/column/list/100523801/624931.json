{"id":624931,"title":"08｜Coroutines：“零”开销降低异步编程复杂度","content":"<p>你好，我是卢誉声。</p><p>在上一讲中，我们看到在传统的C++异步方案中，想要实现高效易用的异步方案是非常困难的。好消息是从C++20开始，提供了一个全新的解决异步问题（特别是异步I/O）的方案——那就是协程。</p><p>协程提供了泛化的协作式多任务模型，在并发计算和高性能I/O领域有着广泛的应用，相较于多线程或多进程运行时来说，可以实现几乎“零”开销的代码调度。虽说如此，协程并不是一个新概念，早在1958年Melvin E. Conway就提出这一概念，早期的C++也支持基于协程的任务模型编程。</p><p>但是，早期C++对协程的支持简陋且不可移植。与此同时，协程在设计上相较于规范函数调用来说更加泛化，因此针对C++的标准化协程方案很难得到一致认可。经过几十年的探索和努力，C++20及其后续演进中终于回归了标准化协程（C++ coroutines）。</p><p>由于以往的协程都被编写在非常底层的实现上，因此常见的应用系统上很少使用它。</p><p>但这次标准化让它重回大众视野，也启发了我们用另一种思维模式来解决高性能计算问题——通过协程，就能在几乎零性能开销的情况下，大幅降低异步编程复杂度。甚至可以说，<strong>标准化协程促使C++20成长为全新的编程模型</strong>，让我们用现代C++解决工程问题时更加游刃有余。</p><!-- [[[read_end]]] --><p>这是一次令人激动的C++标准化核心语言特性推进。今天，就让我们从定义C++协程开始讲起（课程配套代码，点击<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>即可获取）。</p><h2>定义C++协程</h2><p>现代C++20标准下的协程，<strong>是一种可休眠、可恢复、不基于栈实现的函数</strong>。为了方便起见，后续提到的“协程”均特指C++20及其后续演进标准中的协程。</p><p>协程相较于函数来说是一个更加泛化的概念。函数只有“调用”和“返回”两个行为，而协程在这一基础上进行了扩展，增加了“休眠”和“恢复”。<br>\n<img src=\"https://static001.geekbang.org/resource/image/40/98/40d5f8cbec470610713aa2ff94792298.jpg?wh=2600x1285\" alt=\"\"></p><p>与此同时，协程这一核心语言特性不会定义协程的语义，库开发者需要根据一定的规则实现所需的接口约定，包括后面这些约定。</p><ol>\n<li>调用者的传参方式。</li>\n<li>将值返回给调用者的方式。</li>\n<li>休眠与恢复执行的规则。</li>\n<li>异常处理方式。</li>\n</ol><p>由于C++协程属于无栈协程，因此C++并没有提供标准调度器，开发者必须在定义上述接口后，基于C++提供的关键字在协程调用函数中手动处理协程的调度。</p><p>协程的泛化特性在这里进一步展现，编译器在生成协程代码时，会调用库开发者定义的行为——即实现好的、标准的接口规定。</p><h2>协程的执行</h2><p>在掌握了协程的基本定义后，我们发现协程可以被认作是一种函数的扩展或泛化。为了帮你进一步理解协程的工作机制，让我们来看看协程在运行时的行为和生命周期管理。</p><p>前面说过，相较于函数，协程是一种可休眠、可恢复、不基于栈实现的函数。因此，它的生命周期管理自然与普通函数不同。也可以预见，C++中的协程是基于堆来实现的。下图展示了协程与函数交互的过程。<br>\n<img src=\"https://static001.geekbang.org/resource/image/cc/61/cc47d3703ffb92860743f77641463a61.jpg?wh=2600x1696\" alt=\"\"></p><p>我们根据图中的序号逐一解释每个过程。</p><ol>\n<li>调用函数在堆上创建协程帧（coroutine frame），用于存储协程的各类数据。协程帧的结构属于内存模型，因此不同编译器可能会有不同实现。</li>\n<li>调用被调协程，开始执行协程代码。</li>\n<li>被调协程执行到某个特定点，通过co_await/co_yield将当前协程休眠，线程1恢复自身原本的执行流程继续执行剩余代码。co_await与co_yield将在下一节中讲解。</li>\n<li>线程2通过协程句柄coroutine_handle的恢复函数resume恢复协程执行。</li>\n<li>协程在线程2上恢复执行，继续向下执行，直到协程执行结束为止。结束后回到线程2的原本执行流程继续执行代码。</li>\n<li>最后，线程2负责通过协程句柄coroutine_handle销毁协程帧。</li>\n</ol><p>同时，C++中的协程并不会像函数调用那样在栈上执行，它的状态储存在堆上。因此，我们只能在函数调用过程中，通过协程句柄coroutine_handle改变“部分”协程的状态——恢复或销毁。</p><h2>Promise</h2><p>在讲解协程的执行时，我忽略了一些细节。C++的协程要求开发者实现大量接口约定，而我们很难通过阅读标准文档来编写实际的代码，所以我们有必要学习一下实现接口约定的实践方法，这对我们在C++里熟练应用协程非常重要。</p><p>实践里，有两个重要的用户自定义类型Promise和Awaitable。我们先来看看Promise。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7f/7a/7f872af04d4a6fc947cd17ece4c3387a.jpg?wh=1990x612\" alt=\"\"></p><p>Promise其实是异步编程领域（比如JavaScript）中常见的概念和关键字，它用于描述一个未知值的闭包，闭包在C++中以对象的形式体现。我们可以通过Promise对象提供一个值，而这个值会在未来某个时候计算得出。<br>\n<img src=\"https://static001.geekbang.org/resource/image/e9/5c/e9d0b8cd08ff6acf2b7ebf0fbfa0065c.jpg?wh=2600x1588\" alt=\"\"><br>\n如上图所示，生成器Generator用来控制协程，包括协程调用、返回值的操作、co_await/co_yield的具体行为以及promise_type的具体定义。那么，这些接口约定该如何实现呢？</p><p>我们要从coroutine_traits这一concept开始说起。标准中提供的代码如下。</p><pre><code class=\"language-c++\">template&lt;class, class...&gt;\nstruct coroutine_traits {};\n \ntemplate&lt;class R, class... Args&gt;\nrequires requires { typename R::promise_type; }\nstruct coroutine_traits&lt;R, Args...&gt; {\n  using promise_type = typename R::promise_type;\n};\n</code></pre><p>从这段代码我们可以看出，实际编程代码中特化的coroutine_traits必须定义一个公有的promise_type成员（见代码第7行）。否则，这就不是一个有效的协程类且属于未定义行为。也就是说，编译器会查找协程类中的promise_type作为Promise，若promise_type不存在，就会发生编译时报错。</p><p>与此同时，一个协程类需要包含三个成员，分别是promise_type、coroutine_handle和coroutine_state。</p><p><strong>promise_type</strong> 在协程内操作时使用，它必须满足一定规则的类型，包含一系列约束的函数来支持休眠和恢复等功能，包括提交协程的返回值、提交协程异常。通常来说，编译器会通过promise_type的具体实现来判断协程是否合法。</p><p><strong>coroutine_handle</strong> 在协程外部操作时使用，可供调用者使用来休眠协程。它的类型是标准库提供的模板类，封装了协程帧的指针以及恢复、销毁协程帧的接口。</p><p><strong>coroutine_state</strong> 用于支持协程的生命周期，是运行时分配在堆（如果开启了编译器优化选项，则有可能会被优化使用寄存器）上的对象，目的是进一步规范说明协程执行时在堆上创建的数据，包括以下内容。</p><ul>\n<li>promise对象</li>\n<li>参数（在协程创建时，会拷贝所有函数参数进入协程帧）</li>\n<li>当前休眠的状态（在运行时，供后续恢复或销毁协程帧使用）</li>\n<li>局部变量（在运行时，供协程帧使用）</li>\n<li>临时变量（在运行时，供协程帧使用，它的生命周期是整个协程帧的生命周期）</li>\n</ul><p><strong>coroutine_state</strong> 参数还可以细分成这两种情况。</p><ul>\n<li>值类型的参数会被移动或拷贝。</li>\n<li>引用类型的参数会拷贝引用，当被引用的内存被释放了，那么协程状态中的引用会变成一个野引用。</li>\n</ul><p>这三个成员里，coroutine_state是比较特殊的抽象，是支持协程运行时的。但是，我们需要进一步了解promise_type和coroutine_handle的接口约定，并在编写协程时实现它们。</p><h3>promise_type</h3><p>对于promise_type，它是实现协程的最关键一环。开发者需要自己来实现它，代码如下所示。</p><pre><code class=\"language-c++\">template&lt;typename T&gt;\nstruct promise;\n\ntemplate&lt;typename T&gt;\nstruct Generator : std::coroutine_handle&lt;promise&lt;T&gt;&gt; {\n  using promise_type = promise&lt;T&gt;;\n};\n\ntemplate&lt;typename T&gt;\nstruct promise {\n  T _value; // 待计算的值\n  std::exception_ptr _exception; // 待抛出的异常\n\n  template&lt;typename Ty&gt;\n  promise(Ty&amp;&amp; lambdaObj, T value) : _value(value) {}\n  promise(T value) : _value(value) {}\n  promise() {}\n\n  Generator&lt;T&gt; get_return_object() { return { Generator&lt;T&gt;::from_promise(*this) }; }\n  std::suspend_always initial_suspend() noexcept { return {}; }\n  std::suspend_always final_suspend() noexcept { return {}; }\n  // optional，但co_yield需要这一函数实现\n  std::suspend_always yield_value(T value) {\n      _value = value;\n      return {};\n  }\n  // optional，但co_return需要这一函数实现或return_void\n  std::suspend_always return_value(T value) {\n      _value = value;\n      return {};\n  }\n  void return_void() {}\n  void unhandled_exception() { _exception = std::current_exception(); }\n};\n</code></pre><p>关键部分我已经在代码里做了注释，你可以仔细体会一下。</p><p>此外，我用下图总结了协程生命周期内，这些接口的一般调用顺序，供你参考使用。<br>\n<img src=\"https://static001.geekbang.org/resource/image/e2/45/e2be01ae94ba05e6c5090922ed105b45.jpg?wh=2600x1588\" alt=\"\"></p><h3>coroutine_handle</h3><p>在了解了promise_type的结构后，我们再来看看标准库提供的coroutine_handle这一模版类的定义。在编写协程代码的过程中，我们需要依据这一接口约定来实现。</p><p>标准中提供的代码如下。我加了一些注释帮助你理解。</p><pre><code class=\"language-c++\">template&lt;class Promise&gt;\nstruct coroutine_handle {\n  // 构造函数和赋值函数\n  constexpr coroutine_handle() noexcept;\n  constexpr coroutine_handle(nullptr_t) noexcept;\n  static coroutine_handle from_promise(Promise&amp;);\n  coroutine_handle&amp; operator=(nullptr_t) noexcept;\n\n  // 导入和导出\n  constexpr void* address() const noexcept; // 获取coroutine_handle内部数据的指针\n  static constexpr coroutine_handle from_address(void* addr); // 将内部数据指针转换为对应的coroutine_handle对象，会创建一个新对象\n\n  // 转换函数\n  constexpr operator coroutine_handle&lt;void&gt;() const noexcept;\n\n  // 查询协程状态\n  constexpr explicit operator bool() const noexcept; // 用于确定coroutine_handle是否有效\n  bool done() const; // 用于确定协程是否已经执行完成\n\n  // 控制协程执行\n  void operator()() const; // 行为同resume，用于唤醒协程\n  void resume() const; // 用于唤醒协程\n  void destroy() const; // 用于销毁协程\n\n  // 访问Promise对象\n  Promise&amp; promise() const;\n\nprivate:\n  void* ptr;  // exposition only \n};\n\ntemplate&lt;&gt;\nstruct coroutine_handle&lt;void&gt; {\n  // 构造函数和赋值函数\n  constexpr coroutine_handle() noexcept;\n  constexpr coroutine_handle(nullptr_t) noexcept;\n  coroutine_handle&amp; operator=(nullptr_t) noexcept;\n\n  // 导入和导出\n  constexpr void* address() const noexcept;\n  static constexpr coroutine_handle from_address(void* addr);\n\n  // 查询协程状态\n  constexpr explicit operator bool() const noexcept;\n  bool done() const;\n\n  // 恢复协程执行\n  void operator()() const;\n  void resume() const;\n  void destroy() const;\n\nprivate:\n  void* ptr;  // exposition only\n};\n</code></pre><p>相比于void类型的特化版本，如果开发者指定了promise类型，那么就会用通用版本的coroutine_handle，这个类多了以下几个成员函数。</p><ul>\n<li>from_promise：获取promise对应的coroutine_handle。实际行为会根据promise创建新的coroutine_handle对象。</li>\n<li>operator coroutine_handle&lt;&gt;：将promise版本的coroutine_handle转换为void类型的coroutine_handle。</li>\n<li>promise：获取coroutine_handle内部的promise对象。</li>\n</ul><p>两个版本最后一行用“exposition only”标识出来的部分，就是coroutine_handle的内部存储内容，这部分只是为了说明标准做的示例，实际不同编译器可以根据自己的需求定义这里的实现。</p><h2>协程的调度</h2><p>在了解如何实现协程类型与Promise后，我们还需要学习如何对协程进行调度，包括协程休眠、控制权转移和待计算值的传递。对协程进行调度的关键在于co_await和co_yield操作符（关键字）。</p><h3>co_await</h3><p>co_await是协程中必须要了解的与编译器的约定。只有了解它，我们才能知道如何通过co_await灵活处理线程的休眠与唤醒。而搞清楚co_await操作符的具体行为表现，是我们理解Awaitable的重点，我们就从这个操作符开始讲起。</p><p>co_await操作符用于休眠协程，并将控制权返还给协程调用者，用法如下。</p><pre><code class=\"language-c++\">co_await 表达式;\n</code></pre><p>与此同时，co_await的表达式需要满足下列两个条件之一。</p><ol>\n<li>表达式类型必须定义了co_await操作符重载。</li>\n<li>可以通过当前协程的Promise::await_transform转换为定义了co_await操作符的类型。</li>\n</ol><p>请注意，co_await只能出现在函数体的执行表达式中，不能出现在异常处理、声明语句、简单声明表达式、默认参数和带static和thread_local的局部变量定义中。另外，co_await的执行过程较为复杂，其中涉及到两个类型。</p><ol>\n<li>Awaitable：用于获取Awaiter对象。</li>\n<li>Awaiter：用于控制实际的休眠操作细节。</li>\n</ol><p>下面通过co_await的执行过程来看看这两个类型的作用。我们需要将其分为编译时和运行时两个阶段来理解。先看编译时，你可以结合下图来理解。<br>\n<img src=\"https://static001.geekbang.org/resource/image/yy/c7/yy19b83b2cdc260264e6a899776ab5c7.jpg?wh=3500x4305\" alt=\"\"></p><p><strong>编译时</strong>，编译器通过以下方式，将表达式转换成Awaitable对象。</p><ul>\n<li>如果表达式是通过初始休眠点、结束休眠点或yield产生的，那么表达式本身就是Awaitable对象。</li>\n<li>否则，如果当前协程的promise中包含await_transform函数，那么就会调用promise.await_transform将表达式转换为Awaitable对象。</li>\n<li>否则，表达式本身就是Awaitable对象。</li>\n</ul><p>接着，编译器就会通过以下操作获取Awaiter对象。</p><ul>\n<li>如果Awaitable类型包含co_await操作符重载，那么就会将co_await重载的执行结果作为Awaiter。</li>\n<li>如果没有找到co_await操作符重载，那么就会将Awaitable对象自身作为Awaiter对象。</li>\n</ul><p>接着，我们再了解一下co_await在运行时的执行过程，如下图所示。<br>\n<img src=\"https://static001.geekbang.org/resource/image/30/5f/30b1dyy44759ae6364e0d6421d3f325f.jpg?wh=3500x4305\" alt=\"\"></p><p>在<strong>运行时</strong>，代码会调用Awaiter对象的await_ready函数，如果该函数返回值为false，那么就会执行以下行为：首先，将协程休眠；然后，使用当前协程的句柄，调用Awaiter对象的await_suspend(handle)函数。</p><p>我们可以在await_suspend中通过句柄获取到当前协程的各种信息，在自己编写的调度器中选择何时唤醒或者销毁这个协程，你可以参照下表了解不同返回值对应的动作。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7e/55/7e8dffc7fb0e5a390684e44f8cc1fb55.jpg?wh=2492x1285\" alt=\"\"></p><p>在唤醒协程时，会调用Awaiter的await_resume函数，并使用该函数的返回值作为co_await表达式的值。其中，await_resume函数的执行，会根据await_ready和await_suspend的执行结果有所不同。<br>\n<img src=\"https://static001.geekbang.org/resource/image/de/0a/de0445876d0b3ccae84a2fb045990c0a.jpg?wh=2492x764\" alt=\"\"></p><p>这里可能会有一些关于多线程上执行协程的疑问。<strong>如果协程的执行涉及在不同线程上执行，会有线程安全问题吗？</strong></p><p>答案其实是不会。协程在进入await_suspend之前会休眠，因此await_suspend函数可以将协程句柄传递给任意的线程，而不需要考虑额外的线程同步问题。</p><p>举例来说，通过协程处理异步任务，await_suspend函数是某个Awaiter类的成员函数，其this指针指向Awaiter对象。<br>\n<img src=\"https://static001.geekbang.org/resource/image/15/7e/1523cf66295f8d588f0544c3cbac877e.jpg?wh=2804x2074\" alt=\"\"><br>\n我们将句柄存储在一个回调函数中（如图中的lambda表达式）。然后，在预先设定的线程池中完成异步任务。最后，调用回调函数利用协程句柄调度唤醒协程。</p><p>在这种情况下，代码块2依然会在本线程继续执行，回调函数中的代码则会在其他线程执行。由于其他线程的调度时序是未知的，因此本线程在执行代码块2时，协程可能已经被其他线程唤醒。这种多线程同时访问同一内存块上数据的情况，我们通常称为<strong>数据竞争问题</strong>。</p><p>为了避免出现这种数据竞争问题，将协程句柄传递给其他线程后，await_suspend后续代码（示例中代码块2）必须假定*this（也就是调用await_suspend的Awaiter对象）已经被销毁，并且再也不对其进行访问。</p><p>这是一种典型的使用异步I/O处理的场景。我们将在下一讲中，详细阐述如何实现Awaitable和Awaiter对象以及异步I/O处理。</p><h3>生成器和co_yield</h3><p>除了co_await，在协程的上下文中还有一个常见操作符（关键字）——co_yield，它本质上是co_await的语法糖，一般用在生成器这种协程的常见场景中。<strong>那么，什么是生成器呢？</strong></p><p>生成器是基于协程的异步编程中常见的一种编程模式。最常见的应用场景就是，通过生成或其他数据源来获取某种序列。</p><p>生成器的核心思路是让协程的调用者和被调用的协程进行协同调度，其中被调用的协程就是生成器。</p><p>这个协同调度过程是这样的：首先，调用者唤醒生成器，生成器返回一个值，接着就会主动进入休眠状态；然后，调用者使用这个值来执行相应代码逻辑，然后重新唤醒生成器……这个过程如此往复，直到调用者从生成器获取了所需的值为止。</p><p>后面我画了一张过程示意图。<br>\n<img src=\"https://static001.geekbang.org/resource/image/f6/92/f656b0b9ce6dc9ce789003e348236892.jpg?wh=2600x3293\" alt=\"\"></p><p>从图中可以看出，在生成器这种模式下，主要就是两个操作。</p><ul>\n<li>调用者作为调度方恢复协程执行。</li>\n<li>协程将获取或生成的值返回给调用者并继续休眠，等待调用者恢复执行。</li>\n</ul><p>而其中的关键就是co_yield关键字，用法是这样。</p><pre><code class=\"language-c++\">co_yield 表达式;\n</code></pre><p>协程可以通过该关键字将表达式的结果传回给调用方并自动休眠。代码等价于：</p><pre><code class=\"language-c++\">co_await promise.yield_value(表达式);\n</code></pre><p>可以看出，调用co_yield的本质就是调用了promise的yield_value函数，并通过co_await将自身休眠。</p><p>为了进一步帮你理解，我还准备了后面的代码，为你演示一下最简单的生成器模式用法。</p><pre><code class=\"language-c++\">#include &lt;coroutine&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nstruct CountGenerator {\n&nbsp;&nbsp;&nbsp; struct promise_type {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t _value{ 0 };\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~promise_type() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"promise_type 对象销毁\" &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CountGenerator get_return_object() {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ._handle = std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_never initial_suspend() { return {}; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always final_suspend() noexcept { return {}; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void unhandled_exception() {}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::suspend_always yield_value(int32_t value) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _value = value;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {};\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void return_void() {}\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; std::coroutine_handle&lt;promise_type&gt; _handle;\n};\n\nCountGenerator doCount() {\n&nbsp;&nbsp;&nbsp; for (int32_t i = 0; i &lt; 3; ++i) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; co_yield i;\n    }\n}\n\nint main() {\n&nbsp;&nbsp;&nbsp; auto h = doCount()._handle;\n&nbsp;&nbsp;&nbsp; auto&amp; promise = h.promise();\n&nbsp;&nbsp;&nbsp; while (!h.done()) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"计数: \" &lt;&lt; promise._value &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h();\n&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; h.destroy();\n\n    return 0;\n}\n</code></pre><p>我在这里定义了一个协程类CountGenerator，比较特殊的是，这个类定义了一个yield_value成员函数，用于把co_yield的表达式值存储到promise对象内部，调用者通过这一方式来获取值。</p><p>由于调用方不知道协程什么时候结束执行，所以通过coroutine_handle中的done函数获取运行时状态。如果协程尚未结束执行，就获取相应的值并继续，否则就销毁协程并退出程序。</p><h2>总结</h2><p>协程是一种可休眠、可恢复的函数，可以实现几乎“零”开销的代码调度，是C++支持异步编程的重要一环，也是彻底迈向现代编程语言的关键标志之一。</p><p>一个协程类（Generator类）包含promise_type、coroutine_handle、coroutine_state。但是C++20的协程缺乏具体实现，接口约定都需要开发者来实现。</p><p>我们在这一讲中详细阐述了实现这些约定的代码和具体方法，并在这里对promise_type和Awaitable的接口约定，一并总结成用concept描述的约束表达式，供你今后参考。</p><pre><code class=\"language-c++\">// ============= Promise的Concept定义 ===================\n// PromiseType是Promise的类型，ValueType是协程中待计算的值的类型\ntemplate&lt;typename PromiseType, typename ValueType&gt;\nconcept Promise = requires(PromiseType promise) {\n  { promise.get_return_object() } -&gt; Coroutine&lt;PromiseType&gt;;\n  { promise.initial_suspend() } -&gt; Awaiter;\n  { promise.final_suspend() } -&gt; Awaiter;\n  \n  requires (requires(ValueType value) { promise.return_value(value); } || { promise.return_void(); })\n  { promise.unhandled_exception() };\n};\n\n// ============= Awaiter的Concept定义 ===================\n// AwaitSuspendResult约束了await_suspend的返回值类型\n// AwaiterType是Awaiter的类型，Promise是协程的Promise类型，下同\ntemplate &lt;typename ResultType, typename Promise&gt;\nconcept AwaitSuspendResult = std::same_as&lt;ResultType, void&gt; ||\n  std::same_as&lt;ResultType, bool&gt; ||\n  std::same_as&lt;ResultType, std::coroutine_handle&lt;Promise&gt;&gt;;\n\n// Awaiter约束定义，Awaiter类型必须满足requires中的所有接口约定\ntemplate &lt;typename AwaiterType, typename Promise&gt;\nconcept Awaiter = requires(AwaiterType awaiter, std::coroutine_handle&lt;Promise&gt; h) {\n&nbsp;&nbsp;&nbsp; awaiter.await_resume();\n&nbsp;&nbsp;&nbsp; { awaiter.await_ready() } -&gt; std::same_as&lt;bool&gt;;\n&nbsp;&nbsp;&nbsp; { awaiter.await_suspend(h) } -&gt; AwaitSuspendResult&lt;Promise&gt;;\n};\n\n// ============= Awaitable的Concept定义 ===================\n// ValidCoAwait约束用于判断对于AwaitableType是否存在正确的co_await操作符重载\n// co_await可以重载为成员函数或者非成员函数，约束中都需要判断\n// AwaitableType是Awaitable的类型，Promise是协程的Promise类型，下同\ntemplate &lt;typename AwaitableType, typename Promise&gt;\nconcept ValidCoAwait = requires(AwaitableType awaitable) {\n&nbsp;&nbsp;&nbsp; { awaitable.operator co_await() } -&gt; Awaiter&lt;Promise&gt;;\n} || requires(AwaitableType awaitable) {\n&nbsp;&nbsp;&nbsp; { operator co_await(static_cast&lt;AwaitableType&amp;&amp;&gt;(awaitable)) } -&gt; Awaiter&lt;Promise&gt;;\n};\n\n// Awaitable约束定义\n// Awaitable必须存在正确的co_await操作符重载，或者自身是一个Awaiter\ntemplate &lt;typename AwaitableType, typename Promise&gt;\nconcept Awaitable = ValidCoAwait&lt;AwaitableType, Promise&gt; ||\n  Awaiter&lt;AwaitableType, Promise&gt;;\n</code></pre><p>因此，我们从整体上看，C++20中提供的coroutines较为粗糙，它仅提供了语言层面的支持，缺乏标准库的支持。我们期待更加成熟的支持会在C++26或后续标准中到来。</p><h2>课后思考</h2><p>当我们讲解生成器的时候，_handle和promise都是协程的内部状态，应该不需要让调用方关心。那么，我们该如何修改CountGenerator，才能让调用者无需关心这些内部细节，并直接获取到co_yield的结果呢？</p><p>不妨在这里分享你的方案，与大家一起分享。我们一同交流。下一讲见！</p><h2>课后小知识</h2><p><img src=\"https://static001.geekbang.org/resource/image/bd/1b/bd0426eyy1b2a951a8f17bff88bbf01b.jpg?wh=2600x1490\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/3f/f6/3fcfb3a4f8cef31ec9bd3451886e5ef6.jpg?wh=2600x1285\" alt=\"\"></p>","neighbors":{"left":{"article_title":"07｜Coroutines背景：异步I/O的复杂性","id":624911},"right":{"article_title":"09｜Coroutines实战（一）：异步文件操作库","id":626593}},"comments":[{"had_liked":false,"id":383582,"user_name":"Family mission","can_delete":false,"product_type":"c1","uid":2710729,"ip_address":"上海","ucode":"10D4D65520FE0D","user_header":"https://static001.geekbang.org/account/avatar/00/29/5c/c9/f1b053f2.jpg","comment_is_top":false,"comment_ctime":1699318782,"is_pvip":false,"replies":[{"id":140083,"content":"感谢你！\n\nusing promise_type = promise&lt;T&gt;\n是给primise&lt;T&gt;起了一个别名，这个别名是promise_type\n等同于C++98中的 typedef promise&lt;T&gt; promise_type","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1699977137,"ip_address":"上海","comment_id":383582,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"作者你好，感觉你讲的这节内容干货满满，请解释下这个代码块的含义\ntemplate\nstruct promise;\ntemplate\nstruct Generator : std::coroutine_handle&gt; { using promise_type = promise;};\nusing promise_type = promise&lt;T&gt;;这个代码块的含义么，可以理解成是将模版类赋值给这个promise_type么","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631798,"discussion_content":"感谢你！\n\nusing promise_type = promise&lt;T&gt;\n是给primise&lt;T&gt;起了一个别名，这个别名是promise_type\n等同于C++98中的 typedef promise&lt;T&gt; promise_type","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699977137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381422,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"广东","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1695190207,"is_pvip":false,"replies":[{"id":139106,"content":"Modules其实是只有在所有的新代码都采用Modules后才能深刻感受的，但是C++需要引入非Modules代码，肯定就会使得问题反而复杂化了。\nCoroutine中，C++标准只提供了“协议”，具体的实现需要我们根据自己的需要来做。但是如果在封装好一个完善的框架后是可以大幅度降低异步编程的复杂性的——就像我们可以在C++22 Coroutine的基础上实现一个完善的类似于libuv之类的异步I&#47;O框架，应用开发者在框架的基础上开发应用就能降低复杂度了，而框架的开发者也能有足够的灵活性和自由性。因此我们需要从一个使用者的角度来看Coroutine，而不是框架底层的开发者，这样就不会觉得Coroutine会提升复杂性了。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1696256159,"ip_address":"上海","comment_id":381422,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"说实话，从这些代码来看，我认为比传统的异步编程更复杂了，而且是复杂太多了。\n学到这里，我觉得concept是个好东西，相比原来的模板元编程，可读性友好了很多，其它的，就是把简单的事情复杂化。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628927,"discussion_content":"Modules其实是只有在所有的新代码都采用Modules后才能深刻感受的，但是C++需要引入非Modules代码，肯定就会使得问题反而复杂化了。\nCoroutine中，C++标准只提供了“协议”，具体的实现需要我们根据自己的需要来做。但是如果在封装好一个完善的框架后是可以大幅度降低异步编程的复杂性的——就像我们可以在C++22 Coroutine的基础上实现一个完善的类似于libuv之类的异步I/O框架，应用开发者在框架的基础上开发应用就能降低复杂度了，而框架的开发者也能有足够的灵活性和自由性。因此我们需要从一个使用者的角度来看Coroutine，而不是框架底层的开发者，这样就不会觉得Coroutine会提升复杂性了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696256159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380287,"user_name":"！null","can_delete":false,"product_type":"c1","uid":1242483,"ip_address":"北京","ucode":"4E5B7922980397","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/73/f7d3a996.jpg","comment_is_top":false,"comment_ctime":1693313237,"is_pvip":false,"replies":[{"id":138609,"content":"co_yield就是在暂停协程，并将值“return”回调用者。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1693901095,"ip_address":"上海","comment_id":380287,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"CountGenerator doCount() {\n    for (int32_t i = 0; i &lt; 3; ++i) {\n        co_yield i;\n    }\n}\n这个返回值是在哪里return的呢？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627224,"discussion_content":"co_yield就是在暂停协程，并将值“return”回调用者。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693901095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372555,"user_name":"sea520","can_delete":false,"product_type":"c1","uid":1508621,"ip_address":"浙江","ucode":"C943EAD079B2A4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIm5rlbJ4HdXLbxmflvW0FW4rTyLcDzHLGDJUJic9W3f1KibWY7mAj9dxUIEVlxDyjwRXEX54KXEn5g/132","comment_is_top":false,"comment_ctime":1681276993,"is_pvip":false,"replies":[{"id":136011,"content":"生成器在执行代码的时候，调用生成器的代码必然需要暂停等待被调用者返回结果。\n\n但这里是同步还是异步是需要看你如何管理调用者和被调用者的执行。\n\n比如，如果像我们这种简单的生成器，肯定就是同步的，但如果现在调用者和被调用者是在两个线程上，并且两者都是可被调度的任务，当调用者等待生成器时就可以通过调度将本线程的CPU让给其他需要CPU的任务，如果能有这种调度框架，那么从整体上来说就是异步的，因为这种情况主线程基本时不会阻塞的，永远会通过调度器分配任务，不会浪费等待生成器返回结果时的CPU时间。因此同步&#47;异步模型还是需要从不同角度和不同的实现方式来看。协程为我们封装这种能力，实现相关的框架提供了一个技术上的基础。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1681396833,"ip_address":"上海","comment_id":372555,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"生成器在执行代码的时候，调用者也会在执行自己的代码吗，还是调用者暂停执行？\n调用者是通过自己不断循环来获取生成器的返回值，还调用者怎么去做自己的事情，感觉不太能体现异步编程。异步编程是生成器有数据后通知调用者，而不是一直循环去检查是否数据完成吧","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613570,"discussion_content":"生成器在执行代码的时候，调用生成器的代码必然需要暂停等待被调用者返回结果。\n\n但这里是同步还是异步是需要看你如何管理调用者和被调用者的执行。\n\n比如，如果像我们这种简单的生成器，肯定就是同步的，但如果现在调用者和被调用者是在两个线程上，并且两者都是可被调度的任务，当调用者等待生成器时就可以通过调度将本线程的CPU让给其他需要CPU的任务，如果能有这种调度框架，那么从整体上来说就是异步的，因为这种情况主线程基本时不会阻塞的，永远会通过调度器分配任务，不会浪费等待生成器返回结果时的CPU时间。因此同步/异步模型还是需要从不同角度和不同的实现方式来看。协程为我们封装这种能力，实现相关的框架提供了一个技术上的基础。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681396833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370364,"user_name":"tang_ming_wu","can_delete":false,"product_type":"c1","uid":2566054,"ip_address":"广东","ucode":"98E5847CEF8B84","user_header":"https://static001.geekbang.org/account/avatar/00/27/27/a6/32e9479b.jpg","comment_is_top":false,"comment_ctime":1678760050,"is_pvip":false,"replies":[{"id":135291,"content":"标准库对coroutine的支持预计还需要等待后续的标准（C++26或之后）。但是在这之前，C++已经从核心语言特性层面，支持了协程，如果要在工程中使用协程实现非嵌入式的高性能异步计算能力，已经是可能的了。\n\n不过，就像正文所说的，目前这些接口约定还需要开发者实现。我在课程的配套代码中实现了协程的接口约定，可以参考其实现基于协程的高性能异步。\n\n或者，等待 std::lazy 落地。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1679306462,"ip_address":"上海","comment_id":370364,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"个人觉得，作为普通开发者，当前只需要了解无栈协程的基本原理即可。最后使用的，应该还是标准库需要提供的易用接口。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609941,"discussion_content":"标准库对coroutine的支持预计还需要等待后续的标准（C++26或之后）。但是在这之前，C++已经从核心语言特性层面，支持了协程，如果要在工程中使用协程实现非嵌入式的高性能异步计算能力，已经是可能的了。\n\n不过，就像正文所说的，目前这些接口约定还需要开发者实现。我在课程的配套代码中实现了协程的接口约定，可以参考其实现基于协程的高性能异步。\n\n或者，等待 std::lazy 落地。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679306462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368825,"user_name":"momo","can_delete":false,"product_type":"c1","uid":3297483,"ip_address":"江苏","ucode":"4C0869CAEE95D5","user_header":"https://static001.geekbang.org/account/avatar/00/32/50/cb/01422311.jpg","comment_is_top":false,"comment_ctime":1676777067,"is_pvip":false,"replies":[{"id":134886,"content":"C++选用了无栈协程主要是由以下考量：\n1.\t无栈协程具备更好的伸缩性和扩展性，相当于把对协程的高层接口语义定义的权力全部交给了开发者，因此可以允许开发者设计开发协程库，甚至基于无栈协程构建类似于有栈协程的高层接口。而C++26可能也会加入lazy，提供类似于有栈协程的封装，降低对原有代码的侵入性。\n2.\t与已有的其他基础设施，比如线程等完全正交设计，可以无缝集成。\n3.\t因为可以自定义挂起和恢复的实现，因此相比有栈协程可以更加高效。\n4.\t在有些团队或者公司可能因为各种原因会禁用异常，这种情况下自定义的无栈协程会有更好的性能。\n\n总之，就是在日后的标准（比如C++26）中加入便于初学者使用的类似于有栈协程的接口，又允许专家开发者根据自己的需求去根据实际问题场景做深度的定制封装，这就是C++标准的一个设计原则。如果直接用了有栈协程，那就基本封死了开发者扩展定制的可能性，不符合C++的基本设计理念。\n","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1678249402,"ip_address":"上海","comment_id":368825,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教老师一个问题：\n我们知道协程实现有 有栈协程和无栈协程，C++ 选用了无栈协程是基于什么考虑？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608068,"discussion_content":"C++选用了无栈协程主要是由以下考量：\n1.\t无栈协程具备更好的伸缩性和扩展性，相当于把对协程的高层接口语义定义的权力全部交给了开发者，因此可以允许开发者设计开发协程库，甚至基于无栈协程构建类似于有栈协程的高层接口。而C++26可能也会加入lazy，提供类似于有栈协程的封装，降低对原有代码的侵入性。\n2.\t与已有的其他基础设施，比如线程等完全正交设计，可以无缝集成。\n3.\t因为可以自定义挂起和恢复的实现，因此相比有栈协程可以更加高效。\n4.\t在有些团队或者公司可能因为各种原因会禁用异常，这种情况下自定义的无栈协程会有更好的性能。\n\n总之，就是在日后的标准（比如C++26）中加入便于初学者使用的类似于有栈协程的接口，又允许专家开发者根据自己的需求去根据实际问题场景做深度的定制封装，这就是C++标准的一个设计原则。如果直接用了有栈协程，那就基本封死了开发者扩展定制的可能性，不符合C++的基本设计理念。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678249402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367596,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1675343981,"is_pvip":false,"replies":[{"id":134078,"content":"Q1：局部变量的生命周期可以理解成这个变量在堆栈上的存在时间，超出生命周期时这个局部变量就会被销毁，如果是对象就会调用析构函数。\n\nQ2：exposition only是为了解释编译器所提供的标准库实现可能是如何实现coroutine_handle的。coroutine_handle是C++标准库提供的标准类型，这个类型不需要coder自己实现，但是C++标准只定义了coroutine_handle的public部分的接口，内部如何实现完全由编译器包含的标准库具体实现决定，这就是为什么“编译器可以根据自己的需求定义这里的实现”。\n\nQ3：协程完全可以用于长耗时运算，但是如果这样我们会利用线程或者进程通信、网络通信等机制将计算释放给其他的计算单元计算，这样当前线程还可以继续其他计算任务。协程只是提供了计算任务的手动控制切换的能力，和其他的并行并发计算技术是完全正交的。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1676030446,"ip_address":"上海","comment_id":367596,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教老师几个问题：\nQ1：局部变量的声明周期是什么？\nQ2：用“exposition only”标识出来的ptr怎么跟编译器有关？\n文中说“用“exposition only”标识出来的部分，就是 coroutine_handle 的内部存储内容，这部分只是为了说明标准做的示例，实际不同编译器可以根据自己的需求定义这里的实现”。 我的理解是：ptr应该是coder设置的具体内容，应该和编译器无关。\nQ3：协程可以用来做长耗时的运算吗？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603249,"discussion_content":"Q1：局部变量的生命周期可以理解成这个变量在堆栈上的存在时间，超出生命周期时这个局部变量就会被销毁，如果是对象就会调用析构函数。\n\nQ2：exposition only是为了解释编译器所提供的标准库实现可能是如何实现coroutine_handle的。coroutine_handle是C++标准库提供的标准类型，这个类型不需要coder自己实现，但是C++标准只定义了coroutine_handle的public部分的接口，内部如何实现完全由编译器包含的标准库具体实现决定，这就是为什么“编译器可以根据自己的需求定义这里的实现”。\n\nQ3：协程完全可以用于长耗时运算，但是如果这样我们会利用线程或者进程通信、网络通信等机制将计算释放给其他的计算单元计算，这样当前线程还可以继续其他计算任务。协程只是提供了计算任务的手动控制切换的能力，和其他的并行并发计算技术是完全正交的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676030446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}