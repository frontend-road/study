{"id":235336,"title":"19 | 广告系统：广告引擎如何做到在0.1s内返回广告信息？","content":"<p>你好，我是陈东。今天我们来讲广告系统。</p><p>说到广告系统，很多人可能没有那么熟悉。但是在互联网行业中，广告系统其实是非常重要，并且非常有代表性的一种系统。</p><p>一方面是因为，广告是许多互联网公司的重要营收来源。比如，我们熟悉的Google和Facebook，它们的广告收入就占公司总收入的80%以上。因此，尽管许多互联网公司的主营业务并不一样，有的是搜索引擎，有的是电商平台，有的是视频平台等等。但是，它们背后都有着相似的广告业务线。</p><p>另一方面，互联网广告对于工程和算法有着强烈的依赖。强大的工程和算法让现在的互联网广告能做到千人千面。最常见的，我们在打开网站的一瞬间，广告系统就会通过实时的分析计算，从百万甚至千万的广告候选集中，为我们这一次的广告请求选出专属的广告。而且，整个响应广告请求的处理过程，只需要0.1秒就能完成。</p><p>那在大型广告系统中，广告的请求量其实非常大，每秒钟可能有几十万甚至上百万次。因此，广告系统是一个典型的高并发低延迟系统。事实上，这背后离不开一个高性能的广告检索引擎的支持。那今天，我们就来聊一聊，广告系统中负责检索功能的广告引擎架构。</p><h2>广告引擎的整体架构和工作过程</h2><p>首先，我们来了解两个基本概念。</p><!-- [[[read_end]]] --><p>互联网广告分为搜索广告和展示广告两大类。简单来说，搜索广告就是用户主动输入关键词以后，搜索引擎在返回结果中展示出的相关广告。而展示广告，则是在搜索引擎之外的网站或App中，用户在浏览页面的情况下，被动看到的广告。比如说，在打开一些App时出现的开屏广告，以及朋友圈中的广告等等。<br>\n<img src=\"https://static001.geekbang.org/resource/image/9f/02/9fffd31417da6e9dd04599361c75df02.jpg?wh=1920*1080\" alt=\"\" title=\"搜索广告和展示广告示例\"></p><p>尽管这两种广告的业务形态不太一样，但是它们后台的广告引擎本质上都是相似的，主要的区别是约束条件上的不同。</p><p>在搜索广告中，因为它和搜索词有很强的相关性，所以，我们需要针对搜索词进行一系列的分析，这和我们上一讲说过的查询分析过程类似，这里我就不多讲了。而展示广告没有搜索词的约束条件，展示能力也就更灵活。因此，今天我们主要以展示广告为例，来说一说从用户打开网站到看到广告，广告系统是如何工作的。</p><p>为了方便你理解，我梳理了一张广告引擎的核心功能架构图。接下来，我就依据这个架构图，从<strong>用户浏览</strong>和<strong>广告主投放广告</strong>这两个方面，来为你详讲解一下广告引擎的工作过程。<br>\n<img src=\"https://static001.geekbang.org/resource/image/79/a0/7990e7a990043087c1ce5bfa944063a0.jpg?wh=1920*908\" alt=\"\" title=\"广告引擎架构示意图\"></p><p>一方面，当用户浏览网页时，网页会向服务端发起一个广告请求。服务端接到广告请求后，会先进行请求解析，也就是通过用户在系统中的唯一ID、网站地址以及广告位ID，去后台查询相关的广告请求的扩展信息。</p><p>那怎么查询呢？一般来说，通过系统之前对用户的长期行为收集和分析，我们就能知道该用户的喜好，比如喜欢看篮球、喜欢购物等。根据得到的结果，我们会为用户打上相应的标签。同理，对于各种网页和广告位，我们也会分析好网页分类等信息。然后，我们会提前将这些分析好的结果保存在Key-value数据库中，以支持快速查询。这样一来，广告请求解析就可以通过查询Key-value数据库，得到相关信息了。</p><p>另一方面，广告主在投放广告时，为了保证广告的后续效果，往往会进行广告设置，也就是给广告投放加上一些定向投放的条件。比如说，只投放给北京的用户，年龄段在20岁以上，对篮球感兴趣，使用某一型号的手机等。这些限制条件，我们都可以用标签的形式来表示。因此，一个广告设置，抽象出来就是一系列标签的组合。</p><p>所以我们说，<strong>广告引擎处理一个广告请求的过程，本质上就是根据用户的广告请求信息，找出标签匹配的广告设置，并将广告进行排序返回的过程</strong>。这一点非常重要，我们后面讲的内容都是围绕它来展开的，我希望你能记住它。</p><p>返回广告以后，我们还需要收集广告的后续监测数据，比如说是否展现给了用户，以及是否被用户点击等后续行为。那有些后续行为还涉及广告计费，比如，如果广告是按点击付费的话，那么只要有用户点击了广告，就会产生对应的费用。这时广告系统不仅需要进行相应的计费，还需要快速修改系统中的广告数据，使得系统能在广告主的预算花完之后就立即停止投放。</p><p>好了，以上就是广告引擎的工作过程。你会发现，尽管广告引擎在业务形态和流程上都有自己的特点，但是，它的核心检索流程和搜索引擎是类似的，也分为了索引构建、检索召回候选集和排序返回这三个部分。不过，和搜索引擎相比，由于广告引擎没有明确的关键词限制，因此在如何构造倒排索引上，广告引擎会有更大的灵活度。</p><p>接下来，我们就一起来看看，广告引擎是怎么结合自己的业务特点，来进行高性能的检索设计，从而能在0.1秒内返回合适的广告。</p><h2>标签检索：合理使用标签过滤和划分索引空间</h2><p>广告引擎的索引设计思路，是将广告设置的标签作为Key来构建倒排索引，在posting list中记录对应的广告设置列表，然后为标签进行ID编号，让系统处理标签的过程能更高效。这么说比较抽象，我来举个例子。</p><p>如果广告设置的标签是“地域：北京”“兴趣：篮球”“媒体：体育网站”，那我们可以使用一个32位的整数为每个标签进行编号。具体来说就是将32位的整数分为两部分，高位用来表示定向类型，低位用来表示这个定向类型下具体的标签。</p><p>比如说，我们采用高8位作为定向类型的编码，用来表示地域定向、兴趣定向和媒体定向等。用低24位，则作为这个定向类型下面的具体内容。那在地域定向里，低24位就是每个地区或者城市自己的编码。这样，我们就可以将广告设置的标签都转为一个编号了（高、低位的分配是可以根据实际需求灵活调整的）。<br>\n<img src=\"https://static001.geekbang.org/resource/image/73/e5/732f35d1da5df3dc95fcaec13b8b6fe5.jpg?wh=1920*578\" alt=\"\" title=\"标签编码示意图\"></p><h3>1. 将标签加入过滤列表</h3><p>那是不是所有的标签都可以作为倒排索引的Key呢？你可以先自己想一想，我们先来看一个例子。</p><p>如果所有的广告投放设置都选择投放在App上，那么“媒体类型：App”这个标签后面的posting list就保存了所有的广告设置。但是，这样的标签并不能将广告设置区分开。为了解决这个问题，我们可以使用类似TF-IDF算法中计算IDF的方式，找出区分度低的标签，不将它们加入倒排索引。</p><p>那我们什么时候使用这些标签呢？我们可以将这些标签加入“过滤列表”中，然后在倒排索引中检索出结果以后，加上一个过滤环节，也就是对检索结果进行遍历，在遍历过程中使用“过滤列表”中的标签进行检查，这样就完成了标签是否匹配的判断。</p><h3>2. 用标签进行索引分片</h3><p>其实，对于标签的匹配使用，我们还有其他的方案。我们再来看一个例子，假设平台中有一半的广告投放设置希望投放在移动App上，另一半希望投放在PC网站上，那如果我们以“媒体类型：App”和“媒体类型：PC网站”作为标签来建立倒排索引的话，这样的标签是有区分度的。但是由于这两个标签后面的posting list都会非常长，各自都保存着一半的广告设置。因此在进行posting list归并的时候，实际上就等于要遍历一半的广告设置。这反而会降低检索效率。</p><p>因此，对于“媒体类型”这类（以及“性别”、“操作系统”等）具有少量的标签值，但是每个标签值都有大规模区分度的设置维度来说，我们可以不把它们加入到倒排索引中，而是根据标签来将广告设置进行<strong>分片</strong>。也就是把投放PC网站的广告设置作为一组，投放App的广告设置作为另外一组，分别建立倒排索引。</p><p>如果这样的有区分度的设置维度不止一个，那我们就使用树形结构进行划分，将最有区分度的设置维度（如“媒体类型”）作为根节点，不同的设置值作为分叉（如PC网站和App就是“媒体类型”维度下的两个分叉）。在这个节点下，如果有其他的设置也具有足够的区分度，那也可以作为子节点继续划分。然后对于被划分到同一个叶子节点下的一组，我们再利用标签建立倒排索引。<br>\n<img src=\"https://static001.geekbang.org/resource/image/56/89/56d22e65e832602752874fa9e55fa089.jpg?wh=1920*772\" alt=\"\" title=\"树 + 倒排的索引结构示意图\"></p><p>通过这样的树形结构，我们根据广告请求上的标签，就能快速定位到要找的索引分片，之后，再查找分片中的倒排索引就可以了。</p><p>总结来说，广告设置对广告引擎来说，就像搜索词对搜索引擎一样重要。但是对于广告设置，我们不会像关键词一样，全部加入倒排索引中，而是会分别加入到三个环节中：第一个环节，作为树形结构的节点分叉进行分流；第二个环节，作为倒排索引的Key；第三个环节，在遍历候选结果时作为过滤条件。通过这样的设计，广告引擎中的检索空间就能被快速降低，从而提升检索效率，快速返回候选结果了。</p><h2>向量检索：提供智能匹配能力</h2><p>随着广告业务的演化，目前很多平台提供了一种新的广告投放模式：不是由广告主设置广告定向，而是由广告引擎在保证广告效果的前提下，自己决定如何召回广告。在这种情况下，广告引擎就可以摆脱标签的限制，使用向量来表示和检索，也就可以更精准地挖掘出合适的广告了。为什么要摆脱标签的限制呢？</p><p>我们来看个例子，在之前的标签系统中，当广告主想将广告投放给“喜欢篮球的人”时，如果一个用户身上的标签只有“喜欢运动”，那这个广告是不会投放给这个用户的。但如果广告主不进行广告定向限定，而是由广告引擎来决定如何召回广告，那广告引擎是可以针对“喜欢运动”的人投放这条广告的。</p><p>具体是怎么做的呢？我们可以将广告设置和用户兴趣都表示为高维空间的向量，这样，原来的每个标签就都是向量的一个维度了。然后我们使用最近邻检索技术，找到最近的点就可以返回结果了。这样的设计，本质上是使用机器的智能定向设置，代替了广告主手动的定向设置，从而大幅提升了广告设置的效率和效果。<br>\n<img src=\"https://static001.geekbang.org/resource/image/de/94/de4a54928f12ef7549e23817c6d15a94.jpg?wh=1920*705\" alt=\"\" title=\"标签检索和向量检索的对比\"></p><p>不过，在我们使用向量检索来代替标签检索之后，系统的性能压力也会更大，因此，为了保证广告引擎能在0.1秒内返回广告检索结果，我们需要对向量检索进行加速操作。这时，我们可以使用第16讲中“聚类+倒排索引+乘积量化”的实现方案，来搭建广告引擎的向量检索系统，从而提高向量检索的检索效率。</p><h2>打分排序：用非精准打分结合深度学习模型的精准打分</h2><p>广告引擎除了在召回环节和搜索引擎不一样之外，在打分排序环节也有自己的特点。这主要是因为它们需要返回的结果数量不同。具体来说就是，在搜索引擎中，我们要返回Top K个结果，但是在展示广告业务中，广告引擎往往最后只会返回一条广告结果！因此，对于最后选出来的这一条广告，我们希望它和用户的匹配越精准越好。所以，在广告引擎中，我们会使用复杂的深度学习模型来打分排序。</p><p>但如果在召回阶段选出的候选广告数量很多，那全部使用开销很大的深度学习模型来进行打分的话，我们是很难将单次检索结果控制在0.1秒之内的。而且，如果召回的候选广告数量有几千条，广告引擎最终又只能选出一条，那这几千条的候选广告都使用深度学习模型进行计算，会造成大量的资源浪费。</p><p>为了解决这个问题，我们可以在召回和精准打分排序之间，加入一个非精准打分的环节，来更合理地使用资源。具体来说就是，我们可以基于简单的机器学习模型（如逻辑回归模型（LR）、梯度提升决策树（GBDT）、因子分解机（FM）等）配合少量的特征，来完成这个非精准打分环节，将候选广告的数量限制在几十个的量级。然后，我们再使用深度学习模型来进行精准打分，最后选出分数最高的一个广告进行投放。这样，我们就能大幅节省计算资源，提升检索效率了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/35/f3/35d28ceb7ee802c3b0e96b91750f4ff3.jpg?wh=1920*686\" alt=\"\" title=\"召回 + 非精准打分 + 精准打分\"></p><h2>索引精简：在索引构建环节缩小检索空间</h2><p>除了优化在线的召回和打分环节的检索效率之外，广告业务的特点，使得我们还可以在离线的索引构建环节，通过缩小检索空间来优化。这是因为，广告引擎和搜索引擎中检索对象的生命周期有着很大的不同。一般来说，一个网页只要上线就会存在很久，但是一个广告设置的状态却经常变化。这怎么理解呢？</p><p>比如说，当广告设置限定了投放的时间段时，那这个广告可能上午是有效的，下午就处于停投状态了。再比如说，如果广告预算花完了，那广告也会变为停投状态，但是充值后又会恢复成有效状态。举了这么多例子，我其实就是想告诉你，广告设置的生命周期变化非常快。</p><p>因此，如果我们不考虑这些情况，直接将所有的广告设置都加载到系统中进行索引和检索，然后在遍历过滤的环节，再来检查这些状态进行判断的话，就会带来大量的判断开销。</p><p>这种情况下，我们该怎么办呢？我们可以将过滤条件提前到离线的索引构建的环节。这是因为，这些过滤条件和定向设置没有关系，所以我们完全可以在索引构建的时候，就将这些广告设置过滤掉，仅为当前有效的广告设置进行索引，这样检索空间也就得到了大幅压缩。<br>\n<img src=\"https://static001.geekbang.org/resource/image/72/13/7261d56d5cf9ce026c94046b5a116313.jpg?wh=1920*872\" alt=\"\" title=\"过滤条件前置到索引构建环节\"></p><p>当然，这种提前过滤有一个前提条件，那就是广告引擎需要提供实时高效的索引更新能力。好在，广告投放设置的体量一般不会像网页数那么庞大，一般都可以全部加载到内存中，因此，我们使用全量索引结合增量索引的更新机制，就可以对线上的索引进行实时更新了。</p><h2>重点回顾</h2><p>今天，我们以展示广告为例，学习了广告引擎的工作原理。并且，重点学习了，针对展示广告的特点，在不同的环节进行灵活的设计，来实现高性能的广告引擎。这些优化设计，我们可以概括为以下4点。</p><ol>\n<li>\n<p>在标签检索引擎中，我们通过合理地将标签使用在树形检索+倒排索引+结果过滤这三个环节，来提高检索效率。</p>\n</li>\n<li>\n<p>在向量检索引擎中，我们可以使用聚类+倒排索引+乘积量化的技术来加速检索。</p>\n</li>\n<li>\n<p>在打分排序环节，增加一个非精准打分环节，这样我们就可以大幅降低使用深度学习模型带来的开销。</p>\n</li>\n<li>\n<p>在索引构建环节，我们还可以将一些过滤条件前置，仅将当前有效的广告设置加入索引，然后通过全量索引+增量索引的更新方式，来保证过滤逻辑的有效。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ff/3b/ffb2cbe60de1e018336db0301cd8913b.jpg?wh=2415*2097\" alt=\"\"></p>\n</li>\n</ol><h2>课堂讨论</h2><p>假设我们使用“媒体类型”作为树形检索的节点，“PC网站”和“APP”作为两个分叉，并且允许广告主选择“既在PC网站投放，又在APP上投放”。如果有少量的广告主使用了这种投放，我们的索引分片应该怎么调整？针对这道题中的索引分片，我们必须加载到不同服务器上才能发挥效果，还是即使在单台服务器也能发挥效果？为什么？</p><p>欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这一讲分享给你的朋友。</p>","comments":[{"had_liked":false,"id":217934,"user_name":"paulhaoyi","can_delete":false,"product_type":"c1","uid":1105619,"ip_address":"","ucode":"C972F4B459E7D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/d3/2aa0177f.jpg","comment_is_top":false,"comment_ctime":1589673595,"is_pvip":false,"replies":[{"id":80629,"content":"是否会出相关的文章，需要看大部分读者的诉求和接受程度。\n不过你既然在这里问了，我就先回答你。\n我认为，随着AI的发展，以及数据量的持续增加，检索引擎会往智能化，个性化的方向去发展。基于向量的检索引擎是近期的一个热点。在这方面，其实已经有了许多的开源材料可以让我们去学习。我列出几个供你参考。\n1.Facebook在2017年开源的faiss框架。这是一个高性能的高维向量相似检索和聚类框架。支持多种向量检索算法。我们专栏中介绍的乘积量化的方案也支持。\n2.微软在2019年开源的sptag搜索算法。这是微软的搜索引擎bing使用的向量检索算法。\n3.阿里在2018年开源的tdm算法。这是阿里的推荐系统中使用的向量检索算法。\n这是很有代表性的几个算法和框架。希望对你有帮助。\n","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589698929,"ip_address":"","comment_id":217934,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，后面会出一篇专门介绍现在索引技术的现状（大厂们放下主流使用的索引技术，例如结合深度学习的一些索引技术，记得看过一篇阿里妈妈的tdm深度学习树索引框架类似的）与展望（比较能代表老师认可的索引发展趋势的前沿索引技术研究）的文章么？作为大家在课外持续学习的引导。","like_count":19},{"had_liked":false,"id":217199,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1589438848,"is_pvip":false,"replies":[{"id":80307,"content":"之所以对于区分度不高的标签要建立过滤机制，是因为我们要满足广告主的投放设置要求。\n比如说，90%的广告设置希望将广告投放给“地域:国内”这个标签，我们觉得这个标签用处不大，没有加入倒排索引的key中，那么如果一个海外流量进来，它并没有“地域:国内”这个标签，如果我们不在最后进行一次标签检查过滤的话，我们就会将广告投在这个海外流量上了。这就违背了广告主的期望。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589452402,"ip_address":"","comment_id":217199,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"为什么还要把 区分度低的标签加入过滤列表，再对最后的结果进行遍历呢？ \n这里直接使用区分度度高的标签建立倒排索引不就可以了吗？ 然后在归并不就可以了吗？","like_count":7,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495296,"discussion_content":"是否会出相关的文章，需要看大部分读者的诉求和接受程度。\n不过你既然在这里问了，我就先回答你。\n我认为，随着AI的发展，以及数据量的持续增加，检索引擎会往智能化，个性化的方向去发展。基于向量的检索引擎是近期的一个热点。在这方面，其实已经有了许多的开源材料可以让我们去学习。我列出几个供你参考。\n1.Facebook在2017年开源的faiss框架。这是一个高性能的高维向量相似检索和聚类框架。支持多种向量检索算法。我们专栏中介绍的乘积量化的方案也支持。\n2.微软在2019年开源的sptag搜索算法。这是微软的搜索引擎bing使用的向量检索算法。\n3.阿里在2018年开源的tdm算法。这是阿里的推荐系统中使用的向量检索算法。\n这是很有代表性的几个算法和框架。希望对你有帮助。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589698929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237903,"user_name":"Geek_1e3b12","can_delete":false,"product_type":"c1","uid":1565738,"ip_address":"","ucode":"AD10878A935605","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvRhog5HacsUUUJawJkvQ98icpm2FRCrpISVJVWXUEq1pet5ibIAZdSNoUgicaRykzNpBHxVKSXQqmw/132","comment_is_top":false,"comment_ctime":1596001902,"is_pvip":false,"replies":[{"id":88020,"content":"对于搜索引擎和广告引擎，常见的应用还是基于标签的检索，这一块可以以elastic search的源码来学习。\n对于语意搜索，实现的方案是向量检索，可以以faiss为源码进行学习。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1596109134,"ip_address":"","comment_id":237903,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"有相关项目代码吗？只看理论没经验的理解起来比较难。搜索引擎，广告引擎，语义搜索等","like_count":6,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495074,"discussion_content":"之所以对于区分度不高的标签要建立过滤机制，是因为我们要满足广告主的投放设置要求。\n比如说，90%的广告设置希望将广告投放给“地域:国内”这个标签，我们觉得这个标签用处不大，没有加入倒排索引的key中，那么如果一个海外流量进来，它并没有“地域:国内”这个标签，如果我们不在最后进行一次标签检查过滤的话，我们就会将广告投在这个海外流量上了。这就违背了广告主的期望。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589452402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217206,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1589440152,"is_pvip":false,"replies":[{"id":80308,"content":"是的。可以将相同的数据存在两个分片上。\n毕竟我们从来没有要求索引分片必须完全不重复。索引分片的意义是在于能让我们快速减少检索空间。因此，根据合适的业务，进行合理的索引拆分，这样才是合理的设计。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589452536,"ip_address":"","comment_id":217206,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"对于思考题：\n对于 既在 PC 网站投放，又在 APP 上投放 的广告，在 PC 索引posting list和 APP 索引posting list上都存在不就可以了吗？ 这样的话在一个分片上就可以解决了，虽然说会浪费一些空间，但是题目中说了（现实中）这样的广告主是很少量的， 是可以接受的","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502587,"discussion_content":"对于搜索引擎和广告引擎，常见的应用还是基于标签的检索，这一块可以以elastic search的源码来学习。\n对于语意搜索，实现的方案是向量检索，可以以faiss为源码进行学习。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596109134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217264,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589450984,"is_pvip":false,"replies":[{"id":80310,"content":"1.有一个思路需要转变一下，搜索引擎中，是文章要满足搜索流量的需要;但是广告引擎中，是流量要满足广告设置的需要。两者正好是相反的。\n因此，当一个广告请求流量进来时，我们只知道这个流量是PC流量或是APP流量，只有两种可能性，没有你说的123三种情况。\n2.增加一个分叉和索引分片是OK的。不过在检索的时候就需要特殊处理。就是如果是PC流量的话，需要同时查询PC索引分片和这个新的综合分片;如果是APP流量的话，也需要同时查询APP索引分片和这个新的综合分片。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589453185,"ip_address":"","comment_id":217264,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"有两种思路\n1.直接对用户做标签，如果是标签1只对pc做请求，若果是标签2，只对app做请求。如果是3，就同时做请求，然后合并。这个3的时候会导致请求处理速度下降\n2.增加分叉-即是pc又是app，这样避免了用户标签的速度下降的问题，但是引入了空间上的消耗","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495095,"discussion_content":"1.有一个思路需要转变一下，搜索引擎中，是文章要满足搜索流量的需要;但是广告引擎中，是流量要满足广告设置的需要。两者正好是相反的。\n因此，当一个广告请求流量进来时，我们只知道这个流量是PC流量或是APP流量，只有两种可能性，没有你说的123三种情况。\n2.增加一个分叉和索引分片是OK的。不过在检索的时候就需要特殊处理。就是如果是PC流量的话，需要同时查询PC索引分片和这个新的综合分片;如果是APP流量的话，也需要同时查询APP索引分片和这个新的综合分片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589453185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217152,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589427584,"is_pvip":false,"replies":[{"id":80304,"content":"关于讨论题，的确复制两份是会有冗余，但是如果这部分数据比例不大的话，其实复制数据是更好的设计。而如果同时投两边的比例很大的话，那么实际上，PC网站和APP就没有区分度了，就不应该将这个维度作为树形节点了。\n\n然后关于bidding的问题，你说的是RTB,real time bidding吧，的确是这样的。rtb就是要求在100ms内返回结果。因此，对于检索效率和精准打分判断要求都很高。这一讲的内容其实是适用的。\n此外，我们还有另一个设计，就是非精准打分+流量分层处理。就是在入口处预判流量的价值，价值不高的直接抛弃。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589436598,"ip_address":"","comment_id":217152,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"补充回答下老师对于讨论问题的回复，我开始的想法也是在“PC 网站”和“APP”作为两个分叉，各自保存一份数据，这样的会带来数据冗余，对于这样少量的广告主需求问题不大，如果这种需求多了的话，冗余数据量会很大吧？\n\n另外请教老师一个问题，最近两年广告bidding越来越流行了，不知bidding功能的引入是否对于广告检索有很大结构的上影响呢？","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495055,"discussion_content":"关于讨论题，的确复制两份是会有冗余，但是如果这部分数据比例不大的话，其实复制数据是更好的设计。而如果同时投两边的比例很大的话，那么实际上，PC网站和APP就没有区分度了，就不应该将这个维度作为树形节点了。\n\n然后关于bidding的问题，你说的是RTB,real time bidding吧，的确是这样的。rtb就是要求在100ms内返回结果。因此，对于检索效率和精准打分判断要求都很高。这一讲的内容其实是适用的。\n此外，我们还有另一个设计，就是非精准打分+流量分层处理。就是在入口处预判流量的价值，价值不高的直接抛弃。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589436598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292081,"user_name":"Chauncy","can_delete":false,"product_type":"c1","uid":2149842,"ip_address":"","ucode":"B341B57A6762E4","user_header":"https://static001.geekbang.org/account/avatar/00/20/cd/d2/639fa1dc.jpg","comment_is_top":false,"comment_ctime":1620663289,"is_pvip":false,"replies":[{"id":107519,"content":"这里可能是文中没有表述清楚。我想介绍的是标签的编码方式。可以利用高8位作为标签类型(比如兴趣标签是一大类、地理位置是一类)，然后每类的标签类型下面，会有多个具体的标签内容，比如说兴趣类型下面，不同的兴趣标签(如体育、购物、读书等)就可以用低24位进行编码。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1622900431,"ip_address":"","comment_id":292081,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"用高 8 位作为定向类型的编码，用低 24 位，则作为这个定向类型下面的具体内容 。 没有太理解这个实现 ，一般一个广告的定向都是多个定向类型的交集，这个标签要怎么建呢 ？   用一个 int 要怎么表示多个定向条件的组合 ，来构成索引的 key ？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495055,"discussion_content":"关于讨论题，的确复制两份是会有冗余，但是如果这部分数据比例不大的话，其实复制数据是更好的设计。而如果同时投两边的比例很大的话，那么实际上，PC网站和APP就没有区分度了，就不应该将这个维度作为树形节点了。\n\n然后关于bidding的问题，你说的是RTB,real time bidding吧，的确是这样的。rtb就是要求在100ms内返回结果。因此，对于检索效率和精准打分判断要求都很高。这一讲的内容其实是适用的。\n此外，我们还有另一个设计，就是非精准打分+流量分层处理。就是在入口处预判流量的价值，价值不高的直接抛弃。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589436598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229059,"user_name":"w h l","can_delete":false,"product_type":"c1","uid":1170172,"ip_address":"","ucode":"89D52C49E80366","user_header":"https://static001.geekbang.org/account/avatar/00/11/da/fc/49a90c01.jpg","comment_is_top":false,"comment_ctime":1592889648,"is_pvip":false,"replies":[{"id":84532,"content":"首先，并没有非常成熟的一体化的广告引擎框架，或者推荐引擎框架。不过我们在专栏中也说了，无论是广告引擎还是推荐引擎，其实都有着类似的架构，核心都是召回+排序。\n对于候选集的召回问题，我们可以使用elastic search框架来完成;而对于排序问题，其实elastic search自带有简单的排序功能，比如说bm25。如果你想用机器学习来打分排序的话，那么就可以使用TensorFlow框架来完成模型的创建。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1592917715,"ip_address":"","comment_id":229059,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，你好，请教一下Java广告引擎框架和推荐算法框架是用啥？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499318,"discussion_content":"首先，并没有非常成熟的一体化的广告引擎框架，或者推荐引擎框架。不过我们在专栏中也说了，无论是广告引擎还是推荐引擎，其实都有着类似的架构，核心都是召回+排序。\n对于候选集的召回问题，我们可以使用elastic search框架来完成;而对于排序问题，其实elastic search自带有简单的排序功能，比如说bm25。如果你想用机器学习来打分排序的话，那么就可以使用TensorFlow框架来完成模型的创建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216869,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1589358108,"is_pvip":false,"replies":[{"id":80212,"content":"其实召回的意思我觉得挺形象的，就是在一堆的数据中，捞出一批你觉得不错的结果集合。这就是召回了。\n你理解成取出没问题，不过要注意得是从一堆数据中，取出小范围的结果。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589368545,"ip_address":"","comment_id":216869,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"这几篇不是很理解召回这个术语是什么意思，是否只搜索引擎从存储里取出网页返回给用户，或是这里的从广告库里取出广告展示给用户，就是取出的意思吗？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499318,"discussion_content":"首先，并没有非常成熟的一体化的广告引擎框架，或者推荐引擎框架。不过我们在专栏中也说了，无论是广告引擎还是推荐引擎，其实都有着类似的架构，核心都是召回+排序。\n对于候选集的召回问题，我们可以使用elastic search框架来完成;而对于排序问题，其实elastic search自带有简单的排序功能，比如说bm25。如果你想用机器学习来打分排序的话，那么就可以使用TensorFlow框架来完成模型的创建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592917715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216832,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589352429,"is_pvip":false,"replies":[{"id":80244,"content":"我理解一下，你是不是这样的意思: 再增加一个粗粒度索引(也许叫新的索引分片比较好)，这个索引中的广告设置就是“即投放PC网站又投放APP”的。\n然后你指的“两个分叉都指向这个索引”，其实可以理解为再增加一条分叉，这个分叉就代表了“即投放PC网站，又投放APP的”。而它指向的索引分片，就是前面我们构建的索引。\n这样，当PC的广告请求到来时，我们会走两个分叉，一个是“PC网站”的分叉，另一个是“新增加的“即投PC又投APP”的分叉，然后将结果合并。\n\n这样是OK的，不过你会发现流程改动较大。我们还可以有另一种改法，就是“将即投PC网站，又投APP”的广告设置同时加入到“投PC网站”和“投APP”的两个对应的索引分片中。这样，当PC的广告请求到来时，我们就可以只查询一个索引分片就可以得到正确结果了。\n你会发现，使用复制一份数据的方式，就可以让流程变简单。\n","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589398339,"ip_address":"","comment_id":216832,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"对于讨论题，我的想法是另外建一个树形索引使用 ”媒体类型“ 作为树形检索节点，“PC 网站”和“APP”作为两个分叉，但是这两个分叉都指向同一个倒排索引，假定这个是粗粒度索引。之前文中提到树形索引是细粒度索引，查找的时候，在细粒度索引里找到结果集之后，然后再和粗粒度索引的结果进行归并。整体想法类似于文中提到的过滤列表方式。\n\n因为需要与细粒度索引里找到结果集进行合并，所以需要分别加载到不同服务器上效果比较好，因为不同服务器处理的细粒度索引查询请求不同。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494961,"discussion_content":"我理解一下，你是不是这样的意思: 再增加一个粗粒度索引(也许叫新的索引分片比较好)，这个索引中的广告设置就是“即投放PC网站又投放APP”的。\n然后你指的“两个分叉都指向这个索引”，其实可以理解为再增加一条分叉，这个分叉就代表了“即投放PC网站，又投放APP的”。而它指向的索引分片，就是前面我们构建的索引。\n这样，当PC的广告请求到来时，我们会走两个分叉，一个是“PC网站”的分叉，另一个是“新增加的“即投PC又投APP”的分叉，然后将结果合并。\n\n这样是OK的，不过你会发现流程改动较大。我们还可以有另一种改法，就是“将即投PC网站，又投APP”的广告设置同时加入到“投PC网站”和“投APP”的两个对应的索引分片中。这样，当PC的广告请求到来时，我们就可以只查询一个索引分片就可以得到正确结果了。\n你会发现，使用复制一份数据的方式，就可以让流程变简单。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589398339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217934,"user_name":"paulhaoyi","can_delete":false,"product_type":"c1","uid":1105619,"ip_address":"","ucode":"C972F4B459E7D6","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/d3/2aa0177f.jpg","comment_is_top":false,"comment_ctime":1589673595,"is_pvip":false,"replies":[{"id":80629,"content":"是否会出相关的文章，需要看大部分读者的诉求和接受程度。\n不过你既然在这里问了，我就先回答你。\n我认为，随着AI的发展，以及数据量的持续增加，检索引擎会往智能化，个性化的方向去发展。基于向量的检索引擎是近期的一个热点。在这方面，其实已经有了许多的开源材料可以让我们去学习。我列出几个供你参考。\n1.Facebook在2017年开源的faiss框架。这是一个高性能的高维向量相似检索和聚类框架。支持多种向量检索算法。我们专栏中介绍的乘积量化的方案也支持。\n2.微软在2019年开源的sptag搜索算法。这是微软的搜索引擎bing使用的向量检索算法。\n3.阿里在2018年开源的tdm算法。这是阿里的推荐系统中使用的向量检索算法。\n这是很有代表性的几个算法和框架。希望对你有帮助。\n","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589698929,"ip_address":"","comment_id":217934,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，后面会出一篇专门介绍现在索引技术的现状（大厂们放下主流使用的索引技术，例如结合深度学习的一些索引技术，记得看过一篇阿里妈妈的tdm深度学习树索引框架类似的）与展望（比较能代表老师认可的索引发展趋势的前沿索引技术研究）的文章么？作为大家在课外持续学习的引导。","like_count":19,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495296,"discussion_content":"是否会出相关的文章，需要看大部分读者的诉求和接受程度。\n不过你既然在这里问了，我就先回答你。\n我认为，随着AI的发展，以及数据量的持续增加，检索引擎会往智能化，个性化的方向去发展。基于向量的检索引擎是近期的一个热点。在这方面，其实已经有了许多的开源材料可以让我们去学习。我列出几个供你参考。\n1.Facebook在2017年开源的faiss框架。这是一个高性能的高维向量相似检索和聚类框架。支持多种向量检索算法。我们专栏中介绍的乘积量化的方案也支持。\n2.微软在2019年开源的sptag搜索算法。这是微软的搜索引擎bing使用的向量检索算法。\n3.阿里在2018年开源的tdm算法。这是阿里的推荐系统中使用的向量检索算法。\n这是很有代表性的几个算法和框架。希望对你有帮助。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589698929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217199,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1589438848,"is_pvip":false,"replies":[{"id":80307,"content":"之所以对于区分度不高的标签要建立过滤机制，是因为我们要满足广告主的投放设置要求。\n比如说，90%的广告设置希望将广告投放给“地域:国内”这个标签，我们觉得这个标签用处不大，没有加入倒排索引的key中，那么如果一个海外流量进来，它并没有“地域:国内”这个标签，如果我们不在最后进行一次标签检查过滤的话，我们就会将广告投在这个海外流量上了。这就违背了广告主的期望。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589452402,"ip_address":"","comment_id":217199,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"为什么还要把 区分度低的标签加入过滤列表，再对最后的结果进行遍历呢？ \n这里直接使用区分度度高的标签建立倒排索引不就可以了吗？ 然后在归并不就可以了吗？","like_count":7,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495074,"discussion_content":"之所以对于区分度不高的标签要建立过滤机制，是因为我们要满足广告主的投放设置要求。\n比如说，90%的广告设置希望将广告投放给“地域:国内”这个标签，我们觉得这个标签用处不大，没有加入倒排索引的key中，那么如果一个海外流量进来，它并没有“地域:国内”这个标签，如果我们不在最后进行一次标签检查过滤的话，我们就会将广告投在这个海外流量上了。这就违背了广告主的期望。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589452402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237903,"user_name":"Geek_1e3b12","can_delete":false,"product_type":"c1","uid":1565738,"ip_address":"","ucode":"AD10878A935605","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvRhog5HacsUUUJawJkvQ98icpm2FRCrpISVJVWXUEq1pet5ibIAZdSNoUgicaRykzNpBHxVKSXQqmw/132","comment_is_top":false,"comment_ctime":1596001902,"is_pvip":false,"replies":[{"id":88020,"content":"对于搜索引擎和广告引擎，常见的应用还是基于标签的检索，这一块可以以elastic search的源码来学习。\n对于语意搜索，实现的方案是向量检索，可以以faiss为源码进行学习。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1596109134,"ip_address":"","comment_id":237903,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"有相关项目代码吗？只看理论没经验的理解起来比较难。搜索引擎，广告引擎，语义搜索等","like_count":6,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502587,"discussion_content":"对于搜索引擎和广告引擎，常见的应用还是基于标签的检索，这一块可以以elastic search的源码来学习。\n对于语意搜索，实现的方案是向量检索，可以以faiss为源码进行学习。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596109134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217206,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1589440152,"is_pvip":false,"replies":[{"id":80308,"content":"是的。可以将相同的数据存在两个分片上。\n毕竟我们从来没有要求索引分片必须完全不重复。索引分片的意义是在于能让我们快速减少检索空间。因此，根据合适的业务，进行合理的索引拆分，这样才是合理的设计。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589452536,"ip_address":"","comment_id":217206,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"对于思考题：\n对于 既在 PC 网站投放，又在 APP 上投放 的广告，在 PC 索引posting list和 APP 索引posting list上都存在不就可以了吗？ 这样的话在一个分片上就可以解决了，虽然说会浪费一些空间，但是题目中说了（现实中）这样的广告主是很少量的， 是可以接受的","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495076,"discussion_content":"是的。可以将相同的数据存在两个分片上。\n毕竟我们从来没有要求索引分片必须完全不重复。索引分片的意义是在于能让我们快速减少检索空间。因此，根据合适的业务，进行合理的索引拆分，这样才是合理的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589452536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2343516,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c2/5c/791d0f5e.jpg","nickname":"易企秀-郭彦超","note":"","ucode":"2E25574FAB1B3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345946,"discussion_content":"归并排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611821380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217264,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1589450984,"is_pvip":false,"replies":[{"id":80310,"content":"1.有一个思路需要转变一下，搜索引擎中，是文章要满足搜索流量的需要;但是广告引擎中，是流量要满足广告设置的需要。两者正好是相反的。\n因此，当一个广告请求流量进来时，我们只知道这个流量是PC流量或是APP流量，只有两种可能性，没有你说的123三种情况。\n2.增加一个分叉和索引分片是OK的。不过在检索的时候就需要特殊处理。就是如果是PC流量的话，需要同时查询PC索引分片和这个新的综合分片;如果是APP流量的话，也需要同时查询APP索引分片和这个新的综合分片。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589453185,"ip_address":"","comment_id":217264,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"有两种思路\n1.直接对用户做标签，如果是标签1只对pc做请求，若果是标签2，只对app做请求。如果是3，就同时做请求，然后合并。这个3的时候会导致请求处理速度下降\n2.增加分叉-即是pc又是app，这样避免了用户标签的速度下降的问题，但是引入了空间上的消耗","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495076,"discussion_content":"是的。可以将相同的数据存在两个分片上。\n毕竟我们从来没有要求索引分片必须完全不重复。索引分片的意义是在于能让我们快速减少检索空间。因此，根据合适的业务，进行合理的索引拆分，这样才是合理的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589452536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2343516,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c2/5c/791d0f5e.jpg","nickname":"易企秀-郭彦超","note":"","ucode":"2E25574FAB1B3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345946,"discussion_content":"归并排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611821380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217152,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589427584,"is_pvip":false,"replies":[{"id":80304,"content":"关于讨论题，的确复制两份是会有冗余，但是如果这部分数据比例不大的话，其实复制数据是更好的设计。而如果同时投两边的比例很大的话，那么实际上，PC网站和APP就没有区分度了，就不应该将这个维度作为树形节点了。\n\n然后关于bidding的问题，你说的是RTB,real time bidding吧，的确是这样的。rtb就是要求在100ms内返回结果。因此，对于检索效率和精准打分判断要求都很高。这一讲的内容其实是适用的。\n此外，我们还有另一个设计，就是非精准打分+流量分层处理。就是在入口处预判流量的价值，价值不高的直接抛弃。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589436598,"ip_address":"","comment_id":217152,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"补充回答下老师对于讨论问题的回复，我开始的想法也是在“PC 网站”和“APP”作为两个分叉，各自保存一份数据，这样的会带来数据冗余，对于这样少量的广告主需求问题不大，如果这种需求多了的话，冗余数据量会很大吧？\n\n另外请教老师一个问题，最近两年广告bidding越来越流行了，不知bidding功能的引入是否对于广告检索有很大结构的上影响呢？","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495095,"discussion_content":"1.有一个思路需要转变一下，搜索引擎中，是文章要满足搜索流量的需要;但是广告引擎中，是流量要满足广告设置的需要。两者正好是相反的。\n因此，当一个广告请求流量进来时，我们只知道这个流量是PC流量或是APP流量，只有两种可能性，没有你说的123三种情况。\n2.增加一个分叉和索引分片是OK的。不过在检索的时候就需要特殊处理。就是如果是PC流量的话，需要同时查询PC索引分片和这个新的综合分片;如果是APP流量的话，也需要同时查询APP索引分片和这个新的综合分片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589453185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292081,"user_name":"Chauncy","can_delete":false,"product_type":"c1","uid":2149842,"ip_address":"","ucode":"B341B57A6762E4","user_header":"https://static001.geekbang.org/account/avatar/00/20/cd/d2/639fa1dc.jpg","comment_is_top":false,"comment_ctime":1620663289,"is_pvip":false,"replies":[{"id":107519,"content":"这里可能是文中没有表述清楚。我想介绍的是标签的编码方式。可以利用高8位作为标签类型(比如兴趣标签是一大类、地理位置是一类)，然后每类的标签类型下面，会有多个具体的标签内容，比如说兴趣类型下面，不同的兴趣标签(如体育、购物、读书等)就可以用低24位进行编码。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1622900431,"ip_address":"","comment_id":292081,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"用高 8 位作为定向类型的编码，用低 24 位，则作为这个定向类型下面的具体内容 。 没有太理解这个实现 ，一般一个广告的定向都是多个定向类型的交集，这个标签要怎么建呢 ？   用一个 int 要怎么表示多个定向条件的组合 ，来构成索引的 key ？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519672,"discussion_content":"这里可能是文中没有表述清楚。我想介绍的是标签的编码方式。可以利用高8位作为标签类型(比如兴趣标签是一大类、地理位置是一类)，然后每类的标签类型下面，会有多个具体的标签内容，比如说兴趣类型下面，不同的兴趣标签(如体育、购物、读书等)就可以用低24位进行编码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622900431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554347,"discussion_content":"另外一个思路：当定向条件是全部的时候，冗余到每一个倒排索引中，选择区分度大的倒排索引进行求交集，区分度小的加入过滤列表，这样应该就可以满足广告的各种定向了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646354232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554345,"discussion_content":"这个问题我也想问：每个广告的设置是多个定向类型的交并集。文中讲的索引分片+倒排索引并不能解决这种广告检索的问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646353215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229059,"user_name":"w h l","can_delete":false,"product_type":"c1","uid":1170172,"ip_address":"","ucode":"89D52C49E80366","user_header":"https://static001.geekbang.org/account/avatar/00/11/da/fc/49a90c01.jpg","comment_is_top":false,"comment_ctime":1592889648,"is_pvip":false,"replies":[{"id":84532,"content":"首先，并没有非常成熟的一体化的广告引擎框架，或者推荐引擎框架。不过我们在专栏中也说了，无论是广告引擎还是推荐引擎，其实都有着类似的架构，核心都是召回+排序。\n对于候选集的召回问题，我们可以使用elastic search框架来完成;而对于排序问题，其实elastic search自带有简单的排序功能，比如说bm25。如果你想用机器学习来打分排序的话，那么就可以使用TensorFlow框架来完成模型的创建。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1592917715,"ip_address":"","comment_id":229059,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"老师，你好，请教一下Java广告引擎框架和推荐算法框架是用啥？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519672,"discussion_content":"这里可能是文中没有表述清楚。我想介绍的是标签的编码方式。可以利用高8位作为标签类型(比如兴趣标签是一大类、地理位置是一类)，然后每类的标签类型下面，会有多个具体的标签内容，比如说兴趣类型下面，不同的兴趣标签(如体育、购物、读书等)就可以用低24位进行编码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622900431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554347,"discussion_content":"另外一个思路：当定向条件是全部的时候，冗余到每一个倒排索引中，选择区分度大的倒排索引进行求交集，区分度小的加入过滤列表，这样应该就可以满足广告的各种定向了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646354232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554345,"discussion_content":"这个问题我也想问：每个广告的设置是多个定向类型的交并集。文中讲的索引分片+倒排索引并不能解决这种广告检索的问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646353215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216869,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1589358108,"is_pvip":false,"replies":[{"id":80212,"content":"其实召回的意思我觉得挺形象的，就是在一堆的数据中，捞出一批你觉得不错的结果集合。这就是召回了。\n你理解成取出没问题，不过要注意得是从一堆数据中，取出小范围的结果。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589368545,"ip_address":"","comment_id":216869,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"这几篇不是很理解召回这个术语是什么意思，是否只搜索引擎从存储里取出网页返回给用户，或是这里的从广告库里取出广告展示给用户，就是取出的意思吗？","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494972,"discussion_content":"其实召回的意思我觉得挺形象的，就是在一堆的数据中，捞出一批你觉得不错的结果集合。这就是召回了。\n你理解成取出没问题，不过要注意得是从一堆数据中，取出小范围的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589368545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216832,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1589352429,"is_pvip":false,"replies":[{"id":80244,"content":"我理解一下，你是不是这样的意思: 再增加一个粗粒度索引(也许叫新的索引分片比较好)，这个索引中的广告设置就是“即投放PC网站又投放APP”的。\n然后你指的“两个分叉都指向这个索引”，其实可以理解为再增加一条分叉，这个分叉就代表了“即投放PC网站，又投放APP的”。而它指向的索引分片，就是前面我们构建的索引。\n这样，当PC的广告请求到来时，我们会走两个分叉，一个是“PC网站”的分叉，另一个是“新增加的“即投PC又投APP”的分叉，然后将结果合并。\n\n这样是OK的，不过你会发现流程改动较大。我们还可以有另一种改法，就是“将即投PC网站，又投APP”的广告设置同时加入到“投PC网站”和“投APP”的两个对应的索引分片中。这样，当PC的广告请求到来时，我们就可以只查询一个索引分片就可以得到正确结果了。\n你会发现，使用复制一份数据的方式，就可以让流程变简单。\n","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1589398339,"ip_address":"","comment_id":216832,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100048401,"comment_content":"对于讨论题，我的想法是另外建一个树形索引使用 ”媒体类型“ 作为树形检索节点，“PC 网站”和“APP”作为两个分叉，但是这两个分叉都指向同一个倒排索引，假定这个是粗粒度索引。之前文中提到树形索引是细粒度索引，查找的时候，在细粒度索引里找到结果集之后，然后再和粗粒度索引的结果进行归并。整体想法类似于文中提到的过滤列表方式。\n\n因为需要与细粒度索引里找到结果集进行合并，所以需要分别加载到不同服务器上效果比较好，因为不同服务器处理的细粒度索引查询请求不同。","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494972,"discussion_content":"其实召回的意思我觉得挺形象的，就是在一堆的数据中，捞出一批你觉得不错的结果集合。这就是召回了。\n你理解成取出没问题，不过要注意得是从一堆数据中，取出小范围的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589368545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318945,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1635488103,"is_pvip":false,"replies":[{"id":116700,"content":"在第十一讲中，有详细介绍如何使用tf-idf进行打分排序的","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1636815451,"ip_address":"","comment_id":318945,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"使用TF-IDF 如何算区分度是否低，这点不是很了解","like_count":0},{"had_liked":false,"id":248081,"user_name":"企鹅","can_delete":false,"product_type":"c1","uid":1498369,"ip_address":"","ucode":"AE29B98E5B4497","user_header":"https://static001.geekbang.org/account/avatar/00/16/dd/01/803f3750.jpg","comment_is_top":false,"comment_ctime":1600003240,"is_pvip":false,"replies":[{"id":91195,"content":"你说的很对，广告引擎和推荐引擎往往都是自研或者使用elastic search的。这样索引都在内存中，比磁盘上的MySQL会快许多。而且检索排序等环节也可以根据需要进行灵活调整。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1600072532,"ip_address":"","comment_id":248081,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师，有个疑惑点，看到广告引擎召回广告，以及精细化推荐，感觉用mysql这类的关系型数据库不太好实现，通过elastic search更方便实现","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529438,"discussion_content":"在第十一讲中，有详细介绍如何使用tf-idf进行打分排序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636815451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243203,"user_name":"造梦师","can_delete":false,"product_type":"c1","uid":1983429,"ip_address":"","ucode":"705FCED828DC71","user_header":"https://static001.geekbang.org/account/avatar/00/1e/43/c5/288c59ab.jpg","comment_is_top":false,"comment_ctime":1597992139,"is_pvip":false,"replies":[{"id":89731,"content":"各种检索条件如果都提前组合好，然后放在索引中作为组合key，这种做法由于组合的量级很大，空间开销的确很高。\n因此，合理的做法可以参考加餐1中的方案，仅将常见的组合作为组合key加入到索引中，这样就能降低组合的数量，又能加快查询。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1598178379,"ip_address":"","comment_id":243203,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"各种条件组合都进行索引构建的开销是不是太高了，虽然确实会加快查询","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505562,"discussion_content":"你说的很对，广告引擎和推荐引擎往往都是自研或者使用elastic search的。这样索引都在内存中，比磁盘上的MySQL会快许多。而且检索排序等环节也可以根据需要进行灵活调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600072532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385813,"user_name":"像少年样飞驰","can_delete":false,"product_type":"c1","uid":1115033,"ip_address":"上海","ucode":"494E9FBA0648D4","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/99/d7737b19.jpg","comment_is_top":false,"comment_ctime":1703428476,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"你好，关于广告系统架构这一块 有什么推荐的资料学习吗 谢谢","like_count":0},{"had_liked":false,"id":334712,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1645087734,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师，树形检索的方式，是不是会存在只能沿着树多标签查询（比如图中的媒体类型是App &amp; 性别是男性的广告），没办法直接检索叶子标签啊（比如只想定向给男性用户）","like_count":0},{"had_liked":false,"id":323824,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1638175879,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"索引分片这块会出现分片大小不均匀的情况，有的分片很大，有的分片很小。比如媒体类型:APP占比百分之80，媒体类型：WAP占比百分之10，媒体类型：WAP占比百分之10.这样APP标签值得分片可能就很大了。 其他两种就很小了。。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504218,"discussion_content":"各种检索条件如果都提前组合好，然后放在索引中作为组合key，这种做法由于组合的量级很大，空间开销的确很高。\n因此，合理的做法可以参考加餐1中的方案，仅将常见的组合作为组合key加入到索引中，这样就能降低组合的数量，又能加快查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598178379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318945,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1635488103,"is_pvip":false,"replies":[{"id":116700,"content":"在第十一讲中，有详细介绍如何使用tf-idf进行打分排序的","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1636815451,"ip_address":"","comment_id":318945,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"使用TF-IDF 如何算区分度是否低，这点不是很了解","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529438,"discussion_content":"在第十一讲中，有详细介绍如何使用tf-idf进行打分排序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636815451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248081,"user_name":"企鹅","can_delete":false,"product_type":"c1","uid":1498369,"ip_address":"","ucode":"AE29B98E5B4497","user_header":"https://static001.geekbang.org/account/avatar/00/16/dd/01/803f3750.jpg","comment_is_top":false,"comment_ctime":1600003240,"is_pvip":false,"replies":[{"id":91195,"content":"你说的很对，广告引擎和推荐引擎往往都是自研或者使用elastic search的。这样索引都在内存中，比磁盘上的MySQL会快许多。而且检索排序等环节也可以根据需要进行灵活调整。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1600072532,"ip_address":"","comment_id":248081,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师，有个疑惑点，看到广告引擎召回广告，以及精细化推荐，感觉用mysql这类的关系型数据库不太好实现，通过elastic search更方便实现","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505562,"discussion_content":"你说的很对，广告引擎和推荐引擎往往都是自研或者使用elastic search的。这样索引都在内存中，比磁盘上的MySQL会快许多。而且检索排序等环节也可以根据需要进行灵活调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600072532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243203,"user_name":"造梦师","can_delete":false,"product_type":"c1","uid":1983429,"ip_address":"","ucode":"705FCED828DC71","user_header":"https://static001.geekbang.org/account/avatar/00/1e/43/c5/288c59ab.jpg","comment_is_top":false,"comment_ctime":1597992139,"is_pvip":false,"replies":[{"id":89731,"content":"各种检索条件如果都提前组合好，然后放在索引中作为组合key，这种做法由于组合的量级很大，空间开销的确很高。\n因此，合理的做法可以参考加餐1中的方案，仅将常见的组合作为组合key加入到索引中，这样就能降低组合的数量，又能加快查询。","user_name":"作者回复","user_name_real":"陈东","uid":1165703,"ctime":1598178379,"ip_address":"","comment_id":243203,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"各种条件组合都进行索引构建的开销是不是太高了，虽然确实会加快查询","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504218,"discussion_content":"各种检索条件如果都提前组合好，然后放在索引中作为组合key，这种做法由于组合的量级很大，空间开销的确很高。\n因此，合理的做法可以参考加餐1中的方案，仅将常见的组合作为组合key加入到索引中，这样就能降低组合的数量，又能加快查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598178379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385813,"user_name":"像少年样飞驰","can_delete":false,"product_type":"c1","uid":1115033,"ip_address":"上海","ucode":"494E9FBA0648D4","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/99/d7737b19.jpg","comment_is_top":false,"comment_ctime":1703428476,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"你好，关于广告系统架构这一块 有什么推荐的资料学习吗 谢谢","like_count":0},{"had_liked":false,"id":334712,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1645087734,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"老师，树形检索的方式，是不是会存在只能沿着树多标签查询（比如图中的媒体类型是App &amp; 性别是男性的广告），没办法直接检索叶子标签啊（比如只想定向给男性用户）","like_count":0},{"had_liked":false,"id":323824,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1638175879,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100048401,"comment_content":"索引分片这块会出现分片大小不均匀的情况，有的分片很大，有的分片很小。比如媒体类型:APP占比百分之80，媒体类型：WAP占比百分之10，媒体类型：WAP占比百分之10.这样APP标签值得分片可能就很大了。 其他两种就很小了。。","like_count":0}]}