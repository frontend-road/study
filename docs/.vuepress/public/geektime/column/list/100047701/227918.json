{"id":227918,"title":"20 | Spring框架：框架帮我们做了很多工作也带来了复杂度","content":"<p>你好，我是朱晔。今天，我们聊聊Spring框架给业务代码带来的复杂度，以及与之相关的坑。</p><p>在上一讲，通过AOP实现统一的监控组件的案例，我们看到了IoC和AOP配合使用的威力：当对象由Spring容器管理成为Bean之后，我们不但可以通过容器管理配置Bean的属性，还可以方便地对感兴趣的方法做AOP。</p><p>不过，前提是对象必须是Bean。你可能会觉得这个结论很明显，也很容易理解啊。但就和上一讲提到的Bean默认是单例一样，理解起来简单，实践的时候却非常容易踩坑。其中原因，一方面是，理解Spring的体系结构和使用方式有一定曲线；另一方面是，Spring多年发展堆积起来的内部结构非常复杂，这也是更重要的原因。</p><p>在我看来，Spring框架内部的复杂度主要表现为三点：</p><ul>\n<li>第一，Spring框架借助IoC和AOP的功能，实现了修改、拦截Bean的定义和实例的灵活性，因此真正执行的代码流程并不是串行的。</li>\n<li>第二，Spring Boot根据当前依赖情况实现了自动配置，虽然省去了手动配置的麻烦，但也因此多了一些黑盒、提升了复杂度。</li>\n<li>第三，Spring Cloud模块多版本也多，Spring Boot 1.x和2.x的区别也很大。如果要对Spring Cloud或Spring Boot进行二次开发的话，考虑兼容性的成本会很高。</li>\n</ul><!-- [[[read_end]]] --><p>今天，我们就通过配置AOP切入Spring Cloud Feign组件失败、Spring Boot程序的文件配置被覆盖这两个案例，感受一下Spring的复杂度。我希望这一讲的内容，能帮助你面对Spring这个复杂框架出现的问题时，可以非常自信地找到解决方案。</p><h2>Feign AOP切不到的诡异案例</h2><p>我曾遇到过这么一个案例：使用Spring Cloud做微服务调用，为方便统一处理Feign，想到了用AOP实现，即使用within指示器匹配feign.Client接口的实现进行AOP切入。</p><p>代码如下，通过@Before注解在执行方法前打印日志，并在代码中定义了一个标记了@FeignClient注解的Client类，让其成为一个Feign接口：</p><pre><code>//测试Feign\n@FeignClient(name = &quot;client&quot;)\npublic interface Client {\n    @GetMapping(&quot;/feignaop/server&quot;)\n    String api();\n}\n\n//AOP切入feign.Client的实现\n@Aspect\n@Slf4j\n@Component\npublic class WrongAspect {\n    @Before(&quot;within(feign.Client+)&quot;)\n    public void before(JoinPoint pjp) {\n        log.info(&quot;within(feign.Client+) pjp {}, args:{}&quot;, pjp, pjp.getArgs());\n    }\n}\n\n//配置扫描Feign\n@Configuration\n@EnableFeignClients(basePackages = &quot;org.geekbang.time.commonmistakes.spring.demo4.feign&quot;)\npublic class Config {\n}\n</code></pre><p>通过Feign调用服务后可以看到日志中有输出，的确实现了feign.Client的切入，切入的是execute方法：</p><pre><code>[15:48:32.850] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.WrongAspect        :20  ] - within(feign.Client+) pjp execution(Response feign.Client.execute(Request,Options)), args:[GET http://client/feignaop/server HTTP/1.1\n\nBinary data, feign.Request$Options@5c16561a]\n</code></pre><p>一开始这个项目使用的是客户端的负载均衡，也就是让Ribbon来做负载均衡，代码没啥问题。后来因为后端服务通过Nginx实现服务端负载均衡，所以开发同学把@FeignClient的配置设置了URL属性，直接通过一个固定URL调用后端服务：</p><pre><code>@FeignClient(name = &quot;anotherClient&quot;,url = &quot;http://localhost:45678&quot;)\npublic interface ClientWithUrl {\n    @GetMapping(&quot;/feignaop/server&quot;)\n    String api();\n}\n</code></pre><p>但这样配置后，之前的AOP切面竟然失效了，也就是within(feign.Client+)无法切入ClientWithUrl的调用了。</p><p>为了还原这个场景，我写了一段代码，定义两个方法分别通过Client和ClientWithUrl这两个Feign进行接口调用：</p><pre><code>@Autowired\nprivate Client client;\n\n@Autowired\nprivate ClientWithUrl clientWithUrl;\n\n@GetMapping(&quot;client&quot;)\npublic String client() {\n    return client.api();\n}\n\n@GetMapping(&quot;clientWithUrl&quot;)\npublic String clientWithUrl() {\n    return clientWithUrl.api();\n}\n</code></pre><p>可以看到，调用Client后AOP有日志输出，调用ClientWithUrl后却没有：</p><pre><code>[15:50:32.850] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.WrongAspect        :20  ] - within(feign.Client+) pjp execution(Response feign.Client.execute(Request,Options)), args:[GET http://client/feignaop/server HTTP/1.1\n\nBinary data, feign.Request$Options@5c16561\n</code></pre><p>这就很费解了。难道为Feign指定了URL，其实现就不是feign.Clinet了吗？</p><p>要明白原因，我们需要分析一下FeignClient的创建过程，也就是分析FeignClientFactoryBean类的getTarget方法。源码第4行有一个if判断，当URL没有内容也就是为空或者不配置时调用loadBalance方法，在其内部通过FeignContext从容器获取feign.Client的实例：</p><pre><code>&lt;T&gt; T getTarget() {\n\tFeignContext context = this.applicationContext.getBean(FeignContext.class);\n\tFeign.Builder builder = feign(context);\n\tif (!StringUtils.hasText(this.url)) {\n\t\t...\n\t\treturn (T) loadBalance(builder, context,\n\t\t\t\tnew HardCodedTarget&lt;&gt;(this.type, this.name, this.url));\n\t}\n\t...\n\tString url = this.url + cleanPath();\n\tClient client = getOptional(context, Client.class);\n\tif (client != null) {\n\t\tif (client instanceof LoadBalancerFeignClient) {\n\t\t\t// not load balancing because we have a url,\n\t\t\t// but ribbon is on the classpath, so unwrap\n\t\t\tclient = ((LoadBalancerFeignClient) client).getDelegate();\n\t\t}\n\t\tbuilder.client(client);\n\t}\n\t...\n}\nprotected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,\n\t\tHardCodedTarget&lt;T&gt; target) {\n\tClient client = getOptional(context, Client.class);\n\tif (client != null) {\n\t\tbuilder.client(client);\n\t\tTargeter targeter = get(context, Targeter.class);\n\t\treturn targeter.target(this, builder, context, target);\n\t}\n...\n}\nprotected &lt;T&gt; T getOptional(FeignContext context, Class&lt;T&gt; type) {\n\treturn context.getInstance(this.contextId, type);\n}\n</code></pre><p>调试一下可以看到，client是LoadBalanceFeignClient，已经是经过代理增强的，明显是一个Bean：</p><p><img src=\"https://static001.geekbang.org/resource/image/05/fd/0510e28cd764aaf7f1b4b4ca03049ffd.png?wh=2310*924\" alt=\"\"></p><p>所以，没有指定URL的@FeignClient对应的LoadBalanceFeignClient，是可以通过feign.Client切入的。</p><p>在我们上面贴出来的源码的16行可以看到，当URL不为空的时候，client设置为了LoadBalanceFeignClient的delegate属性。其原因注释中有提到，因为有了URL就不需要客户端负载均衡了，但因为Ribbon在classpath中，所以需要从LoadBalanceFeignClient提取出真正的Client。断点调试下可以看到，这时client是一个ApacheHttpClient：</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/30/1b872a900be7327f74bc09bde4c54230.png?wh=2306*1126\" alt=\"\"></p><p>那么，这个ApacheHttpClient是从哪里来的呢？这里，我教你一个小技巧：如果你希望知道一个类是怎样调用栈初始化的，可以在构造方法中设置一个断点进行调试。这样，你就可以在IDE的栈窗口看到整个方法调用栈，然后点击每一个栈帧看到整个过程。</p><p>用这种方式，我们可以看到，是HttpClientFeignLoadBalancedConfiguration类实例化的ApacheHttpClient：</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/9a/7b712acf6d7062ae82f1fd04b954ff9a.png?wh=3020*1908\" alt=\"\"></p><p>进一步查看HttpClientFeignLoadBalancedConfiguration的源码可以发现，LoadBalancerFeignClient这个Bean在实例化的时候，new出来一个ApacheHttpClient作为delegate放到了LoadBalancerFeignClient中：</p><pre><code>@Bean\n@ConditionalOnMissingBean(Client.class)\npublic Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,\n      SpringClientFactory clientFactory, HttpClient httpClient) {\n   ApacheHttpClient delegate = new ApacheHttpClient(httpClient);\n   return new LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);\n}\n\npublic LoadBalancerFeignClient(Client delegate,\n      CachingSpringLoadBalancerFactory lbClientFactory,\n      SpringClientFactory clientFactory) {\n   this.delegate = delegate;\n   this.lbClientFactory = lbClientFactory;\n   this.clientFactory = clientFactory;\n}\n</code></pre><p>显然，ApacheHttpClient是new出来的，并不是Bean，而LoadBalancerFeignClient是一个Bean。</p><p>有了这个信息，我们再来捋一下，为什么within(feign.Client+)无法切入设置过URL的@FeignClient ClientWithUrl：</p><ul>\n<li>表达式声明的是切入feign.Client的实现类。</li>\n<li>Spring只能切入由自己管理的Bean。</li>\n<li><strong>虽然LoadBalancerFeignClient和ApacheHttpClient都是feign.Client接口的实现，但是HttpClientFeignLoadBalancedConfiguration的自动配置只是把前者定义为Bean，后者是new出来的、作为了LoadBalancerFeignClient的delegate，不是Bean</strong>。</li>\n<li>在定义了FeignClient的URL属性后，我们获取的是LoadBalancerFeignClient的delegate，它不是Bean。</li>\n</ul><p>因此，定义了URL的FeignClient采用within(feign.Client+)无法切入。</p><p>那，如何解决这个问题呢？有一位同学提出，修改一下切点表达式，通过@FeignClient注解来切：</p><pre><code>@Before(&quot;@within(org.springframework.cloud.openfeign.FeignClient)&quot;)\npublic void before(JoinPoint pjp){\n    log.info(&quot;@within(org.springframework.cloud.openfeign.FeignClient) pjp {}, args:{}&quot;, pjp, pjp.getArgs());\n}\n</code></pre><p>修改后通过日志看到，AOP的确切成功了：</p><pre><code>[15:53:39.093] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.spring.demo4.Wrong2Aspect       :17  ] - @within(org.springframework.cloud.openfeign.FeignClient) pjp execution(String org.geekbang.time.commonmistakes.spring.demo4.feign.ClientWithUrl.api()), args:[]\n</code></pre><p>但仔细一看就会发现，<strong>这次切入的是ClientWithUrl接口的API方法，并不是client.Feign接口的execute方法，显然不符合预期</strong>。</p><p>这位同学犯的错误是，没有弄清楚真正希望切的是什么对象。@FeignClient注解标记在Feign Client接口上，所以切的是Feign定义的接口，也就是每一个实际的API接口。而通过feign.Client接口切的是客户端实现类，切到的是通用的、执行所有Feign调用的execute方法。</p><p>那么问题来了，ApacheHttpClient不是Bean无法切入，切Feign接口本身又不符合要求。怎么办呢？</p><p>经过一番研究发现，ApacheHttpClient其实有机会独立成为Bean。查看HttpClientFeignConfiguration的源码可以发现，当没有ILoadBalancer类型的时候，自动装配会把ApacheHttpClient设置为Bean。</p><p>这么做的原因很明确，如果我们不希望做客户端负载均衡的话，应该不会引用Ribbon组件的依赖，自然没有LoadBalancerFeignClient，只有ApacheHttpClient：</p><pre><code>@Configuration\n@ConditionalOnClass(ApacheHttpClient.class)\n@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)\n@ConditionalOnMissingBean(CloseableHttpClient.class)\n@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)\nprotected static class HttpClientFeignConfiguration {\n\t@Bean\n\t@ConditionalOnMissingBean(Client.class)\n\tpublic Client feignClient(HttpClient httpClient) {\n\t\treturn new ApacheHttpClient(httpClient);\n\t}\n}\n</code></pre><p>那，把pom.xml中的ribbon模块注释之后，是不是可以解决问题呢？</p><pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>但，问题并没解决，启动出错误了：</p><pre><code>Caused by: java.lang.IllegalArgumentException: Cannot subclass final class feign.httpclient.ApacheHttpClient\n\tat org.springframework.cglib.proxy.Enhancer.generateClass(Enhancer.java:657)\n\tat org.springframework.cglib.core.DefaultGeneratorStrategy.generate(DefaultGeneratorStrategy.java:25)\n</code></pre><p>这里，又涉及了Spring实现动态代理的两种方式：</p><ul>\n<li>JDK动态代理，通过反射实现，只支持对实现接口的类进行代理；</li>\n<li>CGLIB动态字节码注入方式，通过继承实现代理，没有这个限制。</li>\n</ul><p><strong>Spring Boot 2.x默认使用CGLIB的方式，但通过继承实现代理有个问题是，无法继承final的类。因为，ApacheHttpClient类就是定义为了final</strong>：</p><pre><code>public final class ApacheHttpClient implements Client {\n</code></pre><p>为解决这个问题，我们把配置参数proxy-target-class的值修改为false，以切换到使用JDK动态代理的方式：</p><pre><code>spring.aop.proxy-target-class=false\n</code></pre><p>修改后执行clientWithUrl接口可以看到，通过within(feign.Client+)方式可以切入feign.Client子类了。以下日志显示了@within和within的两次切入：</p><pre><code>[16:29:55.303] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.Wrong2Aspect       :16  ] - @within(org.springframework.cloud.openfeign.FeignClient) pjp execution(String org.geekbang.time.commonmistakes.spring.demo4.feign.ClientWithUrl.api()), args:[]\n[16:29:55.310] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.WrongAspect        :15  ] - within(feign.Client+) pjp execution(Response feign.Client.execute(Request,Options)), args:[GET http://localhost:45678/feignaop/server HTTP/1.1\n\n\nBinary data, feign.Request$Options@387550b0]\n</code></pre><p>这下我们就明白了，Spring Cloud使用了自动装配来根据依赖装配组件，组件是否成为Bean决定了AOP是否可以切入，在尝试通过AOP切入Spring Bean的时候要注意。</p><p>加上上一讲的两个案例，我就把IoC和AOP相关的坑点和你说清楚了。除此之外，我们在业务开发时，还有一个绕不开的点是，Spring程序的配置问题。接下来，我们就具体看看吧。</p><h2>Spring程序配置的优先级问题</h2><p>我们知道，通过配置文件application.properties，可以实现Spring Boot应用程序的参数配置。但我们可能不知道的是，Spring程序配置是有优先级的，即当两个不同的配置源包含相同的配置项时，其中一个配置项很可能会被覆盖掉。这，也是为什么我们会遇到些看似诡异的配置失效问题。</p><p>我们来通过一个实际案例，研究下配置源以及配置源的优先级问题。</p><p>对于Spring Boot应用程序，一般我们会通过设置management.server.port参数，来暴露独立的actuator管理端口。这样做更安全，也更方便监控系统统一监控程序是否健康。</p><pre><code>management.server.port=45679\n</code></pre><p>有一天程序重新发布后，监控系统显示程序离线。但排查下来发现，程序是正常工作的，只是actuator管理端口的端口号被改了，不是配置文件中定义的45679了。</p><p>后来发现，运维同学在服务器上定义了两个环境变量MANAGEMENT_SERVER_IP和MANAGEMENT_SERVER_PORT，目的是方便监控Agent把监控数据上报到统一的管理服务上：</p><pre><code>MANAGEMENT_SERVER_IP=192.168.0.2\nMANAGEMENT_SERVER_PORT=12345\n</code></pre><p>问题就是出在这里。MANAGEMENT_SERVER_PORT覆盖了配置文件中的management.server.port，修改了应用程序本身的端口。当然，监控系统也就无法通过老的管理端口访问到应用的health端口了。如下图所示，actuator的端口号变成了12345：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/e6/b287b7ad823a39bb604fa69e02c720e6.png?wh=1278*578\" alt=\"\"></p><p>到这里坑还没完，为了方便用户登录，需要在页面上显示默认的管理员用户名，于是开发同学在配置文件中定义了一个user.name属性，并设置为defaultadminname：</p><pre><code>user.name=defaultadminname\n</code></pre><p>后来发现，程序读取出来的用户名根本就不是配置文件中定义的。这，又是咋回事？</p><p>带着这个问题，以及之前环境变量覆盖配置文件配置的问题，我们写段代码看看，从Spring中到底能读取到几个management.server.port和user.name配置项。</p><p>要想查询Spring中所有的配置，我们需要以环境Environment接口为入口。接下来，我就与你说说Spring通过环境Environment抽象出的Property和Profile：</p><ul>\n<li>针对Property，又抽象出各种PropertySource类代表配置源。一个环境下可能有多个配置源，每个配置源中有诸多配置项。在查询配置信息时，需要按照配置源优先级进行查询。</li>\n<li>Profile定义了场景的概念。通常，我们会定义类似dev、test、stage和prod等环境作为不同的Profile，用于按照场景对Bean进行逻辑归属。同时，Profile和配置文件也有关系，每个环境都有独立的配置文件，但我们只会激活某一个环境来生效特定环境的配置文件。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/2c/c0/2c68da94d31182cad34c965f878196c0.png?wh=1302*1104\" alt=\"\"></p><p>接下来，我们重点看看Property的查询过程。</p><p>对于非Web应用，Spring对于Environment接口的实现是StandardEnvironment类。我们通过Spring注入StandardEnvironment后循环getPropertySources获得的PropertySource，来查询所有的PropertySource中key是user.name或management.server.port的属性值；然后遍历getPropertySources方法，获得所有配置源并打印出来：</p><pre><code>@Autowired\nprivate StandardEnvironment env;\n@PostConstruct\npublic void init(){\n    Arrays.asList(&quot;user.name&quot;, &quot;management.server.port&quot;).forEach(key -&gt; {\n         env.getPropertySources().forEach(propertySource -&gt; {\n                    if (propertySource.containsProperty(key)) {\n                        log.info(&quot;{} -&gt; {} 实际取值：{}&quot;, propertySource, propertySource.getProperty(key), env.getProperty(key));\n                    }\n                });\n    });\n\n    System.out.println(&quot;配置优先级：&quot;);\n    env.getPropertySources().stream().forEach(System.out::println);\n}\n</code></pre><p>我们研究下输出的日志：</p><pre><code>2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : ConfigurationPropertySourcesPropertySource {name='configurationProperties'} -&gt; zhuye 实际取值：zhuye\n2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : PropertiesPropertySource {name='systemProperties'} -&gt; zhuye 实际取值：zhuye\n2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : OriginTrackedMapPropertySource {name='applicationConfig: [classpath:/application.properties]'} -&gt; defaultadminname 实际取值：zhuye\n2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : ConfigurationPropertySourcesPropertySource {name='configurationProperties'} -&gt; 12345 实际取值：12345\n2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : OriginAwareSystemEnvironmentPropertySource {name=''} -&gt; 12345 实际取值：12345\n2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : OriginTrackedMapPropertySource {name='applicationConfig: [classpath:/application.properties]'} -&gt; 45679 实际取值：12345\n配置优先级：\nConfigurationPropertySourcesPropertySource {name='configurationProperties'}\nStubPropertySource {name='servletConfigInitParams'}\nServletContextPropertySource {name='servletContextInitParams'}\nPropertiesPropertySource {name='systemProperties'}\nOriginAwareSystemEnvironmentPropertySource {name='systemEnvironment'}\nRandomValuePropertySource {name='random'}\nOriginTrackedMapPropertySource {name='applicationConfig: [classpath:/application.properties]'}\nMapPropertySource {name='springCloudClientHostInfo'}\nMapPropertySource {name='defaultProperties'}\n</code></pre><ul>\n<li>有三处定义了user.name：第一个是configurationProperties，值是zhuye；第二个是systemProperties，代表系统配置，值是zhuye；第三个是applicationConfig，也就是我们的配置文件，值是配置文件中定义的defaultadminname。</li>\n<li>同样地，也有三处定义了management.server.port：第一个是configurationProperties，值是12345；第二个是systemEnvironment代表系统环境，值是12345；第三个是applicationConfig，也就是我们的配置文件，值是配置文件中定义的45679。</li>\n<li>第7到16行的输出显示，Spring中有9个配置源，值得关注是ConfigurationPropertySourcesPropertySource、PropertiesPropertySource、OriginAwareSystemEnvironmentPropertySource和我们的配置文件。</li>\n</ul><p>那么，Spring真的是按这个顺序查询配置吗？最前面的configurationProperties，又是什么？为了回答这2个问题，我们需要分析下源码。我先说明下，下面源码分析的逻辑有些复杂，你可以结合着下面的整体流程图来理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/f9/3e6dc6456f6d1354da58fb260775c0f9.png?wh=2064*1450\" alt=\"\"></p><p>Demo中注入的StandardEnvironment，继承的是AbstractEnvironment（图中紫色类）。AbstractEnvironment的源码如下：</p><pre><code>public abstract class AbstractEnvironment implements ConfigurableEnvironment {\n\tprivate final MutablePropertySources propertySources = new MutablePropertySources();\n\tprivate final ConfigurablePropertyResolver propertyResolver =\n\t\t\tnew PropertySourcesPropertyResolver(this.propertySources);\n\n\tpublic String getProperty(String key) {\n\t\treturn this.propertyResolver.getProperty(key);\n\t}\n}\n</code></pre><p>可以看到：</p><ul>\n<li>MutablePropertySources类型的字段propertySources，看起来代表了所有配置源；</li>\n<li>getProperty方法，通过PropertySourcesPropertyResolver类进行查询配置；</li>\n<li>实例化PropertySourcesPropertyResolver的时候，传入了当前的MutablePropertySources。</li>\n</ul><p>接下来，我们继续分析MutablePropertySources和PropertySourcesPropertyResolver。先看看MutablePropertySources的源码（图中蓝色类）：</p><pre><code>public class MutablePropertySources implements PropertySources {\n\n\tprivate final List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = new CopyOnWriteArrayList&lt;&gt;();\n\n\tpublic void addFirst(PropertySource&lt;?&gt; propertySource) {\n\t\tremoveIfPresent(propertySource);\n\t\tthis.propertySourceList.add(0, propertySource);\n\t}\n\tpublic void addLast(PropertySource&lt;?&gt; propertySource) {\n\t\tremoveIfPresent(propertySource);\n\t\tthis.propertySourceList.add(propertySource);\n\t}\n\tpublic void addBefore(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource) {\n\t\t...\n\t\tint index = assertPresentAndGetIndex(relativePropertySourceName);\n\t\taddAtIndex(index, propertySource);\n\t}\n    public void addAfter(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource) {\n       ...\n       int index = assertPresentAndGetIndex(relativePropertySourceName);\n       addAtIndex(index + 1, propertySource);\n    }\n    private void addAtIndex(int index, PropertySource&lt;?&gt; propertySource) {\n       removeIfPresent(propertySource);\n       this.propertySourceList.add(index, propertySource);\n    }\n}\n</code></pre><p>可以发现：</p><ul>\n<li>propertySourceList字段用来真正保存PropertySource的List，且这个List是一个CopyOnWriteArrayList。</li>\n<li>类中定义了addFirst、addLast、addBefore、addAfter等方法，来精确控制PropertySource加入propertySourceList的顺序。这也说明了顺序的重要性。</li>\n</ul><p>继续看下PropertySourcesPropertyResolver（图中绿色类）的源码，找到真正查询配置的方法getProperty。</p><p>这里，我们重点看一下第9行代码：遍历的propertySources是PropertySourcesPropertyResolver构造方法传入的，再结合AbstractEnvironment的源码可以发现，这个propertySources正是AbstractEnvironment中的MutablePropertySources对象。遍历时，如果发现配置源中有对应的Key值，则使用这个值。因此，MutablePropertySources中配置源的次序尤为重要。</p><pre><code>public class PropertySourcesPropertyResolver extends AbstractPropertyResolver {\n\tprivate final PropertySources propertySources;\n\tpublic PropertySourcesPropertyResolver(@Nullable PropertySources propertySources) {\n\t\tthis.propertySources = propertySources;\n\t}\n\t\n\tprotected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) {\n\t\tif (this.propertySources != null) {\n\t\t\tfor (PropertySource&lt;?&gt; propertySource : this.propertySources) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(&quot;Searching for key '&quot; + key + &quot;' in PropertySource '&quot; +\n\t\t\t\t\t\t\tpropertySource.getName() + &quot;'&quot;);\n\t\t\t\t}\n\t\t\t\tObject value = propertySource.getProperty(key);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tif (resolveNestedPlaceholders &amp;&amp; value instanceof String) {\n\t\t\t\t\t\tvalue = resolveNestedPlaceholders((String) value);\n\t\t\t\t\t}\n\t\t\t\t\tlogKeyFound(key, propertySource, value);\n\t\t\t\t\treturn convertValueIfNecessary(value, targetValueType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t...\n\t}\n}\n</code></pre><p>回到之前的问题，在查询所有配置源的时候，我们注意到处在第一位的是ConfigurationPropertySourcesPropertySource，这是什么呢？</p><p>其实，它不是一个实际存在的配置源，扮演的是一个代理的角色。但通过调试你会发现，我们获取的值竟然是由它提供并且返回的，且没有循环遍历后面的PropertySource：</p><p><img src=\"https://static001.geekbang.org/resource/image/73/fb/7380c93e743e3fc41d8cc58b77895bfb.png?wh=2388*1140\" alt=\"\"></p><p>继续查看ConfigurationPropertySourcesPropertySource（图中红色类）的源码可以发现，getProperty方法其实是通过findConfigurationProperty方法查询配置的。如第25行代码所示，这其实还是在遍历所有的配置源：</p><pre><code>class ConfigurationPropertySourcesPropertySource extends PropertySource&lt;Iterable&lt;ConfigurationPropertySource&gt;&gt;\n\t\timplements OriginLookup&lt;String&gt; {\n\n\tConfigurationPropertySourcesPropertySource(String name, Iterable&lt;ConfigurationPropertySource&gt; source) {\n\t\tsuper(name, source);\n\t}\n\n\t@Override\n\tpublic Object getProperty(String name) {\n\t\tConfigurationProperty configurationProperty = findConfigurationProperty(name);\n\t\treturn (configurationProperty != null) ? configurationProperty.getValue() : null;\n\t}\n\tprivate ConfigurationProperty findConfigurationProperty(String name) {\n\t\ttry {\n\t\t\treturn findConfigurationProperty(ConfigurationPropertyName.of(name, true));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\tprivate ConfigurationProperty findConfigurationProperty(ConfigurationPropertyName name) {\n\t\tif (name == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (ConfigurationPropertySource configurationPropertySource : getSource()) {\n\t\t\tConfigurationProperty configurationProperty = configurationPropertySource.getConfigurationProperty(name);\n\t\t\tif (configurationProperty != null) {\n\t\t\t\treturn configurationProperty;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n</code></pre><p>调试可以发现，这个循环遍历（getSource()的结果）的配置源，其实是SpringConfigurationPropertySources（图中黄色类），其中包含的配置源列表就是之前看到的9个配置源，而第一个就是ConfigurationPropertySourcesPropertySource。看到这里，我们的第一感觉是会不会产生死循环，它在遍历的时候怎么排除自己呢？</p><p>同时观察configurationProperty可以看到，这个ConfigurationProperty其实类似代理的角色，实际配置是从系统属性中获得的：</p><p><img src=\"https://static001.geekbang.org/resource/image/95/0a/9551d5b5acada84262b7ddeae989750a.png?wh=2422*1564\" alt=\"\"></p><p>继续查看SpringConfigurationPropertySources可以发现，它返回的迭代器是内部类SourcesIterator，在fetchNext方法获取下一个项时，通过isIgnored方法排除了ConfigurationPropertySourcesPropertySource（源码第38行）：</p><pre><code>class SpringConfigurationPropertySources implements Iterable&lt;ConfigurationPropertySource&gt; {\n\n\tprivate final Iterable&lt;PropertySource&lt;?&gt;&gt; sources;\n\tprivate final Map&lt;PropertySource&lt;?&gt;, ConfigurationPropertySource&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;(16,\n\t\t\tReferenceType.SOFT);\n\n\tSpringConfigurationPropertySources(Iterable&lt;PropertySource&lt;?&gt;&gt; sources) {\n\t\tAssert.notNull(sources, &quot;Sources must not be null&quot;);\n\t\tthis.sources = sources;\n\t}\n\n\t@Override\n\tpublic Iterator&lt;ConfigurationPropertySource&gt; iterator() {\n\t\treturn new SourcesIterator(this.sources.iterator(), this::adapt);\n\t}\n\n\tprivate static class SourcesIterator implements Iterator&lt;ConfigurationPropertySource&gt; {\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn fetchNext() != null;\n\t\t}\n\n\t\tprivate ConfigurationPropertySource fetchNext() {\n\t\t\tif (this.next == null) {\n\t\t\t\tif (this.iterators.isEmpty()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (!this.iterators.peek().hasNext()) {\n\t\t\t\t\tthis.iterators.pop();\n\t\t\t\t\treturn fetchNext();\n\t\t\t\t}\n\t\t\t\tPropertySource&lt;?&gt; candidate = this.iterators.peek().next();\n\t\t\t\tif (candidate.getSource() instanceof ConfigurableEnvironment) {\n\t\t\t\t\tpush((ConfigurableEnvironment) candidate.getSource());\n\t\t\t\t\treturn fetchNext();\n\t\t\t\t}\n\t\t\t\tif (isIgnored(candidate)) {\n\t\t\t\t\treturn fetchNext();\n\t\t\t\t}\n\t\t\t\tthis.next = this.adapter.apply(candidate);\n\t\t\t}\n\t\t\treturn this.next;\n\t\t}\n\n\n\t\tprivate void push(ConfigurableEnvironment environment) {\n\t\t\tthis.iterators.push(environment.getPropertySources().iterator());\n\t\t}\n\n\n\t\tprivate boolean isIgnored(PropertySource&lt;?&gt; candidate) {\n\t\t\treturn (candidate instanceof StubPropertySource\n\t\t\t\t\t|| candidate instanceof ConfigurationPropertySourcesPropertySource);\n\t\t}\n\t}\n}\n</code></pre><p>我们已经了解了ConfigurationPropertySourcesPropertySource是所有配置源中的第一个，实现了对PropertySourcesPropertyResolver中遍历逻辑的“劫持”，并且知道了其遍历逻辑。最后一个问题是，它如何让自己成为第一个配置源呢？</p><p>再次运用之前我们学到的那个小技巧，来查看实例化ConfigurationPropertySourcesPropertySource的地方：</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/5d/f43c15a2f491d88a0383023a42cebd5d.png?wh=2844*1318\" alt=\"\"></p><p>可以看到，ConfigurationPropertySourcesPropertySource类是由ConfigurationPropertySources的attach方法实例化的。查阅源码可以发现，这个方法的确从环境中获得了原始的MutablePropertySources，把自己加入成为一个元素：</p><pre><code>public final class ConfigurationPropertySources {\n\tpublic static void attach(Environment environment) {\n\t\tMutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();\n\t\tPropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);\n\t\tif (attached == null) {\n\t\t\tsources.addFirst(new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME,\n\t\t\t\t\tnew SpringConfigurationPropertySources(sources)));\n\t\t}\n\t}\n}\n</code></pre><p>而这个attach方法，是Spring应用程序启动时准备环境的时候调用的。在SpringApplication的run方法中调用了prepareEnvironment方法，然后又调用了ConfigurationPropertySources.attach方法：</p><pre><code>public class SpringApplication {\n\npublic ConfigurableApplicationContext run(String... args) {\n\t\t...\n\t\ttry {\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n\t\t\tConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n\t\t\t...\n\t}\n\tprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,\n\t\t\tApplicationArguments applicationArguments) {\n\t\t...\n\t\tConfigurationPropertySources.attach(environment);\n\t\t...\n    }\n}\n</code></pre><p>看到这里你是否彻底理清楚Spring劫持PropertySourcesPropertyResolver的实现方式，以及配置源有优先级的原因了呢？如果你想知道Spring各种预定义的配置源的优先级，可以参考<a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\">官方文档</a>。</p><h2>重点回顾</h2><p>今天，我用两个业务开发中的实际案例，带你进一步学习了Spring的AOP和配置优先级这两大知识点。现在，你应该也感受到Spring实现的复杂度了。</p><p>对于AOP切Feign的案例，我们在实现功能时走了一些弯路。Spring Cloud会使用Spring Boot的特性，根据当前引入包的情况做各种自动装配。如果我们要扩展Spring的组件，那么只有清晰了解Spring自动装配的运作方式，才能鉴别运行时对象在Spring容器中的情况，不能想当然认为代码中能看到的所有Spring的类都是Bean。</p><p>对于配置优先级的案例，分析配置源优先级时，如果我们以为看到PropertySourcesPropertyResolver就看到了真相，后续进行扩展开发时就可能会踩坑。我们一定要注意，<strong>分析Spring源码时，你看到的表象不一定是实际运行时的情况，还需要借助日志或调试工具来理清整个过程</strong>。如果没有调试工具，你可以借助<a href=\"https://time.geekbang.org/column/article/216830\">第11讲</a>用到的Arthas，来分析代码调用路径。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>除了我们这两讲用到execution、within、@within、@annotation四个指示器外，Spring AOP还支持this、target、args、@target、@args。你能说说后面五种指示器的作用吗？</li>\n<li>Spring的Environment中的PropertySources属性可以包含多个PropertySource，越往前优先级越高。那，我们能否利用这个特点实现配置文件中属性值的自动赋值呢？比如，我们可以定义%%MYSQL.URL%%、%%MYSQL.USERNAME%%和%%MYSQL.PASSWORD%%，分别代表数据库连接字符串、用户名和密码。在配置数据源时，我们只要设置其值为占位符，框架就可以自动根据当前应用程序名application.name，统一把占位符替换为真实的数据库信息。这样，生产的数据库信息就不需要放在配置文件中了，会更安全。</li>\n</ol><p>关于Spring Core、Spring Boot和Spring Cloud，你还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"19 | Spring框架：IoC和AOP是扩展的核心","id":227917},"right":{"article_title":"答疑篇：代码篇思考题集锦（三）","id":262560}},"comments":[{"had_liked":false,"id":212058,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1588054849,"is_pvip":true,"replies":[{"id":"78831","content":"第二个问题，我给了我的实现：https:&#47;&#47;github.com&#47;JosephZhu1983&#47;java-common-mistakes&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;org&#47;geekbang&#47;time&#47;commonmistakes&#47;springpart2&#47;custompropertysource","user_name":"作者回复","comment_id":212058,"uid":"1001470","ip_address":"","utype":1,"ctime":1588056454,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"9.2233721544068997e+18","product_id":100047701,"comment_content":"第一个问题：<br>切入点指示符<br>Spring AOP 支持10种切点指示符：execution、within、this、target、args、@target、@args、@within、@annotation、bean下面做下简记(没有写@Pointcut(),请注意)：<br><br>execution: 用来匹配执行方法的连接点的指示符。<br>用法相对复杂，格式如下:execution(权限访问符 返回值类型 方法所属的类名包路径.方法名(形参类型) 异常类型)<br>e.g. execution(public String com.darren.hellxz.test.Test.access(String,String))<br><br>权限修饰符和异常类型可省略，返回类型支持通配符，类名、方法名支持*通配，方法形参支持..通配<br>within: 用来限定连接点属于某个确定类型的类。<br>within(com.darren.hellxz.test.Test)<br>within(com.darren.hellxz.test.) &#47;&#47;包下类<br>within(com.darren.hellxz.test..) &#47;&#47;包下及子包下<br><br>this和target: this用于没有实现接口的Cglib代理类型，target用于实现了接口的JDK代理目标类型<br>举例：this(com.darren.hellxz.test.Foo) &#47;&#47;Foo没有实现接口，使用Cglib代理，用this<br>实现了个接口public class Foo implements Bar{...}<br>target(com.darren.hellxz.test.Test) &#47;&#47;Foo实现了接口的情况<br><br>args: 对连接点的参数类型进行限制，要求参数类型是指定类型的实例。<br>args(Long)<br><br>@target: 用于匹配类头有指定注解的连接点<br>@target(org.springframework.stereotype.Repository)<br><br>@args: 用来匹配连接点的参数的，@args指出连接点在运行时传过来的参数的类必须要有指定的注解<br><br>@Pointcut(&quot;@args(org.springframework.web.bind.annotation.RequestBody)&quot;)  <br>public void methodsAcceptingEntities() {}<br><br>@within: 指定匹配必须包括某个注解的的类里的所有连接点<br>@within(org.springframework.stereotype.Repository)<br><br>@annotation: 匹配那些有指定注解的连接点<br>@annotation(org.springframework.stereotype.Repository)<br><br>bean: 用于匹配指定Bean实例内的连接点，传入bean的id或name,支持使用*通配符<br><br>切点表达式组合<br>使用&amp;&amp;、||、!、三种运算符来组合切点表达式，表示与或非的关系<br><br>第二个问题其实不太懂，网上搜了搜，核心应该是这个方法：<br>org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(java.lang.String, java.util.Properties)<br><br>参考链接：https:&#47;&#47;www.jianshu.com&#47;p&#47;5fecf71024af","like_count":28,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493420,"discussion_content":"第二个问题，我给了我的实现：https://github.com/JosephZhu1983/java-common-mistakes/tree/master/src/main/java/org/geekbang/time/commonmistakes/springpart2/custompropertysource","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588056454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181192,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","nickname":"Seven.Lin澤耿","note":"","ucode":"4CAB732CD6F149","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263110,"discussion_content":"对于第二个问题：为什么不直接使用${}来做配置呢？这样的话就可以把配置信息放在环境变量，或者启动脚本中，也不用手写替换，交给Spring自己去处理替换（我们现在就是这么做的），然后把ip类配置改为域名，配置hosts也实现类似的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589173372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224762,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1591533450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40246239114","product_id":100047701,"comment_content":"这节课有点难度啊","like_count":9},{"had_liked":false,"id":212476,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1588130518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40242836182","product_id":100047701,"comment_content":"感觉就在等最后的解决方案，然后戛然而止了。。。","like_count":10},{"had_liked":false,"id":211881,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1588034834,"is_pvip":false,"replies":[{"id":"78716","content":"：）","user_name":"作者回复","comment_id":211881,"uid":"1001470","ip_address":"","utype":1,"ctime":1588038623,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"35947773202","product_id":100047701,"comment_content":"我也经常看框架源码，但缺失了老师的演示及溯源过程，学习到了。","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493387,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588038623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211838,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1588028758,"is_pvip":false,"replies":[{"id":"78737","content":"可以参考我文中的例子，程序启动的时候检查一下所有配置项，发现有重复配置的话发出告警","user_name":"作者回复","comment_id":211838,"uid":"1001470","ip_address":"","utype":1,"ctime":1588040492,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"27357832534","product_id":100047701,"comment_content":"1. 配置优先级的问题，理解热加载的时候仔细的看过，知道有这么回事，老师举得这个例子：开发和运维都设置了配置，然后运维的把开发的覆盖了，这种问题如果遇到了怎么查呢？如果是同一个人统一管理还好说，不同的人谁知道谁设置了什么呢？<br>2. 切面不成功的内容，我卡在了切面上。切面怎么用还不太了解。","like_count":6,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493378,"discussion_content":"可以参考我文中的例子，程序启动的时候检查一下所有配置项，发现有重复配置的话发出告警","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588040492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273559,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1610639949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905607245","product_id":100047701,"comment_content":"老师好，对于Spring aop中的args表达式我有疑问：<br>1.args可以对连接点的参数类型进行限制，要求参数类型是指定类型的实例，用法是args(类型的全限定名)。<br>2.也可以用来访问目标方法的参数，用法是args(变量名)。<br>这两种用法目前没看到在同一个地方讲到的。我想知道这两种用法对应的args是同一个args吗（虽然都叫做args）。如果是同一个的话，那spring是如何知道需要用到的是哪种用法呢？","like_count":1},{"had_liked":false,"id":236600,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1595475015,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5890442311","product_id":100047701,"comment_content":"源码之下无秘密，但是看源码挑战了一个程序员的心境，需要耐心，细心，恒心，给自己加油","like_count":1},{"had_liked":false,"id":219495,"user_name":"招财","can_delete":false,"product_type":"c1","uid":1249970,"ip_address":"","ucode":"8A6781148A9932","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/b2/3fb9a4a1.jpg","comment_is_top":false,"comment_ctime":1590032349,"is_pvip":false,"replies":[{"id":"81081","content":"spring.http.encoding.charset=UTF-8<br>spring.http.encoding.force=true<br>spring.http.encoding.enabled=true<br>试过吗？","user_name":"作者回复","comment_id":219495,"uid":"1001470","ip_address":"","utype":1,"ctime":1590046174,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"5884999645","product_id":100047701,"comment_content":"老师，我现在项目中遇到了一个问题，就是用springboot的全局异常处理时，响应出去的信息，编码格式都是ISO-8859-1，试过了在配置文件中设置spring.http.encoding.charset=utf-8和过滤器中给response去setCharacterEncoding为utf-8，但是还是不行。正常响应的数据是不乱码的，只有全局异常处理出去的响应有乱码，这个应该怎么解决呀","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495827,"discussion_content":"spring.http.encoding.charset=UTF-8\nspring.http.encoding.force=true\nspring.http.encoding.enabled=true\n试过吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590046174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271263,"discussion_content":"要看看有没有引入其它框架或拦截器或过滤器在输出的时候做了一些什么设置不","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590111075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249970,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/b2/3fb9a4a1.jpg","nickname":"招财","note":"","ucode":"8A6781148A9932","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270751,"discussion_content":"试过啦，还加了server.tomcat.uri-encoding=utf-8，但是响应给前端就成了iso-8859-1，网上说的所有方法都试过了，但是还是不行。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590047963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213520,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1588446722,"is_pvip":false,"replies":[{"id":"79166","content":"1. 去掉ribbon依赖后，ApacheHttpClient的注册方式就正确了，成为了一个Bean，而不是LoadBalancerFeignClient的delegate<br>2、Spring这么干是为了实现relaxed binding，参考 https:&#47;&#47;spring.io&#47;blog&#47;2018&#47;03&#47;28&#47;property-binding-in-spring-boot-2-0","user_name":"作者回复","comment_id":213520,"uid":"1001470","ip_address":"","utype":1,"ctime":1588471489,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5883414018","product_id":100047701,"comment_content":"老师 问两个问题<br>1.第一个例子 去掉ribbon依赖后 ApacheHttpClient注册了bean 所以@FeignClient这里面直接就使用的ApacheHttpClient的bea 不走那个new 的代码了是吗 ？<br>2.第二个例子. ConfigurationPropertySourcesPropertySourcess这个类实际上一个代理 查询的走的还是其他的配置源 这么做的意义是什么?","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493801,"discussion_content":"1. 去掉ribbon依赖后，ApacheHttpClient的注册方式就正确了，成为了一个Bean，而不是LoadBalancerFeignClient的delegate\n2、Spring这么干是为了实现relaxed binding，参考 https://spring.io/blog/2018/03/28/property-binding-in-spring-boot-2-0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588471489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349559,"user_name":"Geek_8b92bf","can_delete":false,"product_type":"c1","uid":2573588,"ip_address":"","ucode":"0EED09DA79D171","user_header":"","comment_is_top":false,"comment_ctime":1656064031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656064031","product_id":100047701,"comment_content":"within(feign.Client+) 为什么是切入execute方法，不是切人api方法，这个不太明白","like_count":1},{"had_liked":false,"id":327732,"user_name":"9jay","can_delete":false,"product_type":"c1","uid":1127094,"ip_address":"","ucode":"8A2FF8863E7FC0","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/b6/cd785ef7.jpg","comment_is_top":false,"comment_ctime":1640255540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640255540","product_id":100047701,"comment_content":"对FeignClient进行Around 切面后，拿到Response的body 字节流无法重复读取。<br>导致在切面的时候读取了返回值字节流后，Feign再去反序列化时对象就为空。<br>这个有好的方法解决吗？","like_count":0},{"had_liked":false,"id":291921,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1620608020,"is_pvip":false,"replies":[{"id":"105779","content":"密码可以由DBA统一管控，由DBA提供一个接口给到框架在运行时查询数据库对应的密码","user_name":"作者回复","comment_id":291921,"uid":"1001470","ip_address":"","utype":1,"ctime":1620715829,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":1,"score":"1620608020","product_id":100047701,"comment_content":"有个疑问，思考与讨论二中的真实数据库密码放哪呢？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519606,"discussion_content":"密码可以由DBA统一管控，由DBA提供一个接口给到框架在运行时查询数据库对应的密码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620715829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}