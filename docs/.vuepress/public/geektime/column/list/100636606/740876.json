{"id":740876,"title":"第 9 章 Spring MVC 实践(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>Spring MVC 的基本用法</li>\n<li>Spring MVC 的请求处理逻辑</li>\n<li>Spring MVC 的视图相关知识</li>\n<li>RestTemplate 的各类用法</li>\n</ul>\n</blockquote>\n<p>大家在日常工作中或多或少会接触到一些与 Web 相关的内容。早期也许是开发一个 Web 网站，随着大前端技术的发展，在前后端分离之后，后端 Java 系统只需要向前端提供 REST 接口就好了。在系统内部，分布式系统的交互也有可能是通过 <code>REST</code> 接口来实现的——因此掌握基本的 Web 开发能力还是很有必要的。本章我们会学习如何使用 Spring Framework 提供的 Spring MVC 来开发 Web 系统。</p>\n<h2 id=\"nav_point_134\">9.1　简单上手 Spring MVC</h2>\n<p>在早期的 Java EE 项目开发中，大家经常会提到“SSH”组合，其中的第二个“S”指的是 Web MVC 框架 Struts。但随着时间的推移，Struts 早早地就退出了历史的舞台，同一时期的 WebWork 框架也已少人问津，这第二个“S”早就被 Spring MVC 取代了。现在再提起 Struts，多数是老项目要修复安全漏洞。无论是开发 Web 页面，还是 RESTful Web 服务，都可以使用 Spring MVC 轻松实现。本节就让我们先简单了解一下 Spring MVC 的大概用法。</p>\n<h3 id=\"nav_point_135\">9.1.1　Spring MVC 概览</h3>\n<p>Spring MVC 能帮助我们方便地开发符合 MVC 模式 <span class=\"comment-number\">1</span> 的 Web 应用，MVC 即 <strong>Model-View-Controller</strong>（模型——视图——控制器），是一种软件架构模式。开始时，MVC 适用于桌面端程序，在 B/S 结构的应用兴起后，MVC 模式也被逐渐引入 Web 应用。简单说起来，MVC 的主要<strong>目标</strong>就是对用户界面与业务逻辑进行解耦，提升系统代码的可扩展性、可复用性和可维护性。<strong>模型层</strong>封装了业务逻辑，<strong>视图层</strong>则是暴露给用户的界面，<strong>控制器层</strong>则在两者之间充当黏合剂（所以控制器层一般会很薄，没有太多的逻辑），视图层把数据给到控制器，由控制器去调用模型层对应的服务。Spring MVC 里就有一个重要的 <code>ModelAndView</code> 类，请求处理完毕后都会返回这个类型的对象，其中就包含了模型与视图的信息，而代表控制器的类都会带上 <code>@Controller</code> 注解。因此可以说，<code>ModelAndView</code> 对应了 MVC 中的模型与视图，而带有 <code>@Controller</code> 注解的类则对应了 MVC 中的控制器。</p><!-- [[[read_end]]] -->\n\n<p>Spring MVC 的设计是围绕 <code>DispatcherServlet</code> 展开的，它是整个 Spring MVC 的核心，跟它配合的组件主要有下面这些：</p>\n<ul>\n<li><strong>控制器</strong>，我们编写的各种 <code>Controller</code>；</li>\n<li>各类<strong>校验器</strong>，例如，Spring MVC 内置了对 Hibernate Validator 的支持；</li>\n<li>各类<strong>解析器</strong>，例如，视图解析器 <code>ViewResolver</code>、异常解析器 <code>HandlerExceptionResolver</code> 和 Multipart 解析器 <code>MultipartResolver</code>；</li>\n<li><strong>处理器映射</strong>，<code>HandlerMapping</code> 定义了请求该如何找到对应的处理器，例如，根据 Bean 名称的 <code>BeanNameUrlHandlerMapping</code>，以及根据 <code>@RequestMapping</code> 注解的 <code>RequestMappingHandlerMapping</code>；</li>\n<li><strong>处理器适配器</strong>，<code>DispatcherServlet</code> 在收到请求时，通过 <code>HandlerAdapter</code> 来调用被映射的处理器。</li>\n</ul>\n<p>在后文中，我们会详细介绍 Spring MVC 中的几个主要部分，这里先来了解一下其中的一些常用注解，具体如表 9-1 所示。</p>\n<p><strong>表 9-1　Spring MVC 中的常用注解</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>注解</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>@Controller</code></p></td>\n<td><p>定义控制器类，与 <code>@Service</code> 和 <code>@Repository</code> 类似</p></td>\n</tr>\n<tr>\n<td><p><code>@RestController</code></p></td>\n<td><p>定义 REST 服务的控制器类，这是个快捷方式注解，其实就是结合了 <code>@Controller</code> 和 <code>@ResponseBody</code></p></td>\n</tr>\n<tr>\n<td><p><code>@RequestMapping</code></p></td>\n<td><p>定义请求的处理类和方法，其中的 <code>path</code> 属性是映射的 URL，<code>method</code> 是 <code>RequestMethod</code> 枚举中的 HTTP 方法，对于后者，还可以使用一些快捷注解，例如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code> 和 <code>@PathMapping</code></p></td>\n</tr>\n<tr>\n<td><p><code>@RequestBody</code></p></td>\n<td><p>定义请求正文对象，将整个请求正文映射到对象上</p></td>\n</tr>\n<tr>\n<td><p><code>@ResponseBody</code></p></td>\n<td><p>定义方法返回值即为整个请求的应答</p></td>\n</tr>\n<tr>\n<td><p><code>@ResponseStatus</code></p></td>\n<td><p>定义请求应答的 HTTP 响应码，具体的响应码可以用 <code>HttpStatus</code> 枚举</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_136\">9.1.2　编写一个简单的控制器</h3>\n<p>Linus Torvalds 有一句名言：</p>\n<blockquote>\n<p>Talk is cheap. Show me the code.</p>\n</blockquote>\n<p>要想明白如何编写 Spring MVC 的应用，开发 MVC 的控制器，最好的办法还是动手写一个控制器。以二进制奶茶店为例，我们来看这么一个需求。</p>\n<blockquote>\n<p><strong>需求描述</strong>　顾客到店后一般会先浏览菜单。有的顾客会查看完整的菜单，然后从中挑选自己喜欢的饮品；有的顾客会直接报饮品名称；甚至有些熟客能够直接报饮品编号。光顾我们二进制奶茶店的顾客主要是程序员，他们不直接报 0 和 1 组成的编码就是万幸了。</p>\n<p>所以我们需要提供一些服务，以便到店的顾客可以方便地完成下面三件事：</p>\n<p>(1) 找到完整的菜单；</p>\n<p>(2) 根据名称找到饮品；</p>\n<p>(3) 根据编号找到饮品。</p>\n</blockquote>\n<ol>\n<li><p><strong>开发控制器及其依赖代码</strong></p>\n<p>因为要开发 Web 相关的代码，所以 pom.xml 中必须引入 Web 相关的依赖，可以像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>代码示例 9-1<span class=\"comment-number\">2</span> 是菜单的 MVC 控制器代码片段，其中的几个方法分别实现了如下的功能—— <code>getAllMenu()</code> 能获取全部菜单项，<code>getById()</code> 可以根据编号获取指定菜单项，<code>getByName()</code> 可以根据名称获取菜单项。</p>\n<blockquote>\n<p><strong>代码示例 9-1</strong>　菜单的 MVC 控制器 <code>MenuController</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@ResponseBody\n@RequestMapping(\"/menu\")\npublic class MenuController {\n    @Autowired\n    private MenuService menuService;\n\n    @GetMapping(params = \"!name\")\n    public List&lt;MenuItem&gt; getAll() {\n        return menuService.getAllMenu();\n    }\n\n    @GetMapping(path = \"/\", produces = MediaType.APPLICATION_JSON_VALUE)\n    public Optional&lt;MenuItem&gt; getById(@PathVariable Long id) {\n        return menuService.getById(id);\n    }\n\n    @RequestMapping(params = \"name\", method = RequestMethod.GET)\n    public List&lt;MenuItem&gt; getByName(@RequestParam String name) {\n        return menuService.getByName(name);\n    }\n}</code></pre>\n<p>详细分析一下这段代码，<code>MenuController</code> 类上添加了 <code>@Controller</code> 注解，表明这个类是 MVC 控制器。<code>@ResponseBody</code> 可以写在类上，也可以写在方法上，表示将方法的返回值作为响应的正文。Spring MVC 提供了 <code>@RestController</code> 注解，在同时使用 <code>@Controller</code> 和 <code>@ResponseBody</code> 的情况下可以用它来代替。类上的 <code>@RequestMapping</code> 注解设置了整个类里的公共属性，在这里是设置了 URL 映射的基础路径 <code>/menu</code>，下面的方法在写路径时就可以不用再加这段前缀了。</p>\n<p>方法上的几个注解用来建立方法和请求的映射关系，<code>@GetMapping</code> 相当于 <code>@RequestMapping(method = RequestMethod.GET)</code>，表 9-1 中提到的其他几个 <code>@XxxMapping</code> 注解也是类似的情况。<span class=\"comment-number\">3</span></p>\n<p>在 Spring MVC 中，<code>@RequestMapping</code> 是一个非常重要的注解，所以要详细介绍一下，表 9-2 列出了它的所有属性。</p>\n<p><strong>表 9-2　<code>@RequestMapping</code> 注解的属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>属性</th><th>类型</th><th>说明</th></tr><tr><td><code>name</code></td><td><code>String</code></td><td>为映射定义一个名称，当类上和方法上的注解里都定义了名称，会用 <code>#</code> 将它们连接起来</td></tr><tr><td><code>path</code></td><td><code>String[]</code></td><td>指定映射的 URL，也是本注解的默认属性，类上的 <code>path</code> 会作为方法上的 <code>path</code> 的前缀，如果路径中用了占位符 <code>{}</code>，可以用 <code>@PathVariable</code> 注解来取得对应占位符的值</td></tr><tr><td><code>method</code></td><td><code>RequestMethod[]</code></td><td>用来缩小映射的范围，指定可以接受的 HTTP 方法，<code>RequestMethod</code> 定义了支持的 HTTP 方法</td></tr><tr><td><code>params</code></td><td><code>String[]</code></td><td>用来缩小映射的范围，当请求参数匹配规则时才做映射，可以用 <code>param1=value1</code>、<code>param2!=value2</code>、<code>param3</code> 和 <code>!param4</code> 分别表示参数等于某个值，参数不等于某个值，必须包含某个参数和不能包含某个参数</td></tr><tr><td><code>headers</code></td><td><code>String[]</code></td><td>用来缩小映射的范围，当 HTTP 请求头匹配规则时才做映射，规则配置方式与 <code>params</code> 相同</td></tr><tr><td><code>consumes</code></td><td><code>String[]</code></td><td>用来缩小映射的范围，只能处理特定媒体类型的请求，也就是匹配请求头里的 <code>Content-Type</code>，媒体类型一般通过 <code>MediaType</code> 来配置，可以用 <code>!</code> 表示否定</td></tr><tr><td><code>produces</code></td><td><code>String[]</code></td><td>用来缩小映射的范围，只能处理接受特定返回媒体类型的请求，本方法的结果会被限制在指定的媒体类型里</td></tr></table>\n\n<p>这个控制器用到的 <code>MenuService</code> 与上一章里的基本类似，但增加了一些方法和注解，例如，根据 ID 和名称获取 <code>MenuItem</code> 的方法，另外，事务一般配置在服务层上，所以这里还增加了 <code>@Transactional</code> 注解，具体见代码示例 9-2。</p>\n<blockquote>\n<p><strong>代码示例 9-2</strong>　增加了所需方法和注解的 <code>MenuService</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\n@CacheConfig(cacheNames = \"menu\")\npublic class MenuService {\n    @Autowired\n    private MenuRepository menuRepository;\n\n    @Cacheable\n    public List&lt;MenuItem&gt; getAllMenu() {\n        return menuRepository.findAll();\n    }\n\n    public Optional&lt;MenuItem&gt; getById(Long id) {\n        return menuRepository.findById(id);\n    }\n\n    public List&lt;MenuItem&gt; getByName(String name) {\n        return menuRepository.findAll(Example.of(MenuItem.builder().name(name).build()), Sort.by(\"id\"));\n    }\n\n    @Cacheable(key = \"#root.methodName + '-' + #name + '-' + #size\")\n    public Optional&lt;MenuItem&gt; getByNameAndSize(String name, Size size) {\n        return menuRepository.findByNameAndSize(name, size);\n    }\n}</code></pre>\n<p>此外，由于会返回 <code>Money</code> 类型和 Hibernate 的某些类型（我们直接返回了数据库里查找的对象，有些是 Hibernate 包装过的），所以需要对我们的 Jackson JSON 做些配置。本来我们需要自己编写各种序列化和反序列化组件，但好在 Jackson 社区早就为各种常用的库编写好了所需的设施。只需在 pom.xml 中引入需要的数据类型绑定依赖就可以了 <span class=\"comment-number\">4</span>，例如：</p>\n<pre class=\"code-rows\"><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-datatype-joda-money&lt;/artifactId&gt;\n        &lt;version&gt;2.13.1&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-datatype-hibernate5&lt;/artifactId&gt;\n        &lt;version&gt;2.13.1&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 省略其他依赖 --&gt;\n&lt;/dependencies&gt;</code></pre>\n<p>随后，Spring Boot 会收集上下文中配置的 <code>Module</code>，注册到自动配置的 Jackson JSON <code>ObjectMapper</code> 里，我们要做的就是配置几个 Bean，就像代码示例 9-3 那样。</p>\n<blockquote>\n<p><strong>代码示例 9-3</strong>　修改过的 <code>BinaryTeaApplication</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\npublic class BinaryTeaApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(BinaryTeaApplication.class, args);\n    }\n\n    @Bean\n    public JodaMoneyModule jodaMoneyModule() {\n        return new JodaMoneyModule();\n    }\n\n    @Bean\n    public Hibernate5Module hibernate5Module() {\n        return new Hibernate5Module();\n    }\n}</code></pre>\n<p>运行工程，默认 Spring Boot 的应用会监听 <code>8080</code> 端口，随后通过浏览器或者任何可以访问 Web 的方式来访问 http://localhost:8080/menu 就能看到完整的菜单了，图 9-1 就是在 Chrome 浏览器中装上 JSON View 插件后看到的效果。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00770.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-1　完整的菜单 JSON 输出</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>通过 MockMvc 对控制器进行单元测试</strong></p>\n<p>用浏览器查看输出是一种简单的测试方法，通过这种方式，我们可以直观地看到程序运行的效果，但如果希望后续能反复不断地运行测试，做到测试的自动化，那显然需要换一种测试方法，例如，用对应的单元测试来发起请求并检查结果。</p>\n<p>对于 Spring MVC，Spring Framework 提供了一个好用的 <code>MockMvc</code>，可以让我们方便地构建各种 HTTP 请求，并设置期望的返回值，做各种校验。我们可以像代码示例 9-4 这样来构建 <code>MockMvc</code>。</p>\n<blockquote>\n<p><strong>代码示例 9-4</strong>　<code>MenuControllerTest</code> 中关于 <code>MockMvc</code> 初始化的部分</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuControllerTest {\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    void setUp(WebApplicationContext wac) {\n        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).alwaysExpect(status().isOk()).build();\n    }\n\n    @AfterEach\n    void tearDown() {\n        mockMvc = null;\n    }\n    // 省略其他部分\n}</code></pre>\n<p>上面的代码通过传入 <code>WebApplicationContext</code> 来构建 <code>MockMvc</code>，随后设置 <code>MockMvc</code> 每次都期望返回 HTTP <code>200 OK</code> 的返回码（这里的 <code>alwaysExpect()</code> 也可以不加断言，在具体的测试方法里再添加）。在测试过程中会用到很多静态方法，所以最好先根据需要用 <code>import static</code> 导入一些方法，例如：</p>\n<ul>\n<li><code>MockMvcBuilders.*</code></li>\n<li><code>MockMvcRequestBuilders.*</code></li>\n<li><code>MockMvcResultMatchers.*</code></li>\n<li><code>MockMvcResultHandlers.*</code></li>\n</ul>\n<p>此外，我们也可以针对特定 <code>Controller</code> 初始化 <code>MockMvc</code>，例如像下面这样，但这样需要自己处理各种依赖，所以建议使用上面的方法。</p>\n<pre class=\"code-rows\"><code>this.mockMvc = MockMvcBuilders.standaloneSetup(new MenuController()).build();</code></pre>\n<p><code>getAll()</code> 方法的测试代码如代码示例 9-5 所示，其中有以下几个步骤。</p>\n<p>(1) 通过 <code>MockMvcRequestBuilders.get()</code> 发起一个针对 <code>/menu</code> 的 <code>GET</code> 请求，类似的还有 <code>post()</code> 等方法。</p>\n<p>(2) <code>andExpect()</code> 用来设置期望的检查项，这里先用 <code>MockMvcResultMatchers.handler()</code> 取得了处理器，随后判断它是不是 <code>MenuController</code> 类的 <code>getAll()</code> 方法，检查映射是否正确。</p>\n<p>(3) 通过 JsonPath<span class=\"comment-number\">5</span> 对返回的正文进行校验，这里检查了 JSON 是一个数组，数组长度是 2，所有的 <code>name</code> 属性中都有“<code>Java</code> 咖啡”。在匹配时用到了 Hamcrest<span class=\"comment-number\">6</span>，可以在 <code>Matchers</code> 里找到大量现成的匹配器。</p>\n<blockquote>\n<p><strong>代码示例 9-5</strong>　<code>MenuControllerTest</code> 中关于 <code>getAll()</code> 测试的部分</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuControllerTest {\n    // 省略其他部分\n    @Test\n    void testGetAll() throws Exception {\n        mockMvc.perform(get(\"/menu\"))\n                // 判断处理方法\n                .andExpect(handler().handlerType(MenuController.class))\n                .andExpect(handler().methodName(\"getAll\"))\n                // 判断返回JSON内容\n                .andExpect(jsonPath(\"$\").isArray())\n                .andExpect(jsonPath(\"$.length()\").value(2))\n                .andExpect(jsonPath(\"$..name\").value(Matchers.hasItem(\"Java咖啡\")));\n    }\n}</code></pre>\n<p>接下来，再测试一下 <code>getById()</code> 方法，具体如代码示例 9-6 所示，这里多了用 <code>MockMvcResultMatchers.content()</code> 来检查返回的 <code>Content-Type</code> 头和返回的消息正文，因为只返回单个对象，所以在没有结果时序列化的值为 <code>null</code>。我们分别用两个测试方法测试了两种场景。其实，在没有找到菜单项时应该将 HTTP 响应码设置为 <code>404</code>，这样才更符合 RESTful Web Service 的风格，我们在后续内容会介绍如何进行设置。</p>\n<blockquote>\n<p><strong>代码示例 9-6</strong>　<code>MenuControllerTest</code> 中关于 <code>getById()</code> 测试的部分</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuControllerTest {\n    // 省略其他部分\n    @Test\n    void testGetById() throws Exception {\n        mockMvc.perform(get(\"/menu/1\"))\n                // 判断响应头\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n                // 判断处理方法\n                .andExpect(handler().handlerType(MenuController.class))\n                .andExpect(handler().methodName(\"getById\"))\n                // 判断返回的JSON内容\n                .andExpect(jsonPath(\"$.name\").value(\"Java咖啡\"))\n                .andExpect(jsonPath(\"$.size\").value(\"MEDIUM\"));\n    }\n\n    @Test\n    void testGetByIdWithWrongId() throws Exception {\n        mockMvc.perform(get(\"/menu/100\"))\n                .andExpect(content().string(\"null\"));\n    }\n}</code></pre>\n<p>最后，再来测试 <code>getByName()</code> 方法，具体的代码如代码示例 9-7 所示。这里通过 <code>get().param()</code> 方法设置了请求的参数，当传入的参数查不到内容时，返回的数组为空。</p>\n<blockquote>\n<p><strong>代码示例 9-7</strong>　<code>MenuControllerTest</code> 中关于 <code>getByName()</code> 测试的部分</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuControllerTest {\n    // 省略其他部分\n    @Test\n    void testGetByName() throws Exception {\n        mockMvc.perform(get(\"/menu\").param(\"name\", \"Java咖啡\"))\n                .andExpect(handler().handlerType(MenuController.class))\n                .andExpect(handler().methodName(\"getByName\"))\n                .andExpect(jsonPath(\"$.length()\").value(2));\n    }\n\n    @Test\n    void testGetByNameWithWrongName() throws Exception {\n        mockMvc.perform(get(\"/menu\").param(\"name\", \"Java\"))\n                .andExpect(jsonPath(\"$\").isEmpty());\n    }\n}</code></pre>\n<p>JsonPath 非常灵活，有很多操作符和函数，我们可以在其官方主页查看基本的用法，表 9-3 列出了一些常用的操作符。JsonPath 的常用函数有运算类的 <code>max()</code>、<code>min()</code>、<code>avg()</code> 和 <code>sum()</code>，都是用于数组的，此外数组的 <code>length()</code> 可以返回数组长度。</p>\n<p><strong>表 9-3　JsonPath 的常用操作符</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>操作符</th><th>说明</th></tr><tr><td><code>$</code></td><td>JSON 的根元素</td></tr><tr><td><code>@</code></td><td>正在处理的当前节点</td></tr><tr><td><code>*</code></td><td>通配符</td></tr><tr><td><code>..</code></td><td>深度扫描，可以扫描很多层以下的内容</td></tr><tr><td><code>.&lt; 名称 &gt;</code></td><td>特定名称的子节点</td></tr><tr><td><code>[ 数组下标 ]</code></td><td>返回数组的特定位置的元素</td></tr><tr><td><code>[ 起始数组下标 : 结束数组下标 ]</code></td><td>从数组中切出一部分</td></tr></table>\n\n</li>\n</ol>\n\n\n\n\n\n","neighbors":{"left":{"article_title":"第三部分 使用 Spring 开发 Web 应用","id":740875},"right":{"article_title":"第 9 章 Spring MVC 实践(2)","id":740877}},"comments":[]}