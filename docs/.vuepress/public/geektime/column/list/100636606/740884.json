{"id":740884,"title":"第 11 章 Web 开发进阶(3)","content":"<h2 id=\"nav_point_183\">11.4　响应式 Web</h2>\n<p>到目前为止，本书一直使用的是命令式编程方式，整个处理过程也都是阻塞式的。以提供 Web 服务为例，我们如果希望同时并发地服务 100 个请求，那就需要 Tomcat 容器有 100 个工作线程，每个线程处理一个请求，如果来了第 101 个请求，那它只能等待前面的某个请求被处理完，有空闲的线程后才开始处理。每个线程本身是要消耗一定资源的，（例如消耗更多内存），大量线程间的切换也会消耗 CPU。但这还不是最要命的，最要命的是在请求处理过程中，如果我们还需要与数据库交互，或者读写文件，又或者调用远程服务，那么当前线程就不得不被阻塞，直到操作结果返回，这就会造成大量的资源浪费。</p>\n<p>想要处理更多请求，无非是提升性能，提高并发度。可以用更多的线程和更强的机器，也可以想办法挤压现有资源。既然基于同步线程的方式不行，那就换别的方式，人们自然想了各种办法，如何用更少的资源来提供更大的吞吐量，基于事件驱动的方式是否可行呢？</p>\n<p>不同的事件有不同的处理器，在注册完各种处理器之后，通过 IO 多路复用来检测是否有事件（不仅是网络，UI 界面上的点击也算是一种事件），例如 <code>8080</code> 端口是否收到了一个请求，有请求就将它分派给具体的事件处理器做后续处理。而请求处理本身也是事件驱动的，遇到 IO 操作不会“傻傻”地等待结果返回，同样会依靠 IO 完成事件通知。这样一来就能将原本处于阻塞状态的大量线程释放出来。</p><!-- [[[read_end]]] -->\n<p>在上述这一思想的影响下，就有了接下来要讨论的响应式编程（Reactive Programming），本节会着重讨论响应式 Web。维基百科对响应式编程的定义是这样的：</p>\n<blockquote>\n<p>在计算机中，响应式编程（或反应式编程）是一种面向数据流和变化传播的编程范式，这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>\n</blockquote>\n<p>可以看到，响应式编程更关注数据的变化。要处理的数据不是一下子就全都就绪的，而是可以一个接着一个源源不断地“涌”过来；而对数据的处理也不再需要等一大批数据就绪了才开始，一切都会更动态一些。此外，响应式编程更注重描述要做什么，而不是怎么做。</p>\n<p>虽然在这个场景中响应式编程看起来特别厉害，但请务必记住，<strong>响应式编程不是银弹</strong>，它并不能解决所有问题。不要为了响应式而响应式，命令式编程也有自己的优势，两者可以相辅相成。</p>\n<h3 id=\"nav_point_184\">11.4.1　了解 Project Reactor</h3>\n<p>响应式编程的理念是好的，但与命令式编程相比，开发思路并不容易理解。如果没有顺手的工具，编写响应式代码将非常痛苦。无论是用回调还是 <code>Future</code>，遇到稍微复杂一些的场景，会很让人抓狂。好在社区很早就意识到了这个问题，除了有 Reactive Streams 规范，还相继出现了像 RxJava 和 Project Reactor 这样的框架 <span class=\"comment-number\">17</span>。其中，Project Reactor 也出自 VMWare 之手，自然和 Spring 走得很近。本节的主角 Spring WebFlux 就是基于 Reactor 的，所以在正式介绍 WebFlux 前，先让我们来了解一下 Project Reactor。</p>\n\n<ol>\n<li><p><strong>基本使用</strong></p>\n<p>在 Project Reactor 中，有两个重要的概念——<code>Publisher</code> 和 <code>Subscriber</code>，前者是数据的生产者，后者则是数据的订阅者（或者说消费者）。<code>Subscriber</code> 通过 <code>Publisher</code> 的 <code>subscribe()</code> 进行订阅，而 <code>Publisher</code> 则在产生新数据后调用 <code>Subscriber</code> 的 <code>onNext()</code> 进行处理，遇到报错时调用 <code>onError()</code>，在结束时调用 <code>onComplete()</code>。</p>\n<p><code>Mono</code> 和 <code>Flux</code> 就是 Reactor 项目为我们提供的两个 <code>Publisher</code>，<code>Mono</code> 代表 0 或 1 个对象，而 <code>Flux</code> 则代表多个对象，也就是 0 到 <em>N</em> 个对象。如果我们只是产生一个数字 <code>5</code>，用 <code>Mono.just(5)</code> 就可以了，表 11-12 罗列了一些常用的创建 <code>Flux&lt;T&gt;</code> 的方法（有的也适用于 <code>Mono&lt;T&gt;</code>）。</p>\n<p><strong>表 11-12　常用的创建 <code>Flux&lt;T&gt;</code> 的方法</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>方法</th><th>说明</th></tr><tr><td><code>Flux.empty()</code></td><td>创建空的 <code>Flux</code></td></tr><tr><td><code>Flux.just(T... data)</code></td><td>创建固定内容的 <code>Flux</code></td></tr><tr><td><code>Flux.range(int start, int count)</code></td><td>创建 <code>Flux&lt;Integer&gt;</code>，从 <code>start</code> 开始，一共 <code>count</code> 个（包含开始的那个）</td></tr><tr><td><code>Flux.interval(Duration delay, Duration period)</code></td><td>创建 <code>Flux&lt;Long&gt;</code>，延迟 <code>delay</code> 开始，每隔 <code>period</code> 放出一个，从 0 开始的长整形数</td></tr><tr><td><code>Flux.from(Publisher source)</code></td><td>根据某个 <code>Publisher</code> 来创建 <code>Flux</code></td></tr><tr><td><code>Flux.fromArray(T[] array)</code></td><td>根据某个数组来创建 <code>Flux</code></td></tr><tr><td><code>Flux.fromIterable(Iterable it)</code></td><td>根据某个迭代器来创建 <code>Flux</code></td></tr><tr><td><code>Flux.fromStream(Stream s)</code></td><td>根据某个流来创建 <code>Flux</code></td></tr></table>\n\n<p>有了 <code>Flux</code> 之后，我们未必想处理全部元素，这时候可以通过 <code>take()</code>、<code>takeLast()</code> 等方法取出其中的一部分。其实，我们可以把 <code>Publisher</code> 看成类似 Java <code>Stream</code> 的东西，对流的大部分操作是适用的。例如，过滤元素的 <code>filter()</code>，转换元素的 <code>map()</code> 和 <code>flatMap()</code>，将流中的元素收集聚合成一个的 <code>reduce()</code>。</p>\n<p>除了类似流的操作，在遇到事件时 <code>Publisher</code> 也给我们留下了可以加入自己操作的钩子，如表 11-13 所示。</p>\n<p><strong>表 11-13　<code>Publisher</code> 针对事件的钩子方法</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>方法</th><th>说明</th></tr><tr><td><code>doOnSubscribe()</code></td><td>有消费者订阅时执行动作</td></tr><tr><td><code>doOnNext()</code></td><td>产生一个新数据时执行动作</td></tr><tr><td><code>doOnComplete()</code></td><td>数据全部成功产生时执行动作</td></tr><tr><td><code>doOnError()</code></td><td>遇到错误时执行动作</td></tr><tr><td><code>doOnTerminate()</code></td><td>结束时（可以是成功结束，也可以是遇到错误结束）执行动作</td></tr><tr><td><code>doOnEach()</code></td><td>在产生新数据、成功完成和遇到错误时执行动作</td></tr></table>\n\n<p>举个例子，下面我们组合使用一下这些方法：先构造一个从 5 到 0 的 <code>Flux&lt;Integer&gt;</code>；随后从中挑选出小于 4 的整数，取 3 个出来，分别尝试使用 <code>doOnNext()</code>、<code>doOnComplete()</code> 和 <code>doOnEach()</code> 方法，看看有何区别；最后再将这个整数值转换为自己的平方，订阅者用 <code>log</code>（请在类上添加 Lombok 的 <code>@Slf4j</code> 注解来提供 <code>log</code>）打印一下自己取到的值。</p>\n<pre class=\"code-rows\"><code>Flux.just(5, 4, 3, 2, 1, 0)\n    .filter(n -&gt; n &lt; 4)\n    .take(3)\n    .doOnNext(n -&gt; log.info(\"onNext: {}\", n))\n    .doOnComplete(() -&gt; log.info(\"Complete!\"))\n    .doOnEach(n -&gt; log.info(\"onEach: {}, {}\", n.getType(), n.get()))\n    .map(n -&gt; n * n)\n    .subscribe(n -&gt; log.info(\"Subscribe: {}\", n));</code></pre>\n<p>这段代码的输出大概是下面这样的：</p>\n<pre class=\"code-rows\"><code>19:41:39.811 [main] INFO learning.spring.customer.OrderGenerator - onNext: 3\n19:41:39.813 [main] INFO learning.spring.customer.OrderGenerator - onEach: onNext, 3\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - Subscribe: 9\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - onNext: 2\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - onEach: onNext, 2\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - Subscribe: 4\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - onNext: 1\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - onEach: onNext, 1\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - Subscribe: 1\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - Complete!\n19:41:39.814 [main] INFO learning.spring.customer.OrderGenerator - onEach: onComplete, null</code></pre>\n<p>可以看到数字 3、2、1 分别经过了 <code>onNext()</code>、<code>onEach()</code> 和 <code>subscribe()</code>，先是 3，然后是 2，到 1 的时候这个 <code>Flux</code> 完成了，所以还执行了 <code>complete()</code>。<code>doOnEach()</code> 中处理的是 <code>Signal&lt;T&gt;</code>，并非每种信号都有对应的值，比如 <code>onComplete</code> 取到的值就是 <code>null</code>。</p>\n<p>如果调换一下 <code>.filter(n -&gt; n &lt; 4)</code> 和 <code>.take(3)</code> 的顺序，那就变成了先取出 3 个数，再过滤出小于 4 的，前 3 个数是 5、4、3，小于 4 的就只有 3，输出就变成了下面这样（所以，请注意各种操作的顺序）。</p>\n<pre class=\"code-rows\"><code>19:56:10.483 [main] INFO learning.spring.customer.OrderGenerator - onNext: 3\n19:56:10.484 [main] INFO learning.spring.customer.OrderGenerator - onEach: onNext, 3\n19:56:10.485 [main] INFO learning.spring.customer.OrderGenerator - Subscribe: 9\n19:56:10.485 [main] INFO learning.spring.customer.OrderGenerator - Complete!\n19:56:10.486 [main] INFO learning.spring.customer.OrderGenerator - onEach: onComplete, null</code></pre>\n<p>如果我们去掉最后那句 <code>.subscribe(n -&gt; log.info(\"Subscribe: {}\", n))</code>，重新执行这段代码，会发现什么都没有发生。</p>\n<blockquote>\n<p><strong>请注意</strong>　在使用了 Project Reactor 的代码中，只有先订阅，生产者上的各种操作才会被真正执行。官方文档中称其为“Nothing happens until you subscribe”。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>线程调度</strong></p>\n<p>在前面例子的输出中，我们看到的 <code>main</code> 是线程名，它是当前执行的线程。其实 Project Reactor 里的 <code>Mono</code> 和 <code>Flux</code> 可以在主线程外的地方执行，也不一定是调用 <code>subscribe()</code> 的那个线程。具体执行的线程是由框架中的 <code>Scheduler</code> 来调度的，通过 <code>Schedulers</code> 类中的静态方法，我们可以指定想要使用的执行上下文，如表 11-14 所示。</p>\n<p><strong>表 11-14　<code>Schedulers</code> 类中的静态方法</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>方法</th><th>说明</th></tr><tr><td><code>Schedulers.immediate()</code></td><td>直接在当前线程中执行</td></tr><tr><td><code>Schedulers.single()</code></td><td>在一个单独的线程中执行，这个线程是大家共用的</td></tr><tr><td><code>Schedulers.newSingle()</code></td><td>在一个单独的线程中执行，每次调用都会使用一个新的线程</td></tr><tr><td><code>Schedulers.elastic()</code></td><td>在一个可伸缩的线程池中执行，工作线程会按需创建，一段时间不用（默认 60 秒）会被回收，但必须注意线程池中的线程数是没有上限的</td></tr><tr><td><code>Schedulers.boundedElastic()</code></td><td>与 <code>Schedulers.elastic()</code> 类似，区别在于这里的线程数是有限的，默认是 CPU 核数的 10 倍</td></tr><tr><td><code>Schedulers.parallel()</code></td><td>在一个固定的线程池中执行，线程池的线程数就是 CPU 核数</td></tr><tr><td><code>Schedulers.fromExecutorService()</code></td><td>可以指定一个 <code>ExecutorService</code>，在这个 <code>ExecutorService</code> 中执行</td></tr></table>\n\n<p>可以通过 <code>publishOn()</code> 和 <code>subscribeOn()</code> 方法来切换执行的上下文，其中 <code>publishOn()</code> 的位置很有讲究，<code>subscribeOn()</code> 则放在哪里都可以。我们把前面的例子稍作修改，增加两处 <code>publishOn()</code>，让它跑在其他线程里，看看会有何不同。<span class=\"comment-number\">18</span></p>\n<pre class=\"code-rows\"><code>Flux.just(5, 4, 3, 2, 1, 0)\n    .filter(n -&gt; n &lt; 4)\n    .take(3)\n    .publishOn(Schedulers.single())\n    .doOnNext(n -&gt; log.info(\"onNext: {}\", n))\n    .doOnComplete(() -&gt; log.info(\"Complete!\"))\n    .doOnEach(n -&gt; log.info(\"onEach: {}, {}\", n.getType(), n.get()))\n    .map(n -&gt; n * n)\n    .publishOn(Schedulers.parallel())\n    .map(n -&gt; n - 1)\n    .subscribe(n -&gt; log.info(\"Subscribe: {}\", n));\nThread.sleep(1000);</code></pre>\n<p>上面的代码输出如下。可以看到 <code>publishOn(Schedulers.single())</code> 影响了 <code>doOnNext()</code>、<code>doOnComplete</code> 和 <code>doOnEach()</code> 的执行，这三个方法都跑在 <code>single-1</code> 线程里；<code>publishOn(Schedulers.parallel())</code> 则影响了 <code>subscribe()</code>，它跑在 <code>parallel-1</code> 线程里。</p>\n<pre class=\"code-rows\"><code>21:05:03.947 [single-1] INFO learning.spring.customer.OrderGenerator - onNext: 3\n21:05:03.949 [single-1] INFO learning.spring.customer.OrderGenerator - onEach: onNext, 3\n21:05:03.950 [single-1] INFO learning.spring.customer.OrderGenerator - onNext: 2\n21:05:03.950 [single-1] INFO learning.spring.customer.OrderGenerator - onEach: onNext, 2\n21:05:03.950 [parallel-1] INFO learning.spring.customer.OrderGenerator - Subscribe: 8\n21:05:03.950 [single-1] INFO learning.spring.customer.OrderGenerator - onNext: 1\n21:05:03.950 [parallel-1] INFO learning.spring.customer.OrderGenerator - Subscribe: 3\n21:05:03.950 [single-1] INFO learning.spring.customer.OrderGenerator - onEach: onNext, 1\n21:05:03.950 [single-1] INFO learning.spring.customer.OrderGenerator - Complete!\n21:05:03.950 [parallel-1] INFO learning.spring.customer.OrderGenerator - Subscribe: 0\n21:05:03.951 [single-1] INFO learning.spring.customer.OrderGenerator - onEach: onComplete, null</code></pre>\n<p>其实，第一个 <code>map()</code> 也是在 <code>single-1</code> 线程中执行的，第二个 <code>map()</code> 是在 <code>parallel-1</code> 线程里。我们可以通过在 <code>map()</code> 的 Lambda 中增加日志来加以验证，这个验证就交给各位自己动手了。通过这个例子可以看到，<code>publishOn()</code> 会影响它后面代码执行的上下文，直到遇到下一个 <code>publishOn()</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>错误处理</strong></p>\n<p>日常开发工作中，一定会遇到需要处理异常的情况。在“传统”的代码中，我们习惯了用 <code>try-catch</code> 代码块来捕获异常并加以处理，那在响应式的代码里又该如何处理异常呢？每个步骤传入的 Lambda 里都套个 <code>try-catch</code> 一点儿都不优雅，那 Project Reactor 又是怎么做的呢？</p>\n<p>在 <code>subscribe()</code> 方法中，除了正常的消费逻辑，我们还可以传入 <code>Consumer&lt;? super Throwable&gt;</code> 类型的消费者去处理抛出的异常。例如下面的代码就会遇到除数为 0 的异常：</p>\n<pre class=\"code-rows\"><code>Flux.just(2, 1, 0, -1, -2)\n    .map(n -&gt; 10 / n)\n    .subscribe(n -&gt; log.info(\"num={}\", n),\n        e -&gt; log.error(\"Exception occurred: {}\", e.getMessage()));</code></pre>\n<p>运行的结果如下。当处理到 <code>0</code> 的时候 <code>map()</code> 报错了，后面的 <code>-1</code> 和 <code>-2</code> 并未得到处理。</p>\n<pre class=\"code-rows\"><code>22:21:28.669 [main] INFO learning.spring.customer.OrderGenerator - num=5\n22:21:28.670 [main] INFO learning.spring.customer.OrderGenerator - num=10\n22:21:28.674 [main] ERROR learning.spring.customer.OrderGenerator - Exception occurred: / by zero</code></pre>\n<p>把所有异常处理逻辑都写在一个地方必然可行，但还是不够优雅。如果我们希望在报错后能执行降级方案，用其他值代替结果，希望继续处理后续的内容，希望根据异常类型进行有针对性的处理，或者就是简单再重试一下，又该怎么办？表 11-15 中就是 Project Reactor 给出的解决方案，通过这些方法可以满足刚才的诉求。</p>\n<p><strong>表 11-15　一些有用的异常处理方法</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>方法</th><th>说明</th></tr><tr><td><code>onErrorReturn()</code></td><td>捕获异常，返回一个默认值。可以直接返回，也可以根据异常类型返回，或者根据 <code>Predicate</code> 来过滤异常</td></tr><tr><td><code>onErrorResume()</code></td><td>捕获异常，执行一段降级的逻辑，返回另一个 <code>Publisher</code>；同 <code>onErrorReturn()</code> 一样，也可以过滤异常</td></tr><tr><td><code>onErrorContinue()</code></td><td>捕获异常，执行一段逻辑，随后继续处理后续的内容</td></tr><tr><td><code>doOnError()</code></td><td>继续抛出异常，但可以获取到异常信息，以便打印日志或做些其他的处理</td></tr><tr><td><code>doFinally()</code></td><td>类似 <code>try-catch-finally</code> 代码块中的 <code>finally</code> 关键字，其中的逻辑在生产者的序列结束或者取消时会得到执行</td></tr><tr><td><code>retry()</code></td><td>重试指定次数</td></tr></table>\n\n<p>如果用 <code>onErrorContinue()</code> 来改写一下，可以在除以 <code>0</code> 报错后继续处理后续的 <code>-1</code> 和 <code>-2</code>，代码会是下面这样的：</p>\n<pre class=\"code-rows\"><code>Flux.just(2, 1, 0, -1, -2)\n    .map(n -&gt; 10 / n)\n    .onErrorContinue((throwable, o) -&gt; log.info(\"o = {}\", o))\n    .subscribe(n -&gt; log.info(\"num={}\", n));</code></pre>\n<p>代码的输出如下：</p>\n<pre class=\"code-rows\"><code>22:40:08.472 [main] INFO learning.spring.customer.OrderGenerator - num=5\n22:40:08.473 [main] INFO learning.spring.customer.OrderGenerator - num=10\n22:40:08.476 [main] INFO learning.spring.customer.OrderGenerator - o = 0\n22:40:08.476 [main] INFO learning.spring.customer.OrderGenerator - num=-10\n22:40:08.476 [main] INFO learning.spring.customer.OrderGenerator - num=-5</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>背压</strong></p>\n<p>在处理流的时候，下游通常是被动地接受上游发来的内容，但总会出现上游的生产速度远大于下游消费速度的情况，这时该怎么办呢？对于不重要的内容，一般会想到的是直接抛弃，不做处理；那些不能抛弃的，如果可以告诉上游发慢点，让上游先缓一下就好了——<strong>背压</strong>（backpressure，也有叫回压的）就是这种向上游传递信号的机制。</p>\n<p>在上面看到的各种例子里，我们都使用 <code>subscribe()</code> 方法，默认它会请求 <code>Long.MAX_VALUE</code> 个数据回来，这就相当于照单全收。但我们可以通过一些方法来控制请求的数量，例如，<code>buffer()</code> 将数据先缓存一下，这时单个数据会变成集合，订阅者拿到的其实是集合；<code>limitRequest()</code> 能限制实际请求的数据数量；<code>limitRate()</code> 能将请求数按指定大小分批取回。比如下面这个例子，我们通过 <code>doOnRequest()</code> 打印出了每次请求希望获取的数据量。</p>\n<pre class=\"code-rows\"><code>Flux.just(2, 1, 0, -1, -2)\n    .doOnRequest(r -&gt; log.info(\"onRequest1={}\", r))\n    .buffer(2)\n    .doOnRequest(r -&gt; log.info(\"onRequest2={}\", r))\n    .limitRequest(2)\n    .doOnRequest(r -&gt; log.info(\"onRequest3={}\", r))\n    .subscribe(n -&gt; log.info(\"num={}\", n));</code></pre>\n<p>它的输出如下。<code>subscribe()</code> 想要 <code>Long.MAX_VALUE</code> 个数据，而 <code>limitRequest(2)</code> 限制了取回两个缓存的内容，每个缓存大小是 2，所以拿了 4 个数。</p>\n<pre class=\"code-rows\"><code>23:22:28.157 [main] INFO learning.spring.customer.OrderGenerator - onRequest3=9223372036854775807\n23:22:28.158 [main] INFO learning.spring.customer.OrderGenerator - onRequest2=2\n23:22:28.158 [main] INFO learning.spring.customer.OrderGenerator - onRequest1=4\n23:22:28.159 [main] INFO learning.spring.customer.OrderGenerator - num=[2, 1]\n23:22:28.159 [main] INFO learning.spring.customer.OrderGenerator - num=[0, -1]</code></pre>\n<p>如果把 <code>limitRequest(2)</code> 改为 <code>limitRate(2)</code>，那么输出就变成下面这样，所有的数最终都能被取回来。</p>\n<pre class=\"code-rows\"><code>23:24:05.680 [main] INFO learning.spring.customer.OrderGenerator - onRequest3=9223372036854775807\n23:24:05.681 [main] INFO learning.spring.customer.OrderGenerator - onRequest2=2\n23:24:05.681 [main] INFO learning.spring.customer.OrderGenerator - onRequest1=4\n23:24:05.682 [main] INFO learning.spring.customer.OrderGenerator - num=[2, 1]\n23:24:05.682 [main] INFO learning.spring.customer.OrderGenerator - num=[0, -1]\n23:24:05.682 [main] INFO learning.spring.customer.OrderGenerator - onRequest2=2\n23:24:05.682 [main] INFO learning.spring.customer.OrderGenerator - onRequest1=4\n23:24:05.682 [main] INFO learning.spring.customer.OrderGenerator - num=[-2]</code></pre>\n<p>由于不是所有上游都能支持背压信号，有些生产者是有订阅才开始生产，而有些是无论是否有订阅都会生产数据。所以很多情况下，还是只能靠抛弃，最多自己这里稍微缓存一些，剩下的再抛弃。不管怎么样，背压还是给了我们一些应对上下游速率不匹配的手段。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_185\">11.4.2　使用 WebFlux 代替 WebMVC</h3>\n<p>从 Spring Framework 5.0 开始，Spring 团队引入了一套新的响应式 Web 框架——WebFlux。可以说，WebFlux 是以“一等公民”的身份出现在 Spring Framework 中的，和行走江湖多年的 Spring MVC 平起平坐。这是一套完全非阻塞的 Web 框架，不依赖 Servlet 容器。虽然 Servlet 3.1 对非阻塞 IO 也有一定的支持，但在使用时多少有些别扭。</p>\n<p>WebFlux 虽然在底层使用了完全不同的机制，但在使用上还是兼顾了不少 WebMVC 的习惯，例如可以使用相似的注解（也可以编写函数式端点），运行在相同的服务器上，不仅有服务端的支持，还提供了强大的客户端。比起直接使用 Servlet 3.1 开发非阻塞的 Web 服务，使用 WebFlux 显然能获得更好的开发体验。</p>\n<p>如果使用 Spring Boot，可以在 Spring Initializr 中选择 Spring Reactive Web，也可以直接在 pom.xml 中添加如下依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>随后，自动配置类 <code>WebFluxAutoConfiguration</code> 会创建一些必要的 Bean，例如 Spring Boot 内置的 <code>WebFluxConfigurer</code> 和 <code>DelegatingWebFluxConfiguration</code>，通过它们来配置 <code>FormattingConversionService</code>、<code>RequestMappingHandlerAdapter</code> 等内容。<code>DelegatingWebFluxConfiguration</code> 会自动收集上下文中的 <code>WebFluxConfigurer</code>，运用其中的配置。如果我们希望做些自定义的配置，可以考虑定义一个自己的 <code>WebFluxConfigurer</code> 实现类。</p>\n<p>Spring Boot 默认使用 Netty 来运行 WebFlux 的程序，它提供了 4 种不同的服务器支持，具体如表 11-16 所示。只需排除 spring-boot-starter-reactor-netty，随后引入表中的起步依赖，就能完成服务器的替换。</p>\n<p><strong>表 11-16　支持 WebFlux 的 Spring Boot 内置服务器起步依赖</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>服务器</p></th>\n<th><p>依赖</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>Reactor Netty</p></td>\n<td><p><code>org.springframework.boot:spring-boot-starter-reactor-netty</code></p></td>\n</tr>\n<tr>\n<td><p>Tomcat</p></td>\n<td><p><code>org.springframework.boot:spring-boot-starter-tomcat</code></p></td>\n</tr>\n<tr>\n<td><p>Jetty</p></td>\n<td><p><code>org.springframework.boot:spring-boot-starter-jetty</code></p></td>\n</tr>\n<tr>\n<td><p>Undertow</p></td>\n<td><p><code>org.springframework.boot:spring-boot-starter-undertow</code></p></td>\n</tr>\n</tbody>\n</table>\n<p><code>ReactiveWebServerFactoryConfiguration</code> 提供了相应服务器的自动配置，通过 <code>@Import</code> 导入了具体的配置，例如 Tomcat 的配置放在 <code>ReactiveWebServerFactoryConfiguration.EmbeddedTomcat</code> 里，Jetty 的是 <code>ReactiveWebServerFactoryConfiguration.EmbeddedJetty</code>。这些配置类的作用就是创建不同服务器的 <code>ReactiveWebServerFactory</code> Bean，通过它来获得 <code>WebServer</code>。表 11-17 罗列了不同服务器对应的 <code>ReactiveWebServerFactory</code> 类和相应的定制器接口，我们可以通过在上下文里配置这些 <code>XxxCustomizer</code> Bean 来实现内嵌服务器的定制，例如，Spring Boot 的 <code>ReactiveWebServerFactoryCustomizer</code> 就是根据 <code>ServerProperties</code> 配置内嵌服务器的，用的是 <code>server.*</code> 的配置。</p>\n<p><strong>表 11-17　Spring Boot 中不同内嵌服务器对应的类和接口</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>服务器</p></th>\n<th><p><code>ReactiveWebServerFactory</code> 实现类</p></th>\n<th><p>定制器接口</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>Reactor Netty</p></td>\n<td><p><code>NettyReactiveWebServerFactory</code></p></td>\n<td><p><code>NettyServerCustomizer</code></p></td>\n</tr>\n<tr>\n<td><p>Tomcat</p></td>\n<td><p><code>TomcatReactiveWebServerFactory</code></p></td>\n<td><p><code>TomcatConnectorCustomizer</code>、<code>TomcatContextCustomizer</code> 和 <code>TomcatProtocolHandlerCustomizer</code></p></td>\n</tr>\n<tr>\n<td><p>Jetty</p></td>\n<td><p><code>JettyReactiveWebServerFactory</code></p></td>\n<td><p><code>JettyServerCustomizer</code></p></td>\n</tr>\n<tr>\n<td><p>Undertow</p></td>\n<td><p><code>UndertowReactiveWebServerFactory</code></p></td>\n<td><p><code>UndertowBuilderCustomizer</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>说了这么多，其实在实践中需要做的事情基本就是引入起步依赖，剩下的交给自动配置就好了。下面这样的 pom.xml 就完成了适用于 WebFlux 的 Tomcat 的配置。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-reactor-netty&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<ol>\n<li><p><strong>编写基于注解的控制器</strong></p>\n<p>Spring WebFlux 中可以使用与 Spring MVC 一样的注解来开发 Web 控制器，从开发的角度来看，只是用 <code>Flux</code> 和 <code>Mono</code> 作为返回对象，其他基本没有什么差异。</p>\n<p>我们以 10.4 节最后开发的那个 JWT 认证客户端为基础，改造一下 Customer 工程。原来的程序比较简单，完全是自动的，运行结束自动退出，灵活性差了一些。假设我们现在希望由人来触发一些操作。以加载菜单为例，原来用的是 <code>MenuRunner</code> 类，现在可以把它删了，直接调用 REST 服务，取回结果并打印日志。怎么实现呢？可以用 WebFlux 编写一个 Web 控制器，其余操作不变，Web 控制器的代码如代码示例 11-18 所示。<span class=\"comment-number\">19</span></p>\n<blockquote>\n<p><strong>代码示例 11-18</strong>　基于 WebFlux 的 Web 控制器 <code>MenuController</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@RestController\n@RequestMapping(\"/menu\")\npublic class MenuController {\n    @Autowired\n    private MenuService menuService;\n\n    @GetMapping\n    public Flux&lt;MenuItem&gt; getAllMenu() {\n        return menuService.getAllMenu();\n    }\n\n    @GetMapping(path = \"/\")\n    public Mono&lt;MenuItem&gt; getById(@PathVariable Long id) {\n        if (id == null) {\n            return Mono.empty();\n        }\n        return menuService.getById(id);\n    }\n}</code></pre>\n<p>上面的代码中，我们将获取菜单的操作封装进了 <code>MenuService</code> 中，控制器的方法直接返回 Project Reactor 的 <code>Flux</code> 和 <code>Mono</code> 类型对象。<code>MenuService</code> 直接沿用了 <code>MenuRunner</code> 中的部分代码，具体如代码示例 11-19 所示。这里的 <code>RestTemplate</code> 操作是阻塞的（我们会在本节后续的内容中介绍响应式的 Web 客户端 <code>WebClient</code>，此处先继续使用 <code>RestTemplate</code>）。</p>\n<blockquote>\n<p><strong>代码示例 11-19</strong>　封装了 <code>RestTemplate</code> 操作的 <code>MenuService</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\npublic class MenuService {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String binarytea;\n\n    public Flux&lt;MenuItem&gt; getAllMenu() {\n        ParameterizedTypeReference&lt;List&lt;MenuItem&gt;&gt; typeReference =\n            new ParameterizedTypeReference&lt;List&lt;MenuItem&gt;&gt;() {\n            };\n        URI uri = UriComponentsBuilder.fromUriString(binarytea + \"/menu\").build().toUri();\n        RequestEntity&lt;Void&gt; request = RequestEntity.get(uri).accept(MediaType.APPLICATION_JSON).build();\n        ResponseEntity&lt;List&lt;MenuItem&gt;&gt; response = restTemplate.exchange(request, typeReference);\n        return Flux.fromIterable(response.getBody());\n    }\n\n    public Mono&lt;MenuItem&gt; getById(Long id) {\n        MenuItem item = restTemplate.getForObject(binarytea + \"/menu/\", MenuItem.class, id);\n        return item != null ? Mono.just(item) : Mono.empty();\n    }\n}</code></pre>\n<p>由于我们使用了响应式 Web 技术栈，Spring Boot 的一些自动配置类会直接失效，例如 <code>RestTemplateAutoConfiguration</code> 和 <code>HttpMessageConvertersAutoConfiguration</code>，上面都加了 <code>@Conditional(NotReactiveWebApplicationCondition.class)</code>，所以需要我们自己来处理一些 <code>RestTemplate</code> 和 <code>HttpMessageConverter</code> 相关的初始化工作。为此，我们需要再调整一下 <code>CustomerApplication</code> 类里的配置代码，如代码示例 11-20 所示。首先，注释掉 <code>SpringApplicationBuilder</code> 上禁用 Web 功能的代码，开启 Web 功能；然后，调整 <code>RestTemplate</code> 的创建代码，原先通过参数获取自动配置的 <code>RestTemplateBuilder</code>，现在只能自己用 <code>new</code> 创建一个，再配置两个 <code>HttpMessageConverter</code>，尤其是 Jackson2 的那个，一定要用 Spring 容器中的 <code>ObjectMapper</code>，否则无法利用 Spring Boot 自动配置的各种 Module。</p>\n<blockquote>\n<p><strong>代码示例 11-20</strong>　针对 WebFlux 调整过的 <code>CustomerApplication</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\npublic class CustomerApplication {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder()\n            .sources(CustomerApplication.class)\n            //.web(WebApplicationType.NONE)\n            .run(args);\n    }\n\n    @Bean\n    public RestTemplate restTemplate(ObjectProvider&lt;ObjectMapper&gt; objectMapper) {\n        return new RestTemplateBuilder()\n                .additionalMessageConverters(new StringHttpMessageConverter(),\n                    new MappingJackson2HttpMessageConverter(objectMapper.getIfAvailable()))\n                .requestFactory(this::requestFactory)\n                .setConnectTimeout(Duration.ofSeconds(1)) // 连接超时\n                .setReadTimeout(Duration.ofSeconds(5)) // 读取超时\n                .additionalRequestCustomizers(jwtClientHttpRequestInitializer())\n                .build();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>在运行 <code>CustomerApplication</code> 前，先在本地的 <code>8080</code> 端口启动一个 <code>BinaryteaApplication</code>，11.1 节中的那个 binarytea-controller-advice 就可以。随后调整一下 Customer 项目的 <code>application.properties</code>，增加 <code>server.port=8081</code>，指定启动在 <code>8081</code> 端口上，避免冲突。最后启动 <code>CustomerApplication</code>，通过访问 http://localhost:8081/menu 和 http://localhost:8081/menu/1 触发远程调用。</p>\n<blockquote>\n<p><strong>茶歇时间：为什么 Project Reactor 和 WebFlux 还没成为主流</strong></p>\n<p>既然响应式编程在资源利用方面表现这么好，只要很少的资源就能支持大流量，那为什么我们不把所有代码都用响应式编程框架重写一遍呢？自从 Spring Framework 5.0 发布 WebFlux，我身边似乎并没有太大的反应，也没看到什么系统从 Spring MVC 迁移到 WebFlux，这又是为什么呢？</p>\n<p>关键还是我们在 11.4 节开头说的，响应式编程并不是银弹，不能解决所有的问题，它也有自己适用的场景。更重要的一点，将系统完全改为响应式的也是有成本的。如果只将 Web 层改为响应式的，底层的所有操作还是阻塞式的调用，那只能将这些调用放到另外的线程池里，这种为了响应式而响应式的做法并不能带来太多的好处。例如，大部分主流的数据库目前还没有响应式的 JDBC 驱动，Spring 官方的 R2DBC（Reactive Relational Database Connectivity）项目 <span class=\"comment-number\">20</span> 现在只支持 H2、PostgreSQL 和 SQL Server 等少数数据库，有些类型的数据库驱动还不是官方支持的。</p>\n<p>另一方面，响应式编程和命令式编程的理解难度不在一个层面上。相对而言，前者学习曲线陡峭、学习成本高。对于大部分系统来说，如果只是处理业务逻辑，那么按指令步骤描述复杂的业务逻辑也许会更易于理解。</p>\n<p>所以，如果我们面对如下的情况，建议在是否迁移到 Project Reactor 和 WebFlux 的问题上三思而后行：</p>\n<ul>\n<li class=\"第3级无序列表\">如果现有的系统运行很正常，是基于传统的 Spring MVC 的技术栈，是命令式风格的，那不建议迁移；</li>\n<li class=\"第3级无序列表\">如果需要进行的各种操作中有很多指令还不是响应式的，例如要使用 Oracle，那不建议迁移；</li>\n<li class=\"第3级无序列表\">如果团队具有一定的规模，大家的技术水平层次不齐，那不建议迁移。</li>\n</ul>\n<p>比较理想的方式是小步快跑，先拿几个小系统或者小功能做些尝试。如果只是做一下请求处理和转发，可以尝试本节后面讲到的 <code>WebClient</code>，用它代替 <code>RestTemplate</code>，先体验一下，觉得适应了之后，再做后续的打算。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>编写简单的 WebHandler</strong></p>\n<p>除了使用注解的方式，Spring WebFlux 还提供了另一种截然不同的方式：我们可以通过编写路由函数和处理器来实现相同的功能。对于不太复杂的逻辑，使用 Lambda 表达式就够了；而对于相对复杂的逻辑，则可以封装在单独的处理器类里。</p>\n<p>先来看看简单的场景，直接在带有 <code>@Configuration</code> 的配置类中编写 <code>RouterFunction</code> 路由函数，将它作为 Bean 配置在 Spring 容器中，表 11-18 列举了开发路由函数时一定会用到的几个接口。<span class=\"comment-number\">21</span></p>\n<p><strong>表 11-18　开发路由函数时常用的接口</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>接口</th><th>说明</th></tr><tr><td><code>RouterFunction</code></td><td>可以将请求路由到一系列请求处理函数上。在实际开发时，通常会用 <code>RouterFunctions</code> 中的静态方法，例如 <code>route()</code> 和 <code>resources()</code>，在 <code>route()</code> 返回的 <code>Builder</code> 中有 <code>GET()</code>、<code>POST()</code> 之类的方法，能快速编写路由函数</td></tr><tr><td><code>HandlerFunction</code></td><td>实际处理请求的函数，一般直接用 Lambda 表达式来实现</td></tr><tr><td><code>RequestPredicate</code></td><td>用来判断请求是否符合路由条件。在实际开发时，通常会用 <code>RequestPredicates</code> 中的静态方法，例如 <code>methods()</code>、<code>accept()</code> 和 <code>queryParam()</code>，分别用来判断请求的 <code>HTTP</code> 方法、<code>Accept</code> 头和查询参数是否符合条件</td></tr><tr><td><code>ServerRequest</code></td><td>代表一个服务端收到的请求，包含了 HTTP 头和正文信息，<code>HandlerFunction</code> 会处理这个请求。其中的 <code>body()</code>、<code>bodyToMono()</code> 和 <code>bodyToFlux()</code> 可以获取请求正文，<code>formData()</code> 直接获取 <code>POST</code> 提交的表单，<code>multipartData()</code> 获取上传的文件</td></tr><tr><td><code>ServerResponse</code></td><td>代表一个服务端返还给客户端的应答。可以通过其中的 <code>ok()</code>、<code>created()</code> 等方法创建特定响应码的应答</td></tr></table>\n\n<p>如果现在希望在 <code>/order</code> 接收 <code>GET</code> 请求，触发查询所有订单，可以编写一段类似代码示例 11-21 那样的代码。通过 <code>RouterFunctions.route().GET()</code> 方法，我们创建了一个处理 <code>/order</code> 的 <code>GET</code> 请求的函数，要求带有 <code>Accept: application/json</code> 请求头，函数直接返回 <code>200 OK</code> 的应答，应答正文是 <code>OrderService.getAllOrders()</code> 返回的 <code>Flux&lt;Order&gt;</code>。</p>\n<blockquote>\n<p><strong>代码示例 11-21</strong>　处理 <code>/order</code> 的 <code>GET</code> 请求的函数</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\npublic class OrderRouterConfig {\n    @Autowired\n    private OrderService orderService;\n\n    @Bean\n    public RouterFunction&lt;?&gt; orderRouter() {\n        return route()\n                .GET(\"/order\",\n                    RequestPredicates.accept(MediaType.APPLICATION_JSON),\n                    request -&gt; ok().body(orderService.getAllOrders(), Order.class))\n                .build();\n    }\n    // 省略其他代码\n}</code></pre>\n<p><code>OrderService</code> 与前面的 <code>MenuService</code> 作用类似，封装了一些 <code>RestTemplate</code> 的操作，后续会被替换为 <code>WebClient</code>。这里的 <code>getAllOrders()</code> 方法如代码示例 11-22 所示。具体说来，通过 <code>RestTemplate.exchange()</code> 取回所有的订单，随后将 <code>List&lt;Order&gt;</code> 转换为 <code>Flux&lt;Order&gt;</code> 返回。</p>\n<blockquote>\n<p><strong>代码示例 11-22</strong>　<code>OrderService.getAllOrders()</code> 方法的实现</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Slf4j\npublic class OrderService {\n    @Value(\"$\")\n    private String binarytea;\n    @Autowired\n    private RestTemplate restTemplate;\n\n    public Flux&lt;Order&gt; getAllOrders() {\n        ParameterizedTypeReference&lt;List&lt;Order&gt;&gt; typeReference =\n                new ParameterizedTypeReference&lt;&gt;() {};\n        RequestEntity&lt;Void&gt; request = RequestEntity.get(URI.create(binarytea + \"/order\"))\n                .accept(MediaType.APPLICATION_JSON).build();\n        ResponseEntity&lt;List&lt;Order&gt;&gt; response = restTemplate.exchange(request, typeReference);\n        if (response.getStatusCode().is2xxSuccessful()) {\n            return Flux.fromIterable(response.getBody());\n        }\n        return Flux.empty();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>如果请求的处理逻辑较为复杂，Lambda 表达式写起来很繁琐的话，可以将逻辑剥离到单独的类里：处理方法接收 <code>ServerRequest</code> 参数，返回 <code>Mono&lt;ServerResponse&gt;</code> 即可。我们以创建订单的请求为例，接收 <code>POST</code> 请求，其中包含订单里的具体条目，将请求处理逻辑放到单独的 <code>OrderHandler</code> 类中，具体如代码示例 11-23 所示。</p>\n<blockquote>\n<p><strong>代码示例 11-23</strong>　负责创建订单的 <code>OrderHandler</code> 和 <code>OrderRequest</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Getter\n@Setter\npublic class OrderRequest {\n    private List&lt;String&gt; items;\n}\n\npublic class OrderHandler {\n    @Autowired\n    private OrderService orderService;\n\n    public Mono&lt;ServerResponse&gt; createNewOrder(ServerRequest request) {\n        Mono&lt;OrderRequest&gt; orderRequest = request.bodyToMono(OrderRequest.class);\n        Mono&lt;Order&gt; order = orderService.createOrder(orderRequest);\n        return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(order, Order.class);\n    }\n}</code></pre>\n<p>具体创建订单的逻辑封装到了 <code>OrderService.createOrder()</code> 方法里，如代码示例 11-24 所示。<code>createOrder()</code> 先将 <code>Mono&lt;OrderRequest&gt;</code> 转换为 <code>NewOrderForm</code>，随后发送 <code>POST</code> 请求将表单提交给服务端，再过滤应答，如果是返回 2xx 状态码代表成功应答，此时再将正文的订单信息转换为 <code>Mono&lt;Order&gt;</code>。其中用到的折扣信息可以用 <code>binarytea.order.discount</code> 配置项的形式配在 <code>application.properties</code> 里。</p>\n<blockquote>\n<p><strong>代码示例 11-24</strong>　<code>OrderService.createOrder()</code> 方法的实现</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Slf4j\npublic class OrderService {\n    @Value(\"$\")\n    private int discount;\n    @Value(\"$\")\n    private String binarytea;\n    @Autowired\n    private RestTemplate restTemplate;\n\n    public Mono&lt;Order&gt; createOrder(Mono&lt;OrderRequest&gt; orderRequest) {\n        return orderRequest\n                .map(r -&gt; NewOrderForm.builder().itemIdList(r.getItems()).discount(discount).build())\n                .map(f -&gt; restTemplate.postForEntity(binarytea + \"/order\", f, Order.class))\n                .filter(e -&gt; e.getStatusCode().is2xxSuccessful())\n                .map(e -&gt; e.getBody())\n                .log();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>最后，还需要调整一下 <code>OrderRouterConfig</code>，让 <code>orderRouter()</code> 知道如何处理这个 <code>POST</code> 请求，代码示例 11-25 是修改后的配置，主要是加了一行 <code>.POST(\"/order\", orderHandler()::createNewOrder)</code>，告诉 <code>RouterFunction.Builder</code>，发给 <code>/order</code> 的 <code>POST</code> 请求都转给 <code>OrderHandler.createNewOrder()</code>。</p>\n<blockquote>\n<p><strong>代码示例 11-25</strong>　增加了 <code>POST</code> 请求路由的 <code>OrderRouterConfig</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\npublic class OrderRouterConfig {\n    @Autowired\n    private OrderService orderService;\n\n    @Bean\n    public RouterFunction&lt;?&gt; orderRouter() {\n        return route()\n                .GET(\"/order\",\n                    RequestPredicates.accept(MediaType.APPLICATION_JSON),\n                    request -&gt; ok().body(orderService.getAllOrders(), Order.class))\n                .POST(\"/order\", orderHandler()::createNewOrder)\n                .build();\n    }\n\n    @Bean\n    public OrderHandler orderHandler() {\n        return new OrderHandler();\n    }\n}</code></pre>\n</li>\n</ol>\n\n\n\n<h3 id=\"nav_point_186\">11.4.3　通过 WebClient 访问 Web 资源</h3>\n<p>在 Spring Framework 5.0 之前，推荐使用 <code>RestTemplate</code> 发起各种 Web 请求，其中封装了各类常用的 HTTP 操作，我们在本书之前的章节里也大量使用了这个类。从 5.0 版本开始，官方在添加了 WebFlux 之后，也同时提供了与之配套的响应式 Web 客户端——<code>WebClient</code>，并且推荐无论是否使用 WebFlux，是否使用响应式编程风格，都使用 <code>WebClient</code> 来发起 HTTP 操作。</p>\n<p>官方的说法是 <code>RestTemplate</code> 后续只做基本的维护，不会再有大的升级。但从目前的情况来看，<code>RestTemplate</code> 和 <code>WebClient</code> 在功能上并没有太大的区别，主要的差异是前者是阻塞式的，后者是响应式的。但是由于 <code>WebClient</code> 是在 spring-webflux 包里的，如果不引入这个依赖就无法使用 <code>WebClient</code>，试问一个主要使用 Spring MVC 的系统，为什么要引入 WebFlux 的依赖呢？因此，个人还是建议仅在使用响应式编程风格的系统中使用新的 <code>WebClient</code> 客户端。</p>\n<p>在本节的最后一部分里，我们来一起了解一下如何使用 <code>WebClient</code>。</p>\n<ol>\n<li><p><strong>基本使用</strong></p>\n<p><code>WebClient</code> 本身是一个接口，实际使用的是 <code>DefaultWebClient</code>，Spring Framework 为我们提供了两种创建 <code>WebClient</code> 的方法。</p>\n<ul>\n<li><code>WebClient.create()</code> 方法，通过不带任何参数的 <code>create()</code> 方法可以创建一个默认的 <code>WebClient</code> 实现，如果传入 <code>baseUrl</code>（例如 http://localhost:8080），则返回的实现会有默认的 URL 前缀，在发起请求时只需要给出 URL 的后半部分就可以了（例如给定 <code>/menu</code>，实际的请求会拼上前缀，最终的 URL 是 http://localhost:8080/menu）。</li>\n<li><code>WebClient.Builder</code> 构造器，通过这个构造器可以直接设置大量参数，Spring Boot 自动配置会创建一个 <code>WebClient.Builder</code> Bean，我们可以直接注入后调用 <code>build()</code> 方法创建自己的 <code>WebClient</code>。Spring Boot 还提供了 <code>WebClientCustomizer</code> 接口，可以用它完成对自动配置的 <code>WebClient.Builder</code> 的自定义。</li>\n</ul>\n<p>在代码里，可以像下面这样创建自己的 <code>WebClient</code>：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic WebClient webClient(WebClient.Builder builder,\n@Value(\"$\") String binarytea) {\n    return builder.baseUrl(binarytea).build();\n}</code></pre>\n<p>在获得了 <code>WebClient</code> 后，就可以指定要发起的请求了，大致的请求和应答处理过程是下面这样的。</p>\n<ul>\n<li>使用 <code>get()</code>、<code>post()</code>、<code>put()</code>、<code>delete()</code>、<code>head()</code> 等方法指定具体的 <code>HTTP</code> 请求方法，也可以用 <code>method()</code> 方法指定。</li>\n<li>使用 <code>uri()</code> 指定目标 URI，使用 <code>accept()</code>、<code>contentType()</code> 等方法指定请求的相关信息。</li>\n<li>使用 <code>body()</code> 或 <code>bodyValue()</code> 指定请求的正文，前者可以接受 <code>Mono</code>、<code>Flux</code> 等类型，后者直接接受现成的对象。</li>\n<li><code>retrieve()</code> 方法执行请求并获取应答，<code>retrieve()</code> 方法之前都是请求相关的逻辑，之后放的就都是和应答相关的逻辑了。</li>\n<li>对于应答，可以用 <code>bodyToMono()</code> 和 <code>bodyToFlux()</code> 结合具体的类信息 <span class=\"comment-number\">22</span>，将应答正文转换为对应的 <code>Mono</code> 和 <code>Flux</code>；也可以用 <code>toEntity()</code>、<code>toEntityList()</code> 和 <code>toBodilessEntity()</code> 将应答转换为 <code>ResponseEntity</code>。</li>\n</ul>\n<p>在代码示例 11-19 中，我们写过一个与菜单相关的服务类 <code>MenuService</code>，其中用的是 <code>RestTemplate</code>，现在我们要改用 <code>WebClient</code>，具体如代码示例 11-26 所示。<span class=\"comment-number\">23</span> 改用 <code>WebClient</code> 后整个 <code>MenuController</code> 的 WebFlux 控制器的操作就都是响应式的了，其中不带同步的阻塞部分，在返回 <code>Mono</code> 或 <code>Flux</code> 前，我们还通过 <code>timeout()</code> 设置了一下获取结果的超时时间。</p>\n<blockquote>\n<p><strong>代码示例 11-26</strong>　使用了 <code>WebClient</code> 的 <code>MenuService</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\npublic class MenuService {\n    @Autowired\n    private WebClient webClient;\n\n    public Flux&lt;MenuItem&gt; getAllMenu() {\n        return webClient.get().uri(\"/menu\")\n                          .accept(MediaType.APPLICATION_JSON)\n                          .retrieve().bodyToFlux(MenuItem.class)\n                          .timeout(Duration.ofSeconds(1));\n    }\n\n    public Mono&lt;MenuItem&gt; getById(Long id) {\n        return webClient.get().uri(\"/menu/\", id)\n                          .retrieve().bodyToMono(MenuItem.class)\n                          .timeout(Duration.ofSeconds(1));\n    }\n}</code></pre>\n<p>HTTP 的 <code>GET</code> 方法没有请求正文，对于 <code>POST</code> 这样的请求，需要设置正文，具体如代码示例 11-27 所示，其中，通过 <code>body(form, NewOrderForm.class)</code> 将 <code>NewOrdeForm</code> 类型的对象设置为正文。除了一个具体的对象，还可以传入一个 <code>BodyInserter</code>，<code>BodyInserters</code> 抽象类里提供了好多有用的辅助方法，例如，<code>BodyInserters.fromFormData()</code> 可以用来传递表单数据，<code>BodyInserters.fromMultipartData()</code> 可以用来传递 Multipart 数据（上传文件时会用到），而 <code>BodyInserters.fromValue()</code> 就和直接传对象是一样的效果。</p>\n<blockquote>\n<p><strong>代码示例 11-27</strong>　通过 <code>WebClient</code> 发起 <code>POST</code> 请求</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Slf4j\npublic class OrderService {\n    @Value(\"$\")\n    private int discount;\n    @Autowired\n    private WebClient webClient;\n\n    public Mono&lt;Order&gt; createOrder(Mono&lt;OrderRequest&gt; orderRequest) {\n        Mono&lt;NewOrderForm&gt; form = orderRequest.map(r -&gt;\n             NewOrderForm.builder().itemIdList(r.getItems())\n                          .discount(discount).build());\n        return webClient.post().uri(\"/order\")\n                          .body(form, NewOrderForm.class)\n                          .retrieve()\n                          .bodyToMono(Order.class);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>除了返回 <code>Mono</code> 和 <code>Flux</code> 用于各类非阻塞的场景，<code>WebClient</code> 也可以用于同步的场景，调用 <code>block()</code> 方法阻塞等待，取得结果后再返回，<code>block()</code> 里也可以传入超时时间。如代码示例 11-28 所示，这是 <code>WaitForOpenRunner</code> 的 <code>isOpen()</code> 方法，通过访问服务端来判断门店状态，由于只需要响应中的响应码，所以直接用了 <code>toBodilessEntity()</code> 将结果转换为没有正文的 <code>ResponseEntity&lt;Void&gt;</code>，随后 <code>block()</code> 等待。</p>\n<blockquote>\n<p><strong>代码示例 11-28</strong>　使用了 <code>WebClient</code> 的 <code>WaitForOpenRunner</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class WaitForOpenRunner implements ApplicationRunner, ApplicationContextAware {\n    private boolean isOpen() {\n        try {\n            ResponseEntity&lt;Void&gt; entity = webClient.get().uri(\"/menu\")\n                .retrieve().toBodilessEntity().block();\n            return entity.getStatusCode().is2xxSuccessful();\n        } catch (Exception e) {\n            log.warn(\"应该还没开门，访问出错：{}\", e);\n        }\n        return false;\n    }\n    // 省略其他代码\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>进阶配置</strong></p>\n<p><code>RestTemplate</code> 给我们留了很多能够进行自定义的扩展点，<code>WebClient</code> 作为它的后辈，自然也继承了前辈的优良传统。首先，<code>WebClient</code> 通过 <code>ClientHttpConnector</code> 封装了底层客户端，内置了对多种不同的客户端的支持，具体如表 11-19 所示。</p>\n<p><strong>表 11-19　内置的响应式 HTTP 客户端</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>客户端</th><th>依赖项</th><th><code>ClientHttpConnector</code> 实现</th></tr><tr><td>Reactor Netty</td><td><code>io.projectreactor.netty:reactor-netty-http</code></td><td><code>ReactorClientHttpConnector</code></td></tr><tr><td>Jetty Reactive HttpClient</td><td><code>org.eclipse.jetty:jetty-reactive-httpclient</code></td><td><code>JettyClientHttpConnector</code></td></tr><tr><td>Apache HttpComponents</td><td><code>org.apache.httpcomponents.client5:httpclient5</code><sup><b>24</b></sup></td><td><code>HttpComponentsClientHttpConnector</code></td></tr></table>\n\n<blockquote>\n<p><sup><b>24</b></sup>Spring Boot 的依赖里没有这一项，在项目里添加时需要自己填写版本，例如 5.0.3。另外，在运行时还需要增加 <code>org.apache.httpcomponents.core5:httpcore5-reactive</code> 依赖。</p>\n</blockquote>\n<p>因为 Spring Boot 的 spring-boot-starter-webflux 默认引入了 Reactor Netty 作为容器，CLASSPATH 中有 Netty 的库，所以 <code>ClientHttpConnectorAutoConfiguration</code> 会自动配置 <code>ReactorClientHttpConnector</code>。如果我们自己配置了一个 <code>ClientHttpConnector</code> 类型的 Bean，就能覆盖默认的自动配置，例如我们希望使用 Spring WebFlux 5.3 版本增加的 HttpComponents 客户端支持，就可以在 pom.xml 添加相应依赖后再像代码示例 11-29 那样配置自己的 <code>ClientHttpConnector</code>。</p>\n<blockquote>\n<p><strong>代码示例 11-29</strong>　支持 HttpComponents 的客户端 <code>ClientHttpConnector</code> 配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\npublic class CustomerApplication {\n    @Bean\n    public ClientHttpConnector clientHttpConnector() {\n        HttpAsyncClientBuilder clientBuilder = HttpAsyncClients.custom();\n        clientBuilder.disableAutomaticRetries()\n                       .setDefaultRequestConfig(RequestConfig.custom()\n                       .setConnectionRequestTimeout(1, TimeUnit.SECONDS)\n                       .setConnectTimeout(1, TimeUnit.SECONDS).build())\n                       // 省略其他各种客户端相关配置，具体见源码\n                       .evictIdleConnections(TimeValue.ofMinutes(10));\n        CloseableHttpAsyncClient client = clientBuilder.build();\n        return new HttpComponentsClientHttpConnector(client);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>在上面的代码里我们设置了默认的请求超时时间，其实，大量与底层客户端或者请求有关的配置，都可以通过配置自己的 <code>ClientHttpConnector</code> 来实现。Reactor Netty 和 Jetty Reactive HttpClient 的 <code>ClientHttpConnector</code> 配置方法与上面的类似。</p>\n<p>在 10.5 节中，我们还为客户端增加了 JWT 令牌的认证，在 <code>WebClient</code> 中如果希望为每个请求都增加些通用的处理逻辑，可以增加自己的过滤器，即 <code>ExchangeFilterFunction</code> 实现。代码示例 11-30 的作用与 10.5 节中的 <code>JwtClientHttpRequestInitializer</code> 类似，为请求添加了 JWT 令牌，需要注意的是，此处建议在要修改 <code>ClientRequest</code> 时创建一个新的对象，修改后再向下传递。</p>\n<blockquote>\n<p><strong>代码示例 11-30</strong>　为请求头中添加 <code>Authorization</code> 头的 <code>ExchangeFilterFunction</code> 实现</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class JwtExchangeFilterFunction implements ExchangeFilterFunction {\n    @Override\n    public Mono&lt;ClientResponse&gt; filter(ClientRequest request, ExchangeFunction next) {\n        if (StringUtils.isBlank(token)) {\n            initToken();\n        }\n        if (StringUtils.isBlank(token) ||\n            request.headers().containsKey(HttpHeaders.AUTHORIZATION)) {\n            return next.exchange(request);\n        }\n        ClientRequest filtered = ClientRequest.from(request)\n            .header(HttpHeaders.AUTHORIZATION, \"Bearer \" + token)\n            .build();\n        return next.exchange(filtered);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>有了 <code>ExchangeFilterFunction</code> 后，就可以在 <code>WebClient.Builder</code> 构造 <code>WebClient</code> 时，使用 <code>filter()</code> 方法将我们的过滤器赋给待创建的 <code>WebClient</code>，如代码示例 11-31 那样。</p>\n<blockquote>\n<p><strong>代码示例 11-31</strong>　为 <code>WebClient</code> 添加过滤器</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\npublic class CustomerApplication {\n    @Bean\n    public WebClient webClient(WebClient.Builder builder,\n    @Value(\"$\") String binarytea) {\n        return builder.baseUrl(binarytea)\n                .filter(jwtExchangeFilterFunction(builder)).build();\n    }\n\n    @Bean\n    public JwtExchangeFilterFunction jwtExchangeFilterFunction(WebClient.Builder builder) {\n        return new JwtExchangeFilterFunction(builder);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>如果过滤器的逻辑比较简单，我们也完全可以考虑直接使用 Lambda 表达式在 <code>filter()</code> 方法中完成逻辑的开发，或者直接使用 <code>ExchangeFilterFunctions</code> 抽象类里提供的常用过滤器实现，例如 <code>ExchangeFilterFunctions.basicAuthentication()</code> 就可以实现通用的 HTTP Basic 认证。</p>\n</li>\n</ol>\n\n\n<h2 id=\"nav_point_187\">11.5　小结</h2>\n<p>本章我们具体了解了如何在 Web 项目中通过 <code>HandlerInterceptor</code> 实现类似 AOP 的操作，如何通过 <code>@ExceptionHandler</code> 处理请求异常，如何定制 Web 容器的各种细节，如何支持 HTTPS 和 HTTP/2。还从宏观层面上讨论了分布式 Session 的几种实现方式，并使用 Spring Session 简单实现了基于 RDBMS 和 Redis 的分布式 Session。最后还一起看了看 Spring Framework 5.0 新加的响应式 Web 框架 WebFlux，以及对应客户端 <code>WebClient</code> 的用法。Spring WebMVC 和 WebFlux 是两套完全并行的 Web 框架，大家可以根据实际情况选择合适的框架。</p>\n<p>从下一章开始，我们将翻开一个全新的篇章，学习如何使用 Spring 提供的各种组件，开发稳定高可用的微服务系统。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结到</strong></p>\n<p>目前为止，我们的二进制奶茶店已经有了一个 Web 管理的界面，店员可以在界面上直接为顾客下单。界面虽然简陋，但功能却是完整的，甚至还包含了一整套基于角色的权限管理体系。</p>\n<p>为了提升整个奶茶店系统的性能、稳定性和安全性，我们对系统运行的容器进行了一轮调整，还增加了常见攻击方式的防御措施，选择性开启了 HTTPS 与 HTTP/2 的支持。如果后续系统做大了，可以把二进制奶茶店的系统从单机变为一个集群，而分布式 Session 的问题，我们已经通过 Spring Session 解决了（如果真的变成一个集群，记得把数据库从内存中存储数据的 H2 换成独立的 MySQL）。</p>\n<p>对于顾客使用的客户端，原先的客户端只能做固定的几件事；现在我们也为客户端增加了一些可人工介入操作的接口，比如人为模拟顾客查看菜单和下单等操作。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 11 章 Web 开发进阶(2)","id":740883},"right":{"article_title":"第四部分 使用 Spring 开发微服务","id":740885}},"comments":[]}