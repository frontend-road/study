{"id":5175,"title":"52 | 管理设计篇之“分布式锁”","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p>\n<p>我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。在分布式系统下，这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库DB、Redis和ZooKeeper等实现。不管怎么样，分布式的锁服务需要有以下几个特点。</p>\n<ul>\n<li>\n<p><strong>安全性（Safety）</strong>：在任意时刻，只有一个客户端可以获得锁（<strong>排他性</strong>）。</p>\n</li>\n<li>\n<p><strong>避免死锁</strong>：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。</p>\n</li>\n<li>\n<p><strong>容错性</strong>：只要锁服务集群中的大部分节点存活，Client就可以进行加锁解锁操作。</p>\n</li>\n</ul>\n<h1>Redis的分布式锁服务</h1>\n<p>这里提一下，避免死锁的问题。下面以Redis的锁服务为例（参考 <a href=\"https://redis.io/topics/distlock\">Redis的官方文档</a> ）。</p>\n<p>我们通过以下命令对资源加锁。</p>\n<pre><code>SET resource_name my_random_value NX PX 30000\n</code></pre>\n<p>解释一下：</p>\n<ul>\n<li>\n<p><code>SET NX</code> 命令只会在 <code>key</code> 不存在的时候给 <code>key</code> 赋值，<code>PX</code> 命令通知Redis保存这个key 30000ms。</p>\n</li>\n<li>\n<p><code>my_random_value</code> 必须是全局唯一的值。这个随机数在释放锁时保证释放锁操作的安全性。</p>\n</li>\n<li>\n<p>PX 操作后面的参数代表的是这个key的存活时间，称作锁过期时间。</p>\n</li>\n<li>\n<p>当资源被锁定超过这个时间时，锁将自动释放。</p>\n</li>\n<li>\n<p>获得锁的客户端如果没有在这个时间窗口内完成操作，就可能会有其他客户端获得锁，引起争用问题。</p>\n</li>\n</ul>\n<p>这里的原理是，只有在某个key不存在的情况下才能设置（set）成功该key。于是，这就可以让多个进程并发去设置同一个key，只有一个进程能设置成功。而其它的进程因为之前有人把key设置成功了，而导致失败（也就是获得锁失败）。</p>\n<!-- [[[read_end]]] -->\n<p>我们通过下面的脚本为申请成功的锁解锁：</p>\n<pre><code>if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then \n    return redis.call(&quot;del&quot;,KEYS[1]) \nelse \n    return 0 \nend\n</code></pre>\n<p>如果key对应的value一致，则删除这个key。</p>\n<p>通过这个方式释放锁是为了避免Client释放了其他Client申请的锁。</p>\n<p>例如，下面的例子演示了不区分Client会出现的一种问题。</p>\n<ol>\n<li>Client A 获得了一个锁。</li>\n<li>当尝试释放锁的请求发送给Redis时被阻塞，没有及时到达Redis。</li>\n<li>锁定时间超时，Redis认为锁的租约到期，释放了这个锁。</li>\n<li>Client B 重新申请到了这个锁。</li>\n<li>Client A的解锁请求到达，将Client B锁定的key解锁。</li>\n<li>Client C 也获得了锁。</li>\n<li>Client B 和Client C 同时持有锁。</li>\n</ol>\n<p>通过执行上面脚本的方式释放锁，Client的解锁操作只会解锁自己曾经加锁的资源，所以是安全的。</p>\n<p>关于value的生成，官方推荐从 /dev/urandom中取20个byte作为随机数。或者采用更加简单的方式，例如使用RC4加密算法在 /dev/urandom中得到一个种子（Seed），然后生成一个伪随机流。</p>\n<p>也可以采用更简单的方法，使用时间戳+客户端编号的方式生成随机数。Redis的官方文档说：“这种方式的安全性较差一些，但对于绝大多数的场景来说已经足够安全了”。</p>\n<h1>分布式锁服务的一个问题</h1>\n<p>注意，虽然Redis文档里说他们的分布式锁是没有问题的，但其实还是很有问题的。尤其是上面那个为了避免Client端把锁占住不释放，然后，Redis在超时后把其释放掉。不知道你怎么想，但我觉得这事儿听起来就有点不靠谱。</p>\n<p>我们来脑补一下，不难发现下面这个案例。</p>\n<ul>\n<li>\n<p>如果Client A先取得了锁。</p>\n</li>\n<li>\n<p>其它Client（比如说Client B）在等待Client A的工作完成。</p>\n</li>\n<li>\n<p>这个时候，如果Client A被挂在了某些事上，比如一个外部的阻塞调用，或是CPU被别的进程吃满，或是不巧碰上了Full GC，导致Client A 花了超过平时几倍的时间。</p>\n</li>\n<li>\n<p>然后，我们的锁服务因为怕死锁，就在一定时间后，把锁给释放掉了。</p>\n</li>\n<li>\n<p>此时，Client B获得了锁并更新了资源。</p>\n</li>\n<li>\n<p>这个时候，Client A服务缓过来了，然后也去更新了资源。于是乎，把Client B的更新给冲掉了。</p>\n</li>\n<li>\n<p>这就造成了数据出错。</p>\n</li>\n</ul>\n<p>这听起来挺严重的吧。我画了个图示例一下。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/93/89/937d9975899662d90a96f4cd70580d89.png?wh=864*387\" alt=\"\" /></p>\n<p>千万不要以为这是脑补出来的案例。其实，这个是真实案例。HBase就曾经遇到过这样的问题，你可以在他们的PPT（<a href=\"https://www.slideshare.net/enissoz/hbase-and-hdfs-understanding-filesystem-usage\">HBase and HDFS: Understanding FileSystem Usage in HBase</a>）中看到相关的描述。</p>\n<p>要解决这个问题，你需要引入fence（栅栏）技术。一般来说，这就是乐观锁机制，需要一个版本号排它。我们的流程就变成了下图中的这个样子。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/ce/c3/ce3454e9a8bbfe4628899391c003a5c3.png?wh=864*383\" alt=\"\" /></p>\n<p>我们从图中可以看到：</p>\n<ul>\n<li>锁服务需要有一个单调递增的版本号。</li>\n<li>写数据的时候，也需要带上自己的版本号。</li>\n<li>数据库服务需要保存数据的版本号，然后对请求做检查。</li>\n</ul>\n<p>如果使用ZooKeeper做锁服务的话，那么可以使用 <code>zxid</code> 或 znode的版本号来做这个fence 版本号。</p>\n<h1>从乐观锁到CAS</h1>\n<p>但是，我们想想，如果数据库中也保留着版本号，那么完全可以用数据库来做这个锁服务，不就更方便了吗？下面的图展示了这个过程。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/95/41/9557fb5b7269eb5d7d53568298803141.png?wh=847*270\" alt=\"\" /></p>\n<p>使用数据版本（Version）记录机制，即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现的。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。</p>\n<p>当我们提交更新的时候，数据库表对应记录的当前版本信息与第一次取出来的version值进行比对。如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。更新语句写成SQL大概是下面这个样子：</p>\n<pre><code>UPDATE table_name SET xxx = #{xxx}, version=version+1 where version =#{version};\n</code></pre>\n<p>这不就是乐观锁吗？是的，这是乐观锁最常用的一种实现方式。<strong>是的，如果我们使用版本号，或是fence token这种方式，就不需要使用分布式锁服务了。</strong></p>\n<p>另外，多说一下。这种fence token的玩法，在数据库那边一般会用timestamp时间截来玩。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p>\n<p>还有，我们有时候都不需要增加额外的版本字段或是fence token。比如，如果想更新库存，我们可以这样操作：</p>\n<pre><code>SELECT stock FROM tb_product where product_id=#{product_id};\nUPDATE tb_product SET stock=stock-#{num} WHERE product_id=#{product_id} AND stock=#{stock};\n</code></pre>\n<p>先把库存数量（stock）查出来，然后在更新的时候，检查一下是否是上次读出来的库存。如果不是，说明有别人更新过了，我的UPDATE操作就会失败，得重新再来。</p>\n<p>细心的你一定发现了，这不就是计算机汇编指令中的原子操作CAS（Compare And Swap）嘛，大量无锁的数据结构都需要用到这个。（关于CAS的话题，你可以看一下我在CoolShell上写的<a href=\"https://coolshell.cn/articles/8239.html\">无锁队列的实现</a> ）。</p>\n<p><strong>我们一步一步地从分布式锁服务到乐观锁，再到CAS，你看到了什么？你是否得思考一个有趣的问题——我们还需要分布式锁服务吗？</strong></p>\n<h1>分布式锁设计的重点</h1>\n<p>最后，我们来谈谈分布式锁设计的重点。</p>\n<p>一般情况下，我们可以使用数据库、Redis或ZooKeeper来做分布式锁服务，这几种方式都可以用于实现分布式锁。</p>\n<p>分布式锁的特点是，保证在一个集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。这就是所谓的分布式互斥。所以，大家在做某个事的时候，要去一个服务上请求一个标识。如果请求到了，我们就可以操作，操作完后，把这个标识还回去，这样别的进程就可以请求到了。</p>\n<p>首先，我们需要明确一下分布式锁服务的初衷和几个概念性的问题。</p>\n<ul>\n<li>\n<p>如果获得锁的进程挂掉了怎么办？锁还不回来了，会导致死锁。一般的处理方法是在锁服务那边加上一个过期时间，如果在这个时间内锁没有被还回来，那么锁服务要自动解锁，以避免全部锁住。</p>\n</li>\n<li>\n<p>如果锁服务自动解锁了，新的进程就拿到锁了，但之前的进程以为自己还有锁，那么就出现了两个进程拿到了同一个锁的问题，它们在更新数据的时候就会产生问题。对于这个问题，我想说：</p>\n</li>\n<li>\n<p>像Redis那样也可以使用Check and Set的方式来保证数据的一致性。这就有点像计算机原子指令CAS（Compare And Swap）一样。就是说，我在改变一个值的时候先检查一下是不是我之前读出来的值，这样来保证其间没有人改过。</p>\n</li>\n<li>\n<p>如果通过像CAS这样的操作的话，我们还需要分布式锁服务吗？的确是不需要了，不是吗？</p>\n</li>\n<li>\n<p>但现实生活中也有不需要更新某个数据的场景，只是为了同步或是互斥一下不同机器上的线程，这时候像Redis这样的分布式锁服务就有意义了。</p>\n</li>\n</ul>\n<p>所以，需要分清楚：我是用来修改某个共享源的，还是用来不同进程间的同步或是互斥的。如果使用CAS这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。<strong>所以，这是我们在决定使用分布式锁服务前需要考虑的第一个问题——我们是否需要？</strong></p>\n<p>如果确定要分布式锁服务，你需要考虑下面几个设计。</p>\n<ul>\n<li>\n<p>需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。Redis使用超时时间，ZooKeeper可以依靠自身的sessionTimeout来删除节点。</p>\n</li>\n<li>\n<p>分布式锁服务应该是高可用的，而且是需要持久化的。对此，你可以看一下 <a href=\"https://redis.io/topics/distlock\">Redis的文档RedLock</a> 看看它是怎么做到高可用的。</p>\n</li>\n<li>\n<p>要提供非阻塞方式的锁服务。</p>\n</li>\n<li>\n<p>还要考虑锁的可重入性。</p>\n</li>\n</ul>\n<p>我认为，Redis也是不错的，ZooKeeper在使用起来需要有一些变通的方式，好在Apache有 <a href=\"https://curator.apache.org/\">Curator</a> 帮我们封装了各种分布式锁的玩法。</p>\n<h1>小结</h1>\n<p>好了，我们来总结一下今天分享的主要内容。首先，我介绍了为什么需要分布式锁。就像单机系统上的多线程程序需要用操作系统锁或数据库锁来互斥对共享资源的访问一样，分布式程序也需要通过分布式锁来互斥对共享资源的访问。</p>\n<p>分布式锁服务一般可以通过Redis和ZooKeeper等实现。接着，以Redis为例，我介绍了怎样用它来加锁和解锁，由此引出了锁超时后的潜在风险。我们看到，类似于数据库的乐观并发控制，这种风险可以通过版本号的方式来解决。</p>\n<p>进一步，数据库如果本身利用CAS等手段支持这种版本控制方式，其实也就没必要用一个独立的分布式锁服务了。最后，我们发现，分布式锁服务还能用来做同步，这是数据库锁做不了的事情。下节课中，我们将聊聊配置中心相关的技术，希望对你有帮助。</p>\n<p>也欢迎你分享一下你在留言区给我分享下哪些场景下你会用到锁？你都用哪种平台的锁服务？有没有用到数据库锁？是OCC，还是悲观锁？如果是悲观锁的话，你又是怎样避免死锁的？</p>\n<p>我在这里给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。</p>\n<ul>\n<li>弹力设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/3912\">认识故障和弹力设计</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3917\">隔离设计Bulkheads</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3926\">异步通讯设计Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4050\">幂等性设计Idempotency</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4086\">服务的状态State</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4087\">补偿事务Compensating Transaction</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4121\">重试设计Retry</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4241\">熔断设计Circuit Breaker</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4245\">限流设计Throttle</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4252\">降级设计degradation</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4253\">弹力设计总结</a></li>\n</ul>\n</li>\n<li>管理设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/5175\">分布式锁Distributed Lock</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5819\">配置中心Configuration Management</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5909\">边车模式Sidecar</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5920\">服务网格Service Mesh</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6086\">网关模式Gateway</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6283\">部署升级策略</a></li>\n</ul>\n</li>\n<li>性能设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/6282\">缓存Cache</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7036\">异步处理Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7045\">数据库扩展</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7047\">秒杀Flash Sales</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7086\">边缘计算Edge Computing</a></li>\n</ul>\n</li>\n</ul>\n","comments":[{"had_liked":false,"id":105270,"user_name":"yun","can_delete":false,"product_type":"c1","uid":1054906,"ip_address":"","ucode":"3727BF0E566A76","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ba/fb86482f.jpg","comment_is_top":false,"comment_ctime":1560952168,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"138999905640","product_id":100002201,"comment_content":"对资源修改，用cas而不是分布式锁，我反对<br>1:前提是共享资源的修改得提供cas,比如我要更新hdfs,然后再在hbase上更新meta,为了保证一致性，要用分布式锁<br>2，资源一存储在hbase,支持cas,资源二redis上，二者都支持cas,服务更新数据时要更新二者，服务是多个进城并发干，为了保证一致性，得有分布式锁，单个数据库的cas不行<br><br>cas和分布式锁是两个完全不同的东西，cas像是单机的乐观锁，能用cas的话，不用分布式式锁，那不废话吗？能单机干的，谁会上分布式<br>你跨多个服务，搞一个cas,试试？<br><br>文中的令牌和cas，他们间确实类似。但是分布式锁中带令牌，就是为了解决，客户端认为占有锁，到实际锁过期的问题，此时没必要对比cas<br><br>","like_count":33,"discussions":[{"author":{"id":1079439,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/8f/0d927ab3.jpg","nickname":"Shawn","note":"","ucode":"B8171A0BEA2FE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284779,"discussion_content":"1和2都有两部分内容要更新。对于1，如果client要先更新hdfs、再更新hbase，这是分布式事务；如果hbase的更新源自hdfs，可以使用耗子叔说的乐观锁。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1592635151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1955387,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eokorAhvqntTTW1WHK8R296w86X6mb9GQ2v54WtQHPHHsib0Dl9t5FiapGFju38Evj2NFDsAK63ib5kg/132","nickname":"Geek_795ad0","note":"","ucode":"5F20F7E2E90809","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239075,"discussion_content":"尽信书不如无书","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1587271243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/20/99/64046484.jpg","nickname":"摸摸头","note":"","ucode":"0F950175028B05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411326,"discussion_content":"我觉得耗子叔说的没错，你这场景表面是对资源的修改，实际是需要两个操作的同步。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635902936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319159,"discussion_content":"我觉得，理解有点偏颇啊。我的理解是，能不用锁解决的，就不用锁。能用cas解决的，就不用分布式锁。锁的范围不一样，这是作者的意思吧！你的问题，似乎一直在偏离业务说技术。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603953906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1642539,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/2b/2ac7f9d8.jpg","nickname":"Mr.木易","note":"","ucode":"AD385D240EF362","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357755,"discussion_content":"你说的第二点更像是分布式事务 你需要一个全局锁，跟博主的讨论的锁不是一个范畴 ，博主说的只是对单一的资源如果有修改用cas 完全没问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615861449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504610,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/62/629fc805.jpg","nickname":"国产宋炳具","note":"","ucode":"E56D46099E5A23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161894,"discussion_content":"能单机干的上分布式，很大的原因是为了做High-Availability","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580934995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2811447,"avatar":"","nickname":"Geek1691","note":"","ucode":"70A6984847DB94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569570,"discussion_content":"支持楼主的观点，至少从皓哥在文中没有把比较的前提说的很清楚，在楼主说的场景下分布式锁+版本号控制才能有效的解决问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651483598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/d8/425e1b0a.jpg","nickname":"小虾米","note":"","ucode":"F543987A7FAB20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393720,"discussion_content":"在这个应用场景你说得对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631579771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033748,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/14/3f206319.jpg","nickname":"Finch","note":"","ucode":"627124740E3940","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392259,"discussion_content":"耗子叔是在更高的抽象看问题，你还在技术层面，反对无效。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630924916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024997,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/e5/abb7bfe3.jpg","nickname":"fangyu","note":"","ucode":"F966F0607E4C0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386568,"discussion_content":"cas和分布式锁本质是一样的，cas就是trylock","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627643138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512462,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/0e/87d15656.jpg","nickname":"随心","note":"","ucode":"ADB430EA88DB75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343936,"discussion_content":"跨多个服务cas：cas task（hbase+redis+...）status into executing and start transaction with setting timeout，是否可行呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611213897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293889,"discussion_content":"部分同意，确实有一些资源的修改不能用CAS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595717333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155414,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a1/56/ad5dba39.jpg","nickname":"moliniao","note":"","ucode":"D38D159E960FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5944,"discussion_content":"比较同意你的说法哦 嘿嘿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566545736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":5907,"user_name":"Randy","can_delete":false,"product_type":"c1","uid":1087777,"ip_address":"","ucode":"631235F01A7C0A","user_header":"","comment_is_top":false,"comment_ctime":1524115800,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"121783200088","product_id":100002201,"comment_content":"现实生活中也有不需要更新某个数据的场景，只是为了同步或是互斥一下不同机器上的线程，这时候像 Redis 这样的分布式锁服务就有意义了<br>这句没明白，如果要进行互斥或同步操作，那就是要对同一个资源进行写操作，如果只是读操作那就不需要锁保护了，那分布式锁的意义是什么？","like_count":28,"discussions":[{"author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"赵强强","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6228,"discussion_content":"1、查询并更新缓存场景，加锁可以阻止多线程并发更新。\n2、有时为保护系统资源，希望某类任务串行进行。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1566796870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1499380,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","nickname":"不会爬树的熊","note":"","ucode":"E417D8D9D5FED2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073596,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/bc/88a905a5.jpg","nickname":"赵强强","note":"","ucode":"1B8AE07484C69A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236375,"discussion_content":"你这个解释最终目的还是更新同一数据源啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587089429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6228,"ip_address":""},"score":236375,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1499380,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","nickname":"不会爬树的熊","note":"","ucode":"E417D8D9D5FED2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583914,"discussion_content":"串行执行不一定需要更新数据源啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660487473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236375,"ip_address":"北京"},"score":583914,"extra":""}]},{"author":{"id":2400757,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a1/f5/163de665.jpg","nickname":"Mr.L","note":"","ucode":"E180F5329D8F87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394954,"discussion_content":"这句话的意思应该是，如果要保证同一时间只有一个线程操作资源，就需要锁服务，因为能够做到互斥。而如果只是保证数据一致性，用乐观锁或者CAS也可以。因为乐观锁与CAS可以在多线程访问同一个资源的情况下，也能够保证数据的一致性","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1632145715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1300602,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIbLh86ic9KR6bfGRCYQrxdheqV9R9IDRiaOibFfGUVZiaqVHgwcw4Le2YprVicLKiakStGLfGRibCggBicHw/132","nickname":"KoalaRun1024","note":"","ucode":"7EE284EE743DA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361315,"discussion_content":"我认为：\n1、如果一个操作非常耗时，消耗大量资源，单单乐观锁就不太合适，需要分布式锁\n2、如果一个操作涉及到外系统的接口调用，并且一些调用不可逆或可逆的成本高，那么也需要分布式锁","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1616641062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122641,"avatar":"https://static001.geekbang.org/account/avatar/00/11/21/51/a6020b74.jpg","nickname":"刘旭","note":"","ucode":"DD628C59BEB81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369922,"discussion_content":"想想为什么多线程协作时哪些场景会用到锁？分布式锁我理解就是为解决多进程协作而存在","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619194032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034035,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c7/33/80375743.jpg","nickname":"Peter8015","note":"","ucode":"89728C3F9D1860","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531073,"discussion_content":"我觉得要区分这两种场景：1更新资源：可以认为是更新数据或资源，适合用乐观锁 2操作：可能是一系列事务，这种场景下适合用分布式锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637221000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1520703,"avatar":"https://static001.geekbang.org/account/avatar/00/17/34/3f/53aca22e.jpg","nickname":"ken","note":"","ucode":"DCAFD1DD5C6A0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394334,"discussion_content":"假如我们的redis只有一台，加锁后redis崩溃了，那么锁服务器就出现问题了，那么redis也需要高可用，既然是这样。redis有读写分离方式，但是从库同步又可能会有延迟。redis又可以做集群，那么集群又如何保证锁创建读取都指定一个节点乃。所以有redlock。我是这样理解的，不知道对不对。\n而zookeeper本身就可以原子递增，所以作为分布式锁也非常合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631844187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2651290,"avatar":"https://static001.geekbang.org/account/avatar/00/28/74/9a/580d35a5.jpg","nickname":"用户7437721993","note":"","ucode":"0E16E6CFA4D225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379690,"discussion_content":"乐观锁只适合对少量或者小数据的修改写操作，如果大量数据写操作还是需要分布式锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624077663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373626,"discussion_content":"集群的定时任务吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620805622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484174,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cZN9xAaxlYHXTIGibcxP7HGNLWrorU5hw3ic7b6p2fe0JyE9yynibvWPW1CUJQl3iaMib79HOVjPnOkgW8msbMFImdw/132","nickname":"金石","note":"","ucode":"1A4A246812B60F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339148,"discussion_content":"比如想互斥的访问下游服务链","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609517266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1499380,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","nickname":"不会爬树的熊","note":"","ucode":"E417D8D9D5FED2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236376,"discussion_content":"我觉得没有解释到位，望再详细一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587089467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1923032,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/57/d8/5816eb6b.jpg","nickname":"啦啦啦","note":"","ucode":"271456A777B5FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1499380,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6vz8MgZia6Xwdhayv9Jdnee7HfDYSAMTUtMAAVORMhiaN8bIM0QJibrQ5EDqB8o5pWE6FRuaqguwG86o5Gh90ruDw/132","nickname":"不会爬树的熊","note":"","ucode":"E417D8D9D5FED2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284250,"discussion_content":"比如任务调度系统，有多个任务执行者，都是读数据库查询未执行的任务，然后执行，但是任务理应只执行一次","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592485573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236376,"ip_address":""},"score":284250,"extra":""}]}]},{"had_liked":false,"id":15346,"user_name":"林子","can_delete":false,"product_type":"c1","uid":1023794,"ip_address":"","ucode":"EA8C33A6BFD834","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/32/277b55a9.jpg","comment_is_top":false,"comment_ctime":1531134853,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65955644293","product_id":100002201,"comment_content":"如果用cas方式或者叫乐观锁来修改数据库中表（共享资源），会出现脏读问题，耗子叔，这点没提到。","like_count":15,"discussions":[{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293892,"discussion_content":"这个和数据库的隔离设置也有关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595717455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":7815,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1031113,"ip_address":"","ucode":"5948D359734193","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/c9/37924ad4.jpg","comment_is_top":false,"comment_ctime":1525740637,"is_pvip":false,"replies":[{"id":"2280","content":"一切都是trade-off。不过实际情况下，乐观加上重试机制会好一些。","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1525778365,"ip_address":"","comment_id":7815,"utype":1}],"discussion_count":3,"race_medal":0,"score":"61655282781","product_id":100002201,"comment_content":"分布式锁 应该是 先获取锁 再进行业务操作 属于悲观锁 而用乐观锁代替 又演变为cas代替 这样合适吗？ 其实悲观和乐观 核心是面对的并发度不一样，如果在大并发下用乐观锁 应该失败的几率会增大，用悲观锁避免大量失败，但是会block！麻烦耗子哥 指导指导","like_count":14,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417480,"discussion_content":"一切都是trade-off。不过实际情况下，乐观加上重试机制会好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525778365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293893,"discussion_content":"https://www.cnblogs.com/cxuanBlog/p/11595526.html\n\n悲观锁因为对读写都加锁，所以它的性能比较低，对于现在互联网提倡的三高(高性能、高可用、高并发)来说，悲观锁的实现用的越来越少了，但是一般多读的情况下还是需要使用悲观锁的，因为虽然加锁的性能比较低，但是也阻止了像乐观锁一样，遇到写不一致的情况下一直重试的时间。\n\n相对而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595718251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564193,"discussion_content":"这个看情况，如果是库存类的业务用乐观锁，有2个用户同时下单就挂了。\n悲观锁还可以排队下，有可能成功。\n吞吐量要看并发度的，没有并发肯定是乐观锁高，如结算业务，并发不高适合这个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650184241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107285,"user_name":"程序员Artist","can_delete":false,"product_type":"c1","uid":1063635,"ip_address":"","ucode":"F6AEC69AE77DC0","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/d3/c273ee50.jpg","comment_is_top":false,"comment_ctime":1561511537,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"44511184497","product_id":100002201,"comment_content":"redis锁timeout确实是个问题，配合存储的版本控制一起做能解决数据准确问题。但是说存储上cas可以代替分布式锁，就不对了。分布式锁锁住的是计算过程和更新存储两件事，而cas只能管更新存储这一件事，也就是二者就不是一个级别的东西。再说锁住计算过程这件事在正常情况下是没有问题的，而当出现极端异常下的超时问题时，出现了同时计算，出现了冗余计算，这完全可以接受。","like_count":10,"discussions":[{"author":{"id":1114772,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/94/2bf394f3.jpg","nickname":"Numbpad1","note":"","ucode":"2F075AC7E3847D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531333,"discussion_content":"看了这么多评论，你的最通透","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637286967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373668,"discussion_content":"也得保证调用方法幂等性了吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620820259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1063635,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3a/d3/c273ee50.jpg","nickname":"程序员Artist","note":"","ucode":"F6AEC69AE77DC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374287,"discussion_content":"计算过程（方法）一般天然就是幂等的，因为还没更新存储的。特殊情况特殊考虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621105578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373668,"ip_address":""},"score":374287,"extra":""},{"author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1063635,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3a/d3/c273ee50.jpg","nickname":"程序员Artist","note":"","ucode":"F6AEC69AE77DC0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374482,"discussion_content":"好的。请问可以用cas来锁住计算过程吗。就是cas成功了，就计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621212439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374287,"ip_address":""},"score":374482,"extra":""},{"author":{"id":1063635,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3a/d3/c273ee50.jpg","nickname":"程序员Artist","note":"","ucode":"F6AEC69AE77DC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375248,"discussion_content":"你这把我都问懵了。\n\n首先，cas是在低并发竞争下代替加锁的方案，所以他压根就不能加锁，就是为了不加锁，没法实现你要的加锁能力。其次，你说的cas成功了就开始计算，这个说法也是错了，当用cas代替加锁时，cas成功了你的计算就已经正确执行完了，换句话说，cas就是在计算，不断地计算直到正确为止。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621530066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374482,"ip_address":""},"score":375248,"extra":""}]}]},{"had_liked":false,"id":5889,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1524100271,"is_pvip":false,"replies":[{"id":"1629","content":"这篇文章其实我是在不断地变换思路解决问题，不能说Redlock没用，其至少可以同步不同的client。而你的理解是对的，如果是有共享资源，最好是在那个资源上提供无锁实现。","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1524106175,"ip_address":"","comment_id":5889,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44473773231","product_id":100002201,"comment_content":"皓哥，这篇文章前半段一直到cas之前基本是在说redlock，后面说到fence和cas，恰恰是redlock争论当中反方的观点---如果你想锁的资源，能提供给你cas功能，那还要分布式锁干嘛？这也是我的疑问，我觉得是悖论<br>在我使用consul时，我发现，如果我要锁住一个资源，理论上100%安全的必要条件是，我的资源就是那个锁本身，在consul就是那个资源只能是锁住key对应的value。consul本身也提供cas，但对客户端来说，没加锁的代码容易写<br>但换成其他资源，这个悖论就显现出来了。我的想法对么？","like_count":10,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":416884,"discussion_content":"这篇文章其实我是在不断地变换思路解决问题，不能说Redlock没用，其至少可以同步不同的client。而你的理解是对的，如果是有共享资源，最好是在那个资源上提供无锁实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1524106175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178508,"user_name":"黄宸","can_delete":false,"product_type":"c1","uid":1799585,"ip_address":"","ucode":"C346F5604B8724","user_header":"","comment_is_top":false,"comment_ctime":1581729832,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18761599016","product_id":100002201,"comment_content":"看完本章有点疑问，对于一般性的数据库修改都是有锁的，所以不存在并发问题，没必要用cas。而文中的redis分布式锁在使用过程中使用nx，px 实现了占位和过期的操作，从而达到分布式锁的效果。其中说到如果先持到锁的服务在一次执行中时间超时，锁释放；其他发现未执行完成，服务再次抢锁，此时存在两个服务都获得同一把锁，这时如果会出现更新覆盖的问题，个人觉得不能理解为分布式锁的问题，应该是程序设计上要考虑重复执行，或者如何去规避重复执行，或者执行补偿的问题。","like_count":4,"discussions":[{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319167,"discussion_content":"所以，后面介绍了cas","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603955258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13376,"user_name":"董泽润","can_delete":false,"product_type":"c1","uid":1048718,"ip_address":"","ucode":"0859A6ECCB5473","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/8e/ebe3c8ea.jpg","comment_is_top":false,"comment_ctime":1529566577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18709435761","product_id":100002201,"comment_content":"https:&#47;&#47;github.com&#47;dongzerun&#47;dlock<br>这是我在用的，redis lua 实现，和耗子叔的相似","like_count":4},{"had_liked":false,"id":11964,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528468015,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18708337199","product_id":100002201,"comment_content":"皓哥，有个问题想确认下，redlock是要求各个节点独立部署，都是master,那么这样的部署方式是否就限定这N台Redis不能同时作为缓存服务器了?","like_count":4,"discussions":[{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4265,"discussion_content":"红锁也是key-value，只是这个锁要被集群中所有master共享，这和redis本身做不做缓存没关系","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565260319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":5929,"user_name":"华烬","can_delete":false,"product_type":"c1","uid":1008444,"ip_address":"","ucode":"D36AE0FBEF665A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/3c/b4cfbce9.jpg","comment_is_top":false,"comment_ctime":1524144152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18704013336","product_id":100002201,"comment_content":"数据库用timestamp的判断是否冲突是有风险的吧","like_count":4},{"had_liked":false,"id":5881,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1524096972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14408998860","product_id":100002201,"comment_content":"CAS代替分布式锁需要考虑数据库的隔离性，级别比较低的CAS不安全","like_count":3},{"had_liked":false,"id":177389,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1581385238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171319830","product_id":100002201,"comment_content":"数据库、Redis、Zookeeper，这三种是比较常见的分布式锁方式。<br>文章提到了一些锁可能会遇到的问题，给出了一些建议和思考，网友们的留言也建议要读一读，因为文章也不一定就都是完全试用任何场景的，比如数据库当锁可能会导致数据库性能问题","like_count":2},{"had_liked":false,"id":160239,"user_name":"junshuaizhang","can_delete":false,"product_type":"c1","uid":1101502,"ip_address":"","ucode":"5734A9BEA03149","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/be/5cf3f1a0.jpg","comment_is_top":false,"comment_ctime":1575897803,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10165832395","product_id":100002201,"comment_content":"有两个问题<br>1.ABA问题文中没有介绍咋处理。<br>2.对于用库存当version虽然解决了并发问题，但是对实际性能影响太大。","like_count":2,"discussions":[{"author":{"id":1024997,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a3/e5/abb7bfe3.jpg","nickname":"fangyu","note":"","ucode":"F966F0607E4C0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386569,"discussion_content":"版本递增就不会aba了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627643311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107047,"user_name":"又双叒叕是一年啊","can_delete":false,"product_type":"c1","uid":1000015,"ip_address":"","ucode":"E067320E537DEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg","comment_is_top":false,"comment_ctime":1561447975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151382567","product_id":100002201,"comment_content":"发现了一篇 好文 https:&#47;&#47;juejin.im&#47;post&#47;5bbb0d8df265da0abd3533a5#heading-23 ","like_count":2},{"had_liked":false,"id":87204,"user_name":"Cutler","can_delete":false,"product_type":"c1","uid":1228136,"ip_address":"","ucode":"2EDECFE039845B","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/68/3fd6428d.jpg","comment_is_top":false,"comment_ctime":1555547814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10145482406","product_id":100002201,"comment_content":"用过redis和etcd的分布式锁，用分布式锁的场景有两个，一个是定时任务，一个是阻止客户端的重复提交。","like_count":2},{"had_liked":false,"id":40213,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1542555169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10132489761","product_id":100002201,"comment_content":"锁还是感觉zk专业一点","like_count":2},{"had_liked":false,"id":5912,"user_name":"流迷的咸菜","can_delete":false,"product_type":"c1","uid":1082372,"ip_address":"","ucode":"0328120D0F44B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/84/04/aceac3b5.jpg","comment_is_top":false,"comment_ctime":1524120325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10114054917","product_id":100002201,"comment_content":"文中说的RedLock应该是单节点的lock的实现吧？分布式的应该如下吧？<br>1. It gets the current time in milliseconds.<br>2. It tries to acquire the lock in all the N instances sequentially, using the same key name and random value in all the instances. During step 2, when setting the lock in each instance, the client uses a timeout which is small compared to the total lock auto-release time in order to acquire it. For example if the auto-release time is 10 seconds, the timeout could be in the ~ 5-50 milliseconds range. This prevents the client from remaining blocked for a long time trying to talk with a Redis node which is down: if an instance is not available, we should try to talk with the next instance ASAP.<br>3. The client computes how much time elapsed in order to acquire the lock, by subtracting from the current time the timestamp obtained in step 1. If and only if the client was able to acquire the lock in the majority of the instances (at least 3), and the total time elapsed to acquire the lock is less than lock validity time, the lock is considered to be acquired.<br>4. If the lock was acquired, its validity time is considered to be the initial validity time minus the time elapsed, as computed in step 3.<br>5. If the client failed to acquire the lock for some reason (either it was not able to lock N&#47;2+1 instances or the validity time is negative), it will try to unlock all the instances (even the instances it believed it was not able to lock).","like_count":2},{"had_liked":false,"id":129736,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1567234443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862201739","product_id":100002201,"comment_content":"支付回调返回就是使用的分布式锁来实现的，容许有一些错误的出现，但是实现起来会更简单一些。<br>Redis分布式锁是可以实现大粒度的锁，不需要考虑每一个点的更新插入都满足幂等性，实现起来更加简单快捷。小并发量时使用会更快捷。<br>数据库乐观锁只有在数据库操作时满足幂等性，但是其他redis、mongodb等的都是不可回滚的，所以这些场景下必须使用Redis分布式锁。可能更适合大并发量访问时候的。","like_count":1},{"had_liked":false,"id":113766,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1563153276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858120572","product_id":100002201,"comment_content":"当我们需要对资源做互斥访问时，分布式服务也像单机服务一般，需要对资源加锁。分布式锁需要保证安全性，避免死锁和容错性","like_count":1},{"had_liked":false,"id":15460,"user_name":"tiger","can_delete":false,"product_type":"c1","uid":1047291,"ip_address":"","ucode":"C15AC14AA33F40","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/fb/ef99d6ca.jpg","comment_is_top":false,"comment_ctime":1531199325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5826166621","product_id":100002201,"comment_content":"MySQL的事务在第一个事务获取共享锁之后，再获取排他锁的过程中，其它的事务也在等待获取排他锁，于是产生了死锁，这个可以通过重入锁解决，为什么MySQL没有这么做呢?","like_count":1},{"had_liked":false,"id":14838,"user_name":"polk","can_delete":false,"product_type":"c1","uid":1165455,"ip_address":"","ucode":"1B6E948BA4DFAF","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/8f/e13a6552.jpg","comment_is_top":false,"comment_ctime":1530690035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5825657331","product_id":100002201,"comment_content":"首先不应该把锁的压力给数据库，数据库的性能相比redis差很多。<br>然后redis的那个潜在问题，把锁的timeout设置成http的timout，不就可以解决了。<br>我的理解是否有问题？","like_count":1},{"had_liked":false,"id":5924,"user_name":"prajba","can_delete":false,"product_type":"c1","uid":1019023,"ip_address":"","ucode":"F6C6F2B15A0423","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/8f/64854769.jpg","comment_is_top":false,"comment_ctime":1524133564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5819100860","product_id":100002201,"comment_content":"去年参与的自动化平台项目里用到了ZooKeeper悲观锁，回想起来当时并没有特别关注死锁问题，实现方式牺牲了故障情况下的一致性。","like_count":1},{"had_liked":false,"id":355905,"user_name":"丝竹乱耳","can_delete":false,"product_type":"c1","uid":1273920,"ip_address":"上海","ucode":"933A41A394B0E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/40/ce062d99.jpg","comment_is_top":false,"comment_ctime":1661845113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661845113","product_id":100002201,"comment_content":"Client B 重新申请到了这个锁。Client A 的解锁请求到达，将 Client B 锁定的 key 解锁。Client C 也获得了锁。Client B 和 Client C 同时持有锁。<br>这里写的不过， 因为 value 值不一样， 不能讲B的锁解锁。除非，你是相同的value, 这和你的假设违背。<br>这么多人，没人发现吗？<br><br><br>这里写的有问题。 <br>","like_count":0},{"had_liked":false,"id":342309,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1650183901,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650183901","product_id":100002201,"comment_content":"分布式锁一般用于互斥多线程，一个作用是保证资源不被多线程并发操作道致问题。还有一种情况如缓存击穿的时候，可以加锁保证db不被打满","like_count":0},{"had_liked":false,"id":336385,"user_name":"独舟泛海","can_delete":false,"product_type":"c1","uid":1238514,"ip_address":"","ucode":"E35C8CEFAF062D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/f2/21ea4d37.jpg","comment_is_top":false,"comment_ctime":1646123932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646123932","product_id":100002201,"comment_content":"如果客户端处理时间如果大于上锁时间，导致锁已经被释放掉, 造成多个client获取到锁怎么办呢","like_count":0},{"had_liked":false,"id":324013,"user_name":"卖藥郎","can_delete":false,"product_type":"c1","uid":1231829,"ip_address":"","ucode":"0539EF1D335918","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/d5/fab32cf7.jpg","comment_is_top":false,"comment_ctime":1638256891,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638256891","product_id":100002201,"comment_content":"etcd是分布式锁不错的选择","like_count":0},{"had_liked":false,"id":320068,"user_name":"方勇(gopher)","can_delete":false,"product_type":"c1","uid":1290625,"ip_address":"","ucode":"D199911C4CFEF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg","comment_is_top":false,"comment_ctime":1636074998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636074998","product_id":100002201,"comment_content":"锁被滥用在开发中很常见，大部分开发更习惯于悲观锁。之前评审的时候一个流程加了6把锁！的确很多场景采用CAS就足够了！","like_count":0},{"had_liked":false,"id":286123,"user_name":"健康的小牛犊","can_delete":false,"product_type":"c1","uid":2263754,"ip_address":"","ucode":"A63C30B602F0A5","user_header":"https://static001.geekbang.org/account/avatar/00/22/8a/ca/1afcc75b.jpg","comment_is_top":false,"comment_ctime":1617160964,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617160964","product_id":100002201,"comment_content":"分布式锁的主要实现方式：可以使用redis、zookeeper或者数据库<br>是否一定需要使用到分布式锁服务，不一定，依靠CAS操作也能达到目的","like_count":0},{"had_liked":false,"id":241108,"user_name":"勾机","can_delete":false,"product_type":"c1","uid":2048471,"ip_address":"","ucode":"5356720C4135C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ibFW2NOMIgKfZ6bZ4qdhbvAMNicccxtsjeoZQZGRdehSL3yicPzUQca97IeBwriaAs8CziaFl2iaqT6QhlACFsvHz4kw/132","comment_is_top":false,"comment_ctime":1597193834,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597193834","product_id":100002201,"comment_content":"皓哥，不好意思，redis 锁的实现我好像没太看懂。就算加了判断，一样有可能会释放其他 client 加的锁吧，因为就算判断了，只要 client A 的删除命令晚于超时删除动作执行，一样可能会导致多余的释放操作，一样会导致多个 client 同时拿到锁。","like_count":0,"discussions":[{"author":{"id":1332352,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/sic7iatOg6ibkc8ZfWke5mKfgTK8gJ6CVLDFp4D8LuGOMMHbOnNhu81EA3Kfjg95tWqeySgJxvTQSdPkwOHAuBybg/132","nickname":"Geek_092552","note":"","ucode":"FE13A36E15DBA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355584,"discussion_content":"fence 版本号是递增的，client A的fence 版本号 是小于当前的版本号的，所以不会释放其他client的锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615455723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176682,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1581137226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581137226","product_id":100002201,"comment_content":"分析的已经很全面了，使用场景说的很清楚。","like_count":0},{"had_liked":false,"id":170172,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1578542865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578542865","product_id":100002201,"comment_content":"问一下采用伴生线程来续锁的行为是否可取。","like_count":0},{"had_liked":false,"id":166021,"user_name":"文刂 氵共 超","can_delete":false,"product_type":"c1","uid":1282813,"ip_address":"","ucode":"C2CE1512D23012","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","comment_is_top":false,"comment_ctime":1577364877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577364877","product_id":100002201,"comment_content":"坚持学习，学习笔记 https:&#47;&#47;mubu.com&#47;colla&#47;7x-yIQlfyLM","like_count":0},{"had_liked":false,"id":131947,"user_name":"万丈尘","can_delete":false,"product_type":"c1","uid":1422351,"ip_address":"","ucode":"546FF45281EF6B","user_header":"https://static001.geekbang.org/account/avatar/00/15/b4/0f/84e32679.jpg","comment_is_top":false,"comment_ctime":1567990638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567990638","product_id":100002201,"comment_content":"同时更新同一条数据真的合理吗，使用不使用cas都不会出错，因为数据库原子性，相反这种情况需要考虑的是执行顺序而不是抢占一个锁","like_count":0},{"had_liked":false,"id":86087,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1555309663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555309663","product_id":100002201,"comment_content":"分布式锁有点像并发编程","like_count":0},{"had_liked":false,"id":39585,"user_name":"格瑞图","can_delete":false,"product_type":"c1","uid":1221271,"ip_address":"","ucode":"57CC0F830BE1EF","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/97/fb8c01fd.jpg","comment_is_top":false,"comment_ctime":1542326816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542326816","product_id":100002201,"comment_content":"另外，多说一下。这种 fence token 的玩法，在数据库那边一般会用 timestamp 时间截来玩。时间戳吧？","like_count":0},{"had_liked":false,"id":15878,"user_name":"欧星星","can_delete":false,"product_type":"c1","uid":1014347,"ip_address":"","ucode":"56365442E231A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4b/1a7b36ab.jpg","comment_is_top":false,"comment_ctime":1531585543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1531585543","product_id":100002201,"comment_content":"比方说对余额加减可以使用CAS来实现，对于那种每人只能领取一次的优惠活动就要用锁来对每个用户做同步互斥操作因为这里除了资源的修改还有业务上的判断","like_count":0},{"had_liked":false,"id":8479,"user_name":"LI","can_delete":false,"product_type":"c1","uid":1017732,"ip_address":"","ucode":"D33B594D2D3EE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/84/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1526259012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526259012","product_id":100002201,"comment_content":"分布式锁的概念和单机的比较，需要网络超时","like_count":0},{"had_liked":false,"id":6496,"user_name":"黑小子在路上","can_delete":false,"product_type":"c1","uid":1025975,"ip_address":"","ucode":"904A8B6C534289","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/b7/00b87f2d.jpg","comment_is_top":false,"comment_ctime":1524783942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1524783942","product_id":100002201,"comment_content":"老师，如果作为服务提供方，某个接口出现异常，或者说这个接口响应时间长，怎么处理","like_count":0},{"had_liked":false,"id":6013,"user_name":"极客er","can_delete":false,"product_type":"c1","uid":1061466,"ip_address":"","ucode":"43A30683884E2E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/5a/347570e6.jpg","comment_is_top":false,"comment_ctime":1524275858,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1524275858","product_id":100002201,"comment_content":"锁的可重入，耗子哥讲讲啊","like_count":0,"discussions":[{"author":{"id":1332352,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/sic7iatOg6ibkc8ZfWke5mKfgTK8gJ6CVLDFp4D8LuGOMMHbOnNhu81EA3Kfjg95tWqeySgJxvTQSdPkwOHAuBybg/132","nickname":"Geek_092552","note":"","ucode":"FE13A36E15DBA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355587,"discussion_content":"可重入是指当前client可以重复获取锁，每获取锁一次，信号量+1，释放锁一次，信号量-1，只有当信号量为0的时候，其他client才可以获取锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615456195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":5942,"user_name":"programath","can_delete":false,"product_type":"c1","uid":1029605,"ip_address":"","ucode":"EBF48E9406FFD4","user_header":"","comment_is_top":false,"comment_ctime":1524157696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1524157696","product_id":100002201,"comment_content":"，我们发现，分布式锁服务还能用来做同步，这是数据库锁做不了的事情。<br><br>这里的同步指的是什么？为什么数据库锁做不了？请问能详细说下吗？谢谢","like_count":0},{"had_liked":false,"id":5903,"user_name":"常江舟","can_delete":false,"product_type":"c1","uid":1031422,"ip_address":"","ucode":"75376392A1F5D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/fe/b43be33e.jpg","comment_is_top":false,"comment_ctime":1524112674,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1524112674","product_id":100002201,"comment_content":"老师好，我有个场景用的共享的资源不是在数据库中，资源本身就是在Redis中。锁就用的文章前面部分介绍的没有栅栏的Redis锁。看了您的文章后感觉要改进一下了。<br>我的问题是我现在优化的话是不是只能把version也存到资源里？<br>但这样还是会有问题，比如set的时候可能 资源里的version又已经被别的进程修改了。所以想问问您这种共享资源不在库中的场景如何才能完美锁住？","like_count":0}]}