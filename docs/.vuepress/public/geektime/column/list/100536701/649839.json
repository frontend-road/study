{"id":649839,"title":"17｜动态代理：如何在运行时插入逻辑？","content":"<p>你好，我是郭屹。今天我们继续手写MiniSpring。</p><p>从这节课开始，我们就要进入AOP环节了。在学习之前，我们先来了解一下是AOP怎么回事。</p><p>AOP，就是面向切面编程（Aspect Orient Programming），这是一种思想，也是对OOP面向对象编程的一种补充。你可能会想：既然已经存在OOP面向对象编程了，为什么还需要AOP面向切面编程呢？</p><p>这是因为在许多场景下，一个类的方法中，除了业务逻辑，通常还会包括其他比较重要但又不算主业务逻辑的例行性逻辑代码，比如常见的日志功能，它不影响我们的主业务逻辑，但又能在必要时定位问题，几乎每一个业务方法中都需要。又比如权限检查、事务处理，还有性能监控等等，都是这种情况。</p><p>显而易见，日志这类例行性逻辑，在任何一个业务方法实现中都是需要的。如果简单地将这些代码写在业务方法中，会出现两个后果，第一，我们就会将日志之类的代码重复地编写多次；第二，一个业务方法中会包含很多行例行代码，去看源代码会发现方法中多数语句不是在做业务处理。</p><p>有专业进取心的程序员就会思考一个问题，<strong>有没有办法将这些例行性逻辑单独抽取出来，然后在程序运行的时候动态插入到业务逻辑中呢？</strong>正是因为这个疑问，AOP应运而生了。这个问题听起来似乎无解，程序在运行时改变程序本身，似乎有点不可思议。我们研究一下Java，就会惊奇地发现，Java里面早就给我们提供了一个手段：<strong>动态代理</strong>。我们可以利用它来开展我们的工作。</p><!-- [[[read_end]]] --><h2>代理模式</h2><p>我们一步步来，先从代理讲起。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/4c/5e31827e2dec92103754abfc45f67a4c.png?wh=1920x1062\" alt=\"图片\" title=\"GoF的《设计模式》一书中的代理模式类图\"></p><p>看图，我们知道真正干活儿的类是RealSubject，具体则是由DoAction()执行任务。Proxy作为代理提供一个同样的DoAction()，然后调用RealSubject的DoAction()。它们都实现Subject接口，而Client应用程序操作的是Subject 接口。</p><p>简单说来，就是在Client应用程序与真正的服务程序RealSubject之间增加了一个Proxy。</p><p>我们举例说明，先定义一个服务类接口。</p><pre><code class=\"language-plain\">public interface Subject {\n\tString doAction(String name);\n}\n</code></pre><p>再定义具体的服务类。</p><pre><code class=\"language-plain\">public class RealSubject implements Subject {\n\tpublic String doAction(String name) {\n\t\tSystem.out.println(\"real subject do action \"+name);\n\t\treturn \"SUCCESS\";\n\t}\n}\n</code></pre><p>最后再定义一个代理类。</p><pre><code class=\"language-plain\">public class ProxySubject implements Subject {\n\tSubject realsubject;\n\tpublic ProxySubject() {\n\t\tthis.realsubject = new RealSubject();\n\t}\n\tpublic String doAction(String name) {\n\t\tSystem.out.println(\"proxy control\");\n\t\tString rtnValue = realsubject.doAction(name);\n\t\treturn \"SUCCESS\";\n\t}\n}\n</code></pre><p>通过代码我们看到，代理类内部包含了一个真正的服务类，而代理类给外部程序提供了和真正的服务类同样的接口。当外部应用程序调用代理类的方法时，代理类内部实际上会转头调用真正的服务类的相应方法，然后把真正的服务类的返回值直接返回给外部程序。这样做就隐藏了真正的服务类的实现细节。</p><p>同时，在调用真正的服务方法之前和之后，我们还可以在代理类里面做一点手脚，加上额外的逻辑，比如上面程序中的 <code>System.out.println(\"proxy control\");</code>，这些额外的代码，大部分都是一些例行性的逻辑，如权限和日志等。</p><p>最后我们提供一个客户程序使用这个代理类。</p><pre><code class=\"language-plain\">public class Client {\n\tpublic static void main(String[] args) {\n\t\tSubject subject = new ProxySubject();\n\t\tsubject.doAction(\"Test\");\n\t}\n}\n</code></pre><p>总结一下，代理模式能够让我们在业务处理之外添加例行性逻辑。但是这个经典的模式在我们这里不能直接照搬，因为这个代理是静态的，要事先准备好。而我们需要的是在相关的业务逻辑执行的时候，动态插入例行性逻辑，不需要事先手工静态地准备这些代理类。解决方案就是<strong>Java中的动态代理技术。</strong></p><h2>动态代理</h2><p>Java提供的动态代理可以对接口进行代理，在代理的过程中主要做三件事。</p><ol>\n<li>实现InvocationHandler接口，重写接口内部唯一的方法invoke。</li>\n<li>使用Proxy类，通过newProxyInstance，初始化一个代理对象。</li>\n<li>通过代理对象，代理其他类，对该类进行增强处理。</li>\n</ol><p>这里我们还是举例说明。首先定义一个IAction接口。</p><pre><code class=\"language-java\">package com.test.service;\npublic interface IAction {\n   void doAction();\n}\n</code></pre><p>提供一个具体实现类。</p><pre><code class=\"language-java\">package com.test.service;\npublic class Action1 implements IAction {\n   @Override\n   public void doAction() {\n      System.out.println(\"really do action\");\n   }\n}\n</code></pre><p>我们定义了一个DynamicProxy类，用来充当代理对象的类。</p><pre><code class=\"language-java\">package com.test.service;\npublic class DynamicProxy {\n   private Object subject = null; \n   \n   public DynamicProxy(Object subject) {\n         this.subject = subject;\n   }\n   \n   public Object getProxy() {\n      return Proxy.newProxyInstance(DynamicProxy.class\n            .getClassLoader(), subject.getClass().getInterfaces(),\n            new InvocationHandler() {\n         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getName().equals(\"doAction\")) {\n                System.out.println(\"before call real object........\");\n                return method.invoke(subject, args); \n            }\n            return null;\n         }\n      });\n   }\n}\n</code></pre><p>通过这个类的实现代码可以看出，我们使用了Proxy类，调用newProxyInstance方法构建IAction接口的代理对象，而且重写了InvocationHandler接口中的invoke方法。在重写的方法中我们判断方法名称是否与接口中的doAction方法保持一致，随后加上例行性逻辑（print语句），最后通过反射调用接口IAction中的doAction方法。</p><p>通过这个操作，例行性逻辑就在业务程序运行的时候，动态地添加上去了。</p><p>我们编写一个简单的测试程序，就能直观感受到代理的效果了。</p><pre><code class=\"language-java\">package com.test.controller;\npublic class HelloWorldBean {\n    @Autowired\n    IAction action;\n  \n    @RequestMapping(\"/testaop\")\n    public void doTestAop(HttpServletRequest request, HttpServletResponse response) {\n     DynamicProxy proxy = new DynamicProxy(action);\n     IAction p = (IAction)proxy.getProxy();\n     p.doAction();\n     \n     String str = \"test aop, hello world!\";\n     try {\n        response.getWriter().write(str);\n     } catch (IOException e) {\n        e.printStackTrace();\n     }\n  }\n}\n</code></pre><p>运行这个程序，返回内容是“test aop，hello world！”。这个时候查看命令行里的内容，你就会发现还有两行输出。</p><pre><code class=\"language-java\">before call real object........\nreally do action\n</code></pre><p>第一行是代理对象中的输出，第二行是Action1中doAction方法的实现。<br>\n根据这个输出顺序我们发现，这个代理对象达到了代理的效果，在调用IAction的具体实现类之前进行了额外的操作，从而增强了代理类。而这个代理是我们动态增加的，而不是事先静态地手工编写一个代理类。</p><p>但是读代码，这种方式显然是不美观的，需要在业务逻辑程序中写上，对代码的侵入性太强了。</p><pre><code class=\"language-java\">DynamicProxy proxy = new DynamicProxy(action);\nIAction p = (IAction)proxy.getProxy();\n</code></pre><p>这个写法跟我们手工写一个代理类实际上相差不多。这种侵入式的做法不是我们推崇的，所以我们要继续前进。</p><h2>引入FactoryBean</h2><p>我们的目标是<strong>非侵入式编程，</strong>也就是应用程序在编程的时候，它不应该手工去创建一个代理，而是使用本来的业务接口，真正的实现类配置在外部，代理类也是配置在外部。</p><pre><code class=\"language-java\">@Autowired\nIAction action;\n   \n@RequestMapping(\"/testaop\")\npublic void doTestAop(HttpServletRequest request, HttpServletResponse response) {\n    action.doAction();\n}\n</code></pre><p>配置如下：</p><pre><code class=\"language-xml\">&lt;bean id=\"realaction\" class=\"com.test.service.Action1\" /&gt;\n&lt;bean id=\"action\" class=\"com.minis.aop.ProxyFactoryBean\" &gt;\n    &lt;property type=\"java.lang.Object\" name=\"target\" ref=\"realaction\"/&gt;\n&lt;/bean&gt;\n</code></pre><p>业务类中自动注入的是一个action，也就是上面代码里的ProxyFactoryBean类，这个类内部包含了真正干活儿的类realaction。</p><p>这里就有一个初看起来非常奇怪的需求：注册的action bean是ProxyFactoryBean类，而业务程序使用getBean(“action”)的时候，期待返回的又不是这个Bean本身，而是内部那个target。因为只有这样才能让业务程序实际调用target中的方法，外面的这个ProxyFactoryBean对我们来讲是一个入口，而不是目标。这也就要求，当业务程序使用getBean(“action”)方法的时候，这个ProxyFactoryBean应该在内部进行进一步地处理，根据target再动态生成一个代理返回，达到侵入式编程中下面这两句话的效果。</p><pre><code class=\"language-java\">DynamicProxy proxy = new DynamicProxy(action);\nIAction p = (IAction)proxy.getProxy();\n</code></pre><p>上面的方案，看起来奇怪，但是确实能解决动态代理的问题。</p><p>好，现在我们就按照这个思路动手去实现。首先我们参考Spring框架，定义FactoryBean接口。</p><p>相关代码参考：</p><pre><code class=\"language-java\">package com.minis.beans.factory;\npublic interface FactoryBean&lt;T&gt; {\n    T getObject() throws Exception;\n    Class&lt;?&gt; getObjectType();\n    default boolean isSingleton() {\n        return true;\n    }\n}\n</code></pre><p>主要的方法就是getObject()，从Factory Bean中获取内部包含的对象。<br>\n接着定义FactoryBeanRegistrySupport，提供一部分通用的方法。</p><pre><code class=\"language-java\">package com.minis.beans.factory.support;\npublic abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry{\n    protected Class&lt;?&gt; getTypeForFactoryBean(final FactoryBean&lt;?&gt; factoryBean) {\n        return factoryBean.getObjectType();\n    }\n    protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName) {\n        Object object = doGetObjectFromFactoryBean(factory, beanName);\n        try {\n            object = postProcessObjectFromFactoryBean(object, beanName);\n        } catch (BeansException e) {\n            e.printStackTrace();\n        }\n        return object;\n    }\n    //从factory bean中获取内部包含的对象\n    private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName) {\n        Object object = null;\n        try {\n            object = factory.getObject();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return object;\n    }\n}\n</code></pre><p>最重要的是这个方法：doGetObjectFromFactoryBean()，从一个Factory Bean里面获取内部包含的那个target对象。</p><p>因为FactoryBeanRegistrySupport继承了DefaultSingletonBeanRegistry，所以我们接下来可以改写AbstractBeanFactory，由原本继承DefaultSingletonBeanRegistry改成继承FactoryBeanRegistrySupport，保留原有功能的同时增加了功能扩展。</p><p>我们重点要修改核心的getBean()方法。</p><pre><code class=\"language-java\">package com.minis.beans.factory.support;\npublic abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory,BeanDefinitionRegistry{\n   public Object getBean(String beanName) throws BeansException{\n      Object singleton = this.getSingleton(beanName);\n      if (singleton == null) {\n         singleton = this.earlySingletonObjects.get(beanName);\n         if (singleton == null) {\n            System.out.println(\"get bean null -------------- \" + beanName);\n            BeanDefinition bd = beanDefinitionMap.get(beanName);\n            if (bd != null) {\n               singleton=createBean(bd);\n               this.registerBean(beanName, singleton);\n               //beanpostprocessor\n               //step 1 : postProcessBeforeInitialization\n               applyBeanPostProcessorsBeforeInitialization(singleton, beanName);\n               //step 2 : init-method\n               if (bd.getInitMethodName() != null &amp;&amp; !bd.getInitMethodName().equals(\"\")) {\n                  invokeInitMethod(bd, singleton);\n               }\n               //step 3 : postProcessAfterInitialization\n               applyBeanPostProcessorsAfterInitialization(singleton, beanName);\n            }\n            else {\n               return null;\n            }\n         }\n      }\n      else {\n      }\n      //处理factorybean\n      if (singleton instanceof FactoryBean) {\n         return this.getObjectForBeanInstance(singleton, beanName);\n      }\n      else {\n      }\n      return singleton;\n   }\n\n</code></pre><p>我们看到在getBean()这一核心方法中，原有的逻辑处理完毕后，我们新增下面这一段。</p><pre><code class=\"language-java\">//process Factory Bean\nif (singleton instanceof FactoryBean) {\n   return this.getObjectForBeanInstance(singleton, beanName);\n}\n</code></pre><p>根据代码实现可以看出，这里增加了一个判断，如果Bean对象是FactoryBean类型时，则调用getObjectForBeanInstance方法。</p><pre><code class=\"language-java\">protected Object getObjectForBeanInstance(Object beanInstance, String beanName) {\n    // Now we have the bean instance, which may be a normal bean or a FactoryBean.\n    if (!(beanInstance instanceof FactoryBean)) {\n         return beanInstance;\n    }\n    Object object = null;\n    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;\n    object = getObjectFromFactoryBean(factory, beanName);\n    return object;\n}\n</code></pre><p>代码显示，getObjectForBeanInstance又会调用doGetObjectFromFactoryBean方法。</p><pre><code class=\"language-java\">private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName) {\n    Object object = null;\n    try {\n        object = factory.getObject();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return object;\n}\n</code></pre><p>最后落实到了factory.getObject()里。由此可以看出，我们通过AbstractBeanFactory获取Bean的时候，对FactoryBean进行了特殊处理，获取到的已经不是FactoryBean本身了，而是它内部包含的那一个对象。而这个对象，也不是真正底层对应的Bean。它仍然只是一个代理的对象，我们继续往下看。</p><p>我们这个getObject()只是FactoryBean里的一个接口，接下来我们提供一下它的接口实现——ProxyFactoryBean。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic class ProxyFactoryBean implements FactoryBean&lt;Object&gt; {\n    private AopProxyFactory aopProxyFactory;\n    private String[] interceptorNames;\n    private String targetName;\n    private Object target;\n    private ClassLoader proxyClassLoader = ClassUtils.getDefaultClassLoader();\n    private Object singletonInstance;\n    public ProxyFactoryBean() {\n        this.aopProxyFactory = new DefaultAopProxyFactory();\n    }\n    public void setAopProxyFactory(AopProxyFactory aopProxyFactory) {\n        this.aopProxyFactory = aopProxyFactory;\n    }\n    public AopProxyFactory getAopProxyFactory() {\n        return this.aopProxyFactory;\n    }\n    protected AopProxy createAopProxy() {\n        return getAopProxyFactory().createAopProxy(target);\n    }\n    public void setInterceptorNames(String... interceptorNames) {\n        this.interceptorNames = interceptorNames;\n    }\n    public void setTargetName(String targetName) {\n        this.targetName = targetName;\n    }\n    public Object getTarget() {\n        return target;\n    }\n    public void setTarget(Object target) {\n        this.target = target;\n    }\n    @Override\n    public Object getObject() throws Exception {//获取内部对象\n        return getSingletonInstance();\n    }\n    private synchronized Object getSingletonInstance() {//获取代理\n        if (this.singletonInstance == null) {\n            this.singletonInstance = getProxy(createAopProxy());\n        }\n        return this.singletonInstance;\n    }\n    protected Object getProxy(AopProxy aopProxy) {//生成代理对象\n        return aopProxy.getProxy();\n    }\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return null;\n    }\n}\n</code></pre><p>这段代码的核心在于，ProxyFactoryBean在getObject()方法中生成了一个代理getProxy(createAopProxy())，同样也是通过这种方式，拿到了要代理的目标对象。这里的工作就是<strong>创建动态代理</strong>。</p><h2>基于JDK的实现</h2><p>Spring作为一个雄心勃勃的框架，自然不会把自己局限于JDK提供的动态代理一个技术上，所以，它再次进行了包装，提供了AopProxy的概念，JDK只是其中的一种实现。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic interface AopProxy {\n    Object getProxy();\n}\n</code></pre><p>还定义了factory。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic interface AopProxyFactory {\n    AopProxy createAopProxy(Object target);\n}\n</code></pre><p>然后给出了基于JDK的实现。</p><pre><code class=\"language-java\">package com.minis.aop;\npublic class JdkDynamicAopProxy implements AopProxy, InvocationHandler {\n    Object target;\n    public JdkDynamicAopProxy(Object target) {\n        this.target = target;\n    }\n    @Override\n    public Object getProxy() {\n        Object obj = Proxy.newProxyInstance(JdkDynamicAopProxy.class.getClassLoader(), target.getClass().getInterfaces(), this);\n        return obj;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getName().equals(\"doAction\")) {\n            System.out.println(\"-----before call real object, dynamic proxy........\");\n            return method.invoke(target, args);\n        }\n        return null;\n    }\n}\n</code></pre><pre><code class=\"language-java\">package com.minis.aop;\npublic class DefaultAopProxyFactory implements AopProxyFactory{\n    @Override\n    public AopProxy createAopProxy(Object target) {\n\t\treturn new JdkDynamicAopProxy(target); \n    }\n}\n</code></pre><p>在这个实现里，我们终于看到了我们曾经熟悉的Proxy.newProxyInstance()和invoke()。利用Java的动态代理技术代理了目标对象，而这也是ProxyFactoryBean里真正要返回的Object。</p><p>这就是Spring AOP的实现原理。</p><h2>测试</h2><p>有了上面的工具，我们的测试程序就不需要再手动构建代理对象了，而是交给框架本身处理。而注入的对象，则通过配置文件注入属性值。</p><p>applicationContext.xml配置中新增一段内容。</p><pre><code class=\"language-xml\">&lt;bean id=\"realaction\" class=\"com.test.service.Action1\" /&gt;\n&lt;bean id=\"action\" class=\"com.minis.aop.ProxyFactoryBean\" &gt;\n    &lt;property type=\"java.lang.Object\" name=\"target\" ref=\"realaction\"/&gt;\n&lt;/bean&gt;\n</code></pre><p>通过配置，我们在HelloWorldBean里注入的IAction对象就纳入了容器管理之中，因此后续测试的时候，直接使用action.doAction()，就能实现手动初始化JDK代理对象的效果。</p><pre><code class=\"language-java\">package com.test.controller;\npublic class HelloWorldBean {\n   @Autowired\n   IAction action;\n   \n   @RequestMapping(\"/testaop\")\n   public void doTestAop(HttpServletRequest request, HttpServletResponse response) {\n      action.doAction();\n      \n      String str = \"test aop, hello world!\";\n      try {\n         response.getWriter().write(str);\n      } catch (IOException e) {\n         e.printStackTrace();\n      }\n   }\n}\n</code></pre><p>我们终于看到了动态代理的结果。</p><h2>小结</h2><p>这节课我们<strong>利用JDK动态代理技术实现了AOP这个概念</strong>。</p><p>我们介绍了代理模式实现的静态代理，然后使用了JDK的动态代理技术。在使用动态代理技术的程序代码中，我们发现它是侵入式的，不理想，所以我们就想办法把代理配置在XML文件里了。但是如果按照原有的Bean的定义，这个配置在外部文件里的代理Bean本身不能代理业务类，我们真正需要的是通过这个代理Bean来创建一个动态代理，于是引入了FactoryBean的概念，不是直接获取这个Bean本身，而是通过里面的getObject()获取到Factory Bean里面包含的对象。</p><p>这样将IoC容器里的Bean分成了两类：一是普通的Bean，二是Factory Bean。在getObject()的实现中，我们使用JDK的动态代理技术创建了一个代理。这样就实现了AOP。</p><p>另外，Spring中的代理支持JDK代理与Cglib代理两种，目前MiniSpring定义的DefaultAopProxyFactory只支持JDK代理。另一种方式我留作思考题，你可以先想一想要怎么实现。</p><p>AOP还有别的实现方案，比如AspectJ，也比较常用，在实际工程实践中，一般采用的就是AspectJ，而不是Spring AOP，因为AspectJ更加高效，功能更强。比如，AspectJ是编译时创建的代理，性能高十倍以上，而且切入点不仅仅在方法上，而是可以在类的任何部分。所以AspectJ才是完整的AOP解决方案，Spring AOP不是成功的工业级方案。之所以保留Spring AOP，一个原因是原理简单、利于理解，另一个是Rod Johnson不忍抛弃自己的心血。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。如果MiniSpring想扩展到支持Cglib，程序应该从哪里下手改造？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","neighbors":{"left":{"article_title":"16｜再回首：JdbcTemplate章节小结","id":648857},"right":{"article_title":"18｜拦截器 ：如何在方法前后进行拦截？","id":650471}},"comments":[{"had_liked":false,"id":373026,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1681952229,"is_pvip":false,"replies":[{"id":136301,"content":"对。跟jdk的动态代理等位的一个实现。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681991292,"ip_address":"澳大利亚","comment_id":373026,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"Spring与AspectJ是什么关系？AspectJ是一个独立的工具软件，Spring使用该软件完成AOP，这样理解对吗？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614989,"discussion_content":"对。跟jdk的动态代理等位的一个实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681991292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375354,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1685370009,"is_pvip":false,"replies":[{"id":136983,"content":"后面有参考回答。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685403348,"ip_address":"澳大利亚","comment_id":375354,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"可以在DefaultAopProxyFactory类中，获取AopProxy时改造。新增一个入参，区分是jdk的接口代理还是cglib代理，进而返回不同的代理","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619654,"discussion_content":"后面有参考回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685403348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372993,"user_name":"不是早晨，就是黄昏","can_delete":false,"product_type":"c1","uid":2645005,"ip_address":"河南","ucode":"B7132BA7740AFE","user_header":"https://static001.geekbang.org/account/avatar/00/28/5c/0d/9ec703ab.jpg","comment_is_top":false,"comment_ctime":1681899657,"is_pvip":false,"replies":[{"id":136293,"content":"是的是的，后面改过来。这是线下班的时候一边演示一边跟学生说这个地方最后应该是action.doAction顺手就改了。Github上是正确的。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1681937852,"ip_address":"澳大利亚","comment_id":372993,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"DynamicProxy proxy = new DynamicProxy(action);\n IAction p = (IAction)proxy.getProxy(); \naction.doAction();\n这里是不是要写成p.doAction();","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614857,"discussion_content":"是的是的，后面改过来。这是线下班的时候一边演示一边跟学生说这个地方最后应该是action.doAction顺手就改了。Github上是正确的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681937853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615371,"discussion_content":"已更正，感谢提醒🌹","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682233227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393120,"user_name":"赵欣","can_delete":false,"product_type":"c1","uid":1423699,"ip_address":"广东","ucode":"6066BD20C6123E","user_header":"https://static001.geekbang.org/account/avatar/00/15/b9/53/a72bebcc.jpg","comment_is_top":false,"comment_ctime":1722922840,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"这一章中，我个人理解应该是getObjectForBeanInstance,getObjectFromFactoryBean,doGetObjectFromFactoryBean,postProcessObjectFromFactoryBean这四个方法应该写在AbstractBeanFactory.java里面","like_count":0}]}