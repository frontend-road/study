{"id":165198,"title":"02 | var x = y = 100：声明语句与语法改变了JavaScript语言核心性质","content":"<p>你好，我是周爱民。</p><p>如果你听过上一讲的内容，心里应该会有一个问题，那就是——在规范中存在的“引用”到底有什么用？它对我们的编程有什么实际的影响呢？</p><p>当然，除了已经提及过的<code>delete 0</code>和<code>obj.x</code>之外，在今后的课程中，我还会与你讨论这个“引用”的其它应用场景。而今天的内容，就从标题来看，若是我要说与这个“引用”有关，你说不定得跳起来说我无知；但若说是跟“引用”无关的话呢，我觉得又不能把标题中的这一行代码解释清楚。</p><p>为什么这行代码看起来与规范类型中的“引用”无关呢？因为这行代码出现的时候，连ECMAScript这个规范都不存在。</p><p>我大概是在JavaScript 1.2左右的时代就接触到这门语言，在我写的最早的一些代码中就使用过它，并且——没错，你一定知道的：它能执行！</p><p>有很多的原因会促使你在JavaScript写出表达式连等这样的代码。从C/C++走过来的程序员对这样的一行代码是不会陌生的。它能用，而且结果也与你的预期会一致，例如：</p><pre><code>var x = y = 100;\nconsole.log(x); // 100\nconsole.log(y); // 100\n</code></pre><p>它既没错、又好用，还很酷，你说我们为什么不用它呢？然而很不幸，<span class=\"orange\">这行代码可能是JavaScript中最复杂和最容易错用的表达式了。</span></p><p>所以今天我要和你一起好好地盘盘它。</p><!-- [[[read_end]]] --><h2>声明</h2><p>至今为止，除标签声明之外，JavaScript中一共只有六条声明用的语句。注意，所有真正被定义“声明”的语法结构都一定是“语句”，并且都用于声明一个或多个标识符。这里的标识符包括变量、常量等。</p><p>严格意义上讲，JavaScript只有变量和常量两种标识符，六条声明语句中：</p><ul>\n<li><strong>let</strong>  <em>x</em> …</li>\n</ul><p>声明变量x。不可在赋值之前读。</p><ul>\n<li><strong>const</strong>  <em>x</em> …</li>\n</ul><p>声明常量x。不可写。</p><ul>\n<li><strong>var</strong>  <em>x</em> …</li>\n</ul><p>声明变量x。在赋值之前可读取到undefined值。</p><ul>\n<li><strong>function</strong>  <em>x</em> …</li>\n</ul><p>声明变量x。该变量指向一个函数。</p><ul>\n<li><strong>class</strong>  <em>x</em> …</li>\n</ul><p>声明变量x。该变量指向一个类（该类的作用域内部是处理严格模式的）。</p><ul>\n<li><strong>import</strong> …</li>\n</ul><p>导入标识符并作为常量（可以有多种声明标识符的模式和方法）。</p><p>除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）。这两个语句是指：</p><ul>\n<li><strong>for</strong> (<strong><em>var</em></strong>|<strong><em>let</em></strong>|<strong><em>const</em></strong>  <em>x</em> …) …</li>\n</ul><p>for语句有多种语法来声明一个或多个标识符，用作循环变量。</p><ul>\n<li><strong>try</strong> … <strong>catch</strong> (<em>x</em>) …</li>\n</ul><p>catch子句可以声明一个或多个标识符，用作异常对象变量。</p><p>总的来说，除上述的语法，用户是没有其它方式来在当前的代码上下文中“声明”出一个标识符来的。而我之所以在这里严格强调这一“汇总性的”结果，是因为下面的一个简单论断，所有的“声明”：</p><blockquote>\n<ul>\n<li>都意味着JavaScript将可以通过“静态”语法分析发现那些声明的标识符；</li>\n<li>标识符对应的变量/常量“一定”会在用户代码执行前就已经被创建在作用域中。</li>\n</ul>\n</blockquote><p>这个标题中的<code>var x</code>就是一个声明。在这个声明的后半部分，使用“=”这个符号引导了一个初始化语法——通常情况下可以将它理解为一个赋值运算。</p><h2>从读取值到赋值</h2><p>声明是在语法分析阶段就处理的，并且因此它会使得当前代码上下文在正式执行之前就拥有了被声明的标识符，例如<code>x</code>。</p><p>这其实非常有趣，因为这表明<span class=\"orange\">JavaScript虽然被称为是“动态语言”，但确实是拥有静态语义的。</span>而在JavaScript的早期，这个静态语义其实并没有处理得太好，一个典型的问题就是所谓的“变量提升”。也就是可以在变量声明之前访问该变量。例如：</p><pre><code>console.log(x); // undefined\nvar x = 100;\nconsole.log(x); // 100\n</code></pre><p>这个“变量提升”还包括“变量被创建于声明它的语法块”之外的意思，但这并不是这里要讨论的内容，我会在今后再讲它。在今天的课程里，你只需要留意这个变量的读写过程就好了。那么，关于读取值，之前声明的变量与常量又有什么不同呢？</p><p>如上面已经说过的，由于标识符是在用户代码执行之前就已经由静态分析得到，并且创建在环境中，因此let声明的变量和var声明的变量在这一点上没有不同：它们都是在读取一个“已经存在的”标识符名。例如：</p><pre><code>var y = &quot;outer&quot;;\nfunction f() {\n  console.log(y); // undefined\n  console.log(x); // throw a Exception\n  let x = 100;\n  var y = 100;\n  ...\n}\n</code></pre><p>正是由于<code>var y</code>所声明的那个标识符在函数f()创建（它自己的闭包）时就已经存在，所以才阻止了<code>console.log(y)</code>访问全局环境中的<code>y</code>。类似的，<code>let x</code>所声明的那个<code>x</code>其实也已经存在f()函数的上下文环境中。访问它之所以会抛出异常（Exception），不是因为它不存在，而是因为这个标识符被拒绝访问了。</p><p>在ECMAScript 6之后出现的<code>let/const</code>变量在“声明（和创建）一个标识符”这件事上，与<code>var</code>并没有什么不同，只是JavaScript拒绝访问还没有绑定值的<code>let/const</code>标识符而已。</p><p>回到ECMAScript 6之前：JavaScript是允许访问还没有绑定值的<code>var</code>所声明的标识符的。这种标识符后来统一约定称为“变量声明（varDelcs）”，而“let/const”则称为“词法声明（lexicalDecls）”。JavaScript环境在创建一个“变量名（varName in varDecls）”后，会为它初始化绑定一个undefined值，而”词法名字（lexicalNames）”在创建之后就没有这项待遇，所以它们在缺省情况下就是“还没有绑定值”的标识符。</p><blockquote>\n<p>NOTE：6种声明语句中的函数是按varDecls的规则声明的；类的内部是处于严格模式中，它的名字是按let来处理的，而import导入的名字则是按const的规则来处理的。所以，所有的声明本质上只有三种处理模式：var变量声明、let变量声明和const常量声明。</p>\n</blockquote><p>所以，标题中的<code>var x = ...</code>在语义上就是为变量x绑定一个初值。在具体的语言环境中，它将被实现为一个赋值操作。</p><h2>赋值</h2><p>如果是在一门其它的（例如编译型的）语言中，“为变量x绑定一个初值”就可能实现为“在创建环境时将变量x指向一个特定的初始值”。这通常是静态语言的处理方法，然而，如前面说过的，JavaScript是门动态的语言，所以它的“绑定初值”的行为是通过动态的执行过程来实现的，也就是赋值操作。</p><p>那么请你仔细想想，一个赋值操作在语法上怎么表达呢？例如：</p><pre><code>变量名 = 值\n</code></pre><p>这样对吗？不对！在JavaScript中，这样讲是非常不正确的。正确的说法是：</p><pre><code>lRef = rValue\n</code></pre><p>也就是将右操作数（的值）赋给左操作数（的引用）。它的严格语法表达是：</p><blockquote>\n<p><em>LeftHandSideExpression</em> &lt; <strong>=</strong> | <strong><em>AssignmentOperator</em></strong> &gt; <em>AssignmentExpression</em></p>\n</blockquote><p>也就是说，在JavaScript中，一个赋值表达式的左边和右边其实“都是”表达式！</p><h2>向一个不存在的变量赋值</h2><p>接下来我要给你介绍的是从JavaScript 1.0开始就遗留下来的一个巨坑，也就是所谓的<span class=\"orange\">“变量泄漏”问题</span>。这在早期的JavaScript中的确是一个好用的特性：如果你向一个不存在的变量名赋值，那么JavaScript会在全局范围内创建它。</p><p>也就是说，代码中不需要显式地声明一个变量了，变量可以随用随声明，也不用像后来的<code>let</code>语句一样，还要考虑在声明语句之前能不能访问的问题了。这非常简单，在少量的代码中也相当易用。</p><p>但是，如果代码规模扩大，变成百千万行代码，那么“<strong>一个全局变量是在哪里声明和创建的</strong>”就变成一个非常要紧的问题。</p><p>如果随时都可能泄露一个代码给全局，或者随时都可能因为忘记本地的声明而读写了全局变量，那对调试除错将是一场灾难。另外，晚一些出现的运行期优化技术也不能很好地处理这种情况。所以从ECMAScript5开始的严格模式就禁止了这种特性，试图避免用户将变量泄露到全局环境。</p><p>然而现实中，即使在严格模式下这种漏露也未能避免。这称为“<strong>间接执行</strong>”，这将是另一个巨大的议题，并且是ECMAScript6之后开始的一种新的机制。但是现在这里发生的事情，也就是这个“向不存在的变量赋值”的问题，是从JavaScript 1.0时代就遗留下来的问题，也是ECMAScript为JavaScript填补的最大设计漏洞之一。</p><p>那么，在具体技术细节上，这个变量声明是如何发生的呢？</p><p>事实上，这是因为在早期设计中，JavaScript的全局环境是引擎使用一个称为“<strong>全局对象</strong>”东西管理起来的。</p><p>这个全局对象几乎类似或完全等同于一个普通对象。只不过，JavaScript引擎将全局的一些缺省对象、运行期环境的原生对象等东西都初始化在这个全局对象的属性中，并使用这个对象创建了一个称为“<strong>全局对象闭包</strong>”的东西，从而得到了JavaScript的全局环境。</p><p>早期的JavaScript的引擎实现非常简洁，许多基础的技术组件都是直接复用的，例如这里的所谓全局环境、全局闭包，或者全局对象的实现方法，就与“<strong>with语句</strong>”的效果完全相同——他们是相互复用的。</p><p>当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此JavaScript将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了“可以动态地向全局环境中添加一个变量”。并且，显然地，我们在第一讲已经讲过这个结果——你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性。</p><p>那么现在（我是指在ECMAScript6之后）的JavaScript的全局环境有什么不同吗？</p><p>为了兼容旧的JavaScript语言设计，现在的JavaScript环境仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。但是为了得到一个“尽可能”与其它变量环境相似的声明效果（varDecls），ECMAScript规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在eval()中使用<code>var</code>声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是“直接声明的变量”，不能使用<code>delete</code>删除。</p><p>于是，我们得到了这样的一种结果：</p><pre><code>&gt; var a = 100;\n&gt; x = 200;\n\n# `a`和`x`都是global的属性\n&gt; Object.getOwnPropertyDescriptor(global, 'a');\n{ value: 100, writable: true, enumerable: true, configurable: false }\n&gt; Object.getOwnPropertyDescriptor(global, 'x');\n{ value: 200, writable: true, enumerable: true, configurable: true }\n\n# `a`不能删除, `x`可以被删除\n&gt; delete a\nfalse\n&gt; delete x\ntrue\n\n# 检查\n&gt; a\n100\n&gt; x\nReferenceError: x is not defin\n</code></pre><p>所以，表面看起来“泄漏到全局的变量”与使用<code>var</code>声明的都是全局变量，并且都实现为global的属性，但事实上它们是不同的。并且当<code>var</code>声明发生在eval()中的时候，这一特性又还有所不同，例如：</p><pre><code># 使用eval声明\n&gt; eval('var b = 300');\n\n# 它的性质是可删除的\n&gt; Object.getOwnPropertyDescriptor(global, 'b').configurable;\ntrue\n\n# 检测与删除\n&gt; b\n300\n&gt; delete b\ntrue\n&gt; b\nReferenceError: b is not define\n</code></pre><p>这种情况下使用<code>var</code>声明的变量名尽管也会添加到varNames列表，但它也可以从varNames中移除（这是唯一一种能从varNames中移除项的特例，而lexicalNames中的项是不可移除的）。</p><h2>发生了什么？</h2><p>所以，现在回到今天讨论的这行代码<code>var x = y = 100</code>，在这行代码中，等号的右边是一个表达式<code>y = 100</code>，它发生了一次“向不存在的变量赋值”，所以它隐式地声明了一个全局变量<code>y</code>，并赋值为100。</p><p>而一个赋值表达式操作本身也是有“结果（Result）”的，它是右操作数的值。注意，这里是“值”而非“引用”，例如下面的测试中的<code>a</code>将是一个函数，而不是带着“this对象”信息的方法：</p><pre><code>// 调用obj.f()时将检测this是不是原始的obj\n&gt; obj = { f: function() { return this === obj } };\n\n// false，表明赋值表达式的“结果(result)”只是右侧操作数的值，即函数f\n&gt; (a = obj.f)();\nfalse\n</code></pre><p>到现在为止，我们讲述了整个语句的过程，也就是说，由于“y = 100”的结果是100，所以该值将作为初始值赋值“变量x”。并且，从语义上来说，这是变量“x”的初始绑定。</p><p>之所以强调这一点，是因为相同的分析过程也可以用在const声明上，而const声明是只有一次绑定的，常量的初始绑定也是通过“执行赋值过程”来实现的。</p><h2>知识回顾</h2><ul>\n<li>var等声明语句总是在变量作用域（变量表）或词法作用域中静态地声明一个或多个标识符。</li>\n<li>全局变量的管理方式决定了“向一个不存在的变量赋值”所导致的变量泄漏是不可避免的。</li>\n<li>动态添加的“var声明”是可以删除的，这是唯一能操作varNames列表的方式（不过它并不存在多少实用意义）。</li>\n<li>变量声明在引擎的处理上被分成两个部分：一部分是静态的、基于标识符的词法分析和管理，它总是在相应上下文的环境构建时作为名字创建的；另一部分是表达式执行过程，是对上述名字的赋值，这个过程也称为绑定。</li>\n<li>这一讲标题里的这行代码中，x和y是两个不同的东西，前者是声明的名字，后者是一个赋值过程可能创建的变量名。</li>\n</ul><h2>思考题</h2><p>根据今天讲解的内容，我希望你可以尝试回答以下问题：</p><ul>\n<li>严格来说，声明不是语句。但是，是哪些特性决定了声明不是“严格意义上的”语句呢？</li>\n</ul><p>在下一讲中我会来讲一讲JavaScript社区中的一个历史悬案，这桩悬案与今天讨论的这行代码的唯一区别在于：它不是声明语句，而是赋值表达式。</p>","neighbors":{"left":{"article_title":"01 | delete 0：JavaScript中到底有什么是可以销毁的","id":164312},"right":{"article_title":"03 | a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题","id":165985}},"comments":[{"had_liked":false,"id":151305,"user_name":"fatme","can_delete":false,"product_type":"c1","uid":1034451,"ip_address":"","ucode":"75A805D2BB2AD1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","comment_is_top":false,"comment_ctime":1573697943,"is_pvip":false,"replies":[{"id":"58231","content":"+1  ^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573716359,"ip_address":"","comment_id":151305,"utype":1}],"discussion_count":1,"race_medal":0,"score":"379530819991","product_id":100039701,"comment_content":"声明和语句的区别在于发生的时间点不同，声明发生在编译期，语句发生在运行期。声明发生在编译期，由编译器为所声明的变量在相应的变量表，增加一个名字。语句是要在运行时执行的程序代码。因此，如果声明不带初始化，那么可以完全由编译器完成，不会产生运行时执行的代码。","like_count":89,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474431,"discussion_content":"+1  ^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573716359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152920,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574124657,"is_pvip":false,"replies":[{"id":"58779","content":"“因为这是一个函数声明，也就是在编译的时候就创建了”<br>===<br>这个是你混乱的根源，因为从“函数声明”到“闭包”之间还有好几个环节的。<br><br>“函数创建的时候标识符x和y就被创建了”，这个函数内的x和y都是可以被parser到的，因此在函数静态解析完之后，函数就可以确定内部有x和y了，并且相应的静态作用域也（在语法处理相关的内核逻辑部分）被创建了。但是这些东西是用户代码完全不可见的，你不会知道，也用不到。<br><br>然后是一个函数作为表达式得到它的一个实例的过程，也就是<br><br>&gt; (function () {}).xxxxx<br><br>中“.xxxx”之前的部分作为表达式被独立处理的时候，这种情况下函数会有一个自己的环境，该环境也是“基于前面得到的静态作用域”来创建的。这个环境仍然不为用户所知，只是它能传递，例如你可以把这样的东西“返回（return）”或“赋值（=）”给别的东西，你会发现这个东西的“环境&#47;执行上下文”并没有变，所以它们在“返回（return）”或“赋值（=）”的过程之前就被创建了，并且能被这些操作所“传递”。<br><br>最后才是闭包，闭包只发生于“f()”的这个“调用操作()”之后——注意是“之后”，所以高程等等都是说它在“执行之后”标识符才会生成，而我这一章都是在讲“静态语义”，所以我会说他在函数（作为一个静态的对象）创建的时候就已经有这些标识符了。<br><br>这两者都不矛盾。根本上来说，函数实例、函数闭包，都不过是“静态词法解析结果（函数定义&#47;(un)Anonymous Function Definition）”的一个映像，这个“函数定义”就是第4小节讲的那个东东。<br><br>Ok，既然“x,y都是代码执行前就被（静态分析）创建了的”，那么哪种情况下&quot;x&quot;才不是“词法的”呢？<br><br>function f() { let y; return x+y }<br><br>注意在这个例子中，&quot;x&quot;就不是词法的，它在任何情况下都不被创建，不在f()的标识符列表中，也不在语法&#47;词法分析中。<br><br>Ok. 这是第1个问题。<br><br>关于第2个问题，答案其实如上所述：如果“创建”是指静态语义中的一个“函数”，那么确实是创建了的。——但它还没有“绑定”到一个闭包的执行上下文中。<br><br>关于第3个问题，是这样的，这一整个课程（系列）其实不只20讲，大概会是40~45讲的样子。但编辑同学不允许我公布后续内容的计划（呜……），所以……我只能告诉你，在下一个课程里面，才会讲到闭包。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574133802,"ip_address":"","comment_id":152920,"utype":1}],"discussion_count":2,"race_medal":0,"score":"91768437873","product_id":100039701,"comment_content":"hello，老师好啊，研读完文章和评论后还存在如下疑问：<br><br>1.<br><br>var y = &quot;outer&quot;;<br><br>function f() { <br><br>\tconsole.log(y); &#47;&#47; undefined <br><br>\tconsole.log(x); &#47;&#47; throw a Exception <br><br>\tlet x = 100; <br><br>\tvar y = 100; <br><br>\t...<br><br>}<br><br>老师解释函数内部读取不到外部变量的原因是“函数创建的时候标识符x和y就被创建了”。因为这是一个函数声明，也就是在编译的时候就创建了。<br><br>高程上的意思是函数执行的时候会生成一个活动对象当做变量对象，这时候标识符才会生成，包括arguments，形参实参，声明的变量，挂在活动对象上。<br><br>两个解释好像都能说明上面的现象。<br><br>有点糊涂了。<br><br>2.<br><br>function a() {<br><br>\tfunction b() {}<br><br>}<br><br>在代码执行前连函数b都被创建了吗？<br><br>3. 老师对一定了解闭包的本质，后面有机会说到吗？<br>","like_count":21,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474990,"discussion_content":"“因为这是一个函数声明，也就是在编译的时候就创建了”\n===\n这个是你混乱的根源，因为从“函数声明”到“闭包”之间还有好几个环节的。\n\n“函数创建的时候标识符x和y就被创建了”，这个函数内的x和y都是可以被parser到的，因此在函数静态解析完之后，函数就可以确定内部有x和y了，并且相应的静态作用域也（在语法处理相关的内核逻辑部分）被创建了。但是这些东西是用户代码完全不可见的，你不会知道，也用不到。\n\n然后是一个函数作为表达式得到它的一个实例的过程，也就是\n\n&amp;gt; (function () {}).xxxxx\n\n中“.xxxx”之前的部分作为表达式被独立处理的时候，这种情况下函数会有一个自己的环境，该环境也是“基于前面得到的静态作用域”来创建的。这个环境仍然不为用户所知，只是它能传递，例如你可以把这样的东西“返回（return）”或“赋值（=）”给别的东西，你会发现这个东西的“环境/执行上下文”并没有变，所以它们在“返回（return）”或“赋值（=）”的过程之前就被创建了，并且能被这些操作所“传递”。\n\n最后才是闭包，闭包只发生于“f()”的这个“调用操作()”之后——注意是“之后”，所以高程等等都是说它在“执行之后”标识符才会生成，而我这一章都是在讲“静态语义”，所以我会说他在函数（作为一个静态的对象）创建的时候就已经有这些标识符了。\n\n这两者都不矛盾。根本上来说，函数实例、函数闭包，都不过是“静态词法解析结果（函数定义/(un)Anonymous Function Definition）”的一个映像，这个“函数定义”就是第4小节讲的那个东东。\n\nOk，既然“x,y都是代码执行前就被（静态分析）创建了的”，那么哪种情况下&amp;quot;x&amp;quot;才不是“词法的”呢？\n\nfunction f() { let y; return x+y }\n\n注意在这个例子中，&amp;quot;x&amp;quot;就不是词法的，它在任何情况下都不被创建，不在f()的标识符列表中，也不在语法/词法分析中。\n\nOk. 这是第1个问题。\n\n关于第2个问题，答案其实如上所述：如果“创建”是指静态语义中的一个“函数”，那么确实是创建了的。——但它还没有“绑定”到一个闭包的执行上下文中。\n\n关于第3个问题，是这样的，这一整个课程（系列）其实不只20讲，大概会是40~45讲的样子。但编辑同学不允许我公布后续内容的计划（呜……），所以……我只能告诉你，在下一个课程里面，才会讲到闭包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574133802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115471,"discussion_content":"从这个回答中，得到一个重要信息。就是我还得买下一个课程-_-||||","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578015243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150865,"user_name":"Ming","can_delete":false,"product_type":"c1","uid":1358174,"ip_address":"","ucode":"A94E8D8433E54F","user_header":"https://static001.geekbang.org/account/avatar/00/14/b9/5e/a8f6f7db.jpg","comment_is_top":false,"comment_ctime":1573617959,"is_pvip":true,"replies":[{"id":"58040","content":"多谢。我在后面的课程中尽量注意这个 ^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573632927,"ip_address":"","comment_id":150865,"utype":1}],"discussion_count":2,"race_medal":0,"score":"83177996583","product_id":100039701,"comment_content":"〈以下是小生愚见〉<br>概念纷繁，建议老师将讲解重心放到这门语言的现有特性，贯之历史脉络，是否（怎样）解决了某种设计缺陷。这样，知识纵深感更强，并可指导实际工作以避免踩坑。适当穿插示例代码和图文更佳。","like_count":19,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474292,"discussion_content":"多谢。我在后面的课程中尽量注意这个 ^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573632927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691948,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d1/2c/c9f72c08.jpg","nickname":"丁田秀","note":"","ucode":"0AA83E11481AF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306299,"discussion_content":"确实，概念太多，往往要看完整篇文章才知道要表达的是什么，显得看的过程中很迷茫，很枯燥，甚至没有耐心去看完","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600241137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213294,"user_name":"Ppei","can_delete":false,"product_type":"c1","uid":1369514,"ip_address":"","ucode":"C354F8EF0C5814","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/aa/57926594.jpg","comment_is_top":false,"comment_ctime":1588375952,"is_pvip":false,"replies":[{"id":"79162","content":"@Ppei 你提这个问题是很到位的，严格地说，这是我这一讲中跟ECMAScript描述中不一致的地方。所以我需要非常细致地回复你的问题。<br><br>严格来讲，所谓变量提升(Hoisting)指的是如下的现象：<br>```<br>function foo() {<br>  var x = 100;<br>  if (true) {<br>     let y = 200;<br>     var z = 300;<br>     ...<br>  }<br>}<br>```<br><br>在如上示例中，变量z的声明被提升到了x相同的位置声明，相对应的、用作比较的y就没有提升，它声明在if()语句之后的块语句中。<br><br>这是严格的ECMAScript规范概念下的“变量提升”，因此它的确描述的是一种语法现象——在语法阶段，通过自然的、表面的识别就可以理解的现象。<br><br>在ECMAScript中被明确指出的提升现象还包括函数声明。亦即是说，下面的示例：<br>```<br>function foo() {<br>  var x = 100;<br>  if (true) {<br>     let y = 200;<br>     function z() {<br>     }<br>     ...<br>  }<br>}<br>```<br>在这个示例中，函数z()和之前的变量z声明都同样被提升到了x的位置。<br><br>这两种现象——或这两种“严格意义上的变量提升”是JavaScript 1.x时代的早期设计带来的结果。因为没有块级作用域，因此所有的声明都必须“上浮”到函数或全局一级的作用域来处理。这也是我在《JavaScript语言精髓与编程实践》一书中，需要分析“作用域的等级”的原因。这种等级决定了作用域之间的交互关系，而关系之一，就是所谓“提升”。<br><br>除了这两种“严格意义上的变量提升”——函数声明是“隐式的变量声明”——之外，ECMAScript并没有规范其它的提升现象。<br><br>然而通常，在我的讲述中会把如下的现象也称为提升。有些时候，为了特别地指出它们，我会强调它们是一种“提升效果”。例如：<br>```<br>console.log(x);<br>var x = 100;<br>...<br>```<br><br>在如上的例子中，x在它的声明语句之前是能够被访问的。因此，这也是提升。与之相比较的：<br>```<br>console.log(y);<br>var x = 100;<br>let y = 200;<br>```<br><br>这个示例中的`y`就不能被访问，并且提示是：<br>&gt; ReferenceError: y is not defined<br><br>所以，在语法概念上，这个`y`是“还没有声明的”。但是，在事实上呢？在事实上，`y`和`x`都是被声明过了的，只不过`y`被声明之后未被初始化，而`x`被初始化成了undefined。<br><br>所以，“从实现上来说”，这里的所谓<br>&gt; 1、var有变量提升（效果），而let没有变量提升（效果）<br>其实与之前讨论的<br>&gt; 2、var与function在词法作用域中的变量提升<br>并不一样。上述规则2是在规范层面真实的存在的，是语法级别的、在构建作用域的阶段就被“提升”的。而规则1却不是，规则1中的var&#47;let声明在相同的位置，只不过let声明成了未初始化的，并且ECMAScript约定：访问一个未初始化的变量（例如y）时，将错误信息显示成“... is not defined”而已。<br><br>所以我才会说，这种var提升效果，在本质上是`x`没有被拒绝访问，而相对的`y`被拒绝访问。<br><br>回到一些其它的有关Hoisting现象的说明上来，你可以参考一下MDN：<br>https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Glossary&#47;Hoisting<br><br>不过MDN对上述两大类的提升&#47;提升效果也是混在一起讲的，并没有从实现机制的角度来阐释。另外，import和var一样也有“提升效果”，则是“第三种提升”，机制上也是有所不同的，这个我在本专栏中略有讲到，但并不详细。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588469920,"ip_address":"","comment_id":213294,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70307852688","product_id":100039701,"comment_content":"老师你好，词法声明会有提升吗？<br>一些书里面会说不存在变量提升，但是文中说，是拒绝访问。<br>我是不是该从编译期跟运行期去理解？","like_count":16,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493735,"discussion_content":"@Ppei 你提这个问题是很到位的，严格地说，这是我这一讲中跟ECMAScript描述中不一致的地方。所以我需要非常细致地回复你的问题。\n\n严格来讲，所谓变量提升(Hoisting)指的是如下的现象：\n```\nfunction foo() {\n  var x = 100;\n  if (true) {\n     let y = 200;\n     var z = 300;\n     ...\n  }\n}\n```\n\n在如上示例中，变量z的声明被提升到了x相同的位置声明，相对应的、用作比较的y就没有提升，它声明在if()语句之后的块语句中。\n\n这是严格的ECMAScript规范概念下的“变量提升”，因此它的确描述的是一种语法现象——在语法阶段，通过自然的、表面的识别就可以理解的现象。\n\n在ECMAScript中被明确指出的提升现象还包括函数声明。亦即是说，下面的示例：\n```\nfunction foo() {\n  var x = 100;\n  if (true) {\n     let y = 200;\n     function z() {\n     }\n     ...\n  }\n}\n```\n在这个示例中，函数z()和之前的变量z声明都同样被提升到了x的位置。\n\n这两种现象——或这两种“严格意义上的变量提升”是JavaScript 1.x时代的早期设计带来的结果。因为没有块级作用域，因此所有的声明都必须“上浮”到函数或全局一级的作用域来处理。这也是我在《JavaScript语言精髓与编程实践》一书中，需要分析“作用域的等级”的原因。这种等级决定了作用域之间的交互关系，而关系之一，就是所谓“提升”。\n\n除了这两种“严格意义上的变量提升”——函数声明是“隐式的变量声明”——之外，ECMAScript并没有规范其它的提升现象。\n\n然而通常，在我的讲述中会把如下的现象也称为提升。有些时候，为了特别地指出它们，我会强调它们是一种“提升效果”。例如：\n```\nconsole.log(x);\nvar x = 100;\n...\n```\n\n在如上的例子中，x在它的声明语句之前是能够被访问的。因此，这也是提升。与之相比较的：\n```\nconsole.log(y);\nvar x = 100;\nlet y = 200;\n```\n\n这个示例中的`y`就不能被访问，并且提示是：\n&amp;gt; ReferenceError: y is not defined\n\n所以，在语法概念上，这个`y`是“还没有声明的”。但是，在事实上呢？在事实上，`y`和`x`都是被声明过了的，只不过`y`被声明之后未被初始化，而`x`被初始化成了undefined。\n\n所以，“从实现上来说”，这里的所谓\n&amp;gt; 1、var有变量提升（效果），而let没有变量提升（效果）\n其实与之前讨论的\n&amp;gt; 2、var与function在词法作用域中的变量提升\n并不一样。上述规则2是在规范层面真实的存在的，是语法级别的、在构建作用域的阶段就被“提升”的。而规则1却不是，规则1中的var/let声明在相同的位置，只不过let声明成了未初始化的，并且ECMAScript约定：访问一个未初始化的变量（例如y）时，将错误信息显示成“... is not defined”而已。\n\n所以我才会说，这种var提升效果，在本质上是`x`没有被拒绝访问，而相对的`y`被拒绝访问。\n\n回到一些其它的有关Hoisting现象的说明上来，你可以参考一下MDN：\nhttps://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting\n\n不过MDN对上述两大类的提升/提升效果也是混在一起讲的，并没有从实现机制的角度来阐释。另外，import和var一样也有“提升效果”，则是“第三种提升”，机制上也是有所不同的，这个我在本专栏中略有讲到，但并不详细。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588469920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2764177,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/2d/91/2d023a9e.jpg","nickname":"马亮","note":"","ucode":"014425295D3895","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":539256,"discussion_content":"老师，console.log(y); let y;   在执行 console 的时候作用域中已经存在 y并且值为 undefined 了。我理解 y 在编译阶段也已经初始化完毕了吧。只不过出于“词法”的特性，es6 标准限制访问而已。愿闻其详。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639648999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":493735,"ip_address":""},"score":539256,"extra":""}]}]},{"had_liked":false,"id":150842,"user_name":"Mr_Liu","can_delete":false,"product_type":"c1","uid":1472199,"ip_address":"","ucode":"64114CD2E78AB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/c7/74d54fb5.jpg","comment_is_top":false,"comment_ctime":1573615836,"is_pvip":false,"replies":[{"id":"58005","content":"是的。<br><br>delete从不删除值。delete只能删除引用，例如obj.x，或者with(obj) delete x，这些都是以引用的方式得到的，所以delete才能删除它们。<br><br>`delete 0`这种行为并不真的能够发生，它什么也没做，只是返回了true而已。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573620808,"ip_address":"","comment_id":150842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53113223388","product_id":100039701,"comment_content":"思考题: 小白的我，没有太明确的答案，暂时还不能明确自己理解究竟是否正确，希望听老师后续的课程能够明白<br><br>读完今天的这篇理解了昨天的提问，为什么var x = &#39;123&#39;   delete x  是false, <br>即使是<br>var obj ={<br> a: &#39;123&#39;,<br> b: {<br>   name: &#39;123&#39;<br>  }<br>} <br>var z = obj.b<br>delete z 返回也是false<br>所以问了那么delete x 存在有什么意义。<br>今天老师的科解答了<br>x = &#39;123&#39;<br>delete x 返回true <br>是因为你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性。同时也理解了上一讲的“只有在delete x等值于delete obj.x时 delete 才会有执行意义。例如with (obj) ...语句中的 delete x，以及全局属性 global.x。”这句<br>但上一节关于“delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。后一句理解了，但前一句是否可以理解为实际上是删除引用呢，希望老师解答一下<br>立一个flag ，每个争取评论下面都有我的，不为别的，就为增加自己的思考","like_count":12,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474286,"discussion_content":"是的。\n\ndelete从不删除值。delete只能删除引用，例如obj.x，或者with(obj) delete x，这些都是以引用的方式得到的，所以delete才能删除它们。\n\n`delete 0`这种行为并不真的能够发生，它什么也没做，只是返回了true而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573620808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164955,"user_name":"Elmer","can_delete":false,"product_type":"c1","uid":1233975,"ip_address":"","ucode":"61FC9CE0BA5BC1","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/37/528a43e7.jpg","comment_is_top":false,"comment_ctime":1577115986,"is_pvip":true,"replies":[{"id":"62885","content":"这里说到的 varNames在绝大多数情况下是没用的，与你这里想讨论的东西关系也不大。<br><br>window在浏览器环境中等同于global。你在浏览器控制台上查看一下就明白了：<br><br>```<br># 这个globalThis是新EMAScript规范中声明的，它等义于传统的global<br>&gt; window === globalThis<br>true<br><br># 用下面的代码可以获得“传统的global”，并比较之<br>&gt; window === Function(&#39;return this&#39;)()<br>true<br>```<br><br>所以所谓window，就是global，相同的东西。那么window中取变量也就是查global这个对象的属性表，之前也都说过了，不再讲了。至于var&#47;let&#47;const之间的关系，在全局域（global scope）中，var声明在global的属性表中，并在varNames中有一个登记；let&#47;const共享使用同一个称为词法环境（lexicallyEnv）的东西，所以它们不能同名。词法环境在后面会讲到。\b<br><br>因此从原理上来说，全局作用域中的global对象属性，与词法环境中的名字其实是可以重名的。——所以，var与let&#47;const的重名限制，主要是来自于语法。<br><br>例如：<br><br>```<br># 添加属性<br>&gt; global.n = 100<br><br># 看起来有了全局变量的样子（实际上没有在varNames中登记）<br>&gt; n<br>100<br><br># 现在可以声明let<br>&gt; let n = 200<br><br># 这是一个Let变量<br>&gt; n<br>200<br><br># 如果你使用var声明，则与let&#47;const会有重名冲突了<br>&gt; var x = 300<br>&gt; let x = 400<br>SyntaxError: Identifier &#39;x&#39; has already been declared<br>```","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577154358,"ip_address":"","comment_id":164955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44526788946","product_id":100039701,"comment_content":"文中提到：ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames）<br>那么window是怎么取到这些变量的值的，如window.a<br>不是平级么。在global scope中, window var let const 的关系是什么。<br>求讲解","like_count":10,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478967,"discussion_content":"这里说到的 varNames在绝大多数情况下是没用的，与你这里想讨论的东西关系也不大。\n\nwindow在浏览器环境中等同于global。你在浏览器控制台上查看一下就明白了：\n\n```\n# 这个globalThis是新EMAScript规范中声明的，它等义于传统的global\n&amp;gt; window === globalThis\ntrue\n\n# 用下面的代码可以获得“传统的global”，并比较之\n&amp;gt; window === Function(&amp;#39;return this&amp;#39;)()\ntrue\n```\n\n所以所谓window，就是global，相同的东西。那么window中取变量也就是查global这个对象的属性表，之前也都说过了，不再讲了。至于var/let/const之间的关系，在全局域（global scope）中，var声明在global的属性表中，并在varNames中有一个登记；let/const共享使用同一个称为词法环境（lexicallyEnv）的东西，所以它们不能同名。词法环境在后面会讲到。\b\n\n因此从原理上来说，全局作用域中的global对象属性，与词法环境中的名字其实是可以重名的。——所以，var与let/const的重名限制，主要是来自于语法。\n\n例如：\n\n```\n# 添加属性\n&amp;gt; global.n = 100\n\n# 看起来有了全局变量的样子（实际上没有在varNames中登记）\n&amp;gt; n\n100\n\n# 现在可以声明let\n&amp;gt; let n = 200\n\n# 这是一个Let变量\n&amp;gt; n\n200\n\n# 如果你使用var声明，则与let/const会有重名冲突了\n&amp;gt; var x = 300\n&amp;gt; let x = 400\nSyntaxError: Identifier &amp;#39;x&amp;#39; has already been declared\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577154358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233858,"user_name":"孜孜","can_delete":false,"product_type":"c1","uid":1018203,"ip_address":"","ucode":"7EF4FB644357CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","comment_is_top":false,"comment_ctime":1594481281,"is_pvip":true,"replies":[{"id":"86352","content":"1. 第一个是“函数表达式”，(expression, ...)的语法能通过；第二个是语句（6种声明语句之一），所以这个语法通不过。<br><br>2. 第一种`(function f...)()`是将函数f作为一个“单值表达式”，这里的第一对括号是作为“分组运算符”来用的，它强制将`function f...`作为一个表达式来做语法解析，从而避免了它被“（优先地）解释为函数声明语句”。而第二种，也就是`function f {}()`中的f，也是因为相同的原因（第一对括号作为分组运算符），从而导致解析过程进入表达式解析，所以这个函数与第一种没区别。但是接下来，它进行了函数运算调用——也就是f()。——而这里也是两种用户的不同，第一种用法是第一对括号返回函数，第二种用法中第一对括号返回的是函数调用的结果。<br><br>3. 这分别是:<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-call<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-grouping-operator<br>不过第二种不称为“表达式取值”，而是“分组表达式”，它的运算效果是“取Result”——也就是说不仅仅是取值，还可以包括取“（ECMAScript规范的）引用”。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1594573272,"ip_address":"","comment_id":233858,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40249186945","product_id":100039701,"comment_content":"今天写IIFE,突然有点问题想问下老师，<br>1. 为什么(function f(){ return this}) 可以，(var test=1) 不可以。<br>2. 两种IIFE的写法，(function f(){ return this})() 和 (function f(){ return this}()) 有何区别。<br>3. 函数调用（）和表达式取值（）如何在ECMAScript找到说明？","like_count":10,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501190,"discussion_content":"1. 第一个是“函数表达式”，(expression, ...)的语法能通过；第二个是语句（6种声明语句之一），所以这个语法通不过。\n\n2. 第一种`(function f...)()`是将函数f作为一个“单值表达式”，这里的第一对括号是作为“分组运算符”来用的，它强制将`function f...`作为一个表达式来做语法解析，从而避免了它被“（优先地）解释为函数声明语句”。而第二种，也就是`function f {}()`中的f，也是因为相同的原因（第一对括号作为分组运算符），从而导致解析过程进入表达式解析，所以这个函数与第一种没区别。但是接下来，它进行了函数运算调用——也就是f()。——而这里也是两种用户的不同，第一种用法是第一对括号返回函数，第二种用法中第一对括号返回的是函数调用的结果。\n\n3. 这分别是:\nhttps://tc39.es/ecma262/#sec-call\nhttps://tc39.es/ecma262/#sec-grouping-operator\n不过第二种不称为“表达式取值”，而是“分组表达式”，它的运算效果是“取Result”——也就是说不仅仅是取值，还可以包括取“（ECMAScript规范的）引用”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594573272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018203,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","nickname":"孜孜","note":"","ucode":"7EF4FB644357CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290811,"discussion_content":"谢谢老师。爱你，么么哒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594611030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230225,"user_name":"Isaac","can_delete":false,"product_type":"c1","uid":1110607,"ip_address":"","ucode":"038C349AB508AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","comment_is_top":false,"comment_ctime":1593316626,"is_pvip":false,"replies":[{"id":"85000","content":"你说的“引用类型”，不是我说的“引用（规范类型）”。<br><br>以下面的代码为例：<br><br>```<br>x = obj.foo<br>```<br><br>右操作是`obj.foo`，它的引用是obj.foo整体，这包括“obj这个对象”的信息——这称为“引用（规范类型）”；而它的值是GetValue(obj.foo)，GetValue()是引擎的内部操作，是从“引用（规范类型）”中取值，其结果会是foo这个函数。<br><br>对于上述赋值表达式来说，`x = obj.foo` 其结果是`x`变成了函数foo，那么它就是右侧操作数的“值”，而不是右操作数“obj.foo”的全部信息。<br><br>有没有上述示例的反例呢？也就是一个运算符的结果仍然是“obj.foo的全部信息（引用）”，而不仅是它的“值（GetValue的结果）”呢？<br><br>有的。下面的示例：<br><br>```<br>(obj.foo)<br>```<br><br>这一对括号称为“分组运算符（也有称着强制运算符的）”，这个括号的运算结果就是“操作数的引用”。所以，在下一步的运算中：<br><br>```<br>(obj.foo)()<br>```<br><br>这个方法调用中的foo函数可以得到this为obj。<br><br>最后汇总一下：<br>```<br>obj = {<br>  foo() {<br>    console.log(this === obj)<br>  }<br>}<br><br>&#47;&#47; case 1，赋值运算只得到了右侧运算数的“值”<br>x = obj.foo;<br>x();  &#47;&#47; false<br><br>&#47;&#47; case 2，分组运算得到了操作数的“引用（全部的信息）”<br>(obj.foo)();  &#47;&#47; true<br>```<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1593329092,"ip_address":"","comment_id":230225,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40248022290","product_id":100039701,"comment_content":"「一个赋值表达式操作本身也是有“结果（Result）”，它是右操作数的值。注意，这里是“值”而非“引用”」<br>老师，你好，这句话从“值类型”的角度可以理解，但是对于引用类型怎么理解？<br>比如：var x = y = { name: &#39;jack ma&#39; }。<br><br>我的理解：<br>由于 { name: &#39;jack ma&#39; } 本身是引用类型，所以 y = { name: &#39;jack ma&#39; } 的赋值操作的结果也是“一个引用”，所以这里的“值”其实和类型无关，仅仅是一个运算结果。<br><br>在回到这句话：「它是右操作数的值」 ，用更通俗易懂话来讲，这里的“值”仅仅是一个运算结果，和类型无关。<br><br>请问老师我这样理解正确吗？如果错误的话，该怎么解释 var x = y = { name: &#39;jack ma&#39; }？","like_count":9,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499804,"discussion_content":"你说的“引用类型”，不是我说的“引用（规范类型）”。\n\n以下面的代码为例：\n\n```\nx = obj.foo\n```\n\n右操作是`obj.foo`，它的引用是obj.foo整体，这包括“obj这个对象”的信息——这称为“引用（规范类型）”；而它的值是GetValue(obj.foo)，GetValue()是引擎的内部操作，是从“引用（规范类型）”中取值，其结果会是foo这个函数。\n\n对于上述赋值表达式来说，`x = obj.foo` 其结果是`x`变成了函数foo，那么它就是右侧操作数的“值”，而不是右操作数“obj.foo”的全部信息。\n\n有没有上述示例的反例呢？也就是一个运算符的结果仍然是“obj.foo的全部信息（引用）”，而不仅是它的“值（GetValue的结果）”呢？\n\n有的。下面的示例：\n\n```\n(obj.foo)\n```\n\n这一对括号称为“分组运算符（也有称着强制运算符的）”，这个括号的运算结果就是“操作数的引用”。所以，在下一步的运算中：\n\n```\n(obj.foo)()\n```\n\n这个方法调用中的foo函数可以得到this为obj。\n\n最后汇总一下：\n```\nobj = {\n  foo() {\n    console.log(this === obj)\n  }\n}\n\n// case 1，赋值运算只得到了右侧运算数的“值”\nx = obj.foo;\nx();  // false\n\n// case 2，分组运算得到了操作数的“引用（全部的信息）”\n(obj.foo)();  // true\n```\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593329092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171677,"user_name":"Zheng","can_delete":false,"product_type":"c1","uid":1089215,"ip_address":"","ucode":"2E7739395DA146","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/bf/439c9afb.jpg","comment_is_top":false,"comment_ctime":1578990398,"is_pvip":true,"replies":[{"id":"66576","content":"是这样的，node缺省情况下是把.js文件当成模块来加载的，它会为每一个模块（亦即是.js文件）包一层所谓的“模块封装器”。这个封装器是一个函数。所以，.js文件中的代码事实上是运行在函数中的。这样一来，`var a`就变成了声明函数内的局部变量，而不是在全局global上的。<br><br>在node的控制台里面输入的代码是作为全局环境下的代码来执行的，因此如果你的代码是在node控制台上逐行执行，就没有问题。另外，如果你使用-e参数来执行，那么也能得到这样的效果（这种情况下node不会添加模块封装器）：<br><br>```<br>&gt; node -e &quot;$(cat test.js)&quot; -p<br>{ value: 100,<br>  writable: true,<br>  enumerable: true,<br>  configurable: false }<br>```<br><br><br>&gt; NOTE: 模块封装器，参见：http:&#47;&#47;nodejs.cn&#47;api&#47;modules.html#modules_the_module_wrapper","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578996151,"ip_address":"","comment_id":171677,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35938728766","product_id":100039701,"comment_content":"老师，我用node执行这段代码，结果是undefined，但是换成浏览器打印就可以打印出来a的配置信息，这是因为node环境和浏览器的差异还是什么，我试过好多次了，应该不是偶然:<br><br>var a = 100;<br>x = 200;<br>console.log(Object.getOwnPropertyDescriptor(global,&quot;a&quot;)); &#47;&#47;浏览器执行的时候global改为globalThis","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481467,"discussion_content":"是这样的，node缺省情况下是把.js文件当成模块来加载的，它会为每一个模块（亦即是.js文件）包一层所谓的“模块封装器”。这个封装器是一个函数。所以，.js文件中的代码事实上是运行在函数中的。这样一来，`var a`就变成了声明函数内的局部变量，而不是在全局global上的。\n\n在node的控制台里面输入的代码是作为全局环境下的代码来执行的，因此如果你的代码是在node控制台上逐行执行，就没有问题。另外，如果你使用-e参数来执行，那么也能得到这样的效果（这种情况下node不会添加模块封装器）：\n\n```\n&amp;gt; node -e &amp;quot;$(cat test.js)&amp;quot; -p\n{ value: 100,\n  writable: true,\n  enumerable: true,\n  configurable: false }\n```\n\n\n&amp;gt; NOTE: 模块封装器，参见：http://nodejs.cn/api/modules.html#modules_the_module_wrapper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578996151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213738,"user_name":"Geek_baa4ad","can_delete":false,"product_type":"c1","uid":1211737,"ip_address":"","ucode":"34CD7C63756A8F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/yicicolgdxU2vTP6ExtAf6NicvFicuAfM0tL7bOoPDMZa0bYVa8wkV10DgnpobHX9blmIicdL6zFS76Dq40Rm8xt21g/132","comment_is_top":false,"comment_ctime":1588537878,"is_pvip":false,"replies":[{"id":"79230","content":"不要在浏览器中测试，也不要在node repl中测试。这些要么受环境的host&#47;global设计的影响，要么受模块加载的影响。<br><br>得到纯v8引擎测试环境的方法，要么是直接编译一个v8，要么是使用下面这样方法：<br><br>```<br>&#47;&#47; 将下面的代码写文件test.js<br>var x = y = 100;<br>console.log(Object.getOwnPropertyDescriptor(global, &#39;x&#39;));<br>console.log(Object.getOwnPropertyDescriptor(global, &#39;y&#39;));<br>```<br><br>然后：<br>```<br># 在命令行上使用nodejs（在mac&#47;linux环境）<br>&gt; node -e &quot;$(cat test.js)&quot;<br>{ value: 100, writable: true, enumerable: true, configurable: false }<br>{ value: 100, writable: true, enumerable: true, configurable: true }<br>```<br><br>好运。：）","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588579291,"ip_address":"","comment_id":213738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31653308950","product_id":100039701,"comment_content":"var x = y = 100;<br>Object.getOwnPropertyDescriptor(global, &#39;x&#39;);<br>Object.getOwnPropertyDescriptor(global, &#39;y&#39;);<br>{value: 100, writable: true, enumerable: true, configurable: false}configurable: falseenumerable: truevalue: 100writable: true__proto__: Object<br>Object.getOwnPropertyDescriptor(global, &#39;x&#39;);<br>{value: 100, writable: true, enumerable: true, configurable: false}<br>Object.getOwnPropertyDescriptor(global, &#39;y&#39;);<br>{value: 100, writable: true, enumerable: true, configurable: false}<br><br>得到结果一样吖，x y 是一个相同的东西吧 最新的v8 实现不一样啦？","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493856,"discussion_content":"不要在浏览器中测试，也不要在node repl中测试。这些要么受环境的host/global设计的影响，要么受模块加载的影响。\n\n得到纯v8引擎测试环境的方法，要么是直接编译一个v8，要么是使用下面这样方法：\n\n```\n// 将下面的代码写文件test.js\nvar x = y = 100;\nconsole.log(Object.getOwnPropertyDescriptor(global, &amp;#39;x&amp;#39;));\nconsole.log(Object.getOwnPropertyDescriptor(global, &amp;#39;y&amp;#39;));\n```\n\n然后：\n```\n# 在命令行上使用nodejs（在mac/linux环境）\n&amp;gt; node -e &amp;quot;$(cat test.js)&amp;quot;\n{ value: 100, writable: true, enumerable: true, configurable: false }\n{ value: 100, writable: true, enumerable: true, configurable: true }\n```\n\n好运。：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588579291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152323,"user_name":"陆昱嘉","can_delete":false,"product_type":"c1","uid":1389114,"ip_address":"","ucode":"A5E26B3F9A5A8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/32/3a/ead5611e.jpg","comment_is_top":false,"comment_ctime":1573972601,"is_pvip":false,"replies":[{"id":"58559","content":"“var y = 100”不是表达式，而是语句。<br><br>所以“var x = y = 100”里面：<br><br>- “var x ...”是语句语法（Variable Statement）<br>- “= ...”是初始化器（Initializer，严格来说，也不是表达式，而是语法的一部分）<br>- “y = 100”是表达式（expression）。<br><br>所以你列的问题，报错的原因是“语句在语法上不支持这种写法”，即在“ = ...”中的“...”上面，必须是一个用来做“初始器”的表达式，而不能“再是一个语句”。<br><br>参见ECMAScript：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-variable-statement<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#prod-VariableDeclaration","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573992326,"ip_address":"","comment_id":152323,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31638743673","product_id":100039701,"comment_content":"老师，一个赋值表达式的左边和右边其实“都是”表达式，那么var x=(var y=100);这样就报错，原因是什么？varNames里面的冲突？","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474783,"discussion_content":"“var y = 100”不是表达式，而是语句。\n\n所以“var x = y = 100”里面：\n\n- “var x ...”是语句语法（Variable Statement）\n- “= ...”是初始化器（Initializer，严格来说，也不是表达式，而是语法的一部分）\n- “y = 100”是表达式（expression）。\n\n所以你列的问题，报错的原因是“语句在语法上不支持这种写法”，即在“ = ...”中的“...”上面，必须是一个用来做“初始器”的表达式，而不能“再是一个语句”。\n\n参见ECMAScript：\nhttps://tc39.es/ecma262/#sec-variable-statement\nhttps://tc39.es/ecma262/#prod-VariableDeclaration","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573992326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151120,"user_name":"佳民","can_delete":false,"product_type":"c1","uid":1000433,"ip_address":"","ucode":"A5626BAEC96945","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/f1/3c69eb09.jpg","comment_is_top":false,"comment_ctime":1573655407,"is_pvip":false,"replies":[{"id":"58208","content":"是的。不过所有的6种声明都是如此，非独var声明。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573697887,"ip_address":"","comment_id":151120,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31638426479","product_id":100039701,"comment_content":"思考题：var声明会声明提升，在语法解析（静态分析）阶段进行，不是在运行阶段执行，这样理解对吗？","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474369,"discussion_content":"是的。不过所有的6种声明都是如此，非独var声明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573697887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000433,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/f1/3c69eb09.jpg","nickname":"佳民","note":"","ucode":"A5626BAEC96945","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50286,"discussion_content":"哦...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573699361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257755,"user_name":"G","can_delete":false,"product_type":"c1","uid":2189373,"ip_address":"","ucode":"C267833DBBE254","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/3lp20weUpmEjiaLAS6umkKRGB7WicIPGWQ7sjRsxbw0EAiapnslID17FfmrMFppSDw7vn0A8bu1icBBmPXGGweGhjQ/132","comment_is_top":false,"comment_ctime":1604118020,"is_pvip":false,"replies":[{"id":"94087","content":"好问题！<br><br>其实你发现了一个有关于执行环境的、很深层面的问题。简单地表述来说是这样：如果具名函数把自己的名字登记在“函数所在的上下文（环境）”中，那么匿名函数如何登记自己呢？——对于这个问题，更深一点的问下去，就会是“如果匿名函数不能登记，那么它怎么执行呢”？<br><br>其实，整个问题的核心关键在于：这根本不是匿名&#47;具名函数的问题，而是函数声明&#47;函数表达式的问题。注意以下的讨论中要特别强调的是：你所有几个示例中声明的，都是“具名的函数表达式”，而不是“具名函数（声明语句）”。<br><br>好的。真实的情况是这样：1、函数表达式“不会”向当前的环境中登记自己的名字；2、你无法声明出一个匿名函数的语句（这有一个例外，就是export default ...）。<br><br>先说第1条。“（所有的）函数表达式”其实都是不会向当前环境中声明的，只是在表达式执行到的时候，这个函数才会被创建。而当它被创建时，它立即创建一个与这个函数相关的上下文，而由于它是“函数表达式”，所以不会“变动（当前的）”环境——即不改变词法的环境，也不改变变量的环境。<br><br>然后你应该会注意到这个问题，就是“具名的函数表达式”也是有名字的，对吧。是的，但是这个名字“并不注册在当前的上下文环境中”。在函数表达式的实现中，这是一个非常少有人注意到的技巧，称为“多重的环境（或这里可以称为闭包）”，也就是说这样的函数其实有两个闭包，一个外层的，登记了函数名字；一个内层的，登记了参数表等等。这样一来，在“具名的函数表达式”中，既可以让函数体内的代码用到“函数名”（包括覆盖它），又不需要这个名字被“注册到”外部的（例如当前的）环境中。<br><br>关于这一部分，可以参阅《JavaScript语言精髓与编程实践》的第“5.5.2.4 函数表达式的特殊性”一节。<br><br>第2个问题。这是一个细节，因为export是语句，因此如果它用来声明一个匿名函数，那么这个匿名函数也将是“语句声明出来的”，所以它是特例。并且在真实的情况中，这样的一个“匿名函数”其实也是有名字的，它被登记在一个名为“*default*”的项中。这个在本课程的第4讲中也是讲述过了。<br><br>最后，你的问题其实还涉及“函数表达式在当前作用域中到底‘需要&#47;不需要’有名字”的问题，以及所谓的“条件化声明（语句）“的问题，等等。这些是古老时代不同js引擎的实现带来的、与规范有差异的遗产，例如JScript 5.6及之前的版本就认为“具名的函数表达需要在当前作用域中声明一个名字”（这也称为名字泄露）。不过，这些问题中绝大多数如今已经有了定论，你可以再翻翻文章。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1604399553,"ip_address":"","comment_id":257755,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27373921796","product_id":100039701,"comment_content":"老师您好，在回过头来重新读这个课程的时候，我产生了一些新的疑惑。<br>在静态语法解析阶段，会在词法环境中添加所声明的标识符，那么像下面这样的代码：<br>var arr = new Array;<br>for (var i=0; i&lt;5; i++) arr.push(function f() {<br>  &#47;&#47; ...<br>});<br>这段代码是在第八讲中粘贴过来的，第八讲中有说，静态函数f（）有且仅有一个。那么这个函数f是什么时候被定义的，又被定义在了什么样的词法环境下呢？<br>我上面的表述可能不明确，我大概就是想问这么一个问题：<br>let obj = {<br>      test:function(cb){<br>        cb();<br>        (()=&gt;{console.log(this);})()<br>      }<br>    }<br>    obj.test(() =&gt; {console.log(this);})<br><br><br>() =&gt; {console.log(this) 这个箭头函数，是在什么时候被定义的，定义在了哪里。<br>从 cb执行 this打印来看，应该是定义在了全局环境下。<br>但是由于它是一个匿名函数，所以我在全局无法打印出它来验证。但是我把<br>() =&gt; {console.log(this)换成function f() {console.log(this)},全局下也没有办法访问到 f 。<br><br>我描述的可能不太清楚，我大概是想知道，被当做实参传入的函数，是在什么时候被声明的，声明在了哪里。  <br><br><br>","like_count":6,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508440,"discussion_content":"好问题！\n\n其实你发现了一个有关于执行环境的、很深层面的问题。简单地表述来说是这样：如果具名函数把自己的名字登记在“函数所在的上下文（环境）”中，那么匿名函数如何登记自己呢？——对于这个问题，更深一点的问下去，就会是“如果匿名函数不能登记，那么它怎么执行呢”？\n\n其实，整个问题的核心关键在于：这根本不是匿名/具名函数的问题，而是函数声明/函数表达式的问题。注意以下的讨论中要特别强调的是：你所有几个示例中声明的，都是“具名的函数表达式”，而不是“具名函数（声明语句）”。\n\n好的。真实的情况是这样：1、函数表达式“不会”向当前的环境中登记自己的名字；2、你无法声明出一个匿名函数的语句（这有一个例外，就是export default ...）。\n\n先说第1条。“（所有的）函数表达式”其实都是不会向当前环境中声明的，只是在表达式执行到的时候，这个函数才会被创建。而当它被创建时，它立即创建一个与这个函数相关的上下文，而由于它是“函数表达式”，所以不会“变动（当前的）”环境——即不改变词法的环境，也不改变变量的环境。\n\n然后你应该会注意到这个问题，就是“具名的函数表达式”也是有名字的，对吧。是的，但是这个名字“并不注册在当前的上下文环境中”。在函数表达式的实现中，这是一个非常少有人注意到的技巧，称为“多重的环境（或这里可以称为闭包）”，也就是说这样的函数其实有两个闭包，一个外层的，登记了函数名字；一个内层的，登记了参数表等等。这样一来，在“具名的函数表达式”中，既可以让函数体内的代码用到“函数名”（包括覆盖它），又不需要这个名字被“注册到”外部的（例如当前的）环境中。\n\n关于这一部分，可以参阅《JavaScript语言精髓与编程实践》的第“5.5.2.4 函数表达式的特殊性”一节。\n\n第2个问题。这是一个细节，因为export是语句，因此如果它用来声明一个匿名函数，那么这个匿名函数也将是“语句声明出来的”，所以它是特例。并且在真实的情况中，这样的一个“匿名函数”其实也是有名字的，它被登记在一个名为“*default*”的项中。这个在本课程的第4讲中也是讲述过了。\n\n最后，你的问题其实还涉及“函数表达式在当前作用域中到底‘需要/不需要’有名字”的问题，以及所谓的“条件化声明（语句）“的问题，等等。这些是古老时代不同js引擎的实现带来的、与规范有差异的遗产，例如JScript 5.6及之前的版本就认为“具名的函数表达需要在当前作用域中声明一个名字”（这也称为名字泄露）。不过，这些问题中绝大多数如今已经有了定论，你可以再翻翻文章。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604399553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320950,"discussion_content":"> 我大概能知道这个作为实参匿名函数是被&#39;定义&#39;在当前环境下...\n\n问题就是根本没有这个“定义（声明）”。表达式，以及函数实例（闭包）是在执行过程中创建的，这种情况下创建的实例并不登记/声明在环境中，但是函数实例会有内部槽来反向指向环境，以便函数访问它的作用域（环境记录）等。\n\n还有，你的obj.test()中其实有两个匿名箭头函数，一个是obj.test(cb)中传进去，回想一下函数调用过程，会做一次“实参->形参的绑定”，因此就绑定给了obj.test()函数中的cb这个名字。而另一个是“声明即调用”的，这种情况下没有绑定，只是创建了一个执行上下文和相关联的环境记录，然后将这个上下文扔进执行栈，函数就直接在这个环境中执行就好了。——而最后，执行结束就栈就清除了，什么环境呀名字呀都没哒。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604508251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2189373,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/3lp20weUpmEjiaLAS6umkKRGB7WicIPGWQ7sjRsxbw0EAiapnslID17FfmrMFppSDw7vn0A8bu1icBBmPXGGweGhjQ/132","nickname":"G","note":"","ucode":"C267833DBBE254","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320476,"discussion_content":"我最后说的声明不太准确，因为以实参传入的函数实际上应该是一个(function () {})这种函数表达式的形式，所以实际上传入的就相当于一个匿名函数的实例。我大概能知道这个作为实参匿名函数是被&#39;定义&#39;在当前环境下，不过它是什么时候被定义的呢，为什么是定义在当前环境下，而不是被定义在了cb的闭包内。如果是定义在当前环境(例子中是全局)，那么将一个匿名函数定义在全局有什么意义吗(因为匿名函数无法被访问到啊)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604377728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150821,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1573613629,"is_pvip":false,"replies":[{"id":"58003","content":"动态语言的诸多细节，其实要到18讲之后才会讨论到。不过有个概念上的问题，并不是说有动态类型就是动态语言，或者说支持动态执行就是动态语言。有很多方面的“动态语言的特性”，这个需要详细解析。<br><br>仅是说初始化这一项，使用动态赋值的原因是因为这个值必须要到执行期环境中才能确定下来，而在静态语法分析阶段是确认不了的。——所以它不可能“先于环境”而执行。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573620599,"ip_address":"","comment_id":150821,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27343417405","product_id":100039701,"comment_content":"醍醐灌顶，但是有一些疑问：<br>文中说，<br>&quot;如果是在一门其它的（例如编译型的）语言中，“为变量 x 绑定一个初值”就可能实现为“在创建环境时将变量 x 指向一个特定的初始值”。这通常是静态语言的处理方法，然而，如前面说过的，JavaScript 是门动态的语言，所以它的“绑定初值”的行为是通过动态的执行过程来实现的，也就是赋值操作。&quot;<br><br>为什么动态语言就不可以给变量初始化， 一定要使用动态赋值呢？<br>我对动态语言的理解是，变量的类型可以在运行时改变，静态语言变量的类型不可以改变。 但是这性质好像并不影响初始化？","like_count":6,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474280,"discussion_content":"动态语言的诸多细节，其实要到18讲之后才会讨论到。不过有个概念上的问题，并不是说有动态类型就是动态语言，或者说支持动态执行就是动态语言。有很多方面的“动态语言的特性”，这个需要详细解析。\n\n仅是说初始化这一项，使用动态赋值的原因是因为这个值必须要到执行期环境中才能确定下来，而在静态语法分析阶段是确认不了的。——所以它不可能“先于环境”而执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573620599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1319638,"avatar":"https://static001.geekbang.org/account/avatar/00/14/22/d6/9378f4d5.jpg","nickname":"隔夜果酱","note":"","ucode":"5AFEB62E832BCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50720,"discussion_content":"比如c#也引入了var关键字用于变量声明.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573746606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225694,"user_name":"卡尔","can_delete":false,"product_type":"c1","uid":1445936,"ip_address":"","ucode":"BD6F76BC18FF8F","user_header":"https://static001.geekbang.org/account/avatar/00/16/10/30/c07d419c.jpg","comment_is_top":false,"comment_ctime":1591835892,"is_pvip":false,"replies":[{"id":"83233","content":"`let a;`<br>是作为`let a = undefined;`处理的。<br><br>声明语句确实是在语法分析期和环境初始化阶段处理的，但当代码“执行到”相应位置时，会执行它在“运行期语义”——也就是“绑定值”。<br><br>而如上说它是作为“let a = undefined”来处理的，因此这一行代码不是“没有赋值操作”，而是“执行了初值绑定操作”。<br><br>“绑定初值”与“赋值”是语法效果上是一致的，只是概念上的不同。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1591905214,"ip_address":"","comment_id":225694,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23066672372","product_id":100039701,"comment_content":"老师，你说let声明的变量不能在赋值之前使用。<br>这里说的赋值是不是说赋值操作呢？<br>let a;<br>console.log(a)<br>上面代码对a是没有赋值操作吧？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497950,"discussion_content":"`let a;`\n是作为`let a = undefined;`处理的。\n\n声明语句确实是在语法分析期和环境初始化阶段处理的，但当代码“执行到”相应位置时，会执行它在“运行期语义”——也就是“绑定值”。\n\n而如上说它是作为“let a = undefined”来处理的，因此这一行代码不是“没有赋值操作”，而是“执行了初值绑定操作”。\n\n“绑定初值”与“赋值”是语法效果上是一致的，只是概念上的不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591905214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445936,"avatar":"https://static001.geekbang.org/account/avatar/00/16/10/30/c07d419c.jpg","nickname":"卡尔","note":"","ucode":"BD6F76BC18FF8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282181,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591919089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181142,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1582505617,"is_pvip":false,"replies":[{"id":"70321","content":"在ECMAScript中，并没有“赋值语句”，它的准确说法是“赋值表达式语句”。——任何一般表达式，都可以解析为一个语句，并称为“一般表达式语句”。所以“赋值表达式（语句）”在这里并没有任何的特殊性。<br><br>“任何一般表达式”都可以通过在末尾添加一个“;”号来表明将它处理为一个语句（包括还有换行符，以及文末符等等，这些参考“自动分号插入(ASI)”这个语法特性）。<br><br>所以这里不存在是否“错误”的问题。很多地方、很多书都只是按传统的语言习惯来理解JavaScript，所以用传统的名字或概念往上面套。进一步的，也就有了很多似是而非的概念。如果真正的追求概念上的准确性，那么应该使用ECMAScript规范中的明确定义。——但是如果这样讲，那么这个课程中基础也还有稍稍有一些地方有着含混不清的概念的。<br><br>JavaScript中需要分开理解表达式和语句，它们处理机制不同，结果不同，效果也不同，应用环境还是不同。这些的入手点称为“表达式语言”，也就是所谓“函数式语言特性”。你可以尝试着将所有的语句去掉，试着用“纯粹地JavaScript表达式”来写代码，你会发现JS在这个层面上也是完备的。只有先抽离出了“表达式”，以及“表达式语言”，再反观“语句”，才能理解语句真正的用处。总而言之，语句与表达式在JavaScript的语言设计中是很精彩而又令人迷惑的。<br><br>这个课程的后面一部分会分开讲“语句执行”和“表达式执行”，慢慢看就会明白这些东西之间的区别了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582554873,"ip_address":"","comment_id":181142,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23057342097","product_id":100039701,"comment_content":"y = 100 有的地方叫赋值语句，有的地方叫赋值表达式。因为它的执行结构能在代码层面获得 x = (y = 10)，所以我更倾向于认为它是表达式。<br><br>想请问下老师叫赋值语句是错误的么，还是有其它的原因？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484934,"discussion_content":"在ECMAScript中，并没有“赋值语句”，它的准确说法是“赋值表达式语句”。——任何一般表达式，都可以解析为一个语句，并称为“一般表达式语句”。所以“赋值表达式（语句）”在这里并没有任何的特殊性。\n\n“任何一般表达式”都可以通过在末尾添加一个“;”号来表明将它处理为一个语句（包括还有换行符，以及文末符等等，这些参考“自动分号插入(ASI)”这个语法特性）。\n\n所以这里不存在是否“错误”的问题。很多地方、很多书都只是按传统的语言习惯来理解JavaScript，所以用传统的名字或概念往上面套。进一步的，也就有了很多似是而非的概念。如果真正的追求概念上的准确性，那么应该使用ECMAScript规范中的明确定义。——但是如果这样讲，那么这个课程中基础也还有稍稍有一些地方有着含混不清的概念的。\n\nJavaScript中需要分开理解表达式和语句，它们处理机制不同，结果不同，效果也不同，应用环境还是不同。这些的入手点称为“表达式语言”，也就是所谓“函数式语言特性”。你可以尝试着将所有的语句去掉，试着用“纯粹地JavaScript表达式”来写代码，你会发现JS在这个层面上也是完备的。只有先抽离出了“表达式”，以及“表达式语言”，再反观“语句”，才能理解语句真正的用处。总而言之，语句与表达式在JavaScript的语言设计中是很精彩而又令人迷惑的。\n\n这个课程的后面一部分会分开讲“语句执行”和“表达式执行”，慢慢看就会明白这些东西之间的区别了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582554873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157821,"user_name":"家家家家","can_delete":false,"product_type":"c1","uid":1742456,"ip_address":"","ucode":"3F93032D20F9F1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/96/78/114b03c7.jpg","comment_is_top":false,"comment_ctime":1575265684,"is_pvip":false,"replies":[{"id":"60483","content":"这个讲法倒也不错，比较容易理解。<br>不过有些不严谨的地方，比如说，“var x;”这样的声明，“声明阶段和初始化阶段一齐发生”是对的，因为var声明的时候，名字声明并初始化为undefined确实是同时发生的。但是，如果是“var x = 100;”，那么就比较容易混淆了。因为“x = 100”其实是赋值，而不是引擎层面的“初始化”。<br><br>对于let来说，“声明阶段和初始化阶段是分开”其实更不严谨。确切地说，let就没有“初始化阶段”。而用户代码“let x = 100”中的“x = 100”就是赋值阶段了。“let 没有初始化阶段”，所以才会出现它在未赋值之前不能读的现象。<br><br>用这样三个阶段来解释这件事情，跟ECMAScript中的逻辑并不矛盾（而且也可以正确解释），只是细节上需要严谨一点、留意一点就行。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575271970,"ip_address":"","comment_id":157821,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23050102164","product_id":100039701,"comment_content":"忘了在哪本书中还是哪篇文章中讲过，变量的生命周期：声明阶段、初始化阶段、赋值阶段。<br>老师这里讲的静态分析阶段就是指的变量生命周期中的声明阶段对吗？<br>对于var，它的声明阶段和初始化阶段是一起发生的，都在静态分析中；对于let，它的声明阶段和初始化阶段是分开的，只有声明阶段在静态分析中，是这样理解的嘛？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476540,"discussion_content":"这个讲法倒也不错，比较容易理解。\n不过有些不严谨的地方，比如说，“var x;”这样的声明，“声明阶段和初始化阶段一齐发生”是对的，因为var声明的时候，名字声明并初始化为undefined确实是同时发生的。但是，如果是“var x = 100;”，那么就比较容易混淆了。因为“x = 100”其实是赋值，而不是引擎层面的“初始化”。\n\n对于let来说，“声明阶段和初始化阶段是分开”其实更不严谨。确切地说，let就没有“初始化阶段”。而用户代码“let x = 100”中的“x = 100”就是赋值阶段了。“let 没有初始化阶段”，所以才会出现它在未赋值之前不能读的现象。\n\n用这样三个阶段来解释这件事情，跟ECMAScript中的逻辑并不矛盾（而且也可以正确解释），只是细节上需要严谨一点、留意一点就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575271970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1659901,"avatar":"https://static001.geekbang.org/account/avatar/00/19/53/fd/db2cac71.jpg","nickname":"红白十万一只","note":"","ucode":"7170636C924D93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185426,"discussion_content":"我也看过这篇文章。不过let的“声明阶段和初始化阶段是分开”这点不同的阅览器内核处理是不同的，谷歌内核就是显示&#39;a&#39; before initialization初始化前，而IE的内核则是a is not defined。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582627680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151257,"user_name":"Marvin","can_delete":false,"product_type":"c1","uid":1096381,"ip_address":"","ucode":"443BD8B20285A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/bd/6f2f078c.jpg","comment_is_top":false,"comment_ctime":1573692033,"is_pvip":false,"replies":[{"id":"58213","content":"是的。简洁，正确。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573698573,"ip_address":"","comment_id":151257,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23048528513","product_id":100039701,"comment_content":"相当于<br>var&#47;let&#47;const x = (y =100)<br>再拆就是<br>y=100 &#47;&#47; 变量泄漏<br>var x=y &#47;&#47; 模拟表达式返回值赋值<br>","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474417,"discussion_content":"是的。简洁，正确。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573698573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151148,"user_name":"ssala","can_delete":false,"product_type":"c1","uid":1005356,"ip_address":"","ucode":"CCD82C81756FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","comment_is_top":false,"comment_ctime":1573658160,"is_pvip":false,"replies":[{"id":"58211","content":"一是因为向下兼容，这是规范订制过程中面临的主要挑战之一。第二个原因，在于按照JavaScript的核心设计，在原理上这就很难绕过去。例如就包括不受兼容性影响的import，其实也是有变量提升效果的。例如下面这样的代码也是成立的：<br><br>```<br>console.log(x);<br>import x from &#39;.&#47;test.js&#39;;<br>```","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573698539,"ip_address":"","comment_id":151148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23048494640","product_id":100039701,"comment_content":"老师，像变量提升这种不符合直觉的设计，难道规范不能将其移除吗？不移除是为了兼容老代码吗？我想应该没有代码会依赖这个特性吧？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474380,"discussion_content":"一是因为向下兼容，这是规范订制过程中面临的主要挑战之一。第二个原因，在于按照JavaScript的核心设计，在原理上这就很难绕过去。例如就包括不受兼容性影响的import，其实也是有变量提升效果的。例如下面这样的代码也是成立的：\n\n```\nconsole.log(x);\nimport x from &amp;#39;./test.js&amp;#39;;\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573698539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151065,"user_name":"Geek__kkkkkkkk","can_delete":false,"product_type":"c1","uid":1458421,"ip_address":"","ucode":"A6C8683A4C3628","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqW6sdNZ1OF8n5Wsfr7Vr8sBY4vOD8iaj31icqPgyk8NdALibhzKXwdIDmoMJfJznWf8b0NGjcGWKRNg/132","comment_is_top":false,"comment_ctime":1573650001,"is_pvip":false,"replies":[{"id":"58155","content":"&gt; 这种情况下使用var声明的变量名尽管也会添加到varNames列表，但它也可以从varNames中移除（这是唯一一种能从varNames中移除项的特例...<br><br>文章中是解释过的。可能我没有足够地强调这个特例，或者它的特殊性吧。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573652379,"ip_address":"","comment_id":151065,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23048486481","product_id":100039701,"comment_content":"老师，您文章中讲到“ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在 eval() 中使用var声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是“直接声明的变量”，不能使用delete删除。”，这里面的意思我理解了 eval() 中使用var声明的变量名，不可用delete删除，但是下面的代码中eval()声明了b,configurable是true,可删除，是否矛盾了？还是我理解的不够全面？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474352,"discussion_content":"&amp;gt; 这种情况下使用var声明的变量名尽管也会添加到varNames列表，但它也可以从varNames中移除（这是唯一一种能从varNames中移除项的特例...\n\n文章中是解释过的。可能我没有足够地强调这个特例，或者它的特殊性吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573652379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346502,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTYpERVj4wtwAwqz4SUiaoQXDIyhYaKjABMvkJbVXaI3kcJterXovCTqZZSQ1TnueIWX7VGvC3koA/132","nickname":"麦田里的守望者","note":"","ucode":"E2D35F3A628C06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68272,"discussion_content":"为了兼容旧的 JavaScript 语言设计，现在的 JavaScript 环境仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。但是为了得到一个“尽可能”与其它变量环境相似的声明效果（varDecls），ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在 eval() 中使用var声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是“直接声明的变量”，不能使用delete删除。\n我也感觉这段话里面是不是自相矛盾呀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575207724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188815,"user_name":"墨灵","can_delete":false,"product_type":"c1","uid":1409700,"ip_address":"","ucode":"185D70CA20BEEE","user_header":"https://static001.geekbang.org/account/avatar/00/15/82/a4/a92c6eca.jpg","comment_is_top":false,"comment_ctime":1584420682,"is_pvip":false,"replies":[{"id":"72861","content":"我很长的时间里也一直是以这种方法来理解的，效果上也确实类似。但在语言层面，底层的设计与实现确非如此。^^。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1584425527,"ip_address":"","comment_id":188815,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18764289866","product_id":100039701,"comment_content":"以前我把<br>```<br>console.log(x);<br>var x = 100;<br>```<br>理解成<br>```<br>var x;<br>console.log(x);<br>x = 100;<br>```<br>看来以前的理解是有误的，是更为底层的东西在起作用。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487536,"discussion_content":"我很长的时间里也一直是以这种方法来理解的，效果上也确实类似。但在语言层面，底层的设计与实现确非如此。^^。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584425527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154447,"user_name":"授人以摸鱼","can_delete":false,"product_type":"c1","uid":1390561,"ip_address":"","ucode":"69417D324C1473","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/e1/0953c506.jpg","comment_is_top":false,"comment_ctime":1574432467,"is_pvip":false,"replies":[{"id":"59538","content":"你是对的。在JavaScript中，“全局环境”里面的var与let&#47;const是用了两个东西来管理的，所以他们也确实是创建在不同的地方。<br>但是从“作用域链”的角度上来说，它们并没有级别高低（也就是parent没有相互指向）。使得它们存取的效果有差别的，是因为“全局环境”采用了词法环境优先（也就是let&#47;const声明）的顺序。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574661157,"ip_address":"","comment_id":154447,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18754301651","product_id":100039701,"comment_content":"发现我好像对全局作用域的理解有一些偏差：<br>var，或者没有声明直接赋值，这样的创建标识符（引用）是作为global对象的字段存在的，可以用Object.getOwnPropertyDescriptor从global上读到。<br>全局作用域里用let，const创建的变量，虽然也是全局可见，但它并没有创建在global上，而是创建在了另一个地方。从作用域链的视角来看的话，这个作用域要比global低一级这样子。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475472,"discussion_content":"你是对的。在JavaScript中，“全局环境”里面的var与let/const是用了两个东西来管理的，所以他们也确实是创建在不同的地方。\n但是从“作用域链”的角度上来说，它们并没有级别高低（也就是parent没有相互指向）。使得它们存取的效果有差别的，是因为“全局环境”采用了词法环境优先（也就是let/const声明）的顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574661157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1930698,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/75/ca/4c127da3.jpg","nickname":"Emma","note":"","ucode":"C2D31142AF7288","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219565,"discussion_content":"老师是不是执行上下文中包含了变量环境和词法环境，然后变量的查找过程是先从词法环境中找，找不到再从变量环境中找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585782741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150957,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573634649,"is_pvip":false,"replies":[{"id":"58156","content":"是在加载.js文件之后，执行第一行用户代码之前，就已经完成了全部的词法分析（当然，除了eval执行的）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573652443,"ip_address":"","comment_id":150957,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18753503833","product_id":100039701,"comment_content":"老师文中说变量声明分为两步，静态分析和动态绑定，JS 是在进入每个作用域后，执行前进行词法分析的么？","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474325,"discussion_content":"是在加载.js文件之后，执行第一行用户代码之前，就已经完成了全部的词法分析（当然，除了eval执行的）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573652443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230974,"user_name":"埋坑专家","can_delete":false,"product_type":"c1","uid":2050789,"ip_address":"","ucode":"B05D97CE4504A6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3fB603VY46iaYS2h2MibvV4H5iamibPMr6AT4Fiac5snKOiaMI180pb2DVCe5Bd2sNSJibZSwQg8Qo1PD7bVw1uVBx7YA/132","comment_is_top":false,"comment_ctime":1593536632,"is_pvip":false,"replies":[{"id":"85353","content":"确实，“varNames不限制删除”。<br><br>varNames表明其中的变量名一定是用`var`来声明的。但“是否能被删除”这一性质，还是由其它机制来确定和保证的。——例如在全局环境中，使用global属性的configurable性质。<br><br>与此对比的，在函数中——如果函数中也使用`var x`声明，或者使用eval(&#39;var x&#39;)声明——的话，那么函数的环境中并没有[[varNames]]这个列表，而它也同样要实现“是否能被删除”这一限制。我这里的意思是说明，varNames不是“删除&#47;不删除”的依赖条件。<br><br>补充说明一下，在函数环境中实现这个`delete x`能否删除的语言特性时，是使用的CreateMutableBinding()的传入的第二个参数（isDeletable），亦即是当使用eval(`var x`)时，创建的绑定是可删除的，而使用静态声明`var x`时，该绑定不可删除。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1593596306,"ip_address":"","comment_id":230974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14478438520","product_id":100039701,"comment_content":"想请问一下老师：<br><br>var 声明的变量，configurable为false，这个值是因为varNames不给删除，所以才这样设置的吗？<br><br>但我从老师回答其他同学的答案里，得知varNames不限制删除，只是var 声明的变量，configurable为false，导致出现varNames里的变量不给删除这种现象。<br><br>那么这两者是否有因果关系呢？<br><br>谁是因，谁是果？<br><br>或者是否有第三方的原因导致其一是这样，从而影响到另一方了呢？<br><br>谢谢老师！","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500098,"discussion_content":"确实，“varNames不限制删除”。\n\nvarNames表明其中的变量名一定是用`var`来声明的。但“是否能被删除”这一性质，还是由其它机制来确定和保证的。——例如在全局环境中，使用global属性的configurable性质。\n\n与此对比的，在函数中——如果函数中也使用`var x`声明，或者使用eval(&amp;#39;var x&amp;#39;)声明——的话，那么函数的环境中并没有[[varNames]]这个列表，而它也同样要实现“是否能被删除”这一限制。我这里的意思是说明，varNames不是“删除/不删除”的依赖条件。\n\n补充说明一下，在函数环境中实现这个`delete x`能否删除的语言特性时，是使用的CreateMutableBinding()的传入的第二个参数（isDeletable），亦即是当使用eval(`var x`)时，创建的绑定是可删除的，而使用静态声明`var x`时，该绑定不可删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593596306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216217,"user_name":"阳少宇","can_delete":false,"product_type":"c1","uid":1308648,"ip_address":"","ucode":"977CA6F42C7DB6","user_header":"","comment_is_top":false,"comment_ctime":1589206396,"is_pvip":false,"replies":[{"id":"80070","content":"声明语句<br>&gt; let a;<br>也会在运行期处理，与<br>&gt; let a = undefined;<br>是一样的。<br><br>准确地说，所有的声明语句其实都会在执行期处理一次。只不过多数都会什么也不发生，只是直接返回empty（例如具名函数的声明）。<br><br>对于`let x;`来说，它的执行期语义如下：<br><br><br>&#47;&#47; https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-let-and-const-declarations-runtime-semantics-evaluation<br>```<br>LexicalBinding: BindingIdentifier<br>  * Let lhs be ResolveBinding(StringValue of BindingIdentifier).<br>  * Return InitializeReferencedBinding(lhs, undefined).<br>```<br><br>对照的，你看一下函数声明的：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-function-definitions-runtime-semantics-evaluation","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1589250835,"ip_address":"","comment_id":216217,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14474108284","product_id":100039701,"comment_content":"老师你好,对于let声明一个变量说是有个编译期且不会初始化.<br>那么 let a; console.log(a) 得到的结果是undefined, 那这个undefined是从哪里来的呢?","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494720,"discussion_content":"声明语句\n&amp;gt; let a;\n也会在运行期处理，与\n&amp;gt; let a = undefined;\n是一样的。\n\n准确地说，所有的声明语句其实都会在执行期处理一次。只不过多数都会什么也不发生，只是直接返回empty（例如具名函数的声明）。\n\n对于`let x;`来说，它的执行期语义如下：\n\n\n// https://tc39.es/ecma262/#sec-let-and-const-declarations-runtime-semantics-evaluation\n```\nLexicalBinding: BindingIdentifier\n  * Let lhs be ResolveBinding(StringValue of BindingIdentifier).\n  * Return InitializeReferencedBinding(lhs, undefined).\n```\n\n对照的，你看一下函数声明的：\nhttps://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589250835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308648,"avatar":"","nickname":"阳少宇","note":"","ucode":"977CA6F42C7DB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263983,"discussion_content":"好的，谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589275774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157595,"user_name":"麦田里的守望者","can_delete":false,"product_type":"c1","uid":1346502,"ip_address":"","ucode":"E2D35F3A628C06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTYpERVj4wtwAwqz4SUiaoQXDIyhYaKjABMvkJbVXaI3kcJterXovCTqZZSQ1TnueIWX7VGvC3koA/132","comment_is_top":false,"comment_ctime":1575208036,"is_pvip":false,"replies":[{"id":"60484","content":"这里没错的。不过因果是说反了，varNames并不“决定”列表中的变量不能用delete删除。但是由于delete global.x无效时，总是不会删除varNames中的项，所以表现起来，也是它里面的项不能删除。<br><br>其实严格来说，并没有其它地方的逻辑需要特别地使用到varNames，它非常没存在感。只是从引擎的角度上来说，如果没有varNames，它也不能在运行期识别哪个全局变量是从var声明来的，而哪个又是直接在global上创建的属性。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575272309,"ip_address":"","comment_id":157595,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14460109924","product_id":100039701,"comment_content":"为了兼容旧的 JavaScript 语言设计，现在的 JavaScript 环境仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。但是为了得到一个“尽可能”与其它变量环境相似的声明效果（varDecls），ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在 eval() 中使用var声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是“直接声明的变量”，不能使用delete删除。<br>这段话的最后几句，是不是写错了","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476479,"discussion_content":"这里没错的。不过因果是说反了，varNames并不“决定”列表中的变量不能用delete删除。但是由于delete global.x无效时，总是不会删除varNames中的项，所以表现起来，也是它里面的项不能删除。\n\n其实严格来说，并没有其它地方的逻辑需要特别地使用到varNames，它非常没存在感。只是从引擎的角度上来说，如果没有varNames，它也不能在运行期识别哪个全局变量是从var声明来的，而哪个又是直接在global上创建的属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575272309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151499,"user_name":"九酒大人","can_delete":false,"product_type":"c1","uid":1515811,"ip_address":"","ucode":"EB5A4EDC8496E3","user_header":"https://static001.geekbang.org/account/avatar/00/17/21/23/5b81eaf7.jpg","comment_is_top":false,"comment_ctime":1573731655,"is_pvip":false,"replies":[{"id":"58269","content":"因为它在global中声明的属性的configurable为true。<br><br>varNames其实并不限制删除，但global.x删除后会同步删除掉varNames。所以如果configurable为false那么就删不掉属性，于是也就删除不掉varNames中的名字（对于使用var声明来说）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573744555,"ip_address":"","comment_id":151499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14458633543","product_id":100039701,"comment_content":"为什么eval里var的变量可以删除？还是没明白","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474504,"discussion_content":"因为它在global中声明的属性的configurable为true。\n\nvarNames其实并不限制删除，但global.x删除后会同步删除掉varNames。所以如果configurable为false那么就删不掉属性，于是也就删除不掉varNames中的名字（对于使用var声明来说）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573744555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150812,"user_name":"Makus","can_delete":false,"product_type":"c1","uid":1240576,"ip_address":"","ucode":"F51C61D62BDB2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/00/3cca3642.jpg","comment_is_top":false,"comment_ctime":1573612972,"is_pvip":false,"replies":[{"id":"57994","content":"不着急。会慢慢讲到的。^^.<br><br>还有，我所讲的有些会与MDN有出入，这个你可以先存疑。不必急着得到“YES&#47;NO”这样的答案，慢慢地听到后面就会知道我为什么这么讲了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573615324,"ip_address":"","comment_id":150812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14458514860","product_id":100039701,"comment_content":"附「语句和声明」的链接：https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Web&#47;JavaScript&#47;Reference&#47;Statements<br>严格意义上来说，除了本篇中出现的六种和链接中的五大类都不能算作语句吧。<br>例如 ：标题中的 y = 100<br>麻烦老师指正一下，不太懂","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474276,"discussion_content":"不着急。会慢慢讲到的。^^.\n\n还有，我所讲的有些会与MDN有出入，这个你可以先存疑。不必急着得到“YES/NO”这样的答案，慢慢地听到后面就会知道我为什么这么讲了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573615324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280351,"user_name":"如故","can_delete":false,"product_type":"c1","uid":1042089,"ip_address":"","ucode":"F6895792309942","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e6/a9/b459efb7.jpg","comment_is_top":false,"comment_ctime":1614165573,"is_pvip":false,"replies":[{"id":"101913","content":"在函数中，由于要同时支持var和let&#47;const，所以就需要两组名字列表，称为varNames和lexNames，与之对应的也有两组声明用的结构，称为varDecls和lexDecls。其中names用于在运行期简单检索，而decls用于在初始化阶段创建这个名字（var&#47;let&#47;const变量名）。<br><br>上述是简单但完整的、在函数中的名字创建和管理策略。但是你知道，在全局中用var声明的变量名是登记在全局对象（global）上面的，所以事实上只需要简单地检索这个全局对象，就可以找到名字，而并不“总是”强制地需要这个varName来检索，对吧？<br><br>然而为了一致性（亦即是“尽可能”与其它变量环境相似），所以全局环境也创建了一个varNames列表，并且在发现一个var声明时就添加到这个列表中。——当然，如上所述它也会同时添加为全局对象global的属性。所以……我在上面的讲述中，主要是强调对于“全局环境”来说，varNames的存在主要是为了一致性，亦即是让全局环境表现得跟函数环境“尽可能”相似。<br><br>另外，事实上还有一个原因，就是varNames中的名字存在“能否删除”的问题，而这一性质，与全局属性中用属性描述符表达的性质（Configurable）并不完全等同，所以从这个角度上来说，varNames也有在全局中存在的必要性。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1614349975,"ip_address":"","comment_id":280351,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10204100165","product_id":100039701,"comment_content":"老师您好<br>var a = 1;<br>b = 2;<br>a和b都是全局对象上的一个属性，但a存在于一个varNames列表中，并且是不可配置的。<br>那么为啥要设置这样一个varNames列表呢？文中说：是为了得到一个“尽可能”与其它变量环境相似的声明效果（varDecls）。这句话不太理解","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516064,"discussion_content":"在函数中，由于要同时支持var和let/const，所以就需要两组名字列表，称为varNames和lexNames，与之对应的也有两组声明用的结构，称为varDecls和lexDecls。其中names用于在运行期简单检索，而decls用于在初始化阶段创建这个名字（var/let/const变量名）。\n\n上述是简单但完整的、在函数中的名字创建和管理策略。但是你知道，在全局中用var声明的变量名是登记在全局对象（global）上面的，所以事实上只需要简单地检索这个全局对象，就可以找到名字，而并不“总是”强制地需要这个varName来检索，对吧？\n\n然而为了一致性（亦即是“尽可能”与其它变量环境相似），所以全局环境也创建了一个varNames列表，并且在发现一个var声明时就添加到这个列表中。——当然，如上所述它也会同时添加为全局对象global的属性。所以……我在上面的讲述中，主要是强调对于“全局环境”来说，varNames的存在主要是为了一致性，亦即是让全局环境表现得跟函数环境“尽可能”相似。\n\n另外，事实上还有一个原因，就是varNames中的名字存在“能否删除”的问题，而这一性质，与全局属性中用属性描述符表达的性质（Configurable）并不完全等同，所以从这个角度上来说，varNames也有在全局中存在的必要性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614349975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259695,"user_name":"油菜","can_delete":false,"product_type":"c1","uid":2263588,"ip_address":"","ucode":"DB3334BC1720F1","user_header":"","comment_is_top":false,"comment_ctime":1604813447,"is_pvip":false,"replies":[{"id":"94398","content":"这里没有什么特别的解释。ES6之前所谓的对象方法，就是obj.f()，其中f只要是函数就行——亦即是说“ES6之前的方法，就是对象的函数类型的属性”。ES6才真正约定了：方法是由类或对象声明中的一种特定语法来声明的，即：<br><br>```<br>obj = {<br>  foo() {<br>    &#47;&#47; 这种声明才是方法<br>  }<br>}<br>````<br><br>所以你会发现，在ES6之后，你没有办法“动态创建”出上述风格的一个“方法”来。关于这个部分，在后面的章节中还会讲到。<br><br>考虑到一些“传统习惯”，在“函数&#47;方法”中的this处理会变得非常难以解释。我建议你暂时不要深究这个问题，简单地理解为：如果是“对象方法调用，即obj.f()”，那么this就是obj。——这样就可以了，其它的情况理解为“特例（例如直接f()调用中的this是全局）”，以及“绑定（例如f.bind(...)）”，即可。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1604853464,"ip_address":"","comment_id":259695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10194748039","product_id":100039701,"comment_content":"老师，函数和方法有什么区别呢？我的理解，单独看一个function t1(){}这个结构，它是函数；obj.t1，是方法，obj.t1()，是执行方法。<br>例如，我创建一个function t1(){console.log(&quot;123&quot;)}；<br>t1() 等价于this.t1()的执行结果，123；<br>this.t1, 运行结果是 [Function: t1]<br>--------<br>“a将是一个函数，而不是带着“this 对象”信息的方法”，测试后发现，a是带this对象的函数，<br>obj = { f: function() { return this} };<br>console.log(obj===obj.f());  &#47;&#47; true<br>console.log(this===(a = obj.f)()); &#47;&#47; true<br>其中 a =obj.f ，a是函数，this是全局对象， a()返回的是全局对象。<br>----<br>&#47;&#47; 调用obj.f()时将检测this是不是原始的<br>obj&gt; obj = { f: function() { return this === obj } };<br>&#47;&#47; false，表明赋值表达式的“结果(result)”只是右侧操作数的值，即函数<br>f&gt; (a = obj.f)();false<br><br>我的理解，丢失的不是obj的值，而是this变了，之前是obj,现在是全局对象。<br>","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509006,"discussion_content":"这里没有什么特别的解释。ES6之前所谓的对象方法，就是obj.f()，其中f只要是函数就行——亦即是说“ES6之前的方法，就是对象的函数类型的属性”。ES6才真正约定了：方法是由类或对象声明中的一种特定语法来声明的，即：\n\n```\nobj = {\n  foo() {\n    // 这种声明才是方法\n  }\n}\n````\n\n所以你会发现，在ES6之后，你没有办法“动态创建”出上述风格的一个“方法”来。关于这个部分，在后面的章节中还会讲到。\n\n考虑到一些“传统习惯”，在“函数/方法”中的this处理会变得非常难以解释。我建议你暂时不要深究这个问题，简单地理解为：如果是“对象方法调用，即obj.f()”，那么this就是obj。——这样就可以了，其它的情况理解为“特例（例如直接f()调用中的this是全局）”，以及“绑定（例如f.bind(...)）”，即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604853464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251313,"user_name":"G","can_delete":false,"product_type":"c1","uid":2189373,"ip_address":"","ucode":"C267833DBBE254","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/3lp20weUpmEjiaLAS6umkKRGB7WicIPGWQ7sjRsxbw0EAiapnslID17FfmrMFppSDw7vn0A8bu1icBBmPXGGweGhjQ/132","comment_is_top":false,"comment_ctime":1601458615,"is_pvip":false,"replies":[{"id":"92065","content":"我觉得你的理解是对的，只是叙述的方式不太“准确”。<br><br>1. 静态语法分析阶段，只能够识别到 类似 a  这样的标识符，所以给我们一种标识符被提前声明的感觉。——这里说“感觉”应该是从使用js的角度来说的，在这门语言上（也就是ECMAScript的定义上）来说，它实际上就是“在词法环境中添加了这个标识符”。而词法环境，就是可以通过静态词法分析来得到的环境，也就是语法分析阶段可以确定的环境。<br><br>2. 而这些被标识符能不能够被 提前 访问，取决于它的声明方式。——同样的，这也没什么不对，但仍然只是在“使用js”的层面的叙述。在ECMAScript层面对这个的解释是明确的：let&#47;const声明是在词法声明的标识符上不绑定值的，而var是在词法声明上绑定了初值（undefined）的。所以，“能不能‘提前’访问”，本质上就是“不能访问无初值的标识符”。——但是“绑定”值这个概念是在ECMAScript中才说的，在JS中我们通常只说“赋值”，这就是用“赋值”这个概念讲不清上述语法语义的根源。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1601915523,"ip_address":"","comment_id":251313,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10191393207","product_id":100039701,"comment_content":"老师您好，感谢您之前对我的英文的回答，视频中的内容也非常有利于我对前五节内容的理解。<br><br>对于这片文章，我有个疑问<br><br>js中的所谓的 ‘变量提升’，实际上并不是把如下代码<br>`<br>var a = 100<br>`<br>变成<br>`<br>var a<br>a = 100<br>`<br>而是在静态语法分析阶段，只能够识别到 类似 a  这样的标识符，所以给我们一种标识符被提前声明的感觉，造成了类似如上代码的 ‘变量提升’ 效果<br><br>而这些被标识符能不能够被 提前 访问，取决于它的声明方式<br><br>以上就是我的疑问，如果有不正确的地方，还请老师指出","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506447,"discussion_content":"我觉得你的理解是对的，只是叙述的方式不太“准确”。\n\n1. 静态语法分析阶段，只能够识别到 类似 a  这样的标识符，所以给我们一种标识符被提前声明的感觉。——这里说“感觉”应该是从使用js的角度来说的，在这门语言上（也就是ECMAScript的定义上）来说，它实际上就是“在词法环境中添加了这个标识符”。而词法环境，就是可以通过静态词法分析来得到的环境，也就是语法分析阶段可以确定的环境。\n\n2. 而这些被标识符能不能够被 提前 访问，取决于它的声明方式。——同样的，这也没什么不对，但仍然只是在“使用js”的层面的叙述。在ECMAScript层面对这个的解释是明确的：let/const声明是在词法声明的标识符上不绑定值的，而var是在词法声明上绑定了初值（undefined）的。所以，“能不能‘提前’访问”，本质上就是“不能访问无初值的标识符”。——但是“绑定”值这个概念是在ECMAScript中才说的，在JS中我们通常只说“赋值”，这就是用“赋值”这个概念讲不清上述语法语义的根源。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601915523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246315,"user_name":"旗鼓相当的对手","can_delete":false,"product_type":"c1","uid":2007774,"ip_address":"","ucode":"D80BE6E12FF2CE","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a2/de/84f2754d.jpg","comment_is_top":false,"comment_ctime":1599275011,"is_pvip":false,"replies":[{"id":"90600","content":"嗯……<br><br>作为示例，它少了最后一行代码，也就是在最后一行应该是一句<br><br>`f();`<br><br>这样这应该就是你想表达的意思。:)","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1599404120,"ip_address":"","comment_id":246315,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10189209603","product_id":100039701,"comment_content":"<br>var y = &quot;outer&quot;;<br>function f() {<br>  console.log(y); &#47;&#47; undefined<br>  console.log(x); &#47;&#47; throw a Exception<br>  let x = 100;<br>  var y = 100;<br>  ...<br>}<br>&#47;&#47; 老师这里的函数是不是应该是立即执行的函数表达式啊，不然无法形成闭包啊。<br>&#47;&#47; 刚刚按错了，没打完就发布了TAT","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505110,"discussion_content":"嗯……\n\n作为示例，它少了最后一行代码，也就是在最后一行应该是一句\n\n`f();`\n\n这样这应该就是你想表达的意思。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599404120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2007774,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a2/de/84f2754d.jpg","nickname":"旗鼓相当的对手","note":"","ucode":"D80BE6E12FF2CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315227,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603253642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234306,"user_name":"穷精致","can_delete":false,"product_type":"c1","uid":2040934,"ip_address":"","ucode":"F5994A9F8431D7","user_header":"https://static001.geekbang.org/account/avatar/00/1f/24/66/95ef781c.jpg","comment_is_top":false,"comment_ctime":1594637484,"is_pvip":true,"replies":[{"id":"86611","content":"从概念上说，`var a ...`是静态变量声明，因为是静态声明性的，所以不能删除。而`b = ...`是因为“向未声明变量赋值”导致的变量名泄漏，是运行过程中动态创建的，所以可以删除。<br><br>从实现上来说，`var a ...`会在varNames中登记，并且它的global.a属性描述符是不可删除的；而`b = ...`不在varNames中登记，且global.b属性描述符可删除。<br><br>所以你就看到了上面的结果。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1594781591,"ip_address":"","comment_id":234306,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10184572076","product_id":100039701,"comment_content":"(1) var a = 1; delete a &#47;&#47; false;<br>(2) b = 1; delete b &#47;&#47; true;<br>a 和 b变量都是全局变量，可通过window点方法访问，但是delete的结果是不同的；<br>对这个不怎么理解，老师或者哪位同学可以解惑一下吗？？？！！！","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501343,"discussion_content":"从概念上说，`var a ...`是静态变量声明，因为是静态声明性的，所以不能删除。而`b = ...`是因为“向未声明变量赋值”导致的变量名泄漏，是运行过程中动态创建的，所以可以删除。\n\n从实现上来说，`var a ...`会在varNames中登记，并且它的global.a属性描述符是不可删除的；而`b = ...`不在varNames中登记，且global.b属性描述符可删除。\n\n所以你就看到了上面的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594781591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183730,"user_name":"小毛","can_delete":false,"product_type":"c1","uid":1350319,"ip_address":"","ucode":"938EC487011357","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/af/ac09799f.jpg","comment_is_top":false,"comment_ctime":1583121060,"is_pvip":false,"replies":[{"id":"71203","content":"是的。当某个“东西(t)”作为右手端（被）赋值给左侧(x)时，实际发生的动作是：x = GetValue(t)<br><br>因为“引用（规范类型）”被GetValue时得到的也是它所包含的值，所以无论t是一个字面量值，还是一个有名字的变量（引用），那么x都将得到它的值。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1583163133,"ip_address":"","comment_id":183730,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10173055652","product_id":100039701,"comment_content":"而一个赋值表达式操作的本身也是有“结果（Result）”的，它是右操作数的值。注意，这里是“值”而非“引用”，例如下面的测试中的a将是一个函数，而不是带着“this 对象”信息的方法<br>这里值和引用有些摸不清，可不可以这样理解，赋值表达式操作的本身结果是右侧操作数的值或者“引用的值”<br>let x = y = &#39;100&#39;;<br>console.log(x);<br>&#47;&#47;100<br>y = &#39;200&#39;;<br>console.log(x);<br>&#47;&#47;100<br>console.log(y);<br>&#47;&#47;200<br><br>这段代买说明右侧的y=&#39;100&#39;，返回的是&#39;100&#39;这个字符串的引用值，赋值给了x，后面y的引用变化了，并没有改变x的值","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485763,"discussion_content":"是的。当某个“东西(t)”作为右手端（被）赋值给左侧(x)时，实际发生的动作是：x = GetValue(t)\n\n因为“引用（规范类型）”被GetValue时得到的也是它所包含的值，所以无论t是一个字面量值，还是一个有名字的变量（引用），那么x都将得到它的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583163133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390172,"discussion_content":"老师的解释突然让我联想到一个现象：\n当一个变量 x 指向一个对象，同时将该变量再赋予另一个变量y，那么当改变了变量 x 的指向时，变量 y 的指向并不会和它一起改变。\nx = {a : 1};\ny = x; //GetValue(x) 实际为对象的地址值，可以理解为是一个数值类型\nx = {a : 2};\nconsole.log(y) // {a : 1}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629701810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183534,"user_name":"从未止步","can_delete":false,"product_type":"c1","uid":1792361,"ip_address":"","ucode":"17F310796CE8D5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5jr1KfpLoXdoiaLzLswPiazCgCnyPkKhIqrEujPtGA1kryZYaruF8GmUTRRWn1YK71QVSTSVpwkzQ/132","comment_is_top":false,"comment_ctime":1583060535,"is_pvip":false,"replies":[{"id":"71204","content":"是的。<br><br>所以我常常会说“一个语法具有‘声明语义’，或者‘执行语义’……”等等，根源就在这里。因为声明并不是执行阶段处理的，它是语法解析器的处理，并在执行前由环境来处理成执行所依赖的组件，因此它只有声明语义，没有执行的结果（没有意义）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1583163264,"ip_address":"","comment_id":183534,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10172995127","product_id":100039701,"comment_content":"声明并不是严格意义上的语句，因为在代码执行语句之前，这些变量就进行了词法分析，也就是意义上的声明，创建这个变量，使后边语句在使用时，过程不受任何影响","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485707,"discussion_content":"是的。\n\n所以我常常会说“一个语法具有‘声明语义’，或者‘执行语义’……”等等，根源就在这里。因为声明并不是执行阶段处理的，它是语法解析器的处理，并在执行前由环境来处理成执行所依赖的组件，因此它只有声明语义，没有执行的结果（没有意义）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583163264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164525,"user_name":"Jing","can_delete":false,"product_type":"c1","uid":1742214,"ip_address":"","ucode":"D550C1BE1FF95F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/95/86/dc7b7fb4.jpg","comment_is_top":false,"comment_ctime":1577020946,"is_pvip":false,"replies":[{"id":"62772","content":"会冲突呀。<br><br>所以才会让import可以as一个新名字嘛。另外，import名字和当前模块的var名字其实是共用一个名字表，所以import x ...之后，如果用var x...其实是会报异常的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577090876,"ip_address":"","comment_id":164525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10166955538","product_id":100039701,"comment_content":"感谢老师的讲述，每次看都会有新的收获。JavaScript要扫描所谓的“顶层”，来查找那些变量声明和词法声明之间的冲突关系，既然如此这些varDecls中的变量是否会与当前import的地方发生冲突?如果不会冲突是否意味着varNames只是针对于每一个模块？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478801,"discussion_content":"会冲突呀。\n\n所以才会让import可以as一个新名字嘛。另外，import名字和当前模块的var名字其实是共用一个名字表，所以import x ...之后，如果用var x...其实是会报异常的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577090876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156100,"user_name":"因为有你心存感激","can_delete":false,"product_type":"c1","uid":1090373,"ip_address":"","ucode":"18B83F8C346453","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/45/8e9c6a69.jpg","comment_is_top":false,"comment_ctime":1574819259,"is_pvip":false,"replies":[{"id":"60099","content":"1. y是属性（也就是一个属性引用）。y是泄露到全局的变量，他事实上变成了global.y。<br>2. js能“变量名=值”这样赋值，这称为赋值表达式，但“var 变量名=值”是一个声明语句，其中的“=值”称为初始器，他只是跟赋值表达式“形似”而已，在语法和语义上都不是同一个东西。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574908449,"ip_address":"","comment_id":156100,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164753851","product_id":100039701,"comment_content":"var x = y =100  中的y 是可以通过delete y 删除，老师又说 delete 只删除引用不删除值，在这里y是引用吗？还有对于 js 为什不能  变量名 = 值  这样赋值呢？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475986,"discussion_content":"1. y是属性（也就是一个属性引用）。y是泄露到全局的变量，他事实上变成了global.y。\n2. js能“变量名=值”这样赋值，这称为赋值表达式，但“var 变量名=值”是一个声明语句，其中的“=值”称为初始器，他只是跟赋值表达式“形似”而已，在语法和语义上都不是同一个东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574908449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151702,"user_name":"blulu","can_delete":false,"product_type":"c1","uid":1071136,"ip_address":"","ucode":"B3BFFCCD4C30A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/58/20/13f72252.jpg","comment_is_top":false,"comment_ctime":1573780347,"is_pvip":false,"replies":[{"id":"58326","content":"有主题的哦~ ^^.<br><br>目录中对这一个段落的定义是“JavaScript语言是如何构建起来的”。基本上是讲静态语言语义，以及它在引擎级别上的实现。5个小节，从值、引用等基础，到模块和语句，基本上覆盖构成语言的核心组件。<br><br>可不是在乱讲哦。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573783751,"ip_address":"","comment_id":151702,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10163714939","product_id":100039701,"comment_content":"这一节不知主题是什么?这样讲会造成知识点东一快西一快没有发挥系统学习的效果，更像很多很散的集合","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474578,"discussion_content":"有主题的哦~ ^^.\n\n目录中对这一个段落的定义是“JavaScript语言是如何构建起来的”。基本上是讲静态语言语义，以及它在引擎级别上的实现。5个小节，从值、引用等基础，到模块和语句，基本上覆盖构成语言的核心组件。\n\n可不是在乱讲哦。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573783751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361002,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c4/6a/e45bbb6b.jpg","nickname":"Smile","note":"","ucode":"674C2361FFB807","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560999,"discussion_content":"试试多看几遍 或许会改变看法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649509885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541708,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/hkBfzo6cRvbBmFZKPxlzRnKyria9gzID4WQ9mI1NdBBox5lRox7eMuhicXPB7eU1ecOa0lD9fhNTG3H6yJlII50A/132","nickname":"前端男孩","note":"","ucode":"58668020D2D5BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52747,"discussion_content":"”在今天的课程里，你只需要留意这个变量的读写过程就好了。“，这是原文中的一句","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574082739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296551,"user_name":"KaKaKa","can_delete":false,"product_type":"c1","uid":1480732,"ip_address":"","ucode":"07D1980A71F321","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","comment_is_top":false,"comment_ctime":1623038983,"is_pvip":false,"replies":[{"id":"107670","content":"是的，可以这样理解。只是在ECMAScript里面，`let a`在执行期所导致的操作叫“绑定初值”，而真实的`a = undefined`叫“赋值”。前者使用的内部API叫 InitializeReferencedBinding()，后者使用的叫PutValue()，二者实际的操作都是向`a`变量置值。所以在JavaScript中使用效果是一样的，只是在ECMAScript中概念不同。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1623049034,"ip_address":"","comment_id":296551,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5918006279","product_id":100039701,"comment_content":"请问下，老师在下面一个回复中说到：<br>`let a;` 是作为`let a = undefined;`处理的。<br>声明语句确实是在语法分析期和环境初始化阶段处理的，但当代码“执行到”相应位置时，会执行它在“运行期语义”——也就是“绑定值”。<br>而如上说它是作为“let a = undefined”来处理的，因此这一行代码不是“没有赋值操作”，而是“执行了初值绑定操作”。<br>------------------<br>这个意思我能不能理解成：let a 在静态分析时声明 a 这个变量，接着在真正执行代码的时候，遇到 let a 这一行，就当成 a = undefined （执行期语义）来执行？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521483,"discussion_content":"是的，可以这样理解。只是在ECMAScript里面，`let a`在执行期所导致的操作叫“绑定初值”，而真实的`a = undefined`叫“赋值”。前者使用的内部API叫 InitializeReferencedBinding()，后者使用的叫PutValue()，二者实际的操作都是向`a`变量置值。所以在JavaScript中使用效果是一样的，只是在ECMAScript中概念不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623049034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180332,"user_name":"Gamehu","can_delete":false,"product_type":"c1","uid":1013894,"ip_address":"","ucode":"C494BA1A00ADBA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/86/d5019bb0.jpg","comment_is_top":false,"comment_ctime":1582257949,"is_pvip":false,"replies":[{"id":"70020","content":"a() 是函数调用，不传入`this`引用；<br>obj.f()是方法调用，将传入obj作为`this`。<br><br>所以<br>(a=obj.f)<br>这个表达式计算的过程中，代码中丢掉了一个信息，也就是`obj`作为引用被丢掉了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582267605,"ip_address":"","comment_id":180332,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5877225245","product_id":100039701,"comment_content":"你好“例如下面的测试中的a将是一个函数，而不是带着“this 对象”信息的方法：”没太理解，能再解释一下吗<br><br>&#47;&#47; 调用obj.f()时将检测this是不是原始的obj<br>&gt; obj = { f: function() { return this === obj } };<br><br><br>&#47;&#47; false，表明赋值表达式的“结果(result)”只是右侧操作数的值，即函数f<br>&gt; (a = obj.f)();<br>false","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484613,"discussion_content":"a() 是函数调用，不传入`this`引用；\nobj.f()是方法调用，将传入obj作为`this`。\n\n所以\n(a=obj.f)\n这个表达式计算的过程中，代码中丢掉了一个信息，也就是`obj`作为引用被丢掉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582267605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640515,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/43/d2a8d8c8.jpg","nickname":"ayu","note":"","ucode":"8DB850105E4379","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310299,"discussion_content":"引擎隐式调用 GetValue(), 将引用信息 obj 丢掉了.  \n(a = obj.f)() 相当于 a=GetValue(obj.f), 然后分组表达式获取 a 的引用(也即函数 foo)后使用 () 调用执行函数, 得到 window === obj; // false 这就是整个调用的大体流程了.\n\n不过我们可以直接分组表达式避免丢失引用信息: (obj.f)(). 然而这有点鸡肋","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601736827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154444,"user_name":"授人以摸鱼","can_delete":false,"product_type":"c1","uid":1390561,"ip_address":"","ucode":"69417D324C1473","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/e1/0953c506.jpg","comment_is_top":false,"comment_ctime":1574431424,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869398720","product_id":100039701,"comment_content":"一个简单的实验可以证明JS这门语言是真的有编译期存在（而不能仅靠把一切当作对象操作来解释）<br>在浏览器的console中逐行执行以下代码：<br>let k = n; &#47;&#47; n之前从未定义过<br>k = 3;<br>let k = 3;<br>Object.getOwnPropertyDescriptor(window, &#39;k&#39;);","like_count":1,"discussions":[{"author":{"id":1565909,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e4/d5/579615e2.jpg","nickname":"仿生狮子","note":"","ucode":"ECB2726F7E8F2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331058,"discussion_content":"哇，一脸懵逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606757106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151600,"user_name":"尤利西斯的微笑","can_delete":false,"product_type":"c1","uid":1015535,"ip_address":"","ucode":"7413231B6B78A7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7tEdeN11bEZsc4XWXpT2Xbp8pecwfdiceovTetW7JGHL5esbhAP48LmWKzgK3QOPRibZAic7Al7JVFwWW1I4o0vDQ/132","comment_is_top":false,"comment_ctime":1573747468,"is_pvip":true,"replies":[{"id":"58333","content":"strict不能杜绝全局变量污染。例如new Function()一样可能操作全局。<br>就目前的情况来说，strict会对程序员使用这门语言有很好的制约作用，对语言将来的发展也很好。但是，JavaScript的底层设计本来就是那样，多范型带来的特性之间的碰撞不可避免。例如strict其实是静态语言的需求，而new Function去是动态语言的特性。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573784349,"ip_address":"","comment_id":151600,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868714764","product_id":100039701,"comment_content":"请教老师一个问题。现在大部分的JS框架和NODEJS环境都是默认STRICT MODE。也就说任何变量都必须有声明，而像var x=y=100 这样的语句执行就会报错。如果未来ECMAJS都是默认STRICT MODE方向，那像全局变量污染问题还是否需要担心呢？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474551,"discussion_content":"strict不能杜绝全局变量污染。例如new Function()一样可能操作全局。\n就目前的情况来说，strict会对程序员使用这门语言有很好的制约作用，对语言将来的发展也很好。但是，JavaScript的底层设计本来就是那样，多范型带来的特性之间的碰撞不可避免。例如strict其实是静态语言的需求，而new Function去是动态语言的特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573784349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151080,"user_name":"凯文1985","can_delete":false,"product_type":"c1","uid":1036921,"ip_address":"","ucode":"9A42344649072B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/79/0a432fde.jpg","comment_is_top":false,"comment_ctime":1573651311,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5868618607","product_id":100039701,"comment_content":"对于js在词法分析和语法分析中发生的事情还不够了解 希望也能借这个课程讲解一下 ：）","like_count":1},{"had_liked":false,"id":150892,"user_name":"旺旺","can_delete":false,"product_type":"c1","uid":1159196,"ip_address":"","ucode":"FE2CF90F446BFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/1c/2e30eeb8.jpg","comment_is_top":false,"comment_ctime":1573623160,"is_pvip":false,"replies":[{"id":"58039","content":"是的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573632901,"ip_address":"","comment_id":150892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868590456","product_id":100039701,"comment_content":"简单语法语句背后还有这么多门道.<br>声明不是语句，声明只是在告诉编译器，并没有对运行产生影响，是这样吗？<br>","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474303,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573632901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351708,"user_name":"听话的小孩77","can_delete":false,"product_type":"c1","uid":2030114,"ip_address":"","ucode":"06DB21A7A4CDCF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKLaNiaLEqyGw3qE1WIcYUxiafNjmR1AzNmZKyK5RHr49r8Ry4Y0bjfwkY9krLKQmGiaIQ2MRqDwA85Q/132","comment_is_top":false,"comment_ctime":1658112816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658112816","product_id":100039701,"comment_content":"不好意思 我刚刚的环境有问题~","like_count":0},{"had_liked":false,"id":351707,"user_name":"听话的小孩77","can_delete":false,"product_type":"c1","uid":2030114,"ip_address":"","ucode":"06DB21A7A4CDCF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKLaNiaLEqyGw3qE1WIcYUxiafNjmR1AzNmZKyK5RHr49r8Ry4Y0bjfwkY9krLKQmGiaIQ2MRqDwA85Q/132","comment_is_top":false,"comment_ctime":1658112480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658112480","product_id":100039701,"comment_content":"为什么我刚刚试了下b = 3 也是不能删除的。。","like_count":0},{"had_liked":false,"id":337107,"user_name":"冷静冷静  再冷静","can_delete":false,"product_type":"c1","uid":2250102,"ip_address":"","ucode":"EDFED21A3B488F","user_header":"https://static001.geekbang.org/account/avatar/00/22/55/76/f880a299.jpg","comment_is_top":false,"comment_ctime":1646625862,"is_pvip":false,"replies":[{"id":"123227","content":"1. 左侧的总是“作为引用”来使用，但如果它本身就是字面量，那么它就是个值，例如“ 1 = 2”，尽管语义上有问题，但在语法上他的左侧是个值。另外，“引用”总会个是名字，这个在后面的内容中会讲到。<br><br>2. 如果是全局的var，是。<br><br>3. y不会。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1646673417,"ip_address":"","comment_id":337107,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646625862","product_id":100039701,"comment_content":"老师，你好<br>1. 什么时候 左边的表达式 = 引用，什么时候 等于 值呢<br>2. var 声明的 变量 也是可以在 global 访问到的，是因为他的 configure 为 false ，所以 delete 是false 吗？<br>3. 在静态分析中， var x = y =12， x 和 y 都会进入 valNames 吗","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554950,"discussion_content":"1. 左侧的总是“作为引用”来使用，但如果它本身就是字面量，那么它就是个值，例如“ 1 = 2”，尽管语义上有问题，但在语法上他的左侧是个值。另外，“引用”总会个是名字，这个在后面的内容中会讲到。\n\n2. 如果是全局的var，是。\n\n3. y不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646673417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329137,"user_name":"rocinn","can_delete":false,"product_type":"c1","uid":1015149,"ip_address":"","ucode":"12C7BCC4FA838C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/6d/81ed57c3.jpg","comment_is_top":false,"comment_ctime":1641175000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641175000","product_id":100039701,"comment_content":"too difficult","like_count":0},{"had_liked":false,"id":326484,"user_name":"云","can_delete":false,"product_type":"c1","uid":2107468,"ip_address":"","ucode":"705DF6B2A7654B","user_header":"https://static001.geekbang.org/account/avatar/00/20/28/4c/afe2ab34.jpg","comment_is_top":false,"comment_ctime":1639539034,"is_pvip":false,"replies":[{"id":"118720","content":"第1个前面的函数被解释成函数声明语句，于是后面的一对括号()就成了一个里头没有值的表达式，所以它不能执行。如果你在括号里加上点东西，那括号就成了计算表达式。例如：<br>```<br>&gt; function f() {}(1+2)<br>3<br>```<br>前面的声明语句是没有表达式执行意义的，被忽略。所以它实际执行的相当于eval(&quot;(1+2)&quot;)。如下：<br>```<br>&gt; (1+2)<br>3<br>&gt; eval(&quot;(1+2)&quot;)<br>3<br>```<br><br>至于第二个，由于外面加了一对括号——括号里面只能是表达式——所以函数f()被解释成了函数表达式（而不是函数声明语句）。而这种情况下，函数表达式后面的一对括号就理解成了函数调用，所以实际发生的是f函数被调用了一次。<br><br>不过这个两个例子的问题在很多书里都有讲过。我在《javascript语言精髓与编程实践》里面也专门讲过。总之这是从js 1.x以来就有的特性了。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1639675263,"ip_address":"","comment_id":326484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639539034","product_id":100039701,"comment_content":"老师，请教一个问题：<br>function f(){ return this}()<br>(function f(){ return this}())<br>为什么第一个不能执行，而第二个能呢","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539364,"discussion_content":"第1个前面的函数被解释成函数声明语句，于是后面的一对括号()就成了一个里头没有值的表达式，所以它不能执行。如果你在括号里加上点东西，那括号就成了计算表达式。例如：\n```\n&gt; function f() {}(1+2)\n3\n```\n前面的声明语句是没有表达式执行意义的，被忽略。所以它实际执行的相当于eval(&#34;(1+2)&#34;)。如下：\n```\n&gt; (1+2)\n3\n&gt; eval(&#34;(1+2)&#34;)\n3\n```\n\n至于第二个，由于外面加了一对括号——括号里面只能是表达式——所以函数f()被解释成了函数表达式（而不是函数声明语句）。而这种情况下，函数表达式后面的一对括号就理解成了函数调用，所以实际发生的是f函数被调用了一次。\n\n不过这个两个例子的问题在很多书里都有讲过。我在《javascript语言精髓与编程实践》里面也专门讲过。总之这是从js 1.x以来就有的特性了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639675263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310316,"user_name":"Herylee","can_delete":false,"product_type":"c1","uid":1522595,"ip_address":"","ucode":"F183F63C6B0ACA","user_header":"","comment_is_top":false,"comment_ctime":1630592927,"is_pvip":false,"replies":[{"id":"112497","content":"谢谢。其实用global大家都知道，反倒是用成globalThis会有一些人不知道🤔","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1630728682,"ip_address":"","comment_id":310316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630592927","product_id":100039701,"comment_content":"老师，Object.getOwnPropertyDescriptor(global,&#39;x&#39;)<br>global应该换成globalThis","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526194,"discussion_content":"谢谢。其实用global大家都知道，反倒是用成globalThis会有一些人不知道🤔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630728682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262434,"user_name":"zhenzhenChange","can_delete":false,"product_type":"c1","uid":2140340,"ip_address":"","ucode":"AFD74E6B4F0C29","user_header":"https://static001.geekbang.org/account/avatar/00/20/a8/b4/6a818036.jpg","comment_is_top":false,"comment_ctime":1605719979,"is_pvip":false,"replies":[{"id":"95308","content":"这个不算声明。“声明语句”是在静态词法阶段“向当前模块的环境中”添加名字的语句。而export * as abc只是描述了一个被导出的名字为“abc”，并不能在静态词法阶段“决定某个模块中的名字”，所以它不能算作声明。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1605802498,"ip_address":"","comment_id":262434,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605719979","product_id":100039701,"comment_content":"请问一下老师：<br>export * as abc from &quot;xxxx.js&quot;<br>这个算不算声明语句？好像还在提案中。。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509830,"discussion_content":"这个不算声明。“声明语句”是在静态词法阶段“向当前模块的环境中”添加名字的语句。而export * as abc只是描述了一个被导出的名字为“abc”，并不能在静态词法阶段“决定某个模块中的名字”，所以它不能算作声明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605802498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231769,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1593767269,"is_pvip":false,"replies":[{"id":"85966","content":"不是的。eval()语句会将变量名动态地塞入到变量列表，并且也可以动态删除。——这在创建相应的变量名时，会有一个“ isDeletable”的标记<br><br>在评论区的留言中有一处专门讨论过这个标记。你找找看","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1594175997,"ip_address":"","comment_id":231769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593767269","product_id":100039701,"comment_content":"eval里面的声明语句可以被删除，是不是因为，eval里面的语句错过了引擎的静态分析时期，导致变量列表里没有这些变量，所以是可以被删除的呀？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500432,"discussion_content":"不是的。eval()语句会将变量名动态地塞入到变量列表，并且也可以动态删除。——这在创建相应的变量名时，会有一个“ isDeletable”的标记\n\n在评论区的留言中有一处专门讨论过这个标记。你找找看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594175997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183909,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1583160417,"is_pvip":false,"replies":[{"id":"71324","content":"只有六种声明语句。参数中的名字声名可不是“语句”啊～另外还有catch子句和for循环都是能声明出名字的，但他们的声明都是附带的效果，所以也不算在声明语句中了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1583300635,"ip_address":"","comment_id":183909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583160417","product_id":100039701,"comment_content":"老师好，声明的语法有6种。函数的参数，function abc(a) {console.log(a)} 这个参数a不是声明的一种吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485818,"discussion_content":"只有六种声明语句。参数中的名字声名可不是“语句”啊～另外还有catch子句和for循环都是能声明出名字的，但他们的声明都是附带的效果，所以也不算在声明语句中了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583300635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170412,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1578589465,"is_pvip":false,"replies":[{"id":"66085","content":"是的。<br>其中的y是一个“向未声明变量赋值”导致的变量名创建（变量泄露）。这种变量与`var x`这种“var变量声明”的区别，就在于变量泄露名字可以删除。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578623476,"ip_address":"","comment_id":170412,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578589465","product_id":100039701,"comment_content":"var x=y=100;<br>delete x;<br>delete y;<br>——————<br>返回 false，<br>返回 true,对吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480974,"discussion_content":"是的。\n其中的y是一个“向未声明变量赋值”导致的变量名创建（变量泄露）。这种变量与`var x`这种“var变量声明”的区别，就在于变量泄露名字可以删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578623476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156556,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1574911287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574911287","product_id":100039701,"comment_content":"一天只敢看一章，看多了cpu受不了了。。。这一章看了第三遍，总算看懂百分之80了。。<br>有些名次听过，但为啥就是讲不上了是个啥。。比如语句，表达式什么的。。","like_count":0},{"had_liked":false,"id":153960,"user_name":"南墙的树","can_delete":false,"product_type":"c1","uid":1384130,"ip_address":"","ucode":"289B98CA489C09","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/c2/edf5dfcb.jpg","comment_is_top":false,"comment_ctime":1574337652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574337652","product_id":100039701,"comment_content":"概念好多，抽象，懵","like_count":0},{"had_liked":false,"id":153444,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1574236974,"is_pvip":false,"replies":[{"id":"59073","content":"是的。例如你在一个.js中写：<br>```<br>console.log(typeof f); &#47;&#47; &lt;- 提前使用f<br>class f {}<br>function f() {} &#47;&#47; &lt;- 尝试重声明f<br>````<br>这都是行得通的。这是因为名字f所在的环境是非严格模式。而在`class f {}`的内部，包括所有的方法声明中，却是在严格模式的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574303821,"ip_address":"","comment_id":153444,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574236974","product_id":100039701,"comment_content":"类的内部是处于严格模中，但它的名字仍然是按 varDecls 来处理的；<br><br>上面这句话没太懂。varDecls的话会在解析期执行声明，并且赋值为undefined，所以在赋值之前获取它的话为undefined；但是在声明类之前获取类的话，会报错，这种报错不应该更证明类是lexicalDecls吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475169,"discussion_content":"是的。例如你在一个.js中写：\n```\nconsole.log(typeof f); // &amp;lt;- 提前使用f\nclass f {}\nfunction f() {} // &amp;lt;- 尝试重声明f\n````\n这都是行得通的。这是因为名字f所在的环境是非严格模式。而在`class f {}`的内部，包括所有的方法声明中，却是在严格模式的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574303821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748640,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","nickname":"穿秋裤的男孩","note":"","ucode":"D0F48C66377893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62467,"discussion_content":"老师，我在一个js文件里面执行您说的着段代码，也就是提前访问class声明段变量，会报“Uncaught ReferenceError: Cannot access &#39;A&#39; before initialization”这样一个错，所以我认为class声明，不管是class内部还是class本身段名字，都是按照lexicalDecls来的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574845580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1748640,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","nickname":"穿秋裤的男孩","note":"","ucode":"D0F48C66377893","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64123,"discussion_content":"我测试了一下，这里的确是我错了。类声明在当前作用域中也不可以提前的，我已经请编辑老师在线更新了这一处的NOTE。多谢指正~","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574937599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":62467,"ip_address":""},"score":64123,"extra":""}]}]},{"had_liked":false,"id":151566,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1573740956,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1573740956","product_id":100039701,"comment_content":"JS 6种声明语句<br>1. let 声明<br>2. const 声明<br>3. var 声明<br>4. function x {} 声明<br>5. class x  声明<br>6. import .. 声明<br> 变量泄露，在全局声明的变量除了会赋值到全局对象上，还会单独维护一个变量列表，当删除一个全局变量的时候，如果该变量在单独维护的变量列表中就不会被删除（除了 eval() 中声明的变量）","like_count":0},{"had_liked":false,"id":151565,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1573740734,"is_pvip":true,"replies":[{"id":"58268","content":"不是。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573744275,"ip_address":"","comment_id":151565,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1573740734","product_id":100039701,"comment_content":"语句都会返回一个引用，声明不会，可以不可以这样理解？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474536,"discussion_content":"不是。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573744275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151442,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1573721402,"is_pvip":false,"replies":[{"id":"58271","content":"或许是shell环境的问题？","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573744622,"ip_address":"","comment_id":151442,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573721402","product_id":100039701,"comment_content":"提问：为什么我执行 &quot;var x=100; console.log(Object.getOwnPropertyDescriptor(global, &#39;x&#39;));&quot; 输出结果是 undefined呢？<br><br>这节课的收获就是加深了对“声明”的理解，而且让我意外的是 js 居然也有静态语义。对于思考题：声明是针对静态编译的，而“非声明”的语句则是运行时的具体执行，个人感觉上有种“抽象”与“具体”的区别，有种“接口”与“具体实现”的区别。之前我只是大致了解 java 字节码文件的结构，现在我有了更准确的认识——字节码文件的内容其实就是一切“声明”，而只有在运行时的类加载阶段才会真正完成链接、初始化","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474476,"discussion_content":"或许是shell环境的问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573744622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389114,"avatar":"https://static001.geekbang.org/account/avatar/00/15/32/3a/ead5611e.jpg","nickname":"陆昱嘉","note":"","ucode":"A5E26B3F9A5A8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51948,"discussion_content":"global换成window","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573972646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1036052,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","nickname":"Wiggle Wiggle","note":"","ucode":"EFE746551BA998","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1389114,"avatar":"https://static001.geekbang.org/account/avatar/00/15/32/3a/ead5611e.jpg","nickname":"陆昱嘉","note":"","ucode":"A5E26B3F9A5A8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52146,"discussion_content":"我用shell运行的nodejs，没有window","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573999258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51948,"ip_address":""},"score":52146,"extra":""}]}]},{"had_liked":false,"id":151016,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1573643548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573643548","product_id":100039701,"comment_content":"老师讲得太好了，让我又学到了很多以前不知道的东西，感觉学无止境啊。加油","like_count":0},{"had_liked":false,"id":150955,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573634403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573634403","product_id":100039701,"comment_content":"学习了，原来不用 var 还是会出现变量泄漏的...<br><br>function test() {<br>\tconst x = y = 100;<br>}<br>test.bind({})();<br>console.log(y); &#47;&#47; 100<br>","like_count":0}]}