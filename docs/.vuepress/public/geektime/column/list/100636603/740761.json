{"id":740761,"title":"第 3 章 Vue.js 3 的设计思路","content":"<p>在第 1 章中，我们阐述了框架设计是权衡的艺术，这里面存在取舍，例如性能与可维护性之间的取舍、运行时与编译时之间的取舍等。在第 2 章中，我们详细讨论了框架设计的几个核心要素，有些要素是框架设计者必须要考虑的，另一些要素则是从专业和提升开发体验的角度考虑的。框架设计讲究全局视角的把控，一个项目就算再大，也是存在一条核心思路的，并围绕核心展开。本章我们就从全局视角了解 Vue.js 3 的设计思路、工作机制及其重要的组成部分。我们可以把这些组成部分当作独立的功能模块，看看它们之间是如何相互配合的。在后续的章节中，我们会深入各个功能模块了解它们的运作机制。</p>\n<h2 id=\"nav_point_24\">3.1　声明式地描述 UI</h2>\n<p>Vue.js 3 是一个声明式的 UI 框架，意思是说用户在使用 Vue.js 3 开发页面时是声明式地描述 UI 的。思考一下，如果让你设计一个声明式的 UI 框架，你会怎么设计呢？为了搞清楚这个问题，我们需要了解编写前端页面都涉及哪些内容，具体如下。</p>\n<ul>\n<li>DOM 元素：例如是 <code>div</code> 标签还是 <code>a</code> 标签。</li>\n<li>属性：如 <code>a</code> 标签的 <code>href</code> 属性，再如 <code>id</code>、<code>class</code> 等通用属性。</li>\n<li>事件：如 <code>click</code>、<code>keydown</code> 等。</li>\n<li>元素的层级结构：DOM 树的层级结构，既有子节点，又有父节点。</li>\n</ul>\n<p>那么，如何声明式地描述上述内容呢？这是框架设计者需要思考的问题。其实方案有很多。拿 Vue.js 3 来说，相应的解决方案是：</p>\n<ul>\n<li>使用与 HTML 标签一致的方式来描述 DOM 元素，例如描述一个 <code>div</code> 标签时可以使用 <code>&lt;div&gt;&lt;/div&gt;</code>；</li>\n<li>使用与 HTML 标签一致的方式来描述属性，例如 <code>&lt;div id=\"app\"&gt;&lt;/div&gt;</code>；</li>\n<li>使用 <code>:</code> 或 <code>v-bind</code> 来描述动态绑定的属性，例如 <code>&lt;div :id=\"dynamicId\"&gt;&lt;/div&gt;</code>；</li>\n<li>使用 <code>@</code> 或 <code>v-on</code> 来描述事件，例如点击事件 <code>&lt;div @click=\"handler\"&gt;&lt;/div&gt;</code>；</li>\n<li>使用与 HTML 标签一致的方式来描述层级结构，例如一个具有 <code>span</code> 子节点的 <code>div</code> 标签 <code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code>。</li>\n</ul>\n<p>可以看到，在 Vue.js 中，哪怕是事件，都有与之对应的描述方式。用户不需要手写任何命令式代码，这就是所谓的声明式地描述 UI。</p><!-- [[[read_end]]] -->\n<p>除了上面这种使用<strong>模板</strong>来声明式地描述 UI 之外，我们还可以用 JavaScript 对象来描述，代码如下所示：</p>\n<pre class=\"code-rows\"><code> const title = {\n   // 标签名称\n   tag: 'h1',\n   // 标签属性\n   props: {\n     onClick: handler\n   },\n   // 子节点\n   children: [\n     { tag: 'span' }\n   ]\n }\n</code></pre>\n<p>对应到 Vue.js 模板，其实就是：</p>\n<pre class=\"code-rows\"><code> &lt;h1 @click=\"handler\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;\n</code></pre>\n<p>那么，使用模板和 JavaScript 对象描述 UI 有何不同呢？答案是：使用 JavaScript 对象描述 UI 更加灵活。举个例子，假如我们要表示一个标题，根据标题级别的不同，会分别采用 <code>h1</code>~<code>h6</code> 这几个标签，如果用 JavaScript 对象来描述，我们只需要使用一个变量来代表 <code>h</code> 标签即可：</p>\n<pre class=\"code-rows\"><code> // h 标签的级别\n let level = 3\n const title = {\n   tag: `h$`, // h3 标签\n }\n</code></pre>\n<p>可以看到，当变量 <code>level</code> 值改变，对应的标签名字也会在 <code>h1</code> 和 <code>h6</code> 之间变化。但是如果使用模板来描述，就不得不穷举：</p>\n<pre class=\"code-rows\"><code> &lt;h1 v-if=\"level === 1\"&gt;&lt;/h1&gt;\n &lt;h2 v-else-if=\"level === 2\"&gt;&lt;/h2&gt;\n &lt;h3 v-else-if=\"level === 3\"&gt;&lt;/h3&gt;\n &lt;h4 v-else-if=\"level === 4\"&gt;&lt;/h4&gt;\n &lt;h5 v-else-if=\"level === 5\"&gt;&lt;/h5&gt;\n &lt;h6 v-else-if=\"level === 6\"&gt;&lt;/h6&gt;\n</code></pre>\n<p>这远没有 JavaScript 对象灵活。而使用 JavaScript 对象来描述 UI 的方式，其实就是所谓的虚拟 DOM。现在大家应该觉得虚拟 DOM 其实也没有那么神秘了吧。正是因为虚拟 DOM 的这种灵活性，Vue.js 3 除了支持使用模板描述 UI 外，还支持使用虚拟 DOM 描述 UI。其实我们在 Vue.js 组件中手写的渲染函数就是使用虚拟 DOM 来描述 UI 的，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> import { h } from 'vue'\n<p>export default {<br />\nrender() {<br />\nreturn h(‘h1’, { onClick: handler }) // 虚拟 DOM<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>有的读者可能会说，这里是 <code>h</code> 函数调用呀，也不是 JavaScript 对象啊。其实 <code>h</code> 函数的返回值就是一个对象，其作用是让我们编写虚拟 DOM 变得更加轻松。如果把上面 <code>h</code> 函数调用的代码改成 JavaScript 对象，就需要写更多内容：</p>\n<pre class=\"code-rows\"><code> export default {\n   render() {\n     return {\n       tag: 'h1',\n       props: { onClick: handler }\n     }\n   }\n }\n</code></pre>\n<p>如果还有子节点，那么需要编写的内容就更多了，所以 <code>h</code> 函数就是一个辅助创建虚拟 DOM 的工具函数，仅此而已。另外，这里有必要解释一下什么是组件的<strong>渲染函数</strong>。一个组件要渲染的内容是通过渲染函数来描述的，也就是上面代码中的 <code>render</code> 函数，Vue.js 会根据组件的 <code>render</code> 函数的返回值拿到虚拟 DOM，然后就可以把组件的内容渲染出来了。</p>\n<h2 id=\"nav_point_25\">3.2　初识渲染器</h2>\n<p>现在我们已经了解了什么是虚拟 DOM，它其实就是用 JavaScript 对象来描述真实的 DOM 结构。那么，虚拟 DOM 是如何变成真实 DOM 并渲染到浏览器页面中的呢？这就用到了我们接下来要介绍的：渲染器。</p>\n<p>渲染器的作用就是把虚拟 DOM 渲染为真实 DOM，如图 3-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00496.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-1　渲染器的作用</strong></p>\n<p>渲染器是非常重要的角色，大家平时编写的 Vue.js 组件都是依赖渲染器来工作的，因此后面我们会专门讲解渲染器。不过这里有必要先初步认识渲染器，以便更好地理解 Vue.js 的工作原理。</p>\n<p>假设我们有如下虚拟 DOM：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   tag: 'div',\n   props: {\n     onClick: () =&gt; alert('hello')\n   },\n   children: 'click me'\n }\n</code></pre>\n<p>首先简单解释一下上面这段代码。</p>\n<ul>\n<li><code>tag</code> 用来描述标签名称，所以 <code>tag: 'div'</code> 描述的就是一个 <code>&lt;div&gt;</code> 标签。</li>\n<li><code>props</code> 是一个对象，用来描述 <code>&lt;div&gt;</code> 标签的属性、事件等内容。可以看到，我们希望给 <code>div</code> 绑定一个点击事件。</li>\n<li><code>children</code> 用来描述标签的子节点。在上面的代码中，<code>children</code> 是一个字符串值，意思是 <code>div</code> 标签有一个文本子节点：<code>&lt;div&gt;click me&lt;/div&gt;</code></li>\n</ul>\n<p>实际上，你完全可以自己设计虚拟 DOM 的结构，例如可以使用 <code>tagName</code> 代替 <code>tag</code>，因为它本身就是一个 JavaScript 对象，并没有特殊含义。</p>\n<p>接下来，我们需要编写一个<strong>渲染器</strong>，把上面这段虚拟 DOM 渲染为真实 DOM：</p>\n<pre class=\"code-rows\"><code> function renderer(vnode, container) {\n   // 使用 vnode.tag 作为标签名称创建 DOM 元素\n   const el = document.createElement(vnode.tag)\n   // 遍历 vnode.props，将属性、事件添加到 DOM 元素\n   for (const key in vnode.props) {\n     if (/^on/.test(key)) {\n       // 如果 key 以 on 开头，说明它是事件\n       el.addEventListener(\n         key.substr(2).toLowerCase(), // 事件名称 onClick ---&gt; click\n         vnode.props[key] // 事件处理函数\n       )\n     }\n   }\n<p>// 处理 children<br />\nif (typeof vnode.children === ‘string’) {<br />\n// 如果 children 是字符串，说明它是元素的文本子节点<br />\nel.appendChild(document.createTextNode(vnode.children))<br />\n} else if (Array.isArray(vnode.children)) {<br />\n// 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点<br />\nvnode.children.forEach(child =&gt; renderer(child, el))<br />\n}</p>\n<p>// 将元素添加到挂载点下<br />\ncontainer.appendChild(el)<br />\n}<br />\n</code></pre></p>\n<p>这里的 <code>renderer</code> 函数接收如下两个参数。</p>\n<ul>\n<li><code>vnode</code>：虚拟 DOM 对象。</li>\n<li><code>container</code>：一个真实 DOM 元素，作为挂载点，渲染器会把虚拟 DOM 渲染到该挂载点下。</li>\n</ul>\n<p>接下来，我们可以调用 <code>renderer</code> 函数：</p>\n<pre class=\"code-rows\"><code> renderer(vnode, document.body) // body 作为挂载点\n</code></pre>\n<p>在浏览器中运行这段代码，会渲染出“click me”文本，点击该文本，会弹出 <code>alert('hello')</code>，如图 3-2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00497.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 3-2　运行结果</strong></p>\n<p>现在我们回过头来分析渲染器 <code>renderer</code> 的实现思路，总体来说分为三步。</p>\n<ul>\n<li>创建元素：把 <code>vnode.tag</code> 作为标签名称来创建 DOM 元素。</li>\n<li>为元素添加属性和事件：遍历 <code>vnode.props</code> 对象，如果 <code>key</code> 以 <code>on</code> 字符开头，说明它是一个事件，把字符 <code>on</code> 截取掉后再调用 <code>toLowerCase</code> 函数将事件名称小写化，最终得到合法的事件名称，例如 <code>onClick</code> 会变成 <code>click</code>，最后调用 <code>addEventListener</code> 绑定事件处理函数。</li>\n<li>处理 <code>children</code>：如果 <code>children</code> 是一个数组，就递归地调用 <code>renderer</code> 继续渲染，注意，此时我们要把刚刚创建的元素作为挂载点（父节点）；如果 <code>children</code> 是字符串，则使用 <code>createTextNode</code> 函数创建一个文本节点，并将其添加到新创建的元素内。</li>\n</ul>\n<p>怎么样，是不是感觉渲染器并没有想象得那么神秘？其实不然，别忘了我们现在所做的还仅仅是创建节点，渲染器的精髓都在更新节点的阶段。假设我们对 <code>vnode</code> 做一些小小的修改：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   tag: 'div',\n   props: {\n     onClick: () =&gt; alert('hello')\n   },\n   children: 'click again' // 从 click me 改成 click again\n }\n</code></pre>\n<p>对于渲染器来说，它需要精确地找到 <code>vnode</code> 对象的变更点并且只更新变更的内容。就上例来说，渲染器应该只更新元素的文本内容，而不需要再走一遍完整的创建元素的流程。这些内容后文会重点讲解，但无论如何，希望大家明白，渲染器的工作原理其实很简单，归根结底，都是使用一些我们熟悉的 DOM 操作 API 来完成渲染工作。</p>\n<h2 id=\"nav_point_26\">3.3　组件的本质</h2>\n<p>我们已经初步了解了虚拟 DOM 和渲染器，知道了虚拟 DOM 其实就是用来描述真实 DOM 的普通 JavaScript 对象，渲染器会把这个对象渲染为真实 DOM 元素。那么组件又是什么呢？组件和虚拟 DOM 有什么关系？渲染器如何渲染组件？接下来，我们就来讨论这些问题。</p>\n<p>其实虚拟 DOM 除了能够描述真实 DOM 之外，还能够描述组件。例如使用 <code>{ tag: 'div' }</code> 来描述 <code>&lt;div&gt;</code> 标签，但是组件并不是真实的 DOM 元素，那么如何使用虚拟 DOM 来描述呢？想要弄明白这个问题，就需要先搞清楚组件的本质是什么。一句话总结：<strong>组件就是一组 DOM 元素的封装</strong>，这组 DOM 元素就是组件要渲染的内容，因此我们可以定义一个函数来代表组件，而函数的返回值就代表组件要渲染的内容：</p>\n<pre class=\"code-rows\"><code> const MyComponent = function () {\n   return {\n     tag: 'div',\n     props: {\n       onClick: () =&gt; alert('hello')\n     },\n     children: 'click me'\n   }\n }\n</code></pre>\n<p>可以看到，组件的返回值也是虚拟 DOM，它代表组件要渲染的内容。搞清楚了组件的本质，我们就可以定义用虚拟 DOM 来描述组件了。很简单，我们可以让虚拟 DOM 对象中的 <code>tag</code> 属性来存储组件函数：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   tag: MyComponent\n }\n</code></pre>\n<p>就像 <code>tag: 'div'</code> 用来描述 <code>&lt;div&gt;</code> 标签一样，<code>tag: MyComponent</code> 用来描述组件，只不过此时的 <code>tag</code> 属性不是标签名称，而是组件函数。为了能够渲染组件，需要渲染器的支持。修改前面提到的 <code>renderer</code> 函数，如下所示：</p>\n<pre class=\"code-rows\"><code> function renderer(vnode, container) {\n   if (typeof vnode.tag === 'string') {\n     // 说明 vnode 描述的是标签元素\n     mountElement(vnode, container)\n   } else if (typeof vnode.tag === 'function') {\n     // 说明 vnode 描述的是组件\n     mountComponent(vnode, container)\n   }\n }\n</code></pre>\n<p>如果 <code>vnode.tag</code> 的类型是字符串，说明它描述的是普通标签元素，此时调用 <code>mountElement</code> 函数完成渲染；如果 <code>vnode.tag</code> 的类型是函数，则说明它描述的是组件，此时调用 <code>mountComponent</code> 函数完成渲染。其中 <code>mountElement</code> 函数与上文中 <code>renderer</code> 函数的内容一致：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   // 使用 vnode.tag 作为标签名称创建 DOM 元素\n   const el = document.createElement(vnode.tag)\n   // 遍历 vnode.props，将属性、事件添加到 DOM 元素\n   for (const key in vnode.props) {\n     if (/^on/.test(key)) {\n       // 如果 key 以字符串 on 开头，说明它是事件\n       el.addEventListener(\n         key.substr(2).toLowerCase(), // 事件名称 onClick ---&gt; click\n         vnode.props[key] // 事件处理函数\n       )\n     }\n   }\n<p>// 处理 children<br />\nif (typeof vnode.children === ‘string’) {<br />\n// 如果 children 是字符串，说明它是元素的文本子节点<br />\nel.appendChild(document.createTextNode(vnode.children))<br />\n} else if (Array.isArray(vnode.children)) {<br />\n// 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点<br />\nvnode.children.forEach(child =&gt; renderer(child, el))<br />\n}</p>\n<p>// 将元素添加到挂载点下<br />\ncontainer.appendChild(el)<br />\n}<br />\n</code></pre></p>\n<p>再来看 <code>mountComponent</code> 函数是如何实现的：</p>\n<pre class=\"code-rows\"><code> function mountComponent(vnode, container) {\n   // 调用组件函数，获取组件要渲染的内容（虚拟 DOM）\n   const subtree = vnode.tag()\n   // 递归地调用 renderer 渲染 subtree\n   renderer(subtree, container)\n }\n</code></pre>\n<p>可以看到，非常简单。首先调用 <code>vnode.tag</code> 函数，我们知道它其实就是组件函数本身，其返回值是虚拟 DOM，即组件要渲染的内容，这里我们称之为 <code>subtree</code>。既然 <code>subtree</code> 也是虚拟 DOM，那么直接调用 <code>renderer</code> 函数完成渲染即可。</p>\n<p>这里希望大家能够做到举一反三，例如组件一定得是函数吗？当然不是，我们完全可以使用一个 JavaScript 对象来表达组件，例如：</p>\n<pre class=\"code-rows\"><code> // MyComponent 是一个对象\n const MyComponent = {\n   render() {\n     return {\n       tag: 'div',\n       props: {\n         onClick: () =&gt; alert('hello')\n       },\n       children: 'click me'\n     }\n   }\n }\n</code></pre>\n<p>这里我们使用一个对象来代表组件，该对象有一个函数，叫作 <code>render</code>，其返回值代表组件要渲染的内容。为了完成组件的渲染，我们需要修改 <code>renderer</code> 渲染器以及 <code>mountComponent</code> 函数。</p>\n<p>首先，修改渲染器的判断条件：</p>\n<pre class=\"code-rows\"><code> function renderer(vnode, container) {\n   if (typeof vnode.tag === 'string') {\n     mountElement(vnode, container)\n   } else if (typeof vnode.tag === 'object') { // 如果是对象，说明 vnode 描述的是组件\n     mountComponent(vnode, container)\n   }\n }\n</code></pre>\n<p>现在我们使用对象而不是函数来表达组件，因此要将 <code>typeof vnode.tag === 'function'</code> 修改为 <code>typeof vnode.tag === 'object'</code>。</p>\n<p>接着，修改 <code>mountComponent</code> 函数：</p>\n<pre class=\"code-rows\"><code> function mountComponent(vnode, container) {\n   // vnode.tag 是组件对象，调用它的 render 函数得到组件要渲染的内容（虚拟 DOM）\n   const subtree = vnode.tag.render()\n   // 递归地调用 renderer 渲染 subtree\n   renderer(subtree, container)\n }\n</code></pre>\n<p>在上述代码中，<code>vnode.tag</code> 是表达组件的对象，调用该对象的 <code>render</code> 函数得到组件要渲染的内容，也就是虚拟 DOM。</p>\n<p>可以发现，我们只做了很小的修改，就能够满足用对象来表达组件的需求。那么大家可以继续发挥想象力，看看能否创造出其他的组件表达方式。其实 Vue.js 中的有状态组件就是使用对象结构来表达的。</p>\n<h2 id=\"nav_point_27\">3.4　模板的工作原理</h2>\n<p>无论是手写虚拟 DOM（渲染函数）还是使用模板，都属于声明式地描述 UI，并且 Vue.js 同时支持这两种描述 UI 的方式。上文中我们讲解了虚拟 DOM 是如何渲染成真实 DOM 的，那么模板是如何工作的呢？这就要提到 Vue.js 框架中的另外一个重要组成部分：<strong>编译器</strong>。</p>\n<p>编译器和渲染器一样，只是一段程序而已，不过它们的工作内容不同。编译器的作用其实就是将模板编译为渲染函数，例如给出如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;div @click=\"handler\"&gt;\n   click me\n &lt;/div&gt;\n</code></pre>\n<p>对于编译器来说，模板就是一个普通的字符串，它会分析该字符串并生成一个功能与之相同的渲染函数：</p>\n<pre class=\"code-rows\"><code> render() {\n   return h('div', { onClick: handler }, 'click me')\n }\n</code></pre>\n<p>以我们熟悉的 .vue 文件为例，一个 .vue 文件就是一个组件，如下所示：</p>\n<pre class=\"code-rows\"><code> &lt;template&gt;\n   &lt;div @click=\"handler\"&gt;\n     click me\n   &lt;/div&gt;\n &lt;/template&gt;\n<p>&lt;script&gt;<br />\nexport default {<br />\ndata() {/* … <em>/},<br />\nmethods: {<br />\nhandler: () =&gt; {/</em> … */}<br />\n}<br />\n}<br />\n&lt;/script&gt;<br />\n</code></pre></p>\n<p>其中 <code>&lt;template&gt;</code> 标签里的内容就是模板内容，编译器会把模板内容编译成渲染函数并添加到 <code>&lt;script&gt;</code> 标签块的组件对象上，所以最终在浏览器里运行的代码就是：</p>\n<pre class=\"code-rows\"><code> export default {\n   data() {/* ... */},\n   methods: {\n     handler: () =&gt; {/* ... */}\n   },\n   render() {\n     return h('div', { onClick: handler }, 'click me')\n   }\n }\n</code></pre>\n<p>所以，无论是使用模板还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的，然后<strong>渲染器</strong>再把渲染函数返回的虚拟 DOM 渲染为真实 DOM，这就是模板的工作原理，也是 Vue.js 渲染页面的流程。</p>\n<p><strong>编译器</strong>是一个比较大的话题，后面我们会着重讲解，这里大家只需要清楚编译器的作用及角色即可。</p>\n<h2 id=\"nav_point_28\">3.5　Vue.js 是各个模块组成的有机整体</h2>\n<p>如前所述，组件的实现依赖于<strong>渲染器</strong>，模板的编译依赖于<strong>编译器</strong>，并且编译后生成的代码是根据渲染器和虚拟 DOM 的设计决定的，因此 Vue.js 的各个模块之间是互相关联、互相制约的，共同构成一个有机整体。因此，我们在学习 Vue.js 原理的时候，应该把各个模块结合到一起去看，才能明白到底是怎么回事。</p>\n<p>这里我们以<strong>编译器</strong>和<strong>渲染器</strong>这两个非常关键的模块为例，看看它们是如何配合工作，并实现性能提升的。</p>\n<p>假设我们有如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;div id=\"foo\" :class=\"cls\"&gt;&lt;/div&gt;\n</code></pre>\n<p>根据上文的介绍，我们知道编译器会把这段代码编译成渲染函数：</p>\n<pre class=\"code-rows\"><code> render() {\n   // 为了效果更加直观，这里没有使用 h 函数，而是直接采用了虚拟 DOM 对象\n   // 下面的代码等价于：\n   // return h('div', { id: 'foo', class: cls })\n   return {\n     tag: 'div',\n     props: {\n       id: 'foo',\n       class: cls\n     }\n   }\n }\n</code></pre>\n<p>可以发现，在这段代码中，<code>cls</code> 是一个变量，它可能会发生变化。我们知道渲染器的作用之一就是寻找并且只更新变化的内容，所以当变量 <code>cls</code> 的值发生变化时，渲染器会自行寻找变更点。对于渲染器来说，这个“寻找”的过程需要花费一些力气。那么从编译器的视角来看，它能否知道哪些内容会发生变化呢？如果编译器有能力分析动态内容，并在编译阶段把这些信息提取出来，然后直接交给渲染器，这样渲染器不就不需要花费大力气去寻找变更点了吗？这是个好想法并且能够实现。Vue.js 的模板是有特点的，拿上面的模板来说，我们一眼就能看出其中 <code>id=\"foo\"</code> 是永远不会变化的，而 <code>:class=\"cls\"</code> 是一个 <code>v-bind</code> 绑定，它是可能发生变化的。所以编译器能识别出哪些是静态属性，哪些是动态属性，在生成代码的时候完全可以附带这些信息：</p>\n<pre class=\"code-rows\"><code> render() {\n   return {\n     tag: 'div',\n     props: {\n       id: 'foo',\n       class: cls\n     },\n     patchFlags: 1 // 假设数字 1 代表 class 是动态的\n   }\n }\n</code></pre>\n<p>如上面的代码所示，在生成的虚拟 DOM 对象中多出了一个 <code>patchFlags</code> 属性，我们假设数字 <code>1</code> 代表“ <code>class</code> 是动态的”，这样渲染器看到这个标志时就知道：“哦，原来只有 <code>class</code> 属性会发生改变。”对于渲染器来说，就相当于省去了寻找变更点的工作量，性能自然就提升了。</p>\n<p>通过这个例子，我们了解到编译器和渲染器之间是存在信息交流的，它们互相配合使得性能进一步提升，而它们之间交流的媒介就是虚拟 DOM 对象。在后面的学习中，我们会看到一个虚拟 DOM 对象中会包含多种数据字段，每个字段都代表一定的含义。</p>\n<h2 id=\"nav_point_29\">3.6　总结</h2>\n<p>在本章中，我们首先介绍了声明式地描述 UI 的概念。我们知道，Vue.js 是一个声明式的框架。声明式的好处在于，它直接描述结果，用户不需要关注过程。Vue.js 采用模板的方式来描述 UI，但它同样支持使用虚拟 DOM 来描述 UI。虚拟 DOM 要比模板更加灵活，但模板要比虚拟 DOM 更加直观。</p>\n<p>然后我们讲解了最基本的渲染器的实现。渲染器的作用是，把虚拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会更新需要更新的内容。后面我们会专门讲解渲染器的相关知识。</p>\n<p>接着，我们讨论了组件的本质。组件其实就是一组虚拟 DOM 元素的封装，它可以是一个返回虚拟 DOM 的函数，也可以是一个对象，但这个对象下必须要有一个函数用来产出组件要渲染的虚拟 DOM。渲染器在渲染组件时，会先获取组件要渲染的内容，即执行组件的渲染函数并得到其返回值，我们称之为 <code>subtree</code>，最后再递归地调用渲染器将 <code>subtree</code> 渲染出来即可。</p>\n<p>Vue.js 的模板会被一个叫作编译器的程序编译为渲染函数，后面我们会着重讲解编译器相关知识。最后，编译器、渲染器都是 Vue.js 的核心组成部分，它们共同构成一个有机的整体，不同模块之间互相配合，进一步提升框架性能。</p>\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 2 章 框架设计的核心要素","id":740760},"right":{"article_title":"第 4 章 响应系统的作用与实现(1)","id":740762}},"comments":[{"had_liked":false,"id":390789,"user_name":"青雘","can_delete":false,"product_type":"c1","uid":2687278,"ip_address":"广东","ucode":"29D71967CA90F0","user_header":"https://static001.geekbang.org/account/avatar/00/29/01/2e/5d3d4b86.jpg","comment_is_top":false,"comment_ctime":1716279268,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"牛的","like_count":1},{"had_liked":false,"id":395680,"user_name":"Faye","can_delete":false,"product_type":"c1","uid":1293886,"ip_address":"北京","ucode":"7E8351CB61A764","user_header":"https://static001.geekbang.org/account/avatar/00/13/be/3e/aef2c613.jpg","comment_is_top":false,"comment_ctime":1731659264,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"什么叫做有状态组件呢？","like_count":0},{"had_liked":false,"id":389152,"user_name":"写代码的小龙哥","can_delete":false,"product_type":"c1","uid":1088329,"ip_address":"北京","ucode":"B4CCD1260573FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/49/f4117f64.jpg","comment_is_top":false,"comment_ctime":1711688105,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"好，写的真实太棒了 ，看的畅快淋漓","like_count":0}]}