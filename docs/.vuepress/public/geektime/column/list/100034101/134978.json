{"id":134978,"title":"13 | 继承和多态：面向对象运行期的动态特性","content":"<p>面向对象是一个比较大的话题。在“<a href=\"https://time.geekbang.org/column/article/130422\">09 | 面向对象：实现数据和方法的封装</a>”中，我们了解了面向对象的封装特性，也探讨了对象成员的作用域和生存期特征等内容。本节课，我们再来了解一下面向对象的另外两个重要特征：<strong>继承和多态。</strong></p><p>你也许会问，为什么没有在封装特性之后，马上讲继承和多态呢？那是因为继承和多态涉及的语义分析阶段的知识点比较多，特别是它对类型系统提出了新的概念和挑战，所以我们先掌握语义分析，再了解这部分内容，才是最好的选择。</p><p>继承和多态对类型系统提出的新概念，就是子类型。我们之前接触的类型往往是并列关系，你是整型，我是字符串型，都是平等的。而现在，一个类型可以是另一个类型的子类型，比如我是一只羊，又属于哺乳动物。这会导致我们在编译期无法准确计算出所有的类型，从而无法对方法和属性的调用做完全正确的消解（或者说绑定）。这部分工作要留到运行期去做，也因此，面向对象编程会具备非常好的优势，因为它会导致多态性。这个特性会让面向对象语言在处理某些类型的问题时，更加优雅。</p><p>而我们要想深刻理解面向对象的特征，就必须了解子类型的原理和运行期的机制。所以，接下来，我们从类型体系的角度理解继承和多态，然后看看在编译期需要做哪些语义分析，再考察继承和多态的运行期特征。</p><!-- [[[read_end]]] --><h2>从类型体系的角度理解继承和多态</h2><p><strong>继承的意思是一个类的子类，自动具备了父类的属性和方法，除非被父类声明为私有的。</strong>比如一个类是哺乳动物，它有体重（weight）的属性，还会做叫(speak)的操作。如果基于哺乳动物这个父类创建牛和羊两个子类，那么牛和羊就自动继承了哺乳动物的属性，有体重，还会叫。</p><p>所以继承的强大之处，就在于重用。也就是有些逻辑，如果在父类中实现，在子类中就不必重复实现。</p><p><strong>多态的意思是同一个类的不同子类，在调用同一个方法时会执行不同的动作。</strong>这是因为每个子类都可以重载掉父类的某个方法，提供一个不同的实现。哺乳动物会“叫”，而牛和羊重载了这个方法，发出“哞~”和“咩~”的声音。这似乎很普通，但如果创建一个哺乳动物的数组，并在里面存了各种动物对象，遍历这个数组并调用每个对象“叫”的方法时，就会发出“哞~”“咩~”“喵~”等各种声音，这就有点儿意思了。</p><p>下面这段示例代码，演示了继承和多态的特性，a的speak()方法和b的speak()方法会分别打印出牛叫和羊叫，调用的是子类的方法，而不是父类的方法：</p><pre><code>/**\nmammal.play 演示面向对象编程：继承和多态。\n*/\nclass Mammal{\n    int weight = 20;  \n    boolean canSpeak(){\n        return true;\n    }\n\n    void speak(){\n        println(&quot;mammal speaking...&quot;);\n    }\n}\n\nclass Cow extends Mammal{\n    void speak(){\n        println(&quot;moo~~ moo~~&quot;);\n    }\n}\n\nclass Sheep extends Mammal{\n    void speak(){\n        println(&quot;mee~~ mee~~&quot;);\n        println(&quot;My weight is: &quot; + weight); //weight的作用域覆盖子类\n    }\n}\n\n//将子类的实例赋给父类的变量\nMammal a = Cow();\nMammal b = Sheep();\n\n//canSpeak()方法是继承的\nprintln(&quot;a.canSpeak() : &quot; + a.canSpeak());\nprintln(&quot;b.canSpeak() : &quot; + b.canSpeak());\n\n//下面两个的叫声会不同，在运行期动态绑定方法\na.speak();  //打印牛叫\nb.speak();  //打印羊叫\n</code></pre><p>所以，多态的强大之处，在于虽然每个子类不同，但我们仍然可以按照统一的方式使用它们，做到求同存异。<strong>以前端工程师天天打交道的前端框架为例，这是最能体现面向对象编程优势的领域之一。</strong></p><p>前端界面往往会用到各种各样的小组件，比如静态文本、可编辑文本、按钮等等。如果我们想刷新组件的显示，没必要针对每种组件调用一个方法，把所有组件的类型枚举一遍，可以直接调用父类中统一定义的方法redraw()，非常简洁。即便将来添加新的前端组件，代码也不需要修改，程序也会更容易维护。</p><p><strong>总结一下：</strong>面向对象编程时，我们可以给某个类创建不同的子类，实现一些个性化的功能；写程序时，我们可以站在抽象度更高的层次上，不去管具体的差异。</p><p>如果把上面的结论抽象成一般意义上的类型理论，就是<strong>子类型（subtype）。</strong></p><p>子类型（或者动名词：子类型化），是对我们前面讲的类型体系的一个补充。</p><p>子类型的核心是提供了is-a的操作。也就是对某个类型所做的所有操作都可以用子类型替代。因为子类型 is a 父类型，也就是能够兼容父类型，比如一只牛是哺乳动物。</p><p>这意味着只要对哺乳动物可以做的操作，都可以对牛来做，这就是子类型的好处。它可以放宽对类型的检查，从而导致多态。你可以粗略地把面向对象的继承看做是子类型化的一个体现，它的结果就是能用子类代替父类，从而导致多态。</p><p>子类型有两种实现方式：一种就是像Java和C++语言，需要显式声明继承了什么类，或者实现了什么接口。这种叫做名义子类型（Nominal Subtyping）。</p><p>另一种是结构化子类型（Structural Subtyping），又叫鸭子类型（Duck Type）。也就是一个类不需要显式地说自己是什么类型，只要它实现了某个类型的所有方法，那就属于这个类型。鸭子类型是个直观的比喻，如果我们定义鸭子的特征是能够呱呱叫，那么只要能呱呱叫的，就都是鸭子。</p><p>了解了继承和多态之后，我们看看在编译期如何对继承和多态的特性做语义分析。</p><h2>如何对继承和多态的特性做语义分析</h2><p>针对哺乳动物的例子，我们用前面语义分析的知识，看看如何在编译期针对继承和多态做语义分析，也算对语义分析的知识点进行应用和复盘。</p><p>首先，从类型处理的角度出发，我们要识别出新的类型：Mammal、Cow和Sheep。之后，就可以用它们声明变量了。</p><p>第二，我们要设置正确的作用域。</p><p>从作用域的角度来看，一个类的属性（或者说成员变量），是可以规定能否被子类访问的。以Java为例，除了声明为private的属性以外，其他属性在子类中都是可见的。所以父类的属性的作用域，可以说是以树状的形式覆盖到了各级子类：</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/24/c94acfea0ea44dcff839b80c77d3e224.jpg?wh=1142*502\" alt=\"\"></p><p>第三，要对变量和函数做类型的引用消解。</p><p>也就是要分析出a和b这两个变量的类型。那么a和b的类型是什么呢？是父类Mammal？还是Cow或Sheep？</p><p>注意，代码里是用Mammal来声明这两个变量的。按照类型推导的算法，a和b都是Mammal，这是个I属性计算的过程。也就是说，在编译期，我们无法知道变量被赋值的对象确切是哪个子类型，只知道声明变量时，它们是哺乳动物类型，至于是牛还是羊，就不清楚了。</p><p>你可能会说：“不对呀，我在编译的时候能知道a和b的准确类型啊，因为我看到了a是一个Cow对象，而b是一个Sheep，代码里有这两个对象的创建过程，我可以推导出a和b的实际类型呀。”</p><p>没错，语言的确有自动类型推导的特性，但你忽略了限制条件。比如，强类型机制要求变量的类型一旦确定，在运行过程就不能再改，所以要让a和b能够重新指向其他的对象，并保持类型不变。从这个角度出发，a和b的类型只能是父类Mammal。</p><p>所以说，编译期无法知道变量的真实类型，可能只知道它的父类型，也就是知道它是一个哺乳动物，但不知道它具体是牛还是羊。这会导致我们没法正确地给speak()方法做引用消解。正确的消解，是要指向Cow和Sheep的speak方法，而我们只能到运行期再解决这个问题。</p><p>所以接下来，我们就讨论一下如何在运行期实现方法的动态绑定。</p><h2>如何在运行期实现方法的动态绑定</h2><p>在运行期，我们能知道a和b这两个变量具体指向的是哪个对象，对象里是保存了真实类型信息的。具体来说，在playscript中，ClassObject的type属性会指向一个正确的Class，这个类型信息是在创建对象的时候被正确赋值的：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/0d/c1a3070da8053b4a67065e58d2149f0d.jpg?wh=1142*385\" alt=\"\"></p><p>在调用类的属性和方法时，我们可以根据运行时获得的，确定的类型信息进行动态绑定。下面这段代码是从本级开始，逐级查找某个方法的实现，如果本级和父类都有这个方法，那么本级的就会覆盖掉父类的，<strong>这样就实现了多态：</strong></p><pre><code>protected Function getFunction(String name, List&lt;Type&gt; paramTypes){\n    //在本级查找这个这个方法\n    Function rtn = super.getFunction(name, paramTypes);  //TODO 是否要检查visibility\n\n    //如果在本级找不到，那么递归的从父类中查找\n    if (rtn == null &amp;&amp; parentClass != null){\n        rtn = parentClass.getFunction(name,paramTypes);\n    }\n\n    return rtn;\n}\n</code></pre><p>如果当前类里面没有实现这个方法，它可以直接复用某一级的父类中的实现，<strong>这实际上就是继承机制在运行期的原理。</strong></p><p>你看，只有了解运行期都发生了什么，才能知道继承和多态是怎么发生的吧。</p><p>这里延伸一下。我们刚刚谈到，在运行时可以获取类型信息，这种机制就叫做运行时类型信息（Run Time Type Information, RTTI）。C++、Java等都有这种机制，比如Java的instanceof操作，就能检测某个对象是不是某个类或者其子类的实例。</p><p>汇编语言是无类型的，所以一般高级语言在编译成目标语言之后，这些高层的语义就会丢失。如果要在运行期获取类型信息，需要专门实现RTTI的功能，这就要花费额外的存储开销和计算开销。就像在playscript中，我们要在ClassObject中专门拿出一个字段来存type信息。</p><p>现在，我们已经了解如何在运行期获得类型信息，实现方法的动态绑定。接下来，我带你了解一下运行期的对象的逐级初始化机制。</p><h2>继承情况下对象的实例化</h2><p>在存在继承关系的情况下，创建对象时，不仅要初始化自己这一级的属性变量，还要把各级父类的属性变量也都初始化。比如，在实例化Cow的时候，还要对Mammal的成员变量weight做初始化。</p><p>所以我们要修改playscript中对象实例化的代码，从最顶层的祖先起，对所有的祖先层层初始化：</p><pre><code>//从父类到子类层层执行缺省的初始化方法，即不带参数的初始化方法\nprotected ClassObject createAndInitClassObject(Class theClass) {\n    ClassObject obj = new ClassObject();\n    obj.type = theClass;\n\n    Stack&lt;Class&gt; ancestorChain = new Stack&lt;Class&gt;();\n\n    // 从上到下执行缺省的初始化方法\n    ancestorChain.push(theClass);\n    while (theClass.getParentClass() != null) {\n        ancestorChain.push(theClass.getParentClass());\n        theClass = theClass.getParentClass();\n    }\n\n    // 执行缺省的初始化方法\n    StackFrame frame = new StackFrame(obj);\n    pushStack(frame);\n    while (ancestorChain.size() &gt; 0) {\n        Class c = ancestorChain.pop();\n        defaultObjectInit(c, obj);\n    }\n    popStack();\n\n    return obj;\n}\n</code></pre><p>在逐级初始化的过程中，我们要先执行缺省的成员变量初始化，也就是变量声明时所带的初始化部分，然后调用这一级的构造方法。如果不显式指定哪个构造方法，就会执行不带参数的构造方法。不过有的时候，子类会选择性地调用父类某一个构造方法，就像Java可以在构造方法里通过super()来显式地调用父类某个具体构造方法。</p><h2>如何实现this和super</h2><p>现在，我们已经了解了继承和多态在编译期和运行期的特性。接下来，我们通过一个示例程序，把本节课的所有知识复盘检验一下，加深对它们的理解，也加深对this和super机制的理解。</p><p>这个示例程序是用Java写的，在Java语言中，为面向对象编程专门提供了两个关键字：this和super，这两个关键字特别容易引起混乱。</p><p>比如在下面的ThisSuperTest.Java代码中，Mammal和它的子类Cow都有speak()方法。如果我们要创建一个Cow对象，会调用Mammal的构造方法Mammal(int weight)，而在这个构造方法里调用的this.speak()方法，是Mammal的，还是Cow的呢？</p><pre><code>package play;\n\npublic class ThisSuperTest {\n\n    public static void main(String args[]){\n        //创建Cow对象的时候，会在Mammal的构造方法里调用this.reportWeight()，这里会显示什么\n        Cow cow = new Cow();\n\n        System.out.println();\n\n        //这里调用，会显示什么\n        cow.speak();\n    }\n}\n\nclass Mammal{\n    int weight;\n\n    Mammal(){\n        System.out.println(&quot;Mammal() called&quot;);\n        this.weight = 100;\n    }\n\n    Mammal(int weight){\n        this();   //调用自己的另一个构造函数\n        System.out.println(&quot;Mammal(int weight) called&quot;);\n        this.weight = weight;\n\n        //这里访问属性，是自己的weight\n        System.out.println(&quot;this.weight in Mammal : &quot; + this.weight);\n\n        //这里的speak()调用的是谁，会显示什么数值\n        this.speak();\n    }\n\n    void speak(){\n        System.out.println(&quot;Mammal's weight is : &quot; + this.weight);\n    }\n}\n\n\nclass Cow extends Mammal{\n    int weight = 300;\n\n    Cow(){\n        super(200);   //调用父类的构造函数\n    }\n\n    void speak(){\n        System.out.println(&quot;Cow's weight is : &quot; + this.weight);\n        System.out.println(&quot;super.weight is : &quot; + super.weight);\n    }\n}\n</code></pre><p>运行结果如下：</p><pre><code>Mammal() called\nMammal(int weight) called\nthis.weight in Mammal : 200\nCow's weight is : 0\nsuper.weight is : 200\n\nCow's weight is : 300\nsuper.weight is : 200\n</code></pre><p>答案是Cow的speak()方法，而不是Mammal的。怎么回事？代码里不是调用的this.speak()吗？怎么这个this不是Mammal，却变成了它的子类Cow呢？</p><p>其实，在这段代码中，this用在了三个地方：</p><ul>\n<li>this.weight 是访问自己的成员变量，因为成员变量的作用域是这个类本身，以及子类。</li>\n<li>this()是调用自己的另一个构造方法，因为这是构造方法，肯定是做自身的初始化。换句话说，构造方法不存在多态问题。</li>\n<li>this.speak()是调用一个普通的方法。这时，多态仍会起作用。运行时会根据对象的实际类型，来绑定到Cow的speak()方法上。</li>\n</ul><p>只不过，在Mammal的构造方法中调用this.speak()时，虽然访问的是Cow的speak()方法，打印的是Cow中定义的weight成员变量，但它的值却是0，而不是成员变量声明时“int weight = 300;”的300。为什么呢？</p><p>要想知道这个答案，我们需要理解多层继承情况下对象的初始化过程。在Mammal的构造方法中调用speak()的时候，Cow的初始化过程还没有开始呢，所以“int weight = 300;”还没有执行，Cow的weight属性还是缺省值0。</p><p>怎么样？一个小小的例子，却需要用到三个方面的知识：面向对象的成员变量的作用域、多态、对象初始化。<strong>Java程序员可以拿这个例子跟同事讨论一下，看看是不是很好玩。</strong></p><p>讨论完this，super就比较简单了，它的语义要比this简单，不会出现歧义。super的调用，也是分成三种情况：</p><ul>\n<li>super.weight。这是调用父类或更高的祖先的weight属性，而不是Cow这一级的weight属性。不一定非是直接父类，也可以是祖父类中的。根据变量作用域的覆盖关系，只要是比Cow这一级高的就行。</li>\n<li>super(200)。这是调用父类的构造方法，必须是直接父类的。</li>\n<li>super.speak()。跟访问属性的逻辑一样，是调用父类或更高的祖先的speak()方法。</li>\n</ul><h2>课程小结</h2><p>这节课我带你实现了面向对象中的另两个重要特性：继承和多态。在这节课中，我建议你掌握的重点内容是：</p><ul>\n<li>从类型的角度，面向对象的继承和多态是一种叫做子类型的现象，子类型能够放宽对类型的检查，从而支持多态。</li>\n<li>在编译期，无法准确地完成对象方法和属性的消解，因为无法确切知道对象的子类型。</li>\n<li>在运行期，我们能够获得对象的确切的子类型信息，从而绑定正确的方法和属性，实现继承和多态。另一个需要注意的运行期的特征，是对象的逐级初始化过程。</li>\n</ul><p>面向对象涉及了这么多精彩的知识点，拿它作为前端技术原理篇的最后一讲，是正确的选择。到目前为止，我们已经讲完了前端技术的原理篇，也如约拥有了一门具备丰富特性的脚本语言，甚至还支持面向对象编程、闭包、函数式编程这些很高级的特性。一般的应用项目所需要的语言特性，很难超过这个范围了。接下来的两节，我们就通过两个具体的应用案例，来检验一下学到的编译原理前端技术，看看它的威力！</p><h2>一课一思</h2><p>本节课我们深入讨论了面向对象的继承和多态特征。那么你所熟悉的框架，有没有充分利用继承和多态的特点实现一些很有威力的功能？或者，你有没有利用多态的特点，写过一些比较有用的类库或框架呢？欢迎在留言区分享你的经验。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>本节课的示例代码我放在了文末，供你参考。</p><ul>\n<li>playscript-java（项目目录）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/tree/master/playscript-java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/tree/master/playscript-java\">GitHub</a></li>\n<li>ASTEvaluator.java（解释器，请找一下运行期方法和属性动态绑定，以及对象实例逐级初始化的代码）： <a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">码云</a>   <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java\">GitHub</a></li>\n<li>ThisSuperTest.java（测试Java的this和super特性）：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/oop/ThisSuperTest.java\">码云</a>    <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/oop/ThisSuperTest.java\">GitHub</a></li>\n<li>this-and-super.play (playscript的this和super特性)：<a href=\"https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/examples/this-and-super.play\">码云</a>    <a href=\"https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/examples/this-and-super.play\">GitHub</a></li>\n</ul><p></p>","neighbors":{"left":{"article_title":"12 | 语义分析（下）：如何做上下文相关情况的处理？","id":133737},"right":{"article_title":"14 | 前端技术应用（一）：如何透明地支持数据库分库分表？","id":135954}},"comments":[{"had_liked":false,"id":136969,"user_name":"曾经瘦过","can_delete":false,"product_type":"c1","uid":1240106,"ip_address":"","ucode":"57C32575A1C1FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/2a/b11d5ad8.jpg","comment_is_top":false,"comment_ctime":1569568721,"is_pvip":false,"replies":[{"id":"53928","content":"我看看在讲Java那讲里能否把这个内容兼顾。<br><br>有同学提的泛型，其实我还没有安排进去...实在不行做个加餐。<br><br>这里先提一句：java的泛型其实只是语法糖，是在基础语法的基础上封装了一层而已。运行期，带泛型和不带泛型的，是完全同一套代码，没区别。LinkedList&lt;String&gt;和LinkedList&lt;Object&gt;运行时没区别。只是在编译期添加了额外的类型检查功能。<br>这跟C++的模板完全不是一回事。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570715384,"ip_address":"","comment_id":136969,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40224274385","product_id":100034101,"comment_content":"看到了评论 泛型 然后想到了反射。根据使用经验(反射报错都是在运行时)，老师在后端的部分会讲一下反射吗？","like_count":9,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468884,"discussion_content":"我看看在讲Java那讲里能否把这个内容兼顾。\n\n有同学提的泛型，其实我还没有安排进去...实在不行做个加餐。\n\n这里先提一句：java的泛型其实只是语法糖，是在基础语法的基础上封装了一层而已。运行期，带泛型和不带泛型的，是完全同一套代码，没区别。LinkedList&amp;lt;String&amp;gt;和LinkedList&amp;lt;Object&amp;gt;运行时没区别。只是在编译期添加了额外的类型检查功能。\n这跟C++的模板完全不是一回事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570715384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050269,"avatar":"","nickname":"minghu6","note":"","ucode":"F44058E21B14C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359776,"discussion_content":"Java毕竟有个虚拟机提供很强的运行时支持，不必像C++一步到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616290114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133295,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1200589,"ip_address":"","ucode":"CF98ACFB8BFD6F","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/cd/d6fe851f.jpg","comment_is_top":false,"comment_ctime":1568497700,"is_pvip":false,"replies":[{"id":"51370","content":"好的，我把这个问题在答疑那讲里作为一个点。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568695921,"ip_address":"","comment_id":133295,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27338301476","product_id":100034101,"comment_content":"老师能增加一讲泛型吗？这样就圆满了🤣","like_count":6,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467336,"discussion_content":"好的，我把这个问题在答疑那讲里作为一个点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568695921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133094,"user_name":"影影影","can_delete":false,"product_type":"c1","uid":1157761,"ip_address":"","ucode":"5BE8847256B6B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/81/97e36f32.jpg","comment_is_top":false,"comment_ctime":1568358349,"is_pvip":false,"replies":[{"id":"51371","content":"Java语言的成员变量，只要给它分配了内存空间，就一定会做初始化。所以，即使还没有运行这个类的构造方法，其实这些变量也都可以用了，只不过里面的是缺省值。<br>Java只所以采取这个机制，可能就是跟面向对象的生存期特征有关的。也就是，所有成员变量要在调用任何方法之前就创建，并且可用。所以，这个时候调用方法并没有问题。<br>所以，Cow类的初始化过程，如果用放大镜看的话，可能会分成多个阶段。对于int a = 10;这样一个语句来说：<br>阶段1：Cow及其父类的成员属性都获得了内存，并具备了缺省值。<br>阶段2：使用变量声明时的初始化部分，让a的值变为10；<br>在这个阶段，其实还可以用int a = b；或者int a = foo()这样的方式来做初始化，这时候要求b一定是在a的前面。<br>阶段3：运行自定义的构造函数。这时候，a的值可能又被修改成其他值。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568697096,"ip_address":"","comment_id":133094,"utype":1}],"discussion_count":4,"race_medal":0,"score":"14453260237","product_id":100034101,"comment_content":"老师您好，有些小的疑惑，麻烦解答下。<br>对于文中提到的，在ThisSuperTest.java类中调用Mammal的构造方法Mammal(int weight)后调用this.speak()这个例子。<br>根据您的解释，是会调用Cow类的speak函数。其中您也提到了，在调用这个方法时，Cow类初始化并没有开始。<br>因此我的疑惑是，在一个类(Cow)的实例没有初始化的时候，为何就已经可以去调用这个实例的方法了？","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467252,"discussion_content":"Java语言的成员变量，只要给它分配了内存空间，就一定会做初始化。所以，即使还没有运行这个类的构造方法，其实这些变量也都可以用了，只不过里面的是缺省值。\nJava只所以采取这个机制，可能就是跟面向对象的生存期特征有关的。也就是，所有成员变量要在调用任何方法之前就创建，并且可用。所以，这个时候调用方法并没有问题。\n所以，Cow类的初始化过程，如果用放大镜看的话，可能会分成多个阶段。对于int a = 10;这样一个语句来说：\n阶段1：Cow及其父类的成员属性都获得了内存，并具备了缺省值。\n阶段2：使用变量声明时的初始化部分，让a的值变为10；\n在这个阶段，其实还可以用int a = b；或者int a = foo()这样的方式来做初始化，这时候要求b一定是在a的前面。\n阶段3：运行自定义的构造函数。这时候，a的值可能又被修改成其他值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568697096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042507,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/4b/57fa0e34.jpg","nickname":"brianway","note":"","ucode":"E05738C88829C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342334,"discussion_content":"更精炼的解释：区分两个概念，实例化（Instantiation）和初始化（Initialization），前者分配成员属性内存和给默认初始值（比如整型默认0，boolean默认false）。后者是真正的初始操作。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610637520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1534010,"avatar":"https://static001.geekbang.org/account/avatar/00/17/68/3a/61a7e3e1.jpg","nickname":"陈师洋","note":"","ucode":"C3065D290660FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304141,"discussion_content":"这个和c++不同 在基类中调用虚函数 永远只会调用base自己！因为虚函数依赖虚表指针 而这个是在构造函数中才会初始化的！因此base类构造在子类构造之前 在base构造中只能访问到base自己的虚表！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599479034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1157761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/aa/81/97e36f32.jpg","nickname":"影影影","note":"","ucode":"5BE8847256B6B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14042,"discussion_content":"明白了，感谢回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568723853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217332,"user_name":"刘桢","can_delete":false,"product_type":"c1","uid":1482815,"ip_address":"","ucode":"3BFAB1C9772EB4","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/3f/06b690ba.jpg","comment_is_top":false,"comment_ctime":1589465785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179400377","product_id":100034101,"comment_content":"太强了","like_count":2},{"had_liked":false,"id":135394,"user_name":"余晓飞","can_delete":false,"product_type":"c1","uid":1007370,"ip_address":"","ucode":"EEC632FF776327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/0a/7f9c476b.jpg","comment_is_top":false,"comment_ctime":1569144818,"is_pvip":false,"replies":[{"id":"57688","content":"抱歉回复晚了。<br>方法的overide，是下级覆盖商机，所以应该先从下级查找。如果下级实现了，就用下级的。<br>如果下级没有，就用上级的，这就是inheritence。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573440366,"ip_address":"","comment_id":135394,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159079410","product_id":100034101,"comment_content":"&#47;&#47; 在本级查找这个这个方法<br>Function rtn = super.getFunction(name, paramTypes);<br>这里需要首先在本级查找，但是根据下文介绍的super特性，这里查找的应该是上级及以上的方法，是在这里和Java有差别吗？","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468172,"discussion_content":"抱歉回复晚了。\n方法的overide，是下级覆盖商机，所以应该先从下级查找。如果下级实现了，就用下级的。\n如果下级没有，就用上级的，这就是inheritence。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573440366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134003,"user_name":"xiaobang","can_delete":false,"product_type":"c1","uid":1157508,"ip_address":"","ucode":"1735BDCFD61655","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/84/c87b51ce.jpg","comment_is_top":false,"comment_ctime":1568714783,"is_pvip":false,"replies":[{"id":"57684","content":"允许多态正常，因为虽然是在构造函数中，但已经要使用对象的方法了，所以多态逻辑就会发生作用。<br><br>不过，java对象的初始化的语法设计，似乎还可以做得更好。比如，如果调用super()，必须出现在第一行等等。需要明白初始化的原理，才会理解为什么这么设计。<br><br>另，你的问题：加不加this都是一样的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573437508,"ip_address":"","comment_id":134003,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10158649375","product_id":100034101,"comment_content":"Java里面构造函数里面居然允许多态，感觉行为怪怪的，不符合自觉。另外ThisSuperTest里面那个weihgt和speak 前面不加this 语义也一样吗","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467578,"discussion_content":"允许多态正常，因为虽然是在构造函数中，但已经要使用对象的方法了，所以多态逻辑就会发生作用。\n\n不过，java对象的初始化的语法设计，似乎还可以做得更好。比如，如果调用super()，必须出现在第一行等等。需要明白初始化的原理，才会理解为什么这么设计。\n\n另，你的问题：加不加this都是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573437508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054958,"avatar":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","nickname":"ABC","note":"","ucode":"7501AD9C0C4A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341247,"discussion_content":"老师说的没错，Java里面，调用super()必须出现在子类构造方法的第一行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610360879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132742,"user_name":"林恒杰","can_delete":false,"product_type":"c1","uid":1098836,"ip_address":"","ucode":"16EC87B8E177AF","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/54/e17a8602.jpg","comment_is_top":false,"comment_ctime":1568210099,"is_pvip":false,"replies":[{"id":"51375","content":"好的，我安排在后端部分会讨论一下这个问题。<br>深度学习发展速度太快。从长远来看，需要标准的IR。这又是一次标准之争。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568697837,"ip_address":"","comment_id":132742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158144691","product_id":100034101,"comment_content":"现在深度学习的端侧芯片碎片化比较严重，因而对于编译器需求也开始变多起来，包括谷歌最近也像LLVM社区提交了MLIR，老师可以讲一下这个部分的看法吗？","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467102,"discussion_content":"好的，我安排在后端部分会讨论一下这个问题。\n深度学习发展速度太快。从长远来看，需要标准的IR。这又是一次标准之争。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568697837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132598,"user_name":"李懂","can_delete":false,"product_type":"c1","uid":1330436,"ip_address":"","ucode":"539E6639042C88","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/04/5e0d3713.jpg","comment_is_top":false,"comment_ctime":1568170505,"is_pvip":false,"replies":[{"id":"50726","content":"总的来说，this和super在三个场景中，它的语义是有差别的。<br>场景1：对象属性：适用原理，是变量作用域。<br>场景2：对象方法：适用原理，是多态；<br>场景3：构造方法。这个只是长得像方法，其实不是方法。要用对象初始化的逻辑去分析它。<br><br>this和super的实现，你可以参考一下playscript-java的代码。<br>另外，可以再像ThisSuperTest.java一样，写点代码深入测试一下this和super特性。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568181450,"ip_address":"","comment_id":132598,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10158105097","product_id":100034101,"comment_content":"也就是只有方法存在多态，属性和构造函数是不存在多态！<br>这个this，super是咋实现的，以前觉得this是当前对象  super是父类对象，现在看来好像不对！","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467030,"discussion_content":"总的来说，this和super在三个场景中，它的语义是有差别的。\n场景1：对象属性：适用原理，是变量作用域。\n场景2：对象方法：适用原理，是多态；\n场景3：构造方法。这个只是长得像方法，其实不是方法。要用对象初始化的逻辑去分析它。\n\nthis和super的实现，你可以参考一下playscript-java的代码。\n另外，可以再像ThisSuperTest.java一样，写点代码深入测试一下this和super特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568181450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1454676,"avatar":"https://static001.geekbang.org/account/avatar/00/16/32/54/19bbc3bb.jpg","nickname":"WSJay","note":"","ucode":"BD1656298FBC1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9964,"discussion_content":"this和super都是指当前对象，表达的含义不同而已，只是this告诉当前对象查找自身的方法或属性，而super告诉当前对象去查找父类中的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568252140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139894,"user_name":"cry soul","can_delete":false,"product_type":"c1","uid":1508461,"ip_address":"","ucode":"986C52250EB110","user_header":"https://static001.geekbang.org/account/avatar/00/17/04/6d/c959cb93.jpg","comment_is_top":false,"comment_ctime":1570761382,"is_pvip":false,"replies":[{"id":"57695","content":"线程的原理，是操作系统的内容，你可能要去那门课程多学一下:)<br><br>过去的语言（如C语言），只是提供标准的库，让你访问操作系统的线程管理功能，包括信号量、同步互斥什么的。<br><br>Java语言增加了一些专门处理多线程的元素，比如synchronized关键字。<br><br>go语言又更进一步，把操作系统的线程进行了封装，变成了轻量级的goroutine，很受欢迎。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573442648,"ip_address":"","comment_id":139894,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5865728678","product_id":100034101,"comment_content":"还有一个点，其实比较想知道的是多线程的实现。以及线程安全问题等，怎么样实现是原子级的操作。希望老师能稍微提及这样的内容，因为本身是做web开发的，真的比较好奇。","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470164,"discussion_content":"线程的原理，是操作系统的内容，你可能要去那门课程多学一下:)\n\n过去的语言（如C语言），只是提供标准的库，让你访问操作系统的线程管理功能，包括信号量、同步互斥什么的。\n\nJava语言增加了一些专门处理多线程的元素，比如synchronized关键字。\n\ngo语言又更进一步，把操作系统的线程进行了封装，变成了轻量级的goroutine，很受欢迎。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573442648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054958,"avatar":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","nickname":"ABC","note":"","ucode":"7501AD9C0C4A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341246,"discussion_content":"Java在OpenJDK里面有一个叫Loom的项目，实现了轻量级线程。只是需要自己编译。具体可以参考:\n\nhttp://openjdk.java.net/projects/loom/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610360299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050269,"avatar":"","nickname":"minghu6","note":"","ucode":"F44058E21B14C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359783,"discussion_content":"讲到这儿就要说一下Rust了，避免并发问题的最好办法就是没有竞争","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616290615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133020,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1568315304,"is_pvip":false,"replies":[{"id":"51372","content":"在RefResolver.exitPrimary()中，在这里做与primary有关的引用消解。<br>This variable = theClass.getThis();<br>at.symbolOfNode.put(ctx, variable);<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568697459,"ip_address":"","comment_id":133020,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863282600","product_id":100034101,"comment_content":"看代码的时候有个疑问，this作为一个primary，当要去找其左值的时候，会去各个作用域中搜索thisRef，但是thisRef是什么时候加入到作用域的符号表的呢？没有找到代码中对应的位置","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467221,"discussion_content":"在RefResolver.exitPrimary()中，在这里做与primary有关的引用消解。\nThis variable = theClass.getThis();\nat.symbolOfNode.put(ctx, variable);\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568697459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133015,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1568311557,"is_pvip":false,"replies":[{"id":"51373","content":"对，目前没有支持类方法。也没有支持类级别的成员变量。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568697516,"ip_address":"","comment_id":133015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863278853","product_id":100034101,"comment_content":"看老师的代码里好像没有对类方法和对象方法进行区分，是因为PlayScript目前还不支持类方法吗？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467217,"discussion_content":"对，目前没有支持类方法。也没有支持类级别的成员变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568697516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349854,"user_name":"王越","can_delete":false,"product_type":"c1","uid":1852595,"ip_address":"","ucode":"F09FA6DF8CD1C0","user_header":"","comment_is_top":false,"comment_ctime":1656386963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656386963","product_id":100034101,"comment_content":"那位大佬能告诉我  怎么运行起来 playscript 啊","like_count":0},{"had_liked":false,"id":316239,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1634216373,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1634216373","product_id":100034101,"comment_content":"对语言有了新的认识","like_count":0},{"had_liked":false,"id":300928,"user_name":"潜龙勿用","can_delete":false,"product_type":"c1","uid":2159460,"ip_address":"","ucode":"EEB8A6F3E4A1B8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dsZ5CFV7mCIKEn7YcVFJXksO201eeqsJXoT4EYNvcibAKNSWSQVZPbbRgPKraWqg6YnaaRlVoywic9MEsflicRDibQ/132","comment_is_top":false,"comment_ctime":1625453735,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1625453735","product_id":100034101,"comment_content":"多态，支撑了设计原则里面的面向接口编程。应用的地方太多了，比如jdbc","like_count":0},{"had_liked":false,"id":286826,"user_name":"minghu6","can_delete":false,"product_type":"c1","uid":1050269,"ip_address":"","ucode":"F44058E21B14C9","user_header":"","comment_is_top":false,"comment_ctime":1617617437,"is_pvip":false,"replies":[{"id":"105365","content":"很不错，看得出你做了很多工作！棒！<br>我也可以借鉴你的gradle配置:)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1619764761,"ip_address":"","comment_id":286826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617617437","product_id":100034101,"comment_content":"好大的项目，用gradle组织并加了一个简单的集成测试<br>https:&#47;&#47;bitbucket.org&#47;minghu6code&#47;ps-java&#47;src&#47;master&#47;","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518102,"discussion_content":"很不错，看得出你做了很多工作！棒！\n我也可以借鉴你的gradle配置:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619764761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248184,"user_name":"lion_fly","can_delete":false,"product_type":"c1","uid":1060242,"ip_address":"","ucode":"FCFD6B66C01B83","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/92/287f99db.jpg","comment_is_top":false,"comment_ctime":1600053736,"is_pvip":false,"replies":[{"id":"91200","content":"点赞！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1600088113,"ip_address":"","comment_id":248184,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600053736","product_id":100034101,"comment_content":"mark一下，原理篇跟完了","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505579,"discussion_content":"点赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600088113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135117,"user_name":"Giacomo","can_delete":false,"product_type":"c1","uid":1478055,"ip_address":"","ucode":"BE5B1E68BCDBB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","comment_is_top":false,"comment_ctime":1569031759,"is_pvip":false,"replies":[{"id":"57686","content":"能把你的“结构化继承”的含义描述得更细致一些吗？<br>如果你是指基于结构体来做继承，go语言做得就不错。你可以了解一下。对组合的支持做得很好。<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573439971,"ip_address":"","comment_id":135117,"utype":1}],"discussion_count":8,"race_medal":0,"score":"1569031759","product_id":100034101,"comment_content":"老师，现在流行的计算机语言中，有没有结构化继承的啊？因为我自己想写的语言本身是结构化继承的","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468055,"discussion_content":"能把你的“结构化继承”的含义描述得更细致一些吗？\n如果你是指基于结构体来做继承，go语言做得就不错。你可以了解一下。对组合的支持做得很好。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573439971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48104,"discussion_content":"我想要的是，类也好，结构体也罢，我可以直接通过继承来生成子类，也可以直接复制粘贴来获得，这两种方式在之后的使用上没有任何区别（编译时可以有来源的区别）。\n\n直接点就是说，即使我用了复制粘贴来写这个子类，我依然可以通过一个类似于issubclass的函数/关键词来判定它确实是它的子类。\n\n无法理解的话这是例子，\nclass A {\n    int a;\n}\n\nclass B extends A {\n    // 根据定义 B 是 A 的子类\n    int b;\n}\n\nclass C {\n    // 因为拥有A全部的属性，所以 C 也是 A 的子类\n    int a;\n    int b;\n}\n\n谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573448774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631005,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/yoTG87qicuhbNacuWFF1MWxeCCA8bzWO9Tfk7CcM9Hl9o8e3PJp4qvXF250Y5gp5ibyR13xIbPia6qcicFv0PQINzA/132","nickname":"码力不足","note":"","ucode":"8319956D67F861","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25018,"discussion_content":"python和golang就是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570370043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631005,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/yoTG87qicuhbNacuWFF1MWxeCCA8bzWO9Tfk7CcM9Hl9o8e3PJp4qvXF250Y5gp5ibyR13xIbPia6qcicFv0PQINzA/132","nickname":"码力不足","note":"","ucode":"8319956D67F861","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26413,"discussion_content":"python怎么会是呢？它要通过class A(B): 来继承的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570601762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25018,"ip_address":""},"score":26413,"extra":""},{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631005,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/yoTG87qicuhbNacuWFF1MWxeCCA8bzWO9Tfk7CcM9Hl9o8e3PJp4qvXF250Y5gp5ibyR13xIbPia6qcicFv0PQINzA/132","nickname":"码力不足","note":"","ucode":"8319956D67F861","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26435,"discussion_content":"我查查看go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570602250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25018,"ip_address":""},"score":26435,"extra":""},{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631005,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/yoTG87qicuhbNacuWFF1MWxeCCA8bzWO9Tfk7CcM9Hl9o8e3PJp4qvXF250Y5gp5ibyR13xIbPia6qcicFv0PQINzA/132","nickname":"码力不足","note":"","ucode":"8319956D67F861","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26501,"discussion_content":"go根本不是OOP，虽然它可以用接口实现...你说的有道理，但这不是我想要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570604753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25018,"ip_address":""},"score":26501,"extra":""}]}]}]}