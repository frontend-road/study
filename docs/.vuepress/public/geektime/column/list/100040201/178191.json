{"id":178191,"title":"11丨软件设计的开闭原则：如何不修改代码却能实现需求变更？","content":"<p>我在上篇文章讲到，软件设计应该为需求变更而设计，应该能够灵活、快速地满足需求变更的要求。优秀的程序员也应该欢迎需求变更，因为持续的需求变更意味着自己开发的软件保持活力，同时也意味着自己为需求变更而进行的设计有了用武之地，这样的话，技术和业务都进入了良性循环。</p><p>但是需求变更就意味着原来开发的功能需要改变，也意味着程序需要改变。如果是通过修改程序代码实现需求变更，那么代码一定会在不断修改的过程中变得面目全非，这也意味着代码的腐坏。</p><p>有没有办法不修改代码却能实现需求变更呢？</p><p>这个要求听起来有点玄幻，事实上却是软件设计需要遵循的最基本的原则：开闭原则。</p><h2>开闭原则</h2><p>开闭原则说：<strong>软件实体（模块、类、函数等等）应该对扩展是开放的，对修改是关闭的</strong>。</p><p>对扩展是开放的，意味着软件实体的行为是可扩展的，当需求变更的时候，可以对模块进行扩展，使其满足需求变更的要求。</p><p>对修改是关闭的，意味着当对软件实体进行扩展的时候，不需要改动当前的软件实体；不需要修改代码；对于已经完成的类文件不需要重新编辑；对于已经编译打包好的模块，不需要再重新编译。</p><p>通俗的说就是，<strong>软件功能可以扩展，但是软件实体不可以被修改</strong>。</p><p>功能要扩展，软件又不能修改，似乎是自相矛盾的，怎样才能做到不修改代码和模块，却能实现需求变更呢？</p><!-- [[[read_end]]] --><h2>一个违反开闭原则的例子</h2><p>在开始讨论前，让我们先看一个反面的例子。</p><p>假设我们需要设计一个可以通过按钮拨号的电话，核心对象是按钮和拨号器。那么简单的设计可能是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/b4/5f91ab1ced961a153852186a76e1e9b4.jpg?wh=2800*488\" alt=\"\"></p><p>按钮类关联一个拨号器类，当按钮按下的时候，调用拨号器相关的方法。代码是这样的：</p><pre><code>public class Button {\n    public final static int SEND_BUTTON = -99;\n\n    private Dialer          dialer;\n    private int             token;\n\n    public Button(int token, Dialer dialer) {\n        this.token = token;\n        this.dialer = dialer;\n    }\n\n    public void press() {\n        switch (token) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n                dialer.enterDigit(token);\n                break;\n            case SEND_BUTTON:\n                dialer.dial();\n                break;\n            default:\n                throw new UnsupportedOperationException(&quot;unknown button pressed: token=&quot; + token);\n        }\n    }\n}\n</code></pre><pre><code>public class Dialer {\n    public void enterDigit(int digit) {\n        System.out.println(&quot;enter digit: &quot; + digit);\n    }\n\n    public void dial() {\n        System.out.println(&quot;dialing...&quot;);\n    }\n}\n</code></pre><p>按钮在创建的时候可以创建数字按钮或者发送按钮，执行按钮的press()方法的时候，会调用拨号器Dialer的相关方法。这个代码能够正常运行，完成需求，设计似乎也没什么问题。</p><p>这样的代码我们司空见惯，但是它的设计违反了开闭原则：当我们想要增加按钮类型的时候，比如，当我们需要按钮支持星号（*）和井号（#）的时候，我们必须修改Button类代码；当我们想要用这个按钮控制一个密码锁而不是拨号器的时候，因为按钮关联了拨号器，所以依然要修改Button类代码；当我们想要按钮控制多个设备的时候，还是要修改Button类代码。</p><p>似乎对Button类做任何的功能扩展，都要修改Button类，这显然违反了开闭原则：对功能扩展是开放的，对代码修改是关闭的。</p><p>违反开闭原则的后果是，这个Button类非常僵硬，当我们想要进行任何需求变更的时候，都必须要修改代码。同时我们需要注意，大段的switch/case语句是非常脆弱的，当需要增加新的按钮类型的时候，需要非常谨慎地在这段代码中找到合适的位置，稍不小心就可能出现bug。粗暴一点说，<strong>当我们在代码中看到else或者switch/case关键字的时候，基本可以判断违反开闭原则了</strong>。</p><p>而且，这个Button类也是难以复用的，Button类强耦合了一个Dialer类，在脆弱的switch/case代码段耦合调用了Dialer的方法，即使Button类自身也将各种按钮类型耦合在一起，当我想复用这个Button类的时候，不管我需不需要一个Send按钮，Button类都自带了这个功能。</p><p>所以，这样的设计不要说不修改代码就能实现功能扩展，即使我们想修改代码进行功能扩展，里面也很脆弱，稍不留心就掉到坑里了。这个时候你再回头审视Button的设计，是不是就感觉到了代码里面腐坏的味道，如果让你接手维护这些代码实现需求变更，是不是头疼难受？</p><p>很多设计开始看并没有什么问题，如果软件开发出来永远也不需要修改，也许怎么设计都可以，但是当需求变更来的时候，就会发现各种僵硬、脆弱。所以设计的优劣需要放入需求变更的场景中考察。当需求变更时发现当前设计的腐坏，就要及时进行重构，保持设计的强壮和代码的干净。</p><h2>使用策略模式实现开闭原则</h2><p>设计模式中很多模式其实都是用来解决软件的扩展性问题的，也是符合开闭原则的。我们用<strong>策略模式</strong>对上面的例子重新进行设计。</p><p><img src=\"https://static001.geekbang.org/resource/image/6y/f1/6yy9acfbacbe2bdae7d5a9111ea7cdf1.jpg?wh=2800*1295\" alt=\"\"></p><p>我们在Button和Dialer之间增加了一个抽象接口ButtonServer，Button依赖ButtonServer，而Dialer实现ButtonServer。</p><p>当Button按下的时候，就调用ButtonServer的buttonPressed方法，事实上是调用Dialer实现的buttonPressed方法，这样既完成了Button按下的时候执行Dialer方法的需求，又不会使Button依赖Dialer。Button可以扩展复用到其他需要使用Button的场景，任何实现ButtonServer的类，比如密码锁，都可以使用Button，而不需要对Button代码进行任何修改。</p><p>而且Button也不需要switch/case代码段去判断当前按钮类型，只需要将按钮类型token传递给ButtonServer就可以了，这样增加新的按钮类型的时候就不需要修改Button代码了。</p><p>策略模式是一种行为模式，多个策略实现同一个策略接口，编程的时候client程序依赖策略接口，运行期根据不同上下文向client程序传入不同的策略实现。</p><p>在我们这个场景中，client程序就是Button，策略就是需要用Button控制的目标设备，拨号器、密码锁等等，ButtonServer就是策略接口。通过使用策略模式，我们使Button类实现了开闭原则。</p><h2>使用适配器模式实现开闭原则</h2><p>Button符合开闭原则了，但是Dialer又不符合开闭原则了，因为Dialer要实现ButtonServer接口，根据参数token决定执行enterDigit方法还是dial方法，又需要if/else或者switch/case，不符合开闭原则。</p><p>那怎么办？</p><p>这种情况可以使用<strong>适配器模式</strong>进行设计。适配器模式是一种结构模式，用于将两个不匹配的接口适配起来，使其能够正常工作。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/6e/5c210d3315a5b54e7652a5c3d02fd16e.jpg?wh=2800*1718\" alt=\"\"></p><p>不要由Dialer类直接实现ButtonServer接口，而是增加两个适配器DigitButtonDialerAdapter、SendButtonDialerAdapter，由适配器实现ButtonServer接口，在适配器的buttonPressed方法中调用Dialer的enterDigit方法和dial方法，而Dialer类保持不变，Dialer类实现开闭原则。</p><p>在我们这个场景中，Button需要调用的接口是buttonPressed，和Dialer的方法不匹配，如何在不修改Dialer代码的前提下，使Button能够调用Dialer代码？就是靠适配器，适配器DigitButtonDialerAdapter和SendButtonDialerAdapter实现了ButtonServer接口，使Button能够调用自己，并在自己的buttonPressed方法中调用Dialer的方法，适配了Dialer。</p><h2>使用观察者模式实现开闭原则</h2><p>通过策略模式和适配器模式，我们使Button和Dialer都符合了开闭原则。但是如果要求能够用一个按钮控制多个设备，比如按钮按下进行拨号的同时，还需要扬声器根据不同按钮发出不同声音，将来还需要根据不同按钮点亮不同颜色的灯。按照当前设计，可能需要在适配器中调用多个设备，增加设备要修改适配器代码，又不符合开闭原则了。</p><p>怎么办？</p><p>这种情况可以用<strong>观察者模式</strong>进行设计：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/a5/2d48d29a74b12d65f102a3b46026eaa5.jpg?wh=2800*1629\" alt=\"\"></p><p>这里，ButtonServer被改名为ButtonListener，表示这是一个监听者接口，其实这个改名不重要，仅仅是为了便于识别。因为接口方法buttonPressed不变，ButtonListener和ButtonServer本质上是一样的。</p><p>重要的是在Button类里增加了成员变量List<buttonlistener>和成员方法addListener。通过addListener，我们可以添加多个需要观察按钮按下事件的监听者实现，当按钮需要控制新设备的时候，只需要将实现了ButtonListener的设备实现添加到Button的List列表就可以了。</buttonlistener></p><p>Button代码：</p><pre><code>public class Button {\n    private List&lt;ButtonListener&gt; listeners;\n\n    public Button() {\n        this.listeners = new LinkedList&lt;ButtonListener&gt;();\n    }\n\n    public void addListener(ButtonListener listener) {\n        assert listener != null;\n        listeners.add(listener);\n    }\n\n    public void press() {\n        for (ButtonListener listener : listeners) {\n            listener.buttonPressed();\n        }\n    }\n}\n</code></pre><p>Dialer代码和原始设计一样，如果我们需要将Button和Dialer组合成一个电话，Phone代码如下：</p><pre><code>public class Phone {\n    private Dialer   dialer;\n    private Button[] digitButtons;\n    private Button   sendButton;\n\n    public Phone() {\n        dialer = new Dialer();\n        digitButtons = new Button[10];\n        for (int i = 0; i &lt; digitButtons.length; i++) {\n            digitButtons[i] = new Button();\n            final int digit = i;\n            digitButtons[i].addListener(new ButtonListener() {\n                public void buttonPressed() {\n                    dialer.enterDigit(digit);\n                }\n            });\n        }\n        sendButton = new Button();\n        sendButton.addListener(new ButtonListener() {\n            public void buttonPressed() {\n                dialer.dial();\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        Phone phone = new Phone();\n        phone.digitButtons[9].press();\n        phone.digitButtons[1].press();\n        phone.digitButtons[1].press();\n        phone.sendButton.press();\n    }\n}\n</code></pre><p>观察者模式是一种行为模式，解决一对多的对象依赖关系，将被观察者对象的行为通知到多个观察者，也就是监听者对象。</p><p>在我们这个场景中，Button是被观察者，目标设备拨号器、密码锁等是观察者。被观察者和观察者通过Listener接口解耦合，观察者（的适配器）通过调用被观察者的addListener方法将自己添加到观察列表，当观察行为发生时，被观察者会逐个遍历Listener List，通知观察者。</p><h2>使用模板方法模式实现开闭原则</h2><p>如果业务要求按下按钮的时候，除了控制设备，按钮本身还需要执行一些操作，完成一些成员变量的状态更改，不同按钮类型进行的操作和记录状态各不相同。按照当前设计可能又要在Button的press方法中增加switch/case了。</p><p>怎么办？</p><p>这种情况可以用<strong>模板方法模式</strong>进行设计：</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/d7/d0c8c1379b2e5a7f124d20cf33b956d7.jpg?wh=2800*649\" alt=\"\"></p><p>在Button类中定义抽象方法onPress，具体类型的按钮，比如SendButton实现这个方法。Button类中增加抽象方法onPress，并在press方法中调用onPress方法：</p><pre><code>abstract void onPress();\n\npublic void press() {\n     onPress();\n     for (ButtonListener listener : listeners) {\n         listener.buttonPressed();\n     }\n}\n</code></pre><p>所谓模板方法模式，就是在父类中用抽象方法定义计算的骨架和过程，而抽象方法的实现则留在子类中。</p><p>在我们这个例子中，press方法就是模板，press方法除了调用抽象方法onPress，还执行通知监听者列表的操作，这些抽象方法和具体操作共同构成了模板。而在子类SendButton中实现这个抽象方法，在这个方法中修改状态，完成自己类型特有的操作，这就是模板方法模式。</p><p>通过模板方法模式，每个子类可以定义自己在press执行时的状态操作，无需修改Button类，实现了开闭原则。</p><h2>小结</h2><p><strong>实现开闭原则的关键是抽象</strong>。当一个模块依赖的是一个抽象接口的时候，就可以随意对这个抽象接口进行扩展，这个时候，不需要对现有代码进行任何修改，利用接口的多态性，通过增加一个新实现该接口的实现类，就能完成需求变更。不同场景进行扩展的方式是不同的，这时候就会产生不同的设计模式，大部分的设计模式都是用来解决扩展的灵活性问题的。</p><p>开闭原则可以说是软件设计原则的原则，是软件设计的核心原则，其他的设计原则更偏向技术性，具有技术性的指导意义，而开闭原则是方向性的，在软件设计的过程中，应该时刻以开闭原则指导、审视自己的设计：当需求变更的时候，现在的设计能否不修改代码就可以实现功能的扩展？如果不是，那么就应该进一步使用其他的设计原则和设计模式去重新设计。</p><p>更多的设计原则和设计模式，我将在后面陆续讲解。</p><h2>思考题</h2><p>我在观察者模式小节展示的Phone代码示例中，并没有显式定义DigitButtonDialerAdapter和SendButtonDialerAdapter这两个适配器类，但它们是存在的。在哪里呢？</p><p>欢迎在评论区写下你的思考，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":162081,"user_name":"山猫","can_delete":false,"product_type":"c1","uid":1466682,"ip_address":"","ucode":"004F622AEDA906","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","comment_is_top":false,"comment_ctime":1576459231,"is_pvip":false,"replies":[{"id":"61700","content":"是否要使用各种设计模式设计一个非常灵活的程序，主要是看你的需求场景，而不是看项目的阶段。<br><br>如果你的场景就是需要这么灵活，就是要各种复用，应对各种变更，那么你一开始就应该这样设计。<br><br>如果你的场景根本不需要一个可复用的button，那么就不需要这样设计。<br><br>关键还是看场景。<br><br>但是场景也会变化，一开始不需要复用，但是后来又需要复用了，那么在在需要复用的第一个场景，就重构代码，而不是等将来维护困难局面hold不住了再重构。<br><br>ps 如果你习惯了这种灵活的设计，你会觉得这种设计并不复杂。对于软件开发而言，复杂的永远是业务逻辑，而不是设计模式。设计模式是可重复的，可重复的东西即使看起来复杂，熟悉了就会觉得很简单。<br><br>pps 看起来复杂的设计模式就是用来解决维护困难问题的，正确使用设计模式，看起来复杂了，其实维护简单了，因为关系和边界更清晰了，你不需要在一堆强耦合的代码里搅来搅去。真正维护成本高的其实是你所谓的简单的设计，牵一发动全身，稍不注意就是各种bug。<br><br>ppps 重要的话再说一次：<br>关键还是看场景。<br><br>没有银弹，没有一种必然就是好的设计方案，能理解场景的才是真·高手。<br><br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576468776,"ip_address":"","comment_id":162081,"utype":1}],"discussion_count":2,"race_medal":0,"score":"551332273119","product_id":100040201,"comment_content":"我同意老师通过这个例子简单的描述开闭原则。但如果项目初始就对button按钮需要进行这么复杂的设计，那么这个项目后期的维护成本也是相当之高。","like_count":129,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477948,"discussion_content":"是否要使用各种设计模式设计一个非常灵活的程序，主要是看你的需求场景，而不是看项目的阶段。\n\n如果你的场景就是需要这么灵活，就是要各种复用，应对各种变更，那么你一开始就应该这样设计。\n\n如果你的场景根本不需要一个可复用的button，那么就不需要这样设计。\n\n关键还是看场景。\n\n但是场景也会变化，一开始不需要复用，但是后来又需要复用了，那么在在需要复用的第一个场景，就重构代码，而不是等将来维护困难局面hold不住了再重构。\n\nps 如果你习惯了这种灵活的设计，你会觉得这种设计并不复杂。对于软件开发而言，复杂的永远是业务逻辑，而不是设计模式。设计模式是可重复的，可重复的东西即使看起来复杂，熟悉了就会觉得很简单。\n\npps 看起来复杂的设计模式就是用来解决维护困难问题的，正确使用设计模式，看起来复杂了，其实维护简单了，因为关系和边界更清晰了，你不需要在一堆强耦合的代码里搅来搅去。真正维护成本高的其实是你所谓的简单的设计，牵一发动全身，稍不注意就是各种bug。\n\nppps 重要的话再说一次：\n关键还是看场景。\n\n没有银弹，没有一种必然就是好的设计方案，能理解场景的才是真·高手。\n\n","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1576468776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536042,"discussion_content":"老师的回复太精辟了。真正复杂的是业务逻辑，而不是设计模式！如果公司的产品就是非常单一，未来变化不大，就不用设计得太复杂。所以，需要做到何种程度的设计，完全是根据业务需求决定的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638657731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":477948,"ip_address":""},"score":536042,"extra":""}]}]},{"had_liked":false,"id":162672,"user_name":"陈小龙 Cheney","can_delete":false,"product_type":"c1","uid":1328689,"ip_address":"","ucode":"4B721FE4DDB2F4","user_header":"https://static001.geekbang.org/account/avatar/00/14/46/31/cb061c09.jpg","comment_is_top":false,"comment_ctime":1576576150,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"96065856662","product_id":100040201,"comment_content":"希望老师给出几个阶段的代码. 方便对着代码对比学习. 直接看文字感觉抽象模糊了.","like_count":22,"discussions":[{"author":{"id":1142025,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","nickname":"任鑫","note":"","ucode":"9803EB15B634C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378593,"discussion_content":"相关代码到处都有，得学会自己找这种容易的答案。设计模式的书我也看过，但是是这个专栏让我真的理解了设计原则和设计模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623297554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308366,"discussion_content":"@QQ怪 给出的代码比较完整 https://github.com/xqq1994/DesignPatternLearn","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600930722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737874,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6dnxU0KTMG0s7ekh7cBSppqA7S2PaHXVUZiaBlKXvA8m69AraMo9g7LxUREIKwdN4POXhFdibGRPst4g5FCicyWwg/132","nickname":"Geek_c66294","note":"","ucode":"CF2011E5AD578E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291581,"discussion_content":"同意  推你上墙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594875587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163513,"user_name":"山猫","can_delete":false,"product_type":"c1","uid":1466682,"ip_address":"","ucode":"004F622AEDA906","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","comment_is_top":false,"comment_ctime":1576735878,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"78886147206","product_id":100040201,"comment_content":"没有想到我的评论老师会有那么多文字进行评论，也没有想到会有那么多赞。<br><br>看了老师的评论，其实我也知道这个和所处的场景有很大关系。<br><br>在项目开发过程初期，有很多东西是想不到的。譬如一个登陆页面，<br><br>第一版可能就是简单的账号口令登陆，<br>第二版可能就需要加上第三方登陆，<br>再往后可能需要分类型登陆，<br>在过一段时间可能有客户端的登陆。<br><br>还有一种可能就是这个项目真的就这一个登陆，其他的登录方式又采取微服务的办法。<br><br>有时候真的是看每个工程师的经验，还有对客户的熟悉程度。做开发好多年了，过度开发我也写过，预估不足我也写过。<br><br>需求每天都在变，虽然设计模式能够照顾到大多数的需求变化，但总有坑死人的客户和打不死的需求。<br><br>祝每个开发者好好学习技术，祝每个开发者都不要遇到坑死人的项目。<br><br>疯了，累了，痛了，人间喜剧@_@","like_count":18,"discussions":[{"author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95009,"discussion_content":"所以经验很重要啊，就要在初期较多地设想到可能的变化，这样就不会面向功能编程，而是面向问题领域编程。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577006333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162712,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1576579838,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"66001089278","product_id":100040201,"comment_content":"&#47;*适配器模式*&#47;<br>public class Button {<br>    private ButtonServer    server;<br>    private int             token;<br><br>    public Button(int token, ButtonServer server) {<br>        this.token = token;<br>        this.server = server;<br>    }<br><br>    public void press() {<br>        server.buttonPressed(token);<br>    }<br>}<br><br>public interface ButtonServer {<br>    void buttonPressed(int token);<br>}<br><br>public class Dialer {<br>    public final static int SEND_BUTTON = -99;<br><br>    public void enterDigit(int digit) {<br>        System.out.println(&quot;enter digit: &quot; + digit);<br>    }<br><br>    public void dial() {<br>        System.out.println(&quot;dialing...&quot;);<br>    }<br>}<br><br>public class DigitButtonDialerAdapter implements ButtonServer {<br>    private Dialer dailer = new Dialer();<br><br>    @Override<br>    public void buttonPressed(int token) {<br>        dailer.enterDigit(token);<br>    }<br>}<br><br>public class SendButtonDialerAdapter implements ButtonServer {<br>    private Dialer dialer = new Dialer();<br><br>    @Override<br>    public void buttonPressed(int token) {<br>        dialer.dial();<br>    }<br>}","like_count":15,"discussions":[{"author":{"id":1529209,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIp8ibcRP0ZCBL4zJgTVj2Micb1tuUBBDDKOg7zu1uNXBkMsAFfVeXVnERsjFa2sKbTu63Jfs2cMewg/132","nickname":"Geek_c986ae","note":"","ucode":"0A36EEDAFEEBF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294162,"discussion_content":"我也有这个疑惑，就算用适配器模式，那token判断放在哪里了？老师为什么画龙不点睛？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595814313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337753,"avatar":"https://static001.geekbang.org/account/avatar/00/14/69/99/a817330d.jpg","nickname":"BestKF02","note":"","ucode":"74356EAB5351CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179538,"discussion_content":"看类图,Interface ButtonServer 的公开方法 void buttonPressed(） 是没得参数，你这个实现是带有参数的。我现在就对 上面的类图中，token 突然丢失感到不解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582217595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200275,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/93/dfc3c214.jpg","nickname":"肉球明晖","note":"","ucode":"E5E3CAED3A1029","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375186,"discussion_content":"dialer应该是传入的参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621504923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2285227,"avatar":"","nickname":"Geek_12c52c","note":"","ucode":"630E0A67691A48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336777,"discussion_content":"你这个显示了。错的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608696203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162221,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1576479903,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"61706022047","product_id":100040201,"comment_content":"思考题<br>匿名内部类，已经数字按钮注册的listener其实就是DigitButtonDailerAdepter适配器的实现，sendButton中注册的listener其实就是SendButtonDailerAdepter适配器的实现。","like_count":14,"discussions":[{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536044,"discussion_content":"这种解释比老师的那个图直接多了。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638661995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120348,"avatar":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","nickname":"草原上的奔跑","note":"","ucode":"D69C617F767736","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85005,"discussion_content":"匿名内部类隐式的实现了适配器的区分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576509577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166941,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1577634245,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"40232339909","product_id":100040201,"comment_content":"看了2遍，敲了一遍，https:&#47;&#47;github.com&#47;xqq1994&#47;DesignPatternLearn","like_count":9,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308367,"discussion_content":"代码很清晰，有助于理解。不过 Part 4 好像无法通过编译，\n\nPhone.java:16: error: Button is abstract; cannot be instantiated\n            digitButtons[i] = new Button();\n\n另外，Part 5 似乎与这篇专栏无关？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600930898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529209,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIp8ibcRP0ZCBL4zJgTVj2Micb1tuUBBDDKOg7zu1uNXBkMsAFfVeXVnERsjFa2sKbTu63Jfs2cMewg/132","nickname":"Geek_c986ae","note":"","ucode":"0A36EEDAFEEBF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294165,"discussion_content":"感谢分享，看了你的代码终于明白了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595814736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192995,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/23/e9268af5.jpg","nickname":"飞扬","note":"","ucode":"548A9D5955BB3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245913,"discussion_content":"感谢分享，结合你的代码明白了很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587711278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162057,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576457195,"is_pvip":false,"replies":[{"id":"61697","content":"当你准备写第一个else的时候，就说明你的代码即将陷入僵化、牢固和脆弱，而且为将来的需求变更引入了一个糟糕的“设计模式”。<br><br>如果其他人接手你的代码，他有两个选择，要么继续写更多的else以应对需求变更；要么心理暗骂一声然后重构你的代码。你希望他选择哪个？","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576467400,"ip_address":"","comment_id":162057,"utype":1}],"discussion_count":8,"race_medal":0,"score":"35936195563","product_id":100040201,"comment_content":"开闭原则是移除底层的if else，取而代之的是上层的类结构。不过，我个人以为一开始的if else, 甚至switch 也没什么不妥的，毕竟代码简单直接。引入了很多类，读代码也是负担，而且也很难预料到哪些修改是必要的。当if else数量多于一定的数目，再开始重构。 不知道李老师如何看待这种观点。","like_count":8,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477946,"discussion_content":"当你准备写第一个else的时候，就说明你的代码即将陷入僵化、牢固和脆弱，而且为将来的需求变更引入了一个糟糕的“设计模式”。\n\n如果其他人接手你的代码，他有两个选择，要么继续写更多的else以应对需求变更；要么心理暗骂一声然后重构你的代码。你希望他选择哪个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576467400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/39/9b/fc21f943.jpg","nickname":"睡浴缸的人","note":"","ucode":"AAA7476707D82F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139760,"discussion_content":"可以先留出接口啊。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579315901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593140,"avatar":"","nickname":"Paul Shan","note":"","ucode":"32D99989028284","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85638,"discussion_content":"多谢老师回答，个人以为好的代码是高内聚低耦合，实际中这两条原则经常矛盾。文中的例子，重构前是高内聚高耦合。重构之后如果没有新功能的话，耦合性度显著降低，但是内聚性也降低了，要维护的类数目也显著增加，如果那些预期的新功能没有来，或者以其他的方式来，这种修改带来的好处并不大，例如，如果修改来自于每次按键，都要发送额外用户的名字，适配器那个版本增加的类和接口反而成为负担。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576561691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1168540,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","nickname":"java小霸王","note":"","ucode":"7094BCD9F25E1E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1593140,"avatar":"","nickname":"Paul Shan","note":"","ucode":"32D99989028284","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579759,"discussion_content":"公共方法不就可以用上模板了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657676664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85638,"ip_address":""},"score":579759,"extra":""}]},{"author":{"id":1466682,"avatar":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","nickname":"山猫","note":"","ucode":"004F622AEDA906","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83704,"discussion_content":"其实我也遇到过这样的问题，如果上来就设计这样复杂的代码，其构建成本就很高。而且需求是变化的，你并不知道哪一块需要进行修改。所以我在设计代码的时候，开始总是进行基础模块的简单拆分，等到后面迭代的时候，再进行一些结构模式化的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576459052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83691,"discussion_content":"别指望他会回复你了，极客里只管卖课程，对疑问都视而不见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576458648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1007569,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5f/d1/faf32296.jpg","nickname":"pinteressante","note":"","ucode":"C17A89E655CC84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350700,"discussion_content":"确实, 作者在评论区的讨论其实是不太多的. 而有时候就是需要靠大家提问才让问题和答案更清楚. \n就我个人而言, 负责的是一些业务开发, 业务开发常常一个月以后可能就是 dead code 了, 或者就是添加一些莫名其妙的条件判断进来, 很难避免用到 else 或 switch. 所以这样讲可能有点过于绝对了.\n不是为了杠, 源码里到处可见的条件判断为什么不改成设计模式呢? 之前老师说是因为当初的开发者代码写的不好. 这个我可以接受, 但是一些优秀的项目还是随处可见的条件判断该怎么理解?\n我之前带着这个疑问问过其他的大神, 结果就被告诉我抬杠, 没正面回应了, 所以一直很好奇. 其中还包括一些源码里常见 goto  这个不是很早就不让用了么.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613983048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83691,"ip_address":""},"score":350700,"extra":""},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007569,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5f/d1/faf32296.jpg","nickname":"pinteressante","note":"","ucode":"C17A89E655CC84","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377666,"discussion_content":"尽信书则不如无书。。是这么个道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622769946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350700,"ip_address":""},"score":377666,"extra":""}]}]},{"had_liked":false,"id":173324,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1579504500,"is_pvip":false,"replies":[{"id":"67239","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1579569209,"ip_address":"","comment_id":173324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18759373684","product_id":100040201,"comment_content":"“开闭原则可以说是软件设计原则的原则，是软件设计的核心原则，其他的设计原则更偏向技术性，具有技术性的指导意义，而开闭原则是方向性的，在软件设计的过程中，应该时刻以开闭原则指导、审视自己的设计：当需求变更的时候，现在的设计能否不修改代码就可以实现功能的扩展？如果不是，那么就应该进一步使用其他的设计原则和设计模式去重新设计。”<br>读的过程中一直有这种感觉：开闭原则可能是软件设计和实现时最重要的原则；果然和老师最后的总结一样。👍","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482037,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579569209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162107,"user_name":"Jonathan Chan","can_delete":false,"product_type":"c1","uid":1433628,"ip_address":"","ucode":"7BBD27596E8366","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/1c/93e1710f.jpg","comment_is_top":false,"comment_ctime":1576462281,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461364169","product_id":100040201,"comment_content":"求老师后续给出完整代码学习！","like_count":3,"discussions":[{"author":{"id":1661704,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","nickname":"丁丁历险记","note":"","ucode":"A43829E454C067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83916,"discussion_content":"求不如自己写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576473817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312071,"user_name":"x-ray","can_delete":false,"product_type":"c1","uid":1140175,"ip_address":"","ucode":"8363F0C4D0AC0B","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/cf/326c0eea.jpg","comment_is_top":false,"comment_ctime":1631612568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10221547160","product_id":100040201,"comment_content":"老师展示的这个过程其实还是很好的，设计的程度，其实真的是和经验有关系的，很多场景具有通用性，就是这种场景的需求变化，以后大概率会出现的，这个时候就需要提前去布局去设计。这个代码里我有个疑问，就是main函数，我认为实际的场景应该是一个指令过来，是一个String字符串，而不是直接调用sendButton或者digitalButton，这样的话，这里还是免不了if else处理，当然工厂模式或者map是可以解决这个问题的","like_count":2},{"had_liked":false,"id":232338,"user_name":"Winon","can_delete":false,"product_type":"c1","uid":1080055,"ip_address":"","ucode":"17F4108B2F5D00","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/f7/24df0ff9.jpg","comment_is_top":false,"comment_ctime":1593960153,"is_pvip":false,"replies":[{"id":"85779","content":"模板方法常和策略模式结合，为各种策略实现类提供模板和公共处理逻辑。<br>充血模型也需要策略和模板。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1594002050,"ip_address":"","comment_id":232338,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10183894745","product_id":100040201,"comment_content":"请教老师，模板方法是否也是另外一种面向过程设计？是否在充血对象模型中，模板方法的使用会相对少？","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500603,"discussion_content":"模板方法常和策略模式结合，为各种策略实现类提供模板和公共处理逻辑。\n充血模型也需要策略和模板。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594002050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174203,"user_name":"yes","can_delete":false,"product_type":"c1","uid":1386201,"ip_address":"","ucode":"612BF6884ED6CC","user_header":"https://static001.geekbang.org/account/avatar/00/15/26/d9/f7e96590.jpg","comment_is_top":false,"comment_ctime":1580083944,"is_pvip":false,"replies":[{"id":"67841","content":"starButton = new Button(); <br>starButton.addListener(<br>  new ButtonListener() { <br>     public void buttonPressed() { <br>      dialer.enterDigit(STAR); <br>  } <br> }<br>);","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1580270933,"ip_address":"","comment_id":174203,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10170018536","product_id":100040201,"comment_content":"我不是想找茬，我就想知道以上的代码怎么对说好的加“*” 和“#” 开闭","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482333,"discussion_content":"starButton = new Button(); \nstarButton.addListener(\n  new ButtonListener() { \n     public void buttonPressed() { \n      dialer.enterDigit(STAR); \n  } \n }\n);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580270933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219591,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1161738,"ip_address":"","ucode":"7275E7F5756D64","user_header":"https://static001.geekbang.org/account/avatar/00/11/ba/0a/fed7d928.jpg","comment_is_top":false,"comment_ctime":1590047686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885014982","product_id":100040201,"comment_content":"【 typescript实现(二)】<br>&#47;**<br> * 一个电话应用<br> * 有一系列的数字按钮<br> * 有一个拨打按钮<br> *&#47;<br>class Phone {<br>  private dialer: Dialer;<br>  public digitButtons: Button[];<br>  public sendButton: Button;<br><br>  constructor() {<br>    this.dialer = new Dialer();<br>    this.digitButtons = new Array(10);<br><br>    for (let i = 0; i &lt; this.digitButtons.length; i++) {<br>      this.digitButtons[i] = new MyButton(i);<br>      this.digitButtons[i].addListener(<br>        new DigitButtonDailerAdepter(this.dialer, i),<br>      );<br>    }<br><br>    this.sendButton = new MyButton(99); &#47;&#47; 假设拨打是99<br>    this.sendButton.addListener(new SendButtonDailerAdepter(this.dialer));<br>  }<br>}<br><br>&#47;**<br> * 启动函数<br> *&#47;<br>function start() {<br>  const phone = new Phone();<br>  phone.digitButtons[9].press();<br>  phone.digitButtons[1].press();<br>  phone.digitButtons[1].press();<br>  phone.sendButton.press();<br>}<br><br>start();<br><br>&#47;&#47; MyButton-onPress<br>&#47;&#47; enter digit: 9<br>&#47;&#47; MyButton-onPress<br>&#47;&#47; enter digit: 1<br>&#47;&#47; MyButton-onPress<br>&#47;&#47; enter digit: 1<br>&#47;&#47; MyButton-onPress<br>&#47;&#47; dialing...<br>","like_count":1},{"had_liked":false,"id":219590,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1161738,"ip_address":"","ucode":"7275E7F5756D64","user_header":"https://static001.geekbang.org/account/avatar/00/11/ba/0a/fed7d928.jpg","comment_is_top":false,"comment_ctime":1590047669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885014965","product_id":100040201,"comment_content":"【 typescript实现(一)】<br>&#47;&#47; 拨号器<br>class Dialer {<br>  public enterDigit(digit: number) {<br>    console.log(&#39;enter digit: &#39; + digit);<br>  }<br><br>  public dial() {<br>    console.log(&#39;dialing...&#39;);<br>  }<br>}<br><br>abstract class ButtonLister {<br>  abstract buttonPressed(token: number): void;<br>}<br><br>&#47;&#47; 新增两个适配器，适配器去实现接口，然后调用Dialer；<br>class DigitButtonDailerAdepter implements ButtonLister {<br>  private dialer: Dialer;<br>  private token: number;<br>  constructor(dialer: Dialer, token: number) {<br>    &#47;&#47; super();<br>    this.dialer = dialer;<br>    this.token = token;<br>  }<br>  buttonPressed() {<br>    this.dialer.enterDigit(this.token);<br>  }<br>}<br><br>class SendButtonDailerAdepter implements ButtonLister {<br>  private dialer: Dialer;<br>  constructor(dialer: Dialer) {<br>    this.dialer = dialer;<br>  }<br>  buttonPressed() {<br>    this.dialer.dial();<br>  }<br>}<br><br>abstract class Button {<br>  private listeners: ButtonLister[] = [];<br>  private token: number;<br><br>  constructor(token: number) {<br>    this.listeners = [];<br>    this.token = token;<br>  }<br><br>  addListener(listener: ButtonLister) {<br>    this.listeners.push(listener);<br>  }<br><br>  abstract onPress(): void;<br><br>  public press(): void {<br>    this.onPress();<br>    this.listeners.forEach((listener) =&gt; {<br>      listener.buttonPressed(this.token);<br>    });<br>  }<br>}<br>&#47;&#47; 利用多态实现不同的onPress效果<br>class MyButton extends Button {<br>  onPress() {<br>    console.log(&#39;MyButton-onPress&#39;);<br>  }<br>}","like_count":1},{"had_liked":false,"id":164681,"user_name":"张希音","can_delete":false,"product_type":"c1","uid":1311065,"ip_address":"","ucode":"224D5FE01E14B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/59/b2267eaa.jpg","comment_is_top":false,"comment_ctime":1577071501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872038797","product_id":100040201,"comment_content":"以前感觉面试的时候问设计模式都是为了面试而设计的问题，现在经过这么一分析，终于明白了设计模式的重要性，是时候去隔壁补补设计模式的知识漏洞了","like_count":1},{"had_liked":false,"id":163634,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1576757836,"is_pvip":false,"replies":[{"id":"62295","content":"Adapter不需要判断，请看思考题","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576813179,"ip_address":"","comment_id":163634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871725132","product_id":100040201,"comment_content":"有一点想不通，在adapter里面还是需要判断呀？这并没有 达到老师说的 避免做switch&#47;if判断的效果，而且判断的逻辑一点不少，还无端弄出这么多类，有必要非得这么做吗？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478479,"discussion_content":"Adapter不需要判断，请看思考题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576813179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162054,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576456819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871424115","product_id":100040201,"comment_content":"思考题<br>Adapter 是在继承接口的时候调用了dialer不同的函数实现了，没有显式的Adapter。","like_count":1},{"had_liked":false,"id":351285,"user_name":"java小霸王","can_delete":false,"product_type":"c1","uid":1168540,"ip_address":"","ucode":"7094BCD9F25E1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","comment_is_top":false,"comment_ctime":1657677178,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657677178","product_id":100040201,"comment_content":"开闭原则，就是对修改关闭，对扩展开放，扩展就是通过新增接口的实现，对if else功能的分支要特别注意怪味道","like_count":0},{"had_liked":false,"id":338482,"user_name":"Geek_e54f10","can_delete":false,"product_type":"c1","uid":2868155,"ip_address":"","ucode":"93C9CFA1837EBA","user_header":"","comment_is_top":false,"comment_ctime":1647518760,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647518760","product_id":100040201,"comment_content":"这个章节干货满满","like_count":0},{"had_liked":false,"id":314998,"user_name":"张闯","can_delete":false,"product_type":"c1","uid":1090513,"ip_address":"","ucode":"D5AD46A8DD6FB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/d1/a30a4d06.jpg","comment_is_top":false,"comment_ctime":1633653819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633653819","product_id":100040201,"comment_content":"给ButtonListener接口加上@FunctionalInterface注解，就是另一种感觉了。","like_count":0},{"had_liked":false,"id":297072,"user_name":"任鑫","can_delete":false,"product_type":"c1","uid":1142025,"ip_address":"","ucode":"9803EB15B634C3","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","comment_is_top":false,"comment_ctime":1623298148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623298148","product_id":100040201,"comment_content":"发现部分同学的一些问题：<br>1. 希望在这样一个篇幅有限的地方得到所有的答案，这不现实<br>2. 一些技术性的比如代码怎么写，可以很容易的在搜索引擎上找到，但你看过干巴巴的代码很难理解其原则和场景<br>3. 任何理论的探讨有其范围限制，我们必须理解这个大前提才能从中获益<br>4. 现实和理想有差距，但是并不冲突，设计模式并不能干掉每一个if-else，也不需要干掉每一个if-else，在这一点上杠的同学其实自己也该也清楚<br>","like_count":1},{"had_liked":false,"id":287387,"user_name":"海风","can_delete":false,"product_type":"c1","uid":1465863,"ip_address":"","ucode":"38BA513F7AEC8C","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/07/61a4cb92.jpg","comment_is_top":false,"comment_ctime":1617928184,"is_pvip":false,"replies":[{"id":"104526","content":"谢谢~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1618195870,"ip_address":"","comment_id":287387,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1617928184","product_id":100040201,"comment_content":"老师的风格像酒剑仙，我们目标做李逍遥，悟。","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518284,"discussion_content":"谢谢~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618195870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284055,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1616052306,"is_pvip":false,"replies":[{"id":"103204","content":"“不要过早优化”是说，为潜在的或即将到来的问题而优化；设计时要遵循“开闭原则”是说，需求变化一定会到来，功能一定会扩展，所以要遵循各种基本设计原则。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1616379599,"ip_address":"","comment_id":284055,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616052306","product_id":100040201,"comment_content":"老师，怎么理解“不要过早优化”这句话呢？在设计的早期就利用设计模式实现软件的“开闭原则”有什么关系呢","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517215,"discussion_content":"“不要过早优化”是说，为潜在的或即将到来的问题而优化；设计时要遵循“开闭原则”是说，需求变化一定会到来，功能一定会扩展，所以要遵循各种基本设计原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616379599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250093,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1600931561,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1600931561","product_id":100040201,"comment_content":"其实我倒是欢迎变更的，能够理解用户的需求会不断变化，但是确实也没有什么好的应对变更的办法，勤能补拙，或者说是用战术的勤奋弥补战略的懒惰。<br><br>大概 15 年前就知道了开闭原则，那个时候还是在学习 C#，不过在项目中似乎没什么机会实践。<br><br>文中的电话的例子挺好的，用一个可以拓展的例子，展示了僵硬的代码，然后采用策略模式、适配器模式、观察者模式、模板方法模式循序渐进的进行了说明。<br><br>看了之后，有一点疑惑，这四个设计模式并不是由简单到复杂，越到后面越好的意思，也就是说并不是一上来就要模板方法，而是应该按照自己的需要灵活选择，不知道理解的是否正确。<br><br>留言里面 @QQ怪 同学给出了很好的代码示例，我看文章的时候也敲了一遍，不过没那么整齐。<br><br>思考题并不难，两个 Adapter 都是在 addListener 的时候采用匿名函数的方式实现了。不过我感觉这种方法有点抽象，不够直观。也可能是平时用的少的缘故。","like_count":0,"discussions":[{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536043,"discussion_content":"倒是应该找个聪明的产品经理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638661104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248968,"user_name":"席席","can_delete":false,"product_type":"c1","uid":1591399,"ip_address":"","ucode":"656377E29D4F76","user_header":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","comment_is_top":false,"comment_ctime":1600392813,"is_pvip":false,"replies":[{"id":"91385","content":"用一个Factory返回策略类，把if的条件当做参数传给Factory，就不需要if了。<br><br>或者用一个map记录&lt;if条件变量，策略对象&gt;，从map中获得策略，也不需要if了。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1600416424,"ip_address":"","comment_id":248968,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1600392813","product_id":100040201,"comment_content":"李老师，我尝试用上面的设计模式套用到我之前写的1400行代码中，策略模式的确分开了最开始的if判断，分成了三个类。<br>  但我在需要使用他们的时候，又不得不使用if判断代码是否属于这三个类中的某一个，我并没有消灭if条件，但是我感觉这么用挺好的！<br>  还有我怀疑if真的能被消灭嘛？目前来讲，我只能做到拆分，无法消灭if","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505788,"discussion_content":"用一个Factory返回策略类，把if的条件当做参数传给Factory，就不需要if了。\n\n或者用一个map记录&amp;lt;if条件变量，策略对象&amp;gt;，从map中获得策略，也不需要if了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600416424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142025,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","nickname":"任鑫","note":"","ucode":"9803EB15B634C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378595,"discussion_content":"我经常使用枚举来绑定条件变量和策略对象，此外dubbo这样的框架中SPI机制配置文件中的properties也正是这样一种思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623298338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236712,"user_name":"梁小猫，喵","can_delete":false,"product_type":"c1","uid":1264424,"ip_address":"","ucode":"796C9272E896B9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/28/464fc03e.jpg","comment_is_top":false,"comment_ctime":1595507592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595507592","product_id":100040201,"comment_content":"这个决策模式的具体代码如何实现，<br>1.Dialer实现ButtonServer，表明Server类是个接口？<br>2.Button不和Dialer类进行直接交互，而是和ButtonServer有关联，这个要如何实现？<br>李老师，帮忙看下，是否是我理解有误，多谢","like_count":0},{"had_liked":false,"id":209759,"user_name":"hz","can_delete":false,"product_type":"c1","uid":1944260,"ip_address":"","ucode":"51708FA35B3F49","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/05nEWFAM4iaVR6Vk9R7lJyT2RLeXuE2mBPBjpn0uXxmwL9C8DnN8lITsmfbBAVvPicp2zvtnhQn5XiaGmSbKdA5Nw/132","comment_is_top":false,"comment_ctime":1587609502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587609502","product_id":100040201,"comment_content":"面对实际的业务需求，一下子真不知道怎么用设计模式来写代码~","like_count":0},{"had_liked":false,"id":202429,"user_name":"米亮","can_delete":false,"product_type":"c1","uid":1125521,"ip_address":"","ucode":"CA9C0AF24AD236","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/91/06270b06.jpg","comment_is_top":false,"comment_ctime":1585987581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585987581","product_id":100040201,"comment_content":"受益匪浅，虽然。。。","like_count":0},{"had_liked":false,"id":196474,"user_name":"非同凡想","can_delete":false,"product_type":"c1","uid":1934969,"ip_address":"","ucode":"713FD449A49D5A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","comment_is_top":false,"comment_ctime":1585284634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585284634","product_id":100040201,"comment_content":"到了，开闭原则是原则的原则，方向性的，其他的设计原则是策略性的","like_count":0},{"had_liked":false,"id":180249,"user_name":"BestKF02","can_delete":false,"product_type":"c1","uid":1337753,"ip_address":"","ucode":"74356EAB5351CE","user_header":"https://static001.geekbang.org/account/avatar/00/14/69/99/a817330d.jpg","comment_is_top":false,"comment_ctime":1582217252,"is_pvip":false,"replies":[{"id":"70018","content":"其实就是思考题的问题，建议参考代码思考一下","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1582265414,"ip_address":"","comment_id":180249,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582217252","product_id":100040201,"comment_content":"有个问题： Button在优化到Adapter适配器的时候，token 怎么就不见了。没得token 怎么知道是取 DigitButtonDailerAdapter 还是  SendButtonDailerAdapter，这个片段突然缺失；老师有解答的地方吗？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484584,"discussion_content":"其实就是思考题的问题，建议参考代码思考一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582265414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172962,"user_name":"InfoQ_e077cb303519","can_delete":false,"product_type":"c1","uid":1390669,"ip_address":"","ucode":"2CCA309DB2EF46","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAK6F4BFT5ewhJEeZrjmRx5HxP8tvnNpJcpLlotHiadp0s6aL3d7LfMHEuQP6tibu80wUy8micVu4oQ/132","comment_is_top":false,"comment_ctime":1579397188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579397188","product_id":100040201,"comment_content":"看到评论突然想说一下，不要舍本逐末，直接写逻辑固然快捷，但是当业务变更和扩展时，或者有人维护你的代码时，比骂人还难受的感觉，就是恶心想吐","like_count":0},{"had_liked":false,"id":172803,"user_name":"睡浴缸的人","can_delete":false,"product_type":"c1","uid":1194395,"ip_address":"","ucode":"AAA7476707D82F","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/9b/fc21f943.jpg","comment_is_top":false,"comment_ctime":1579316361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579316361","product_id":100040201,"comment_content":"封装变化点，这个真的就要看工程师的经验和抽象能力了。所幸，目前正在向这方面努力~","like_count":0},{"had_liked":false,"id":167425,"user_name":"TH","can_delete":false,"product_type":"c1","uid":1053413,"ip_address":"","ucode":"C5EA20546DC09C","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/e5/592d9324.jpg","comment_is_top":false,"comment_ctime":1577791568,"is_pvip":true,"replies":[{"id":"65034","content":"不同button按下调用不同的adapter，参考文中代码。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1577862602,"ip_address":"","comment_id":167425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577791568","product_id":100040201,"comment_content":"适配器的例子中使用了两个适配器类，这两个类都会接收任意buttonPressed吗？还是说由谁来控制具体使用哪个适配器？可不可以把两个适配器合为一个呢？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479862,"discussion_content":"不同button按下调用不同的adapter，参考文中代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577862602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166937,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1577633744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577633744","product_id":100040201,"comment_content":"课后问题：<br>两个适配器全在Phone的构造函数中以匿名内部类形式存在","like_count":0},{"had_liked":false,"id":164691,"user_name":"灰灰","can_delete":false,"product_type":"c1","uid":1122397,"ip_address":"","ucode":"907A2FD339E158","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/5d/69170b96.jpg","comment_is_top":false,"comment_ctime":1577073083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577073083","product_id":100040201,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":163700,"user_name":"诗泽","can_delete":false,"product_type":"c1","uid":1031865,"ip_address":"","ucode":"F28BE01C3FD12F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/b9/f2481c2c.jpg","comment_is_top":false,"comment_ctime":1576769302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576769302","product_id":100040201,"comment_content":"通俗的说就是，软件功能可以扩展，但是软件实体不可以被修改<br><br>如果这个phone 之前是没有摄像头，现在加了一个摄像头那phone 这个实体要不要修改呢？🤔","like_count":0},{"had_liked":false,"id":163065,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1576651047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576651047","product_id":100040201,"comment_content":"依葫芦画瓢，应用观察者模式写了一个密码箱类<br>public class CodeCase {<br>    private Dialer dialer;<br>    private Button[] digitButtons;<br>    private Button lockButton;<br><br>    public CodeCase() {<br>        dialer = new Dialer();<br>        digitButtons = new Button[10];<br>        for (int i = 0; i &lt; digitButtons.length; i++) {<br>            final int digit = i;<br>            digitButtons[i] = new Button();<br>            digitButtons[i].addListener(() -&gt; dialer.enterDigit(digit));<br>        }<br>        lockButton = new Button();<br>        lockButton.addListener(() -&gt; dialer.lock());<br>    }<br><br>    public static void main(String[] args) {<br>        CodeCase codeCase = new CodeCase();<br>        codeCase.digitButtons[1].press();<br>        codeCase.digitButtons[2].press();<br>        codeCase.digitButtons[3].press();<br>        codeCase.digitButtons[4].press();<br>        codeCase.lockButton.press();<br>    }<br>}","like_count":0},{"had_liked":false,"id":162569,"user_name":"草原上的奔跑","can_delete":false,"product_type":"c1","uid":1120348,"ip_address":"","ucode":"D69C617F767736","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","comment_is_top":false,"comment_ctime":1576556930,"is_pvip":false,"replies":[{"id":"61851","content":"组件就是jar，dll这些。子系统和系统就是可运行的完整程序，一个或者多个war。<br><br>不管是什么架构图，只要你觉得有助于你描述你的架构设计，都可以加入设计文档中。<br><br><br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576567295,"ip_address":"","comment_id":162569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576556930","product_id":100040201,"comment_content":"想问下老师，在写设计文档的时候，系统，子系统，组件，分别映射到代码的什么层面(类很好理解)；还有老师的设计文档中没有业务架构图和技术架构图，老师对这两种架构图是怎么理解的，设计文档中需要加入吗？希望老师给予解答","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478088,"discussion_content":"组件就是jar，dll这些。子系统和系统就是可运行的完整程序，一个或者多个war。\n\n不管是什么架构图，只要你觉得有助于你描述你的架构设计，都可以加入设计文档中。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576567295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162458,"user_name":"鹏酱","can_delete":false,"product_type":"c1","uid":1528879,"ip_address":"","ucode":"CA87B7CFD1BF7A","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/2f/429c568d.jpg","comment_is_top":false,"comment_ctime":1576541705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576541705","product_id":100040201,"comment_content":"Phone的构造函数里了","like_count":0},{"had_liked":false,"id":162389,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1576508106,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576508106","product_id":100040201,"comment_content":"结合王争老师的设计模式课，会理解的更透彻","like_count":0},{"had_liked":false,"id":162362,"user_name":"seg-上海","can_delete":false,"product_type":"c1","uid":1760320,"ip_address":"","ucode":"46BA8DCB06ED5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBllicLBj61g1ibmCeWzLYpQYEteTOtAAAypoIg6CD19ibXQBbM09VsME9Ta1G8ubwk0ibjiacItavibaeg/132","comment_is_top":false,"comment_ctime":1576504303,"is_pvip":false,"replies":[{"id":"61805","content":"谢谢指正，我用的UML工具没有虚线三角😢<br><br>我在第9篇专栏提到，UML用来交流和思考，如果不影响交流，那么UML画法可以简化，也就是所谓的UML方言。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576547664,"ip_address":"","comment_id":162362,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576504303","product_id":100040201,"comment_content":"老师，Dailer 实现 ButtonServer你画的UML图用的是实线三角形图，接口实现应该是虚线三角头","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478027,"discussion_content":"谢谢指正，我用的UML工具没有虚线三角😢\n\n我在第9篇专栏提到，UML用来交流和思考，如果不影响交流，那么UML画法可以简化，也就是所谓的UML方言。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576547664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162324,"user_name":"龙龙first","can_delete":false,"product_type":"c1","uid":1213315,"ip_address":"","ucode":"6F4499DDA57A53","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI22CZTicOPDbur5hn9cMeOLf5ITjOqibrdBicWVb6t6jFcnTt5cJYUmzPhT618dD0erTjiaIXjWm39Iw/132","comment_is_top":false,"comment_ctime":1576500320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576500320","product_id":100040201,"comment_content":"我觉得还是需要业务和技术经验才能知道怎样模块解耦。如果不清楚，就不知道是对button的实现做预留扩展还是对action做预留扩展，因为也有可能后续需求不是点击按钮操作，而是动作识别出发操作","like_count":0}]}